{
  "name" : "1505.03953.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Theory of Formal Synthesis via Inductive Learning",
    "authors" : [ "Susmit Jha", "Sanjit A. Seshia" ],
    "emails" : [ "jhask@utrc.utc.com", "sseshia@eecs.berkeley.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Submitted to: c© S. Jha & S. A. Seshia\nThis work is licensed under the Creative Commons Attribution License."
    }, {
      "heading" : "A Theory of Formal Synthesis via Inductive Learning",
      "text" : "Susmit Jha United Technologies Research Center, Berkeley\njhask@utrc.utc.com\nSanjit A. Seshia EECS, UC Berkeley\nsseshia@eecs.berkeley.edu\nFormal synthesis is the process of generating a program satisfying a high-level formal specification. In recent times, effective formal synthesis methods have been proposed based on the use of inductive learning. We refer to this class of methods that learn programs from examples as formal inductive synthesis. In this paper, we present a theoretical framework for formal inductive synthesis. We discuss how formal inductive synthesis differs from traditional machine learning. We then describe oracle-guided inductive synthesis (OGIS), a framework that captures a family of synthesizers that operate by iteratively querying an oracle. An instance of OGIS that has had much practical impact is counterexample-guided inductive synthesis (CEGIS). We present a theoretical characterization of CEGIS for learning any program that computes a recursive language. In particular, we analyze the relative power of CEGIS variants where the types of counterexamples generated by the oracle varies. We also consider the impact of bounded versus unbounded memory available to the learning algorithm. In the special case where the universe of candidate programs is finite, we relate the speed of convergence to the notion of teaching dimension studied in machine learning theory. Altogether, the results of the paper take a first step towards a theoretical foundation for the emerging field of formal inductive synthesis."
    }, {
      "heading" : "1 Introduction",
      "text" : "The field of formal methods has made enormous strides in recent decades. Formal verification techniques such as model checking [15, 47, 16] and theorem proving (see, e.g. [45, 36, 22]) are used routinely in the computer-aided design of integrated circuits and have been widely applied to find bugs in software, analyze models of embedded systems, and find security vulnerabilities in programs and protocols. At the heart of many of these advances are computational reasoning engines such as Boolean satisfiability (SAT) solvers [41], Binary Decision Diagrams (BDDs) [13], and satisfiability modulo theories (SMT) solvers [8]. Alongside these advances, there has been a growing interest in the synthesis of programs or systems from formal specifications with correctness guarantees. We refer to this area as formal synthesis. Starting with the seminal work of Manna and Waldinger on deductive program synthesis [42] and Pnueli and Rosner on reactive synthesis from temporal logic [46], there have been several advances that have made formal synthesis practical in specific application domains such as robotics, online education, and end-user programming.\nAlgorithmic approaches to formal synthesis range over a wide spectrum, from deductive synthesis to inductive synthesis. In deductive synthesis (e.g., [42]), a program is synthesized by constructively proving a theorem, employing logical inference and constraint solving. On the other hand, inductive synthesis [19, 57, 52] seeks to find a program matching a set of input-output examples. At a high level, it is thus an instance of learning from examples, also termed as inductive inference or machine learning [6, 43]. Many current approaches to synthesis blend induction and deduction in the sense that even as they generalize from examples, deductive procedures are used in the process of generalization (see [51, 34] for a detailed exposition). Even so, the term “inductive synthesis” is typically used to refer to all of them. We will refer to these methods as formal inductive synthesis to place an emphasis on correctness of the synthesized artifact. These synthesizers generalize from examples by searching a\nar X\niv :1\n50 5.\n03 95\n3v 4\n[ cs\n.A I]\n2 1\nM ay\n2 01\n6\nrestricted space of programs. In machine learning, this restricted space is called the concept class, and each element of that space is often called a candidate concept. The concept class is usually specified syntactically. It has been recognized that this syntax guidance, also termed as a structure hypothesis, can be crucial in helping the synthesizer converge quickly to the target concept [55, 51, 1].\nThe fields of formal inductive synthesis and machine learning have the same high-level goal: to develop algorithmic techniques for synthesizing a concept (function, program, or classifier) from observations (examples, queries, etc.). However, there are also important differences in the problem formulations and techniques used in both fields. We identify some of the main differences below:\n1. Concept Classes: In traditional machine learning, the classes of concepts to be synthesized tend to be specialized, such as linear functions or half-spaces [61], convex polytopes [25], neural networks of specific forms [9], Boolean formulas in fixed, bounded syntactic forms [26], and decision trees [48]. However, in formal synthesis, the target concepts are general programs or automata with constraints or finite bounds imposed mainly to ensure tractability of synthesis.\n2. Learning Algorithms: In traditional machine learning, just as concept classes tend to be specialized, so also are the learning algorithms for those classes [43]. In contrast, in formal inductive synthesis, the trend is towards using general-purpose decision procedures such as SAT solvers, SMT solvers, and model checkers that are not specifically designed for inductive learning.\n3. Exact vs. Approximate Learning: In formal inductive synthesis, there is a strong emphasis on exactly learning the target concept; i.e., the learner seeks to find a concept that is consistent with all positive examples but not with any negative example. The labels for examples are typically assumed to be correct. Moreover, the learned concept should satisfy a formal specification. In contrast, the emphasis in traditional machine learning is on techniques that perform approximate learning, where input data can be noisy, some amount of misclassification can be tolerated, there is no formal specification, and the overall goal is to optimize a cost function (e.g., capturing classification error).\n4. Emphasis on Oracle-Guidance: In formal inductive synthesis, there is a big emphasis on learning in the presence of an oracle, which is typically implemented using a general-purpose decision procedure or sometimes even a human user. Moreover, and importantly, the design of this oracle is part of the design of the synthesizer. In contrast, in traditional machine learning, the use of oracles is rare, and instead the learner typically selects examples from a corpus, often drawing examples independently from an underlying probability distribution. Even when oracles are used, they are assumed to be black boxes that the learner has no control over. The oracle is part of the problem definition in machine learning, whereas in formal inductive synthesis, the design of the oracle is part of the solution.\nThe last item, oracle-guidance, is a particularly important difference, and informs the framework we proposed in this paper.\nIn this paper, we take first steps towards a theoretical framework and analysis of formal inductive synthesis. Most instances of inductive synthesis in the literature rely on an oracle that answers different types of queries. In order to capture these various synthesis methods in a unifying framework, we formalize the notion of oracle-guided inductive synthesis (OGIS). While we defer a detailed treatment of OGIS to Section 2, we point out three dimensions in which OGIS techniques differ from each other:\n1. Characteristics of concept class: The concept class for synthesis may have different characteristics depending on the application domain. For instance, the class of programs from which the synthesizer must generate the correct one may be finite, as in the synthesis of bitvector programs [55, 30, 24], or infinite, as in the synthesis of guards for hybrid automata [31, 33]. In the former case, termination is easily guaranteed, but it is not obvious for the case of infinite-size concept classes.\n2. Query types: Different applications may impose differing constraints on the capabilities of the oracle. In some cases, the oracle may provide only positive examples. When verification engines are\nused as oracles, as is typical in formal synthesis, the oracle may provide both positive examples and counterexamples which refute candidate programs. More fine-grained properties of queries are also possible — for instance, an oracle may permit queries that request not just any counterexample, but one that is “minimum” according to some cost function.\n3. Resources available to the learning engine: As noted above, the learning algorithms in formal inductive synthesis tend to be general-purpose decision procedures. Even so, for tractability, certain constraints may be placed on the resources available to the decision procedure, such as time or memory available. For example, one may limit the decision procedure to use a finite amount of memory, such as imposing an upper bound on the number of (learned) clauses for a SAT solver.\nWe conduct a theoretical study of OGIS by examining the impact of variations along the above three dimensions. Our work has a particular focus on counterexample-guided inductive synthesis (CEGIS) [55], a particularly popular and effective instantiation of the OGIS framework. When the concept class is infinite size, termination of CEGIS is not guaranteed. We study the relative strength of different versions of CEGIS, with regards to their termination guarantees. The versions vary based on the type of counterexamples one can obtain from the oracle. We also analyze the impact of finite versus infinite memory available to the learning algorithm to store examples and hypothesized programs/concepts. Finally, when the concept class is finite size, even though termination of CEGIS is guaranteed, the speed of termination can still be an issue. In this case, we draw a connection between the number of counterexamples needed by a CEGIS procedure and the notion of teaching dimension [20] previously introduced in the machine learning literature.\nTo summarize, we make the following specific contributions in this paper: 1. We define the formal inductive synthesis problem and propose a class of solution techniques termed as\nOracle-Guided Inductive Synthesis (OGIS). We illustrate how OGIS generalizes instances of concept learning in machine learning/artificial intelligence as well as synthesis techniques developed using formal methods. We provide examples of synthesis techniques from literature and show how they can be represented as instantiations of OGIS.\n2. We perform a theoretical comparison of different instantiations of the OGIS paradigm in terms of their synthesis power. The synthesis power of an OGIS technique is defined as the class of concepts/programs (from an infinite concept class) that can be synthesized using that technique. We establish the following specific novel theoretical results: • For learning engines that can use unbounded memory, the power of synthesis engines using oracle\nthat provides arbitrary counterexamples or minimal counterexamples is the same. But this is strictly more powerful than using oracle which provides counterexamples which are bounded by the size of the positive examples. • For learning engines that use bounded memory, the power of synthesis engines using arbitrary counterexamples or minimal counterexamples is still the same. The power of synthesis engines using counterexamples bounded by positive examples is not comparable to those using arbitrary/minimal counterexamples. Contrary to intuition, using counterexamples bounded by positive examples allows one to synthesize programs from program classes which cannot be synthesized using arbitrary or minimal counterexamples.\n3. For finite concept classes, we prove the NP hardness of the problem of solving the formal inductive synthesis problem for finite domains for a large class of OGIS techniques. We also show that the teaching dimension [20] of the concept class is a lower bound on the number of counterexamples needed for a CEGIS technique to terminate (on an arbitrary program from that class).\nThe rest of the paper is organized as follows. We first present the Oracle Guided Inductive Synthesis (OGIS) paradigm in Section 2. We discuss related work in Section 3. We present the notation and\ndefinitions used for theoretical analysis in Section 4 followed by the theoretical results and their proofs in Section 5 and Section 6. We summarize our results and discuss open problems in Section 7. A preliminary version of this paper appeared in the SYNT 2014 workshop [32].\n2 Oracle-Guided Inductive Synthesis: OGIS\nWe begin by defining some basic terms and notation. Following standard terminology in the machine learning theory community [4], we define a concept c as a set of examples drawn from a domain of examples E. In other words, c ⊆ E. An example x ∈ E can be viewed as an input-output behavior of a program; for example, a (pre, post) state for a terminating program, or an input-output trace for a reactive program. Thus, in this paper, we ignore syntactic issues in representing concepts and model them in terms of their semantics, as a set of behaviors. The set of all possible concepts is termed the concept class, denoted by C . Thus, C ⊆ 2E. The concept class may either be specified in the original synthesis problem or arise as a result of a structure hypothesis that restricts the space of candidate concepts. Depending on the application domain, E can be finite or infinite. The concept class C can also be finite or infinite. Note that it is possible to place (syntactic) restrictions on concepts so that C is finite even when E is infinite.\nOne key distinguishing characteristic between traditional machine learning and formal inductive synthesis is the presence of an explicit formal specification in the latter. We define a specification Φ as a set of “correct” concepts, i.e., Φ ⊆ C ⊆ 2E. Any example x ∈ E such that there is a concept c ∈ Φ where x ∈ c is called a positive example. Likewise, an example x that is not contained in any c ∈Φ is a negative example. We will write x ` Φ to denote that x is a positive example. An example that is specified to be either positive or negative is termed a labeled example.\nNote that standard practice in formal methods is to define a specification as a set of examples, i.e., Φ ⊆ E. This is consistent with most properties that are trace properties, where Φ represents the set of allowed behaviors — traces, (pre,post) states, etc. — of the program. However, certain practical properties of systems, e.g., certain security policies, are not trace properties (see, e.g., [17]), and therefore we use the more general definition of a specification.\nWe now define what it means for a concept to satisfy Φ. Given a concept c∈C we say that c satisfies Φ iff c ∈ Φ. If we have a complete specification, it means that Φ is a singleton set comprising only a single allowed concept. In general, Φ is likely to be a partial specification that allows for multiple correct concepts.\nWe now present a first definition of the formal inductive synthesis problem:\nGiven a concept class C and a domain of examples E, the formal inductive synthesis problem is to find, using only a subset of examples from E, a target concept c ∈ C that satisfies a specification Φ⊆ C .\nThis definition is reasonable in cases where only elements of E can be accessed by the synthesis engine — the common case in the use of machine learning methods. However, existing formal verification and synthesis methods can use a somewhat richer set of inputs, including Boolean answers to equivalence (verification) queries with respect to the specification Φ, as well as verification queries with respect to other constructed specifications. Moreover, the synthesis engine typically does not directly access or manipulate the specification Φ. In order to formalize this richer source of inputs as well as the indirect access to Φ, we introduce the concept of an oracle interface.\nDefinition 2.1 An oracle interface O is a subset of Q×R where Q is a set of query types, R is a corresponding set of response types, and O defines which pairs of query and response types are semantically well-formed.\nA simple instance of an oracle interface is one with a single query type that returns positive examples from E. In this case, the synthesis problem is to learn a correct program from purely positive examples. The more common case in machine learning (of classifiers) is to have an oracle that supports two kinds of queries, one that returns positive examples and another that returns negative examples. As we will see in Sec. 2.1, there are richer types of queries that are commonly used in formal synthesis. For now, we will leave Q and R as abstract sets.\nImplementations of the oracle interface can be nondeterministic algorithms which exhibit nondeterministic choice in the stream of queries and responses. We define the notion of nondeterministic mapping to represent such algorithms.\nDefinition 2.2 A nondeterministic mapping F : I→ O takes as input i ∈ I and produces an output o ∈ O(i)⊆ O where O(i) is the set of all valid outputs corresponding to input i in F.\nWith this notion of an oracle interface, we now introduce our definition of formal inductive synthesis (FIS):\nDefinition 2.3 Consider a concept class C , a domain of examples E, a specification Φ, and an oracle interface O . The formal inductive synthesis problem is to find a target concept c ∈ C that satisfies Φ, given only O and C . In other words, E and Φ can be accessed only through O .\nThus, an instance of FIS is defined in terms of the tuple 〈C ,E,Φ,O〉. We next introduce a family of solution techniques for the FIS problem. A FIS problem instance defines an oracle interface and a solution technique for that problem instance can access the domain E and the specification Φ only through that interface.\n2.1 OGIS: A family of synthesizers\nOracle-guided inductive synthesis (OGIS) is an approach to solve the formal inductive synthesis problem defined above, encompassing a family of synthesis algorithms.\nAs illustrated in Figure 1, OGIS comprises two key components: an inductive learning engine (also sometimes referred to as a “Learner”) and an oracle (also referred to as a “Teacher”). The interaction between the learner and the oracle is in the form of a dialogue comprising queries and responses. The oracle is defined by the types of queries that it can answer, and the properties of its responses. Synthesis is thus an iterative process: at each step, the learner formulates and sends a query to the oracle, and the oracle sends its response. For formal synthesis, the oracle is also tasked with determining whether\nthe learner has found a correct target concept. Thus, the oracle implicitly or explicitly maintains the specification Φ and can report to the learner when it has terminated with a correct concept.\nWe first formalize the notions of learner and oracle. Let Q be a set of queries of types Q, and R be a set of responses of types R. We allow both Q and R to include a special element ⊥ indicating the absence of a query or response. An element (q,r) ∈Q×R is said to conform to an oracle interface O if q is of type qt , r is of type rt and (qt ,rt)∈O . A valid dialogue pair for an oracle interface O , denoted d, is a query-response pair (q,r) such that q ∈Q, r ∈R and (q,r) conforms to O . The set of valid dialogue pairs for an oracle interface is denoted by D and D∗ denotes the set of valid dialogue sequences — finite sequences of valid dialogue pairs. If δ ∈D∗ is a valid dialogue sequence, δ [i] denotes a sub-sequence of δ of length i and δ (i) denotes the i-th dialogue pair in the sequence.\nDefinition 2.4 An oracle is a nondeterministic mapping O : D∗×Q→R. O is consistent with a given interface O iff given a valid dialogue sequence δ and a query q of type qt , O(δ ,q) is a response of type rt where (qt ,rt) ∈ O . A learner is a nondeterministic mapping L : D∗→ Q×C . L is consistent with a given interface O iff given a valid dialogue sequence δ , L(δ ) = (q,c) where q ∈Q has type qt such that there exists a response type rt s.t. (qt ,rt) ∈ O .\nWe will further assume in this paper that the oracle O is sound, meaning that it gives a correct response to every query it receives. For example, if asked for a positive example, O will not return a negative example instead. This notion is left informal for now, since a formalization requires discussion of specific queries and is orthogonal to the results in our paper.\nGiven the above definitions, we can now define the OGIS approach formally.\nDefinition 2.5 Given a FIS 〈C ,E,Φ,O〉, an oracle-guided inductive synthesis (OGIS) procedure (engine) is a tuple 〈O,L〉, comprising an oracle O : D∗×Q→ R and a learner L : D∗→Q×C , where the oracle and learner are consistent with the given oracle interface O as defined above.\nIn other words, an OGIS engine comprises an oracle O that maps a “dialogue history” and a current query to a response, and a learner L that, given a dialogue history, outputs a hypothesized concept along with a new query. Upon convergence, the final concept output by L is the output of the OGIS procedure.\nWe also formalize the definition of when an OGIS engine solves an FIS problem.\nDefinition 2.6 A dialogue sequence δ ∈D∗ corresponding to OGIS procedure 〈O,L〉 is such that δ (i) is (q,r) where L(δ [i−1]) = (q,c) for some query q ∈Q and some concept c ∈ C , and O(δ [i−1],q) = r.\nThe OGIS procedure 〈O,L〉 is said to solve the FIS problem with dialogue sequence δ if there exists an i such that L(δ [i]) = (q,c), c ∈ C and c satisfies Φ, and for all j > i, L(δ [ j]) = (q′,c), that is, the OGIS procedure converges to a concept c ∈ C that satisfies Φ.\nThe OGIS procedure 〈O,L〉 is said to solve the FIS problem if there exists a dialogue sequence δ with which it solves that problem.\nThe convergence and computational complexity of an OGIS procedure is determined by the nature of the FIS problem along with three factors: (i) the complexity of each invocation of the learner L; (ii) the complexity of each invocation of the oracle O, and (iii) the number of iterations (queries, examples) of the loop before convergence. We term first two factors as learner complexity and oracle complexity, and the third as sample complexity. Sometimes, in OGIS procedures, oracle complexity is ignored, so that we simply count calls to the oracle rather than the time spent in each call.\nAn OGIS procedure is defined by properties of the learner and the oracle. Relevant properties of the learner include (i) its inductive bias that restricts its search to a particular family of concepts and a search strategy over this space, and (ii) resource constraints, such as finite or infinite memory. Relevant properties of the oracle include the types of queries it supports and of the responses it generates. We list\nbelow the common query and response types. In each case, the query type is given in square brackets as a template comprising a query name along with the types of the formal arguments to that query, e.g., examples x or concepts c. An instance of each of these types, that is, a query, is formed by substituting a specific arguments (examples, concepts, etc.) for the formal arguments.\n1. Membership query: [qmem(x)] The learner selects an example x and asks “Is x positive or negative?” The oracle responds with a label for x, indicating whether x is a positive or negative example. 2. Positive witness query: [q+wit] The learner asks the oracle “Give me a positive example”. The oracle responds with an example x `Φ, if one exists, and with ⊥ otherwise. 3. Negative witness query: [q−wit] The learner asks the oracle “Give me a negative example”. The oracle responds with an example x 6`Φ, if one exists, and with ⊥ otherwise.\n4. Counterexample query: [qce(c)] The learner proposes a candidate concept c and asks “Does the oracle have a counterexample demonstrating that c is incorrect?” (i.e., “proof that c 6∈Φ?”). If the oracle can find a counterexample x to c 6∈ Φ, the oracle provides the counterexample. Otherwise, if the oracle cannot find any counterexample, it responds with ⊥. Such a query allows us to accurately model the working of counterexample-guided synthesis techniques such as [35] where the verification problem is undecidable but, if a counterexample is reported, it is a true counterexample.\n5. Correctness query: [qcorr(c)] The learner proposes a candidate concept c and asks “Is c correct?” (i.e., “does it satisfy Φ?”). If so, the oracle responds “YES” (and the synthesis can terminate). If it is not so, the oracle responds “NO” and provides the counterexample. Here x is an example such that either x ∈ c but x 6` Φ, or x 6∈ c and there exists some other concept c′ ∈ Φ containing x. This query is a stronger query than counterexample query as it is guaranteed to provide a counterexample whenever the proposed c is not correct. For the special case of trace properties, the correctness query can take on specific forms. One form is termed the equivalence query, denoted qeq, where the counterexample is in the symmetric difference of the single correct target concept and c. The other is termed the subsumption query, denoted qsub, where the counterexample is a negative example present in c, and is used when Φ is a partial specification admitting several correct concepts. It is important to note that, in the general case, a verification query does not, by itself, specify any label for a counterexample. One may need an additional membership query to generate a label for a counterexample. 6. Crafted Correctness (Verification) query: [qccorr(ĉ,Φ̂)] As noted earlier, oracles used in formal inductive synthesis tend to be general-purpose decision procedures. Thus, they can usually answer not only verification queries with respect to the specification Φ for the overall FIS problem, but also verification queries for specifications crafted by the learner. We refer to this class of queries as crafted correctness/verification queries. The learner asks “Does ĉ satisfy Φ̂?” for a crafted specification Φ̂ and a crafted concept ĉ. As for qcorr one can define as special cases a crafted equivalence query type qce and a crafted subsumption query type qcsub. 7. Distinguishing input query: [qdiff(X,c)] In this query, the learner supplies a finite set of examples X and a concept c, where X ⊆ c, and asks “Does there exist another concept c′ s.t. c 6= c′ and X ⊆ c′?” If so, the oracle responds “YES” and provides both c′ and an example x ∈ c c′. The example x forms a so-called “distinguishing input” that differentiates the two concepts c and c′. If no such c′ exists, the oracle responds “NO”. The distinguishing input query has been found useful in scenarios where it is computationally hard to check correctness using the specification Φ, such as in malware deobfuscation [30].\nThe query/response types qmem, q+wit, q − wit, qce, qcorr, qccorr and qdiff listed above are not meant to be exhaustive. Any subset of such types can form an oracle interface O . We note here that, in the machine\nlearning theory community, there have been thorough studies of query-based learning; see Angluin’s review paper [5] for details. However, in our formalization of OGIS, new query types such as qccorr and qdiff are possible due to the previously-identified key differences with traditional machine learning including the general-purpose nature of oracle implementations and the ability to select or even design the oracle. Moreover, as we will see, our theoretical analysis raises the following questions that are pertinent in the setting of formal synthesis where the learner and oracle are typically implemented as general-purpose decision procedures: • Oracle design: When multiple valid responses can be made to a query, which ones are better, in terms\nof convergence to a correct concept (convergence and complexity)? • Learner design: How do resource constraints on the learner or its choice of search strategy affect\nconvergence to a correct concept?\n2.2 Examples of OGIS\nWe now take three example synthesis techniques previously presented in literature and illustrate how they instantiate the OGIS paradigm. These techniques mainly differ in the oracle interface that they employ.\nExample 2.1 Query-based learning of automata [3]: Angluin’s classic work on learning deterministic finite automata (DFAs) from membership and equivalence queries [3] is an instance of OGIS with O = {qmem,qeq}. The learner is a custom-designed algorithm called L∗, whereas the oracle is treated as a black box that answers the membership and equivalence queries; in particular, no assumptions are made about the form of counterexamples. Several variants of L∗ have found use in the formal verification literature; see [18] for more information.\nExample 2.2 Counterexample-guided inductive synthesis (CEGIS) [55]: CEGIS was originally proposed as an algorithmic method for program synthesis where the specification is given as a reference program and the concept class is defined using a partial program, also referred to as a “sketch” [55]. It has since proved very versatile, also applying to partial specifications (see, e.g., [35]) and other ways of providing syntax guidance; see [1] for a more detailed treatment. In CEGIS, the learner (synthesizer) interacts with a “verifier’ that can take in a candidate program and a specification, and try to find a counterexample showing that the candidate program does not satisfy the specification. In CEGIS, the learner is typically implemented on top of a general-purpose decision procedure such as a SAT solver, SMT solver, or model checker. The oracle (verifier) is also implemented similarly. In addition to a counterexample-generating oracle, many instances of CEGIS also randomly sample positive examples (see Sec. 5.4 of [55] and Fig. 3 of [35]). Moreover, the counterexample-generating oracle is not required to be a sound verifier that can declare correctness (e.g., see [35]). Thus, we model CEGIS as an instance of OGIS with O = {q+wit,qce}.\nAs noted earlier, if the verifier is sound (can prove correctness of candidate concept), then qce can be substituted by qcorr. Moreover, general-purpose verifiers typically support not only correctness queries with respect to the original specification, but also crafted correctness queries, as well as membership queries, which are special cases of the verification problem where the specification is checked on a single input/output behavior. We term an instantiation of CEGIS with these additional query types as generalized CEGIS, which has an oracle interface O = {q+wit,qcorr,qccorr,qmem}. We will restrict our attention in this paper to the standard CEGIS.\nExample 2.3 Oracle-guided program synthesis using distinguishing inputs [30]: Our third example is an approach to program synthesis that uses distinguishing inputs when a complete specification is either unavailable or it is expensive to verify a candidate program against its specification [30]. In this case, distinguishing input queries, combined with witness and membership queries,\nprovide a way to quickly generate a corpus of examples that rule out incorrect programs. When there is only a single program consistent with these examples, only then does a correctness query need to be made to ascertain its correctness. Thus, the oracle interface O = {q+wit,qdiff,qmem,qcorr} with qcorr being used sparingly. The learner and the oracle are implemented using SMT solving."
    }, {
      "heading" : "2.3 Counterexample-Guided Inductive Synthesis (CEGIS)",
      "text" : "Consider the CEGIS instantiation of the OGIS framework. In this paper, we consider a general setting where the concept class C is the set of programs corresponding to the set of recursive (decidable) languages; thus, it is infinite. The domain E of examples is also infinite. We choose such an expressive concept class and domain because we want to compare how the power of CEGIS varies as we vary the oracle and learner. More specifically, we vary the nature of responses from the oracle to correctness and witness queries, and the memory available to the learner.\nFor the oracle, we consider four different types of counterexamples that the oracle can provide in response to a correctness query. Recall that in formal synthesis, oracles are general-purpose verifiers or decision procedures whose internal heuristics may determine the type of counterexample obtained. Each type describes a different oracle and hence, a different flavor of CEGIS. Our goal is to compare these synthesis techniques and establish whether one type of counterexample allows the synthesizer to successfully learn more programs than the other. The four kinds of counterexamples considered in this paper are as follows:\n1. Arbitrary counterexamples: This is the “standard” CEGIS technique (denoted CEGIS) that makes no assumptions on the form of the counterexample obtained from the oracle. Note however that our focus is on an infinite concept class, whereas most practical instantiations of CEGIS have focused on finite concept classes; thus, convergence is no longer guaranteed in our setting. This version of CEGIS serves as the baseline for comparison against other synthesis techniques. 2. Minimal counterexamples: We require that the verification oracle provide a counterexample from E which is minimal for a given ordering over E. The size of examples can be used for ordering. The exact definition of “size” is left abstract and can be defined suitably in different contexts. The intuition is to use counterexamples of smaller size which eliminates more candidate concepts. Significant effort has been made on improving validation engines to produce counterexamples which aid debugging by localizing the error [44, 14]. The use of counterexamples in CEGIS conceptually is an iterative repair process and hence, it is natural to extend successful error localization and debugging techniques to inductive synthesis.\n3. Constant-bounded counterexamples: Here the “size” of the counterexamples produced by the verification oracle is bounded by a constant. This is motivated by the use of bounds in formal verification such as bounded model checking [10] and bug-finding in concurrent programs [7] using bounds on context switches.\n4. Positive-bounded counterexamples: Here the counterexample produced by the validation engine must be smaller than a previously seen positive example. This is motivated from the industrial practice of validation by simulation where the system is often simulated to a finite length to discover bugs. The length of simulation often depends on the traces which illustrate known positive behaviors. It is expected that errors will show up if the system is simulated up to the length of the largest positive trace. Mutation-based software testing and symbolic execution also has a similar flavor, where a sample correct execution is mutated to find bugs.\nIn addition to the above variations to the oracle, we also consider two kinds of learners that differ based on their ability to store examples and counterexamples:\n1. Infinite memory: In the typical setting of CEGIS, the learner is not assumed to have any memory bound, allowing the learner to store as many examples and counterexamples as needed. Note that, for an infinite domain, this set of examples can grow unbounded.\n2. Finite memory: A more practical setting is one where the learner only has a finite amount of memory, and therefore can only store a finite representation of examples or hypothesized programs. This notion of finite memory is similar to that used classically for language learning from examples [62]. We give the first theoretical results on the power of CEGIS and its variants, for general program synthesis, in this restricted setting.\nWe introduce notation to refer to these variants in a more compact manner. The synthesis engine using arbitrary counterexamples and with infinite memory is denoted as TCEGIS. The variant of the synthesis engine which is restricted to use finite memory is referred to as Tcegis. Similarly, the synthesis engine using minimal counterexamples and infinite memory is called minimal counterexample guided inductive synthesis (TMINCEGIS). The variant of this engine using finite memory is referred to as Tmincegis. The synthesis engine using counterexamples which are smaller than a fixed constant is called a constant bounded counterexample guided inductive synthesis, and is denoted as TCBCEGIS if the memory is not finite and Tcbcegis if the memory is finite. The synthesis engine using counterexamples which are smaller than the largest positive examples is called positive-history bounded counterexample guided inductive synthesis, and is denoted as TPBCEGIS if the memory is not finite and Tpbcegis if the memory is finite.\nFor the class of programs corresponding to the set of recursive languages, our focus is on learning in the limit, that is, whether the synthesis technique converges to the correct program or not (see Definition 4.14 in Sec. 4 for a formal definition). This question is non-trivial since our concept class is not finite. In this paper, we do not discuss computational complexity of synthesis, and the impact of different types of counterexamples on the speed of convergence. Investigating the computational complexity for concept classes for which synthesis is guaranteed to terminate is left as a topic for future research.\nWe also present an initial complexity analysis for OGIS in case of finite concept classes. The decidability question for finite class of programs is trivial since convergence is guaranteed as long as the queries provide new examples or some new information about the target program. But the speed at which the synthesis approach converges remains relevant even for finite class of programs. We show that the complexity of these techniques is related to well-studied notions in learning theory such as the Vapnik-Chervonenkis dimension [12] and the teaching dimension [20]."
    }, {
      "heading" : "3 Background and Related Work",
      "text" : "In this section, we contrast the contributions of this paper with the most closely related work and also provide some relevant background."
    }, {
      "heading" : "3.1 Formal Synthesis",
      "text" : "The past decade has seen an explosion of work in program synthesis (e.g. [54, 55, 30, 56, 37, 58]. Moreover, there has been a realization that many of the trickiest steps in formal verification involve synthesis of artifacts such as inductive invariants, ranking functions, assumptions, etc. [51, 23]. Most of these efforts have focused on solution techniques for specific synthesis problems. There are two main unifying characteristics across most of these efforts: (i) syntactic restrictions on the space of programs/artifacts to be synthesized in the form of templates, sketches, component libraries, etc., and (ii) the use of inductive synthesis from examples. The recent work on syntax-guided synthesis (SyGuS) [1] is an attempt to capture these disparate efforts in a common theoretical formalism. While SyGuS is about formalizing the\nsynthesis problem, the present paper focuses on formalizing common ideas in the solution techniques. Specifically, we present OGIS as a unifying formalism for different solution techniques, along with a theoretical analysis of different variants of CEGIS, the most common instantiation of OGIS. In this sense, it is complementary to the SyGuS effort."
    }, {
      "heading" : "3.2 Machine Learning Theory",
      "text" : "Another related area is the field of machine learning, particularly the theoretical literature. In Section 1, we outlined some of the key differences between the fields of formal inductive synthesis and that of machine learning. Here we focus on the sub-field of query-based learning that is the closest to the OGIS framework. The reader is referred to Angluin’s excellent papers on the topic for more background [4, 5].\nA major difference between the query-based learning literature and our work is in the treatment of oracles, specifically, how much control one has over the oracle that answers queries. In query-based learning, the oracles are treated as black boxes that answer particular types of queries and only need to provide one valid response to a query. Moreover, it is typical in the query-based learning literature for the oracle to be specified a priori as part of the problem formulation. In contrast, in our OGIS framework, designing a synthesis procedure involves also designing or selecting an oracle. The second major difference is that the query-based learning literature focuses on specific concept classes and proves convergence and complexity results for those classes. In contrast, our work proves results that are generally applicable to programs corresponding to recursive languages."
    }, {
      "heading" : "3.3 Learning of Formal Languages",
      "text" : "The problem of learning a formal language from examples is a classic one. We cover here some relevant background material.\nGold [19] considered the problem of learning formal languages from examples. Similar techniques have been studied elsewhere in literature [29, 63, 11, 2]. The examples are provided to learner as an infinite stream. The learner is assumed to have unbounded memory and can store all the examples. This model is unrealistic in a practical setting but provides useful theoretical understanding of inductive learning of formal languages. Gold defined a class of languages to be identifiable in the limit if there is a learning procedure which identifies the grammar of the target language from the class of languages using a stream of input strings. The languages learnt using only positive examples were called text learnable and the languages which require both positive and negative examples were termed informant learnable. None of the standard classes of formal languages are identifiable in the limit from text, that is, from only positive examples [19]. This includes regular languages, context-free languages and context-sensitive languages.\nA detailed survey of classical results in learning from positive examples is presented by Lange et al. [39]. The results summarize learning power with different limitations such as the inputs having certain noise, that is, a string not in the target language might be provided as a positive example with a small probability. Learning using positive as well as negative examples has also been well-studied in literature. A detailed survey is presented in [27] and [38]. Lange and Zilles [40] relate Angluin-style query-based learning with Gold-style learning. They establish that any query learner using superset queries can be simulated by a Gold-style learner receiving only positive data. But there are concepts learnable using subset queries but not Gold-style learnable from positive data only. Learning with equivalence queries coincides with Gold’s model of limit learning from positive and negative examples, while learning with membership queries equals finite learning from positive data and negative data. In contrast to this line of work, we present a general framework OGIS to learn programs or languages and Angluin-style or Gold-\nstyle approaches can be instantiated in this framework. Our theoretical analysis focusses on varying the oracle and the nature of counterexample produced by it to examine the impact of using different types of counterexamples obtainable from verification or testing tools."
    }, {
      "heading" : "3.4 Learning vs. Teaching",
      "text" : "We also study the complexity of synthesizing programs from a finite class of programs. This part of our work is related to previous work on the complexity of teaching in exact learning of concepts by Goldman and Kearns [20]. Informally, the teaching dimension of a concept class is the minimum number of instances a teacher must reveal to uniquely identify any target concept from the class. Exact bounds on teaching dimensions for specific concept classes such as orthogonal rectangles, monotonic decision trees, monomials, binary relations and total orders have been previously presented in literature [20, 21]. Shinohara et al. [53] also introduced a notion of teachability in which a concept class is teachable by examples if there exists a polynomial size sample under which all consistent learners will exactly identify the target concept. Salzberg et al. [50] also consider a model of learning with a helpful teacher. Their model requires that any teacher using a particular algorithm such as the nearest-neighbor algorithm learns the target concept. This work assumes that the teacher knows the algorithm used by the learner. We do not make any assumption on the inductive learning technique used by the OGIS synthesis engine. Our goal is to obtain bounds on the number of examples that need to be provided by the oracle to synthesize the correct program by relating our framework to the literature on teaching."
    }, {
      "heading" : "4 Theoretical Analysis of CEGIS: Preliminaries",
      "text" : "Our presentation of formal inductive synthesis and OGIS so far has not used a particular representation of a concept class or specification. In this section, we begin our theoretical formalization of the counterexample-guided inductive synthesis (CEGIS) technique, for which such a choice is necessary. We precisely define the formal inductive synthesis problem for concepts that correspond to recursive languages. We restrict our attention to the case when the specification is partial and is a trace property — i.e., the specification is defined by a single formal language. This assumption, which is the typical case in formal verification and synthesis, also simplifies notation and proofs. Most of our results extend to the case of more general specifications; we will make suitable additional remarks about the general case where needed. For ease of reference, the major definitions and frequently used notation are summarized in Table 1."
    }, {
      "heading" : "4.1 Basic Notation",
      "text" : "We use N to denote the set of natural numbers. Ni ⊂N denotes a subset of natural numbers Ni = {n|n < i}. Consider a set S ⊂ N. min(S) denotes the minimal element in S. The union of the sets is denoted by ∪ and the intersection of the sets is denoted by ∩. S1 \\S2 denotes set minus operation with the resultant set containing all elements in S1 and not in S2.\nWe denote the set N∪{⊥} as N⊥. A sequence σ is a mapping from N to N⊥. We denote a prefix of length k of a sequence by σ [k]. So, σ [k] of length k is a mapping from Nk to N⊥. σ [0] is an empty sequence also denoted by σ0 for brevity. The set of natural numbers appearing in the sequence σ [i] is defined using a function SAMPLE, where SAMPLE(σ [i]) = range(σ [i])−{⊥}. The set of sequences is denoted by Σ. Languages and Programs: We also use standard definitions from computability theory which relate languages and programs [49]. A set L of natural numbers is called a computable or recursive language if\nthere is a program, that is, a computable, total function P such that for any natural number n,\nP(n) = 1 if n ∈ L and P(n) = 0 if n 6∈ L\nWe say that P identifies the language L. Let Lmap(P) denote the language L identified by the program P. The mapping Lmap is not necessarily one-to-one and hence, syntactically different programs might identify the same language. In formal synthesis, we do not distinguish between syntactically different programs that satisfy the specification. Additionally, in this paper, we restrict our discussion to recursive languages because it includes many interesting and natural classes of languages that correspond to programs and functions of various kinds, including regular, context free, context sensitive, and pattern languages.\nGiven a sequence of non-empty languages L = L0,L1,L2, . . ., L is said to be an indexed family of languages if and only if for all languages Li, there exists a recursive function TEMPLATE such that TEMPLATE( j,n) = P(n) and Lmap(P) = Li for some j. Practical applications of program synthesis often consider a family of candidate programs which contain syntactically different programs that are semantically equivalent, that is, they have the same set of behaviors. Formally, in practice program synthesis techniques permit picking j such that TEMPLATE( j,n) = P(n) and Lmap(P) = Li for all j ∈ I j where the set I j represents the syntactically different but semantically equivalent programs that produce output 1 on an input if and only if the input natural number belongs to Li. Intuitively, a function TEMPLATE defines an encoding of the space of candidate programs similar to encodings proposed in the literature such as those on program sketching [55] and component interconnection encoding [30]. In the case of formal synthesis where we have a specification Φ, we are only interested in finding a single program satisfying Φ. In the general case, Φ comprises a set of allowed languages, and the task of synthesis is to find a program identifying some element of this set. In the case of partial specifications that are trace properties, Φ comprises subsets of a single target language Lc. Any program Pc identifying some subset of Lc is a valid solution, and usually positive examples are used to rule out programs identifying “uninteresting” subsets of Lc. Thus, going forward, we will define the task of program synthesis as one of identifying the corresponding correct language Lc. Ordering of elements in the languages: A language corresponds to a set of program behaviors. We model this set in an abstract manner, only assuming the presence of a total order over this set, without prescribing any specific ordering relation. Thus, languages are modeled as sets of natural numbers. While such an assumption might seem restrictive, we argue that this is not the case in the setting of CEGIS, where the ordering relation is used specifically to model the oracle’s preference for returning specific kinds of counterexamples. For example, consider the case where elements of a language are input/output traces. We can construct a totally ordered set of all possible input/output traces using the length of the trace as the primary ordering metric and the lexicographic ordering as the secondary ordering metric. Thus, an oracle producing smallest counterexample would produce an unique trace which is shortest in length and is lexicographically the smallest. The exact choice of ordering is orthogonal to results presented in our paper, and using the natural numbers allows us to greatly simplify notation."
    }, {
      "heading" : "4.2 CEGIS Definitions",
      "text" : "We now specialize the definitions from Sec. 2 for the case of CEGIS. An indexed family of languages (also called a language class) L defines the concept class C for synthesis. The domain E for synthesis is the set of natural numbers N and the examples are i ∈ N. Recall that we restrict our attention to the special case where the specification Φ is captured by a single target language, i.e., Lc comprising all permitted program behaviors. Therefore, the formal inductive synthesis (FIS) problem defined in Section 2 (Definition 2.3) can be restricted for this setting as follows:\nDefinition 4.1 Given a language class L , a domain of examples N, the specification Φ defined by a target language Lc, and an oracle interface O , the problem of formal inductive synthesis of languages (and the associated programs) is to identify a language in Φ using only the oracle interface O .\nCounterexample-guided inductive synthesis (CEGIS) is a solution to the problem of formal inductive synthesis of languages where the oracle interface O is defined as follows.\nDefinition 4.2 A counterexample-guided inductive synthesis (CEGIS) oracle interface is O = Q×R where Q = {q+wit,qce(L)} with L ∈L , R = N⊥, and the specification Φ is defined as subsets of a target language Lc. The positive witness query q+wit returns a positive example i ∈ Lc, and the counterexample query qce takes as argument a candidate language L and either returns a counterexample i ∈ L \\ Lc showing that the candidate language L is incorrect or returns ⊥ if it cannot find a counterexample. 1\nThe sequence τ of responses of the positive witness q+wit query is called the transcript, and the sequence cex of the responses to the counterexample queries qce is called the counterexample sequence. The positive witness queries can be answered by the oracle sampling examples from the target language. Our work uses the standard model for language learning in the limit [19], where the learner has access to an infinite stream of positive examples from the target language. This is also realistic in practical CEGIS settings for infinite concept classes (e.g. [35]) where more behaviors can be sampled over time. We formalize these terms below.\nDefinition 4.3 A transcript τ for a specification language Lc is a sequence with SAMPLE(τ) = Lc. τ[i] denotes the prefix of the transcript τ of length i. τ(i) denotes the i-th element of the transcript.\n1CEGIS techniques in literature [55, 35] initiate search for correct program using positive examples and use specification to obtain positive examples corresponding to counterexamples.\nDefinition 4.4 A counterexample sequence cex for a specification language Lc from a counterexample query qce is a sequence with cex(i) = qce(Lcandi), where cex[i] denotes the prefix of the counterexample sequence cex of length i, cex(i) denotes the i-th element of the counterexample sequence, and Lcandi is the argument of the i-th invocation of the query qce.\nWe now define the verification oracle in CEGIS that produces arbitrary counterexamples, as well as its three other variants which generate particular kinds of counterexamples.\nDefinition 4.5 A verifier CHECKL for language L is a nondeterministic mapping from L to N⊥ such that CHECKL(Li) =⊥ if and only if Li ⊆ L, and CHECKL(Li) ∈ Li \\L otherwise.\nRemark: For more general specifications Φ that are a set of languages, the definition of CHECKL changes in a natural way: it returns ⊥ if and only if Li ∈ Φ and otherwise returns an example j that is in the intersection of the symmetric differences of each language L ∈Φ and the candidate language Li.\nWe define a minimal counterexample generating verifier below. The counterexamples are minimal with respect to the total ordering on the domain of examples.\nDefinition 4.6 A verifier MINCHECKL for a language L is a nondeterministic mapping from L to N⊥ such that MINCHECKL(Li) =⊥ if and only if Li ⊆ L, and MINCHECKL(Li) = min(Li \\L) otherwise.\nNext, we consider another variant of counterexamples, namely (constant) bounded counterexamples. Bounded model-checking [10] returns a counterexample trace for an incorrect design if it can find a counterexample of length less than the specified constant bound. It fails to find a counterexample for an incorrect design if no counterexample exists with length less than the given bound. Verification of concurrent programs by bounding the number of context switches [7] is another example of the bounded verification technique. This motivates the definition of a verifier which returns counterexamples bounded by a constant B.\nDefinition 4.7 A verifier CBCHECKB,L is a nondeterministic mapping from L to N⊥ such that CBCHECKB,L(Li)= m where m ∈ Li \\L∧m < B for the given bound B, and CBCHECKB,L(Li) =⊥ if such m does not exist.\nThe last variant of counterexamples is positive bounded counterexamples. The verifier for generating positive bounded counterexample is also provided with the transcript seen so far by the synthesis engine. The verifier generates a counterexample smaller than the largest positive example in the transcript. If there is no counterexample smaller than the largest positive example in the transcript, then the verifier does not return any counterexample. This is motivated by the practice of mutating correct traces to find bugs in programs and designs. The counterexamples in these techniques are bounded by the size of positive examples (traces) seen so far.2\nDefinition 4.8 A verifier PBCHECKL is a nondeterministic mapping from L ×Σ to N⊥ such that PBCHECKL(Li,τ[n])= m where m ∈ Li \\L∧m < τ( j) for some j ≤ n, and PBCHECKL(Li,τ[n]) =⊥ if such m does not exist.\nWe now define the oracle for counterexample guided inductive synthesis. We drop the queries in dialogue since there are only two kind of queries and instead only use the sequence of responses: transcript τ and the counterexample sequence cex. The oracle also receives as input the current candidate language Lcand to be used as the argument of the qcorr query. The overall response of the oracle is a pair of elements in N⊥.\n2Note that we can extend this definition to include counterexamples of size bounded by that of the largest positive example seen so far plus a constant. The proof arguments given in Sec. 5 continue to work with only minor modifications.\nDefinition 4.9 An oracle O for counterexample-guided inductive synthesis (CEGIS oracle) is a nondeterministic mapping Σ×Σ×L →N⊥×N⊥ such that O(τ[i−1],cex[i−1],Lcand) = (τ(i),cex(i)) where τ(i) is the nondeterministic response to positive witness query q+wit and cex(i) is the nondeterministic response to counterexample query qce(Lcand). The oracle can use any of the four verifiers presented earlier to generate the counterexamples. An oracle using CHECKL is called Ocegis, one using MINCHECKL is called Omincegis, one using PBCHECKL is called Opbcegis and one using CBCHECKB,L is called Ocbcegis.\nWe make the following reasonable assumption on the oracle. The oracle is assumed to be consistent: it does not provide the same example both as a positive example (via a positive witness query) and as a negative example (as a counterexample). Second, the oracle is assumed to be non-redundant: it does not repeat any positive examples that it may have previously provided to the learner; for a finite target language, once the oracle exhausts all positive examples, it will return ⊥.\nThe learner is simplified to be a mapping from the sequence of responses to a candidate program.\nDefinition 4.10 An infinite memory learner LEARN is a function Σ×Σ→L such that LEARN(τ[n],cex[n])= L where L includes all positive examples in τ[n] and excludes all examples in cex[n].3 LEARN(σ0,σ0) is a predefined constant representing an initial guess L0 of the language, which, for example, could be N.\nWe now define a finite memory learner which cannot take the unbounded sequence of responses as argument. The finite memory learner instead uses the previous candidate program to summarize the response sequence. We assume that languages are encoded in terms of a finite representation (index of the language since the language class is an indexed family of languages and we assume that every index needs unit memory) such as a program that identifies that language. Such an iterative learner only needs finite memory.\nDefinition 4.11 A finite memory learner learn is a recursive function L ×N⊥×N⊥ →L such that for all n ≥ 0, learn(Ln,τ(n),cex(n)) = Ln+1, where Ln+1 includes all positive examples in τ[n] and excludes all examples in cex[n]. We define L0 = LEARN(σ0,σ0) to be the initial guess of the language, which for example, could be N. For ease of presentation, we omit the finite memory available to the learner in its functional representation above. The learner can store additional finite information.\nThe synthesis engine using infinite memory can now be defined as follows.\nDefinition 4.12 An infinite memory CEGIS engine TCEGIS is a pair 〈Ocegis,LEARN〉 comprising a CEGIS oracle Ocegis and an infinite memory learner LEARN, where, there exists τ and cex such that for all i≥ 0, Ocegis(τ[i],cex[i],Li) = (τ(i+ 1),cex(i+ 1)) and Li = LEARN(τ[i],cex[i]). Since the oracle Ocegis is nondeterministic, TCEGIS can have multiple transcripts τ and counterexample sequences cex.\nA synthesis engine with finite memory cannot store unbounded infinite transcripts. So, the bounded memory cegis synthesis engine Tcegis uses a finite memory learner learn.\nDefinition 4.13 A finite memory cegis engine Tcegis is a tuple 〈Ocegis,learn〉 comprising a CEGIS oracle Ocegis and a finite memory learner learn where, there exists τ and cex such that for all i ≥ 0, Ocegis(τ[i],cex[i],Li+1) = (τ(i+ 1),cex(i+ 1)) and Li = learn(Li,τ(i),cex(i)). Since the oracle Ocegis is nondeterministic, TCEGIS can have multiple transcripts τ and counterexample sequences cex.\nA pair (τ,cex) is a valid transcript and counterexample sequence for Tcegis if the above definitions hold for that pair. We denote this by (τ,cex) |= Tcegis. Similar to Definition 2.5, the convergence of the counterexample-guided synthesis engine is defined as follows:\n3This holds due to the specialization of Φ to a partial specification, and as a trace property. For general Φ, the learner need not exclude all counterexamples.\nDefinition 4.14 We say that Tcegis : 〈Ocegis,learn〉 identifies L, that is, it converges to L, written Tcegis→ L if and only if there exists k such that for all n ≥ k, learn(Ln,τ[n],cex[n]) = L for all valid transcripts τ and counterexample sequences cex of Tcegis. This notion of convergence is standard in language learning in the limit [19]. For the case of general specifications Φ, as given in Definition 2.5, the synthesizer must converge to some language in Φ. As per Definition 4.3, a transcript is an infinite sequence of examples which contains all the elements in the target language. Definition 4.14 requires the synthesis engine to converge to the correct language after consuming a finite part of the transcript and counterexample sequence. This notion of convergence is standard in the literature on language learning in the limit [19] 4.\nWe extend Definition 4.14 to general specifications Φ as follows: Tcegis identifies a specification Φ if it identifies some language in Φ. As noted before, this section focuses on the case of a partial specification that is a trace property. In this case, Φ comprises all subsets of a target language Lc. Since Definition 4.3 defines a transcript as comprising all positive examples in Lc and Definition 4.14 requires convergence for all possible transcripts, the two notions of identifying Φ and identifying Lc coincide. We therefore focus in Sec. 5 purely on language identification with the observation that our results carry over to the case of “specification identification”.\nDefinition 4.15 Tcegis = 〈Ocegis,learn〉 identifies a language family L if and only if Tcegis identifies every language L ∈L .\nThe above definition extends to families of specifications in an exactly analogous manner. We now define the set of language families that can be identified by the inductive synthesis engines as cegis formally below.\nDefinition 4.16 cegis= {L | ∃learn ∀Ocegis . the engine Tcegis = 〈Ocegis,learn〉 identifies L }.\nThe convergence of synthesis engine to the correct language, identification condition for a language, and language family identified by a synthesis engine are defined similarly as listed in Table 2.\nThe constant bounded counterexample-guided inductive synthesis oracle Ocbcegis uses the verifier CBCHECKB,L. It takes an additional parameter B which is the constant bound on the maximum size of a counterexample. If the verifier cannot find a counterexample below this bound, it will respond with ⊥. Definition 4.17 Given a bound B, Tcbcegis = 〈Ocbcegis,learn〉 where Ocbcegis uses CBCHECKB,L, we say that Tcbcegis identifies a language family L if and only if Tcbcegis identifies every language L ∈L .\nNote that the values of B for which a language family L is identifiable can be different for different L . The overall class of language families identifiable using Ocbcegis oracles can thus be defined as follows:\nDefinition 4.18 cbcegis = {L | ∃B ∃learn . ∀Ocbcegis s.t.Ocbcegis uses CBCHECKB,L . the engine Tcegis = 〈Ocbcegis,learn〉 identifies L }\n4In this framework, a synthesis engine is only required to converge to the correct concept without requiring it to recognize it has converged and terminate. For a finite concept or language, termination can be trivially guaranteed when the oracle is assumed to be non-redundant and does not repeat examples."
    }, {
      "heading" : "5 Theoretical Analysis of CEGIS: Results",
      "text" : "In this section, we present the theoretical results when the class of languages (programs) is infinite. We consider two axes of variation. We first consider the case in which the inductive learning technique has finite memory in Section 5.1, and then the case in which it has infinite memory in Section 5.2. For both cases, we consider the four kinds of counterexamples mentioned in Section 1 and Section 4; namely, arbitrary counterexamples, minimal counterexamples, constant bounded counterexamples and positive bounded counterexamples.\nFor simplicity, our proofs focus on the case of partial specifications that are trace properties, the common case in formal verification and synthesis. Thus, Φ comprises subsets of a target specification language Lc. However, many of the results given here extend to the case of general specifications. Most of our theorems show differences between language classes for CEGIS variants — i.e., theorems showing that there is a specification on which one variant of CEGIS converges while the other does not — and for these, it suffices to show such a difference for the more restricted class of partial specifications. The results also extend to the case of equality between language classes (e.g., Theorem 5.1) in certain cases; we make suitable remarks alongside."
    }, {
      "heading" : "5.1 Finite Memory Inductive Synthesis",
      "text" : "We investigate the four language classes cegis,mincegis,cbcegis and pbcegis identified by the synthesis engines Tcegis, Tmincegis, Tcbcegis and Tpbcegis and establish relations between them. We show that cbcegis⊂ mincegis= cegis, pbcegis 6⊆ cegis and pbcegis 6⊇ cegis."
    }, {
      "heading" : "5.1.1 Minimal vs. Arbitrary Counterexamples",
      "text" : "We begin by showing that replacing a deductive verification engine which returns arbitrary counterexamples with a deductive verification engine which returns minimal counterexamples does not change the power of counterexample-guided inductive synthesis. The result is summarized in Theorem 5.1.\nTheorem 5.1 The power of synthesis techniques using arbitrary counterexamples and those using minimal counterexamples are equivalent, that is, mincegis= cegis.\nProof MINCHECKL is a special case of CHECKL in that a minimal counterexample reported by MINCHECKL can be treated as arbitrary counterexample to simulate Tcegis using Tmincegis. Thus, cegis⊆ mincegis.\nThe more interesting case to prove is mincegis⊆ cegis. For a language L, let mincegis converge to the correct language L on transcript τ . We show that Tcegis can simulate Tmincegis and also converge to L on transcript τ . The proof idea is to show that a finite learner can simulate MINCHECKL by making a finite number of calls to CHECKL. Therefore, the learner sees the same counterexample sequence with CHECKL as with MINCHECKL and thus converges to the same language in both cases.\nConsider an arbitrary step of the dialogue between learner and verifier when a counterexample is returned. Let the arbitrary counterexample returned by the verifier for a candidate language Li be c, that is CHECKL(Li) = c. Thus, c is an upper bound on the minimal counterexample returned by MINCHECKL. The latter can be recovered using the following characterization:\nMINCHECKL(Li) = minimum j such that CHECKL({ j}) is not ⊥ for 0≤ j ≤ CHECKL(Li)\nThe learner can thus perform at most c queries to CHECKL to compute the minimal counterexample that would be returned by MINCHECKL. In case of totally ordered set (such as N), we could do this more efficiently using binary search. At each stage of the iteration, the learner needs to store the smallest\ncounterexample returned so far. Thus, the work performed by the learner in each iteration to craft queries to CHECKL can be done with finite memory. MINCHECKL(Li) can be computed using finite memory and using at most c = CHECKL(Li) calls of CHECKL.\nThus, Tcegis can simulate Tmincegis by finding the minimal counterexample at each step using the verifier CHECK iteratively as described above. This implies that mincegis= cegis.\nThus, mincegis successfully converges to the correct language if and only if cegis also successfully converges to the correct language. So, there is no increase or decrease in power of synthesis by using the deductive verifier that provides minimal counterexamples.\nRemark: The above result (and its analog in Sec. 5.2) also holds in the case of general specifications when CEGIS is replaced by Generalized CEGIS. In particular, if either crafted correctness (qccorr) or membership queries (qmem) are introduced, then it is easy to show that cegis can simulate mincegis by mimicking each step of mincegis by recovering the same counterexample it used with suitable qmem or qccorr queries. In this case, cegis can converge to every language that mincegis converges to, and hence identifies the same class of specifications."
    }, {
      "heading" : "5.1.2 Bounded vs. Arbitrary Counterexamples",
      "text" : "We next investigate cbcegis and compare its relative synthesis power to cegis. As intuitively expected, cbcegis is strictly less powerful than cegis as summarized in Theorem 5.2 which formalizes the intuition.\nTheorem 5.2 The power of synthesis techniques using bounded counterexamples is less than those using counterexamples, that is, cbcegis⊂ cegis. Proof Since bounded counterexample is also a counterexample, we can easily simulate a bounded verifier CBCHECK using a CHECK by ignoring counterexamples from CHECK if they are larger than a specified bound B which is a fixed parameter and can be stored in the finite memory of the inductive learner. Thus, cbcegis⊆ cegis.\nWe now describe a language class for which the corresponding languages cannot be identified using bounded counterexamples. Language Family 1 : Lnotcb = {Li|i > B and Li = {n|n ∈ N∧n > i}} where B is a constant bound. We provide this by contradiction. Let us assume that there is a Tcbcegis that can identify languages in Lnotcb. Let the verifier used by Tcbcegis be CBCHECK and B′ be the constant bound on the counterexamples produced by CBCHECK. Let us consider the languages Lnotcb f ail = {L j|L j ∈Lnotcb ∧ j > B′} ⊆Lnotcb, the set of counterexamples that can be produced by CBCHECK is the same for these languages (that is, {n|n ∈ N∧ n ≤ B′}) since the counterexamples produced by CBCHECK cannot be larger than B′. Thus, a synthesis engine Tcbcegis cannot distinguish between languages in Lnotcb f ail which is a contradiction. Thus, Tcbcegis cannot identify all languages in Lnotcb. Tcegis can identify all languages in Lnotcb using a simple learner which proposes Li as the hypothesis language if i is the smallest positive example seen so far. So, cbcegis⊂ cegis.\nWe next analyze pbcegis, and show that it is not equivalent to cegis or contained in it. So, replacing a deductive verification engine which returns arbitrary counterexamples with a verification engine which returns counterexamples bounded by history of positive examples has impact on the power of the synthesis technique. But this does not strictly increase the power of synthesis. Instead, the use of positive history bounded counterexamples allows languages from new classes to be identified but at the same time, language from some language classes which could be identified by cegis can no longer be identified using positive bounded counterexamples. The main result regarding the power of synthesis techniques using positive bounded counterexamples is summarized in Theorem 5.3.\nTheorem 5.3 The power of synthesis techniques using arbitrary counterexamples and those using positive bounded counterexamples are not equivalent, and none is more powerful than the other. pbcegis 6= cegis. In fact, pbcegis 6⊆ cegis and cegis 6⊆ pbcegis.\nWe prove this using the following two lemmas. The first lemma 5.4 shows that there is a family of languages from which a language can be identified by cegis but, this cannot be done by pbcegis. The second lemma 5.5 shows that there is another family of languages from which a language can be identified by pbcegis but not by cegis.\nLemma 5.4 There is a family of languages L such that pbcegis cannot identify every language L in L but cegis can do so, that is, cegis 6⊆ pbcegis.\nProof Now, consider the language family 2 formed by upper bounding the elements by some fixed constant. Let the target language L (for which we want to identify Li. In rest of the proof, we also refer to this family as L for brevity.\nLanguage Family 2 Lnot pb = {Li|i ∈ N} such that Li = {n|n ∈ N∧n≤ i}.\nIf we obtain a transcript τ[ j] at any point in synthesis using positive bounded counterexamples, then for any intermediate language L j proposed by Tpbcegis, PBCHECKL would always return ⊥ since all the counterexamples would be larger than any element in τ[ j]. This is the consequence of the chosen languages in which all counterexamples to the language are larger than any positive example of the language. So, Tpbcegis cannot identify the target language L.\nBut we can easily design a synthesis engine Tcegis using arbitrary counterexamples that can synthesize P corresponding to the target language L. The algorithm starts with L0 as its initial guess. If there is no counterexample, the algorithm next guess is L1. In each iteration j, the algorithm guesses L j+1 as long as there are no counterexamples. When a counterexample is returned by CHECKL on the guess L j+1, the algorithm stops and reports the previous guess L j as the correct language.\nSince the elements in each language Li is bounded by some fixed constant i, the above synthesis procedure Tcegis is guaranteed to terminate after i iterations when identifying any language Li ∈ L . Further, CHECKL did not return any counterexample up to iteration j−1 and so, L j ⊆ Li. And in the next iteration, a counterexample was generated. So, L j+1 6⊆ Li. Since, the languages in L form a monotonic chain L0 ⊂ L1 . . .. So, L j = Li. In fact, j = i and in the i-th iteration, the language Li is correctly identified by Tcegis. Thus, cegis 6⊆ pbcegis.\nThis shows that cegis can be used to identify languages when pbcegis will fail. Putting a restriction on the verifier to only produce counterexamples which are bounded by the positive examples seen so far does not strictly increase the power of synthesis.\nWe now show that this restriction enables identification of languages which cannot be identified by cegis.\nIn the proof below, we construct a language which is not distinguishable using arbitrary counterexamples and instead, it relies on the verifier keeping a record of the largest positive example seen so far and restricting counterexamples to those below the largest positive example.\nLemma 5.5 There is a family of languages L such that, cegis cannot identify a language L in L but pbcegis can identify L, that is, pbcegis 6⊆ cegis.\nProof Consider the language L32 = {3 j.2i| j ∈ {0,1}, i ∈ N}\nwhere 3 j.2i is a natural number obtained by taking the product of 3 raised to the power of j and 2 raised to the power of i. L32 is a set of these natural numbers. We now construct a family of languages which are finite subsets of L32 and have at least one member of the form 3.2i, that is,\nL 32 = {L32i |i ∈ N,L32i ⊂ L32,L32i is finite and ∃k s.t. 3.2k ∈ L32i }\nWe now consider the language L2 = {2i|i ∈ N}\nNow, let L 2 be the family of languages such that the smallest element member in the language is the same as the index of the language, that is,\nL 2 = {L2i |i ∈ N,L2i ⊆ L2,L2i is infinite and min(L2i ) = 2i}\nNow, we consider the following family of languages below.\nLanguage Family 3 Lpb = L 32∪L 2\nWe refer to this language as L in rest of the proof for brevity. We show that there is a language L in L such that the language L cannot be identified by cegis but pbcegis can identify any language in L .\nThe key intuition is as follows. If the examples seen by synthesis algorithm till some iteration i are all of the form 2 j, then any synthesis technique cannot differentiate whether the language belongs to L 32 or L 2. If the language belongs to L 32, the synthesis engine would eventually obtain an example of the form 3.2 j (since each language in L 32 has at least one element of this kind and these languages are finite). While the synthesis technique using arbitrary counterexamples cannot recover the previous examples, the techniques with access to the verifier which produces positive bounded counterexamples can recover all the previous examples.\nWe now specify a Tpbcegis which can identify languages in L . The synthesis approach works in two possible steps.\n• Until an example 3.2 j is seen by the synthesis engine, let 2i be the smallest member element seen so far in the transcript, the learner proposes Li as the language. If the target language L ∈L 2, the learner would eventually identify the language since the minimal element will show up in the transcript. If the target language L ∈L 32, then eventually, an example of the form 3.2 j will be seen since L must have one such member element. And after such an example is seen in the transcript, the synthesis engine moves to second step.\n• After an example of the form 3.2 j is seen, the synthesis engine can now be sure that the language belongs to L 32 and is finite. Now, the learner can discover all the positive examples seen so far using the following trick. We first discover the upper bound Bp on positive examples seen so far.\nBp = minimum k such that PBCHECKL({3k},τ[n]) returns ⊥ for k = 2,3, . . .\nRecall that 3k,k = 2,3, . . . are not in the target language since they are not in any of the languages in the L to which the target language belongs. PBCHECKL will return the only element 3k in the proposed candidate language as a counterexample as long as there is some positive example 2i seen previously such that 2i ≥ 3k. So, 3Bp is the upper bound on all the positive examples seen so far. The learner can now construct singleton languages {2 j} for j = 0,1, ...l such that 2l < 3Bp . If a counterexample is returned by PBCHECKL({2i},τ[n]) then 2i is not in the target language. If no counterexample is\nreturned, then 2i is in the target language. This allows the synthesis engine to recover all the positive examples seen previously in finite steps. As we recover the positive examples, we run a Gold style algorithm for identifying finite languages [28] to converge to the correct language. Thus, the learner would identify the correct language using finite memory.\nWe now prove that cegis does not identify this family of languages. Let us assume that L ∈ cegis. So, there is a synthesis engine Tcegis which can identify all languages in L . So, Tcegis must converge to any language L1 ∈L 2 after some finite transcript τs. Let us consider an extension τs2m of τs such that 2m ∈ L1 and 2m 6∈ SAMPLE(τs). Such an element 2m exists since τs is a finite transcript and L1 is an infinite language. Since the learner converges to L1 starting from the initial language L0 after consuming τs, learn(L0,τs2m,cex′) = learn(L0,τs,cex).\nLet us consider two transcripts τs2m(3.2p)⊥ω and τs(3.2p)⊥ω where ⊥ω denotes repeating ⊥ infinitely in the rest of the transcript. We know that learn(L0,τs2m,cex′) = learn(L0,τs,cex) = L1 and thus, learn(τs2m(3.2p)⊥ω ,cex′) = learn(τs(3.2p)⊥ω ,cex) = learn(L1,(3.2p)⊥ω ,cex′′). So, the synthesis engine would behave exactly the same for both transcripts, and if it converges to a language L2 on one transcript, it would converge to the same language on the other transcript. But the two transcripts are clearly from two different languages in L 32. One of the transcripts corresponds to the finite language SAMPLE(τs)∪{3.2p} and the other corresponds to SAMPLE(τs)∪{2m,3.2p}. This is a contradiction and hence, there is no synthesis engine using arbitrary counterexamples Tcegis that can identify all languages in L ."
    }, {
      "heading" : "5.1.3 Different Flavors of Bounded Counterexamples",
      "text" : "Finally, we compare pbcegis and cbcegis and show that they are not contained in each other.\nTheorem 5.6 The power of synthesis techniques using bounded counterexamples is neither less nor more than the techniques using positive bounded counterexamples, that is, cbcegis 6⊆ pbcegis and pbcegis 6⊆ cbcegis. Proof We consider two languages considered in previous proofs and show that the languages corresponding to one of them can only be identified by pbcegis while the languages corresponding to the other can only be identified by cbcegis.\nConsider the language family 1 (Lnotcb) formed by lower bounding the elements by some fixed constant, that is, Lnotcb = {Li|i > B and Li = {n|n ∈ N∧ n > i}} where B is a fixed integer constant. We have proved in Theorem 5.2 that a synthesis engine Tcbcegis cannot identify all languages in Lnotcb. On the other hand, any counterexample is smaller than all positive examples in any language in Lnotcb. So, a verifier producing positive bounded counterexample behaves similar to an arbitrary counterexample verifier since any positive example is larger than all negative examples. Thus, Tcegis can identify languages in this language class. So, pbcegis 6⊆ cbcegis.\nNow, consider the family of languages consisting of these, that is, Language Family 4 Lcbnot pb = {Li|i < B} where Li = {n|n ∈ N∧n≤ i} This is a slight variant of the language class considered in proving Tcegis to be more powerful than Tpbcegis where we have restricted the class of languages to be a finite set. As stated earlier, PBCHECK does not produce any counterexample for these languages since all positive examples are smaller than any counterexample. But CBCHECK can be used to identify languages in this class by selecting the bound of the counterexamples to be B. Since, the counterexamples are at most of size B for these languages, a bounded counterexample verifier behaves exactly like an arbitrary counterexample producing verifier. Thus, cbcegis 6⊆ pbcegis."
    }, {
      "heading" : "5.2 Infinite Memory Inductive Synthesis",
      "text" : "We now consider the case where the inductive learning engine has infinite unbounded memory. This case is simpler than the one considered earlier with finite memory bound on the inductive learning engine and most of the results presented here follow from the results proved for the finite memory case. For brevity of space, we only give proof sketches highlighting the difference from the finite memory case.\n1. The proof of Theorem 5.1 works even when we replace the inductive learning engine using finite memory with the one using infinite memory. Further, the minimal counterexample can still be used as an aribitrary counterexample. And so, MINCEGIS= CEGIS.\n2. Next, we show that CBCEGIS ⊆ CEGIS. Consider an arbitrary but fixed constant B. For this B, consider all verifiers CBCHECK that only produce counterexamples bounded by B. We wish to argue that any infinite memory learner LEARN that can converge to a target language Lc using any CBCHECK can also do so using CHECK. The basic idea is as follows: since LEARN has infinite memory, it can make extra queries to CHECK to obtain counterexamples bounded by B and learns only from those. Suppose at some step it received a counterexample x bigger than B for candidate language L. Then LEARN constructs a new candidate language L′ that excludes x but otherwise agrees with L.5 It then queries CHECK with this new candidate L′, and iterates the process until a counterexample less than B is received (which must happen if such a counterexample exists). LEARN uses its infinite-size memory to construct candidate languages that keep track of a potentially unbounded number of counterexamples bigger than B. Thus, LEARN uses this procedure to convert any CHECK into some CBCHECK. Since CBCEGIS comprises all language families learnable by LEARN given any CBCHECK, these language families are also learnable by LEARN using CHECK. Therefore, CBCEGIS⊆ CEGIS.\n3. We now sketch the proof for PBCEGIS ⊆ CEGIS. The argument is similar to the previous case. Since the learner has infinite memory, it can store all the positive examples seen so far. Moreover, similar to the case of CBCEGIS, it can construct a stream of candidate languages to query CHECK so as to obtain positive history bounded counterexamples, as follows. It queries CHECK to obtain an arbitrary counterexample. If this is smaller than the largest positive example in stored positive examples, then the learner uses this example for proposing the next hypothesis language. If this counterexample is larger that the largest positive example, it constructs a new candidate language by excluding this counterexample from the previous candidate language, and again queries CHECK to obtain a new counterexample. This continues until the learner can get a positive history bounded counterexample or there is no such counterexample. Thus, the learner now uses only positive history bounded counterexamples, and hence, TCEGIS can identify any language that TPBCEGIS can identify.\nWe now present three languages used previously in proofs for inductive learning engines using finite memory, and show how these languages allow us to distinguish relative power of synthesis engines.\n1. Consider the language family 1: Lnotcb = {Li|i > B and Li = {n|n ∈ N∧ n > i}} where B is a constant bound. The argument in Theorem 5.2 also holds for the infinite memory synthesis engines, and so, Lnotcb ∈ CBCEGIS∩CEGIS. Further, a positive history bounded verifier will always return a counterexample if one exists since all counterexamples are smaller than any positive example in the language. Thus, TPBCEGIS can also identify languages in Lnotcb. Thus, Lnotcb ∈ CBCEGIS∩PBCEGIS.\n5We can do this as we have a finite representation of L (e.g., in the form of its characteristic function) and can modify this to initially check if the input is x, and if so, to report that this is not in the modified language.\n2. Consider the language family 2: Lnot pb = {Li|i ∈ N} where\nLi = {n|n ∈ N∧n≤ i}\nAs argued in the proof of Theorem 5.3, the verifier producing positive bounded counterexamples will not report any counterexample for any of the languages in Lnot pb because all counterexamples are larger than any positive example. So, languages in this family cannot be identified by TPBCEGIS but these can be identified using TCEGIS. So, Lnot pb ∈ PBCEGIS∩CEGIS.\n3. Consider the finite language family 4: Lcbnot pb = {Li|i < B} where\nLi = {n|n ∈ N∧n≤ i}\nAs argued in proof of Theorem 5.6, the verifier PBCHECK does not produce any counterexample for these languages since all positive examples are smaller than any counterexample. But CBCHECK can be used to identify languages in this class by selecting the bound to be B. Since, the counterexamples are at most of size B for these languages, a bounded counterexample verifier behaves exactly like an arbitrary counterexample producing verifier. Thus, Lcbnot pb ∈ PBCEGIS∩CBCEGIS.\nWe now summarize the results described in this section below. For finite memory learners, cbcegis⊂ mincegis= cegis, pbcegis and cegis are not comparabale, that is, pbcegis 6⊆ cegis and pbcegis 6⊇ cegis. cbcegis and pbcegis are also not comparable. In case of infinite memory learners, CBCEGIS⊂ MINCEGIS= CEGIS, and PBCEGIS⊂ CEGIS= MINCEGIS. CBCEGIS and PBCEGIS are again not comparable. The results are summarized in Figure 2.\n6 Analysis of OGIS for Finite Language Classes\nWe now discuss the case when the class of candidate programs (languages) has finite cardinality. As in Sec. 4, rather than referring to programs we will refer to synthesizing the languages identified by those programs. If the language class is finite then there exists a terminating OGIS procedure, e.g., one that\nsimply enumerates languages from this class until one satisfying the specification Φ is obtained. Moreover, any implementation of OGIS which uses an oracle that provides new (positive/negative) examples in every iteration ruling out at least one candidate language will terminate with the correct language. The counterexample guided inductive synthesis approach [55] for bitvector sketches and oracle guided inductive synthesis using distinguishing inputs [30] for programs composed of a finite library of components are examples of OGIS synthesis techniques applied to finite language classes. We analyze the complexity of synthesis for finite language classes and discuss its relation to the notion of teaching dimension from the concept learning literature [20]. This connection between synthesis of languages from finite classes and teaching of concepts was first discussed in [30]. Here we establish that the size of the smallest set of examples for language (program) synthesis is bounded below by the teaching dimension of the concept class corresponding to the class of languages."
    }, {
      "heading" : "6.1 NP-hardness",
      "text" : "We measure efficiency of an OGIS synthesis engine using the notion of sample complexity mentioned in Sec. 2 — the number of queries (and responses) needed to correctly identify a language. In order to analyze sample complexity, we need to fix the nature of queries to the oracle. We focus on queries to which the oracle provides an example or counterexample in response. We show that finding the minimal set of examples to be provided by the oracle such that the synthesis engine converges to the correct language is NP-hard.\nTheorem 6.1 Solving the formal inductive synthesis problem 〈C ,E,Φ,O〉 for a finite C and finite E with the minimum number of queries is NP-hard for any oracle interface O comprising the correctness query qcorr (and possibly qposwit and qnegwit).\nProof We prove NP-hardness through reduction from the minimum set cover problem. Consider the minimum set cover problem with k sets S1,S2, . . . ,Sk and a universe comprising m elements x1,x2, . . . ,xm which needs to be covered using the sets. We reduce it to a formal inductive synthesis problem 〈C ,E,Φ,O〉 where C = {L1,L2, . . . ,Lm,Lm+1} is a set of m+1 languages, E = {e1,e2, . . . ,ek} is the domain comprising k examples over which the languages are defined and Φ = {Lm+1} is the specification. Intuitively, the m languages L1, . . . ,Lm are associated to the m elements in the set cover problem. The k examples correspond to the k sets. The sets L1,L2, . . . ,Lm+1 are constructed as follows: For all 1≤ i≤ k and 1≤ j ≤m, example ei belongs to the symmetric difference of L j and Lm+1 if and only if the set Si contains element x j. We can do this, for instance, by including ei in L j but not in Lm+1.\nConsider the operation of an OGIS procedure implementing an O containing qcorr. Every unsuccessful correctness query returns a counterexample which is an element of E in the symmetric difference of the proposed L j and Lm+1. Let ei1 ,ei2 , . . . ,ein be the smallest set of counterexamples that uniquely identifies the correct language Lm+1. So, for all 1 ≤ j ≤ m, there exists some il such that either eil ∈ L j or eil ∈ Lm+1 but not both. And so, for all 1 ≤ j ≤ m, there exists some il such that x j ∈ Sil where il ∈ {i1, i2, . . . , in}. Moreover, dropping il results in some x j not being covered (the corresponding L j is not distinguished from Lm+1). Thus, Si1 ,Si2 , . . . ,Sin is a solution to the minimum set cover problem which is known to be NP-complete. Similarly, it is easy to see that any solution to the minimum set cover problem also yields a minimum counterexample set.\nWe can therefore conclude that solving the formal inductive synthesis problem 〈C ,E,Φ,O〉 with the minimum number of queries is NP-hard.\nWe note that this proof applies to any FIS problem with an oracle interface O containing the correctness query qcorr. Moreover, this proof can be easily extended to other oracle interfaces as well,\nsuch as the version of the distinguishing input method that does not use the correctness query, with O = {q+wit,qdiff,qmem}. In this latter case, the combined use of qdiff and qmem yields the desired mapping."
    }, {
      "heading" : "6.2 Relation to Teaching Dimension",
      "text" : "Goldman et al. [20, 21] proposed teaching dimension as a measure to study computational complexity of learning. They consider a teaching model in which a helpful teacher selects the examples of the concept and provides it to the learner. Informally, the teaching dimension of a concept class is the minimum number of examples that a teacher must reveal to uniquely identify any target concept chosen from the class.\nFor a domain E and concept class C , a concept c∈C is a set of examples from E. So, C ⊆ 2E. In the learning model proposed by Goldman et al. [20, 21], the basic goal of the teacher is to help the learner identify the target concept c∗ ∈ C by providing an example sequence from E. We now formally define the teaching dimension of a concept class.\nDefinition 6.1 (adapted from [20]) An example sequence is a sequence of labeled examples from E, where the labels are given by some underlying specification. For concept class C and target concept c ∈ C , we say T is a teaching sequence for c (in C ) if T is an example sequence that uniquely identifies c in C - that is, c is the only concept in C consistent with T . Let T (c) denote the set of all teaching sequences for c. Teaching dimension T D(C ) of the concept class is defined as follows:\nT D(C ) = max c∈C ( min τ∈T (c) |τ|)\nConsider an FIS problem where the specification is complete, i.e., Φ = {Lc}. Consider an instance of OGIS using any combination of witness, equivalence, subsumption, or distinguishing input queries. Each of these queries, if it does not terminate the OGIS loop, returns a new example for the learner. Thus, the number of iterations of the OGIS loop, its sample complexity, is the number of examples needed by the learner to identify a correct language. Suppose the minimum such number of examples, for any specification (target language Lc ∈ C ), is MOGIS(C ). Then, the following theorem must hold. Theorem 6.2 MOGIS(C )≥ T D(C ) The theorem can be obtained by a straightforward proof by contradiction: if MOGIS(C )< T D(C ), then for each target concept to be learned, there is a shorter teaching sequence than T D(C ), viz., the one used by the OGIS instance for that target, contradicting the definition of teaching dimension.\nNow, given that the teaching dimension is a lower bound on the sample complexity of OGIS, it is natural to ask how large T D(C ) can grow in practice. This is still a largely open question for general language classes. However, results from machine learning theory can help shed more light on this question. One of these results relates the teaching dimension to a second metric for measuring complexity of learning, namely the Vapnik-Chervonenkis (VC) dimension [60]. We define this below.\nDefinition 6.2 [60] Let E be the domain of examples and c be a concept from the class C . A finite set E′ ⊆ E is shattered by C if {c∩E′|c ∈ C } = 2E′ . In other words, E′ ⊆ E is shattered by C if for each subset E′′ ⊆ E′, there is a concept c ∈ C which contains all of E′′, but none of the instances in E′−E′′. The Vapnik-Chervonenskis (VC) dimension is defined to be smallest d for which no set of d+1 examples is shattered by C .\nBlumer et al. [12] have shown that the VC dimension of a concept class characterizes the number of examples required for learning any concept in the class under the distribution-free or probably approximately correct (PAC) model of Valiant [59]. The differences between teaching dimension and\nVapnik-Chervonenkis dimension are discussed at length by Goldman and Kearns [20]. The following theorems from [20] provides lower and upper bound on the teaching dimension of a finite concept class in terms of the size of the concept class and its VC-dimension.\nTheorem 6.3 [20] The teaching dimension T D(C ) of any concept class C satisfies the following upper and lower bounds: VC(C )/ log(|C |)≤ T D(C )≤ |C |−1 where VC(C ) is the VC dimension of the concept class C and |C | denotes the number of concepts in the concept class.\nMoreover, Goldman and Kearns [20] exhibit a concept class for which the upper bound is tight. This indicates that without restrictions on the concept class, one may not be able to prove very strong bounds on the sample complexity of OGIS.\nTo summarize, we have shown that solving the formal inductive synthesis problem for finite domains and finite concept classes with the minimum number of queries is NP-hard. Further, we showed that the combinatorial measure of teaching dimension captures the smallest number of examples required to identify the correct language."
    }, {
      "heading" : "7 Conclusion",
      "text" : "We presented a theoretical framework and analysis of formal inductive synthesis by formalizing the notion of oracle-guided inductive synthesis (OGIS). We illustrated how OGIS generalizes instances of concept learning in machine learning as well as synthesis techniques developed using formal methods. We focus on counterexample-guided inductive synthesis (CEGIS) which is an OGIS implementations that uses the verification engine as the oracle. We presented different variations of cegis motivated by practice, and showed that their synthesis power can be different, especially when the learning engine can only store a bounded number of examples. There are several directions for future work. We discuss some open problems below that would further improve the theoretical understanding of formal inductive synthesis. • Teaching dimension of concept classes such as decision trees and axis parallel rectangles have been\nwell-studied in literature. But teaching dimension of formal concept classes such as programs in the while [64] language with only linear arithmetic over integers is not known. Finding teaching dimensions for these classes would help in establishing bounds on the number of examples needed for synthesizing programs from these classes. • We investigated the difference in synthesis power when the learning engine has finite memory vs when\nthe learning engine has infinite memory. Another important question to consider is how the power of the synthesis engine changes when we restrict the time complexity of learning engine such as the learning engines which take time polynomial in the number of examples. • We have not analyzed the impact of different learning strategies that may traverse the space of possible\nprograms (languages) in various ways. This is also an interesting avenue for future work. In summary, our paper is a first step towards a theory of formal inductive synthesis, and much remains\nto be done to improve our understanding of this emerging area with several practical applications."
    } ],
    "references" : [ {
      "title" : "Syntax-Guided Synthe-  28  Formal Inductive Synthesis sis",
      "author" : [ "Rajeev Alur", "Rastislav Bodik", "Garvit Juniwal", "Milo M.K. Martin", "Mukund Raghothaman", "Sanjit A. Seshia", "Rishabh Singh", "Armando Solar-Lezama", "Emina Torlak", "Abhishek Udupa" ],
      "venue" : "Proceedings of the IEEE International Conference on Formal Methods in Computer-Aided Design (FMCAD)",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2013
    }, {
      "title" : "Inductive Inference of Formal Languages from Positive Data",
      "author" : [ "Dana Angluin" ],
      "venue" : "Information and Control",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1980
    }, {
      "title" : "Learning regular sets from queries and counterexamples",
      "author" : [ "Dana Angluin" ],
      "venue" : "Information and computation",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1987
    }, {
      "title" : "Queries and concept learning",
      "author" : [ "Dana Angluin" ],
      "venue" : "Machine Learning",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1988
    }, {
      "title" : "Available at http://www.sciencedirect.com/ science/article/pii/S030439750300608X",
      "author" : [ "Dana Angluin" ],
      "venue" : "Queries revisited. Theoretical Computer Science",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2003
    }, {
      "title" : "Inductive Inference: Theory and Methods",
      "author" : [ "Dana Angluin", "Carl H. Smith" ],
      "venue" : "ACM Computing Surveys",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1983
    }, {
      "title" : "Context-Bounded Analysis For Concurrent Programs With Dynamic Creation of Threads",
      "author" : [ "Mohamed Faouzi Atig", "Ahmed Bouajjani", "Shaz Qadeer" ],
      "venue" : "Logical Methods in Computer Science",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2011
    }, {
      "title" : "Satisfiability Modulo Theories",
      "author" : [ "Clark Barrett", "Roberto Sebastiani", "Sanjit A. Seshia", "Cesare Tinelli" ],
      "venue" : "editors: Handbook of Satisfiability,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "Bounded Model Checking",
      "author" : [ "Armin Biere" ],
      "venue" : "Handbook of Satisfiability,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2009
    }, {
      "title" : "Toward a mathematical theory of inductive inference",
      "author" : [ "L. Blum", "M. Blum" ],
      "venue" : "Information and Control",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1975
    }, {
      "title" : "Learnability and the Vapnik-Chervonenkis Dimension",
      "author" : [ "Anselm Blumer", "A. Ehrenfeucht", "David Haussler", "Manfred K. Warmuth" ],
      "venue" : "J. ACM 36(4),",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1989
    }, {
      "title" : "Graph-based algorithms for Boolean function manipulation",
      "author" : [ "Randal E. Bryant" ],
      "venue" : "IEEE Transactions on Computers",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1986
    }, {
      "title" : "Automated Design Debugging With Maximum Satisfiability",
      "author" : [ "Yibin Chen", "Sean Safarpour", "Joo Marques-Silva", "Andreas G. Veneris" ],
      "venue" : "IEEE Trans. on CAD of Integrated Circuits and Systems",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2010
    }, {
      "title" : "Design and Synthesis of Synchronization Skeletons Using Branching-Time",
      "author" : [ "Edmund M. Clarke", "E. Allen Emerson" ],
      "venue" : "Temporal Logic. In: Logic of Programs,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1981
    }, {
      "title" : "Special issue on learning techniques for compositional reasoning",
      "author" : [ "Dimitra Giannakopoulou", "Corina S. Pasareanu", "eds" ],
      "venue" : "Formal Methods in System Design",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2008
    }, {
      "title" : "On the Complexity of Teaching",
      "author" : [ "Sally A. Goldman", "Michael J. Kearns" ],
      "venue" : "Journal of Computer and System Sciences",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1992
    }, {
      "title" : "Learning Binary Relations and Total Orders",
      "author" : [ "Sally A. Goldman", "Ronald L. Rivest", "Robert E. Schapire" ],
      "venue" : "SIAM J. Comput",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1993
    }, {
      "title" : "Synthesizing software verifiers from proof rules",
      "author" : [ "Sergey Grebenshchikov", "Nuno P Lopes", "Corneliu Popeea", "Andrey Rybalchenko" ],
      "venue" : "ACM SIGPLAN Notices, 47,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2012
    }, {
      "title" : "Geometrical Concept Learning and Convex Polytopes",
      "author" : [ "Tibor Hegedűs" ],
      "venue" : "Proceedings of the Seventh Annual Conference on Computational Learning Theory, COLT ’94,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1994
    }, {
      "title" : "An Efficient Membership-Query Algorithm for Learning {DNF} with Respect to the Uniform Distribution",
      "author" : [ "C Jeffrey" ],
      "venue" : "Journal of Computer and System Sciences",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1997
    }, {
      "title" : "Systems that learn: an introduction to learning theory",
      "author" : [ "Sanjay Jain" ],
      "venue" : null,
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 1999
    }, {
      "title" : "Iterative learning from positive data and negative counterexamples",
      "author" : [ "Sanjay Jain", "Efim Kinber" ],
      "venue" : "Information and Computation",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2007
    }, {
      "title" : "Combining Postulates of Naturalness in Inductive Inference",
      "author" : [ "Klaus P. Jantke", "Hans-Rainer" ],
      "venue" : "Beick",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 1981
    }, {
      "title" : "Oracle-guided Component-based Program Synthesis",
      "author" : [ "Susmit Jha", "Sumit Gulwani", "Sanjit A. Seshia", "Ashish Tiwari" ],
      "venue" : "ICSE ’10,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2010
    }, {
      "title" : "Synthesizing Switching Logic for Safety and Dwell-Time Requirements",
      "author" : [ "Susmit Jha", "Sumit Gulwani", "Sanjit A. Seshia", "Ashish Tiwari" ],
      "venue" : "Proceedings of the International Conference on Cyber-Physical Systems (ICCPS),",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2010
    }, {
      "title" : "Are There Good Mistakes? A Theoretical Analysis of CEGIS",
      "author" : [ "Susmit Jha", "Sanjit A. Seshia" ],
      "venue" : "Workshop on Synthesis (SYNT)",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2014
    }, {
      "title" : "Synthesis of Optimal Switching Logic for Hybrid Systems",
      "author" : [ "Susmit Jha", "Sanjit A. Seshia", "Ashish Tiwari" ],
      "venue" : "Proceedings of the International Conference on Embedded Software (EMSOFT),",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2011
    }, {
      "title" : "Towards Automated System Synthesis Using SCIDUCTION",
      "author" : [ "Susmit Kumar Jha" ],
      "venue" : "Ph.D. thesis, EECS Department,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2011
    }, {
      "title" : "Mining Requirements from Closed-Loop Control Models",
      "author" : [ "Xiaoqing Jin", "Alexandre Donzé", "Jyotirmoy Deshmukh", "Sanjit A. Seshia" ],
      "venue" : "Proceedings of the International Conference on Hybrid Systems: Computation and Control (HSCC)",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2013
    }, {
      "title" : "Computer-Aided Reasoning: An Approach",
      "author" : [ "Matt Kaufmann", "Panagiotis Manolios", "J. Strother Moore" ],
      "venue" : null,
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2000
    }, {
      "title" : "Software synthesis procedures",
      "author" : [ "Viktor Kuncak", "Mikaël Mayer", "Ruzica Piskac", "Philippe Suter" ],
      "venue" : "Commun. ACM",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2012
    }, {
      "title" : "Algorithmic Learning of Recursive Languages. Mensch-und-Buch-Verlag",
      "author" : [ "S. Lange" ],
      "venue" : null,
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2000
    }, {
      "title" : "Learning Indexed Families of Recursive Languages from Positive Data: A Survey",
      "author" : [ "Steffen Lange", "Thomas Zeugmann", "Sandra Zilles" ],
      "venue" : "Theor. Comput. Sci",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2008
    }, {
      "title" : "Formal language identification: Query learning vs gold-style learning",
      "author" : [ "Steffen Lange", "Sandra Zilles" ],
      "venue" : "Information Processing Letters,",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2004
    }, {
      "title" : "Boolean Satisfiability: From Theoretical Hardness to Practical Success",
      "author" : [ "Sharad Malik", "Lintao Zhang" ],
      "venue" : "Communications of the ACM (CACM)",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 2009
    }, {
      "title" : "A Deductive Approach to Program Synthesis",
      "author" : [ "Zohar Manna", "Richard Waldinger" ],
      "venue" : "ACM Trans. Program. Lang. Syst",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 1980
    }, {
      "title" : "Machine Learning, first edition",
      "author" : [ "Thomas M. Mitchell" ],
      "venue" : null,
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 1997
    }, {
      "title" : "MaxSAT-Based MCS Enumeration",
      "author" : [ "Antonio Morgado", "Mark Liffiton", "Joao Marques-Silva" ],
      "venue" : null,
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2013
    }, {
      "title" : "PVS: A Prototype Verification System",
      "author" : [ "S. Owre", "J.M. Rushby", "N. Shankar" ],
      "venue" : "In Deepak Kapur, editor: 11th International Conference on Automated Deduction (CADE), Lecture Notes in Artificial Intelligence",
      "citeRegEx" : "45",
      "shortCiteRegEx" : "45",
      "year" : 1992
    }, {
      "title" : "On the Synthesis of a Reactive Module",
      "author" : [ "Amir Pnueli", "Roni Rosner" ],
      "venue" : "ACM Symposium on Principles of Programming Languages (POPL),",
      "citeRegEx" : "46",
      "shortCiteRegEx" : "46",
      "year" : 1989
    }, {
      "title" : "Specification and Verification of Concurrent Systems in CESAR",
      "author" : [ "Jean-Pierre Queille", "Joseph Sifakis" ],
      "venue" : "In: Symposium on Programming,",
      "citeRegEx" : "47",
      "shortCiteRegEx" : "47",
      "year" : 1982
    }, {
      "title" : "Induction of Decision Trees",
      "author" : [ "J.R. Quinlan" ],
      "venue" : "Mach. Learn",
      "citeRegEx" : "48",
      "shortCiteRegEx" : "48",
      "year" : 1986
    }, {
      "title" : "Theory of Recursive Functions and Effective Computability",
      "author" : [ "Hartley Rogers", "Jr." ],
      "venue" : null,
      "citeRegEx" : "49",
      "shortCiteRegEx" : "49",
      "year" : 1987
    }, {
      "title" : "Best-case results for nearest-neighbor learning",
      "author" : [ "S. Salzberg", "A.L. Delcher", "D. Heath", "S. Kasif" ],
      "venue" : "Pattern Analysis and Machine Intelligence, IEEE Transactions on 17(6),",
      "citeRegEx" : "50",
      "shortCiteRegEx" : "50",
      "year" : 1995
    }, {
      "title" : "Sciduction: Combining Induction, Deduction, and Structure for Verification and Synthesis",
      "author" : [ "Sanjit A. Seshia" ],
      "venue" : "Proceedings of the Design Automation Conference (DAC),",
      "citeRegEx" : "51",
      "shortCiteRegEx" : "51",
      "year" : 2012
    }, {
      "title" : "Algorithmic Program Debugging",
      "author" : [ "Ehud Y Shapiro" ],
      "venue" : null,
      "citeRegEx" : "52",
      "shortCiteRegEx" : "52",
      "year" : 1982
    }, {
      "title" : "Teachability in Computational Learning",
      "author" : [ "Ayumi Shinohara", "Satoru Miyano" ],
      "venue" : "In: ALT,",
      "citeRegEx" : "53",
      "shortCiteRegEx" : "53",
      "year" : 1990
    }, {
      "title" : "Programming by sketching for bit-streaming programs",
      "author" : [ "Armando Solar-Lezama", "Rodric Rabbah", "Rastislav Bodı́k", "Kemal Ebcioglu" ],
      "venue" : null,
      "citeRegEx" : "54",
      "shortCiteRegEx" : "54",
      "year" : 2005
    }, {
      "title" : "Combinatorial sketching for finite programs",
      "author" : [ "Armando Solar-Lezama", "Liviu Tancau", "Rastislav Bodk", "Sanjit A. Seshia", "Vijay A. Saraswat" ],
      "venue" : "In: ASPLOS,",
      "citeRegEx" : "55",
      "shortCiteRegEx" : "55",
      "year" : 2006
    }, {
      "title" : "A Methodology for LISP Program Construction from Examples",
      "author" : [ "Phillip D. Summers" ],
      "venue" : "J. ACM 24(1)",
      "citeRegEx" : "57",
      "shortCiteRegEx" : "57",
      "year" : 1977
    }, {
      "title" : "TRANSIT: Specifying Protocols with Concolic Snippets",
      "author" : [ "Abhishek Udupa", "Arun Raghavan", "Jyotirmoy V. Deshmukh", "Sela Mador-Haim", "Milo M.K. Martin", "Rajeev Alur" ],
      "venue" : "Proceedings of the 34th ACM SIGPLAN conference on Programming Language Design and Implementation,",
      "citeRegEx" : "58",
      "shortCiteRegEx" : "58",
      "year" : 2013
    }, {
      "title" : "A Theory of the Learnable",
      "author" : [ "G. Leslie" ],
      "venue" : "Valiant",
      "citeRegEx" : "59",
      "shortCiteRegEx" : "59",
      "year" : 1984
    }, {
      "title" : "On the Uniform Convergence of Relative Frequencies of Events to Their Probabilities",
      "author" : [ "V.N. Vapnik", "A. Ya" ],
      "venue" : "Chervonenkis",
      "citeRegEx" : "60",
      "shortCiteRegEx" : "60",
      "year" : 1971
    }, {
      "title" : "Applied Linear Regression, third edition",
      "author" : [ "Sanford Weisberg" ],
      "venue" : "Wiley, Hoboken NJ. Available at http: //www.stat.umn.edu/alr",
      "citeRegEx" : "61",
      "shortCiteRegEx" : "61",
      "year" : 2005
    }, {
      "title" : "Limit Detection of Recursive Functions by Specific Strategies",
      "author" : [ "Rolf Wiehagen" ],
      "venue" : "Electronic Information Processing and Cybernetics",
      "citeRegEx" : "62",
      "shortCiteRegEx" : "62",
      "year" : 1976
    }, {
      "title" : "A Thesis in Inductive Inference",
      "author" : [ "Rolf Wiehagen" ],
      "venue" : "editors: Nonmonotonic and Inductive Logic, Lecture Notes in Computer Science 543,",
      "citeRegEx" : "63",
      "shortCiteRegEx" : "63",
      "year" : 1990
    }, {
      "title" : "The Formal Semantics of Programming Languages: An Introduction",
      "author" : [ "Glynn Winskel" ],
      "venue" : null,
      "citeRegEx" : "64",
      "shortCiteRegEx" : "64",
      "year" : 1993
    } ],
    "referenceMentions" : [ {
      "referenceID" : 13,
      "context" : "Formal verification techniques such as model checking [15, 47, 16] and theorem proving (see, e.",
      "startOffset" : 54,
      "endOffset" : 66
    }, {
      "referenceID" : 40,
      "context" : "Formal verification techniques such as model checking [15, 47, 16] and theorem proving (see, e.",
      "startOffset" : 54,
      "endOffset" : 66
    }, {
      "referenceID" : 38,
      "context" : "[45, 36, 22]) are used routinely in the computer-aided design of integrated circuits and have been widely applied to find bugs in software, analyze models of embedded systems, and find security vulnerabilities in programs and protocols.",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 29,
      "context" : "[45, 36, 22]) are used routinely in the computer-aided design of integrated circuits and have been widely applied to find bugs in software, analyze models of embedded systems, and find security vulnerabilities in programs and protocols.",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 34,
      "context" : "At the heart of many of these advances are computational reasoning engines such as Boolean satisfiability (SAT) solvers [41], Binary Decision Diagrams (BDDs) [13], and satisfiability modulo theories (SMT) solvers [8].",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 11,
      "context" : "At the heart of many of these advances are computational reasoning engines such as Boolean satisfiability (SAT) solvers [41], Binary Decision Diagrams (BDDs) [13], and satisfiability modulo theories (SMT) solvers [8].",
      "startOffset" : 158,
      "endOffset" : 162
    }, {
      "referenceID" : 7,
      "context" : "At the heart of many of these advances are computational reasoning engines such as Boolean satisfiability (SAT) solvers [41], Binary Decision Diagrams (BDDs) [13], and satisfiability modulo theories (SMT) solvers [8].",
      "startOffset" : 213,
      "endOffset" : 216
    }, {
      "referenceID" : 35,
      "context" : "Starting with the seminal work of Manna and Waldinger on deductive program synthesis [42] and Pnueli and Rosner on reactive synthesis from temporal logic [46], there have been several advances that have made formal synthesis practical in specific application domains such as robotics, online education, and end-user programming.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 39,
      "context" : "Starting with the seminal work of Manna and Waldinger on deductive program synthesis [42] and Pnueli and Rosner on reactive synthesis from temporal logic [46], there have been several advances that have made formal synthesis practical in specific application domains such as robotics, online education, and end-user programming.",
      "startOffset" : 154,
      "endOffset" : 158
    }, {
      "referenceID" : 35,
      "context" : ", [42]), a program is synthesized by constructively proving a theorem, employing logical inference and constraint solving.",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 49,
      "context" : "On the other hand, inductive synthesis [19, 57, 52] seeks to find a program matching a set of input-output examples.",
      "startOffset" : 39,
      "endOffset" : 51
    }, {
      "referenceID" : 45,
      "context" : "On the other hand, inductive synthesis [19, 57, 52] seeks to find a program matching a set of input-output examples.",
      "startOffset" : 39,
      "endOffset" : 51
    }, {
      "referenceID" : 5,
      "context" : "At a high level, it is thus an instance of learning from examples, also termed as inductive inference or machine learning [6, 43].",
      "startOffset" : 122,
      "endOffset" : 129
    }, {
      "referenceID" : 36,
      "context" : "At a high level, it is thus an instance of learning from examples, also termed as inductive inference or machine learning [6, 43].",
      "startOffset" : 122,
      "endOffset" : 129
    }, {
      "referenceID" : 44,
      "context" : "Many current approaches to synthesis blend induction and deduction in the sense that even as they generalize from examples, deductive procedures are used in the process of generalization (see [51, 34] for a detailed exposition).",
      "startOffset" : 192,
      "endOffset" : 200
    }, {
      "referenceID" : 27,
      "context" : "Many current approaches to synthesis blend induction and deduction in the sense that even as they generalize from examples, deductive procedures are used in the process of generalization (see [51, 34] for a detailed exposition).",
      "startOffset" : 192,
      "endOffset" : 200
    }, {
      "referenceID" : 48,
      "context" : "It has been recognized that this syntax guidance, also termed as a structure hypothesis, can be crucial in helping the synthesizer converge quickly to the target concept [55, 51, 1].",
      "startOffset" : 170,
      "endOffset" : 181
    }, {
      "referenceID" : 44,
      "context" : "It has been recognized that this syntax guidance, also termed as a structure hypothesis, can be crucial in helping the synthesizer converge quickly to the target concept [55, 51, 1].",
      "startOffset" : 170,
      "endOffset" : 181
    }, {
      "referenceID" : 0,
      "context" : "It has been recognized that this syntax guidance, also termed as a structure hypothesis, can be crucial in helping the synthesizer converge quickly to the target concept [55, 51, 1].",
      "startOffset" : 170,
      "endOffset" : 181
    }, {
      "referenceID" : 53,
      "context" : "Concept Classes: In traditional machine learning, the classes of concepts to be synthesized tend to be specialized, such as linear functions or half-spaces [61], convex polytopes [25], neural networks of specific forms [9], Boolean formulas in fixed, bounded syntactic forms [26], and decision trees [48].",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 18,
      "context" : "Concept Classes: In traditional machine learning, the classes of concepts to be synthesized tend to be specialized, such as linear functions or half-spaces [61], convex polytopes [25], neural networks of specific forms [9], Boolean formulas in fixed, bounded syntactic forms [26], and decision trees [48].",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 19,
      "context" : "Concept Classes: In traditional machine learning, the classes of concepts to be synthesized tend to be specialized, such as linear functions or half-spaces [61], convex polytopes [25], neural networks of specific forms [9], Boolean formulas in fixed, bounded syntactic forms [26], and decision trees [48].",
      "startOffset" : 275,
      "endOffset" : 279
    }, {
      "referenceID" : 41,
      "context" : "Concept Classes: In traditional machine learning, the classes of concepts to be synthesized tend to be specialized, such as linear functions or half-spaces [61], convex polytopes [25], neural networks of specific forms [9], Boolean formulas in fixed, bounded syntactic forms [26], and decision trees [48].",
      "startOffset" : 300,
      "endOffset" : 304
    }, {
      "referenceID" : 36,
      "context" : "Learning Algorithms: In traditional machine learning, just as concept classes tend to be specialized, so also are the learning algorithms for those classes [43].",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 48,
      "context" : "For instance, the class of programs from which the synthesizer must generate the correct one may be finite, as in the synthesis of bitvector programs [55, 30, 24], or infinite, as in the synthesis of guards for hybrid automata [31, 33].",
      "startOffset" : 150,
      "endOffset" : 162
    }, {
      "referenceID" : 23,
      "context" : "For instance, the class of programs from which the synthesizer must generate the correct one may be finite, as in the synthesis of bitvector programs [55, 30, 24], or infinite, as in the synthesis of guards for hybrid automata [31, 33].",
      "startOffset" : 150,
      "endOffset" : 162
    }, {
      "referenceID" : 24,
      "context" : "For instance, the class of programs from which the synthesizer must generate the correct one may be finite, as in the synthesis of bitvector programs [55, 30, 24], or infinite, as in the synthesis of guards for hybrid automata [31, 33].",
      "startOffset" : 227,
      "endOffset" : 235
    }, {
      "referenceID" : 26,
      "context" : "For instance, the class of programs from which the synthesizer must generate the correct one may be finite, as in the synthesis of bitvector programs [55, 30, 24], or infinite, as in the synthesis of guards for hybrid automata [31, 33].",
      "startOffset" : 227,
      "endOffset" : 235
    }, {
      "referenceID" : 48,
      "context" : "Our work has a particular focus on counterexample-guided inductive synthesis (CEGIS) [55], a particularly popular and effective instantiation of the OGIS framework.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 15,
      "context" : "In this case, we draw a connection between the number of counterexamples needed by a CEGIS procedure and the notion of teaching dimension [20] previously introduced in the machine learning literature.",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 15,
      "context" : "We also show that the teaching dimension [20] of the concept class is a lower bound on the number of counterexamples needed for a CEGIS technique to terminate (on an arbitrary program from that class).",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 25,
      "context" : "A preliminary version of this paper appeared in the SYNT 2014 workshop [32].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 3,
      "context" : "Following standard terminology in the machine learning theory community [4], we define a concept c as a set of examples drawn from a domain of examples E.",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 28,
      "context" : "Such a query allows us to accurately model the working of counterexample-guided synthesis techniques such as [35] where the verification problem is undecidable but, if a counterexample is reported, it is a true counterexample.",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 23,
      "context" : "The distinguishing input query has been found useful in scenarios where it is computationally hard to check correctness using the specification Φ, such as in malware deobfuscation [30].",
      "startOffset" : 180,
      "endOffset" : 184
    }, {
      "referenceID" : 4,
      "context" : "learning theory community, there have been thorough studies of query-based learning; see Angluin’s review paper [5] for details.",
      "startOffset" : 112,
      "endOffset" : 115
    }, {
      "referenceID" : 2,
      "context" : "1 Query-based learning of automata [3]: Angluin’s classic work on learning deterministic finite automata (DFAs) from membership and equivalence queries [3] is an instance of OGIS with O = {qmem,qeq}.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 2,
      "context" : "1 Query-based learning of automata [3]: Angluin’s classic work on learning deterministic finite automata (DFAs) from membership and equivalence queries [3] is an instance of OGIS with O = {qmem,qeq}.",
      "startOffset" : 152,
      "endOffset" : 155
    }, {
      "referenceID" : 14,
      "context" : "Several variants of L∗ have found use in the formal verification literature; see [18] for more information.",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 48,
      "context" : "2 Counterexample-guided inductive synthesis (CEGIS) [55]: CEGIS was originally proposed as an algorithmic method for program synthesis where the specification is given as a reference program and the concept class is defined using a partial program, also referred to as a “sketch” [55].",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 48,
      "context" : "2 Counterexample-guided inductive synthesis (CEGIS) [55]: CEGIS was originally proposed as an algorithmic method for program synthesis where the specification is given as a reference program and the concept class is defined using a partial program, also referred to as a “sketch” [55].",
      "startOffset" : 280,
      "endOffset" : 284
    }, {
      "referenceID" : 28,
      "context" : ", [35]) and other ways of providing syntax guidance; see [1] for a more detailed treatment.",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 0,
      "context" : ", [35]) and other ways of providing syntax guidance; see [1] for a more detailed treatment.",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 48,
      "context" : "4 of [55] and Fig.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 28,
      "context" : "3 of [35]).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 28,
      "context" : ", see [35]).",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 23,
      "context" : "3 Oracle-guided program synthesis using distinguishing inputs [30]: Our third example is an approach to program synthesis that uses distinguishing inputs when a complete specification is either unavailable or it is expensive to verify a candidate program against its specification [30].",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 23,
      "context" : "3 Oracle-guided program synthesis using distinguishing inputs [30]: Our third example is an approach to program synthesis that uses distinguishing inputs when a complete specification is either unavailable or it is expensive to verify a candidate program against its specification [30].",
      "startOffset" : 281,
      "endOffset" : 285
    }, {
      "referenceID" : 37,
      "context" : "Significant effort has been made on improving validation engines to produce counterexamples which aid debugging by localizing the error [44, 14].",
      "startOffset" : 136,
      "endOffset" : 144
    }, {
      "referenceID" : 12,
      "context" : "Significant effort has been made on improving validation engines to produce counterexamples which aid debugging by localizing the error [44, 14].",
      "startOffset" : 136,
      "endOffset" : 144
    }, {
      "referenceID" : 8,
      "context" : "This is motivated by the use of bounds in formal verification such as bounded model checking [10] and bug-finding in concurrent programs [7] using bounds on context switches.",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 6,
      "context" : "This is motivated by the use of bounds in formal verification such as bounded model checking [10] and bug-finding in concurrent programs [7] using bounds on context switches.",
      "startOffset" : 137,
      "endOffset" : 140
    }, {
      "referenceID" : 54,
      "context" : "This notion of finite memory is similar to that used classically for language learning from examples [62].",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 10,
      "context" : "We show that the complexity of these techniques is related to well-studied notions in learning theory such as the Vapnik-Chervonenkis dimension [12] and the teaching dimension [20].",
      "startOffset" : 144,
      "endOffset" : 148
    }, {
      "referenceID" : 15,
      "context" : "We show that the complexity of these techniques is related to well-studied notions in learning theory such as the Vapnik-Chervonenkis dimension [12] and the teaching dimension [20].",
      "startOffset" : 176,
      "endOffset" : 180
    }, {
      "referenceID" : 47,
      "context" : "[54, 55, 30, 56, 37, 58].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 48,
      "context" : "[54, 55, 30, 56, 37, 58].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 23,
      "context" : "[54, 55, 30, 56, 37, 58].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 30,
      "context" : "[54, 55, 30, 56, 37, 58].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 50,
      "context" : "[54, 55, 30, 56, 37, 58].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 44,
      "context" : "[51, 23].",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 17,
      "context" : "[51, 23].",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 0,
      "context" : "The recent work on syntax-guided synthesis (SyGuS) [1] is an attempt to capture these disparate efforts in a common theoretical formalism.",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 3,
      "context" : "The reader is referred to Angluin’s excellent papers on the topic for more background [4, 5].",
      "startOffset" : 86,
      "endOffset" : 92
    }, {
      "referenceID" : 4,
      "context" : "The reader is referred to Angluin’s excellent papers on the topic for more background [4, 5].",
      "startOffset" : 86,
      "endOffset" : 92
    }, {
      "referenceID" : 22,
      "context" : "Similar techniques have been studied elsewhere in literature [29, 63, 11, 2].",
      "startOffset" : 61,
      "endOffset" : 76
    }, {
      "referenceID" : 55,
      "context" : "Similar techniques have been studied elsewhere in literature [29, 63, 11, 2].",
      "startOffset" : 61,
      "endOffset" : 76
    }, {
      "referenceID" : 9,
      "context" : "Similar techniques have been studied elsewhere in literature [29, 63, 11, 2].",
      "startOffset" : 61,
      "endOffset" : 76
    }, {
      "referenceID" : 1,
      "context" : "Similar techniques have been studied elsewhere in literature [29, 63, 11, 2].",
      "startOffset" : 61,
      "endOffset" : 76
    }, {
      "referenceID" : 32,
      "context" : "[39].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "A detailed survey is presented in [27] and [38].",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 31,
      "context" : "A detailed survey is presented in [27] and [38].",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 33,
      "context" : "Lange and Zilles [40] relate Angluin-style query-based learning with Gold-style learning.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 15,
      "context" : "This part of our work is related to previous work on the complexity of teaching in exact learning of concepts by Goldman and Kearns [20].",
      "startOffset" : 132,
      "endOffset" : 136
    }, {
      "referenceID" : 15,
      "context" : "Exact bounds on teaching dimensions for specific concept classes such as orthogonal rectangles, monotonic decision trees, monomials, binary relations and total orders have been previously presented in literature [20, 21].",
      "startOffset" : 212,
      "endOffset" : 220
    }, {
      "referenceID" : 16,
      "context" : "Exact bounds on teaching dimensions for specific concept classes such as orthogonal rectangles, monotonic decision trees, monomials, binary relations and total orders have been previously presented in literature [20, 21].",
      "startOffset" : 212,
      "endOffset" : 220
    }, {
      "referenceID" : 46,
      "context" : "[53] also introduced a notion of teachability in which a concept class is teachable by examples if there exists a polynomial size sample under which all consistent learners will exactly identify the target concept.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 43,
      "context" : "[50] also consider a model of learning with a helpful teacher.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 42,
      "context" : "Languages and Programs: We also use standard definitions from computability theory which relate languages and programs [49].",
      "startOffset" : 119,
      "endOffset" : 123
    }, {
      "referenceID" : 48,
      "context" : "Intuitively, a function TEMPLATE defines an encoding of the space of candidate programs similar to encodings proposed in the literature such as those on program sketching [55] and component interconnection encoding [30].",
      "startOffset" : 171,
      "endOffset" : 175
    }, {
      "referenceID" : 23,
      "context" : "Intuitively, a function TEMPLATE defines an encoding of the space of candidate programs similar to encodings proposed in the literature such as those on program sketching [55] and component interconnection encoding [30].",
      "startOffset" : 215,
      "endOffset" : 219
    }, {
      "referenceID" : 28,
      "context" : "[35]) where more behaviors can be sampled over time.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 48,
      "context" : "1CEGIS techniques in literature [55, 35] initiate search for correct program using positive examples and use specification to obtain positive examples corresponding to counterexamples.",
      "startOffset" : 32,
      "endOffset" : 40
    }, {
      "referenceID" : 28,
      "context" : "1CEGIS techniques in literature [55, 35] initiate search for correct program using positive examples and use specification to obtain positive examples corresponding to counterexamples.",
      "startOffset" : 32,
      "endOffset" : 40
    }, {
      "referenceID" : 8,
      "context" : "Bounded model-checking [10] returns a counterexample trace for an incorrect design if it can find a counterexample of length less than the specified constant bound.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 6,
      "context" : "Verification of concurrent programs by bounding the number of context switches [7] is another example of the bounded verification technique.",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 21,
      "context" : "As we recover the positive examples, we run a Gold style algorithm for identifying finite languages [28] to converge to the correct language.",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 48,
      "context" : "The counterexample guided inductive synthesis approach [55] for bitvector sketches and oracle guided inductive synthesis using distinguishing inputs [30] for programs composed of a finite library of components are examples of OGIS synthesis techniques applied to finite language classes.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 23,
      "context" : "The counterexample guided inductive synthesis approach [55] for bitvector sketches and oracle guided inductive synthesis using distinguishing inputs [30] for programs composed of a finite library of components are examples of OGIS synthesis techniques applied to finite language classes.",
      "startOffset" : 149,
      "endOffset" : 153
    }, {
      "referenceID" : 15,
      "context" : "We analyze the complexity of synthesis for finite language classes and discuss its relation to the notion of teaching dimension from the concept learning literature [20].",
      "startOffset" : 165,
      "endOffset" : 169
    }, {
      "referenceID" : 23,
      "context" : "This connection between synthesis of languages from finite classes and teaching of concepts was first discussed in [30].",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 15,
      "context" : "[20, 21] proposed teaching dimension as a measure to study computational complexity of learning.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 16,
      "context" : "[20, 21] proposed teaching dimension as a measure to study computational complexity of learning.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 15,
      "context" : "[20, 21], the basic goal of the teacher is to help the learner identify the target concept c∗ ∈ C by providing an example sequence from E.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 16,
      "context" : "[20, 21], the basic goal of the teacher is to help the learner identify the target concept c∗ ∈ C by providing an example sequence from E.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 15,
      "context" : "1 (adapted from [20]) An example sequence is a sequence of labeled examples from E, where the labels are given by some underlying specification.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 52,
      "context" : "One of these results relates the teaching dimension to a second metric for measuring complexity of learning, namely the Vapnik-Chervonenkis (VC) dimension [60].",
      "startOffset" : 155,
      "endOffset" : 159
    }, {
      "referenceID" : 52,
      "context" : "2 [60] Let E be the domain of examples and c be a concept from the class C .",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 10,
      "context" : "[12] have shown that the VC dimension of a concept class characterizes the number of examples required for learning any concept in the class under the distribution-free or probably approximately correct (PAC) model of Valiant [59].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 51,
      "context" : "[12] have shown that the VC dimension of a concept class characterizes the number of examples required for learning any concept in the class under the distribution-free or probably approximately correct (PAC) model of Valiant [59].",
      "startOffset" : 226,
      "endOffset" : 230
    }, {
      "referenceID" : 15,
      "context" : "Vapnik-Chervonenkis dimension are discussed at length by Goldman and Kearns [20].",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 15,
      "context" : "The following theorems from [20] provides lower and upper bound on the teaching dimension of a finite concept class in terms of the size of the concept class and its VC-dimension.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 15,
      "context" : "3 [20] The teaching dimension T D(C ) of any concept class C satisfies the following upper and lower bounds: VC(C )/ log(|C |)≤ T D(C )≤ |C |−1",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 15,
      "context" : "Moreover, Goldman and Kearns [20] exhibit a concept class for which the upper bound is tight.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 56,
      "context" : "But teaching dimension of formal concept classes such as programs in the while [64] language with only linear arithmetic over integers is not known.",
      "startOffset" : 79,
      "endOffset" : 83
    } ],
    "year" : 2016,
    "abstractText" : "Formal synthesis is the process of generating a program satisfying a high-level formal specification. In recent times, effective formal synthesis methods have been proposed based on the use of inductive learning. We refer to this class of methods that learn programs from examples as formal inductive synthesis. In this paper, we present a theoretical framework for formal inductive synthesis. We discuss how formal inductive synthesis differs from traditional machine learning. We then describe oracle-guided inductive synthesis (OGIS), a framework that captures a family of synthesizers that operate by iteratively querying an oracle. An instance of OGIS that has had much practical impact is counterexample-guided inductive synthesis (CEGIS). We present a theoretical characterization of CEGIS for learning any program that computes a recursive language. In particular, we analyze the relative power of CEGIS variants where the types of counterexamples generated by the oracle varies. We also consider the impact of bounded versus unbounded memory available to the learning algorithm. In the special case where the universe of candidate programs is finite, we relate the speed of convergence to the notion of teaching dimension studied in machine learning theory. Altogether, the results of the paper take a first step towards a theoretical foundation for the emerging field of formal inductive synthesis.",
    "creator" : "LaTeX with hyperref package"
  }
}