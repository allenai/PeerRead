{
  "name" : "1608.03665.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Learning Structured Sparsity in Deep Neural Networks",
    "authors" : [ "Wei Wen", "Chunpeng Wu", "Yandan Wang" ],
    "emails" : [ "wew57@pitt.edu", "chw127@pitt.edu", "yaw46@pitt.edu", "yic52@pitt.edu", "hal66@pitt.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Deep neural networks (DNN), especially deep convolutional neural networks (CNN), made remarkable success in visual tasks[1][2][3][4][5] by leveraging large-scale networks learning from a huge volume of data. Deployment of such big models, however, is computation-intensive and memory-intensive. To reduce computation cost, many studies are performed to compress the scale of DNN, including sparsity regularization[6], connection pruning[7][8] and low rank approximation [9][10][11][12][13]. Sparsity regularization and connection pruning approaches, however, often produce non-structured random connectivity in DNN and thus, irregular memory access that adversely impacts practical acceleration in hardware platforms. Figure 1 depicts practical speedup of each layer of a AlexNet, which is non-structurally sparsified by `1-norm. Compared to original model, the accuracy loss of the sparsified model is controlled within 2%. Because of the poor data locality associated with the scattered weight distribution, the achieved speedups are either very limited or negative even the actual sparsity is high, say, >95%. We define sparsity as the ratio of zeros in this paper. In recently proposed low rank approximation approaches, the DNN is trained first and then each trained weight tensor is decomposed and approximated by a product of smaller factors. Finally, fine-tuning is performed to restore the model accuracy. Low rank approximation is able to achieve practical speedups because it coordinates model parameters in dense matrixes and avoids the locality problem of non-structured sparsity regularization. However, low rank approximation can only obtain the compact structure within each layer, and the structures of the layers are fixed during fine-tuning ar X\niv :1\n60 8.\n03 66\n5v 1\n[ cs\n.N E\n] 1\n2 A\nsuch that costly reiterations of decomposing and fine-tuning are required to find an optimal weight approximation for performance speedup and accuracy retaining.\nInspired by the facts that (1) there is redundancy across filters and channels [11]; (2) shapes of filters are usually fixed as cuboid but enabling arbitrary shapes can potentially eliminate unnecessary computation imposed by this fixation; and (3) depth of the network is critical for classification but deeper layers cannot always guarantee a lower error because of the exploding gradients and degradation problem [5], we propose Structured Sparsity Learning (SSL) method to directly learn a compressed structure of deep CNNs by group Lasso regularization during the training. SSL is a generic regularization to adaptively adjust mutiple structures in DNN, including structures of filters, channels, and filter shapes within each layer, and structure of depth beyond the layers. SSL combines structure regularization (on DNN for classification accuracy) with locality optimization (on memory access for computation efficiency), offering not only well-regularized big models with improved accuracy but greatly accelerated computation (e.g. 5.1× on CPU and 3.1× on GPU for AlexNet)."
    }, {
      "heading" : "2 Related works",
      "text" : "Connection pruning and weight sparsifying. Han et al. [7][8] reduced number of parameters of AlexNet by 9× and VGG-16 by 13× using connection pruning. Since most reduction is achieved on fully-connected layers, the authors obtained 3× to 4× layer-wise speedup for fully-connected layers. However, no practical speedups of convolutional layers are observed because of the issue shown in Figure 1. As convolution is the computational bottleneck and many new DNNs use fewer fully-connected layers, e.g., only 3.99% parameters of ResNet-152 in [5] are from fully-connected layers, compression and acceleration on convolutional layers become essential. Liu et al. [6] achieved >90% sparsity of convolutional layers in AlexNet with 2% accuracy loss, and bypassed the issue shown in Figure 1 by hardcoding the sparse weights into program, achieving layer-wise 4.59× speedup on a CPU. In this work, we also focus on convolutional layers. Compared to the above techniques, our SSL method can coordinate sparse weights in adjacent memory space and achieve higher speedups with the same accuracy. Note that hardware and program optimizations can further boost the system performance on top of the level of SSL but are not covered in this work.\nLow rank approximation. Denil et al. [9] predicted 95% parameters in a DNN by exploiting the redundancy across filters and channels. Inspired by it, Jaderberg et al. [11] achieved 4.5× speedup on CPUs for scene text character recognition and Denton et al. [10] achieved 2× speedups on both CPUs and GPUs for the first two layers. Both of the works used Low Rank Approximation (LRA) with ∼1% accuracy drop. [13][12] improved and extended LRA to larger DNNs. However, the network structure compressed by LRA is fixed; reiterations of decomposing, training/fine-tuning, and cross-validating are still needed to find an optimal structure for accuracy and speed trade-off. As number of hyper-parameters in LRA method increases linearly with layer depth [10][13], the search space increases linearly or even polynomially for very deep DNNs. Comparing to LRA, our contributions are: (1) SSL can dynamically optimize the compactness of DNN structure with only one hyper-parameter and no reiterations; (2) besides the redundancy within the layers, SSL also exploits the necessity of deep layers and reduce them; (3) DNN filters regularized by SSL have lower rank approximation, so it can work together with LRA for more efficient model compression.\nModel structure learning. Group Lasso [14] is an efficient regularization to learn sparse structures. Kim et al. [15] used group Lasso to regularize the structure of correlation tree for multi-task regression problem and reduced prediction errors. Liu et al. [6] utilized group Lasso to constrain the scale of the structure of LRA. To adapt DNN structure to different databases, Feng et al. [16] learned\n                                                                                                                                                                                                                                                                                                                                                                                                                                       \n     \n1\nW (l):,cl,:,: (2)\nW (l):,cl,ml,kl (3)\nW (l) (4)\n1\n1\n1\nthe appropriate number of filters in DNN. Different from these prior arts, we apply group Lasso to regularize multiple DNN structures (filters, channels, filter shapes, and layer depth)."
    }, {
      "heading" : "3 Structured Sparsity Learning Method for DNNs",
      "text" : "We focus mainly on the Structured Sparsity Learning (SSL) on convolutional layers to regularize the structure of DNNs. We first propose a generic method to regularize structures of DNN in Section 3.1, and then specify the method to structures of filters, channels, filter shapes and depth in section 3.2. Variants of formulations are also discussed from computational efficiency viewpoint in Section 3.3."
    }, {
      "heading" : "3.1 Proposed structured sparsity learning for generic structures",
      "text" : "Suppose weights of convolutional layers in a DNN form a sequence of 4-D tensors W (l) ∈ RNl×Cl×Ml×Kl , where Nl, Cl, Ml and Kl are the dimensions of the l-th (1 ≤ l ≤ L) weight tensor along the axes of filter, channel, spatial height and spatial width, respectively. L denotes the number of convolutional layers. Then the proposed generic optimization target of a DNN with structured sparsity regularization can be formulated as:\nE(W ) = ED(W ) + λ ·R(W ) + λg · L∑\nl=1\nRg ( W (l) ) . (1)\nHere W represents the collection of all weights in the DNN; ED(W ) is the loss on data; R(·) is non-structured regularization applying on every weight, e.g., `2-norm; and Rg(·) is the structured sparsity regularization on each layer. Because Group Lasso can effectively zero out all weights in some groups [14][15], we adopt it in our SSL. The regularization of group Lasso on a set of weights w can be represented as Rg(w) = ∑G g=1 ||w(g)||g, where w(g) is a group of partial weights in w and G is the total number of groups. Different groups may overlap. Here || · ||g is the group Lasso, or\n||w(g)||g = √∑|w(g)|\ni=1\n( w\n(g) i\n)2 , where |w(g)| is the number of weights in w(g)."
    }, {
      "heading" : "3.2 Structured sparsity learning for structures of filters, channels, filter shapes and depth",
      "text" : "In SSL, the learned “structure” is decided by the way of splitting groups of w(g). We investigate and formulate the filer-wise, channel-wise, shape-wise, and depth-wise structured sparsity in Figure 2. For simplicity, the R(·) term of Eq. (1) is omitted in the following formulation expressions.\nPenalizing unimportant filers and channels. Suppose W (l)nl,:,:,: is the nl-th filter and W (l) :,cl,:,: is the cl-th channel of all filters in the l-th layer. The optimization target of learning the filter-wise and channel-wise structured sparsity can be defined as\nE(W ) = ED(W ) + λn · L∑\nl=1  Nl∑ nl=1 ||W (l)nl,:,:,:||g + λc · L∑ l=1  Cl∑ cl=1 ||W (l):,cl,:,:||g  . (2)\nAs indicated in Eq. (2), our approach tends to remove less important filters and channels. Note that zeroing out a filter in the l-th layer results in a dummy zero output feature map, which in turn makes a corresponding channel in the (l+ 1)-th layer useless. Hence, we combine the filter-wise and channel-wise structured sparsity in the learning simultaneously.\nLearning arbitrary shapes of filers. As illustrated in Figure 2, W (l):,cl,ml,kl denotes the vector of all corresponding weights located at spatial position of (ml, kl) in the 2D filters across the cl-th channel. Thus, we define W (l):,cl,ml,kl as the shape fiber related to learning arbitrary filter shape because a homogeneous non-cubic filter shape can be learned by zeroing out some shape fibers. The optimization target of learning shapes of filers becomes:\nE(W ) = ED(W ) + λs · L∑\nl=1  Cl∑ cl=1 Ml∑ ml=1 Kl∑ kl=1 ||W (l):,cl,ml,kl ||g  . (3) Regularizing layer depth. We also explore the depth-wise sparsity to regularize the depth of DNNs in order to improve accuracy and reduce computation cost. The corresponding optimization target is E(W ) = ED(W ) + λd · ∑L l=1 W\n(l). Different from other discussed sparsification techniques, zeroing out all the filters in a layer will cut off the message propagation in the DNN so that the output neurons cannot perform any classification. Inspired by the structure of highway networks [17] and deep residual networks [5], we propose to leverage the shortcuts across layers to solve this issue. As illustrated in Figure 2, even when SSL removes an entire unimportant layers, feature maps will still be forwarded through the shortcut."
    }, {
      "heading" : "3.3 Structured sparsity learning for computationally efficient structures",
      "text" : "All proposed schemes in section 3.2 can learn a compact DNN for computation cost reduction. Moreover, some variants of the formulations of these schemes can directly learn structures that can be efficiently computed.\n2D-filter-wise sparsity for convolution. 3D convolution in DNNs essentially is a composition of 2D convolutions. To perform efficient convolution, we explored a fine-grain variant of filter-wise sparsity, namely, 2D-filter-wise sparsity, to spatially enforce group Lasso on each 2D filter of W (l)nl,cl,:,:. The saved convolution is proportional to the percentage of the removed 2D filters. The fine-grain version of filter-wise sparsity can more efficiently reduce the computation associated with convolution: Because the group sizes are much smaller and thus the weight updating gradients are shaper, it helps group Lasso to quickly obtain a high ratio of zero groups for a large-scale DNN.\nCombination of filter-wise and shape-wise sparsity for GEMM. Convolutional computation in DNNs is commonly converted to modality of GEneral Matrix Multiplication (GEMM) by lowering weight tensors and feature tensors to matrices [18]. For example, in Caffe [19], a 3D filter W (l)nl,:,:,: is reshaped to a row in the weight matrix where each column is the collection of weights W (l):,cl,ml,kl related to shape-wise sparsity. Combining filter-wise and shape-wise sparsity can directly reduce the dimension of weight matrix in GEMM by removing zero rows and columns. In this context, we use row-wise and column-wise sparsity as the interchangeable terminology of filter-wise and shape-wise sparsity, respectively."
    }, {
      "heading" : "4 Experiments",
      "text" : "We evaluated the effectiveness of our SSL using published models on three databases – MNIST, CIFAR-10, and ImageNet. Without explicit explanation, SSL starts with the network whose weights are initialized by the baseline, and speedups are measured in matrix-matrix multiplication by Caffe in a single-thread Intel Xeon E5-2630 CPU .\n4.1 LeNet and multilayer perceptron on MNIST\nIn the experiment of MNIST, we examined the effectiveness of SSL in two types of networks: LeNet [20] implemented by Caffe and a multilayer perceptron (MLP) network. Both networks were trained without data augmentation.\nLeNet: When applying SSL to LeNet, we constrain the network with filter-wise and channel-wise sparsity in convolutional layers to penalize unimportant filters and channels. Table 1 summarizes the remained filters and channels, floating-point operations (FLOP), and practical speedups. In the table, LeNet 1 is the baseline and the others are the results after applying SSL in different strengths of structured sparsity regularization. The results show that our method achieves the similar error (±0.1%) with much fewer filters and channels, and saves significant FLOP and computation time. To demonstrate the impact of SSL on the structures of filters, we present all learned conv1 filters in Figure 3. It can be seen that most filters in LeNet 2 are entirely zeroed out except for five most important detectors of stroke patterns that are sufficient for feature extraction. The accuracy of LeNet 3 (that further removes the weakest and redundant stroke detector) drops only 0.2% from that of LeNet 2. Compared to the random and blurry filter patterns in LeNet 1 that resulted from the high freedom of parameter space, the filters in LeNet 2 & 3 are regularized and converge to smoother and more natural patterns. This explains why our proposed SSL obtains the same-level accuracy but has much less filters. The smoothness of the filters are also observed in the deeper layers.\nThe effectiveness of the shape-wise sparsity on LeNet is summarized in Table 2. The baseline LeNet 1 has conv1 filters with a regular 5× 5 square (size = 25) while LeNet 5 reduces the dimension that can be constrained by a 2× 4 rectangle (size = 7). The 3D shape of conv2 filters in the baseline is also regularized to the 2D shape in LeNet 5 within only one channel, indicating that only one filter in conv1 is needed. This fact significantly saves FLOP and computation time.\nMLP: Besides convolutional layers, our proposed SSL can be extended to learn the structure (i.e. the number of neurons) of fully-connected layers. We enforce the group Lasso regularization on all the input (or output) connections of each neuron. A neuron whose input connections are all zeroed out can degenerate to a bias neuron in the next layer; similarly, a neuron can degenerate to a removable dummy neuron if all of its output connections are zeroed out. Figure 4(a) summarizes the learned structure and FLOP of different MLP networks. The results show that SSL can not only remove hidden neurons but also discover the sparsity of images. For example, Figure 4(b) depicts the number of connections of each input neuron in MLP 2, where 40.18% of input neurons have zero connections and they concentrate at the boundary of the image. Such a distribution is consistent with our intuition: handwriting digits are usually written in the center and pixels close to the boundary contain little discriminative classification information.\nTable 2: Results after learning filter shapes in LeNet LeNet # Error Filter size § Channel # FLOP Speedup 1 (baseline) 0.9% 25–500 1–20 100%–100% 1.00⇥–1.00⇥ 4 0.8% 21–41 1–2 8.4%–8.2% 2.33⇥–6.93⇥ 5 1.0% 7–14 1–1 1.4%–2.8% 5.19⇥–10.82⇥ § The sizes of filters after removing zero shape fibers, in the order of conv1–conv2 0 50 100 0 10 20 30 40 50 % R ec on st ru ct io n er ro r conv1 conv2 0 50 100 0 10 20 30 40 50 % ranks conv1 conv2 conv3 0 50 100 0 10 20 30 40 50 conv1 conv2 conv3 conv4 conv5 Figure 4: The normalized reconstructure error of weight matrix vs. the percent of ranks. Principal Component Analysis (PCA) is utilized to explore the redundancy among filters. % ranks of eigenvectors corresponding to the largest eigenvalues are selected as basis to perform low rank approximation. Left: LeNet 2 in Table 1; middle: ConvNet 2 in Table 4; right: AlexNet 4 in Table 5. Dash lines indicate baselines and solid lines indicate results of SSL. detectors of stroke patterns which are sufficient for feature extraction. The accuracy of LeNet 3170 (that further removes one weakest and one redundant stroke detector) compared with LeNet 2 drops171 only 0.2%. Although the training processes of three networks are independent, the corresponding172 regularized filters in LeNet 2 and LeNet 3 demonstrate very high similarity and represent certain level173 of alikeness to those in LeNet 1. Comparing with random and blurry filter patterns in LeNet 1 resulted174 from the high freedom of parameter space, the filters in LeNet 2 & 3 are regularized through the175 filter-wise and channel-wise sparsity and therefore converge at smoother and more natural patterns.176 This explains why our proposed SSL obtains the same-level accuracy but having much less filters.177 These regularity and similarity phenomena are also observed in deeper layers. Different from low178 rank decomposition which only explore the redundancy and does not change the rank, SSL can reduce179 the redundancy as shown in Figure 4.180 We also explore the effectiveness of the shape-wise sparsity on LeNet in Table 2. The baseline LeNet181 1 has a regular 5⇥ 5 square size of conv1 filters, while LeNet 5 reduces the dimension to less than182 2⇥ 4. And the 3D shape of filters in conv2 of LeNet 1 are regularized to 2D shape of LeNet 5 with183 only one channel, indicating that only one filter in conv1 is needed. This saves significant FLOP and184 computing time.185\nMLP: Besides convolutional layers, our proposed SSL can be extended to learn the structure (i.e.186 the number of neurons) in fully-connected layers. Here, the baseline MLP network composed of187 two hidden layers with 500 and 300 neurons respectively obtains a test error of 1.43%. We enforced188 the group Lasso regularization on all the input (or output) connections of every neuron, including189 those of the input layer. Note that a neuron with all the input connections zeroed out degenerate190 to a bias neuron in the next layer; similarly, a neuron degenerates to a removable dummy neuron191 if all of its output connections are zeroed out. As such, the computation of GEneral Matrix Vector192 (GEMV) product in fully-connected layers can be significantly reduced. Table 3 summarizes the193\nTable 3: Learning the number of neurons in multi-layer perceptron\nMLP # Error Neuron # per layer § FLOP per layer §\n1 (baseline) 1.43% 784–500–300–10 100%–100%–100% 2 1.34% 469–294–166–10 35.18%–32.54%–55.33% 3 1.53% 434–174–78–10 19.26%–9.05%–26.00%\n§In the order of input layer–hidden layer 1–hidden layer 2–output layer\n6\n(a)\n1 28\n1\n28 0\n291\n(b)\nFigure 4: (a) Results of learning the number of neurons in MLP. (b) the connection numbers of input neurons (i.e. pixels) in MLP 2 after SSL.\n4.2 ConvNet and ResNet on CIFAR-10\nWe implemented the ConvNet of [1] and deep residual networks (ResNet) [5] on CIFAR-10. When regularizing filters, channels, and filter shapes, the results and observations of both networks are similar to that of the MNIST experiment. Moreover, we simultaneously learn the filter-wise and shape-wise sparsity to reduce the dimension of weight matrix in GEMM of ConvNet. We also learn the depth-wise sparsity of ResNet to regularize the depth of the DNNs.\nConvNet: We use the network from Alex Krizhevsky et al. [1] as the baseline and implement it using Caffe. All the configurations remain the same as the original implementation except that we added a dropout layer with a ratio of 0.5 in the fully-connected layer to avoid over-fitting. ConvNet is trained without data augmentation. Table 3 summarizes the results of three ConvNet networks. Here, the row/column sparsity of a weight matrix is defined as the percentage of all-zero rows/columns. Figure 5 shows their learned conv1 filters. In Table 3, SSL can reduce the size of weight matrix in ConvNet 2 by 50%, 70.7% and 36.1% for each convolutional layer and achieve good speedups without accuracy drop. Surprisingly, without SSL, four conv1 filters of the baseline are actually all-zeros as shown in Figure 5, demonstrating the great potential of filter sparsity. When SSL is applied, half of conv1 filters in ConvNet 2 can be zeroed out without accuracy drop.\nOn the other hand, in ConvNet 3, SSL achieves 1.0% (±0.16%) lower error with a model even smaller than the baseline. In this scenario, SSL performs as a structure regularization to dynamically learn a better network structure (including the number of filters and filer shapes) to reduce the error.\nResNet: To investigate the necessary depth of DNNs required by SSL, we use a 20-layer deep residual networks (ResNet-20) proposed in [5] as the baseline. The network has 19 convolutional layers and 1 fully-connected layer. Identity shortcuts are utilized to connect the feature maps with the same dimension while 1×1 convolutional layers are chosen as shortcuts between the feature maps with different dimensions. Batch normalization [21] is adopted after convolution and before activation. We use the same data augmentation and training hyper-parameters as that in [5]. The final error of baseline is 8.82%. In SSL, the depth of ResNet-20 is regularized by depth-wise sparsity. Group Lasso regularization is only enforced on the convolutional layers between each pair of shortcut endpoints, excluding the first convolutional layer and all convolutional shortcuts. After SSL converges, layers with all zero weights are removed and the net is finally fine-tuned with a base learning rate of 0.01, which is lower than that (i.e., 0.1) in the baseline.\n12 14 16 18 20 7\n8\n9\n10\nSSL−ResNet−#\n% e\nrr or\nSSL ResNet−20 ResNet−32\n12 14 16 18 20 0\n2\n4\n6\n8\n10\n12\n14\n16\n18 20\nSSL−ResNet−#\n# co\nnv la\nye rs\n32×32 16×16 8×8\n12 14 16 18 20 7\n8\n9\n10\nSSL−ResNet−#\n% e\nrr or\nSSL ResNet−20 ResNet−32\n12 14 16 18 20 0 2 4 6 8\n10 12 14 16 18 20\nSSL−ResNet−#\n# co\nnv la\nye rs\n32×32 16×16 8×8\nFigure 6: Error vs. layer number after depth regularization by SSL. ResNet-# is the original ResNet in [5] with # layers. SSL-ResNet-# is the depth-regularized ResNet by SSL with # layers, including the last fully-connected layer. 32×32 indicates the convolutional layers with an output map size of 32×32, and so forth.\nFigure 6 plots the trend of the error vs. the number of layers under different strengths of depth regularizations. Compared with original ResNet in [5], SSL learns a ResNet with 14 layers (SSLResNet-14) that reaching a lower error than the one of the baseline with 20 layers (ResNet-20); SSL-ResNet-18 and ResNet-32 achieve an error of 7.40% and 7.51%, respectively. This result implies that SSL can work as a depth regularization to improve classification accuracy. Note that SSL can efficiently learn shallower DNNs without accuracy loss to reduce computation cost; however, it does not mean the depth of the network is not important. The trend in Figure 6 shows that the test error generally declines as more layers are preserved. A slight error rise of SSL-ResNet-20 from SSL-ResNet-18 shows the suboptimal selection of the depth in the group of “32×32”.\n4.3 AlexNet on ImageNet\nTo show the generalization of our method to large scale DNNs, we evaluate SSL using AlexNet with ILSVRC 2012. CaffeNet [19] – the replication of AlexNet [1] with mirror changes, is used in our experiment. All training images are rescaled to the size of 256×256. A 227×227 image is randomly cropped from each scaled image and mirrored for data augmentation and only the center crop is used for validation. The final top-1 validation error is 42.63%. In SSL, AlexNet is first trained with structure regularization; when it converges, zero groups are removed to obtain a DNN with the new structure; finally, the network is fine-tuned without SSL to regain the accuracy.\nWe first studied 2D-filter-wise and shape-wise sparsity by exploring the trade-offs between computation complexity and classification accuracy. Figure 7(a) shows the 2D-filter sparsity (the ratio between the removed 2D filters and total 2D filters) and the saved FLOP of 2D convolutions vs. the validation error. In Figure 7(a), deeper layers generally have higher sparsity as the group size shrinks and the number of 2D filters grows. 2D-filter sparsity regularization can reduce the total FLOP by 30%–40% without accuracy loss or reduce the error of AlexNet by ∼1% down to 41.69% by retaining the original number of parameters. Shape-wise sparsity also obtains similar results – In Table 4, for\nexample, AlexNet 5 achieves on average 1.4× layer-wise speedup on both CPU and GPU without accuracy loss after shape regularization; The top-1 error can also be reduced down to 41.83% if the parameters are retained. In Figure 7(a), the obtained DNN with the lowest error has a very low sparsity, indicating that the number of parameters in a DNN is still important to maintain learning capacity. In this case, SSL works as a regularization to add restriction of smoothness to the model in order to avoid over-fitting. Figure 7(b) compares the results of dimensionality reduction of weight tensors in the baseline and our SSL-regularized AlexNet. The results show that the smoothness restriction enforces parameter searching in lower-dimensional space and enables lower rank approximation of the DNNs. Therefore, SSL can work together with low rank approximation to achieve even higher model compression.\nBesides the above analyses, the computation efficiencies of structured sparsity and non-structured sparsity are compared in Caffe using standard off-the-shelf libraries, i.e., Intel Math Kernel Library on CPU and CUDA cuBLAS and cuSPARSE on GPU. We use SSL to learn a AlexNet with high column-wise and row-wise sparsity as the representative of structured sparsity method. `1-norm is selected as the representative of non-structured sparsity method instead of connection pruning in [7] because `1-norm get a higher sparsity on convolutional layers as the results of AlexNet 3 and AlexNet 4 depicted in Table 4. Speedups achieved by SSL are measured by subroutines of GEMM where nonzero rows and columns in each weight matrix are concatenated in consecutive memory space. Note that compared to GEMM, the overhead of concatenation can be ignored. To measure the speedups of `1-norm, sparse weight matrices are stored in the format of Compressed Sparse Row (CSR) and computed by sparse-dense matrix multiplication subroutines.\nTable 4 compares the obtained sparsity and speedups of `1-norm and SSL on CPU (Intel Xeon) and GPU (GeForce GTX TITAN Black) under approximately the same errors, e.g., with acceptable or no accuracy loss. For a fair comparison, after `1-norm regularization, the DNN is also finetuned by disconnecting all zero-weighted connections so that 1.39% accuracy is recovered for the AlexNet 1. Our experiments show that the DNNs require a very high non-structured sparsity to achieve a reasonable speedup (The speedups are even negative when the sparsity is low). SSL, however, can always achieve positive speedups. With an acceptable accuracy loss, our SSL achieves on average 5.1× and 3.1× layer-wise acceleration on CPU and GPU, respectively. Instead, `1-norm achieves on average only 3.0× and 0.9× layer-wise acceleration on CPU and GPU, respectively. We note that at the same accuracy, our average speedup is indeed higher than that of [6] which adopts heavy hardware customization to overcome the negative impact of non-structured sparsity. Figure 7(c) shows the speedups of `1-norm and SSL on various platforms, including both GPU (Quadro, Tesla and Titan) and CPU (Intel Xeon E5-2630). SSL can achieve on average ∼ 3× speedup on GPU while non-structured sparsity obtain no speedup on GPU platforms. On CPU platforms, both methods can\nachieve good speedups and the benefit grows as the processors become weaker. Nonetheless, SSL can always achieve averagely ∼ 2× speedup compared to non-structured sparsity."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In this work, we have proposed a Structured Sparsity Learning (SSL) method to regularize filter, channel, filter shape, and depth structures in deep neural networks (DNN). Our method can enforce the DNN to dynamically learn more compact structures without accuracy loss. The structured compactness of the DNN achieves significant speedups for the DNN evaluation both on CPU and GPU with off-the-shelf libraries. Moreover, a variant of SSL can be performed as structure regularization to improve classification accuracy of state-of-the-art DNNs."
    } ],
    "references" : [ {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "Alex Krizhevsky", "Ilya Sutskever", "Geoffrey E. Hinton" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2012
    }, {
      "title" : "Rich feature hierarchies for accurate object detection and semantic segmentation",
      "author" : [ "Ross Girshick", "Jeff Donahue", "Trevor Darrell", "Jitendra Malik" ],
      "venue" : "In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR),",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2014
    }, {
      "title" : "Very deep convolutional networks for large-scale image recognition",
      "author" : [ "Karen Simonyan", "Andrew Zisserman" ],
      "venue" : "arXiv preprint arXiv:1409.1556,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2014
    }, {
      "title" : "Going deeper with convolutions",
      "author" : [ "Christian Szegedy", "Wei Liu", "Yangqing Jia", "Pierre Sermanet", "Scott Reed", "Dragomir Anguelov", "Dumitru Erhan", "Vincent Vanhoucke", "Andrew Rabinovich" ],
      "venue" : "arXiv preprint arXiv:1409.4842,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2015
    }, {
      "title" : "Deep residual learning for image recognition",
      "author" : [ "Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun" ],
      "venue" : "arXiv preprint arXiv:1512.03385,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2015
    }, {
      "title" : "Sparse convolutional neural networks",
      "author" : [ "Baoyuan Liu", "Min Wang", "Hassan Foroosh", "Marshall Tappen", "Marianna Pensky" ],
      "venue" : "In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR),",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2015
    }, {
      "title" : "Learning both weights and connections for efficient neural network",
      "author" : [ "Song Han", "Jeff Pool", "John Tran", "William Dally" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2015
    }, {
      "title" : "Deep compression: Compressing deep neural network with pruning, trained quantization and huffman coding",
      "author" : [ "Song Han", "Huizi Mao", "William J. Dally" ],
      "venue" : "arXiv preprint arXiv:1510.00149,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2015
    }, {
      "title" : "Predicting parameters in deep learning",
      "author" : [ "Misha Denil", "Babak Shakibi", "Laurent Dinh", "Marc' Aurelio Ranzato", "Nando de Freitas" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2013
    }, {
      "title" : "Exploiting linear structure within convolutional networks for efficient evaluation",
      "author" : [ "Emily L Denton", "Wojciech Zaremba", "Joan Bruna", "Yann LeCun", "Rob Fergus" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2014
    }, {
      "title" : "Speeding up convolutional neural networks with low rank expansions",
      "author" : [ "Max Jaderberg", "Andrea Vedaldi", "Andrew Zisserman" ],
      "venue" : "arXiv preprint arXiv:1405.3866,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2014
    }, {
      "title" : "Training cnns with low-rank filters for efficient image classification",
      "author" : [ "Yani Ioannou", "Duncan P. Robertson", "Jamie Shotton", "Roberto Cipolla", "Antonio Criminisi" ],
      "venue" : "arXiv preprint arXiv:1511.06744,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2015
    }, {
      "title" : "Convolutional neural networks with low-rank regularization",
      "author" : [ "Cheng Tai", "Tong Xiao", "Xiaogang Wang", "Weinan E" ],
      "venue" : "arXiv preprint arXiv:1511.06067,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2015
    }, {
      "title" : "Model selection and estimation in regression with grouped variables",
      "author" : [ "Ming Yuan", "Yi Lin" ],
      "venue" : "Journal of the Royal Statistical Society. Series B (Statistical Methodology),",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2006
    }, {
      "title" : "Tree-guided group lasso for multi-task regression with structured sparsity",
      "author" : [ "Seyoung Kim", "Eric P Xing" ],
      "venue" : "In Proceedings of the 27th International Conference on Machine Learning,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2010
    }, {
      "title" : "Learning the structure of deep convolutional networks",
      "author" : [ "Jiashi Feng", "Trevor Darrell" ],
      "venue" : "In The IEEE International Conference on Computer Vision (ICCV),",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2015
    }, {
      "title" : "cudnn: Efficient primitives for deep learning",
      "author" : [ "Sharan Chetlur", "Cliff Woolley", "Philippe Vandermersch", "Jonathan Cohen", "John Tran", "Bryan Catanzaro", "Evan Shelhamer" ],
      "venue" : "arXiv preprint arXiv:1410.0759,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2014
    }, {
      "title" : "Caffe: Convolutional architecture for fast feature embedding",
      "author" : [ "Yangqing Jia", "Evan Shelhamer", "Jeff Donahue", "Sergey Karayev", "Jonathan Long", "Ross Girshick", "Sergio Guadarrama", "Trevor Darrell" ],
      "venue" : "arXiv preprint arXiv:1408.5093,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2014
    }, {
      "title" : "Gradient-based learning applied to document recognition",
      "author" : [ "Yann LeCun", "Léon Bottou", "Yoshua Bengio", "Patrick Haffner" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1998
    }, {
      "title" : "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
      "author" : [ "Sergey Ioffe", "Christian Szegedy" ],
      "venue" : "arXiv preprint arXiv:1502.03167,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Deep neural networks (DNN), especially deep convolutional neural networks (CNN), made remarkable success in visual tasks[1][2][3][4][5] by leveraging large-scale networks learning from a huge volume of data.",
      "startOffset" : 120,
      "endOffset" : 123
    }, {
      "referenceID" : 1,
      "context" : "Deep neural networks (DNN), especially deep convolutional neural networks (CNN), made remarkable success in visual tasks[1][2][3][4][5] by leveraging large-scale networks learning from a huge volume of data.",
      "startOffset" : 123,
      "endOffset" : 126
    }, {
      "referenceID" : 2,
      "context" : "Deep neural networks (DNN), especially deep convolutional neural networks (CNN), made remarkable success in visual tasks[1][2][3][4][5] by leveraging large-scale networks learning from a huge volume of data.",
      "startOffset" : 126,
      "endOffset" : 129
    }, {
      "referenceID" : 3,
      "context" : "Deep neural networks (DNN), especially deep convolutional neural networks (CNN), made remarkable success in visual tasks[1][2][3][4][5] by leveraging large-scale networks learning from a huge volume of data.",
      "startOffset" : 129,
      "endOffset" : 132
    }, {
      "referenceID" : 4,
      "context" : "Deep neural networks (DNN), especially deep convolutional neural networks (CNN), made remarkable success in visual tasks[1][2][3][4][5] by leveraging large-scale networks learning from a huge volume of data.",
      "startOffset" : 132,
      "endOffset" : 135
    }, {
      "referenceID" : 5,
      "context" : "To reduce computation cost, many studies are performed to compress the scale of DNN, including sparsity regularization[6], connection pruning[7][8] and low rank approximation [9][10][11][12][13].",
      "startOffset" : 118,
      "endOffset" : 121
    }, {
      "referenceID" : 6,
      "context" : "To reduce computation cost, many studies are performed to compress the scale of DNN, including sparsity regularization[6], connection pruning[7][8] and low rank approximation [9][10][11][12][13].",
      "startOffset" : 141,
      "endOffset" : 144
    }, {
      "referenceID" : 7,
      "context" : "To reduce computation cost, many studies are performed to compress the scale of DNN, including sparsity regularization[6], connection pruning[7][8] and low rank approximation [9][10][11][12][13].",
      "startOffset" : 144,
      "endOffset" : 147
    }, {
      "referenceID" : 8,
      "context" : "To reduce computation cost, many studies are performed to compress the scale of DNN, including sparsity regularization[6], connection pruning[7][8] and low rank approximation [9][10][11][12][13].",
      "startOffset" : 175,
      "endOffset" : 178
    }, {
      "referenceID" : 9,
      "context" : "To reduce computation cost, many studies are performed to compress the scale of DNN, including sparsity regularization[6], connection pruning[7][8] and low rank approximation [9][10][11][12][13].",
      "startOffset" : 178,
      "endOffset" : 182
    }, {
      "referenceID" : 10,
      "context" : "To reduce computation cost, many studies are performed to compress the scale of DNN, including sparsity regularization[6], connection pruning[7][8] and low rank approximation [9][10][11][12][13].",
      "startOffset" : 182,
      "endOffset" : 186
    }, {
      "referenceID" : 11,
      "context" : "To reduce computation cost, many studies are performed to compress the scale of DNN, including sparsity regularization[6], connection pruning[7][8] and low rank approximation [9][10][11][12][13].",
      "startOffset" : 186,
      "endOffset" : 190
    }, {
      "referenceID" : 12,
      "context" : "To reduce computation cost, many studies are performed to compress the scale of DNN, including sparsity regularization[6], connection pruning[7][8] and low rank approximation [9][10][11][12][13].",
      "startOffset" : 190,
      "endOffset" : 194
    }, {
      "referenceID" : 10,
      "context" : "Inspired by the facts that (1) there is redundancy across filters and channels [11]; (2) shapes of filters are usually fixed as cuboid but enabling arbitrary shapes can potentially eliminate unnecessary computation imposed by this fixation; and (3) depth of the network is critical for classification but deeper layers cannot always guarantee a lower error because of the exploding gradients and degradation problem [5], we propose Structured Sparsity Learning (SSL) method to directly learn a compressed structure of deep CNNs by group Lasso regularization during the training.",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 4,
      "context" : "Inspired by the facts that (1) there is redundancy across filters and channels [11]; (2) shapes of filters are usually fixed as cuboid but enabling arbitrary shapes can potentially eliminate unnecessary computation imposed by this fixation; and (3) depth of the network is critical for classification but deeper layers cannot always guarantee a lower error because of the exploding gradients and degradation problem [5], we propose Structured Sparsity Learning (SSL) method to directly learn a compressed structure of deep CNNs by group Lasso regularization during the training.",
      "startOffset" : 416,
      "endOffset" : 419
    }, {
      "referenceID" : 6,
      "context" : "[7][8] reduced number of parameters of AlexNet by 9× and VGG-16 by 13× using connection pruning.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[7][8] reduced number of parameters of AlexNet by 9× and VGG-16 by 13× using connection pruning.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 4,
      "context" : "99% parameters of ResNet-152 in [5] are from fully-connected layers, compression and acceleration on convolutional layers become essential.",
      "startOffset" : 32,
      "endOffset" : 35
    }, {
      "referenceID" : 5,
      "context" : "[6] achieved >90% sparsity of convolutional layers in AlexNet with 2% accuracy loss, and bypassed the issue shown in Figure 1 by hardcoding the sparse weights into program, achieving layer-wise 4.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[9] predicted 95% parameters in a DNN by exploiting the redundancy across filters and channels.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 10,
      "context" : "[11] achieved 4.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 9,
      "context" : "[10] achieved 2× speedups on both CPUs and GPUs for the first two layers.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[13][12] improved and extended LRA to larger DNNs.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[13][12] improved and extended LRA to larger DNNs.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 9,
      "context" : "As number of hyper-parameters in LRA method increases linearly with layer depth [10][13], the search space increases linearly or even polynomially for very deep DNNs.",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 12,
      "context" : "As number of hyper-parameters in LRA method increases linearly with layer depth [10][13], the search space increases linearly or even polynomially for very deep DNNs.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 13,
      "context" : "Group Lasso [14] is an efficient regularization to learn sparse structures.",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 14,
      "context" : "[15] used group Lasso to regularize the structure of correlation tree for multi-task regression problem and reduced prediction errors.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 5,
      "context" : "[6] utilized group Lasso to constrain the scale of the structure of LRA.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 15,
      "context" : "[16] learned",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 13,
      "context" : "Because Group Lasso can effectively zero out all weights in some groups [14][15], we adopt it in our SSL.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 14,
      "context" : "Because Group Lasso can effectively zero out all weights in some groups [14][15], we adopt it in our SSL.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 4,
      "context" : "Inspired by the structure of highway networks [17] and deep residual networks [5], we propose to leverage the shortcuts across layers to solve this issue.",
      "startOffset" : 78,
      "endOffset" : 81
    }, {
      "referenceID" : 16,
      "context" : "Convolutional computation in DNNs is commonly converted to modality of GEneral Matrix Multiplication (GEMM) by lowering weight tensors and feature tensors to matrices [18].",
      "startOffset" : 167,
      "endOffset" : 171
    }, {
      "referenceID" : 17,
      "context" : "For example, in Caffe [19], a 3D filter W (l) nl,:,:,: is reshaped to a row in the weight matrix where each column is the collection of weights W (l) :,cl,ml,kl related to shape-wise sparsity.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 18,
      "context" : "In the experiment of MNIST, we examined the effectiveness of SSL in two types of networks: LeNet [20] implemented by Caffe and a multilayer perceptron (MLP) network.",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 0,
      "context" : "We implemented the ConvNet of [1] and deep residual networks (ResNet) [5] on CIFAR-10.",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 4,
      "context" : "We implemented the ConvNet of [1] and deep residual networks (ResNet) [5] on CIFAR-10.",
      "startOffset" : 70,
      "endOffset" : 73
    }, {
      "referenceID" : 0,
      "context" : "[1] as the baseline and implement it using Caffe.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "ResNet: To investigate the necessary depth of DNNs required by SSL, we use a 20-layer deep residual networks (ResNet-20) proposed in [5] as the baseline.",
      "startOffset" : 133,
      "endOffset" : 136
    }, {
      "referenceID" : 19,
      "context" : "Batch normalization [21] is adopted after convolution and before activation.",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 4,
      "context" : "We use the same data augmentation and training hyper-parameters as that in [5].",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 4,
      "context" : "ResNet-# is the original ResNet in [5] with # layers.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 4,
      "context" : "Compared with original ResNet in [5], SSL learns a ResNet with 14 layers (SSLResNet-14) that reaching a lower error than the one of the baseline with 20 layers (ResNet-20); SSL-ResNet-18 and ResNet-32 achieve an error of 7.",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 17,
      "context" : "CaffeNet [19] – the replication of AlexNet [1] with mirror changes, is used in our experiment.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 0,
      "context" : "CaffeNet [19] – the replication of AlexNet [1] with mirror changes, is used in our experiment.",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 6,
      "context" : "`1-norm is selected as the representative of non-structured sparsity method instead of connection pruning in [7] because `1-norm get a higher sparsity on convolutional layers as the results of AlexNet 3 and AlexNet 4 depicted in Table 4.",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 5,
      "context" : "We note that at the same accuracy, our average speedup is indeed higher than that of [6] which adopts heavy hardware customization to overcome the negative impact of non-structured sparsity.",
      "startOffset" : 85,
      "endOffset" : 88
    }, {
      "referenceID" : 6,
      "context" : "3 pruning[7] 42.",
      "startOffset" : 9,
      "endOffset" : 12
    } ],
    "year" : 2016,
    "abstractText" : "High demand for computation resources severely hinders deployment of large-scale Deep Neural Networks (DNN) in resource constrained devices. In this work, we propose a Structured Sparsity Learning (SSL) method to regularize the structures (i.e., filters, channels, filter shapes, and layer depth) of DNNs. SSL can: (1) learn a compact structure from a bigger DNN to reduce computation cost; (2) obtain a hardware-friendly structured sparsity of DNN to efficiently accelerate the DNN’s evaluation. Experimental results show that SSL achieves on average 5.1× and 3.1× speedups of convolutional layer computation of AlexNet against CPU and GPU, respectively, with off-the-shelf libraries. These speedups are about twice speedups of non-structured sparsity; (3) regularize the DNN structure to improve classification accuracy. The results show that for CIFAR-10, regularization on layer depth can reduce 20 layers of a Deep Residual Network (ResNet) to 18 layers while improve the accuracy from 91.25% to 92.60%, which is still slightly higher than that of original ResNet with 32 layers. For AlexNet, structure regularization by SSL also reduces the error by ∼ 1%.",
    "creator" : "LaTeX with hyperref package"
  }
}