{
  "name" : "0906.5151.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Unsupervised Search-based Structured Prediction",
    "authors" : [ "Hal Daumé III" ],
    "emails" : [ "me@hal3.name" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "A prevalent and useful version of unsupervised learning arises when both the observed data and the latent variables are structured. Examples range from hidden alignment variables in speech recognition (Rabiner, 1989) and machine translation (Brown et al., 1993; Vogel et al., 1996), to latent trees in unsupervised parsing (Paskin, 2001; Klein & Manning, 2004; Smith & Eisner, 2005; Titov & Henderson, 2007), and to pose estimation in computer vision (Ramanan et al., 2005). These techniques are all based on probabilistic models. Their applicability hinges on the tractability of (approximately) computing latent variable expectations, thus enabling the use of EM (Dempster et al., 1977). In this paper we show that a recently-developed search-based algorithm, Searn (Daumé III et al., 2009 to appear) (see Section 2.2), can be utilized for unsupervised structured prediction (Section 3). We show: (1) that under an appropriate construction, Searn can imitate the expectation maximization (Section 4); (2) that unsupervised Searn can be used to obtain competitive performance on an unsupervised dependency parsing task (Section 6); and (3) that unsupervised\nAppearing in Proceedings of the 26 th International Conference on Machine Learning, Montreal, Canada, 2009. Copyright 2009 by the author(s)/owner(s).\nSearn naturally extends to a semi-supervised setting (Section 7). The key insight that enables this work is that we can consider the prediction of the (observed) input to be, itself, a structured prediction problem."
    }, {
      "heading" : "2. Structured Prediction",
      "text" : "The supervised structured prediction problem is the task of mapping inputs x to complex structured outputs y (e.g., sequences, trees, etc.). Formally, let X be an arbitrary input space and Y be structure output space. Y is typically assumed to decompose over some smaller substructures (e.g., labels in a sequence). Y comes equipped with a loss function, often assumed to take the form of a Hamming loss over the substructures. Features are defined over pairs (x, y) in such a way that they obey the substructures (e.g., one might have features over adjacent label pairs in a sequence). Under strong assumptions on the structures, the loss function and the features (essentially “locality” assumptions), a number of learning algorithms can be employed: for example, conditional random fields (Lafferty et al., 2001) or max-margin Markov networks (Taskar et al., 2005).\nA key difficulty in structured prediction occurs when the output space Y, the features, or the loss, does not decompose nicely. All of these issues can lead to intractable computations at either training or prediction time (often both). An attractive approach for dealing with this intractability is to employ a search-based algorithm. The key idea in search-based structured prediction is to first decompose the output y into a sequence of (dependent) smaller predictions y1, . . . , yT . These may each be predicted in turn, with later predictions dependent of previous decisions."
    }, {
      "heading" : "2.1. Search-based Structured Prediction",
      "text" : "A recently proposed algorithm for solving the structured prediction problem is Searn (Daumé III et al., 2009 to appear). Searn operates by considering each substructure prediction y1, . . . , yT as a classification problem. A classifier h is trained so that at time t,\nar X\niv :0\n90 6.\n51 51\nv1 [\ncs .L\nG ]\n2 8\nJu n\n20 09\ngiven a feature vector, it predict the best value for yt. The feature vector can be based on any part of the input x and any previous decision y1, . . . , yt−1. This introduces a chicken-and-egg problem. h should ideally be trained so that it makes the best decision for yt given that h makes all past decisions y1, . . . , yt−1 and all future decisions yt+1, . . . , yT . Of course, at training time we do not have access to h (we are trying to construct it). The solution is to use an iterative scheme."
    }, {
      "heading" : "2.2. Searn",
      "text" : "The presentation we give here differs slightly from the original presentation of the Searn algorithm. Our motivation for straying from the original formulation is because our presentation makes more clear the connection between our unsupervised variant of Searn and more standard unsupervised learning methods (such as standard algorithms on hidden Markov models).\nLet DSP denote a distribution over pairs (x, y) drawn from X ×Y, and let `(y, ŷ) be the loss associated with predicting ŷ when the true answer is y. We assume that y ∈ Y can be decomposed into atomic predictions y1, . . . , yT , where each yt is drawn from a discrete set Y . A policy, π, is a (possibly stochastic) function that maps tuples (x, y1, . . . , yt−1) to atomic predictions yt.\nThe key ingredient in Searn is to use the loss function ` and a “current” policy π to turn DSP into a distribution over cost-sensitive (multiclass) classification problems (Beygelzimer et al., 2005). A cost-sensitive classification example is given by an input x and a cost vector c = 〈c1, . . . , cK〉, where ck is the cost of predicting class k on input x. Define by Searn(DSP, `, π) a distribution over cost-sensitive classification problems derived as follows. To sample from this induced distribution, we first sample an example (x, y) ∼ DSP. We then sample t uniformly from [1, T ] and run π for t − 1 steps on (x, y). This yields a partial prediction (ŷ1, . . . , ŷt−1). The input for the cost sensitive classification problem is then the tuple (x, ŷ1, . . . , ŷt−1). The costs are derived as follows. For each possible choice k of ŷt, we defined ck as the expected loss if π were run, beginning at (ŷ1, . . . , ŷt−1, k) on input x. Formally:\nck = Eŷt+1,...,ŷT∼π`(y, (ŷ1, . . . , ŷt−1, k, ŷt+1, . . . , ŷT )) (1) Searn assumes access to an “initial policy” π∗ (sometimes called the “optimal policy”). Given an input x, a true output y and a prefix of predictions ŷ1, . . . , ŷt−1, π∗ produces a best next-action, ŷt. It should be constructed so that the choice ŷt is optimal (or close to optimal) with respect to the problem-specific loss function. For example, if the loss function is Hamming loss,\nthe π∗ will always produce ŷt = yt. For more complex loss functions, computing π∗ may be more involved.\nGiven these ingredients, Searn operates according the algorithm given in Figure 1. Operationally, the sampling step is typically implemented by generating every example from a fixed structured prediction training set. The costs (expected losses) are computed by sampling with tied randomness (Ng & Jordan, 2000).\nIf β = 1/T 3, one can show (Daumé III et al., 2009 to appear) that after at most 2T 3 lnT iterations, Searn is guaranteed to find a solution π with structured prediction loss bounded as:\nL(π) ≤ L(π∗) + 2`avgT lnT + c(1 + lnT )/T (2)\nwhere L(π∗) is the loss of the initial policy (typically zero), T is the length of the longest example, c is the worse-case per-step loss and `avg is the average multiclass classification loss. This shows that the structured prediction algorithm learned by Searn is guaranteed to be not-much-worse than that produced by the initial policy, provided that the created classification problems are easy (i.e., that `avg is small). Note that one can use any classification algorithm one likes."
    }, {
      "heading" : "3. Unsupervised Searn",
      "text" : "In unsupervised structured prediction, we no longer receive an pair (x, y) but instead observes only an input x. Our job is to construct a classifier that produces y, even though we have never observed it."
    }, {
      "heading" : "3.1. Reduction for Unsupervised to Supervised",
      "text" : "The key idea—one that underlies much work in unsupervised learning—is that a good y is one that enables us to easily recover x. This is precisely the intuition we build in to our model. The observation that makes this practical is that there is nothing in the theory or application of Searn that says that π∗ cannot be\nstochastic. Moreover, there is not requirement that the loss function depend on all components of the prediction. Our model will essentially first predict y and then predict x based on y. Importantly, the loss function is agnostic to y (since we do not have true outputs).\nThe general construction is as follows. Let Dunsup be a distribution over inputs x ∈ X and let Y be the space of desired latent structures (e.g., trees). We define a distribution Dsup over X × (Y ×X ) by defining a sampling procedure. To sample from Dsup, we first sample x ∼ Dunsup. We then sample uniformly from the set of all Y that are valid structures for x. Finally, we return the pair (x, (y, x)). We define a loss function L by L((y, x), (ŷ, x̂)) = Linput(x, x̂) where Linput is any loss function on the input space (e.g., Hamming loss). We apply Searn to the supervised structured prediction problem Dsup, and implicitly learn latent structures."
    }, {
      "heading" : "3.2. Sequence Labeling Example",
      "text" : "To gain insight into the operation of Searn in the unsupervised setting, it is useful to consider a sequence labeling example. That is, our input x is a sequence of length T and we desire a label sequence y of length T drawn from a label space of size K. We convert this into a supervised learning problem by considering the “true” structured output to be a label sequence of length 2T , with the first T components drawn from the label space of size K and the second T components drawn from the input vocabulary. The loss function can then be anything that depends only on the last T components. For simplicity, we can consider it to be Hamming loss. The construction of the optimal policy in this case is straightforward. For the first T components, π∗ may behave arbitrarily (e.g., it may produce a uniform distribution over the K labels). For the second T components, π∗ always predicts the true label (which is known, because it is part of the input).\nAn important aspect of the model is the construction of the feature vectors. It is most useful to consider this construction as having two parts. The first part has to do with predicting the hidden structure (the first T components). The second part has to do with predicting the observed structure (the second T components). For the first part, we are free to use whatever features we desire, so long as they can be computed based on the input x and a partial output. For instance, in the HMM case, we could use the two most recent label predictions and windowed features from x.\nThe construction of the features for the second part is, however, also crucial. For instance, if the feature vector corresponding to “predict the tth component of x” contains the t component of x, then this learning prob-\nlem is trivial—but also renders the latent structure useless. The goal of the designer of the feature space is to construct features for predicting xt that crucially depend on getting the latent structure y correct. That is, the ideal feature set is one for which you can predict xt accurately if an only if we have found the correct latent structure (more on this in Section 5). For instance, in the HMM case, we may predict xt based only on the corresponding label yt, or maybe on the basis of yt−1, yt, yt+1. (Note that we are not limited to the Markov assumption, as in the case of HMMs.)\nIn the first iteration of Searn, all costs for the prediction of the latent structure are computed with respect to the initial policy. Recalling that the initial policy behaves randomly when predicting the latent labels and correctly when predicting the words, we can see that these costs are all zero. Thus, for the latent structure actions, Searn will not induce any classification examples (because the cost of all actions is equal). However, it will create example for predicting the x component. For predicting the xs, the cost will be zero for the correct word and one for any incorrect word. These examples will have associated features: we will predict word xt based exclusively on yt. Remember: yt was generated randomly by the initial policy.\nIn the second iteration, the behavior is different. Searn returns to creating examples for the latent structure components. However, in this iteration, since the current policy is not longer optimal, the future cost estimates may be non-zero. Consider generating an example corresponding to a (latent) state yt. For some small percentage (as dictated by β) of the “generate x” decisions, the previously learned classifier will fire. If this learned classifier does well, then the associated cost will be low. However, if the learned classifier does poorly, the the associated cost will be high. Intuitively, the learned classifier will do well if and only if the action that labels yt is “good” (i.e., consistent with what was learned previously). This, in the second pass through the data, Searn does create classification examples specific to the latent decisions.\nAs Searn iterates, more and more of the latent prediction decisions are made according to the learned classifiers and not with respect to the random policy."
    }, {
      "heading" : "4. Comparison to EM",
      "text" : "In this section, we show an equivalence between expectation maximization in directed probabilistic structures and unsupervised Searn. We use mixture of multinomials as a motivating example (primarily for simplicity), but the results easily extend to more com-\nplicated models (e.g., HMMs: see Section 4.3)."
    }, {
      "heading" : "4.1. EM for Mixture of Multinomials",
      "text" : "In the mixture of multinomials problem, we are given N documents d1, . . . ,dN , where dn is a vector of word counts over a vocabulary of size V ; that is, dn,v is the number of times word v appeared in document n. The mixture of multinomials is a probabilistic clustering model, where we assume an underlying set of K clusters (multinomials) that generated the documents. Denote by θk the multinomial parameter associated with cluster k, ρk the prior probability of choosing cluster k, and let zn be an indicator vector associating document n with the unique cluster k such that zn,k = 1. The probabilistic model has the form:\np(d | θ,ρ) = ∏ n ( ∑ v dn,v)!∏ v dn,v! ∑ zn ∏ k [ ρk ∏ v θ dn,v k,v ]zn,k (3) Expectation maximization in this model involves first computing expectations over the z vectors and then updating the model parameters θ:\nE-step: zn,k ∝ ρk Y v θ dn,v k,v (4)\nM-step: θk,v ∝ X\nn\nzn,kdn,v ; ρk ∝ X\nn\nzn,k (5)\nIn both cases, the constant of proportionality is chosen so that the variables sum to one over the last component. These updates are repeated until convergence of the incomplete data likelihood, Eq (3)."
    }, {
      "heading" : "4.2. An Equivalent Model in Searn",
      "text" : "Now, we show how to construct an instance of unsupervised Searn that effectively mimics the behavior of EM on the mixture of multinomials problem. The ingredients are as follows:\n• The input space X is the space of documents, represented as word count vectors.\n• The (latent) output space Y is a single discrete variable in the range [1,K] that specifies the cluster.\n• The feature set for predicting y (document counts).\n• The feature set for predicting x is the label y and the total number of words in the document. The predictions for a document are estimated word probabilities, not the words themselves.\n• The loss function ignores the prediction y and returns the log loss of the true document x under the word probabilities predicted.\n• The cost-sensitive learning algorithm is different depending on whether the latent structure y is being predicted or if the document x is being predicted:\n– Structure: The base classifier is a multinomial näıve Bayes classifier, parameterized by (say) hm\n– Document: The base classifier is a collection of independent maximum likelihood multinomial estimators for each cluster.\nConsider the behavior of this setup. In particular, consider the distribution Searn(DSP, `, π). There are two “types” of examples drawn from this distribution: (1) latent structure examples and (2) document examples. The claim is that both classifiers learned are identical to the mixture of multinomials model from Section 4.1.\nConsider the generation of a latent structure example. First, a document n is sampled uniformly from the training set. Then, for each possible label k of this document, a cost Ed̂∼πl((y,dn), (k, d̂)) is computed. By definition, the d̂ that is computed is exactly the prediction according to the current multinomial estimator, hm. Interpreting the multinomial estimator in terms of the EM parameters, the costs are precisely the zn,ks from EM (see Eq (4)). These latent structure examples are fed in to the multinomial näıve Bayes classifier, which re-estimates a model exactly as per the M-step in EM (Eq (5)).\nNext, consider the generation of the document examples. These examples are generated by π first choosing a cluster according to the structure classifier. This cluster id is then used as the (only) feature to the “generate document” multinomial. As we saw before, the probability that π will select label k for document n is precisely zn,k from Eq (4). Thus, the multinomial estimator will effectively receive weighted examples, weighted by these zn,ks, thus making the maximum likelihood estimate exactly the same as the M-step from EM (Eq (5))."
    }, {
      "heading" : "4.3. Synthetic experiments",
      "text" : "To demonstrate the advantages of the generality of Searn, we report here the result of some experiments on synthetic data. We generate synthetic data according to two different HMMs. The first HMM is a first-order model. The initial state probabilities, the transition probabilities, and the observation probabilities are all drawn uniformly. The second HMM is a second-order model, also will all probabilities drawn uniformly. The lengths of observations are given by a Poisson with a fixed mean.\nIn our experiments, we consider the following learning algorithms: EM, Searn with HMM features and a näıve Bayes classifier, and Searn with a logistic regression classifier (and an enhanced feature space: predicting yt depends on xt−1:t+1. The first Searn\nshould mimic EM, but by using sampling rather than exact expectation computations. The models are all first-order, regardless of the underlying process.\nWe run the following experiment. For a given number of states (which we will vary), we generate 10 random data sets according to each model. Each data set consists of 5 examples with mean example length of 40 observations. The vocabulary size of the observed data is always 10. We compute error rates by matching each predicted label to the best-matching true label and the compute Hamming loss. Forward-backward is initialized randomly. We run experiments with the number of latent states equal to 2, 5 and 10.1\nThe results of the experiments are shown in Table 1. The observations show two things. When the true model matches the model we attempt to learn (HMM1), there is essentially no statistically significant difference between any of the algorithms. Where once sees a difference is when the true model does not match the learned model (HMM2). In this case, we see that Searn-LR obtains a significant advantage over both EM and Searn-NB, due to its ability to employ a richer set of features. These results hold over all values of K. This is encouraging, since in the real world our model is rarely (if ever) right. The (not statistically significant) difference in error rates between EM and Searn-NB are due to a sampling versus exact computation of expectations. Many of the models outperform “truth” because likelihood and accuracy do not necessarily correlate (Liang & Klein, 2008)."
    }, {
      "heading" : "5. Analysis",
      "text" : "There are two keys to success in unsupervised-Searn. The first key is that the features on the Y-component of the output space be descriptive enough that it be\n1We ran experiments varying the number of samples Searn uses in {1, 2, 5}; there was no statistically significant difference. The results we report are based on 2 samples.\nlearnable. One way of thinking of this constraint is that if we had labeled data, then we would be able to learn well. The second key is that the features on the X -component of the output space be intrinsically tied to the hidden component. Ideally, these features will be such that X can be predicted with high accuracy if and only if Y is predicted accurately.\nThe general–though very trivial–result is that if we can guarantee that the loss on Y is bounded by some function f of the loss on X , then the loss on Y is guaranteed after learning to be bounded by f(L(π∗)+ 2`avgTmaxlnTmax + c(1 + lnTmax)/Tmax), where all the constants now depend on the induced structured prediction problem; see Eq 2.\nOne can see the unsupervised Searn analysis as justifying a small variant on “Viterbi training”–the process of performing EM where the E-step is approximated with a delta function centered at the maximum. One significant issue with Viterbi training is that it is not guaranteed to converge. However, Viterbi training is recovered as a special case of unsupervised Searn where the interpolation parameter is fixed at 1. While the Searn theorem no longer applies in this degenerate case, any algorithm that uses Viterbi training could easily be retrofitted to simply make some decisions randomly. In doing so, one would obtain an algorithm that does have theoretical guarantees."
    }, {
      "heading" : "6. Unsupervised Dependency Parsing",
      "text" : "The dependency formalism is a practical and linguistically interesting model of syntactic structure. One can think of a dependency structure for a sentence of length T as a directed tree over a graph over T + 1 nodes: one node for each word plus a unique root node. Edges point from heads to dependents. An example dependency structure for a T = 7 word sentence is shown in Figure 2 . To date, unsupervised dependency parsing has only been viewed in the context of\nglobal probabilistic models specified over dependency pairs (Paskin, 2001) or spanning trees (Klein & Manning, 2004; Smith & Eisner, 2005). However, there is an alternative, popular method for producing dependency trees in a supervised setting: shift-reduce parsing (Nivre, 2003; Sagae & Lavie, 2005)."
    }, {
      "heading" : "6.1. Shift-reduce dependency parsing",
      "text" : "Shift-reduce dependency parsing (Nivre, 2003) is a leftto-right parsing algorithm that operates by maintaining three state variables: a stack S, a current position i and a set of arcs A. The algorithm begins with 〈S, i, A〉 = 〈∅, 1, ∅〉: the stack and arcset are empty and the current index is 1 (the first word). The algorithm then proceeds through a series of actions until a final state is reached. A final state is one in which i = T , at which point the set A contains all dependency edges for the parse. Denote by i|I a stack with i at the head and stack I at the tail. There are four actions:\nLeftArc: 〈t|S, i, A〉 −→ 〈S, i, (i, t)|A〉, so long as there does not exist an arc (·, t) ∈ A. (Adds a left dependency to the arc set between the word t at the top of the stack and the word i at the current index.)\nRightArc: 〈t|S, i, A〉 −→ 〈i|t|s, i + 1, (t, i)|A〉, so long as there is no arc (·, i) ∈ A. (Adds a right dependency between the top of the stack and the next input.)\nReduce: 〈t|S, i, A〉 −→ 〈S, i, A〉, so long as there does exist an arc (·, t) ∈ A. (Removes a word from the stack.)\nShift: 〈S, i, A〉 −→ 〈n|S, i+ 1, A〉. (Place item on stack.)\nThis algorithm is guaranteed to terminate in at most 2T steps with a valid dependency tree (Nivre, 2003), unlike standard probabilistic algorithms that have a time-complexity that is cubic in T (McDonald & Satta, 2007). The advantage of the shift-reduce framework is that it fits nicely into Searn. However, until now, it has been an open question how to train a shift-reduce model in an unsupervised fashion. The techniques described in this paper give a solution to this problem."
    }, {
      "heading" : "6.2. Experimental setup",
      "text" : "We follow the same experimental setup as (Smith & Eisner, 2005), using data from the WSJ10 corpus (sentences of length at most ten from the Penn Treebank (Marcus et al., 1993)). The data is stripped of punctuation and parsing depends on the part-of-speech tags,\nnot the words. We use the same train/dev/test split as Smith and Eisner: 5301 sentences of training data, 531 sentences of development data and 530 sentences of blind test data. All algorithm development and tuning was done on the development data.\nWe use a slight modification to SearnShell to facilitate the development of our algorithm together with a multilabel logistic regression classifier, MegaM.2 Our algorithm uses the following features for the tree-based decisions (inspired by (Hall et al., 2006)), where t is the top of the stack and i is the next token: the partsof-speech within a window of 2 around t and i; the pair of tokens at t and i; the distance (discretized) between t and i; and the part-of-speech at the head (resp. tail) of any existing arc pointing to (resp. from) t or i. For producing word i, we use the part of speech of i’s parent, grandparent, daughters and aunts.\nWe use Searn with a fixed β = 0.1. One sample is used to approximate expected losses. The development set is used to tune the scale of the prior variances for the logistic regression (different variances are allowed for the “produce tree” and “produce words” features). The initial policy makes uniformly random decisions. Accuracy is directed arc accuracy."
    }, {
      "heading" : "6.3. Experimental results",
      "text" : "The baseline systems are: two random baselines (one generative, one given by the Searn initial policy), Klein and Manning’s model (Klein & Manning, 2004) EM-based model (with and without clever initialization), and three variants of Smith and Eisner’s model (Smith & Eisner, 2005) (with random initialization, which seems to be better for most of their mod-\n2SearnShell and MegaM are available at http://searn. hal3.name and http://hal3.name/megam, respectively.\nels). We also report an “upper bound” performance based on supervised training, for both the probabilistic (Smith+Eisner model) as well as supervised Searn.\nThe results are reported in Table 2: accuracy on the training data, accuracy on the test data and the number of iterations required. These are all averaged over 10 runs; standard deviations are shown in small print. Many of the results (the non-Searn results) are copied from (Smith & Eisner, 2005). The stopping criteria for the EM-based models is that the log likelihood changes by less than 10e − 5. For the Searn-based methods, the stopping criteria is that the development accuracy ceases to increase (on the individual classification tasks, not on the structured prediction task).\nAll learned algorithms outperform the random algorithms (except Klein+Manning with random inits). K+M with smart initialization does slightly better than the worst of the S+E models, though the difference is not statistically significant. It does so needing only about a third of the number of iterations (moreover, a single S+E iteration is slower than a single K+M iteration). The other two S+E models do roughly comparably in terms of performance (strictly dominating the previous methods). One of them (“DelOrTrans1”) requires about twice as many iterations as K+M; the other (“Trans1”) requires about three times (but has much high performance variance). Unsupervised Searn performs halfway between the best K+M model and the best S+E model (it is within the error bars for “DelOrTrans1” but not “Trans1”).\nNicely, it takes significantly fewer iterations to converge (roughly 15%). Moreover, each iteration is quite fast in comparison to the EM-based methods (a complete run took roughly 3 hours on a 3.8GHz Opteron using SearnShell). Finally, we present results for the supervised case. Here, we see that the Searn-based method converges much more quickly to a better solution than the S+E model. Note that this comparison is unfair since the Searn-based model uses additional features (though it is a nice property of the Searnbased model that it can make use of additional features). Nevertheless we provide it so as to give a sense of a reasonable upper-bound. We imagine that including more features would shift the upper-bound and the unsupervised algorithm performance up."
    }, {
      "heading" : "7. A Semi-Supervised Version",
      "text" : "The unsupervised learning algorithm described above naturally extends to the case where some labeled data is available. In fact, the only modification to the algorithm is to change the loss function. In the unsu-\npervised case, the loss function completely ignores the latent structure, and returns a loss dependent only on the “predict self” task. In the semi-supervised version, one plugs in a natural loss function for the “latent” structure prediction for the labeled subset of the data.\nIn Figure 3, we present results on dependency parsing. We show learning curves for unsupervised, fully supervised and semi-supervised models. The x-axis shows the number of examples used; in the unsupervised and supervised cases, this is the total number of examples; in the semi-supervised case, it is the number of labeled examples. Error bars are two standard deviations. Somewhat surprisingly, with only five labeled examples, the semi-supervised approach achieves an accuracy of over 70%, only about 10% behind the fully supervised approach with 5182 labeled examples. Eventually the supervised model catches up (at about 250 labeled examples). The performance of the unsupervised model continues to grow as more examples are provided, but never reaches anywhere close to the supervised or semi-supervised models."
    }, {
      "heading" : "8. Conclusions",
      "text" : "We have described the application of a search-based structured prediction algorithm, Searn, to unsupervised learning. This answers positively an open question in the field of learning reductions (Beygelzimer et al., 2005): can unsupervised learning be reduced to supervised learning? We have shown a nearequivalence between the resulting algorithm and the forward-backward algorithm in hidden Markov models. We have shown an application of this algorithm to unsupervised dependency parsing in a shift-reduce framework. This provides the first example of unsupervised learning for dependency parsing in a non-\nprobabilistic model and shows that unsupervised shiftreduce parsing is possible. One obvious extension of this work is to structured prediction problems with additional latent structure, such as in machine translation. Instead of using the predict-self methodology, one could directly apply a predict-target methodology.\nThe view of “predict the input” for unsupervised learning is implicit in many unsupervised learning approaches, including standard models such as restricted Boltzmann machines and Markov random fields. This is made most precise in the wake-sleep algorithm (Hinton et al., 1995), which explicitly trains a neural network to reproduce its own input. The wake-sleep algorithm consists of two phases: the wake phase, where the latent layers are produced, and the sleep phase, where the input is (re-)produced. These two phases are analogous to the predict-structure phase and the predict-words phase in unsupervised Searn.\nAcknowledgements. Thanks for Ryan McDonald and Joakim Nivre for discussions related to dependency parsing algorithms. Comments from 5 (!) anonymous reviewers were incredibly helpful. This was partially supported by NSF grant IIS-0712764."
    } ],
    "references" : [ {
      "title" : "Error limiting reductions between classification",
      "author" : [ "A. Beygelzimer", "V. Dani", "T. Hayes", "J. Langford", "B. Zadrozny" ],
      "venue" : "tasks. Proc. Int’l Conf. on Machine Learning (pp. 49–56)",
      "citeRegEx" : "Beygelzimer et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Beygelzimer et al\\.",
      "year" : 2005
    }, {
      "title" : "The mathematics of statistical machine translation: Parameter estimation",
      "author" : [ "P. Brown", "S. Della Pietra", "V. Della Pietra", "R. Mercer" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Brown et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Brown et al\\.",
      "year" : 1993
    }, {
      "title" : "2009 (to appear)). Search-based structured prediction. Machine Learning J",
      "author" : [ "H. Daumé III", "J. Langford", "D. Marcu" ],
      "venue" : null,
      "citeRegEx" : "III et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "III et al\\.",
      "year" : 2009
    }, {
      "title" : "Maximum likelihood from incomplete data via the EM algorithm",
      "author" : [ "A. Dempster", "N. Laird", "D. Rubin" ],
      "venue" : "J. of the Royal Statistical Society,",
      "citeRegEx" : "Dempster et al\\.,? \\Q1977\\E",
      "shortCiteRegEx" : "Dempster et al\\.",
      "year" : 1977
    }, {
      "title" : "Discriminative classifiers for determining dependency parsing",
      "author" : [ "J. Hall", "J. Nivre", "J. Nilsson" ],
      "venue" : "Proc. Conf. of the Assoc. for Computational Linguistics (pp. 316–323)",
      "citeRegEx" : "Hall et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Hall et al\\.",
      "year" : 2006
    }, {
      "title" : "The wake-sleep algorithm for unsupervised neural networks",
      "author" : [ "G. Hinton", "P. Dayan", "B. Frey", "R. Neal" ],
      "venue" : null,
      "citeRegEx" : "Hinton et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Hinton et al\\.",
      "year" : 1995
    }, {
      "title" : "Corpus-based induction of syntactic structure: Models of depen",
      "author" : [ "D. Klein", "C. Manning" ],
      "venue" : null,
      "citeRegEx" : "Klein and Manning,? \\Q2004\\E",
      "shortCiteRegEx" : "Klein and Manning",
      "year" : 2004
    }, {
      "title" : "Conditional random fields: Probabilistic models for segmenting and labeling sequence data",
      "author" : [ "J. Lafferty", "A. McCallum", "F. Pereira" ],
      "venue" : "Proc. Int’l Conf. on Machine Learning (pp. 282–289)",
      "citeRegEx" : "Lafferty et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Lafferty et al\\.",
      "year" : 2001
    }, {
      "title" : "Analyzing the errors of unsupervised learning",
      "author" : [ "P. Liang", "D. Klein" ],
      "venue" : null,
      "citeRegEx" : "Liang and Klein,? \\Q2008\\E",
      "shortCiteRegEx" : "Liang and Klein",
      "year" : 2008
    }, {
      "title" : "Building a large annotated corpus of English: The Penn Treebank",
      "author" : [ "M. Marcus", "M.A. Marcinkiewicz", "B. Santorini" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Marcus et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Marcus et al\\.",
      "year" : 1993
    }, {
      "title" : "On the complexity of non-projective data-driven dependency parsing",
      "author" : [ "R. McDonald", "G. Satta" ],
      "venue" : "Int’l Wk. on Parsing Technologies",
      "citeRegEx" : "McDonald and Satta,? \\Q2007\\E",
      "shortCiteRegEx" : "McDonald and Satta",
      "year" : 2007
    }, {
      "title" : "PEGASUS: A policy search method for large MDPs and POMDPs",
      "author" : [ "A. Ng", "M. Jordan" ],
      "venue" : "Proc. Converence on Uncertainty in Artificial Intelligence (pp. 406–415)",
      "citeRegEx" : "Ng and Jordan,? \\Q2000\\E",
      "shortCiteRegEx" : "Ng and Jordan",
      "year" : 2000
    }, {
      "title" : "An efficient algorithm for projective dependency parsing",
      "author" : [ "J. Nivre" ],
      "venue" : "Int’l Wk. on Parsing Technologies",
      "citeRegEx" : "Nivre,? \\Q2003\\E",
      "shortCiteRegEx" : "Nivre",
      "year" : 2003
    }, {
      "title" : "Grammatical bigrams",
      "author" : [ "M.A. Paskin" ],
      "venue" : "Advances in Neural Info. Processing Systems (pp",
      "citeRegEx" : "Paskin,? \\Q2001\\E",
      "shortCiteRegEx" : "Paskin",
      "year" : 2001
    }, {
      "title" : "A tutorial on hidden Markov models and selected applications in speech recognition",
      "author" : [ "L. Rabiner" ],
      "venue" : null,
      "citeRegEx" : "Rabiner,? \\Q1989\\E",
      "shortCiteRegEx" : "Rabiner",
      "year" : 1989
    }, {
      "title" : "Strike a pose: Tracking people by finding stylized poses. Computer Vision and Pattern Recognition",
      "author" : [ "D. Ramanan", "D. Forsyth", "A. Zisserman" ],
      "venue" : null,
      "citeRegEx" : "Ramanan et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Ramanan et al\\.",
      "year" : 2005
    }, {
      "title" : "A classifier-based parser with linear run-time complexity",
      "author" : [ "K. Sagae", "A. Lavie" ],
      "venue" : "Int’l Wk. on Parsing Technologies",
      "citeRegEx" : "Sagae and Lavie,? \\Q2005\\E",
      "shortCiteRegEx" : "Sagae and Lavie",
      "year" : 2005
    }, {
      "title" : "Guiding unsupervised grammar induction using contrastive estimation",
      "author" : [ "N.A. Smith", "J. Eisner" ],
      "venue" : "IJCAI Wk. on Grammatical Inference Apps (pp. 73–82)",
      "citeRegEx" : "Smith and Eisner,? \\Q2005\\E",
      "shortCiteRegEx" : "Smith and Eisner",
      "year" : 2005
    }, {
      "title" : "Learning structured prediction models: A large margin approach",
      "author" : [ "B. Taskar", "V. Chatalbashev", "D. Koller", "C. Guestrin" ],
      "venue" : "Proc. Int’l Conf. on Machine Learning (pp. 897–904)",
      "citeRegEx" : "Taskar et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Taskar et al\\.",
      "year" : 2005
    }, {
      "title" : "A latent variable model for generative dependency parsing",
      "author" : [ "I. Titov", "J. Henderson" ],
      "venue" : "Int’l Conf. on Parsing Technologies",
      "citeRegEx" : "Titov and Henderson,? \\Q2007\\E",
      "shortCiteRegEx" : "Titov and Henderson",
      "year" : 2007
    }, {
      "title" : "HMM-based word alignment in statistical translation",
      "author" : [ "S. Vogel", "H. Ney", "C. Tillmann" ],
      "venue" : "Proc. Int’l Conf. on Computational Linguistics (pp. 836–841)",
      "citeRegEx" : "Vogel et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Vogel et al\\.",
      "year" : 1996
    } ],
    "referenceMentions" : [ {
      "referenceID" : 14,
      "context" : "Examples range from hidden alignment variables in speech recognition (Rabiner, 1989) and machine translation (Brown et al.",
      "startOffset" : 69,
      "endOffset" : 84
    }, {
      "referenceID" : 1,
      "context" : "Examples range from hidden alignment variables in speech recognition (Rabiner, 1989) and machine translation (Brown et al., 1993; Vogel et al., 1996), to latent trees in unsupervised parsing (Paskin, 2001; Klein & Manning, 2004; Smith & Eisner, 2005; Titov & Henderson, 2007), and to pose estimation in computer vision (Ramanan et al.",
      "startOffset" : 109,
      "endOffset" : 149
    }, {
      "referenceID" : 20,
      "context" : "Examples range from hidden alignment variables in speech recognition (Rabiner, 1989) and machine translation (Brown et al., 1993; Vogel et al., 1996), to latent trees in unsupervised parsing (Paskin, 2001; Klein & Manning, 2004; Smith & Eisner, 2005; Titov & Henderson, 2007), and to pose estimation in computer vision (Ramanan et al.",
      "startOffset" : 109,
      "endOffset" : 149
    }, {
      "referenceID" : 13,
      "context" : ", 1996), to latent trees in unsupervised parsing (Paskin, 2001; Klein & Manning, 2004; Smith & Eisner, 2005; Titov & Henderson, 2007), and to pose estimation in computer vision (Ramanan et al.",
      "startOffset" : 49,
      "endOffset" : 133
    }, {
      "referenceID" : 15,
      "context" : ", 1996), to latent trees in unsupervised parsing (Paskin, 2001; Klein & Manning, 2004; Smith & Eisner, 2005; Titov & Henderson, 2007), and to pose estimation in computer vision (Ramanan et al., 2005).",
      "startOffset" : 177,
      "endOffset" : 199
    }, {
      "referenceID" : 3,
      "context" : "Their applicability hinges on the tractability of (approximately) computing latent variable expectations, thus enabling the use of EM (Dempster et al., 1977).",
      "startOffset" : 134,
      "endOffset" : 157
    }, {
      "referenceID" : 7,
      "context" : "Under strong assumptions on the structures, the loss function and the features (essentially “locality” assumptions), a number of learning algorithms can be employed: for example, conditional random fields (Lafferty et al., 2001) or max-margin Markov networks (Taskar et al.",
      "startOffset" : 205,
      "endOffset" : 228
    }, {
      "referenceID" : 18,
      "context" : ", 2001) or max-margin Markov networks (Taskar et al., 2005).",
      "startOffset" : 38,
      "endOffset" : 59
    }, {
      "referenceID" : 0,
      "context" : "The key ingredient in Searn is to use the loss function ` and a “current” policy π to turn D into a distribution over cost-sensitive (multiclass) classification problems (Beygelzimer et al., 2005).",
      "startOffset" : 170,
      "endOffset" : 196
    }, {
      "referenceID" : 13,
      "context" : "global probabilistic models specified over dependency pairs (Paskin, 2001) or spanning trees (Klein & Manning, 2004; Smith & Eisner, 2005).",
      "startOffset" : 60,
      "endOffset" : 74
    }, {
      "referenceID" : 12,
      "context" : "However, there is an alternative, popular method for producing dependency trees in a supervised setting: shift-reduce parsing (Nivre, 2003; Sagae & Lavie, 2005).",
      "startOffset" : 126,
      "endOffset" : 160
    }, {
      "referenceID" : 12,
      "context" : "Shift-reduce dependency parsing (Nivre, 2003) is a leftto-right parsing algorithm that operates by maintaining three state variables: a stack S, a current position i and a set of arcs A.",
      "startOffset" : 32,
      "endOffset" : 45
    }, {
      "referenceID" : 12,
      "context" : "This algorithm is guaranteed to terminate in at most 2T steps with a valid dependency tree (Nivre, 2003), unlike standard probabilistic algorithms that have a time-complexity that is cubic in T (McDonald & Satta, 2007).",
      "startOffset" : 91,
      "endOffset" : 104
    }, {
      "referenceID" : 9,
      "context" : "We follow the same experimental setup as (Smith & Eisner, 2005), using data from the WSJ10 corpus (sentences of length at most ten from the Penn Treebank (Marcus et al., 1993)).",
      "startOffset" : 154,
      "endOffset" : 175
    }, {
      "referenceID" : 4,
      "context" : "Our algorithm uses the following features for the tree-based decisions (inspired by (Hall et al., 2006)), where t is the top of the stack and i is the next token: the partsof-speech within a window of 2 around t and i; the pair of tokens at t and i; the distance (discretized) between t and i; and the part-of-speech at the head (resp.",
      "startOffset" : 84,
      "endOffset" : 103
    }, {
      "referenceID" : 0,
      "context" : "This answers positively an open question in the field of learning reductions (Beygelzimer et al., 2005): can unsupervised learning be reduced to supervised learning? We have shown a nearequivalence between the resulting algorithm and the forward-backward algorithm in hidden Markov models.",
      "startOffset" : 77,
      "endOffset" : 103
    }, {
      "referenceID" : 5,
      "context" : "This is made most precise in the wake-sleep algorithm (Hinton et al., 1995), which explicitly trains a neural network to reproduce its own input.",
      "startOffset" : 54,
      "endOffset" : 75
    } ],
    "year" : 2009,
    "abstractText" : "We describe an adaptation and application of a search-based structured prediction algorithm “Searn” to unsupervised learning problems. We show that it is possible to reduce unsupervised learning to supervised learning and demonstrate a high-quality unsupervised shift-reduce parsing model. We additionally show a close connection between unsupervised Searn and expectation maximization. Finally, we demonstrate the efficacy of a semi-supervised extension. The key idea that enables this is an application of the predict-self idea for unsupervised learning.",
    "creator" : "TeX"
  }
}