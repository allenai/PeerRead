{
  "name" : "1303.5735.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Non-monotonic Negation in Probabilistic Deductive Databases",
    "authors" : [ "Raymond T. Ng" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 Introduction\n1\\lany fratneworks on nndlivalued logic progranuning liim' bc<'ll proposed to handk uncertain information. such as the Oll<'S described in [:l, !J, 1:1. 11, 21]. llow cwr, all these approaches are non-probabilistic in IIClltin', as tl1e way they iitl.t'rprPt ronjiinct.ions attd dis.itJnclioltS is too restrictive for p m habilisl.ic dala. Since prohabilil.y lh<'ory is well understood. we lwlieve llu1l a p robabilistic approach to quanl.itatiw ckdue t .io n iu logic prop;rat!Hlling is iutportant. In [lG, 17] we haw proposed <1 franl<'work for probabilistic ckductiw databases, i.<'. logic prog:rants \\Vit.hout. function SJ'l1I bols. We sltml· that t.l1is franl<'work is expressive, as anto11g others. it supports conditional prohahilities. clas:-;iral JH'g:at.ion, propagation of probahilit.i(�s, and Bayesian updai.<'s (cf. Example l ).\nllowevcr, ont: funclanwnt .al issue that re1nains UIJ '\\.cldressed in t.lw fnmwwork propos<•d in [!G. 17] is the rcprr'fwnt.a tion and n1a ni pu Ia t.ion of non-tnonotonic Inodcs of Iwg:a .t.ion. ln pa .rt.icula .r, tlw fra.nH�work is incn pnhk of ckfatdt rcasoninp; and drawing: n <-'g;at.ivt\" conclusions hasC'd on t.he abs( 1/Cf of posit.iv<� inforn1a-\nlion. 'l'lllls, our focus in this paper is l.o study the uses and tllC' scJnautics of non-tnonotonic negation in proLahili�tir Iogie progra.uuning. The setnillllical approach we adopt is based on the stable senl iuJt .ics of (classical) logic programming with ll <'gation [JL]. In a nulshcll, the stable semantics for cla�sic.a.l logic progra.111111ing n1akes a ''guess\" as to thf' set of fornndas provabk from' I he program. Based on this guess, it. t.ran�fonns the prograu J into a new pro granl COJll.aining tlO OCClll'rc'llCPS of negation, and VC'r jfi��S if' t.ltis gii<'S:-> sa.tisfies SOill<' rea.sonahk crit.rrion. Tlw \"guess\" [s said to he stab/, il' [t satisfies the crite rJO!l.\nlu l11is p<lp<'r W<' propose a s l.ahle semantics thai. is uatural f'or probabilistic logic programs with non lllOIJotonic negation. \\\\'c introduce tlH' notion of stable JorJIJu.la Juncliou.'i. and ex<uuiu<� various ronnrctio11s between this notion of' stability and fixpoints of op erators associated with this kind of probabilistic logic pnJgraJns. In dfi·cl, sl<1hk forlllula functions provides a fixpoint. S<'lll<llll.i('s for prohabilist.ic logic progra.Jlls with negation. llowev<'l', silllilar to the situation in classical logic progronnning , not all probabilistic logic programs haw slahle forn111la functions. Basccd on the �<'llltl lt.ics p ropos<'d in [�] for rlossical logic progran1tlling, W<' t I HIS providC\" a 1non' gcnC\"ral notion of 8iablr classrs of f'onllllia functions thai applif's lo all proba bilistic logic progra1ns.\nS<•ct.ion :! JH<'sents tlw Bynt.ax anclusc·s of prolmbilisl.ic logic programB (wit.honl function symbols) with nega tion. Secl.ion :) reviews the fixpoinl. theory for positive proL ;d >ilist.ic logic programs p n·scutccd iu [J(i, 17]. Sec tion 4 presents i.lw notion of stable formula functions. [I relat<·s stable formula functions to fix points of opn a.t.ors associated with prograu1s with negation. As pro grains nu1�.' not ha.v<� st.able fornmla functions, Section � extends I he notion of stability to prov ide set llaulics for such programs. Section G disntsseB how negation supports default r<�asoning , and con1pares our fra.nw work with related work. The last seet.ion concl11des t.his pap<�r with a discussiou on fut.ure work.\n250 Ng and Subrahmanian\n2 Syntax and Uses of General Probabilistic Logic Programs\n2.1 Gp-Clauses and Programs\nLet L be a language generated by finitely many con stant and predicate symbols. While L does not contain any ordinary function symbols, it may contain sym bols for a fixed family of interpreted and computable1 functions, known as annotation functions defined as follows.\nDefinition 1 An annotation function f of arity n IS a total function of type ( [0, 1])\"--+ [0, 1]. 0\n\\,Ye also assume that L contains infinitely many vari able symbols which are partitioned into two infinite subsets. The first subset consists of normal variable symbols in first order logic; they can only appear in atoms. We refer to these variables as object 1>ariables. The other set consists of annotation ·varzablc symbols. Annotation variables can only range between 0 and 1. Annotation variahk symbols can only appear in anno tation terms, a concept defined as follows.\nDefinition 2 1) pis called an annotation item if it is one of the following: i) a constant in [0, 1 J, or ii) an annotation variable in L, or iii) of the form !(51, ... , 8, ), where f is an annotation function of arity n and 8 1, ... , 8, are annotation items. :2) For real numbers c, d such that. 0 :S: c, d :S: 1, let the closed interval [ c, d] be the set { J> I c ::; J> ::; d } . :3) [p1, p2] is called an annotation (term) if Pi (i = 1, 2) is an annotation item. If an annotation does not contain any annotation vari ables, the annotation is called a c-annotation. 0\nLet BL denote the Herbrancl base of L. Since L does not contain any function symhols\", BI. is finite.\nDefinition 3 1) A basic formula, not. necessarily ground, is either a conjunction or a disjnnct.ion of atom:<. Note that. both disjund.ion and conjunction cannot occur simultaiwously in one hasic formula. :!) Ld bf( BL) <knot.e the set. of all ground basic for mulas obtained by using distinct atoms in BL, i.e. b f (BI-) = {A 1 1\\ . . . /\\ A.,ln :::0: 1 is an integer and A 1, . . • ,A, E BLand \\1 :S: i,j :S: n,i f. j =? .4; f. Aj} U {AJ V ... VA,In:::O: 1 is a1 integer andA1, ... ,A, E fh and \\11 ::; i, j ::; n, i f. j =? A; f. A j}, where all A; 's are ground atoms. 0\n1 A function f is co mputable in the sense that there is a fix0d pro cedure P1 such tha.t. if is n-ary, and Jl-1, ... , ttn are given a.s inputs to Pt, then f(J1· , ... , Jl·n) is computed by Pf in a fi11ite amount of time.\n2Whenever we say fnnct.ion symhob, we n1ean exclu sively thC' function symbols in normal first order logic, not including thP annotation fund.iou symbols defined pn'viously.\nDefinition 4 1) Let Fo, . . . , F,, G1, ... , Gm be basic formulas. Also let JJo, . . . , l\"n+m be annotations such that every annotation variable occurring in p.0, if any, also appears in one of /\"I, . .. , i\"n+m· Then the clause\nFo : JJo r- F1 : /\"I 1\\ . . . 1\\ F, : /\"n 1\\ -,(G!: l\"n+I) 1\\ ··.I\\ -,(Gm: Jl-n+m)\nis called a general probabilistic clause (g]J-cla1lse for short). 2) A pf-clause is a gp-clause without negated anno tated basic formulas, i.e. m = 0 [17]. 0\nDefinition 5 1) A general probabilistic (gp-)program is a finite set of gp-dauses. 2) A pf-program is a finite set. of pf-clauses [ 17]. 0\nIf the annotation JJ is a c-annotation [ c1, c2], the an notated basic formula F : p intuitively means: \"The probability ofF must lie in the interval [ c 1, c2] .\" Simi larly, the negation of the annotated formula, -,(G: p), is to be read as: \"It is not. provable that the probability of G must lie in the interval 11 . '' Hence, t.hc uegat.ion -, considered here is non-monotonic. Finally, not.c tl1at to specify that the probability of F is a point c, silll ply use F: [c, c]. The reason why we prefer t.o support probability ranges to probability points is that given the probabilities of two formulas F1, F'z, it. is g�ner ally not possible to precisely state the probabilities of ( F1 1\\ F2) and (F1 V F2) [1G]. It. is howcwr possi ble to precisely state the tightest range wit.hiu whicl1 these probabilities must lie. In [8] Fagin and Halpem also propose using an interval to represPut the degn'e of belief for a nonmeasurable event.\n2.2 Uses of Gp-programs\nIn the following we show a few exampks to demon strate the expri'ssive power of gp-danses. More exal!l ples on default reasoning are included in Section G.\nExample 1 In [17, 18], we show how to use gp-clauses to support propagation of probabilit.ies, classical nega tion and van Emden's quantitative rule processing[24]. Due to space limitations, here we only show how to support conditional prohahilities and Bayesian up elates in our framework. i) (Support for Conditional Probabilities:) Sup pose the conditional probability of A given B is known to be p. This is equivalent to saying: P1·ob(A 1\\ B) p * P 1'ob(B). Thus, we can use the pf-clause:\n(A/\\B):[p*VI,P*VI] B:[F1,VI] Similarly, if to calculate the conditional probability of A given B, denoted by (AlB), we can use:\n(AlB): W2/\\/I, l-\"2/Vd (AI\\ B): [l-2, \\/z] 1\\ B: [\\/1, FI],\nassuming that the probahilit.y of B is not 0. In [17] we show that. these clauses maintain the intl'nded condi tional probahility relationships.\nNon-Monotonic Negation in Probabilistic Deductive Databases 251\niii) (Bayesian Updates:) Bayes rule states that: Prob(BIA) = P>·ob(AIB) * Prob(B) / Prob(A) as suming P>·ob(A) # 0. Hence, the (updated) condi tional probability of B given A, can be calculated by the pf-clause:\n(BIA): fVt * V2/V3, Vt * Vz/V3] ..___ (AlB): [Vt, llt] A B: (V2, 1/2] A A: (V3, V3].\n0\nExample 2 Suppose we believe that if it is not prov able t.hat the probability of a coin C showing hea.ds is within th<' range [0.49, 0.51], then there is over 95% chance that the coin is unfair. The gp-clause:\nunfai>·(C): [0.95, 1] �(head(C): [0.49,0.51])\nrepresents our belief. 0\nExample 3 Suppos� we know that t.here is over 95'1,. chance that. a dog can hark, unless the dog is abnormal:�. We also know that. Benjy and F ido are dogs. llownw, Benjy is unable to bark (his vocal cords were injured at. some point). This ca.n be repre sented as:\ndoy(.fido): [1, 1] dog(brnjy) : [1, 1]\nlmrk(brnjy) : [0, 0] alm(X): [1, l ]\ndoy(X): [1, l] A �(abn(X) : [l, 1])\nbm·k(X) : [0, 0] The last clause says t .ha (. a dog is certainly abnormal if it definitely cannot hark. As we shall see la.ter on (cf. Example (i), we can deduc<> from these clauses the fact t.hat Fido call hark, bnt. Benjy cannot.. 0\nIn [ l fi] we also show how our framework can support mutual exclusion. See [18] for more details. 1n (17] we propose a fixpoint theory for pf-programs- negation frc'<' gp-programs. Our objective here is to investigate how to ext.<'JHI this th0ory to handle negation. To do so, we adopt the stable semantiral approach(12] for classical logic programming. But before we describe t.llf' stable semantics for gp-programs, we review the fixpoint theory we developed for pf-programs.\n3 Background: F ixpoint Theory for Pf-programs\nIn this section we summarize the essential notions and results of the fixpoint theory we developed for proba bilistic logic programs without negation a.s described in [ l ti, 17]. Headers familiar with (16, 17] may skip t his sect ion.\n2'Nof.(' that thi:-: statement is not the same a.s saying: '\"Over 95% of all dogs bark.''\nDefinition 6 1) Let a world W be an Herbrand inter pretation, i.e. a subset of BL. For ea.se of presentation, assume there is an arbitrary, but fixed enumeration of all possible worlds/snbsets of BL. Such enumerations are possible as L contains no function symbols. 2) A world probability density f1tnction W P : 2BL --+ (0, 1] assigns to each world w1 E 2BL a probability W P(Wj) such that for all w1 E 2BL, W P(W1) � 0 and L W P(Wj) = 1.\nWjE2BL 3) To simplify our notation, hereafter denote W P(l-'Vj) for w1 E 2BL. we use Pi to 0\nIn the context of probabilistic deduction, we a.ssume that the \"real\" world is definite, i.e. there are some propositions that are true, and some that are false. However, we are nnc<>rtain which of the various \"pos sible worlds\" is the right one. Thus, we use a. world probability density function to define probability den sities on the set of all possible worlds. In other words, a world probability density function assigns a proba bility (i.e. a non-negative number) to each world such that the sum of a.ll probabilities adds up to I. Our notions of worlds and world probability density func tions are similar in essence to the \"possible worlds\" approach suggested by Nilsson (HJ]. While Nilsson's enumeration of the possible worlds is based on the given set of sentences, ours is hRs<>el on the Herbrancl interpretations of L. In the study of the semantics of pf-programs, our aim is to use the probability ranges described in a pf-program to find the probabilistic truth values (i.e. point proba bilities) of basic formulas. In particular, we use the probability ranges to find world probability density functions that obey those ranges. While the process will be fonualized shortly, the following notion of a formula function is crucial for the process.\nDefinition 7 1) Let C(O, 1] denot.c the set of all closed sub-intervals of the unit. interval (0, I], i.e. the sd of all (contiguous) dosed intervals [c, en that. arc snhset.s of [0, I]. 2) A formula function is a mapping h bf(lh) C�, l]. o\nThe empty interval, denoted by 0, is a member of C(O, 1], because it may be represented as (cJ, c2] where c2 < C[. Intuitively, a formula function assigns a prob ability range to each ground basic formula. Then given a formula function, we can find world probability den sity functions that obey the ranges assigned by the formula function. This is achieved by setting up a. set of linear constraints, as described in the following def inition.\nDefinition 8 1) Let. h be a formula function. A set. of linear constraints, denoted by .CC( h), is defined as follows. For all Fi E bf(lh ), if h( P;) = [ci, di], then\n252 Ng and Subrahmanian\nthe inequality c; :::; ( 2:= 8 • Pi) :::; d; is in W1FF; andWjE2 L L:C(h) (w here Pi's are used as specified in Definition 6). In addition, L:C(h) contains the following 2 constraints:\n2:= Pi= 1 and ('v'Wj E 28LJ,Pi ?_ 0. WjE28L 2) Let WP(h) denote the solution set of L:C(h). 0\nIt is easy to see that each solution WP E WP(h) (i.e. the solution set of L:C(h)) is a world probability den sity function. Also note that 28L consists of all possi ble worlds, and any two distinct worlds are mutually incompatible as they must differ on at least one atom. Thus, given a world probability density function W P, we can compute the probabilistic truth value of any basic formula F with respect to W P by adding up the probabilities of all the possible worlds in which F' is true in t.he classical 2-va.lued sense. Hence, it is the set L:C(h) of linear constraints that enables us to find probabilistic truth values that satisfy the ranges as signed hy the formula function h. Now we are in a. po sition to define a fixpoint operator Tp for pf-programs P. llereafter we use t.he notation FF to denote the set of all formula functions, and minq(El,p) and maxq ( FJ:cp) to denote the minimization and maxi mization of the expression Exp subject. to the set of constraints Q.\nDefinition 9 Suppose P is a pf-program and h is a. formula function. l) Define an intermediate operator Sp : FF -• FF as follows: For all FE bf(BL), Sp(h)(F') = n Mp where Mp = {n I F: n ,._ F1 <'1 II ... II Fn :\"\"is a. ground instance of a clause in P, ami for all 1 :::; i:::; n,h(Fi) <;; ni } . In particular, if Mp is empty, set. Sp(h)(F) = [0, l].\n2) Define Tp : FF -• FF as follows: i) If );VP(.'i'p(h)) is non-empty (i.e. L:C(Sp(h)) has so lutions), then for all FE bf(HL), Tp(h)(F ) = [cJ·, dF] where\n( L 1') and WiJ=F and W1E�\"L J\ndp = lHaxi<'!SpihJI ( L Pi) . W.1I=F a11.d lf'_7E:.?BL ii) OthcrwisP, if WP(Sp(h )) is empty, then for all FE bf(JJL), l'p(h)(F) = 0. D\nlnfonnally, Sp(h) is a one-step immediate consequence operator that. dctPnnines th<> probability ranges of ba sic formulas hy o1w-stcp deductions of tlw pf-dauscs in !'. But since basic formulas can appear as the heads of pf�cl:lllS<'S, as au example th<' following situation may anse: Sp(h)(;1 V /J) = [0,0]. hut .'i'p(h)(A) =\nSp(h)(B) = [1, 1] . By regarding [1, 1] as trne and [0, 0] a.s false, these range assignments are not consistent. In genera.!, \"local\" assignments of probability ranges to formulas may not be \"globally\" consistent. Hence, the linear program L:C(Sp(h)) is set up to ensure that all assignments are consistent. Then Tp assigns to each formula a probability range that satisfies every con straint in the linear program.\nGiven two formula functions h1 and h2, we say that h1:::; h2 iff\\fF E bf(BL), h1(F) 2 h2(F'). As shown in [16], the set FF of formula functions forms a complete lattice with respect to the ordering :::; defined above. Moreover, the T element is the formula. function h such that \\f F' E bf(BL ), h(F') = 0, and the j_ element is the one such that IfF' E bf(BL), h(F) = [0, 1]. In [17] we show that Tp is monontonic, and thus there exists a least fix point lfp(Tp) of Tp.\n4 Stability of Formula Functions\nIn the presence of negation, the fixpoint operator as sociated with a pf-program (cf. Definition 9) must lw extended to handle 1wgation. \\Ve use 7�, to denote the fixpoint operator associated with a gp-program P.\nDefinition 10 Suppose I' is a gp-progran1 and h is a formula. function. 1) Define an intc>rmediate operator S'p : FF - FF as follows: For all FE bf(BL), S'p(h)(F) = n M}. wl1er<' !1J;, = {c> I F : n c- F1: <t1 11 ... 11 F;,: n, II�((;I: i}l) II ... II �( Gm : ;3m) is a ground instance of a cia ww in P, for all1:::; i:::; n,h(F;) <;; n;, nnd for all 1:::; j:::; m,h(Gj) 1£ ;'3j}. In part.iwlar, if M;, is empty, set s�,(h)(F) = [o, lJ. 2) T� is obtained from S�, in exact.ly t.ii<' ,;anw way as Tp is obtained from .')p. 0\nThe example below shows that 7'f, is not monotoniC'.\nExa1nple 4 Consider the gp-program P descrilwd in Example 2:\n]J: [0.9!i, 1] �(q: [0.49, 0.51]).\nSuppose h1 is a formula function that assigns [0, 1] to q, and h2 is one that assigns [0.5,0.5] to q. Suppose that h.1 and h2 assign [0,1] to all other basic formulas. Thus, it is the case that. h1 :::; h2. But. then, 7'f,(h.I) assigns [0.95,1] t.o p, wbik 1;,(h2) assigns [0,1] to p . Therefore, 7'f,(h1) is not Il<'cessarily !f'ss than or equal to 1�,(h� ) . 0\nIn the following we define the notion of stable formula functions, adapted from the stable model semantics proposed by (�elfond and Lifschitz [1:!]. We ultimately show that if there <'xists a stable formula function with respect to a gp-progran1 P. the for mula function is a minimal fixpoint of 7';,.\nNon-Monotonic Negation in Probabilistic Deductive Databases 253\nDefinition 11 Given a gp-program P and a for mula function h, the formula-function-transform (ff transform for short) of P based on h, denoted by f f(P, h), is defined as follows: I) Given a ground instance C' = F : a <- F1 : a1 /\\ ... /\\ F, :an /\\•(GJ :{31) /\\ ... /\\ •(G, :f3m) of a clause in P, if h( Gj) !£ f3j for all 1 :::; j :::; m, then the clause C = F : a ,_ F1 : rq 1\\ .. . 1\\ F, : a, is included in ff( P, h). 2) Nothing else is in ff(P, h). D\nDefinition 12 Let P be a gp-program. A formula function h is stable with respect to P if h is equal to the least fixpoint ofTJJ(P,h)· i.e. h = lfp(TJ.f(P,h)). D\nExample 5 Consider again the gp-program P:\np: [0.95, 1] <- •(q: [0.49, 0.�1]), where p, q ar<e ground. Then given the formula function h1 such that. hJ (p) = [0.%, I] and hJ(q) = [0, 1], the ff-t.raJtsfonn of P based on h 1 is the single clause:\n)i: [0.\\JfJ, 1]\nTIH>n the least fixpoint lfp(1JJIP,h, J) assigus [0.�15, 1] top and [0,1] to q. Hence, h1 is stable. In fact, it is easy to show that h 1 is the only stable formula fnnd.ion[l8]. D\nExample 6 Consider the gp-program P for Benjy and Fido shown in Example :l. Ld. a formula function h1 assigns [0.0] t.o bark(bcnjy), [1,1] to abn(benj,q), [0.\\15,1] to bal'!.:(fido), and [0.1] to ulm(fido). Then f f(P, h1) consists of the following clauses:\nbm·k(fido): [O.fl5, 1] dog(fido) : [L, 1]\ndog(fido) : [1, 1]\ndoy(benjy) : [!, 1] bark(lu njy) : [0, OJ\nalm(br11jy): [1, l ]\nalm(fido): [1. 1]\nbad:(bcnjy) : [0, OJ\nbark(fido) : [0, 0].\nlt is easy to check that /11 = ljp(Tr.r1P,h, 1). Therdorc, h1 is stable. In fact., it is easy to verify that h1 is the only st.able forntula funct.ion for this gp-progralll. D\nThe exnmples he! ow show I hat there are gp-programs that have none or more than one stable formula func tion.\nExample 7 Thre gp-progrant that consists of the sin gle clause he! ow:\nl' : [0 95, l] •(p: [lUl!i, !]) does not have a stable formub function. See [It'\\] for a proof. D\nExample 8 The gp-progra1n that consist.s of the fol lowing clauses:\n}J: [0.!15, 1] If : [0.4!J, {) fl I]\n•(q: [0.4!), 0.51]) •(]!: [0.95, 1])\nhas two stable formula funct.ions: i) h1 such that. h1(p) = [0.95,1] and ht(q) = [0,1], and ii) h2 such that h2(p) = [0, 1] and h2(q) = [0.49, 0.51]. D\nIntuitively, a stable formula function with respect to a gp-program makes \"reasonable\" guesses on the proba bility ranges assigned hy the program t.o basic formu las. In particular, the following theorem shows that a stable formula function with respect to gp-program P is a minimal fixpoint ofTf, (cf. Definition LO).\nTheorem 1 Let. h he a stable formula. function with respect to gp-program P. Then: h is a minimal fix point of Tf,, i.e. there does not exist any formula func. tion h' < h such that Tf,(h') = h'- D\nFrom Theorem 1, we can conclude that every stable formula function is a minimal fixpoint of Tf,. But the following example shows thAt the converse is not true.\nExample 9 Cousider the g;p-program P that consists of the following clauses:\n}J : [0.95, 1 J\np : [0.95, I]\nq: [l , l]\n•(p • [0.95, l J) 'I : [I , l) I[ : [I' 1].\nIt is easy to check that the formula function h that assigns [0.95.1] top and [1,1] to q is a minim al fixpoint of7� . However, his not stable[!�]. D\nThus far, we have iut.roduced the notion of stable for mula funct.ions which has the desirable property that it is a minimal fixpoint of 1'[,. In effect, stable for mula functions provide a fixpoint. semantics for gp programs . Howevn, as shown in Example 7, a gp program does not twcessarily have a stable formula function. It is therefore the pmposc of the next sec t.ion to extend our theory of stability to cover those IHogranls.\n5 Stable Classes of Formula Functions\nIn [2] Baral and Subrahmanian propose a st.'able and <'Xt<·nsion daoo theory for logic programs <llhl d<'fault. logics. Here we adopt an analogous approach in proposing a stahk dass of formula fund.ions defined as follows.\nDefinition 13 Let P \\w a gp-program, and .SF lw a finite sd of formula fuuctions. Then: SF is a slabh class of formula functions with respect to P iff SF = {lfpCFrr!P,h,1) ih;ES'F). D\nlntuitivdy, a formula function h, in a stable class is the same as the least fixpoi nt. of an operator associated with tlw ff-t.ransform of P based on some nwmher hj in t.lwst.ahleclass, i.e. h; = l.fp('ff.III',I:,J). In general, every nwtnlwr in t.he class is rdal<'d in the samt' way\n254 Ng and Subrahmanian\nwith some other member in the class. See [2] for more details on stable class theory. In short, a stable class of formula functions with respect to a gp-program repre sents a set of \"reasonable\" guesses on the probability ranges assigned by the program to basic formulas.\nExample 10 Consider the gp-program in Example 7 again. A stable class of the program consists of the two formula functions: h1(p) = [0.9.5, 1] and h2(p) = [0, 1]. It is easy to check that h1 = lfp(TJJ(P,h,J) and h2 = lfp(1j j(P,h.))· 0\nLemma 1 A formula function h is a stable formula function with respect to gp-program P iff the singleton set {h} is a stable class with respect toP. 0\nThe aim of the remainder of this section is to prove that every gp-program has a non-empty stable class of formula functions (cf. Theorem 2).\nDefinition 14 Let P be a gp-program and h be a formula functiou. Define the operator S:F p : :F:F �· :F:F as: S:Fp(h) = lfp(1jJIP,h)l· 0\nLemma 2 The operator S:F p is anti-monotonic, i.e. h1 ::; h2 implies S:F p(h2)::; S:F p(hl ). 0\nThe following theorem is now an immediate conse quence of the above lemma and a theorem by Yablo[25] and Fitting[IO] .\nTheorem 2 Every gp-program has a non-empty st.a hle class of formula functions. 0\nTlw tlworem above states that every gp-program has a non-empty stable class of formula functions. Sup pose C1, C2 arc two sets of formula functions. Recall that the ordering ::; applies to formula functions. \\Vc extend this ordering now to Mls of formula functions (and hence to stable classes) in two ways. Both or derings arc wdl known in algebraic structures called powrr domains due to Hoare ;wd Smyth [2:l].\nDefinition 15 Let 5'1, S', be two sets. We say that: 1) 81 :'Ssmyth 8� iff (lfs1 E S'J)(:Js� E 82) ·'1 :'S s2, and 2) S'l :'Shoare 5'2 iff (lfs2 E S'2)(3sl E sl) Sj ::; S:J. 0\nDefinition 16 1) A uon-cmpty stable class C is said t.o lw Jfoa.re-minirna.l iff: i) C is inclusion-minimal, i.e. there is no non-empty stable class C' such that C:' C C and ii) for every inclusion-minimaluon-empty finite stabk class C', C' :'S!ware C implies C\n' = C. 2) Cis said to be Smyth-minimal iff condition (i) above holds and condition (ii) holds with :'Shoar·e replaced by :'Ssmyth · 0\n\\.Yc may choose either Iloare-minimal stable classes or Smyth-miuimal stable classes as the intended meaning\nof our program. However, depending on the choice we make, we may get different semantics as shown below.\nExample 11 Consider the gp-program: p: [1, 1] ,__ a : [1, 1]\np: [1, 1] ,__ b : [1, 1] a : [1, 1] ,__ ·(b: [1, 1]) b : [ 1, 1] •(a : [1, 1]).\nThis program has two stable formula functions: i) h 1 that assigns [1, 1] to both p and a, and ii) h2 that assigns [1, 1] to both p and b. Furthermore, suppose h3 is the function that assigns [1, 1] to all of p, a, b a.nd h4 is the function that assigns [0, 1] to all of p, a, b. Then the set {h3, h4} is a stable class of formula functions.\nNote that here {hi} and {h2} are both Smyth-minimal stable classes of formula functions. Hence, the Smyth minimal stable class semantics assigns [1, 1] top. How ever, {h3, h4} is the unique Hoare-minimal stable class of formula functions. This Hoare-minimal class only allows us to conclude that p gets the value [0, 1]. 0\nIn short, we have introduced the notion of a stable class of formula functions for gp-programs. L<>mma 1 shows that if h is a stable formula function, then the singleton set {h} is a stable class. Thus, the sta ble class semantics is defined for all gp-programs - whether or not they have stable formula functions.\n6 Discussion\nLike many researclwrs, we arc interested in the use of numerical estimate:; in default reasoning. Unfortu nately the framework we proposed in [ 17] is not power ful enough to hand I<' default rules and exceptions. But now with the support. of the non-monotonic negation •, we can specify that a. default rule is only applicable in the absence of evidence to the contrary. Example (i shows that the stahl<� semantics proposed here han dles the interaction lwtween default mles and excep tions appropriately. Furthermore, the following exaln pks demonstrate that t.hc proposed se1nantics can also deal with interacting default rules.\nExample 12 In [21], Reiter and Criscuolo consider the following situation: i) that John is a high school dropout, ii ) that high school dropouts are typically adults, and iii) that. adults are typically employed. Due to transitivity of default rules ii) and iii), the conchl sion that John is employed can lw deduced . They argue that this conclusion is undesirable.\nNow consider the following gp-program P1:\nadult(X) : [0.95, 1] cmployed(X) : [0.%, I]\nabn(X): [1, 1]\ndropout( X) : [1, 1] adult(X): [1, 1] A •(abn(X) :[I, 1]) dl·opout(X): [I, 1].\nNon-Monotonic Negation in Probabilistic Deductive Databases 255\nSuppos� initially ?1 contains the fact: adult(john) : [1, 1] ,_ _ Then it is easy to check that the only stable formula function with respect to ?1 assigns the range [0,95,1] to employed(john) correctly. Suppose d1·opmtt(john): [1, 1] ;- is added to ?1. Call this new program ?2. Consider the formula function h that assigns [1 ,1] to adult(john), dropout(jolm) and alm(john), but [0,1] to employed(john). It is easy to check that h is a unique stablP formula function with respect to ?2.\nFinally, consider the situation where the only known fact about .John is that he is a high school dropout, J.e. deleting the fact about John's adulthood from program ?2. Call th is new program ?3. The unique stable formula function with respect to ?3 is the> one that assigns: [1,1] to dropout(john) and abn(john), [O.DG,l] to adult(john), and [0,1] to cmployrd(john). li enee , undesirable conclusions due to transiti v ity of default rules are avoided. 0\n'J'lw fr ame work proposed by Dubois and Prade [GJ also handles the situation discussed in the above example. However, their semantics is different from ours, as their framework is based 011 possibility logic and their model theory is based on fuzzy sds [26] which are well-kuown to he JIOil-probabi\\istic. The following example CHI in teracting default rules has been discussed extensively, hut see [11, 20] for a. probabilistic treatme11t on the subject.\nExample 13 Consider the situation: i) that tweety IS a peng;um, ii) !hat a penguin is a bird. iii) that typically penguins can11ot fly, and iv ) that birds can typically fly. The situation can be represented by the following gp-program:\nfly( X) : [0.90, 1]\nfly( X) • [0, 0.05]\nbird( X): [1, 1] aim Bini( X): [1, 1] <\nfwnyu.iii(Ltcr.dy): [1, 1]\nbh·d(X) : (1, I] A\n•(abnBh·d(X): [1, 1])\npengnin(X): [1, 1]A\n•(abnPcny(X): [1, 1])\npengui11(X) : [1, 1]\npenguin(X) : [I, 1 J\nConsider the formula function h that assigns: [1, 1] to pcngnin(twcety), bird(tweety) and abnBird(tweety), [O,O.OGJ to fly(lwccty), and [0,1] to abnPeng(twcety). Again it is easy to show that h is the unique stable formula. function with respect to the program. 0\nThus far , we have shown several examples on how to handle default reasoning in our framework. But our framework is not as expressive as the probabilistic frameworks proposed by Bacchus[! J and Buntine[4]. For instance, given the above example, their frame works can c:onducle that \"birds typically are not pen guins.\" Such a conclusion is not deducible in our\nframework, and in ongoing research we are study i ng how to extend our theory to handle such cases. How ever, aB the framework of Bacchus extends full first order logic, it is unclear to us how his framework can be used as a basis for logic programming and deduc tive databases. Similar comments apply to Buntine's proposal.\nThere have also been many proposals on multivalued logic programming. These include the works by Blair and Subrahmanian [3], Fitting [D], Kifer et al [13, .14], and van Emden [24]. However, they do not. support non-monotonic modes of negation . On the other hand, the integration of logic and probability theory has been the subject of numerous studies [1, 5, 7, 8, 15, 22, 19]. While [HJ, 17] prov ides more details on these works, it suffices to point out here that these works have con cerns quite different from ours, and that. it. is unclear how (.o use these formalisms to support probabilistic logic programs and deduct.ive databas<es.\n7 Conclusions\nIn this paper we study tlw semantics and the uses of probabilistic logic programs with non-monotonic: nega tion (i.e. gp-programs). Based on the. stahle semanti cal approach for classical logic: programming, we inves tigate the notion of stable formula functions. We show that stable formula functions are minimal fixpoints of operators associated with gp-programs. While some gp-programs may not. hav<e stable formula functions, we provide a stable class semantics that. applies to all gp-programs. Finally, we demonstrate by exam ples how the proposed semantics can handle default reasoning appropriately in the context of probabilistic deduction.\nIn ongoing research, we are studying how to sup port empirical probabilities in our framework. VVe arc also interested in designing a proof procedure for gp programs. In particular, we are investigating whether it suffices to augment the proof procedure we devel oped for positive probabilistic logic programs with some kind of negation as failure rule.\nAcknowledgements\nThis research was partially sponsored by the National Science Foundation under Grant IRI-87194.58 and by the \"Office of Graduate Studies and Research of the University of Maryland.\"\nReferences\n[1] F. Bacchus . ( 1988) Representing and Reasoning with Probabilistic Knowledge, Research Report CS-88-31, University of Waterloo.\n[2] C. Baral and V.S. Subrahmanian. (1990) Sta ble and Extension Class Theor·y for Logic Pro-\n256 Ng and Subrahmanian\ngrams and Default Logics, to appear in: .Journal of Automated Reasoning. Prelim inar y version in: Proc. 1990 Inti. Workshop on Non-Monotonic Reasoning, ed K. Konolige, .June 1990.\n[3] H. A. Blair and V.S. Snhrahmanian. (1987) Pamconsistcnt Logic Progmmming, Theoretical Computer Science, G8, pp :3:)-!i1. Preliminary version in: Proc. 7th Conference on Foundations of Software 1'fc·huology and Theoretical Com puter Science, Lecture Notes in Computer Sci ence, Vol. 287, pps 340 -:3GO, Springer Verlag.\n[4] W. Buntine. (1990) Modelling Default and Like lihood Reasoning as l'mbab'l istic, Technical Re port FIA-D0-09-11-01, NASA Ames Research CentN.\n[5] A. P. Dempster. ( 1\\J68) A Gencmli.:ation of Ba.ycsian Inference. .] . of the Royal Statistical Society, Series B, �0. pp :lO!i-247.\n[6] D. Dubois and H. Prack. (H188) Default Rw soning and Possibilil,q Theory, Artificial Iut.dli gence, 35, pp 24:3-2G7.\n[7] R. Fagin and .J. llalpcm. (H188) Uncertainty, Belief and Pmbabdity, in Proc. l.JCAI-89, Mor gan Kauffman.\n[8] R. Fagin, .J. Y. Halpem and N. Megiddo. (1\\189) A Logic for Reasoning About Pml>abililies, to ap pear in: Information and Computation.\n[9] M. C. F itting. (1988) Hi/altius and the Seman tics of Logic Programming, l.o appear in: .Journal of Logic Progranuning.\n[10] M. C. Fitting. (H190) personal correspondence.\n[11] H. Geffner. (HI89) Default Rea.5oning: Causal a11d Conditional Theories, Technical Report 137, Cognitive Systerns Laboratory, Uuiversity of California, Los Angeles.\n[12] M. Gelfand and V. Lifschitz. (1988) I'hr Sta ble Model Semantics for Logic Programming, in: Proc. 5th lntemational Conference and SylllpO sium on Logic Pro;;ranuning, ed R. A. l�owah<ki and K. A. Bowerr, pp 1070-1080.\n[1:3] M. Kifer and E. Lozinskii. ( 1DEI9) R/: A Logic for Reasoning with Inconsistency, Proc. 4-th Sym posium on Logic in Computer Science, Asilomar, CA, pp. 25:�-262. Full version to appear in: .Jour nal of Automated Reasoning.\n[14] M. Kifer and V. S. Subralnnanian. (19�)1) The ory of Gcnerali.ocd A.nnolatul Logic Program ming and its Applzcat-ions, to appear in: .Journal of Logic Programming.\n[15] H. Kybmg. (1974) The Logical Fou.nda.tions of Statistical Inference, D. Reidel.\n[16] R.T. Ng and V.S. Subrahmanian. (1989) Prob abilistic Logic Pr·ogramming, to appear in: In formation and C:omputa Lion. Preliminary ver-\nsion in: Proc. 5th International Symposium on Methodologies for Intellig<'nt SystPms, pp 9-16.\n[17] R.T. Ng and V.S. Suhrahmanian. (1\\190) A S'emantical Framework for· Supporting Subjec tive and Conditional Probabilzties in Deductive Databases, to appear in: Pror. 1991 Interna tional Conference of Logic Programming, ed I�. Furukawa, MIT Press. Full version in: Tedmi cal Report CS-TR-256:�, University of Maryland, College Parle\n[18] R.T. Ng and V.S. Subrahmanian. (HI�JO) S'ta.ble Semantics for Probabilistic Dcducti1•e Databases, Technical Report CS-TR-257.3, University of Maryland, College Park.\n[19] N. Nilsson. (198G) Probabilzstic Logic, Artificial Inelligence, 28, pp 71-87.\n[20] .J. Pearl. (19X8) Probabilistic Rea8oning in lntcl ligenl Systems: Networks of 1'/a.usib/e Inference, !\\forgan Kaufmann.\n[21] R. Reiter and G. Criscuolo. (lD81) On intcracl ing Defaults, in Proc. I.JC'Al 81, pp 270-276.\n[22] G. Shafer. (1976) A Mathematical T heory of Ev i dence, Princeton University Press.\n[23] M. Smyth. (1978) Pouu Domains, .Joumal of Computer and Systems Sciences, 16, 1 pp.� 23- 36.\n[24] M.H. van Emden. (1986) Quantitalillf Deduc tion and its Fixpoinf Tlum·y, .Jomnal of Logic Pro gramming, 4, 1. pp 37-5:3.\n[25] S. Yablo. (1\\185) Truth and Reflection, .Journal of Philosophical Logic, 14, pps 27\\J-:34!J.\n[26] L.A. Zadeh. ( 1965) Fuzzy Sets, Information and Control, 8, pp 338<)5:3."
    } ],
    "references" : [ {
      "title" : "Representing and Reasoning with Probabilistic Knowledge, Research Report CS-88-31",
      "author" : [ "F. Bacchus" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1988
    }, {
      "title" : "Sta­ ble and Extension Class Theor·y for Logic Pro-  256 Ng and Subrahmanian grams and Default Logics, to appear in: .Journal of Automated Reasoning",
      "author" : [ "C. Baral", "V.S. Subrahmanian" ],
      "venue" : "Prelim inar y version in: Proc. 1990 Inti. Workshop on Non-Monotonic Reasoning,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1990
    }, {
      "title" : "Pamconsistcnt Logic Progmmming, Theoretical Computer Science, G8, pp :3:)-!i1",
      "author" : [ "V.S.H.A. Blair" ],
      "venue" : "Snhrahmanian",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1987
    }, {
      "title" : "Modelling Default and Like­ lihood Reasoning as l'mbab'l istic, Technical Re­ port FIA-D0-09-11-01, NASA Ames Research CentN",
      "author" : [ "W. Buntine" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1990
    }, {
      "title" : "Hi/altius and the Seman­ tics of Logic Programming, l.o appear in: .Journal of Logic Progranuning",
      "author" : [ "M.C. F itting" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1988
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Definition 1 An annotation function f of arity n IS a total function of type ( [0, 1])\"--+ [0, 1].",
      "startOffset" : 79,
      "endOffset" : 85
    }, {
      "referenceID" : 0,
      "context" : "Definition 1 An annotation function f of arity n IS a total function of type ( [0, 1])\"--+ [0, 1].",
      "startOffset" : 91,
      "endOffset" : 97
    }, {
      "referenceID" : 0,
      "context" : "fido): [1, 1] dog(brnjy) : [1, 1] lmrk(brnjy) : [0, 0] alm(X): [1, l ] doy(X): [1, l] A �(abn(X) : [l, 1])",
      "startOffset" : 7,
      "endOffset" : 13
    }, {
      "referenceID" : 0,
      "context" : "fido): [1, 1] dog(brnjy) : [1, 1] lmrk(brnjy) : [0, 0] alm(X): [1, l ] doy(X): [1, l] A �(abn(X) : [l, 1])",
      "startOffset" : 7,
      "endOffset" : 13
    }, {
      "referenceID" : 0,
      "context" : "fido): [1, 1] dog(brnjy) : [1, 1] lmrk(brnjy) : [0, 0] alm(X): [1, l ] doy(X): [1, l] A �(abn(X) : [l, 1])",
      "startOffset" : 27,
      "endOffset" : 33
    }, {
      "referenceID" : 0,
      "context" : "fido): [1, 1] dog(brnjy) : [1, 1] lmrk(brnjy) : [0, 0] alm(X): [1, l ] doy(X): [1, l] A �(abn(X) : [l, 1])",
      "startOffset" : 27,
      "endOffset" : 33
    }, {
      "referenceID" : 0,
      "context" : "'i'p(h)(A) = Sp(h)(B) = [1, 1] .",
      "startOffset" : 24,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : "'i'p(h)(A) = Sp(h)(B) = [1, 1] .",
      "startOffset" : 24,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : "By regarding [ 1, 1] as trne and [0, 0] a.",
      "startOffset" : 13,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "By regarding [ 1, 1] as trne and [0, 0] a.",
      "startOffset" : 13,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "function h such that \\f F' E bf(BL ), h(F') = 0, and the j_ element is the one such that IfF' E bf(BL), h(F) = [0, 1].",
      "startOffset" : 111,
      "endOffset" : 117
    }, {
      "referenceID" : 0,
      "context" : "Suppose h1 is a formula function that assigns [0, 1] to q, and h2 is one that assigns [0.",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "1 and h2 assign [0,1] to all other basic formulas.",
      "startOffset" : 16,
      "endOffset" : 21
    }, {
      "referenceID" : 0,
      "context" : "o p, wbik 1;,(h2) assigns [0,1] to p .",
      "startOffset" : 26,
      "endOffset" : 31
    }, {
      "referenceID" : 0,
      "context" : "%, I] and hJ(q) = [0, 1], the ff-t.",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "�15, 1] top and [0,1] to q.",
      "startOffset" : 16,
      "endOffset" : 21
    }, {
      "referenceID" : 0,
      "context" : "o bark(bcnjy), [1,1] to abn(benj,q), [0.",
      "startOffset" : 15,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "o bark(bcnjy), [1,1] to abn(benj,q), [0.",
      "startOffset" : 15,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "dog(fido) : [1, 1] doy(benjy) : [!, 1]",
      "startOffset" : 12,
      "endOffset" : 18
    }, {
      "referenceID" : 0,
      "context" : "dog(fido) : [1, 1] doy(benjy) : [!, 1]",
      "startOffset" : 12,
      "endOffset" : 18
    }, {
      "referenceID" : 0,
      "context" : "95,1] and ht(q) = [0,1], and ii) h2 such that h2(p) = [0, 1] and h2(q) = [0.",
      "startOffset" : 18,
      "endOffset" : 23
    }, {
      "referenceID" : 0,
      "context" : "95,1] and ht(q) = [0,1], and ii) h2 such that h2(p) = [0, 1] and h2(q) = [0.",
      "startOffset" : 54,
      "endOffset" : 60
    }, {
      "referenceID" : 0,
      "context" : "1] top and [1,1] to q is a minim al fixpoint of7� .",
      "startOffset" : 11,
      "endOffset" : 16
    }, {
      "referenceID" : 0,
      "context" : "1] top and [1,1] to q is a minim al fixpoint of7� .",
      "startOffset" : 11,
      "endOffset" : 16
    }, {
      "referenceID" : 1,
      "context" : "In [2] Baral and Subrahmanian propose a st.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : "See [2] for more details on stable class theory.",
      "startOffset" : 4,
      "endOffset" : 7
    }, {
      "referenceID" : 0,
      "context" : "5, 1] and h2(p) = [0, 1].",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "p: [1, 1] ,__ a : [1, 1]",
      "startOffset" : 3,
      "endOffset" : 9
    }, {
      "referenceID" : 0,
      "context" : "p: [1, 1] ,__ a : [1, 1]",
      "startOffset" : 3,
      "endOffset" : 9
    }, {
      "referenceID" : 0,
      "context" : "p: [1, 1] ,__ a : [1, 1]",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "p: [1, 1] ,__ a : [1, 1]",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "p: [1, 1] ,__ b : [1, 1]",
      "startOffset" : 3,
      "endOffset" : 9
    }, {
      "referenceID" : 0,
      "context" : "p: [1, 1] ,__ b : [1, 1]",
      "startOffset" : 3,
      "endOffset" : 9
    }, {
      "referenceID" : 0,
      "context" : "p: [1, 1] ,__ b : [1, 1]",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "p: [1, 1] ,__ b : [1, 1]",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "a : [1, 1] ,__ ·(b: [1, 1]) b : [ 1, 1] •(a : [1, 1]).",
      "startOffset" : 4,
      "endOffset" : 10
    }, {
      "referenceID" : 0,
      "context" : "a : [1, 1] ,__ ·(b: [1, 1]) b : [ 1, 1] •(a : [1, 1]).",
      "startOffset" : 4,
      "endOffset" : 10
    }, {
      "referenceID" : 0,
      "context" : "a : [1, 1] ,__ ·(b: [1, 1]) b : [ 1, 1] •(a : [1, 1]).",
      "startOffset" : 20,
      "endOffset" : 26
    }, {
      "referenceID" : 0,
      "context" : "a : [1, 1] ,__ ·(b: [1, 1]) b : [ 1, 1] •(a : [1, 1]).",
      "startOffset" : 20,
      "endOffset" : 26
    }, {
      "referenceID" : 0,
      "context" : "a : [1, 1] ,__ ·(b: [1, 1]) b : [ 1, 1] •(a : [1, 1]).",
      "startOffset" : 32,
      "endOffset" : 39
    }, {
      "referenceID" : 0,
      "context" : "a : [1, 1] ,__ ·(b: [1, 1]) b : [ 1, 1] •(a : [1, 1]).",
      "startOffset" : 32,
      "endOffset" : 39
    }, {
      "referenceID" : 0,
      "context" : "a : [1, 1] ,__ ·(b: [1, 1]) b : [ 1, 1] •(a : [1, 1]).",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "a : [1, 1] ,__ ·(b: [1, 1]) b : [ 1, 1] •(a : [1, 1]).",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "This program has two stable formula functions: i) h 1 that assigns [1, 1] to both p and a, and ii) h2 that assigns [1, 1] to both p and b.",
      "startOffset" : 67,
      "endOffset" : 73
    }, {
      "referenceID" : 0,
      "context" : "This program has two stable formula functions: i) h 1 that assigns [1, 1] to both p and a, and ii) h2 that assigns [1, 1] to both p and b.",
      "startOffset" : 67,
      "endOffset" : 73
    }, {
      "referenceID" : 0,
      "context" : "This program has two stable formula functions: i) h 1 that assigns [1, 1] to both p and a, and ii) h2 that assigns [1, 1] to both p and b.",
      "startOffset" : 115,
      "endOffset" : 121
    }, {
      "referenceID" : 0,
      "context" : "This program has two stable formula functions: i) h 1 that assigns [1, 1] to both p and a, and ii) h2 that assigns [1, 1] to both p and b.",
      "startOffset" : 115,
      "endOffset" : 121
    }, {
      "referenceID" : 0,
      "context" : "Furthermore, suppose h3 is the function that assigns [1, 1] to all of p, a, b a.",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 0,
      "context" : "Furthermore, suppose h3 is the function that assigns [1, 1] to all of p, a, b a.",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 0,
      "context" : "nd h4 is the function that assigns [0, 1] to all of p, a, b.",
      "startOffset" : 35,
      "endOffset" : 41
    }, {
      "referenceID" : 0,
      "context" : "Hence, the Smyth­ minimal stable class semantics assigns [1, 1] top.",
      "startOffset" : 57,
      "endOffset" : 63
    }, {
      "referenceID" : 0,
      "context" : "Hence, the Smyth­ minimal stable class semantics assigns [1, 1] top.",
      "startOffset" : 57,
      "endOffset" : 63
    }, {
      "referenceID" : 0,
      "context" : "This Hoare-minimal class only allows us to conclude that p gets the value [0, 1].",
      "startOffset" : 74,
      "endOffset" : 80
    }, {
      "referenceID" : 0,
      "context" : "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A •(abn(X) :[I, 1]) dl·opout(X): [I, 1].",
      "startOffset" : 8,
      "endOffset" : 14
    }, {
      "referenceID" : 0,
      "context" : "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A •(abn(X) :[I, 1]) dl·opout(X): [I, 1].",
      "startOffset" : 8,
      "endOffset" : 14
    }, {
      "referenceID" : 0,
      "context" : "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A •(abn(X) :[I, 1]) dl·opout(X): [I, 1].",
      "startOffset" : 29,
      "endOffset" : 35
    }, {
      "referenceID" : 0,
      "context" : "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A •(abn(X) :[I, 1]) dl·opout(X): [I, 1].",
      "startOffset" : 29,
      "endOffset" : 35
    }, {
      "referenceID" : 0,
      "context" : "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A •(abn(X) :[I, 1]) dl·opout(X): [I, 1].",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A •(abn(X) :[I, 1]) dl·opout(X): [I, 1].",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "Suppos� initially ?1 contains the fact: adult(john) : [1, 1] ,_ _ Then it is easy to check that the only stable formula function with respect to ?1 assigns the range [0,95,1] to employed(john) correctly.",
      "startOffset" : 54,
      "endOffset" : 60
    }, {
      "referenceID" : 0,
      "context" : "Suppos� initially ?1 contains the fact: adult(john) : [1, 1] ,_ _ Then it is easy to check that the only stable formula function with respect to ?1 assigns the range [0,95,1] to employed(john) correctly.",
      "startOffset" : 54,
      "endOffset" : 60
    }, {
      "referenceID" : 0,
      "context" : "Suppos� initially ?1 contains the fact: adult(john) : [1, 1] ,_ _ Then it is easy to check that the only stable formula function with respect to ?1 assigns the range [0,95,1] to employed(john) correctly.",
      "startOffset" : 166,
      "endOffset" : 174
    }, {
      "referenceID" : 0,
      "context" : "Suppose d1·opmtt(john): [1, 1] ;- is added to ?1.",
      "startOffset" : 24,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : "Suppose d1·opmtt(john): [1, 1] ;- is added to ?1.",
      "startOffset" : 24,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : "Consider the formula function h that assigns [1 ,1] to adult(john), dropout(jolm) and alm(john), but [0,1] to employed(john).",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 0,
      "context" : "Consider the formula function h that assigns [1 ,1] to adult(john), dropout(jolm) and alm(john), but [0,1] to employed(john).",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 0,
      "context" : "Consider the formula function h that assigns [1 ,1] to adult(john), dropout(jolm) and alm(john), but [0,1] to employed(john).",
      "startOffset" : 101,
      "endOffset" : 106
    }, {
      "referenceID" : 0,
      "context" : "The unique stable formula function with respect to ?3 is the> one that assigns: [1,1] to dropout(john) and abn(john), [O.",
      "startOffset" : 80,
      "endOffset" : 85
    }, {
      "referenceID" : 0,
      "context" : "The unique stable formula function with respect to ?3 is the> one that assigns: [1,1] to dropout(john) and abn(john), [O.",
      "startOffset" : 80,
      "endOffset" : 85
    }, {
      "referenceID" : 0,
      "context" : "DG,l] to adult(john), and [0,1] to cmployrd(john).",
      "startOffset" : 26,
      "endOffset" : 31
    }, {
      "referenceID" : 0,
      "context" : "bird( X): [1, 1] aim Bini( X): [1, 1] <­ fwnyu.",
      "startOffset" : 10,
      "endOffset" : 16
    }, {
      "referenceID" : 0,
      "context" : "bird( X): [1, 1] aim Bini( X): [1, 1] <­ fwnyu.",
      "startOffset" : 10,
      "endOffset" : 16
    }, {
      "referenceID" : 0,
      "context" : "bird( X): [1, 1] aim Bini( X): [1, 1] <­ fwnyu.",
      "startOffset" : 31,
      "endOffset" : 37
    }, {
      "referenceID" : 0,
      "context" : "bird( X): [1, 1] aim Bini( X): [1, 1] <­ fwnyu.",
      "startOffset" : 31,
      "endOffset" : 37
    }, {
      "referenceID" : 0,
      "context" : "dy): [1, 1] bh·d(X) : (1, I] A",
      "startOffset" : 5,
      "endOffset" : 11
    }, {
      "referenceID" : 0,
      "context" : "dy): [1, 1] bh·d(X) : (1, I] A",
      "startOffset" : 5,
      "endOffset" : 11
    }, {
      "referenceID" : 0,
      "context" : "•(abnBh·d(X): [1, 1])",
      "startOffset" : 14,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "•(abnBh·d(X): [1, 1])",
      "startOffset" : 14,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "pengnin(X): [1, 1]A",
      "startOffset" : 12,
      "endOffset" : 18
    }, {
      "referenceID" : 0,
      "context" : "pengnin(X): [1, 1]A",
      "startOffset" : 12,
      "endOffset" : 18
    }, {
      "referenceID" : 0,
      "context" : "•(abnPcny(X): [1, 1])",
      "startOffset" : 14,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "•(abnPcny(X): [1, 1])",
      "startOffset" : 14,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "pengui11(X) : [1, 1]",
      "startOffset" : 14,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "pengui11(X) : [1, 1]",
      "startOffset" : 14,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "Consider the formula function h that assigns: [1, 1] to pcngnin(twcety), bird(tweety) and abnBird(tweety), [O,O.",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "Consider the formula function h that assigns: [1, 1] to pcngnin(twcety), bird(tweety) and abnBird(tweety), [O,O.",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "OGJ to fly(lwccty), and [0,1] to abnPeng(twcety).",
      "startOffset" : 24,
      "endOffset" : 29
    }, {
      "referenceID" : 3,
      "context" : "But our framework is not as expressive as the probabilistic frameworks proposed by Bacchus[! J and Buntine[4].",
      "startOffset" : 106,
      "endOffset" : 109
    }, {
      "referenceID" : 2,
      "context" : "These include the works by Blair and Subrahmanian [3], Fitting [D], Kifer et al [13, .",
      "startOffset" : 50,
      "endOffset" : 53
    }, {
      "referenceID" : 0,
      "context" : "On the other hand, the integration of logic and probability theory has been the subject of numerous studies [1, 5, 7, 8, 15, 22, 19].",
      "startOffset" : 108,
      "endOffset" : 132
    } ],
    "year" : 2011,
    "abstractText" : "In this paper we study tlw uses and the se­ mantics of non-monotonic negation in prob­ abilistic deductive databases. Based on the stahl<semantics for classical logic program­ ming, we in I roduce the notion of stable for­ mula functions. We show that. stable for­ mula functions are minimal fixpoints of op­ erators associated with probabilistic dednc1 ive databases with negation. Furthermore, since a probabilistic deductive database may not n<xcssarily have a stable formula func­ tion, we provick a stable class semantics for such databases. Finally, we demonstrate that tlu' proposed semantics can handle default reasoning naturally in tlw contc>xt of prob­ abilist ic deduction.",
    "creator" : "pdftk 1.41 - www.pdftk.com"
  }
}