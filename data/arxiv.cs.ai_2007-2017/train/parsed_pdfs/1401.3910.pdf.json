{
  "name" : "1401.3910.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Topological Value Iteration Algorithms",
    "authors" : [ "Peng Dai", "Daniel S. Weld", "Judy Goldsmith" ],
    "emails" : [ "DAIPENG@CS.WASHINGTON.EDU", "MAUSAM@CS.WASHINGTON.EDU", "WELD@CS.WASHINGTON.EDU", "GOLDSMIT@CS.UKY.EDU" ],
    "sections" : [ {
      "heading" : null,
      "text" : "because it puts the majority of its effort into backing up the entire state space, which turns out to be unnecessary in many cases. In order to overcome this problem, many approaches have been proposed. Among them, ILAO* and variants of RTDP are state-of-the-art ones. These methods use reachability analysis and heuristic search to avoid some unnecessary backups. However, none of these approaches build the graphical structure of the state transitions in a pre-processing step or use the structural information to systematically decompose a problem, whereby generating an intelligent backup sequence of the state space. In this paper, we present two optimal MDP algorithms. The first algorithm, topological value iteration (TVI), detects the structure of MDPs and backs up states based on topological sequences. It (1) divides an MDP into strongly-connected components (SCCs), and (2) solves these components sequentially. TVI outperforms VI and other state-of-the-art algorithms vastly when an MDP has multiple, close-to-equal-sized SCCs. The second algorithm, focused topological value iteration (FTVI), is an extension of TVI. FTVI restricts its attention to connected components that are relevant for solving the MDP. Specifically, it uses a small amount of heuristic search to eliminate provably sub-optimal actions; this pruning allows FTVI to find smaller connected components, thus running faster. We demonstrate that FTVI outperforms TVI by an order of magnitude, averaged across several domains. Surprisingly, FTVI also significantly outperforms popular ‘heuristically-informed’ MDP algorithms such as ILAO*, LRTDP, BRTDP and Bayesian-RTDP in many domains, sometimes by as much as two orders of magnitude. Finally, we characterize the type of domains where FTVI excels — suggesting a way to an informed choice of solver."
    }, {
      "heading" : "1. Introduction",
      "text" : "Markov Decision Processes (MDPs) (Bellman, 1957) are a powerful and widely-adopted formulation for modeling autonomous decision making under uncertainty. For instance, NASA researchers\nc©2011 AI Access Foundation. All rights reserved.\nuse MDPs to model the next-generation Mars rover planning problems (Bresina, Dearden, Meuleau, Ramkrishnan, Smith, & Washington, 2002; Feng & Zilberstein, 2004; Mausam, Benazera, Brafman, Meuleau, & Hansen, 2005; Meuleau, Benazera, Brafman, Hansen, & Mausam, 2009). MDPs are also used to formulate the military operations planning (Aberdeen, Thiébaux, & Zhang, 2004) and coordinated multi-agent planning (Musliner, Carciofini, Goldman, E. H. Durfee, & Boddy, 2007), etc.\nClassical dynamic programming algorithms, such as value iteration (VI), solve an MDP optimally by iteratively updating the value of every state in a fixed order, one state per iteration. This can be very inefficient, since it overlooks the graphical structure of a problem, which can provide vast information about state dependencies.\nDuring the past decade researchers have developed heuristic search algorithms that use reachability information and heuristic functions to avoid some unnecessary backups. These approaches, such as improved LAO* (ILAO*) (Hansen & Zilberstein, 2001), LRTDP (Bonet & Geffner, 2003b), HDP (Bonet & Geffner, 2003a), BRTDP (McMahan, Likhachev, & Gordon, 2005) and Bayesian RTDP (Sanner, Goetschalckx, Driessens, & Shani, 2009), frequently outperform value iteration. On some problems, however, heuristic search algorithms offer little benefit and it is difficult to predict when they will excel. This raises an important, open question, “What attributes of problems and problem domains make them best suited for heuristic search algorithms?”\nIn this paper we present two algorithms that solve MDPs optimally and speed up the convergence of value iteration: topological value iteration (TVI) (Dai & Goldsmith, 2007) and focused topological value iteration (FTVI) (Dai, Mausam, & Weld, 2009b). TVI makes use of the graphical structure of an MDP. It performs Bellman backups in a more intelligent order after performing an additional topological analysis of the MDP state space. TVI first divides an MDP into strongly connected components (SCCs) and then solves each component sequentially in topological order. Experimental results demonstrate significant performance gains over VI and, surprisingly, over heuristic search algorithms (despite TVI not using reachability information itself) in a specific kind of domain – one that has multiple, close-to-equal-sized SCCs.\nTVI is very general, as it is independent of any assumptions on the start state and can find the optimal value function for the entire state space. However, many benchmark problems cannot be broken into roughly equal-sized SCCs, leaving TVI’s performance no better (or often worse, due to the overhead of generating SCCs) than other MDP algorithms. For instance, many domains (e.g., Blocksworld) have reversible actions. Problems from these domains that have most of the states connected by reversible actions end up being in one (large) SCC, thus, eliminating the benefit of TVI.\nFTVI addresses the weaknesses of TVI. It first performs a phase of heuristic search and eliminates provably sub-optimal actions found during the search. Then it builds a more informative graphical structure based on the remaining actions. We find that a very short phase of heuristic search is often able to eliminate many actions leading to an MDP structure that is amenable to efficient, topology-based solutions.\nWe evaluate FTVI across several benchmark domains and find that FTVI outperforms TVI by significant margins. Surprisingly, we also find that FTVI outperforms other state-of-the-art heuristic search algorithms in most of the domains. This is unexpected, since common wisdom dictates that heuristic-guided search is much faster than all-state dynamic programming. To better understand this big improvement, we study the convergence speed of algorithms on a few problem features. We discover two important features of problems that are hard for heuristic search algorithms: smaller\nnumber of goal states and long search distance to the goal. These features are commonly found in many domains, e.g., Mountain car (Wingate & Seppi, 2005) and Drive (Bonet, 2006). We show that, in such domains, FTVI outperforms heuristic search in convergence speed by an order of magnitude on average, and sometimes by even two orders of magnitude.\nComparing with the previous conference versions (Dai & Goldsmith, 2007; Dai et al., 2009b), this paper makes several significant improvements: (1) We add a convergence test module in the search phase of FTVI. With the module, FTVI works as good as the best heuristic search algorithms in domains where it used to be significantly outperformed. (2) We perform extensive empirical study on both TVI (Figures 2 and 3 are new) and FTVI (Figure 5 is new, and we added the Blocksworld domain). (3) We describe TVI and FTVI in a consistent way and improve the pesudo-codes. (4) We add the convergence proof of TVI (Theorem 2).\nThe outline of the rest of the paper is as follows: Section 2 formally defines MDPs, and reviews algorithms that solve MDPs. Section 3 describes the topological value iteration algorithm, and compares it empirically with other algorithms on a special MDP domain. Section 4 introduces the focused topological value iteration algorithm and provides a thorough empirical evaluation. We present related work in Section 5 and conclude in Section 6."
    }, {
      "heading" : "2. Background",
      "text" : "We provide an overview of Markov decision process (MDP) and dynamic programming algorithms that solve an MDP."
    }, {
      "heading" : "2.1 Markov Decision Processes for Planning",
      "text" : "AI researchers typically use MDPs to formulate fully-observable probabilistic planning problems. An MDP is defined as a five-tuple 〈S,A, Ap, T, C〉, where\n• S is a finite set of discrete states.\n• A is a finite set of all applicable actions.\n• Ap : S → P(A) is the applicability function. Ap(s) denotes the set of actions that can be applied in state s. P(A) is the power set of the set of actions.\n• T : S ×A×S → [0, 1] is the transition function describing the effect of an action execution.\n• C : S ×A → R+ is the cost of executing an action in a state.\nThe agent executes its actions in discrete time steps. At each step, the system is at one distinct state s ∈ S. The agent can execute any action a from a set of applicable actions Ap(s) ⊆ A, incurring a cost of C(s, a). The action takes the system to a new state s′ stochastically, with probability Ta(s′|s).\nThe horizon of an MDP is the number of steps for which costs are accumulated. We concentrate on a special set of MDPs called stochastic shortest path (SSP) problems. Despite its simplicity, SSP is a general MDP representation. Any infinite-horizon, discounted-reward MDP can be easily converted to an SSP problem (Bertsekas & Tsitsiklis, 1996). The horizon in such an MDP is indefinite, i.e., finite but unbounded, and the costs are accumulated with no discounting. There are two more components of an SSP:\n• s0 is the initial state.\n• G ⊆ S is the set of sink goal states. Reaching any one of g ∈ G terminates an execution.\nThe cost of an execution is the sum of all costs along the path from s0 to the first goal state encountered.\nWe assume full observability, i.e., after executing an action and transitioning stochastically to a next state as governed by T , the agent has full knowledge of the state. A policy, π : S → A, of an MDP is a mapping from the state space to the action space, indicating which action to execute at each state. To solve the MDP we need to find an optimal policy (π∗ : S → A), a probabilistic execution plan that reaches a goal state with the minimum expected cost. We evaluate any policy π by its value function, the set of values that satisfy the following equation:\nV π(s) = C(s, π(s)) + ∑ s′∈S Tπ(s)(s ′|s)V π(s′). (1)\nAny optimal policy must satisfy the following system of Bellman equations:\nV ∗(s) = 0 if s ∈ G, else\nV ∗(s) = min a∈Ap(s)\n[ C(s, a) +\n∑ s′∈S Ta(s′|s)V ∗(s′)\n] . (2)\nThe corresponding optimal policy can be extracted from the value function:\nπ∗(s) = argmina∈Ap(s) [ C(s, a) +\n∑ s′∈S Ta(s′|s)V ∗(s′)\n] ,∀s ∈ S − G. (3)\nGiven an implicit optimal policy π∗ in the form of its optimal value function V ∗(·), the Q-value of a state-action pair (s, a) is defined as the value of state s, if an immediate action a is performed, followed by π∗ afterwards. More concretely,\nQ∗(s, a) = C(s, a) + ∑ s′∈S Ta(s′|s)V ∗(s′). (4)\nTherefore, the optimal value function can be expressed by:\nV ∗(s) = mina∈Ap(s)Q ∗(s, a)."
    }, {
      "heading" : "2.2 Dynamic Programming",
      "text" : "Most optimal MDP algorithms are based on dynamic programming, whose utility was first proved by a simple yet powerful algorithm named value iteration (Bellman, 1957). Value iteration first initializes the value function arbitrarily, for example all zero. Then, the values are updated iteratively using an operator called the Bellman backup (Line 7 of Algorithm 1) to create successively better approximations for each state per iteration. We define the Bellman residual of a state to be the absolute difference of a state value before and after a Bellman backup. Value iteration stops when the value function converges. In implementation, it is typically signaled by when the Bellman error,\nAlgorithm 1 (Gauss-Seidel) Value Iteration 1: Input: an MDP M = 〈S,A, Ap, T, C〉, δ: the threshold value 2: initialize V arbitrarily 3: while true do 4: Bellman error ← 0 5: for each state s ∈ S do 6: oldV ← V (s) 7: V (s)← mina∈Ap(s) [ C(s, a) + ∑ s′∈S Ta(s ′|s)V (s′) ]\n8: Bellman residual(s)← |V (s)− oldV | 9: Bellman error ← max(Bellman error,Bellman residual(s))\n10: if Bellman error < δ then 11: return V\nthe largest Bellman residual of all states, becomes less than a pre-defined threshold, δ. We call a Bellman backup a contraction operation (Bertsekas, 2001), if for every state, its Bellman residual never increase with the iteration number.\nValue iteration converges to the optimal value function in time polynomial in |S| (Littman, Dean, & Kaelbling, 1995; Bonet, 2007), yet in practice it is usually inefficient, since it blindly performs backups over the state space iteratively, often introducing many unnecessary backups."
    }, {
      "heading" : "2.2.1 HEURISTIC SEARCH",
      "text" : "To improve the efficiency of dynamic programming, researchers have explored various ideas from traditional heuristic-guided search, and have consistently demonstrated their usefulness for MDPs (Barto, Bradtke, & Singh, 1995; Hansen & Zilberstein, 2001; Bonet & Geffner, 2003b, 2006; McMahan et al., 2005; Smith & Simmons, 2006; Sanner et al., 2009). The basic idea of heuristic search is to consider an action only when necessary, which leads to a more conservative backup strategy. This strategy helps to save a lot of unnecessary backups.\nWe define a heuristic function h : S → R+, where h(s) is an estimate of V ∗(s). A heuristic function h is admissible if it never over-estimates the value of a state,\nh(s) ≤ V ∗(s),∀s ∈ S. (5)\nWe also interchangeably write an admissible heuristic function as Vl, to emphasize that Vl(s) is a lower bound of V ∗(s). Definition A greedy policy π is the best policy by one-step lookahead given the current value function, V :\nπ(s) = argmina∈Ap(s)\n[ C(s, a) +\n∑ s′∈S Ta(s′|s)V (s′)\n] ,∀s ∈ S − G. (6)\nA policy graph, Gπ = (V, E), for an MDP with the set of states S and policy π is a directed, connected graph with vertices V ⊆ S , where s0 ∈ V , and for any s ∈ S, s ∈ V iff s is reachable from s0 under policy π. Furthermore, ∀s, s′ ∈ V , 〈s, s′〉 ∈ E (the edges of the policy graph) iff Tπ(s)(s′|s) > 0.\nHeuristic search algorithms have two main features: (1) The search is limited to states that are reachable from the initial state. Given the heuristic value, a heuristic search algorithm generates a running greedy policy, as well as its policy graph. The algorithm performs a series of heuristic searches, until all states on the greedy policy graph converge. A search typically starts from the initial state, with successor states explored in a best-first manner. Visited states have their values backed up during the search. (2) Since heuristic search algorithms do fewer backups than value iteration, they require special care to guarantee final optimality. So values of the state space have to be initialized by an admissible heuristic function. Note that value iteration can also take advantage of initial heuristic values as an informative starting point, but does not require the heuristics to be admissible to guarantee optimality.\nDifferent heuristic search algorithms use different search strategies and therefore perform Bellman backups in different orders.\nThe AO* algorithm (Nilson, 1980) solves acyclic MDPs, so it is not applicable to general MDPs. LAO* (Hansen & Zilberstein, 2001) is an extension to the AO* algorithm that can handle MDPs with loops. Improved LAO* (ILAO*) (Hansen & Zilberstein, 2001) is an efficient variant of LAO*. It iteratively performs complete searches that discover a running greedy policy graph. In detail, the greedy policy graph only contains the initial state s0 when a search starts. New states are added to the graph by means of expansions over a frontier state in a depth-first manner, until no more states can be added. In a state expansion, one of its greedy actions is chosen, and all the action’s successor states are added into the graph. States that are not expanded yet but contain successors are called frontier states. Later, states of the greedy policy graph are backed up only once in the postorder when they are visited. Each search iteration performs at most |S| backups, but in practice this number is typically much smaller. ILAO* terminates when all states of the current greedy policy graph have a Bellman residual less than a given δ.\nReal-time dynamic programming (RTDP) (Barto et al., 1995) is another popular algorithm for MDPs. It interleaves dynamic programming with search through plan execution trials. An execution trial is a path that originates from s0 and ends at any goal state or by a bounded-step cutoff. Each execution step simulates the result of one-step plan execution. The agent greedily picks an action a of the current state s, and mimics the state transition to a new current state s′, chosen stochastically based on the transition probabilities of the action, i.e., s′ ∼ Ta(s′|s). Dynamic programming happens when states are backed up immediately when they are visited. RTDP is good at finding a good sub-optimal policy relatively quickly. However, in order for RTDP to converge, states on the optimal policy have to be backed up sufficiently, so its convergence is usually slow. To overcome the slow convergence problem of RTDP, researchers later proposed several heuristic search variants of the algorithm.\nBonet and Geffner (2003b) introduced a smart labeling technique in a RTDP extension named labeled RTDP (LRTDP). They label a state s solved if every state reachable from s by applying the greedy policy is either a goal state, or is solved, or has a Bellman residual no greater than the threshold δ. States that are labeled as solved no longer get backed up in any future search. Labeling helps speed up convergence as it avoids many unnecessary backups over states that have already converged. After an execution trial, LRTDP tries to label every unsolved state in the reverse order of visit. To label a state s, LRTDP initiates a DFS from s0 and checks if all states reachable under the greedy policy rooted at s are solved, and back them up, otherwise. LRTDP terminates when all states of the current policy graph are solved. Bonet and Geffner also applied the labeling technique in another algorithm called HDP (Bonet & Geffner, 2003a). HDP uses Tarjan’s algorithm to find all\nthe strongly connected component of an MDP to help label solved states and implicitly control the order in which states are backed up in a search trial.\nMcMahan et al. (2005) proposed another extension named bounded RTDP (BRTDP), which not only uses a lower bound heuristic of the value function Vl, but also an upper bound Vu. BRTDP has two key differences from the original RTDP algorithm. First, once BRTDP backs up a state s, it updates both the lower bound and the upper bound. Second, when choosing the next state s′, the difference of its two bounds, Vu(s′)− Vl(s′), is also taken into consideration. More concretely, s′ ∼ Ta(s′|s)[Vu(s′) − Vl(s′)], which focuses search on states that are less likely to be converged. One feature of BRTDP is its adaptive trial termination criterion, which is very helpful in practice. Smith and Simmons (2006) introduced a similar algorithm named focused RTDP (FRTDP). They define occupancy as an intuitive measure of the expected number of times a state is visited before execution termination. Therefore occupancy of a state indicates its relevance to a policy. Similar to BRTDP, FRTDP also keeps two bounds for a state. FRTDP uses the product of a state’s occupancy and the difference of its bounds for picking the next state. Also, FRTDP assumes a discounted cost setting, so it is not immediately applicable to SSP problems.\nRecently Sanner et al. (2009) described another advanced RTDP variant named Bayesian RTDP, which also uses two value bounds. The basic motivation of Bayesian RTDP is that anytime performance for sub-optimal policies is important, when finding an optimal policy can be very timeconsuming. This is especially true when some sub-optimal policy performs close to an optimal one, but is much faster to generate. Its key assumption is that the true value function of a state s, V ∗(s), is uniformly distributed on the interval [Vl(s), Vu(s)]. Therefore, the probability density function of V ∗(s) is 1v∈[Vl(s),Vu(s)][ 1 Vu(s)−Vl(s) ], and E[V\n∗(s)] = 12 [Vl(s) + Vu(s)]. To evaluate how important it is to pick state s′ as the next state, it refers to the notion of value of perfect information (VPI), which intuitively tells the expected Q-value difference of the current state-action pair, Q(s, a), with and without the knowledge of V ∗(s′). To choose s′, Bayesian RTDP uses a metric that combines the BRTDP metric and the VPI value."
    }, {
      "heading" : "2.3 A Limitation of Previous Solvers",
      "text" : "Value iteration backs up states iteratively based on some fixed order. Heuristic search backs up states in a dynamic, informed order, implied by when they are visited in the search. A state can be backed up in the pre-order (when it is first visited, e.g., variants of RTDP), or the post-order (when searches back track, e.g., ILAO*). None of the algorithms use an MDP’s graphical structure, an intrinsic property that governs the complexity of solving a problem (Littman et al., 1995), in a way to decide the order in which states are solved.\nConsider a PhD program in some Finance department. Figure 1 shows an MDP that describes the progress of a PhD student. For simplicity reasons, we omit the action nodes, the transition probabilities, and the cost functions. The goal state set is a singleton G = {g}, which indicates a student gets her PhD degree. A directed edge between two states means the head state is one successor state of the tail state under at least one action. The initial state, s0, describes the status of an entry-level student. She has to first pass the qualifying exam, which consists of finding a supervisor and passing an exam. Before passing the exam one can choose to work with a different supervisor (back to state s0 in the figure). State s1 indicates the student has found a supervisor. Then she works on her proposal, which consists of a written document and an oral exam. She has\nto pass both in two consecutive quarters; otherwise back to state s2. After passing the proposal, at state s4, she needs to defend her thesis, passing which reaches the goal state g.\nObserving the MDP, we find the optimal order to back up states is s4, then s2 and s3, till they converge, followed by s0 and s1. The reason is that the value of s4 does not depend on the values of other non-goal states. Similarly, the values of s2 and s3 do not depend on the values of either s0 or s1. Value iteration as well as heuristic search algorithms do not take advantage of the graphical structure and apply this backup order, as they do not contain an “intelligent” subroutine that discovers the graphical structure, nor use this information in the dynamic programming step. The intuition of our new approaches is to discover the intrinsic complexity of solving an MDP by studying its graphical structure, which later contributes to a more intelligent backup order."
    }, {
      "heading" : "3. Topological Value Iteration",
      "text" : "We now describe the topological value iteration (TVI) algorithm (Dai & Goldsmith, 2007). First observe that the value of a state depends on the values of its successors. For example, suppose state s2 is a successor state of s1 under action a (Ta(s2|s1) > 0). By the Bellman equations V ∗(s1) is dependent on V ∗(s2). In this case, we define state s1 causally depends on state s2. Note that the causal dependence relationship is transitive. We can find out all causally dependent states implicitly by building a reachability graph GR of the MDP. The set of vertices of GR equals the set of states that are reachable from s0. A directed edge from vertex s1 to s2 means that there exists at least an action a ∈ Ap(s1), such that Ta(s2|s1) > 0. As the causal relationship is transitive, a directed path from state s1 to sk in GR means s1 is causally dependent on sk, or V ∗(s1) depends on V ∗(sk). Also note that two vertices can be causally dependent on each other, which we call mutual causal dependence.\nDue to causal dependence, it is usually more efficient to back up s2 ahead of s1. With this observation, we have the following theorem.\nTheorem 1 Optimal Backup Order (Bertsekas, 2001): If an MDP is acyclic, then there exists an optimal backup order. By applying the optimal order, the optimal value function can be found with each state needing only one backup.\nThe theorem is easy to prove and, furthermore, the optimal backup order is a topological order of the vertices in GR. However, in general, MDPs contain cycles and it is common for one state to mutually causally depend on another.\nIf two states are mutually causally dependent, the best order to back up them is unclear. On the other hand, if neither state is causally dependent on the other, the order of backup does not matter. Finally, if one state is causally dependent on the other (and not vice versa), it is better to order the\nbackups so that the state which is causally dependent is updated later. To apply this idea we then group together states that are mutually causally dependent and make them a meta-state. We make a new directed graph GM where a directed edge between two meta-states X and Y exists if and only if there exists two states s1 and s2 and an action a ∈ Ap(s1) such that s1 ∈ X , s2 ∈ Y and Ta(s2|s1) > 0. It is clear that GM is acyclic, otherwise all states on such a cycle are mutually causally dependent, and by our construction rule they should belong to the same meta-state. In this case, we can back up states in GM in their topological order. By Theorem 1, each such state only requires one meta-backup. It is called a meta-backup since a meta-state may contain multiple states. To perform a meta-backup, we can apply any dynamic programming algorithm, such as value iteration, on all states belonging to the corresponding meta-state.\nThe pseudo-code of TVI is shown in Algorithm 2. We first apply Kosaraju’s algorithm (Cormen, Leiserson, Rivest, & Stein, 2001) to find the set of strongly connected components (SCCs, or metastates) in the causality graph GR, and its topological order. (id[s] indicates the topological order of the SCC that state s belongs to.) It is based on the fact that by reversing all the edges in GR, the resulting graph, G′R, has the same strongly connected components as the original. From using that, we can get the SCCs by doing a forward traversal to find an ordering of vertices, followed by a traversal of the reverse of the graph in the order generated by the first traversal. Kosaraju’s algorithm is efficient, as its time complexity is linear in the number of states. When the state space is large, running the algorithm leads to unavoidable yet acceptable overhead. In many cases the overhead is well compensated by the computational gain. We then use value iteration to solve each SCC C (as a meta-backup) in its topological order.\nAlgorithm 2 Topological Value Iteration 1: Input: an MDP M = 〈S,A, Ap, T, C〉, δ: the threshold value 2: SCC(M ) 3: for i← 1 to cpntnum do 4: S ′ ← the set of states s where id[s] = i 5: M ′ ← 〈S ′,A, Ap, T, C〉 6: VI(M ′, δ) 7:\n8: Function SCC(M) 9: construct GR of M\n10: construct a graph G′R which reverses the head and tail vertices of every edge in GR 11: {call Kosaraju’s algorithm (Cormen et al., 2001). It inputs GR and G′R and outputs cpntnum,\nthe total number of SCCs, and id : S → [1, cpntnum], the id of the SCC each state belongs to, by topological order.}\n12: return (cpntnum, id)"
    }, {
      "heading" : "3.1 Convergence",
      "text" : "When the Bellman operator is a contraction operation (Bertsekas, 2001), we have:\nTheorem 2 Topological Value Iteration is guaranteed to converge to a value function with a Bellman error that is no greater than δ.\nProof We first prove that TVI is guaranteed to terminate in finite time. Since each MDP contains a finite number of states, it contains a finite number of connected components. In solving each of these components, TVI uses value iteration. Because value iteration is guaranteed to converge in finite time (given a finite δ), TVI, which is essentially a finite number of value iterations, terminates in finite time.\nWe then prove TVI is guaranteed to converge to an optimal value function with Bellman error at most δ. We prove by induction.\nFirst, if an MDP contains only one SCC, then TVI coincides with VI, an optimal algorithm. By the contraction property of Bellman backups, when VI converges, the Bellman error of the state space is at most δ.\nNow, consider the case where an MDP contains multiple SCCs. At any point, TVI is working on one component C. We know that the optimal value of every state s ∈ C, V ∗(s), depends only on the optimal values of the states that are descendants of s. We also know that any descendant s′ of s must belong either to C, or a component C′ that is topologically no later than C. This means either its value is computed by VI in the same batch as s (s′ ∈ C), or state s′ is already converged (s′ ∈ C′). In the latter case, its value is a convex combination of states having error at most δ. Inside each maximization operation of an Bellman equation is an affine combination of values with a total weight of 1, which leads to an overall convex combination error of no more than δ. Therefore, when VI finishes solving C, the value of s must converge with Bellman residual at most δ. Also note that the values of all states that belong to a component that is earlier than C does not depend on those of states in component C. As a result, after component C converges, the Bellman residual of states in those components remain unchanged and thus are at most δ. Combining the results we conclude that when TVI terminates, the Bellman residuals of all states are at most δ. This means the Bellman error of the state space is at most δ.\nFrom the high-level perspective, TVI decomposes an MDP into sub-problems and finds the value of the state space in a batch manner, component by component. When a component is converged, all its states will be safely treated as sink states, as their values do not depend on values of states belonging to later components."
    }, {
      "heading" : "3.2 Implementation",
      "text" : "We made two optimizations in implementing TVI. The first one is an uninformed reachability analysis. TVI does not depend on any initial state information. However, once given that information, TVI is able to mark the reachable components and later ignore the unreachable ones in the dynamic programming step. The reachable state space can be found by a depth-first search starting from s0, with an overhead that is linear in |S| and |A|. It is extremely useful when only a small portion of the state space is reachable (e.g., most domains from the International Planning Competition 2006, see Bonet, 2006).\nThe second optimization is to use heuristic values Vl(·) as a starting point. We used the hmin (Bonet & Geffner, 2003b), an admissible heuristic:\nhmin(s) = 0 if s ∈ G, else hmin(s) = min\na∈Ap(s)\n[ C(s, a) +mins′:Ta(s′|s)>0hmin(s ′) ] . (7)\nTo implement it, we first construct a new deterministic problem. For each action and successor pair of the original MDP, we add to the new problem a deterministic action with the same cost\nand the same, deterministic successor. We then solve this new problem by a single, backward, breadth-first search from the set of goal states. Values of the deterministic problem are hmin."
    }, {
      "heading" : "3.3 Experiments",
      "text" : "We address the following questions in our experiments: (1) How does TVI compare with VI and heuristic search algorithms on MDPs that contain multiple SCCs? (2) What are the most favorable problem features for TVI?\nWe compared TVI with several other optimal algorithms, including VI (Bellman, 1957), ILAO* (Hansen & Zilberstein, 2001), LRTDP (Bonet & Geffner, 2003b), BRTDP (McMahan et al., 2005), Bayesian RTDP (Sanner et al., 2009) (BaRTDP), and HDP (Bonet & Geffner, 2003a)1. We used the fully optimized C code of ILAO* provided by Eric A. Hansen and additionally implemented the rest of the algorithms over the same framework. We performed all experiments on a 2.5GHz Dual-Core AMD Opteron(tm) Processor with 2GB memory. Recall that BRTDP and BaRTDP use upper bounds. We used upper bounds as described in Section 4.2. We used α = 2 × 10−6 and τ = 10 for BRTDP and BaRTDP.2 For BaRTDP, we used the probabilistic termination condition in Algorithm 3 of Sanner et al. (2009). 3\nWe compared all algorithms on running time, time between an algorithm starts solving a problem until generating a policy with a Bellman error of at most δ(= 10−6). We terminated an algorithm if it did not find such a policy within five minutes. Note that there are other performance measures such as anytime performance (the original motivation of BaRTDP) and space consumption, but the main motivation of TVI is to decrease convergence time. We expect TVI to have a very steep anytime performance curve, because it postpones backing up the initial state till it starts working on the SCC where the initial state belongs to. Space, on the other hand, is less interesting because in-memory MDPs algorithms requires that the MDP model stored in the main memory before dynamic programming can apply. Therefore, they all share the same space limit. For work on overcoming space limitation, see, for example the work of Dai et al. (2008, 2009a).\nWe tested all algorithms on a set of artificially-generated “layered” MDPs. For each such MDP of state size |S|, we partition the state space evenly into a number nl of layers, labeled by integers 1, . . . , nl. We allow states in higher numbered layers to be the successors of states in lower numbered layers, but not vice versa, so each state s only has a limited set of allowable successor states, named succ(s). A layered MDP is parameterized by two other variables: the number of actions per state, na, and the maximum number of successor states per action, ns. When generating the transition function of a state-action pair (s, a), we draw an integer k uniformly from [1, ns]. Then k distinct successors are uniformly sampled from succ(s) with random transition probabilities. We pick one state from layer nl as the only goal state. One property of a layered MDP is that it contains at least nl connected components.\n1. Notice that this comparison is somewhat unfair to TVI, since heuristic search algorithms may not expand portions of the state space, if their sub-optimality can be proved. Still, we make this comparison to understand the practical benefits of TVI v.s. all other known optimal MDP algorithms 2. α is the termination threshold of BRTDP (it terminates when vu(s0) − Vl(s0) < α). τ indicates the stopping condition of each heuristic search trial. For more detailed discussions on the two parameters, please refer to the work of McMahanet al. (2005). We carefully tuned these parameters. 3. This termination condition may result in sub-optimal policies, so the reported times of BaRTDP in this paper are lower bounds. Note that BaRTDP mainly aims at improving the anytime performance of RTDP, which is orthogonal to convergence time. We report its convergence speed for thorough investigation purposes.\nThere are several planning domains that lead to multi-layered MDPs. An example is the game Bejeweled, or any game with difficulty levels: each level is at least one layer. Or consider a chess variant without pawn promotions, played against a stochastic opponent. Each set of pieces that could appear on the board together leads to at least one strongly connected component. But we know of no multi-layered standard MDP benchmarks. Therefore, we compare, in this section, on artificial problems to study TVI’s performance across controlled parameters, such as nl and |S|. Next section contains more comprehensive experiments on benchmark problems.\nWe generated problems with different parameter configurations and ran all algorithms on the same set of problems. The running times, if the process converged within the cut-off, are reported in Figures 2 and 3. Each element of the table represents the median convergence time of running 10 MDPs with the same configuration.4 Note that varying |S|, nl, na, and ns yields many MDP configurations. We tried more combinations than the representative ones reported. We found HDP much slower than the other algorithms, so did not include its performance.\nFor the first experiment, we fixed |S| to be 50,000 and varied nl from 1 to 1,000. Observing Figure 2 we first find that, when there is only one layer, the performance of TVI is slightly worse than VI, as such an MDP probably contains an SCC that contains the majority of the state space, which defeats the benefit of TVI. But TVI consistently outperforms VI if nl > 1. When nl ≤ 10, TVI equals or beats ILAO*, the fastest heuristic search algorithm for this set of problems. When nl > 10, TVI outperforms all the other algorithms in all cases by a visible margin. Also note that, as the number of layers increases the running times of all algorithms decrease. This is because\n4. We picked median instead of mean just to avoid an unexpected hard problem, which takes a long time to solve, thereby dominating the performance.\nthe MDPs become more structured, therefore simpler to solve. The running time of TVI decreases second fastest to that of LRTDP. LRTDP is very slow when nl = 1 and its running time drops dramatically when nl increases from 1 to 20. As TVI spends nearly constant time in generating the topological order of the SCCs, its fast convergence is mainly due to the fact that VI is much more efficient in solving many small (and roughly equal-sized) problems than a large problem whose size is the same as the sum of the small ones. This experiment shows TVI is good at solving MDPs with many SCCs.\nFor the second experiment, we fixed nl to be 100 and varied |S| from 10,000 to 100,000. We find that, when the state space is 10,000 TVI outperforms VI, BRTDP and BaRTDP, but slightly underperforms ILAO* and LRTDP. However, as the problem size grows TVI soon takes the lead. It outperforms all the other algorithms when the state space is 20,000 or larger. When the state space grows to 100,000, TVI solves a problem 6 times as fast as VI, 4 times as fast as ILAO*, 2 times as fast as LRTDP, 21 times as fast as BRTDP, and 3 times as fast as BaRTDP. This experiment shows that TVI is even more efficient when the problem space is larger."
    }, {
      "heading" : "4. Focused Topological Value Iteration",
      "text" : "Topological value iteration improves the performance of value iteration most significantly when an MDP has many equal-sized strongly connected components. However, we also observe that many MDPs do not have evenly distributed connected components. This is due to the following reason: a state can have many actions, most of which are sub-optimal. These sub-optimal actions, although not part of an optimal policy, may lead to connectivity between a lot of states. For example, domains like Blocksworld have reversible actions. Due to these actions most states are mutually causally\ndependent. As a result, states connected by reversible actions end up forming a large connected component, making TVI slow.\nOn the other hand, heuristic search is a powerful solution technique, which successfully concentrates computation, in the form of backups, on states and transitions that are more likely to be part of an optimal policy. However, heuristic search uses the same backup strategy on all problems, thus missing out on the potential savings from knowing the graphical structure information.\nIf we knew about the existence of an action in the optimal policy, we could eliminate the rest actions for its outgoing state, thus breaking some connectivity. Of course, such information is never available. However, with a little help from heuristic search, we can eliminate sub-optimal actions from a problem leading to a reduced connectivity and hopefully, smaller sizes of strongly connected components.\nFigure 4 shows the graphical representation of a part of one simple MDP that has 7 states and 12 actions. In the figure, successors of probabilistic actions are connected by an arc. For simplicity, transition probabilities Ta, costs C(s, a), initial state and goal states are omitted. Using TVI, we can divide the MDP into two SCCs C1 and C2. However, suppose we are given some additional information that a5 and a12 are sub-optimal. Based on the remaining actions, C1 and C2 can be sub-divided into three and two smaller components respectively (as shown in the figure). Dynamic programming will greatly benefit from the new graphical structure, since solving smaller components can be much easier than a large one."
    }, {
      "heading" : "4.1 The FTVI Algorithm",
      "text" : "The key insight of our novel algorithm is to break the big components into smaller parts, by removing actions that can be proven to be suboptimal for the current problem at hand. This exploits the knowledge of the current initial state and goal, which TVI mostly ignores. We call our new algorithm focused topological value iteration (FTVI) (Dai et al., 2009b). The pseudo-code is shown in Algorithm 3.\nAt its core, FTVI makes use of the action elimination theorem, which states:\nTheorem 3 Action Elimination (Bertsekas, 2001): If a lower bound of Q∗(s, a) is greater than an upper bound of V ∗(s) then action a cannot be an optimal action for state s.\nThis gives us a template to eliminate actions, except that we need to compute a lower bound for Q∗ and an upper bound for V ∗. FTVI keeps two bounds of V ∗ simultaneously: the lower bound Vl(·) and the upper bound Vu(·). Vl(·) is initialized via the admissible heuristic. We note two properties of Vl: (1) Ql(s, a) computed by a one-step lookahead given the current lower bound value Vl(·) (Line 30, Algorithm 3) is a lower bound of Q∗(s, a), and (2) all the V values remain lower bounds throughout the algorithm execution process, if they were initialized by an admissible heuristic. So, this lets us easily compute a lower bound ofQ∗, which also improves as more backups are performed.\nSimilar properties hold for Vu, the upper bound of V ∗, i.e., if we initialize Vu by an upper bound and perform backups based on Vu then each successive value estimate remains an upper bound. The later implementation section lists our exact procedure to compute the lower and upper bounds in a domain-independent manner. We note that to employ action elimination we can use any lower and upper bounds, so if a domain has informative, domain-dependent bounds available, that can be easily plugged into FTVI.\nFTVI contains two sequential steps. In the first step, which we call the search step, FTVI performs a small number of heuristic searches similar to ILAO*, i.e., backs up a state at most once per iteration. This makes the searches in FTVI fast, but still useful enough to eliminate sub-optimal actions. There are two main differences in common heuristic search and the search phase of FTVI. First, in each backup, we update the upper bound in the same manner as the lower bound. This is reminiscent of backups in BRTDP (McMahan et al., 2005). Second, we also check and eliminate sub-optimal actions using action elimination (Lines 30–32).\nIn the second step, the computation step, FTVI generates a directed graph GSR in the same manner as TVI generates GR, but only based on the remaining actions. More concretely, a directed edge from vertex s1 to s2 exists if there is an uneliminated action a such that Ta(s2|s1) > 0. It is easy to see that the graph GSR generated is always a sub-graph of GR. FTVI then finds all connected components of GSR, their topological order, and solves each component sequentially in the topological order.\nWe can state the following theorem for FTVI.\nTheorem 4 FTVI is guaranteed to converge to the optimal value function.\nThe correctness of the theorem is based on two facts: (1) action elimination preserves soundness, and (2) TVI is an optimal planning algorithm (Theorem 2)."
    }, {
      "heading" : "4.2 Implementation",
      "text" : "There are several interesting questions to answer in implementation. How to calculate the initial upper and lower bounds? How many search iterations do we need to perform in the search step? Is it possible that FTVI converges in the search step? What if there still remains a large component even after action elimination?\nWe used the same lower bound Vl as in TVI (see Section 3.2). For the upper bound, we started with a simple upper bound:\nAlgorithm 3 Focused Topological Value Iteration 1: Input: an MDP 〈S,A, Ap, T, C〉, x: the number of search iterations in a batch, y: the lower bound of\nthe percentage of change in the initial state value for a new batch of search iterations, δ: the threshold value\n2: {step 1: search} 3: while true do 4: old value← Vl(s0) 5: for iter ← 1 to x do 6: Bellman error ← 0 7: for every state s do 8: mark every state as unvisited 9: s← s0\n10: Search(s) 11: if Bellman error < δ then {The value function converges} 12: return Vl 13: if old value/Vl(s0) > (100− y)% then 14: break 15: 16: {step 2: computation} 17: M ← 〈S,A, Ap, T, C〉 18: TVI(M , δ) {by applying the backup operator with action elimination} 19: 20: Function Search(s) 21: if s /∈ G then 22: mark s as visited 23: a← argminaQ(s, a) 24: for every unvisited successor s′ of action a do 25: Search(s′) 26: Bellman error ← max(Bellman error,Back − up(s)) 27: 28: Function Back − up(s) 29: for each action a do 30: Q(s, a)← C(s, a) + ∑ s′∈S Ta′(s\n′|s)Vl(s′) 31: if Ql(s, a) > Vu(s) then 32: eliminate a from Ap(s) 33: oldVl ← Vl(s) 34: Vl(s)← mina∈Ap(s)Q(s, a) 35: Vu(s)← mina∈Ap(s)[C(s, a) + ∑ s′∈S Ta′(s\n′|s)Vu(s′)] 36: return |Vl(s)− oldVl|\nVu(s) = 0 if s ∈ G, else Vu(s) =∞. (8)\nThis initialization gives us a global yet very loose upper bound. To improve its tightness, we performed a backward best-first search from the set of goal states. States visited have their Vu values updated as in Algorithm 3, Line 35. We can iteratively get tighter and tighter bounds when more backward searches are performed.\nThe time spent on search can have a significant impact on FTVI. Very few search iterations might not eliminate enough sub-optimal actions. However, too many search iterations will turn\nFTVI into a heuristic search algorithm and trade off the advantage of FTVI. We did a control experiment by varying the total number of heuristic search trials on two problems. Figure 5 shows that the performance on a Wet-floor problem matches our hypothesis perfectly. For the Drive problem, the number of search trials does not affect the convergence speed too much, but too many search trials turn out to be harmful.\nConsidering the tradeoff, we let the algorithm automatically determine the number of search iterations. FTVI incrementally performs a batch of x search iterations. After the batch, it computes the amount of change to the Vl(s0) value. If the change is greater than y%, a new batch of search is performed. Otherwise, the search phase is considered complete. In our implementation, we use x = 100, and y = 3.\nAn interesting case occurs when the optimal value is found during the search step. Although FTVI performs a limited number of search iterations, it is possible that a problem is optimally solved within the search step. It is helpful to keep track of optimality information during the search step, so that FTVI can potentially skip some unnecessary search iterations and the entire computation step. To do this, we only need to maintain a Bellman error of the current search iteration, and terminate FTVI if the error is smaller than the threshold (Lines 11–12). In our experiment, we find this simple optimization to be extremely helpful in promoting the performance of FTVI.\nSometimes there are cases where GSR still contains large connected components. This can be caused by two reasons (1) An optimal policy indeed has large components, or (2) the connectivity caused by many suboptimal actions is not successfully eliminated by search. To try to further decompose these large components, we let FTVI perform additional intra-component heuristic searches. An intra-component heuristic search takes place only inside a particular component. Its purpose is to find new, sub-optimal actions, which might help decompose the component. Given a component C of GSR, we define SourceC to be the set of states where none of its incoming transitions are from states in C. In other words, states in SourceC are the incoming bridge states between C and rest of the MDP. An intra-component heuristic search of C originates from a state in SourceC . A search branch terminates when a state outside C is encountered.\nWe did some experiments and compared the performance of FTVI with and without additional intra-component search on problems from four domains, namely Wet-floor (Bonet & Geffner, 2006),\nSingle-arm pendulum (Wingate & Seppi, 2005), Drive, and Elevator (Bonet, 2006). Our results show that additional intra-component search only provided limited gains in Wet-floor problems, in which it helped decrease the size of the largest components by approximately 50% on average, and sped up the convergence by 10% at best. However, intra-component search turned out to be harmful for the other domains, as it did not provide any new graphical information (no smaller components were generated). On the contrary, the search itself introduced a lot of unnecessary overhead. So we used the version that does not perform additional intra-component search throughout the rest of the experiments."
    }, {
      "heading" : "4.3 Experiments",
      "text" : "We address the following two questions in our experiments: (1) How does FTVI compare with other algorithms on a broad range of domain problems? (2) What are the specific kind of domains on which FTVI should be preferred over heuristic search?\nWe implemented FTVI on the same framework as in Section 3.3, and used the same cut-off time of 5 minutes for each algorithm per problem. To investigate the helpfulness of action elimination, we also implemented a VI variant that applies action elimination in backups. We used the same threshold value δ = 10−6, and ran BRTDP and BaRTDP on the same upper bound as FTVI."
    }, {
      "heading" : "4.3.1 RELATIVE SPEED OF FTVI",
      "text" : "We evaluated the various algorithms on problems from eight domains — Mountain Car, Single and Double Arm Pendulum (Wingate & Seppi, 2005), Wet-floor (Bonet & Geffner, 2006)5, and four domains from International Planning Competition 2006 — Drive, Elevators, TireWorld and Blocksworld. A mountain car problem usually has many source states.6 We chose each source state as an initial state, and averaged the statistics per problem. Table 1 lists the running times for the various algorithms. For FTVI, we additionally report (in Table 2) the time used by the searches (Tsearch), and the time spent in generating the graphical structure (Tgen), if a problem is not solved during the search phase, where the leftover is the time spent in solving the SCCs. We also compared the size of the biggest component (BC size) generated by TVI and FTVI.\nOverall we find that FTVI outperforms the other five algorithms on most of these domains. FTVI outperforms TVI in all domains. Notice that on the MCar problems, FTVI establishes very favorable graphical structures (strongly connected components of size one) during the search step.7 This graphical structure makes the second step of FTVI trivial. But TVI has to solve much bigger components, so it runs much slower. For the Drive domain, even if it does not find a more informed graphical structure, the advanced backup with action elimination enables FTVI converge faster.\n5. Note that we used the probability of wet cells, p = 0.5. 6. A source state is a state with no incoming transitions. 7. If we allow FTVI to perform the computation step as opposed to stop at the search step when a problem is solved, it\nwill find similar structures in the Tireworld and Blocksworld problems.\nFTVI outperforms heuristic search algorithms most significantly in domains such as MCar, SAP and Drive. It is faster than ILAO* by an order of magnitude. This shows the extreme effectiveness of FTVI’s decomposing a problem into small sub-problems using advanced graphical information and solving these sub-problems sequentially. The three RTDP algorithms are not competitive with the other algorithms in these domains, and fail to return a solution by the cutoff time for many problems. FTVI shows limited speedup against heuristic search in domains such as Wet-floor, DAP, and Elevator. FTVI is on par with ILAO*, and vastly outperforms TVI in Tireworld and Blocksworld domains, as it converges within the search step. The convergence speed of value iteration is typically slow, as it backs up states iteratively by a fixed order. Adding action elimination to Bellman backups increases the convergence speed of VI up to two times, especially in the Mountain Car, Single Arm Pendulum, and Elevator domains, but its convergence speed is usually at least one magnitude slower than those of FTVI."
    }, {
      "heading" : "4.3.2 FACTORS DETERMINING PERFORMANCE",
      "text" : "We have shown that FTVI is faster than heuristic search algorithms in many domains, but its relative speedup is domain-dependent. Can we find any domain features that are particularly beneficial for FTVI or worse for heuristic search algorithms? In this evaluation we performed control experiments by varying the domains across different features and study the effect on planning time of various algorithms.\nWe make an initial prediction of three features.\n1. The number of goals in the domain: If the number of goal states is small, search may take a long time before it discovers a path to a goal. Therefore, many sub-optimal policies might be evaluated by a heuristic search algorithm.\n2. Search depth from the initial state to a goal state: This depth is a lower bound of the length of an execution trial and also of the size of any policy graph. A greater depth implies more search steps per iteration, which might make evaluating a policy time-consuming.\n3. Heuristic informativeness: The performance of a heuristic search algorithm depends a lot on the quality of the initial heuristic function. We expect the win from FTVI to increase when heuristic is less informed.\nThe Number of Goals. As far as we know, there is no suitable domain where we can specify the total number of goal states arbitrarily, so we used an artificial domain. In this domain each state has two applicable actions, and each action has at most two random successors. We tested all algorithms on domains of two sizes, 10,000 (Figure 6(left)) and 50,000 (Figure 6(right)). For each problem size, we fixed the shortest goal distance but varied the number of goal states, |G|. More concretely, after generating the state transitions, we performed a BFS from the initial state, and randomly picked goal states on a same search depth. For each |G| value, we generated 10 problems, and reported the median running time of four algorithms (LRTDP and BaRTDP were slow in this domain). We observe that all algorithms take more time to solve a problem with a smaller number of goal states than with a larger number. However, beyond a point (|G| > 20 in our experiments), the running times become stable. FTVI runs only marginally slower when |G| is small, suggesting that its performance is less dependent on the number of goal states. BRTDP is the second best in handling small goal sets, and it runs nearly as fast as FTVI when the goal set is large. Even though\nTVI runs the slowest among the four algorithms, its performance shows less severe dependence on the number of goal states. It runs almost as fast as ILAO* when the goal set size is 1. In contrast, ILAO* runs twice as fast as TVI when the goal set size is greater than 20.\nSearch Depth. In this experiment, we studied how the search depth of a goal from the initial state influences the performance of various algorithms. We chose a Mountain car problem and a Single-arm pendulum problem. We randomly picked 100 initial states from the state space8 and measured the shallowest search depth, or, the shortest distance, d, to a goal state. The running times in Figure 7 are ordered by d. BaRTDP does not terminate with an optimal policy for many instances, so its performance is not shown. BRTDP has the biggest variance so its performance is not included for clarity purposes.\nAs we can see, FTVI is the fastest algorithm in this suite of experiments. It converges very quickly for all initial states (usually around one or two seconds on Mcar300, and less than 10 seconds on SAP300). TVI’s performance is unaffected by the search depth, which is expected, since it is a variant of value iteration and has no search component. In the MCar300 problem, we do not find strong evidence that the running time of any algorithm depends on the search depth. FTVI runs an order of magnitude faster than TVI, ILAO*, and BRTDP and two orders of magnitude faster than LRTDP. In the SAP300 problems, the running times of all algorithms except TVI increase as search depth increases. LRTDP runs fast when d is relatively small, but it slows down considerably and is unable to solve many problems when d becomes larger. ILAO*’s convergence speed varies a bit when the distance is small. As d increases, its running time also increases. BRTDP’s performance (not included) is close to that of ILAO* when d is small, but becomes slower and performs similar to LRTDP when d is large. In this problem, heuristic search algorithms unanimously suffer significantly from the increase in the search depth, as their running times increase by at least two orders of magnitude from small to large d values. On the other hand, FTVI slows down by only one order of magnitude, which makes it converge one order of magnitude faster than ILAO*, one to two orders of magnitude faster than BRTDP and TVI, and two orders of magnitude faster than LRTDP for large depths.\n8. Note that these problems have well-defined initial states. Here we picked initial states arbitrarily from S.\nHeuristic Quality. Finally we studied the effect of the heuristic informativeness on the algorithms. We conducted two sets of experiments, based on two sets of consistent heuristics. We found BRTDP slower than other algorithms in all problems and BaRTDP to be comparable (about 50% slower than LRTDP) only on the Wet100 problem, so did not include their running times. In the first experiment, we pre-computed the optimal value function of a problem using value iteration, and used a fraction of the optimal value as an initial heuristic. Given a fraction f ∈ (0, 1], we calculated h(s) = f × V ∗(s). Figure 8 plots the running times of different algorithms against f for three problems. Note that f = 1 means the initial heuristic is already optimal, so a problem is trivial for all algorithms, but TVI has the overhead of building a topological structure. FTVI, however, is able to detect convergence in the search step and circumvent this overhead, so it is fast. LRTDP is slow in the Wet100 problem, so its running times in that problem are omitted from the figure. The figure shows that as f increases (i.e. as the heuristic becomes more informative) the running times of all algorithms decrease almost linearly. This is true even for TVI, which is not a heuristic-guided algorithm, but takes less time, probably because the initial values affect the number of iterations required until convergence.\nTo thoroughly study the influence of the heuristics, we conducted a second set of experiments. In this experiment, we used a fractional Vl value as our initial heuristic. Recall that Vl is a lower bound of V ∗ computed by the value of a deterministic problem. We calculated the initial heuristic\nby h(s) = f×Vl(s). All included algorithms show a similar smooth decrease in running time when f increases. BRTDP, however, shows strong dependence on the heuristics in the Wet100 problem. Its running time decreases sharply from 96.91 seconds to 0.54 seconds and from 99.81 seconds to 6.21 seconds from when f = 0.02 to when f = 1 in the two experiments. Stable changes in the two experiments suggests the following for algorithms except BRTDP. (1) No algorithm is particularly vulnerable to a less informed heuristic function; (2) extremely informative heuristics (when f is very close to 1) do not necessarily lead to extra fast convergence. This result is in-line with results for deterministic domains (Helmert & Röger, 2008)."
    }, {
      "heading" : "4.3.3 DISCUSSION",
      "text" : "From the experiments, we learn that FTVI is vastly better in domains whose problems have a small number of goal states and a long search depth from the initial state to a goal (such as MCar, SAP and Drive). But the convergence control module of FTVI helps in successfully matching the performance of FTVI with the fastest heuristic search algorithm. In addition, FTVI displays limited advantage over heuristic search in the two intermediate cases where a problem has (1) many goal states but long search depth (Elevator), or (2) a short depth but fewer goal states (DAP). In conclusion, FTVI is our algorithm of choice whenever a problem has either a small number of goal states or a long search depth."
    }, {
      "heading" : "5. Related Work",
      "text" : "Besides TVI several other researchers have proposed decomposing an MDP into sub-problems and combining their solutions for the final policy, e.g., the work of Hauskrecht et al. (1998) and Parr (1998). However, these approaches typically assume some additional structure in the problem, either known hierarchies, or known decomposition into weakly coupled sub-MDPs, etc., whereas FTVI assumes no additional structure.\nBRTDP (McMahan et al., 2005), Bayesian RTDP (Sanner et al., 2009) and Focused RTDP (Smith & Simmons, 2006) (FRTDP) also keep an upper bound for the value function. However, all algorithms use the upper bound purely to judge how close a state is to convergence, by comparing the difference between the upper and lower bound values. For example, BRTDP tries to make searches focus more on states whose two bounds have larger differences, or intuitively, states whose values are less converged. Unlike FTVI, all three algorithms do not perform action elimination, nor do they use any connected component information to solve an MDP. The performance of BRTDP (and similarly Bayesian RTDP) is highly dependent on the quality of the heuristics. Furthermore, FRTDP only works for the discounted setting, thus is not immediately applicable for stochastic shortest path problems.\nHDP is similar to TVI in the sense that it uses the Tarjan’s algorithm (slightly different from the Kosaraju’s algorithm) to find the strongly connected components of a greedy graph. It computes the SCCs multiple times and dynamically during the depth-first searches when HDP tries to label solved states. But it does not find the topological order of the SCCs nor decompose a problem and use the topological order to sequentially solve each SCC.\nPrioritized sweeping (Moore & Atkeson, 1993) and its extensions, focussed dynamic programming (Ferguson & Stentz, 2004) and improved prioritized sweeping (McMahan & Gordon, 2005), order backups intelligently with the help of a priority queue. Each state in the queue is prioritized based on the potential improvement in value of a backup over that state. Dai and Hansen (2007) demonstrate that these algorithms have large overhead in maintaining a priority queue so they are outperformed by a simple backward search algorithm, which implicitly prioritizes backups without a priority queue. Moreover, prioritized sweeping and improved prioritized sweeping find the optimal value of the entire state space of an MDP, as they do not use the initial state information. Focussed dynamic programming, however, is able to make use of the initial state information, but it is not an optimal algorithm. All three algorithms are massively outperformed by an LAO* variant (Dai & Hansen, 2007).\nWhen an MDP is too large to be solved optimally, another thread of work solves MDPs approximately. The typical way to do this is to use deterministic relaxations of the MDP and/or basis\nfunctions (Guestrin, Koller, Parr, & Venkataraman, 2003; Poupart, Boutilier, Patrascu, & Schuurmans, 2002; Patrascu, Poupart, Schuurmans, Boutilier, & Guestrin, 2002; Yoon, Fern, & Givan, 2007; Kolobov, Mausam, & Weld, 2009, 2010a, 2010b). The techniques of these algorithms are orthogonal to the ones by FTVI, and an interesting future direction is to approximate FTVI by applying basis functions.\nWhen an MDP maintains a logical representation, another type of algorithm aggregates groups of states of an MDP by features, represents them as a factored MDP using algebraic and Boolean decision diagrams (ADDs and BDDs) and solves the factored MDP using ADD and BDD operations; SPUDD (Hoey, St-Aubin, Hu, & Boutilier, 1999), sLAO* (Feng & Hansen, 2002), sRTDP (Feng, Hansen, & Zilberstein, 2003) are examples. The factored representation can be exponentially simpler than a flat MDP, but the computation efficiency is problem-dependent. The idea of these algorithms are orthogonal to those of (F)TVI. Exploring ways of combining the ideas of (F)TVI with compact logical representation to achieve further performance improvements remains future work.\nAction elimination was originally proposed by Bertsekas (2001). It has been proved to be helpful for RTDP in the factored MDP setting (Kuter & Hu, 2007), when the cost of an action depends on only a few state variables. Action elimination is also very useful in temporal planning (Mausam & Weld, 2008). It has been extended to combo-elimination, a rule to prune irrelevant action combinations in a setting when multiple actions can be executed at the same time.\nThe idea of finding the topological order of strongly connected components of an MDP has been extended to solving partially-observable MDPs (POMDPs). A POMDP problem is typically much harder than an MDP problem since the decision agent only has partial information of the current state (Littman et al., 1995). The topological order-based planner (POT) (Dibangoye, Shani, Chaib-draa, & Mouaddib, 2009) uses the topological order information of the underlying MDPs to help solve a POMDP problem faster. We believe the idea can be extended to help solve even harder problems, such as decentralized POMDP (Bernstein, Givan, Immerman, & Zilberstein, 2002), in the future."
    }, {
      "heading" : "6. Conclusions",
      "text" : "This work makes several contributions. First, we present two new optimal algorithms to solve MDPs, topological value iteration (TVI) and focused topological value iteration (FTVI). TVI studies the graphical structure of an MDP by breaking it into strongly connected components and solves the MDP based on the topological order of the components. FTVI extends topological value iteration algorithm by focusing the construction of strongly connected components on transitions that likely belong to an optimal policy. FTVI does this by using a small amount of heuristic search to eliminate provably suboptimal actions. In contrast to TVI, which does not care about goal-state information, FTVI removes transitions which it determines to be irrelevant to an optimal policy for reaching the goal. In this sense, FTVI builds a much more informative topological structure than TVI.\nSecond, we show empirically that TVI outperforms VI and other state-of-the-art algorithms when an MDP contains many strongly connected components. We find that TVI is the most advantageous on problems with multiple equal-sized components.\nThird, we show empirically that FTVI outperforms TVI and VI in a large number of domains, usually by an order of magnitude. This performance is due to the success of a more informed graphical structure, since the sizes of the connected components found by FTVI are vastly smaller than those constructed by TVI’s.\nFourth, we find surprisingly that for many domains FTVI massively outperforms popular heuristic search algorithms in convergence speed, such as ILAO*, LRTDP, BRTDP and BaRTDP. After analyzing the performance of these algorithms over different problems, we find that a smaller number of goal states and long search depth to a goal are two key features of problems that are especially hard for heuristic search to handle. Our results show that FTVI outperforms heuristic search in such domains by an order of magnitude.\nFinally, as a by-product we also compare ILAO*, LRTDP, BRTDP and BaRTDP (four popular, state-of-the-art heuristic search algorithms) and find that the strength of each algorithm is usually domain-specific. Generally, ILAO* is faster in convergence than other algorithms. BRTDP and BaRTDP are slow in some domains probably due to the fact that they are vulnerable to those problems’ lack of informed upper bounds."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work was conducted when Peng Dai was a student at the University of Washington. This work was supported by Office of Naval Research grant N00014-06-1-0147, National Science Foundation IIS-1016465, ITR-0325063 and the WRF / TJ Cable Professorship. We thank Eric A. Hansen for sharing his code for ILAO*, and anonymous reviewers for excellent suggestions on improving the manuscript."
    } ],
    "references" : [ {
      "title" : "Decision-Theoretic Military Operations Planning",
      "author" : [ "D. Aberdeen", "S. Thiébaux", "L. Zhang" ],
      "venue" : "In Proc. of the 14th International Conference on Automated Planning and Scheduling",
      "citeRegEx" : "Aberdeen et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Aberdeen et al\\.",
      "year" : 2004
    }, {
      "title" : "Learning to act using real-time dynamic programming",
      "author" : [ "A. Barto", "S. Bradtke", "S. Singh" ],
      "venue" : "Artificial Intelligence J.,",
      "citeRegEx" : "Barto et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Barto et al\\.",
      "year" : 1995
    }, {
      "title" : "Dynamic Programming",
      "author" : [ "R. Bellman" ],
      "venue" : null,
      "citeRegEx" : "Bellman,? \\Q1957\\E",
      "shortCiteRegEx" : "Bellman",
      "year" : 1957
    }, {
      "title" : "The Complexity of Decentralized Control of Markov Decision Processes",
      "author" : [ "D.S. Bernstein", "R. Givan", "N. Immerman", "S. Zilberstein" ],
      "venue" : "Mathematics of Opererations Research,",
      "citeRegEx" : "Bernstein et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Bernstein et al\\.",
      "year" : 2002
    }, {
      "title" : "Faster Heuristic Search Algorithms for Planning with Uncertainty and Full Feedback",
      "author" : [ "B. Bonet", "H. Geffner" ],
      "venue" : "In Proc. of 18th International Joint Conf. on Artificial Intelligence",
      "citeRegEx" : "Bonet and Geffner,? \\Q2003\\E",
      "shortCiteRegEx" : "Bonet and Geffner",
      "year" : 2003
    }, {
      "title" : "Labeled RTDP: Improving the Convergence of Real-time Dynamic Programming",
      "author" : [ "B. Bonet", "H. Geffner" ],
      "venue" : "In Proc. 13th International Conference on Automated Planning and Scheduling",
      "citeRegEx" : "Bonet and Geffner,? \\Q2003\\E",
      "shortCiteRegEx" : "Bonet and Geffner",
      "year" : 2003
    }, {
      "title" : "Non-Deterministic Planning Track of the 2006 International Planning Competition.. http://www.ldc.usb.ve/ ̃bonet/ipc5",
      "author" : [ "B. Bonet" ],
      "venue" : null,
      "citeRegEx" : "Bonet,? \\Q2006\\E",
      "shortCiteRegEx" : "Bonet",
      "year" : 2006
    }, {
      "title" : "On the Speed of Convergence of Value Iteration on Stochastic Shortest-Path Problems",
      "author" : [ "B. Bonet" ],
      "venue" : "Mathematics of Operations Research,",
      "citeRegEx" : "Bonet,? \\Q2007\\E",
      "shortCiteRegEx" : "Bonet",
      "year" : 2007
    }, {
      "title" : "Learning in Depth-First Search: A Unified Approach to Heuristic Search in Deterministic Non-deterministic Settings, and Its Applications to MDPs",
      "author" : [ "B. Bonet", "H. Geffner" ],
      "venue" : "In Proc. of the 16th International Conference on Automated Planning and Scheduling",
      "citeRegEx" : "Bonet and Geffner,? \\Q2006\\E",
      "shortCiteRegEx" : "Bonet and Geffner",
      "year" : 2006
    }, {
      "title" : "Planning under Continuous Time and Resource Uncertainty: A Challenge for AI",
      "author" : [ "J.L. Bresina", "R. Dearden", "N. Meuleau", "S. Ramkrishnan", "D.E. Smith", "R. Washington" ],
      "venue" : "In Proc. of 18th Conf. in Uncertainty in AI (UAI-02),",
      "citeRegEx" : "Bresina et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Bresina et al\\.",
      "year" : 2002
    }, {
      "title" : "Introduction to Algorithms, Second Edition",
      "author" : [ "T.H. Cormen", "C.E. Leiserson", "R.L. Rivest", "C. Stein" ],
      "venue" : null,
      "citeRegEx" : "Cormen et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Cormen et al\\.",
      "year" : 2001
    }, {
      "title" : "Topological Value Iteration Algorithm for Markov Decision Processes",
      "author" : [ "P. Dai", "J. Goldsmith" ],
      "venue" : "In Proc. of IJCAI,",
      "citeRegEx" : "Dai and Goldsmith,? \\Q2007\\E",
      "shortCiteRegEx" : "Dai and Goldsmith",
      "year" : 2007
    }, {
      "title" : "Prioritizing Bellman Backups Without a Priority Queue",
      "author" : [ "P. Dai", "E.A. Hansen" ],
      "venue" : "In Proc. of the 17th International Conference on Automated Planning and Scheduling",
      "citeRegEx" : "Dai and Hansen,? \\Q2007\\E",
      "shortCiteRegEx" : "Dai and Hansen",
      "year" : 2007
    }, {
      "title" : "Partitioned External-Memory Value Iteration",
      "author" : [ "P. Dai", "Mausam", "D.S. Weld" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "Dai et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Dai et al\\.",
      "year" : 2008
    }, {
      "title" : "Domain-Independent, Automatic Partitioning for Probabilistic Planning",
      "author" : [ "P. Dai", "Mausam", "D.S. Weld" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "Dai et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Dai et al\\.",
      "year" : 2009
    }, {
      "title" : "Focused Topological Value Iteration",
      "author" : [ "P. Dai", "Mausam", "D.S. Weld" ],
      "venue" : "In Proc. of ICAPS,",
      "citeRegEx" : "Dai et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Dai et al\\.",
      "year" : 2009
    }, {
      "title" : "Topological Order Planner for POMDPs",
      "author" : [ "J.S. Dibangoye", "G. Shani", "B. Chaib-draa", "Mouaddib", "A.-I" ],
      "venue" : "In Proc. of IJCAI,",
      "citeRegEx" : "Dibangoye et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Dibangoye et al\\.",
      "year" : 2009
    }, {
      "title" : "Symbolic Heuristic Search for Factored Markov Decision Processes",
      "author" : [ "Z. Feng", "E.A. Hansen" ],
      "venue" : "In Proc. of the 17th National Conference on Artificial Intelligence (AAAI-05)",
      "citeRegEx" : "Feng and Hansen,? \\Q2002\\E",
      "shortCiteRegEx" : "Feng and Hansen",
      "year" : 2002
    }, {
      "title" : "Symbolic Generalization for On-line Planning",
      "author" : [ "Z. Feng", "E.A. Hansen", "S. Zilberstein" ],
      "venue" : "In Proc. of the 19th Conference in Uncertainty in Artificial Intelligence",
      "citeRegEx" : "Feng et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Feng et al\\.",
      "year" : 2003
    }, {
      "title" : "Region-Based Incremental Pruning for POMDPs",
      "author" : [ "Z. Feng", "S. Zilberstein" ],
      "venue" : "In Proc. of UAI,",
      "citeRegEx" : "Feng and Zilberstein,? \\Q2004\\E",
      "shortCiteRegEx" : "Feng and Zilberstein",
      "year" : 2004
    }, {
      "title" : "Focussed Dynamic Programming: Extensive Comparative Results",
      "author" : [ "D. Ferguson", "A. Stentz" ],
      "venue" : "Tech. rep. CMU-RI-TR-04-13,",
      "citeRegEx" : "Ferguson and Stentz,? \\Q2004\\E",
      "shortCiteRegEx" : "Ferguson and Stentz",
      "year" : 2004
    }, {
      "title" : "Efficient Solution Algorithms for Factored MDPs",
      "author" : [ "C. Guestrin", "D. Koller", "R. Parr", "S. Venkataraman" ],
      "venue" : "J. of Artificial Intelligence Research,",
      "citeRegEx" : "Guestrin et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Guestrin et al\\.",
      "year" : 2003
    }, {
      "title" : "LAO*: A heuristic search algorithm that finds solutions with loops",
      "author" : [ "E.A. Hansen", "S. Zilberstein" ],
      "venue" : "Artificial Intelligence J.,",
      "citeRegEx" : "Hansen and Zilberstein,? \\Q2001\\E",
      "shortCiteRegEx" : "Hansen and Zilberstein",
      "year" : 2001
    }, {
      "title" : "Hierarchical Solution of Markov Decision Processes using Macro-actions",
      "author" : [ "M. Hauskrecht", "N. Meuleau", "L.P. Kaelbling", "T. Dean", "C. Boutilier" ],
      "venue" : "In Proc. of UAI,",
      "citeRegEx" : "Hauskrecht et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Hauskrecht et al\\.",
      "year" : 1998
    }, {
      "title" : "How Good is Almost Perfect",
      "author" : [ "M. Helmert", "G. Röger" ],
      "venue" : "In Proc. of AAAI,",
      "citeRegEx" : "Helmert and Röger,? \\Q2008\\E",
      "shortCiteRegEx" : "Helmert and Röger",
      "year" : 2008
    }, {
      "title" : "SPUDD: Stochastic Planning using Decision Diagrams",
      "author" : [ "J. Hoey", "R. St-Aubin", "A. Hu", "C. Boutilier" ],
      "venue" : "In Proc. of the 15th Conference on Uncertainty in Artificial Intelligence",
      "citeRegEx" : "Hoey et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Hoey et al\\.",
      "year" : 1999
    }, {
      "title" : "ReTrASE: Intergating Paradigms for Approximate Probabilistic Planning",
      "author" : [ "A. Kolobov", "Mausam", "D.S. Weld" ],
      "venue" : "In Proc. of IJCAI,",
      "citeRegEx" : "Kolobov et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Kolobov et al\\.",
      "year" : 2009
    }, {
      "title" : "Classical Planning in MDP Heuristics: With a Little Help from Generalization",
      "author" : [ "A. Kolobov", "Mausam", "D.S. Weld" ],
      "venue" : "In Proc. of ICAPS,",
      "citeRegEx" : "Kolobov et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kolobov et al\\.",
      "year" : 2010
    }, {
      "title" : "SixthSense: Fast and Reliable Recognition of Dead Ends in MDPs",
      "author" : [ "A. Kolobov", "Mausam", "D.S. Weld" ],
      "venue" : "In Proc. of AAAI",
      "citeRegEx" : "Kolobov et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kolobov et al\\.",
      "year" : 2010
    }, {
      "title" : "Computing and Using Lower and Upper Bounds for Action Elimination in MDP Planning",
      "author" : [ "U. Kuter", "J. Hu" ],
      "venue" : "In SARA,",
      "citeRegEx" : "Kuter and Hu,? \\Q2007\\E",
      "shortCiteRegEx" : "Kuter and Hu",
      "year" : 2007
    }, {
      "title" : "On the Complexity of Solving Markov Decision Problems",
      "author" : [ "M.L. Littman", "T. Dean", "L.P. Kaelbling" ],
      "venue" : "In Proc. of the 11th Annual Conference on Uncertainty in Artificial Intelligence",
      "citeRegEx" : "Littman et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Littman et al\\.",
      "year" : 1995
    }, {
      "title" : "Planning with Continuous Resources in Stochastic Domains",
      "author" : [ "Mausam", "E. Benazera", "R.I. Brafman", "N. Meuleau", "E.A. Hansen" ],
      "venue" : "In Proc. of IJCAI,",
      "citeRegEx" : "Mausam et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Mausam et al\\.",
      "year" : 2005
    }, {
      "title" : "Planning with Durative Actions in Stochastic Domains",
      "author" : [ "Mausam", "D.S. Weld" ],
      "venue" : "J. of Artificial Intelligence Research (JAIR),",
      "citeRegEx" : "Mausam and Weld,? \\Q2008\\E",
      "shortCiteRegEx" : "Mausam and Weld",
      "year" : 2008
    }, {
      "title" : "Fast Exact Planning in Markov Decision Processes",
      "author" : [ "H.B. McMahan", "G.J. Gordon" ],
      "venue" : "In Proc. of the 15th International Conference on Automated Planning and Scheduling (ICAPS05)",
      "citeRegEx" : "McMahan and Gordon,? \\Q2005\\E",
      "shortCiteRegEx" : "McMahan and Gordon",
      "year" : 2005
    }, {
      "title" : "Bounded real-time dynamic programming: RTDP with monotone upper bounds and performance guarantees",
      "author" : [ "H.B. McMahan", "M. Likhachev", "G.J. Gordon" ],
      "venue" : "In Proceedings of the 22nd international conference on Machine learning",
      "citeRegEx" : "McMahan et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "McMahan et al\\.",
      "year" : 2005
    }, {
      "title" : "A Heuristic Search Approach to Planning with Continuous Resources in Stochastic Domains",
      "author" : [ "N. Meuleau", "E. Benazera", "R.I. Brafman", "E.A. Hansen", "Mausam" ],
      "venue" : "J. of Artificial Intellegence Research (JAIR),",
      "citeRegEx" : "Meuleau et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Meuleau et al\\.",
      "year" : 2009
    }, {
      "title" : "Prioritized Sweeping: Reinforcement Learning with Less Data and Less Real Time",
      "author" : [ "A. Moore", "C. Atkeson" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Moore and Atkeson,? \\Q1993\\E",
      "shortCiteRegEx" : "Moore and Atkeson",
      "year" : 1993
    }, {
      "title" : "Flexibly Integrating Deliberation and Execution in Decision-Theoretic Agents. In ICAPS Workshop on Planning and Plan-Execution for Real-World Systems",
      "author" : [ "D.J. Musliner", "J. Carciofini", "R.P. Goldman", "J.W.E.H. Durfee", "M.S. Boddy" ],
      "venue" : null,
      "citeRegEx" : "Musliner et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Musliner et al\\.",
      "year" : 2007
    }, {
      "title" : "Principles of Artificial Intelligence",
      "author" : [ "N.J. Nilson" ],
      "venue" : "Tioga Publishing",
      "citeRegEx" : "Nilson,? \\Q1980\\E",
      "shortCiteRegEx" : "Nilson",
      "year" : 1980
    }, {
      "title" : "Flexible Decomposition Algorithms for Weakly Coupled Markov Decision Problems",
      "author" : [ "R. Parr" ],
      "venue" : "In Proc. of UAI,",
      "citeRegEx" : "Parr,? \\Q1998\\E",
      "shortCiteRegEx" : "Parr",
      "year" : 1998
    }, {
      "title" : "Greedy Linear Value-Approximation for Factored Markov Decision Processes",
      "author" : [ "R. Patrascu", "P. Poupart", "D. Schuurmans", "C. Boutilier", "C. Guestrin" ],
      "venue" : "In Proc. of the 17th National Conference on Artificial Intelligence",
      "citeRegEx" : "Patrascu et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Patrascu et al\\.",
      "year" : 2002
    }, {
      "title" : "Piecewise Linear Value Function Approximation for Factored MDPs",
      "author" : [ "P. Poupart", "C. Boutilier", "R. Patrascu", "D. Schuurmans" ],
      "venue" : "In Proc. of the 18th National Conference on Artificial Intelligence",
      "citeRegEx" : "Poupart et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Poupart et al\\.",
      "year" : 2002
    }, {
      "title" : "Bayesian Real-Time Dynamic Programming",
      "author" : [ "S. Sanner", "R. Goetschalckx", "K. Driessens", "G. Shani" ],
      "venue" : "In Proc. of IJCAI,",
      "citeRegEx" : "Sanner et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Sanner et al\\.",
      "year" : 2009
    }, {
      "title" : "Focused Real-Time Dynamic Programming for MDPs: Squeezing More Out of a Heuristic",
      "author" : [ "T. Smith", "R.G. Simmons" ],
      "venue" : "In Proc. of the 21th National Conference on Artificial Intelligence (AAAI-06)",
      "citeRegEx" : "Smith and Simmons,? \\Q2006\\E",
      "shortCiteRegEx" : "Smith and Simmons",
      "year" : 2006
    }, {
      "title" : "Prioritization Methods for Accelerating MDP Solvers",
      "author" : [ "D. Wingate", "K.D. Seppi" ],
      "venue" : "J. of Machine Learning Research,",
      "citeRegEx" : "Wingate and Seppi,? \\Q2005\\E",
      "shortCiteRegEx" : "Wingate and Seppi",
      "year" : 2005
    }, {
      "title" : "FF-Replan: A Baseline for Probabilistic Planning",
      "author" : [ "S. Yoon", "A. Fern", "R. Givan" ],
      "venue" : "In Proc. of the 17th International Conference on Automated Planning and Scheduling",
      "citeRegEx" : "Yoon et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Yoon et al\\.",
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "Markov Decision Processes (MDPs) (Bellman, 1957) are a powerful and widely-adopted formulation for modeling autonomous decision making under uncertainty.",
      "startOffset" : 33,
      "endOffset" : 48
    }, {
      "referenceID" : 6,
      "context" : ", Mountain car (Wingate & Seppi, 2005) and Drive (Bonet, 2006).",
      "startOffset" : 49,
      "endOffset" : 62
    }, {
      "referenceID" : 2,
      "context" : "2 Dynamic Programming Most optimal MDP algorithms are based on dynamic programming, whose utility was first proved by a simple yet powerful algorithm named value iteration (Bellman, 1957).",
      "startOffset" : 172,
      "endOffset" : 187
    }, {
      "referenceID" : 7,
      "context" : "Value iteration converges to the optimal value function in time polynomial in |S| (Littman, Dean, & Kaelbling, 1995; Bonet, 2007), yet in practice it is usually inefficient, since it blindly performs backups over the state space iteratively, often introducing many unnecessary backups.",
      "startOffset" : 82,
      "endOffset" : 129
    }, {
      "referenceID" : 34,
      "context" : "1 HEURISTIC SEARCH To improve the efficiency of dynamic programming, researchers have explored various ideas from traditional heuristic-guided search, and have consistently demonstrated their usefulness for MDPs (Barto, Bradtke, & Singh, 1995; Hansen & Zilberstein, 2001; Bonet & Geffner, 2003b, 2006; McMahan et al., 2005; Smith & Simmons, 2006; Sanner et al., 2009).",
      "startOffset" : 212,
      "endOffset" : 367
    }, {
      "referenceID" : 42,
      "context" : "1 HEURISTIC SEARCH To improve the efficiency of dynamic programming, researchers have explored various ideas from traditional heuristic-guided search, and have consistently demonstrated their usefulness for MDPs (Barto, Bradtke, & Singh, 1995; Hansen & Zilberstein, 2001; Bonet & Geffner, 2003b, 2006; McMahan et al., 2005; Smith & Simmons, 2006; Sanner et al., 2009).",
      "startOffset" : 212,
      "endOffset" : 367
    }, {
      "referenceID" : 38,
      "context" : "The AO* algorithm (Nilson, 1980) solves acyclic MDPs, so it is not applicable to general MDPs.",
      "startOffset" : 18,
      "endOffset" : 32
    }, {
      "referenceID" : 1,
      "context" : "Real-time dynamic programming (RTDP) (Barto et al., 1995) is another popular algorithm for MDPs.",
      "startOffset" : 37,
      "endOffset" : 57
    }, {
      "referenceID" : 1,
      "context" : "Real-time dynamic programming (RTDP) (Barto et al., 1995) is another popular algorithm for MDPs. It interleaves dynamic programming with search through plan execution trials. An execution trial is a path that originates from s0 and ends at any goal state or by a bounded-step cutoff. Each execution step simulates the result of one-step plan execution. The agent greedily picks an action a of the current state s, and mimics the state transition to a new current state s′, chosen stochastically based on the transition probabilities of the action, i.e., s′ ∼ Ta(s|s). Dynamic programming happens when states are backed up immediately when they are visited. RTDP is good at finding a good sub-optimal policy relatively quickly. However, in order for RTDP to converge, states on the optimal policy have to be backed up sufficiently, so its convergence is usually slow. To overcome the slow convergence problem of RTDP, researchers later proposed several heuristic search variants of the algorithm. Bonet and Geffner (2003b) introduced a smart labeling technique in a RTDP extension named labeled RTDP (LRTDP).",
      "startOffset" : 38,
      "endOffset" : 1022
    }, {
      "referenceID" : 34,
      "context" : "McMahan et al. (2005) proposed another extension named bounded RTDP (BRTDP), which not only uses a lower bound heuristic of the value function Vl, but also an upper bound Vu.",
      "startOffset" : 0,
      "endOffset" : 22
    }, {
      "referenceID" : 34,
      "context" : "McMahan et al. (2005) proposed another extension named bounded RTDP (BRTDP), which not only uses a lower bound heuristic of the value function Vl, but also an upper bound Vu. BRTDP has two key differences from the original RTDP algorithm. First, once BRTDP backs up a state s, it updates both the lower bound and the upper bound. Second, when choosing the next state s′, the difference of its two bounds, Vu(s)− Vl(s), is also taken into consideration. More concretely, s′ ∼ Ta(s|s)[Vu(s) − Vl(s)], which focuses search on states that are less likely to be converged. One feature of BRTDP is its adaptive trial termination criterion, which is very helpful in practice. Smith and Simmons (2006) introduced a similar algorithm named focused RTDP (FRTDP).",
      "startOffset" : 0,
      "endOffset" : 694
    }, {
      "referenceID" : 34,
      "context" : "McMahan et al. (2005) proposed another extension named bounded RTDP (BRTDP), which not only uses a lower bound heuristic of the value function Vl, but also an upper bound Vu. BRTDP has two key differences from the original RTDP algorithm. First, once BRTDP backs up a state s, it updates both the lower bound and the upper bound. Second, when choosing the next state s′, the difference of its two bounds, Vu(s)− Vl(s), is also taken into consideration. More concretely, s′ ∼ Ta(s|s)[Vu(s) − Vl(s)], which focuses search on states that are less likely to be converged. One feature of BRTDP is its adaptive trial termination criterion, which is very helpful in practice. Smith and Simmons (2006) introduced a similar algorithm named focused RTDP (FRTDP). They define occupancy as an intuitive measure of the expected number of times a state is visited before execution termination. Therefore occupancy of a state indicates its relevance to a policy. Similar to BRTDP, FRTDP also keeps two bounds for a state. FRTDP uses the product of a state’s occupancy and the difference of its bounds for picking the next state. Also, FRTDP assumes a discounted cost setting, so it is not immediately applicable to SSP problems. Recently Sanner et al. (2009) described another advanced RTDP variant named Bayesian RTDP, which also uses two value bounds.",
      "startOffset" : 0,
      "endOffset" : 1244
    }, {
      "referenceID" : 30,
      "context" : "None of the algorithms use an MDP’s graphical structure, an intrinsic property that governs the complexity of solving a problem (Littman et al., 1995), in a way to decide the order in which states are solved.",
      "startOffset" : 128,
      "endOffset" : 150
    }, {
      "referenceID" : 10,
      "context" : "Algorithm 2 Topological Value Iteration 1: Input: an MDP M = 〈S,A, Ap, T, C〉, δ: the threshold value 2: SCC(M ) 3: for i← 1 to cpntnum do 4: S ′ ← the set of states s where id[s] = i 5: M ′ ← 〈S ′,A, Ap, T, C〉 6: VI(M ′, δ) 7: 8: Function SCC(M) 9: construct GR of M 10: construct a graph GR which reverses the head and tail vertices of every edge in GR 11: {call Kosaraju’s algorithm (Cormen et al., 2001).",
      "startOffset" : 385,
      "endOffset" : 406
    }, {
      "referenceID" : 2,
      "context" : "3 Experiments We address the following questions in our experiments: (1) How does TVI compare with VI and heuristic search algorithms on MDPs that contain multiple SCCs? (2) What are the most favorable problem features for TVI? We compared TVI with several other optimal algorithms, including VI (Bellman, 1957), ILAO* (Hansen & Zilberstein, 2001), LRTDP (Bonet & Geffner, 2003b), BRTDP (McMahan et al.",
      "startOffset" : 296,
      "endOffset" : 311
    }, {
      "referenceID" : 34,
      "context" : "3 Experiments We address the following questions in our experiments: (1) How does TVI compare with VI and heuristic search algorithms on MDPs that contain multiple SCCs? (2) What are the most favorable problem features for TVI? We compared TVI with several other optimal algorithms, including VI (Bellman, 1957), ILAO* (Hansen & Zilberstein, 2001), LRTDP (Bonet & Geffner, 2003b), BRTDP (McMahan et al., 2005), Bayesian RTDP (Sanner et al.",
      "startOffset" : 387,
      "endOffset" : 409
    }, {
      "referenceID" : 42,
      "context" : ", 2005), Bayesian RTDP (Sanner et al., 2009) (BaRTDP), and HDP (Bonet & Geffner, 2003a)1.",
      "startOffset" : 23,
      "endOffset" : 44
    }, {
      "referenceID" : 2,
      "context" : "3 Experiments We address the following questions in our experiments: (1) How does TVI compare with VI and heuristic search algorithms on MDPs that contain multiple SCCs? (2) What are the most favorable problem features for TVI? We compared TVI with several other optimal algorithms, including VI (Bellman, 1957), ILAO* (Hansen & Zilberstein, 2001), LRTDP (Bonet & Geffner, 2003b), BRTDP (McMahan et al., 2005), Bayesian RTDP (Sanner et al., 2009) (BaRTDP), and HDP (Bonet & Geffner, 2003a)1. We used the fully optimized C code of ILAO* provided by Eric A. Hansen and additionally implemented the rest of the algorithms over the same framework. We performed all experiments on a 2.5GHz Dual-Core AMD Opteron(tm) Processor with 2GB memory. Recall that BRTDP and BaRTDP use upper bounds. We used upper bounds as described in Section 4.2. We used α = 2 × 10−6 and τ = 10 for BRTDP and BaRTDP.2 For BaRTDP, we used the probabilistic termination condition in Algorithm 3 of Sanner et al. (2009). 3 We compared all algorithms on running time, time between an algorithm starts solving a problem until generating a policy with a Bellman error of at most δ(= 10−6).",
      "startOffset" : 297,
      "endOffset" : 989
    }, {
      "referenceID" : 34,
      "context" : "This is reminiscent of backups in BRTDP (McMahan et al., 2005).",
      "startOffset" : 40,
      "endOffset" : 62
    }, {
      "referenceID" : 6,
      "context" : "Single-arm pendulum (Wingate & Seppi, 2005), Drive, and Elevator (Bonet, 2006).",
      "startOffset" : 65,
      "endOffset" : 78
    }, {
      "referenceID" : 34,
      "context" : "BRTDP (McMahan et al., 2005), Bayesian RTDP (Sanner et al.",
      "startOffset" : 6,
      "endOffset" : 28
    }, {
      "referenceID" : 42,
      "context" : ", 2005), Bayesian RTDP (Sanner et al., 2009) and Focused RTDP (Smith & Simmons, 2006) (FRTDP) also keep an upper bound for the value function.",
      "startOffset" : 23,
      "endOffset" : 44
    }, {
      "referenceID" : 22,
      "context" : ", the work of Hauskrecht et al. (1998) and Parr (1998).",
      "startOffset" : 14,
      "endOffset" : 39
    }, {
      "referenceID" : 22,
      "context" : ", the work of Hauskrecht et al. (1998) and Parr (1998). However, these approaches typically assume some additional structure in the problem, either known hierarchies, or known decomposition into weakly coupled sub-MDPs, etc.",
      "startOffset" : 14,
      "endOffset" : 55
    }, {
      "referenceID" : 12,
      "context" : "Dai and Hansen (2007) demonstrate that these algorithms have large overhead in maintaining a priority queue so they are outperformed by a simple backward search algorithm, which implicitly prioritizes backups without a priority queue.",
      "startOffset" : 0,
      "endOffset" : 22
    }, {
      "referenceID" : 30,
      "context" : "A POMDP problem is typically much harder than an MDP problem since the decision agent only has partial information of the current state (Littman et al., 1995).",
      "startOffset" : 136,
      "endOffset" : 158
    }, {
      "referenceID" : 38,
      "context" : "functions (Guestrin, Koller, Parr, & Venkataraman, 2003; Poupart, Boutilier, Patrascu, & Schuurmans, 2002; Patrascu, Poupart, Schuurmans, Boutilier, & Guestrin, 2002; Yoon, Fern, & Givan, 2007; Kolobov, Mausam, & Weld, 2009, 2010a, 2010b). The techniques of these algorithms are orthogonal to the ones by FTVI, and an interesting future direction is to approximate FTVI by applying basis functions. When an MDP maintains a logical representation, another type of algorithm aggregates groups of states of an MDP by features, represents them as a factored MDP using algebraic and Boolean decision diagrams (ADDs and BDDs) and solves the factored MDP using ADD and BDD operations; SPUDD (Hoey, St-Aubin, Hu, & Boutilier, 1999), sLAO* (Feng & Hansen, 2002), sRTDP (Feng, Hansen, & Zilberstein, 2003) are examples. The factored representation can be exponentially simpler than a flat MDP, but the computation efficiency is problem-dependent. The idea of these algorithms are orthogonal to those of (F)TVI. Exploring ways of combining the ideas of (F)TVI with compact logical representation to achieve further performance improvements remains future work. Action elimination was originally proposed by Bertsekas (2001). It has been proved to be helpful for RTDP in the factored MDP setting (Kuter & Hu, 2007), when the cost of an action depends on only a few state variables.",
      "startOffset" : 29,
      "endOffset" : 1213
    } ],
    "year" : 2011,
    "abstractText" : "Value iteration is a powerful yet inefficient algorithm for Markov decision processes (MDPs) because it puts the majority of its effort into backing up the entire state space, which turns out to be unnecessary in many cases. In order to overcome this problem, many approaches have been proposed. Among them, ILAO* and variants of RTDP are state-of-the-art ones. These methods use reachability analysis and heuristic search to avoid some unnecessary backups. However, none of these approaches build the graphical structure of the state transitions in a pre-processing step or use the structural information to systematically decompose a problem, whereby generating an intelligent backup sequence of the state space. In this paper, we present two optimal MDP algorithms. The first algorithm, topological value iteration (TVI), detects the structure of MDPs and backs up states based on topological sequences. It (1) divides an MDP into strongly-connected components (SCCs), and (2) solves these components sequentially. TVI outperforms VI and other state-of-the-art algorithms vastly when an MDP has multiple, close-to-equal-sized SCCs. The second algorithm, focused topological value iteration (FTVI), is an extension of TVI. FTVI restricts its attention to connected components that are relevant for solving the MDP. Specifically, it uses a small amount of heuristic search to eliminate provably sub-optimal actions; this pruning allows FTVI to find smaller connected components, thus running faster. We demonstrate that FTVI outperforms TVI by an order of magnitude, averaged across several domains. Surprisingly, FTVI also significantly outperforms popular ‘heuristically-informed’ MDP algorithms such as ILAO*, LRTDP, BRTDP and Bayesian-RTDP in many domains, sometimes by as much as two orders of magnitude. Finally, we characterize the type of domains where FTVI excels — suggesting a way to an informed choice of solver.",
    "creator" : "TeX"
  }
}