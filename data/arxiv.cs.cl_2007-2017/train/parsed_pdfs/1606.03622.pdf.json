{
  "name" : "1606.03622.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Data Recombination for Neural Semantic Parsing",
    "authors" : [ "Robin Jia", "Percy Liang" ],
    "emails" : [ "robinjia@stanford.edu", "pliang@cs.stanford.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Semantic parsing—the precise translation of natural language utterances into logical forms—has many applications, including question answering (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Liang et al., 2011; Berant et al., 2013), instruction following (Artzi and Zettlemoyer, 2013b), and regular expression generation (Kushman and Barzilay, 2013). Modern semantic parsers (Artzi and Zettlemoyer, 2013a; Berant et al., 2013) are complex pieces of software, requiring handcrafted features, lexicons, and grammars.\nMeanwhile, recurrent neural networks (RNNs)\nhave made swift inroads into many structured prediction tasks in NLP, including machine translation (Sutskever et al., 2014; Bahdanau et al., 2014) and syntactic parsing (Vinyals et al., 2015b; Dyer et al., 2015). Because RNNs make very few domain-specific assumptions, they have the potential to succeed at a wide variety of tasks with minimal feature engineering. However, this flexibility also puts RNNs at a disadvantage compared to standard semantic parsers, which can generalize naturally by leveraging their built-in awareness of logical compositionality.\nIn this paper, we introduce data recombination, a generic framework for declaratively inject-\nar X\niv :1\n60 6.\n03 62\n2v 1\n[ cs\n.C L\n] 1\n1 Ju\nn 20\n16\ning prior knowledge into a domain-general structured prediction model. In data recombination, prior knowledge about a task is used to build a high-precision generative model that expands the empirical distribution by allowing fragments of different examples to be combined in particular ways. Samples from this generative model are then used to train a domain-general model. In the case of semantic parsing, we construct a generative model by inducing a synchronous context-free grammar (SCFG), creating new examples such as those shown in Figure 1; our domain-general model is a sequence-to-sequence RNN with a novel attention-based copying mechanism. Data recombination boosts the accuracy of our RNN model on three semantic parsing datasets. On the GEO dataset, data recombination improves test accuracy by 4.3 percentage points over our baseline RNN, leading to new state-of-the-art results for models that do not use a seed lexicon for predicates."
    }, {
      "heading" : "2 Problem statement",
      "text" : "We cast semantic parsing as a sequence-tosequence task. The input utterance x is a sequence of words x1, . . . , xm ∈ V (in), the input vocabulary; similarly, the output logical form y is a sequence of tokens y1, . . . , yn ∈ V (out), the output vocabulary. A linear sequence of tokens might appear to lose the hierarchical structure of a logical form, but there is precedent for this choice: Vinyals et al.\n(2015b) showed that an RNN can reliably predict tree-structured outputs in a linear fashion.\nWe evaluate our system on three existing semantic parsing datasets. Figure 2 shows sample input-output pairs from each of these datasets.\n• GeoQuery (GEO) contains natural language questions about US geography paired with corresponding Prolog database queries. We use the standard split of 600 training examples and 280 test examples introduced by Zettlemoyer and Collins (2005). We preprocess the logical forms to De Brujin index notation to standardize variable naming.\n• ATIS (ATIS) contains natural language queries for a flights database paired with corresponding database queries written in lambda calculus. We train on 4473 examples and evaluate on the 448 test examples used by Zettlemoyer and Collins (2007).\n• Overnight (OVERNIGHT) contains logical forms paired with natural language paraphrases across eight varied subdomains. Wang et al. (2015) constructed the dataset by generating all possible logical forms up to some depth threshold, then getting multiple natural language paraphrases for each logical form from workers on Amazon Mechanical Turk. We evaluate on the same train/test splits as Wang et al. (2015).\nIn this paper, we only explore learning from logical forms. In the last few years, there has an emergence of semantic parsers learned from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013b). While our system cannot directly learn from denotations, it could be used to rerank candidate derivations generated by one of these other systems."
    }, {
      "heading" : "3 Sequence-to-sequence RNN Model",
      "text" : "Our sequence-to-sequence RNN model is based on existing attention-based neural machine translation models (Bahdanau et al., 2014; Luong et al., 2015a), but also includes a novel attention-based copying mechanism. Similar copying mechanisms have been explored in parallel by Gu et al. (2016) and Gulcehre et al. (2016)."
    }, {
      "heading" : "3.1 Basic Model",
      "text" : "Encoder. The encoder converts the input sequence x1, . . . , xm into a sequence of context-\nsensitive embeddings b1, . . . , bm using a bidirectional RNN (Bahdanau et al., 2014). First, a word embedding function φ(in) maps each word xi to a fixed-dimensional vector. These vectors are fed as input to two RNNs: a forward RNN and a backward RNN. The forward RNN starts with an initial hidden state hF0, and generates a sequence of hidden states hF1, . . . , h F m by repeatedly applying the recurrence\nhFi = LSTM(φ (in)(xi), h F i−1). (1)\nThe recurrence takes the form of an LSTM (Hochreiter and Schmidhuber, 1997). The backward RNN similarly generates hidden states hBm, . . . , h B 1 by processing the input sequence in reverse order. Finally, for each input position i, we define the context-sensitive embedding bi to be the concatenation of hFi and h B i\nDecoder. The decoder is an attention-based model (Bahdanau et al., 2014; Luong et al., 2015a) that generates the output sequence y1, . . . , yn one token at a time. At each time step j, it writes yj based on the current hidden state sj , then updates the hidden state to sj+1 based on sj and yj . Formally, the decoder is defined by the following equations:\ns1 = tanh(W (s)[hFm, h B 1 ]). (2)\neji = s > j W (a)bi. (3) αji = exp(eji)∑m i′=1 exp(eji′) . (4)\ncj = m∑ i=1 αjibi. (5) P (yj = w | x, y1:j−1) ∝ exp(Uw[sj , cj ]). (6) sj+1 = LSTM([φ(out)(yj), cj ], sj). (7)\nWhen not specified, i ranges over {1, . . . ,m} and j ranges over {1, . . . , n}. Intuitively, the αji’s define a probability distribution over the input words, describing what words in the input the decoder is focusing on at time j. They are computed from the unnormalized attention scores eji. The matrices W (s), W (a), and U , as well as the embedding function φ(out), are parameters of the model."
    }, {
      "heading" : "3.2 Attention-based Copying",
      "text" : "In the basic model of the previous section, the next output word yj is chosen via a simple softmax over all words in the output vocabulary. However, this\nmodel has difficulty generalizing to the long tail of entity names commonly found in semantic parsing datasets. Conveniently, entity names in the input often correspond directly to tokens in the output (e.g., “iowa” becomes iowa in Figure 2).1\nTo capture this intuition, we introduce a new attention-based copying mechanism. At each time step j, the decoder generates one of two types of actions. As before, it can write any word in the output vocabulary. In addition, it can copy any input word xi directly to the output, where the probability with which we copy xi is determined by the attention score on xi. Formally, we define a latent action aj that is either Write[w] for some w ∈ V (out) or Copy[i] for some i ∈ {1, . . . ,m}. We then have\nP (aj = Write[w] | x, y1:j−1) ∝ exp(Uw[sj , cj ]), (8)\nP (aj = Copy[i] | x, y1:j−1) ∝ exp(eji). (9)\nThe decoder chooses aj with a softmax over all these possible actions; yj is then a deterministic function of aj and x. During training, we maximize the log-likelihood of y, marginalizing out a.\nAttention-based copying can be seen as a combination of a standard softmax output layer of an attention-based model (Bahdanau et al., 2014) and a Pointer Network (Vinyals et al., 2015a); in a Pointer Network, the only way to generate output is to copy a symbol from the input."
    }, {
      "heading" : "4 Data Recombination",
      "text" : ""
    }, {
      "heading" : "4.1 Motivation",
      "text" : "The main contribution of this paper is a novel data recombination framework that injects important prior knowledge into our oblivious sequence-tosequence RNN. In this framework, we induce a high-precision generative model from the training data, then sample from it to generate new training examples. The process of inducing this generative model can leverage any available prior knowledge, which is transmitted through the generated examples to the RNN model. A key advantage of our two-stage approach is that it allows us to declare desired properties of the task which might be hard to capture in the model architecture.\n1 On GEO and ATIS, we make a point not to rely on orthography for non-entities such as “state” to _state, since this leverages information not available to previous models (Zettlemoyer and Collins, 2005) and is much less languageindependent.\nOur approach generalizes data augmentation, which is commonly employed to inject prior knowledge into a model. Data augmentation techniques focus on modeling invariances— transformations like translating an image or adding noise that alter the inputs x, but do not change the output y. These techniques have proven effective in areas like computer vision (Krizhevsky et al., 2012) and speech recognition (Jaitly and Hinton, 2013).\nIn semantic parsing, however, we would like to capture more than just invariance properties. Consider an example with the utterance “what states border texas ?”. Given this example, it should be easy to generalize to questions where “texas” is replaced by the name of any other state: simply replace the mention of Texas in the logical form with the name of the new state. Underlying this phenomenon is a strong conditional independence principle: the meaning of the rest of the sentence is independent of the name of the state in question. Standard data augmentation is not sufficient to model such phenomena: instead of holding y fixed, we would like to apply simultaneous transformations to x and y such that the new x still maps to the new y. Data recombination addresses\nthis need."
    }, {
      "heading" : "4.2 General Setting",
      "text" : "In the general setting of data recombination, we start with a training set D of (x, y) pairs, which defines the empirical distribution p̂(x, y). We then fit a generative model p̃(x, y) to p̂ which generalizes beyond the support of p̂, for example by splicing together fragments of different examples. We refer to examples in the support of p̃ as recombinant examples. Finally, to train our actual model pθ(y | x), we maximize the expected value of log pθ(y | x), where (x, y) is drawn from p̃."
    }, {
      "heading" : "4.3 SCFGs for Semantic Parsing",
      "text" : "For semantic parsing, we induce a synchronous context-free grammar (SCFG) to serve as the backbone of our generative model p̃. An SCFG consists of a set of production rules X → 〈α, β〉, whereX is a category (non-terminal), and α and β are sequences of terminal and non-terminal symbols. Any non-terminal symbols in α must be aligned to the same non-terminal symbol in β, and vice versa. Therefore, an SCFG defines a set of joint derivations of aligned pairs of strings. In our case, we use an SCFG to represent joint deriva-\ntions of utterances x and logical forms y (which for us is just a sequence of tokens). After we induce an SCFG G from D, the corresponding generative model p̃(x, y) is the distribution over pairs (x, y) defined by sampling from G, where we choose production rules to apply uniformly at random.\nIt is instructive to compare our SCFG-based data recombination with WASP (Wong and Mooney, 2006; Wong and Mooney, 2007), which uses an SCFG as the actual semantic parsing model. The grammar induced by WASP must have good coverage in order to generalize to new inputs at test time. WASP also requires the implementation of an efficient algorithm for computing the conditional probability p(y | x). In contrast, our SCFG is only used to convey prior knowledge about conditional independence structure, so it only needs to have high precision; our RNN model is responsible for boosting recall over the entire input space. We also only need to forward sample from the SCFG, which is considerably easier to implement than conditional inference.\nBelow, we examine various strategies for inducing a grammar G from a dataset D. We first encode D as an initial grammar with rules ROOT → 〈x, y〉 for each (x, y) ∈ D. Next, we will define each grammar induction strategy as a mapping from an input grammar Gin to a new grammar Gout. This formulation allows us to compose grammar induction strategies (Section 4.3.4)."
    }, {
      "heading" : "4.3.1 Abstracting Entities",
      "text" : "Our first grammar induction strategy, ABSENTITIES, simply abstracts entities with their types. We assume that each entity e (e.g., texas) has a corresponding type e.t (e.g., state), which we infer based on the presence of certain predicates in the logical form (e.g. stateid). For each grammar rule X → 〈α, β〉 in Gin, where α contains a token (e.g., “texas”) that string matches an entity (e.g., texas) in β, we add two rules to Gout: (i) a rule where both occurrences are replaced with the type of the entity (e.g., state), and (ii) a new rule that maps the type to the entity (e.g., STATEID → 〈“texas”,texas〉; we reserve the category name STATE for the next section). Thus, Gout generates recombinant examples that fuse most of one example with an entity found in a second example. A concrete example from the GEO domain is given in Figure 3."
    }, {
      "heading" : "4.3.2 Abstracting Whole Phrases",
      "text" : "Our second grammar induction strategy, ABSWHOLEPHRASES, abstracts both entities and whole phrases with their types. For each grammar rule X → 〈α, β〉 in Gin, we add up to two rules to Gout. First, if α contains tokens that string match to an entity in β, we replace both occurrences with the type of the entity, similarly to rule (i) from ABSENTITIES. Second, if we can infer that the entire expression β evaluates to a set of a particular type (e.g. state) we create a rule that maps the type to 〈α, β〉. In practice, we also use some simple rules to strip question identifiers from α, so that the resulting examples are more natural. Again, refer to Figure 3 for a concrete example.\nThis strategy works because of a more general conditional independence property: the meaning of any semantically coherent phrase is conditionally independent of the rest of the sentence, the cornerstone of compositional semantics. Note that this assumption is not always correct in general: for example, phenomena like anaphora that involve long-range context dependence violate this assumption. However, this property holds in most existing semantic parsing datasets."
    }, {
      "heading" : "4.3.3 Concatenation",
      "text" : "The final grammar induction strategy is a surprisingly simple approach we tried that turns out to work. For any k ≥ 2, we define the CONCAT-k strategy, which creates two types of rules. First, we create a single rule that has ROOT going to a sequence of k SENT’s. Then, for each rootlevel rule ROOT → 〈α, β〉 in Gin, we add the rule SENT → 〈α, β〉 to Gout. See Figure 3 for an example.\nUnlike ABSENTITIES and ABSWHOLEPHRASES, concatenation is very general, and can be applied to any sequence transduction problem. Of course, it also does not introduce additional information about compositionality or independence properties present in semantic parsing. However, it does generate harder examples for the attention-based RNN, since the model must learn to attend to the correct parts of the now-longer input sequence. Related work has shown that training a model on more difficult examples can improve generalization, the most canonical case being dropout (Hinton et al., 2012; Wager et al., 2013)."
    }, {
      "heading" : "4.3.4 Composition",
      "text" : "We note that grammar induction strategies can be composed, yielding more complex grammars. Given any two grammar induction strategies f1 and f2, the composition f1 ◦ f2 is the grammar induction strategy that takes in Gin and returns f1(f2(Gin)). For the strategies we have defined, we can perform this operation symbolically on the grammar rules, without having to sample from the intermediate grammar f2(Gin)."
    }, {
      "heading" : "5 Experiments",
      "text" : "We evaluate our system on three domains: GEO, ATIS, and OVERNIGHT. For ATIS, we report logical form exact match accuracy. For GEO and OVERNIGHT, we determine correctness based on denotation match, as in Liang et al. (2011) and Wang et al. (2015), respectively."
    }, {
      "heading" : "5.1 Choice of Grammar Induction Strategy",
      "text" : "We note that not all grammar induction strategies make sense for all domains. In particular, we only apply ABSWHOLEPHRASES to GEO and OVERNIGHT. We do not apply ABSWHOLEPHRASES to ATIS, as the dataset has little nesting structure."
    }, {
      "heading" : "5.2 Implementation Details",
      "text" : "We tokenize logical forms in a domain-specific manner, based on the syntax of the formal language being used. On GEO and ATIS, we disallow copying of predicate names to ensure a fair\ncomparison to previous work, as string matching between input words and predicate names is not commonly used. We prevent copying by prepending underscores to predicate tokens; see Figure 2 for examples.\nOn ATIS alone, when doing attention-based copying and data recombination, we leverage an external lexicon that maps natural language phrases (e.g., “kennedy airport”) to entities (e.g., jfk:ap). When we copy a word that is part of a phrase in the lexicon, we write the entity associated with that lexicon entry. When performing data recombination, we identify entity alignments based on matching phrases and entities from the lexicon.\nWe run all experiments with 200 hidden units and 100-dimensional word vectors. We initialize all parameters uniformly at random within the interval [−0.1, 0.1]. We maximize the loglikelihood of the correct logical form using stochastic gradient descent. We train the model for a total of 30 epochs with an initial learning rate of 0.1, and halve the learning rate every 5 epochs, starting after epoch 15. We replace word vectors for words that occur only once in the training set with a universal <unk> word vector. Our model is implemented in Theano (Bergstra et al., 2010).\nWhen performing data recombination, we sample a new round of recombinant examples from our grammar at each epoch. We add these examples to the original training dataset, randomly shuffle all examples, and train the model for the epoch. Figure 4 gives pseudocode for this training procedure. One important hyperparameter is how many examples to sample at each epoch: we found that a good rule of thumb is to sample as many recombinant examples as there are examples in the training dataset, so that half of the examples the model sees at each epoch are recombinant.\nAt test time, we use beam search with beam size 5. We automatically balance missing right parentheses by adding them at the end. On GEO and OVERNIGHT, we then pick the highest-scoring logical form that does not yield an executor error when the corresponding denotation is computed. On ATIS, we just pick the top prediction on the beam."
    }, {
      "heading" : "5.3 Impact of the Copying Mechanism",
      "text" : "First, we measure the contribution of the attentionbased copying mechanism to the model’s overall\nperformance. On each task, we train and evaluate two models: one with the copying mechanism, and one without. Training is done without data recombination. The results are shown in Table 1.\nOn GEO and ATIS, the copying mechanism helps significantly: it improves test accuracy by 10.4 percentage points on GEO and 6.4 points on ATIS. However, on OVERNIGHT, adding the copying mechanism actually makes our model perform slightly worse. This result is somewhat expected, as the OVERNIGHT dataset contains a very small number of distinct entities. It is also notable that both systems surpass the previous best system on OVERNIGHT by a wide margin.\nWe choose to use the copying mechanism in all subsequent experiments, as it has a large advantage in realistic settings where there are many distinct entities in the world. The concurrent work of Gu et al. (2016) and Gulcehre et al. (2016), both of whom propose similar copying mechanisms, provides additional evidence for the utility of copying on a wide range of NLP tasks."
    }, {
      "heading" : "5.4 Main Results",
      "text" : "2The method of Liang et al. (2011) is not comparable to\nFor our main results, we train our model with a variety of data recombination strategies on all three datasets. These results are summarized in Tables 2 and 3. We compare our system to the baseline of not using any data recombination, as well as to state-of-the-art systems on all three datasets.\nWe find that data recombination consistently improves accuracy across the three domains we evaluated on, and that the strongest results come from composing multiple strategies. Combining ABSWHOLEPHRASES, ABSENTITIES, and CONCAT-2 yields a 4.3 percentage point improvement over the baseline without data recombination on GEO, and an average of 1.7 percentage points on OVERNIGHT. In fact, on GEO, we achieve test accuracy of 89.3%, which surpasses the previous state-of-the-art, excluding Liang et al. (2011), which used a seed lexicon for predicates. On ATIS, we experiment with concatenating more than 2 examples, to make up for the fact that we cannot apply ABSWHOLEPHRASES, which generates longer examples. We obtain a test accuracy of 83.3 with ABSENTITIES composed with CONCAT-3, which beats the baseline by 7 percentage points and is competitive with the state-of-theart.\nData recombination without copying. For completeness, we also investigated the effects of data recombination on the model without attention-based copying. We found that recombination helped significantly on GEO and ATIS, but hurt the model slightly on OVERNIGHT. On GEO, the best data recombination strategy yielded test accuracy of 82.9%, for a gain of 8.3 percentage points over the baseline with no copying and no recombination; on ATIS, data recombination gives test accuracies as high as 74.6%, a 4.7 point gain over the same baseline. However, no data recombination strategy improved average test accuracy on OVERNIGHT; the best one resulted in a 0.3 percentage point decrease in test accuracy. We hypothesize that data recombination helps less on OVERNIGHT in general because the space of possible logical forms is very limited, making it more like a large multiclass classification task. Therefore, it is less important for the model to learn good compositional representations that generalize to new logical forms at test time.\nours, as they as they used a seed lexicon mapping words to predicates. We explicitly avoid using such prior knowledge in our system."
    }, {
      "heading" : "5.5 Effect of Longer Examples",
      "text" : "Interestingly, strategies like ABSWHOLEPHRASES and CONCAT-2 help the model even though the resulting recombinant examples are generally not in the support of the test distribution. In particular, these recombinant examples are on average longer than those in the actual dataset, which makes them harder for the attention-based model. Indeed, for every domain, our best accuracy numbers involved some form of concatenation, and often involved ABSWHOLEPHRASES\nas well. In comparison, applying ABSENTITIES alone, which generates examples of the same length as those in the original dataset, was generally less effective.\nWe conducted additional experiments on artificial data to investigate the importance of adding longer, harder examples. We experimented with adding new examples via data recombination, as well as adding new independent examples (e.g. to simulate the acquisition of more training data). We constructed a simple world containing a set of entities and a set of binary relations. For any n, we can generate a set of depth-n examples, which involve the composition of n relations applied to a single entity. Example data points are shown in Figure 5. We train our model on various datasets, then test it on a set of 500 randomly chosen depth-2 examples. The model always has access to a small seed training set of 100 depth-2 examples. We then add one of four types of examples to the training set:\n• Same length, independent: New randomly chosen depth-2 examples.3\n• Longer, independent: Randomly chosen depth-4 examples.\n• Same length, recombinant: Depth-2 examples sampled from the grammar induced by applying ABSENTITIES to the seed dataset.\n• Longer, recombinant: Depth-4 examples sampled from the grammar induced by applying ABSWHOLEPHRASES followed by ABSENTITIES to the seed dataset.\nTo maintain consistency between the independent and recombinant experiments, we fix the recombinant examples across all epochs, instead of resampling at every epoch. In Figure 6, we plot accuracy on the test set versus the number of additional examples added of each of these four types. As\n3Technically, these are not completely independent, as we sample these new examples without replacement. The same applies to the longer “independent” examples.\nexpected, independent examples are more helpful than the recombinant ones, but both help the model improve considerably. In addition, we see that even though the test dataset only has short examples, adding longer examples helps the model more than adding shorter ones, in both the independent and recombinant cases. These results underscore the importance training on longer, harder examples."
    }, {
      "heading" : "6 Discussion",
      "text" : "In this paper, we have presented a novel framework we term data recombination, in which we generate new training examples from a highprecision generative model induced from the original training dataset. We have demonstrated its effectiveness in improving the accuracy of a sequence-to-sequence RNN model on three semantic parsing datasets, using a synchronous context-free grammar as our generative model.\nThere has been growing interest in applying neural networks to semantic parsing and related tasks. Dong and Lapata (2016) concurrently developed an attention-based RNN model for semantic parsing, although they did not use data recombination. Grefenstette et al. (2014) proposed a non-recurrent neural model for semantic parsing, though they did not run experiments. Mei et al. (2016) use an RNN model to perform a related task of instruction following.\nOur proposed attention-based copying mechanism bears a strong resemblance to two models that were developed independently by other groups. Gu et al. (2016) apply a very similar copying mechanism to text summarization and singleturn dialogue generation. Gulcehre et al. (2016) propose a model that decides at each step whether to write from a “shortlist” vocabulary or copy from the input, and report improvements on machine translation and text summarization. Another piece of related work is Luong et al. (2015b), who train a neural machine translation system to copy rare words, relying on an external system to generate alignments.\nPrior work has explored using paraphrasing for data augmentation on NLP tasks. Zhang et al. (2015) augment their data by swapping out words for synonyms from WordNet. Wang and Yang (2015) use a similar strategy, but identify similar words and phrases based on cosine distance between vector space embeddings. Unlike our data\nrecombination strategies, these techniques only change inputs x, while keeping the labels y fixed. Additionally, these paraphrasing-based transformations can be described in terms of grammar induction, so they can be incorporated into our framework.\nIn data recombination, data generated by a highprecision generative model is used to train a second, domain-general model. Generative oversampling (Liu et al., 2007) learns a generative model in a multiclass classification setting, then uses it to generate additional examples from rare classes in order to combat label imbalance. Uptraining (Petrov et al., 2010) uses data labeled by an accurate but slow model to train a computationally cheaper second model. Vinyals et al. (2015b) generate a large dataset of constituency parse trees by taking sentences that multiple existing systems parse in the same way, and train a neural model on this dataset.\nSome of our induced grammars generate examples that are not in the test distribution, but nonetheless aid in generalization. Related work has also explored the idea of training on altered or out-of-domain data, often interpreting it as a form of regularization. Dropout training has been shown to be a form of adaptive regularization (Hinton et al., 2012; Wager et al., 2013). Guu et al. (2015) showed that encouraging a knowledge base completion model to handle longer path queries acts as a form of structural regularization.\nLanguage is a blend of crisp regularities and soft relationships. Our work takes RNNs, which excel at modeling soft phenomena, and uses a highly structured tool—synchronous context free grammars—to infuse them with an understanding of crisp structure. We believe this paradigm for simultaneously modeling the soft and hard aspects of language should have broader applicability beyond semantic parsing.\nAcknowledgments This work was supported by the NSF Graduate Research Fellowship under Grant No. DGE-114747, and the DARPA Communicating with Computers (CwC) program under ARO prime contract no. W911NF-15-1-0462.\nReproducibility. All code, data, and experiments for this paper are available on the CodaLab platform at https: //worksheets.codalab.org/worksheets/ 0x50757a37779b485f89012e4ba03b6f4f/."
    } ],
    "references" : [ {
      "title" : "UW SPF: The University of Washington semantic parsing framework",
      "author" : [ "Artzi", "Zettlemoyer2013a] Y. Artzi", "L. Zettlemoyer" ],
      "venue" : "arXiv preprint arXiv:1311.3011",
      "citeRegEx" : "Artzi et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Artzi et al\\.",
      "year" : 2013
    }, {
      "title" : "Weakly supervised learning of semantic parsers for mapping instructions to actions. Transactions of the Association for Computational Linguistics (TACL), 1:49–62",
      "author" : [ "Artzi", "Zettlemoyer2013b] Y. Artzi", "L. Zettlemoyer" ],
      "venue" : null,
      "citeRegEx" : "Artzi et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Artzi et al\\.",
      "year" : 2013
    }, {
      "title" : "Neural machine translation by jointly learning to align and translate",
      "author" : [ "Bahdanau et al.2014] D. Bahdanau", "K. Cho", "Y. Bengio" ],
      "venue" : "arXiv preprint arXiv:1409.0473",
      "citeRegEx" : "Bahdanau et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Bahdanau et al\\.",
      "year" : 2014
    }, {
      "title" : "Semantic parsing on Freebase from question-answer pairs. In Empirical Methods in Natural Language Processing (EMNLP)",
      "author" : [ "Berant et al.2013] J. Berant", "A. Chou", "R. Frostig", "P. Liang" ],
      "venue" : null,
      "citeRegEx" : "Berant et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Berant et al\\.",
      "year" : 2013
    }, {
      "title" : "Theano: a CPU and GPU math expression compiler",
      "author" : [ "Bergstra et al.2010] J. Bergstra", "O. Breuleux", "F. Bastien", "P. Lamblin", "R. Pascanu", "G. Desjardins", "J. Turian", "D. Warde-Farley", "Y. Bengio" ],
      "venue" : "In Python for Scientific Computing",
      "citeRegEx" : "Bergstra et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Bergstra et al\\.",
      "year" : 2010
    }, {
      "title" : "Driving semantic parsing from the world’s response",
      "author" : [ "Clarke et al.2010] J. Clarke", "D. Goldwasser", "M. Chang", "D. Roth" ],
      "venue" : "In Computational Natural Language Learning (CoNLL),",
      "citeRegEx" : "Clarke et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Clarke et al\\.",
      "year" : 2010
    }, {
      "title" : "Language to logical form with neural attention. In Association for Computational Linguistics (ACL)",
      "author" : [ "Dong", "Lapata2016] L. Dong", "M. Lapata" ],
      "venue" : null,
      "citeRegEx" : "Dong et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Dong et al\\.",
      "year" : 2016
    }, {
      "title" : "Transitionbased dependency parsing with stack long shortterm memory",
      "author" : [ "Dyer et al.2015] C. Dyer", "M. Ballesteros", "W. Ling", "A. Matthews", "N.A. Smith" ],
      "venue" : null,
      "citeRegEx" : "Dyer et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Dyer et al\\.",
      "year" : 2015
    }, {
      "title" : "A deep architecture for semantic parsing",
      "author" : [ "P. Blunsom", "N. de Freitas", "K.M. Hermann" ],
      "venue" : "In ACL Workshop on Semantic Parsing,",
      "citeRegEx" : "Grefenstette et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Grefenstette et al\\.",
      "year" : 2014
    }, {
      "title" : "Incorporating copying mechanism in sequence-tosequence learning. In Association for Computational Linguistics (ACL)",
      "author" : [ "Gu et al.2016] J. Gu", "Z. Lu", "H. Li", "V.O. Li" ],
      "venue" : null,
      "citeRegEx" : "Gu et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Gu et al\\.",
      "year" : 2016
    }, {
      "title" : "Pointing the unknown words. In Association for Computational Linguistics (ACL)",
      "author" : [ "Gulcehre et al.2016] C. Gulcehre", "S. Ahn", "R. Nallapati", "B. Zhou", "Y. Bengio" ],
      "venue" : null,
      "citeRegEx" : "Gulcehre et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Gulcehre et al\\.",
      "year" : 2016
    }, {
      "title" : "Traversing knowledge graphs in vector space. In Empirical Methods in Natural Language Processing (EMNLP)",
      "author" : [ "Guu et al.2015] K. Guu", "J. Miller", "P. Liang" ],
      "venue" : null,
      "citeRegEx" : "Guu et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Guu et al\\.",
      "year" : 2015
    }, {
      "title" : "Improving neural networks by preventing co-adaptation of feature detectors. arXiv preprint arXiv:1207.0580",
      "author" : [ "Hinton et al.2012] G.E. Hinton", "N. Srivastava", "A. Krizhevsky", "I. Sutskever", "R.R. Salakhutdinov" ],
      "venue" : null,
      "citeRegEx" : "Hinton et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hinton et al\\.",
      "year" : 2012
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Hochreiter", "Schmidhuber1997] S. Hochreiter", "J. Schmidhuber" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Hochreiter et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Hochreiter et al\\.",
      "year" : 1997
    }, {
      "title" : "Vocal tract length perturbation (vtlp) improves speech recognition",
      "author" : [ "Jaitly", "Hinton2013] N. Jaitly", "G.E. Hinton" ],
      "venue" : "In International Conference on Machine Learning (ICML)",
      "citeRegEx" : "Jaitly et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Jaitly et al\\.",
      "year" : 2013
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "I. Sutskever", "G.E. Hinton" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Krizhevsky et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Krizhevsky et al\\.",
      "year" : 2012
    }, {
      "title" : "Using semantic unification to generate regular expressions from natural language",
      "author" : [ "Kushman", "Barzilay2013] N. Kushman", "R. Barzilay" ],
      "venue" : "In Human Language Technology and North American Association",
      "citeRegEx" : "Kushman et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Kushman et al\\.",
      "year" : 2013
    }, {
      "title" : "Inducing probabilistic CCG grammars from logical form with higher-order unification",
      "author" : [ "L. Zettlemoyer", "S. Goldwater", "M. Steedman" ],
      "venue" : "In Empirical Methods in Natural Language Processing",
      "citeRegEx" : "Kwiatkowski et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kwiatkowski et al\\.",
      "year" : 2010
    }, {
      "title" : "Lexical generalization in CCG grammar induction for semantic parsing",
      "author" : [ "L. Zettlemoyer", "S. Goldwater", "M. Steedman" ],
      "venue" : "In Empirical Methods in Natural Language Processing (EMNLP),",
      "citeRegEx" : "Kwiatkowski et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Kwiatkowski et al\\.",
      "year" : 2011
    }, {
      "title" : "Learning dependency-based compositional semantics",
      "author" : [ "Liang et al.2011] P. Liang", "M.I. Jordan", "D. Klein" ],
      "venue" : "In Association for Computational Linguistics (ACL),",
      "citeRegEx" : "Liang et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Liang et al\\.",
      "year" : 2011
    }, {
      "title" : "Generative oversampling for mining imbalanced datasets",
      "author" : [ "A. Liu", "J. Ghosh", "C. Martin" ],
      "venue" : "In International Conference on Data Mining (DMIN)",
      "citeRegEx" : "Liu et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Liu et al\\.",
      "year" : 2007
    }, {
      "title" : "Effective approaches to attention-based neural machine translation",
      "author" : [ "Luong et al.2015a] M. Luong", "H. Pham", "C.D. Manning" ],
      "venue" : "In Empirical Methods in Natural Language Processing (EMNLP),",
      "citeRegEx" : "Luong et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Luong et al\\.",
      "year" : 2015
    }, {
      "title" : "Addressing the rare word problem in neural machine translation",
      "author" : [ "Luong et al.2015b] M. Luong", "I. Sutskever", "Q.V. Le", "O. Vinyals", "W. Zaremba" ],
      "venue" : "In Association for Computational Linguistics (ACL),",
      "citeRegEx" : "Luong et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Luong et al\\.",
      "year" : 2015
    }, {
      "title" : "Listen, attend, and walk: Neural mapping",
      "author" : [ "Mei et al.2016] H. Mei", "M. Bansal", "M.R. Walter" ],
      "venue" : null,
      "citeRegEx" : "Mei et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Mei et al\\.",
      "year" : 2016
    }, {
      "title" : "Uptraining for accurate deterministic question parsing",
      "author" : [ "S. Petrov", "P. Chang", "M. Ringgaard", "H. Alshawi" ],
      "venue" : "In Empirical Methods in Natural Language Processing (EMNLP)",
      "citeRegEx" : "Petrov et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Petrov et al\\.",
      "year" : 2010
    }, {
      "title" : "Grounded unsupervised semantic parsing. In Association for Computational Linguistics (ACL)",
      "author" : [ "H. Poon" ],
      "venue" : null,
      "citeRegEx" : "Poon.,? \\Q2013\\E",
      "shortCiteRegEx" : "Poon.",
      "year" : 2013
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "O. Vinyals", "Q.V. Le" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Sutskever et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Sutskever et al\\.",
      "year" : 2014
    }, {
      "title" : "2015b. Grammar as a foreign language",
      "author" : [ "Vinyals et al.2015b] O. Vinyals", "L. Kaiser", "T. Koo", "S. Petrov", "I. Sutskever", "G. Hinton" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Vinyals et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Vinyals et al\\.",
      "year" : 2015
    }, {
      "title" : "Dropout training as adaptive regularization",
      "author" : [ "Wager et al.2013] S. Wager", "S.I. Wang", "P. Liang" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS)",
      "citeRegEx" : "Wager et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Wager et al\\.",
      "year" : 2013
    }, {
      "title" : "That’s so annoying!!!: A lexical and frame-semantic embedding based data augmentation approach to automatic categorization of annoying behaviors using #petpeeve tweets",
      "author" : [ "Wang", "Yang2015] W.Y. Wang", "D. Yang" ],
      "venue" : null,
      "citeRegEx" : "Wang et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2015
    }, {
      "title" : "Building a semantic parser overnight. In Association for Computational Linguistics (ACL)",
      "author" : [ "Y. Wang", "J. Berant", "P. Liang" ],
      "venue" : null,
      "citeRegEx" : "Wang et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2015
    }, {
      "title" : "Learning for semantic parsing with statistical machine translation",
      "author" : [ "Wong", "Mooney2006] Y.W. Wong", "R.J. Mooney" ],
      "venue" : "In North American Association for Computational Linguistics (NAACL),",
      "citeRegEx" : "Wong et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Wong et al\\.",
      "year" : 2006
    }, {
      "title" : "Learning synchronous grammars for semantic parsing with lambda calculus",
      "author" : [ "Wong", "Mooney2007] Y.W. Wong", "R.J. Mooney" ],
      "venue" : "In Association for Computational Linguistics (ACL),",
      "citeRegEx" : "Wong et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Wong et al\\.",
      "year" : 2007
    }, {
      "title" : "Learning to parse database queries using inductive logic programming",
      "author" : [ "Zelle", "Mooney1996] M. Zelle", "R.J. Mooney" ],
      "venue" : "In Association for the Advancement of Artificial Intelligence (AAAI),",
      "citeRegEx" : "Zelle et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Zelle et al\\.",
      "year" : 1996
    }, {
      "title" : "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars",
      "author" : [ "Zettlemoyer", "Collins2005] L.S. Zettlemoyer", "M. Collins" ],
      "venue" : "In Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "Zettlemoyer et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Zettlemoyer et al\\.",
      "year" : 2005
    }, {
      "title" : "Online learning of relaxed CCG grammars for parsing to logical form",
      "author" : [ "Zettlemoyer", "Collins2007] L.S. Zettlemoyer", "M. Collins" ],
      "venue" : "In Empirical Methods in Natural Language Processing and Computational Natural Language Learning",
      "citeRegEx" : "Zettlemoyer et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Zettlemoyer et al\\.",
      "year" : 2007
    }, {
      "title" : "Character-level convolutional networks for text classification",
      "author" : [ "X. Zhang", "J. Zhao", "Y. LeCun" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS)",
      "citeRegEx" : "Zhang et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2015
    }, {
      "title" : "Type-driven incremental semantic parsing with polymorphism. In North American Association for Computational Linguistics (NAACL)",
      "author" : [ "Zhao", "Huang2015] K. Zhao", "L. Huang" ],
      "venue" : null,
      "citeRegEx" : "Zhao et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Zhao et al\\.",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 19,
      "context" : "Semantic parsing—the precise translation of natural language utterances into logical forms—has many applications, including question answering (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Liang et al., 2011; Berant et al., 2013), instruction following (Artzi and Zettlemoyer, 2013b), and regular expression generation (Kushman and Barzilay, 2013).",
      "startOffset" : 143,
      "endOffset" : 270
    }, {
      "referenceID" : 3,
      "context" : "Semantic parsing—the precise translation of natural language utterances into logical forms—has many applications, including question answering (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Liang et al., 2011; Berant et al., 2013), instruction following (Artzi and Zettlemoyer, 2013b), and regular expression generation (Kushman and Barzilay, 2013).",
      "startOffset" : 143,
      "endOffset" : 270
    }, {
      "referenceID" : 3,
      "context" : "Modern semantic parsers (Artzi and Zettlemoyer, 2013a; Berant et al., 2013) are complex pieces of software, requiring handcrafted features, lexicons, and grammars.",
      "startOffset" : 24,
      "endOffset" : 75
    }, {
      "referenceID" : 26,
      "context" : "have made swift inroads into many structured prediction tasks in NLP, including machine translation (Sutskever et al., 2014; Bahdanau et al., 2014) and syntactic parsing (Vinyals et al.",
      "startOffset" : 100,
      "endOffset" : 147
    }, {
      "referenceID" : 2,
      "context" : "have made swift inroads into many structured prediction tasks in NLP, including machine translation (Sutskever et al., 2014; Bahdanau et al., 2014) and syntactic parsing (Vinyals et al.",
      "startOffset" : 100,
      "endOffset" : 147
    }, {
      "referenceID" : 7,
      "context" : ", 2014) and syntactic parsing (Vinyals et al., 2015b; Dyer et al., 2015).",
      "startOffset" : 30,
      "endOffset" : 72
    }, {
      "referenceID" : 27,
      "context" : "A linear sequence of tokens might appear to lose the hierarchical structure of a logical form, but there is precedent for this choice: Vinyals et al. (2015b) showed that an RNN can reliably predict tree-structured outputs in a linear fashion.",
      "startOffset" : 135,
      "endOffset" : 158
    }, {
      "referenceID" : 29,
      "context" : "We evaluate on the same train/test splits as Wang et al. (2015).",
      "startOffset" : 45,
      "endOffset" : 64
    }, {
      "referenceID" : 5,
      "context" : "emergence of semantic parsers learned from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013b).",
      "startOffset" : 55,
      "endOffset" : 147
    }, {
      "referenceID" : 19,
      "context" : "emergence of semantic parsers learned from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013b).",
      "startOffset" : 55,
      "endOffset" : 147
    }, {
      "referenceID" : 3,
      "context" : "emergence of semantic parsers learned from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013b).",
      "startOffset" : 55,
      "endOffset" : 147
    }, {
      "referenceID" : 2,
      "context" : "Our sequence-to-sequence RNN model is based on existing attention-based neural machine translation models (Bahdanau et al., 2014; Luong et al., 2015a), but also includes a novel attention-based copying mechanism.",
      "startOffset" : 106,
      "endOffset" : 150
    }, {
      "referenceID" : 2,
      "context" : "Our sequence-to-sequence RNN model is based on existing attention-based neural machine translation models (Bahdanau et al., 2014; Luong et al., 2015a), but also includes a novel attention-based copying mechanism. Similar copying mechanisms have been explored in parallel by Gu et al. (2016) and Gulcehre et al.",
      "startOffset" : 107,
      "endOffset" : 291
    }, {
      "referenceID" : 2,
      "context" : "Our sequence-to-sequence RNN model is based on existing attention-based neural machine translation models (Bahdanau et al., 2014; Luong et al., 2015a), but also includes a novel attention-based copying mechanism. Similar copying mechanisms have been explored in parallel by Gu et al. (2016) and Gulcehre et al. (2016).",
      "startOffset" : 107,
      "endOffset" : 318
    }, {
      "referenceID" : 2,
      "context" : ", bm using a bidirectional RNN (Bahdanau et al., 2014).",
      "startOffset" : 31,
      "endOffset" : 54
    }, {
      "referenceID" : 2,
      "context" : "The decoder is an attention-based model (Bahdanau et al., 2014; Luong et al., 2015a)",
      "startOffset" : 40,
      "endOffset" : 84
    }, {
      "referenceID" : 2,
      "context" : "Attention-based copying can be seen as a combination of a standard softmax output layer of an attention-based model (Bahdanau et al., 2014) and a Pointer Network (Vinyals et al.",
      "startOffset" : 116,
      "endOffset" : 139
    }, {
      "referenceID" : 15,
      "context" : "These techniques have proven effective in areas like computer vision (Krizhevsky et al., 2012) and speech recognition (Jaitly and Hinton, 2013).",
      "startOffset" : 69,
      "endOffset" : 94
    }, {
      "referenceID" : 12,
      "context" : "Related work has shown that training a model on more difficult examples can improve generalization, the most canonical case being dropout (Hinton et al., 2012; Wager et al., 2013).",
      "startOffset" : 138,
      "endOffset" : 179
    }, {
      "referenceID" : 28,
      "context" : "Related work has shown that training a model on more difficult examples can improve generalization, the most canonical case being dropout (Hinton et al., 2012; Wager et al., 2013).",
      "startOffset" : 138,
      "endOffset" : 179
    }, {
      "referenceID" : 19,
      "context" : "For GEO and OVERNIGHT, we determine correctness based on denotation match, as in Liang et al. (2011) and Wang et al.",
      "startOffset" : 81,
      "endOffset" : 101
    }, {
      "referenceID" : 19,
      "context" : "For GEO and OVERNIGHT, we determine correctness based on denotation match, as in Liang et al. (2011) and Wang et al. (2015), respectively.",
      "startOffset" : 81,
      "endOffset" : 124
    }, {
      "referenceID" : 4,
      "context" : "Our model is implemented in Theano (Bergstra et al., 2010).",
      "startOffset" : 35,
      "endOffset" : 58
    }, {
      "referenceID" : 17,
      "context" : "6 Kwiatkowski et al. (2010) 88.",
      "startOffset" : 2,
      "endOffset" : 28
    }, {
      "referenceID" : 17,
      "context" : "6 Kwiatkowski et al. (2010) 88.9 Liang et al. (2011) 91.",
      "startOffset" : 2,
      "endOffset" : 53
    }, {
      "referenceID" : 17,
      "context" : "6 Kwiatkowski et al. (2010) 88.9 Liang et al. (2011) 91.1 Kwiatkowski et al. (2011) 88.",
      "startOffset" : 2,
      "endOffset" : 84
    }, {
      "referenceID" : 17,
      "context" : "6 Kwiatkowski et al. (2010) 88.9 Liang et al. (2011) 91.1 Kwiatkowski et al. (2011) 88.6 82.8 Poon (2013) 83.",
      "startOffset" : 2,
      "endOffset" : 106
    }, {
      "referenceID" : 17,
      "context" : "6 Kwiatkowski et al. (2010) 88.9 Liang et al. (2011) 91.1 Kwiatkowski et al. (2011) 88.6 82.8 Poon (2013) 83.5 Zhao and Huang (2015) 88.",
      "startOffset" : 2,
      "endOffset" : 133
    }, {
      "referenceID" : 9,
      "context" : "The concurrent work of Gu et al. (2016) and Gulcehre et al.",
      "startOffset" : 23,
      "endOffset" : 40
    }, {
      "referenceID" : 9,
      "context" : "The concurrent work of Gu et al. (2016) and Gulcehre et al. (2016), both of whom propose similar copying mechanisms, provides additional evidence for the utility of copying on a wide range of NLP tasks.",
      "startOffset" : 23,
      "endOffset" : 67
    }, {
      "referenceID" : 19,
      "context" : "The method of Liang et al. (2011) is not comparable to For our main results, we train our model with a variety of data recombination strategies on all three datasets.",
      "startOffset" : 14,
      "endOffset" : 34
    }, {
      "referenceID" : 19,
      "context" : "the previous state-of-the-art, excluding Liang et al. (2011), which used a seed lexicon for predicates.",
      "startOffset" : 41,
      "endOffset" : 61
    }, {
      "referenceID" : 29,
      "context" : "Previous Work Wang et al. (2015) 46.",
      "startOffset" : 14,
      "endOffset" : 33
    }, {
      "referenceID" : 8,
      "context" : "Grefenstette et al. (2014) proposed a non-recurrent neural model for semantic parsing, though they did not run experiments.",
      "startOffset" : 0,
      "endOffset" : 27
    }, {
      "referenceID" : 9,
      "context" : "Gu et al. (2016) apply a very similar copying mechanism to text summarization and singleturn dialogue generation.",
      "startOffset" : 0,
      "endOffset" : 17
    }, {
      "referenceID" : 9,
      "context" : "Gu et al. (2016) apply a very similar copying mechanism to text summarization and singleturn dialogue generation. Gulcehre et al. (2016) propose a model that decides at each step whether to write from a “shortlist” vocabulary or copy from the input, and report improvements on machine translation and text summarization.",
      "startOffset" : 0,
      "endOffset" : 137
    }, {
      "referenceID" : 9,
      "context" : "Gu et al. (2016) apply a very similar copying mechanism to text summarization and singleturn dialogue generation. Gulcehre et al. (2016) propose a model that decides at each step whether to write from a “shortlist” vocabulary or copy from the input, and report improvements on machine translation and text summarization. Another piece of related work is Luong et al. (2015b), who train a neural machine translation system to copy rare words, relying on an external system to generate alignments.",
      "startOffset" : 0,
      "endOffset" : 375
    }, {
      "referenceID" : 36,
      "context" : "Zhang et al. (2015) augment their data by swapping out words for synonyms from WordNet.",
      "startOffset" : 0,
      "endOffset" : 20
    }, {
      "referenceID" : 36,
      "context" : "Zhang et al. (2015) augment their data by swapping out words for synonyms from WordNet. Wang and Yang (2015) use a similar strategy, but identify similar words and phrases based on cosine distance between vector space embeddings.",
      "startOffset" : 0,
      "endOffset" : 109
    }, {
      "referenceID" : 20,
      "context" : "Generative oversampling (Liu et al., 2007) learns a generative model in a multiclass classification setting, then uses it to generate additional examples from rare classes in order to combat label imbalance.",
      "startOffset" : 24,
      "endOffset" : 42
    }, {
      "referenceID" : 24,
      "context" : "Uptraining (Petrov et al., 2010) uses data labeled by an ac-",
      "startOffset" : 11,
      "endOffset" : 32
    }, {
      "referenceID" : 27,
      "context" : "Vinyals et al. (2015b) generate a large dataset of constituency parse trees by taking sentences that multiple existing systems parse in the same way, and train a neural model on",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 12,
      "context" : "Dropout training has been shown to be a form of adaptive regularization (Hinton et al., 2012; Wager et al., 2013).",
      "startOffset" : 72,
      "endOffset" : 113
    }, {
      "referenceID" : 28,
      "context" : "Dropout training has been shown to be a form of adaptive regularization (Hinton et al., 2012; Wager et al., 2013).",
      "startOffset" : 72,
      "endOffset" : 113
    }, {
      "referenceID" : 11,
      "context" : "Guu et al. (2015) showed that encouraging a knowledge base completion model to handle longer path queries",
      "startOffset" : 0,
      "endOffset" : 18
    } ],
    "year" : 2016,
    "abstractText" : "Modeling crisp logical regularities is crucial in semantic parsing, making it difficult for neural models with no task-specific prior knowledge to achieve good results. In this paper, we introduce data recombination, a novel framework for injecting such prior knowledge into a model. From the training data, we induce a highprecision synchronous context-free grammar, which captures important conditional independence properties commonly found in semantic parsing. We then train a sequence-to-sequence recurrent network (RNN) model with a novel attention-based copying mechanism on datapoints sampled from this grammar, thereby teaching the model about these structural properties. Data recombination improves the accuracy of our RNN model on three semantic parsing datasets, leading to new state-of-the-art performance on the standard GeoQuery dataset for models with comparable supervision.",
    "creator" : "LaTeX with hyperref package"
  }
}