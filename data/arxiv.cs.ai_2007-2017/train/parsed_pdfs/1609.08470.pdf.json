{
  "name" : "1609.08470.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A computer program for simulating time travel and a possible 'solution' for the grandfather paradox",
    "authors" : [ "Doron Friedman" ],
    "emails" : [ "doronf@idc.ac.il" ],
    "sections" : [ {
      "heading" : null,
      "text" : "While the possibility of time travel in physics is still debated, the explosive growth of virtual-reality simulations opens up new possibilities to rigorously explore such time travel and its consequences in the digital domain. Here we provide a computational model of time travel and a computer program that allows exploring digital time travel. In order to explain our method we formalize a simplified version of the famous grandfather paradox, show how the system can allow the participant to go back in time, try to kill their ancestors before they were born, and experience the consequences. The system has even come up with scenarios that can be considered consistent \"solutions\" of the grandfather paradox. We discuss the conditions for digital time travel, which indicate that it has a large number of practical applications.\n1. Introduction\nIn the principal paradox of time travel a person travels back in time and kills his grandfather before the grandfather meets the time traveler's grandmother. As a consequence, one of the traveler's parents, and therefore the traveler himself, would never have been born. This would imply that the traveller could not have travelled back in time, which means that the grandfather would still be alive, which now makes it possible for the traveler to be born, travel back in time and kill his grandfather, hence a paradox.\nIn this paper we describe a computer program that allows us to interactively explore the consequences of \"changing the past\" in a narrative. Our system uses well-known techniques from automated reasoning to compute the specific consequences of modifying history. The contribution of this paper is in the application of automated reasoning to the experience of time travel and in the implementation of this method in a computer\nprogram. We provide the details showing how our program was used to interactively explore the consequences of time travel while maintaining consistency in the context of a simplified version of the grandfather paradox. Furthermore, we show how the program was used to proactively resolve the paradox by suggesting transformations of the story line, resulting in some narratives that may be considered valid solutions to the famous paradox. We explain the difference between our time travel approach and other types of digital simulations. Finally, we explicate the conditions required for digital time travel, which indicate that the method can be applied in many useful domains.\nTime travel is discussed in physics, philosophy, and popular culture. In this paper we deliberately avoid the discussion of time travel in physics, and try to capture the notions of time, causality, and time travel as they are perceived by laymen, assisted by insights provided by analytic philosophers. An early discussion of time travel in philosophy in contemporary times has been provided by Lewis (Lewis 1976). His suggestion for resolving the paradox rests on the hypothesis that if time travel is possible then some mundane event will always happen to prevent paradoxes from taking place. Horwich (Horwich 1975) criticized this view by pointing out that if travel to the local past is allowed then there would be countless attempts to initiate self-defeating causal chains, and it would be highly improbable that all of them would be avoided by mundane events such as slipping over a banana peel. Further investigations of time travel in philosophy lead to discussions of causality, identity, and other metaphysical issues (Dowe 2000, Grey 1999, Smith 1997). Our goal in this computer program is to borrow from these discussion and provide a virtual time travel experience that would be consistent with some popular notions of time travel. Nevertheless, we hope that future work based on our formalization of time travel in a computer program may contribute to the philosophical discussion.\nUnlike the physical world, the digital sphere allows you to \"go back in time\", make a change, and observe the consequences. This can be as simple as the \"undo\" function in a word-processing program, or take place in the context of a rich experience such as in a virtual-reality simulation. For example, consider a video game in which you can be upset at the way things turned out at time t, restart the game and continue playing from a\nprevious time t', t' < t. Typically, in such cases whatever happened between t' and t is lost forever, and the simulation restarts. Our approach is different; it allows the participant to re-experience the history that took place between t' and t. The history will be repeated, except for local changes caused by the participant's actions in the \"second time around\". The difference between our approach and typical simulations will be refined in Section 4, after providing the details regarding our method for virtual time travel.\nHere we have focused on time traveling to the past. Time travel into the future is possible in physics (just hop on a spaceship that flies at almost the speed of light), but digital time travel to the future is still interesting to explore and may be useful in some scenarios. For example, meeting your older self in virtual reality (VR) was found to increase subjects' saving behavior (Hershfield et al 2011).\n2. Method\nOur implementation is based on two levels of abstraction: logic and history. The first level takes care of the automated reasoning mechanism, intended to maintain the logical consistency of the narrative. The second level of abstraction in necessary for the application level to present a time travel experience to the user. Automated processes convert application level assumptions and events into logical facts and constraints and vice versa."
    }, {
      "heading" : "2.1 Logic",
      "text" : "Recording and replaying data is typically straightforward in the digital sphere. The main challenge in providing a digital time-travel experience is in automatically tracking causality chains. Fortunately, there are abundant formalizations and techniques in computational logic and artificial intelligence that can be utilized for tracking causality. We opted using Boolean constraint propagation; this is a straightforward mechanism that we have used in the past for automated reasoning in the context of VR applications.\nThe entities in this layer are terms, facts, and constraints. The terms in our grandfather paradox domain are mainly people and actions (supplementary text S.1). Facts are functions or actions applied to other terms. Exactly one of the terms needs to denote the\ncurrent time to which the fact applies. At any given moment facts are assigned one of three truth values: True, False, or Unknown. The facts are treated as propositional; each fact is an atomic literal.\nConstraints are logical operators applied to one or more facts; the constraints required for\nour domain are the Boolean operators: , , , and . We refer to these as constraints because the automated deduction process is based on constraint propagation.\nThe Boolean constraint propagation network is integrated with a truth maintenance system (TMS) (Doyle 1979, McAllester 1990) which records justifications for all derived values. The unit clauses in the reasoning database are treated as premises, which can be asserted or retracted by changing or removing the value of the corresponding node. The non-unit clauses (corresponding to constraint boxes in the network) cannot be changed. Finally, our reasoning engine also includes pattern-directed invocation (Rich & Feldman 1992): a procedure is automatically executed whenever a term matching a given pattern is\ncreated. In our case, pattern-directed invocation is used to implement quantifiers ( and\n)."
    }, {
      "heading" : "2.2 History",
      "text" : "A history is a sequence of state-action pairs denoted by: h = ((s0,a0),(s1,a1),…,(sn,an)). The indexes 0,…,n correspond to the terms 0,…,n in the logical level of abstraction, which of course denote specific times.\nA state is, in general, a collection of value assignments to a predefined set of variables s = {v1,v2,..,vm}. In our domain the only variables are Boolean and reflect the existence of the actors in the scenario in the particular time. Thus, for each person p in the application, there is one state variable vp, which can be True, False, or Unknown, and indicates whether the person is alive or not at a given state.\nFor each action in the history level there is a corresponding fact in the logical level. The variable vp in state st corresponds to the fact exists(p,t) in the logical level. Facts are generated dynamically as the narrative unfolds, i.e., whenever a new action is introduced to the history.\nA history h can be changed by adding or removing actions; this is written in the form: h'\n=  (h, Ah, Ah'), where Ah is the set of actions to remove from h, Ah' is the set of actions to add to h', and  is a transformation that changes h into h'. The series of histories is generated through interaction with the participant over actual time, which is orthogonal to the virtual time of each history (Fig. 1). While we allow time travel along the virtual time dimension, actual time only moves in one orthogonal direction (at least until the physicists might come up with a physical time machine).\nGiven two histories h1 and h2, we can say that h1 h2 if and only if the sequence of actions in h1 is a subset of the sequence of actions in h2 (when null actions are ignored). Typically, the series of histories will evolve by adding actions (since the simulation is interactive, and the participants take actions). Thus, as we move along the actual time histories become more specific, and each new history contains the previous history. If a\ntransformation  s.t. hk+1 = (hk, A1, A2) does not satisfy hk  hk+1 then it is said to be a strong transformation. A strong transformation is one that transforms history by changing one of the things that already happened, rather than by just adding new actions. Strong transformations can be understood in the context of a multiple-world interpretation (Deutsch & Lockwood 1994). Before strong transformations are introduced, we can\nassume that there is one series of events, and information that is missing in the first histories is revealed over (actual) time. As soon as we have an action removed from a history, we can assume that this action took place in one universe and did not take place in another parallel universe.\nTypically, actions are accumulated as the narrative unfolds, but actions can also be replaced or removed. Whenever a transformation is applied the resulting history needs to be consistent, i.e., the fact that we add an action at poses additional logical constraints, and we require that both previous constraints and the new constraints will hold after the transformation. We allow a transformation to add a set of actions simultaneously, since it is possible that adding a single action would cause a contradiction, whereas adding two actions or more would allow for a consistent history.\n3. Results: The main example\nWe formalize a simple version of the famous grandfather paradox (Horwich 1975, Lewis 1976). The example is kept deliberately as simple as possible for clarity. The example is constructed and explained in way that should facilitate communicating our ideas to a nontechnical audience, and some of the technical information is left to the supplementary online material. We ignore issues of gender and sexual reproduction. We maintain the\nessence of the paradox: a son S goes back in time to kill his father F (rather than his\ngrandparent) before F gives birth to S. This \"toy\" example does not require a history of over ten actions to illustrate the paradox and its \"solutions\". When formalized, the scenario includes a few hundred facts and constraints; the scenario of the \"solution\" to the paradox that we describe below (Fig. 6) includes 229 facts and 344 constraints. This \"toy\" example serves to explain our method and testify to its validity. Future work (in progress) will show how our method scales to a richer VR scenario."
    }, {
      "heading" : "3.1 Formalizing the paradox",
      "text" : ""
    }, {
      "heading" : "3.1.1 Initialization and generic setup",
      "text" : "Our example has only three possible actions: begetting, killing, and traveling in time. The precondition for the action A beget B is that A is alive and the post-condition is that B\nis alive. The preconditions for A kill B is that both A and B are alive, and the post-\ncondition is that B is not alive. Time travel is modeled as two interlinked actions, depart and arrive. A person has to exist in order to depart (precondition) and after he arrives (post-condition).\nA notorious challenge when modeling actions over time is the frame problem (McCarthy & Hayes 1968). When modeling a dynamic domain it is natural to specify the changes that take place whenever an action is taken. However, the system also needs to be able to deduce that all the rest has not changed. Since our domain is very small we have taken the naïve approach: we explicitly specify for each action whether it changes the state variables in the world. In this case the state variables are only required to track whether a specific person exists or not, so this solution is reasonable. Extension of the work presented here needs will reveal whether this simple method is scalable or whether any of the many formalisms suggested for overcoming the frame problem (e.g., (Hanks & McDermott 1986, Reiter 1991, Scherl & Levesque 2003, Schubert 1990, Shanahan 1997, Shoham 1987)) may be more appropriate.\nWe introduce two constraints: remains and appears. For each person we define that he always remains at time t+1 if he existed in time t, and that he never appears at time t+1 if he did not exist at time t. We call these the continuity-of-existence and the continuity-ofnon-existence rules. They are implemented automatically using pattern-directed invocation. We introduce these constraints whenever a new person is entered into the simulation. Thus, at this stage there are no actions that involve this person. Whenever a new action involving that person will be introduced the system will check whether the default assumptions about remaining and appearing need to be revised. Thus, it is a type of default reasoning that is practical and simple (see Section S.2 of the supplementary online material for details).\nThere are two ways to explain our approach. So far we have adopted the formal way, which is more convenient from an algorithmic point of view would adopt a metatemporal viewpoint (\"the view from nowhen\" (Price 1996)). In this view we are outside the timeline and at any moment can observe a complete history from beginning to end, or even multiple histories, in the case of a multiple world interpretation. However, note that\nin order to provide a time travel experience the participant needs to be embedded inside the timeline, and thus be provided with only a limited view of the present. The implementation in our program is straightforward: the participant is at any moment (of real time) in a specific state (of virtual time). Only the current values of the state variables are passed into the rendering engine that describes the environment. In our program described in this paper the user sees a textual description of the world. In general, the state of the world can be rendered using a more immersive virtual reality.\nAs the real time moves along, so does the virtual time progresses. The participant steps from one state to the consequent state, in the order of the virtual time. The exception is time travel; in this case of course the order of states visited by the participant is violated, and she is transferred to an earlier or later state according to the setup of the `time machine'. The implementation is the same; the `current time' can skip to a previous state or to a state in the future, and that state information is sent to the rendering engine.\nOur example includes two people: a time traveler S and his parent F. Already, we have a chicken and egg problem; we would like to formalize the fact that people are born to their parents, but this raises a question: where did the first person come from? Since modeling\nevolution is out of the scope of this paper, we introduce a person called F to exist in the world from the beginning, by adding a corresponding fact at the logic layer. Based on the\ncontinuity-of-existence rule mentioned above, the system deduces that F exists throughout the whole history (Section S.2).\nIn our example the time traveler, S, is a user of the computer program, and the narrative\nwill unfold from S's the point of view. In order to begin the scenario the system\nintroduces the action whereby F gives birth to S. The system has some knowledge about the nature of giving birth – it requires that a person would exist to give birth and it also requires that a person would not exist before it is born (Section S.3).\nOur program gives the user free choice to take different actions, but here we are interested with the exploration of the paradox. We will assume that the user plays along in order to explore the paradox. Thus, after being born, S goes back in time to some other point in time before he was born. At this point our system reports a logical contradiction.\nWhen F begets S this introduces the precondition that S does not exist before the birth, whereas now he does exist, since he arrived via time travel. The contradiction thus involves a person already existing at the time they are born; this is impossible in our world but is of course made possible by time travel (Section S.4).\nAt this point we introduce three \"metaphysical\" models: T0 – it is not allowed for a person to exist at the time they are born, T1 – the old copy merges into the newly born copy so there is always a single copy of each person at most, and T2 – every time a person goes back in time a new copy (clone) is generated, and multiple clones may coexist in time; this version is popular in fiction. Even T0 does not take out all the fun of time travel, since time travel is possible both into the future and into the remote past (Fig. 2). T1 can be useful for some applications but it raises problems, e.g.: if a grown up person would travel back in time to the time they are born, T1 would imply that a grown person has merged into a newly-born baby, which probably does not reflect our intention.\nFor the rest of the scenario we adopt model T2, which means that following time travel S turns into a clone S1, and they both co-exist (Section S.4). Thus, we resolve the contradiction by technically relaxing the constraint on identity; a time traveler and his clone are two separate entities. Thus, when S is born his clone S1 exists and witnesses the\nbirth, but S is technically different than S1, so the contradiction is resolved. Note that this is just a technical solution; S and S1 are one in terms of a continuous phenomenal experience, and it is still the case that the son killed his parent. A person and their clone have the same personal identity in the same way that a child and the same person who is a grownup have the same personal identity (see (Lewis 1976) for a discussion on identity and time travel) (Section S.4).\nWe are now ready for the paradoxical murder to take place. The user (who is now the cloned son S1) kills his father F. On the history timeline this happens before the father begets the user S (Section S.5). This is the parent paradox, our version of the principle paradox of time travel (Fig. 3)."
    }, {
      "heading" : "3.2. Exploring the paradox",
      "text" : "The user (clone S1) kills his parent F; this introduces the parent paradox and, indeed, our reasoning engine reports a contradiction: F is supposed to be dead because he was killed,\nbut he is also supposed to be alive to beget S (Section S.8). First, our system allows the user to explore the implications of the paradox and to try to resolve it, by retracting the offending premises. The system reports the facts that are involved in the contradiction, and the user can decide that the actions that assigned these facts their truth values would\nnot have happened. For example, the user can retract the murder, or alternatively retract\nthe beget action, and F is no longer S's father (Section S.9).\nRather than allowing the user to resolve paradoxes \"manually\", the system can proactively suggest transformations that resolve contradictions by adding new actions to the history automatically; some philosophers even suggest that our world may behave in such a way (recall the banana peels?;4,7). There are various approaches as to how the system can proactively try to resolve paradoxes. From a computational point of view this can be posed as a logical deduction problem, and the system can come up with all the solutions, if any, that are compatible with the logical constraints. However, the search for a solution is in principle computationally expensive (exponential). Moreover, if there is one possible solution for resolving the paradox then there would typically be many solutions. Thus, our goal is to quickly find the \"best\" solutions to the paradox.\nDefining what the best solution is an interesting question. We may pose some constraints on the solutions, which would disqualify some of the logically acceptable solutions. For example, we would probably disqualify solutions that assume that the user has to do something very specific, thus overriding the user's free choice. In addition, we may want to sort the solutions in terms of how plausible they seem. For example, we can require the system to introduce a change such that the new history is as close as possible to the old one; this is the kind of \"even with time travel you cannot escape your fate\" narrative often presented in fiction, such as the feature film The Butterfly Effect1. Section S.10 provides a technical formalization of this intuition.\nThese methods for resolving paradoxes are generic. In the case of the parent paradox the system adopts a domain-specific strategy. Since our domain is simple we have augmented our system with some meta-knowledge. In our model world, there are two typical types of contradictions: either a person is supposed to exist at some point and he does not, or a person is supposed not to exist at some point and he does. In the first case, the system tries to introduce actions that cause the person to exist at the required point in time: either by having the person born or by making him arrive by time travel. In the second case the\n1 http://www.imdb.com/title/tt0289879/\nsystem tries to introduce actions that would \"get rid\" of the person at the required time, either by having him killed or having him leave by time travel. Such automatic attempts to resolve the contradiction can result in various solutions, and some of these solutions are discussed in more detail in the supplementary online material (Section S.11).\nHere we provide two solutions of interest. Applying the deduction mechanism without constraints yields the first solution (Section S.11): the son goes back in time, kills his father, and then gives birth to his father, which would then give birth to him (Fig. 4). This solution results in an entertaining narrative, and in some sense it serves as a `solution' to the paradox, but it has a drawback. The system violates the time traveler's `free will' in\nthe second time around, and forces the user (S1) to beget F.\nTherefore, we prefer another solution, which can be automatically deduced by the system and does not assume anything of the user. Figure 5 describes what we regard to be a simple yet novel solution to the parent paradox (which is also, of course, a solution to the grandfather paradox): the son goes back in time and kills his father. From the user's (son's) perspective this seems like a paradox. Only if the user waits long enough in the simulation he may discover how the paradox was resolved. Without the son's knowledge it turns out that the father actually traveled to the future to give birth to him and came back just before being killed. How were we able to avoid the paradox? S killed F before\nF gave birth to S in virtual time, but the murder happened after the birth with respect to S's personal time.\n4. Discussion\nIn this paper we attempted to capture the common-sense interpretation of time and causality, which has been claimed to be not only wrong but also logically inconsistent. Since we allow changing history, our interpretation is similar to Deutsch's interpretation of experiencing time travel in parallel universes through virtual reality (Deutsch 1997), but there are subtle differences; for example, in the first time around our time traveler does not need to meet his future clone. Most important, using our method, every assumption that is explicitly introduced into the system can be altered and the consequences can be further explored. Thus, our approach allows exploration of the consequences of various metaphysical assumptions, including ones that we believe to be true about the physical world.\nGiven that we can (1) record events, (2) define the causality relationships among the events, and (3) replay events, we can implement various forms of time travel. These three conditions are not met in the physical world (mostly, of course, the third one), but they can often be met in the digital sphere (here the main challenge is on the second condition, modeling and capturing causality). Thus, there are a large number of digital applications for which we can introduce time travel, e.g., for entertainment, training, and psychological interventions.\nNow we can refine the differences between our approach and a \"traditional\" simulation. Obviously, in simulations in general you do not meet your former clones and do not interact with other time travelers. However, there is also an important logical difference. If a simulation is completely deterministic then the narrative should unfold in the same way as it does using our approach. However, many domains require non determinism for useful simulations. Even if the world is completely deterministic, we do not have a complete deterministic model of how people make decisions, individually or collectively. This is especially true when modeling people and historical events, but is also true in many other domains. Thus, our simulations would necessarily include idiosyncratic\nevents, which would not repeat exactly as is in a typical simulation, and this is where our approach is required.\nThe main limitation of our approach is in formalizing causality in large-scale domains of knowledge; this is a notoriously difficult problem in artificial intelligence, and one of the main reasons that \"classic\" approaches have come out of favor. We expect our method, as described here, to scale to complete applications in some small well-defined domains, but large-scale implementations may require substantial changes.\nFuture work should correspond with the vast literature in artificial intelligence, logic, and philosophy regarding time, action, and causality. In this paper we have used relatively basic methods but future work may be bi-directional; first, theoretic insights from those fields may assist in refining our approach, scaling it, and reinforcing its foundations. Second, we hope that our practical approach will contribute to the theoretic discussions in those fields.\nOur future work focuses on the exploration of our approach within an immersive virtual reality system. Such a system would require refinements and extensions to our method, and will serve to reaffirm its validity. Moreover, with the aid of an immersive system we hope to explore the psychological experience of virtual time travel; such exploration may be useful not only as a form of art and entertainment, but may serve as a useful tool for education, training, and psychological science and rehabilitation."
    }, {
      "heading" : "Acknowledgments",
      "text" : "I wish to thank Rafael Malach, Mel Slater, and Thomas Metzinger for their feedback on this manuscript."
    }, {
      "heading" : "Online Supplementary Material",
      "text" : "S.1: Terms in the paradox domain\nFor the paradox example our domain includes propositions made of the following terms:\n1. P: people, specifically p (parent) and s (subject).\n2. A: actions, including: beget, kill, depart, and arrive. Additionally, we include a no operation action (nop).\n3. T: time instances – positive integers denoting a specific time.\n4. F: functions, including: exists, remains, and appears.\nS.2: Initialization and the frame problem\nA specification of a history includes the truth values of the state variables at the beginning of each state. The history is initialized to be empty, and the main actors, P and S, do not exist – this is marked as ? (unknown) at all times.\nWhenever an action is introduced in the history level a corresponding fact is automatically introduced into the logic level. At the initialization stage the application thus introduces the following facts into the logic level:\nnop(0)\nnop(1)\nnop(2)\nnop(3)\nIn order to introduce the father (p) we add an axiom to the logic level:\nexist(p,0)\nIn our example, adding exists(p,0) results in the following facts, all initialized to Unknown:\nexists(p,1)\nexists(p,2)\nexists(p,3)\nremains(p,0)\nremains(p,1)\nremains(p,2)\nremains(p,3)\nappears(p,0)\nappears(p,1)\nappears(p,2)\nappears(p,3)\nThe same rule now installs a set of constraints that require that all actions in the history do not affect the state of that person; this is always true since this only happens at the first time the person is introduced. In this case the rule installs the following constraints:\nnop(0)  remains(p,0)\nnop(1)  remains(p,1)\nnop(2)  remains(p,2)\nnop(3)  remains(p,3)\nnop(0)  appears(p,0)\nnop(1)  appears(p,1)\nnop(2)  appears(p,2)\nnop(3)  appears(p,3)\nEvery time a new constraint is introduced it immediately applied. In our case this sets the following facts to be True:\nremains(p,0)\nremains(p,1)\nremains(p,2)\nremains(p,3)\nappears(p,0)\nappears(p,1)\nappears(p,2)\nappears(p,3)\nIn addition, the rule installs the following constraints; these maintain the continuity and discontinuity of people's existence, in both temporal directions.\nexists(p,0) ^ remains(p,0)  exists(p,1)\nexists(p,1) ^ remains(p,1)  exists(p,2)\nexists(p,2) ^ remains(p,2)  exists(p,3)\nexists(p,3) ^ appears(p,2)  exists(p,2)\nexists(p,2) ^ appears(p,1)  exists(p,1)\nexists(p,1) ^ appears(p,1)  exists(p,0)\nexists(p,0) ^ appears(p,0)  exists(p,1)\nexists(p,1) ^ appears(p,1)  exists(p,2)\nexists(p,2) ^ appears(p,2)  exists(p,3)\nexists(p,3) ^ remains(p,2)  exists(p,2)\nexists(p,2) ^ remains(p,1)  exists(p,1)\nexists(p,1) ^ remains(p,0)  exists(p,0)\nThese constraints are evaluated and result in adding the following facts to the system:\nexists(p,1)\nexists(p,2)\nexists(p,3)\nThese facts and constraints together provide the solution to the frame problem, in our limited domain. We can prove, for example, that a person exists until he is killed or he departs via time travel; this is guaranteed by the remains facts.\nFollowing these steps, the history is updated as follows:"
    }, {
      "heading" : "S.3",
      "text" : "The first step in the narrative is the birth of the son s. We will introduce the begetting of the son s by the parent p as the third action, which is the action that is applied after the state s2. This is where non-monotonic reasoning is applied; the previous action is discarded by resetting the fact nop(2) to False and a new fact is introduced to be True: beget(p,s,2).\nFor each type of action there are specific constraints that need to be installed; this is a generic mechanism that can be implemented with pattern-directed invocation. These constraints reflect the semantic of the action. In our case the constraints are:\nbeget(p,s,2)  remains(p,2)\nbeget(p,s,2)  appears(p,2)\nbeget(p,s,2)  appears(s,2)\nbeget(p,s,2)  exists(p,2)\nbeget(p,s,2)  exists(s,2)\nappears(s,2)  exists(p,3)\nThe history is updated as follows:\nTime P S Action\n0 + - Nop\n1 + - Nop\n2 + - beget(p,s)\n3 + + Nop\nIn our interactive application this is actually the beginning. The user is s. The user would typically not see the \"god's view\" of the whole history, but only the current time. So the time is 3, and the user is provided a description of the state of the world. In our application the description only includes a textual description of the current time, and of the fact that he and his parent, p, exist. In general we could envision a virtual reality environment that renders this state as a complete audio-visual experience.\nNext, we introduce the time travel action from time 3 to time 0. This is done by adding two actions, resulting in two facts: depart(s,0) and arrive(s,3) (the second parameter in both actions denotes the destination and source of the time travel, correspondingly). The facts are set to be True. The introduction of these actions also results in the following constraints:\ndepart(s,0)  remains(s,3)\ndepart(s,0)  appears(s,3)\ndepart(s,0)  exists(s,3)\narrive(s,3)  remains(s,0)\narrive(s,3)  appears(s,0)\narrive(s,3)  exists(s,0)\nThe history is:\nTime P S Action\n0 + - arrive(s,3)\n1 + + Nop\n2 + + beget(p,s)\n3 + + depart(s,0)"
    }, {
      "heading" : "S.4: The time-travel contradiction",
      "text" : "After adding the time travel, the system reports a logical contradiction: s has to exist at time 1 since he arrived there by time travel, but he also should not exist at that time because he was born later, between times 2 and 3!\nAs explained in the main text, there are three time travel models: T0, T1, and T2. In addition, the program can be run in three modes:\nR1: The system prevents the user from doing anything that results in a contradiction\nR2: The system allows the user to interactively try to resolve contradictions\nR3: The system automatically tries to resolve contradictions.\nIn all modes the system uses the deduction chain that led to the contradiction.\nexists(s,1)\narrive(s,0)  exists(s,1)\narrive(s,0) is True: premise\n exists(s,1)\n exists(s,2)  remains(s,1)  exists(s,1) TBD: make sure we have it above\nbeget(p,s,2)   exists(s,2)\nbeget(p,s,2) is True: premise\nnop(1)  remains(s,1) TBD: make sure this is consistent\nnop(1) is True: premise\nSpecifically, the logic layer reports the premises. Usually these would be actions; in this case there are indeed three facts that are premises and correspond to the three actions in times 0,1, and 2.\nIn model T0 this is indeed a contradiction. If the program is running in mode R1 the user will not be allowed to go back in time to the past. This is very limiting. Thus, if in option R1 the contradiction is delayed until the last moment. In our case the contradiction involves 3 actions, at times 0,1, and 2. The program can keep this contradiction in a buffer and wait until time 2, to see if the contradiction is resolved by then. For example, the user may choose to travel in time again, and would thus not exist at the time he is born.\nTBD: prove that dealing with delayed contradictions works.\nIn mode R1 the user may be given a choice to manually overcome the contradiction. This is typically used for debugging the application, rather than in the application itself. The user is given the set of premises that serve as the roots in the deduction tree that leads to the contradiction, and the user is required to retract one of the premises.\nThe premises in this case are:\narrive(s,0) #TBD check syntax\nnop(1)\nbeget(p,s,2)\nIf the arrive is retracted a mechanism makes sure the departure is also retracted. This can be done by logic but we prefer to do it hardcoded. TBD. This is equivalent to avoiding the time travel.\nIn general when an action is cancelled it is replaced by a nop. Since the user asks to replace a nop, he is asked for a new action. Here the user can add an action that would cause the user not to exist after it, i.e. killing the user or time traveling.\nFinally, the last option is remove the begetting of the user; typically the application would not allow this to happen.\nIn mode R2 the system automatically tried to resolve the contradiction. There are several ways of doing this, but in the domain of the parent paradox the most useful is a heuristic rule. This would be useful later for resolving the main paradox, so we provide here the details.\nNote that the typical contradictions in the parent domain take place when a person is supposed to exist for one reason and is supposed not to exist for another reason. The heuristic for resolving such constraints is as follows.\nAe  set of actions that require p to exist\nAn  set of actions that require p not to exist\nT(A)  set of times of the actions in A\nten  min(T(Ae))\ntex  max(T(Ae))\ntan  min(T(An))\ntax  max(T(An))\nif tex < tan then\nfind t, tex < t < tan s.t. nop(t) is True\nreplace the nop action by an action that eliminates p\nelse if ten > tax then\nfind t, tax < t < ten s.t. nop(t) is True\nreplace the nop action by an action that introduces p\nendif\nNote that the algorithm does not always apply but practically it will most of the times, and this is also the case in our examples. If the domain-specific heuristics fail we resort to general techniques.\nNote that if there are no nops in the middle we can introduce a new state followed by a nop. We have assumed that the resolution of time is infinite. The details are TBD.\nIn our case the algorithm needs to replace nop(1) with an action that eliminates s. This could be a time travel or killing s. The first kind of makes sense – your time machine ejects you to another unexpected time to avoid contradictions. For example:\nTime P S Action\n0 + - arrive(s,3)\n1 + + depart(s,4)\n2 + - beget(p,s)\n3 + + depart(s,0)\n4 + - arrive(s,1)\nThe second type of solution is more dramatic:\nTime P S Action\n0 + - arrive(s,3)\n1 + + Kill(p,s)\n2 + - beget(p,s)\n3 + + depart(s,0)\nIn this narrative s goes back and is killed by his parent, just before the parent gives birth to s. Game over.\nIn general there are infinitely many ways for the system to automatically resolve the contradiction. The general criteria is to find all solutions that do not require extending the time line. There are at most a finite number of such solutions. If there is no such solution the system gradually extends the time line until a solution is found. We also weight the changes. For example, adding a time travel is prepared over killing the user; not for ethical reasons, but because we don’t want to terminate the application.\nTBD: this algorithm above is infinite. Can we prove a reasonable bound? Then we can sort all legal solutions. In the example above if we prefer shorter solutions then the user would be killed.\nIn model T1 we allow only one copy of each person to exist. We remove the preconditions that a person does not exist before he is born or arrives. [TBD – do I have it for arrives?]. TBD do we need the appears facts at all?\nThe challenge is that there is a very twisted personal time – is it consistent at all? TBD\nWe adopt model T2, which means that following time travel s turns into a clone s1, and they both co-exist.\nTime P S S1 Action\n0 + - - arrive(s1,3)\n1 + - + Nop\n2 + - + beget(p,s)\n3 + + + depart(s,0)\nA clone is also generated automatically in the case of time travel to the future.\nIt is easy to see that this avoids the contradiction: exists(s,1) is now False. The challenge is to show that this technical solution involving clones retains our intuitions about personal identities. What are these intuitions? Before time travel, it would be:\n1. p is born once, say at t1\n2. p dies once, say at t2\n3. p is alive for each t, t1  t  t2\n4. p is not alive for each t, t < t1\n5. p is not alive for each t, t > t2\nNote that this is the continuity of existence assumption for each object, not only for people.\nIf we introduce time travel, axioms 3-5 no longer hold. We replace this with the following set of requirements:\n1. There is a finite set of intervals I1=[t11,t12], …, In=[tn1,tn2] in which p is alive.\n2. there is exactly one k s.t. p is born in tk1.\n3. there is exactly one j s.t. p dies in tj2.\n4. For every l, l~=k, 1 <= l <= n, for every tl1 there is an action arrive(p,tl1,t') at this time. The arrival is associated with a departure time t', s.t. there is an index i s.t. ti2 = t', and i~=j.\n5. For every l, l~=j, 1 <= l <= n, for every tl2 there is an action depart(p,tl2,t') at this time. The departure is associated with an arrival time t', s.t. there is an index i s.t. ti1 = t', and i~=k.\nTBD: prove that these conditions cover overlap.\nTBD: so what do we do with these definitions? Need to prove that they hold. Using the continuity of existence and in-existence rules. But still need to make sure no one lives twice. So add axioms. And move the standard people, before time travel, to an earlier section."
    }, {
      "heading" : "S.5: The parent paradox",
      "text" : "Killing actions result in the following constraints and propositions:\nkill(a,b,t)  remains (a,t)\nkill(a,b,t)  appears (a,t)\nkill(a,b,t)  remains (b,t)\nkill(a,b,t)  appears (b,t)\nkill(a,b,t)  exists (a,t)\nkill(a,b,t)  exists (b,t+1)\nWe add kill (s1,p,1) and set it to True. The result is a contradiction.\nTime P S S1 Action\n0 + - - arrive(s1,3)\n1 + - + kill(s1,p)\n2 X - + beget(p,s)\n3 + + + depart(s,0)\nNote: X is where the contradiction is. The parent has to exist to beget s, but he was just killed by s1.\nS7\nThe condition for a preservation of identity with the possibility of time travel is that there would be a continuous line. @@TBD formalize. Moreover, there should be a continuity\nof the properties of the object, or the attributes of the person. @@TBD formalize. In our case there are no attributes, the only attribute is whether a person is dead or alive. If we had attributes, clearly the identity can be preserved under time travel and in this way the clones all have a single identity.\nS.7. Resolving the paradox: The naïve version\nIn knowledge based systems we can often let the user decide what option to retract (see above) – this is useful for debug.\nThere are two facts involved in the contradiction. One of them was introduced by the user, and the other in the initialization. In principle the system can retract the initialization fact – the begetting of the user, but then the user would not exist. In principle the system can be smart enough to decide that the user exists for another reason, and avoid the paradox by having the user not be the son of the one he kills. Not sure if this is interesting and worth the effort."
    }, {
      "heading" : "S.8. Proactive reasoning",
      "text" : "The first principle is that we do not retract premises. Premises may be of three types: a) world or application knowledge (in our domain we do not have any – only constraints), b) application specific initialization of narrative, and c) user actions. In general it may be possible to change some of these without changing the \"spirit of the story\", but this is beyond our scope.\nBy induction the history is consistent at any given time t, so the contradiction is always attributed, at least partially, to the most recently introduced action. In general, we discuss this in terms of transformations rather than actions; recall that transformations may involve removing some actions as well as adding others.\nA generic proactive reasoning method, intended to keep the changed history as close as possible to the original one, can be written formally as follows. Given a transformation h2 =  (h1,A1, A2) s.t. h2 is illegal, find sets of actions A3,A4 s.t. h3 =  (h2, A3, A4) is consistent and for each possible hH |h3-h1|  |h-h1|. The distance |h1-h2| is typically application dependent. One criteria for this metric is that some actions are less common than others. For example, adding a beget action in our domain may be more likely than adding a killing action. There may be additional constraints on A3 and A4; e.g., the system would typically not introduce actions taken by the user (so as not to violate his free will or his memory of his own actions).\nWe have introduced our domain-specific algorithm to overcome contradictions in Section X. TBD: could be generalized. It is applied here in a very similar way, with interesting results.\nHere is the deduction chain leading to the contradiction:\nexists(p,2)\nbeget(p,2)  exists(p,2)\nbeget(p,2) is True: premise\nbut also\nexists(p,2)\nkill(s1,p,1)  exists(p,2)\nkill(s1,p,1) is True: premise\nThe algorithm is applied. The premise for the non existence of p is at time 1 and the premise for its existence is from time 2. So, in this case, the algorithm needs to add an action between 1 and 2, which makes p appear. Here is a possible solution:\nTime P S S1 Action\n0 + - - arrive(s1,3)\n1 + - + kill(s1,p)\n1.5 - - + beget(s1,p)\n2 + - + beget(p,s)\n3 + + + depart(s,0)\nThis could have been a solution unless we have made sure each person exists only once. So the kill action at time 1 installs not exists for all time > 1, and similarly the new beget at time 1.5 installs a not exists at all times < 1.5. So this solution, which results in p having tow lifelines, is invalid.\nTBD: adding an action in the middle 1.5 – what happens to continuity?\nS1 killed F and the system decided that he then gave birth to him again! Here we display the whole history, for the reader's convenience. This is an interesting twist, but it has two problems. The first is that we do not want the system to take proactive actions on behalf of the user. If we had another user they could beget F, and that would make more sense.\nThe other problem is an identity problem, and a very interesting one! Incidentally, this solution to the paradox and its importance was discussed by philosophers (see (Smith 1997), counterfactual B, p. 372). We see that S went back in time and killed F, and F is S's father. How did the system avoid the parent paradox? The problem is, of course, that we now have two separate life threads, both called F, and the F that was killed by S is not F's father.\nS.9 A solution to the paradox\nTime P P1 S S1 Action\n-1 - - - - arrive(p1,4)\n0 - + - - arrive(s1,3)\n1 - + - + kill(s1,p1)\n1.5 - - - + beget(s1,p)\n2 + - - + beget(p,s)\n3 + - + + depart(s,0)\n4 + - - - depart(p,-1)\nHow do we reach this? the system needs another heuristic to generate time travel .\nTBD: can add an arrival instead of the beget! Is that a new solution? Or is that how the system arrives at the solution below?\nTime P P1 P2 S S1 Action\n0 + - - - - arrive(s1,3)\n0.5 + - - - + depart(p,1.5)\n0.75 - - + - + arrive(p2,4)\n1 - - + - + kill(s1,p2)\n1.5 - - - - + arrive(p1,0.5)\n2 - + - - + beget(p1,s)\n3 - + - + + depart(s,0)\n4 - + - - + depart(p1,0.75)\nThe solution needs to add time travel as well."
    } ],
    "references" : [ {
      "title" : "The Fabric of Reality",
      "author" : [ "D. Deutsch" ],
      "venue" : "New York: Penguin. Deutsch D, Lockwood M. 1994. The Quantum Physics of Time Travel Scientific",
      "citeRegEx" : "Deutsch,? 1997",
      "shortCiteRegEx" : "Deutsch",
      "year" : 1997
    }, {
      "title" : "The Case for Time Travel",
      "author" : [ "P. American Dowe" ],
      "venue" : "Philosophy 75: 441-51 Doyle J. 1979. Truth Maintenance Systems. Artificial Intelligence 12: 231-72 Grey W. 1999. Troubles with Time Travel. Philosophy 74: 55-70 Hanks S, McDermott DV. AAAI1986, 86: 328-33.",
      "citeRegEx" : "Dowe,? 2000",
      "shortCiteRegEx" : "Dowe",
      "year" : 2000
    }, {
      "title" : "Increasing Saving Behavior Through Age-Progressed Renderings of the Future Self",
      "author" : [ "HE Hershfield", "DG Goldstein", "WF Sharpe", "J Fox", "L Yeykelis" ],
      "venue" : "Journal of Marketing Research:",
      "citeRegEx" : "Hershfield et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Hershfield et al\\.",
      "year" : 2011
    }, {
      "title" : "On Some Alleged Paradoxes of Time Travel",
      "author" : [ "P. Horwich" ],
      "venue" : "Journal of Philosophy 72: 432-44",
      "citeRegEx" : "Horwich,? 1975",
      "shortCiteRegEx" : "Horwich",
      "year" : 1975
    }, {
      "title" : "The Paradoxes of Time Travel",
      "author" : [ "D. Lewis" ],
      "venue" : "American Philosophical Quarterly: 14552",
      "citeRegEx" : "Lewis,? 1976",
      "shortCiteRegEx" : "Lewis",
      "year" : 1976
    }, {
      "title" : "Truth Maintenance",
      "author" : [ "McAllester DML." ],
      "venue" : "Proc. Eighth National Conf. Artificial Intelligence, pp. 1109--16. Boston, MA",
      "citeRegEx" : "DML.,? 1990",
      "shortCiteRegEx" : "DML.",
      "year" : 1990
    }, {
      "title" : "Some philosophical problems from the standpoint of artificial intelligence",
      "author" : [ "J McCarthy", "P. Hayes" ],
      "venue" : "Stanford University.",
      "citeRegEx" : "McCarthy and Hayes,? 1968",
      "shortCiteRegEx" : "McCarthy and Hayes",
      "year" : 1968
    }, {
      "title" : "Time's Arrow and Archimedes Point",
      "author" : [ "H. Price" ],
      "venue" : "New York, NY, USA: Oxford University Press.",
      "citeRegEx" : "Price,? 1996",
      "shortCiteRegEx" : "Price",
      "year" : 1996
    }, {
      "title" : "The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression",
      "author" : [ "R. Reiter" ],
      "venue" : "Artificial intelligence and mathematical theory of computation: papers in honor of John McCarthy 27: 359-80",
      "citeRegEx" : "Reiter,? 1991",
      "shortCiteRegEx" : "Reiter",
      "year" : 1991
    }, {
      "title" : "Seven Layers of Knowledge Representation and Reasoning in Support of Software Development",
      "author" : [ "Rich C", "Feldman YA." ],
      "venue" : "IEEE Trans. Software Eng. 18: 451-69",
      "citeRegEx" : "C and YA.,? 1992",
      "shortCiteRegEx" : "C and YA.",
      "year" : 1992
    }, {
      "title" : "Knowledge, action, and the frame problem",
      "author" : [ "Scherl RB", "Levesque HJ." ],
      "venue" : "Artificial Intelligence 144: 1-39",
      "citeRegEx" : "RB and HJ.,? 2003",
      "shortCiteRegEx" : "RB and HJ.",
      "year" : 2003
    }, {
      "title" : "Monotonic solution of the frame problem in the situation calculus",
      "author" : [ "L. Schubert" ],
      "venue" : "Springer.",
      "citeRegEx" : "Schubert,? 1990",
      "shortCiteRegEx" : "Schubert",
      "year" : 1990
    }, {
      "title" : "Solving the frame problem: a mathematical investigation of the common sense law of inertia",
      "author" : [ "M. Shanahan" ],
      "venue" : "MIT press Cambridge.",
      "citeRegEx" : "Shanahan,? 1997",
      "shortCiteRegEx" : "Shanahan",
      "year" : 1997
    }, {
      "title" : "Reasoning about change: time and causation from the standpoint of artificial intelligence",
      "author" : [ "Y. Shoham" ],
      "venue" : "Yale Univ.,",
      "citeRegEx" : "Shoham,? \\Q1987\\E",
      "shortCiteRegEx" : "Shoham",
      "year" : 1987
    }, {
      "title" : "Bananas Enough for Time Travel? Brit",
      "author" : [ "N. Smith" ],
      "venue" : "J. Phil. Sci. 48: 363-89",
      "citeRegEx" : "Smith,? 1997",
      "shortCiteRegEx" : "Smith",
      "year" : 1997
    }, {
      "title" : "The first is that we do not want the system to take proactive actions on behalf of the user. If we had another user they could beget F, and that would make more sense. The other problem is an identity problem, and a very interesting one! Incidentally, this solution to the paradox and its importance was discussed by philosophers",
      "author" : [ ],
      "venue" : "counterfactual B,",
      "citeRegEx" : "F and F,? \\Q1997\\E",
      "shortCiteRegEx" : "F and F",
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "An early discussion of time travel in philosophy in contemporary times has been provided by Lewis (Lewis 1976).",
      "startOffset" : 98,
      "endOffset" : 110
    }, {
      "referenceID" : 3,
      "context" : "Horwich (Horwich 1975) criticized this view by pointing out that if travel to the local past is allowed then there would be countless attempts to initiate self-defeating causal chains, and it would be highly improbable that all of them would be avoided by mundane events such as slipping over a banana peel.",
      "startOffset" : 8,
      "endOffset" : 22
    }, {
      "referenceID" : 7,
      "context" : "So far we have adopted the formal way, which is more convenient from an algorithmic point of view would adopt a metatemporal viewpoint (\"the view from nowhen\" (Price 1996)).",
      "startOffset" : 159,
      "endOffset" : 171
    }, {
      "referenceID" : 4,
      "context" : "A person and their clone have the same personal identity in the same way that a child and the same person who is a grownup have the same personal identity (see (Lewis 1976) for a discussion on identity and time travel) (Section S.",
      "startOffset" : 160,
      "endOffset" : 172
    }, {
      "referenceID" : 0,
      "context" : "Since we allow changing history, our interpretation is similar to Deutsch's interpretation of experiencing time travel in parallel universes through virtual reality (Deutsch 1997), but there are subtle differences; for example, in the first time around our time traveler does not need to meet his future clone.",
      "startOffset" : 165,
      "endOffset" : 179
    } ],
    "year" : 2016,
    "abstractText" : "While the possibility of time travel in physics is still debated, the explosive growth of virtual-reality simulations opens up new possibilities to rigorously explore such time travel and its consequences in the digital domain. Here we provide a computational model of time travel and a computer program that allows exploring digital time travel. In order to explain our method we formalize a simplified version of the famous grandfather paradox, show how the system can allow the participant to go back in time, try to kill their ancestors before they were born, and experience the consequences. The system has even come up with scenarios that can be considered consistent \"solutions\" of the grandfather paradox. We discuss the conditions for digital time travel, which indicate that it has a large number of practical applications.",
    "creator" : "Microsoft® Word 2013"
  }
}