{
  "name" : "1411.6369.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Scale-Invariant Convolutional Neural Network",
    "authors" : [ "Yichong Xu", "Tianjun Xiao", "Jiaxing Zhang", "Kuiyuan Yang", "Zheng Zhang" ],
    "emails" : [ "xycking@163.com", "xiaotianjun@pku.edu.cn", "jiaxz@microsoft.com", "kuyang@microsoft.com", "zz@nyu.edu" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Many classical computer vision tasks have enjoyed a great breakthrough, primarily due to the large amount of training data and the application of deep convolution neural networks (CNN) [8]. In the most recent ILSVRC 2014 competition [11], CNN-based solutions have achieved nearhuman accuracies in image classification, localization and detection tasks [14, 16].\nAccompanying this progress are studies trying to understand what CNN has learnt internally and what contribute to its success [2, 13, 17]. By design, layers within the network have progressively larger receptive field sizes, allowing them to learn more complex features. Another key point is the shift-invariance property, that a pattern in the input can be recognized regardless of its position [9]. Pooling layers contribute resilience to slight deformation as well small\nscale change [12]. However, it is evident that CNN deals with shift-variance far better than scale-invariance [3]. Not dealing with scaleinvariance well poses a direct conflict to the design philosophy of CNN, in that higher layers may see and thus captures features of certain plain patterns simply because they are larger at the input, not because they are more complex. In other words, there is no alignments between in the position of a filter and the complexity it captures. What is more, there are other invariance that CNN does not deal with internally. Examples include rotations and flips (since features of natural objects are mostly symmetric).\nA brutal force solution would be to make the network larger by introducing more filters to cope with scale variations of the same feature, accompanied by scale-jittering the input images, often by order of magnitude. This is, in fact, the popular practice today [1, 8, 14]. It is true even for proposals that directly deal with this problem. For example, [3] drives the CNN with crops of different size and positions with three differnt scales, and then uses VLAD pooling to produce a feature summary of the patches.\nWe explore a radically different approach that is also simple. Observing that filters that detect the same pattern but with different scales bear strong relationship, we adopt a multi-column design and designate each column to specialize on certain scales. We call our system SiCNN (Scaleinvariant CNN). Unlike a conventional multi-column CNN, filters in SiCNN are strongly regulated among columns. The goal is to make the network resilient to scale variance without blowing up number of free parameters, and thus reduce the need of jittering the input.\nWe performed detailed analysis and verified that SiCNN exhibits the desired behavior. For example, the column that deals with larger scale is indeed activated by input patterns with the larger scaling factor, and the system as a whole becomes less sensitive to scale variance. On unaugmented CIFAR-10 dataset [7], our method produces the best re-\n1\nar X\niv :1\n41 1.\n63 69\nv1 [\ncs .C\nV ]\n2 4\nN ov\nsult among all previous works using a single CNN and a simple softmax classifier, and is complementary to other techniques that improve the performance. Our model increases training cost linear to number of columns, but we find that incremental refinement can dramatically reduce the cost without compromising the performance significantly.\nThe rest of the paper is organized as follows. Section 2 presents SiCNN, covering the high-level intuition, the mathematical foundation and the architecture. Detailed analysis and results are presented in Section 3, and we conclude in Section 4."
    }, {
      "heading" : "2. Model",
      "text" : "Consider the case of classifying objects that have only one canonical scale and the only free parameter is their positions. A stack of convolution filters can progressively build more complex hidden representations. These hidden representations are all invariant by shift, meaning that the activations preserve the same pattern except that they are shifted. In other words, conv(Shift(I), f) ≡ Shift(conv(I, f)), for arbitrary image I and filter f , and this relationship is upheld layer to layer. This makes the job of the classifier easy.\nIn the existing CNN architecture, dealing with multiple scales is jointly achieved by the pooling layers and the convolution layers. The convolution layer not only needs to learn different features but also their scaled variants into multiple feature maps. Units in the pairing pooling layer generate scale-invariance within their receptive fields, which help to save feature maps. This multi-scale solution leads to bigger model and, since filters are independently learned, the need of more training data. The popular practice is scale-jittering [8].\nOur idea is simple, and is inspired by the invariance-byshift property of the existing convolution layer. Just like CNN convolve a filter on different positions, we also ”convolve” the filter on different scales. This is done by adding independent columns, each is a conventional CNN but “specialized” at detecting one scale. Crucially, the columns are strongly regularized such that the number of free parameters in the convolution layers stay the same. Thus, we inject scale-invariance into the model, requiring neither additional data augmentation nor increasing the model size.\nIn the followings, we first introduce our architecture, present the intuition and then give the concrete mathematical definition."
    }, {
      "heading" : "2.1. Scale-Invariance Architecture",
      "text" : "SiCNN uses multiple columns of convolutional stack with varying filter size to capture objects with unknown scales in input images. The architecture is illustrated in Figure 1. From bottom up, the input image is fed into all the columns. Each column has several convolutional layers\nwith max-pooling. The key difference from conventional multi-column CNN is that, although these columns use different filter size, they still share a set of common parameters among their filters. A canonical column (Column 1 in Figure 1) keeps canonical filters in each layer. Other columns, which we call scale columns, transform these canonical filters into their own filter. Collectively, a canonical filter and its transformed filters detect its pattern at different scales in multiple columns simultaneously. Therefore, a single pattern with different scales trigger one or more columns.\nIn our architecture, we simply concatenate the top-layer feature maps from all the columns into a feature vector. The final classification layers (a softmax layer in the simplest case) take this feature vector as input."
    }, {
      "heading" : "2.2. Filters in Multiple Scales",
      "text" : "Filters that are transformed into different columns from the canonical filter capture the same pattern at different scales. We will discuss this transformation from canonical filters to other columns.\nConsider a canonical filter f , which detects a pattern in image I by convolution conv(I, f) (Figure 2). When the image is scaled by a scaling operation S to S(I), we expect another column k with transformed filter T (f) to capture the same pattern instead. Thus, the column k generates another convolution result conv(S(I), T (f)). Just as invariance-by-shift, we require this convolution be equivalent with scaling from the convolution result in the canonical column. That is\nconv(S(I), T (f)) = S(conv(I, f)). (1)\nWe call this property of filter as invariance-by-scaling. Given a scaling S, we want to find the T that satisfies Equation 1 for any image I and filter f .\nThe above discussion is for the first layer. However, it is easy to see that if the filter transformation T in each layer satisfies Equation 1, then invariance-by-scaling property is preserved layer by layer till reaching the classification layer. In Figure 3, when input images I and S(I) with different scale are fed into the canonical column and the column k separately, they generate X1 and S(X1) respectively. The following ReLU nonlinear activation function and maxpooling keep this scale relationship and result in Y1 and S(Y1). By recursively applying Equation 1, we know the top layers of these two columns also keep the same scale relationship: if canonical column generates YM on input image I , the column k generates S(YM ) on image S(I).\nIf the object scale fits exactly one of the columns, then there is a perfect matching with the column outputting the\nhighest responses. Otherwise, if the object scale just falls in between the scales of two neighboring columns, both the two columns will have relatively high responses. The concatenated feature vector at the end makes it possible for the classifier to do a linear combinations of responses from multiple columns to eliminate above variance."
    }, {
      "heading" : "2.3. Filter Transformation",
      "text" : "By a vector representation of the image (concatenating all the rows or columns in matrix), scaling and convolution are all linear transformations. Given a canonical filter fc represented by a vector, we can solve the following equation derived from Equation 1 to get the transformed filter ft,\n∀I,conv(S(I), ft) = S(conv(I, fc)). (2)\nEquation 2 is a system of linear equations for ft. However, such a system doesn’t always have a valid solution because it has too many constraints (linear equations). To address this problem, we reduce I to be of the same size as fc, which makes the conv(I, fc) produce only a single number. Then, Equation 2 turns into\n∀I, (S · I)T · ft = IT · fc, (3)\nwhere S is the scaling matrix, I is the vector representation of the image, and similar are fc and ft. It’s easy to prove that Equation 3 is equivalent to\nST · ft = fc, (4)\nWe can solve Equation 4 to obtain ft. However, in practice we can’t always obtain an exact or unique ft because S is not a square and invertible matrix. When S is a scaling-up matrix (#rows > #columns), the equation have infinite number of solutions; when S is a scaling-down matrix (#rows < #columns), the equation have no exact solutions.\nFor the first case with infinite solutions, we choose the solution with the minimum L2 norm,\nft = argmin ft ‖ft‖22 subject to ST · ft = fc. (5)\nThe reason that we choose a minimum-norm solution is similar of applying weight decay to the weights, i.e., to reduce over-fitting. A flat filter is likely to have more generalization to various cases. It is easy to get the solution of (5) by the generalized inverse of ST ,\nft = S(S TS)−1 · fc. (6)\nFor the second case with no exact solution, we see the problem from a different angle: we take the scaled image Ĩ = S·I as an input image, and proximate the original I with a scaling of Ĩ, I ≈ S̃Ĩ. Here the S̃ is a scaling-up matrix in the reverted direction of S. We turn the Equation 3 into\n∀Ĩ, ĨT · ft = (S̃ · Ĩ)T · fc. (7)\nSimilar to Equation 4, we get\nft = S̃ T · fc. (8)\nIn our implementation, we use bicubic interpolation [6] as the scaling method to transform filters. This method can produce nice scaling results without losing too much information of the original image.\nIn our model, we also consider a special scaling operation: horizontal flipping. We add some columns with flipped filters to capture the flipped patterns in input. The scaling matrix for flipping is a symmetric invertible matrix. It is very easy to solve Equation 4,\nft = S · fc. (9)"
    }, {
      "heading" : "2.4. Training Multiple Columns",
      "text" : "We integrate all the columns with tied filters into a single model and train them together with back-propagation algorithm. Observing Equation 6, 8 and 9 in above cases, we find the transformation from canonical filter to any scale is always a linear transformation. That means, the filters in all the columns are tied to the canonical filter by a matrix multiplication,\nft = Q · fc,\nwhere Q is some transformation matrix. Particularly, Q is an identity matrix for canonical column. This property makes back-propagation very convenient.\nSuppose we have n columns, and the corresponding filters are\nf it = Qi · fc.\nDefine the cost function as E, which is a function of all the f it . By the chain rule of derivatives, we get\n∂E ∂fc = n∑ i=1 ( ∂f it ∂fc )T · ∂E ∂f it\n= n∑ i=1 QTi · ∂E ∂f it .\nIn training, we first do the back-propagation in each column independently. Then, derivatives of the filters distributed on all columns are transformed and gathered as the canonical filters’ derivatives. When the canonical filters are updated by these aggregated derivatives, all the filters on the scaled columns are recomputed by filter transformation from the new canonical filters."
    }, {
      "heading" : "3. Experiment Results",
      "text" : "This section presents our experimental results. We begin with a detailed analysis on the scale invariance achieved within the network, followed by end-to-end performance on\nCIFAR-10 dataset [7]. The baseline CNN is close to the Alex network [5], with 3 layers of convolution. Each layer uses 5 × 5 receptive size and a stride of 1, pooling of receptive size 3 × 3 and a stride of 2, followed by local normalization. The first convolution is paired with max pooling whereas the latter two is followed by average pooling. SiCNN extends it to 6 columns. The first three columns use filter size of 3, 5 and 7, with the last three columns being the flipped versions of the first three. All the weights are regularized and tied to the column with the 5 × 5 non-flipped column. We train these models on standard CIFAR-10 with the training method similar to that in [5]. We use the same hyper-parameters (learning rate, momentum, weight decay) as in [5]. We first train the whole net for 240 epochs, then reduce the learning rate by a factor of ten. We train for another 20 epochs, tune the learning rate again, and train for another 20 epochs to get the final result.\nTo exploit the invariance property of the model, we need to generate a new test dataset with a mixture of different scales. We crop the central 24 × 24 and 28 × 28 of the CIFAR-10 images and resize them to 32 × 32. This mixed dataset has 3 different scales: small, middle and large. We refer to this dataset as scaled CIFAR-10 later in this section.\nOur experiment results are best viewed in electronic form."
    }, {
      "heading" : "3.1. Filter Transformation for Scale-Invariance",
      "text" : "Consider an arbitrary image I and its scaled version S(I). After applying a filter f and its transformation T (f), their corresponding activations become conv(I, f) and conv(S(I), T (f)), respectively. As described in Section 2.3, to achieve scale-invariant pattern matching, we expect the former after scaling is indistinguishable with the latter, i.e.,\nS(conv(I, f)) ≡ conv(S(I), T (f)). (10)\nIn section Section 2.3, we achieve this for small image patches; in this section, we verify this property for larger images.\nNote that the left side of Equation 10, S(conv(I, f)) is the scaled activation of the canonical image, and is the design target of our transformation function. So we quantify with relative error using\ndiff(x, y) = ‖x− y‖2 ‖x‖2 .\nwhere x = S(conv(I, f)) and y = conv(S(I), T (f)). We compare three different kinds of filter transformation methods. transI is an identity transformation, with which we apply the original filter f onto the scaled image S(I). transT is the filter transformation described in Section 2.3. transS is a comparison method, where we directly use simple image sampling to scale the filter. We also\nnormalize the transformed filter to the same L1 norm as the original filter; we find this normalization performs the best compared to other alternatives. transS takes such a transformation on filter f ,\nWe report the filter invariance-by-scaling by measuring\ndiff(S(conv(I, f)),conv(S(I), T (f)))\nin Table 1. We take 100 random images from the test set of CIFAR-10 and take their averaged result. Three canonical filters with size of 5 × 5 are considered: random filter (the first row), filters learnt in the baseline CNN model (the second row), and filters learnt in SiCNN (the third row). As comparison, non-overlapped 2 × 2 max pooling, which is usually considered powerful for scale-invariance, is taken as a non-parametric filter applied to image I and scaled S(I). In Table 1(a), we use a scaling-up S that doubles the image size from 32 × 32 to 64 × 64. Accordingly, transT and transS scale the filter size from 5 × 5 to 9 × 9. In Table 1(b), S is a scaling-down. Image size is halved from 32 × 32 to 16 × 16, and the filter size is scaled down from 5× 5 to 3× 3.\nFrom Table 1, it is clear that convolution with the same filter without any transformation is very sensitive to the image scale (column transI ). Our filter transformation method (column transT ) and the sampling-based method (column transS) are much more robust to the image scale. transT is almost always better than the simple-minded transS , especially when the image is scaled down and we need a more precise filter with a very small size. Considering the fact that transS is hard for back-propagation because of the normalization, our method becomes an apparent choice for transforming filters. Also, when the image is scaled up, our filter transformation is even better than\npooling. Considering pooling doesn’t need to detect any patterns, it’s interesting to see that our method achieves robust invariance-by-scaling. When the image is scaled down, our method is still comparable against pooling. From random filter to SiCNN trained one, these filters adapt to some specific scale more and more. Consequently, the invarianceby-scaling of these filters also gets worse (from first row to the last row) as expected.\nTo give a more concrete feeling of our approach, we inspect the feature maps generated by images of different scales. Fig. 4 shows two particular examples, visualizing a feature map in each of the three convolution layers and the final result after pooling and normalization. In each example, the left column is the activations from the original image of 32 × 32, and the other two columns are from scaled image of 48×48. The left and middle column are results of using filter of the size 5× 5 and its transformed 7× 7 filter. All the feature maps have been scaled to the same size for ease of comparison. From the relatively small difference in each layer, it is clear that applying the transformed filters on the scaled image preserves the essential characteristics of the original. The rightmost column is the result of applying the original 5 × 5 filter to the scaled image. It is clear that the fixed filter generates the activations that diverge from that of the original image (the leftmost column) significantly."
    }, {
      "heading" : "3.2. Multi-Column Features",
      "text" : "To give an idea of what features the different columns learn, we scan over the activations on the last pooling layer caused by 30,000 test images from the scaled CIFAR-10.\nWe randomly pick up a filter in the last layer and visualize the top 16 images that cause the largest outputs of this filter, in each of the 6 columns individually (Fig. 5). This method is similar to that used in [17]. It can be seen that each column in our model focuses on a particular scale and orientation: the images which causes largest activations get larger from left to right, and the automobiles in the two rows face opposite directions.\nIn addition to the visual inspection, we try to quantify how sensitive filters of different columns are to the scales. We take the top 100 images that this feature of a given column gets activated the most, then break them down according to which scale they belong to in the data set: small, middle or large. This statics is reported at the bottom of the images in Fig. 5. It is clear that columns with small filters “picks” the small-scale images more, whereas the columns with larger filters does the opposite.\nWhen an object for recognition is scaled from small to large, the columns in SiCNN will also work in turn to capture this object. We illustrate that in Figure 7. Using method similar as in Fig. 5, we first select a feature map that detects dogs in the last layer. Then we pick a dog image from CIFAR-10 and scale the object into different sizes (2x larger at most). The max activation value in the feature map are plotted as a function of the object size for each scale column. In Figure 7, it is clear that when the object is small, the column with 3 × 3 filter first captures it and gives a big response. When the object gets larger, activations on this 3 × 3-filter column drop. The 5 × 5 and 7× 7 columns gradually reach their peak responses in turn. The peaks of the three columns locate with the same interval along the object size, because of the equal-interval filter sizes of 3, 5 and 7. Comparing activation values among different columns is meaningless, because they are eventually summed up with different weights for classification. However, this study clearly shows that by tracing which column is activated more, we can detect a object as well as its scale."
    }, {
      "heading" : "3.3. Scale-Invariant Classification",
      "text" : "Table 2 compare the results of the baseline CNN and SiCNN, both of which are trained on standard CIFAR-10 dataset. SiCNN achieves statistically significant gain on standard CIFAR-10. Its full advantage is more apparent with the scaled CIFAR-10, where CNN has a performance drop of more than 43.22%, and SiCNN drops by 32.42%. We manually examine the error cases, and find that the simple central-crop-resize has cut off many significant features in the scaled CIFAR-10. We speculate SiCNN will work better on higher quality multi-scale datasets.\nTo verify the above hypothesis, we pick 5 random images in which the object is at the center, and scale them to different sizes; the largest one is the central 16 × 16 area of the image resized to 32 × 32. We put these images into both CNN and SiCNN, and compare the probability of the correct class. The results are shown in Fig. 7. It can be seen that as the scale of the image goes up, the performance of CNN drops whereas SiCNN is stable. The only exception among these samples is the one of horse; its scaled up versions start to lose vital features."
    }, {
      "heading" : "3.4. Training results on CIFAR-10",
      "text" : "In Table 3, we compare the classification error rate of SiCNN with other previous approaches on CIFAR-10 [7]. We achieve an error rate of 14.22% on unaugmented data, an improvement of more than 2% absolute gain over the baseline CNN in [5]. SiCNN also exceeds other improvement on CNN, such as dropout [5] and Spearmint [15], but is insufficient to catch up with the maxout [4] and network-\nin-network [10], which are the current state of the art. Nevertheless, our method can be combined with these techniques as SiCNN is addressing scale-invariance problem, which is a different goal from others. For example, by using an average voting with SiCNN, we drop the error rate of maxout model from 11.68% to 11.35%. Moreover, by simply adding a extra flipped column to maxout model, we reach an error rate of 11.33% with a single 2-column\nmaxout-SiCNN model. We find these results encouraging, and expect that SiCNN will work better on benchmarks that exhibit higher scale variations, as the results in Section 3.3 suggest. Replicating SICNN on larger and more complex dataset such as ImageNet is ongoing work.\nSiCNN takes the form of multi-column CNN without blowing up number of free parameters. As a more direct comparison, we train a 6-column CNN where the filters are\nindependent. Under the same training condition this network suffers severe overfit, the testing error hovers around 19% while training error already reaches zero."
    }, {
      "heading" : "3.5. Incremental Training",
      "text" : "Improving scale invariance does not come for free. In the current configuration, training costs increase linearly with number of columns. Clearly, we can first train one single column, transform its filters to other columns and finally refine the model. In this ideal setting, it is reasonable to expect that the additional training cost is insignificant.\nWe explored two incremental training methods. In the first choice (named inc-1), we first train a baseline CNN with about half the epochs of a full training, and we build a 6-column SiCNN based on the current filters. Then we begin to refine the entire model with the left half of the epochs. In the second choice (named inc-2), we continue from a fully trained baseline CNN, and use its filters to build the 6- column SiCNN. Then, with all the filter parameters frozen, we only refine the parameters in classifier. As we use a single softmax layer as classifier, the inc-2 method has a very small extra cost.\nResults for incremental learning are summarized in Table 4. Compared with SiCNN trained from scratch (the second row), inc-1 training (the third row) takes nearly half cost, with the model achieving a comparable performance. With the inc-2 training (the fourth row), although the extra training cost is very small (1.5%), we still get a model with better performance than baseline CNN. Also by combination with the maxout units [4], we’re able to reach an error rate of 11.33% which is higher than the previous result. Incremental learning does help to balance the performance gain and training efficiency in SiCNN."
    }, {
      "heading" : "4. Conclusion",
      "text" : "In this paper, we propose a new generalization of CNN, SiCNN, where we incorporate scale and flip invariance into the model. This model improves the results of traditional CNN, and complements other optimization techniques. Our results clearly indicate that the model learns the feature in different scales in different columns. The idea is generaliz-\nable, can be applied in all aspects where CNN is employed, including supervised and unsupervised learning, recognition, detection, and localization tasks. Our preliminary study also implies a nice trade-off between performance and training cost.\nSeveral open problems remain. For example, we can use a different way of summarizing all the columns (instead of concatenation), and different connectivity structure among column (e.g., pair-wise between columns instead of all-to-one against the canonical column). We plan to apply SiCNN to larger and more complex datasets such as Imagenet."
    } ],
    "references" : [ {
      "title" : "Multi-column deep neural networks for image classification",
      "author" : [ "D. Ciresan", "U. Meier", "J. Schmidhuber" ],
      "venue" : "Computer Vision and Pattern Recognition (CVPR), 2012 IEEE Conference on, pages 3642–3649. IEEE",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Visualizing higher-layer features of a deep network",
      "author" : [ "D. Erhan", "Y. Bengio", "A. Courville", "P. Vincent" ],
      "venue" : "Dept. IRO, Université de Montréal, Tech. Rep",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Multi-scale orderless pooling of deep convolutional activation features",
      "author" : [ "Y. Gong", "L. Wang", "R. Guo", "S. Lazebnik" ],
      "venue" : "arXiv preprint arXiv:1403.1840",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Maxout networks",
      "author" : [ "I.J. Goodfellow", "D. Warde-Farley", "M. Mirza", "A. Courville", "Y. Bengio" ],
      "venue" : "arXiv preprint arXiv:1302.4389",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Improving neural networks by preventing co-adaptation of feature detectors",
      "author" : [ "G.E. Hinton", "N. Srivastava", "A. Krizhevsky", "I. Sutskever", "R.R. Salakhutdinov" ],
      "venue" : "arXiv preprint arXiv:1207.0580",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Cubic convolution interpolation for digital image processing",
      "author" : [ "R. Keys" ],
      "venue" : "Acoustics, Speech and Signal Processing, IEEE Transactions on, 29(6):1153–1160",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1981
    }, {
      "title" : "Learning multiple layers of features from tiny images",
      "author" : [ "A. Krizhevsky", "G. Hinton" ],
      "venue" : "Computer Science Department, University of Toronto, Tech. Rep",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevsky", "I. Sutskever", "G.E. Hinton" ],
      "venue" : "Advances in neural information processing systems, pages 1097–1105",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Convolutional networks for images",
      "author" : [ "Y. LeCun", "Y. Bengio" ],
      "venue" : "speech, and time series. The handbook of brain theory and neural networks, 3361",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Network in network",
      "author" : [ "M. Lin", "Q. Chen", "S. Yan" ],
      "venue" : "CoRR, abs/1312.4400",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "et al",
      "author" : [ "O. Russakovsky", "J. Deng", "H. Su", "J. Krause", "S. Satheesh", "S. Ma", "Z. Huang", "A. Karpathy", "A. Khosla", "M. Bernstein" ],
      "venue" : "Imagenet large scale visual recognition challenge. arXiv preprint arXiv:1409.0575",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Evaluation of pooling operations in convolutional architectures for object recognition",
      "author" : [ "D. Scherer", "A. Müller", "S. Behnke" ],
      "venue" : "Artificial Neural Networks–ICANN 2010, pages 92– 101. Springer",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Deep inside convolutional networks: Visualising image classification  models and saliency maps",
      "author" : [ "K. Simonyan", "A. Vedaldi", "A. Zisserman" ],
      "venue" : "arXiv preprint arXiv:1312.6034",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Very deep convolutional networks for large-scale image recognition",
      "author" : [ "K. Simonyan", "A. Zisserman" ],
      "venue" : "arXiv preprint arXiv:1409.1556",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Practical bayesian optimization of machine learning algorithms",
      "author" : [ "J. Snoek", "H. Larochelle", "R.P. Adams" ],
      "venue" : "Advances in Neural Information Processing Systems, pages 2951–2959",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Going deeper with convolutions",
      "author" : [ "C. Szegedy", "W. Liu", "Y. Jia", "P. Sermanet", "S. Reed", "D. Anguelov", "D. Erhan", "V. Vanhoucke", "A. Rabinovich" ],
      "venue" : "arXiv preprint arXiv:1409.4842",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Visualizing and understanding convolutional neural networks",
      "author" : [ "M.D. Zeiler", "R. Fergus" ],
      "venue" : "arXiv preprint arXiv:1311.2901",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "Many classical computer vision tasks have enjoyed a great breakthrough, primarily due to the large amount of training data and the application of deep convolution neural networks (CNN) [8].",
      "startOffset" : 185,
      "endOffset" : 188
    }, {
      "referenceID" : 10,
      "context" : "In the most recent ILSVRC 2014 competition [11], CNN-based solutions have achieved nearhuman accuracies in image classification, localization and detection tasks [14, 16].",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 13,
      "context" : "In the most recent ILSVRC 2014 competition [11], CNN-based solutions have achieved nearhuman accuracies in image classification, localization and detection tasks [14, 16].",
      "startOffset" : 162,
      "endOffset" : 170
    }, {
      "referenceID" : 15,
      "context" : "In the most recent ILSVRC 2014 competition [11], CNN-based solutions have achieved nearhuman accuracies in image classification, localization and detection tasks [14, 16].",
      "startOffset" : 162,
      "endOffset" : 170
    }, {
      "referenceID" : 1,
      "context" : "Accompanying this progress are studies trying to understand what CNN has learnt internally and what contribute to its success [2, 13, 17].",
      "startOffset" : 126,
      "endOffset" : 137
    }, {
      "referenceID" : 12,
      "context" : "Accompanying this progress are studies trying to understand what CNN has learnt internally and what contribute to its success [2, 13, 17].",
      "startOffset" : 126,
      "endOffset" : 137
    }, {
      "referenceID" : 16,
      "context" : "Accompanying this progress are studies trying to understand what CNN has learnt internally and what contribute to its success [2, 13, 17].",
      "startOffset" : 126,
      "endOffset" : 137
    }, {
      "referenceID" : 8,
      "context" : "Another key point is the shift-invariance property, that a pattern in the input can be recognized regardless of its position [9].",
      "startOffset" : 125,
      "endOffset" : 128
    }, {
      "referenceID" : 11,
      "context" : "Pooling layers contribute resilience to slight deformation as well small scale change [12].",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 2,
      "context" : "However, it is evident that CNN deals with shift-variance far better than scale-invariance [3].",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 0,
      "context" : "This is, in fact, the popular practice today [1, 8, 14].",
      "startOffset" : 45,
      "endOffset" : 55
    }, {
      "referenceID" : 7,
      "context" : "This is, in fact, the popular practice today [1, 8, 14].",
      "startOffset" : 45,
      "endOffset" : 55
    }, {
      "referenceID" : 13,
      "context" : "This is, in fact, the popular practice today [1, 8, 14].",
      "startOffset" : 45,
      "endOffset" : 55
    }, {
      "referenceID" : 2,
      "context" : "For example, [3] drives the CNN with crops of different size and positions with three differnt scales, and then uses VLAD pooling to produce a feature summary of the patches.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 6,
      "context" : "On unaugmented CIFAR-10 dataset [7], our method produces the best re-",
      "startOffset" : 32,
      "endOffset" : 35
    }, {
      "referenceID" : 7,
      "context" : "The popular practice is scale-jittering [8].",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 5,
      "context" : "In our implementation, we use bicubic interpolation [6] as the scaling method to transform filters.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 6,
      "context" : "We begin with a detailed analysis on the scale invariance achieved within the network, followed by end-to-end performance on CIFAR-10 dataset [7].",
      "startOffset" : 142,
      "endOffset" : 145
    }, {
      "referenceID" : 4,
      "context" : "The baseline CNN is close to the Alex network [5], with 3 layers of convolution.",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 4,
      "context" : "We train these models on standard CIFAR-10 with the training method similar to that in [5].",
      "startOffset" : 87,
      "endOffset" : 90
    }, {
      "referenceID" : 4,
      "context" : "We use the same hyper-parameters (learning rate, momentum, weight decay) as in [5].",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 16,
      "context" : "This method is similar to that used in [17].",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 4,
      "context" : "Method Testing error CNN [5] 16.",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 4,
      "context" : "6% CNN+ dropout [5] 15.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 14,
      "context" : "6% CNN+Spearmint [15] 14.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 3,
      "context" : "22% CNN+Maxout [4] 11.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 3,
      "context" : "68% CNN+Maxout [4] + SiCNN (voting) 11.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 9,
      "context" : "33% Network in Network [10] 10.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 6,
      "context" : "In Table 3, we compare the classification error rate of SiCNN with other previous approaches on CIFAR-10 [7].",
      "startOffset" : 105,
      "endOffset" : 108
    }, {
      "referenceID" : 4,
      "context" : "22% on unaugmented data, an improvement of more than 2% absolute gain over the baseline CNN in [5].",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 4,
      "context" : "SiCNN also exceeds other improvement on CNN, such as dropout [5] and Spearmint [15], but is insufficient to catch up with the maxout [4] and network-",
      "startOffset" : 61,
      "endOffset" : 64
    }, {
      "referenceID" : 14,
      "context" : "SiCNN also exceeds other improvement on CNN, such as dropout [5] and Spearmint [15], but is insufficient to catch up with the maxout [4] and network-",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 3,
      "context" : "SiCNN also exceeds other improvement on CNN, such as dropout [5] and Spearmint [15], but is insufficient to catch up with the maxout [4] and network-",
      "startOffset" : 133,
      "endOffset" : 136
    }, {
      "referenceID" : 9,
      "context" : "in-network [10], which are the current state of the art.",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 3,
      "context" : "Also by combination with the maxout units [4], we’re able to reach an error rate of 11.",
      "startOffset" : 42,
      "endOffset" : 45
    } ],
    "year" : 2014,
    "abstractText" : "Even though convolutional neural networks (CNN) has achieved near-human performance in various computer vision tasks, its ability to tolerate scale variations is limited. The popular practise is making the model bigger first, and then train it with data augmentation using extensive scale-jittering. In this paper, we propose a scaleinvariant convolutional neural network (SiCNN), a model designed to incorporate multi-scale feature exaction and classification into the network structure. SiCNN uses a multi-column architecture, with each column focusing on a particular scale. Unlike previous multi-column strategies, these columns share the same set of filter parameters by a scale transformation among them. This design deals with scale variation without blowing up the model size. Experimental results show that SiCNN detects features at various scales, and the classification result exhibits strong robustness against object scale variations.",
    "creator" : "LaTeX with hyperref package"
  }
}