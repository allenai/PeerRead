{
  "name" : "1707.06813.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "On the Computation of Paracoherent Answer Sets",
    "authors" : [ "Giovanni Amendola", "Carmine Dodaro", "Wolfgang Faber", "Nicola Leone", "Francesco Ricca" ],
    "emails" : [ "amendola@mat.unical.it", "dodaro@mat.unical.it", "leone@mat.unical.it", "ricca@mat.unical.it", "w.faber@hud.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 7.\n06 81\n3v 1\n[ cs\n.L O\n] 2\n1 Ju\nAnswer Set Programming (ASP) is a well-established formalism for nonmonotonic reasoning. An ASP program can have no answer set due to cyclic default negation. In this case, it is not possible to draw any conclusion, even if this is not intended. Recently, several paracoherent semantics have been proposed that address this issue, and several potential applications for these semantics have been identified. However, paracoherent semantics have essentially been inapplicable in practice, due to the lack of efficient algorithms and implementations. In this paper, this lack is addressed, and several different algorithms to compute semi-stable and semi-equilibrium models are proposed and implemented into an answer set solving framework. An empirical performance comparison among the new algorithms on benchmarks from ASP competitions is given as well."
    }, {
      "heading" : "1 Introduction",
      "text" : "In the past decades, many advances in Artificial Intelligence research has been done thanks to studies in the field of knowledge representation and reasoning. Answer Set Programming (ASP) is a premier formalism for nonmonotonic reasoning (see, [8, 19]). It is a declarative programming paradigm oriented towards difficult, primarily NP-hard, search problems, which are encoded into a logic program, whose models (answer sets) encode solutions. ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].\nHowever, a logic program could have no answer set due to cyclic default negation. In this case, it is not possible to draw any conclusion, even if this is not intended. For this reason, theoretical studies have been developed to extend answer set semantics to keep a system responsive in these exceptional cases. To distinguish this situation from reasoning under classical logical contradiction due to strong negation, called paraconsistent reasoning, it has been referred to it as paracoherent reasoning [4].\n∗The original version is published in the Proceedings of the ThirtyFirst AAAI Conference on Artificial Intelligence (AAAI-17), see aaai.org/ocs/index.php/AAAI/AAAI17/paper/download/14358/13877.\nIn order to deal with this, [34] introduced the semi-stable model semantics that coincides with answer set semantics whenever a program has some answer set, but admits paracoherent models for each classically consistent program. Recently, [4] have improved this kind of semantics avoiding some anomalies with respect to basic modal logic properties, resorting to the equilibrium logic [31]. Thus, this paracoherent semantics is called semi-equilibrium model semantics.1\nDifferent possible applications of these paracoherent semantics have been identified, such as debugging, model building, inconsistency-tolerant query answering, diagnosis, planning and reasoning about actions; and computational complexity aspects have been studied [4]. However, to the best of our knowledge, there are no efficient algorithms to compute paracoherent answer sets, obstructing the concrete use of these reasoning approaches. The goal of the paper is to fill this gap, by developing efficient algorithms and their implementation.\nIn the paper, we consider different algorithms to compute semi-stable and semiequilibrium models, implementing and integrating them into an answer set building framework. Finally, we report the results of an experimental activity conducted on benchmarks from ASP competitions [11], identifying the more efficient algorithm."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We start with recalling answer set semantics, and then present the paracoherent semantics of semi-stable and semi-equilibrium models."
    }, {
      "heading" : "2.1 Answer Set Programming",
      "text" : "We concentrate on programs over a propositional signature Σ. A disjunctive rule r is of the form\na1∨·· ·∨al ← b1, ...,bm,not bm+1, ...,not bn, (1)\nwhere all ai and b j are atoms (from Σ) and l ≥ 0, n ≥ m ≥ 0 and l + n > 0; not represents negation-as-failure. The set H(r) = {a1, ...,al} is the head of r, while B+(r) = {b1, ...,bm} and B\n−(r) = {bm+1, . . . ,bn} are the positive body and the negative body of r, respectively; the body of r is B(r) = B+(r) ∪ B−(r). We denote by At(r) = H(r) ∪ B(r) the set of all atoms occurring in r. A rule r is a fact, if B(r) = /0 (we then omit ←); a constraint, if H(r) = /0; normal, if |H(r)| ≤ 1 and positive, if B−(r) = /0. A (disjunctive logic) program P is a finite set of disjunctive rules. P is called normal [resp. positive] if each r ∈ P is normal [resp. positive]. We let At(P) = ⋃\nr∈PAt(r). Any set I ⊆ Σ is an interpretation; it is a model of a program P (denoted I |= P) iff for each rule r ∈ P, I ∩H(r) 6= /0 if B+(r) ⊆ I and B−(r)∩ I = /0 (denoted I |= r). A model M of P is minimal, iff no model M′ ⊂M of P exists. We denote by MM(P) the set of all minimal models of P and by AS(P) the set of all answer sets (or stable models) of P, i.e., the set of all interpretations I such that I ∈MM(PI), where PI is the well-known Gelfond-Lifschitz reduct [21] of P with respect to I, i.e., the set of rules a1∨ ...∨al ← b1, ...,bm, obtained from rules r ∈ P of form (1), such that B −(r)∩ I = /0. A program is said to be coherent if AS(P) 6= /0, incoherent otherwise. Now, we recall a useful extension of the answer set semantics by the notion of weak constraint [10]. A weak constraint ω is of the form:\n1The relationship with other semantics is discussed in the Related Work section.\nb1, . . . , bm, not bm+1, . . . , not bn.\nGiven a program P and a set of weak constraintsW , the semantics of P∪W extends from the basic case defined above. A constraint ω ∈W is violated by an interpretation I if all positive atoms in ω are true, and all negated atoms are false with respect to I. An optimum answer set for P∪W is an answer set of P that minimizes the number of the violated weak constraints. We denote by ASO(P∪W ) the set of all optimum answer sets of P∪W ."
    }, {
      "heading" : "2.2 Paracoherent ASP",
      "text" : "Here, we introduce two paracoherent semantics that allow for keeping a system responsive when a logic program has no answer set due to cyclic default negation. These semantics satisfy three desiderata properties identified by [4].\nSemi-StableModels. Inoue and Sakama ([34]) introduced semi-stable model semantics. We consider an extended signature Σκ = Σ∪{Ka | a ∈ Σ}. Intuitively, Ka can be read as a is believed to hold. Semantically, we resort to subsets of Σκ as interpretations Iκ and the truth values false ⊥, believed true bt, and true t. The truth value assigned by Iκ to a propositional variable a is defined by\nIκ(a) =\n\n \n \nt if a ∈ Iκ , bt if Ka ∈ Iκ and a 6∈ Iκ ,\n⊥ otherwise.\nThe semi-stable models of a programP are obtained from its epistemic κ-transformation Pκ .\nDefinition 1 (Epistemic κ-transformation Pκ ) Let P be a program. Then its epistemic κ-transformation is defined as the program Pκ obtained from P by replacing each rule r of the form (1) in P, such that B−(r) 6= /0, with:\nλr,1∨ . . .∨λr,l ∨Kbm+1∨ . . .∨Kbn ← b1, . . . ,bm, (2)\nai ← λr,i, (3)\n← λr,i,b j, (4)\nλr,i ← ai,λr,k, (5)\nfor 1≤ i,k ≤ l and m+ 1≤ j ≤ n, where the λr,i, λr,k are fresh atoms.\nNote that for any program P, its epistemic κ-transformation Pκ is positive. For every interpretation Iκ over Σ′ ⊇ Σκ , let G (Iκ ) = {Ka ∈ Iκ | a 6∈ Iκ} denote the atoms believed true but not assigned true, also referred to as the gap of Iκ . Given a set F of interpretations over Σ′, an interpretation Iκ ∈ F is maximal canonical in F , if no Jκ ∈ F exists such that G (Iκ)⊃ G (Jκ). By mc(F ) we denote the set of maximal canonical interpretations inF . Semi-stable models are then defined asmaximal canonical interpretations among the answer sets of Pκ . Then we can equivalently paraphrase the definition of semi-stable models in [34] as follows.\nDefinition 2 (Semi-stable models) Let P be a program over Σ. An interpretation Iκ over Σκ is a semi-stable model of P, if Iκ = S∩Σκ for some maximal canonical answer set S of Pκ . The set of all semi-stable models of P is denoted by SST(P), i.e., SST(P) = {S∩Σκ | S ∈mc(AS(Pκ))}.\nExample 1 Consider the program P = {b ← not a; c ← not b; a ← c; d ← not d}. Its epistemic κ-transformation is Pκ = {λ1∨Ka; b← λ1; ← a,λ1; λ1 ← b,λ1; λ2∨ Kb; c ← λ2; ← b,λ2; λ2 ← c,λ2; a← c; λ3 ∨Kd; d ← λ3; ← d,λ3; λ3 ← d,λ3;}, which has the answer sets M1 = {Ka,Kb,Kd}, M2 = {λ1,b,Kb,Kd}, andM3 = {Ka,λ2,a,c,Kd}; as G (M1) = {Ka,Kb,Kd}, G (M2) = {Kd}, and G (M3) = {Kd}. Therefore, among them M2 and M3 are maximal canonicals, and hence M2 ∩ Σ\nκ = {b,Kb,Kd} and M3∩Σ\nκ = {a,c,Ka,Kd} are semi-stable models of P, that also correspond to answer sets of P.\nSemi-EquilibriumModels. Semi-equilibriummodelswere introduced by [4] to avoid some anomalies in semi-stable model semantics. Like semi-stable models, semi-equilibrium models may be computed as maximal canonical answer sets, of an extension of the epistemic κ-transformation.\nDefinition 3 (Epistemic HT -transformation PHT ) Let P be a program over Σ. Then its epistemic HT-transformation PHT is defined as the union of Pκ with the set of rules:\nKa← a, (6)\nKa1∨ . . .∨Kal ∨Kbm+1∨ . . .∨Kbn ← Kb1, . . . ,Kbm, (7)\nfor a ∈ Σ, respectively for every rule r ∈ P of the form (1).\nDefinition 4 (Semi-equilibrium models) Let P be a program over Σ, and let Iκ be an interpretation over Σκ . Then, Iκ ∈ SEQ(P) if, and only if, Iκ ∈ {M ∩Σκ | M ∈ mc(AS(PHT ))}, where SEQ(P) is the set of semi-equilibrium models of P.\nExample 2 Consider the program P of Example 1. Its epistemic HT-transformation PHT is Pκ ∪{Ka← a; Kb← b; Kc← c; Kd← d; Kb∨Ka; Kc∨Kb; Ka←Kc; Kd← Kd}, which has the answer sets {Ka,Kb,Kd}, {λ1,b,Kb,Kd}, and {Ka,λ2,a,c,Kc,Kd}. Therefore, the semi-equilibrium models of P are {b,Kb,Kd} and {a,c,Ka,Kc,Kd}.\nIn the following, we refer to semi-stable models or semi-equilibrium models as\nparacoherent answer sets.\nComplexity Considerations. The complexity of various reasoning tasks with paracoherent answer sets has been analyzed in [4]: while determining the existence of paracoherent answer sets is NP-complete (it is sufficient to test for existence of classical models), paracoherent answer set checking is ΠP2 -complete, leading to Σ P 3 -completeness for brave, and ΠP3 -completeness for cautious reasoning. In this paper, we consider the computation of one paracoherent answer set, which is a functional problem. From previous work it is clear that this task is in FΣP3 , and actually in FΘ P 3 (functional polynomial time with a logarithmic number of calls to a ΣP2 -complete oracle), because for computing one paracoherent answer set it is sufficient to solve a cardinality-optimization problem."
    }, {
      "heading" : "3 Computation of a Paracoherent Answer Set",
      "text" : "In this section we propose different algorithms to compute one paracoherent answer set. The algorithms take as input a program Π = Pχ ∪Pg, where P χ is a generic epistemic\nAlgorithm 1: Filtering\n1 M := nextAnswerSet(Π,⊥); Mw :=M; 2 Mw := nextAnswerSet(Π,Mw); 3 ifMw =⊥ then returnM; 4 if gap(Mw)⊂ gap(M) thenM :=Mw; 5 goto 2;\nAlgorithm 2: Guess&Check\n1 M =⊥; 2 M = nextAnswerSet(Π,M); 3 Mw = nextAnswerSet(Π∪ΠM,⊥); 4 ifMw =⊥ then returnM; else goto 2;\ntransformation of the ASP program P and Pg is the following set of rules capturing the notion of gap:\ngap(Ka)← Ka, not a; ∀a ∈ At(P) (8)\nProposition 1 Let gap(I) = {gap(Ka) | gap(Ka)∈ I}, for a set I of atoms. An answer set M of Π is a paracoherent answer set if, and only if, there exists no answer set M1 of Π such that gap(M1)⊂ gap(M).\nExample 3 Consider again the program Pκ of Example 1, then Π is the union of Pκ with the following set of rules:\ngap(Ka)← Ka, not a; gap(Kb)← Kb, not b; gap(Kc)← Kc, not c; gap(Kd)← Kd, not d;\nwhich admits the answer sets M′1 =M1 ∪{gap(Ka),gap(Kb),gap(Kd)}, M ′ 2 =M2 ∪ {gap(Kd)}, andM′3 =M3∪{gap(Kd)}. Then, gap(M ′ 1)= {gap(Ka),gap(Kb),gap(Kd)}, gap(M′2) = gap(M ′ 3) = {gap(Kd)}, thus M ′ 2 and M ′ 3 are paracoherent answer sets.\nThe output of the algorithms is one semi-stable model of P (if χ = κ) or one semiequilibrium model of P (if χ = HT ). In the following, without loss of generality we assume that Π admits at least one paracoherent answer set. In fact, by properties of semi-stable and semi-equilibrium models, this kind of programs admit always a paracoherent answer set [4].\nMoreover, in order to ease the description of the algorithms presented in this section, we introduce the enumeration function nextAnswerSet, that takes as input the program Π and an answer set M of Π, and returns as output the next one according to some internal criteria or⊥ if no other answer set exists. We abuse of the notation using M =⊥ to indicate that the function computes the first answer set.\nFiltering. An immediate algorithm for finding a paracoherent answer set is Filtering, Algorithm 1. The underlying idea is to enumerate all answer sets of Π and to store the one that is subset-minimal with respect to gap atoms. The algorithm first finds an\nAlgorithm 3:Minimize\n1 M := nextAnswerSet(Π,⊥); 2 Π := Π∪ΠM; 3 Mw := nextAnswerSet(Π,⊥); 4 ifMw =⊥ then returnM; else M :=Mw; goto 2;\nAlgorithm 4: Split\n1 M := nextAnswerSet(Π,⊥); C := gap(M); 2 ifC = /0 then returnM; 3 Π := Π∪ΠM; a := OneO f (C); 4 Mw := nextAnswerSet(Π∪{← a},⊥); 5 ifMw =⊥ then {Π := Π∪{← not a};C :=C \\ {a};} else {M :=Mw; C := gap(Mw);} goto 2;\nanswer set M of Π. Then, another answer set Mw is searched (line 2). If gap(Mw) is a subset of gap(M) then M is replaced with Mw. Subsequently, the algorithm continues the search until all answer sets have been enumerated. Intuitively, at each step of the computationM is a subset-minimal answer set with respect to the answer sets enumerated so far. Thus, when all answer sets have been enumerated thenM is a paracoherent answer set.\nExample 4 Consider again program Π of Example 3. The first call to nextAnswerSet returns M′1 that is stored in M. The second call to nextAnswerSet returns M ′ 2, gap(M ′ 2) is a subset of gap(M′1) therefore M is replaced by M ′ 2. The third call of nextAnswerSet returns M′3 and M is not modified since gap(M ′ 3)\n′ is not a subset of gap(M). No other answer sets can be enumerated, thus the algorithm terminates returning M.\nThe main drawback of Algorithm 1 is that it always computes all answer sets of Π,\na potentially exponential number in the size of the atoms of the original program.\nIn the following we present different algorithms for addressing this inefficiency.\nGuess&Check. This algorithm, Algorithm 2, improves Algorithm 1 by reducing the number of computed answer sets. In order to ease the description of the remaining algorithms we introduce the following.\nDefinition 5 Given a program Π defined as above. Let M be a model of Π, then ΠM is the following set of constraints:\n← gap(M); (9)\n← gap(Ka); ∀gap(Ka) ∈ At(Π)\\M. (10)\nNote that (9) contains all atoms in gap(M).\nTheorem 1 Let P be a logic program, let Π be defined as above, and let M ∈ AS(Π). Then, AS(Π∪ΠM) 6= /0 if, and only if, M is not a paracoherent answer set of P.\nExample 5 Consider again program Π of Example 3. ΠM′1 is composed by the following set of constraints:\n← gap(Ka),gap(Kb),gap(Kd); ← gap(Kc);\nwhereas ΠM′2 is composed by the following set of constraints:\n← gap(Kd); ← gap(Ka); ← gap(Kb); ← gap(Kc).\nNote that AS(Π∪ΠM′1 ) = {M′2,M ′ 3} and AS(Π∪ΠM′2 ) = /0.\nThe Guess&Check algorithm finds an answer setM of Π. Subsequently, an answer set of the program Π∪ΠM is sought. If such an answer set does not exist then M is a paracoherent answer set and the algorithm terminates returning M. Otherwise, the algorithm iterates the computation until a paracoherent answer set is found.\nExample 6 Consider again program Π of Example 3. The first answer set computed by nextAnswerSet is M′1. The subsequent check is performed on the program Π∪ΠM′1 , that is coherent. Thus, M′1 is not a paracoherent answer set. Then, nextAnswerSet is called again and it returns M′2. At this point, Π∪ΠM′2 is incoherent, therefore the algorithm terminates returning M′2.\nAlgorithm 2 terminates as soon as a paracoherent answer set of P is found. How-\never, in the worst case, it still needs to enumerate all answer sets.\nMinimize. The next algorithm is called Minimize and it is reported as Algorithm 3. The idea is to compute an answer setM of Π and then to search for another answer set Mw such that gap(Mw)⊂ gap(M). This property is enforced by the constraints of ΠM that are added to the program Π (line 2). If Π admits an answer set, say Mw, then M is replaced byMw and the algorithm iterates minimizingM. Otherwise, if Π admits no answer set, M is a paracoherent answer set and the algorithm terminates returningM.\nExample 7 Consider again program Π of Example 3. The first answer set computed by nextAnswerSet is M′1. Thus, the constraints of ΠM′1 are added to Π. The subsequent check on Π returns an answer set, say M′2, and then Π is modified by adding the constraints of ΠM′2 . At this point, Π is incoherent, therefore the algorithm terminates returning M′2.\nAlgorithm 3 computes at most |At(P)| answer sets.\nSplit. Another algorithm for computing a paracoherent answer set is called Split, Algorithm 4. The algorithm first computes an answer set M of Π and creates a set C of gap atoms that are included in M. Then, the program Π is modified by adding the constraints of ΠM. Moreover, one of the atoms in C is selected by the procedure OneO f , say a. Subsequently, an answer set of Π∪ {← a} is searched. If such an answer set does not exist then a must be included in the paracoherent answer set and thus Π is modified by adding the constraint ← not a and a is removed from the set C. Otherwise, if Π∪{← a} admits an answer set, say Mw, thenM is replaced byMw and the set C is replaced by the gap atoms that are true in Mw. The algorithm then iterates until the set C is empty, returningM that corresponds to the paracoherent answer set.\nExample 8 Consider again program Π of Example 3. The first answer set computed by nextAnswerSet is M′1. Thus, C is set to {gap(Ka),gap(Kb),gap(Kc)} and the constraints of ΠM′1 are added to Π. Then, function OneO f selects one of the atoms in C, say gap(Ka). The subsequent check on Π∪{← gap(Ka)} returns an answer set, say M′2. Therefore, C is set to gap(Kd) and Π is modified by adding the constraints of ΠM′2 . Then, the function OneO f selects gap(Kd) and the subsequent check on Π∪{← gap(Kd)} returns ⊥. Subsequently, Π is modified by adding the constraint ← not gap(Kd) and C is updated by removing gap(Kd). At this point, C is empty, therefore the algorithm terminates returning the latest computed answer set, i.e. M′2.\nNote that Algorithm 4 requires to compute at most |At(P)| answer sets.\nWeak constraints. All the algorithms presented above require the modification of an ASP solver to be implemented. An alternative approach is based on the observation that the gap minimality can be obtained adding to Π the following set of weak constraints, sayW :\ngap(Ka); ∀a ∈ At(P). (11)\nThe answer set of the extended program is then an answer set of Π such that a minimal number of weak constraints in W is violated. This means that this answer set that is cardinality minimal with respect to the gap atoms. Therefore, it is also subset minimal with respect to the gap atoms, and so, it is a paracoherent answer set of P.\nTheorem 2 Let P be a program, let Π andW be defined as above. If M ∈ ASO(Π∪W), then M \\ gap(M) is a paracoherent answer set of P.\nNote that, the reverse statement does not hold in general. For example, consider the program P = {b← not a; c ← a; d ← b,not d}. Its semi-equilibrium models are {b,Kd} and {Ka,Kc}. However, {Ka,Kc,gap(Ka),gap(Kc)} is not an optimum answer set of Π∪W ."
    }, {
      "heading" : "4 Implementation and Experiments",
      "text" : "We implemented the algorithms presented in this paper, and we report on an experiment comparing their performance.\nImplementation. The computation of a paracoherent answer set is obtained in two steps. First a Java rewriter computes the epistemic transformations Pκ and PHT of a propositional ASP program. Then the output of the rewriter is fed in input to a variant of the state-of-the-art ASP solver WASP [2]. WASP is an open-source ASP solver, winner of the latest ASP competition [20], that we modified by implementing the algorithms presented in the previous section (the source can be downloaded at https://github.com/alviano/wasp).\nBenchmarks settings. Experimentswere run on a Debian Linux systemwith 2.30GHz Intel Xeon E5-4610 v2 CPUs and 128GB of RAM. Execution time and memory were limited to 1200 seconds and 3 GB, respectively. We use benchmark instances from the latest ASP competition [20] collection. We consider all the incoherent instances that do not feature in the encoding neither aggregates, nor choice rules, nor weak constraints, since such features are not currently supported by the paracoherent semantics [4]. This resulted in instances from the following domains: Knight Tour, Minimal Diagnosis, Qualitative Spatial Reasoning, Stable Marriage and Visit All. Instances were grounded with GRINGO (from http://potassco.sourceforge.net/ ). Grounding times, the same for all compared methods, are not reported.\nResults of the experiments. A summary of the result is reported in Table 5, where the number of solved instances for each considered semantics is reported. In the table, Filt is WASP running Algorithm 1, G&C is WASP running Algorithm 2, Minim is WASP running Algorithm 3, Split is WASP running Algorithm 4, and Weak is WASP running the algorithm based on weak constraints.\nAs a general comment, the algorithm based on the enumeration of answer sets is highly inefficient solving no instances at all. The Guess&Check algorithm outperforms the Filtering algorithm demonstrating that in many cases the enumeration of all answer sets is not needed. The best performing algorithms are Minimize and Split solving both the same number of instances. The performance of the two algorithms are similar also considering the running times. In fact, this is evident by looking at the instance-wise comparison reported in the scatter plot of Figure 1. A point (x,y) in the scatter plot is reported for each instance, where x is the solving time of the algorithm Minimize whereas y is the solving time of the algorithm Split. Concerning the algorithm based on weak constraints, it can be observed that its performance is better than the one of algorithm Filtering. However, it does not reach the efficiency of the algorithms Guess&Check, Minimize and Split.\nConcerning the semi-equilibrium semantics, it can be observed that the performance of all algorithms deteriorates. This can be explained by looking at the number of rules introduced by the epistemic HT-transformation, reported in Table 2. In fact, the epistemic HT-transformation introduces approximately twice the number of rules introduced by the epistemic κ-transformation. Moreover, we observe that also in this case the best performing algorithms are Minimize and Split. The latter is slightly more efficient than the former.\nFocusing on the performance of the algorithms on the different benchmarks, it can be observed that none of the algorithms was effective on the problems KnightTour and StableMarriage. Concerning KnightTour, we observed that WASP is not able to find any answer set of the epistemic transformations for 12 out of 26 instances. Basically, no algorithm can be effective on such 12 instances, and the remaining ones are hard due to the subsequent checks. Concerning StableMarriage, we observed that java rewriter\ncould not produce the epistemic transformation within the allotted time, because the unique instance of this domain features more than 100 millions rules. The presented algorithms (but Filtering) are able to solve all the considered instances of VisitAll problem, where the epistemic transformations results in a very limited number of atoms and rules (see Table 2)."
    }, {
      "heading" : "5 Related Work",
      "text" : "Paracoherent Semantics. Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30]. However, [4] have shown that only semi-stable semantics [34] and semi-equilibrium semantics [4] satisfy the following desiderata properties: (i) every consistent answer set of a program corresponds to a paracoherent answer set (answer set coverage); (ii) if a program has some (consistent) answer set, then its paracoherent answer sets correspond to answer sets (congruence); (iii) if a program has a classical model, then it has a paracoherent answer set (classical coherence); (iv) a minimal set of atoms should be undefined (minimal undefinedness); (v) every true atom must be derived from the program (justifiability).\nComputational aspects. Our approach to the computation of paracoherent answer sets is related to the computation of minimal models of propositional theories. The first approaches were proposed for implementing circumscriptive reasoning (cfr. [16]). Later the attention shifted to the computation of minimalmodels of first-order clauses [29, 23]. [29] proposed a tableaux-based method where candidate models are generated and then tested for minimality. [23] proposed a method able to reduce minimality tests on candidate models. The usage of hyperresolution for minimal models of first-order clauses was presented in [9] and implemented in Prolog. As observed in [26] these approaches do not take profit of modern non-chronological-backtracking-based solving technology. This limit was overcome in [26] by an algorithm for computing minimal models of SAT formulas that is based on the same principle as the Minimize algorithm. The computation of minimal models of SAT formulae can be reduced to computing a Minimal Set over a Monotone Predicate (MSMP) [25]. Thus algorithms for MSMP such as those described in [28] could be adapted (by properly taking into account the jump in computational complexity) for computing paracoherent answer sets. Efficient\npolynomial algorithms for a subclass of positive CNF theories was proposed in [6]. That method cannot be applied directly to find a model of Π that is minimal on the extension of gap predicate. The Split algorithm is similar to the algorithms employed for computing cautious consequences of ASP programs [3] and backbones of SAT formulas [24]; nonetheless, to the best of our knowledge, it has no related counterpart in the literature concerning the computation of minimal models."
    }, {
      "heading" : "6 Conclusion",
      "text" : "In this paper, we have tackled the problem of computing paracoherent answer sets, namely semi-stable and stable-equilibrium models, which has not been addressed so far. We have proposed a number of algorithms relying on a program transformation with subsequent calls to an answer set solver. We have conducted an experimental analysis of these algorithms using incoherent programs of the ASP competition, the analysis of incoherent answer set programs being the prime application that we envision for paracoherent answer sets. The experiments show that algorithms Minimize and Split outperform other tested algorithms. The results also show that the computation of a paracoherent answer set is a difficult problem not just theoretically, but also in practice."
    }, {
      "heading" : "Acknowledgements",
      "text" : "This work was partially supported by the EU H2020 Marie Skłodowska-Curie grant agreement No 690974 “MIREL”, MIUR within project “SI-LAB BA2KNOW”, by MISE under project “PIUCultura”, N. F/020016/01-02/X27, and by GNCS-INDAM."
    } ],
    "references" : [ {
      "title" : "An encompassing framework for paraconsistent logic programs",
      "author" : [ "J. Alcântara", "C.V. Damásio", "L.M. Pereira" ],
      "venue" : "J. Applied Logic, 3(1):67–95",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Advances in WASP",
      "author" : [ "M. Alviano", "C. Dodaro", "N. Leone", "F. Ricca" ],
      "venue" : "LPNMR 2015, pages 40–54",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Anytime computation of cautious consequences in answer set programming",
      "author" : [ "M. Alviano", "C. Dodaro", "F. Ricca" ],
      "venue" : "TPLP, 14(4-5):755–770",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Semi-equilibriummodels for paracoherent answer set programs",
      "author" : [ "G. Amendola", "T. Eiter", "M. Fink", "N. Leone", "J. Moura" ],
      "venue" : "Artif. Intell., 234:219–271",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Modeling and reasoning about NTU games via answer set programming",
      "author" : [ "G. Amendola", "G. Greco", "N. Leone", "P. Veltri" ],
      "venue" : "IJCAI 2016, pages 38–45",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "On the tractability of minimal model computation for some CNF theories",
      "author" : [ "F. Angiulli", "R. Ben-Eliyahu", "F. Fassetti", "L. Palopoli" ],
      "venue" : "Artif. Intell., 210:56–77",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Logic programs with consistency-restoring rules",
      "author" : [ "M. Balduccini", "M. Gelfond" ],
      "venue" : "ISLFCR, AAAI 2003 Spring Symposium Series, pages 9–18",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Answer set programming at a glance",
      "author" : [ "G. Brewka", "T. Eiter", "M. Truszczynski" ],
      "venue" : "Com. ACM, 54(12):92–103",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Positive unit hyperresolution tableaux and their application to minimal model generation",
      "author" : [ "F. Bry", "A.H. Yahya" ],
      "venue" : "J. Autom. Reasoning, 25(1):35–82",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Enhancing disjunctive datalog by constraints",
      "author" : [ "F. Buccafurri", "N. Leone", "P. Rullo" ],
      "venue" : "IEEE Trans. Knowl. Data Eng., 12(5):845–860",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Design and results of the fifth answer set programming competition",
      "author" : [ "F. Calimeri", "M. Gebser", "M. Maratea", "F. Ricca" ],
      "venue" : "Artif. Intell., 231:151–181",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "A declarative concurrent system for protein structure prediction on GPU",
      "author" : [ "F. Campeotto", "A. Dovier", "E. Pontelli" ],
      "venue" : "J. Exp. Theor. Artif. Intell., 27(5):503–541",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Combining Answer Set Programming and domain heuristics for solving hard industrial problems (Application Paper)",
      "author" : [ "C. Dodaro", "P. Gasteiger", "N. Leone", "B. Musitsch", "F. Ricca", "K. Shchekotykhin" ],
      "venue" : "TPLP, 16(5-6):653–669",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Allotment problem in travel industry: A solution based on ASP",
      "author" : [ "C. Dodaro", "N. Leone", "B. Nardi", "F. Ricca" ],
      "venue" : "B. ten Cate and A. Mileo, editors, RR 2015, volume 9209 of LNCS, pages 77–92. Springer",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "On the partial semantics for disjunctive deductive databases",
      "author" : [ "T. Eiter", "N. Leone", "D. Saccà" ],
      "venue" : "Ann. Math. Artif. Intell., 19(1-2):59–96",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "editors",
      "author" : [ "D.M. Gabbay", "C.J. Hogger", "J.A. Robinson", "J.H. Siekmann" ],
      "venue" : "Handbook of Logic in Artificial Intelligence and Logic Programming, Volume2, Deduction Methodologies. Oxford University Press",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Improved answerset programming encodings for abstract argumentation",
      "author" : [ "S. Gaggl", "N. Manthey", "A. Ronca", "J. Wallner", "S. Woltran" ],
      "venue" : "TPLP, 15(4-5):434–448",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "J",
      "author" : [ "M.J.O. Galindo" ],
      "venue" : "R. A. Ramı́rez, and J. L. Carballido. Logical weak completions of paraconsistent logics. J. Log. Comput., 18(6):913–940",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Answer Set Solving in Practice",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Morgan & Claypool Publishers",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "The design of the sixth answer set programming competition - report ",
      "author" : [ "M. Gebser", "M. Maratea", "F. Ricca" ],
      "venue" : "LPNMR 2015, pages 531–544",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Comput., 9(3/4):365–386",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "ASP at work: Spin-off and applications of the DLV system",
      "author" : [ "G. Grasso", "N. Leone", "M. Manna", "F. Ricca" ],
      "venue" : "Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning, LNCS 6565, pages 432–451",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Efficient minimal model generation using branching lemmas",
      "author" : [ "R. Hasegawa", "H. Fujita", "M. Koshimura" ],
      "venue" : "CADE-17, 2000, pages 184–199",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Algorithms for computing backbones of propositional formulae",
      "author" : [ "M. Janota", "I. Lynce", "J. Marques-Silva" ],
      "venue" : "AI Commun., 28(2):161–177",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "On the query complexity of selecting minimal sets for monotone predicates",
      "author" : [ "M. Janota", "J. Marques-Silva" ],
      "venue" : "Artif. Intell., 233:73–83",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Minimal model generation with respect to an atom set",
      "author" : [ "M. Koshimura", "H. Nabeshima", "H. Fujita", "R. Hasegawa" ],
      "venue" : "FTP 2009, CEUR 556",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Taming primary key violations to query large inconsistent data via ASP",
      "author" : [ "M. Manna", "F. Ricca", "G. Terracina" ],
      "venue" : "TPLP, 15(4-5):696–710",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Minimal sets over monotone predicates in boolean formulae",
      "author" : [ "J. Marques-Silva", "M. Janota", "A. Belov" ],
      "venue" : "CAV 2013, pages 592–607",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "A tableau calculus for minimal model reasoning",
      "author" : [ "I. Niemelä" ],
      "venue" : "TABLEAUX 1996, pages 278–294",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "J",
      "author" : [ "M. Osorio" ],
      "venue" : "R. A. Ramı́rez, and J. L. Carballido. Logical weak completions of paraconsistent logics. J. Log. Comput., 18(6):913–940",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Equilibrium logic",
      "author" : [ "D. Pearce" ],
      "venue" : "Ann. Math. Artif. Intell., 47(1-2):3–41",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Revised stable models - a semantics for logic programs",
      "author" : [ "L.M. Pereira", "A.M. Pinto" ],
      "venue" : "EPIA, pages 29–42",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Stable semantics for disjunctive programs",
      "author" : [ "T.C. Przymusinski" ],
      "venue" : "New Generation Comput., 9(3/4):401–424",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Paraconsistent stable semantics for extended disjunctive programs",
      "author" : [ "C. Sakama", "K. Inoue" ],
      "venue" : "J. Log. Comput., 5(3):265–285",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Partial evidential stable models for disjunctive deductive databases",
      "author" : [ "D. Seipel" ],
      "venue" : "LPKR, pages 66–84",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "The well-founded semantics for general logic programs",
      "author" : [ "A. van Gelder", "K. Ross", "J. Schlipf" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 1991
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "Answer Set Programming (ASP) is a premier formalism for nonmonotonic reasoning (see, [8, 19]).",
      "startOffset" : 85,
      "endOffset" : 92
    }, {
      "referenceID" : 18,
      "context" : "Answer Set Programming (ASP) is a premier formalism for nonmonotonic reasoning (see, [8, 19]).",
      "startOffset" : 85,
      "endOffset" : 92
    }, {
      "referenceID" : 20,
      "context" : "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 16,
      "context" : "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 11,
      "context" : "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].",
      "startOffset" : 164,
      "endOffset" : 168
    }, {
      "referenceID" : 26,
      "context" : "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].",
      "startOffset" : 180,
      "endOffset" : 184
    }, {
      "referenceID" : 4,
      "context" : "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].",
      "startOffset" : 198,
      "endOffset" : 201
    }, {
      "referenceID" : 13,
      "context" : "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].",
      "startOffset" : 271,
      "endOffset" : 283
    }, {
      "referenceID" : 21,
      "context" : "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].",
      "startOffset" : 271,
      "endOffset" : 283
    }, {
      "referenceID" : 12,
      "context" : "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].",
      "startOffset" : 271,
      "endOffset" : 283
    }, {
      "referenceID" : 3,
      "context" : "To distinguish this situation from reasoning under classical logical contradiction due to strong negation, called paraconsistent reasoning, it has been referred to it as paracoherent reasoning [4].",
      "startOffset" : 193,
      "endOffset" : 196
    }, {
      "referenceID" : 33,
      "context" : "In order to deal with this, [34] introduced the semi-stable model semantics that coincides with answer set semantics whenever a program has some answer set, but admits paracoherent models for each classically consistent program.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 3,
      "context" : "Recently, [4] have improved this kind of semantics avoiding some anomalies with respect to basic modal logic properties, resorting to the equilibrium logic [31].",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 30,
      "context" : "Recently, [4] have improved this kind of semantics avoiding some anomalies with respect to basic modal logic properties, resorting to the equilibrium logic [31].",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 3,
      "context" : "Different possible applications of these paracoherent semantics have been identified, such as debugging, model building, inconsistency-tolerant query answering, diagnosis, planning and reasoning about actions; and computational complexity aspects have been studied [4].",
      "startOffset" : 265,
      "endOffset" : 268
    }, {
      "referenceID" : 10,
      "context" : "Finally, we report the results of an experimental activity conducted on benchmarks from ASP competitions [11], identifying the more efficient algorithm.",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 20,
      "context" : ", the set of all interpretations I such that I ∈MM(P), where P is the well-known Gelfond-Lifschitz reduct [21] of P with respect to I, i.",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 9,
      "context" : "Now, we recall a useful extension of the answer set semantics by the notion of weak constraint [10].",
      "startOffset" : 95,
      "endOffset" : 99
    }, {
      "referenceID" : 3,
      "context" : "These semantics satisfy three desiderata properties identified by [4].",
      "startOffset" : 66,
      "endOffset" : 69
    }, {
      "referenceID" : 33,
      "context" : "Inoue and Sakama ([34]) introduced semi-stable model semantics.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 33,
      "context" : "Then we can equivalently paraphrase the definition of semi-stable models in [34] as follows.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 3,
      "context" : "Semi-equilibriummodelswere introduced by [4] to avoid some anomalies in semi-stable model semantics.",
      "startOffset" : 41,
      "endOffset" : 44
    }, {
      "referenceID" : 3,
      "context" : "The complexity of various reasoning tasks with paracoherent answer sets has been analyzed in [4]: while determining the existence of paracoherent answer sets is NP-complete (it is sufficient to test for existence of classical models), paracoherent answer set checking is ΠP2 -complete, leading to Σ P 3 -completeness for brave, and Π3 -completeness for cautious reasoning.",
      "startOffset" : 93,
      "endOffset" : 96
    }, {
      "referenceID" : 3,
      "context" : "In fact, by properties of semi-stable and semi-equilibrium models, this kind of programs admit always a paracoherent answer set [4].",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 1,
      "context" : "Then the output of the rewriter is fed in input to a variant of the state-of-the-art ASP solver WASP [2].",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 19,
      "context" : "WASP is an open-source ASP solver, winner of the latest ASP competition [20], that we modified by implementing the algorithms presented in the previous section (the source can be downloaded at https://github.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 19,
      "context" : "We use benchmark instances from the latest ASP competition [20] collection.",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 3,
      "context" : "We consider all the incoherent instances that do not feature in the encoding neither aggregates, nor choice rules, nor weak constraints, since such features are not currently supported by the paracoherent semantics [4].",
      "startOffset" : 215,
      "endOffset" : 218
    }, {
      "referenceID" : 32,
      "context" : "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].",
      "startOffset" : 130,
      "endOffset" : 164
    }, {
      "referenceID" : 35,
      "context" : "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].",
      "startOffset" : 130,
      "endOffset" : 164
    }, {
      "referenceID" : 14,
      "context" : "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].",
      "startOffset" : 130,
      "endOffset" : 164
    }, {
      "referenceID" : 34,
      "context" : "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].",
      "startOffset" : 130,
      "endOffset" : 164
    }, {
      "referenceID" : 6,
      "context" : "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].",
      "startOffset" : 130,
      "endOffset" : 164
    }, {
      "referenceID" : 31,
      "context" : "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].",
      "startOffset" : 130,
      "endOffset" : 164
    }, {
      "referenceID" : 0,
      "context" : "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].",
      "startOffset" : 130,
      "endOffset" : 164
    }, {
      "referenceID" : 17,
      "context" : "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].",
      "startOffset" : 130,
      "endOffset" : 164
    }, {
      "referenceID" : 29,
      "context" : "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].",
      "startOffset" : 130,
      "endOffset" : 164
    }, {
      "referenceID" : 3,
      "context" : "However, [4] have shown that only semi-stable semantics [34] and semi-equilibrium semantics [4] satisfy the following desiderata properties: (i) every consistent answer set of a program corresponds to a paracoherent answer set (answer set coverage); (ii) if a program has some (consistent) answer set, then its paracoherent answer sets correspond to answer sets (congruence); (iii) if a program has a classical model, then it has a paracoherent answer set (classical coherence); (iv) a minimal set of atoms should be undefined (minimal undefinedness); (v) every true atom must be derived from the program (justifiability).",
      "startOffset" : 9,
      "endOffset" : 12
    }, {
      "referenceID" : 33,
      "context" : "However, [4] have shown that only semi-stable semantics [34] and semi-equilibrium semantics [4] satisfy the following desiderata properties: (i) every consistent answer set of a program corresponds to a paracoherent answer set (answer set coverage); (ii) if a program has some (consistent) answer set, then its paracoherent answer sets correspond to answer sets (congruence); (iii) if a program has a classical model, then it has a paracoherent answer set (classical coherence); (iv) a minimal set of atoms should be undefined (minimal undefinedness); (v) every true atom must be derived from the program (justifiability).",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 3,
      "context" : "However, [4] have shown that only semi-stable semantics [34] and semi-equilibrium semantics [4] satisfy the following desiderata properties: (i) every consistent answer set of a program corresponds to a paracoherent answer set (answer set coverage); (ii) if a program has some (consistent) answer set, then its paracoherent answer sets correspond to answer sets (congruence); (iii) if a program has a classical model, then it has a paracoherent answer set (classical coherence); (iv) a minimal set of atoms should be undefined (minimal undefinedness); (v) every true atom must be derived from the program (justifiability).",
      "startOffset" : 92,
      "endOffset" : 95
    }, {
      "referenceID" : 15,
      "context" : "[16]).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "Later the attention shifted to the computation of minimalmodels of first-order clauses [29, 23].",
      "startOffset" : 87,
      "endOffset" : 95
    }, {
      "referenceID" : 22,
      "context" : "Later the attention shifted to the computation of minimalmodels of first-order clauses [29, 23].",
      "startOffset" : 87,
      "endOffset" : 95
    }, {
      "referenceID" : 28,
      "context" : "[29] proposed a tableaux-based method where candidate models are generated and then tested for minimality.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "[23] proposed a method able to reduce minimality tests on candidate models.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 8,
      "context" : "The usage of hyperresolution for minimal models of first-order clauses was presented in [9] and implemented in Prolog.",
      "startOffset" : 88,
      "endOffset" : 91
    }, {
      "referenceID" : 25,
      "context" : "As observed in [26] these approaches do not take profit of modern non-chronological-backtracking-based solving technology.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 25,
      "context" : "This limit was overcome in [26] by an algorithm for computing minimal models of SAT formulas that is based on the same principle as the Minimize algorithm.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 24,
      "context" : "The computation of minimal models of SAT formulae can be reduced to computing a Minimal Set over a Monotone Predicate (MSMP) [25].",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 27,
      "context" : "Thus algorithms for MSMP such as those described in [28] could be adapted (by properly taking into account the jump in computational complexity) for computing paracoherent answer sets.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 5,
      "context" : "polynomial algorithms for a subclass of positive CNF theories was proposed in [6].",
      "startOffset" : 78,
      "endOffset" : 81
    }, {
      "referenceID" : 2,
      "context" : "The Split algorithm is similar to the algorithms employed for computing cautious consequences of ASP programs [3] and backbones of SAT formulas [24]; nonetheless, to the best of our knowledge, it has no related counterpart in the literature concerning the computation of minimal models.",
      "startOffset" : 110,
      "endOffset" : 113
    }, {
      "referenceID" : 23,
      "context" : "The Split algorithm is similar to the algorithms employed for computing cautious consequences of ASP programs [3] and backbones of SAT formulas [24]; nonetheless, to the best of our knowledge, it has no related counterpart in the literature concerning the computation of minimal models.",
      "startOffset" : 144,
      "endOffset" : 148
    } ],
    "year" : 2017,
    "abstractText" : "Answer Set Programming (ASP) is a well-established formalism for nonmonotonic reasoning. An ASP program can have no answer set due to cyclic default negation. In this case, it is not possible to draw any conclusion, even if this is not intended. Recently, several paracoherent semantics have been proposed that address this issue, and several potential applications for these semantics have been identified. However, paracoherent semantics have essentially been inapplicable in practice, due to the lack of efficient algorithms and implementations. In this paper, this lack is addressed, and several different algorithms to compute semi-stable and semi-equilibrium models are proposed and implemented into an answer set solving framework. An empirical performance comparison among the new algorithms on benchmarks from ASP competitions is given as well.",
    "creator" : "LaTeX with hyperref package"
  }
}