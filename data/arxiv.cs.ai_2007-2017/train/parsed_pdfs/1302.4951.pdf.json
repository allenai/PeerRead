{
  "name" : "1302.4951.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Transforming Prioritized Defaults and Specificity into Parallel Defaults",
    "authors" : [ "BenjaDlin N. Grosof", "IBM T. J. Watson" ],
    "emails" : [ "grosof@watson.ibm.com", "grosof@cs.stanford.edu)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We show how to transform any set of priori tized propositional defaults into an equivalent set of parallel (i.e. , unprioritized) defaults, in circumscription. We give an algorithm to im plement the transform. We show how to use the transform algorithm as a generator of a whole family of inferencing algorithms for cir cumscription. The method is to employ the transform algorithm as a front end to any in ferencing algorithm, e.g . , one of the previously available, that handles the parallel (empty) case of prioritization. Our algorithms provide not just coverage of a new expressive class, but also alternatives to previous algorithms for im plementing the previously covered class (lay ered) of prioritization. In particular, we give a new query-answering algorithm for prioritized cirumscription which is sound and complete for the full expressive class of unrestricted finite prioritization par tial orders, for propositional defaults (or mini mized predicates). By contrast, previous algo rithms required that the prioritization partial order be layered, i .e . , structured similar to the system of rank in the military. Our algorithm enables, for the first time, the implementation of the most useful class of pri oritization: non-layered prioritization partial orders. Default inheritance, for example, typi cally requires non-layered prioritization to rep resent specificity adequately. Our algorithm enables not only the implementation of de fault inheritance (and specificity) within pri oritized circumscription, but also the exten sion and combination of default inheritance with other kinds of prioritized default reason ing, e.g . : with stratified logic programs with negation-as-failure. Such logic programs are previously known to be representable equiv alently as layered-priority predicate circum scriptions. Worst-case, the transform increases the num ber of defaults exponentially. We discuss how inferencing is practically implementable nev-\nertheless in two kinds of situations: general expressiveness but small numbers of defaults, or expressive special cases with larger numbers of defaults. One such expressive special case is non-top-heaviness of the prioritization partial order. In addition to its direct implementation, the transform can also be exploited analytically to generate special case algorithms, e.g . , a tractable transform for a class within default inheritance (detailed in another, forthcoming paper) . We discuss other aspects o f the significance of the fundamental result . One can view the transform as reducing n degrees of partially or dered belief confidence to just 2 degrees of con fidence: for-sure and ( unprioritized) default. Ordinary, parallel default reasoning, e.g. , in parallel circumscription or Poole's Theorist, can be viewed in these terms as reducing 2 degrees of confidence to just 1 degree of con fidence: that of the non-monotonic theory's conclusions. The expressive reduction's com putational complexity suggests that prioritiza tion is valuable for its expressive conciseness, just as defaults are for theirs. For Reiter's Default Logic and Poole's Theo rist , the transform implies how to extend those formalisms so as to equip them with a concept of prioritization that is exactly equivalent to that in circumscription. This provides an in teresting alternative to Brewka's approach to equipping them with prioritization-type prece dence. A longer version of this paper, including the proof of the central transform result, will soon be available as an IBM Research Report.\n1 INTRODUCTION\nTHE IMPORTANCE OF PRIORITIZATION T YPE PRECEDENCE: Prioritization-type precedence is an important aspect of default and non-monotonic reasoning. It is a widely studied concept (actually, family of related concepts) of\n218 Grosof\nmultiple degrees of confidence (uncertainty, reliability) in beliefs: partially ordered, and lexicographic in flavor. By prioritization-type \"precedence\", we mean an over ride relationship between defaults that governs the res olution of conflicts between defaults; so that, in case of pairwise conflicts between defaults, a higher-precedence default \"wins\", i.e., goes through as non-monotonically entailed, in case of conflict with a lower-precedence de fault. Each default can be viewed as an uncertain belief. Prioritization in circumscription [McCarthy, 1986] [Lif schitz, 1985] [Grosof, 1991] is one of the first, and most expressively general, concepts of precedence in the de fault reasoning literature. Several other non-monotonic formalisms share a some what similar concept of prioritization-type precedence / degrees of confidence (and a somewhat similar concept of a default) to that in circumscription, including: the specificity dominance principle employed in inheritance, e.g., cf. [Touretzky, 1986] [Stein, 1989] [Quantz and Royer, 1992] [Geffner, 1992], conditional logics, e.g., cf. [Delgrande, 1987a] [Delgrande, 1987b] [Geffner, 1992], and argument systems, e.g., cf. [Loui, 1987]; aggrega tion principles for model-preference logics [Brown and Shoham, 1989], including for logic pro�ramming with negation-as-failure [Przymusinski, 19881 and termino logical logics [Quantz and Royer, 1992]; possibilistic logic [Dubois and Prade, 1988]; syntax-based belief re vision formalisms, e.g., [Nebel, 1989]; and a variety of others, e.g., [Brewka, 1989a] [Brewka, 1989b] [Brewka, 1994] (Ginsberg\nj 1988] [Zadroznr, 1987] [Pollock, 1987]\n[Konolige, 1988 [Ryan, 1992b] lRyan, 1992a] [Hunter, 1994]. From a practical viewpoint, two very important kinds of non-monotonic reasoning, in use even before the knowl edge representation (KR) field of non-monotonic logic started in the late 1970's, are: 1. inheritance with exceptions, e.g., default inheritance in frame-based KR systems; and 2. use of negation-as-failure in logic programming, e.g., inProlog.\nBoth these kinds of non-monotonic reasoning can be viewed formally in terms of defaults. In both, prioritization-type precedence is then very important to represent desired behavior: in default inheritance, to represent specificity dominance (i.e., the precedence of a default with more specific-class antecedent over a default with a more general-class antecedent); and, in stratified logic programs, to represent recursive depth in negation-as-failure use (i.e., deeper strata in backward inferencing have higher precedence associated with their predicates' minimization) [Lifschitz, 1987) [Przymusin ski, 1988]. More generally, precedence appears to be an important expressive aspect of defaults needed or useful to repre sent many domains. Bases for precedence information include not only specificity dominance but also reliabil ity and authority of sources [Grosof, 1993], decision theoretic utility (e.g., rules about emergencies have higher precedence) lGrosof, 1991] [Poole, 1992], and\ntemporal directionality (e.g., freshness; or Shoham's [1988] chronological minimization).\nVIRTUES OF CIRCUMSCRIPTION AS A FO CUS FORMALISM: Circumscription is a historically central and relatively well-studied non-monotonic formalism, with a number of attractive characteristics. First, its expressive feature of prioritization can directly represent precedence; and do so, moreover, in a relatively expressively powerful fashion. By contrast, many other non-monotonic for malisms do not have any expressive feature to directly represent precedence: e.g., Default Logic [Reiter, 1980] and Autoepistemic Logic [Moore, 1985]. Second, cir cumscription captures a core notion of default shared by most formalisms, corresponding closely to that of Poole's Theorist formalism l1988]. Third, circumscrip tion is skeptical, which we find to be typically more use ful for applications than brave. Fourth, circumscription has a relatively attractive model theory. Fifth, much is known about relationships between circumscription and a variety of other non-monotonic formalisms, including Default Logic and Autoepistemic Logic. In particular, prioritized (default) circumscription has been previously shown to be able to represent the strat ified class of logic programs with negation-as-failure. This is a large, interesting class that is important in practical implementations and applications of logic pro gramming. Prioritized circumscription has also been previously shown to be able to represent a large, inter esting class of default inheritance. We observe that prioritized (default) cirumscription can, moreover, represent theories that combine default inheritance and logic programs, as well as that extend them expressively.\nPreviously, however, there have not been any query answering inferencing algorithms for sufficiently general cases of prioritization: i.e., to handle prioritization par tial orders that are not layered (a.k.a. stratified), in the sense discussed first in [Grosof, 1991] and studied more in [Grosof, 1992b). In particular, as discussed there, non-layered prioritization partial orders are re quired to adequately represent even very simple cases of specificity in default inheritance. Layered prioriti zation cannot adequately represent default inheritance, much less its combination and extension with logic pro grams. (Sections 2 and 3 discuss details of how circumscription represents these classes.)\nPROBLEMS AND OPPORTUNITIES AD DRESSED: Our overall, primary motivations in this paper are twofold. The first is to advance fundamental under standing of prioritization-type precedence as a kind of partially-ordered degree of confidence (uncertainty, reliability) among beliefs. The second is to ad vance the implementation of default reasoning that has prioritization-type precedence.\nMore particularly, we are interested in prioritized cir-\nTransforming Prioritized Defaults and Specificity into Parallel Defaults 219\ncumscription, in great part because of its ability to rep resent, to a considerable extent, the combination and extension of logic programs with negation-as-failure and default inheritance.\nThe prospect of practically implementing such combi nation and extension is an exciting opportunity. It could provide closer integration and enhancement of two very important kinds of non-monotonic reasoning that are today in practical use as basic programming mechanisms.\nIn this paper, we accomplish (among other things) a first step towards this vision: to provide a correct algo rithm for query-answering inference, where previously there was no algorithm at all. More precisely, we give a family of sound and complete query-answering algo rithms for the full class of circumscriptions in which the prioritization partial order is unrestricted, and the de faults are propositional. This expressive class suffices to include the combination and extension of large classes of logic programs and default inheritance.\n2 PRELIMINARY DEFINITIONS\nBelow, and throughout the paper, we follow the defin itions, notation, and terminology of [Grosof, 1991] and of [Grosof, 1992b]. Refer to either the former (sections 3 and 4 there) or the latter (sections 2.2, 2.3, 2.7, 2.9 there) to find what is not elaborated below. A pre-order is a transitive, reflexive binary relation; i.e., a kind of ordering. A default pre-order :::5Di is one that expresses the preference to maximize a first-order for mula Di (in predicate and function symbols Z), called the default formula:\nZ:::5DiZ' �r Di[Z] ::S Di[Z'] Here, Di[Z'] stands for the result of substituting Z' for Z in the formula Di[ Z]. The :::; notation is as usual in the circumscription literature. If Di[Z] is a closed formula, then the right-hand-side above stands for D[Z] :J Di[Z']. If Di[Z] is an open formula with a tuple x of individual object variables, then the right hand-side above stands for 'Vx. Di[Z](x) :J Di[Z'](x). Prioritization is defined formally as an operation that takes as input 1) a tuple of starting pre-orders; and 2) a prioritization (precedence) partial order (e.g., R), which is a well-founded (e.g., finite) strict partial or der. The prioritization operation outputs a single, ag gregated output pre-order. A layered strict partial order is one that has a structure similar to the system of rank in the military. Viewed as a dag, a layered partial order consists of a totally ordered series of one or more levels. At each level, there are one or more elements, with no links between them (i.e., within that level). Each element in a higher level has higher priority than every element in any lower level. By contrast, the typical kinds of prioritization partial orders needed to represent even simple cases of specificity in default inheritance are non-layered, e.g., columnar: a forest of two or more chains, with no links between the chains. Among the elements within each\nchain, there is a total ordering. A prioritized default pre-order, e.g., (D; R), is one in which each of the starting pre-orders, e.g., Di (from tuple D), is a (single) default pre-order. A prioritized default circumscription is a circumscription in which the overall preference pre-order is a prioritized default pre-order. We write it as follows:\ndef PDC(B;D;R;Z) ::\nB[Z] 1\\ ...,3z'. B[Z'] 1\\ (Z:::5(D;R)Z') Here, B is the base, i.e., the conjunction of all the for sure premises (which are classical, e.g., first-order, for mulas). D is the tuple of (starting) default formulas, indexed say by N. R is the prioritization partial order, defined over the tuple N. Z is the tuple of all predicate and function symbols in the first-order logical language within which B and D (and F below) are expressed. When each Di in D is closed (i.e., propositional), then\n1 def Z:::5<vN;R)z =\n'ViE N. [\\fj EN. R(j, i) :J (Dj[Z]:: Dj[Z'])] :J (Di[Z] :J Di[Z'])\nwhere R(j, i) means that index j has higher priority than index i. In addition, we permit (explicit) fixtures (e.g., fixed predicates or functions):\nP DC(B; D; R; fix F; Z) �r B[Z] 1\\ -,3z'. B[Z'] 1\\ (Z:::5(D;R)Z1) 1\\ (Z�FZ')\nHere, F is a tuple, indexed say by M, of first-order fixture formulas Fk. E.g., the fixture formula P(x) ex presses the fixing of the predicate P. E.g., the fixture formula f( x) = y expresses the fixing of the function f.\nz�FZ' �r 1\\keM(Z�FkZ') z�FkZ' � (Z:::5FkZ') 1\\ (Z':::5FkZ)\nFixtures can be expressed equivalently (implicitly) via default formulas: adding the fixture of the formula F k is equivalent to adding the pair of defaults Fk and ...,pk in parallel to (i.e., without strict prioritization relative to) the rest of the defaults. Equivalently, prioritized default circumscription can be defined in terms of preferences over models.\nA prioritized predicate pre-order or circumscription can be defined as a prioritized default pre-order or circum scription, respectively, in which every default (and fix ture) formula is a negated unbound atom. Minimizing a predicate, say P, is just a special case of a default. It corresponds to maximizing the default formula ...,p(x), where x is a tuple of free individual variables and has the arity of P.\n3 REPRESENTING LOGIC PROGRAMS AND DEFAULT INHERITANCE IN PRIORITIZED DEFAULT CIRCUMSCRIPTION\nStratified logic programs with negation-as-failure are previously known to be representable equivalently as\n220 Grosof\nlayered-priority predicate circumscriptions [Lifschitz, 1 987] [Lifschitz, 1 988] [Przymusinski, 1 988]. For any stratified logic program, there is an equivalent circum scription. In the circumscription, every predicate is minimized. Every clause of the logic program is treated as a for-sure premise. The prioritization partial order corresponds to recursive depth in negation-as-failure use.\nDefault inheritance theories are previously known often to be representable as prioritized default circumscrip tions. A straightforward method is to represent each default in the inheritance theory as one default in the circumscription, and to represent the specificity domi nance partial order among defaults as the prioritization partial order. Higher specificity corresponds to higher prioritization. McCarthy's [1 986] original example for prioritized circumscription is birds flying, for example. See [Grosof, 1 9 92b] (especially, chapters 1, 2, 5, and 6) for discussion and many more examples.\nMore generally, one might also have other bases for prioritization-type precedence information, besides specificity, among a set of defaults. Being able to rep resent such is an expressive advantage of prioritized cir cumscription over default inheritance formalisms.\nPrioritized default circumscription enables the expres sive extension of default inheritance ( cf. [Touretzky, 1 986]) in several directions. One direction is to rep resent prioritization information based other than on specificity. Another direction is to represent negation, non-unary predicates, or arbitrarily nested connectives and quantifiers, in the consequent or antecedent sub formulas of default \"rules\".\n4 TRANSFORM EQUIVALENCE RESULTS, GENERAL CASE\nOur main results are somewhat complex to state for mally. So we start by giving a few simple examples to give the flavor and some intuition.\nIn general, the transform treats the input default formu las E opaquely, and does not involve any inferencing in the sense of computing classical-logic entailments. Es sentially, the transform depends only on the details of the prioritization partial order R, not on the form or details of the input default formulas E.\nExample 1 (Two Defaults)\nLet two defaults' formulas be denoted by 1,2. Let the prioritization be: 1 higher than 2. Then the result of the transform is 3 parallel defaults, with formulas: 1 , 2 /\\1 , 2 V1\nExample 2 (Two Columns of Two Each)\nLet four defaults' formulas be denoted by 1,2,3,4. Let the prioritization be: 1 higher than 2, and 3 higher than 4. Then the result of the transform is 6 parallel defaults, with formulas:\n1 , 2 /\\1 , 2 V1 , 3 , 4 /\\3 , 4 V3\nExample 3 (One Higher Than Two Others)\nLet three defaults' formulas be denoted by 1 ,2,3. Let the prioritization be: 1 higher than 2, and 1 higher than 3. Then the result of the transform is 5 parallel defaults, with formulas: 1 , 2 /\\1 , 2 V1 , 3 /\\1 , 3 V1\nExample 4 (Chain of Three)\nLet three defaults' formulas be denoted by 1 ,2,3. Let the prioritization be total : 1 higher than 2, and 2 higher than 3. Then the result of the transform is 7 parallel defaults, with formulas: 1 , 2 /\\1 , 2 V1 , 3 1\\ 2 1\\ 1 , (3 1\\ 2) v 1 , (3 v 2) 1\\ 1 , 3 v 2 v 1\nExample 5 (Two Higher than One)\nLet three defaults' formulas be denoted by 1,2,3. Let the prioritization be: 1 higher than 3, and 2 higher than 3. Then one (non-deterministic) result of the transform is 7 parallel defaults, with formulas: 1 , 2 , 3 1\\ 2 1\\ 1 , (3 1\\ 2) v 1 , (3 v 2) 1\\ 1 , 3 v 2 v 1\nThere is another, equivalent (non-deterministic) alter native: 1 , 2 , 3 1\\ 1 1\\ 2 , (3 1\\ 1) v 2 , (3 v 1 ) 1\\ 2 , 3 v 1 v 2\nDefinition 6 (General Transform to Parallel)\nLet EN be a finite tuple of propositions (i.e., closed first-order formulas) . (The tuple N indexes E.) Let R be any prioritization partial order defined over N.\nWe define g, the general-case transform for elimi nating prioritization, as follows. g is a functional that depends only on the prioritization partial order R. g, moreover, is non-deterministic in general. Hence, we define it as a multi-functional: 9R maps its argument E into a non-empty set, each of whose members is a tuple of propositions.\nLet W be a tuple of propositions. We define W to be a member of 9R(E) when W is constructed (non deterministically) as follows.\nFor each i EN: Let ui be any sequencing of Rv(i) that is descending with respect to R. ( Rv ( i) stands for the set of indices in N that are higher-priority than i, i.e., the Dominators of i. \"De scending\" means topologically sorted in the downward\nTransforming Prioritized Defaults and Specificity into Parallel Defaults 221\ndirection of priority. In more detail, it means the follow ing. Consider comparing the ith and the ph elements in the sequence, where i < j. Then either the (earlier) ith element has higher priority than the (later) ph el ement, or else the two are incomparable with respect to the prioritization partial order (neither has higher priority than the other) . ) Note that since the result of topological sorting is not always unique, the choice of ui is non-deterministic in general. Let !7li stand for the size of Rv(i), and thus the length of u'. Let u� stand for the kth element in the sequence ui . Consider the set V; of all bit strings of length m;. There are 2m; of these, corresponding to the binary numbers {0, . . . , 2m; -1}.\nFor each IE V;: Let lk stand for the kth bit of I. Let �� be defined as the logical connective \"/\\\" (i.e. , logical and) when lk = 1, and as the logical connective \"V\" (i.e. , logical or) when lk = 0. Let W;1 be defined as the proposition\n(Eo; !{ (E0; �� (Eo; �� ( ... (E0; 1!.. E;) ... )))) 1 2 3 m s I where, for any j E N, Ei stands for the ph default formula in the tuple EN.\nFinally: Let W; be the tuple of all the W;1 's, for all I E V;. Let W be the tuple formed by concatenating (union'ing) all the W;'s, for all i E N.\nTheorem 7 (General Transform, Pre-Orders)\nSuppose EN is a finite tuple of propositions . (The tuple N indexes E.) Let R be any prioritization partial order defined over N. Then the prioritized propositional default pre order (EN; R) is equivalent to the parallel proposi tional default pre-order (W; 0 ), for every W such that W E {;R(E). (0 stands for the empty prioritization partial order.)\nProof Overview: Involved; inductive on the priori tization partial order R. See the longer version of this paper. D\nProof of Example 1 :\nThe proof for Example 1 gives some of the flavor of the full proof, which is much more complicated.\nLet i' for i = 1, 2 stand for the default formula i with Z' substituted for Z. We want to show that\n(l:J 1') 1\\ ((1/\\2) ::> (1 '/\\2')) 1\\ ((1V2) :::> (1'V2'))\nis equivalent to (1 :::> 1') 1\\ ((1 = 1') :::> (2 ::> 2')) Assume:\n(1 :::> 1') (A1)\nThen it suffices to show\n((1/\\ 2) :::> (1' 1\\ 2')) 1\\ ( (1 v 2) :::> (1 ' v 2')) (2)\nis equivalent to\n((1 = 1') :::> (2 :::> 2'))\n(AI) implies that (2) is equivalent to\n((1/\\ 2) :::> 2') 1\\ (2 :::> (1' v 2'))\n( 4) is tautologically equivalent to\n(1 :::> (2 :::> 2')) \" (-,1' :::> (2 :::> 2'))\n(A1) implies tautologically that\n(3)\n(4)\n(5)\n(1 = ( 1/\\ 1')) \" (-,1' = (-,1 \"-,1')) (6)\n(6) implies by substitutional rewriting that (5) is equiv alent to\n((1\" 1') :::> (2 :::> 2')) \" (-,1/\\ -,1') :::> (2 :::> 2')) (7)\n(7) is tautologically equivalent to\n((1/\\ 1') v (-,1 \"-,1')) :::> (2 :::> 2') (8)\nTautologically, the left-hand-side of (8) is equivalent to the left-hand-side of (3) .\nQED Example 1\nTheorem 8 (Transform, Circumscriptions)\nLet P DC(B; E; R; Z) be any prioritized default circum scription defined without (explicit) fixtures. In particu lar, R may be any arbitrary prioritization partial order. (E.g. , R need not be layered.)\nSuppose the default formulas E are all propositional. Then the PDC is equivalent to the parallel default cir cumscription that results from applying the transform g, i .e. :\nPDC(B;E;R;Z) ::: PDC(B;W;0;Z) for every WE gR(E).\nMatters are similar for the case when any (explicit) fix tures F are present: PDC(B;E;R;fizF;Z) ::: PDC(B;W;0;fizF;Z)\nProof : We begin by considering the case without (explicit) fixtures:\nWe are comparing two circumscriptions, one before the transform and one after the transform. They have the same base B. The definition of circumscription im plies, therefore, that two circumscriptions are equiva lent if their preference pre-orders ((E; R ) and (W; 0), respectively) are equivalent. Theorem 7 implies just such equivalence between the preference pre-orders.\nThat adding (explicit) fixtures preserves the equiva lence is seen easily by inspecting the role of fixture in the definition of circumscription. D\nRemarks: The base B and the fixtures F above need not be propositional.\nThe equivalence between the prioritized set of defaults (E; R) and the parallel set of defaults (W; 0 ) is strong,\n222 Grosof\nin the sense that it holds for any base (or fixture). Thus if there are a series of updates to the base (or fixtures) alone, then the transform does not need to be re-applied.\nThe non-determinism in the definition of the transform does not increase required computational effort. All it does is provide equivalent alternatives.\nObservation 9 (Effective Propositionality)\nWhen the base implies 1. domain closure (DCA); plus 2. uniqueness of names (UNA) (or, more generally, a complete theory of equality), then the defaults in a circumscription, and in its pre orders, are effectively propositional, in the sense that every default can be viewed as equivalent to the (par allel) collection of all its ground instances. More pre cisely: in a PDC, when the base implies domain closure plus uniqueness of names, then this first PDC is equiva lent to a second PDC defined by replacing every default in the first PDC by the collection of its instances.\nProof: See [Grosof, 1992b]: Theorem 2 .47 . D\nTheorem 10 (Extension to DCA & UNA)\nOur results in Theorem 8 thus generalize straightfor wardly to permit the default formulas to be open or closed, when the restriction in Observation 9 is met . Convert the initial set of prioritized defaults to a set of prioritized closed defaults, by replacing every default by the collection of its instances. Then apply Theorem 8.\nProof : Immediate from Observation 9. D\n5 ALGORITHM TO IMPLEMENT THE GENERAL TRANSFORM\nImplementing the general-case transform g is straight forward. Next, we sketch an algorithm to compute 9R(E):\n1. For each i EN: 2 . compute Rv(i) and its size m,; 3. non-det�rministically, topologically sort Rv(i), re sulting in 0'1;\nAs one simple way to compute step 3. , one might do the following: Before step 1. above: non-deterministically, topologi cally sort R, resulting in a sequence that we may call tf;. Then, in step 3. , compute O'i as the intersection of t/; with Rv(i).\n4. construct v,; 5. For each IE V,:\nAlternatively, one might skip step 4. and instead gen erate Vi within 5 . as one goes.\n6. construct Wi1 , : first, initialize it to be E,, then:\n7. For each k = m1 , • • • , 1 : 8 . add another Eq; 1i then parenthesize.\nk\n9. Finally, collect all the Wu's: the result W is, as desired, a member of 9R(E).\nComputational Complexity of the General Transform: Worst case, the transform is exponential in the size of the input representation of E and R, i.e., in the number n of input (prioritized) defaults. The nub is the size of W itself, which is worst-case exponential in n.\nHowever, when the size of W is polynomial, then the time required to compute the transform is also poly nomial. This is the case, for example, when: for each default i in EN, the size m, of Rv(i) is bounded by a constant, or grows slowly, say is O(log n) . Recall that Rv(i) is the set of defaults that are higher-priority than default i. Thus if the prioritization partial order R is non-\"top-heavy\" in this sense, then the transform is tractable.\nLayered or Total Restrictions Do Not Help: We observe that the (size) complexity of the transform is not, in general, improved by requiring that the priori tization partial order be layered, nor by requiring it to be totally ordered. A total order is always top-heavy. Layered partial orders are often top-heavy.\n6 SPECIAL CASE TRANSFORM FOR SPECIFICITY IN INHERITANCE\nThe general-case transform g can also be used analyt ically to develop special-case transforms that are much simpler than the general-case transform.\nIn particular, it can be used to develop a special-case transform for default inheritance, where prioritization is based on specificity, which is in turn based on for sure beliefs about a taxonomic hierarchy. Preliminary investigations indicate that this specificity transform has only quadratic (often linear) blow-up in the num ber/size of defaults, and thus polynomial computational time complexity. Due to space limitations here, we dis cuss the details and general results elsewhere in a forth coming paper. To give the flavor, however, next we give some examples.\nAll of these examples are about inheritance by a sin gle individual, let us call her Tweety, of a single at tribute, flying; however, they straightforwardly extend to a full domain of many individuals, and inheritance of many attributes. Below, for conciseness of exposi tion, we leave Tweety implicit and omit showing it as an argument of the predicates bird, flies, etc . .\nExample 11 (One Exceptional Sub-Class)\nLet the starting representation with priorities be:\nEl � bird :J flies\nTransforming Prioritized Defaults and Specificity into Parallel Defaults 223\ndef E2 = ostrich :J -,flies\nwhere E2 has higher priority than E1, and the base/for sure axioms entail that ostrich :J bird. This is a very simple case of an default inheritance chain. Then after the special-case transform, there are two defaults, with formulas:\nD1 �f D2 d=_ef bird :J (flies /\\ -,ostrich) ostrich :J ..,flies\nExample 12 (Two Exceptional Sub-Classes) Suppose we extend Example 1 1 by adding another de fault: def E3 = penguin :J -,flies where E3 has higher priority than E1, and the base/for sure axioms entail that penguin :J bird. Then after the special-case transform, there are three defaults, with formulas:\nD1 def bird :J (flies /\\ -.ostrich /\\ -.penguin) D2 def h ostric :J -.flies D3 def penguin :J -.flies\nExample 13\n{Two Levels of Exceptional Sub-Classes) Suppose we extend Example 12 by adding another de fault: EO �f animal :J -.flies where E1 (and E2 and E3) has higher priority than EO, and the base/for-sure axioms entail that bird :J animal. Then after the special-case transform, there are four de faults, with formulas:\nDO � animal :J (-.flies /\\ -.bird) D1\nD2 D3\n�f def def bird :J (flies /\\ -.ostrich /\\ -.penguin) ostrich :J -.flies\npenguin :J -.flies\nExamples Proof Overview: Our proof technique for the above Examples, and for the special case transform more generally, relies on results in [Grosof, 1992b]. The special-case transform, e.g., in the examples above, has as output a subset of the defaults that result from the general-case transform. Defaults can be dropped (from the general-case's output) when they are redundant in the sense of [Grosof, 1992b]'s Definition 4.17 and The orem 6.29. A default is redundant if the base implies 1) that its formula W il is equivalent to an expression formed positively (i.e., using /\\ , V , and quantifiers but not -.) from other default formulas (in W); or 2) that Wil is tautologically true; or 3) that Wil is tauto logically false. 0\nRelationship to Parallel Abnormalities With Cancellation: There is a close relationship between the above examples and a well-known method of em ploying abnormality predicates to represent a simple de fault inheritance chain: by minimizing the abnormality predicates, with explicit cancellation axioms, and with parallel prioritization. For the above examples, the fol lowing defines an equivalent representation. Introduce\none distinct abnormality predicate abi for each default formula Di above. Assert a for-sure premise for each i:\n..,abi :J Di Assert explicit cancellation axioms as for-sure premises, as follows. For each pair (j, i) of defaults such that j has higher priority (is more specific) than i, include ei ther the for-sure premise:\n-,Dj :J abi or, alternatively (equivalently), the for-sure premise:\n-,cj :J abi where cj is the class condition on the left-hand-side of the rule Dj, e.g., ostrich in the left-hand-side of D2. Finally, minimize all the abnormality predicates in par allel. (No other defaults are maximized.)\nProof Overview for Equivalence of Examples to Abnormalities plus Cancellation: The equivalence of this representation, for the above examples, can be proven straightforwardly using the results on abnormal ity theories, and their equivalence relationship to maxi mizing default formulas, in [Grosof, 1992b] (section 3.2 there). 0\nThus abnormalities with explicit cancellation provides an alternative way to transform a prioritized default representation into a parallel one, for these examples.\n7 USES FOR IMPLEMENTATION\nThe transforms, both general-case and special-case, are useful as a front-end to inferencing algorithms that han dle the parallel expressive class.\nAs we discussed earlier (recall Theorem 10), our general-case transform requires only one expressive re striction: that 1) the defaults are propositional; or 2) the base implies domain closure and uniqueness of names / complete theory of equality. In case of 2), re call, the defaults are effectively propositional.\n7.1 REVIEW OF PREVIOUSLY AVAILABLE INFERENCING ALGORITHMS\nThere are several previously available query-answering inferencing algorithms for parallel defaults in circum scription that are sound and complete for queries over fairly general expressive classes of first-order-form be liefs: [Przymusinski, 1989] [Ginsberg, 1989] [Baker and Ginsberg, 1989] [Inoue and Helft, 1990] [Helft et a/., 1991]. Each of these covers (at least) ground queries. All of these essentially require effective propositional ity. Each, besides Przymusinski's, covers (at least) the expressive class of: domain closure plus uniqueness of names, which includes propositionality (of base and de faults) as a special case, of course. All restrict the de fault formulas to have the form of minimizing a pred icate: i.e., every default formula Di has the form of a negated atom -.Pi(x), where Pi is a predicate symbol and x is a tuple of free variables. However, this restric tion is inessential. Maximizing arbitrary default formu las can be reduced, in a simple fashion, to minimizing predicates. [Grosof, 1992b] (section 7.6 there) shows\n224 Groso£\na general method, imposing only overhead time that is polynomial in the input representation, to convert infer encing with arbitrary default formulas (and fixtures) to inferencing with default formulas that are restricted to be predicate minimizations (with all fixtures expressed as fixing of predicates or functions) . This method re quires no other restrictions on the (input) base, pri orities, fixtures, or form of conclusions. This method is based on introducing abnormality predicates. It ex tends and refines the by-now well-known style of abnor mality theories, so as to apply to the case of arbitrary prioritization partial orders. In addition, the algorithms of [Ginsberg, 1989] and [Baker and Ginsberg, 1989] are essentially developed, conceptually as well as mathe matically, in terms of maximizing default pre-orders. Thus they are easily extended to handle correctly the default, not just the predicate, case.\nThe algorithms of [Ginsberg, 1989] and [Baker and Ginsberg, 1989] enable arbitrary closed queries, but im pose the restriction of no fixed predicates; however, [In oue and Helft, 1990] shows how to relax this restriction to permit arbitrary fixed predicates. [Helft et al., 1991] shows how to extend to queries with answer extraction, not just closed (yes/no) queries.\nThe punchline is that previously available algorithms support rich query-answering for parallel defaults in circumscription, for the expressive ciass of domain clo sure plus uniqueness of names (which includes proposi tional) .\nIn addition, two of the previously available query answering algorithms, [Baker and Ginsberg, 1989] and [Przymusinski, 1989] (who does not give a proof), ap ply to the prioritized case, but require that the prior itization partial order be layered. (Both also require queries to be closed. )\n7.2 NEW INFERENCE ALGORITHMS\nOur general-case transform enables the extension of any parallel-case algorithm IP to handle defaults with ar bitrary prioritization. These include all of the previ ous algorithms discussed above, as well as any other / future algorithms. Our general-case transform applies to any direction of inferencing: e.g., the direction may be backward (query-answering) or forward (exhaustive; or selective, e.g., data-driven); queries may be ground, closed, or open (answer extraction) . And it applies to inferencing algorithms for expressively highly restricted parallel cases, as well as to those for expressively gen eral parallel cases. Special case transforms based on (i, e.g., the one we briefly discussed in section 6, apply similarly, though of course with appropriate expressive restrictions.\nThe method is simple: 1 . If the input prioritized defaults are not propositional, but there is domain closure and uniqueness of names / complete theory of equality, then replace every (open) default by the collection of its instances. In practice, this need not be computed explicitly in its entirety, e.g., for defaults about which there is no strict prioritization\ninformation. 2. Apply the transform to the input prioritized defaults. This results in a representation where the defaults are parallel. 3 . Apply the inference procedure IP.\nFor example, the [Inoue and Helft, 1990] algorithm can thus be extended to cover the expressive case of: domain closure plus uniqueness of names, for arbi trary prioritization, universal default formulas, univer sal base, quantifier-free fixtures, and closed queries. This is a fairly expressive class, and compares well with the expressive classes used practically today in mono tonic first-order-logic inferencing.\nAnother potential use of our transform approach is to partially eliminate the input's prioritization, so as to produce a simpler prioritization, e.g., layered, in the output that can be handled by another available algo rithm, e.g., [Baker and Ginsberg, 1989]'s.\n8 COMPUTATIONAL PRACTICALITY\n8.1 COMPUTATIONAL COMPLEXITY OF INFERENCING, GENERALLY, INCLUDING WITHOUT PRIORITIES\nA major practical difficulty for default reasoning, even without priorities, is the worst-case computa tional complexity of inferencing. Skeptical entailment (i.e., answering a single closed query) is known to be IIf -complete, i .e . , co-NP-harder than monotonic entailment, in the propositional case of several ex pressively rich non-monotonic logical formalisms, in cluding: circumscription (even minimizing predicates without priorities), Default Logic (even the \"normal\" case), Autoepistemic Logic, and several additional non monotonic modal logics and other formalisms [Eiter and Gottlob, 1993] [Stillman, 1992] [Gottlob, 1992].\nThere are several avenues to avoiding worst-case com plexity of default reasoning, generally. One is to employ approximations, perhaps sound but incomplete, e.g. , as in LCadoli and Schaerf, 1992]. Another is to restrict ex pressive classes to those with significantly better com plexity, e.g., such that inferencing over a large theory can be decomposed into inferencing over several smaller or simpler theories. [Grosof, 1992b] explores both of these avenues, especially the latter.\n8.2 COMPUTATIONAL PRACTICALITY OF INFERENCING IMPLEMENTED VIA OUR METHOD\nOur transform, as used in our inference algorithms for prioritized defaults, potentially compounds the compu tational complexity situation for parallel defaults with yet another source of worst-case exponential complex ity: in time, and in the number of defaults input into parallel-case inferencing. Thus, it must be used with some discretion, just as parallel default reasoning must\nTransforming Prioritized Defaults and Specificity into Parallel Defaults 225\nbe in general.\nImplementing the transform is practical nevertheless in two kinds of situations: general expressiveness but small numbers of defaults, or expressive special cases with larger numbers of defaults.\nFirst, our method enables the implementation at least of small numbers of prioritized defaults that have ar bitrary non-layered prioritization partial orders. The history of rule-based knowledge representation demon strates that even small rule sets are often quite useful for applications.\nSecond, feasibility for small numbers of defaults can be sometimes be leveraged in order to implement larger prioritized default theories. There exist previous tech niques for decomposing large prioritized default the ories into a collection of local default theories, each with a small number of defaults [Grosof, 1992b] [Grosof, 1992a].\nThird, complexity of the transform can be kept man ageable by expressively limiting the top-heaviness (mi) of the prioritization partial order. An exam ple is when the (strict) prioritization is columnar (re call section 2 terminology) and the columns (chains) have bounded height (e.g . , less than five) . Shallowness of rule interaction is a common situation in practical knowledge-based systems today.\nFourth, complexity of the transform can be kept man ageable by employing special-case transforms, corre sponding to restricted expressive classes, e.g., the tractable special-case transform for specificity in inher itance that we briefly discussed in section 6 .\nFinally, we observe also that the transform is a \"compile-time\" operation that need be performed only once for a long sequence of for-sure (base) updates and even default updates, as long as the (strict) prioritiza tion is not changed.\nThe computational complexity of the overall inferencing does not depend only on the computational complexity of the transform. It also depends on the underlying computational complexity of inferencing with the par allel defaults that result from the transform. As we discussed in subsection 8.1, this itself is Ilf -complete. Again, the worst-case complexity of inferencing with parallel defaults limits, but far from eliminates, the practicality of such inferencing. In some interesting and useful cases, parallel default reasoning is tractable. Again, there are two kind of situations. The first kind is general expressiveness but small numbers of defaults. The second kind is expressive special cases with larger numbers of defaults: e.g., Closed World Assumption, some kinds of logic programs and predicate comple tions, sympathetically solitary default theories [Grosof, 1992b] (section 6.5 there) , and some other cases.\nLet us summarize the foregoing's implications for over all inferencing via our method, combining both the transform and the parallel reasoning. The feasibility picture is of a glass half full and half empty, just as\nin much of AI and KR. Inferencing via our method is computationally practical for small numbers of defaults with general expressiveness, or for larger numbers of de faults in expressive special cases for which the underly ing default reasoning and the transform are tractable.\n9 MORE IMPLICATIONS OF FUNDAMENTAL RESULT\n9.1 PRIORITIZATION'S EXPRESSIVE REDUCIDILITY AND CONCISENESS\nOne can view the transform as reducing n degrees of partially ordered belief confidence to just 2 degrees of confidence: for-sure and (unprioritized) default .\nThis reducibility is, at first glance, surprising: prior itization was introduced into circumscription by Mc Carthy [1986] , Lifschitz [1985], and Grosof [1991] be cause it was not understood how to achieve the same entailment behavior without it; likewise, for similar con cepts of precedence in other non-monotonic formalisms.\nAt second glance, however, the reducibility is less sur prising. Ordinary, parallel default reasoning, e.g. , in parallel circumscription or Poole's Theorist, can be viewed in these terms as reducing 2 degrees of confi dence to just 1 degree of confidence: that of the non monotonic theory's conclusions.\nMuch of the point of non-monotonic reasoning (e.g., Ilf -complete; recall subsection 8 .1) altogether is its rep resentational conciseness (e.g., exponential) relative to monotonic reasoning (e.g., NP-complete) .\nNevertheless, prioritization appears to be useful as a tool for conciseness, and thus naturalness, in represen tation. Our transform result suggests (no lower-bound result, though) that prioritization may allow an expo nential savings in the number of defaults that must be specified by a user.\nIn short, the expressive reduction's computational com plexity suggests that prioritization is valuable for its expressive conciseness, just as defaults are for theirs.\n9.2 DEFINING PRIORITIZATION IN FORMALISMS PREVIOUSLY WITHOUT IT\nOur transform implies how to define / introduce ex plicit prioritization, in a manner precisely equivalent to prioritization in default circumscription, into some previously parallel formalisms. In particular, Theorist Poole's formalism [1988] and the \"normal, prerequisite free\" case of Reiter's [1980] Default Logic each overlap equivalently with parallel fixture-free default circum scription, in the case of propositionality or domain clo sure plus uniqueness of names.\nIn a bit more detail: Grosof [1992b] (section 8.5 there) shows that, in this case, for any set of default formulas G, indexed by N: the parallel default circumscription without explicit fix-\n226 Grosof\ntures PDC(B; GN; 0;Z) is equivalent to the skeptical versiOn of the Default Logic default theory (B, D), where each DL default DiED, for i EN, is defined as:\n: Gi Gi\nThus, our transform can be applied to define prioritized versions of Poole's Theorist formalism and of normal, prerequisite-free Default Logic. It will be interesting to compare this to Brewka [1989a] [1989b] [1994] al ternative approach in which he defines new extended, prioritized variants of Poole's Theorist formalism and of Default Logic. Brewka's approach does not, in gen eral, have the same entailment behavior (see [Grosof, 1992b] section 8.8) .\n10 CONTRAST WITH OTHER ALGORITHMS AND APPROACHES\nOur transformational approach (for transforming pri oritized into parallel) and algorithms (for inferencing with prioritization) is quite different from previous ap proaches and algorithms for circumscription. Perhaps most importantly, unlike previous ones, it extends to non-layered prioritization partial orders, which appear quite important for practical applications; e.g., default inheritance typically has non-layered prioritization.\nBaker & Ginsberg's [1989]'s query-answering algorithm for the layered case of prioritized default circumscrip tion does not reduce the prioritized representation to a parallel one; instead it takes prioritization into ac count by modifying the dominance criterion involved in dialectically comparing arguments for and against a given proposition.\nThe previous approach to transforming a prioritized set of defaults into a parallel set of defaults is based on what [Grosof, 1992b] calls decomposition. [Lifschitz, 1985] has shown an equivalence theorem, for the case of lay ered prioritization and predicate minimization, between a prioritized circumscription and a conjunction of par allel circumscriptions, one per layer. [Grosof, 1992b] (chapters 5 and 7, especially) has extended this to the case of arbitrary non-layered prioritization and arbi trary default formulas, and has shown a similar result giving equivalence to a series (cascade) of parallel cir cumscriptions (extending a previous unpublished result by Lifschitz for the layered predicate case). In addi tion, Brewka's [1989a) [1989b) [1994) employs the serial decompositional approach as a means to definitionally introduce prioritization-type precedence into Poole's [1988] Theorist formalism and into Default Logic.\nThe decompositional approach is quite different in spirit from our transform here, which gives equivalence to a single parallel circumscription. The decompositional approach, in general, results in extra fixtures and also, for non-layered prioritizations, expressively complex ex tra base. Also, neither Grosof nor Lifschitz have pre-\nviously given a query-answering algorithm based on this decompositional approach. (Though [Przymusin ski, 1989]'s unproven algorithm for layered predicate case is based on Lifschitz' result.)\nBesides previous work for general prioritized circum scriptions, there is also some relevant previous work on encoding specificity into parallel defaults. Early work by Etherington & Reiter [1983] showed how to encode specificity in inheritance into Default Logic, startin� from a path-based representation cf. [Touretzky, 19861. Delgrande & Schaub [1994] propose a general approach, applicable to many default formalisms: \" to use the tech niques of a weak system, as exemplified by System Z [ [Pearl, 1990) ] , to isolate minimal sets of conflicting defaults. From the specificity information intrinsic in these sets, a default theory in a target language is spec ified.\" They then give some particular transforms, con centrating primarily on Default Logic. In current work, they are exploring applying their approach to circum scription.\nIt will be interesting to compare the transformational approach here in more detail to the previous ap proaches, in the cases where they overlap: e:g., to co� pare their entailment behavior and the efficiency �f m ferencing and updating algorithms based on the differ ent approaches.\n1 1 SUMMARY; CURRENT AND FUTURE WORK\nSUMMARY OF PAPER: See the Abstract.\nMORE EFFICIENT SPECIAL CASE FOR SPECIFICIT Y AND INHERITANCE: Recall section 6 which described a forthcoming paper.\nAPPLYING RESULTS TO OTHER FOR MALISMS: In a forthcoming paper, we also show that our results apply to several default formalisms other than circumscription, including [Geffner, 1992]'s for malism for defaults, inheritance, specificity, and con ditionals; [Quantz and Royer, 1992]'s formalism for defaults, inheritance, and specificity in terminological logics; and Brewka's formalism family [1989�] [1,989b) [1994] which extends Poole's Theorist and Reiter s De fault Logic with prioritization-type precedence.\nEach of these formalisms overlap equivalently, for a broad case, with propositional prioritized defaults in circumscription. Our results thus apply to these for malisms as well.\nREMAINING CHALLENGES: We have not yet experimented with, or evaluated the efficiency of, our approach and algorithms: that awaits future work.\nThere is much further to go to realize the vision we dis cussed towards the end of section 1 . Enabling sufficient computational efficiency and demonstrating practical applications remain outstanding as problems for future work.\nGood algorithms for other kinds of reasoning besides\nTransforming Prioritized Defaults and Specificity into Parallel Defaults 227\nquery-answering are also needed: for updating and be lief revision, and for other directions, e.g. , forward, of inferencing. Approaches to these are discussed for prioritized default circumscription in [Grosof, 1992b] [Grosof, 1992a].\nAcknowledgements\nThanks to Torsten Schaub, Jim Delgrande, Leora Mor genstern, and Hector Geffner for encouraging discus sions. Thanks also to two anonymous reviewers for helpful suggestions, some of which are incorporated only in the longer version of this paper.\nReferences\n[Baker and Ginsberg, 1989] A. Baker and M. Ginsberg. A theorem prover for prioritized circumscription. In Proceedings /JCAI-89, pages 463-467, Detroit , MI . , 1989.\n[Brewka, 1989a] G. Brewka. Preferred subtheories: An extended logical framework for default reasoning. In Proceedings of /JCAI-89, pages 1043-1049, Detroit, Michigan, 1989.\n[Brewka, 1989b] Gerhard Brewka. Nonmonotonic Rea soning: From Theoretical Foundations to Efficient Computation. PhD thesis, University of Hamburg, Germany, 1989 .\n[Brewka, 1994] Gerhard Brewka. Reasoning about priorities in default logic. In Proceedings of the Twelfth National Conference on Artificial Intelli gence ( AAAI-94}, pages 940-945, Menlo Park, CA / Cambridge, MA, 1994. AAAI Press / MIT Press.\n[Brown and Shoham, 1989] Allen L. Brown, Jr. and Yoav Shoham. New results on semantical nonmono tonic reasoning. In M . Reinfrank et al, editor, Pro ceedings of the Second International Workshop on Non-Monotonic Reasoning, Berlin, Germany, 1989. Springer Lecture Notes on Computer Science.\n[Cadoli and Schaerf, 1992] Marco Cadoli and Marco Schaerf. Approximate inference in default reasoning and circumscription. In B. Neumann, editor, Proceed ings of the Tenth European Conference on Artificial Intelligence {ECAI-92}, pages 319-323. John Wiley, August 1992. Extended version to appear on Funda menta Informaticae.\n[Delgrande and Schaub, 1994] James P. Delgrande and Torsten H. Schaub. A general approach to specificity in default reasoning. In Proceedings of the Fourth International Conference on Principles of Knowledge Representation and Reasoning, pages 146-157, San Francisco, CA, 1994. Morgan Kaufmann.\n[Delgrande, 1987a] J . Delgrande. An approach to de fault reasoning based on a first-order conditional logic. In Proceedings of the Sixth National Conference on Artificial Intelligence ( AAAI-87), pages 340-345, Seattle, 1987.\n[Delgrande, 1987b] James P. Delgrande. A first-order conditional logic for prototypical properties. Artifi cial Intelligence, 33:105-130, 1987.\n[Dubois and Prade, 1988] Didier Dubois and Henri Prade. Possibility Theory. Plenum Press, New York, 1988.\n[Eiter and Gottlob, 1993] Tomas Eiter and Georg Got tlob. Propositional circumscription and extended dosed world reasoning are 1rf -complete. Theoreti cal Computer Science, 1 14(2) :231-245, 1993. See also Addendum with two missing references in Theoretical Computer Science 118 (2) 1993 p. 315.\n[Etherington and Reiter, 1983] D. Etherington and R. Reiter. On inheritance hierarchies with ex ceptions. In Proceedings of the Second National Con ference on Artificial Intelligence ( AAAI-83}, pages 104-108, Washington, D.C. , 1983.\n[Geffner, 1992] Hector Geffner. Default Reasoning: Causal and Conditional Theories. MIT Press, Cam bridge, Mass. , 1992.\n[Ginsberg, 1988] M. Ginsberg. Multivalued logics: A uniform approach to reasoning in artificial intelli gence. Computational Intelligence, 4:265-316 , 1988.\n[Ginsberg, 1989] M. Ginsberg. A circumscriptive theo rem prover. Artificial Intelligence, 39:209-230, 1989.\n[Gottlob, 1992] Georg Gottlob. Complexity results for nonmonotonic logics. Logic and Computation, 2(3):397-425, June 1992.\n[Grosof, 1991] Benjamin N. Grosof. Generalizing prior itization. In Proceedings of the Second International Conference on Principle of Knowledge Representa tion and Reasoning, pages 289-300, April 1991 . Also available as IBM Research Report RC15605, IBM T.J. Watson Research Center, P.O. Box 704, York town Heights, NY 10598.\n[Grosof, 1992a] Benjamin N. Grosof. Reformulating non-monotonic theories for inference and updating. In Michael Lowry, editor, Proceedings of the 1992 Workshop on Change of Representation and Problem Reformulation, 1992. Also available as IBM Research Report RC17955.\n[Grosof, 1992b] Benjamin N. Grosof. Updating and Structure in Non-Monotonic Theories. PhD thesis, Computer Science Dept . , Stanford University, Stan ford, California 94305, October 1992. Published by University Microfilms, Inc .. Also available as Re search Report from Stanford University Computer Science Dept. and/or IBM T.J . Watson Research Center .\n[Grosof, 1993] Benjamin N . Grosof. Prioritizing multi ple, contradictory sources in common-sense learning by being told; or, advice-taker meets bureaucracy. In Leora Morgenstern, editor, Proceedings of the Second Symposium on Logical Formalizations of Common Sense Reasoning (Common-Sense '93). Available as an IBM Research Report. Copies of the Proceedings are available via the editor (wider publication being arranged) : leora@watson.ibm.com., 1993.\n[Helft et al. , 1991] Nicolas Helft, Katsumi Inoue, and David Poole. Query answering in circumscription. In Proceedings of /JCAI-91, pages 426-431, San Fran cisco, California, 1991. Morgan Kaufmann.\n228 Grosof\n[Hunter, 1994] Anthony Hunter. Defeasible reason ing with structured information. In Proceedings of the Fourth International Conference on Principles of Knowledge Representation and Reasoning, pages 281-292, San Francisco, CA, 1994. Morgan Kauf mann.\n[Inoue and Helft, 1990] Katsumi Inoue and Nicolas Helft. On theorem provers for circumscription. In Proceedings of the Canadian Conference on Com puter Science and Artificial Intelligence '90, 1990. Held Ottawa, Canada, May 1990.\n[Konolige, 1988] Kurt Konolige. Hierarchic autoepis temic theories for nonmonotonic reasoning. In Pro ceedings of AAAI-88, pages 439-443 . Morgan Kauf mann, 1988. Held Minneapolis, MN.\n[Lifschitz, 1985] V. Lifschitz. Computing circumscrip tion. In Proceedings /JCAI-85, pages 121-127, Los Angeles, CA, 1985.\n[Lifschitz, 1987] Vladimir Lifschitz. On the declara tive semantics of logic programs with negation. In Matthew L. Ginsberg, editor, Readings in Nonmono tonic Reasoning. Morgan Kaufmann, San Francisco, CA, 1987.\n[Lifschitz, 1988] V. Lifschitz. On the declarative se mantics of logic programs. In J. Minker, editor, Foun dations of Deductive Databases and Logic Program ming, pages 177-192. Morgan Kaufmann, Los Altos, CA., 1988.\n[Loui, 1987] R. Loui. Defeat among arguments: A sys tem of defeasible inference. Computational Intelli gence, 3(3) : 100-107, 1987.\n[McCarthy, 1986] J. McCarthy. Applications of circum scription to formalizing commonsense knowledge. A r tificial Intelligence, 28:89-116, 1986.\n[Moore, 1985] R. Moore. Semantical considerations on non-monotonic logics. Artificial Intelligence, 25:75- 94, 1985.\n[Nebel, 1989] Bernhard Nebel. A knowledge-level analysis of belief revision. In Proceedings of the First International Conference on Principles of Knowl edge Representation and Reasoning, pages 301-31 1 , San Francisco, CA, 1989. Morgan Kaufmann. Held Toronto, Canada.\n[Pearl, 1990] Judea Pearl. System z: A natural or dering of defaults with tractable applications to nonmonotonic reasoning. In Proceedings of the Third Conference on Theoretical Aspects of Reason ing about Knowledge (TARC '90), pages 121-135, 1990. Held Pacific Grove, CA.\n[Pollock, 1987] J . Pollock. Defeasible reasoning. Cog nitive Science, 1 1 :481-518, 1987.\n[Poole, 1988] D. Poole. A logical framework for default reasoning. Artificial Intelligence, 36:27-47, 1988.\n[Poole, 1992] David Poole. Decision-theoretic defaults. In Proceedings of Canadian AI Conference (CSCSI92), pages 190-197, Vancouver, B . C. , May 1992.\n[Przymusinski, 1988] Teodor Przymusinski. On the de clarative semantics of deductive databases and logic programs. In J . Minker, editor, Foundations of De ductive Databases and Logic Programming. Morgan Kaufmann, San Francisco, CA. , 1988.\n[Przymusinski, 1989] T. Przymusinski. An algorithm for circumscription. Artificial Intelligence, 38:49-73, 1989.\n[Quantz and Royer, 1992] J. Joachim Quantz and V eronique Royer. A preference semantics for de faults in terminological logics. In Proceedings of KR '92: the Third International Conference on Prin ciples of Knowledge Representation and Reasoning, pages 294-305, San Francisco, California, 1992. Mor gan Kaufmann.\n[Reiter, 1980] R. Reiter. A logic for default reasoning. Artificial Intelligence, 12:81-132, 1980.\n[Ryan, 1992a] Mark Ryan. Ordered Presentations of Theories - Default Reasoning and Belief Revision. PhD thesis, University of London, London, England, U .K. , 1992. Author's address: Department of Com puting, Imperial College, London SW7 2BZ, Eng land, U.K.\n[Ryan, 1992b] Mark Ryan. Representing defaults as sentences with reduced priority. In Proceedings of KR '92: the Third International Conference on Prin ciples of Knowledge Representation and Reasoning, pages 649-660, San Francisco, California, 1992. Mor gan Kaufmann.\n[Shoham, 1988] Y. Shoham. Reasoning about Change: Time and Causation from the Standpoint of Artificial Intelligence. MIT Press, Cambridge, Mass. , 1988.\n[Stein, 1989] Lynn A. Stein. Skeptical inheritance: Computing the intersection of credulous extensions. In Proceedings of /JCAI-89, pages 1 153-1158. Mor gan Kaufmann, 1989. Held Detroit, MI.\n[Stillman, 1992] Jonathan Stillman. The complexity of propositional default logics. In Proceedings of the Tenth National Conference on Artificial Intelligence (AAAI-92}, pages 794-799, Cambridge, Mass. , 1992. AAAI Press / MIT Press.\n[Touretzky, 1986] D. Touretzky. The Mathematics of Inheritance Systems. Pitman, London, 1986.\n[Zadrozny, 1987] W. Zadrozny. A theory of default rea soning. In Proceedings of the Sixth National Con ference on Artificial Intelligence ( AAAI-87), pages 385-390, Seattle, Washington, 1987."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2011,
    "abstractText" : "We show how to transform any set of priori­ tized propositional defaults into an equivalent set of parallel (i.e. , unprioritized) defaults, in circumscription. We give an algorithm to im­ plement the transform. We show how to use the transform algorithm as a generator of a whole family of inferencing algorithms for cir­ cumscription. The method is to employ the transform algorithm as a front end to any in­ ferencing algorithm, e.g . , one of the previously available, that handles the parallel (empty) case of prioritization. Our algorithms provide not just coverage of a new expressive class, but also alternatives to previous algorithms for im­ plementing the previously covered class (lay­ ered) of prioritization. In particular, we give a new query-answering algorithm for prioritized cirumscription which is sound and complete for the full expressive class of unrestricted finite prioritization par­ tial orders, for propositional defaults (or mini­ mized predicates). By contrast, previous algo­ rithms required that the prioritization partial order be layered, i .e . , structured similar to the system of rank in the military. Our algorithm enables, for the first time, the implementation of the most useful class of pri­ oritization: non-layered prioritization partial orders. Default inheritance, for example, typi­ cally requires non-layered prioritization to rep­ resent specificity adequately. Our algorithm enables not only the implementation of de­ fault inheritance (and specificity) within pri­ oritized circumscription, but also the exten­ sion and combination of default inheritance with other kinds of prioritized default reason­ ing, e.g . : with stratified logic programs with negation-as-failure. Such logic programs are previously known to be representable equiv­ alently as layered-priority predicate circum­ scriptions. Worst-case, the transform increases the num­ ber of defaults exponentially. We discuss how inferencing is practically implementable nevertheless in two kinds of situations: general expressiveness but small numbers of defaults, or expressive special cases with larger numbers of defaults. One such expressive special case is non-top-heaviness of the prioritization partial order. In addition to its direct implementation, the transform can also be exploited analytically to generate special case algorithms, e.g . , a tractable transform for a class within default inheritance (detailed in another, forthcoming paper) . We discuss other aspects o f the significance of the fundamental result . One can view the transform as reducing n degrees of partially or­ dered belief confidence to just 2 degrees of con­ fidence: for-sure and ( unprioritized) default. Ordinary, parallel default reasoning, e.g. , in parallel circumscription or Poole's Theorist, can be viewed in these terms as reducing 2 degrees of confidence to just 1 degree of con­ fidence: that of the non-monotonic theory's conclusions. The expressive reduction's com­ putational complexity suggests that prioritiza­ tion is valuable for its expressive conciseness, just as defaults are for theirs. For Reiter's Default Logic and Poole's Theo­ rist , the transform implies how to extend those formalisms so as to equip them with a concept of prioritization that is exactly equivalent to that in circumscription. This provides an in­ teresting alternative to Brewka's approach to equipping them with prioritization-type prece­ dence. A longer version of this paper, including the proof of the central transform result, will soon be available as an IBM Research Report.",
    "creator" : "pdftk 1.41 - www.pdftk.com"
  }
}