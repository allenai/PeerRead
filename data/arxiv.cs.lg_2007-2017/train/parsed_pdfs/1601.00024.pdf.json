{
  "name" : "1601.00024.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Selecting Near-Optimal Learners via Incremental Data Allocation",
    "authors" : [ "Ashish Sabharwal", "Horst Samulowitz", "Gerald Tesauro" ],
    "emails" : [ "AshishS@allenai.org", "samulowitz@us.ibm.com", "gtesauro@us.ibm.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We further develop substantial theoretical support for DAUB in an idealized setting where the expected accuracy of a classifier trained on n samples can be known exactly. Under these conditions we establish a rigorous sub-linear bound on the regret of the approach (in terms of misallocated data), as well as a rigorous bound on suboptimality of the selected classifier. Our accuracy estimates using real-world datasets only entail mild violations of the theoretical scenario, suggesting that the practical behavior of DAUB is likely to approach the idealized behavior."
    }, {
      "heading" : "1 Introduction",
      "text" : "The goal of our work is to develop novel practical methods to enhance tractability of Data Science practice in the era of Big Data. Consider, for example, the following very common scenario: A Data Science practitioner is given a data set comprising a training set, a validation set, and a collection of classifiers in an ML toolkit, each of which may have numerous possible hyper-parameterizations. The practitioner would like to determine which classifier/parameter combination (hereafter referred to as “learner”) would yield the highest validation accuracy, after training on all examples in the training set. However, the practitioner may have quite limited domain knowledge of salient characteristics of the data, or indeed of many of the algorithms in the toolkit.\nIn such a scenario, the practitioner may inevitably resort to the traditional approach to finding the best learner [cf. 12], namely, brute-force training of all learners on the full training set, and selecting the one with best validation accuracy. Such an approach is acceptable if the computational cost of training all learners is not an issue. However, in the era of Big Data, this is becoming increasingly infeasible. Web-scale datasets are proliferating from sources such as Twitter, TREC, SNAP, ImageNet, and the UCI repository, particularly in domains such as vision and NLP. ImageNet datasets can exceed 100 gigabytes, and the recent “YouTube-Sports-1M” video collection exceeds 40 terabytes. Moreover, the diverse set of learners available in today’s ML packages [18, 22, 24, 26]\nar X\niv :1\n60 1.\n00 02\n4v 1\n[ cs\n.L G\n] 3\n1 D\nec 2\n01 5\nare continually expanding, and many of the most successful recent algorithms entail very heavy training costs (e.g., Deep Learning neural nets with Dropout).\nThe above factors motivate a search for techniques to reduce training cost while still reliably finding a near-optimal learner. One could consider training each learner on a small subset of the training examples, and choose the best performing one. This entails less computation, but could result in significant loss of learner accuracy, since performance on a small subset can be a misleading predictor of performance on the full dataset. As an alternative, the small-subset results could be projected forward using parameterized accuracy models to predict full training set accuracy. Creating such models is, however, a daunting task [16], potentially needing prior knowledge about learners and domain, characteristic features of the data, etc.\nIn this paper, we develop a novel formulation of what it means to solve the above dual-objective problem, and we present a novel solution approach, inspired by multi-armed bandit literature [1, 3, 27, 29]. Our method develops model-free, cost-sensitive strategies for sequentially allocating small batches of training data to selected learners, wherein “cost” reflects misallocated samples that were used to train other learners that were ultimately not selected. We express the cost in terms of the regret of the approach, comparing the algorithm’s cost with that of an oracle which only allocates data to the best learner.\nOur main contributions are as follows. First, we give a precise definition of a new ML problem setting, called the Cost-Sensitive Training Data Allocation Problem. Second, we present a simple, knowledge-free, easy-to-use and practical new algorithm for this setting, called DAUB (Data Allocation with Upper Bounds). Third, we give empirical demonstrations that DAUB achieves significant savings in training time while reliably achieving optimal or near-optimal learner accuracy over multiple real-world datasets. Fourth, we provide theoretical support for DAUB in an idealization of the real-world setting, wherein DAUB can work with noiseless accuracy estimates when training on n samples, in lieu of actual noisy estimates. The real-world behavior of DAUB will progressively approach the idealized behavior as n becomes large. In this setting, we establish a bound on accuracy of learners selected by DAUB, a sub-linear bound on the data misallocated by DAUB, and an associated bound on the computational training cost (regret).\nRelated work on traditional bandit strategies mentioned above, such as the celebrated UCB1 [3] and Thompson sampling [1, 29], presume that additional trials of a given arm yield stationary payoffs. Whereas in our scenario, additional data allocations to a learner yield increasing values of its accuracy. There are also existing methods to optimize a single arbitrary function while minimizing the number of evaluations [cf. 23]. These also do not fit our setting: we are dealing with multiple unknown but well-behaved functions, and wish to rank them on estimated accuracy after training on the full dataset, based on their upper-bounds from much fewer samples.\nSomewhat related is algorithm portfolio selection [25] which seeks the most suitable algorithm (e.g., learner) for a given problem instance, based on knowledge from other instances and features characterizing the current instance. Note, however, that most selection algorithms use parameterized accuracy models which are fit to data [e.g., 20]. Also related is work on hyper-parameter optimization, where one searches for novel configurations of algorithms to improve performance [5–7, 28] or a combination of both [15]. An example is Auto-Weka [30], which combines selection and parameter configuration based on Bayesian optimization [cf. 11]. Predicting generalization error on unseen data has in fact been recognized as a major ML challenge [17].\nA recent non-frequentist approach [19] takes a Bayesian view of multi-armed bandits, applicable especially when the number of arms exceeds the number of allowed evaluations, and applies it also to\nautomatic selection of ML algorithms. Like some prior methods, it evaluates algorithms on a small fixed percentage (e.g., 10%) of the full dataset. Unlike the above approaches, we do not assume that training (and evaluation) on a small fixed fraction of the data reliably ranks full-training results.\nFinally, Domhan et al. [13] recently proposed extrapolating learning curves to enable early termination of non-promising learners. Their method is designed specifically for neural networks and does not apply directly to many classifiers (SVMs, trees, etc.) that train non-iteratively from a single pass through the dataset. They also do not focus on a theoretical justification and fit accuracy estimates to a library of hand-designed learning curves."
    }, {
      "heading" : "2 Cost-Sensitive Training Data Allocation",
      "text" : "We begin by formally defining the problem of cost-sensitive training data allocation. As before, we use learner to refer to a classifier along with a hyper-parameter setting for it. Let C = C1, C2, . . . , CM be a set of M learners which can be trained on subsets of a training set Tr and evaluated on a validation set Tv. Let |Tr| = N . For k ∈ N, let [k] denote the set {1, 2, . . . , k}.\nFor i ∈ [M ], let ci : [N ] → R+ be a cost function denoting expected computational cost of training learner Ci when n training examples are drawn uniformly at random from Tr.\n1 We make two common assumptions about the training process, namely, that it looks at all training data and its complexity grows at least linearly. Formally, ci(n) ≥ n and ci(m) ≥ mn ci(n) for m > n.\nFor i ∈ [M ], let fi : [N ]→ [0, 1] be an accuracy function where fi(n) denotes expected accuracy of Ci on Tv when trained on n training examples chosen at random from Tr. The corresponding error function, ei(n), is defined as 1 − fi(n). Note that our tool also supports accuracy functions not tied to a fixed validation set Tv (e.g., cross-validation) and other measures such as precision, recall, and F1-score; our analysis applies equally well to these measures.\nWe denote a training data allocation of n training samples to learner i by a pair a = (i, n). Let S = ( (i(1), n(1)), (i(2), n(2)), . . . , (i(s), n(s)) ) be a sequence of allocations to learners in C. We will use Si to denote the induced subsequence containing all training data allocations to learner Ci, i.e., the subsequence of S induced by all pairs (i(k), n(k)) such that i(k) = i. In our context, if allocations (i, n(k)) and (i, n(`)) are in Si with k < `, then n\n(k) < n(`). Evaluating fi(n) amounts to training learner Ci on n examples from Tr and evaluating its accuracy. This, in expectation, incurs a computational cost of ci(n). In general, the expected training complexity or cost associated with C under the data allocation sequence S is cost(S) =∑\n(i,n)∈S ci(n).\nOur goal is to search for an ĩ ∈ [M ] such that fĩ(N) is maximized, while also ensuring that overall training cost is not too large relative to cĩ(N). This bi-objective criterion is not easy to achieve. E.g., a brute-force evaluation, corresponding to S = ((1, N), (2, N), . . . , (M,N)) and ĩ = arg maxi∈[M ] fi(N), obtains the optimal ĩ but incurs maximum training cost of ci(N) for all\nsuboptimal learners. On the other hand, a low-cost heuristic S = ( (1, n), (2, n), . . . , (m,n), (̃i,N) ) for some n N and ĩ = arg maxi fi(n), incurs a small training overhead of only ci(n) for each suboptimal Ci, but may choose an arbitrarily suboptimal ĩ.\nWe seek an in-between solution, ideally with the best of both worlds: a bounded optimality gap on Cĩ’s accuracy, and a bounded regret in terms of data misallocated to sufficiently suboptimal\n1While we define the core concepts in terms of expected values suitable for a formal definition and idealized analysis, the actual DAUB algorithm will operate on observed values of ci on particular subsets of n training examples chosen at runtime.\nlearners. Informally speaking, we will ensure that learners with performance at least ∆ worse than optimal are allocated only o(N) training examples, i.e., an asymptotically vanishing fraction of Tr. Under certain conditions, this will ensure that the training cost regret is sublinear. We next formally define the notions of suboptimality and regret in this context.\nDefinition 1. Let C be a collection of M learners with accuracy functions fi, ∆ ∈ (0, 1], n ∈ N+, and i∗ = arg maxi∈[M ] fi(n). A learner Cj ∈ C is called (n,∆)-suboptimal for C if fi∗(n)−fj(n) ≥ ∆, and (n,∆)-optimal otherwise.\nDefinition 2. Let S be a data allocation sequence for a collection C of learners with accuracy functions fi, ∆ ∈ (0, 1], and n ∈ N+. The (n,∆)-regret of S for C is defined as:∑\ni:Ci is (n,∆)-suboptimal\ncost(Si)\nThe regret of S is thus the cumulative cost of training all (n,∆)-suboptimal learners when using S.\nDefinition 3 (COST-SENSITIVE TRAINING DATA ALLOCATION PROBLEM). Let C = {C1, . . . , CM} be a set of learners, Tr be a training set for C containing N examples, Tv be a validation set, ci and fi, for i ∈ [M ], be the training cost and accuracy functions, resp., for learner Ci, and ∆ ∈ (0, 1] be a constant. The Cost-Sensitive Training Data Allocation Problem is to compute a training data allocation sequence S for C and Tr as well as a value ĩ ∈ [M ] such that:\n1. S contains (̃i,N),\n2. Cĩ is (N,∆)-optimal,\n3. cost(Sĩ) ≤ d · cĩ(N) for some fixed constant d, and\n4. (N,∆)-regret of S is o(M · cost(Sĩ)) in N .\nA solution to this problem thus identifies an (N,∆)-optimal learner Cĩ, trained on all of Tr, incurring on Cĩ no more than a constant factor overhead relative to the minimum training cost of cĩ(N), and with a guarantee that any (N,∆)-suboptimal learner Ci incurred a vanishingly small training cost compared to training Cĩ (specifically, cost(Si)/cost(Sĩ)→ 0 as N →∞)."
    }, {
      "heading" : "3 The DAUB Algorithm",
      "text" : "Algorithm 1 describes our Data Allocation using Upper Bounds strategy. The basic idea is to project an optimistic upper bound on full-training accuracy fi(N) of learner i using recent evaluations fi(n). The learner with highest upper bound is then selected to receive additional samples. Our implementation of DAUB uses monotone regression to estimate upper bounds on fi(N) as detailed below, since observed accuracies are noisy and may occasionally violate known monotonicity of learning curves. Whereas in the noise-free setting, a straight line through the two most recent values of fi(n) provides a strict upper bound on fi(N).\nAs a bootstrapping step, DAUB first allocates b, br, and br2 ≤ N training examples to each learner Ci, trains them, and records their training and validation accuracy in arrays f T i and f V i ,\nInput : Learners C = {C1, . . . , CM}, training examples Tr, N = |Tr|, validation set Tv Output : Learner Cĩ trained on Tr, data allocation sequence S Params: Geometric ratio r > 1, granularity b ∈ N+ s.t. br2 ≤ N DAUB(C, Tr, Tv, r, b) begin\nS ← empty sequence for i ∈ 1..M do\nfor k ∈ 0..2 do append (i, brk) to S TrainLearner (i, brk) ni ← br2 ui ← UpdateBound (i, ni)\nwhile (maxi ni) < N do j ← arg maxi∈[M ] ui (break ties arbitrarily) nj ← min{drnje, N} append (j, nj) to S TrainLearner (j, nj) uj ← UpdateBound (j)\nselect ĩ such that nĩ = N return Cĩ, S\nend\nsub TrainLearner(i ∈ [M ], n ∈ [N ]) begin\nT ← n examples sampled from Tr Train Ci on T fTi [n]← training accuracy of Ci on T fVi [n]← validation accuracy of Ci on Tv if n/r ≥ b then\nδ ← (fVi [n]− fVi [n/r]) if δ < 0 then\nfVi [n/r] −= δ/2 fVi [n] += δ/2\nend\nsub UpdateBound(i ∈ [M ], n ∈ [N ]) begin\nf ′Vi [n]← LinearRegrSlope(fVi [n/r2], fVi [n/r], fVi [n]) ubVi [n]← fVi [n] + (N − n)f ′Vi [n] return min{fTi [n], ub V i [n]}\nend\nAlgorithm 1: Data Allocation using Upper Bounds\nresp. If fVi at the current point is smaller than at the previous point, DAUB uses a simple monotone regression method, making the two values meet in the middle.\nAfter bootstrapping, in each iteration, it identifies a learner Cj that has the most promising upper bound estimate (computed as discussed next) on the unknown projected expected accuracy fj(N) and allocates r times more examples (up to N) to it than what Cj was allocated previously. For computing the upper bound estimate, DAUB uses two sources. First, assuming training and\nvalidation data come from the same distribution, fTi [ni] provides such an estimate. Further, as will be justified in the analysis of the idealized scenario called DAUB*, ubVi [ni] = f V i [ni]+(N−ni)f ′Vi [ni] also provides such an estimate under certain conditions, where f ′Vi [ni] is the estimated derivative computed as the slope of the linear regression best fit line through fVi [n] for n ∈ {ni/r2, ni/r, ni}. Once some learner Cĩ is allocated all N training examples, DAUB halts and outputs Cĩ along with the allocation sequence it used."
    }, {
      "heading" : "3.1 Theoretical Support for DAUB",
      "text" : "To help understand the behavior of DAUB, we consider an idealized variant, DAUB*, that operates precisely like DAUB but has access to the true expected accuracy and cost functions, fi(n) and ci(n), not just their observed estimates. As n grows, learning variance (across random batches of size n) decreases, observed estimates of fi(n) and ci(n) converge to these ideal values, and the behavior of DAUB thus approaches that of DAUB*.\nLet f∗ = maxi∈[M ] fi(N) be the (unknown) target accuracy and Ci∗ be the corresponding (unknown) optimal learner. For each Ci, let ui : [N ]→ [0, 1] be an arbitrary projected upper bound estimate that DAUB* uses for fi(N) when it has allocated n < N training examples to Ci. We will assume w.l.o.g. that ui is non-increasing at the points where it is evaluated by DAUB*.\n2 For the initial part of the analysis, we will think of ui as a black-box function, ignoring how it is computed. Let umin(N) = mini∈[N ]{ui(N)}. It may be verified that once uj(n) drops below umin(N), DAUB* will stop allocating more samples to Cj . While this gives insight into the behavior of DAUB*, for the analysis we will use a slightly weaker form n∗i that depends on the target accuracy f\n∗ rather than umin(N).\nDefinition 4. ui : [N ] → [0, 1] is a valid projected upper bound function if ui(n) ≥ fi(N) for all n ∈ [N ].\nDefinition 5. Define n∗i ∈ N as N if ui(N) ≥ f∗ and as min{` | ui(`) < f∗} otherwise.\nA key observation is that when using uj as the only source of information about Cj , one must allocate at least n∗j examples to Cj before acquiring enough information to conclude that Cj is suboptimal. Note that n∗j depends on the interaction between uj and f\n∗, and is thus unknown. Interestingly, we can show that DAUB*(C, Tr, Tv, r, b) allocates to Cj at most a constant factor more examples, specifically fewer than rn∗j in each step and r2 r−1n ∗ j in total, if it has access to valid projected upper bound functions for Cj and Ci∗ (cf. Lemma 1 in Appendix). In other words, DAUB*’s allocation is essentially optimal w.r.t. uj .\nRemark 1. A careful selection of the learner in each round is critical for allocation optimality w.r.t. uj . Consider a simpler alternative: In round k, train all currently active learners on n = br k examples, compute all fi(n) and ui(n), and permanently drop Cj from consideration if uj(n) < fi(n) for some Ci. This will not guarantee allocation optimality; any permanent decisions to drop a classifier must necessarily be conservative to be correct. By instead only temporarily suspending suboptimal looking learners, DAUB* guarantees a much stronger property: Cj receives no more allocation as soon as uj(n) drops below the (unknown) target f ∗.\nThe following observation connects data allocation to training cost: if DAUB* allocates at most n training examples to a learner Cj in each step, then its overall cost for Cj is at most r r−1cj(n)\n2Since DAUB* evaluates ui for increasing values of n, it is easy to enforce monotonicity.\n(cf. Lemma 2 in Appendix). Combining this with Lemma 1, we immediately obtain the following result regarding DAUB*’s regret:3\nTheorem 1. Let C, Tr, Tv, N,M, ci and fi for i ∈ [M ] be as in Definition 3. Let r > 1, b ∈ N+, and S be the allocation sequence produced by DAUB*(C, Tr, Tv, r, b). If the projected upper bound functions uj and ui∗ used by DAUB* are valid, then cost(Sj) ≤ rr−1cj(rn ∗ j ).\nIn the remainder of the analysis, we will (a) study the validity of the actual projected upper bound functions used by DAUB* and (b) explore conditions under which (N,∆)-suboptimality of Cj guarantees that n ∗ j is a vanishingly small fraction of N , implying that DAUB* incurs a vanishingly small training cost on any (N,∆)-suboptimal learner."
    }, {
      "heading" : "3.1.1 Obtaining Valid Projected Upper Bounds",
      "text" : "If fi for i ∈ [M ] were arbitrary functions, it would clearly be impossible to upper bound fi(N) by looking only at estimates of fi(n) for n < N . Fortunately, each fi is the expected accuracy of a learner and is thus expected to behave in a certain way. In order to bound DAUB*’s regret, we make two assumptions on the behavior of fi. First, fi is non-decreasing, i.e., more training data does not hurt validation accuracy. Second, fi has a diminishing returns property, namely, as n grows, the additional validation accuracy benefit of including more training examples diminishes. Formally:\nDefinition 6. f : N→ [0, 1] is well-behaved if it is non-decreasing and its discrete derivative, f ′, is non-increasing.\nThese assumptions on expected accuracy are well-supported from the PAC theory perspective. Let ubi(n) be the projected upper bound function used by DAUB* for Ci, namely the minimum of the training accuracy fTi (n) of Ci at n and the validation accuracy based expression fi(n) + (N − n)f ′i(n). For DAUB*, we treat f ′ i(n) as the one-sided discrete derivative defined as (fi(n)− fi(n− s))/s for some parameter s ∈ N+. We assume the training and validation sets, Tr and Tv, come from the same distribution, which means fTi (n) itself is a valid projected upper bound. Further, we can show that if fi(n) is well-behaved, then ubi(n) is a valid projected upper bound function (cf. Lemma 3 in Appendix).\nThus, instead of relying on a parameterized functional form to model fi(n), DAUB* evaluates fi(n) for certain values of n and computes an expression that is guaranteed to be a valid upper bound on fi(N) if fi is well-behaved."
    }, {
      "heading" : "3.1.2 Bounding Regret",
      "text" : "We now fix ubi as the projected upper bound functions and explore how (N,∆)-suboptimality and the well-behaved nature of fi together limit how large n ∗ i is.\nDefinition 7. For ∆ ∈ (0, 1] and a well-behaved accuracy function fi, define n∆i ∈ N as N if f ′i(N) > ∆/N and as min{` | f ′i(`) ≤ ∆/N} otherwise.\nUsing first order Taylor expansion, we can prove that ubi(n ∆ i ) < f ∗, implying n∗j ≤ n∆j (cf. Lemma 4 in Appendix). Combining this with Theorem 1, we obtain:\n3All proofs are deferred to the Appendix.\nTheorem 2. Let C, Tr, Tv, N,M, ci and fi for i ∈ [M ] be as in Definition 3. Let r > 1, b ∈ N+,∆ ∈ (0, 1], Cj ∈ C be an (N,∆)-suboptimal learner, and S be the allocation sequence produced by DAUB*(C, Tr, Tv, r, b). If fj and fi∗ are well-behaved, then cost(Sj) ≤ rr−1cj(rn ∆ j ).\nThe final piece of the analysis is an asymptotic bound on n∆i . To this end, we observe that the derivative of any bounded, well-behaved, discrete function of N behaves asymptotically as o(1/n) (cf. Proposition 1 in Appendix). Applying this to fj , we can prove that if f ′ j(N) ≤ ∆/N , then n∆j is o(N) in N (cf. Lemma 5 in Appendix). This leads to our main result regarding DAUB*’s regret:\nTheorem 3 (Sub-Linear Regret). Let C, Tr, Tv, N,M, ci and fi for i ∈ [M ] be as in Definition 3. Let r > 1, b ∈ N+, and ∆ ∈ (0, 1]. Let J = {j | Cj ∈ C is (N,∆)-suboptimal}. For all j ∈ J , suppose fj is well-behaved and f ′ j(N) ≤ ∆/N . If DAUB*(C, Tr, Tv, r, b) outputs S as the training data allocation sequence along with a selected learner Cĩ trained on all of Tr, then:\n1. cost(Sĩ) ≤ r r−1cĩ(N); 2. (N,∆)-regret of S is o( ∑\nj∈J cj(N)) in N ; and\n3. If cj(n) = O(cĩ(n)) for all j ∈ J , then the (N,∆)-regret of S is o(M · cost(Sĩ)) in N .\nThus, DAUB* successfully solves the cost-sensitive training data allocation problem whenever for j ∈ J , fj is well-behaved and cj(n) = O(cĩ(n)), i.e., training any suboptimal learner is asymptotically not any costlier than training an optimal learner. While more refined versions of this result can be generated, the necessity of an assumption on the cost function is clear: if a suboptimal learner Cj was arbitrarily costlier to train than optimal learners, then, in order to guarantee near-optimality, one must incur a significant misallocation cost training Cj on some reasonable subset of Tr in order to ascertain that Cj is in fact suboptimal."
    }, {
      "heading" : "3.1.3 Tightness of Bounds",
      "text" : "The cost bound on misallocated data in Theorem 2 in terms of n∆i is in fact tight (up to a constant factor) in the worst case, unless further assumptions are made about the accuracy functions. In particular, every algorithm that guarantees (N,∆)-optimality without further assumptions must, in the worst case, incur a cost of the order of cj(n ∆ j ) for every suboptimal Cj ∈ C (cf. Theorem 5 in Appendix for a formal statement):\nTheorem 4 (Lower Bound, informal statement). Let ∆ ∈ (0, 1] and A be a training data allocation algorithm that always outputs an (N,∆)-optimal learner. Then there exists an (N,∆)-suboptimal learner Cj that would force A to incur a misallocated training cost larger than cj(n∆j )/2."
    }, {
      "heading" : "4 Experiments",
      "text" : "Our experiments make use of 41 classifiers covering a wide range of algorithms (SVMs, Decision Trees, Neural Networks, Logistic Regression, etc.) as implemented in WEKA [18]. All experiments were conducted on AMD Opteron 6134 machines with 32 cores and 64 GB memory, running Scientific Linux 6.1.4\n4Code and data, including full parameterization for each classifier, are available from the authors.\nWe first evaluate DAUB on one real-world binary classification dataset, “Higgs boson” [4] and one artificial dataset, “Parity with distractors,” to examine robustness of DAUB’s strategy across two extremely different types of data. In the latter task the class label is the parity of a (hidden) subset of binary features—the remaining features serve as distractors, with no influence on the class label. We generated 65,535 distinct examples based on 5-bit parity with 11 distractors, and randomly selected 21,500 samples each for Tr and Tv. For the Higgs and other real-world datasets, we first randomly split the data with a 70/30 ratio and selected 38,500 samples for Tr from the 70% split and use the 30% as Tv . We coarsely optimized the DAUB parameters at b = 500 and r = 1.5 based on the Higgs data, and kept those values fixed for all datasets. This yielded 11 possible allocation sizes: 500, 1000, 1500, 2500, 4000, 5000, 7500, 11500, 17500, 25500, 385005.\nResults for HIGGS and PARITY are as follows. The accuracy loss of the ultimate classifiers selected by DAUB turned out to be quite small: DAUB selected the top classifier for HIGGS (i.e. 0.0% loss) and one of the top three classifiers for PARITY (0.3% loss). In terms of complexity reduction, Table 1 shows clear gains over “full” training of all classifiers on the full Tr, in both total allocated samples as well total CPU training time, for both standard DAUB as well as a variant which does not use training set accuracy fT as an upper bound. Both variants reduce the allocated samples by ∼2x-4x for HIGGS, and by ∼5x for PARITY. The impact on CPU runtime is more pronounced, as many sub-optimal classifiers with supra-linear runtimes receive very small amounts of training data. As the table shows, standard DAUB reduces total training time by a factor of ∼25x for HIGGS, and ∼15x for PARITY.\nFigures 1 and 2 provide additional insight into DAUB’s behavior. Figure 1 shows how validation accuracy progresses with increasing training data allocation to several classifiers on the HIGGS dataset. The plots for the most part conform to our ideal-case assumptions of increasing accuracy with diminishing slope, barring a few monotonicity glitches6 due to stochastic sampling noise. We note that, while there is one optimal classifier C∗ (a parameterization of a Rotation Forest) with best validation accuracy after training on all of Tr, there are several other classifiers that outperformed C∗ in early training. For instance, LADTree is better than C∗ until 5,000 examples but then flattens out.\nFigure 2 gives perspective on how DAUB distributes data allocations among the 41 classifiers when run on the HIGGS dataset. The classifiers here are sorted by decreasing validation accuracy fi(N). While DAUB manages to select C\n∗ in this case, what’s equally critical is the distribution of allocated training data. The figure shows that DAUB allocates most of the training data to the top eight classifiers. Most classifiers receive 2500 or fewer samples, and only four classifiers receive more than 10k samples, with all of them within 1.5% of the optimal performance.\n5Unfortunately some of our classifiers crash and/or run out of memory above 38500 samples. 6 In our experience, most of these glitches pertain to weak classifiers and thus would not significantly affect DAUB,\nsince DAUB mostly focuses its effort on the strongest classifiers.\nFinally, in Table 2 we report results of DAUB on Higgs plus five other real-world benchmarks as indicated: Buzz [21]; Covertype [10]; Million Song Dataset [8]; SUSY [4]; and Vehicle-SensIT [14]. These experiments use exactly the same parameter settings as for HIGGS and PARITY. As before, the table shows a comparison in terms of allocated training samples and runtime. In addition it displays the incurred accuracy loss of DAUB’s final selected classifier. The highest loss is ∼1%, well within an acceptable range. The average incurred loss across all six benchmarks is 0.4% and the average speedup is 16x. Our empirical findings thus show that in practice DAUB can consistently\nselect near-optimal classifiers at a substantial reduced computational cost when compared to full training of all classifiers."
    }, {
      "heading" : "5 Conclusion",
      "text" : "We reiterate the potential practical impact of our original Cost-Sensitive Training Data Allocation problem formulation, and our proposed DAUB algorithm for solving this problem. In our experience, DAUB has been quite easy to use, easy to code and tune, and is highly practical in robustly finding near-optimal learners with greatly reduced CPU time across datasets drawn from a variety of real-world domains. Moreover, it does not require built-in knowledge of learners or properties of datasets, making it ideally suited for practitioners without domain knowledge of the learning algorithms or data characteristics. Furthermore, all intermediate results can be used to interactively inform the practitioner of relevant information such as progress (e.g., updated learning curves) and decisions taken (e.g., allocated data). Such a tool was introduced by Biem et al. [9] and a snapshot of it is depicted in Figure 3.\nOur theoretical work on the idealized DAUB* scenario also reveals novel insights and provides important support for the real-world behavior of DAUB with noisy accuracy estimates. As dataset sizes scale, we expect that DAUB will better and better approach the idealized behavior of DAUB*, which offers strong bounds on both learner sub-optimality as well as regret due to misallocated samples.\nThere are many opportunities for further advances in both the theoretical and practical aspects of this work. It should be possible to develop more accurate bound estimators given noisy accuracy estimates, e.g., using monotone spline regression. Likewise, it may be possible to extend the theory to encompass noisy accuracy estimates, for example, by making use of PAC lower bounds on generalization error to establish upper bounds on learner accuracy. DAUB could be further combined in an interesting way with methods [2] to optimally split data between training and validation sets."
    }, {
      "heading" : "A Appendix: Proof Details",
      "text" : "Lemma 1. Let C, Tr, Tv, N,M, and fi for i ∈ [M ] be as in Definition 3. Let r > 1 and b ∈ N+. If the projected upper bound functions uj and ui∗ used by DAUB*(C, Tr, Tv, r, b) are valid, then it allocates to Cj fewer than rn ∗ j examples in each step and r2 r−1n ∗ j examples in total.\nProof of Lemma 1. Suppose, for the sake of contradiction, that DAUB* allocates at least rn∗j examples to learner Cj at some point in its execution. Since r > 1 and all allocation sizes are at most N , n∗j < N . Further, since nj , the number of examples allocated to Cj , is always incremented geometrically by a factor of at most r, at some previous point in the algorithm, we must have nj ∈ {n∗j , . . . , rn∗j − 1}. Since the projected upper bound function uj is non-increasing, at that previous point in the algorithm, uj(nj) ≤ uj(n∗j ) < f∗ by the definition of n∗j . On the other hand, since the projected upper bound function ui∗ is valid, the projected upper bound for Ci∗ would always be at least f∗.\nTherefore, the algorithm, when choosing which learner to allocate the next set of examples to, will, from this point onward, always prefer Ci∗ (and possibly another learner appearing to be even better) over Cj , implying that nj will never exceed its current value. This contradicts the assumption that DAUB* allocates at least rn∗j examples to Cj at some point during its execution.\nFor the bound on the total number of examples allocated to Cj , let k = blogr rn∗j b c. Since DAUB* allocates fewer than rn∗j examples to Cj in any single step and the allocation sizes start at b and increase by a factor of r in each step, Cj must have received precisely b+ br+ br 2 + . . .+ brk examples in total. This is smaller than rr−1br k ≤ r2r−1n ∗ j .\nLemma 2. Let C, Tr, Tv, N,M, and ci for i ∈ [M ] be as in Definition 3. Let r > 1, b ∈ N+, and S be the training data allocation sequence produced by DAUB*(C, Tr, Tv, r, b). If DAUB* allocates at most n training examples to a learner Cj ∈ C in each step, then cost(Sj) ≤ rr−1cj(n).\nProof of Lemma 2. As in the proof of Lemma 1, let k = blogr(n/b)c and observe that the data allocation subsequence Sj for learner Cj must have been (b, br, br\n2, . . . , brk). The corresponding training cost for Cj is cost(Sj) = cj(b) + cj(br) + cj(br 2) + . . . cj(br k). By the assumption that cj grows at least linearly: cj(br `) ≤ cj(br k)\nrk−` for ` ≤ k. It follows that:\ncost(Sj) ≤ cj(brk) · (r−k + r−k+1 + r−k+2 + . . .+ 1)\n< r\nr − 1 cj(br k) ≤ r r − 1 cj(n)\nThis finishes the proof.\nLemma 3. If fi(n) is well-behaved, then ubi(n) is a valid projected upper bound function.\nProof of Lemma 3. Recall that ubi(n) is the minimum of f T i (n) and fi(n) + (N − n)f ′i(n). Since fTi (n) is a non-increasing function and is already argued to be an upper bound on fi(N), it suffices to show that g(n) = fi(n) + (N − n)f ′i(n) is also a non-increasing function of n and g(n) ≥ fi(N).\ng(n+ 1) = fi(n+ 1) + (N − n− 1)f ′i(n+ 1) ≤ ( fi(n) + f ′ i(n) ) + (N − n− 1)f ′i(n+ 1)\n≤ ( fi(n) + f ′ i(n) ) + (N − n− 1)f ′i(n) because f ′i is non-increasing = fi(n) + (N − n)f ′i(n) = g(n)\nThe first inequality follows from the assumptions on the behavior of fi w.r.t. n and its first-order Taylor expansion. Specifically, recall that f ′i(n) is defined as (fi(n)−fi(n−s))/s for some (implicit) parameter s. For concreteness, let’s refer to that implicit function as hi(n, s). Let h ′ i(n, s) denote the discrete derivative of hi(n, s) w.r.t. n. The non-increasing nature of f ′ i(n) w.r.t. n implies h ′ i(n, s), for any fixed n, is a non-decreasing function of s. In particular, f ′i(n) = h ′ i(n, s) ≥ h′i(n, 1) for any s ≥ 1. It follows that fi(n+1) = fi(n)+h ′ i(n+1, 1) ≤ fi(n)+h′i(n+1, s) = fi(n)+f ′i(n+1) ≤ fi(n)+f ′i(n), as desired. Thus, g(n) is non-increasing. Since g(N) = f(N) by definition, we have g(n) ≥ f(N), finishing the proof.\nLemma 4. For an (N,∆)-suboptimal learner Cj with well-behaved accuracy function fj, n ∗ j ≤ n∆j .\nProof of Lemma 4. If f ′j(N) > ∆/N , then n ∆ j = N and the statement of the lemma holds trivially. Otherwise, by the definition of n∆j , f ′ j(n ∆ j ) ≤ ∆/N . In order to prove n∗j ≤ n∆j , we must show that ubj(n ∆ j ) < f ∗. We do this by using first-order Taylor expansion:\nubj(n ∆ j ) ≤ fj(n∆j ) + (N − n∆j ) f ′j(n∆j )\n≤ fj(n∆j ) + (N − n∆j ) ∆\nN by the above observation\n< fj(n ∆ j ) + ∆ ≤ fj(N) + ∆ since n∆j ≤ N and fj is non-decreasing ≤ fi∗(N) by (N,∆)-suboptimality of Cj\nHence, ubj(n ∆ j ) < fi∗(N) = f ∗.\nProposition 1. If g : N → [m1,m2] is a well-behaved function for m1,m2 ∈ R, then its discrete derivative g′(n) decreases asymptotically as o(1/n).\nProof of Proposition 1. Recall the definition of the discrete derivative from Section 3 and assume for simplicity of exposition that the parameter s is 1, namely, g′(n) = g(n) − g(n − 1). The argument can be easily extended to s > 1. Applying the definition repeatedly, we get g(n) = g(1) + (g′(2) + . . . + g′(n)) ≥ m1 + g′(2) + . . . g′(n). If g′(n) was Ω(1/n), then there would exist n0 and c such that for all n ≥ n0, g′(n) ≥ c/n. This would mean g(n) ≥ m1 + ∑ n≥n0 c/n. This summation, however, diverges to infinity while g(n) is bounded above by m2. It follows that g ′(n) could not have been Ω(1/n) to start with. It must thus decrease asymptotically strictly faster than 1/n, that is, be o(1/n).\nLemma 5. For an (N,∆)-suboptimal learner Cj with a well-behaved accuracy function fj satisfying f ′j(N) ≤ ∆/N , we have that n∆j is o(N) in N .\nProof of Lemma 5. From Proposition 1, f ′j(N) = o(1/N), implying ∆/f ′ j(N) = ω(N∆). This means that a value N ′ that is o(N/∆) and suffices to ensure ∆/f ′j(N ′) ≥ N for all large enough N , that is, f ′j(N ′) ≤ ∆/N . Since n∆j is, by definition, no larger than N ′, n∆j must also be o(N/∆).\nProof of Theorem 3. Since DAUB* never allocates more than N training examples in a single step to Ci for any i ∈ [M ], it follows from Lemma 2 that cost(Si) ≤ rr−1ci(N). In particular, cost(Sĩ) ≤ r r−1cĩ(N).\nThe (N,∆)-regret of DAUB*, by definition, is ∑\nj∈J cost(Sj). By Theorem 2, this is at most r r−1 ∑ j∈J cj(rn ∆ j ). Since the cost function cj is assumed to increase at least linearly, this quantity\nis at most rr−1 ∑ j∈J rn∆j N cj(N). From Lemma 5, we have that n ∆ j = o(N/∆) and hence rn∆j N = o(1) in N . Plugging this in and dropping the constants r and ∆ from the asymptotics, we obtain that the regret is o( ∑ j∈J cj(N)).\nFinally, if cj(n) = O(cĩ(n)), then ∑ j∈J cj(N) = O( ∑\nj∈J cĩ(N)), which is simply O(M · cĩ(N)). Since cost(Sĩ) ≥ cĩ(N), this quantity is also O(M · cost(Sĩ)) in N . It follows from the above result that the (N,∆)-regret of DAUB* is o(M · cost(Sĩ)) in N , as claimed.\nTheorem 5 (Lower Bound, formal statement). Let ∆ ∈ (0, 1] and A be a training data allocation algorithm that, when executed on a training set of size N , is guaranteed to always output an (N,∆)optimal learner. Let C, Tr, Tv, N,M, ci and fi for i ∈ [M ] be as in Definition 3. Let γ = ( √ 5− 1)/2 and Cj ∈ C be an (N,∆)-suboptimal learner. Then there exists a choice of fj(n) such that fj is well-behaved, f ′j(N) ≤ ∆/N, and A(C, Tr, Tv) allocates to Cj more than γn∆j examples, thus incurring a misallocated training cost on Cj larger than γcj(n ∆ j ).\nProof of Theorem 5. We will argue that, under certain circumstances, A must allocate at least γN∆j examples to Cj in order to guarantee (N,∆) optimality.\nTo prove the desired result by contradiction, we consider the optimal learner Ci∗ and will construct specific accuracy functions fj(n) and fi∗(n) such that they are identical for all n ≤ γN∆j , have derivative no more than ∆/n at N∆j , but differ by at least ∆ when evaluated at n = N . This would imply that A simply cannot distinguish between the accuracy of Cj and Ci∗ by evaluating them on at most γN∆j examples and thus cannot guarantee (N,∆)-optimality of the learner it outputs.\nSuppose we can preserve the properties of fj required by the theorem, including f ′ j(N ∆ j ) ≤ ∆/N , but can enforce that f ′j(γN ∆ j ) ≥ d∆/N for some d > 1 whose value we will determine shortly. Further, let us alter fj such that it remains unchanged for n ≤ γN∆j and is altered for larger n such that f ′j(n) = d∆/N for γN ∆ j < n ≤ N∆j and f ′j(n) = ∆/N for n > N∆j . Recalling that N∆j ≤ N , this modified fj then satisfies:\nfj(N)− fj(γN∆j ) = (N∆j − γN∆j ) d∆\nN + (N −N∆j )\n∆\nN\n= (1− γ − 1/d)N∆j d∆\nN + ∆\nwhich is at least ∆ as long as 1/d ≤ 1 − γ. Now define fi∗ s.t. fi∗(n) = fj(n) for n ≤ γN∆j and fi∗(n) = fj(γN ∆ j ) for n > γN ∆ j . Thus, fj and fi∗ are identical for n ≤ γN∆j but fi∗(N)− fj(N) ≥ ∆, as desired.\nIt remains to show that we can choose a valid fj satisfying the properties required by the theorem but such that f ′j(γN ∆ j ) ≥ d∆/N . To achieve this, consider fj(n) = 1 − c∆/n for any c > 0. Then fj is non-decreasing, f ′ j(n) = c∆/n 2 is non-increasing, n∆j = √ cN , f ′j(n ∆ j ) = ∆/N , and f ′j(γn ∆ j ) = f ′ j(γ √ cN) = ∆/(γ2N). Notice that γ = ( √ 5−1)/2 satisfies the condition γ2 ≤ 1−γ; it is in fact the largest value that satisfies the condition. Hence, we can choose d = 1/γ2 in order to ensure 1/d ≤ 1 − γ, which in turn ensures that the altered fj(N) and fj(γN), as constructed above, differ by at least ∆. This finishes the construction for the lower bound."
    }, {
      "heading" : "B Classifier Parameterizations",
      "text" : "The exact configurations of each classifier in the WEKA package that were used in the experiments are as follows:\n1. weka.classifiers.trees.SimpleCart\n2. weka.classifiers.rules.DecisionTable\n3. weka.classifiers.bayes.NaiveBayesUpdateable\n4. weka.classifiers.functions.SMO -K “weka.classifiers.functions.supportVector.RBFKernel -C 250007 -G 0.01”\n5. weka.classifiers.functions.SMO -K “weka.classifiers.functions.supportVector.PolyKernel -C 250007 -E 1.0”\n6. weka.classifiers.functions.SMO -K “weka.classifiers.functions.supportVector.NormalizedPolyKernel -C 250007 -E 2.0”\n7. weka.classifiers.functions.RBFNetwork\n8. weka.classifiers.trees.RandomTree\n9. weka.classifiers.trees.RandomForest -depth 10 -I 5 -K 0\n10. weka.classifiers.trees.RandomForest -depth 10 -I 10 -K 0\n11. weka.classifiers.trees.RandomForest -depth 20 -I 5 -K 0\n12. weka.classifiers.rules.DTNB\n13. weka.classifiers.trees.NBTree\n14. weka.classifiers.functions.Logistic\n15. weka.classifiers.functions.SPegasos\n16. weka.classifiers.rules.PART\n17. weka.classifiers.trees.LADTree\n18. weka.classifiers.misc.HyperPipes\n19. weka.classifiers.trees.J48graft\n20. weka.classifiers.rules.JRip\n21. weka.classifiers.trees.BFTree\n22. weka.classifiers.trees.LMT\n23. weka.classifiers.trees.J48 -M 2 -C 0.25\n24. weka.classifiers.trees.J48 -M 4 -C 0.10\n25. weka.classifiers.trees.J48 -M 4 -C 0.35\n26. weka.classifiers.lazy.IBk -K 1\n27. weka.classifiers.lazy.IBk -K 5\n28. weka.classifiers.lazy.IBk -K 10\n29. weka.classifiers.lazy.IBk -K 25\n30. weka.classifiers.meta.RotationForest\n31. weka.classifiers.rules.ConjunctiveRule\n32. weka.classifiers.trees.REPTree\n33. weka.classifiers.rules.NNge\n34. weka.classifiers.rules.ZeroR\n35. weka.classifiers.trees.DecisionStump\n36. weka.classifiers.rules.Ridor\n37. weka.classifiers.misc.VFI\n38. weka.classifiers.bayes.NaiveBayes\n39. weka.classifiers.functions.MultilayerPerceptron\n40. weka.classifiers.functions.SimpleLogistic\n41. weka.classifiers.trees.SimpleCart"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "We study a novel machine learning (ML) problem setting of sequentially allocating small<lb>subsets of training data amongst a large set of classifiers. The goal is to select a classifier<lb>that will give near-optimal accuracy when trained on all data, while also minimizing the cost<lb>of misallocated samples. This is motivated by large modern datasets and ML toolkits with<lb>many combinations of learning algorithms and hyper-parameters. Inspired by the principle of<lb>“optimism under uncertainty,” we propose an innovative strategy, Data Allocation using Upper<lb>Bounds (DAUB), which robustly achieves these objectives across a variety of real-world datasets.<lb>We further develop substantial theoretical support for DAUB in an idealized setting where<lb>the expected accuracy of a classifier trained on n samples can be known exactly. Under these<lb>conditions we establish a rigorous sub-linear bound on the regret of the approach (in terms<lb>of misallocated data), as well as a rigorous bound on suboptimality of the selected classifier.<lb>Our accuracy estimates using real-world datasets only entail mild violations of the theoretical<lb>scenario, suggesting that the practical behavior of DAUB is likely to approach the idealized<lb>behavior.",
    "creator" : "LaTeX with hyperref package"
  }
}