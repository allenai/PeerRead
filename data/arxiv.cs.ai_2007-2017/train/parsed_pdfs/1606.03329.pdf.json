{
  "name" : "1606.03329.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Community Structure in Industrial SAT Instances",
    "authors" : [ "Carlos Ansótegui", "Maria Luisa Bonet", "Jesús Giráldez-Cru", "Jordi Levy" ],
    "emails" : [ "carlos@diei.udl.cat", "bonet@lsi.upc.edu", "jgiraldez@iiia.csic.es", "levy@iiia.csic.es" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 6.\n03 32\n9v 1\n[ cs\n.A I]\n1 0\nModern SAT solvers have experienced a remarkable progress on solving industrial instances. Most of the techniques have been developed after an intensive experimental process. It is believed that these techniques exploit the underlying structure of industrial instances. However, there are few works trying to exactly characterize the main features of this structure.\nThe research community on complex networks has developed techniques of analysis and algorithms to study real-world graphs that can be used by the SAT community. Recently, there have been some attempts to analyze the structure of industrial SAT instances in terms of complex networks, with the aim of explaining the success of SAT solving techniques, and possibly improving them.\nIn this paper, inspired by the results on complex networks, we study the community structure, or modularity, of industrial SAT instances. In a graph with clear community structure, or high modularity, we can find a partition of its nodes into communities such that most edges connect variables of the same community. In our analysis, we represent SAT instances as graphs, and we show that most application benchmarks are characterized by a high modularity. On the contrary, random SAT instances are closer to the classical Erdös-Rényi random graph model, where no structure can be observed. We also analyze how this structure evolves by the effects of the execution of the SAT solver. We detect that new clauses learnt by the solver during the search contribute to destroy the original community structure of the formula. This partially explains the distinct performance of SAT solvers on random and industrial SAT instances."
    }, {
      "heading" : "1. Introduction",
      "text" : "The Boolean Satisfiability problem (SAT) is central in Computer Science. Even though the general SAT problem is NP-Complete, many very large industrial instances can be efficiently solved by modern SAT solvers. Hence, SAT is extensively used to encode and solve many other problems, such as hardware and software verification, planning,\n✩This research has been partially founded by the CICYT research project TASSAT2 (TIN2013-48031-C4-1 and TIN2013-48031-C4-4-P), the MINECO/FEDER project RASO (TIN2015-71799-C2-1-P) and the CSIC project 201450E045.\nEmail addresses: carlos@diei.udl.cat (Carlos Ansótegui), bonet@lsi.upc.edu (Maria Luisa Bonet), jgiraldez@iiia.csic.es (Jesús Giráldez-Cru), levy@iiia.csic.es (Jordi Levy)\nURL: http://www.lsi.upc.edu/˜bonet (Maria Luisa Bonet), http://www.iiia.csic.es/˜jgiraldez (Jesús Giráldez-Cru), http://www.iiia.csic.es/˜levy (Jordi Levy)\nPreprint submitted to Artificial Intelligence June 13, 2016\ncryptography, scheduling, among others. Therefore, finding good algorithms to solve SAT is of practical use in many areas of Computer Science.\nAlthough nowadays large real-world instances can be efficiently solved, most relatively smaller random formulas cannot. It is well-known in the SAT community that classical random k-CNF formulas and industrial instances have a distinct nature. The intuition is that the difference in performance of SAT solvers between random and industrial instances comes from the existence of some kind of structure in industrial instances that can be exploited [44, 21, 22, 18, 23, 6]. This makes SAT solvers specialize in one or the other kind of formulas, and in the SAT competitions these formulas are separated in different tracks. In the case of (almost) all application benchmarks, Conflict-Driven Clause Learning (CDCL) SAT solvers show the best performance, even when these instances come from very different domains, as hardware verification, planning or cryptography. The main component of these solvers is the learning of new clauses during the search [24]. The motivation of this work is to study the body of industrial instances to detect general properties that are shared by the majority of instances. This knowledge can help understand the success of CDCL SAT solvers on these benchmarks, and possibly improve them.\nThe inspiration of our analysis comes from the work of complex networks where the general structure of real-world graphs is studied. To this effect, we use two ways to represent the SAT instances as graphs. One model represents them as bipartite graphs, where variables and clauses are nodes, and edges represent the presence of a variable in a clause. In the second model, variables are nodes, and edges between nodes (variables) indicate that there exists a clause in which the two variables appear.\nThe classical Erdös-Rényi random graph model [16] was one of the best studied during the last century, and set the basis of graph theory. In this model, the degree of nodes follows a binomial distribution. Random k-CNF formulas, represented as graphs, follow this model. For instance, for k = 3, in the phase transition point, most of the variables have a number of occurrences very close to 12.75,1 with a small variability in big graphs. In the context of real-world networks, other models have been defined.\nA first model is the small-world topology, proposed by Watts and Strogatz [43], as a new model to describe the structure of some social networks. These networks are characterized by short path lengths and high clustering factors.\nAnother is the scale-free model, introduced by Albert et al. [1] to describe the structure of the World Wide Web. They show that the WWW, viewed as a graph, has a structure that cannot be described by the classical random graph model. This means that this graph is very different from what one would expect if edges existed independently and at random. The name of this model comes from the fact that, in this new model, the degree of nodes follows a power-law distribution P (k) ∼ k−α, and this distribution is scale-free.\nThe topology of graphs has a major impact on the cost of solving search problems on these graphs. Gent et al. [18] analyze the impact of a small-world topology on the cost of coloring graphs, and Walsh [42] does the same in the case of scale-free graphs. Walsh [41] analyzes the small world topology of many graphs associated with search problems in AI. He also shows that the cost of solving these search problems can have a heavy-tailed distribution. Therefore, we can expect that SAT solving, viewed as a search process on a graph (the formula), will be affected by the topology of this graph.\nIn this paper, we focus on the analysis of the community structure. This is a very characteristic feature in realworld networks [17], that has received the attention of many researchers in the last years. In order to analyze the community structure of SAT instances, we use the notion of modularity introduced by Newman [31]. Having high modularity (in a graph) means that nodes can be grouped into sets or communities, such that, there are many edges between nodes of the same community, but there are few edges connecting nodes from different communities. The notion of community is more general than the notion of connected component. In particular, it allows the existence of (a few) connections between communities. Biere and Sinz [8] show that many SAT instances can be decomposed into connected components, and how to handle them within a SAT solver. They discuss how this connected components structure can be used to improve the performance of SAT solvers. Since our notion of community is more general, it might be more practical to analyze and improve the performance of SAT solvers.\nThe first contribution of this work is an exhaustive analysis of the community structure of SAT instances. We show that industrial SAT instances are characterized by a very clear community structure, i.e., high modularity. On the contrary, random formulas do not have community structure, thus the modularity is very low (as expected). Interestingly,\n1The number 12.75 comes from multiplying the size of the clauses k = 3 by the clause/variable ratio m/n = 4.25 at the phase transition point.\nthis feature of SAT instances can be computed with efficient algorithms. As we will see in the next section, this decisive result has been already used as the core of other applications, as some modularity-based SAT and MaxSAT solvers [29, 40, 30, 5] or some modularity-based pseudo-industrial random generators [19, 20]. Therefore, this feature seems to be essential to better understand the underlying structure of real-world problems.\nThe second contribution is the analysis of the evolution of the community structure during SAT solver search. In particular, we focus on the effects of learning new clauses on this structure. We show that learnt clauses usually contain variables of distinct communities. Therefore, the SAT solver tends to destroy the original partition of the formula. We remark that this result is very interesting since it allows us to better understand the behavior of the solver using a simple, compact feature: the community structure. We consider that a better understanding of the success of CDCL techniques is a required step to improve them. In fact, this idea of destroying the original partition of the formula is used to improve the performance of several CDCL SAT solvers [5].\nThis work is an extended and revised version of [4]. The rest of the paper proceeds as follows. Related work and some preliminary concepts are introduced in Sections 2 and 3, respectively. In Section 4, we introduce the analysis of the community structure in graphs, and our analysis of the community structure in SAT instances is presented in Section 5. In Section 6, we show how this structure is affected by CDCL techniques. Finally, conclusions are in Section 7."
    }, {
      "heading" : "2. Related Work",
      "text" : "The previous version of this paper [4] has been a seminal contribution to many other works. The community structure is correlated to the runtime of CDCL SAT solvers [33, 34]. Also, it has been used to improve the performance of several solvers. Martins et al. [29] partition MaxSAT instances using the community structure in order to identify smaller unsatisfiable subformulas. This method is refined by Neves et al. [30]. Sonobe et al. [40] use the partition obtained with the community structure to improve the performance of a parallel SAT solver. The community structure is used to detect relevant learnt clauses, and the performances of several CDCL SAT solvers are improved augmenting the original instance with this set of useful clauses [5].\nAn important issue to develop new SAT solving techniques specialized in industrial problems is the limited number of these benchmarks and the high cost of solving them. For these reasons, the generation of random instances with properties more similar to industrial formulas is a very interesting challenge. This problem was already stated by Selman et al. [37] as one of the ten most interesting challenges in propositional search. The same problem is highlighted by Kautz and Selman [26], Dechter [13]. Some approaches on pseudo-insdustrial random generation focus on general properties shared by the majority of real-world problems. This is the case of the (clear) community structure. There exist some generators that indirectly use the notion of modularity [39, 11, 33, 28]. Recently, the Community Attachment model [19, 20] has been proposed to generate random pseudo-industrial instances with high modularity.\nThe underlying structure of SAT instances and its relations to the performance of SAT solvers have been also addressed in other related works. Most industrial SAT instances have a scale-free structure [3]. In particular, it is shown that the number of variable occurrences k follows a power-law distribution P (k) ∼ k−α. Katsirelos and Simon [25] study the centrality of variables picked by a CDCL solver. Simon [38] uses observations from the SAT solver performance on industrial problems to better understand its behavior. Also, most industrial SAT instances have fractal dimension [2]. This means that the shape of the graph is preserved after rescaling, i.e., replacing groups of nodes by a single node."
    }, {
      "heading" : "3. Preliminaries",
      "text" : "Given a set of Boolean variables X = {x1, . . . , xn}, a literal is an expression of the form xi or ¬xi. A clause c of size s is a disjunction of s literals, l1 ∨ . . . ∨ ls. We note s = |c|, and say that x ∈ c, if c contains the literal x or ¬x. A CNF formula or SAT instance of length t is a conjunction of t clauses, c1 ∧ . . . ∧ ct. A k-CNF formula is a conjunction of k-sized clauses.\nAn (undirected) weighted graph is a pair (V,w) where V is a set of vertexes and w : V × V → R+ satisfies w(x, y) = w(y, x). This definition generalizes the classical notion of graph (V,E), where E ⊆ V × V , by taking\nw(x, y) = 1 if (x, y) ∈ E and w(x, y) = 0 otherwise. The degree of a vertex x is defined as deg(x) = ∑\ny∈V w(x, y). A bipartite graph is a tuple (V1, V2, w) where V1 and V2 are two disjoint sets of vertexes, and w : V1 × V2 → R+.\nGiven a SAT instance, we construct two graphs, following two models. In the Variable Incidence Graph model (VIG, for short), vertexes represent variables, and edges represent the existence of a clause relating two variables. A clause x1 ∨ . . . ∨ xn results into ( n 2 )\nedges, one for every pair of variables. Notice also that there can be more than one clause relating two given variables. To preserve this information we put a higher weight on edges connecting variables related by more clauses. Moreover, to give the same relevance to all clauses, we ponder the contribution of a clause to an edge by 1/ ( n\n2\n)\n. This way, the sum of the weights of the edges generated by a clause is always one.\nDefinition 1 (Variable Incidence Graph (VIG)). Given a SAT instance Γ over the set of variables X , its variable incidence graph is a graph (X,w) with set of vertexes the set of Boolean variables, and weight function:\nw(x, y) = ∑\nc∈Γ\nx,y∈c\n1 (\n|c| 2\n)\nIn the Clause-Variable Incidence Graph model (CVIG, for short), vertexes represent either variables or clauses, and edges represent the occurrence of a variable in a clause. Like in the VIG model, we try to give the same relevance to all clauses, thus every edge connecting a variable x with a clause c containing it has weight 1/|c|. This way, the sum of the weights of the edges generated by a clause is also one in this model.\nDefinition 2 (Clause-Variable Incidence Graph (CVIG)). Given a SAT instance Γ over the set of variables X , its clause-variable incidence graph is a bipartite graph (X, {c | c ∈ Γ}, w), with vertexes the set of variables and the set of clauses, and weight function:\nw(x, c) =\n{\n1/|c| if x ∈ c 0 otherwise\nFrom now on we will indistinctly use the words formula or graph, to discuss SAT formulas."
    }, {
      "heading" : "4. The Community Structure of Graphs",
      "text" : "The notion of modularity was introduced by Newman and Girvan [32]. This property is defined for a graph and a specific partition of its vertexes into communities, and measures the density of internal edges, i.e., edges between nodes of the same community. Thus, in a graph with high modularity, there exists a partition of its nodes such that most of the edges connect nodes of the same community. The modularity of a graph is then the maximal modularity for all possible partitions of its vertexes. Obviously, measured this way, the maximal modularity would be obtained putting all vertexes in the same community. To avoid this problem, Newman and Girvan [32] define modularity as the fraction of edges connecting vertexes of the same community minus the expected fraction of edges in a random graph with the same number of vertexes and the same node degrees.\nDefinition 3 (Modularity of a Graph). Given a weighted graph G = (V,w) and a partition P = {P1, . . . , Pn} of its vertexes V , we define their modularity as\nQ(G,P ) = ∑\nPi∈P\n∑\nx,y∈Pi\nw(x, y)\n∑\nx,y∈V\nw(x, y) −\n\n  \n∑\nx∈Pi\ndeg(x)\n∑\nx∈V\ndeg(x)\n\n  \n2\nThe (optimal) modularity of a graph is the maximal modularity, for any possible partition of its vertexes: Q(G) = max{Q(G,P ) | P}\nSince both terms in the definition of modularity are in the range [0, 1], and, for the partition given by a single community, both have value 1, the optimal modularity of graph will be in the range [0, 1]. In practice, Q values for networks showing a strong community structure range from 0.3 to 0.7, higher values are rare [32].\nThere has not been an agreement on the definition of modularity for bipartite graphs. Here we will use the notion proposed by Barber [7] that extends Newman and Girvan’s definition by restricting the random graphs used in the second term of such definition to be bipartite. In this new definition, communities may contain vertexes of both sets V1 and V2.\nDefinition 4 (Modularity of a Bipartite Graph). Given a graphG = (V1, V2, w) and a partitionP = {P1, . . . , Pn} of its vertexes V1 ∪ V2, we define their modularity as\nQ(G,P ) = ∑\nPi∈P\n∑\nx∈Pi∩V1 y∈Pi∩V2\nw(x, y)\n∑\nx∈V1 y∈V2\nw(x, y) −\n∑\nx∈Pi∩V1\ndeg(x)\n∑\nx∈V1\ndeg(x) ·\n∑\ny∈Pi∩V2\ndeg(y)\n∑\ny∈V2\ndeg(y)\nThere exist a wide variety of algorithms for computing the modularity of a graph. Moreover, there exist alternative notions and definitions of modularity for analyzing the community structure of a network. See [17] for a survey in the field. The decision version of modularity maximization is NP-complete [10]. Therefore, all efficient modularityoptimization algorithms proposed in the literature, instead of computing the exact value of the modularity, return an approximation ofQ, in fact a lower bound of Q. They include greedy methods, methods based on simulated annealing, on spectral analysis of graphs, etc. Most of them have a complexity that make them inadequate to study the structure of very large graphs, like industrial SAT instances. There are algorithms specially designed to deal with large-scale networks, like the greedy algorithms for modularity optimization [31, 12], the label propagation-based algorithm [35] and the method based on graph folding [9].\nThe first algorithm for modularity maximization was described by Newman [31]. This algorithm starts by assigning every vertex to a distinct community. Then, it proceeds by joining the pair of communities that results in a bigger increase of the modularity value. The algorithm finishes when no community joining results in an increase of the modularity. In other words, it is a greedy gradient-guided optimization algorithm. The algorithm may also return a dendrogram of the successive partitions found. Obviously, the obtained partition may be a local maximum. Clauset et al. [12] optimize the data structures used in this basic algorithm, using among others, data structures for sparse matrices. The complexity of this refined algorithm is O(md logn), where d is the depth of the dendrogram (i.e. the number of joining steps), m the number of edges and n the number of vertexes. They argue that d may be approximated by logn, assuming that the dendrogram is a balanced tree, and the sizes of the communities are similar. However, this is not true for the graphs we have analyzed, where the sizes of the communities are not homogeneous. This algorithm has not been able to finish, for any of our SAT instances, with a run-time limit of one hour.\nAn alternative algorithm is the Label Propagation Algorithm (LPA) proposed by Raghavan et al. [35]. Initially, all vertexes are assigned to a distinct label, e.g., its identifier. Then, the algorithm proceeds by re-assigning to every vertex the label that is more frequent among its neighbors. The procedure ends when every vertex is assigned a label that is maximal among its neighbors. In case of a tie between most frequent labels, the winning label is chosen randomly. The algorithm returns the partition defined by the vertexes sharing the same label. The label propagation algorithm has a near linear complexity. However, it has been shown experimentally that the partitions it computes have a worse modularity than the partitions computed by the Newman’s greedy algorithm.\nThe Louvain Method (LM)2 proposed by Blondel et al. [9] (see Alg. 1) improves the Label Propagation Algorithm in two directions. The idea of moving one node from one community to another following a greedy strategy is the same, but, instead of selecting the community where the node has more neighbors, it selects the community where the movement would most increase the modularity. Second, once no movement of node from community to community\n2In some works, this method is also known as Graph Folding Algorithm (GFA).\nAlgorithm 1: Louvain Method (LM) Input: Graph G = (X,w) Output: Label L1 1 foreach i ∈ X do 2 L1[i] := i\n3 L2 := OneLevel(G); 4 while Modularity(G,L1) < Modularity(G,L2) do 5 L1 := L1 ◦ L2; // labelling of original nodes in the folded graph 6 G = Fold(G,L2); 7 L2 := OneLevel(G);\n8 function OneLevel(Graph G = (X,w)) : Label L 9 foreach i ∈ X do\n10 L[i] := i\n11 repeat 12 changes := false; 13 foreach i ∈ X do 14 bestinc := 0; 15 foreach c ∈ {c | ∃j.w(i, j) 6= 0 ∧ L[j] = c} do 16 inc := ∑\nL(j)=c w(i, j)− deg(i) · ∑ L[j]=c deg(j)/ ∑ j∈X deg(j);\n17 if inc > bestinc then 18 L[i] := c; bestinc := inc; changes := true;\n19 until ¬changes; 20 return L\n21 function Fold(Graph G1 = (X,w), Label L) : Graph G2 22 X2 = {c ⊆ X | ∀i, j ∈ c . L[i] = L[j]}; 23 w2(c1, c2) = ∑\ni∈c1,j∈c2 w(i, j);\n24 return G2 = (X2, w2);\ncan increase the modularity (we have reached a local modularity maximum), we allow to merge communities. For this purpose we construct a new graph where nodes are the communities of the old graph, and where edges are weighted with the sum of the weights of the edges connecting both communities. Then, we apply again the greedy algorithm to the new graph. This folding process is repeated till no modularity increase is possible. In our experiment, we use this method since it gives better bounds in both models VIG and CVIG than other algorithms, like LPA [4]."
    }, {
      "heading" : "5. The Community Structure of Industrial SAT Instances",
      "text" : "In this section, we present the analysis of the community structure of SAT instances. To this purpose, we represent SAT instances as graphs using the VIG and CVIG model, and we analyze the community structure of these graphs using the Louvain Method. Notice that LM is not able to compute the community structure of bipartite graphs according to Definition 4, since it collapses all nodes of the same community into a single node in the folding step, i.e., destroying the bipartite structure of the graph. Therefore, in order to compute the community structure of the CVIG model, we have adapted this algorithm for bipartite graphs, re-implementing the folding step to preserve the bipartite structure of the graph. In particular, we replace the folding function by the function described in Algorithm 2.\nWe have used the set of industrial formulas of the SAT Competition 20133. They are 300 instances grouped into 19 families: 2d-strip-packing, bio, crypto-aes, crypto-des, crypto-gos, crypto-md5, crypto-sha, crytpo-vmpc, diagnosis,\n3http://satcompetition.org/2013/\nhardware-bmc, hardware-bmc-ibm, hardware-cec, hardware-velev, planning, scheduling, scheduling-pesp, softwarebit-verif, software-bmc and termination. All instances are industrial, in the sense that they come from a real-world problem. During the paper, we compare them to random 3-CNF formulas. We remark that the conclusions obtained from our experiments are general, in the sense that same conclusions can be observed if experiments are performed on a different set. In fact, the same conclusions are obtained by Ansótegui et al. [4], where experiments are performed on the set of the SAT Race 2010, and by Ansótegui et al. [5] where it is computed the community structure of the industrial benchmarks of the SAT Competitions of 2011 and 2014. The software we use in the experimentation is publicly available in http://www.iiia.csic.es/˜jgiraldez/software.\nIn our experiments, we report the modularity Q of the partition returned by the Louvain Method, as well as the number of communities |P | and the percentage larg of nodes belonging to the largest community. Values of modularity higher than 0.4 are marked in bold. Finally, we also report the number of iterations iter spent by the LM algorithm, being each iteration an execution of the main loop of the function OneLevel. Notice that each iterations visits all nodes of the graph. Therefore, this number gives an intuition about the runtime of the LM on SAT instances.\nFirst, we conduct a study of the modularity of 100 random 3-CNF SAT instances varying their clause/variable ratio m/n, for a fixed number of variables n = 104. For this experiment we used the LM algorithm on the VIG model only. Table 1 shows the results. As we can see, the modularity of random instances is only significant for very low clause/variable ratios, i.e., on the leftist SAT easy side. This is due to the presence of a large quantity of very small unconnected components. Even though, for these low values of m/n, the modularity is not as high as for industrial instances, as we will see later, confirming their distinct nature. Notice that as the clause/variable ratio m/n increases, the variables get more connected but without following any particular structure, and the number of communities highly decreases. This explains the low value of the modularity for this family of benchmarks. Also, we do not observe any abrupt change in the phase transition point.\nAs a second experiment with random SAT instances, we want to investigate the modularity at the peak transition region m/n = 4.25, for an increasing number of variables n. Table 2 shows the results. As we can see, the modularity\nis very low and it tends to slightly decrease as the number of variables increases, and seems to tend to a particular value (0.15 for the phase transition point).\nWe recall that these results on random instances are expected since these benchmarks do not have any structure at all. However, the value of the modularity can be useful to measure how clear is the community structure in industrial SAT instances. To this purpose, we compute the modularity of the industrial SAT instances of the SAT Competition 20134, using the LM algorithm on both VIG and CVIG models. Recall that this set contains a total of 300 application benchmarks, divided into 19 industrial families.\nFirst, we observe that all instances of the same family have a similar community structure (modularity, number of communities, etc..). For instance, the maximal dispersion of the modularity Q is found in the family hardawre-velev for the VIG model, with an standard deviation SD[Q] = 0.0081. Therefore, we report results on average for each family.\nIn Table 3, we report results of the community structure of industrial SAT instances, grouped by families. For each family of industrial instances, we present the results of the modularity Qorig of the original formulas, and the modularity Qprep of these formulas after prepossessing with Satelite [14] with default options. The results about the\n4We have omitted the study of the 3 formulas of the family software-bmc due to their extremely large sizes."
    }, {
      "heading" : "300 4.00 0.190 0.073",
      "text" : ""
    }, {
      "heading" : "300 4.25 0.183 0.041",
      "text" : ""
    }, {
      "heading" : "300 4.50 0.177 0.045",
      "text" : ""
    }, {
      "heading" : "300 6.00 0.150 0.120",
      "text" : ""
    }, {
      "heading" : "300 10.00 0.112 0.171",
      "text" : "number of communities (|P |), the percentage of vertexes belonging to the largest community (larg), and number of iterations of the algorithm (iter) correspond to the results with the preprocessed instances. Finally, we also study the connected components, as suggested by Biere and Sinz [8].\nWe have to remark that the LM algorithm returns a lower bound on the modularity. Having this in mind, we can conclude that, except for the crypto-vmpc family, all families show a very clear community structure with values of Q around 0.8. In other kind of networks, values greater than 0.7 are rare, therefore the values obtained for industrial SAT instances can be considered as exceptionally high.\nIf we compare the modularity for the VIG model with the same values for the CVIG model, we can conclude that, in general, these values are higher for the VIG model. This is an effect of the LM algorithm when it is applied to bipartite graphs. After the first folding, LM is not (almost) able to do any change in the bipartite structure of the resulting graph, and it finishes. Hence, the number of foldings is smaller. Therefore, for the CVIG the number of iterations iter is smaller, the number of communities |P | is bigger, and the biggest community is smaller compared to the results obtained for the VIG model.\nWe also compare the values of the modularity before and after prepossessing the instances, Qorig and Qprep respectively. We see that in most cases, Qprep is slightly smaller than Qorig, and in some crypto families, it is even bigger. However, both values are very close. Therefore, we can conclude that the default prepossessing techniques applied by Satelite almost do not affect the community structure of the formula.\nIf all communities have a similar size, then larg ≈ 1/|P |. In many cases in Table 3, we have |P | ≫ 1/larg. This means that the community structure has a big variability in the sizes of the communities obtained.\nRespect to the number of iterations, with the LM algorithm, in every iteration we have to visit all neighbors of every node. Therefore, the cost of an iteration is linear in the number of edges of the graph. Moreover, after folding the graph, we can do further iterations, and even several graph foldings.\nFinally, we have also studied the connected components of these instances after prepossessing. As we can see in Table 3, almost all instances have a single connected component, i.e., almost all variables are included in the same connected component. Hence the rest of connected components contain just an insignificant subset of the variables. Therefore, the modularity gives us much more information about the structure of the formula than connected components. Notice that a connected component can be structured into several communities. We also found a large number of very small connected components in some industrial formulas before preprocessing (these results are not shown in Table 3). However, these components are easily removed by the preprocessor."
    }, {
      "heading" : "6. The Community Structure during SAT Solver Search",
      "text" : "We want to investigate how CDCL techniques affect the community structure of the formula. The natural question is: even if the original formula shows a clear community structure, could it be the case that this structure is quickly destroyed during the search process? In other words, the learning mechanism increases the original formula with new learnt clauses. How do these new clauses affect the community structure of the formula? Finally, even if the value of the modularity is not altered, can it be the case that the original partition of the formula is changed? In this section, we investigate these phenomena.\nFirst, we start our analysis with random formulas. In Table 4, we compare the modularity of the original formula Qorig to the modularity of this formulas augmented with all learnt clauses that the solver is keeping when it finishes the search Qlearnt. The solver used to produce these learnt clauses is MiniSAT [15]. It is interesting to observe that closer to the peak transition region m/n = 4.25, lower the modularity is with respect to the addition of learnt clauses. A possible explanation is that at the peak region we find the hardest instances, and harder an instance is, more clauses connecting distinct communities have to be learnt, thus lower the modularity is. Even though, the modularity in all cases is very low, and the presence of learnt clauses does not contribute to increase the modularity of the original formula (as expected for random instances).\nThen, we analyze the evolution of the community structure for the case of industrial SAT instances. As solving all industrial benchmarks is a too costly task (notice that some formulas are not even solved in the competitions by any solver), we generate some set of learnt clauses running the solver for a fixed number of conflicts and augmenting the original instances with the learnt clauses the solver is keeping at that moment. In this experiment, we use MiniSAT, and we stop the solver after 103, 104 and 105 conflicts5.\nIn Table 5, we show the values of the modularities Qorig and Qprep of the original and preprocessed formulas, and the modularities QX of the formulas after X = 103, 104, 105 conflicts, for both the VIG and the CVIG models. We remark that these modularities are obtained with the LM algorithm on the augmented instances (i.e., original instances and learnt clauses).\nWe can observe that the modularity weakly decreases as we add learnt clauses, but it is still meaningful. Therefore, learning does not completely destroy the organization of the formula into (weakly) connected communities. This means that LM is able to find a partition of the (new) formula such that most of the edges connect variables of the same community.\nThe question now is, even if the modularity does not decreases very much, could it be the case that the communities have changed? In other words, can it be the case that there is still a clear community structure but the partition of the formula into communities has totally changed?\nIf a considerable part of learning is performed locally inside each community, then the communities will not\n5These numbers of conflicts are not related to the number of conflicts required to solve the formula, but they increase in one order of magnitude, so they can be useful to analyze the evolution of the search.\nchange. In VIG model, the set of vertexes is always the same (even with the addition of learnt clauses). Notice that in this model, vertexes represent only variables, so no learnt clause creates new nodes. However, these learnt clauses do create new edges between the existent nodes. Therefore, we can use modularity as a quality measure to see how internal a learnt clause is. Notice that modularity is a function of two parameters: a graph, and a partition of it. For a given partition of a graph, a new edge will increase the modularity iff it connects two nodes of the same community, otherwise modularity will decrease. Thus, using the partition of the original formulas, we can see if learning acts internally (i.e., connecting variables of the same community), or if it tends to connect variables of different communities.\nWe have conducted another experiment to see how learning changes such partition. We use the same formulas than before (original formulas augmented with learnt clauses kept by the solver after 103, 104 and 105 conflicts), and the partition of the VIG obtained from the original formulas, to compute the modularity Qpart. Notice that in the case we do not run the LM to compute a (possibly) new partition, but we give explicitly that partition. Moreover, we can only use the VIG since the set of nodes is the same in both formulas original and after learning (recall that using the CVIG, each new (learnt) clause adds a new clause-node to the graph). In Table 6, we show the result of the modularity Qpart. The analysis of this experiment shows us that there is a drop-off in the modularity as we incorporate more learnt clauses. In other words, the partition of the formula is changing. This means that, if we use explicitly the community structure to improve the efficiency of a SAT solver, to overcome this problem, we would have to recompute the partition (after some number of conflicts) to adjust it to the modified formula.\nLet us represent this effect using the graph of communities6. This graph is built as follows. All nodes of the VIG (variables) that belong to the same community are merged into a single node in the graph of communities, and weighted edges are updated accordingly. The weight of the edge connecting communities A and B is the addition of the weights of the edges connecting one node from A and one node from B.\nIn Figure 1 (left), we represent the graph of communities of the industrial formula ibm-2002-22r-k60. This instance has a modularity Q = 0.91 and 35 communities. Glucose [6] solved this formula keeping a total of 504964 learnt clauses. We can recompute the graph of communities after adding some of these learnt clauses to the original\n6We cannot directly represent the VIG due to its large number of nodes (variables).\ninstance. In Figure 1 (center and right), we represent the graph of communities after adding small learnt clauses (up to 10 literals), and medium-sized learnt clauses (up to 50 literals), respectively.7 The modularity of these augmented instances is respectively 0.87 and 0.82, and the number of communities 29 and 24. In these graphs of communities, the node size is scaled according to the number of variables that belong to each community. Also, edges are scaled by their weights. Notice that edges weights are computed using the weights of the VIG (i.e., taking into account the length of the clauses). The community structure is clear in all of these three graphs. However, as we consider more learnt clauses, we can observe two phenomena. First, the number of communities (number of nodes in the graph of communities) decreases. This means that variables that originally belonged to distinct communities are now grouped into the same community. Second, the weight of the inter-communities edges increases. Therefore, from the two previous effects, we observe that the solver prefers to learn clauses containing variables of distinct (original) communities. For these reasons, in general, clause learning contributes to decrease the modularity.\nFinally, we want to determine how much each learnt clause contributes to destroy the original organization of the formula. To this purpose, we can measure the increase of the modularity ∆Q that each learnt clause produces. Notice that ∆Q is positive when most of the new edges generated by such clause connect nodes (variables) of the same community. Otherwise, ∆Q is negative.\nAfter an extensive experimentation on a subset of UNSAT industrial instances, we see that, in general, each learnt clause produces a decrease of the modularity (i.e., ∆Q < 0), but this decrease is very small (i.e., ∆Q ≈ 0).\nIn Figure 2, we represent this analysis for the industrial instances E05X15 and isqrt1 32. Each point (x, y), with y measured in the left Y axis, represents a clause learnt at instant x and increasing Q on y. We also represent (using the right Y axis) the current value of the modularity Q using the original partition of variables, along the execution. We can see that the contribution to increase or decrease the modularity is very small (i.e., ∆Q ≈ 0). Also, even when some learnt clauses contribute to increase the value of Q, most of them do not (i.e., ∆Q < 0), and thus Q tends to decrease. Due to space limitations, we only represent this analysis in two benchmarks. However, we observed similar results in most industrial SAT instances studied. Therefore, we can conclude that, in general, learnt clauses contribute to destroy the (original) community structure of the formula. It is not due to some particular clauses but rather a general phenomenon of the learning mechanism."
    }, {
      "heading" : "7. Conclusions",
      "text" : "Inspired by complex networks, we have studied one decisive feature of the underlying structure of industrial SAT formulas, representing them as graphs. The classical Erdös-Rényi model for generating random graphs cannot\n7As each clause of length l generates ( l\n2\n)\nedges, it is hard to compute these graphs using long clauses.\nbe used for studying real-world networks, since they exhibit some particular structural properties. In the case of SAT instances, we have shown that this model is appropriate to study random formulas. However, we have given empirical evidence that this model is not valid for modeling industrial instances. These instances are characterized by a particular structure, which may explain their distinct nature w.r.t. random formulas. In particular, we have analyzed the community structure, or the modularity, of these benchmarks. Moreover, we study how this structure evolves during the execution of a CDCL SAT solver.\nWe have seen that most industrial instances exhibit a clear community structure (whereas random formulas do not). This means that we can find a partition of the formula into communities in which variables are highly interconnected. In general, industrial formulas have a exceptionally high modularity, greater than 0.8 in many cases. Notice that in other kind of networks, values greater than 0.7 are rare.\nAlso, we have analyzed the effect of learning new clauses on this structure. Interestingly, most of the learnt clauses tend to connect variables of different communities. As a consequence, learning new clauses destroys the original structure of the formula. However, this occurs very slowly, since each learnt clause contributes very little to the decrease of modularity. This behaviour is observed in all benchmarks analyzed. Therefore, it seems that the solver performs the search destroying the original community organization of the formula.\nWe think that the present study provides a step towards a theoretical explanation of why some SAT solvers perform better on industrial instances, and others on random SAT instances. Moreover, the better understanding of this structure in real-world instances has led to the improvement of existing SAT solvers [29, 30, 40, 5].\nThis analysis also serves as basis for new random SAT generation models that produce more realistic pseudoindustrial random instances. This problem is distinguished as one of the 10 challenge problems in SAT [37, 36, 26, 27]. Understanding the structure of industrial instances is a first step towards the development of random instance generators, reproducing the features of industrial instances. These generators can be used to support the testing of industrial SAT solvers under development."
    } ],
    "references" : [ {
      "title" : "The fractal dimension of SAT formulas",
      "author" : [ "C. Ansótegui", "M.L. Bonet", "J. Giráldez-Cru", "J. Levy" ],
      "venue" : "Proc. of the 7th Int. Joint Conf. on Automated Reasoning",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2014
    }, {
      "title" : "On the structure of industrial SAT instances",
      "author" : [ "C. Ansótegui", "M.L. Bonet", "J. Levy" ],
      "venue" : "Proc. of the 15th Int. Conf. on Principles and Practice of Constraint Programming",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2009
    }, {
      "title" : "The community structure of SAT formulas",
      "author" : [ "C. Ansótegui", "J. Giráldez-Cru", "J. Levy" ],
      "venue" : "Proc. of the 15th Int. Conf. on Theory and Applications of Satisfiability Testing",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2012
    }, {
      "title" : "Using community structure to detect relevant learnt clauses",
      "author" : [ "C. Ansótegui", "J. Giráldez-Cru", "J. Levy", "L. Simon" ],
      "venue" : "Proc. of the 18th Int. Conf. on Theory and Applications of Satisfiability Testing (SAT’15)",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2015
    }, {
      "title" : "Predicting learnt clauses quality in modern SAT solvers",
      "author" : [ "G. Audemard", "L. Simon" ],
      "venue" : "Proc. of the 21st Int. Joint Conf. on Artificial Intelligence",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2009
    }, {
      "title" : "Modularity and community detection in bipartite networks",
      "author" : [ "M.J. Barber" ],
      "venue" : "Phys. Rev. E",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2007
    }, {
      "title" : "Decomposing SAT problems into connected components",
      "author" : [ "A. Biere", "C. Sinz" ],
      "venue" : "JSAT 2",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2006
    }, {
      "title" : "Fast unfolding of communities in large networks",
      "author" : [ "V.D. Blondel", "Guillaume", "J.-L", "R. Lambiotte", "E. Lefebvre" ],
      "venue" : "Journal of Statistical Mechanics: Theory and Experiment",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2008
    }, {
      "title" : "On modularity clustering",
      "author" : [ "U. Brandes", "D. Delling", "M. Gaertler", "R. Görke", "M. Hoefer", "Z. Nikoloski", "D. Wagner" ],
      "venue" : "IEEE Trans. on Knowledge and Data Engineering",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2008
    }, {
      "title" : "Creating industrial-like sat instances by clustering and reconstruction",
      "author" : [ "S. Burg", "M. Kaufmann", "S. Kottler" ],
      "venue" : "Proc. of the 15th Int. Conf. on Theory and Applications of Satisfiability Testing",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2012
    }, {
      "title" : "Finding community structure in very large networks",
      "author" : [ "A. Clauset", "M.E.J. Newman", "C. Moore" ],
      "venue" : "Phys. Rev. E",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2004
    }, {
      "title" : "Constraint Processing",
      "author" : [ "R. Dechter" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2003
    }, {
      "title" : "Effective preprocessing in SAT through variable and clause elimination",
      "author" : [ "N. Eén", "A. Biere" ],
      "venue" : "Proc. of the 8th Int. Conf. on Theory and Applications of Satisfiability Testing",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2005
    }, {
      "title" : "An extensible SAT-solver",
      "author" : [ "N. Eén", "N. Sörensson" ],
      "venue" : "Proc. of the 6th Int. Conf. on Theory and Applications of Satisfiability Testing",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2003
    }, {
      "title" : "On random graphs",
      "author" : [ "P. Erdós", "A. Rényi" ],
      "venue" : "Publicationes Mathematicae",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1959
    }, {
      "title" : "Community detection in graphs",
      "author" : [ "S. Fortunato" ],
      "venue" : "Physics Reports 486 (3-5),",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2010
    }, {
      "title" : "Morphing: Combining structure and randomness",
      "author" : [ "I.P. Gent", "H.H. Hoos", "P. Prosser", "T. Walsh" ],
      "venue" : "Proc. of the 16th Nat. Conf. on Artificial Intelligence",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1999
    }, {
      "title" : "A modularity-based random SAT instances generator",
      "author" : [ "J. Giráldez-Cru", "J. Levy" ],
      "venue" : "Proc. of the 24th Int. Joint Conf. on Artificial Intelligence",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2015
    }, {
      "title" : "Generating SAT instances with community structure",
      "author" : [ "J. Giráldez-Cru", "J. Levy" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2016
    }, {
      "title" : "Problem structure in the presence of perturbations",
      "author" : [ "C.P. Gomes", "B. Selman" ],
      "venue" : "Proc. of the 14th Nat. Conf. on Artificial Intelligence",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1997
    }, {
      "title" : "Refining the phase transition in combinatorial search",
      "author" : [ "T. Hogg" ],
      "venue" : "Artif. Intell",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1996
    }, {
      "title" : "The effect of structural branching on the efficiency of clause learning SAT solving: An experimental study",
      "author" : [ "M. Järvisalo", "I. Niemelä" ],
      "venue" : "J. Algorithms",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2008
    }, {
      "title" : "Empirical study of the anatomy of modern SAT solvers",
      "author" : [ "H. Katebi", "K.A. Sakallah", "J.P. Marques-Silva" ],
      "venue" : "Proc. of the 14th Int. Conf. on Theory and Applications of Satisfiability Testing",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2011
    }, {
      "title" : "Eigenvector centrality in industrial SAT instances",
      "author" : [ "G. Katsirelos", "L. Simon" ],
      "venue" : "Proc. of the 19th Int. Conf. on Principles and Practice of Constraint Programming",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2012
    }, {
      "title" : "Ten challenges redux: Recent progress in propositional reasoning and search",
      "author" : [ "H.A. Kautz", "B. Selman" ],
      "venue" : "Proc. of the 9th Int. Conf. on Principles and Practice of Constraint Programming",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2003
    }, {
      "title" : "The state of SAT",
      "author" : [ "H.A. Kautz", "B. Selman" ],
      "venue" : "Discrete Applied Mathematics",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2007
    }, {
      "title" : "Structure-preserving instance generation",
      "author" : [ "Y. Malitsky", "M. Merschformann", "B. O’Sullivan", "K. Tierney" ],
      "venue" : "Proc. of the 10th Learning and Intelligen Optimization Conference (LION’16)",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2016
    }, {
      "title" : "Community-based partitioning for maxsat solving",
      "author" : [ "R. Martins", "V.M. Manquinho", "I. Lynce" ],
      "venue" : "Proc. of the 16th Int. Conf. on Theory and Applications of Satisfiability Testing",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2013
    }, {
      "title" : "Exploiting resolution-based representations for MaxSAT solving",
      "author" : [ "M. Neves", "R. Martins", "M. Janota", "I. Lynce", "V.M. Manquinho" ],
      "venue" : "Proc. of the 18th Int. Conf. on Theory and Applications of Satisfiability Testing",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2015
    }, {
      "title" : "Fast algorithm for detecting community structure in networks",
      "author" : [ "M.E.J. Newman" ],
      "venue" : "Phys. Rev. E",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2004
    }, {
      "title" : "Finding and evaluating community structure in networks",
      "author" : [ "M.E.J. Newman", "M. Girvan" ],
      "venue" : "Phys. Rev. E",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2004
    }, {
      "title" : "Impact of community structure on SAT solver performance",
      "author" : [ "Z. Newsham", "V. Ganesh", "S. Fischmeister", "G. Audemard", "L. Simon" ],
      "venue" : "Proc. of the 17th Int. Conf. on Theory and Applications of Satisfiability Testing",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2014
    }, {
      "title" : "SATGraf: Visualizing the evolution of SAT formula structure in solvers",
      "author" : [ "Z. Newsham", "W. Lindsay", "V. Ganesh", "J.H. Liang", "S. Fischmeister", "K. Czarnecki" ],
      "venue" : "Proc. of the 18th Int. Conf. on Theory and Applications of Satisfiability Testing",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2015
    }, {
      "title" : "Near linear time algorithm to detect community structures in large-scale networks",
      "author" : [ "U.N. Raghavan", "R. Albert", "S. Kumara" ],
      "venue" : "Phys. Rev. E",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2007
    }, {
      "title" : "Satisfiability testing: Recent developments and challenge problems",
      "author" : [ "B. Selman" ],
      "venue" : "Proc. of the 15th Annual IEEE Symposium on Logic in Computer Science (LICS’00)",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2000
    }, {
      "title" : "Ten challenges in propositional reasoning and search",
      "author" : [ "B. Selman", "H.A. Kautz", "D.A. McAllester" ],
      "venue" : "Proc. of the 15th Int. Joint Conf. on Artificial Intelligence",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 1997
    }, {
      "title" : "Post mortem analysis of SAT solver proofs",
      "author" : [ "L. Simon" ],
      "venue" : "Proc. of the 5th Pragmatics of SAT Workshop",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2014
    }, {
      "title" : "Modelling more realistic SAT problems",
      "author" : [ "A. Slater" ],
      "venue" : "Proc. of the 15th Australian Joint Conf. on Artificial Intelligence",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2002
    }, {
      "title" : "Community branching for parallel portfolio SAT solvers",
      "author" : [ "T. Sonobe", "S. Kondoh", "M. Inaba" ],
      "venue" : "Proc. of the 17th Int. Conf. on Theory and Applications of Satisfiability Testing",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2014
    }, {
      "title" : "Search in a small world",
      "author" : [ "T. Walsh" ],
      "venue" : "Proc. of the 16th Int. Joint Conf. on Artificial Intelligence",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 1999
    }, {
      "title" : "Search on high degree graphs",
      "author" : [ "T. Walsh" ],
      "venue" : "Proc. of the 17th Int. Joint Conf. on Artificial Intelligence",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 2001
    }, {
      "title" : "Collective dynamics of ’small-world",
      "author" : [ "D.J. Watts", "S.H. Strogatz" ],
      "venue" : "networks. Nature",
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 1998
    }, {
      "title" : "Backdoors to typical case complexity",
      "author" : [ "R. Williams", "C.P. Gomes", "B. Selman" ],
      "venue" : "Proc. of the 18th Int. Joint Conf. on Artificial Intelligence",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 42,
      "context" : "The intuition is that the difference in performance of SAT solvers between random and industrial instances comes from the existence of some kind of structure in industrial instances that can be exploited [44, 21, 22, 18, 23, 6].",
      "startOffset" : 204,
      "endOffset" : 227
    }, {
      "referenceID" : 19,
      "context" : "The intuition is that the difference in performance of SAT solvers between random and industrial instances comes from the existence of some kind of structure in industrial instances that can be exploited [44, 21, 22, 18, 23, 6].",
      "startOffset" : 204,
      "endOffset" : 227
    }, {
      "referenceID" : 20,
      "context" : "The intuition is that the difference in performance of SAT solvers between random and industrial instances comes from the existence of some kind of structure in industrial instances that can be exploited [44, 21, 22, 18, 23, 6].",
      "startOffset" : 204,
      "endOffset" : 227
    }, {
      "referenceID" : 16,
      "context" : "The intuition is that the difference in performance of SAT solvers between random and industrial instances comes from the existence of some kind of structure in industrial instances that can be exploited [44, 21, 22, 18, 23, 6].",
      "startOffset" : 204,
      "endOffset" : 227
    }, {
      "referenceID" : 21,
      "context" : "The intuition is that the difference in performance of SAT solvers between random and industrial instances comes from the existence of some kind of structure in industrial instances that can be exploited [44, 21, 22, 18, 23, 6].",
      "startOffset" : 204,
      "endOffset" : 227
    }, {
      "referenceID" : 4,
      "context" : "The intuition is that the difference in performance of SAT solvers between random and industrial instances comes from the existence of some kind of structure in industrial instances that can be exploited [44, 21, 22, 18, 23, 6].",
      "startOffset" : 204,
      "endOffset" : 227
    }, {
      "referenceID" : 22,
      "context" : "The main component of these solvers is the learning of new clauses during the search [24].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 14,
      "context" : "The classical Erdös-Rényi random graph model [16] was one of the best studied during the last century, and set the basis of graph theory.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 41,
      "context" : "A first model is the small-world topology, proposed by Watts and Strogatz [43], as a new model to describe the structure of some social networks.",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 16,
      "context" : "[18] analyze the impact of a small-world topology on the cost of coloring graphs, and Walsh [42] does the same in the case of scale-free graphs.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 40,
      "context" : "[18] analyze the impact of a small-world topology on the cost of coloring graphs, and Walsh [42] does the same in the case of scale-free graphs.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 39,
      "context" : "Walsh [41] analyzes the small world topology of many graphs associated with search problems in AI.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 15,
      "context" : "This is a very characteristic feature in realworld networks [17], that has received the attention of many researchers in the last years.",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 29,
      "context" : "In order to analyze the community structure of SAT instances, we use the notion of modularity introduced by Newman [31].",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 6,
      "context" : "Biere and Sinz [8] show that many SAT instances can be decomposed into connected components, and how to handle them within a SAT solver.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 27,
      "context" : "As we will see in the next section, this decisive result has been already used as the core of other applications, as some modularity-based SAT and MaxSAT solvers [29, 40, 30, 5] or some modularity-based pseudo-industrial random generators [19, 20].",
      "startOffset" : 162,
      "endOffset" : 177
    }, {
      "referenceID" : 38,
      "context" : "As we will see in the next section, this decisive result has been already used as the core of other applications, as some modularity-based SAT and MaxSAT solvers [29, 40, 30, 5] or some modularity-based pseudo-industrial random generators [19, 20].",
      "startOffset" : 162,
      "endOffset" : 177
    }, {
      "referenceID" : 28,
      "context" : "As we will see in the next section, this decisive result has been already used as the core of other applications, as some modularity-based SAT and MaxSAT solvers [29, 40, 30, 5] or some modularity-based pseudo-industrial random generators [19, 20].",
      "startOffset" : 162,
      "endOffset" : 177
    }, {
      "referenceID" : 3,
      "context" : "As we will see in the next section, this decisive result has been already used as the core of other applications, as some modularity-based SAT and MaxSAT solvers [29, 40, 30, 5] or some modularity-based pseudo-industrial random generators [19, 20].",
      "startOffset" : 162,
      "endOffset" : 177
    }, {
      "referenceID" : 17,
      "context" : "As we will see in the next section, this decisive result has been already used as the core of other applications, as some modularity-based SAT and MaxSAT solvers [29, 40, 30, 5] or some modularity-based pseudo-industrial random generators [19, 20].",
      "startOffset" : 239,
      "endOffset" : 247
    }, {
      "referenceID" : 18,
      "context" : "As we will see in the next section, this decisive result has been already used as the core of other applications, as some modularity-based SAT and MaxSAT solvers [29, 40, 30, 5] or some modularity-based pseudo-industrial random generators [19, 20].",
      "startOffset" : 239,
      "endOffset" : 247
    }, {
      "referenceID" : 3,
      "context" : "In fact, this idea of destroying the original partition of the formula is used to improve the performance of several CDCL SAT solvers [5].",
      "startOffset" : 134,
      "endOffset" : 137
    }, {
      "referenceID" : 2,
      "context" : "This work is an extended and revised version of [4].",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 2,
      "context" : "The previous version of this paper [4] has been a seminal contribution to many other works.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 31,
      "context" : "The community structure is correlated to the runtime of CDCL SAT solvers [33, 34].",
      "startOffset" : 73,
      "endOffset" : 81
    }, {
      "referenceID" : 32,
      "context" : "The community structure is correlated to the runtime of CDCL SAT solvers [33, 34].",
      "startOffset" : 73,
      "endOffset" : 81
    }, {
      "referenceID" : 27,
      "context" : "[29] partition MaxSAT instances using the community structure in order to identify smaller unsatisfiable subformulas.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "[30].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 38,
      "context" : "[40] use the partition obtained with the community structure to improve the performance of a parallel SAT solver.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 3,
      "context" : "The community structure is used to detect relevant learnt clauses, and the performances of several CDCL SAT solvers are improved augmenting the original instance with this set of useful clauses [5].",
      "startOffset" : 194,
      "endOffset" : 197
    }, {
      "referenceID" : 35,
      "context" : "[37] as one of the ten most interesting challenges in propositional search.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "The same problem is highlighted by Kautz and Selman [26], Dechter [13].",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 11,
      "context" : "The same problem is highlighted by Kautz and Selman [26], Dechter [13].",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 37,
      "context" : "There exist some generators that indirectly use the notion of modularity [39, 11, 33, 28].",
      "startOffset" : 73,
      "endOffset" : 89
    }, {
      "referenceID" : 9,
      "context" : "There exist some generators that indirectly use the notion of modularity [39, 11, 33, 28].",
      "startOffset" : 73,
      "endOffset" : 89
    }, {
      "referenceID" : 31,
      "context" : "There exist some generators that indirectly use the notion of modularity [39, 11, 33, 28].",
      "startOffset" : 73,
      "endOffset" : 89
    }, {
      "referenceID" : 26,
      "context" : "There exist some generators that indirectly use the notion of modularity [39, 11, 33, 28].",
      "startOffset" : 73,
      "endOffset" : 89
    }, {
      "referenceID" : 17,
      "context" : "Recently, the Community Attachment model [19, 20] has been proposed to generate random pseudo-industrial instances with high modularity.",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 18,
      "context" : "Recently, the Community Attachment model [19, 20] has been proposed to generate random pseudo-industrial instances with high modularity.",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 1,
      "context" : "Most industrial SAT instances have a scale-free structure [3].",
      "startOffset" : 58,
      "endOffset" : 61
    }, {
      "referenceID" : 23,
      "context" : "Katsirelos and Simon [25] study the centrality of variables picked by a CDCL solver.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 36,
      "context" : "Simon [38] uses observations from the SAT solver performance on industrial problems to better understand its behavior.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 0,
      "context" : "Also, most industrial SAT instances have fractal dimension [2].",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 30,
      "context" : "The notion of modularity was introduced by Newman and Girvan [32].",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 30,
      "context" : "To avoid this problem, Newman and Girvan [32] define modularity as the fraction of edges connecting vertexes of the same community minus the expected fraction of edges in a random graph with the same number of vertexes and the same node degrees.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 30,
      "context" : "7, higher values are rare [32].",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 5,
      "context" : "Here we will use the notion proposed by Barber [7] that extends Newman and Girvan’s definition by restricting the random graphs used in the second term of such definition to be bipartite.",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 15,
      "context" : "See [17] for a survey in the field.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 8,
      "context" : "The decision version of modularity maximization is NP-complete [10].",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 29,
      "context" : "There are algorithms specially designed to deal with large-scale networks, like the greedy algorithms for modularity optimization [31, 12], the label propagation-based algorithm [35] and the method based on graph folding [9].",
      "startOffset" : 130,
      "endOffset" : 138
    }, {
      "referenceID" : 10,
      "context" : "There are algorithms specially designed to deal with large-scale networks, like the greedy algorithms for modularity optimization [31, 12], the label propagation-based algorithm [35] and the method based on graph folding [9].",
      "startOffset" : 130,
      "endOffset" : 138
    }, {
      "referenceID" : 33,
      "context" : "There are algorithms specially designed to deal with large-scale networks, like the greedy algorithms for modularity optimization [31, 12], the label propagation-based algorithm [35] and the method based on graph folding [9].",
      "startOffset" : 178,
      "endOffset" : 182
    }, {
      "referenceID" : 7,
      "context" : "There are algorithms specially designed to deal with large-scale networks, like the greedy algorithms for modularity optimization [31, 12], the label propagation-based algorithm [35] and the method based on graph folding [9].",
      "startOffset" : 221,
      "endOffset" : 224
    }, {
      "referenceID" : 29,
      "context" : "The first algorithm for modularity maximization was described by Newman [31].",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 10,
      "context" : "[12] optimize the data structures used in this basic algorithm, using among others, data structures for sparse matrices.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 33,
      "context" : "[35].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "[9] (see Alg.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "In our experiment, we use this method since it gives better bounds in both models VIG and CVIG than other algorithms, like LPA [4].",
      "startOffset" : 127,
      "endOffset" : 130
    }, {
      "referenceID" : 2,
      "context" : "[4], where experiments are performed on the set of the SAT Race 2010, and by Ansótegui et al.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "[5] where it is computed the community structure of the industrial benchmarks of the SAT Competitions of 2011 and 2014.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 12,
      "context" : "For each family of industrial instances, we present the results of the modularity Qorig of the original formulas, and the modularity Qprep of these formulas after prepossessing with Satelite [14] with default options.",
      "startOffset" : 191,
      "endOffset" : 195
    }, {
      "referenceID" : 6,
      "context" : "Finally, we also study the connected components, as suggested by Biere and Sinz [8].",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 13,
      "context" : "The solver used to produce these learnt clauses is MiniSAT [15].",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 4,
      "context" : "Glucose [6] solved this formula keeping a total of 504964 learnt clauses.",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 27,
      "context" : "Moreover, the better understanding of this structure in real-world instances has led to the improvement of existing SAT solvers [29, 30, 40, 5].",
      "startOffset" : 128,
      "endOffset" : 143
    }, {
      "referenceID" : 28,
      "context" : "Moreover, the better understanding of this structure in real-world instances has led to the improvement of existing SAT solvers [29, 30, 40, 5].",
      "startOffset" : 128,
      "endOffset" : 143
    }, {
      "referenceID" : 38,
      "context" : "Moreover, the better understanding of this structure in real-world instances has led to the improvement of existing SAT solvers [29, 30, 40, 5].",
      "startOffset" : 128,
      "endOffset" : 143
    }, {
      "referenceID" : 3,
      "context" : "Moreover, the better understanding of this structure in real-world instances has led to the improvement of existing SAT solvers [29, 30, 40, 5].",
      "startOffset" : 128,
      "endOffset" : 143
    }, {
      "referenceID" : 35,
      "context" : "This problem is distinguished as one of the 10 challenge problems in SAT [37, 36, 26, 27].",
      "startOffset" : 73,
      "endOffset" : 89
    }, {
      "referenceID" : 34,
      "context" : "This problem is distinguished as one of the 10 challenge problems in SAT [37, 36, 26, 27].",
      "startOffset" : 73,
      "endOffset" : 89
    }, {
      "referenceID" : 24,
      "context" : "This problem is distinguished as one of the 10 challenge problems in SAT [37, 36, 26, 27].",
      "startOffset" : 73,
      "endOffset" : 89
    }, {
      "referenceID" : 25,
      "context" : "This problem is distinguished as one of the 10 challenge problems in SAT [37, 36, 26, 27].",
      "startOffset" : 73,
      "endOffset" : 89
    } ],
    "year" : 2016,
    "abstractText" : "Modern SAT solvers have experienced a remarkable progress on solving industrial instances. Most of the techniques have been developed after an intensive experimental process. It is believed that these techniques exploit the underlying structure of industrial instances. However, there are few works trying to exactly characterize the main features of this structure. The research community on complex networks has developed techniques of analysis and algorithms to study real-world graphs that can be used by the SAT community. Recently, there have been some attempts to analyze the structure of industrial SAT instances in terms of complex networks, with the aim of explaining the success of SAT solving techniques, and possibly improving them. In this paper, inspired by the results on complex networks, we study the community structure, or modularity, of industrial SAT instances. In a graph with clear community structure, or high modularity, we can find a partition of its nodes into communities such that most edges connect variables of the same community. In our analysis, we represent SAT instances as graphs, and we show that most application benchmarks are characterized by a high modularity. On the contrary, random SAT instances are closer to the classical Erdös-Rényi random graph model, where no structure can be observed. We also analyze how this structure evolves by the effects of the execution of the SAT solver. We detect that new clauses learnt by the solver during the search contribute to destroy the original community structure of the formula. This partially explains the distinct performance of SAT solvers on random and industrial SAT instances.",
    "creator" : "gnuplot 5.0 patchlevel 0"
  }
}