{
  "name" : "1301.1389.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Planning and Scheduling in Hybrid Domains Using Answer Set Programming",
    "authors" : [ "Sandeep Chintabathina" ],
    "emails" : [ "chintabathinas@uapb.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "In this paper we are interested in modeling intelligent agents capable of planning, acting and reasoning in a dynamic environment. We are primarily interested in hybrid domains - domains that exhibit both discrete and continuous behavior. Many real world situations such as a robot in a manufacturing plant, a decision control system of a space shuttle etc. deal with both discrete change as well as continuous change. For example, a decision control system in a space shuttle is capable of opening and closing valves of fuel tanks to supply fuel to some jets. The actions open and close change positions of valves. The valves will remain in a certain position as long as no open or close actions occurs. The change of position of valves is, therefore, discrete. However, the fuel level in the tank can change continuously with time when the valve is open or there is an incoming supply of fuel to the tank. This type of continuous change coupled with discrete change makes this domain hybrid. We are not only interested in modeling such domains but also to solve planning and scheduling problems in such domains. A simple planning and scheduling problem in the above example would be to fire a jet within 10 seconds. This would require opening and closing the appropriate valves and delivering fuel to the jet in time to achieve the goal.\nTo model intelligent agents we need to provide the agent with knowledge about its environment and its own capabilities and goals. There are several approaches to representing and reasoning about such knowledge. In this paper, we use action language\nar X\niv :1\n30 1.\n13 89\nv1 [\ncs .A\nI] 8\nJ an\n2 01\nH - a high level language for representing and reasoning about actions and their effects. We chose this language mainly because it is capable of representing and reasoning about hybrid domains. A description written in H describes a transition diagram whose states correspond to possible physical states of the system and whose arcs are labeled by actions. A transition, 〈σ ,a,σ ′〉, of a diagram denotes that action a is possible in state σ and that after the execution of a the system may move to state σ ′. The diagram consists of all possible trajectories of the system.\nLanguage H [4] was developed by extending the signature of action language A L [2] with a collection of numbers for representing time, a collection of functions of time, and fluents 1 with non-boolean values including fluents defined by functions of time (process fluents). It also allows triggers which specifies conditions under which actions are triggered. The semantics of A L is based on the McCain-Turner equation [9]. A slightly modified version of this equation defines the semantics of H. Thus, both languages are based on the same underlying intuition. However, in A L a state of the transition diagram is a snapshot of the world, whereas in H, a state is a snapshot of the world over a time interval. Process fluents are defined over this time interval. Prior to H, logic-based formalisms such as Situation Calculus [13] and Event Calculus [14] were extended to reason about process fluents. Both approaches demonstrate via examples how their approach can be used for reasoning about process fluents. However, in both approaches, it is difficult to express causal relations between fluents.\nTo solve planning and scheduling problems in hybrid domains, we use an action language-logic programming approach. We begin by representing the domain in H. To this extent, we come up with a theory of H (also called action description) to describe actions and their effects. We implement this theory by translating it into an Answer Set Prolog (A-Prolog) program, a class of logic programs under answer set semantics [7,8], and computing answer sets (models) of the resulting program. In this way, we reduce the problem of finding solutions to the planning and scheduling problem to computing answer sets of the A-Prolog program. In [5] we show that there is a one-to-one correspondence between models of A-Prolog programs and models of our specification.\nThe paper is organized as follows. In section 2, we revisit the syntax and semantics of H as described in [4]. In section 3, we cite a planning and scheduling example from [12] and come up with a theory of H to model it. In section 4, we present the main contribution of this paper which is the translation of the resulting H theory into an A-Prolog program. The example from [12] was run using ZENO, a least commitment planner that supports continuous change. After ZENO, researchers have come up with several efficient solvers. One significant contribution is the Planning Domain Description Language (PDDL) which was exclusively developed for planning purposes. A variant of this language, PDDL+ [6] is capable of modeling continuous change through the use of processes and events. Like H, the semantics of this language is defined using a labeled transition diagram. The language has been shown to represent a number of complex time dependent effects. However, one major limitation of the language is that it does not support derived predicates - predicates defined in terms of other predicates for eg. above(x,y) from the blocks world domain. There are no such limitations in H.\n1 functions whose values depend on a state and may change as a result of actions"
    }, {
      "heading" : "2 Preliminaries",
      "text" : "In this section we revisit the syntax and semantics of H as described in [4]."
    }, {
      "heading" : "2.1 Syntax",
      "text" : "By sort we mean a non-empty countable collection of strings in some fixed alphabet. A sorted signature Σ is a collection of sorts and function symbols. A process signature is a sorted signature with special sorts time, action, and process. Sort time is normally identified with one of the standard numerical sorts with the exception that it contains an ordinal ω such that for any x ∈ time \\ {ω}, ω > x. No operations are defined over ω . If time is discrete, elements of time\\{ω} may be viewed as non-negative integers, otherwise they can be interpreted as either rational numbers, constructive real numbers, etc. Sort process contains strings of the form λT. f (T ) where T is a variable ranging over time and f (T ) is a mathematical expression (possibly) containing T . A string λT. f (T ) represents a function defined over time. The λ is said to bind T in f (T ). If the expression, f (T ), does not contain any variables for time then λT. f (T ) is said to denote a constant function. For e.g. λT.0 denotes the constant function 0. For simplicity we assume that all functions from process have the same range denoted by the sort range(process). An example of a function from sort process is λT.h−(g/2)∗(T − t)2 which defines the height in meters, at time T, of a freely falling object dropped from a height h, T − t seconds before. The symbol g denotes the Earth’s average gravitational acceleration which is equal to 9.8 meters/sec2. Sort action is divided into subsorts agent and exogenous. Members of agent denote (unit) actions performed by an agent and members of exogenous denote non-agent actions. Both agent and exogenous actions will be referred to as actions. A compound action is a set of unit actions performed at the same time. The collection of function symbols includes names for fluents and standard numerical functions. Each fluent name is associated with an arity - a number indicating the number of arguments. Intuitively, fluents are properties that may change as a result of actions. For example, the height of a brick held at a certain position above the ground could change when it is dropped. Every process signature contains reserved fluents start and end of sort time. A term of sort s is defined as follows:\n1. A string y ∈ s is a term of sort s; 2. If t1, . . . , tn are terms of sorts s1, . . . ,sn respectively and f : s1× . . .× sn → s is a\nfunction symbol then f (t1, . . . , tn) is a term of sort s.\nNotice that if f (x̄) is a term of sort process and t is a term of sort time then f (x̄)(t) is a term of sort range(process). For example, to represent the height of brick b we can introduce a fluent height(b) of sort process. Then by height(b)(10) we denote the height of b at time 10. Similarly, λT.200− (g/2) ∗ (T − 5)2(10) denotes the value of the function at T = 10 which is equal to 77.5. An atom of Σ is a statement of the form t = y where t is a term of some sort s and y ∈ s. Examples of atoms are end = 10, 2+3 = 5 etc. If t is a term built from fluent symbols\nthen such an atom is called a fluent atom. Examples of fluent atoms are height(b) = λT.100− (g/2)∗ (T −5)2, height(b)(5) = 100, end = 10, etc. A literal of Σ is an atom t = y or its negation ¬(t = y) . Negation of = will be often written as 6=. If t is a term of Boolean sort then t = true (t 6= f alse) is often written as t and t = f alse (t 6= true) is often written as ¬t. For example, the atom 4 < 5 = true will be written as 4 < 5. Language, H, is parameterized by a process signature Σ with standard interpretations of numerical functions and relations (such as +,<,≤, 6=, etc).\nDefinition 1. An action description of H(Σ) is a collection of statements of the form:\nl0 if l1, . . . , ln. (1) e causes l0 if l1, . . . , ln. (2) impossible e1, . . . ,em if l1, . . . , ln. (3) l1, . . . , ln triggers e. (4)\nwhere e’s are elements of action, l0’s are fluent atoms and l1, . . . , ln are literals of the signature of H. l0 is referred to as the head of a statement and l1, . . . , ln are referred to as the body of a statement. A statement of the form (1) is called a state constraint. It guarantees that any state satisfying l1, . . . , ln also satisfies l0. A statement of the form (2) is called a dynamic causal law and it states that if action e were executed in a state satisfying literals l1, . . . , ln then any successor state would satisfy l0. A statement of the form (3) is called an executability condition and it states that actions e1, . . . ,em cannot be executed in a state satisfying l1, . . . , ln. If n = 0 then if is dropped from statements (1), (2) and (3). A statement of the form (4) is called a trigger and it states that action e is triggered in any state satisfying l1, . . . , ln.\nBy ground instantiations of a variable of sort s, we mean the elements of s. From the description of the syntax, the only variable that appears in the statements of H is the variable T ranging over time. However, variables ranging over other sorts are allowed in the statements as long as those statements are viewed as a shorthand for the collection of statements obtained by replacing each occurrence of a variables other than T by its corresponding ground instantiations."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "The semantics of language H is based on a slightly modified McCain-Turner equation [9]. An action description, AD, of H(Σ ) describes a transition diagram, T D(AD), whose nodes correspond to possible physical states of a system and whose arcs are labeled by actions. A transition 〈s,a,s′〉 of the diagram denotes that action a is possible in s and as a result of execution of a the system may move to state s′. It is important to note that an action description of H can be either deterministic (i.e. for any state-action pair there is at most one successor state [2]) or non-deterministic (i.e. there is a state-action pair with more than one successor state). In this section we will give a formal definition for a state and a transition of T D(AD). We begin with interpreting symbols of Σ .\nDefinition 2. Given an action description AD of H(Σ), an interpretation I of Σ is a mapping defined as follows.\n– for every non-process sort, s, and every string y ∈ s, I maps y into itself i.e. yI = y. – standard interpretation is used for the sort process and other standard numerical\nfunctions and relations. – I maps every fluent into a properly typed function.\nOften an interpretation I of Σ is identified with a collection, s(I), of atoms of the form t = y such that tI = y where t and y are terms of some sort. In other words, s(I) = {t = y | tI = y}. Before we give the definition of a state of T D(AD) let us consider the following definitions. A set, s, of atoms is said to be consistent if for every atom t = y1 ∈ s, 6 ∃y2 such that t = y2 ∈ s and y1 6= y2. Let us define what it means for a literal to be true w.r.t a set of atoms of Σ . Definition 3. Given a consistent set, L, of atoms of Σ\n– An atom t = y is true in L (symbolically L |= t = y) iff t = y ∈ L. – A literal t 6= y is true in L (L |= t 6= y) iff L |= t = y0 and y 6= y0.\nWe will now define what it means for a set of atoms to be closed under state constraints of AD.\nDefinition 4. A set L of atoms is closed under the state constraint\nl0 if l1, . . . , ln\nof AD if, whenever L |= li for every i, 1≤ i≤ n, L |= l0.\nA set L of atoms is closed under state constraints of AD if L is closed under every state constraint of AD. Next, we define what it means for a set of atoms to satisfy a trigger of AD.\nDefinition 5. A set L of atoms of H satisfies a trigger\nl1, . . . , ln triggers e\nof AD iff L |= li for every i such that 1≤ i≤ n. Intuitively, if a set of atoms satisfies a trigger it means that the corresponding action will take place at some time point. The next definition characterizes sets of atoms which “end” before any triggered action takes place.\nDefinition 6. A set L of atoms of H is closed under triggers of AD iff 6 ∃ L′ such that L′ satisfies at least one trigger of AD and L\\L′ = {end = t2} and L′ \\L = {end = t1} and t1 < t2.\nIntuitively, a state of T D(AD) can be viewed as a collection of functions of time defined over an interval. The endpoints of the interval are implicitly defined by the reserved fluents start and end. The domain of each function is the set {t | start ≤ t ≤ end∧ t < ω}. We say that a state is defined over an interval of the form [start,end] iff end 6= ω . There is at least one arc labeled by an action leading out of such a state. We say that a state is defined over an interval of the form [start,end) iff end = ω . There is no arc leading out of such a state. States that begin at time 0 are called initial states. They define the initial conditions of a domain. Here is the formal definition of a state.\nDefinition 7. Given an interpretation I of Σ , s(I) is a state of T D(AD) if each of the following holds.\n– s(I) is a collection of atoms of the form t = y such that tI = y where t and y are terms of the same sort. – s(I) is closed under the state constraints of AD. – If s(I) |= start = t1 and s(I) |= end = t2 then t1 ≤ t2∧ t1 < ω . – s(I) is closed under the triggers of AD. – If s(I) |= p = λT. f (T ) where p is a fluent of sort process then λT. f (T ) is defined\nover the domain {t | startI ≤ t ≤ endI ∧ t < ω}. – If p is a fluent of sort process and t is a term of sort time then s(I) |= p(t) = x iff\ns(I) |= p = λT. f (T ) and λT. f (T )(tI) = x.\nBy definition of interpretation every symbol is mapped uniquely. Therefore, states of T D(AD) are complete and consistent. Whenever convenient the parameter I will be dropped from s(I). Next, we will define what is means for an action to be possible in a state.\nDefinition 8. Action a is possible in state s if for every non-empty subset a0 of a, there is no executability condition\nimpossible a0 if l1, . . . , ln.\nof AD such that s |= li for every i, 1≤ i≤ n.\nGiven a state s and action e let us define what are the direct effects of executing e in s.\nDefinition 9. Let e be an elementary action that is possible in state s. By Es(e) we denote the set of all direct effects of e w.r.t s.\nEs(e) = {l0 | e causes l0 if l1, . . . , ln ∈ AD∧ s |= li for every i,1≤ i≤ n}\nIf a is a compound action then Es(a) = ⋃\ne∈a Es(e). The following definition allows us to identify sets of atoms with adjacent intervals.\nDefinition 10. Let x,y, and z be elements of sort time such that x ≤ y ≤ z∧ y < ω and s and s′ be sets of atoms of H. We say that s′ follows s iff s |= {start = x,end = y} and s′ |= {start = y,end = z}.\nGiven two sets of atoms s and s′, the function Ts(s′) is defined as follows.\nTs(s′) = { {start = t1,end = t2} if s′ follows s∧{start = t1,end = t2} ⊆ s′. /0 otherwise.\nIn other words, the function returns the interval of s′ if s′ follows s; otherwise it returns an empty set. The consequences of a set of atoms w.r.t a set of state constraints is defined as follows.\nDefinition 11. Given a set S of atoms and a set Z of state constraints of AD the set, CnZ(S), of consequences of S under Z is the smallest set of atoms (w.r.t set theoretic inclusion) containing S and closed under Z.\nDefinition 12. Action a is complete w.r.t a set of atoms s if for every trigger r ∈ AD of the form\nl1, . . . , ln triggers e\ne ∈ a iff s satisfies r.\nWe know that a state contains arbitrary atoms of Σ . However, for the next definition we focus only on fluent atoms including those formed from start and end. All other atoms such as 2+3 = 5 which is always true will be ignored.\nDefinition 13. A transition diagram T D(AD) is a tuple 〈φ ,ψ〉 where\n– φ is the set of states. – ψ is the set of all transitions 〈s,a,s′〉 such that each of the following holds. • a is complete w.r.t s • a is possible in s • s′ is closed under the triggers of AD •\ns′ =CnZ(Es(a)∪ (s∩ s′)∪Ts(s′)) (1) where Z is the set of state constraints of AD.\nThe set, Es(a), consists of direct effects of a while the set, s∩ s′, consists of facts preserved by inertia. Ts(s′) projects the start and end of s′. The application of CnZ to the union of these sets adds the indirect effects. From the definition, it is evident that concurrent actions such as dropping two balls from different heights at the same time can be handled in H."
    }, {
      "heading" : "3 A planning and scheduling example",
      "text" : "In this section we will visit a planning and scheduling example from [12] and demonstrate how to model it in H. Consider a toy world in which a single plane moves passengers between cities. Slow flying travels at 400 miles per hour and consumes 1 gallon of fuel every 3 miles, on average. Fast flying travels at 600 miles per hour and consumes 1 gallon of fuel every 2 miles. Passengers can be boarded in 30 minutes and deplaned in 20 minutes. Refueling gradually increases the fuel level to a maximum of 750 gallons, taking one hour from an empty tank. Boarding, deplaning, and refueling must all occur while the plane is on the ground. The distance between city-a and city-b is 600 miles, the distance between city-a and city-c is 1000 miles, the distance between city-b and city-c is 800 miles and the distance between city-c and city-d is 1000 miles. Suppose that Dan and Ernie are at city-c, but the empty plane and Scott are at city-a. If the plane only has 500 gallons of fuel, how can we ensure that Scott and Ernie get to city-d in less than five and a half hours? [12] A solution to this problem requires reasoning about effects of (concurrent) actions in the presence of continuous time. There are properties of the domain that change continuously with time such as the fuel level of the plane, the distance covered by the plane etc. With proper planning and scheduling, the plane will make its tight schedule without running out of fuel. Hence, the problem is a planning and scheduling problem in the presence of continuous change. We begin with the representation of the domain in H."
    }, {
      "heading" : "3.1 Representation in H",
      "text" : "We begin with the description of the signature. It consists of several objects - persons scott, ernie, and dan and locations a,b,c, and d. We will use another location called enroute to denote that the plane is in the air. We will use (possibly indexed) variables P and L to denote persons and locations respectively. We are given the constants distance(a,b,600), distance(a,c,1000) and so on. We are also given the fuel consumption rates for different speeds. For example, when flying at 400 mph the mileage is 3 miles per gallon. We can encode this information in the form of constants f c(400) and f c(600) which denote 3 miles per gallon and 2 miles per gallon respectively. For modeling purposes we will use minutes as our unit of time. We know that there are several durative actions in the domain, for example, boarding which takes 30 minutes. We will use the approach used by Reiter [13] to model durative actions. We introduce the action start boarding(P,L) which denotes that person P is boarding at location L and end boarding(P,L) which denotes that person P has finished boarding at location L. So instead of one action we have two actions start boarding(P,L) and end boarding(P,L) which make the fluent boarding(P,L) true and false respectively. In our model, the end boarding(P,L) action will be triggered 30 minutes from the time start boarding(P,L) is executed. We will use the same approach for all durative actions. We introduce the action start f lying(L1,L2,S) to denote that the plane has started flying from location L1 to location L2 with speed S. The variable S ranges over {400,600}. The remaining actions in the domain are start deplaning(P,L), end deplaning(P,L), start re f ueling, end re f ueling, and end f lying(L1,L2). The signature consists of the boolean fluents boarding(P,L), deplaning(P,L), on board(P) and re f ueling. We also have non-boolean fluents location(P) and location(plane) which range over {a,b,c,d,enroute}. We have process fluents time left board(P,L) and time left deplane(P,L) which are clock functions to count down the time left for person P to board and deplane at location L respectively. We have process fluent distance le f t(L1,L2) to denote the distance that is yet to be covered to reach L2 from L1. Finally, the process fluent f uel level denotes the fuel level in the plane’s tank. We proceed with defining the effects of each action. The effects of start boarding(P,L) are defined using dynamic causal laws\nstart boarding(P,L) causes boarding(P,L). start boarding(P,L) causes time le f t board(P,L) = λT.max(0,30− (T −T0))\nif end = T0.\nThe following executability condition says that person P cannot start boarding if he or she is already boarding.\nimpossible start boarding(P,L) i f boarding(P,L).\nThe following are causal laws involving end boarding(P,L).\nend boarding(P,L) causes ¬boarding(P,L). end boarding(P,L) causes on board(P). impossible end boarding(P,L) if ¬boarding(P,L).\nThe following are causal laws involving actions start deplaning(P,L) and end depla ning(P,L).\nstart deplaning(P,L) causes deplaning(P,L) start deplaning(P,L) causes\ntime le f t deplane(P,L) = λT.max(0,20− (T −T0)) if end = T0.\nimpossible start deplaning(P,L) if deplaning(P,L). end deplaning(P,L) causes ¬deplaning(P,L). end deplaning(P,L) causes ¬on board(P). impossible end deplaning(P,L) if ¬deplaning(P,L).\nThe following are direct effects of refueling. Instead of assuming that it takes 1 hour to fill up from an empty tank we will assume that the rate of refueling is 20 gallons per minute. When we start refueling, we add fuel to the existing level and the level increases at the rate of 20 gallons per minute.\nstart re f ueling causes f uel level = λT.max(750,X +20∗ (T −T0)) if end = T0, f uel level(end) = X . start re f ueling causes re f ueling. impossible start re f ueling if re f ueling. impossible start re f ueling if location(plane) = enroute. end re f ueling causes ¬re f ueling. impossible end re f ueling if location(plane) = enroute. impossible end re f ueling if ¬re f ueling.\nNext, we define the direct effects of start f lying(L1,L2,S).\nstart f lying(L1,L2,S) causes location(plane) = enroute. start f lying(L1,L2,S) causes distance le f t(L1,L2) = λT.max(0,X−S∗ (T −T0)/60) if distance(L1,L2,X), end = T0. start f lying(L1,L2,S) causes f uel level = λT.max(0,X−S∗ (T −T0)/(60∗ f c(S))) if f uel level(end) = X , end = T0 impossible start f lying(L1,L2,S) if location(plane) = enroute. impossible start f lying(L1,L2,S) if location(plane) 6= L1. impossible start f lying(L1,L2,S) if boarding(P,L1),\nlocation(P) = L1.\nThe following are causal laws involving action end f lying(L1,L2).\nend f lying(L1,L2) causes location(plane) = L2. impossible end f lying(L1,L2) if location(plane) 6= enroute.\nThe following causal laws specify conditions under which each “ending” action is triggered.\ntime le f t board(P,L,end) = 0 triggers end boarding(P,L). time le f t deplane(P,L,end) = 0 triggers end deplaning(P,L). f uel level(end) = 750 triggers end re f ueling. distance le f t(L1,L2,end) = 0 triggers end f lying(L1,L2).\nThe following state constraint encodes common sense knowledge. It states that a person on board a plane is at the same location as the plane.\nlocation(P) = L if location(plane) = L,on board(P).\nThe following executability condition states that flying to a location without enough fuel is not allowed. A rational reasoner who wants to reach his or her destination safely will not violate this constraint.\nimpossible start f lying(L1,L2,S) if f uel level(end) = X , distance(L1,L2,Y ), X < Y/ f c(S).\nThis concludes the representation of the domain in H."
    }, {
      "heading" : "4 Translation into logic program",
      "text" : "We solve the planning and scheduling problem by translating the above theory into an Answer Set Prolog program and computing answer sets of the resulting program. Thus, we reduce the problem of finding solutions to the planning and scheduling problem to computing answer sets of the resulting program. The translation that was provided in [5] is a theoretical translation from statements of H into rules of A-Prolog. However, in this paper we are going to provide a translation that adheres to the syntax of a specific ASP solver. Since we are dealing with continuous functions we chose a solver that, in addition to computing answer sets, is capable of reasoning about constraints over reals. Here is a brief summary of solvers that are available at our disposal.\nIn the past few years researchers [1,10] have focused on integrating Answer Set Programming(ASP) and Constraint logic programming(CLP). They came up with new systems that achieve significant improvement in performance over existing ASP solvers. The following such systems are available: ACsolver[10] (and it’s successor Luna[11]); EZCSP 2; and Clingcon3. Each solver couples a constraint solver with an answer set solver. However, the coupling varies. In Luna (ACsolver) and Clingcon the coupling is tight whereas in EZCSP the coupling is loose. We considered using Luna for our purposes but we found out that there are some implementation issues. Besides, the underlying answer set solver is less efficient than the one used by EZCSP. We also considered using Clingcon, however, the underlying constraint solver only deals with finite domains which is a limitation when dealing with continuous functions. We chose EZCSP as it allows us to reason about constraints over reals.\nIn EZCSP, the A-Prolog programs are written in such a way that their answer sets encode a constraint satisfaction problem. The system calls the answer set solver, uses the resulting answer sets to pose a constraint satisfaction problem in the input language of the constraint solver, then calls the constraint solver and combines the solutions returned by both solvers. The constraint solver can use the results from the answer set\n2 http://marcy.cjb.net/ezcsp/index.html 3 http://www.cs.uni-potsdam.de/clingcon/\nsolver to solve new constraints but the answer set solver cannot use results from the constraint solver to make new inferences. The current version uses gringo+clasp4 by default as the ASP solver and SICSTUS Prolog as the constraint solver. Both solvers are very fast.\nThe translation that we present here will be in the input language of EZCSP. Before we begin the translation there are some modeling decisions to be made. These decisions are necessary to overcome some of the implementation issues. One of the main issues is the implementation of functions. The input language of EZCSP will allow us to represent constants and variables but it is not possible to represent functions of time. For example, we can translate statements such as velocity = 5 directly into the input language of EZCSP but it is not possible to translate a statement such as height = λT.T 2 . The reason is that there is no representation for functions in this language. The alternative is to provide a value for T and obtain the value of the function for that instance. So it is possible to translate the statement height(5) = λT.T 2(5) = 25. The constraint solver may obtain the value for T from other constraints and then use that value to evaluate height(5).\nSorts, actions, boolean fluents and fluents ranging over finite domains will be translated as atoms in the input language of EZCSP. All other fluents ranging over infinite or large domains will be represented as constraint variables. Every constraint involving a constraint variable will appear in an atom called required. For example, we write required(height > 5) to denote the variable height must be greater than 5. Process fluents will be represented by constraint variables. For each process fluent we can use two constraint variables - one to denote the initial value and one to denote the final value in a given state.\nLet us look at some statements from our example and see how they are translated into EZCSP rules. Consider the following statement from our example.\nstart re f ueling causes f uel level = λT.max(750,X +20∗ (T −T0)) if end = T0, f uel level(end) = X .\nSince we cannot encode functions in EZCSP we are going to expand the signature to include a boolean fluent called re f ueling, a real-valued fluent called f time to denote the time at which fueling began and two new real-valued fluents - f initial and f f inal to denote the initial and final fuel level in a state. We then replace the above causal law with the following causal laws.\nstart re f ueling causes f initial = X if f f inal = X . start re f ueling causes f time = T if end = T. start re f ueling causes re f ueling. f f inal = max(750,X +20∗ (T −T0)) if f initial = X , f time = T0,\nend = T,re f ueling.\nThe first two dynamic causal laws say that executing start re f ueling initializes f initial to the current fuel level and f time to the end time of the current state. The next dynamic law says that start re f ueling begins the re f ueling process. Next, we have a state\n4 http://potassco.sourceforge.net/\nconstraint which defines f f inal in terms of f initial, f time and end of a state in which re f ueling is true. We consider fluents f initial, f time and re f ueling to be inertial. These fluents will retain their values until an action causes them to change. For example, f initial will be reset by actions end re f ueling, start f lying(L1,L2,S) and end f lying(L1,L2) because each action has a bearing on the fuel level. So we will add dynamic causal laws encoding the effects of these actions on f initial. The relationship between the process fluent f uel level in the original action description and f f inal in the modified action description is that for any given state, f f inal = f uel level(end).\nTo translate the above statements into EZCSP we have to first define the various constraint variables. All the real-valued fluents will be translated as constraint variables. Since fluents are dependent on state, we have to consider state as one of its parameters during translation. It is important to note that with the assignment of time intervals to states, each state in a transition diagram is unique. Our approach is to assign (nonnegative) integers to each state in the order it appears in the trajectory of a transition diagram. This is done in the language of EZCSP as follows.\n#const n = 10. step(0..n). #domain step(I; I1).\nHere n denotes the length of the trajectory and the #domain declaration says that variables I and I1 range over [0,n] . Next, we will define the various constraint variables parameterized by step.\ncspvar( f time(I),0,400). cspvar( f initial(I),0,750). cspvar( f f inal(I),0,750). cspvar(end(I),0,400).\nThe numbers in each declaration specify the range of that variable. Next, the boolean fluent re f ueling will be translated into the atom v(X ,re f ueling, I) where X ranges over {true, f alse}. It says that X is the value of re f ueling in step I. The action start re f ueling is translated as occurs(start re f ueling, I) which says that start re f ueling occurred in step I. Finally, here are the EZCSP rules obtained by translating the above causal laws.\nrequired( f initial(I1) == f f inal(I)) :−occurs(start re f ueling, I), I1 = I +1. required( f time(I1) == end(I)) :−occurs(start re f ueling, I), I1 = I +1. v(true,re f ueling, I +1) :−occurs(start re f ueling, I). required( f f inal(I) == max(750, f initial(I)+20∗ (end(I)− f time(I)))) :−\nv(true,re f ueling, I).\nThe rest of the dynamic causal laws are translated using a similar approach. As mentioned before, in EZCSP the answer set solver does not receive any input from the constraint solver to make new inferences. This poses a problem especially when translating triggers. A trigger mentions the conditions under which an action will be executed. It is possible that these conditions are constraints over time. Even if these constrains are evaluated, since there is no feedback to the answer set solver, it is not possible to know when an action is triggered. The author of EZCSP, Marcello Balduccini, has suggested a solution to overcome this problem. Suppose that we have the following trigger.\nf uel level(end) = 750 triggers end re f ueling.\nSince we have replaced process fluent f uel level with other real valued fluents, this trigger is really\nf initial = X , f time = T,re f ueling,end = (750−X)/20+T triggers end re f ueling\nGiven the initial fuel level X and the refuel rate of 20 gallons per minute, the expression (750−X)/20 gives the number of minutes it takes to fill up the tank. The trigger states that if a state ends at a time when the tank is full then end re f ueling is triggered. Of course, re f ueling must be also be true in that state. A direct translation of this trigger is\noccurs(end re f ueling, I) :− required(end(I) == (750− f initial(I))/20+ f time(I)), v(true,re f ueling, I).\nThis rule will be fired if the body is satisfied. The atom v(true,re f ueling, I) is a direct consequence of start re f ueling. However, the constraint atom in the body of the rule is not obtained from other rules of the program. Balduccini suggested that it can be generated by adding the rules\n1{p(I),q(I)}1 :−v(true,re f ueling, I). required(end(I) == (750− f initial(I))/20+ f time(I)) :−p(I). required(end(I)< (750− f initial(I))/20+ f time(I)) :−q(I).\nThe choice rule will allow us to generate one of the two constraints. If no action takes place before the tank fills up then end re f ueling is triggered. We use the same approach to translate other triggers in the domain. Currently, there is no formal proof stating that this solution will always work. However, the solution is based on answer set programming methodology and EZCSP uses a state-of-the-art answer set solver. We rely on the solver to give us the correct solutions.\nIn our example, the goal is to have Scott and Ernie in city d in less than five and a half hours (330 minutes). We encode this goal in EZCSP as follows\ngoal(I) :− v(d, location(scott), I),v(d, location(ernie), I), required(start(I)< 330).\nwhere start(I) is a constraint variable denoting the start time of a step. The constraint says that the goal state must be achieved in less than five and a half hours. It is generated by adding the rules\n1{g(I),ng(I)}1. required(start(I)< 330) :−g(I). required(start(I)>= 330) :−ng(I).\nWe add the following rules to say that failure is not an option.\nsuccess :−goal(I). :−not success.\nNext, we will talk about the planning component of the program. As in the case of noncontinuous domains, we will use Answer Set Programming techniques for generating\nand testing plans. A plan is a sequence of actions. We will be generating all possible sequences of actions that will lead us to our goal. In the process of generating these plans we use the constraints in our program to test these plans and discard the ones that violate the constraints. A simple way to generate plans is to use the choice rule\n{occurs(A, I) : action(A)} :−step(I), I < n.\nwhere n is the length of the plan. Note that we are going to generate only the initiating actions for example, start re f ueling etc. This is because all the terminating actions have triggers associated with them and there is no need to generate them again. Since we are dealing with continuous time, in addition to computing the sequences of actions, we will also determine when these actions will take place. This is the reason why planning in hybrid domains also involves scheduling. According to the problem specification, we have a constraint that specifies the time within which the goal has to be achieved i.e. five and a half hours. We can specify this constraint in EZCSP as follows.\nrequired(end(I)< 330) :−occurs(A, I),action(A).\nThe rules states that all action occurrences must take place before five and a half hours. This constraint gives a very broad range of scheduling possibilities. The times during which actions will take place could now range over intervals of time. For example, in order to achieve our goal it may be required that Scott has to board the plane within the first 50 minutes and that the plane has to depart city c no later than three hours and 45 minutes into the trip. Dealing with time intervals is an issue because it does not allow us to compute values of fluents at specific time points. More issues arise when fluents are defined in terms of other fluents whose values are unknown. To overcome these issues we decided to assign specific times to the initiating actions. The times for the terminating actions were determined by our triggers. Here is a solution given by EZCSP to our planning and scheduling problem.\noccurs(start boarding(scott,a),0) end(0) = 5.0 occurs(end boarding(scott,a),1) end(1) = 35.0 occurs(start f lying(a,c,400),2) end(2) = 40.0 occurs(end f lying(a,c),3) end(3) = 190.0 occurs(start re f ueling,4) end(4) = 195.0 occurs(start boarding(ernie,c),5) end(5) = 197.0 occurs(end re f ueling,6) end(6) = 224.16 occurs(end boarding(ernie,c),7) end(7) = 227.0 occurs(start f lying(c,d,600),8) end(8) = 229.0 occurs(end f lying(c,d),9) end(9) = 329.0\nIt is necessary to refuel in city c because there is not enough fuel to travel to city d. A shorter plan can be obtained by allowing concurrent actions. For example, refueling and boarding can start at the same time. The running times and the performance of the solver will be discussed in a longer version of the paper."
    }, {
      "heading" : "5 Conclusions and Future Work",
      "text" : "In this paper, we presented an Action Language-Answer Set Programming based approach to solving planning and scheduling problems in hybrid domains. We used action language H to model a planning and scheduling example and translated the resulting theory into an A-Prolog program. We used a hybrid solver called EZCSP to compute the answer sets of the resulting program. Our approach overcomes the limitations of existing formalisms such as PDDL+. We believe that our approach can be applied to any planning and scheduling problem in hybrid domains.\nIn the future, we would like to model several benchmark examples and compare the performance of EZCSP with existing planners. Some of the planners used for industrysized problems are domain-specific [3]. It will be useful to investigate why some of these planners work really well. There are areas for improvement including the efficiency of solvers, the expressiveness of the input language and so on."
    } ],
    "references" : [ {
      "title" : "Representing constraint satisfaction problems in answer set programming",
      "author" : [ "M. Balduccini" ],
      "venue" : "In ICLP’09 Workshop on Answer Set Programming and Other Computing Paradigms",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2009
    }, {
      "title" : "Reasoning agents in dynamic domains",
      "author" : [ "C. Baral", "M. Gelfond" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2000
    }, {
      "title" : "Integrated planning and scheduling for petroleum refinery operations",
      "author" : [ "M. Boddy", "D. Johnson" ],
      "venue" : "In Proc. of ICAPS Workshop on Integrating Planning into Scheduling (WIPIS),",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2004
    }, {
      "title" : "A New Incarnation of Action Language H",
      "author" : [ "S. Chintabathina", "R. Watson" ],
      "venue" : "In Correct Reasoning - Essays on Logic-Based AI in Honor of Vladimir Lifschitz,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2012
    }, {
      "title" : "Towards Answer Set Programming Based Architectures for Intelligent Agents",
      "author" : [ "Sandeep Chintabathina" ],
      "venue" : "PhD Dissertation. Texas Tech University,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2010
    }, {
      "title" : "Modeling mixed discrete-continuous domains for planning",
      "author" : [ "Maria Fox", "Derek Long" ],
      "venue" : "Journal of Artifical Intelligence Research,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2006
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proc. of ICLP-88,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1988
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1991
    }, {
      "title" : "A causal theory of ramifications and qualifications",
      "author" : [ "N. McCain", "H. Turner" ],
      "venue" : "Proc. of IJCAI-95,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1995
    }, {
      "title" : "Integrating Answer Set Programming and Constraint Logic Programming",
      "author" : [ "V. Mellarkod", "M. Gelfond", "Y. Zhang" ],
      "venue" : "In Proc. of ISAIM’08,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2008
    }, {
      "title" : "Improving Efficiency of Solving Computational Problems with ASP",
      "author" : [ "A. Ricardo Morales" ],
      "venue" : "PhD Dissertation. Texas Tech University,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2010
    }, {
      "title" : "Temporal planning with continuous change",
      "author" : [ "Scott Penberthy", "Daniel Weld" ],
      "venue" : "In Proc. of AAAI-94,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1994
    }, {
      "title" : "Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems",
      "author" : [ "R. Reiter" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2001
    }, {
      "title" : "Solving the frame problem",
      "author" : [ "M. Shanahan" ],
      "venue" : null,
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : "Language H [4] was developed by extending the signature of action language A L [2] with a collection of numbers for representing time, a collection of functions of time, and fluents 1 with non-boolean values including fluents defined by functions of time (process fluents).",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 1,
      "context" : "Language H [4] was developed by extending the signature of action language A L [2] with a collection of numbers for representing time, a collection of functions of time, and fluents 1 with non-boolean values including fluents defined by functions of time (process fluents).",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 8,
      "context" : "The semantics of A L is based on the McCain-Turner equation [9].",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 12,
      "context" : "Prior to H, logic-based formalisms such as Situation Calculus [13] and Event Calculus [14] were extended to reason about process fluents.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 13,
      "context" : "Prior to H, logic-based formalisms such as Situation Calculus [13] and Event Calculus [14] were extended to reason about process fluents.",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 6,
      "context" : "We implement this theory by translating it into an Answer Set Prolog (A-Prolog) program, a class of logic programs under answer set semantics [7,8], and computing answer sets (models) of the resulting program.",
      "startOffset" : 142,
      "endOffset" : 147
    }, {
      "referenceID" : 7,
      "context" : "We implement this theory by translating it into an Answer Set Prolog (A-Prolog) program, a class of logic programs under answer set semantics [7,8], and computing answer sets (models) of the resulting program.",
      "startOffset" : 142,
      "endOffset" : 147
    }, {
      "referenceID" : 4,
      "context" : "In [5] we show that there is a one-to-one correspondence between models of A-Prolog programs and models of our specification.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 3,
      "context" : "In section 2, we revisit the syntax and semantics of H as described in [4].",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 11,
      "context" : "In section 3, we cite a planning and scheduling example from [12] and come up with a theory of H to model it.",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 11,
      "context" : "The example from [12] was run using ZENO, a least commitment planner that supports continuous change.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 5,
      "context" : "A variant of this language, PDDL+ [6] is capable of modeling continuous change through the use of processes and events.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 3,
      "context" : "In this section we revisit the syntax and semantics of H as described in [4].",
      "startOffset" : 73,
      "endOffset" : 76
    }, {
      "referenceID" : 8,
      "context" : "The semantics of language H is based on a slightly modified McCain-Turner equation [9].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 1,
      "context" : "for any state-action pair there is at most one successor state [2]) or non-deterministic (i.",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 11,
      "context" : "In this section we will visit a planning and scheduling example from [12] and demonstrate how to model it in H.",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 11,
      "context" : "If the plane only has 500 gallons of fuel, how can we ensure that Scott and Ernie get to city-d in less than five and a half hours? [12] A solution to this problem requires reasoning about effects of (concurrent) actions in the presence of continuous time.",
      "startOffset" : 132,
      "endOffset" : 136
    }, {
      "referenceID" : 12,
      "context" : "We will use the approach used by Reiter [13] to model durative actions.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 4,
      "context" : "The translation that was provided in [5] is a theoretical translation from statements of H into rules of A-Prolog.",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 0,
      "context" : "In the past few years researchers [1,10] have focused on integrating Answer Set Programming(ASP) and Constraint logic programming(CLP).",
      "startOffset" : 34,
      "endOffset" : 40
    }, {
      "referenceID" : 9,
      "context" : "In the past few years researchers [1,10] have focused on integrating Answer Set Programming(ASP) and Constraint logic programming(CLP).",
      "startOffset" : 34,
      "endOffset" : 40
    }, {
      "referenceID" : 9,
      "context" : "The following such systems are available: ACsolver[10] (and it’s successor Luna[11]); EZCSP 2; and Clingcon3.",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 10,
      "context" : "The following such systems are available: ACsolver[10] (and it’s successor Luna[11]); EZCSP 2; and Clingcon3.",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 2,
      "context" : "Some of the planners used for industrysized problems are domain-specific [3].",
      "startOffset" : 73,
      "endOffset" : 76
    } ],
    "year" : 2013,
    "abstractText" : "In this paper we present an Action Language-Answer Set Programming based approach to solving planning and scheduling problems in hybrid domains domains that exhibit both discrete and continuous behavior. We use action language H to represent the domain and then translate the resulting theory into an A-Prolog program. In this way, we reduce the problem of finding solutions to planning and scheduling problems to computing answer sets of A-Prolog programs. We cite a planning and scheduling example from the literature and show how to model it in H. We show how to translate the resulting H theory into an equivalent A-Prolog program. We compute the answer sets of the resulting program using a hybrid solver called EZCSP which loosely integrates a constraint solver with an answer set solver. The solver allows us reason about constraints over reals and compute solutions to complex planning and scheduling problems. Results have shown that our approach can be applied to any planning and scheduling problem in hybrid domains.",
    "creator" : "LaTeX with hyperref package"
  }
}