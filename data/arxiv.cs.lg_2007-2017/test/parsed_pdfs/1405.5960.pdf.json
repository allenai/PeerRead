{
  "name" : "1405.5960.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "LASS: a simple assignment model with Laplacian smoothing",
    "authors" : [ "Miguel Á. Carreira-Perpiñán", "Weiran Wang" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 5.\n59 60\nv1 [\ncs .L\nG ]\n2 3\nM ay"
    }, {
      "heading" : "1 Introduction",
      "text" : "A major success in machine learning in recent years has been the development of semisupervised learning (SSL) (Chapelle et al., 2006), where we are given labels for only a few of the training points. Many SSL approaches rely on a neighborhood graph constructed on the training data (labeled and unlabeled), typically weighted with similarity values. The Laplacian of this graph is used to construct a quadratic nonnegative function that measures the agreement of possible labelings with the graph structure, and minimizing it given the existing labels has the effect of propagating them over the graph. Laplacian-based formulations are conceptually simple, computationally efficient (since the Laplacian is usually sparse), have a solid foundation in graph theory and linear algebra (Chung, 1997; Doyle and Snell, 1984), and most importantly work very well in practice. The graph Laplacian has been widely exploited in machine learning, computer vision and graphics, and other areas: as mentioned, in semisupervised learning, manifold regularization and graph priors (Zhu et al., 2003; Belkin et al., 2006; Zhou et al., 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.\nWe concern ourselves with assignment problems in a semisupervised learning setting, where we have N items and K categories and we want to find soft assignments of items to categories given some information. This information often takes the form of partial tags or annotations, e.g. for pictures in websites such as Flickr, blog entries, etc. Let us consider a specific example where the items are documents (e.g. papers submitted to this conference) and the categories are keywords. Any given paper will likely be associated to a larger or smaller extent with many keywords, but most authors will tag their papers with only a few of them, usually the most distinctive (although, as we know, there may be other reasons). Thus, few papers will be tagged as “computer science” or “machine learning” because those keywords are perceived as redundant given, say,\n“semisupervised learning”. However, considered in a larger context (e.g. to include biology papers), such keywords would be valuable. Besides, categories may have various correlations that are unknown to us but that affect the assignments. For example, a hierarchical structure implies that “machine learning” belongs to “computer science” (although it does to “applied maths” to some extent as well). In general, we consider categories as sets having various intersection, inclusion and exclusion relations. Section 6 illustrates this in an example. Finally, it is sometimes practical to tag an item as not associated with a certain category, e.g. “this paper is not about regression” or “this patient does not have fever”, particularly if this helps to make it distinctive. In summary, in this type of applications, it is impractical for an item to be fully labeled over all categories, but it is natural for it to be associated or disassociated with a few categories. This can be coded with item-category similarity values that are positive or negative, respectively, with the magnitude indicating the degree of association, and zero meaning indifference or ignorance. We call this source of information, which is specific for each item irrespectively of other items, the wisdom of the expert.\nWe also consider another practical source of information. Usually it is easy to construct a similarity of a given item to other items, at least its nearest neighbors. For example, with documents or images, this could be based on a bag-of-words representation. We would expect similar items to have similar assignment vectors, and this can be captured with an item-item similarity matrix and its graph Laplacian. We call this source of information, which is about an item in the context of other items, the wisdom of the crowd.\nAs an example of the interaction of these two sources of information, imagine the following example where the items are conference papers and the categories are authors. We know that author A1 writes papers about regression (usually with author A2) or bioinformatics (usually with author A3). We are sent for review a paper that is about regression (it contains many words about regression) and, we are tipped, by A1. Can we guess its coauthors, i.e., predict its assignments to all existing authors? Based on the crowd wisdom alone, many authors could have written the paper (those who write regression papers). Based on the expert wisdom alone, A2 or A3 may have cowritten the paper (since each of them has coathored other papers with A1). Given both wisdoms, we might expect a high assignment for A2 (and A1) and low for everybody else.\nIn this paper, we propose a simple model that captures this intuition as a quadratic program. We give some properties of the solution, define an out-of-sample mapping, derive a training algorithm, and illustrate the model with document and image datasets.\nA shorter version of this work appears in a conference paper (Carreira-Perpiñán and Wang, 2014)."
    }, {
      "heading" : "2 The Laplacian assignment (LASS) model",
      "text" : "We consider the following assignment problem. We haveN items andK categories, and we want to determine soft assignments znk of each item n to each category k, where znk ∈ [0, 1] and ∑K\nk=1 znk = 1 for each n = 1, . . . , N . We are given two similarity matrices, suitably defined, and typically sparse: an item-item similarity matrix W, which is an N ×N matrix of affinities wnm ≥ 0 between each pair of items n and m; and an item-category similarity matrix G, which is an N ×K matrix of affinities gnk ∈ R between each pair of item n and category k (negative affinities, i.e., dissimilarities, are allowed in G).\nWe want to assign items to categories optimally as follows:\nmin Z\nλ tr ( ZTLZ ) − tr ( GTZ )\n(1a)\ns.t. Z1K = 1N (1b)\nZ ≥ 0 (1c)\nwhere λ > 0, 1K is a vector of K ones, and L is the N×N graph Laplacian matrix, obtained as L = D−W, where D = diag ( ∑N\nn=1 wnm) is the degree matrix of the weighted graph defined by W. The problem is a quadratic program (QP) over an N × K matrix Z = (z1, . . . , zK), i.e., NK variables1 altogether, where zk, the kth column of Z, contains the assignments of each item to category k. We will call problems of the type (1) Laplacian assignment problems (LASS). Minimizing objective (1a) encourages items to be assigned\n1We will use a boldface vector zn or to mean the nth row of Z (as a column vector), and a boldface vector zk to mean the kth column of Z (likewise for gn or gk). The context and the index (n or k) will determine which is the case. This mild notation abuse will simplify the explanations.\nto categories with which they have high similarity (the linear term in G), while encouraging similar items to have similar assignments (the Laplacian term in L), since\ntr ( ZTLZ ) = 1\n2\nN ∑\nn,m=1\nwnm ‖zn − zm‖2\nwhere zn is the nth row of Z, i.e., the assignments for item n. Although we could absorb λ inside G, we will find it more convenient to fix the scale of each similarity gnk to, say, the interval [−1, 1] (where ±1 mean maximum (dis)similarity and 0 ignorance), and then let λ control the strength of the Laplacian term.\nThe objective function (1a) is separable over categories as\nK ∑\nk=1\nE(zk;L,gk) where E(z;L,g) = λz TLz − gT z\nand the constraints (1b)–(1c) are separable over items as zTn1K = 1N , zn ≥ 0, for n = 1, . . . , N . Thus, the problem (1) is not separable, since all the assignments are coupled with a certain structure."
    }, {
      "heading" : "2.1 Extreme values of λ",
      "text" : "We can determine the solution(s) for the following extreme values of λ:\n• If λ = 0, then the LASS problem is a linear program (LP) and separates over each item n = 1, . . . , N . The solution is znk = δ(k − kmax(n)) where kmax(n) = argmax{gnk, k = 1, . . . ,K}, i.e., each item is assigned to its most similar category. This tells us what the linear term can do by itself. (If the maximum is achieved for more than one category for a given point, then there is an infinite number of “mixed” solutions that correspond to giving any assignment value to those categories, and zero for the rest.)\n• If λ = ∞ or equivalentlyG = 0, then the LASS problem is a quadratic program with an infinite number of solutions of the form zn = zm for each n,m = 1, . . . , N , i.e., all items have the same assignments. This tells us what the Laplacian term can do by itself.\n• If λ → ∞, i.e., for very large λ but still having the linear term, the behavior actually differs from that of G = 0. In the generic case, we expect a unique solution close to Z = 1Nz\nT where z ∈ RK and zk = δ(k − kmax) where kmax = argmaxk (GT1N ), k = 1, . . . ,K, i.e., all items are assigned to the same category, the one having maximum total similarity gTk 1N over all items. (Again, if G\nT1N has more than one maximum values, there is an infinite number of solutions corresponding to mixed assignments.) Indeed, if λ is very large, the Laplacian term dominates and we have that zn = zm = z for every pair of items, approximately. Then the LASS problem becomes the following LP\nmax z\nzT (GT1N )\ns.t. zT1K = 1\nz ≥ 0\nwhose solution allocates all the assignment mass to the category with largest total similarity gTk 1N .\nWith intermediate λ > 0, more interesting solutions appear (particularly when the similarity matrices are sparse), where the item-category similarities are propagated to all points through the item-item similarities."
    }, {
      "heading" : "2.2 Existence and unicity of the solution",
      "text" : "The LASS problem is a convex QP, so general results of convex optimization tell us that all minima are global minima. However, since the Hessian of the objective function is positive semidefinite, there can be multiple minima. The following theorem characterizes the solutions, and its corollary gives a sufficient condition for the minimum to be unique.\nTheorem 2.1. Assume the graph Laplacian L corresponds to a connected graph and let Z∗ ∈ RN×K be a solution (minimizer) of the LASS problem (1). Then, any other solution has the form Z∗ + 1Np\nT where p ∈ RK satisfies the conditions:\npT1K = 0, p T (GT1N) = 0, Z ∗ + 1Np T ≥ 0. (2)\nIn particular, for each k = 1, . . . ,K for which ∃n ∈ {1, . . . , N}: z∗nk = 0, then pk ≥ 0.\nProof. Call q(Z) = λ tr ( ZTLZ ) −tr ( GTZ )\nthe objective function of the LASS problem. Since q is continuous and the feasible set of the problem is bounded and closed in RN×K , q achieves a minimum value in the feasible set, hence at least one solution exists, which makes the theorem statement well defined. We call this solution Z∗. Now let us show that q(Z∗ +P) ≥ q(Z∗) for any other feasible point Z∗ +P, with P ∈ RN×K . Simple algebra shows that\nq(Z∗ +P) = q(Z∗) + tr ( PT (2λLZ∗ −G) ) + λ tr ( PTLP ) . (3)\nThe last term is nonnegative because L is positive semidefinite. The penultimate term is also nonnegative. To see this, write the KKT conditions for the LASS problem with Lagrange multipliers π ∈ RN and M ∈ RN×K = (µnk) for the equality and inequality constraints, respectively:\n2λLZ∗ −G− π1TK −M = 0 Z∗1K = 1N\nZ∗ ≥ 0 M ≥ 0\nµnkz ∗ nk = 0, n = 1, . . . , N, k = 1, . . . ,K.\nThus, since Z∗ +P is feasible, (Z∗ +P)1K = 1N ⇒ P1K = 0, and Z∗ +P ≥ 0 ⇒ pnk ≥ 0 where z∗nk = 0 (i.e., the active inequalities). Then, from the first KKT equation, we have for the penultimate term:\ntr ( PT (2λLZ∗ −G) ) = tr ( PTπ1TK +P TM ) = tr ( 1TKP T π +PTM ) =\nN,K ∑\nn,k=1\npnkµnk = ∑\nactive n,k\npnkµnk ≥ 0\nbecause µnk ≥ 0 for all n, k, µnk = 0 for the inactive inequalities, and pnk ≥ 0 for the active inequalities. Hence, the last two terms in (3) are nonnegative, so q(Z∗ +P) ≥ q(Z∗) and Z∗ is a global minimizer.\nNow assume that q(Z∗ + P) = q(Z∗). Then the last two terms in (3) must both be zero. Recall that if the graph Laplacian L corresponds to a connected graph, it has a single null eigenvalue with an eigenvector consisting of all ones. From tr ( PTLP ) = 0 it follows that P = 1Np T for some p ∈ RK . Since Z∗ + P is feasible, P1K = 0 ⇒ pT1K = 0, and Z∗ + 1NpT ≥ 0. From the penultimate term, 0 = tr ( PT (2λLZ∗ −G) ) = tr (\n2λp1TNLZ ∗ − p1TNG\n)\n⇒ pT (GT1N ) = 0. Finally, from Z∗ + 1Np\nT ≥ 0 it follows that z∗nk + pnk ≥ 0 for each n = 1, . . . , N and k = 1, . . . ,K, so if ∃n, k: z∗nk = 0 (i.e., if any of the inequalities involving k are active), then pk ≥ 0.\nCorollary 2.2. Assume the graph Laplacian L corresponds to a connected graph and let Z∗ ∈ RN×K be a solution of the LASS problem (1). If maxk (minn (z ∗ nk)) = 0 then the solution Z ∗ is unique.\nProof. We have maxk (minn (z ∗ nk)) = 0, so for each k, ∃n: z∗nk = 0. From theorem 2.1, any other solution Z∗ + 1Np T must have pk ≥ 0 for k = 1, . . . ,K, and pT1K = 0. Hence p = 0.\nRemark 2.3. If the graph Laplacian L corresponds to a graph with multiple connected components, then the LASS problem separates into a problem for each component, and the previous theorem holds in each component. Computationally, it is also more efficient to solve each problem separately.\nRemark 2.4. The set (2) of solutions to a LASS problem is a convex polytope.\nRemark 2.5. The condition of corollary 2.2 means that each category has at least one item with a zero assignment to it. In practice, we can expect this condition to hold, and therefore the solution to be unique, if the categories are sufficiently distinctive and λ is small enough. Equivalently, nonunique solutions arise if some categories are a catch-all for the entire dataset. Theoretically, this should always be possible if λ is large\nenough, particularly if there are many categories. However, in practice we have never observed nonunique solutions, because for large λ the algorithm is attracted towards a solution where one category dominates, so the vector p can only have one negative component, which makes (2) impossible unless G takes a special value, such as G = 0. Thus, the symmetric situation where all assignments are possible for λ → ∞ does not seem to occur in practice.\nRemark 2.6. Practically, one can always make the solution unique by replacing L with L+ ǫIN where ǫ > 0 is a small value, since this makes the objective strongly convex. (This has the equivalent meaning of adding a penalty ǫ‖Z‖2F to it, which has the effect of biasing the assignment vector zn of each item towards the simplex barycenter, i.e., uniform assignments.) However, as noted before, nonunique solutions appear to be rare with practical data, so this does not seem necessary."
    }, {
      "heading" : "2.3 Particular cases",
      "text" : "Theorem 2.7. Assume the graph Laplacian L corresponds to a connected graph and let Z ∈ RN×K be a solution of the LASS problem (1). Then:\n1. If gn = 0 then zn = ZTwn 1T N wn = ∑N m=1 wnm∑ N m′=1 w nm′ zm, µn = 0 and πn = 0.\n2. If gk ≤ 0 then zk = 0, µn = −gk and πn = 0.\nProof. Both statements follow from substituting the values in the KKT conditions (4). Conditions (4b)– (4e) are trivially satisfied, so we prove condition (4a) only. For statement 1, we can write row n of L as ln = −wn + (1TNwn)en, where wn is row n of W and en is a vector with entries enm = δ(n −m), and we write all row vectors as column vectors. Then we can write row n (in column form) of condition (4a) as:\n0 = 2λZT ln − gn − πn1K − µn = 2λ(−ZTwn + (1TNwn)zn) ⇒ zn = ZTwn\n1TNwn .\nFor statement 2, we can write column k of condition (4a) as 0 = 2λLzk − gk − π − µk ⇒ µ = −gk.\nRemark 2.8. The meaning of th. 2.7 is as follows. (1) An item for which no similarity to any category is given (i.e., no expert information) receives as assignment the average of its neighbors. This corresponds to the SSL prediction. (2) A category for which no item has a positive similarity receives no assignments."
    }, {
      "heading" : "2.4 Lagrange multipliers for a solution",
      "text" : "Given a feasible point ZN×K in parameter space, we may want to test whether it is a solution of the LASS problem. For a QP, the KKT conditions are necessary and sufficient for a solution (Nocedal and Wright, 2006). For our problem, and written in matrix form, the KKT conditions are:\n2λLZ−G− π1TK −M = 0 (4a) Z1K = 1N (4b)\nZ ≥ 0 (4c) M ≥ 0 (4d)\nM ◦ Z = 0 (4e)\nwhere ◦ means elementwise product, and π and M are the Lagrange multipliers associated with the point Z for the equality and inequality constraints, respectively. We need to compute π and M. Given Z, the KKT system (4) has 2NK linear equations for N +NK unknowns, and its solution is unique if Z is feasible, as we will see. To obtain it, we multiply (4a) times 1K on the right and obtain π as a function of M:\nπ = 1\nK (2λLZ−G−M)1K = −\n1\nK (G+M)1K . (5)\nSubstituting it in (4a) gives, together with (4e):\nM = Q+ 1\nK M1K1\nT K\nM ◦ Z = 0\nwhere Q = 2λLZ−G+ 1 K G1K1 T K . This is a linear system of 2NK equations for the NK unknowns in M. It separates over each row of M, n = 1, . . . , N , in a system of the form\nµ− 1 K (1TKµ)1K = q\ndiag (µ) diag (z) = 0 ⇐⇒\n(\nIK − 1K1TK1K diag (z)\n)\nµ =\n(\nq 0\n)\nwhere µ, z and q correspond to the nth row of M, Z and Q, respectively, written as K-dimensional column vectors (we omit the index n). This is a linear system of 2K equations for K unknowns, which we solve by multiplying on the left times the transpose of the coefficient matrix:\n(\nΨ− 1 K 1K1 T K\n)\nµ = q− 1 K (1TKq)1K Ψ = diag (z) 2 + IK .\nFinally, using the matrix inversion lemma\n(A+ αuuT )−1 = A−1 − αA −1uuTA−1\n1 + αuTA−1u\nwe obtain the solution for µ:\nµ = Ψ−1q− ( 1TKq− 1TKΨ−1q K − 1TKΨ−11K ) Ψ−11K (6)\nwhose transpose gives row n of M. Note the formula is well defined because ψkk = z 2 k + 1 ≥ 0 and 1TKΨ −11K = ∑K k=1 1\n1+z2 k < K since zk ≥ 0 for k = 1, . . . ,K and zk > 0 for at least one k ∈ {1, . . . ,K}, since Z is feasible.\nFor the case λ = 0, one can verify that the above formulas simplify as follows (again, we give z, µ and π for item n but omitting the index n):\nz = (zk), zk = δ(k − kmax) µ = gmax1K − g π = −gmax\nwhere g represents the nth row of G, kmax = argmax{gk, k = 1, . . . ,K} and gmax = gkmax ."
    }, {
      "heading" : "3 A simple, efficient algorithm to solve the QP",
      "text" : "It is possible to solve problem (1) in different ways, but one must be careful in designing an effective algorithm because the number of variables and the number of constraints grows proportionally to the number of data points, and can then be very large. We describe here one algorithm that is very simple, has guaranteed convergence without line searches, and takes advantage of the structure of the problem and the sparsity of L. It is based on the alternating direction method of multipliers (ADMM), combined with a direct linear solver using the Schur’s complement and caching the Cholesky factorization of L."
    }, {
      "heading" : "3.1 QP solution using ADMM",
      "text" : "We briefly review how to solve a QP using the alternating direction method of multipliers (ADMM), following (Boyd et al., 2011). Consider the QP\nmin x\n1 2 xTPx+ qTx (7)\ns.t. Ax = b, x ≥ 0 (8)\nover x ∈ RD, where P is positive (semi)definite. In ADMM, we introduce new variables z ∈ RD so that we replace the inequalities with an indicator function g(z), which is zero in the nonnegative orthant z ≥ 0 and ∞ otherwise. Then we write the problem as\nmin x f(x) + g(z) (9)\ns.t. x = z (10)\nwhere\nf(x) = 1\n2 xTPx+ qTx, dom(f) = {x ∈ RD: Ax = b}\nis the original objective with its domain restricted to the equality constraint. The augmented Lagrangian is\nL(x, z,y; ρ) = f(x) + g(z) + yT (x− z) + ρ 2 ‖x− z‖2 (11)\nand the ADMM iteration has the form:\nx ← argmin x L(x, z,y; ρ) z ← argmin z L(x, z,y; ρ) y ← y + ρ(x− z)\nwhere y is the dual variable (the Lagrange multiplier estimates for the constraint x = z), and the updates are applied in order and modify the variables immediately. Here, we use the scaled form of the ADMM iteration, which is simpler. It is obtained by combining the linear and quadratic terms in x− z and using a scaled dual variable u = y/ρ:\nx ← argmin x\n( f(x) + ρ\n2 ‖x− z+ u‖2\n)\nz ← argmin z\n( g(z) + ρ\n2 ‖x− z+ u‖2\n)\nu ← u+ x− z.\nSince g(x) is the indicator function for the nonnegative orthant, the solution of the z-update is simply to threshold each entry in x+ u by taking is nonnegative part. Finally, the ADMM iteration is:\nx ← argmin x\n( f(x) + ρ\n2 ‖x− z+ u‖2\n)\n(12)\nz ← (x+ u)+ (13) u ← u+ x− z (14)\nwhere the updates are applied in order and modify the variables immediately, and (t)+ = max(t, 0) applies elementwise, and ‖·‖ is the Euclidean norm. The penalty parameter ρ > 0 is set by the user, and z = (z1, . . . , zD)\nT are the Lagrange multiplier estimates for the inequalities. The x-update is an equalityconstrained QP with KKT conditions\n(\nP+ ρI AT\nA 0\n)(\nx\nν\n)\n=\n(\n−q+ ρ(z− u) b\n)\n. (15)\nSolving this linear system gives the optimal x and ν (the Lagrange multipliers for the equality constraint). The ADMM iteration consists of very simple updates to the relevant variables, but its success crucially relies in being able to solve the x-update efficiently. Given the structure of our problem, it is convenient to use a direct solution using Schur’s complement, that is:\n(A(P+ ρI)−1AT )ν = A(P+ ρI)−1(−q+ ρ(z− u)) + b (16a) (P+ ρI)−1x = −ATν − q+ ρ(z− u). (16b)\nEq. (16a) results from left-multiplying the first equation in (15) by A(P + ρI)−1 and using the second equation in (15) to eliminate x. Eq. (16b) results from substituting ν back in the first equation in (15) and solving it for x.\nThus, the ADMM iteration consists of solving a linear system on the primal variables x, applying a thresholding to get z, and an addition to get u. Convergence of the ADMM iteration (12) to the global minimum of problem (7) in value and to a feasible point is guaranteed for any ρ > 0."
    }, {
      "heading" : "3.2 Application to our QP",
      "text" : "We now write the ADMM updates for our QP (1), where we identify:\nP = 2λdiag (L, . . . ,L) of NK ×NK q = − vec (G) of NK × 1 A = (IN , . . . , IN ) of N ×NK b = 1N of N × 1\nwhere vec (·) concatenates the columns of its argument into a single column vector. Given the structure of these matrices, the solution of the KKT system (15) by using Schur’s complement (16) simplifies considerably. The basic reasons are that (1) the matrix P is block-diagonal with K identical copies of the graph Laplacian L, which is itself usually sparse; and (2) the especially simple form of the equality constraint matrix A. Thus, even though the x-update involves solving a large linear system of NK equations, it is equivalent to solving K systems of N equations where the coefficient matrix is the same for each system and besides is constant and sparse, equal to 2λL + ρI. In turn, these linear systems may be solved efficiently in one of the two following ways: (1) preferably, by caching the Cholesky factorization of this matrix (using a good permutation to reduce fill-in), if it does not add so much fill that it can be stored; or (2) by using an iterative linear solver such as conjugate gradients, initialized with a warm start, preconditioned, and exiting it before convergence, so as to carry out faster, inexact x-updates.\nThe final algorithm is as follows, with its variables written in matrix form. The input are the affinity matrices GN×K and WN×N , from which we construct the graph Laplacian LN×N . We then choose ρ > 0 and set\nh = − 1 K G1K + ρ K 1N RR T = 2λL+ ρI.\nThe Cholesky factor R is used to solve linear system (17b). We then iterate, in order, the following updates until convergence:\nν ← ρ K (Y −U)1K − h (17a)\nZ ← (2λL+ ρI)−1(ρ(Y −U) +G− ν1TK) (17b) Y ← (Z+U)+ (17c) U ← U+ Z−Y (17d)\nwhere ZN×K are the primal variables, YN×K the auxiliary variables, UN×K the Lagrange multiplier estimates for Y, and νN×1 the Lagrange multipliers for the equality constraints. The solution for the linear system in the Z-update may be obtained by using two triangular backsolves if using the Cholesky factor of 2λL+ ρI, or using an iterative method such as conjugate gradients if the Cholesky factor is not available.\nThe iteration (17) is very simple to implement. It requires no line searches and has only one user parameter, the penalty parameter. The algorithm converges for any positive value of the penalty parameter, but this value does affect the convergence rate."
    }, {
      "heading" : "3.3 Remarks",
      "text" : "Theorem 3.1. At each iterate in the algorithm updates (17), Z1K = 1N , U ≤ 0, Y ≥ 0 and Y ◦U = 0.\nProof. For Z, substituting eq. (17a) into (17b):\nZ1K = (2λL+ρI) −1(ρ(Y−U)+G−ν1TK)1K = (2λL+ρI)−1(ρ(Y−U)1K+G1K−Kν = (2λL+ρI)−1ρ1N = 1N\nwhere the last step results from (2λL + ρI)1N = 2λL1N + ρ1N = ρ1N . For U, from eqs. (17c)–(17d) we have that U ← U + Z − (U + Z)+ = (U + Z)− ≤ 0. For Y, Y ≥ 0 follows from Y = (Z +U)+ in (17c). Finally, Y ◦U = 0 follows from Y = (Z+U)+ and U = (U+ Z)−.\nTheorem 3.2. Upon convergence of algorithm (17), Z is a solution with Lagrange multipliers π = −ν and M = −ρU.\nProof. Let us compare the KKT conditions (4) with the algorithm updates (17) upon convergence, i.e., at a fixed point of the update equations. From th. 3.1 we know that Z1K = 1N and U ≤ 0 ⇒ M = −ρU ≥ 0, which are KKT conditions (4b) and (4d). From eq. (17d) we must have Z = Y, so from eq. (17c) we have Z = (Z + U)+ ≥ 0, which is KKT condition (4c). From eqs. (17c)–(17d) we have Z = (Z + U)+ and U = (Z+U)−, therefore U ◦Z = M ◦Z = 0, which is KKT condition (4e). Finally, from eq. (17b) we have:\n(2λL+ ρI)Z = ρ(Y −U) +G− ν1TK ⇒ 2λLZ−G+ ρU+ ν1TK = 2λLZ −G− π1TK −M = 0\nwhich matches KKT condition (4a). The change of sign in the multipliers between the algorithm and the KKT conditions is due to the sign choice in the Lagrangian (adding in eq. (11), subtracting in (4)).\nRemark 3.3. In practice, the algorithm is stopped before convergence, and Z, π = −ν and M = −ρU are estimates for a solution and its Lagrange multipliers, respectively. The estimate Z may not be feasible, in particular the values znk need not be in [0, 1], since this is only guaranteed upon convergence. If needed, a feasible point may be obtained by projecting each row of Z onto the simplex (see section 4).\nRemark 3.4. If G = 0 (or λ → ∞) one solution is given by Z = 1 K 1N1 T K , for which the Lagrange multipliers are M = 0 and π = 0, thus the inequality constraints are inactive and the equality constraints are weakly active. Indeed, that Z value is also a solution of the unconstrained problem."
    }, {
      "heading" : "3.4 Computational complexity",
      "text" : "Each step in (17) is O(NK) except for the linear system solution in (17b). If L is sparse, using the Cholesky factor makes this step O(NK) as well, and adds a one-time setup cost of computing the Cholesky factor (which is also linear in N with sufficiently sparse matrices). Thus, each iteration of the algorithm is cheap. In practice, for good values of ρ, the algorithm quickly approaches the solution in the first iterations and then converges slowly, as is known with ADMM algorithms in general. However, since each iteration is so cheap, we can run a large number of them if high accuracy is needed. As a sample runtime, for a problem with N = 10 000 items and K = 10 categories (i.e., Z has 105 parameters) and using a 100-nearest-neighbor graph, the Cholesky factorization takes 0.5 s and each iteration takes 0.15 s in a PC.\nFor large-scale problems, the slow convergence becomes more problematic, and it is possible that the Cholesky factor may create too much fill even with a good preordering. One can use instead an iterative linear solver, such as preconditioned conjugate gradients. Scaling up the training is a topic for future research."
    }, {
      "heading" : "3.5 Initialization",
      "text" : "If the LASS problem is itself a subproblem in a larger problem (as in the Laplacian K-modes clustering algorithm; Wang and Carreira-Perpiñán, 2014b), one should warm-start the iteration of eq. (17) from the values ofY andU in the previous outer-loop iteration. Otherwise, we can simply initializeY = U = 0, which (substituting in eqs. (17a)–(17b)) gives Z0 = (2λL+ρI) −1(G− 1 K G1K1 T K)+ 1 K 1N1 T K (where G− 1KG1K1TK is the matrix G with centered rows, and 1 K 1N1 T K is the simplex barycenter). This initialization is closely related to the projection on the simplex of the unconstrained optimum of the LASS problem, as we show next. Consider first the unconstrained minimization\nmin Z\nf(Z) = λ tr ( ZTLZ ) − tr ( GTZ ) .\nThis problem is in fact unbounded unless GT1 = 0, because taking Z = 1vT for any v ∈ RK , v 6= 0, since L1 = 0, we have f(1vT ) = (GT1)Tv, which can be made arbitrarily negative. We could still try to define a Z from the gradient ∇f(Z)T = 2λLZ −G, but this involves a linear system on L, whose computational cost defeats the purpose of the initialization. Instead, we can consider the unconstrained minimization\nmin Z\nρ 2 tr ( ZTZ ) + λ tr ( ZTLZ ) − tr ( GTZ )\nfor ρ > 0, which is strongly convex and has a unique minimum Z∗ = (2λL+ ρI)−1G, which we can compute cheaply if we reuse the Cholesky factor for 2λL+ρI. Now, we can write the initialization Z0 (for Y = U = 0) in terms of Z∗ as Z0 = Z ∗ − ( 1 K Z∗1K)1 T K + 1 K 1N1 T K , which means that each row vector of Z\n∗ is translated along the direction 1K . Since this direction is orthogonal to the simplex, both Z\n∗ and Z0 have the same projection on it.\nFinally, note that if ρ is large, then Z0 ≈ 1K1N1TK and Z∗ ≈ 0, both of which project onto the simplex barycenter, independently of the problem data."
    }, {
      "heading" : "3.6 Stopping criterion",
      "text" : "We stop when ‖Z(τ+∆) − Z(τ)‖1 < tol, i.e., when the change in absolute terms in Z in the last ∆ iterations falls below a set tolerance tol (e.g. 10−5). Using an absolute criterion here is equivalent to using a relative one, since ‖zn‖1 = 1, n = 1, . . . , N . Since our iterations are so cheap, evaluating ∥ ∥Z(τ+∆) − Z(τ) ∥ ∥ 1 takes a runtime comparable to that of the updates in (17) (except for the Z-update, possibly), so testing the stopping criterion every ∆ = 10–100 iterations saves around 10% runtime.\nAnother possible stopping criterion is to test whether the KKT conditions (4) are satisfied up to a given tolerance, using the Lagrange multipliers’ estimates provided by the algorithm at each iterate. Each iterate always satisfies (4b) and (4d), so we only need to check (4a), (4c) and (4e) (if the iterate is interior to the inequalities it will also satisfy (4c) and (4e)). Still, it is faster to check for changes in Z.\nSince the iterates Z in the algorithm need not be feasible, they may be slightly infeasible once the stopping criterion is satisfied. If desired, a feasible Z can be obtained by projecting each assignment vector zn onto the simplex (see section 4)."
    }, {
      "heading" : "3.7 Optimal penalty parameter ρ",
      "text" : "The speed at which ADMM converges depends on the quadratic penalty parameter ρ (Boyd et al., 2011). We illustrate this with the “2 moons” dataset in fig. 1 (N = 4 000 points, K = 2 categories, 5-nearestneighbor graph, λ = 1), where we set positive similarity values for one point in each cluster, resulting in each cluster being assigned to a different category, as expected. The problem has 8 000 parameters and we ran 104 iterations, which took 11 s. Little work exists on how to select ρ so as to achieve fastest convergence. Recently, for QPs, Ghadimi et al. (2013) suggest to use ρ∗ = 2λ √ σminσmax where σmin and σmax are the smallest (nonzero) and largest eigenvalue of the Laplacian. In fig. 1, ρ∗ ≈ 0.2, and we show the relative error ‖Z− Zopt‖F / ‖Zopt‖F vs number of iterations for different ρ/ρ∗ (initial Z = 0, with relative error 1). Asymptotically, the convergence is linear; a model ǫk = r\nkǫ0 gives r ≈ 0.9977 for ρ∗. While, in the long term, values close to ρ∗ work best, in the short term, smaller values are able to achieve an acceptably low relative error (≈ 10−3) in just a few iterations, so an adaptive ρ would be best overall."
    }, {
      "heading" : "3.8 Matlab code",
      "text" : "The following Matlab code implements the algorithm, assuming a direct solution of the Z-update linear system.\nfunction [Z,Y,U,nu] = lass(L,l,G,r,Y,U,maxit,tol)\n[N,K] = size(G); LI = 2*l*L+r*speye(N,N); h = (-sum(G,2)+r)/K; Zold = zeros(N,K); for i=1:maxit\nnu = (r/K)*sum(Y-U,2) - h; Z = LI \\ bsxfun(@minus,r*(Y-U)+G,nu);\nY = max(Z+U,0); U = U + Z - Y; if max(abs(Z(:)-Zold(:))) < tol break; end; Zold = Z;\nend"
    }, {
      "heading" : "4 Out-of-sample mapping",
      "text" : "Having trained the system, that is, having found the optimal assignments Z for the training set items, we are given a new, test item x (for example, a new point x ∈ RD), along with its item-item and item-category similarities w = (wn), n = 1, . . . , N and g = (gk), k = 1, . . . ,K, respectively, and we wish to find its assignment to each category. We follow the reasoning of Carreira-Perpiñán and Lu (2007) to derive an outof-sample mapping. While one could train again the whole system augmented with x, this would be very time-consuming, and the assignments of all points would change (although very slightly). A more practical and still natural way to define an out-of-sample mapping z(x) is to solve a problem of the form (1) with a dataset consisting of the original training set augmented with x, but keeping Z fixed to the values obtained during training. Hence, the only free parameter is the assignment vector z for the new point x. After dropping constant terms, the optimization problem (1) reduces to the following quadratic program over K variables:\nmin z\n‖z− (z̄ + γg)‖2 (18a)\ns.t. zT1K = 1 (18b)\nz ≥ 0 (18c)\nwhere γ = 1/2λ(1TNw) = 1/2λ ∑N n=1 wn and\nz̄ = ZTw\n1TNw =\nN ∑\nn=1\nwn ∑N\nn′=1 wn′ zn\nis a weighted average of the training points’ assignments, and so z̄+ γg is itself an average between this and the item-category affinities. Thus, the solution is the Euclidean projection Π(z̄ + γg) of the K-dimensional\nvector z̄+γg onto the probability simplex. This can be efficiently computed, in a finite number of steps, with a simple O(K logK) algorithm (Duchi et al., 2008; Wang and Carreira-Perpiñán, 2014a). Computationally, assuming w is sparse, the most expensive step is finding the neighbors to construct w. With large N , one should use some form of hashing (Shakhnarovich et al., 2006) to retrieve approximate neighbors quickly.\nThe out-of-sample prediction for a point in the training set does not generally equal the z value it received during training (although it does not differ much from it either). That is, z(xn) 6= zn, where z(xn) uses the training data w = Wn· and g = Gn· for xn. This is also true of semisupervised learning, and it simply reflects the fact that the out-of-sample mapping smoothes, rather than interpolates, the training data.\nGiven a solution Z of the LASS training problem, the out-of-sample mapping is uniquely defined, because the problem (18) is strongly convex. However, as described in section 2.2, in particular settings the solution of the LASS training problem may not be unique, and a natural question is: what is the relation between the out-of-sample mappings for two different solutions? From th. 2.1, the solutions have the form Z+ 1Np T where Z is any particular solution and p ∈ RK satisfies pT1K = 0, pT (GT1N) = 0 and Z + 1NpT ≥ 0. Then the out-of-sample mapping for a p-solution has the form\nzp(x) = Π\n(\n(Z+ 1Np T )Tw\n1TNw + γg\n)\n= Π(v(x) + p) v(x) = ZTw\n1TNw + γg\nwhere z0(x) = Π(v(x)) is the out-of-sample mapping for the base solution Z. If p was parallel to the vector 1K then the out-of-sample mappings for different solutions but actually coincide, but in fact p\nT1K = 0, so the out-of-sample mappings for different solutions correspond to sliding z0(x) along the simplex by vector p (which must respect the remaining conditions above, of course).\nAs a function of λ, the out-of-sample mapping takes the following extreme values:\n• If λ = 0 or w = 0, zk = δ(k−kmax) where kmax = argmax{gk, k = 1, . . . ,K}, i.e., the item is assigned to its most similar similar category (or any mixture thereof in case of ties).\n• If λ = ∞ or g = 0, z = z̄, independently of g. This corresponds to the SSL out-of-sample mapping.\nIn between these, the out-of-sample mapping as a function of λ is a piecewise linear path in the simplex, which represents the tradeoff between the crowd (w) and expert (g) wisdoms. This path is quite different from the simple average of z̄ and g (which need not even be feasible), and may produce exact 0s or 1s for some entries.\nThe LASS out-of-sample mapping offers an extra degree of flexibility to the user, which may be used on a case-by-case basis for each test item. The user has the prerogative to set λ to favor more or less the expert vs the crowd opinion, and in fact to explore the entire continuum for λ ∈ [0,∞). The user can also explore what-if scenarios by changing g itself, given the vector w (e.g. how would the assignment vector look like if we think that test item x belongs to category k but not to category k′?). These computations are all relatively efficient because the bottleneck, which is the O(N) computation of z̄, is done once only.\nNote that the out-of-sample mapping is nonlinear and nonparametric, and it maps an input x (given its affinity information) onto a valid assignment vector in the probability simplex. Hence, LASS can also be considered as learning nonparametric conditional distributions over the categories, given partial supervision."
    }, {
      "heading" : "5 Related work",
      "text" : ""
    }, {
      "heading" : "5.1 Semisupervised learning with a Laplacian penalty (SSL)",
      "text" : "In semisupervised learning (SSL) with a Laplacian penalty (Zhu et al., 2003), the basic idea is that we are given an affinity matrix W and corresponding graph Laplacian L = D−W on N items, and the labels for a subset of the items. Then, the labels for the remaining, unlabeled items are such that they minimize the Laplacian penalty, or equivalently they are the smoothest function on the graph that satisfies the given labels (“harmonic” function). Call Zu of Nu ×K and Zl of Nl ×K the matrices of labels for the unlabeled and labeled items, respectively, where N = Nl +Nu, and Z T = (ZTu Z T l ). To obtain Zu we minimize tr ( ZTLZ )\nover Zu, with fixed Zl:\nmin Zu\ntr ( ZTLZ )\n= min Zu tr\n(\n(\nZu Zl\n)T (\nLu Lul LTul Ll\n)(\nZu Zl\n)\n)\n= min Zu\ntr ( ZTuLuZu + 2Z T l L T ulZu ) + constant\n⇒ Zu = −L−1u LulZl = L−1u WulZl. (19)\nThus, computationally the solution involves a sparse linear system of Nu ×Nu. An out-of-sample mapping for a new test item x with affinity vector w wrt the the training set can be derived by SSL again, taking Zl of N × K as all the trained labels (given and predicted) and Zu = zT as the free label. This gives a closed-form expression\nz(x) =\nN ∑\nn=1\nwn ∑N\nn′=1 wn′ zn (20)\nwhich is the average of the labels of x’s neighbors, making clear the smoothing behavior of the Laplacian. SSL with a Laplacian penalty is very effective in problems where there are very few labels, i.e., Nu ≪ Nl, but the graph structure is highly predictive of each item’s labels. Essentially, the given labels are propagated throughout the graph.\nIn our setting, the labels are the item-category assignments znk, and we have the following result.\nTheorem 5.1. In problem (19), if Zl ≥ 0 and Zl1Nl = 1K then Zu ≥ 0 and Zu1Nu = 1K .\nProof. Since L = D−W we have\n0 = L1Nu+Nl =\n(\nLu Lul LTul Ll\n)(\n1Nu 1Nl\n)\n=\n(\nLu1Nu + Lul1Nl LTul1Nu + Ll1Nl\n)\n⇒ −L−1u Lul1Nl = 1Nu .\nHence Zu1K = −L−1u LulZl1K = −L−1u Lul1Nl = 1Nu . That Zu ≥ 0 follows from the maximum principle for harmonic functions (Doyle and Snell, 1984): each of the unknowns must lie between the minimum and maximum label values, i.e., in [0, 1]. (Strictly, they will lie in (0, 1) or be all equal to a constant.)\nThus, in the special case where the given labels are valid assignments (nonnegative with unit sum), the predicted labels will also be valid assignments, and we need not subject the problem explicitly to simplex constraints, which simplifies it computationally. This occurs in the standard semisupervised classification setting where each item belongs to only one category and we use the zn vectors to implement a 1-of-K coding (e.g. as used for supervised clustering in Grady, 2006). However, in general SSL does not produce valid assignments, e.g. if the given labels are not valid assignments, or in other widely used variations of SSL, such as using class mass normalization (Zhu et al., 2003), or using the normalized graph Laplacian instead of the unnormalized one, or using label penalties (Zhou et al., 2004). In the latter case (also similar to the “dongle” variation of SSL; Zhu et al., 2003), one minimizes the Laplacian penalty plus a term equal to the squared distance of the labeled points (considered free parameters as well) to the labels Zl provided. Thus, this penalizes the labeled points from deviating from their intended labels, rather than forcing them to equal them. This was extended by Subramanya and Bilmes (2011) (replacing squared losses with Kullback-Leibler divergences and adding an additional entropy term) to learning probability distributions, i.e., where the labels Zl are entire distributions over the K classes, with each item-class probability specified exactly. All these approaches rely on the following: they use provided, specific label values Zl as targets to be (ideally) met by the parameters.\nRelation with LASS LASS and SSL are similar in that (1) L plays the same role, i.e., to propagate label information in a smooth way according to the item-item graph; and (2) both rely on some given data to learn Z: the similarity matrix G in LASS and the given labels Zl in SSL. LASS and SSL differ as follows. (1) The use of the simplex constraints, necessary to ensure valid assignments, which also means all the assignment values in LASS are interdependent, unlike in the classical SSL, where the prediction for each category can be solved independently. (2) A fundamental difference is in the supervision provided. If in LASS we were given\nactual labels Zl for some of the items, we would simply use them just as in SSL, and the LASS problem with Zl having given assignments would be:\nmin Zu\nλ tr ( ZTuLuZu + 2Z T l L T ulZu ) − tr ( GTuZu )\n(21a)\ns.t. Zu1K = 1Nu (21b)\nZu ≥ 0. (21c)\nIt is clear that setting G = 0 there gives the SSL problem (19) if Zl contains valid assignments (so the constraints are redundant, from th. 5.1). Thus, SSL is a particular case of LASS, not a different way of encoding the same input data. However, the G term provides soft, partial “labels”, and this information differs from (hard) labels Zl. Indeed, when the label to be learned for each item is an assignment vector, the concept of “labeling” breaks down, for two reasons. First, if the number of categories K is not very small and an item n has nonzero assignments to multiple categories, in practice it is hard for a user to have to give a value (or tag) for every single relevant category. Giving partial information is much easier, by simply setting gnk = 1 for the most relevant categories, possibly setting gnk = −1 for a few categories, and setting gnk = 0 for the rest (we stick to ±1 and 0 similarities for simplicity). Second, because the assignment values are constrained to be in the simplex, we cannot give actual values for individual entries (unless we give the entire assignment vector). For example, setting an entry to 1 implicitly forces the other entries to 0. In summary, the semantics of the item-category similarities in LASS is that, where nonzero, they encourage the corresponding assignment towards relatively high or low values (for positive and negative similarities, respectively), and where zero, they reflect ignorance and are non-committing, something which is close to a user’s intuition, but generally difficult to achieve by setting assignment values directly.\nNot being able to commit to specific assignment values, especially where gnk = 0, also implies that it is not possible to transform meaningfully a given item-category sparse similarity matrix G into an assignment vector. Given a sparse matrix G, if we insist in setting full assignments for each item n having a nonzero vector gn (so we can use these with SSL), perhaps the best one can do is to follow this labeling procedure: for each k, set znk = 1, ǫ or 0 if gnk = 1, 0 or −1, respectively, and normalize zn (where 1 ≫ ǫ ≥ 0 is a smoothing user parameter). This forces a zero assignment for each negative-similarity category, and distributes the unit assignment mass over the remaining categories. Obviously, this likely forces many znk to wrong values and, as we show in the experiments, works poorly. (Another approach would be to set only the znk entries for which gnk 6= 0 and leave the others free (subject to the constraints (1b)–(1c)), but this is essentially with LASS does.)\nThe difference between SSL and LASS is clearly seen in the out-of-sample mapping. In SSL, the information provided for a test item is just the vector w of similarities to other items, and the SSL out-of-sample mapping coincides with z̄ in the LASS out-of-sample mapping, i.e., the average of its neighbors’ assignments. With LASS, in addition to w we also give the vector g of similarities to categories. If g = 0, the predictions of LASS and SSL coincide. Otherwise, LASS trades off both w and g. This is particularly important when w is not very informative, e.g. if it has many nonzero entries of similar magnitude, or all entries are very small (an outlying or “new” item).\nA further difference between SSL and LASS is that in SSL the learned assignments znk are never exactly 0 or 1 (in nontrivial problems) because each zn is the average of its neighbors’ assignments. In LASS, the znk values can be exactly 0 or 1. This happens for the same reason why in many statistical models the L1 norm achieves sparse solutions while the L2 norm does not (indeed, the simplex constraints (1b)–(1c) imply ‖zn‖1 = 1 for each n)."
    }, {
      "heading" : "5.2 Assignments and probabilities",
      "text" : "The semantics of assignments is different from that of probabilities. Given a discrete probability distribution p over the values in Ω = {1, . . . ,K}, saying that “p(Z = k) = zk” means that Z equals exactly one of the values in Ω, but that we observe the value k with a probability zk (frequentist or Bayesian), for each k ∈ Ω. In contrast, given an assignment vector z over the values in Ω, the value of zk corresponds to the proportion of z that belongs to category k. For example, in a portfolio model, k = 1, . . . ,K are possible investments and zk is the portion of a $1 capital that is allocated to investment k, not the probability that we allocate all the $1 to investment k. However, in some cases the assignments can indeed be used as proxies for probabilities.\nFor example, our model includes classification as a particular (and rather restricted) setting, where (most) items belong to a single category and categories are mutually exclusive. Here, the assignment vectors may be interpreted as probabilities and the labels safely provided as 1–of–K codes.\nAssignment problems have a long history in operations research and economics. For example, the Markowitz portfolio model (Nocedal and Wright, 2006) seeks the portfolio (soft assignment of an individual investor’s $1 capital to K investments) that maximizes the expected return and minimizes the variance, and has the form of a QP. However, the use of Laplacian penalties (which, in the Markowitz model, would describe the similarity between different investors) does not seem to have been applied there."
    }, {
      "heading" : "5.3 Other applications of LASS",
      "text" : "The LASS problem (1) appears in the assignment step of the training algorithm for Laplacian K-modes clustering (Wang and Carreira-Perpiñán, 2014b). Here, the items are data points x1, . . . ,xN ∈ RD to be clustered into K clusters and the categories are the cluster centroids c1, . . . , cK ∈ RD. Both affinities are Gaussian: the W matrix has entries wnm = G(‖(xn − xm)/σ‖2), n,m = 1, . . . , N , and the G matrix has entries gnk = G(‖(xn − ck)/σ‖2), n = 1, . . . , N , k = 1, . . . ,K, where G(·2) gives a Gaussian kernel. At an optimum Laplacian K-modes clustering, the cluster centroids C = (c1, . . . , cK) are the modes of the kernel density estimates defined by each of the K clusters’ points. The problem is optimized over Z and C in alternating steps, where the step over Z for fixed C has the form (1).\nSupervised clustering can be formulated as problem (1), in particular supervised image segmentation. The user marks several pixels for each segment of the image, from which we can define the similarity matrixG in various ways. The similarity matrix W is constructed from the image (pixel location and range features)."
    }, {
      "heading" : "6 Experiments",
      "text" : "Illustrative example We constructed a simple example to show the difference between LASS and SSL, and the role of positive and negative item-category similarities. The data consists of N = 14 points a–g and a′–g′ and K = 4 categories C1–C4 which are related to each other according to the Venn diagram in\nfig. 2. Category C1 contains the other three categories and C3 and C4 intersect. This is quite different from the usual classification setting where each point is assigned to only one category. A graph is built on the data set, denoted by the edges between data points. We consider a–g (filled circles) as partially labeled and a′–g′ (hollow circles) as completely unlabeled. The ground-truth (true assignments derived from the Venn diagram), positive and negative labels we use are given in fig. 2(top right). For LASS, we set gnk = ±1 if xn is given positive/negative label Ck, and set gnk = 0 if no information is given. We do not give the full label information for any point (except a), so it is crucial to make use of the graph Laplacian to propagate label information. Since each unlabeled point xi is only connected to one (partially) labeled point xj , xi will inherit exactly the same assignment from xj in order to minimize the objective function (in this case wij ‖zi − zj‖2 = 0). Fig. 2(bottom) shows the assignment of unlabeled points obtained from SSL and from LASS (λ = 1) with only positive labels, and both positive and negative labels in G. With SSL (Zhu et al., 2003), since the labels are used as constraints (eq. (19)), the unlabeled points just inherit them and miss many assignments. With LASS, using only positive G obtains smoother assignments, but it sometimes assigns points to categories they do not belong to (e.g. a′ to C2, d′ to C3). Once we use negative labels, the progagation of those wrong labels is cut off and we obtain assignments closer to the ground truth for all points. SSL cannot easily use the negative labels.\nDigit recognition We test LASS in a classification task where each data point has only one valid label. We randomly sample 10 000 MNIST digit images and compute the 10-nearest-neighbor graph with similarities based on the Euclidean distance between images. We then randomly select Nl images from each of the 0–9 categories and give them the correct label. We compare with a nearest neighbor classifier (NN), one-vs-all kernel support vector machine (KSVM) using RBF kernel of width σ = 5 and hinge loss penalty parameter C selected from {10−3, 10−2, 10−1, 1, 101, 102, 103} and SSL (Zhu et al., 2003; Grady, 2006) using 1-out-of-10 coding for the labeled points. We also include two variants of SSL: SSL1 (Zhu et al., 2003) normalizes the assignments from SSL so that the prior distribution of the different classes is respected. SSL2 uses the normalized graph Laplacian instead of the unnormalized one in SSL (Zhou et al., 2004). SSL1 and SSL2 improve over SSL but neither of them produce valid assignments (they do not lie on the probability simplex). For LASS and SSL/1/2 we assign each point to the category with the highest prediction value. We let all algorithms use their respective optimal parameters (e.g. λ in LASS is determined by a grid search).\nFig. 3(left) shows the classification error over 20 different labeled/unlabeled partitions of the dataset as a function of Nl (errorbars not shown to avoid clutter). The accuracy of all algorithms improves as the number of labeled points increase, particularly for NN and KSVM, which are template matchers. But when only few points are labeled, the methods that make use of Laplacian smoothing significantly outperform them. LASS (runtime: 40 s) consistently achieves the best accuracy while producing valid assignments.\nDocument categorization We want to predict assignments of documents to topics, where each document may belong to multiple topics, in the 20-newsgroups dataset (N = 11 269 documents). We manually add 7 new topics (comp.sys, rec.sport, computer, recreation, politics, science and religion) based on the hierarchical structure and perceived similarity of groups (e.g. comp.sys.ibm.pc.hardware / comp.sys.mac.hardware). This yields K = 27 topics and each document can belong to 1 to 3 topics. To construct feature vectors, we remove words that occur in 5 or fewer documents, and then extract the TFIDF (term frequency × inverse document frequency) feature of the documents. We generate the G similarity matrix by randomly selecting Nl documents from each of the 27 topics, and giving each document one +1 label (the topic it is selected from) and five −1 labels (topics it does not belong to). For SSL, we turn this into assignment labels as described in section 19, and select the smoothing parameter ǫ optimally from {0, 0.005, 0.01, 0.02, 0.05, 0.1, 0.2}.\nTo evaluate the performance, we select for each test document the T topics to which it has highest predicted assignments (where T ∈ {1, 2, 3} is the actual number of topics this document belongs to), consider them as predicted label set, and compare them with ground truth labels. We consider it as an error if the predicted label set and the ground truth set differ. NN classification does not apply here because no document is fully labeled. We can apply one-vs-all linear SVM (hinge loss penalty parameter C selected from {10−3, 10−2, 10−1, 1, 101, 102, 103}) because we do have training points for each topic. Fig. 3(right) shows the mean classification error over 20 random labeled/unlabeled partitions of the dataset as a function of Nl. The accuracy of all algorithms again improves when Nl increases. LASS outperforms all other algorithms at nearly all Nl values, and, unlike them, always produces valid assignments.\nImage tagging This experiment fully benefits from the ability of LASS to handle partial labels, and predict full assignment vectors. In the problem of image tagging, each image can typically be tagged with multiple categories of a large number of possible categories. However, a user will usually tag only a few of the relevant categories for it (e.g. out of laziness) and will miss tagging other categories that would be relevant too. The task given a test image is to predict an assignment vector, i.e., to fill in “soft tags”, for all categories. When there are many possible categories, trying to fill in the missing assignments for the partially labeled samples (so we can use SSL to propagate them to the unlabeled samples) is pointless. In contrast, LASS does not require these missing assignments, by conveniently providing zero affinities.\nWe demonstrate LASS on a subset of the ESP game (von Ahn and Dabbish, 2004) images used by Guillaumin et al. (2009). We select the images in the training set that are tagged with at least 6 categories (words), resulting in 6 100 images with a total of 267 non-empty categories, with 7.2 categories per image on average. We use the same image feature sets as Guillaumin et al. (2009) to compute distances between images and build a 10-nearest neighbor graph. We give partial information for 4 600 images and provide item-category affinities for each image in the following way: we give positive affinity (+1) for a random subset of size nl from the categories it is tagged with, and give negative affinities (−1) randomly for 5 out of the 20 most frequent categories it is not tagged with. Providing negative affinities in this way stops the algorithm from concentrating most of the probability mass on the most frequent categories. The other 1 500 images are completely unlabeled and used for testing. SSL fills in missing assignments of the partially labeled samples as described in the document categorization experiment. Parameters are selected based on grid search for each algorithm.\nWe evaluate the performance of different algorithms using the precision, recall and F–1 score (averaged over sample images) on the test samples while fixing the annotation length at 5, i.e., each image is tagged with the 5 categories of highest assignment. (Although LASS admits tags as similarity values at test time, we do not use them here.) We vary the number of positive tags nl from 1 to 6. Fig. 4 shows the results for SSL and LASS over 20 runs (each with a different random selection of test set and partial affinities). We could not run one-versus-all SVMs because there are no negative samples for most categories. In SSL2, the highest prediction values are nearly always the most frequent categories. We see that LASS greatly improves over SSL, especially when smaller numbers of positive affinities are given."
    }, {
      "heading" : "7 Conclusion",
      "text" : "We have proposed a simple quadratic programming model for learning assignments of items to categories that combines two complementary and possibly conflicting sources of information: the crowd wisdom and the\nPrecision Recall F–1 score\n1 2 3 4 5 6\n25\n30\n35\n40\nSSL SSL1 SSL2 LASS\nnl\nP re ci si o n (%\n)\n1 2 3 4 5 6 15\n20\n25\n30\nnl\nR ec a ll (%\n)\n1 2 3 4 5 6\n20\n25\n30\n35\nnl\nF – 1\nGT : dog grass green man sky white Pred.: grass man sky green white tree\nGT : black drawing man old soldier tent white Pred.: black old drawing white tent sketch man\nGT : blue computer gray purple screen window Pred.: computer screen gray window blue white\nGT : black drawing hair man nose old white Pred.: black white drawing man hair circle tie\nGT : black coin man money old round silver white Pred.: black old round coin money man woman gray\nGT : field grass green people sky tree Pred.: grass sky green man tree tent\nexpert wisdom. It is particularly attractive when fully labeling an item is impractical, or when categories have a complex structure and items can genuinely belong to multiple categories to different extents. It provides a different way to incorporate supervision to that of traditional Laplacian semisupervised learning, which is ill-suited for this setting because the similarity information cannot be faithfully transformed into assignment labels.\nWe have derived a training algorithm based on the alternating direction method of multipliers. The algorithm’s iterations can be made fast by caching the Cholesky factorization of the graph Laplacian. The algorithm is very simple to implement. It requires no line searches and has only one user parameter, the penalty parameter. The algorithm converges for any positive value of the penalty parameter, but this value does affect the convergence rate.\nWe expect LASS to apply to problems beyond semisupervised learning, such as clustering, and in social\nnetwork applications, with image, sound or text data that is partially tagged. It can also be extended to handle tensor data or have additional terms in its objective, for example to represent relations between categories with a category-category similarity matrix, or even to use negative similarities in the item-item graph (since the feasible set is bounded, solution(s) still exist). A further application of LASS is to learn probability distributions that are conditional on partial supervisory information, since, in effect, the out-ofsample mapping is a nonparametric mapping from the affinity information to a distribution over categories. Another research direction is to find optimally adaptive schedules for the penalty parameter and to accelerate the convergence of the training algorithm, particularly with large datasets with many categories, where we may expect each row of Z to be sparse."
    } ],
    "references" : [ {
      "title" : "Laplacian eigenmaps for dimensionality reduction and data representation",
      "author" : [ "M. Belkin", "P. Niyogi" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Belkin and Niyogi.,? \\Q2003\\E",
      "shortCiteRegEx" : "Belkin and Niyogi.",
      "year" : 2003
    }, {
      "title" : "Manifold regularization: A geometric framework for learning from labeled and unlabeled examples",
      "author" : [ "M. Belkin", "P. Niyogi", "V. Sindhwani" ],
      "venue" : "J. Machine Learning Research,",
      "citeRegEx" : "Belkin et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Belkin et al\\.",
      "year" : 2006
    }, {
      "title" : "Distributed optimization and statistical learning via the alternating direction method of multipliers",
      "author" : [ "S. Boyd", "N. Parikh", "E. Chu", "B. Peleato", "J. Eckstein" ],
      "venue" : "Foundations and Trends in Machine Learning,",
      "citeRegEx" : "Boyd et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Boyd et al\\.",
      "year" : 2011
    }, {
      "title" : "Carreira-Perpiñán. Fast nonparametric clustering with Gaussian blurring mean-shift",
      "author" : [ "Á. M" ],
      "venue" : "Proc. of the 23rd Int. Conf. Machine Learning",
      "citeRegEx" : "M.,? \\Q2006\\E",
      "shortCiteRegEx" : "M.",
      "year" : 2006
    }, {
      "title" : "The Laplacian Eigenmaps Latent Variable Model",
      "author" : [ "M.Á. Carreira-Perpiñán", "Z. Lu" ],
      "venue" : "Proc. of the 11th Int. Workshop on Artificial Intelligence and Statistics (AISTATS",
      "citeRegEx" : "Carreira.Perpiñán and Lu.,? \\Q2007\\E",
      "shortCiteRegEx" : "Carreira.Perpiñán and Lu.",
      "year" : 2007
    }, {
      "title" : "LASS: A simple assignment model with Laplacian smoothing",
      "author" : [ "M.Á. Carreira-Perpiñán", "W. Wang" ],
      "venue" : "Proc. of the 28th National Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "Carreira.Perpiñán and Wang.,? \\Q2014\\E",
      "shortCiteRegEx" : "Carreira.Perpiñán and Wang.",
      "year" : 2014
    }, {
      "title" : "Semi-Supervised Learning. Adaptive Computation and Machine Learning Series",
      "author" : [ "O. Chapelle", "B. Schölkopf", "A. Zien", "editors" ],
      "venue" : null,
      "citeRegEx" : "Chapelle et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Chapelle et al\\.",
      "year" : 2006
    }, {
      "title" : "Spectral Graph Theory. Number 92 in CBMS Regional Conference Series in Mathematics",
      "author" : [ "F.R.K. Chung" ],
      "venue" : "American Mathematical Society,",
      "citeRegEx" : "Chung.,? \\Q1997\\E",
      "shortCiteRegEx" : "Chung.",
      "year" : 1997
    }, {
      "title" : "Random Walks and Electric Networks, volume 22 of Carus Mathematical Monographs",
      "author" : [ "P.G. Doyle", "J.L. Snell" ],
      "venue" : "Mathematical Association of America,",
      "citeRegEx" : "Doyle and Snell.,? \\Q1984\\E",
      "shortCiteRegEx" : "Doyle and Snell.",
      "year" : 1984
    }, {
      "title" : "Efficient projections onto the l1-ball for learning in high dimensions",
      "author" : [ "J. Duchi", "S. Shalev-Shwartz", "Y. Singer", "T. Chandra" ],
      "venue" : "Proc. of the 25th Int. Conf. Machine Learning",
      "citeRegEx" : "Duchi et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Duchi et al\\.",
      "year" : 2008
    }, {
      "title" : "Optimal parameter selection for the alternating direction method of multipliers (ADMM): Quadratic problems",
      "author" : [ "E. Ghadimi", "A. Teixeira", "I. Shames", "M. Johansson" ],
      "venue" : "[math.OC],",
      "citeRegEx" : "Ghadimi et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Ghadimi et al\\.",
      "year" : 2013
    }, {
      "title" : "Random walks for image segmentation",
      "author" : [ "L. Grady" ],
      "venue" : "IEEE Trans. Pattern Analysis and Machine Intelligence,",
      "citeRegEx" : "Grady.,? \\Q2006\\E",
      "shortCiteRegEx" : "Grady.",
      "year" : 2006
    }, {
      "title" : "TagProp: Discriminative metric learning in nearest neighbor models for image auto-annotation",
      "author" : [ "M. Guillaumin", "T. Mensink", "J. Verbeek", "C. Schmid" ],
      "venue" : "In Proc. 12th Int. Conf. Computer Vision (ICCV’09),",
      "citeRegEx" : "Guillaumin et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Guillaumin et al\\.",
      "year" : 2009
    }, {
      "title" : "Constrained spectral clustering through affinity propagation",
      "author" : [ "Z. Lu", "M.Á. Carreira-Perpiñán" ],
      "venue" : "In Proc. of the 2008 IEEE Computer Society Conf. Computer Vision and Pattern Recognition (CVPR’08),",
      "citeRegEx" : "Lu and Carreira.Perpiñán.,? \\Q2008\\E",
      "shortCiteRegEx" : "Lu and Carreira.Perpiñán.",
      "year" : 2008
    }, {
      "title" : "Numerical Optimization. Springer Series in Operations Research and Financial Engineering",
      "author" : [ "J. Nocedal", "S.J. Wright" ],
      "venue" : null,
      "citeRegEx" : "Nocedal and Wright.,? \\Q2006\\E",
      "shortCiteRegEx" : "Nocedal and Wright.",
      "year" : 2006
    }, {
      "title" : "Nearest-Neighbor Methods in Learning and Vision. Neural Information Processing Series",
      "author" : [ "G. Shakhnarovich", "P. Indyk", "T. Darrell", "editors" ],
      "venue" : null,
      "citeRegEx" : "Shakhnarovich et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Shakhnarovich et al\\.",
      "year" : 2006
    }, {
      "title" : "Normalized cuts and image segmentation",
      "author" : [ "J. Shi", "J. Malik" ],
      "venue" : "IEEE Trans. Pattern Analysis and Machine Intelligence,",
      "citeRegEx" : "Shi and Malik.,? \\Q2000\\E",
      "shortCiteRegEx" : "Shi and Malik.",
      "year" : 2000
    }, {
      "title" : "Semi-supervised learning with measure propagation",
      "author" : [ "A. Subramanya", "J. Bilmes" ],
      "venue" : "J. Machine Learning Research,",
      "citeRegEx" : "Subramanya and Bilmes.,? \\Q2011\\E",
      "shortCiteRegEx" : "Subramanya and Bilmes.",
      "year" : 2011
    }, {
      "title" : "A signal processing approach to fair surface design",
      "author" : [ "G. Taubin" ],
      "venue" : "Proc. of the 22nd Annual Conference on Computer Graphics and Interactive Techniques (SIGGRAPH",
      "citeRegEx" : "Taubin.,? \\Q1995\\E",
      "shortCiteRegEx" : "Taubin.",
      "year" : 1995
    }, {
      "title" : "Labeling images with a computer game",
      "author" : [ "L. von Ahn", "L. Dabbish" ],
      "venue" : "In Proc. ACM Int. Conf. Human Factors in Computing Systems (CHI",
      "citeRegEx" : "Ahn and Dabbish.,? \\Q2004\\E",
      "shortCiteRegEx" : "Ahn and Dabbish.",
      "year" : 2004
    }, {
      "title" : "Manifold blurring mean shift algorithms for manifold denoising",
      "author" : [ "W. Wang", "M.Á. Carreira-Perpiñán" ],
      "venue" : "In Proc. of the 2010 IEEE Computer Society Conf. Computer Vision and Pattern Recognition",
      "citeRegEx" : "Wang and Carreira.Perpiñán.,? \\Q2010\\E",
      "shortCiteRegEx" : "Wang and Carreira.Perpiñán.",
      "year" : 2010
    }, {
      "title" : "The role of dimensionality reduction in classification",
      "author" : [ "W. Wang", "M.Á. Carreira-Perpiñán" ],
      "venue" : "Proc. of the 28th National Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "Wang and Carreira.Perpiñán.,? \\Q2014\\E",
      "shortCiteRegEx" : "Wang and Carreira.Perpiñán.",
      "year" : 2014
    }, {
      "title" : "Laplacian K-modes clustering",
      "author" : [ "W. Wang", "M.Á. Carreira-Perpiñán" ],
      "venue" : "Unpublished manuscript,",
      "citeRegEx" : "Wang and Carreira.Perpiñán.,? \\Q2014\\E",
      "shortCiteRegEx" : "Wang and Carreira.Perpiñán.",
      "year" : 2014
    }, {
      "title" : "Learning with local and global consistency",
      "author" : [ "D. Zhou", "O. Bousquet", "T.N. Lal", "J. Weston", "B. Schölkopf" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Zhou et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Zhou et al\\.",
      "year" : 2004
    }, {
      "title" : "Semi-supervised learning using Gaussian fields and harmonic functions",
      "author" : [ "X. Zhu", "Z. Ghahramani", "J. Lafferty" ],
      "venue" : "Proc. of the 20th Int. Conf. Machine Learning",
      "citeRegEx" : "Zhu et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Zhu et al\\.",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "A major success in machine learning in recent years has been the development of semisupervised learning (SSL) (Chapelle et al., 2006), where we are given labels for only a few of the training points.",
      "startOffset" : 110,
      "endOffset" : 133
    }, {
      "referenceID" : 7,
      "context" : "Laplacian-based formulations are conceptually simple, computationally efficient (since the Laplacian is usually sparse), have a solid foundation in graph theory and linear algebra (Chung, 1997; Doyle and Snell, 1984), and most importantly work very well in practice.",
      "startOffset" : 180,
      "endOffset" : 216
    }, {
      "referenceID" : 8,
      "context" : "Laplacian-based formulations are conceptually simple, computationally efficient (since the Laplacian is usually sparse), have a solid foundation in graph theory and linear algebra (Chung, 1997; Doyle and Snell, 1984), and most importantly work very well in practice.",
      "startOffset" : 180,
      "endOffset" : 216
    }, {
      "referenceID" : 24,
      "context" : "The graph Laplacian has been widely exploited in machine learning, computer vision and graphics, and other areas: as mentioned, in semisupervised learning, manifold regularization and graph priors (Zhu et al., 2003; Belkin et al., 2006; Zhou et al., 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.",
      "startOffset" : 197,
      "endOffset" : 255
    }, {
      "referenceID" : 1,
      "context" : "The graph Laplacian has been widely exploited in machine learning, computer vision and graphics, and other areas: as mentioned, in semisupervised learning, manifold regularization and graph priors (Zhu et al., 2003; Belkin et al., 2006; Zhou et al., 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.",
      "startOffset" : 197,
      "endOffset" : 255
    }, {
      "referenceID" : 23,
      "context" : "The graph Laplacian has been widely exploited in machine learning, computer vision and graphics, and other areas: as mentioned, in semisupervised learning, manifold regularization and graph priors (Zhu et al., 2003; Belkin et al., 2006; Zhou et al., 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.",
      "startOffset" : 197,
      "endOffset" : 255
    }, {
      "referenceID" : 11,
      "context" : ", 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.",
      "startOffset" : 94,
      "endOffset" : 107
    }, {
      "referenceID" : 16,
      "context" : ", 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.",
      "startOffset" : 182,
      "endOffset" : 203
    }, {
      "referenceID" : 13,
      "context" : ", 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.",
      "startOffset" : 231,
      "endOffset" : 263
    }, {
      "referenceID" : 0,
      "context" : ", 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.",
      "startOffset" : 303,
      "endOffset" : 328
    }, {
      "referenceID" : 4,
      "context" : ", 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.",
      "startOffset" : 381,
      "endOffset" : 413
    }, {
      "referenceID" : 20,
      "context" : ", 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.",
      "startOffset" : 517,
      "endOffset" : 590
    }, {
      "referenceID" : 18,
      "context" : ", 2004) for regression, classification and applications such as supervised image segmentation (Grady, 2006), where one solves a Laplacian-based linear system; in spectral clustering (Shi and Malik, 2000), possibly with constraints (Lu and Carreira-Perpiñán, 2008), and spectral dimensionality reduction (Belkin and Niyogi, 2003) and probabilistic spectral dimensionality reduction (Carreira-Perpiñán and Lu, 2007), where one uses eigenvectors of the Laplacian; in clustering, manifold denoising and surface smoothing (Carreira-Perpiñán, 2006; Wang and Carreira-Perpiñán, 2010; Taubin, 1995), where one iterates products of the data with the Laplacian; etc.",
      "startOffset" : 517,
      "endOffset" : 590
    }, {
      "referenceID" : 5,
      "context" : "A shorter version of this work appears in a conference paper (Carreira-Perpiñán and Wang, 2014).",
      "startOffset" : 61,
      "endOffset" : 95
    }, {
      "referenceID" : 14,
      "context" : "For a QP, the KKT conditions are necessary and sufficient for a solution (Nocedal and Wright, 2006).",
      "startOffset" : 73,
      "endOffset" : 99
    }, {
      "referenceID" : 2,
      "context" : "1 QP solution using ADMM We briefly review how to solve a QP using the alternating direction method of multipliers (ADMM), following (Boyd et al., 2011).",
      "startOffset" : 133,
      "endOffset" : 152
    }, {
      "referenceID" : 2,
      "context" : "7 Optimal penalty parameter ρ The speed at which ADMM converges depends on the quadratic penalty parameter ρ (Boyd et al., 2011).",
      "startOffset" : 109,
      "endOffset" : 128
    }, {
      "referenceID" : 2,
      "context" : "7 Optimal penalty parameter ρ The speed at which ADMM converges depends on the quadratic penalty parameter ρ (Boyd et al., 2011). We illustrate this with the “2 moons” dataset in fig. 1 (N = 4 000 points, K = 2 categories, 5-nearestneighbor graph, λ = 1), where we set positive similarity values for one point in each cluster, resulting in each cluster being assigned to a different category, as expected. The problem has 8 000 parameters and we ran 10 iterations, which took 11 s. Little work exists on how to select ρ so as to achieve fastest convergence. Recently, for QPs, Ghadimi et al. (2013) suggest to use ρ = 2λ √ σminσmax where σmin and σmax are the smallest (nonzero) and largest eigenvalue of the Laplacian.",
      "startOffset" : 110,
      "endOffset" : 599
    }, {
      "referenceID" : 4,
      "context" : "We follow the reasoning of Carreira-Perpiñán and Lu (2007) to derive an outof-sample mapping.",
      "startOffset" : 27,
      "endOffset" : 59
    }, {
      "referenceID" : 9,
      "context" : "This can be efficiently computed, in a finite number of steps, with a simple O(K logK) algorithm (Duchi et al., 2008; Wang and Carreira-Perpiñán, 2014a).",
      "startOffset" : 97,
      "endOffset" : 152
    }, {
      "referenceID" : 15,
      "context" : "With large N , one should use some form of hashing (Shakhnarovich et al., 2006) to retrieve approximate neighbors quickly.",
      "startOffset" : 51,
      "endOffset" : 79
    }, {
      "referenceID" : 24,
      "context" : "1 Semisupervised learning with a Laplacian penalty (SSL) In semisupervised learning (SSL) with a Laplacian penalty (Zhu et al., 2003), the basic idea is that we are given an affinity matrix W and corresponding graph Laplacian L = D−W on N items, and the labels for a subset of the items.",
      "startOffset" : 115,
      "endOffset" : 133
    }, {
      "referenceID" : 8,
      "context" : "That Zu ≥ 0 follows from the maximum principle for harmonic functions (Doyle and Snell, 1984): each of the unknowns must lie between the minimum and maximum label values, i.",
      "startOffset" : 70,
      "endOffset" : 93
    }, {
      "referenceID" : 24,
      "context" : "if the given labels are not valid assignments, or in other widely used variations of SSL, such as using class mass normalization (Zhu et al., 2003), or using the normalized graph Laplacian instead of the unnormalized one, or using label penalties (Zhou et al.",
      "startOffset" : 129,
      "endOffset" : 147
    }, {
      "referenceID" : 23,
      "context" : ", 2003), or using the normalized graph Laplacian instead of the unnormalized one, or using label penalties (Zhou et al., 2004).",
      "startOffset" : 107,
      "endOffset" : 126
    }, {
      "referenceID" : 24,
      "context" : "In the latter case (also similar to the “dongle” variation of SSL; Zhu et al., 2003), one minimizes the Laplacian penalty plus a term equal to the squared distance of the labeled points (considered free parameters as well) to the labels Zl provided.",
      "startOffset" : 19,
      "endOffset" : 84
    }, {
      "referenceID" : 11,
      "context" : "as used for supervised clustering in Grady, 2006). However, in general SSL does not produce valid assignments, e.g. if the given labels are not valid assignments, or in other widely used variations of SSL, such as using class mass normalization (Zhu et al., 2003), or using the normalized graph Laplacian instead of the unnormalized one, or using label penalties (Zhou et al., 2004). In the latter case (also similar to the “dongle” variation of SSL; Zhu et al., 2003), one minimizes the Laplacian penalty plus a term equal to the squared distance of the labeled points (considered free parameters as well) to the labels Zl provided. Thus, this penalizes the labeled points from deviating from their intended labels, rather than forcing them to equal them. This was extended by Subramanya and Bilmes (2011) (replacing squared losses with Kullback-Leibler divergences and adding an additional entropy term) to learning probability distributions, i.",
      "startOffset" : 37,
      "endOffset" : 807
    }, {
      "referenceID" : 14,
      "context" : "For example, the Markowitz portfolio model (Nocedal and Wright, 2006) seeks the portfolio (soft assignment of an individual investor’s $1 capital to K investments) that maximizes the expected return and minimizes the variance, and has the form of a QP.",
      "startOffset" : 43,
      "endOffset" : 69
    }, {
      "referenceID" : 24,
      "context" : "With SSL (Zhu et al., 2003), since the labels are used as constraints (eq.",
      "startOffset" : 9,
      "endOffset" : 27
    }, {
      "referenceID" : 24,
      "context" : "We compare with a nearest neighbor classifier (NN), one-vs-all kernel support vector machine (KSVM) using RBF kernel of width σ = 5 and hinge loss penalty parameter C selected from {10−3, 10, 10, 1, 10, 10, 103} and SSL (Zhu et al., 2003; Grady, 2006) using 1-out-of-10 coding for the labeled points.",
      "startOffset" : 220,
      "endOffset" : 251
    }, {
      "referenceID" : 11,
      "context" : "We compare with a nearest neighbor classifier (NN), one-vs-all kernel support vector machine (KSVM) using RBF kernel of width σ = 5 and hinge loss penalty parameter C selected from {10−3, 10, 10, 1, 10, 10, 103} and SSL (Zhu et al., 2003; Grady, 2006) using 1-out-of-10 coding for the labeled points.",
      "startOffset" : 220,
      "endOffset" : 251
    }, {
      "referenceID" : 24,
      "context" : "We also include two variants of SSL: SSL1 (Zhu et al., 2003) normalizes the assignments from SSL so that the prior distribution of the different classes is respected.",
      "startOffset" : 42,
      "endOffset" : 60
    }, {
      "referenceID" : 23,
      "context" : "SSL2 uses the normalized graph Laplacian instead of the unnormalized one in SSL (Zhou et al., 2004).",
      "startOffset" : 80,
      "endOffset" : 99
    }, {
      "referenceID" : 11,
      "context" : "We demonstrate LASS on a subset of the ESP game (von Ahn and Dabbish, 2004) images used by Guillaumin et al. (2009). We select the images in the training set that are tagged with at least 6 categories (words), resulting in 6 100 images with a total of 267 non-empty categories, with 7.",
      "startOffset" : 91,
      "endOffset" : 116
    }, {
      "referenceID" : 11,
      "context" : "We demonstrate LASS on a subset of the ESP game (von Ahn and Dabbish, 2004) images used by Guillaumin et al. (2009). We select the images in the training set that are tagged with at least 6 categories (words), resulting in 6 100 images with a total of 267 non-empty categories, with 7.2 categories per image on average. We use the same image feature sets as Guillaumin et al. (2009) to compute distances between images and build a 10-nearest neighbor graph.",
      "startOffset" : 91,
      "endOffset" : 383
    } ],
    "year" : 2014,
    "abstractText" : "We consider the problem of learning soft assignments of N items to K categories given two sources of information: an item-category similarity matrix, which encourages items to be assigned to categories they are similar to (and to not be assigned to categories they are dissimilar to), and an item-item similarity matrix, which encourages similar items to have similar assignments. We propose a simple quadratic programming model that captures this intuition. We give necessary conditions for its solution to be unique, define an out-of-sample mapping, and derive a simple, effective training algorithm based on the alternating direction method of multipliers. The model predicts reasonable assignments from even a few similarity values, and can be seen as a generalization of semisupervised learning. It is particularly useful when items naturally belong to multiple categories, as for example when annotating documents with keywords or pictures with tags, with partially tagged items, or when the categories have complex interrelations (e.g. hierarchical) that are unknown.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}