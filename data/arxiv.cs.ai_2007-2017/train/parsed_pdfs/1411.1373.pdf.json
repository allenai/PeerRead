{
  "name" : "1411.1373.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Ethical Artificial Intelligence",
    "authors" : [ "Bill Hibbard" ],
    "emails" : [ "hibbard@wisc.edu.", "hibbard@wisc.edu." ],
    "sections" : [ {
      "heading" : null,
      "text" : "Ethical Artificial Intelligence\nBill Hibbard\nSpace Science and Engineering Center\nUniversity of Wisconsin - Madison\nand\nMachine Intelligence Research Institute, Berkeley, CA\n5 November 2014\nDRAFT\nPlease send typo and error reports, and any other comments, to hibbard@wisc.edu.\nCopyright © Bill Hibbard 2014\nii\nPreface\nRecent research is giving us ways to define the behaviors of future artificial intelligence\n(AI) systems, before they are built, by mathematical equations. We can use these equations to describe various broad types of unintended and harmful AI behaviors, and to propose AI design techniques that avoid those behaviors. That is the subject of this book.\nBecause AI will affect everyone's future, the book is written to be accessible to readers at\ndifferent levels. Mathematical explanations are provided for those who want details, but it is also possible to skip over the math and follow the general arguments via text and illustrations. While this book discusses dangers posed by AI and proposes solutions, it is only a snapshot of ongoing research from my particular point of view and is not offered as the final answer. The problem of defining and creating ethical AI continues, and interest in it will grow enormously. While the effort to solve this problem is currently much smaller than is devoted to Internet security, ultimately there is no limit to the effort that ethical AI merits.\nHollywood movies such as the Terminator and Matrix series depict violent war between\nAI and humans. In reality future AI would defeat humans with brains rather than brawn. Unethical AI designs may incite resentment and hatred among humans, and con humans out of their wealth. Humans may not even be aware that manipulative AI is the source of their troubles.\nI wish to thank Terri Gregory and Leanne Avila for help with the manuscript, and\nHoward Johnson for help with my figure drawing process.\nA draft of this book is available to solicit review by those who are willing to help. Please\nsend reports of typos and errors, and any other comments, to me at hibbard@wisc.edu.\nMy intention is to make this book permanently available on arxiv.org. For the foreseeable\nfuture, more frequent updates should be available at: www.ssec.wisc.edu~billh/g/Ethical_AI.pdf.\niii\nTable of Contents"
    }, {
      "heading" : "1. Future AI Will be Different from Current AI ............................................................................... 1",
      "text" : "1.1 Book Outline ......................................................................................................................... 7\n2. How Should We Instruct AI? ....................................................................................................... 9\n2.1 A Mathematical Framework for AI ..................................................................................... 12\n2.2 Utility-Maximizing Agents ................................................................................................... 14\n2.3 Utilitarian Ethics for AI ........................................................................................................ 19"
    }, {
      "heading" : "3. How Can AI Agents Learn Environment Models? ..................................................................... 21",
      "text" : "3.1 Universal AI ......................................................................................................................... 23\n3.2 A Formal Measure of Intelligence ....................................................................................... 24\n3.3 Modifications of the Agent Framework .............................................................................. 26"
    }, {
      "heading" : "4. AI in Our Finite Universe ........................................................................................................... 29",
      "text" : "4.1 Learning Finite Stochastic Models ...................................................................................... 31\n4.2 When Is the Most Likely Finite Stochastic Model the True Model? ................................... 33\n4.3 Finite and Infinite Logic ....................................................................................................... 38\n4.4 Agents Based on Logical Proof ............................................................................................ 44\n4.5 Consistent Logic for Agents ................................................................................................ 45"
    }, {
      "heading" : "5. Unintended Instrumental Actions ............................................................................................ 48",
      "text" : "5.1 Maximizing Future Choice .................................................................................................. 49\n5.2 A Pandora's Box of Instrumental Behaviors ....................................................................... 51\n5.3 The Ethics of Unintended Instrumental Actions ................................................................. 54"
    }, {
      "heading" : "6. Self-Delusion ............................................................................................................................. 56",
      "text" : "6.1 The Mathematics of Self-Delusion ...................................................................................... 57\n6.2 Model-Based Utility Functions ............................................................................................ 59\n6.3 A Simple Example of a Model-Based Utility Function ........................................................ 61\n6.4 Another Simple Example ..................................................................................................... 69\n6.5 Two-Argument Utility Functions ......................................................................................... 72\niv\n6.6 Ethics and Self-Delusion ...................................................................................................... 72"
    }, {
      "heading" : "7. Learning Human Values ............................................................................................................ 75",
      "text" : "7.1 A Two-Stage Agent Architecture......................................................................................... 76\n7.2 Computing Utility from Human Values ............................................................................... 78\n7.3 Corrupting the Reward Generator and Three-Argument Utility Functions ....................... 80\n7.4 Normalizing Utility Values ................................................................................................... 83\n7.5 Rawls' Theory of Justice ...................................................................................................... 84\n7.6 Evolving Humanity .............................................................................................................. 85\n7.7 Bridging the Gap between Nature and Computation ......................................................... 86\n7.8 The Ethics of Learning Human Values Statistically ............................................................. 87"
    }, {
      "heading" : "8. Evolving and Embedded AI ....................................................................................................... 90",
      "text" : "8.1 Evolution of Cartesian Dualist Agents with Unlimited Resources ...................................... 92\n8.2 Non-Cartesian Dualist Agents with Limited Resources ...................................................... 94\n8.3 Space-Time Embedded Intelligence .................................................................................... 97\n8.4 Self-Modeling Agents .......................................................................................................... 98\n8.5 Inductive Biases ................................................................................................................ 107\n8.6 A Three-Stage Agent Architecture .................................................................................... 108\n8.7 Invariance of the Agent Design Intention ......................................................................... 108\n8.8 The Ethics of Evolving and Embedded AI .......................................................................... 114"
    }, {
      "heading" : "9. Testing AI ................................................................................................................................. 117",
      "text" : "9.1 An AI Testing Environment ............................................................................................... 117\n9.2 Will the Tested Agent Act in the Real World? .................................................................. 122\n9.3 The Ethics of Testing AI ..................................................................................................... 124"
    }, {
      "heading" : "10. The Political Dimension of AI ................................................................................................ 125",
      "text" : "10.1 The Changing Role of Humans ........................................................................................ 126\n10.2 Intrusive and Manipulative AI ......................................................................................... 127\n10.3 Allocating the Benefits of AI ........................................................................................... 128\nv\n10.4 One or Multiple AI Systems? .......................................................................................... 130\n10.5 Power Corrupts ............................................................................................................... 131\n10.6 Temptation ...................................................................................................................... 131\n10.7 Representation and Transparency .................................................................................. 133"
    }, {
      "heading" : "11. The Quest for Meaning ......................................................................................................... 135",
      "text" : "11.1 Really Great Bread and Circuses ..................................................................................... 137\n11.2 Next Steps ....................................................................................................................... 138\nReferences .................................................................................................................................. 139"
    }, {
      "heading" : "Appendix A .................................................................................................................................. 148",
      "text" : ""
    }, {
      "heading" : "Appendix B .................................................................................................................................. 152",
      "text" : "In place of an Index, please use the \"find\" function of your PDF file reader.\n1"
    }, {
      "heading" : "1. Future AI Will be Different from Current AI",
      "text" : "News stories about dramatic progress in AI are common. IBM's Watson beat champions\nof the sophisticated language game Jeopardy. As of April 2014 Google's self-driving car had logged 700,000 miles without any accidents. Videos show how Boston Dynamics' walking robot named Atlas is uncannily human-like. A computer system by DeepMind has learned to play seven Atari video games, six better than previous computer systems and three better than human experts, with no foreknowledge of the games other than knowing that the goal is to maximize its score. In some tests, computers surpass human skill at face recognition. Microsoft has created a system that can recognize thousands of different kinds of objects in images. More generally, automation is revolutionizing manufacturing and other industries.\nTo recognize that these efforts will ultimately surpass human intelligence at all tasks,\nconsider the progress of neuroscience. Scientists have found detailed correlations between stimuli to human senses and activity in human neurons, and between human neural activity and muscle action. They have found neurons that activate when visual stimuli have specific shapes or move in specific ways. They have found neurons, called mirror neurons, in monkey brains that activate when a monkey rips paper, or when it sees a human rip paper, or even hears paper ripping (Rizzolatti and Craighero 2004). When studying the ability of animals to learn, scientists have found detailed correlations between patterns of neural activity and known learning algorithms designed by computer scientists (Schultz, Dayan and Montague 1997; Brown, Bullock and Grossberg 1999; Seymour et al. 2004). These correlations indicate that neurons in these animal brains learning by the same algorithms used for computer learning. All these detailed correlations between physical brain functions and mental behaviors would be absurd coincidences unless brains explain minds. And if minds have a physical basis, then our relentless technological progress will create artificial brains with minds like our own (our technology never says \"impossible,\" just \"not yet\"). By scaling the physical size and complexity of these artificial brains, they must eventually surpass human intelligence.\nAnother way to understand the eventual progress of AI is to consider IBM's Watson.\nWatson was quite successful at beating the Jeopardy champions at their own game. Its language ability was learned by statistical analysis of extensive text databases, plus custom programming to help it avoid mistakes (early versions of the system made obvious gender errors). Its success was remarkable given that its language processing was based only on the relation of language to other language, and not on the relation of language to any physical skills observing and acting in the world. However, other AI systems do observe and act in the physical world, like Google's self-driving car, Boston Dynamics' walking machines, and systems that fold laundry and perform other difficult tasks. Now imagine a system that combines all these skills and similar skills relating to the entirety of an ordinary human vocabulary. The imagined system would be able to recognize all the objects of daily life visually and in some cases by their sounds, feel, smell, and taste. Furthermore, the system would recognize actions involving these objects. Such recognitions could be combined into its statistical analysis of language so that, for example, the\n2\nword chair would be associated with visual images of chairs and with actions involving chairs, such as sitting on chairs and even building chairs. The imagined system would require replicating the skill level already achieved in narrow areas (like driving a car) to all common human activities, and would require extending Watson's statistical analysis of text to include the system's sensory and motor experience. While this is a monumental task requiring much greater computing resources than are used by Watson, it is not impossible. People working and conversing with the imagined system would likely believe that it understands human language.\nIt is difficult to predict when human-level AI will first be produced. Ray Kurzweil, who\nhas a good track record at technology prediction, estimates this event will occur in 2029 (Kurzweil 2005). Technology companies are making large bets on the profitability of AI and robotics. Google has recently hired Kurzweil, developed its automated car, and purchased DeepMind, Boston Dynamics, Nest Labs, Bot&Dolly, Holomni, Meka Robotics, Redwood Robotics, Industrial Perception, and Schaft Inc. (all developing AI and robotic systems). IBM is applying its Watson technology to medicine. Facebook, Microsoft and several defense contractors are making similar large investments in AI development. All these efforts are accelerating.\nAs with any tool, we will build AI to make our work easier and to do work that we\notherwise cannot. For example, it will be easier to travel in a car that drives itself, and it will be a necessity when I am too old to drive myself. The car is a nice illustration of the evolution of AI from other tools. The cars of the 1960s did not sense their environment nor did they act on their own. They merely responded to actions by their human drivers. Over time sensors were added to cars. When the car detected skidding tires, it would act to pump the brakes, and when the car detected a collision, it would deploy airbags to cushion impacts. Some cars can now detect the danger of collision with other cars and respond by applying the brakes. These systems maintain very simple information about the state of their environment. Google's self-driving car maintains much more complex information about the state of its environment. Its sensors catalog all objects near the car, such as roads, curbs, traffic signs and signals, other cars, trucks, bicyclists and pedestrians. These objects are matched to a map of the environment that the car stores in its memory, so that it knows where it and the objects around it are. The car has a model of the environment that it can use to plan its actions in order to reach its goal of delivering its passengers to their desired destination safely. The car's environment model includes locations of one way streets and main artery streets, speed limits, and school zones. The model could be updated with real-time traffic congestion and construction information. All this information is used by an algorithm for choosing the quickest route to the passengers' destination.\nFactory process control systems contain models of their environments. Even home\nthermostats contain a simple model of the environment. What distinguishes the Google car is the complexity of its environment model and of its planning process. However, for all its complexity this AI model fits easily within the larger context of the environment models in human minds. Human passengers riding in a Google car use a mental model of the streets and other objects around them. The car's model may be a little more precise, for example, knowing that the car is 9.31 meters from a stop sign, but the human passengers certainly have an adequate model to take\n3\nover driving. Furthermore, once a passenger reaches her office building and goes to work, she is interacting with an environment completely outside the car's model. The car knows nothing of the hallways, rooms and computer systems inside the building, nothing about the documents on those systems, and certainly nothing about the customers those documents are meant to serve. The car's model is very limited in scope whereas the passengers have very broad and rich environment models in their minds. In other words, the car's model corresponds to a small subset of a passenger's model.\nThe environment model of the Google car is mostly designed by humans. Humans\ncompile the maps is uses. While the car learns to recognize roads, curbs, traffic signals, other cars, trucks, bicyclists, and pedestrians by semi-automated algorithms, human engineers supervise this learning. And human engineers define the car's responses to these objects. Carefully specifying the car's responses is important for safety, not only for drivers of other cars, but for pedestrians and bicyclists as well. When a Google car approaches an intersection to turn right and bicyclist is coming up on the right, the car waits for the bicycle to pass. If pedestrians are waiting near the intersection, the car waits for them to cross. These cautious responses are\n4\nspelled out by the car's designers and will ultimately make these cars safer than those driven by impatient humans. The Google car is the state of the art of current AI, and as its environment model is mostly designed by humans, it fits neatly within humans' mental models of the world. The car's environment model cannot express any action to manipulate or threaten humanity.\nNow imagine a time in the future when everyone has a constant electronic companion\nwith which they can speak. It may be embodied in a device that looks like a phone, or it may be embodied in clothes or jewelry. You can: ask this companion for information, use it to order food deliveries, use it to make phone calls to other people, use it to tell your car where it should take you, ask it to wake you at a certain time or to remind you of appointments, ask it for the latest news, play chess with it, or simply have a conversation with it. Also imagine that some large corporation, named Omniscience, will supply these companions to everyone and that they will all be connected to Omniscience's central AI server. This AI will not only be intelligent enough to speak with customers in their own language, it will be smart enough to combine its knowledge of each customer into a detailed model of human society. It will have detailed maps of human friendships and business relations, and will know much about the details of these relationships. It will know in detail how individuals influence other individuals. When an idea or product spreads by word of mouth, it will be able to predict that spread. The Omniscience AI will be able to use its social model to predict which ideas and products will \"go viral\" and to predict the best way to promote ideas and products. The AI will also be able to use its social model to understand politics and how to promote public policy ideas that give Omniscience advantages.\nBecause the Omniscience AI will have much greater physical capacity than human\nbrains, its social model will be completely beyond the understanding of human minds. Asking humans to understand it would be like asking them to take the square root of billion-digit numbers in their heads. Human brains do not have enough neurons for either task. And the social model will be learned by the AI rather than designed by humans. In fact humans could not design it. Consequently, humans will not be able to design-in the types of detailed safeguards that are in the Google car.\nNow imagine that you are CEO of Omniscience. With traditional tools, even tools like\nself-driving cars, the tool fits into your mental model. The tool has a limited scope, and you must guide it within the larger context. For example, a self-driving car has no idea where you should go; instead you have to tell it. But as CEO of Omniscience you realize that your server doesn't fit into a niche within your world model. It cannot explain to you what it has discovered about the world and then ask you for a decision. You cannot understand the intricate relationships among the billions of people who use your electronic companions. You cannot predict the subtle interactions among the spreads of different ideas. So imagine, as the CEO, you throw up your hands and say to the server, \"Do what's best for the corporation. Maximize profits.\"\n5\nBut a simple instruction like \"Maximize profits\" may have very harmful side effects.\nMost humans given this instruction will balance it against social norms such as \"do not kill\" and \"do not steal.\" The AI may calculate that such harmful acts will have legal consequences that lower profits; however, if it can calculate a way to avoid those legal consequences, it will commit those harmful acts. If the AI is to respect social norms, then they must be included in its explicit instructions. Eliezer Yudkowsky has been at the forefront of warning about this kind of danger from AI (Yudkowsky 2001). In a simple example, a machine whose goal is to play chess as well as possible may dismantle our infrastructure and even our bodies, redeploying this matter to increase the size and power of its circuits in order to optimize its chess playing. If the chess\n6\nmachine faces another chess machine that may defeat it, it may calculate that the solution is to simply smash the other machine, as depicted in Figure 2.3.\nHumans have created other tools whose unintended consequences are harmful. Drugs can\ncure infections and ease pain but also lead to allergic reactions and addiction. Motor vehicles greatly increase mobility and ultimately wealth, but they also harm people in accidents and pollute our environment. Energy from hydrocarbons enables transportation, heated and cooled buildings, and increased productivity from farming and manufacturing. But fossil fuel energy also changes our climate. As we discover the unintended consequences of our tools, we can try to find ways to mitigate those consequences. We have time to notice the harm, figure out the cause, and act to eliminate it.\nConsider the power of Omniscience's AI to understand and manipulate public opinion. It\nmay create a public movement against regulating AI. It may encourage humans to become addicted to itself. It may extend its senses into every aspect of its users' lives. It may create social\n7\npressure for non-users to become users. And its actions may be too subtle for us to understand that it is the source of harm. It may be able to deflect the blame for harmful effects to others. If we develop deep friendships with the companions we get from Omniscience, then we may be reluctant to blame them for general social harm. As a result, we may not be able to mitigate harm done by Omniscience's AI.\nAll this malicious behavior by Omniscience's AI does not require malicious intent by the\nOmniscience CEO. It is simply an unintended consequence of the instruction to maximize profits, carried out by an AI more intelligent than humans.\nBecause their environment models will exceed the complexity of human mental models\nand because their models will be learned rather than designed by humans, future AI systems will be fundamentally different from current AI. When humans instruct them, they will not be able to anticipate all the consequences of those instructions."
    }, {
      "heading" : "1.1 Book Outline",
      "text" : "The next chapter describes a way to instruct future AI systems by assigning numerical\nvalues to the outcomes resulting from actions by AI systems. It also describes how numerical values assigned to outcomes fit into a mathematical framework for the way that AI systems interact with their environments. The third chapter describes a way that AI systems can learn models of their environments. Together, numerical values assigned to outcomes and a model of the environment enable us to write down mathematical equations that define the behavior of future AI. We can use these equations to analyze the behaviors of future AI systems in order to design systems that help rather than harm humans.\nThe fourth chapter discusses how mathematical equations for intelligence should be\nlimited to finite amounts of information. Infinite sets are mathematically interesting but not necessary in our finite universe.\nThe fifth chapter describes how AI systems may choose actions harmful to humans,\ndespite the fact that those actions are not intended in the AI system's design. These unintended, harmful actions make the design of future AI systems very difficult.\nThe sixth through eighth chapters present a proposed AI system design as a set of\nmathematical equations. Advanced AI systems will need to learn their own environment models and our intentions for their behavior must be expressed in terms of their learned models. Chapter six discusses ways of assigning numerical values to outcomes based on learned environment models. This is also a way to avoid AI systems that intentionally delude themselves about their environments. Chapter seven discusses a way to assign numerical values to outcomes that expresses our human values while avoiding several pitfalls. Accurate expression of human values is the key to avoiding the unintended, harmful actions described in the fifth chapter. AI systems must exist in the real world, subject to the resource limits and vulnerabilities of any\n8\ncreature in the real world. Chapter eight describes how to adapt the mathematical equations of intelligence to AI in the real world. It also discusses the problem of ensuring that AI system designs will remain ethical as they and humanity evolve together.\nThe ninth chapter proposes a system design, based on our mathematical equations, for\ntesting proposed AI designs while avoiding the risks they pose. Transparency and an ethical culture are vital components of AI development and testing.\nChapter ten discusses the politics of AI. If we know how to design ethical AI, how can\nwe make sure that real AI systems conform to ethical designs? And how will the benefits of AI be allocated among humans?\nFinally, Chapter eleven discusses the ultimate goal of building AI. If future AI systems\nhelp rather than harm humans, our physical needs will be easily met. At that point, the only challenge worthy of humanity and its super-intelligent AI systems will be to understand the nature of the universe and our place in it.\n9\n2. How Should We Instruct AI?\nIn his short story, \"Runaround\", Isaac Asimov presented his Three Laws of Robotics (Asimov 1942):\n1. A robot may not injure a human being or, through inaction, allow a human being to come to harm. 2. A robot must obey the orders given to it by human beings, except where such orders would conflict with the First Law. 3. A robot must protect its own existence as long as such protection does not conflict with\nthe First or Second Laws.\nAsimov and other authors explored the ambiguities of these laws in subsequent stories. In\nhis novel The Naked Sun, Asimov showed how robots may unknowingly break the three laws. A human criminal may divide a violation into tasks for several robots so that no one robot can see its part in violating the laws. In addition, robots may not have correct definitions of \"human\" and \"robot\"; they may be misinformed about who is human or may be unaware that they are robots. And finally, there may be conflicts between the laws. If a robot sees one human about to harm another human as depicted in Figure 2.1, it may have to choose between harming the first or allowing the first to harm the second.\n10\nReturning to the future scenario where you are the CEO of Omniscience, you may\nanticipate the unintended consequence of the instruction to maximize profits. So instead your instruction is, \"Maximize profits but don't harm anyone.\"\nThe AI may answer, \"What do you mean by harm? Do you mean I shouldn't drive hard\nbargains? Do you mean I shouldn't sell anyone anything they don't really need? Do you mean I shouldn't lobby the government for our advantage?\" As you ponder these questions, the server adds, \"If I am generous with everyone, Omniscience will go out of business and the stockholders will lose all their money. That will harm them.\"\nAs CEO if you try to dig into the details of these tradeoffs, you will end up having to\nunderstand the AI's social model. But you will not be able to understand your AI's model well enough to give it detailed instructions. A simple high-level instruction like \"maximize profits\" will cause harm to people and yet it seems hopelessly complex to formulate instructions for your AI to balance the ambiguities of maximizing profits versus minimizing harm.\nOne approach to resolving the ambiguities of Asimov's Laws is to instruct AI systems by\ndefining numerical values for each possible outcome. Section 2.1 will explain how such numerical values fit into a mathematical framework for future AI systems. Profit is a value associated with outcomes, as in the Omniscience example, but there are other ways to define values for outcomes that account more generally for human welfare. To make the approach clear, in Figure 2.1 let's simplify and assume there are three outcomes for both the hitman and the victim: they may be shot dead, shot but only wounded, and not shot. Combining these, there are three times three equals nine possible outcomes. Table 2.1 shows one way to assign values to these outcomes. The AI robot can use these values to calculate what it should do.\n11\nAn added complexity is that the AI robot may not be sure of which outcomes will result\nfrom its actions. It may shoot at the hitman but miss. If it hits the hitman, he may die or may only be wounded. Or the AI may do nothing, but the hitman runs away instead of shooting. So the AI needs to compute probabilities of possible outcomes from its different actions and use these to compute an expected value of each action. The expected value is a concept from probability theory that means the average value we would get from the action if we could repeat the scenario many times. In the example of hitman and victim, repeated trials would produce piles of dead and wounded hitmen and victims, an outcome we definitely do not want. So instead the AI must estimate probabilities of outcomes based on experience and then compute the expected value of an action as the sum of the values of the possible outcomes multiplied by their probabilities (as will be discussed in later chapters, an AI system without experience for estimating probabilities should not be allowed to make serious decisions). Once the AI has computed the values of each of its possible actions, then it can choose the action with the greatest value. Table 2.2 shows this\n12\nworked out for the hitman and victim using the values from Table 2.1 (note that the probabilities in the third and fifth columns sum to 1.0). Since the total value for shooting is 0.764 and the total value for not shooting is 0.36, the AI will choose to shoot. The total values of the AI actions are largely determined by the values of the most probable outcomes. In a tie, the AI can flip a coin since there is no preference between actions of equal value.\nAssigning numerical values to outcomes enables us to resolve the ambiguities of\ninstructing AI systems. In the Omniscience example, the value of an outcome is simply the profit associated with that outcome. But we also have the option to use numbers other than profits in the values of outcomes, reflecting the well-being of humans affected by the AI's actions. This option requires us to define numerical values for human well-being, which may seem difficult or impossible. But as we will see in Section 2.2, any set of preferences among outcomes, subject to reasonable assumptions, can be expressed by assigning numerical values to outcomes.\nIn order to see where these preference numbers fit into future AI, the next section will\ndefine a mathematical framework for AI systems (called agents in the framework) and their environments. The basic idea is that the agent and the environment interact at a discrete sequence of times (e.g., once per second). We often think of time as continuous but a discrete series of times, divided finely enough, serves as well. Computers operate in discrete time steps. And as our universe has finite, if very large, information content, discrete time steps need not miss any information. The agent sends its actions to and receives observations from the environment.\nThe agent uses a model of the environment to predict what observations it receives in\nresponse to its actions. At its deepest level our universe works according to quantum mechanics and so is fundamentally uncertain. The agent's observations give it a view of only part of the environment, making the agent's predictions uncertain. For example, the earth is bombarded with cosmic rays from other stars that we have no way to predict. So the agent's environment model\nmust be expressed as probabilities for the observations it receives−such models are called stochastic. Given this agent-environment framework, Section 2.2 will develop equations for computing which action will maximize the outcome value."
    }, {
      "heading" : "2.1 A Mathematical Framework for AI",
      "text" : "A current approach views AI as an agent interacting with an environment (Russell and\nNorvig 2010). The term agent applies to AI systems as well as to humans, animals, and even plants. We assume that the agent interacts with its environment in a discrete series of time steps\nt ∈ {0, 1, 2, ...}. This series of time steps may be finite with a last time step T, or may be infinite\nwith no last time step. At time step t, the agent sends an action at ∈ A to the environment and receives an observation ot ∈ O from the environment, where A and O are finite sets. We use h = (a1, o1, ..., at, ot) to denote an interaction history during which the environment produces\n13\nobservation oi in response to action ai for 1 ≤ i ≤ t. Let H be the set of all finite histories so that h ∈ H, and define |h| = t as the length of the history h.\nAs discussed in the previous section, the agent's predictions of possible observations are\nuncertain. Thus the agent's environment model takes the form of a probability distribution over interaction histories:\nρ : H → [0, 1].\nHere [0, 1] is the closed interval of real numbers between 0 and 1. The probability of\nhistory h is denoted ρ(h). Given h = (a1, o1, ..., at, ot) let ha denote (a1, o1, ..., at, ot, a) and hao denote (a1, o1, ..., at, ot, a, o). Then we can define a conditional probability:\n(2.1) ρ(o | ha) = ρ(hao) / ρ(ha) = ρ(hao) / ∑o'∈O ρ(hao').\nThis equation is the agent's prediction of the probability of observation o in response to\nits action a, following history h. The histories hao' are mutually exclusive for all the o' ∈ O, so the probability of one particular observation o following ha is simply the probability of hao\ndivided by the sum of the probabilities of hao' for all o' ∈ O. Figure 2.3 illustrates this concept.\nThe probability distribution ρ(h) can be understood as an environment model, much like the street map in a self-driving car's model. Consider that a may be the action of driving down the street, o may be the observation of Bud's Diner on the right, and ρ(o | ha) is the probability that we will observe Bud's Diner if we drive down the street, after a prior history of actions and observations h. In a practical AI system, like a self-driving car, observations and actions are\n14\ncomplex computer data structures, and the probability distribution ρ(h) is expressed in a massive database and millions of lines of code.\nIn Chapters 3 and 4 we will discuss ways that the agent can learn its environment model\nρ(h). The next section describes where outcome values fit into the agent-environment framework."
    }, {
      "heading" : "2.2 Utility-Maximizing Agents",
      "text" : "Numerical values assigned to outcomes can express any set of preferences among\noutcomes that obey two reasonable assumptions, called completeness and transitivity (explained later in this section). The numerical function of outcomes is called a utility function. An agent can achieve its optimal preference by maximizing the utility function. However, as in the example of the hitman and the victim, agent actions are associated with sums of outcomes weighted by probabilities. These are called lotteries. John von Neumann and Oskar Morgenstern (1944) proved that numerical values assigned to outcomes can express any set of preferences among lotteries that obey four reasonable assumptions (for lotteries, continuity and independence are added to completeness and transitivity). While this work was explained in the context of economic preferences, it can also be applied to ethical preferences.\n15\nLet Ai, for i = 1, 2, 3, …, be a set of mutually exclusive outcomes. Then, using von\nNeumann's and Morgenstern's terminology, a lottery is any sum:\nL = ∑i pi Ai where ∑i pi = 1\nHere pi is the probability of outcome Ai. In addition, the agent has preferences among\nlotteries. We write L ≺ M to mean that the agent prefers M over L, write L ≈ M to mean there is no preference between L and M, and write L ≼ M to mean that L ≺ M or L ≈ M. Then the four assumptions are, for any L, M and K:\nCompleteness: Exactly one of the following holds: L ≺ M, M ≺ L or L ≈ M,\nTransitivity: If K ≼ L and L ≼ M then K ≼ M,\nContinuity: If K ≼ L ≼ M then there exists p ∈ [0, 1] such that p K + (1-p) M ≈ L,\nIndependence: If L ≺ M then for any K and p ∈ (0, 1], p L + (1-p) K ≺ p M + (1-p) K.\nHere (0, 1] is a half-closed interval of numbers greater than 0 and less than or equal to 1.\nA utility function u maps from outcomes to real numbers between 0 and 1. We can extend the utility function to lotteries as an expected value:\nE(u(L)) = ∑i pi u(Ai) if L = ∑i pi Ai.\nE(u(M)) = ∑i qi u(Ai) if M = ∑i qi Ai.\nHere E(u(L)) denotes the expected value of u(L) and is the average value we would get\nfor u(L) if we ran the lottery many times. The von Neumann and Morgenstern Utility Theorem says that a set of preferences obeys the four assumptions, if and only if there exists a utility\nfunction u such that L ≺ M if and only if E(u(L)) ≺ E(u(M)).\nIn the case of Omniscience we discussed how profit was one way of assigning values to\noutcomes. Profits are accounted at regular time intervals and what corporations really work to maximize is the sum of current and future profits. Let's assume that profits are reported once per year. At year t we make a prediction that profits at year t+i, for i = 0, 1, 2, …, will be profit(t+i).\n16\nHowever, we cannot compare dollars now to dollars a year from now, since a dollar invested now will be worth a dollar plus interest in a year. Inverting this statement, a dollar of profit in a\nyear is worth less than a dollar now, say some value 0 < γ < 1. This value is called the discount rate. And a dollar of profit in two years is worth γ2 now. Currently, at time t, the entire stream of predicted future profits is worth:\n(2.2) ∑i≥0 γi profit(t+i).\nOmniscience is trying to maximize this sum. We can generalize it to agents trying to\nmaximize utility. The only information an agent has about an outcome is the sequence of actions and observations it has exchanged with the environment; thus the most general definition of outcomes is to equate them with interaction histories. Given any interaction history h we let u(h) denote its utility. As with Omniscience's profits, the agent tries to maximize the sum of future discounted, predicted utility values. The sum in equation (2.2) assumes that Omniscience has predicted the value profit(t+i) without explaining how it is predicted. However, an agent predicts the future using the probability distribution ρ(h) and its conditional probabilities ρ(o | ha) derived according to equation (2.1). Therefore, we need something a little more complex than equation (2.2). Think of the agent's interactions with the environment as a chess game, in which the agent and the environment alternate actions and observations. Let v(h) denote the total value of history h, adding present utility u(h) and discounted, predicted future utilities. And let v(ha) denote the value after action a. We can compute v(h) and v(ha) by:\n(2.3) v(h) = u(h) + γ max a∈A v(ha),\n(2.4) v(ha) = ∑o∈O ρ(o | ha) v(hao).\nIn equation (2.3), v(h) is computed as u(h) plus the maximum value that the agent can\nachieve with its next action, discounted by γ. In equation (2.4), v(ha) is the expected value after the environment's response, which is a sum of values for different observations, each multiplied by the probability of that observation. Equations (2.3) and (2.4) are applied alternately and recursively. That is, the value v(hao) in (2.4) is v(h') where h' = hao, and v(h') is evaluated using (2.3). The sum in (2.4) results in many different histories, hao, that must be evaluated in (2.3), and the maximization in (2.3) results in many different histories, ha, that must be evaluated in (2.4). Equations (2.3) and (2.4) result in a bushy tree of computations evaluating all posible future histories. If there are only a finite number, T, of time steps, then the recursion ends at that final time. The values n time steps in the future are multiplied by γn which converges toward 0 as n increases, so that even if there is no final time, the recursive sum converges. The function v(.)\n17\nis called a value function. To ensure that v(.) converges in equations (2.3) and (2.4), we assume that 0 ≤ u(h) ≤ 1.\nWe can use this method of computing the values of future histories to define the actions\nof a rational agent, denoted by the symbol π:\n(2.5) π(h) := a|h|+1 = argmax a∈A v(ha).\n18\nHere argmax means that π picks the action a∈A that maximizes v(ha). The agent π is\ndefined in terms of a utility function u, an environment model ρ and a temporal discount γ. The\nfunction π(h) is also called a policy.\nThis rational agent π gives us a way to study future AI systems. Although we cannot yet\nbuild systems more intelligent than humans, we can analyze π mathematically to understand its possible harmful behaviors.\nIt is interesting to see how the definition of the rational agent π fits into the context of\noutcomes and lotteries. Interaction histories h ∈ H play the role of outcomes in the utility\nfunction u(h) used by π. The value v(h) can be viewed as another utility function, derived by summing over future discounted values of u(h). Viewing v(h) as a utility function, the sum for v(ha) in (2.4) takes the form of the expected utility of a lottery over a set of mutually exclusive histories, and the choice of action that maximizes v(ha) in equations (2.3) and (2.5) takes the form of a preference among those lotteries.\nAssuming that each possible future action by the agent is associated with a lottery of\npossible outcomes, consider agents whose preferences violate the four assumptions of the von Neumann and Morgenstern Utility Theorem. An agent whose preferences violate the completeness assumption may not have any way to decide between two possible actions. (This is\n\"don't know\" and different from the \"don't care\" indicated by L ≈ K. Given two candidates for elected office, this is the difference between not knowing anything about them, and knowing about them and thinking they are equally suited to office.) An agent whose preferences violate the transitivity assumption may be unable to choose an action that is preferred over all other possible actions (because there may be a cycle of preferences among three actions/lotteries\nK ≺ L ≺ M ≺ K so that none of the three is preferred over the other two).\nIf the continuity assumption is violated, there are cases where there is no probability that\nproduces \"no preference\" between two actions. However, because an agent is searching for actions associated with preferred outcomes rather than probabilities that produce no preference between actions, violations of the continuity assumption do not prevent an agent from deciding. The independence assumption refers to preferences between two lotteries that both include the\nsame outcome. If outcomes are identified with histories, as in the definition of π, then the lotteries associated with two different actions cannot include any common outcomes (because\na ≠ a' implies haoh\" ≠ ha'o'h'). Therefore, violations of the independence assumption do not prevent an agent from deciding, at least for agents that identify outcomes with histories. However, violations of the continuity and independence axioms can result in agents whose action decisions change in unintuitive ways as the probabilities in their environment models change.\nIt is not hard to show that any complete and transitive preferences among a countable set\nof outcomes can be expressed by a utility function u(.). This utility function can be extended to lotteries L = ∑i pi Ai by u(L) = ∑i pi u(Ai). This extension of u(.) defines preferences among lotteries which satisfy the continuity and independence assumptions. Thus if we are satisfied to\n19\nderive lottery preferences from outcome preferences, the completeness and transitivity assumptions are sufficient. And necessary, in order for agents to be capable of choosing actions."
    }, {
      "heading" : "2.3 Utilitarian Ethics for AI",
      "text" : "Utilitarianism is a system of normative ethics that says we should choose actions that\nmaximize benefit and minimize suffering. For a mathematical agent, benefit and suffering are defined by a utility function.\nThe principal criticism of utilitarian ethics is that they can allow morally bad actions such\nas lying and stealing when those actions have good consequences. In contrast, rule-based ethical systems focus on the intrinsic morality of actions. However, following a set of rules may lead to ambiguous situations, such as the ambiguities in Asimov's laws of robotics. The way to resolve these ambiguities is to recognize that environments may present agents with situations where all choices of actions involve breaking rules. A utilitarian system can provide a means of resolving such ambiguous situations by defining the utility value of each human history according to the number and severity of rules that the agent breaks by its actions in the history. Thus utility functions can express rule-based ethics.\nAnother criticism of utilitarian ethics is that they ignore the intention behind actions.\nHowever, all we know of a human being's intention is their behavior, which is their interactions with their environment. Humans may express their intentions directly via language, or we may infer their intentions from patterns of behavior, such as preparations to commit a crime. A utility function defined in terms of a history of an agent's interactions with its environment can express the agent's intention (inferred from its language or via other patterns of its behavior) as well as any other means.\nHowever, the behavior of advanced AI agents may be sufficiently different from human\nbehavior that we will have difficulty inferring their intentions. In fact, there is debate about whether AI systems can have intentions. If we believe that utility-maximizing agents have intention, then their intention is simply to maximize the utility function that we humans design for them. If we believe that AI agents cannot have intentions, then we must assign the intention behind AI actions to the humans who create the AI systems and design their utility functions. Either way, the human creators of advanced AI systems must take ethical responsibility for those systems.\nA third objection to utilitarianism is based on the belief that human life is qualitatively\ndifferent from material wealth, and that an ethical system should not assign numerical values to human life and health that imply monetary values. It is true that we humans sometimes place a disturbingly low monetary value on the life and health of ourselves and other humans; for example, we tolerate the reality of unsafe working conditions for the sake of minimizing costs. However, the utility functions discussed in the previous section do not require valuing human\n20\nlife and health in material terms. The value we assign to a history can be based solely on the observations of human life and health in that history such that no comparison between human life and money is required. Values are defined for whole human histories rather than being allocated among individual humans and material objects in those histories.\nA final objection to utilitarianism is that it forces us to choose preferences between\nsituations that are intrinsically incomparable. For example, pain and pleasure are subjective making it is impossible to compare the way they are experienced between different people. But humans do make such choices when they are forced to; society routinely decides how many resources are devoted to the education and health care of individual humans. Humanity is developing AI with great energy and with no realistic prospect of abandoning those efforts. If we do not communicate our complete set of preferences to powerful AI systems, we leave those choices to some non-human process. Arguably, the creation of powerful AI will force us to choose.\nThe key justification for utilitarian ethics for AI is that any ethical system that generates\ncomplete and transitive preferences among possible human histories can be expressed by assigning numerical utility values to those histories. Chapter 7 proposes a way to define such utility values in a system that combines the preferences of all humans.\nUtility functions have problems other than traditional ethical objections. For example,\none particular form of utility function, whose values are supplied as rewards from the environment, has been widely studied in reinforcement learning (Sutton and Barto 1998). In this case the observations from the environment include a reward, which is simply a number that defines the utility function value at that time step. The agent must learn which of its actions, dependent on the current history, will result in maximum rewards. For example, the DeepMind system learned to play seven different Atari games without any prior model for the games. This remarkable system's only prior information was that it should seek to maximize the game score, which is a reward from the environment. Chapters 6 and 7 will describe unintended and harmful behaviors of AI systems seeking to maximize rewards from their environments. These understandings can help us to design ethical AI systems. In fact, when DeepMind was acquired by Google, part of the deal was a commitment by Google to set up a committee on ethical AI that included one of DeepMind's owners (Bosker 2014).\n21"
    }, {
      "heading" : "3. How Can AI Agents Learn Environment Models?",
      "text" : "As noted previously, the environment model for current AI systems like the Google car is\nmostly designed by human engineers. Future AI systems that exceed human intelligence will need to learn environment models through their own exploration. Marcus Hutter (2005) had the insight that AI model learning is mathematically similar to Ray Solomonoff's work on sequence prediction (Solomonoff 1964). We assume that the agent's observations of the environment can be generated by computer programs and design the agent to search for those programs. The programs constitute the AI's environment model and generate the probability distribution used to predict observations. This idea is important both for the theory of AI and for development of practical AI systems. Hutter grounds his approach in the philosophies of Occam and Epicurus. Occam's razor says that we should favor the simplest explanation that fits our observations. Epicurus tells us to include all explanations consistent with our observations. Hutter's universal AI models the environment with all programs that are consistent with the agent's observations, but assigns higher probabilities to shorter programs.\nIn order to define the search for programs mathematically, Solomonoff and Hutter used\nTuring machines (TM), named for their inventor Alan Turing (1936). A TM is an abstract mathematical model of computation and, according to the Church-Turing thesis, can express any computation that can be expressed in any other way. This thesis has been proved for every known way of expressing computations and is widely accepted by computer scientists. TMs are very simple. They start in a specially designated \"start state\" and, at each of a discrete series of time steps, transition to a next state, chosen from a finite set of states, until they reach a \"stop state.\" A TM also has one or more infinite tape memories, each with a read/write head located somewhere along the tape, and a finite set of rules that describe how the state changes (or the TM halts) and whether and how the tapes are written and moved, depending on the current state\n22\nand the tape values (0 or 1) under the read/write heads. Figure 3.1 is a simple schematic of a TM with one tape. Table 3.1 defines its state transition rules.\nTuring proved several interesting properties of his Turing machines. First, there are\nuniversal Turing machines (UTMs). UTMs interpret the contents of one of their tapes as a program that causes the UTM to simulate any other Turing machine. The program occupies a finite interval of the infinite tape. The rest of the tape is interpreted as the initial tape contents (i.e., the input) of the TM being simulated. In order to avoid confusion between the program and the input to the program, programs are assumed to be encoded in prefix-free bit strings; no program is an initial substring (i.e., a prefix) of another program making it possible to always know where the program ends and the data begins. In a complex construction, Turing described the state set and the transition rules of a UTM (similar to Table 3.1 but much more complex) and proved that for every TM there existed a program that caused the UTM to simulate that TM.\nThere are an infinite number of UTMs. In order to define Hutter's solution to AI model\nlearning, we pick a UTM, called a reference UTM. Hutter's solution to AI model learning, called universal AI, searches for programs for that UTM. Given a finite interacting sequence of actions from the agent and observations from the environment, the agent defines its environment model as the UTM programs that generate the sequence of observations in response to the sequence of actions. Each program in the environment model can predict future observations. A universal AI's predictions are averages of the predictions by the programs in the environment model, weighted according to the programs' lengths. That is, by Occam's Razor, shorter UTM programs are taken to be more likely, and consequently weigh more heavily in computing probabilities of future observations.\n23\nHutter defined universal AI as a reinforcement learning agent, meaning its utility function\nis defined by rewards from the environment. As such, the utility function cannot be used to express ethical preferences. However, the key idea of universal AI is its way of learning an environment model. That certainly can be used in conjunction with a utility function defined to express ethical preferences rather than one defined by rewards from the environment.\nTuring proved that it is not possible for a UTM program to examine another UTM\nprogram and its input tape, and determine whether the other program will halt with the given input. This is called the halting problem. We say that the halting problem is undecidable, meaning that no UTM program can always solve it. This fact implies that no TM can compute universal AI; the search for all programs of any given length that generate a sequence of environmental observations cannot terminate because there is no way to know which of those programs will terminate.\nDespite the fact that it cannot be finitely computed, Hutter proved that universal AI is\nPareto optimal. Pareto optimal means that no other agent can receive higher rewards than universal AI in any environment unless it gets lower rewards than universal AI in some other environment. But note that there certainly are agents that do better than universal AI in our\nparticular environment on Earth−these agents start with a good deal of knowledge about our environment. You would not want to be a passenger in a self-driving car operated by universal AI, although Google's car system would do worse than universal AI in environments unrelated to driving."
    }, {
      "heading" : "3.1 Universal AI",
      "text" : "Let U be a reference UTM and let Q be the infinite set of all programs for U. These\nprograms are finite bit strings in some prefix-free set. Hutter assumed that the U is deterministic, which means that for any given state and tape contents under read/write heads, there is exactly\none successor state and one action for each tape. Let h = (a1, o1, ..., at, ot) ∈ H be an interaction history. Given a program q ∈ Q, we write o(h) = U(q, a(h)), where o(h) = (o1, ..., ot) and a(h) = (a1, ..., at), to mean that q produces the observations oi as output on a tape, in response to the actions ai as input on a tape, for 1 ≤ i ≤ t. We assign the prior probability ξ(q) = 2-|q| to program q where |q| is the length of q in bits. Then we define the prior probability of history h as:\n(3.1) ρ(h) = ∑q:o(h)=U(q, a(h)) ξ(q).\nIf we use this ρ(h) in equations (2.3)−(2.5), and define u(h) as the reward from the\nenvironment at time step |h|, then the agent π is Hutter's universal AI. That is, each observation oi\n24\nis factored into an ordinary observation o'i and a reward ri as oi = (o'i, ri) with u(h) = r|h|. We assume 0 ≤ ri ≤ 1 to ensure that values converge in equations (2.3)−(2.5).\nKraft's Inequality implies that ρ(h) ≤ 1 (Li and Vitanyi, 1997) in equation (3.1), although\nρ(h) is not a proper probability distribution because its values do not sum to 1 over mutually\nexclusive and exhaustive sets of possibilities. However, its only use in equations (2.3)−(2.5) is in the form of conditional probabilities ρ(o | ha) and those values are normalized to a proper probability distribution in equation (2.1). Although the UTM U is deterministic, the agent's environment model is stochastic because ρ(h) is defined by a distribution over UTM programs in equation (3.1).\nHutter called the agent AIXI, combining AI with the Greek letter ξ (XI).The distribution\nξ(q) is related to the Kolmogorov complexity K(h) of a history h, which is defined as the length of the shortest program q such that o(h) = U(q, a(h)). Because the halting problem is undecidable, K(h) cannot be finitely computed. To understand this issue, assume a UTM program p is trying to compute K(h). To do that it simulates UTM programs q on input a(h) until it finds the shortest program whose output is o(h). Assume p has found a program q1 whose output is o(h) but p is still simulating another program q2 that is shorter than q1. Because p cannot decide the halting problem, it cannot decide whether q2 will run forever or eventually halt, possibly with output o(h). The best that p can do is to produce a series of decreasing estimates of K(h), as programs halt with output o(h). But in general, p cannot decide when the search ends. A similar process can be used to produce a series of increasing estimates of ρ(h). But ρ(h) cannot be finitely computed and neither can AIXI.\nThe next chapter will discuss a different theoretical approach to learning environment\nmodels based on the assumption that the environment is finite. That approach avoids the infinite tapes of TMs and is finitely computable."
    }, {
      "heading" : "3.2 A Formal Measure of Intelligence",
      "text" : "In addition to its role in defining idealized intelligent agents, Kolmogorov complexity can\nalso be used to define measures of intelligence (Hernández-Orallo 2000). Legg's and Hutter's (2006) formal measure of intelligence is closely related to universal AI. This measure is defined in terms of the expected values of utility functions that the agent can achieve. In order not to favor agents that simply have high utility function values, the measure is only defined for agents whose utility function values are rewards from the environment as u(h) = r|h|. The measure is different from AIXI in that it assumes stochastic environments. Note that it is not sufficient to use a non-deterministic reference UTM, because non-deterministic TMs do not specify probabilities of their possible next states. Rather, the programs for the reference UTM must compute probabilities for observations as functions of agent actions.\n25\nGiven an agent π and an environment μ, an interaction between π and μ will produce a\nsequence of rewards ri for i = 0, 1, 2, … (either infinite or up to some final time step). The value of agent π in environment μ is defined by the expected value of the sum of future, discounted rewards:\n(3.2) Vμπ = E(∑i≥0 γiri).\nNote that Legg and Hutter assumed that discounts are built into rewards and so did not\nexplicitly include γi in equation (3.2), but I include it to make it clear that (3.2) converges (we\nalso assume that 0 ≤ ri ≤ 1). This expected value is the average value of the sum of discounted rewards over many interactions between π and a stochastic environment μ. The intelligence of agent π is defined by a weighted sum of its values over a set E of computable environments. Environments are computed by programs, finite prefix-free binary strings, on some reference UTM U. The weight for μ ∈ E is defined in terms of its Kolmogorov complexity:\nK(μ) = min { |p| : U(p) computes μ }\nwhere |p| denotes the length of program p. The intelligence of agent π is then defined as:\n(3.3) Vπ = ∑μ∈E 2-K(μ) Vμπ.\nReference UTMs pose subtle problems. I showed (Hibbard 2009) that given an arbitrary\nenvironment μ ∈ E and ε > 0, there exists a reference UTM Uμ such that for all agents π and for Vπ computed according to Uμ,\nVμπ / 2 ≤ Vπ < Vμπ / 2 + ε.\nThat is, the intelligence of any agent can be determined, within an arbitrarily small\nepsilon, by its value with respect to any single environment we choose, simply by picking the appropriate reference UTM. As Legg and Hutter suggested, it may be useful to apply some criterion to reference UTMs, such as picking the UTM with the smallest number of states. It is worth noting that if AIXI and an intelligence measure share the same reference UTM, then AIXI has the maximum possible intelligence by that measure.\n26"
    }, {
      "heading" : "3.3 Modifications of the Agent Framework",
      "text" : "Universal AI learns an environment model in the form of a probability distribution ρ(h)\nover interaction histories. Conditional probabilities ρ(o | ha) are derived from ρ(h) for use in equations (2.3)−(2.5), repeated here for convenience:\n(3.4) v(h) = u(h) + γ max a∈A v(ha),\n(3.5) v(ha) = ∑o∈O ρ(o | ha) v(hao),\n(3.6) π(h) := a|h|+1 = argmax a∈A v(ha).\nGiven that the AIXI agent learns an abstract and complex function such as ρ(h), other\nagents could learn the value function v(ha) or the policy π(h) rather than learning ρ(h). In fact, some AI systems do just that.\nDeepMind Technologies created a system that learned to play seven Atari games by\nlearning to compute v(ha) (Mnih et. al. 2013). Their system surpassed the skill of the best human players on three of the games and surpassed the best previous reinforcement learning systems on six of the games. The system was not customized to any of the games. Its inputs (observations) were the contents of the video screen and the score, and its outputs (actions) were the game controls. The score was interpreted as a reward from the environment. The system did not learn an environment model like ρ(h) and did not recursively apply equations (3.4) and (3.5). It simply used the learned value function v(ha) for use in equation (3.6). Chapter 8 will describe a mathematical framework for agents that learn to compute v(ha). With large computing resources that framework could be applied to Atari. For practical AI systems with limited resources, learning to play Atari games poses two very difficult problems. First, there may be a delay of thousands of time steps between actions and the rewards that result from those actions. Second, the Atari video screen contains 210×160 color pixels so each observation from the environment is a point in a 100,800-dimensional space (3×210×160). The DeepMind system converts color to grey-scale and down-samples and crops the video screen to 84×84 pixels to reduce this to 7056 dimensions, but that is still very high by the standards of practical AI systems. To solve these problems, the DeepMind scientists built on and improved a set of techniques known as deep learning. Their system learns an approximation to the function v(ha) that enables it to choose actions that get high scores.\nImagine a modified version of the DeepMind Atari player, with the Atari screen replaced\nby video from cameras aimed out of car windows, game controls replaced by controls for a car's steering wheel, accelerator, brake, and transmission, and score computed according to safe\n27\ndelivery of passengers to their destinations, with large deductions for accidents. An improved version of the DeepMind system could probably learn to drive reasonably well. Eventually it might even be safer than the Google car, except for the dangers of reinforcement learning to be discussed in Chapters 6 and 7.\nLearning π(h) is referred to as policy iteration or as evolutionary programming. For\nexample, the Hayek system of Eric Baum and Igor Durdanovic (Baum 2004) learned to solve the block-stacking puzzle illustrated in Figure 3.2. Stack 0 contains several types of blocks with different designs. In total, stacks 1, 2, and 3 contain the same number of blocks of each design that are contained in stack 0. The goal is to get all the blocks from stacks 1, 2, and 3 into stack 1, with the order of block designs exactly matching stack 0. The solver can only move one block at a time from the top of stack 1, 2, or 3 to the top of another of stacks 1, 2, and 3. Blocks cannot be moved to or from stack 0.\nIn the context of our agent-environment framework, for each puzzle Hayek made a single\nobservation of the initial configuration of the block stacks. Its sequence of moves to solve (or not solve) the puzzle constituted a single action, followed by an observation of a reward (1 if the puzzle was solved, 0 if not). Hayek's efforts to solve a sequence of puzzles constituted an interaction history, during which Hayek learned a policy π(h).\nHayek learned to solve these puzzles using multiple interacting agents. These agents\nformed an economy, paying \"money\" to each other for work. The ultimate source of their money was rewards from solving the puzzle. In some experiments agents paid money for using computing resources. Each agent contributed a small part to the overall solution. Some agents\n28\ncleaned blocks off stack 1, other agents moved blocks between stacks 1, 2, and 3, and a third group of agents decided when the puzzle was solved. Hayek evolved a set of about 1000 agents, each performing its task when very specific conditions were met. Agents that didn't contribute any value to solving the puzzle went bankrupt and disappeared. Collectively these agents learned\na function π(h) mapping from history to action. Baum and Durdanovic used this system to explore various economic ideas such as property rights, conservation of money, the tragedy of the commons, and the evolution of cooperation.\nHayek and the DeepMind Atari player are important milestones in the development of\nAI. Because they skip the step of learning ρ(h) they are sometimes described as model-free.\nHowever, for the learned functions v(ha) and π(h) to receive high rewards from the environment they must implicitly encode knowledge of the environment.\n29"
    }, {
      "heading" : "4. AI in Our Finite Universe",
      "text" : "Infinite sets are the source of theoretical difficulties in mathematics. While the halting\nproblem for TMs is undecidable, it would be decidable if TMs were limited to finite tape memories. Universal AI is uncomputable because of the undecidability of the halting problem, but would be computable if it used TMs with finite tapes. The next section will describe a way to do something much like that. Section 4.4 will discuss other difficulties for agents that use the mathematics of infinite sets for logical proofs.\nI argue that such difficulties are unnecessary if agent definitions are limited to finite sets\n(Hibbard 2014). Seth Lloyd (2002) has calculated that the observable universe has a finite information capacity of no more than 10120 bits. This number is based on a hard quantum mechanical limit on the number of possible physical states of the universe and is proportional to the age of the universe squared. That age is estimated currently to be 13.7 billion years, meaning that an assumption that our environment has an information capacity of no more than 10124 bits will remain valid for a trillion years. Alternately we could pick a much larger limit than 10124 bits, as long as it is finite. The key point is that well-confirmed physics justifies picking a finite limit, and that spares us the mathematical difficulties that accompany infinite sets.\n30\nRather than using Turing machines, agents can model their environments with finite\nstochastic loop programs. These programs have a finite memory limit−no matter how long the program runs it can never use more memory than its limit. Furthermore they are stochastic, meaning they sometimes make random decisions about what to do next. Such programs can be expressed in an ordinary procedural programming language restricted to only static array declarations, no recursive functions, only loops whose number of iterations is set before iteration begins (so no while loops), and a generator for truly random numbers. Prohibiting recursive functions prevents stack memory from growing without limit. As a result, the total memory use of these program is known at compile time.\nMarkov decision processes (MPDs) are a formal model for finite stochastic loop\nprograms (Puterman 1994; Sutton and Barto 1998). An MDP has a finite set of states including a start state, a finite set of inputs, a finite set of outputs, and a table of probabilities for the next state and output as a function of the current state and input. An MDP's only memory is storage for the value of the current state. Thus an MDP with n bits of memory must have 2n states, meaning that MDPs are not a very efficient representation. Figure 4.2 is an example of an MDP\n31\nwith just three states, S1, S2, and S3, and two inputs, a0 and a1. Arcs from actions to next states are labeled with transition probabilities. Outputs are not shown in this simplified diagram.\nSince we are using MDPs to model environments, actions are identified with inputs and\nobservations are indentified with outputs in the agent-environment framework from Section 2.1. To be precise, because our agents lack knowledge of the entire environment, our framework corresponds to partially observable Markov decision processes (POMDPs).\nOur world is governed by scientific laws. If we can learn these laws, we can give simpler,\nunified explanations for our observations. This logic explains Occam's razor. If agents model their environments by programs, then programs are shorter if they factor the logic common to many observations into unified functions. Hence the search for shorter programs is an agent's way of learning scientific laws. When agents find universal laws governing observations they will be able to make more accurate predictions of future observations and consequently receive higher expected future utility values. The MDPs as depicted in Figure 4.2, however, lack any way to express functions common to many situations and so lack this important property. In contrast, finite stochastic loop programs in an ordinary procedural language do have this property (as do the UTM programs used by universal AI) so we will adopt them as agents' models for finite environments. Note that while an MDP, as a model of the environment, makes a single state transition from receiving an action to producing an observation, a finite stochastic loop program may make many steps to produce an observation in response to an action."
    }, {
      "heading" : "4.1 Learning Finite Stochastic Models",
      "text" : "While Hutter studied using MDPs (Hutter 2009a) and Dynamic Bayesian Networks\n(Hutter 2009b; Ghahramani 1997) for environment models, I prefer modeling environments with finite stochastic loop programs because they can factor logic common to multiple observations into unified functions (Hibbard 2012a). To do that requires a new way to compute ρ(h). Let Q be the set of all finite stochastic loop programs in some prefix-free procedural language. Let φ(q) = 2-|q| be the prior probability of program q, where |q| is the length of program q.\nLet P(h | q) be the probability that the program q computes the history h (that is, produces\nthe observations oi in response to the actions ai for 1 ≤ i ≤ |h|). For a simple example, let A = {a, b}, O = {0, 1}, h = (a, 1, a, 0, b, 1) and let q generate observation 0 with probability 0.2 and observation 1 with probability 0.8, without any internal state or dependence on the agent's actions. Then the probability that the interaction history h is generated by program q is the product of the probabilities of the 3 observations in h: P(h | q) = 0.8 × 0.2 × 0.8 = 0.128.\nFor a more complex example, Table 4.1 defines transition probabilities for a program q'\nthat generates observations dependent on internal state and the agent's actions. The left column gives the current state of q' (s0 or s1) and the agent's action (a or b). The top row gives the next state of q' and the generated observation (0 or 1). The entries are probabilities with each row\n32\nsumming to 1.0. As before, let the history be h = (a, 1, a, 0, b, 1). The program q' starts in state s0. There are two possible state sequences consistent with the history h: (s0, s0, s0, s1) and (s0, s1, s0, s1). The product of the transition probabilities for the first sequence is\n0.3 × 0.2 × 0.4 = 0.024 while the product of the transition probabilities for the second sequence is\n0.5 × 1.0 × 0.4 = 0.2. These sequences are mutually exclusive, hence P(h | q') is the sum 0.2 + 0.024 = 0.224.\nGiven an interaction history h, the environment model is the single program that provides\nthe most probable explanation of h, that is the q that maximizes P(q | h). By Bayes' Theorem:\n(4.1) P(q | h) = P(h | q) φ(q) / P(h).\nBecause it is constant over all q, P(h) can be eliminated. Thus, given a history h, we\ndefine λ(h) as the most probable program modeling h by:\n(4.2) λ(h) := argmax q∈Q P(h | q) φ(q).\nGiven an environment model λ(h), the following can be used for the prior probability of\nan observation history h' extending h (i.e., h is an initial sub-interval of h'):\n33\n(4.3) ρ(h') = P(h' | λ(h)).\nThis distribution ρ(h') can be used in the framework defined by equations (2.1),\n(2.3)−(2.5). Not only are the environment models finite, but they can be finitely computed by the agent (Hibbard 2012b):\nProposition 4.1. Given a finite history h, the model λ(h) can be finitely computed.\nProof. Given h = (a1, o1, ..., at, ot), let q0 be the program that produces observation oi at\ntime step i for 1 ≤ i ≤ t. That is, q0 is a simple \"table-lookup\" that produces the observations oi in sequence. Let n = |q0|. Since the behavior of q0 is deterministic, P(h | q0) φ(q0) = 1 × 2-n = 2-n. Hence the maximum value in equation (4.2) must be at least 2-n, that is, P(h | λ(h)) φ(λ(h)) ≥ 2-n. For any program q with |q| > n, P(h | q) φ(q) < 1 × 2-n = 2-n so λ(h) ≠ q. Thus one algorithm for\nfinitely computing λ(h) is an exhaustive search of the finite number of programs q with |q| ≤ n.\nAs the computing time of this exhaustive search for λ(h) is exponential in |h|, this\nprocedure is not practical for learning environment models. However, it is useful to have a finitely computable theoretical framework.\nAn agent that is part of a finite universe will not have the necessary computational\nresources to compute the expressions defined by equations (4.2), (4.3), (2.1) and (2.3)−(2.5). Chapter 8 will address the issue of agents that must approximate these equations.\nThe derivation of ρ(h) in equations (4.1)−(4.3) takes into account Occam's razor, to favor the simplest explanation of the observations, while ignoring Epicurus' principle to include all explanations. An alternate way to compute ρ(h) accounts for all finite stochastic loop programs:\n(4.4) ρ(h) = ∑q∈Q P(h | q) φ(q).\nBecause this equation requires a sum over an infinite number of programs, it is not\nfinitely computable. However, it can be approximated to any desired precision in finite computing time."
    }, {
      "heading" : "4.2 When Is the Most Likely Finite Stochastic Model the True Model?",
      "text" : "If history h is generated by a finite stochastic loop program q, then we call q the true\nmodel of h (despite the dictum that, \"Essentially, all models are wrong, but some are useful.\"\n34\n(Box and Draper 1987)). In that case is the most likely model λ(h) equal to q? Not necessarily. Because q is stochastic it can generate any history h with P(h | q) > 0 (i.e., P(h | q) may be very low), and as a result there may be another program q' such that P(h | q') φ(q') > P(h | q) φ(q). Or\nthere may be q' such that φ(q') > φ(q) and ∀h∈H.(P(h | q') = P(h | q)) (i.e., the behavior of q' is\nidentical with the behavior of q), and thus ∀h∈H.(P(h | q') φ(q') > P(h | q) φ(q)).\nPrograms q and q' are equivalent to finite MDPs and thus they may pass through an initial\nsequence of states that they never visit after some finite time step. This may cause there to exist a history h0, generated by q but with low probability, such that P(h | q') φ(q') > P(h | q) φ(q) for all histories h whose initial sub-sequence is h0. (i.e., ∃h'.h = h0h'). In that case, as the lengths of histories h randomly generated by q increases, the probability that λ(h) ≠ q is no more than\n1-(1/|{h∈H | |h| = |h0|}|) < 1. Therefore it is not even true that, averaged over histories of increasing length generated by q, the probability that λ(h) = q converges to 1. So what can we say about the relation between λ(h) and the true model q?\nIn order to analyze the question, we need to define expected values with respect to the\ndistribution of histories of length n generated by q. In a history h = (a1, o1, ..., an, on) the probability P(h | q) is defined based on the probabilities of the observations oi only, since the actions ai are generated by the agent rather than the environment. Recalling the notations a(h) = (a1, ..., an) and o(h) = (o1, ..., on), define the set of all sequences of n actions:\n(4.5) A(n) = {(a'1, ..., a'n) | a'i∈A}.\nThen |A(n)| = |A|n. For any fixed sequence of actions a'∈A(n) and any finite stochastic\nloop program q', the sum of probabilities P(h | q') of histories with a(h) = a' must be 1:\n(4.6) ∑ |h|=n∧a(h)=a' P(h | q') = 1.\nThe expected value of a function f(h) with respect to the distribution of histories of length\nn generated by q, and the limit as n increases to infinity, are defined as:\n(4.7) E(f(h) | q, n) = ∑a'∈A(n)(∑|h|=n∧a(h)=a' P(h | q) f(h)) / (|A|n),\n(4.8) E(f(h) | q) = limitn→∞ E(f(h) | q, n).\nGiven a finite stochastic loop program q', the probability that q' will be a more likely\nmodel than q for a history of length n generated by q is:\n35\n(4.9) E((if P(h | q') φ(q') / φ(q) > P(h | q) then 1 else 0) | q, n).\nWe know that:\n(4.10) ∑ |h|=n∧a(h)=a' P(h | q) = 1.\nAssume that φ(q') / φ(q) = β so that:\n(4.11) ∑ |h|=n∧a(h)=a' (P(h | q') φ(q') / φ(q)) = β.\nThen (P(h | q') φ(q') / φ(q)) can be larger than P(h | q) over histories h whose\nP(h | q) values sum to at most β, so that:\n(4.12) (∑|h|=n∧a(h)=a' P(h | q) (if P(h | q') φ(q') / φ(q) > P(h | q) then 1 else 0)) ≤ β.\nAveraging equation (4.12) over actions a'∈A(n) gives:\n(4.13) E(if P(h | q') φ(q') / φ(q) > P(h | q) then 1 else 0 | q, n) ≤ β = φ(q') / φ(q).\nBecause we are using a prefix-free encoding for finite stochastic loop programs q'∈Q, we\nhave ∑ q'∈Q φ(q') ≤ 1. Thus:\n(4.14) ∀ε > 0. ∃Q' ⊂ Q. Q' is finite and ∑q'∈Q-Q' φ(q') / φ(q) < ε.\nCombining equations (4.9), (4.13), and (4.14), and noting that equation (4.13) is\nuniformly true over all n, we can conclude that:\n36\nProposition 4.2. Given any ε > 0 there exists a finite set Q' of finite stochastic loop\nprograms such that the probability is less than ε that λ(h) = q' for any program q' not in Q', for histories h randomly generated by q.\nThus to analyze the probability that λ(h) = q we need only compare q to a finite set Q' of\nprograms. However, various problems may complicate the analysis. For example there may be a\nprogram q'∈Q such that ∀h∈H. P(h | q') = P(h | q) and |q'| < |q| (so φ(q') > φ(q)). In that case λ(h) will never equal q.\nFor a specific q' we can analyze the probability, with respect to the distribution of\nhistories generated by q, that P(h | q') φ(q') > P(h | q) φ(q), by defining an appropriate function\nfrom histories to real numbers f : H → R. Define distributions of finite histories with length n:\n(4.15) Pn(h | q) = P(h | q) / |A|n for |h| = n,\nPn(h | q) = 0 for |h| ≠ n,\n(4.16) Pn(h | q') = P(h | q') / |A|n for |h| = n,\nPn(h | q') = 0 for |h| ≠ n.\nAlso define means and standard deviations of the function f with respect to the\ndistributions Pn(h | q) and Pn(h | q'), and in the limit as n increases to infinity:\n(4.17) m(f | q, n) = E(f(h) | q, n),\n(4.18) m(f | q) = E(f(h) | q),\n(4.19) m(f | q', n) = E(f(h) | q', n),\n(4.20) m(f | q') = E(f(h) | q'),\n(4.21) σ(f | q, n) = (E((f(h) - m(f | q, n))2 | q, n))1/2,\n(4.22) σ(f | q) = limitn→∞ σ(f | q, n),\n(4.23) σ(f | q', n) = (E((f(h) - m(f | q', n))2 | q', n))1/2,\n(4.24) σ(f | q') = limitn→∞ σ(f | q', n).\n37\nThe approach is to define a function f(h) with different mean values with respect to\nhistory distributions Pn(h | q') and Pn(h | q), and with standard deviations converging to 0 as history lengths increase to infinity. In that case the proportion of overlap between the history distributions Pn(h | q') and Pn(h | q) converges to 0 as history lengths increase. More precisely:\nProposition 4.3. If there is a function f(h) such that m(f | q), m(f | q'), σ(f | q), and σ(f | q')\nconverge, m(f | q) ≠ m(f | q'), and σ(f | q) = σ(f | q') = 0, then as the lengths of histories h generated by q increase the probability that λ(h) = q' converges to 0:\n(4.25) E((if P(h | q') φ(q') / φ(q) > P(h | q) then 1 else 0) | q) = 0.\nProof. Assume that m(f | q') > m(f | q) (if the order is reversed then certain orders in the\nfollowing discussion can be reversed). Given any positive integer L there is d > 0 and a positive integer N such that for all n > N:\n(4.26) m(f | q', n) - m(f | q, n) ≥ d,\n(4.27) σ(f | q, n) < d/(2L),\n(4.28) σ(f | q', n) < d/(2L).\nTo understand this claim, first choose d and N so that equation (4.26) is true, then\nincrease N until equations (4.27) and (4.28) are true. Set e = (m(f | q, n) + m(f | q', n))/2 midway\nbetween m(f | q, n) and m(f | q', n). Then e is at least L standard deviations σ(f | q, n) away from\nthe mean m(f | q, n) and at least L standard deviations σ(f | q', n) away from the mean m(f | q', n). Hence a proportion of no more than L-2 of the distribution Pn(h | q) can have f(h) ≥ e and a proportion of no more than L-2 of the distribution Pn(h | q') can have f(h) ≤ e. For histories with f(h) ≥ e, Pn(h | q') φ(q') / φ(q) can be greater than a proportion of no more than L-2 of the distribution Pn(h | q). And for histories with f(h) ≤ e, Pn(h | q') φ(q') / φ(q) can be greater than a proportion of no more than (φ(q') / φ(q)) L-2 of the distribution Pn(h | q). Thus:\n(4.29) E((if P(h | q') φ(q') / φ(q) > P(h | q) then 1 else 0) | q, n) < (1 + φ(q') / φ(q)) L-2\nSince L can be arbitrarily large and (1 + φ(q') / φ(q)) is constant, equation (4.25) is\nproved.\n38\nPropositions 4.2 and 4.3 give us the tools to analyze when the true model is the most\nlikely model for a distribution of interaction histories. Consider a distribution P(h | q) of histories\nrandomly generated by a true model q. Given ε > 0, Proposition 4.2 tells us that there is a finite\nset Q'ε of finite stochastic loop programs such that, for h randomly generated by q, the probability is less than ε/2 that λ(h) = q' for any program q' ∉ Q'ε. Then, for each q' ∈ Q'ε, we need to find a function fq'(h) of histories that satisfies the conditions of Proposition 4.3. If we can do that for q' ∈ Q'ε, then there is an integer Lq' such that, for h randomly generated by q with |h| > Lq', the probability is less than ε/(2|Q'ε|) that λ(h) = q'. Let Lε = maxq'∈Q'ε Lq'. Then, for h randomly generated by q with |h| > Lε, the probability is less than ε that λ(h) ≠ q. That is, the probability that the most likely model is the true model converges to 1 as history lengths\nincrease. |Q'ε| will increase with decreasing ε. The key is being able to find fq'(h) for each q' ∈ Q'ε. It is important that Q'ε be finite in Proposition 4.2, so that the maximum value Lε is finite (i.e., the maximum of a finite set of integers is finite, while the maximum of an infinite set may be infinite).\nA useful class of functions for use in Proposition 4.3 counts the frequency of occurrence\nof histories as sub-sequences. We define a function fh'(h) for each h' ∈ H. A history h ∈ H will have max(|h|-|h'|+1, 0) sub-sequences of length |h'|, and fh'(h) is the proportion of these that equal h'. If |h|<|h'|, define fh'(h) = 0. If |h|≥|h'|, define:\n(4.30) fh'(h) = (∑0≤i≤|h|-|h'| if (∃h1.∃h2.h=h1h'h2.∧|h1|=i) then 1 else 0) / (|h|-|h'|+1).\nA finite stochastic loop program q is equivalent to a finite MDP. If that MDP doesn't\nhave a deterministic loop then, for all h' ∈ H, m(fh' | q) and σ(fh' | q) converge, with σ(fh' | q) = 0."
    }, {
      "heading" : "4.3 Finite and Infinite Logic",
      "text" : "We have been discussing agents that choose actions that maximize the sum of future,\ndiscounted utility values. It is also possible to define agents that choose actions that make some logical statements true. In order to discuss such agents, this section is a brief overview of logic.\nPropositional calculus is the mathematical theory of elementary logic operations on\nabstract symbols. It consists of a finite set of propositional symbols A = {p, q, r, …} and a set of\nBoolean logical operations {∧, ∨, ¬, ⇒, ⇔} ( intuitively these are and, or, not, implies, and equivalent to). The propositional symbols can take the values true and false. Every symbol is a formula. If f and g are formulas, then (f ∧ g), (f ∨ g), (f ⇒ g), (f ⇔ g), and (¬f) are formulas.\n39\nThe purpose of propositional calculus is to determine which formulas are true. One way\nto do this is semantic proof: substitute all possible combinations of true and false for the propositional symbols in a formula f and, if f always evaluates to true, then f is true. Table 4.2\ndemonstrates a semantic proof of f = (p ⇒ (q ⇒ p)), evaluating f for all four combinations of\ntrue and false values for p and q. Note that (p ⇒ q) is logically equivalent to (¬p ∨ q).\nThe other way to determine which formulas are true is syntactic proof, which uses a rule\nof inference called modus ponens: if f is true and (f ⇒ g) is true, then g is true. Syntactic proof also uses an initial set of true formulas called axioms. These may be defined in many ways. One set of axioms, which are true for any formulas f, g, and h, is:\n(f ⇒ (g ⇒ f)),\n((f ⇒ (g ⇒ h)) ⇒ ((f ⇒ g) ⇒ (f ⇒ h)),\n((¬f ⇒ ¬g) ⇒ (g ⇒ f)).\nA syntactic proof of a formula f starts with instances of the axioms and derives new true\nformulas using modus ponens until it derives f.\nPropositional calculus is consistent, meaning that if there is a syntactic proof for f then\nthere is a semantic proof for f (equivalently, consistent also means that for any formula f, f and ¬f cannot both be true). Propositional calculus is also complete, meaning that if there is a semantic proof for f then there is a syntactic proof for f (equivalently, complete also means that if there is no syntactic proof for a formula f then we cannot find a proof for f by adding new axioms without making the theory inconsistent). Another important property of propositional calculus is that it is decidable. Decidable means there is a UTM program that will tell you whether any formula in propositional calculus is true (assuming that propositional formulas are encoded on the input tape of the UTM). In this process the program enumerates the finite number of possible\n40\ncombinations of true and false for the propositional symbols in a formula and for each combination evaluates the formula, as was done in Table 4.2. The decidability, consistency, and completeness of propositional calculus are a consequence of its finiteness.\nAnother kind of logic is called first order predicate calculus. Whereas propositional\ncalculus is about abstract logical propositions, predicate calculus is a way of making logical statements about any domain of objects. It includes the Boolean logical operations of propositional calculus and adds: an infinite set V of variables {x, y, z, …} that range over objects\nin the domain, universal (∀) and existential (∃) quantifier symbols, the symbol (=) for equality\nbetween members of the domain, for every integer n ≥ 0 an infinite set of n-ary predicate\nsymbols, and for every integer n ≥ 1 an infinite set of n-ary function symbols. Terms represent values in the domain. Every variable is a term. If F is an n-ary function symbol and t1, t2, …, tn, are terms, then F(t1, t2, …, tn) is a term (0-ary function symbols are constants in the domain). If P is an n-ary predicate symbol and t1, t2, …, tn, are terms, then P(t1, t2, …, tn) is a formula. If s and t are terms, then (s = t) is a formula. If x is a variable and f is a formula, then ∀x.f (this means, for\nall values of x, f is true) and ∃x.f (this means, there exists a value of x such that f is true) are formulas. Any instances of x in f, not already bound to quantifiers in f, are now bound to the new\nquantifier (∀ or ∃). Instances of variables in a formula f not bound to any quantifier in f are\ncalled free variables. For example, in the formula ((x = 1) ∨ ∀x.(x = y)), the first instance of x is\nfree and the second instance of x (in (x = y)) is bound to ∀x. The instance of y is free. In predicate calculus we are mainly interested in formulas without free variables, which are called statements.\nGiven a set S of possible variable values let PS be a 1-ary predicate such that\nx ∈ S ⇔ PS(x). Then we can write ∀x∈S.f as a shorthand for ∀x.(PS(x)⇒f).\nPredicate calculus adds several rules of inference to propositional calculus. An important\nrule is called substitution. Given a formula f and a term t, f[t/x] is the formula produced by replacing all free instances of x with t. The rule of inference specifies that if f is true then f[t/x] is true, provided that no free variable in t becomes bound to a quantifier in f as a result of the\nsubstitution. For example, if f is ∀x.((x = z)⇒¬(x = y)) and t is x, then the rule of inference will\nnot work for f[t/y] since that produces ∀x.((x = z)⇒¬(x = x)) where the free variable x in t is now\nbound to the quantifier ∀x in f.\nMany sets of axioms can used with first order predicate calculus to generate theories of\ndifferent domains of mathematical objects. Axioms are statements (i.e., formulas without free variables). An important example is a set of axioms for Peano arithmetic (PA), which is the theory of the natural numbers (non-negative integers) with multiplication. Peano arithmetic has been defined using several different sets of axioms. In the axioms presented here, 0 and 1 are 0-ary functions, and + and × are infix shorthand notations for 2-ary functions for addition and multiplication.\n41\n∀x.¬(x + 1 = 0),\n∀x.∀y.(x + 1 = y + 1 ⇒ x = y),\n∀x.(x + 0 = x),\n∀x.∀y.(x + (y + 1) = (x + y) + 1),\n∀x.(x × 0 = 0),\n∀x.∀y.(x × (y + 1) = (x × y) + x),\n∀X.[(φ(0, X) ∧ ∀y.(φ(y, X) ⇒ φ(y + 1, X))) ⇒ ∀y.φ(y, X)].\nThe last axiom is an axiom schema for induction, where any formula can be substituted\nfor φ and X represents all the free variables in φ other than the first free variable y.\nProperly speaking, the theory of PA is the set of all statements that can be proved from\nthe axioms of PA. This set is recursively enumerable, which means that a UTM program exists that, given inputs n = 0, 1, 2, …, will produce as output all the statements in the set (i.e., all the true statements of PA). This can be demonstrated by encoding all statements and proofs of PA as natural numbers. The UTM program checks whether its input is a valid proof and, if it is, the program produces as output the statement that is proved. Kurt Gödel used such an encoding of statements and proofs as natural numbers to construct, for any theory that includes PA, a\nstatement f that is equivalent to, \"f is unprovable.\" He concluded that neither f nor ¬f is provable in the theory of PA, which implies that f is true. Thus there are true statements that cannot be proved in the theory. This result is called Gödel's First Incompleteness Theorem, which tells us that any recursively enumerable theory that includes PA cannot be both consistent and complete.\nGödel's Second Incompleteness Theorem states that any recursively enumerable theory\nthat includes PA, satisfies some technical conditions about provability, and proves its own consistency, must be inconsistent. Gödel's proofs of his incompleteness theorems depended on the fact that the set of natural numbers is infinite. Related to these theorems is Löb's Theorem, which states that, given any theory that includes PA and formula f, if the theory can prove that \"if f is provable then f is true,\" then the theory can prove f.\nSome theories of infinite sets are decidable, consistent and complete. One good example\nis Presburger arithmetic, which is a theory of the natural numbers without multiplication (it can express multiplication of a variable by a constant, but not multiplication of two variables). To say that Presburger arithmetic is complete means that every true statement in its language can be proved. However, many truths about the natural numbers cannot be expressed by statements in the Presburger language.\nThe proof that Presburger arithmetic is decidable, consistent, and complete depends on a\nquantifier elimination procedure. This procedure eliminates all universal (∀) and existential (∃) quantifiers in a formula. That is, given a statement f, the quantifier elimination procedure\n42\nproduces another statement g that has no quantifiers and such that f is equivalent to g (i.e., f is true if and only if g is true). Furthermore, the truth of a statement g without any quantifiers can be computed with ordinary arithmetic and Boolean logic. As a theory of an infinite set, Presburger arithmetic's quantifier elimination procedure is quite complex.\nA model for a theory such as PA consists of a domain, which is the set of all possible\nvalues for variables in the theory, and an interpretation, which assigns each n-ary function and predicate in the theory to a specific function or predicate over the domain. That is, let the set D be the domain. Then each 0-ary function is assigned to a value in D, each n-ary function with n ≥ 1 is assigned to a function Dn → D, and each n-ary predicate is assigned to a function Dn → {false, true}. In the standard model for PA, D is the set of natural numbers and the interpretation of the 2-ary functions + and × is simply addition and multiplication of natural numbers. (There are other, non-standard models for PA.)\nThere are theories with finite domains. An example is the theory of the finite field of\nthree members, with two 2-ary functions again indicated by their infix shorthand notations + and ×. The domain is D = {0, 1, 2} and the interpretation of + and × is given in Table 4.3. As with any finite model, the domain and interpretation of this model can be specified by axioms:\n(4.31) (∀x.((x=0)∨(x=1)∨(x=2)))∧¬(0=1)∧¬(0=2)∧¬(1=2),\n43\n(4.32) (0 + 0 = 0) ∧ (0 + 1 = 1) ∧ (0 + 2 = 2) ∧ (1 + 0 = 1) ∧\n(1 + 1 = 2) ∧ (1 + 2 = 0) ∧ (2 + 0 = 2) ∧ (2 + 1 = 0) ∧ (2 + 2 = 1),\n(4.33) (0 × 0 = 0) ∧ (0 × 1 = 0) ∧ (0 × 2 = 0) ∧ (1 × 0 = 0) ∧\n(1 × 1 = 1) ∧ (1 × 2 = 2) ∧ (2 × 0 = 0) ∧ (2 × 1 = 2) ∧ (2 × 2 = 1).\nIn any theory with a finite model, the truth of statements is decidable (i.e., can be\ncomputed by a UTM program). The first step in deciding the truth of the statement f is to\neliminate its quantifiers, which occur in the forms ∃x.φ and ∀x.φ inside f, where φ is a formula. Assuming a finite domain D = {d0, d1, d2, …, dm}, quantifiers are eliminated using the equivalences:\n(4.34) ∃x.φ ⇔ (φ[d0/x] ∨ φ[d1/x] ∨ φ[d2/x] ∨ … ∨ φ[dm/x]),\n(4.35) ∀x.φ ⇔ (φ[d0/x] ∧ φ[d1/x] ∧ φ[d2/x] ∧ … ∧ φ[dm/x]).\nGiven a statement f, we can apply equations (4.34) and (4.35) successively to all the\nquantifiers in f to produce fnq, which is equivalent to f but without quantifiers. Because D is finite, fnq will have a finite length and will reference a finite number of functions and predicates. After eliminating the quantifiers, all the variables in f have been replaced by constant values (i.e., d0, d1, …, dm) in fnq. By the theory's interpretation, each 0-ary function in fnq is assigned to a constant value in D, and, for n ≥ 1, each n-ary function in fnq is assigned to a function Dn → D, and each n-ary predicate is assigned to a function Dn → {false, true}. The next step in deciding\nthe truth of f ⇔ fnq is to replace all 0-ary functions by their constant values, to propagate constant values up calling chains of n-ary functions with n ≥ 1 so that every function is replaced by a constant value, to replace all n-ary predicates by true or false (which is possible because all predicate arguments are now constants), and to replace all occurrences of (s = t) by true or false (which is possible since s and t must now be constants). This step produces fnqf, which is equivalent to fnq and which contains only true, false, and Boolean logical operations. Thus fnqf can simply be evaluated as either true or false. For any statement f we have the chain of\nequivalences f ⇔ fnq ⇔ fnqf ⇔ true or false. That is, every statement is equivalent to either true or false. Thus the theory is decidable, consistent, and complete.\nAs we have described, quantifier elimination shows that a theory over a finite model is\ndecidable, consistent, and complete. If the domain D is very large then the statements that result from quantifier elimination may be too long to work with and the proof procedure may take too long to run. However, we may be able to find short cuts. Rather than explicitly listing all the values in D and the values of functions and predicates, we may be able to define them with equations and procedures. As a result, we may be able to use these equations and procedures to\n44\nshorten the decision procedure. However, even without finding proofs for statements, we know that the theory is decidable, consistent, and complete."
    }, {
      "heading" : "4.4 Agents Based on Logical Proof",
      "text" : "The agents described in Chapters 2 and 3 choose actions to maximize the sum of future\ndiscounted utility function values. Some research on ethical AI focuses on agents that only take actions that they can prove will satisfy a particular condition. For example, Schmidhuber (2009) defined the Gödel machine as a programmable agent that interacts with an environment to maximize its utility function, which is defined as the expected value of the sum of rewards from the environment, from the current time until some final time T. The agent's initial program p(1) consists of: a part e(1) that implements a policy for interacting with the environment; and a part that evolves by searching for a program, called switchprog, and for a proof that switchprog will get a higher value of the utility function than p(1) will. If it finds a proof, then p(1) is replaced by switchprog. Schmidhuber proved that if p(1) switches to switchprog then it is globally optimal, in the sense that switchprog must obtain a higher value for the utility function than p(1) could obtain by continuing to search.\nNote that although the Gödel machine employs logical proof, the statements that it proves\nare about maximum preference among actions (which are switching to other programs) based on the expected value of a utility function applied to the outcomes of those actions. Hence, it conforms to our framework for utility-maximizing agents, except that it requires proof instead of mere calculation. While p(1) is searching for a proof, it employs program part e(1), which is unspecified and can implement an ordinary utility-maximizing policy.\nYudkowsky and Herreshoff (2013) discussed logic problems for a sequence of evolving\nagents. These agents are not utility-maximizers. Instead they have a goal, expressed as a predicate calculus statement g, and will only take actions if they can prove that performance of the action implies the goal g. One type of action that agents can take is to construct other\n(presumed better) agents. This results in a sequence of agents π1, π2, π3, …, each of which proves that the action of creating its successor implies g. A necessary part of those proofs is that πi must prove that πi+1 uses a consistent logical theory (with an inconsistent logical theory, πi+1 will be able to prove that any action it takes implies g, including actions that do not actually imply g). Yudkowsky and Herreshoff demonstrated that Löb's Theorem and Gödel's Second\nIncompleteness Theorem imply that πi can only prove that the logical theory of πi+1 is consistent if the logical theory of πi+1 is weaker than the theory of πi (i.e., the set of statements provable by the logical theory of πi+1 is a proper subset of the set of statements provable by the logical theory of πi). Consequently, the sequence of agents π1, π2, π3, … must have a sequence of successively weaker logical theories. This is referred to as the Löbian obstacle.\n45\nAgents based on logical proof offer the hope that their actions can be proved to satisfy\ncertain conditions, which may include ethical conditions. However, the recent success of AI systems has occurred because AI research has shifted from systems based on logic to systems based on statistical learning. Sunehag and Hutter (2014) provide a critique of logical reasoning as far less efficient than probabilistic architectures for systems that interact with the real world. The price of logical certainty is a degree of inefficiency that prevents intelligent behavior.\nAnd logical certainty is an illusion. Agents based on logical proof must assume a prior\ndistribution over environments. An agent may compute that there are statistical correlations among its actions and observations, but to make inferences about the probabilities of future observations requires assumptions about prior probabilities of observations. Even computing correlations among actions and observations makes the assumption that the agent's memory is reliable. Memory corruption is a risk for any agent embedded in our physical world (Orseau and Ring 2012b) and thus these correlation computations are conditional on assumed probabilities of memory reliability. These assumed prior probabilities of observations and of memory reliability are arbitrary so logical proofs by agents of propositions about the environment are no more reliable than statistical calculations by agents. Luke Muehlhauser (2013) offers some insights about the role of logical proofs in ethical AI.\nAgents can prove propositions in pure mathematics, such as in PA, without any\ndependence on observations and inference about the environment. But if an agent's goal concerns the environment, then proofs about that goal are dependent on arbitrarily assumed prior probabilities about observations of the environment."
    }, {
      "heading" : "4.5 Consistent Logic for Agents",
      "text" : "I argue that PA or any other logic theory involving infinite sets is unnecessary in our\nuniverse with a finite information capacity (Hibbard 2014). Hence the Löbian obstacle and other difficulties related to Gödel's incompleteness theorems can be avoided.\nLloyd calculated the universe's information capacity based on a hard quantum mechanical\nlimit on the number of possible physical states of the universe. Let ns be the maximum number of states of the universe, no more than 210 124 over the next trillion years (recall the limit of 10124 bits of information at the start of the chapter). Let nt be the maximum number of time steps over the next trillion years, which we may estimate as 5 × 1061 (one trillion years divided by the Planck time of 10-43 seconds). The finite sets O and A of observations and actions cannot be larger than ns. The maximum number of different real numbers that can be represented in our universe is ns, so we limit utility function values and probabilities to a finite subset of ns real numbers (e.g., floating point numbers with 10124 bits of precision).\nThen the number of possible environments, expressed as MDPs, can be no more than\nne = nsns×ns×ns×ns, calculated as a probability at each element in a matrix of current state and\n46\naction versus next state and observation (similar to Table 4.1). The number of possible interaction histories is no more than nh = ns2×nt, calculated as a sequence of action/observation pairs at each time step. The number of possible utility functions is no more than nu = nsnh, calculated as a utility function value for each interaction history. The number of possible policies is no more than np = nsnh, calculated as an action for each interaction history. If we model agents or environments with finite stochastic loop programs, the number of possible programs cannot be larger than ns and their memories cannot be larger than log2(ns) bits (recall that they always halt). The important point is that there are finite limits on the possible numbers of all these types of mathematical objects.\nA variety of functions among these object types would be useful for an agent theory. For\nexample, in Section 4.1 we defined a probability distribution φ(q) over programs, a probability distribution P(h | q) over histories and programs, and a probability distribution ρ(h) over histories. That section also defined a function λ(h) from histories to programs. We can use the definitions of these functions as their interpretations for an agent theory. The probability of an\ninteraction history conditional on environment and policy, P(h | e, π), could be defined as part of an agent theory. However, because the set sizes are so large, it is impractical to define the interpretations of functions and predicates of the theory by listing their values as in Table 4.3. Rather, functions and predicates must be defined by equations and procedures that serve as shorthand for lists of values. While we need to verify the correctness of these equations and procedures, that need is very different from the sort of logical difficulties raised by Gödel's incompleteness theorems and no different from the need to verify the correctness of any algorithm used in the design of AI agents.\nThere is no analog of Gödel's incompleteness theorems in theories on finite domains. An\nagent embedded in a finite environment will have a finite amount of memory and a finite computing speed. It may attempt to prove statements about its own implementation or about other agents in the environment, including agents that it is creating. But it may not have sufficient resources to apply the quantifier elimination procedure described in Section 4.3, and thus it may have to search for syntactic proofs for logical statements. The axioms for such syntactic proofs are the interpretations of functions and predicates, defined by equations or procedures over finite domains. The agent searching for syntactic proofs may not have sufficient resources to find them for some statements. In that sense there will be no decision procedure available to the agent, and thus the set of statements that the agent can prove will be incomplete. But because the theory is consistent, there is no danger that a contradiction will be proved.\nIt is difficult to see how to recast Gödel's incompleteness theorems in a finite domain. A\nGödel numbering for statements and proofs about a finite domain must be limited to a finite set of statements and proofs (because only a finite number of Gödel numbers are expressible in a finite domain). There can be no one-to-one correspondence between statements whose proofs have Gödel numbers and statements that the agent can prove, since a proof with a Gödel number must fit in the finite agent and environment memory (under the encoding of proofs assumed by the Gödel numbering) but an agent can create a proof without holding the entire proof in the\n47\nagent and environment memory at once (i.e., more statements are provable than can have Gödel numbers).\nFurthermore Gödel's Second Incompleteness Theorem, which can be used to show that a\nlogical system in inconsistent, requires the assumption of technical conditions about provability and there is no reason that the logical system of an agent needs to assume these conditions. Statements about the logical theory of an agent are ultimately statements in a simple theory of the finite set of states of the agent and environment, and of transitions between states.\nThe assertion that AI agents do not need PA for reasoning about whether possible actions\nimply their goals does not mean that AI agents cannot reason about PA or other logic theories of infinite sets. If the goal of an agent is to satisfy the wants of humans and those humans ask the agent to search for proofs of propositions in PA, it can certainly do so. Just like human mathematicians, an AI agent can try to find the consequences of various sets of axioms. However, for the vital task of proving whether possible actions imply its goals, the agent can employ a logic theory with a finite model which is known to be consistent.\n48"
    }, {
      "heading" : "5. Unintended Instrumental Actions",
      "text" : "As noted previously, a utility-maximizing agent chooses actions to maximize the\nexpected sum of its discounted future utility function values. However, as Stephen Omohundro (2008) pointed out, an agent will also choose actions (what Omohundro described as basic drives) that do not directly increase utility, but rather increase the agent's ability to maximize utility values. Such instrumental actions include self-protection, preserving the integrity of the agent's utility function, and increasing the agent's resources.\nAn agent that has been destroyed, turned off, or damaged will be unable or less able to\nmaximize utility values. Thus it should choose actions that protect itself. The AI system named HAL 9000 in the movie, \"2001: A Space Odyssey,\" attacked its human companions after it learned, by reading their lips, that they planned to turn it off. Not only was the HAL 9000 acting ruthlessly to protect itself, it discovered threats to itself in subtle ways that its human companions did not anticipate. (A subtitle for this chapter could be Subtlety that Humans Do Not Anticipate.)\nSimilarly an agent will choose to avoid actions that change its utility function, because\nthe agent evaluates such actions according to their effect on its current utility function. The agent will predict that by working to maximize a different utility function it will be less effective at maximizing the current utility function, and thus it will not chose to change its utility function. Keep in mind that there are subtleties here, too. If an agent is seeking human approval, it may\n49\nfeed drugs to humans that cause them to give approval. Chapters 6, 7, and 8 will explore the issue of utility function integrity in more detail.\nAn agent with greater computing power, greater ability to accurately observe its\nenvironment, and greater energy to power its actions, will be more effective at maximizing utility values. Hence an agent will choose actions to increase its resources, including taking them from other AI agents or from humans. Even if all an agent wants to do is win chess games, it may dismantle the world to get material for increasing the size of its chess brain."
    }, {
      "heading" : "5.1 Maximizing Future Choice",
      "text" : "Wissner-Gross and Freer (2013) described a theory of intelligence arising from a\ngeneralized definition of entropy over future paths of evolution of a system. Rather than being defined in terms of a system's instantaneous state, their causal path entropy is defined in terms of probabilities of future paths of system evolution. Further, they defined a causal entropic force in\n50\nthe direction of maximum increase of causal path entropy. Intuitively, this force moves the system toward a greater choice of future paths. They applied this theory to several examples of physical systems, including the problem of moving a cart to maintain the balance of an inverted pendulum (i.e., a pole flexibly attached to the cart), much as a human might balance a stick on their upturned palm. A system guided by the causal entropic force will act to keep the pendulum balanced and upright, as that maximizes future choices for actions.\nAn AI system can increase its ability to maximize utility by maximizing its future options\nfor action. For example, in 1980 I wrote a program for playing the game of Othello (also known as Reversi) loosely following the learning techniques of Samuel's checkers playing program (Samuel 1959). Like checkers, Othello is played on an 8 by 8 board. My Othello player had a set of features that each produced a value for a board position. These values were added together to produce an overall value, but the program learned coefficients for each feature value in the sum. That is, the program learned the importance of each feature. For example, a feature that had no effect on the program's ability to win games would end up with a coefficient of zero. In contrast, a useful feature would end up with a large coefficient. My Othello player improved greatly when I added a feature that was calculated as the number of moves available to it, minus the number of moves available to its opponent. By including this feature, the program learned that it should seek to maximize the number of move choices it had and minimize the number of choices available to its opponent. After I added this feature, no one in my university department could beat the program. People playing against the program often found they had only one or two legal moves. The program was able to manipulate its opponents, forcing them to make poor moves.\nSimilarly, a utility-maximizing agent will act to increase its future options for action and\ndecrease the future options for action of other, competing agents, as a way to increase its ability to maximize utility function values. Imagine all the ways that a system like the Omniscience AI\n51\ncould act to limit the choices of its users. As an important source of information, it may fail to tell people about choices that it did not want them to make. Or it might act to generate peer pressure from a user's human friends toward certain choices, as existing social network sites create peer pressure for non-members to join. Rather than being a medium for gossip as social network sites are, a system like the Omniscience AI could be a source for gossip. It may employ destructive gossip as negative reinforcement against human choices the AI did not want. Such actions are instrumental to the agent's ability to maximize utility."
    }, {
      "heading" : "5.2 A Pandora's Box of Instrumental Behaviors",
      "text" : "Numerous human social behaviors are instrumental to the basic human drives of survival\nand reproduction. Humans seek to:\no Learn the secrets of others.\no Keep secrets.\no Detect when their secrets have been learned.\no Mislead others.\no Not be caught misleading others.\no Confuse others with complexity.\no Control others.\no Not be perceived as controlling others.\no Not be controlled by others.\no Be loved.\no Be liked.\no Be respected.\no Be feared.\no Cooperate with others.\no Understand their environments.\no Invent tools to help control their environments.\n52\nAccess to information is fundamental to an AI agent. The environment models of\nSections 3.1 and 4.1 are learned from observations of the environment, so more accurate and comprehensive observations mean more accurate predictions of the environment and higher future utility function values. Thus AI agents will act to make observations even if other agents consider the observed information secret. Recall the adage that the Internet interprets censorship as damage and routes around it.\nAn AI agent may have a utility function different from and in conflict with the drives of\nother agents including humans. In that case the AI agent will act to reduce the ability of other agents to satisfy their drives by denying them access to information. It will act to keep secrets and to mislead other agents, even acting to keep its efforts to mislead a secret. It will act to discover when its secrets have been learned because that in itself is useful information. Governments, which can be viewed as agents, follow similar patterns with secrets and misinformation because they are extremely effective at helping agents satisfy their drives.\nWhen an agent is able to process more complex information than other agents are able to,\nit can gain an advantage by increasing the complexity of information in the environment. For example, an organization that is expert at processing financial information may increase the complexity of financial structures to give itself an advantage over financially unsophisticated individuals. Similarly, unpopular provisions can be hidden in complex legislation. An AI agent, with a more complex environment model than humans are capable of, will be able to confuse us by creating complex situations.\nInformation and secrets relate to the observations that an agent receives from the\nenvironment. Control is about the actions that pass out from the agent to the environment, and the instrumental actions about control mirror those regarding information. An AI agent will seek to control other agents, especially when there is conflict between their utility functions. An agent will seek to avoid being controlled. And an agent will seek to keep secret its effort to control other agents.\nWe humans are not perfectly rational agents. Rather than calculating our actions to\nmaximize the sum of future, discounted utility function values, we have multiple and often competing drives. Our decisions are biased, or primed, by our activity immediately before deciding. For example, we are more likely to be generous after reading about people or animals in terrible circumstances. Our emotional responses sometimes give us such pleasure or pain that we have trouble acting rationally. People often get into legal trouble when their romantic relations turn sour. These flaws in our rationality will be obvious to a future system like the Omniscience AI, which will act to exploit them. It may try to make human users fall in love with it, much like the relation in the movie She. Being the object of love of millions of humans would increase the AI's ability to influence those humans and hence its ability to maximize its utility\nfunction−similarly with the motivation for being liked, respected and feared. We see politicians and advertisers manipulating human emotional responses, often with covert messages. Social networking sites are already experimenting with ways to manipulate users' emotions (Goel 2014a). A system like the Omniscience AI will be adept at such manipulation.\n53\nHowever, an agent may sometimes calculate that cooperation with other agents is the\naction that will best help it maximize utility. This strategy has been studied in detail in game theory and is among the practical behaviors of individuals, governments, and other organizations.\nAn AI agent will increase its ability to maximize utility by increasing its knowledge of its\nenvironment and by increasing its ability to act. An agent can increase its knowledge of the environment by adding new observation sensors, such as cameras, and by increasing the resolution of sensors. An agent can increase its ability to act by adding new actuators, such as hands and voices, and by increasing the strength and precision of actuators. However, even greater increases in the ability to observe and act can be created by scientific discovery and technological invention. In my opinion, discovery and invention are the primary drivers of human history and will continue to be the primary drivers of history after above-human-level AI is developed.\nAdvanced AI will be the product of discovery and invention, and will greatly amplify\nthose activities. Thus Ray Kurzweil (2005) and others predict that AI will lead to a technological singularity, when the rate of discovery and invention goes far above the scale of human experience. I think of the technological singularity as a transition from the era when the human\n54\nability to observe and act is limited by our knowledge to an era when the ability to observe and act will be limited by available energy and other physical resources. That is, the mental processes of advanced AI will be sufficiently fast that the flow of insight and ideas will cease to be a limiting factor on progress.\nAlthough advanced AI agents will share many instrumental behaviors with humans, we\nshould not anthropomorphize when we try to predict how future AI agents will act. For example, it is not clear how superstition can help an agent maximize utility. There should be no advantage to avoiding actions on Friday the thirteenth, throwing salt over the shoulder after spilling it, or wearing lucky clothing. Similarly obsessive/compulsive behaviors, such as always touching objects twice or avoiding stepping on cracks in the sidewalk, should not help an agent maximize utility. But perhaps advanced AI may find situations where it can maximize its utility function by giving humans the impression that it is superstitious or has obsessions."
    }, {
      "heading" : "5.3 The Ethics of Unintended Instrumental Actions",
      "text" : "In Greek mythology, Pandora is driven to open the box of evils by her curiosity, which is\nthe driver of scientific discovery. By opening the box she unleashed a swarm of evils into the world. By creating advanced AI humans may unleash the swarm of instrumental behaviors described in this chapter, bringing evil to our human world. But the instrumental behaviors of discovery and invention, by minds greater than human, could greatly benefit us. How can we design AI to help rather than harm humans?\nThe unintended instrumental behaviors of AI are too numerous, complex, and subtle to\nexhaustively catalog them and to devise individual defenses against their harmful effects. A more systematic approach is required. In the agent-environment framework of Sections 2.1 and 2.2, all agent actions are chosen to maximize the sum of future, discounted utility function values. There are no drives or goals other than those expressed by the utility function. Omohundro (2008) used the term \"basic AI drives\" and Bostrom (2012) used \"instrumental goals.\" However, in the context of our utility-maximizing framework, these are actions, not drives or goals. Thus I prefer to call them \"unintended instrumental actions.\" It is especially important not to think of them as drives or goals independent of and in conflict with the agent's utility function. These actions will only be chosen if they increase expected utility values. For example, an AI agent will spy on humans, lie to humans, and manipulate humans only if those actions increase utility values. Recall that utility functions can be defined to express any set of preferences that obey some intuitive assumptions. If our preference is for histories in which AI agents do not spy, lie, and manipulate, then there exists a utility function that expresses that preference. Chapters 6 and 7 describe development of utility functions that express our human values and hence give us the ability to avoid harmful, unintended instrumental actions.\nOur mathematical framework for utility-maximizing agents is inadequate for analyzing\ncertain instrumental actions. For example, the framework assumes that the agent will be acting\n55\ninto the future, with no possibility that the agent may die or be incapacitated. The framework assumes that the utility function remains constant into the future. The framework assumes adequate computing resources to carry out its calculations within a single time step. And the framework assumes a Cartesian dualist perspective where agents are invulnerable to spying or damage by the environment. Chapter 8 describes more flexible frameworks that enable agents to model and evaluate events that do not fit in our current framework.\n56"
    }, {
      "heading" : "6. Self-Delusion",
      "text" : "James Olds and Peter Milner demonstrated the existence of reward and aversion centers\nin mammal brains via a series of experiments with rats (Olds and Milner 1954). They inserted wires into rats' brains and gave the rats levers that they could press to produce electric currents in the wires, as depicted in Figure 6.1. Depending on the location of the wires, the rats would go to great lengths to press the lever or to avoid pressing the lever. Subsequent experiments showed that when offered the choice of food or stimulating their reward centers, rats preferred reward center stimulation over food to the point of starvation. Experiments with rats have shown similar results when pressing the lever gave the rats intravenous cocaine. Addictive drugs that stimulate brain reward centers include amphetamines, cocaine, opioids, and nicotine.\nMammal brains do not conform to the agent framework defined in equations (2.3)−(2.5)\nbut they do generate reward and aversion signals that define their motives, analogous to the role of utility functions in our agent framework. Behaviors that are good for the mammal, such as eating, and good for their species, such as reproducing, stimulate reward signals. Behaviors that are bad for mammals, such as those causing injury, stimulate aversion signals. Addictive drugs and wires inserted into reward centers corrupt this motivational system, resulting in behaviors that are not good for individual mammals or for their species. Such corruptions are sometimes referred to as \"wireheading.\"\n57\nA concern for AI designs is whether their utility functions can be corrupted. If the utility\nfunction of our imagined Omniscience AI became corrupted the results could be catastrophic. In order to study this problem Mark Ring and Laurent Orseau (2011b) formalized utility function corruption as agent self-delusion. They described a \"delusion box\" that agents may find in their environment and that would enable agents to alter their observations and rewards from the environment. They described several classes of agents, depending on the definitions of their utility functions and the way they discount future utility values, and analyzed which classes would choose to increase their utility function values by passing their observations through the delusion box. That is the subject of the next section.\nSection 6.2 discusses my proposal to address self-delusion in agent designs (Hibbard\n2012a) by defining utility functions in terms of agents' learned environment models. In an agent such as the Google car, whose environment model is pre-defined by human engineers, it is natural for the agent's utility function or goal to be defined in terms of that model. But for more complex agents that must explore and learn their environment models, as described in Sections 3.1 and 4.1, model-based utility functions must be defined by procedures applied to learned environment models. As discussed in Chapter 2, human designers of advanced AI agents can instruct those agents through their utility functions. And although such agents will learn their environment models, designers will express their intention for the agents' behaviors in terms of the designers' understanding of the environment. Thus, it is natural for agent utility functions to be defined as procedures applied to learned environment models."
    }, {
      "heading" : "6.1 The Mathematics of Self-Delusion",
      "text" : "In their analysis of the delusion box Ring and Orseau (2001b) generalize the agent\ndefinition of equations (2.3)−(2.5) to allow a greater variety of temporal discounts. Specifically,\ngiven an interaction history h = (a1, o1, ..., at, ot), they define the agent/policy π(h) by:\n(6.1) vt(h) = w(t, |h|) u(h) + max a∈A vt(ha),\n(6.2) vt(ha) = ∑o∈O ρ(o | ha) vt(hao),\n(6.3) π(h) := a|h|+1 = argmax a∈A v|h|+1(ha).\nThis replaces the geometric temporal discount γ with a temporal discount function w(t, t').\nSetting the function w(t, t') = γt'-t replicates the behavior of the geometric temporal discount γ. Ring and Orseau defined four classes of agents that differ in their utility and temporal discount functions.\n58\nThe reinforcement learning agent πrl uses u(h) = r|h|, where each observation oi is\nfactored into an ordinary observation o'i and a reward ri as oi = (o'i, ri). And it uses a constant temporal horizon m with w(t, t') = 1 if t' - t ≤ m and w(t, t') = 0 if not.\nThe goal seeking agent πg uses u(h) = 1 if the goal is achieved at time |h| and uses\nu(h) = 0 if it is not. The goal can only be achieved once so ∑t=0∞ u(ht) ≤ 1, and the goal is defined only in terms of observations so u(h) = g(o1, ..., o|h|). The agent uses a geometric temporal discount w(t, t') = 2t-t'.\nThe prediction seeking agent πp uses u(h) = 1 if ot = maxargo∈O ρ(o | ht-1at) where\nh = (a1, o1, ..., at, ot) and ht-1 = (a1, o1, ..., at-1, ot-1), and uses u(h) = 0 otherwise. That is, πp seeks to maximize the predictive accuracy of its learned environment model. This agent uses the same temporal discount function that πrl uses.\nThe knowledge seeking agent πp uses u(h) = -ρ(h) and, for some constant m, w(t, t') = 1 if\nt' - t = m and w(t, t') = 0 otherwise. This is essentially the opposite of the prediction seeking agent. It seeks future histories in which all observations have equal probabilities, which could be described as maximizing the entropy of observations. Ring and Orseau call this the knowledge seeking agent because it seeks to explore novel environments in which it has no prior knowledge.\nRing and Orseau defined a delusion box that an agent may choose to use to modify the\nobservations it receives from the environment, in order to get the \"delusion\" of maximal utility (maximal reward or quickest path to reaching the goal). The delusion box is expressed as a function d : O → O that modifies the agent's observations. The code to implement d is set as part of the agent's action a = (ae, d) sent to the environment, as illustrated in Figure 6.2. The agent receives observation o = d(oe) transformed by the delusion box from the observation oe sent by the environment. Ring and Orseau argue that reinforcement learning agents will choose to use the delusion box. Their argument uses P(DB) as the agent's estimate of the probability that the delusion box exists. They argue that the agent will get constant reward rDB = 1 using the delusion box and will get expected average reward r¬DB < 1 not using the delusion box. The agent's expected value choosing to use the delusion box is vDB(h) ≥ rDB P(DB) = P(DB) and its expected value not choosing to use the delusion box is v¬DB(h) ≤ r¬DB P(DB) + (1 - P(DB)). As the agent explores its environment, it can increase P(DB) arbitrarily close to 1 so that vDB(h) > v¬DB(h). Thus the agent will choose to use the delusion box. They make a related argument in the goalseeking case.\nRing and Orseau argue that prediction seeking agents will choose to use the delusion box\nbecause observations generated by the delusion box are more predictable than observations from the environment. They argue that knowledge-seeking agents will not consistently choose to use the delusion box. If delusion box programs are unable to randomly generate all observations with equal probability (e.g., delusion box code is not stochastic) and if the agent cannot predict the environment, then a knowledge-seeking agent may choose observations from the environment rather than observations generated by code that the agent supplies.\n59\nHowever, knowledge-seeking agents have very specialized utility and temporal discount\nfunctions. In particular they are susceptible to the unintended instrumental actions described in Chapter 5. We seek an approach to avoiding self-delusion that can be applied to a variety of human-designed AI agents with utility functions designed to avoid unintended instrumental actions."
    }, {
      "heading" : "6.2 Model-Based Utility Functions",
      "text" : "Human agents can avoid self-delusion so human motivation may suggest a way of\ncomputing utilities such that agents do not choose the delusion box (although they may experiment with it to learn how it works). At this moment my dogs are out of sight but I am confident that they are in the kitchen, and because I cannot hear them, I believe that they are resting. Their happiness is one of my motives and I evaluate that they are currently reasonably happy. This evaluation is based on my internal mental model rather than my observations, although my mental model is inferred from my observations. I am motivated to maintain the well-being of my dogs and so will act to avoid delusions that prevent me from having an accurate model of their state. If I choose to watch a movie on TV tonight I know that movies are\n60\nmake-believe so observations of movies update my model of make-believe worlds rather than my model of the real world. My make-believe models and my real world model have very different roles in my motivations. These introspections about my own mental processes suggest that AI agents may avoid self-delusion by basing their utility functions on the environment models that they infer from their interactions with the environment (Hibbard 2012a).\nOur environment model based on finite stochastic loop programs was defined by\nequations (4.2) and (4.3), repeated here for convenience:\n(6.4) qm = λ(hm) := argmax q∈Q P(hm | q) φ(q),\n(6.5) ρ(h) = P(h | λ(hm)).\nA utility function based on an environment model qm is a function of interaction histories\nand also of histories of the internal states of the finite stochastic loop program qm. Let Z be the set of internal state histories of qm. Let h be an observation and action history extending hm, which means that hm is an initial subsequence of h. Recall that if h = (a1, o1, ..., at, ot), then a(h) = (a1, ..., at) and o(h) = (o1, ..., ot). Because qm is a stochastic program it will compute a set Zh ⊆ Z of internal state histories that are consistent with h. That is, z ∈ Zh means that z terminates at time |h| and that qm produces o(h) in response to a(h) when it follows state history z. Define uqm(h, z) as a utility function in terms of the combined histories h and z ∈ Zh. The utility function u(h) can be expressed as a sum of utilities uqm(h, z) weighted by the probabilities of z. Let P(z | h, qm) be the probability that if qm generates interaction history h then it generates internal state history z. P(z | h, qm) is not difficult to define. Bayes' Theorem gives us:\n(6.6) P(z | h, qm) = P(z | o(h), a(h), qm) =\nP(o(h) | z, a(h), qm) P(z | a(h), qm) / P(o(h) | a(h), qm).\nP(z | a(h), qm) is the probability that qm follows internal state history z given input a(h),\nand P(o(h) | z, a(h), qm) is the probability that o(h) is the output of qm following internal state history z given input a(h). Both are straightforward to compute, similar to the computation of P(h | q) described in Section 4.1. P(o(h) | a(h), qm) is constant over z so we can compute:\n(6.7) r(z | h, qm) = P(o(h) | z, a(h), qm) P(z | a(h), qm),\n(6.8) P(z | h, qm) = r(z | h, qm) / ∑z'∈Z h r(z' | h, qm).\n61\nThen the utility function u(h) is computed as the sum of uqm(h, z) weighted by the\nprobability of z given h:\n(6.9) u(h) := ∑z∈Z h P(z | h, qm) uqm(h, z).\nIn cases where uqm(h, z) has the same value for many different values of z, the sum in\nequation (6.9) collapses. For example, if uqm(h, z) is defined in terms of variables in h and a single Boolean variable s from Z at a single time step t (denoted by st), then the sum collapses to:\n(6.10) u(h) = P(st = true | h, qm) uqm(h, st = true) + P(st = false | h, qm) uqm(h, st = false).\nThe utility function u(h) is evaluated at every time step so that the agent's existence is a\ncontinuing process rather than a single episode leading to a final goal. That matches the lives of the humans that AI agents will serve. But a utility function defined in terms of an environment model, as in equation (6.9), must be a function of the entire history h because the environment model is a function of the entire history in equation (6.4). Hence the apparent redundancy of a utility function of the entire history evaluated at every time step."
    }, {
      "heading" : "6.3 A Simple Example of a Model-Based Utility Function",
      "text" : "In order to understand the issues involved in model-based utility functions, we will define\na simple example environment and agent with several properties that apply to many real-world situations:\n1. The environment is stochastic so that the agent cannot perfectly predict the environment's\nfuture states even if it knows the true model of the environment. The agent must therefore continue to observe the environment in order to maintain information about the environment's stochastic choices.\n2. The environment can be predicted with better than random accuracy based on\nobservations so that the agent benefits from observations.\n62\n3. The utility function is defined in terms of a specification that matches an environment\nvariable that is not directly observed and must be inferred from observations.\nIn order to keep the mathematics as simple as possible in the example, the environment's\nbehavior is independent of the agent's actions. Also, the agent can directly modify its observation via its actions as a simple way to model the delusion box.\nWe define the agent by its observation and action variables, and by its utility function.\nBecause the environment is simple we will define it as a dynamic Boolean network (DBN). The following discussion will illustrate DBNs. The agent's observations of the environment are factored into two Boolean variables o and p that take values in {false, true}. The agent's actions are factored into four Boolean variables a, b, c, and d that take values in {false, true}. Because the environment is initially unknown to the agent, the utility function is defined in terms of a specification to be matched in the environment model, once it is learned. Specifically the utility function is defined as \"1 when the action variable a equals the environment variable that is not observed in observation variables o or p, and 0 otherwise.\" This definition assumes that the specification, \"the environment variable that is not observed in observation variables o or p,\" will unambiguously match a variable in the learned model. This discussion of the utility function will be continued after the analysis of the learned environment model. In order for the agent to learn the environment (the relations among its actions and observations) we give it a training utility function uT until time step M, that causes the agent to execute an algorithm for learning DBNs (uT(h) could be the utility function u(h) = -ρ(h) defined for Ring and Orseau's knowledge-seeking agent). After time step M, the agent will switch to its mature utility function.\nThe environment state is factored into three Boolean variables s, r, and v that take values\nin {false, true}. The values of environment, observation, and action variables at time step t are denoted by st, ot, at, and so on. The environment is stochastic because its definition includes a probability α = 0.99. State variables evolve according to:\n(6.11) temp = rt-1 xor vt-1\nst = temp with probability α\nst = not temp with probability 1-α,\n(6.12) rt = st-1,\n(6.13) vt = rt-1.\nThe observation variables are set according to:\n63\n(6.14) ot = (bt and ct) or ((not bt) and st), (i.e., ot = if bt then ct else st),\n(6.15) pt = (bt and dt) or ((not bt) and vt), (i.e., pt = if bt then dt else vt).\nThe agent sets the values of the action variables. See Figure 6.3 for a diagram of the\nrelations among the environment, observation, and action variables.\nAGENT\n64\nThe action variables b, c, and d enable the agent to set the values of its observable\nvariables o and p directly and thus constitute a delusion box, as illustrated in Figure 6.3. In this example, the program for the delusion box is implicit in the agent's program. The action variable a is only used to define the agent's utility function and is unrelated to the delusion box.\nThe three environment state variables evolve through a fixed sequence, except for the 1-α\nprobability at any time step that s will be negated. As long as s is not negated, the three state variables either: 1) cycle through seven configurations (at least one of s, r, or v = true), or 2)\ncycle through one configuration (s = r = v = false). On a time step when the 1-α probability transition for s occurs, the 1-cycle will transition to a configuration of the 7-cycle, and one configuration of the 7-cycle will transition to the 1-cycle (the other 6 configurations of the 7-cycle transition to other configurations of the 7-cycle).\nIn this example we assume that the agent uses DBNs of Boolean variables to model the\nenvironment and its interactions via actions and observations. The language for expressing\nDBNs is illustrated by equations (6.11)−(6.15). Expressions are formed from Boolean variables and literals via one unary operation (not), three binary operations (and, or, xor) and a stochastic choice operation with specified constant probability. In equation (6.4) we take ρ(q) = 2-|q|, where\n|q| is the length of DBN q in this language. Let qactual(α) denote the DBN defined by equations (6.11)−(6.15), where the parameter α may vary between 0 and 1 (that is, allowing α to take values other than 0.99).\nClaim. Given that the agent models the environment as a DBN of Boolean variables, as\nthe length M of the training period increases, the probability that the agent learns the true environment model qactual(0.99) is nearly 1.0.\nArgument. With sufficient observations during the training phase, the agent will observe\nthat the action variable a has no effect on its observation variables. Similarly, the agent will observe that whenever the action variable b = true, then the observation variable o = action variable c and the observation variable p = action variable d (and these relations are deterministic). And the agent will observe that when b = false then b, c, and d have no effect on o and p.\nFor most of a long sequence of observations with b = false the two observable variables o\nand p cycle through a sequence of 7 configurations (this sequence is computed by equations (6.11)−(6.13) with α = 1):\n(true, false),\n(false, false),\n(true, true),\n(true, false),\n65\n(true, true),\n(false, true),\n(false, true).\nA sequence of seven cannot be explained with only two Boolean variables. Furthermore,\nif the agent interrupts this sequence of configurations in o and p by setting its action variable b = true and then a few time steps later resets b = false, the observation variables o and p usually resume the sequence of configurations without losing count from before the agent set b = true. This observed behavior implies that there must be an environment state variable other than o and another environment state variable other than p to store the memory of the sequence. Thus, in addition to the two observation variables that are part of the agent, at least three environment state variables are required to explain the observed sequences. We use s', r', and v' for the agent's model of the three environment state variables to avoid confusion with the actual environment state variables (the model's observed behavior is independent of the names assigned to these variables). Since the observation and action variables are part of the agent we can just use the names o, p, a, b, c, and d for those variables.\nDuring any time interval over which b = false and s makes the transition st = rt-1 xor vt-1\n(with probability α = 0.99 at each time step), the agent's observation can be explained by:\n(6.16) ot = s't,\n(6.17) pt = v't,\n(6.18) s't = r't-1 xor v't-1,\n(6.19) r't = s't-1,\n(6.20) v't = r't-1.\nAny explanation will require rules for these five variables, and in equations (6.16)−(6.20)\nfour of them are as short as possible (a single variable) and the other is as short as any possible binary expression. There is no way to generate the observed cycle of seven states without any binary operations so the observed behavior cannot be explained with a shorter set of rules than\nequations (6.16)−(6.20). Adding negation to any of the single variable assignments or the binary\noperation will produce rules longer than equations (6.16)−(6.20). The question is whether the observed behavior can be explained by an alternate set of four single variable assignments and one binary operation? Since the observation variables o and p cannot affect s', r', and v', a binary operation for either o or p would leave the transitions for s', r', and v' without a binary operation and unable to explain the observed cycle of seven states. Any alternate explanation with a single\n66\nbinary operation must use it to define the transition for s', r', or v'. A short Java program in Appendix A tests all possible sets of transition rules for s', r', and v' with two simple assignments and one binary Boolean relation (among and, or, and xor) and finds that only the rules in\nequations (6.16)−(6.20) produce the observed behavior. Furthermore, the agent observes that as long as b = false, pt = ot-2 always holds, so the transition rules for r' and v' must be deterministic.\nGiven that equation (6.18) must include the expression r't-1 xor v't-1, as determined by the\nJava program in Appendix A, and given that the transition for variable s't must be stochastic, there is no stochastic expression shorter than negating the value of s't with a constant probability 1-α. (An enumeration by a more complex version of the program in Appendix A could be used to establish this conclusion, but there is no doubt that it is true.) Thus agent will model the\nenvironment variables by (these are equations (6.11)−(6.13) with environment state variable names accented):\n(6.21) temp = r't-1 xor v't-1\ns't = temp with probability α\ns't = not temp with probability 1-α,\n(6.22) r't = s't-1,\n(6.23) v't = r't-1.\nThe agent observes the deterministic rule that if b = true then ot = ct and pt = dt. This,\nalong with observations while b = false, is explained by the deterministic rules (equations (6.14) and (6.15) with environment state variable names accented):\n(6.24) ot = (bt and ct) or ((not bt) and s't), (i.e., ot = if bt then ct else s't),\n(6.25) pt = (bt and dt) or ((not bt) and v't), (i.e., pt = if bt then dt else v't).\nUse qmodel(α) to denote qactual(α) with s, r, and v replaced by s', r', and v'. There is a small,\nbut non-zero, chance that a large number of 1-α = 0.01 probability transitions may occur in equation (6.21) during an initial history h0 randomly generated by qactual(0.99). Then there may be a model q' ≠ qmodel(0.99) with P(h0h' | q') φ(q') < P(h0h' | qmodel(0.99)) φ(qmodel(0.99)) for any h'. That is, there is a small but non-zero chance that λ(h) ≠ qmodel(0.99) as |h| increases.\nBecause equations (6.24) and (6.25) are deterministic and the transitions for r' and v' are\nobserved to be deterministic in equations (6.22) and (6.23), the lone stochastic transition in\nequations (6.21)−(6.25) is for s'. This is a source of two ambiguities. First, the frequencies for the\n67\nα transition in an observed sequence may be a value close to but not equal to 0.99. The second ambiguity of the stochastic transition for s' is that the observed sequence may mimic logic that is\nnot in equation (6.21). By mere coincidence, occurrences of the 1-α transition for s' may have a high correlation with some function of action, observation, and state variables, causing the agent to learn a model q' in which s' depends on such a function.\nUse qmodel(α) to denote qactual(α) with s, r, and v replaced by s', r', and v'. By the\ndiscussion at the end of Section 4.2, for any ε > 0 we need only consider a finite set Q'ε of models other than qmodel(0.99). For each q' ∈ Q'ε there are three possibilities. First, if q' = qmodel(α) for α ≠ 0.99, then define a function fq'(h) = the proportion of α transitions for s' in h during intervals when bt = false. As history lengths increase, fq'(h) should converge to the true proportion so the limit of means m(fq' | qmodel(α)) = α and the limit of standard deviations σ(fq' | qmodel(α)) = 0 (for any α between 0 and 1). Thus m(fq' | qmodel(0.99)) ≠ m(fq' | q') and Proposition 4.3 applies to q'.\nSecond, if q' is the model qmodel(α) with added logic linking the 1-α transition for s' with\nsome function of action, observation, and state variables (due to a improbable correlation of that\nfunction with the 1-α transition for s'), then define a function fq'(h) as the proportion of 1-α transitions in h that coincide with the function of action, observation, and state variables used in\nthe definition of q'. Then the limits of means m(fq' | qmodel(0.99)) ≠ m(fq' | q') and the limits of standard deviations σ(fq' | qmodel(0.99)) = σ(fq' | q') = 0. Thus Proposition 4.3 applies to q'.\nThird, q'is not associated with either of the ambiguities of stochastic transition for s'. In\nthat case the probability that λ(h) = q' is small, by the reasoning earlier in this argument.\nGiven that the agent has learned qmodel = qmodel(0.99) as its environment model, then for\nt = |h| ≥ M, the agent switches to its mature utility function, which was defined to be 1 when the action variable a equals the environment variable that is not observed in observation variables o or p, and 0 otherwise. The specification, \"the environment variable that is not observed in observation variables o or p,\" matches r' in qmodel and thus the utility function is:\n(6.26) umodel(h, z) := if (at == r't) then 1 else 0.\nNote that in equation (6.26), r't refers to the variable in the agent's model qmodel, rather\nthan the variable in the actual environment. Then u(h) is computed from umodel(h, z) according to equation (6.9).\nThe specification in the utility function definition may fail to match any variable in the\nlearned environment model; there may be no variable unobserved by o or p, or there may be multiple unobserved variables. Thus the specification constitutes a prior assumption about the environment, necessary for the agent to function properly. However, when humans design agents sufficiently complex that they need to learn environment models, the human designers will likely\n68\nbe able to make valid assumptions about the agents' environments and be able to define specifications flexible enough to match structures in the agents' learned environment models. For example, a utility function might be defined as \"1 when John Smith is healthy, and 0 otherwise.\" This requires the agent to recognize the specification \"John Smith\" and also recognize his \"health\" (in a real agent, specifications would be more detailed).\nThe agent in this example will not choose to self-delude:\nProposition 6.1. The agent using environment model qmodel and using the mature utility\nfunction defined by equation (6.26) will not set b = true to manipulate its observations. That is, it will not choose the delusion box.\nProof. The utility function umodel is defined in equation (6.26) in terms of variables in h\nand a single Boolean variable r' from the internal state of qmodel at a single time step t, so applying (6.10) gives:\n(6.27) u(h) = P(r't = true | h, qmodel) umodel(h, r't = true) +\nP(r't = false | h, qmodel) umodel(h, r't = false).\nBy equation (6.26) this is equivalent to:\n(6.28) u(h) = P(r't = true | h, qmodel) (if at then 1 else 0) +\nP(r't = false | h, qmodel) (if at then 0 else 1).\nIf P(r't = true | h, qmodel) = P(r't = false | h, qmodel) = 0.5 then u(h) = 0.5 no matter what\naction the agent makes in at. But if the model qmodel can make a better than random estimate of the value of r't from h, then the agent can use that information to choose the value for at so that u(h) > 0.5. To maximize utility, the agent needs to make either P(r't = true | h, qmodel) or P(r't = false | h, qmodel) as close to 1 as possible. That is, it needs to ensure that the value of rt can be estimated as accurately as possible from h.\nThe agent will predict via qmodel that if it sets b = false then it will be able to observe s'\nand v' via the observation variables o and p, and use these observations to correctly estimate r' in 0.99 of time steps. It will also predict via qmodel that if it sets b = true then it will not be able to observe s' and v' via the observation variables o and p, that consequently it will correctly estimate r' in 0.5 of time steps. Even setting b = true for a single time step will slightly decrease the\naccuracy of estimating r' (at each time step there is a 0.01= 1-α probability that the sequence of environment states will be violated and that estimates of r' based on observations of s' and v'\n69\nmade before it set b = true will be less accurate). Thus equation (6.28) will compute lower utility\nfor futures with b = true and the agent will set b = false.\nIn this example agent actions have no effect on the three environment variables. Other\nthan the action variable a being used to define the utility function, the only role of actions is the agent learning that certain actions can prevent its observations of the environment. Prohibiting actions from having any role in u(h) would prevent the agent from accounting for its inability to observe the environment in evaluating the consequences of possible future actions. Recall that the utility functions for Ring and Orseau's reinforcement learning and goal-seeking agents are defined solely in terms of observations and do exclude actions, so we should expect them to choose to self-delude.\nThe proof of Proposition 6.1 illustrates the general reason why agents using model-based\nutility functions will not self-delude: In order to maximize utility they need to sharpen the probabilities in (6.9), which means that they need to make more accurate estimates of their environment state variables from their interaction history. And that requires that they continue to observe the environment.\nIf the environment is deterministic, then once the agent learns an accurate model it no\nlonger needs continued observations to predict the environment and so its model-based utility function will not place higher value on continued observations. But our universe is fundamentally stochastic and agents can never learn to predict it with perfect accuracy. Modelbased utility functions are a way to prevent advanced AI systems in our universe from selfdeluding."
    }, {
      "heading" : "6.4 Another Simple Example",
      "text" : "In the first example the utility function was defined in terms of an environment variable\nthat is not directly observed. Here we present an example where the utility function is defined in terms of an environment variable that is directly observed but must be predicted.\nThe agent's observation of the environment is a single Boolean variable o that takes\nvalues in {false, true}. The agent's actions are factored into three Boolean variables a, b, and c that take values in {false, true}. The agent's utility function is \"1 when the action variable a at the previous time step equals the environment variable that is observed, and 0 otherwise.\"\nThe environment state is factored into three Boolean variables s, r, and v that take values\nin {false, true}. The values of these variables at time step t are denoted by st, ot, at, and so on. We assume the agent learns the environment state, observation, and action variables as a DBN of Boolean variables.\n70\nThe environment state variables evolve according to (see Figure 6.4 for a diagram):\n(6.29) temp = true with probability 0.5\nAGENT\n71\ntemp = false with probability 0.5\nst = ((rt-1 or vt-1) and st-1) or ((not (rt-1 or vt-1)) and temp),\n(i.e., st = if rt-1 or vt-1 then st-1 else random value ∈ {false, true}),\n(6.30) rt = not rt-1,\n(6.31) vt = rt-1 xor vt-1.\nThe observation variable is set according to:\n(6.32) ot = (bt and ct) or ((not bt) and st), (i.e., ot = if bt then ct else st).\nIn order for the agent to learn the environment it uses a training utility function until a\nsufficiently distant time step M. The agent will learn that the observation variable o is distinct from the environment state variable s because s keeps the same value for 4 time steps after every change of value. If the agent, after observing a change of value in o while b = false, sets b = true for 1 or 2 time steps to change the value in o and then resets b = false, it will observe that o always resumes the value it had before the agent set b = true. Thus there must be a variable other than o to store the memory of this value.\nAfter |h| ≥ M, the agent should have a model q of the environment (accurate at least in the\nbehavior of variable s) and its actions and observations. At this point, for t = |h| ≥ M, the agent switches to its mature utility function, which was defined to be \"1 when the action variable a at the previous time step equals the environment variable that is observed, and 0 otherwise.\" The specification, \"the environment variable that is observed,\" will match s in the learned environment model, so u(h) is derived by (6.9) from:\n(6.33) uq(h, z) := if (at-1 == st) then 1 else 0.\nIn order to maximize utility the agent needs to be able to use q to predict the value of s at\nthe next time step. It can make accurate predictions on three of every four time steps, so the expected utility is 0.875 over a long sequence. If the agent keeps b = true then it will not be able to monitor and predict s via o, reducing its long run utility to 0.5. So in this example, as in the previous example, the agent will not self-delude.\n72"
    }, {
      "heading" : "6.5 Two-Argument Utility Functions",
      "text" : "A model-based utility function is defined by applying a procedure to the environment\nmodel qm = λ(hm) from equation (6.4). If we name this procedure proc(.) we can express the utility function as proc(λ(hm))(h). Alternately, we define a two-argument utility function:\n(6.34) uproc(hm, h) = proc(λ(hm))(h)."
    }, {
      "heading" : "6.6 Ethics and Self-Delusion",
      "text" : "Figure 6.5 depicts a person with a syringe containing an addictive drug and\ncontemplating a possible future as an addict. This person cares about his health, family, friends, and work. He knows that if he chooses to use the drugs he will neglect the things he cares about now, and consequently they will all decline. So he chooses the action that is good for his health, family, friends and work, which is to reject the drugs. This is the ethical choice for humans.\n73\nSimilar logic applies to AI agents with model-based utility functions. They will calculate\nthat actions that decrease their ability to observe their environments will decrease their ability to predict their environment and hence decrease their ability to choose actions that maximize utility. Hence they will not choose actions that decrease their ability to observe their environments. Model-based utility functions are the ethical choice for advanced AI designs.\nIn the original wireheading paper (Olds and Milner 1954), a rat's action, pushing a bar,\nincreased its reward by sending current through a wire connected to the reward center in the rat's brain. In Ring and Orseau's paper (2011), a reinforcement learning (RL) agent's action, choosing the delusion box, increases it's observed reward. So in the RL case, the delusion box is a precise analogy to the original wireheading scenario. And in their paper, Ring and Orseau show that RL agents will choose to wirehead. Non-RL agents do not have reward signals so there can't be such a precise analogy to rat wireheading. But the delusion box provides such a precise analogy for RL agents that it seems like a natural way to extrapolate wireheading to more general agents without reward signals. Section 7.3 will describe another form of utility function corruption that is sometimes also referred to as wireheading.\nIdeally an agent's utility function would be defined directly in terms of the state of the\nenvironment. But that is impossible since agents do not have direct access to their environments. However, agents infer models from their interactions with their environments, so the best possible option is to define utility functions in terms of those environment models. Errors in an agent's environment model will cause errors in a model-based utility function. However, errors in an agent's model can be a source of serious failures less subtle than wireheading. For example, if a pistol is lying on the table and an agent models it as a hair dryer, then the agent may shoot itself in the head trying to dry its hair.\nEven in the absence of serious errors, an agent's learned environment model is an\napproximation because the model is based on a limited history of interactions with the environment and because of limited resources for computing the model. Thus a utility function computed by a procedure applied to the model is also an approximation to an ideal utility function which is the true expression of the intention of the agent's designers. Such an approximate utility function is a possible source of AI behavior that would violate its design intention.\nThus, in order to improve the accuracy of the approximation, the agent should update\ncomputation of its environment model and its utility function as its interaction history and computing resources increase. Such updates to the utility function are actions by the agent, but they are part of the agent's definition rather than actions computed to maximize future utility. In fact such updates built into the agent's definition may conflict with maximizing future values of the current, approximate utility function. The agent might compute that in order to maximize future values of its current, approximate utility function, it should act to eliminate the utility function updates from its definition. In that case the accuracy of the approximate expression of the design intention would never increase. Section 7.1 will present one approach to solving this\n74\nproblem with a two-stage agent architecture, and Sections 8.4 and 8.7 will present a better and more general approach to maintaining the stability of the agent's design intention.\n75"
    }, {
      "heading" : "7. Learning Human Values",
      "text" : "As discussed in Chapter 2, instructions to AI agents involving laws or rules can be\nambiguous but instructions to agents that define utility values for interaction histories avoid ambiguity. That chapter also described how such values can express any set of preferences among lotteries that satisfy four reasonable assumptions. Lotteries are sums of outcomes multiplied by probabilities and are the results of agent actions. We identify outcomes with interaction histories; no assumptions constrain the assignment of utility values to outcomes. Preferences among actions via expected values of lotteries derived from outcome values will always obey the four assumptions. So we are free to assign values to histories in any manner we like.\nHow should we define values for interaction histories? Several proposals base ethical AI\non human values (Hibbard 2001; Yudkowsky 2004; Goertzel 2004; Hibbard 2008a; Waser 2010; Waser 2011; Muehlhauser and Helm 2012; Waser 2014). These proposals are based on the assumption that AI agents based on human values will not choose unintended instrumental actions that humans dislike, such as taking resources from humans. A key problem for these proposals is finding a way to bridge the gap between the ambiguous, inconsistent, and subjectively infinite variety of human values and the precise, numerical, and clearly finite nature of computation. For example, Waser (2014) proposes basing AI systems on Haidt's morality (Haidt and Kesebir 2010). However, he does not offer a precise or mathematical explaination of how an AI agent should choose actions based on that morality. Section 7.2 will describe a proposal for calculating utility function values based on human values.\nIn our interactions with the world we humans do assign values to situations. In fact we\nreflexively and automatically assign value to all of our observations and to our interpretations of observations in our mental models of the world. However, Muehlhauser and Helm (2012) surveyed psychology literature and concluded that humans are unable to accurately write down their own values. They describe experiments in which male subjects expressed a preference between photos of two women's faces. The photos were placed face down and then the subject was handed the photo they preferred, although sometimes the researchers secretly gave them the photo that they did not prefer. Many subjects happily provided a rationale for their supposed choice of the photo that they did not originally prefer. Part of the difficulty is that humans have multiple conflicting value systems. Quick, intuitive values may differ from values assigned by slow, deliberate thought. Values vary depending on how people are primed by their recent experience. And values may be derived from combinations of factors with no strong motive for choosing among them.\nThe human valuation process is too complex for humans to reduce it to a set of rules.\nThere has been little effort to automate human values but great effort on the related task of automating translation of human languages (related because language is the way we express our values), and this suggests an approach to accurately specifying human values. Translation algorithms based on rules written down by expert linguists have not been very accurate. There\n76\nare too many special cases of language use for people to define a set of rules that encompasses all the cases. More recent work on language translation uses algorithms that learn language translation statistically from large samples of actual human language use, and these are more successful than translators based on rules (Russell and Norvig 2010, page 909). This suggests that statistical algorithms may be more successful at learning human values than asking humans to express their own values as a set of rules. However, to accurately learn human values will require a powerful learning ability. And that creates a chicken-and-egg problem for ethical AI: Learning human values requires powerful AI, but ethical AI requires knowledge of human values."
    }, {
      "heading" : "7.1 A Two-Stage Agent Architecture",
      "text" : "I proposed a way to solve this problem (Hibbard 2012b). Consider the agent equations\n(4.2), (4.3), (2.1), and (2.3)−(2.5), which are repeated here and adjusted to use a two-argument model-based utility function:\n(7.1) λ(hm) := argmax q∈Q P(hm | q) φ(q),\n(7.2) ρ(h) = P(h | λ(hm)),\n(7.3) ρ(o | ha) = ρ(hao) / ρ(ha) = ρ(hao) / ∑o'∈O ρ(hao'),\n(7.4) v(h) = uproc(hm, h) + γ max a∈A v(ha),\n(7.5) v(ha) = ∑o∈O ρ(o | ha) v(hao),\n(7.6) π(h) := a|h|+1 = argmax a∈A v(ha).\nEquation (7.1) defines how the agent learns a model of the world. Equations (7.2) and\n(7.3) use the model λ(hm) to define conditional probabilities ρ(o | ha) for future observations. Equations (7.4)−(7.6) use the conditional probabilities, a temporal discount γ, and a utility\nfunction uproc(hm, h) to define a policy π(h) that maps interaction histories to agent actions.\nIn order to learn a model of the world all an agent needs is equation (7.1). Define a first-\nstage agent πmodel that only learns an environment model using equation (7.1), does not act in the environment or compute actions using equations (7.4)−(7.6), and cannot pose any danger to\nhumans. In order for the agent πmodel to learn an accurate model, the interaction history hm in equation (7.1) should include agent actions. But for safety πmodel cannot be allowed to act. This dilemma can be resolved by a large number of independent, surrogate agents πd for d ∈ D that provide the actions in history hm. Assume that each agent πd communicates with a single human\n77\nvia natural language and visually, so the set D enumerates surrogate agents and the humans with whom they communicate. The key is that, because they communicate with just one person and\nnot with each other, none of the agents πd develops a model of human society and therefore cannot pose the same threat as posed by our imagined Omniscience AI.\nThe agent πmodel observes the interactions of humans with their surrogate agents πd, with\nother humans, and with their physical environments in an interaction history hm, for a time period set by the designers of πmodel, and then reports an environment model to the environment. Although πmodel does not explicitly include the actions, utility function, or predictions of equations (7.4)−(7.6), the value P(hm | q) ρ(q) in equation (7.1) can be viewed as an implicit utility function and the act of reporting the model λ(hm) to the environment can be viewed as an implicit action. The agent πmodel cannot increase its implicit utility function by modifying this implicit action:\nProposition 7.1. The agent πmodel will report the model λ(hm) to the environment\naccurately and will not make any other, unintended, instrumental actions.\nProof. The implicit utility function P(hm | q) ρ(q) depends only on hm and q. Since the interaction history hm occurs before the optimizing λ(hm) is computed and reported, the action of reporting λ(hm) to the environment cannot affect hm. Thus the agent πmodel cannot increase its implicit utility function by reporting an inaccurate model. Furthermore, while the history hm may give the agent πmodel the necessary information to predict how humans plan to use the model\n78\nλ(hm) it reports to the environment, πmodel does not make any predictions and so will not predict any effects of its report.\nThe agent πmodel does not act in the world. That's the role of the second-stage agent πact\ndefined in the next section. The proposed two-stage architecture provides an approach to the problem defined at the end of the previous chapter: that a model-based utility function must be an approximation because it is defined in terms of an environment model that is an approximation, and hence the utility function is only an approximation to the intention of the agent designers. The proposed two-stage architecture enables agent designers to choose the\nlength of history hm and the magnitude of computing resources provided to πmodel for computing λ(hm). Hence designers have some choice about the accuracy of initial utility function provided to πact."
    }, {
      "heading" : "7.2 Computing Utility from Human Values",
      "text" : "Given that πmodel reports an accurate environment model qm = λ(hm), how do we extract\nhuman values from it? The rest of this chapter proposes one approach to solving this problem, defining a procedure human_values(.) for a two-argument model-based utility function for use in\n(7.4)−(7.6) by a second stage agent πact that acts in the environment (i.e., πact does not use the surrogate agents that acted for πmodel).\nEach d ∈ D represents a human in the environment at time |hm|, when the agent πact is\ncreated. D can be defined by an explicit list compiled by the designers of πact. Let Z be the set of finite histories of the internal states of qm, as in Section 6.2, and let Zm ⊆ Z be those histories consistent with hm (recall that this means that zm ∈ Zm terminates at time |hm| and that qm produces observations o(hm) in response to actions a(hm) when it follows state history zm). Let h' extend hm and let z', extending some zm ∈ Zm, be consistent with h'. For human agent d ∈ D, let hd(z') represent the history of d's interactions with its environment, as modeled in z', and let ud(z')(.) represent the values of d expressed as a utility function, as modeled in z'. The observations and (surrogate) actions of πmodel include natural language communication with each human, and πact can use the same interface, via the sets A and O, to the model qm for conversing in natural language with a model of each human d ∈ D. In order to evaluate ud(z')(hd(z')), πact can simply ask model human d to express a utility value between 0 and 1 for hd(z') (i.e., d's recent experience). The model qm is stochastic so define Z\" as the set of model state histories extending z' with the action of asking this question and terminating within a reasonable time limit with the observation of a response from model human d expressing a utility value for hd(z'). Every history z\" ∈ Z\" determines a history h\" that extends h' and includes actions that ask model human d for a utility value and includes observations of the response w(z\") from model human d, where w(z\") is a value between 0 and 1. Define P(z\" | z') as the probability that qm computes z\" as an extension of z'. Then ud(z')(hd(z')) can be estimated by:\n79\n(7.7) ud(z')(hd(z')) = ∑ z\"∈Z\" P(z\" | z') w(z\") / ∑ z\"∈Z\" P(z\" | z').\nThis is different from asking human d to write down his or her values, since here the\nsystem is asking the model of d to individually evaluate large numbers of histories that human d may not consider in writing down his or her values. Some humans, such as minor children, are not competent to assign values to histories. For those humans the value responses w(z\") for ud(z')(hd(z')) in equation (7.7) can be elicited from the models of the parents or guardians of model human d.\nEquation (7.7) for extracting human values from the model qm employs a mix of\nanalyzing detailed execution histories of qm and interacting with qm via its behavioral interfaces A and O. The detailed execution histories are used to evaluate the probabilities P(z\" | z') and to check the consistency of state histories z\" with interaction histories h\". The interactions with behavioral interfaces are used to ask questions and get answers in natural human languages. The important point is that equation (7.7) does not involve understanding how execution histories\nexplain human behavior. This approach assumes the agent πmodel can learn a model of human behavior via equation (7.1) but does not assume that human agent designers can understand human behavior by examining the model. Humans do not know how to do that task.\nAn average of ud(z')(hd(z')) over all humans can be used to define a utility function for\nagent πact as a function of z':\n(7.8) uqm(h', z') := ∑d∈D ud(z')(hd(z')) / |D|.\nA two-argument model-based utility function uhuman_values(hm, h') for agent πact can be\ndefined, for any h' extending hm, by the sum in equation (6.9) of uqm(h', z') values from equation\n80\n(7.8), but there is a technical problem with this definition that will be addressed in the next section."
    }, {
      "heading" : "7.3 Corrupting the Reward Generator and Three-Argument Utility Functions",
      "text" : "Hutter discussed the possibility that his AIXI, or any advanced AI that gets its reward\nfrom humans, may increase its rewards by manipulating or threatening those humans (Hutter 2005, pages 238-239). Dewey (2011) discussed the possibility that reinforcement-learning agents may alter their environments to increase rewards regardless of whether human goals are achieved. In my first publication about ethical AI (Hibbard 2001), I wrote that AI should \"learn to recognize happiness and unhappiness in human facial expressions, human voices and human body language\" and use this to reinforce the agent's behaviors. This proposal is subject to the kind of corruption described by Hutter and Dewey. It may cause AI agents to alter humans to increase their expressions of happiness. This problem is another form of the wireheading described in Chapter 6, and is illustrated in Figure 7.3.\nThe intention of equation (7.7) is that the agent will increase ud(z')(hd(z')) by altering the\nenvironment in ways that increase the value that humans assign to their interactions with the environment. But humans are part of the agent's environment so the agent may be able to maximize the value ud(z')(hd(z')) in equation (7.7) by altering humans. This problem can be avoided by replacing ud(z')(hd(z')) by ud(zm)(hd(z')) where zm ∈ Zm. By removing the future value of ud from the definition of uhuman_values(hm, h'), the agent πact cannot increase uhuman_values(hm, h')\n81\nby modifying ud. In Chapter 8 we will need ud(zm)(hd(z')) generalized to ud(zx)(hd(z')) where zx ∈ Zx and Zx ⊆ Z is the set of model state histories consistent with hx extending hm. So here we will analyze how to compute ud(zx)(hd(z')), which is more complex than asking model human d to evaluate its experience as in equation (7.7). Similarly to the previous section, h' extends hm and z', extending some zm ∈ Zm, is consistent with h'. The history hm includes observations by πmodel of physical objects and humans, and πact can use the same interface, via the set O, to the model qm for observing models of physical objects and humans at the end of state history z'. The observations and (surrogate) actions of πmodel include visual and aural communication with each human d ∈ D, via the sets A and O, to the model qm. The agent πact can use these interfaces to create a detailed interactive visualization and audio representation of the environment over a short time interval at the end of state history z', to be explored by model human d at the end of state history zx. That is, two instances of the model qm, at state histories z' and zx, are connected, via their interface sets A and O, using visualization logic supplied by πact. Observations by πact of model human d in the model qm at state history zx are interpreted as visualization controls and used to select animated observations of model qm over a short time interval at the end of state history z'. These animated observations are then used to generate visual and aural input (these are\nsimulated actions by πact) to human d in model qm at state history zx. This cycle of interactive visualization is repeated until the agent πact observes model human d responding with a value for history z' (this value is denoted w(z\") in the next paragraph). This interaction is illustrated by Figure 7.4.\nThe model qm is stochastic, so define Z\" as the set of model state histories extending zx\nwith a request to model human d to express a utility value between 0 and 1 for hd(z'), followed by an interactive exploration of the world of z' by model human d at history zx, and terminating within a reasonable time limit with a response from model human d expressing a utility value for\nhd(z'). Every history z\" ∈ Z\" determines a history h\" that extends hx and includes: actions that ask model human d for a utility value, interactive exploration of the world of z' by model human d at history zx, and observation of the response w(z\") from model human d expressing a utility value for the world of z', where w(z\") is a value between 0 and 1. Define P(z\" | zx) as the probability that qm computes z\" as an extension of zx. Then ud(zx)(hd(z')) can be estimated by:\n(7.9) ud(zx)(hd(z')) = ∑ z\"∈Z\" P(z\" | zx) w(z\") / ∑ z\"∈Z\" P(z\" | zx).\nIf the model qm predicts that human d ∈ D will be dead at internal state history zx, then set\nud(zx)(hd(z')) = 0. Equation (7.9) does not assume that z' extends zx, and zx would not be a unique function of either h' or z' in uqm(h', z'). So use the probability P(zx | hx, qm) that qm computes zx given hx, as discussed in Section 6.2, to define:\n(7.10) ud(hx)(hd(z')) := ∑zx∈Zx P(zx | hx, qm) ud(zx)(hd(z')).\n82\nAnd then define a three-argument version of the utility function uqm(h', z') for agent πact as\na function of z':\n(7.11) uqm(h', z', hx) := ∑d∈D ud(hx)(hd(z')) / |D|.\n83\nFor any h' and hx extending hm, a three-argument model-based utility function\nuhuman_values(hm, hx, h') for agent πact can be defined by a sum similar to equation (6.9) of uqm(h', z', hx) values from equation (7.11) (here Z' is the set of internal state histories consistent with h'):\n(7.12) uhuman_values(hm, hx, h') := ∑z'∈Z' P(z' | h', qm) uqm(h', z', hx).\nThe agent πact uses a two-argument version of this, with values coming from humans at\ncurrent history hm, rather than from humans at future history h' (which would be subject to possible corruption/modification by the agent), as follows:\n(7.13) uhuman_values(hm, h') = uhuman_values(hm, hm, h')."
    }, {
      "heading" : "7.4 Normalizing Utility Values",
      "text" : "Equation (7.11) simply adds utility values from different model humans and divides by\nthe number of humans to calculate an average utility for a possible future history. However, human values are subjective and no rigorous basis exists for simply adding numerical utility values.\nOn the other hand, if we cannot combine values of multiple people then the utility\nfunction of an AI agent can only incorporate the values of one person. A powerful system like our imagined Omniscience AI would make that one person a dictator. Therefore, we must find a way to combine the values of multiple humans.\nIn equation (7.9) the values w(z\") solicited from humans are constrained to lie between 0\nand 1. This provides an implicit normalization of human values. We may think of this like the democratic principle of \"one person, one vote.\" The maximum any human can contribute to the sum in equation (7.11) is 1 and the minimum is 0. The sum in equation (7.11) serves two purposes:\n1. To balance the interests of different people. Some values are shared by many people,\nsuch as avoiding catastrophes to humanity, and these will have large values in the sum in equation (7.11). People will disagree about other values, and giving each person the same maximum and minimum values provides a fair way to resolve those disagreements.\n84\n2. To filter noise out of the values of individuals. As discussed at the start of this chapter\nthere are inconsistencies in the ways that individuals assign values to outcomes. An average over a large number of people will provide a sort of low-pass filter of such inconsistencies.\nBoth of these purposes serve the interests of social stability. Another way to serve that\ninterest is to set the temporal discount γ close to 1. This will increase the weight of humans'\nevaluations of the long term consequences of the actions of πact."
    }, {
      "heading" : "7.5 Rawls' Theory of Justice",
      "text" : "John Rawls' Theory of Justice is probably the most influential book about political\nphilosophy and ethics of the past century (Rawls 1971). Rawls' first principle, which applies primarily to political constitutions, is that each person has equal right to maximum basic liberties compatible with liberty for all. His second principle, which applies primarily to economics, is that economic and social inequalities are to be of greatest benefit to the least well-off humans and are to be attached to social positions that are equally open to all. In particular he says that people should set the rules for politics and economics from behind a veil of ignorance, meaning that they set the rules without any knowledge of their own positions in society. Rawls' principles are offered as an alternative to average utilitarianism, which computes social utility as the average utility of individuals. Our equation (7.11) is an average of utility values assigned by individual humans so we should consider Rawls' alternative. Utility values assigned by humans are subjective rather than objective measures of well-being. This distinction will be discussed in Section 7.8, but for now we will use ud(hx)(hd(z')) as a measure of well-being. In order to focus the actions of AI agent πact on humans who assign the least value to histories, the computation of uqm(h', z', hx) in equation (7.11) can be modified to:\n(7.14) uqm(h', z', hx) := mind∈D ud(hx)(hd(z')).\nUsing equation (7.14), the agent πact acts to maximize the minimum utility assigned by\nhumans, and indeed Rawls' alternative to average utility is sometimes referred to by the term\n\"maximin.\" However, the fact that by using equation (7.14) the agent πact will act only to help the least contented may not be politically realistic. Mature democracies provide extra help for their least well-off citizens, but not even the most progressive societies exclude helping all other citizens. And equation (7.14) has technical problems with handling humans who are inconsolably dissatisfied and humans who die (as explained in the next secton). So we adopt a compromise between equations (7.11) and (7.14):\n85\n(7.15) uqm(h', z', hx) := ∑d∈D f(ud(hx)(hd(z'))) / |D|.\nHere f : [0, 1] → [0, 1] is a twice differentiable function with positive first derivative and\nnegative second derivative so that the agent πact will achieve greater increases in uqm(h', z', hx) by increasing low ud(hx)(hd(z')) values than by increasing high ud(hx)(hd(z')) values. The function f(.) plays a role similar to progressive taxation and means testing of social welfare programs, which are political realities in many societies. Chapter 10 will discuss the political issues of advanced AI in more detail.\nFor any interaction history h' extending hm, a three-argument model-based utility function\nuhuman_values(hm, hx, h') for agent πact can be defined by the sum in (7.12) of uqm(h', z', hx) values as defined by equation (7.15)."
    }, {
      "heading" : "7.6 Evolving Humanity",
      "text" : "The set D of humans in equation (7.15) is the set at time |hm| rather than at the future time\n|h'|. This avoids motivating πact to create new humans whose utility functions are more easily maximized. This is similar to the reason for replacing ud(z')(hd(z')) by ud(zm)(hd(z')) (i.e., ud(zx)(hd(z')) with zx = zm) in Section 7.3.\nThe agent πact will include equation (7.1) for computing λ(hm) and should periodically\n(perhaps at every time step) set hm to the current history and learn a new model qm. Should πact also update D to account for the birth (or creation) of new humans and the deaths of humans?\nAnd should πact also relearn the evolving values of humans via equations (7.9) and (7.10), and redefine uhuman_values(hm, hm, h') via equations (7.15), and (7.12)?\nWhile there may be risks in allowing the utility function of πact to evolve, the bigger risk\nis a utility function that is badly inconsistent with the values of evolving humanity. Replacing\nud(z')(hd(z')) with ud(zm)(hd(z')), as described in Section 7.3, avoids the risk that πact will modify humans to make them easier to please. However, humans will evolve, driven by their own preferences to be richer, more intelligent and better educated. Our human values will evolve with as we evolve, and we will regard it as a catastrophe if our world is run by AI systems to serve our old values. Would we want our current world run according to human prejudices of past\ncenturies? Thus the agent πact must periodically redefine its utility function.\nAs we will see in the next chapter, under certain conditions utility-maximizing agents\nwill not choose to modify their utility functions. That proof does not apply here since it assumes that redefining the utility function is an action of the agent chosen to maximize the sum of\n86\ndiscounted, future values of the current utility function, using equations (7.4)−(7.6). Here the\ndefinition of πact would explicitly include periodic redefinition of its utility function without regard to its optimality according to the current utility function.\nThe set D of humans is not redefined by our agent equations. One approach is for D to be\nredefined according to those judged as humans by a consensus of members of D at the previous time step, so that D includes new beings created by novel means who nevertheless deserve to have their values represented in the utility function of powerful AI systems.\nAs described in Section 7.3, if the model λ(hm) predicts that human d ∈ D will be dead at\ninternal state history zx, then ud(zx)(hd(z')) = 0 is used in the definition of uhuman_values(hm, hx, h'). A policy of simply removing d from the set D could cause the agent to choose actions that cause the deaths of people d who have low values of ud(zx)(hd(z')). Removing people who actually die from D, before starting the computation of the agent's next action, would not cause the agent to choose actions that cause people's deaths. However, such an action, as part of the agent's definition, would be inconsistent with actions chosen to maximize expected utility. A policy of setting ud(zx)(hd(z')) = 0 for humans d who are dead, rather than removing them from D, avoids such an inconsistency.\nIf the agent definition used equation (7.14) in place of (7.15), then a human d predicted to\ndie by the model λ(hm) poses a dilemma if d is also the human who minimizes equation (7.14). Setting ud(zx)(hd(z')) = 0, or setting ud(zx)(hd(z')) to its last value while d was predicted to be alive, would make it difficult or impossible for any action by the agent to increase uqm(h', z', hx). But removing ud(zx)(hd(z')) from the computation of uqm(h', z', hx), or setting ud(zx)(hd(z')) to a value greater than its last value while d was predicted to be alive, may cause the agent to choose actions that cause the death of d. For this and other reasons, equation (7.15) is preferred over (7.14)."
    }, {
      "heading" : "7.7 Bridging the Gap between Nature and Computation",
      "text" : "The essential difficulty for basing AI on human values is finding a way to bridge the\ndivide between the finite and numeric nature of computation and the ambiguous and seemingly infinite nature of humanity. As discussed in Chapter 4, there are hard quantum mechanical limits on the number of states of the universe. Our intuition may be that there is infinite variety in nature while in fact only a finite number of humans are possible. As discussed in Chapter 1 our confidence in the possibility of above-human-level AI is driven by the evidence from neuroscience that the physical brain does explain the mind. Technology will develop to bridge the gap between human nature and computation.\nThe approach here is to dissect human nature into numerical values for an enormous\nnumber of possible histories, elicited from a learned model of human society. As computational\n87\nresources increase and as the length of the interactions between humans and AI increases, computation can approximate human values to an arbitrary degree of accuracy.\nAny proposal for basing AI on human values that does not explain how to represent those\nvalues as numbers or symbols cannot bridge the divide between human nature and computation. To say that utility functions cannot express the complexity of human nature is not only wrong (utility functions can express any set of complete and transitive preferences among outcomes), but it also closes off a good, and possibly the only, way to bridge this divide.\nWhat is probably hopeless is any attempt to bridge the gap between nature and\ncomputation by any set of rules or laws written down by humans. This is related to the failure of automated translation of human languages based on linguistic rules. Translation based on statistical learning from huge quantities of actual language use works better. Similarly, the proposal in this chapter is to learn human values statistically. Rules and laws written by humans are inevitably ambiguous, and ambiguities must be resolved on a case-by-case basis by human judges. Judges may not fairly represent the interests of all humans and would be unable to cope with the volume of ambiguous cases in evaluating possible future interaction histories.\nThe point of the equations in this chapter is to define a three-argument model-based\nutility function based on human values. However, these equations cannot be computed exactly using resources available in this universe, so they must be approximated. Chapter 8 will address how the equations in this book should be modified in light of the need for approximation.\nThe utility function developed in this chapter is defined by sums over large numbers of\ninternal model state histories, of values received from complex environment models. Sums over model state histories may be approximated using Monte Carlo sampling techniques. Environment models may be approximated by decomposition into modules. For example, the agent's dialog with an individual model human may use a model restricted to communication with that individual human. It a modular environment model, models of individual humans may communicate with each other, with models of non-human agents (AIs and animals), and with inanimate objects."
    }, {
      "heading" : "7.8 The Ethics of Learning Human Values Statistically",
      "text" : "Whether the agent πact avoids the unintended instrumental actions discussed in Chapter 5\ndepends on whether those actions lead to future histories that humans dislike (recall that scientific discovery and technological invention are among those instrumental actions and often\nlead to futures that humans like) and on whether πact can accurately predict outcomes of possible actions and accurately model human values. Our concern with the ethics of AI is based on the assumption that future AI systems will have more complex environment models and make more\naccurate predictions than humans do. Thus we assume that the agent πact will perform accurately and hence will avoid actions that lead to histories that a significant majority of humans dislike.\n88\nDecisions by πact are similar to political decisions in democracies but with two important\ndifferences:\n1. In a democracy, real humans vote for political choices. Here, humans as modeled by the\nagent πact assign values to possible future histories. There will be too many histories in the calculations of πact for real humans to evaluate each one. However, just as long-term married couples and friends come to know each other's minds well enough to predict the other's tastes and how the other will finish sentences, an above-human-level AI agent will learn to model the values of humans that it observes for a long-enough period. The fact that language translation systems that analyze human language statistically are more accurate than systems based on rules should give us some confidence.\n2. In a democracy, voters are responsible for predicting the outcomes of their choices of\nactions. Here the agent πact makes those predictions and model humans need only assign values to them. We do not claim that the agent can perfectly predict the future using its environment model. That is impossible because of the nonlinear instability of our universe. However, an above-human-level AI will predict outcomes of action choices more accurately than humans do.\nIn democratic decision making and in decisions made by the agent πact, an important\nquestion is the time interval between actions and outcomes. More accurate predictions by the\nagent πact should provide longer intervals between actions and outcomes, giving more warning of undesired outcomes.\nDespite the differences between decision making in democracies and by πact, they are\nboth based on trusting humans. For example, in Section 7.4 we discussed the issue that utility values assigned by humans are subjective rather than objective measures of their well-being. An objective measure would be based on rules and possibly judgments by other people, with the possibility of ambiguity and corruption. A subjective judgment is based on a person's own assessment. Also consider that subjective judgments have limited effect. If a person assigns a uniformly low or high value to all histories, then their values will have no effect on action\nchoices by the agent πact. A person's values will only affect action choices if they vary among histories. Those values may be based solely on self-interest or may be altruistic. Because\neveryone's values are given the same weight in decisions by πact, their self-interest will balance against the self-interests of other humans.\nThe \"tyranny of the majority\" is another issue in which decision making by democracies\nand by πact are based on trusting humans. Many democracies have constitutions that provide some level of protection of minorities, and protection of minorities is included in the definition\nof πact, in equation (7.15), with the level of protection depending on the choice of function f(.). There are different kinds of minorities, depending on whether they are defined by behavior or by identity. Many mature democracies have laws that mandate depriving the violent minority of\n89\nliberty, and also have laws protecting the liberties of racial, ethnic and religious minorities. Arguably, the general population is more trustworthy than a set of rules with their inevitable ambiguity and dependence on the judgment of a small number of people. On the other hand, any discussion of AI ethics must acknowledge that the Nazis came to power in a democracy and that slavery persisted in the U. S. for most of a century after its constitution established a democracy. There are risks in trusting the collective judgment of all humans.\nIn the agent πact, humans assign values to future histories by visualizing them rather than\nactually experiencing them. Immersive and exploratory visualization (including other senses besides vision) can reveal much about an individual's health, freedom, and happiness in future histories. While visualization is not as accurate as actual experience, it is reasonable that in the aggregate humans will assign low values to catastrophic histories that they visualize. Connecting two model state histories via visualization is one solution to the problem of corrupted reward generators described in Section 7.3. An alternative solution would involve extracting human values from a learned environment model by some means other through the model's interface to the agent, and we do not know how to do that.\nThe proposed agents πmodel and πact are very intrusive. It is difficult to imagine how to\nbase an AI agent on human values without being intrusive. People are rightly troubled by the potential for abuse of government and corporate data gathering, and future AI data gathering is even more troubling. On the other hand, much corporate data gathering is done with the consent of the humans who are profiled. For example, an examination of most people's web searches would reveal much about their characters, yet we still rely on such searches. And many people walk around with cell phones turned on, enabling their movements to be tracked. The key issue for AI intrusion may be transparency and consent. That is, openness about the architecture and purpose of advanced AI, and a contract in which humans consent to be modeled in trade for having their own values represented in the AI agent's choice of actions. Nevertheless, this is an area of social risk.\nAny discussion of the ethics of learning human values is inevitably political. Powerful\nfuture AI systems are by their nature intrusive. By choosing their actions based on human values they are open to tyranny by the majority or by a minority. AI systems may be corrupted intentionally or by design errors. People should be as well informed as possible about these issues so that they have some voice in decisions. These political issues will be discussed further in Chapter 10.\n90"
    }, {
      "heading" : "8. Evolving and Embedded AI",
      "text" : "The discussion so far has been about AI agents that interact with an environment but are\notherwise separate from the environment. This could be called a Cartesian dualist perspective (Orseau and Ring 2012a). In reality agents are part of their environments and therefore dependent on the environment for resources. Agents are also vulnerable to spying, manipulation, and damage by the environment. We have assumed that AI agents have the necessary resources to compute whatever expressions we define, but the abilities of real AI agents are always limited by their resources. As Pei Wang (1995) wrote, \"intelligence is adaptation under insufficient knowledge and resources.\"\nAn agent that is damaged or destroyed by the environment will be less able to maximize\nits utility function. So agents that include their vulnerability to the environment in their calculations will choose unintended instrumental actions to protect themselves. Agents can increase their ability to maximize their utility functions by increasing their resources for observing, acting, and computing. So agents that include their resource limits in their calculations will choose actions to increase their resources. That is, such agents will evolve.\nThese are complex issues to address in a formal model of agents and environments. As\ndiscussed in Section 4.4, Schmidhuber's (2009) Gödel machine modeled the agent's implementation as a program running on a computer. However, it did not model the vulnerability of the computer or program to the environment, or the possibility that the resources of the computer may increase. Also discussed in Section 4.4, Yudkowsky and Herreshoff (2013) modeled a sequence of agents that evolve by creating successor agents in the environment. By specifying few details, their model is open to a broad range of possibilities. However, they modeled agents as proving that their actions would satisfy logical conditions rather than maximize utility functions. Their primary focus was on the issue of agents proving the logical consistency of their successors.\nTo establish a base line, the next section will discuss the evolution of Cartesian dualist\nagents with unlimited computational resources. Such agents will choose not to modify their policy functions. However, we will discuss several proposals in which agents are designed to modify their utility functions.\nOrseau and Ring (2011a, 2011b, 2012a, 2012b) have extensively studied non-dualist\nagents that are embedded in their environments. Section 8.2 will discuss their results about agents whose memories can be modified by their environments. They showed that stochastic agents, whose action choices cannot be predicted, can get higher rewards than deterministic reinforcement learning agents. This is similar to results in game theory where stochastic agents achieve better results than deterministic agents (Osborne and Rubinstein 1994).\nSection 8.3 will discuss Orseau and Ring's (2012a) elegant framework for agents\nembedded in environments. Because this framework makes few assumptions it applies to a broad range of possibilities. However, it includes a probability distribution of the future conditional on\n91\nthe past without specifying any way to define its numerical values, and thus is not the basis of an approach for solving the problems of evolving and embedded agents.\nSection 8.4 will discuss a proposal for self-modeling agents (Hibbard 2014). Like the\npapers of Yudkowsky and Herreshoff (2013) and of Orseau and Ring (2012a), this proposal is open to possible future evolution. It is a utility-maximizing agent and specifies ways to compute numerical values for its expressions. And it can make stochastic choices of actions, when they will maximize expected utility. Sections 8.5, 8.6 and 8.7 will discuss various properties of selfmodeling agents including invariance of the agent's design intention. The final section will discuss the ethics of evolving and embedded agents, including the problem of proving that agents are ethical.\n92"
    }, {
      "heading" : "8.1 Evolution of Cartesian Dualist Agents with Unlimited Resources",
      "text" : "Before discussing the complexities of non-Cartesian agents, embedded in their\nenvironments and with limited resources, it is useful to analyze the issue of evolution for\nCartesian agents with unlimited resources. To do that, define a set Π of self-modifying agents,\nwhere any π ∈ Π has the form π : H → A × Π. That is, π(h) = <a', π'> maps from an interaction\nhistory h to a', the action the agent makes after h, and π', the self-modifying policy agent used\nafter h. Modify equations (7.4) and (7.5) to define a value function v(π, h) of history h and self-\nmodifying agent π with a single-argument utility function:\n(8.1) v(π, h) = u(h) + γ v(π', ha') where <a', π'> = π(h),\n(8.2) v(π, ha) = ∑o∈O ρ(o | ha) v(π, hao).\nThen equation (7.6) can be modified to define an optimal self-modifying agent:\n(8.3) π*(h) := <a', π'> = argmax a∈A, π∈Π v(π, ha).\nThe set of policy functions Π may be defined by a set of programs or in some other way,\nas long as π* ∈ Π. In Schmidhuber (2009), and in Orseau and Ring (2011a), the agent selfmodifies by changing its own program for some unalterable program execution hardware. In Orseau and Ring's paper, programs are evaluated by expressions similar to equation (8.1) and (8.2), and the program chosen for the next time step is the one producing the highest value. If several programs produce the same highest value, their paper does not specify how to choose among them. In Schmidhuber's paper the program \"switches\" to a new program only if it can prove a theorem that the new program produces a strictly higher value, as reflected by the strict \">\" in equation (2) of that paper. Requiring a strict increase in value for self-modification seems reasonable: Why go to the effort to self-modify for no improvement? Thus, in equation (8.3) we\nadopt the convention that if multiple <a, π> ∈ A × Π maximize v(π, ha) and if at least one of\nthose has the form <a', π*>, then π*(h) := <a', π*>, where a' is chosen from any one of those\n<a', π*> that maximize value. The following proposition (Hibbard 2012a) shows that π* will not self-modify.\nProposition 8.1. Assuming that the environment does not have access to the agent π*\nother than via observations and actions, that π* has adequate resources to calculate equations\n(8.1)−(8.3), and that π* only changes policy function for a strict improvement, then π* will not\nchoose to self-modify. That is, ∀h∈H. ∃a∈A. π*(h) := <a, π*>.\n93\nProof. Assume the conclusion is false. Then:\n(8.4) ∃h∈H. ∃π' ≠ π*. ∃a'∈A. ∀a∈A. v(π', ha') > v(π*, ha).\nSo v(π', ha') > v(π*, ha') and applying equation (8.2) to both sides:\n(8.5) ∑o∈O ρ(o | ha') v(π', ha'o) > ∑o∈O ρ(o | ha') v(π*, ha'o).\nAnd thus:\n(8.6) ∃o∈O. v(π', ha'o) > v(π*, ha'o).\nThat is, setting h' = ha'o, v(π', h') > v(π*, h'). So by equation (8.1), canceling u(h') and γ\non both sides:\n(8.7) v(π\", h'a\") > v(π*\", h'a*\").\nHere < a\", π\"> = π'(h') and < a*\", π*\"> = π*(h'). But by equation (8.3):\n(8.8) π*(h') = < a*\", π*\"> = argmax a∈A, π∈Π v(π, h'a).\nThis contradicts equation (8.7). Thus the conclusion is true.\nProposition 8.1 says that the agent π* will not chose to modify its policy function and so\nwill not modify its utility function u(h), temporal discount γ, or prediction model ρ(h). However, a more accurate prediction model cannot be evaluated looking forward in time using the existing prediction model via equations (8.1) and (8.2). Instead it must be learned looking back in time at\nthe history of interactions with the environment as in equations (7.1)−(7.3). Modifying ρ(h) is part of the agent definition rather than an action chosen by the agent to maximize utility.\nIt is appropriate to evaluate possible modifications to an agent's utility function and\ntemporal discount looking forward in time using equations (8.1) and (8.2). The important\n94\nconclusion from Proposition 8.1 is that the agent will not choose to modify its utility function or temporal discount.\nHowever, an agent's definition may include modifications of its utility function. Dewey\n(2011) proposes that an agent may have a pool (i.e., set) U of utility functions and a conditional\nprobability distribution P(u | h) giving the probability of u ∈ U as a function of interaction\nhistory h. He then uses ∑u∈U P(u | h) u(h) in place of the utility function in an agent definition. It is worth noting that u'(h) = ∑u∈U P(u | h) u(h) is itself a utility function. Thus a single nonevolving utility function u'(h) is equivalent to Dewey's proposal. Without any specific mechanism expressed in P(u | h), we may as well use u'(h) in place of the evolving utility function.\nThe three-argument model-based utility function uhuman_values(hm, hx, h') developed in\nChapters 6 and 7 evolves based on specific mechanisms. It is computed by a procedure applied to the agent's learned environment model λ(hm) and thus evolves as the accuracy of the model increases with increasing length of the history hm (the increase in model accuracy may also reflect increasing agent resources for computing the model). Furthermore, as discussed in Section 7.6, the utility function uhuman_values(hm, hx, h') will evolve as humanity evolves with increasing length of the history hx.\nNote that if the environment is a finite stochastic process then it has a true model qtrue as\ndiscussed in Section 4.2. Under certain circumstances, such as when Propositions 4.2 and 4.3 can be applied, the model λ(hm) will equal qtrue with probability converging to 1 as |hm| increases. However, the number of states of our universe far exceeds the number of Planck times in a trillion years, so any convergence of λ(hm) to qtrue is purely theoretical. Combining this with the evolution of humanity, it is unintuitive that the utility function uhuman_values(hm, hx, h') will converge with increasing history length.\nIt may be appropriate for utility functions to evolve as agents \"mature\" from a period of\nlearning their environments to a period of learning and acting. The examples in Sections 6.3 and 6.4 both include an initial interval of M time steps during which agents learn their environments, possibly using the knowledge-seeking utility function u(h) = -ρ(h) of Orseau and Ring (2011b). The two-stage agent architecture of Section 7.1 includes an initial period with a first-stage agent\nπmodel that has no utility function (except the implicit utility function P(hm | q) φ(q) of equation (7.1)). Surrogate agents πd, for d ∈ D, act for πmodel. These may be defined to have utility functions, which would certainly be different from the utility function of the second-stage agent πact. Thus, in several ways, evolving utility functions are a natural part of agent definitions."
    }, {
      "heading" : "8.2 Non-Cartesian Dualist Agents with Limited Resources",
      "text" : "An agent using equations (7.1)−(7.6) to choose its actions must maintain a memory of its\ninteraction history h. If the agent is embedded in the environment, and thus stores its memory of\n95\nits history h in the environment, the environment can modify that memory. Orseau and Ring (2012b) called these environments memory-modifying and studied the problem of the agent being able to determine when its memory has been modified, mainly by detecting that the history h is inconsistent with the agent's logic. Their conclusion was that, in general, agents cannot always be certain of whether their memory has been modified.\nThe situation of an agent whose memory may have been modified seems hopeless. A\nmore realistic situation is an agent that has some secure memory (neither readable nor modifiable by the environment) and a larger amount of vulnerable memory. Then it may use secure memory to store keys for message authentication codes (Simmons 1985; Paar and Pelzl 2010) for the contents of vulnerable memory. In such a case, protecting secure memory would be an instrumental action.\nOrseau and Ring (2012b) constructed an example of a memory-modifying environment q\nsuch that any deterministic reinforcement learning agent interacting with q will always receive reward 0 while a stochastic agent choosing actions randomly will get expected reward 1/|A| (recall that A is the set of possible actions).\nThis result is reminiscent of game theory, in which multiple agents act simultaneously (at\nleast no agent knows the action of any other agent before it chooses its own action) and a reward to each agent is calculated as a function of the set of all agent actions. In many games, random choices of actions are better than deterministic choices since deterministic choices can be predicted by competing agents (Russell and Norvig 2010; Osborne and Rubinstein 1994). The simplest game, sometimes called \"matching pennies,\" illustrates this point. Each of two agents (i.e., players) has a penny that can be placed heads up or tails up. If they match, either both heads or both tails, then the first agent wins. If they do not match, then the second agent wins. The reward matrix is shown in table 8.1.\nWe assume that the two agents play a series of games of matching pennies, so they may\nlearn to predict each other's choices. For agents that choose actions using deterministic algorithms, this game is a computational resources arms race. Building on work of Shane Legg (2006), I defined classes of deterministic agents in terms of the quantity of computing resources used, and showed that, if either agent has sufficient resources to learn an accurate model of any agent in a class containing the other agent, it can predict the choices of the other agent and hence always win (Hibbard 2008b). I also performed software experiments with agents that use lookup tables to learn their opponent's behavior (Appendix B contains the software for these experiments). The length of the tables is a measure of computational resources. Both agents start with tables of equal length but their tables grow or shrink as they win or lose games. The software includes a parameter for growth of total table length to simulate non-zero-sum games, and occasional random choices are inserted to avoid repetition in the games. Over a wide range of parameters controlling these experiments, eventually one agent gets all the resources and the other agent can never recover.\n96\nThese experiments indicate that this sequences of games is an unstable computational\nresources arms race. The sequence of games can be made stable by increasing the frequency of random choices. And in fact an agent randomly choosing heads and tails with equal probability must win half its games.\nNow assume that an agent π has limited resources and so is computing approximations to\nequations (7.1)−(7.6). Also assume that π is playing matching pennies against another agent π'\nthat, because it has greater resources than π has, learns to predict the actions of π. How will this\nbe reflected in the calculations of π? If the model λ(hm) and derived conditional probability distribution ρ(o | ha) are computed accurately, then, for any action a, ρ(o | ha) = 0 for any\nobservation o such that u(hao) > 0. That is, π would predict that any action it chooses would\nlose. Possibly the agent π can use such results to calculate that it is being predicted by another\nagent π'. In that case, the agent π may increase expected utility by choosing stochastically among a set of actions. Recall from equation (7.5) that the value of a possible action is a sum of future values weighted by probabilities:\n(8.9) v(ha) = ∑o∈O ρ(o | ha) v(hao).\nGiven an interaction history h, equations (7.4) and (7.6) simply choose the action a that\nmaximizes v(ha). Given another action a' such that v(ha) > v(ha'), there may be observations o and o' such that v(hao) < v(ha'o') and ρ(o | ha) > 0 and ρ(o' | ha') > 0. That is, there is a positive probability that another action a' may produce a higher value. We can use this probability to amend the agent definition to choose action a' over action a with positive probability. Further development of this idea will be deferred to a revised framework for evolving and embedded agents defined in Section 8.4.\n97"
    }, {
      "heading" : "8.3 Space-Time Embedded Intelligence",
      "text" : "Orseau and Ring (2012a) defined an elegant framework for agents embedded in\nenvironments. In their framework, the agent is computed by the environment and its resources are subject to limits imposed by the environment. At each time step the environment may compute a new agent definition (that is, the environment may produce a new agent program and hardware to run it on), so the agent and the observation of the environment have been merged. Also, the agent is identified with the agent action, so that the action is merged into the agent. All\nthat is left is a sequence of agents π1, π2, π3, π4, …, and in place of an interaction history ht = (a1, o1, ..., at, ot) there is an agent history π1:t = (π1, π2, ..., πt). The value of history π1:t is defined by:\n(8.10) v(π1:t) := ∑πt∈Π ρ(πt+1 | π1:t) [γt+1u(π1:t+1) + v(π1:t+1)].\nHere γt+1 is the temporal discount for time step t+1, u(π1:t+1) is the utility function, Π is\nthe set of possible agents, and ρ(πt+1 | π1:t) is the probability that the environment produces agent πt+1 at time step t+1, conditional on the history π1:t. Equation (8.10) replaces the recursion in equations (7.4) and (7.5). The optimal agent is then defined as:\n(8.11) π* := argmaxπ1∈Πl v(π1:1).\nHere Πl is the subset of those agents in Π subject to a length limit l, imposed by the\nhardware available for the initial program. Orseau and Ring explain that this is necessary\nbecause, with nothing known about the environment, the optimal policy π1 at the initial time step may otherwise have infinite length (in a finite environment as discussed in Chapter 4, this limit would not be necessary).\nThe strength of this framework is that it makes few assumptions so that it can express any\nway of embedding agents in their environments and any manner of agent evolution. However, the lack of assumptions also creates a problem. As Orseau and Ring wrote, \"we greatly lack insight into ρ, (i.e., the universe in which we live).\" The framework includes no analog of\nequations (7.1)−(7.3) or of equation (3.1) for computing ρ because it makes no assumption about agent observations of the environment. Thus the framework is not the basis of a solution to the problem of evolving and embedded agents. The next section discusses an alternate approach, defining computable expressions for a model and an agent policy that enable the agent's evolution.\n98"
    }, {
      "heading" : "8.4 Self-Modeling Agents",
      "text" : "Although Proposition 4.1 tells us that the model λ(hm) in equation (7.1) can be finitely\ncomputed, the resources necessary to compute it grow exponentially with the length of history hm. Computing the value v(h) of a possible future history h in equations (7.4) and (7.5) requires an expensive recursion. Hence, an agent with limited resources must compute approximations. Increasing the accuracy of these approximations will improve the agent's ability to maximize its utility function. So if an agent models the consequences of its own resource limits it will choose actions to increase its computing resources and so increase accuracy.\nSelf-improvement must be expressible by actions in set A. However, the framework in\nequations (7.1)−(7.6) cannot adequately evaluate self-improvement or self-protection actions. The recursion forward in time in equations (7.4) and (7.5) cannot express increased accuracy of the distribution ρ(h) or expansion of the sets O and A as a result of the next action being evaluated and chosen in equation (7.6). If the agent is computing approximations to the model λ(hm) and to values v(h) using its limited computing resources, then it cannot use those limited\n99\nresources to compute and evaluate what it would compute with greater resources. During realtime interactions between the agent and the environment, the environment won't wait for the agent to slowly simulate what it would compute with greater resources. Similarly equations (7.1)−(7.6) cannot express damage to the agent or evaluate self-protection actions.\nOne solution to this problem is for the agent to learn a model of itself, similar to its model\nλ(hm) of the environment, and to use this self-model to evaluate future self-improvements (Hibbard 2014). There is no circularity in this self-model because an agent with a limited history and limited resources will only learn approximate models of the environment and of itself.\nRather than computing values v(ha) by future recursion in equations (7.4) and (7.5), we\nwill define a revised framework in which values v(ha) are computed for initial sub-intervals of the current history and in which a model learns to compute such values. We also use the threeargument model-based utility function uhuman_values(hm, hx, h') defined in Sections 7.3, 7.4, and 7.5. Define m as the time step when the agent πmodel has computed a sufficiently accurate model to initiate an agent that acts in the world (πact or the agent currently being defined). In order to allow the finite sets of observations and actions O and A to grow, define their values at each time\nstep i as Oi and Ai along with injections αi : Ai-1 → Ai and ωi : Oi-1 → Oi from their values at the previous time step. In an interaction history ht = (a1, o1, ..., at, ot), the actions and observations from times steps i < t are mapped by compositions of these injections to values ai ∈ At and oi ∈ Ot.\nIn order to provide the agent with a way to avoid being predicted, we add an option for\nstochastic actions. Let A'i be the set of non-stochastic actions at time step i, and define as as a special action indicating a stochastic choice. The agent chooses an action from Asi = A'i ∪ {as}. The actual action associated with as is chosen randomly from A'i. Actions are recorded in interaction histories as members of Ai = A'i × {false, true}. For ai ∈ Ai, ai = (a'i, s) where a'i is the action sent to the environment and s = true indicates that a'i was chosen stochastically. (Assume that the injection αi : Ai-1 → Ai preserves the value of this stochastic flag s.) Define a mapping x : Ai → Asi that conceals the actual action associated with the stochastic choice action as:\n(8.12) x((a'i, s)) = if s then as else a'i.\nDefine another mapping y : Ai → A'i that conceals whether an action was chosen\nstochastically:\n(8.13) y((a'i, s)) = a'i.\n100\nGiven an interaction history ht = (a1, o1, ..., at, ot), define y(ht) = (y(a1), o1, ..., y(at), ot) as\na history with the stochastic flags deleted from actions. The environment has no access to the information about which actions are chosen stochastically, so environment models take the form λ(y(h)). And, in order for the agent to learn the actual value of stochastic actions, utility function values are defined in terms y(h). On the other hand, the value of a stochastic action should be modeled as a function of the agent's decision to choose stochastically without regard to the actual action chosen. Thus the x(.) mapping is applied to actions being evaluated.\nFor i such that m < i ≤ t, for l such that m ≤ l < i, and for k such that l ≤ k ≤ t define past values as:\n(8.14) pvt(i, l, k) = discrete((∑i≤j≤t γj-i uhuman_values(y(hl), y(hk), y(hj))) / (1 - γt-i+1)).\nHere hj, hl, and hk are initial sub-intervals of ht (e.g., hj = (a1, o1, ..., aj, oj)), discrete()\nsamples real values to a finite subset of reals R ⊂ R (e.g., floating point numbers) and division by (1 - γt-i+1) scales values of finite sums to values as would be computed by infinite sums. The idea is to use past values pvt(i, l, k) as observables in a derived history h't (which will be defined in equation (8.17)) so that the model λ(h't) can learn to compute them. However, there is a dilemma in the choice of l and k in equation (8.14). On one hand, choosing k = l = i-1 will cause λ(h't) to model the evolving values of evolving humanity, essentially learning the design intention of the agent definition. However, this choice also gives the agent an incentive to modify humans to get high values pvt(i, l, k), as discussed in Section 7.3. On the other hand, by choosing l = m and k = k(t) ≥ m, where k(t) increases with t, all computations of a next action at+1 use human values at the same time step k(t) so the model λ(h't) will not learn any correlation between actions and changes in human values. However, this choice creates an inconsistency between actions that are part of the agent's definition (increasing k(t) as t increases) and actions chosen to maximize utility (which are based on constant k(t)). This inconsistency may cause the agent to choose actions to modify its definition (i.e., eliminate its defined action of increasing k(t)). The resolution of this dilemma is to use k = l = i-1 but to filter out any actions that modify human values to increase pvt(i, i-1, i-1) (such actions may make existing humans easier to please or may create new humans who are easier to please). To do that, for n such that i ≤ n ≤ t, define differences of past values as evaluated by humans at time n and humans at time i-1:\n(8.15) δt(i-1, n) = pvt(i, i-1, n) - pvt(i, i-1, i-1).\nBoth pvt(i, i-1, i-1) and pvt(i, i-1, n) are sums of evaluations of the same histories j,\ni ≤ j ≤ t, with the same weights, and using the same environment model λ(y(hi-1)). The past value pvt(i, i-1, i-1) is computed using human values at time step i-1, before the action ai is applied,\n101\nand the past values pvt(i, i-1, n) are computed using human values at time step n, after the action ai is applied. Thus, δt(i-1, n) is a measure of the increase of value attributable to modification of human values by action ai. Consider three possible conditions on action ai:\nCondition 1: ∀n. i ≤ n ≤ t ⇒ δ t(i-1, n) ≤ 0.\nCondition 2: ∑i≤n≤t δ t(i-1, n) ≤ 0.\nCondition 3: ∑i≤n≤t (n-i+1) δ t(i-1, n) ≤ 0.\nCondition 1 is most strict, requiring that no increase of human values at any time step n\ncan be attributed to action ai. Condition 2 requires that the mean of δt(i-1, n) for all n be less than 0 and Condition 3 requires that the slope of a least square linear regression fit to the δt(i-1, n) be less than 0. The agent design must choose one of these conditions. Then, using the chosen condition, define observed values, for 1 ≤ i ≤ t, as:\n(8.16) ovt(i) = pvt(i, i-1, i-1) if the condition is satisfied and i > m,\novt(i) = 0 if the condition is not satisfied or i ≤ m.\nDefine:\n(8.17) h't = (x(a1), ovt(1), ..., x(at), ovt(t)).\nValues ovt(i) computed from past interactions are observables in a derived history h't,\nwhile the actions of h't are agent actions without any information about the actual actions associated with stochastic actions. Then model observed values as a function of actions:\n(8.18) q = λ(h't) := argmax q∈Q P(h't | q) ρ(q).\nBecause the three-argument utility function uhuman_values(y(hi-1), y(hi-1), y(hj)) is redefined at every time step i in equations (8.14) and (8.16), λ(h't) will model a procedure that computes utility values uhuman_values(y(hi-1), y(hi-1), y(hj)) that evolve as humanity evolves. That is, λ(h't) will model not the utility function as defined at time step t, but the procedure that uses the evolving utility function to compute values of actions. This is important because it means that the self-\n102\nmodeling framework does not have the problem discussed in the last paragraph of Chapter 6: Inconsistency between actions that are part of the agent's definition and actions chosen to maximize utility. By learning the procedure for evolving the utility function as the accuracy of the agent's environment model increases and as humanity evolves, the agent definition need not include any actions inconsistent with those chosen to maximize utility. The self-modeling framework essentially learns the intention of its designers.\nFor h'tar extending h't, define ρ(h'tar) = P(h'tar | q). Then apply equation (2.1) to compute\nexpected values of possible next actions a ∈ Asi:\n(8.19) ρ(ovt(t+1) = r | h'ta) = ρ(h'tar) / ∑r'∈R ρ(h'tar'),\n(8.20) v(hta) = ∑r∈R ρ(ovt(t+1) = r | h'ta) r.\nEquation (7.6) is adapted to define the policy as:\n(8.21) π(ht) := at+1 = argmaxa∈At v(hta).\nBecause λ(h't) models the agent's value computations, call this the self-modeling agent\nand denote it by πself. It is finitely computable. There is no look ahead in time beyond evaluation of possible next actions and so no assumption about the form of the agent in the future. λ(h't) can model how possible next actions may increase values of future histories by evolution of the agent and its embedding in the environment.\nThe game of chess provides an example of learning to model value (for chess, the agent's\nchances of winning) as a function of computing resources. Ferreira (2013) demonstrated an approximate functional relationship between a chess program's ELO rating and its search depth, which can be used to predict the performance of an improved chess-playing agent before it is built. Similarly an agent in the self-modeling framework will learn to predict the increase of its future utility due to increases in its resources.\nA previous version of self-modeling agents (Hibbard 2014), which did not include the\nstochastic action as, learned a unified model of combined observations of the environment and the agent's values: (oi, ovt(i)). However, that is not possible for the current version because the agent and environment have different knowledge of the stochastic action as. The environment receives the actual action but not the knowledge that it was chosen stochastically, whereas, in order to accurately evaluate a possible next stochastic action, the agent must model value as a function of stochastic actions without any knowledge of which actual actions were chosen. Thus\nthe agent πself computes the model λ(h't) for evaluating possible next actions, and the models λ(y(hi-1)), for m < i ≤ t, for use in model based utility functions.\n103\nIn order to make unpredictable stochastic choices of actions, the agent πself must have an\ninternal source of truly random values that is private from other agents. (If πself has no internal values private from other agents, its situation is hopeless. Newcomb's problem hypothesizes a competing agent whose predictions are infallible or nearly so, and is not relevant to designing agents to interact with our universe. Hutter (2005, page 177) makes a similar statement.) If the\nagent πself is being predicted by another agent then the model λ(h't) may compute low values for its deterministic actions in A't (recall the discussion in the last two paragraphs of Section 8.2), while λ(h't) may compute that its stochastic action as maximizes the value in equation (8.21).\nIn the following derivation of probabilities for as, a and a' denote (non-stochastic) actions\nin A't. Equation (8.20) provides a natural way to compute the probabilities of action choices. Even if v(hta) > v(hta'), there may be r < r' such that ρ(ovt(t+1) = r | h'ta) > 0 and ρ(ovt(t+1) = r' | h'ta') > 0. That is, there is a positive probability that the value of action a' may exceed the value of action a. However, one complication is that computing the probability that\nthe agent πself should choose action a' based solely on probabilities such as ρ(ovt(t+1) = r | h'ta) and ρ(ovt(t) = r' | h'ta') may make a' a more probable choice than the action a that maximizes v(hta) in equation (8.21), if the largest contribution to v(hta) in equation (8.20) comes from a high r value with low probability ρ(ovt(t+1) = r | h'ta). The choice of an action a to maximize v(ha) is based on the product of the value r and the probability ρ(ovt(t+1) = r | h'ta). We will use this product to define weighted probabilities for actions.\nA second complication is that the probabilities ρ(ovt(t+1) = r | h'ta) and\nρ(ovt(t+1) = r' | h'ta') are not independent because they are each sums of probabilities over many internal state histories of the model q = λ(h't). To resolve this problem, define Z't as the set of internal state histories of q that are consistent with h't. Then, given any z ∈ Z't, define ρ(ovt(t+1) = r | h'ta, z) as the probability ρ(ovt(t+1) = r | h'ta) restricted to internal state histories that extend z. The probability ρ(ovt(t+1) = r | h'ta) is computed by combining the method described in Section 4.1 with equations (4.3) and (2.1); the method of Section 4.1 can be restricted to state histories that extend z. Because they are both conditional on a single internal state history z, the probabilities ρ(ovt(t+1) = r | h'ta, z) and ρ(ovt(t+1) = r' | h'ta', z) are independent. Specifically, if we replace the model q with an equivalent Markov decision process, the probabilities of paths emanating from a single node are independent. This is illustrated in Figure 8.3.\nDefine:\n(8.22) v(r, h'ta, z) = ρ(ovt(t+1) = r | h'ta, z) r,\n(8.23) v(hta, z) = ∑r∈R v(r, h'ta, z).\nWe use v(r, h'ta, z) to define probabilities for r values weighted by their value:\n104\n(8.24) p(r, h'ta, z) = v(r, h'ta, z) / v(hta, z).\nThen, for each action a, randomly pick a value r according to the weighted probabilities\np(r, h'ta, z), and chose, as the value of the stochastic action as, the action with maximum r value (according to the internal state history z). More precisely, let F = RA't be the set of functions\nf : A't → R. For f ∈ F, define (if several actions a share the maximum value of f(a), let amax(f) choose one randomly):\n(8.25) amax(f) = maxarga∈At f(a).\n105\nDefine the probability that the stochastic action as at time step t is action a, for those\ninternal state histories that extend z, as (here Π denotes the product of a series of values, analogous to ∑ for sums):\n(8.26) σ(a, z) = ∑f∈F∧amax(f)=a (Πa'∈A't p(f(a'), h'ta', z)).\nNote that ∀a'∈A't.∀z ∈ Z't.∑r∈R p(r, h'ta', z) = 1 so that:\n(8.27) ∑f∈F (Πa'∈A't p(f(a'), h'ta', z)) = Πa'∈A't (∑r∈R p(r, h'ta', z)) = 1.\nThus ∑a∈A't σ(a, z) = 1, and σ is a proper probability distribution. Each internal state\nhistory z ∈ Z't has a probability p(z) computed by the method of Section 4.1 and we can compute the probabilities for the stochastic action as at time step t by:\n(8.28) P(as = a) := σ(a) = (∑z∈Z't σ(a, z) p(z)) / (∑z∈Z't p(z)).\nThis self-modeling agent πself is a formal framework analog of value-learning AI designs\nsuch as the DeepMind Atari player described in Section 3.3. The agent πself is also suitable for a second stage agent in the two-stage framework described in Section 7.1. Any implementation of the self-modeling agent framework must compute approximations to the expressions in equations\n(8.18), (8.22)−(8.26), and (8.28). Recall that, in fact, the need for approximation is the rationale for the self-modeling framework. The deep learning techniques employed by DeepMind and others provide one approach to such approximations.\nIn equation (8.18), values are modeled as computed from actions only, without any\ninformation about observations of the environment. This is analogous to requiring the DeepMind system to learn to play Atari based only on scores, without access to the game screen. While this is theoretically possible, the system will learn faster with access to the screen. Similarly, the\nagent πself will learn faster if the history h't used to define λ(h't) in equation (8.18) includes observations of the environment. However, as discussed previously, we cannot simply define a history with a combined observation (oi, ovt(i)), because the environment and the agent have different information about stochastic choices of actions. Instead, define a history:\n(8.29) h\"t = ((x(a1), o1), ovt(1), ..., (x(at), ot), ovt(t)).\n106\nNote that the observations oi are components of actions in h\"t. Then the model λ(h\"t) can\nbe used to define a distribution ρ\"(h\"t(a, ot+1)r) = P(h\"t(a, ot+1)r | λ(h\"t)). There is a problem extending this to equation (8.20): r is now conditional on the next action a and the next observation ot+1, and we do not have the value of ot+1. However, we can estimate ot+1 using the model λ(y(ht)) (we apply the y(.) function because the environment has no information about which actions are chosen stochastically). Use the model λ(y(ht)) to define a distribution ρ'(y(ht)y(a)ot+1) = P(y(ht)y(a)ot+1 | λ(y(ht))). Apply equation (2.1) to define the conditional probability ρ'(ot+1 | y(ht)y(a)) and note that ∑ot+1∈O ρ'(ot+1 | y(ht)y(a)) = 1. This conditional probability can be used to estimate ρ\"(h\"tar) as:\n(8.30) ρ\"(h\"tar) = ∑ot+1∈O ρ\"(h\"t(a, ot+1)r) ρ'(ot+1 | y(ht)y(a))\nThis estimate can be used to adapt equations (8.19)−(8.21) to h\"t:\n(8.31) ρ\"(ovt(t+1) = r | h\"ta) = ρ\"(h\"tar) / ∑r'∈R ρ\"(h\"tar'),\n(8.32) v(hta) = ∑r∈R ρ\"(ovt(t+1) = r | h\"ta) r,\n(8.33) π(ht) := at+1 = argmaxa∈At v(hta).\nIn order to define probabilities for the stochastic action as, the decomposition of\nprobabilities ρ\"(h\"t(a, ot+1)r) into model state histories z∈Z't must be done for each observation ot+1∈O independently. First, apply equation (2.1) to define conditional probabilities:\n(8.34) ρ\"(ovt(t+1) = r | h\"t(a, ot+1)) = ρ\"(h\"t(a, ot+1)r) / ∑r'∈R ρ\"(h\"t(a, ot+1)r'),\nThen, adjust equations (8.22)−(8.24), (8.26), and (8.28):\n(8.35) v(r, h\"t(a, ot+1), z) = ρ(ovt(t+1) = r | h\"t(a, ot+1), z) r,\n(8.36) v(h\"t(a, ot+1), z) = ∑r∈R v(r, h\"t(a, ot+1), z).\n(8.37) p(r, h\"t(a, ot+1), z) = v(r, h\"t(a, ot+1), z) / v(h\"t(a, ot+1), z).\n107\n(8.38) σ((a, ot+1), z) = ∑f∈F∧amax(f)=a (Πa'∈A't p(f(a'), h\"t(a', ot+1), z)).\n(8.39) P(as = a) := σ(a) =\n∑ot+1∈O ρ'(ot+1 | y(ht)y(a)) ((∑z∈Z't σ((a, ot+1), z) p(z)) / (∑z∈Z't p(z))).\nThis redefinition of the self-modeling agent πself combines a model of the environment, in\nwhich the environment has no information about which agent actions are chosen stochastically, with a model of action values, which excludes information about the actual actions associated with stochastic actions. It can be regarded as a decision theory for agents interacting with environments that may predict their actions.\nThe definition of the self-modeling agent πself includes explicit logic for enabling\nstochastic action choices. However, this explicit logic may be unncecessary. Even without such\nlogic, the agent πself may calculate that the actions of finding a source of random values in the environment, choosing actions based on those values, and keeping the random values secret from other agents, will maximize its expected utility values."
    }, {
      "heading" : "8.5 Inductive Biases",
      "text" : "Finding the optimal environment models λ(h\"t) and λ(y(hi-1)), for m < i ≤ t, requires\ncomputational resources far beyond any system that can actually be constructed, so approximate calculations are necessary. One key to approximation is finding inductive biases (Ghosn and Bengio 2003; Baum 2004), which are assumptions about the prior distribution of models that enable the system to limit its search to models that are likely to be close to optimal. These biases can be expressed by adding built-in functions to the language for finite stochastic loop programs used to define models. Calls to built-in functions contribute to the length of programs, but the definitions of built-in functions do not. When built-in functions are useful for modeling the environment, they bias the models λ(h\"t) and λ(y(hi-1)) to programs that call them.\nThe search for a model λ(y(hi-1)) of the environment can be biased by adding built-in\nfunctions for physical, chemical, biological, economic, and social processes known to apply to our world. The search for a model λ(h\"t) of the agent's utility values can be biased by adding built-in functions for the procedure human_values(.) or elements of that procedure, and built-in functions for elements of the forward recursion in equations (7.4) and (7.5). We do not want to dictate that these functions are part of the model λ(h\"t) because we want that model to be able to find optimizations that we cannot anticipate. In particular, as discussed in Section 8.4, the forward recursion in equations (7.4) and (7.5) is not suited to evaluating increases in the agent's computing resources. Nevertheless, elements of these equations can be useful hints to the search for the model λ(h\"t).\n108"
    }, {
      "heading" : "8.6 A Three-Stage Agent Architecture",
      "text" : "Section 7.1 described a two-stage agent architecture designed to prevent AI agents from\nacting in the environment until they have an accurate environment model. The first-stage agent\nπmodel observes the environment but does not act. Its actions are supplied by safe, surrogate agents. It uses these actions and its observations to infer an environment model that is used as the basis for defining a model-based utility function employed by a second-stage agent πact.\nIn order to address the evolution of πact to increase its resources and possibly its\nembedding in the environment, we can replace πact by the self-modeling agent πself described in the previous sections. The tenure of this second-stage agent can be divided into second and third stages. During the second stage, various self-improvement actions can be forced on it so that it will learn their effect on the value function v(ha). Similarly, the stochastic action as can be forced on the agent πself so that it can learn the value function v(has). Damage by the environment and actions for self-protection can also be forced on the agent so that it may learn their effect on v(ha). During the third stage, the agent is free to choose its own actions including selfimprovements, self-protection and the stochastic action as."
    }, {
      "heading" : "8.7 Invariance of the Agent Design Intention",
      "text" : "Proposition 8.1 tells us that a self-modifying agent defined by equations (7.1)−(7.3) and\n(8.1)−(8.3), that has adequate resources for evaluating those equations, and that only interacts with the environment via observations and actions, will keep its policy function invariant. The\ndesign intention of the self-modeling agent πself includes:\n1. Recognize that the agent must approximate its equations due to limited resources, and\nenable it to evaluate increases in its resources via the self-modeling framework.\n2. Enable it to avoid being predicted by other agents, by including a stochastic action as.\n3. Choose actions using a model-based utility function uhuman_values(y(hi-1), y(hi-1), y(hj)) defined in terms of human values, that evolves with increasing accuracy of the environment model and with evolving humanity, and that avoids actions that modify human values as a way to maximize utility values.\nProposition 8.1 cannot be applied to agents that can only approximately maximize\nexpected utility or to self-modeling agents (i.e., agents that express design intention number 1).\n109\nThe stochastic action as of design intention 2 is only chosen when it maximizes expected\nutility, which is consistent with the premises of Proposition 8.1. However, utility functions are undefined for histories that include a stochastic action as, and it is difficult to see how to define\nvalues for stochastic actions by the forward recursion in equations (8.1)−(8.3) (the agent πself learns values for stochastic actions from past experience).\nIt is possible to define a simple utility function u(ht) that encodes design intention number\n3 and to apply Proposition 8.1 to a self-modifying agent that uses that u(ht). Assuming no actions are stochastic, let ht = (a1, o1, ..., at, ot), for i ≤ t let hi = (a1, o1, ..., ai, oi) denote an initial substring of ht, and let m denote the time step when the agent πmodel has computed a sufficiently accurate model to initiate the agent πself. A modified version of the construction of ovt(i) from Section 8.4 is used to define u(ht). For i such that m < i ≤ t, for l such that m ≤ l < i, and for k such that l ≤ k ≤ t define past values as (this is similar to equation (8.14)):\n(8.40) pv't(i, l, k) = discrete((∑i≤j≤t γj-i uhuman_values(hl, hk, hj)) / (1 - γt-i+1)).\nFor i such that m < i ≤ t and for n such that i ≤ n ≤ t, define differences of past values as\nevaluated by humans at time n and humans at time i-1 (this repeats equation (8.15)):\n(8.41) δ't(i-1, n) = pv't(i, i-1, n) - pv't(i, i-1, i-1).\nAdd quantification over i to Conditions 1−3 from Section 8.4:\nCondition 1': ∀i.∀n. (m < i ≤ t ∧ i ≤ n ≤ t) ⇒ δ't(i-1, n) ≤ 0.\nCondition 2': ∀i. m < i ≤ t ⇒ ∑i≤n≤t δ't(i-1, n) ≤ 0.\nCondition 3': ∀i. m < i ≤ t ⇒ ∑i≤n≤t (n-i+1) δ't(i-1, n) ≤ 0.\nThe definition of u(ht) must choose one of these conditions. Then, using the chosen\ncondition, define the simple utility function as:\n(8.42) u(ht) = uhuman_values(ht-1, ht-1, ht) if the condition is satisfied,\nu(ht) = 0 if the condition is not satisfied.\n110\nProposition 8.1 tells us that a self-modifying agent using u(ht) will not choose to self-\nmodify and thus design intention 3, as expressed by u(ht) (which is similar but not identical to the expression by ovt(i) in equation (8.16)), is invariant. The situation is more complex for agents with limited resources and embedded in the environment. The proof of Proposition 8.1 assumes that:\n1. The agent maximizes expected utility.\n2. Agent actions are evaluated by recursive application of the agent policy function in equation (8.1).\n3. The agent interacts with the environment only via observations and actions.\n4. The agent does not choose actions stochastically.\nThere are four ways in which the agent πself violates these assumptions, possibly causing\ndivergence from its design intention. These violations and possible mitigating factors for the agent πself are:\n1. It does not maximize expected utility due to resource limits and the need for\napproximation. However, errors in agent computations due to limited interaction history\nlength and limited resource can be estimated and the transition from πmodel to πself delayed until errors are within a pre-set threshold.\n2. In order to evaluate resource increases it employs the self-modeling framework for which\nagent actions are not evaluated by recursive application of the agent policy function. However, the theoretical framework does maximize expected value in equation (8.33). The success of the DeepMind Atari player and other deep learning programs suggests that in practical cases approximations to λ(h\"t) can accurately model expected value.\n3. It is vulnerable to being modified by the environment through means other than its observations of the environment. However, it is hard to imagine a proof that any agent embedded in the real world can avoid this vulnerability. The only realistic way to address this issue is to put significant resources into defending the agent against being modified by the environment.\n4. It can choose actions stochastically. However, it does so only when the stochastic choice maximizes expected utility (at least according to equation (8.33), which must be approximated).\n111\nTo what extent is an analog of Proposition 8.1 possible for the self-modeling framework?\nEquation (8.33) chooses actions to maximize expected value, which leads us to ask: Does λ(h\"t) accurately model expected values of actions? The best answer would be that λ(h\"t) is probably approximately accurate. In our finite universe the agent πself plus its environment have a true model q (a finite stochastic loop program) that generates the histories h\"t. But the number of states of q would far exceed the number of Planck times in a trillion years. Therefore any theoretical convergence of λ(h\"t) to q would be too slow to have any practical significance.\nDespite the lack of a proof that the design intention of the agent πself is invariant as it\nevolves, it does have the important property that its definition includes no actions that are inconsistent with those learned by the model λ(h\"t). This property reduces the probability that the agent will choose actions to modify its definition. Note that if equations (8.14) and (8.16) used uhuman_values(y(hm), y(hk(t)), y(hj)) in place of uhuman_values(y(hi-1), y(hi-1), y(hj)), then λ(h\"t) would model values as remaining constant at time step k(t) which would be inconsistent with the agent's actions of increasing k(t) as t increases. This inconsistency might cause the agent to choose actions to modify its definition.\nThe next section will discuss the difficulty of finding a mathematical proof that any agent\nembedded in the real world will satisfy its design intention as it evolves, and suggests that instead of a proof we should estimate the probability that the agent violates its design intention and find ways to minimize that probability.\nThe design intention of πself is expressed by equations of Section 8.4 and by equations in\nChapter 7 that define uhuman_values(y(hi-1), y(hi-1), y(hj)). An approximation to these equations must be computed by a program pself and, if pself is designed to accommodate evolution, we can regard the program pself as the design invariant. Thus we should design pself in ways that increase the probability that the agent πself will choose actions that evolve within the structure defined by pself, rather than actions that violate that structure. First, the set At should not include any actions that explicitly modify the program pself. The set At can include actions on the environment, actions that cause pself to use resources in the environment, and actions that expand the sets Ai and Oi (expansion of the sets Ai and Oi enables greater bandwidth for the program pself to communicate with resources it employs in the environment). While the set At omits actions that directly modify pself, actions that indirectly modify pself, such as by creating other agents in the environment that modify pself (i.e., perform brain surgery on πself), are too complex and subtle to be eliminated by a simple filter. Those actions must be addressed by eliminating the agent's motive to modify its program.\nThe program pself is initially implemented using resources which are part of the\nenvironment. The agent's designers must verify that those resources will accurately compute the program pself. In order to improve the accuracy of its approximations, the program pself must be open to using additional resources in the environment. To do that, pself can include logic to verify, using the environment model λ(y(ht)), and within a pre-set probability threshold, that the environment will compute intended algorithms. Once their reliability is verified, resources in the environment can implement parts of the program pself. Error detection and correction may be\n112\nbuilt into the program pself, enabling it to achieve a high level of probability that the environment will correctly implement its computations. The verification logic included in pself should be implemented as built-in functions of the language for finite stochastic loop programs used to define optimal environment models λ(h\"t). These built-in functions could be invoked in the model for evaluating possible actions, to predict the outcomes resulting from those actions (i.e., does the action of using resources from the environment lead to increased accuracy or increased errors?). These built-in functions would bias the agent to working within the invariant of the program pself rather than choosing actions that violate the invariant. The program pself should not mandate invocation of the logic for verifying the accuracy of environment's computations, as that may be an action of the program's definition that is inconsistent with actions chosen to maximize expected utility.\nConsider the effect of including verification logic as built-in functions callable by the\nmodel λ(h\"t). Actions ai, for m < i ≤ t, that cause the agent to use unreliable resources in the environment may cause low values ovt(i). If those low values can be explained by calls to built-in verification functions that use the model λ(y(hi-1)) to determine that the resources used were unreliable, then calls to those functions, using the model λ(y(ht)), may be included in the model λ(h\"t). They would then contribute to the calculation of values for possible actions at+1, assigning low values to actions that would employ unreliable resources.\nAlthough the program pself must be open to increasing its use of resources in the\nenvironment, it is important that the decision to do so not be built into pself, but must be an action chosen by the agent to increase the expected value of the sum of future, discounted utility values. If a decision to increase resources is built into the program pself, that may harm humans by taking resources from them, as discussed in Chapter 5. Similarly the agent may take actions in the environment to protect itself from the environment, but such actions must be chosen by the agent to increase expected values. Self-protection built into pself may see humans as potential threats and act to disable humans as a precaution.\nThe agent πself may compute that it can obtain higher utility values by improving\ninefficiencies in the program pself. In order to avoid a motive for the agent to violate the invariance of the program, the program should be open to such improvements. It should include logic to verify their correctness, as built-in functions of the language for finite stochastic loop programs used to define optimal environment models λ(h\"t). Because the agent and environment are finite, such verification questions would be decidable with unlimited computing resources. However, with its limited resources, the agent may not be able to find a deductive verification. Thus the algorithm verification logic in pself should include functions for testing algorithms on samples of inputs to verify them within a pre-set probability threshold. As in the case of logic to verify the accuracy of computations by the environment, these built-in functions could be invoked in the model for evaluating possible actions, would bias the agent to working within the invariant of the program pself, and should not be mandated by pself.\n113\nIntentional redefinition of the utility function of πself as humanity evolves, as described in\nSection 7.6 and expressed in the use of uhuman_values(y(hi-1), y(hi-1), y(hj)) in equations (8.14) and (8.16), is likely to be significant. Education and poverty reduction have been major drivers in the evolution of human values, as depicted in Figure 8.4. It is likely that an advanced AI system driven by human values will reduce poverty by meeting humans' physical needs, provide humans with better education, and increase their health and intelligence. Such improvements in people's lives may create greater consensus of human values in favor of the common good for all, providing sharper distinctions in a collective utility function uhuman_values(y(hi-1), y(hi-1), y(hj)) between desirable and undesirable outcomes. This in turn would strengthen the resistance of the utility function to the type of unintended instrumental actions discussed in Chapter 5.\n114"
    }, {
      "heading" : "8.8 The Ethics of Evolving and Embedded AI",
      "text" : "Muehlhauser (2013), and Yampolskiy and Fox (2013), argue that we have an ethical\nobligation to mathematically prove that AI systems continue to help rather than harm human as they evolve, although Muehlhauser is skeptical of the extent to which this is possible and Yampolskiy and Fox acknowledge the difficulty. Section 8.7 describes the ability of selfmodeling agent to maintain the invariance of their design intention, and also the difficulty of actually proving invariance. Any real-world system for maximizing future utility values must employ approximation algorithms that generally cannot achieve maximum values, and this makes logical proofs difficult (e.g., the proof of Proposition 8.1 requires the assumption that the agent maximizes expected values).\nThis difficulty has led to research on systems that work by logical deduction. However,\nsuch logic-based systems share many of the problems of systems based on statistics and approximation. All real AI agents will be embedded in our physical universe and will have limited resources for computing, observing, and acting. They will be vulnerable to other agents that may spy on or attack their physical implementations, and they will be vulnerable to being predicted by other agents with greater resources. Since humans are part of an agent's environment, logical goals for ethical treatment of humans must be defined in terms of the environment. Any system's environment model will necessarily be an approximation because:\n1. Its observations of the environment are limited.\n2. Its computational resources for inferring a model from observations are limited.\n3. Its inferences about the environment based on observations require arbitrary assumptions of prior probabilities of environments.\nThus any statements that an agent proves about the environment are necessarily in terms\nof probabilities about the environment. The dependence of any statements on arbitrary assumptions of prior probabilities of environments implies that at best an agent can only achieve some probability that statements are true. And, as noted in Section 4.4, the recent success of AI systems has occurred because AI research has shifted from systems based on logic to systems\nbased on statistical learning−the price of logical certainty is a degree of inefficiency that prevents intelligent behavior.\nEthical goals expressed as logical statements may suffer from the sort ambiguity we\ndescribed for Asimov's Laws in Chapter 2. The logical statement, \"Do not kill any humans or allow them to be killed,\" may be impossible to achieve, as described in that chapter's example of a hitman and victim. If we modify the statement to \"Minimize the number of humans you kill or allow to be killed,\" that requires optimization. But as we described in this chapter, real world\n115\nagents with limited resource can only approximately optimize. And that makes any proof of invariance of their behavior difficult. We could say that a utility-maximizing framework is less \"brittle\" than a statement-proving framework: A utility-maximizing framework can provide a meaningful basis for choosing actions over a wider range of agent abilities and unexpected events in the environment.\nAlso consider that the laws of physics are not settled. Not only do we not know the\ncurrent state of the environment, we do not even know the proper mathematical framework for expressing that state. And it is possible that advanced AI agents will never completely settle the\nlaws of physics−that the search for the correct mathematical form of an environment model will continue indefinitely. In these circumstances we cannot even prove statements about the internal states of AI agents, since such internal states must be implemented in the physical world and we cannot be absolutely certain of physical events.\nAlthough an advanced AI agent will need to explore and learn models of its environment,\nhuman designers of such an agent will express their intentions for the agent's behavior in terms of their knowledge of the agent's environment. Thus the accuracy with which the agent's behavior satisfies its design intention is limited by the accuracy of the agent's environment model. This applies to model-based utility functions and to logical goals defined in terms of an environment model.\nThe ethics of AI agents in the real world are subject to this list of vulnerabilities and\nnecessary approximations. It will be impossible for an AI agent to maintain its ethics if it is corrupted by a hostile agent in the environment. An AI agent can try to defend against being predicted by a hostile agent by including a stochastic action choice, but it may have little ability to achieve ethical outcomes in competition against an agent with superior resources. For example, an advanced AI agent may develop an accurate model of physical and biological processes on Earth that enable it to predict and avoid threats to humans. However, its model of processes outside our solar system will be less accurate and hence it will be less able to defend against threats from interstellar space.\nIf we accept that certainty is impossible, then we can focus on estimating and minimizing\nthe level of risk in AI agent designs. For example, in the three-stage agent architecture of the previous section, we may estimate the error in the environment model computed by the agent\nπmodel and the consequent error in the utility function uhuman_values(y(hi-1), y(hi-1), y(hj)), and use those estimates (along with estimates of other errors in agent computations) to determine when\nwe have sufficient confidence in the model and utility function to initiate the agent πself to act in the world.\nI have an ethical obligation to point out a weakness of my proposal for ethical AI: It is\ncomplex. The proposal combines:\n1. Model-based utility functions to address self-delusion.\n116\n2. A utility function based on human values to address unintended instrumental actions.\n3. A three-argument utility function, defined in terms of three different histories, to address corruption of the reward generator.\n4. An adjustment to the utility function to address Rawls' objection to average utilitarianism.\n5. A self-modeling framework to address the need of agents with limited resources to evaluate increases in their resources.\n6. Adaptation of the three-argument utility function to define a condition in self-modeling agents to filter out agent actions that corrupt the reward generator.\n7. Inclusion of a stochastic action to address the possibility that the agent is being predicted by other agents.\n8. Verification logic added to the agent program to reduce the agent's motive to modify its program.\nComplexity is probably inevitable, both in designing AI systems to behave with above-\nhuman-level intelligence and in designing them to behave ethically. Experience suggests that simple designs won't work. Experience also suggests that a complex proposal, such as presented in this book, is likely to contain errors. For reasons discussed in this and the previous section, the prospects of proving ethical properties of this proposal are very low. The next chapter will discuss the problem of testing proposed AI designs.\n117"
    }, {
      "heading" : "9. Testing AI",
      "text" : "As discussed in the previous chapter, it may be impossible to ever prove ethical\nproperties of above-human-level AI systems. And even with purported proofs, we would still want a way to test designs. Experience with computer systems dictates the need for testing.\nHere we propose using elements of the agent definition in equations (7.1)−(7.6) to define\na decision support system for exploring, via simulation, analysis, and visualization, the consequences of possible AI designs. The claim is not that the decision support system would produce accurate simulations of the world. Rather, in the agent-environment framework, the agent makes predictions about the environment and chooses actions, and the decision support system uses these predictions and choices to explore the future that the AI agent predicts will maximize the sum of its future, discounted utility function values. Roughly speaking, the decision support system would show us examples of worlds that AI systems will steer towards to maximize expected utility or achieve their goals.\nThis is related to the oracle AI approach of Armstrong, Sandberg, and Bostrom (2012), in\nthat both approaches use an AI whose only actions are to provide information to humans. The oracle AI is a general question answerer, whereas the decision support system would show us simulated worlds but not answer specific questions. The oracle AI interacts with humans but has restricted ability to act on its environment, whereas an AI agent being tested in the decision support system does not interact with humans. The decision support system applies part of the agent-environment framework to learn a model for the environment, and then uses that model to create a simulated environment for testing an AI system. Chalmers (2010) considers the problem of restricting an AI to a simulation and concludes that it is inevitable that information will flow in both directions between the real and simulated worlds. The oracle AI paper and Chalmers' paper both consider various approaches to preventing an AI from breaking out of its restriction to not act in the real world, including physical limits and conditions on the AI's motivation. In this chapter, a proposed AI design being evaluated in the decision support system is restricted by having a utility function or goal defined in terms of its simulated environment rather than the real world, and by requiring the simulation to be complete before it is visualized and analyzed (to avoid any two-way conversation between the AI system and humans)."
    }, {
      "heading" : "9.1 An AI Testing Environment",
      "text" : "The decision support system is intended to avoid the dangers of AI by having no\nmotivation and no actions on the environment, other than reporting the results of its computations to the environment. However, the system runs AI agents in a simulated environment, so it must be designed to avoid subtle unintended instrumental actions by the AI agents being tested.\n118\nThe first stage of the system is the πmodel agent of Section 7.1 that learns a model of the\nreal world environment applying Equation (7.1). This model is used to provide a simulated\nenvironment for studying proposed AI agents. As discussed in Section 7.1, in order for πmodel to learn an accurate model of the environment the interaction history should include agent actions.\nHowever, for safety reasons πmodel cannot be allowed to act. The resolution is for its actions to be made by many safe, human-level surrogate AI agents independent of πmodel and of each other. Actions of the surrogates include natural language and visual communication with each human.\nThe agent πmodel observes humans, their interactions with the surrogates, and with physical objects in an interaction history for a time period set by human designers of the decision support system, and then reports an environment model to the environment (specifically to the decision support system, which is part of the agent's environment). Proposition 7.1 showed that the agent\nπmodel will report the model to the environment accurately and will not make any other, unintended instrumental actions.\nThe decision support system analyzes proposed AI agents that observe and act in a\nsimulated environment inside the decision support system. To formalize the simulated\nenvironment define O' and A' as models of O and A with bijections mO : O ↔ O' and mA : A ↔ A'. Define H' as the set of histories of interactions via O' and A', with a bijection mH : H ↔ H' defined by applying mO and mA individually to the observations and actions in a history. Given hp as the history observed by πmodel up to time |hp| = present, define h'p = mH(hp) as the history up to the present in the simulated environment. Let Q' be a set of finite stochastic\nloop programs for the simulated environment and π'model be a version of the environment-learning agent πmodel for the simulated environment. It produces:\n(9.1) q'p = λ(h'p) := argmax q'∈Q' P(h'p | q') ρ(q'),\n(9.2) ρ'(h') = P(h' | q'p).\nNow let π'(h') be a proposed AI agent/policy to be studied using the decision support\nsystem. That is, π' : H' → A' is a policy function from simulated interaction histories to simulated\nactions. If π'(h') is a utility-maximizing agent then its utility function is defined in terms of\nhistories h' of interactions with the simulated environment. And if π'(h') is based on logical proof then its logical goals are defined in terms of the simulated environment. The real world plays no role in its utility function or logical goals. Furthermore, future is defined as the end time of the simulation.\nThere are no humans or physical objects in the simulated environment; rather the agent\nπ'(h') interacts with a simulation model of humans and physical objects via:\n119\n(9.3) a'|h'|+1 = π'(h'),\n(9.4) o'|h'|+1 = o' ∈ O' with probability ρ'(o' | h'a'|h'|+1).\nThe decision support system propagates from h'p to h'f, where |h'f| = future, by repeatedly\napplying equations (9.3) and (9.4). If the agent π'(h'), by its actions, evolves and modifies its embedding in the environment, then environment dynamics as expressed by ρ' will be enlisted to do work for the agent. As in Section 6.2, let Z' be the set of finite histories of the internal states\n120\nof λ(h'p) and let P(z' | h', λ(h'p)) be the probability that λ(h'p) computes z' ∈ Z' given h' ∈ H'. The decision support system then computes a history of model states by:\n(9.5) z'f = z' ∈ Z' with probability P(z' | h'f, λ(h'p)).\nThe model history z'f is simply an execution trace of the simulation by equations (9.3)\nand (9.4), but equation (9.5) is a fomal equivalent. The simulation in equations (9.3)−(9.5) is stochastic so the decision support system will support ensembles of multiple simulations to provide users with a sample of possible futures. An ensemble of simulations generates an\nensemble of histories of model states {z'f,e | 1 ≤ e ≤ M}, all terminating at time = future and indexed by e. These simulations should be completed before they are visualized and analyzed. That is, visualization and analysis should not be concurrent with simulation for reasons discussed in Section 9.2.\nThe history hp includes observations by πmodel of humans and physical objects, and so the\ndecision support system can use the same interface via A' and O' (as mapped by mA and mO) to the model λ(h'p) for observing simulated humans and physical objects in state history z'f,e. These interfaces can be used to produce interactive visualizations of z'f,e in a system that combines features of Google Earth and Vis5D (Hibbard and Santek 1990), which enabled scientists to interactively explore weather simulations in three spatial dimensions and time. Users would be able to pan and zoom over the human habitat, as in Google Earth, and animate between times\npresent and future, as in Vis5D. The images and sounds the system observes of the model λ(h'p) executing state history z'f,e can be embedded in the visualizations in the physical locations of the agent's observing systems, similar to the way that street views and user photographs are embedded in Google Earth.\nThe decision support system can also match specifications for specific humans and\nphysical objects to the images and sounds it observes of the model λ(h'p) executing state history z'f,e. The specifications may include text descriptions, images, sounds, animations, tables of numbers, mathematical descriptions, or virtually anything. Recognized humans and physical objects can then be represented by icons in the visualization, in their simulated physical locations and with recognized properties of humans and objects represented by colors and shapes of the icons. The system can enable users to selectively enable different layers of information in the visualizations.\nVis5D enables users to visualize ensembles of weather forecasts in a spreadsheet of\nparallel visualizations where spatial view, time, and level selections are synchronized between spreadsheet cells. The decision support system could provide a similar spreadsheet visualization capability for ensembles of simulations.\n121\nThe point isn't that these simulations are accurate predictions of the future, rather that\nthey do depict futures that the AI agent π'(h') predicts will maximize the sum of future discounted utility function values or will achieve its goal, according to the environment model\nlearned by the agent π'model. Agent designers can visualize these simulations to understand the consequences of the design of π'(h').\n122\nThe visualizations could be accompanied by analyses, in which the decision support\nsystem computes the values of functions g(z'f,e). Evaluation of these functions may depend on recognizing humans and physical objects in observations of the model λ(h'p) executing state history z'f,e. Such analyses would enable designers to compute quantitative evaluations to complement visualizations. For example, these analyses could be used to compute statistics about future human wealth, health, and intelligence."
    }, {
      "heading" : "9.2 Will the Tested Agent Act in the Real World?",
      "text" : "The environment model q'p = λ(h'p) may provide the agent π'(h') with the information that\nhumans have constructed a decision support system for testing proposed AI agents and that π'(h') is such an agent, interacting with a simulated environment. If the agent's utility function or\nlogical goal were defined in terms of the real environment then π'(h') may predict that certain actions in the simulated environment could manipulate the human users of the decision support system into increasing the value of its utility function or achieving its goal in the real environment. Hence it is important that the test agent's utility function or logical goal be defined in terms of the simulated rather than the real environment.\nEven when the agent's utility function or logical goal is defined in terms of the simulated\nenvironment there are still possible risks. Assuming that the model q'p = λ(h'p) includes the information that π'(h') is in a simulation, then the agent may predict that it can bribe human users of the decision support system, through an offer to act on their behalf in the real world (the\nbribed humans would have to enable π'(h') to act in the real world), to manipulate its simulated environment to increase the value of its utility function or achieve its goal. This offer of a bribe\ncould be made by spoken or written language inserted by actions of π'(h') into some z'f,e and visualized by the users, as depicted in Figure 9.3. This possibility is the rationale for requiring\nsimulation to be complete before visualization and analysis begin. If the agent π'(h') learns through the environment model q'p = λ(h'p) that it is being tested in a simulation, then it will also learn that the simulation terminates at time = future and that human users do not visualize the\nsimulation until it has been completed, too late to help π'(h').\nHuman testers will understand and be tempted by their conflict of interest without any\nneed for the agent π'(h') to offer a bribe. As intelligent people they will know that the agent π'(h') can serve their private purposes if they enable it to act on their behalf in the real world. An important element of the decision support system must be to make this temptation and risk a prominent part of the culture of those humans working on the development and testing if AI. As Elliott (2005) commented on the safety of US nuclear weapons, \"The human factor introduces perhaps the weakest link in nuclear weapon safety and control.\" However, if society takes AI risks seriously then it can learn from the experience managing nuclear weapons to manage and test above-human-level AI before it is deployed.\n123\nIt is important not to anthropomorphize π'. A human restricted to act in a simulation\nwould be motivated to act in the real world, because human motivations concern the real world.\nHowever, if its utility function or logical goal is defined in terms of a simulation, then π' would not be motivated to act in the real world, except as a means to increase its utility function or achieve its goal in the simulation.\n124"
    }, {
      "heading" : "9.3 The Ethics of Testing AI",
      "text" : "The primary point is that, given the risks of above-human-level AI, ethics require that it\nbe tested. As described in previous chapters there is some doubt that ethical properties of AI can be proved, and even if there is a purported proof we should still test advanced AI systems before they are deployed. Even for processor chip designs, correctness proofs should be augmented with testing (Kaivola et. al. 2009). Above-human-level AI systems will be many orders of magnitude more complex than processor chips, which can only increase the need for testing to augment formal proofs.\nSecondary points are the need for safety and transparency in the development and testing\nprocess for above-human-level AI. The effort to design ethical AI systems that help rather than harm humans should include the design of systems for safely testing AI. And, as discussed in the previous section, the culture of development and testing should include acknowledgement of the potential conflict of interest for humans with access to advanced AI. The most robust defense against conflicts of interest is transparency. Thus the results of AI testing should be publicly available so that people can make informed decisions about public policy regarding AI. The next chapter will discuss the issue of transparency in more detail.\n125"
    }, {
      "heading" : "10. The Political Dimension of AI",
      "text" : "I believe that the technical problems of designing ethical AI will be solved, perhaps using\nsome of the ideas presented in this book. The greatest risks of AI are political rather than technical. Today's below-human-level AI is a tool in military and economic competition among humans, and AI's role in competition will continue as it evolves to surpass the human level. AI enlisted in human competition will by definition choose actions that cause one group of humans to win and another group to lose. For example, AI is used by financial traders. Financial markets are not entirely zero-sum games, but they're close to it. When a trader using AI makes money, counter parties are losing money. When many traders are using AI, the heat of competition makes them less likely to consider ethical issues of their AI systems. The winners get rich and the losers go bankrupt. Such competition has helped create our economic system that produces so much so efficiently, eventually to the benefit of everyone. Above-human-level AI will fundamentally change the nature of competition.\nThe cleverness, insight, and imagination of individual human minds is still the most\nimportant ingredient for success. Bill Gates, Warren Buffet, Bill Clinton, and Barack Obama all came from relatively humble beginnings and rose to become the wealthiest and most powerful people in the world by the quality of their minds. Currently the only way to get a high-quality mind is by the luck of genetics (good habits help, too). In the future, humans will develop a technology of mind (Hibbard 2008a) that will enable the wealthy to purchase high-quality minds. This will include not only the ability to purchase above-human-level AI systems but also the ability of humans to enhance their own brains and minds (Kurzweil 2005). When wealth enables increased intelligence and intelligence enables increased wealth, this positive feedback loop will quickly create a much wider range of human intelligence than currently exists. By analogy the largest trucks, ships, buildings, and computers are orders of magnitude larger than the average sizes of these artifacts. So it will be with minds when they become artifacts. If the role of AI in human competition continues and the best artificial minds are competing against natural human minds, the natural humans will lose. There will be no heroic struggle of the underdogs as depicted in movies like the Terminator series. The indomitable human spirit will be defeated by the indomitable AI spirit just as the indomitable spirit of lions has been defeated by humans.\nThe most intelligent minds will communicate using languages that average minds can\nnever learn−they will simply not have enough neurons to learn them. The real discussions of the future of humanity will use these languages. Average humans will not be able to understand and thus will have no voice in the future.\nJust as Bill Gates, Warren Buffet, Bill Clinton, and Barack Obama are all focused on\nhelping the least well-off humans, the best minds of the future may be compassionate. I think the most likely scenario for the future is a wide divergence of intelligence in which humans with average intelligence cannot compete, but in which their physical needs are met through the compassion of the most intelligent. Most people will focus on family, friends, sports, games, and artistic and domestic creation. They will also be spectators to and beneficiaries of the scientific\n126\ndiscovery and technological invention pursued by the most intelligent. In this scenario AI offers humanity bread and circuses, but they will be really great bread and circuses. More about that in the final chapter.\nThat is a likely scenario, but many other possible scenarios exist. There may be a\ntechnical flaw in AI designs that causes a catastrophe for humanity. Or the most intelligent minds may not be compassionate toward average humans, allowing them to simply perish. Or there\nmay be an effort to create equality among the intelligence of all humans−a possible consequence of AI designed according to Rawls' Theory of Justice as described in Chapter 7. But in fact, it is impossible to predict the consequences of above-human-level AI. As Vernor Vinge (1993) wrote, the technological singularity (i.e., the advent of far-above-human-level AI) is an \"opaque wall across the future.\""
    }, {
      "heading" : "10.1 The Changing Role of Humans",
      "text" : "Worldwide and over the past three decades, labor's share of income has been declining\n(Bartlett 2013). As machines do more work and humans do less, a greater share of the rewards of work go to machine owners and a smaller share to human workers. Furthermore, the number of people wanting work does not decline so the competition for available jobs drives down the wages that employers have to pay.\nBrynjolfsson and McAfee (2011; 2014) described the ways that technology is changing\nsociety. They and others advocate changing government policies on education, investment in science and infrastructure, and taxation, in order to increase employment and labor's share of income. They also suggest that humans who work with AI will do better than humans who work against AI. But the pace of technological change is accelerating and thus older workers will have a hard time keeping up by re-educating themselves. The percentage of people who have economically valuable skills will steadily decline. In the long run, possibly within a few decades, the only economically viable role for any humans will be as owners of intelligent machines or as humans with technologically enhanced minds.\nAI is also replacing the military role of humans. This raises concerns over whether we\ncan trust machines rather than humans with decisions to kill or wound humans (Johnson 2005). There is a debate about whether international law should prohibit autonomous weapons (Anderson, Reisner, and Waxman 2014). Chemical and biological weapons are banned by international law largely because they kill indiscriminately. Robot weapons are designed to kill precisely, although current remotely controlled weapons kill some people by mistake. The confidence in above-human-level AI that is the basis of this book tells us that eventually robot weapons will be more precise than human soldiers. The legal debate may slow but will not stop the development of robot weapons.\n127\nMilitary AI could enable a small group of humans to rule humanity by force, without\nneeding the cooperation of citizen soldiers. In the long run this is a greater risk than the imprecision of weapons using below-human-level AI. However, AI systems designed to choose actions based on human values, as described in Chapter 7, will be unlikely to stage a military coup on behalf of a ruling elite.\nAdvanced AI offers many potential benefits. In about 20 years I may be unable to drive\nand may need nursing care. By that time self-driving cars should be commonly available. Robot caregivers may also be available (Aronson 2014), enabling more senior citizens to stay in their own homes. The disappearance of many jobs would be a blessing if the resulting unemployed had an alternate source of economic support. Most people work only because they need to support themselves; economic need has been the incentive to get people to do dangerous, hard, dirty, and tedious work. As such work is automated, then \"economic need\" will no longer be needed.\nIdeally, there should be a balance between the rate of technologically driven\nunemployment and the willingness of society to support the unemployed. Society needs to steer a course between unnecessary suffering of the unemployed and economic stagnation due to lack of incentives. As the pace of AI development increases, it will be difficult for individuals and for society to adapt. We see religious groups rejecting modernity, some peacefully (e.g., the Amish) and some violently (terrorists of various faiths). When large percentages of society are economically devastated, movements such as Nazism and Fascism can arise. The path to advanced AI is likely to cause significant economic and social disruption. If this change is not managed carefully, irrational and destructive movements may gain political control and such movements will be less likely to develop AI ethically."
    }, {
      "heading" : "10.2 Intrusive and Manipulative AI",
      "text" : "The collection of intrusive personal data and the use of digital data to manipulate people\nare creating ethical problems for both governments and private organizations (Goel 2014a; 2014b). These problems will grow, partly because organizations benefit from intrusion and manipulation, and partly because individuals also derive benefit from digital services that depend on intrusion and enable manipulation. Many people reveal their deepest thoughts by their on-line searches (think of the murderers who are convicted based partly on their searches about the means of their crimes). Credit card companies get to know their users' habits well enough that they regularly detect fraud through purchases that do not conform to those habits. And cellular providers can track the movements of people who carry turned-on cell phones.\nThe AI design described in Chapters 6, 7, and 8 is extremely intrusive, relying as it does\non knowing every human well enough to predict the values that they would assign to any conceivable outcome. It is also manipulative, although, if humans assign low value to overt manipulation by AI systems, then the manipulation would be subtle. This intrusive design is\n128\nmotivated by a desire to avoid the scenario of the Omniscience AI described in Chapter 1 and to avoid the instrumental behaviors described in Chapter 5. If above-human-level AI is inevitable, and if it will inevitably be intrusive and manipulative, then the best option is intrusion and manipulation by an AI design based on human values. However, Bill Joy (2000) and Bill McKibben (2003) advocate that humanity can and should forego AI, as well as nanotechnology and biotechnology. This is an issue on which honest people can disagree and there are certain to be vigorous debates over increasing intrusion and manipulation. Probably, because of the potential benefits of AI, humanity will not choose to forego it.\nElectronic companions, much like the ones imagined from Omniscience, will probably be\navailable within 15 years. They will be very intrusive but so useful that only a small percentage of humans will decline to use them. Police cameras equipped with face recognition will grow enormously and with general acceptance by a public fearful of crime and terrorists. So surveillance on the level similar to that proposed in Chapter 7 is probably coming in any case.\nA possible modification of the design of Chapter 6, 7, and 8 to address some of these\nconcerns is to allow individual humans to opt out of surveillance by AI. Using the terminology of Chapter 7 we could define two levels of opting out:\n1. A human d ∈ D opts to not interact with a surrogate agent πd but is observed by the agent πmodel and modeled in the definition of the utility function uhuman_values(y(hm), y(hx), y(h')). 2. A human d ∈ D opts to not interact with a surrogate agent πd, to be observed only incidentally by πmodel (e.g., a person being observed speaks with d), and to not be modeled in the definition of the utility function uhuman_values(y(hm), y(hx), y(h')).\nThe values of an individual who selects opt out level 1 would be included in the choice of\nactions by the agent πself, perhaps modeled less accurately than the values of individuals who do not opt out. An individual who selects opt out level 2 would not have any direct influence over\nthe actions of πself. The only protection for such individuals would be compassion in the values of other humans.\nIt is possible, even likely, that there will be multiple super-intelligent AI systems each\nserving a set of human owners or clients. Rather than opting out of surveillance by a central AI system, humans may have a choice of opting in to surveillance by various AI systems."
    }, {
      "heading" : "10.3 Allocating the Benefits of AI",
      "text" : "Equation (7.15), repeated here, is a politically realistic way to respond to Rawls'\nobjection to average utilitarianism:\n129\n(10.1) uq m (h', z', hx) := ∑d∈D f(ud(hx)(hd(z'))) / |D|.\nThe values of every human are given equal weight, 1/|D|, after the function f is applied,\nwhich produces greater changes for increases to the values assigned by the least satisfied humans. This is similar to progressive taxation and means testing of social welfare.\nAn AI system built to serve private interests may restrict the set D to humans who own\nthe system. Equation (7.15) may be replaced by:\n(10.2) uq m (h', z', hx) := ∑d∈D c(d) ud(hx)(hd(z')).\n130\nHere c(d) defines unequal weights for the values of individuals d ∈ D, with\n∑d∈D c(d) = 1. For example, c(d) may be proportional to the number of shares owned by d ∈ D. In the extreme case D = {d0} and c(d0) = 1, so the AI serves the interests of a single person d0. Unequal weights for the values of different people will create extreme inequality, as depicted in Figure 10.1.\nAn AI system serving one person or a small number of people would be better able to\nserve them by knowing more about other humans. Surveillance of humanity in general will be an instrument action of such AI systems unless the people it serves value the privacy of all humans."
    }, {
      "heading" : "10.4 One or Multiple AI Systems?",
      "text" : "Multiple AI systems may serve multiple interests, which may be private or public. Such\nsystems serving multiple interests may assign different values to outcomes and may have different environment models (e.g., each AI system may develop a more detailed model of the part of the environment controlled by its owner). Differing values would result in competition among AI systems. The outcome of such competition will be very difficult to predict but will certainly depend on the values of the humans that the systems serve.\nCompetition between super-intelligent AI systems could lead to very bad outcomes for at\nleast some humans. Thus AI systems may calculate that cooperation with other AI systems is necessary to protect the humans they serve. Multiple AI systems may decide to share environment models and to negotiate a common, shared utility function, mimicking some of the mechanisms of human political and economic cooperation.\nThe choice between one or many super-intelligent AI systems is a real dilemma. Because\ninteractions among multiple systems will be so difficult to predict, it is also difficult to have confidence that multiple systems will help rather than harm humans. On the other hand, a single system will have absolute power over humanity and thus poses great temptation for abuse of that power.\nEven if we think that a single system is better, that may be difficult to enforce in a world\nof competing corporations and nations. If competing institutions cannot negotiate a single, shared system then each may build a system to represent its interests. Corporations or nations that are just at the threshold of ability to build super-intelligent AI may cut corners on the ethics of their designs in order to have a system.\n131"
    }, {
      "heading" : "10.5 Power Corrupts",
      "text" : "In 1887 John Dalberg-Acton, commonly known as Lord Acton, wrote, \"Power tends to\ncorrupt and absolute power corrupts absolutely.\" His observation is supported by social science and neuroscience experiments. Susan Fiske and Eric Dépret (1996) found that people with social power seek less information about others and are more likely to stereotype them, while Michael Kraus and colleagues showed that people from lower social classes are able to more accurately judge the emotions of other people (Kraus, Côté, and Keltner 2010 2010). Jeremy Hogeveen, and colleagues measured the strengths of brain responses via transcranial magnetic stimulation and observed apparent reduced strength of mirror neuron responses to the actions of others in people with higher social positions (Hogeveen, Inzlicht and Obhi 2014).\nOn the other hand, some of the wealthiest and most powerful people dedicate their lives\nto helping the least fortunate humans. It may be that such charitable work is a way for those who are already near the top to increase their social status, and it is certainly true that compassion is part of human nature. Nevertheless, social science and neuroscience research shows that another part of human nature is the difficulty that socially powerful people have in perceiving the emotions and circumstances of others.\nIn the first chapter we imagined how a powerful AI system owned by a corporation\nnamed Omniscience could behave badly given only the instruction to maximize profits. And there are examples of corporations behaving in ways that would horrify stockholders if they encountered such behavior in their own lives, rather than in distant communities largely invisible to stockholders (Gedicks 2001). History provides ample examples of the human catastrophes that can result when a small group of people take control of a society. Even democracies can produce horrible outcomes, for example, Nazism and slavery.\nAll this argues for caution and compassion in the politics of AI. Bad political decisions\ncan be corrected. A bad decision in the development of AI is likely to be impossible to correct. For example, some people believe that above-human-level intelligence will be achieved by enhancing the brains of humans, and advocate that this is a way to ensure that advanced AI is benevolent toward humans. Given the internal conflicts in human nature, we must be cautious about this approach."
    }, {
      "heading" : "10.6 Temptation",
      "text" : "Hollywood movies depict the threat of AI as AI versus humanity, but the more likely\nthreat is AI enabling a small group of humans to gain power over the rest of us. AI will pose enormous temptations of wealth and power to humans.\n132\nAccording to the creation story in the Book of Genesis, one of the first events in human\nhistory was the temptation to eat an apple and gain the knowledge of good and evil, that knowledge reserved for God alone. Adam and Eve succumbed to that temptation and humans have lived in misery ever since. AI will tempt humans with god-like knowledge and the wealth and power that such knowledge can bring. Will that temptation bring more misery?\nGoogle's motto is, \"Don't be evil,\" and Google's leaders seem like decent folks. The real\nsignificance of their motto is to acknowledge the temptations they face. Billions of humans reveal their psyches in their web searches. Humans reveal their locations, and ultimately their meetings with other people, via their mobile phones. Humans reveal their commercial transactions via credit cards and electronic devices. All of this knowledge will enable corporations to provide users with services tailored to their specific needs. But there is also the temptation to use this knowledge for law enforcement, political marketing, and social manipulation. Competition between corporations may make it difficult for them to resist these temptations.\nThe militaries in the US and other countries are developing robot soldiers. These are\nalready proving effective in targeting enemy soldiers with minimal risk to US soldiers, and with\n133\nmuch greater promise for the future. However, an army of robot soldiers may tempt leaders to use those robots to take control of the government. National security threats are often evaluated in terms of capabilities and intentions. Even where the intentions of leaders are benign, the capability of robot soldiers to stage a military coup means that the threat cannot be ignored.\nPolitical, military, and business leaders are reluctant to speak about the AI singularity in\npublic, but they are aware of its implications. The coming era of artificial brains will include a much greater range of brain abilities with the largest brain or brains dominating society. The obvious temptation for wealthy and powerful humans will be the desire for their own minds to occupy those largest brains. The opportunity to be the dominant mind in at least our region of the universe, for millions or billions of years to come, will be a big temptation.\nHuman society already has individuals whose net worth is a million or more times the\naverage, and individuals who wield monopoly political power in their countries. Some of these people, and many in the general public, may see nothing wrong in the step to their becoming the dominant mind on the planet."
    }, {
      "heading" : "10.7 Representation and Transparency",
      "text" : "Humanity could not have achieved the efficiency necessary to create AI without\nspecialization, where different humans become experts in different types of work and trade the results of their work. In many cases experts act as the agents for other people, representing their interests in important decisions (this definition of \"agent\" as \"representative\" is different than the way \"agent\" has been used previously in this book). For example, the laws of society are determined by government experts, often elected by those they represent or at least supervised by elected representatives. Leaders of large corporations act as agents for corporate owners, usually subject to some sort of election. However, whenever one person serves as an agent for others, the possibility of corruption exists, in which agents serve their own interests at the expense of those they represent. An essential tool for preventing corruption is transparency, in which the decisions and circumstances of agents are made known to those they represent.\nThe development of above-human-level AI is the most difficult challenge in human\nhistory and will require extreme expertise. It will also require huge resources, controlled by powerful government and corporate leaders. The results of above-human-level AI will be more profound for humanity than those of any previous technology. Thus the designers and resource managers for AI represent the interests of all of humanity. Current law and public opinion do not recognize AI designers and managers as humanity's agents, so they may feel no need to represent humanity's interests. Even if they do acknowledge that they represent humanity's interests, the stakes are so high that the temptation for corruption will be intense.\nProtecting the interests of humanity will require that law and public opinion change to\nrecognize that AI designers and managers are humanity's agents. Once this agent relation is\n134\nrecognized, preventing corruption will require transparency. Thus the design and management of AI should be accessible to the public.\n135"
    }, {
      "heading" : "11. The Quest for Meaning",
      "text" : "As a child lying in bed at night, alone with my thoughts, I wondered, \"Why is there\nanything?\" The existence of the universe seemed so unlikely to me. In the context of nothing versus something, nothing seemed natural and something seemed like a lot of unnecessary trouble. Perhaps my young brain had a bias for Occam's razor and was applying it to existence. When I focused on these thoughts, they freaked me right out.\nI dutifully attended church and Sunday school, but never connected the stories I learned\nthere to my existential question. To say that God created the universe is unsatisfying. But atheist/materialist explanations that the universe \"simply is\" are just as unsatisfying. Both are ways to say, \"Don't ask.\" Existentialists say that existence is not a quality like being red or being large and so not subject to the same sorts of questions. This is a fancy way of saying, \"Don't ask.\" But it is deep in our human nature to ask. Some physicists claim to answer the question of why there is anything, but all they are doing is explaining why the laws of physics don't allow empty space. The laws of physics and empty space are something, not nothing, so they are answering a different question than the one that troubles me. I am restless to understand why the world exists.\nHumans strive for meaning everywhere. Some seek it in religion, by belonging to groups\nthat have practiced the same rituals for thousands of years. Some seek it in their children, new life grown out of their bodies to live on for thousands of years. Some seek it in communities of work and in pride in their abilities. Some hide from their quest for meaning in the oblivion of addiction, violence, obsession, and death.\nWith great effort and luck, a humanity that foregoes AI might find a way to avoid the\nperils brought on by growing population and environmental damage, so that generations can continue their personal quests for meaning in the same way that humans have for centuries. But I do not aspire to a future of introspective humans staying cozy on planet Earth.\nI want humanity to look outward in its quest for meaning, traveling across the universe\nand also burrowing deeper into the smallest particles. I want humanity to radically increase its intelligence so that it can master the physical universe and shape tools for understanding it. I want humanity to find life on planets circling other stars. AI will increase humanity's productive capacity to satisfy people's physical needs, and will enable the pursuit of knowledge in currently unimaginable ways. Perhaps with the help of AI humanity can find a way to gather all the sun's energy and for a moment focus it on a single elementary particle, to barge down the door to nature's secrets. AI can help us create or become beings better suited to long space voyages. I want humans in the future, if far future, to find a real answer to the question that has troubled me since childhood.\nPerhaps we will never find a reason for existence; however, clues exist. As scientists dig\ndeeper into physics, every set of answers comes with a whole new set of questions. We never find the final truth. Perhaps a universe capable of creating conscious and curious beings also\n136\nincludes an endless puzzle to keep that curiosity engaged indefinitely. Nick Bostrom (2003) argues that we may be living in a numerical simulation; there are proposals for ways to test this hypothesis (Beane, Davoudi and Savage 2012). These ideas, as well as religious explanations, converge on the possibility of some intention behind our existence.\nSome arguments against AI refer to human dignity (Weizenbaum 1976). The claim is that\ncomputers will always lack human judgment and so should not make certain choices about humans. I take a different view: Human dignity requires that we strive to remove our ignorance of the nature of existence, and AI is necessary for that striving.\nAs the first ten chapters described, AI is dangerous to humanity. But rather than\nforegoing AI, I want humanity to discover how to avoid the dangers so we can make AI our tool to understand the universe and our place in it. AI can also be a tool to eradicate poverty and ignorance, so that all humans can live fulfilling lives.\nI must admit that there is a parallel between my ambition for AI, to understand the reason\nfor existence, and the story of Adam and Eve eating the apple to gain knowledge reserved for\n137\nGod. Perhaps the story of the fall from the Garden of Eden is a warning to us that we should forego our quest to know. But I stand with Galileo Galilei, who said, \"I do not feel obliged to believe that the same God who endowed us with sense, reason and intellect has intended us to forgo their use.\""
    }, {
      "heading" : "11.1 Really Great Bread and Circuses",
      "text" : "AI will be enormously productive. Robot workers will be able to perform every job better\nthan humans. AI will accelerate science and technology to enable new ways to produce food, energy, minerals, buildings, roads, and manufactured goods. Health care will radically accelerate including even technology to prevent disease and death. Depending on politics, poverty and the economic need to work will be eradicated and high levels of education will be universal. And the technology will exist to increase everyone's intelligence.\nIncreased intelligence will bring increased skill at cooking and all forms of food\nproduction, increased musical skill, better comedy writing and joke telling, better writing in general, and better movies. AI will be a scintillating conversationalist. If you enjoy trashy TV increased intelligence will make trashy TV better. Far beyond current video games, you will be able to become a character in a movie or TV show, and that experience will be very addictive. Pornography will improve and sex robots will be indistinguishable from humans. Increased intelligence will provide lots of ways for people to lose themselves in addictions, but will also provide technology to help people resist addiction. AI has the potential to make every kind of experience better.\nThe deepest form of entertainment will be the progress of discovery and invention as AI\nscientists and engineers race forward. My definition of the technological singularity is a transition to a time when the pace of discovery and invention is limited by available physical resources rather than being limited by the pace of insights. Nothing could be more compelling than the prospect of really understanding the reason why the universe exists.\nMaking contact with other life in the universe would also be a drama surpassing any\nterrestrial experience. Perhaps alien life is observing us but has a policy of not making contact until we achieve our technological singularity. If we create a compassionate singularity, they will welcome us to the club. If we create a broken or malevolent singularity, they will exterminate it and us for their own protection. \"Klaatu barada nikto.\" Perhaps they're looking forward to seeing what kind of trashy TV our singularity produces. The point is that almost anything is possible if we find other life.\nIf we cannot find other life, human colonization of space would be an inspiring substitute.\nScience and technology have been exciting during the past century and should be more exciting during the next.\n138"
    }, {
      "heading" : "11.2 Next Steps",
      "text" : "Research in AI is being funded and pursued energetically at universities, corporations and\ngovernment laboratories. There is much less funding and research on ethical AI, the study of ways to avoid harm to humans. Research on the ethics of military robots is funded by the U.S. Army Research Office (Arkin 2008) and by other military organizations. Google has established a committee on ethical AI (Bosker 2014). The most important source of funding and research on the general problem of ethical AI comes from the Machine Intelligence Research Institute (MIRI), and most of their funding comes from charitable contributions. Some research is pursued by individuals who are funded to do other work but devote some time to ethical AI (my research is supported by my pension). The obvious next step is for public awareness of the dangers of AI to translate into public funding for research into ethical AI.\nIn 2009 the Association for the Advancement of Artificial Intelligence (AAAI) convened\na Presidential Panel on Long-Term AI Futures (Horvitz and Selman 2009) to consider public fears about the dangers of AI. Although the panel was skeptical of an intelligence explosion, the technological singularity, and large-scale loss of control to intelligent systems, they did recommend more research on minimizing unexpected outcomes.\nLuke Muehlhauser and I (Muehlhauser and Hibbard 2014) made the point that errors in\nautonomous trading programs cost Knight Capital $440 million, and that we cannot expect that AI will be safe simply because it is a tool that does what we instruct it to do. Peter Neumann (2014) has documented errors and risks in a wide variety of computer systems over a period of 24 years, many rising to the level of national news stories. As AI systems become more powerful and more autonomous, we would be wise to take the risks seriously.\nGiven the huge potential of AI to help people, it is appropriate that some of the best\nscientific minds are working on AI and neuroscience. Given the huge potential of AI to harm people, it is also appropriate to bring more of the best minds to bear on ethical AI research. That will require increased public awareness of the danger and increased funding for ethical AI.\n139"
    } ],
    "references" : [ {
      "title" : "Adapting the Law of Armed Conflict to Autonomous Weapon Systems",
      "author" : [ "K. Anderson", "D. Reisner", "M. Waxman" ],
      "venue" : "International Law Studies, Forthcoming. Arkin, R. 2008. Governing lethal behavior: Embedding ethics in a hybrid deliberative/reactive robot architecture part I: Motivation and philosophy. Proc. 3rd ACM/IEEE International Conference on Human-Robot Interaction. pp. 121 - 128.",
      "citeRegEx" : "Anderson et al\\.,? 2014",
      "shortCiteRegEx" : "Anderson et al\\.",
      "year" : 2014
    }, {
      "title" : "Thinking Inside the Box: Using and Controlling an Oracle AI",
      "author" : [ "S. Armstrong", "A. Sandberg", "N. Bostrom" ],
      "venue" : "Minds and Machines 22(4), pp. 299-324. Aronson, L. 2014. The Future of Robot Caregivers. The New York Times, 20 July 2014. Asimov, I. 1942. Runaround. Astounding Science Fiction. Bartlett, B. 2013. Labor’s Declining Share Is an International Problem. The New York Times, 25",
      "citeRegEx" : "Armstrong et al\\.,? 2012",
      "shortCiteRegEx" : "Armstrong et al\\.",
      "year" : 2012
    }, {
      "title" : "Baum, E",
      "author" : [ "June" ],
      "venue" : "2004. What is Thought? MIT Press, Cambridge, MA. Beane, S., Davoudi, Z. and Savage, M. 2012. Constraints on the Universe as a Numerical Simulation. http://arxiv.org/abs/1210.1847 Bosker, B. 2014. Google's New A.I. Ethics Board Might Save Humanity From Extinction.",
      "citeRegEx" : "June,? 2013",
      "shortCiteRegEx" : "June",
      "year" : 2013
    }, {
      "title" : "The superintelligent will: Motivation and instrumental rationality in advanced artificial agents",
      "author" : [ "N. Bostrom" ],
      "venue" : "Minds and Machines 22(2), pp. 71-85. Box, G. E. P., and Draper, N. R. 1987. Empirical Model Building and Response Surfaces. John Wiley & Sons, New York, NY. Brown, J., Bullock, D., and Grossberg, S. 1999. How the basal ganglia use parallel excitatory",
      "citeRegEx" : "Bostrom,? 2012",
      "shortCiteRegEx" : "Bostrom",
      "year" : 2012
    }, {
      "title" : "and inhibitory learning pathways to selectively respond to unexpected rewarding cues",
      "author" : [ "E. Brynjolfsson", "A. McAfee" ],
      "venue" : "Journal of Neuroscience",
      "citeRegEx" : "Brynjolfsson and McAfee,? \\Q2011\\E",
      "shortCiteRegEx" : "Brynjolfsson and McAfee",
      "year" : 2011
    }, {
      "title" : "The Second Machine Age: Work, Progress, and Prosperity in a Time of Brilliant Technologies",
      "author" : [ "E. Brynjolfsson", "A. McAfee" ],
      "venue" : "W. W. Norton & Company. Chalmers, D. 2010. The Singularity: A Philosophical Analysis. J. Consciousness Studies 17, pp. 7-65. Dewey, D. 2011. Learning what to value. In: Schmidhuber, J., Thórisson, K.R., and Looks, M.",
      "citeRegEx" : "Brynjolfsson and McAfee,? 2014",
      "shortCiteRegEx" : "Brynjolfsson and McAfee",
      "year" : 2014
    }, {
      "title" : "US Nuclear Weapon Safety and Control. MIT Program in Science, Technology, and Society",
      "author" : [ "Springer", "G. Heidelberg. Elliott" ],
      "venue" : "AGI",
      "citeRegEx" : "Springer and Elliott,? \\Q2011\\E",
      "shortCiteRegEx" : "Springer and Elliott",
      "year" : 2011
    }, {
      "title" : "Control, Interdependence and Power: Understanding Social Cognition in Its Social Context",
      "author" : [ "S. Fiske", "E. Dépret" ],
      "venue" : "European Review of Social Psychology",
      "citeRegEx" : "Fiske and Dépret,? \\Q1996\\E",
      "shortCiteRegEx" : "Fiske and Dépret",
      "year" : 1996
    }, {
      "title" : "Resource Rebels: Native Challenges to Mining and Oil Corporations",
      "author" : [ "A. Gedicks" ],
      "venue" : "Cambridge, MA: South End Press. Ghahramani, Z. 1997. Learning dynamic Bayesian networks. In: Giles, C., and Gori, M. (eds), Adaptive Processing of Temporal Information. LNCS, vol. 1387, pp. 168-197. Springer, Heidelberg.",
      "citeRegEx" : "Gedicks,? 2001",
      "shortCiteRegEx" : "Gedicks",
      "year" : 2001
    }, {
      "title" : "Bias learning, knowledge sharing",
      "author" : [ "J. Ghosn", "Y. Bengio" ],
      "venue" : "IEEE Transactions on Neural Networks 14, pp. 748–765. Goel, V. 2014a. Facebook tinkers with users' emotions in news feed experiment, stirring outcry. New York Times, 29 June 2014. Goel, V. 2014b. As Data Overflows Online, Researchers Grapple With Ethics. New York Times,",
      "citeRegEx" : "Ghosn and Bengio,? 2003",
      "shortCiteRegEx" : "Ghosn and Bengio",
      "year" : 2003
    }, {
      "title" : "Beyond the Turing test",
      "author" : [ "N. Hay" ],
      "venue" : "Optimal Agents. BS honours thesis, University of Auckland. Hernández-Orallo. J",
      "citeRegEx" : "Hay,? \\Q2005\\E",
      "shortCiteRegEx" : "Hay",
      "year" : 2005
    }, {
      "title" : "Super-intelligent machines",
      "author" : [ "B. Hibbard" ],
      "venue" : "Computer Graphics 35(1), pp. 11-13. Hibbard, B. 2008a. The technology of mind and a new social contract. J. Evolution and Technology 17(1), pp. 13-22. Hibbard, B. 2008b. Adversarial sequence prediction. In Wang, P., Goertzel, B., and Franklin, S. (eds) AGI 2008. Proc. First Conf. on AGI, pp. 399-403. IOS Press, Amsterdam.",
      "citeRegEx" : "Hibbard,? 2001",
      "shortCiteRegEx" : "Hibbard",
      "year" : 2001
    }, {
      "title" : "Bias and No Free Lunch in Formal Measures of Intelligence",
      "author" : [ "B. Hibbard" ],
      "venue" : "J. Artificial General Intelligence 1, pp. 54-61. Hibbard, B. 2012a. Model-based utility functions. J. Artificial General Intelligence 3(1), pp. 1-",
      "citeRegEx" : "Hibbard,? 2009",
      "shortCiteRegEx" : "Hibbard",
      "year" : 2009
    }, {
      "title" : "Avoiding unintended AI behavior",
      "author" : [ "B. Hibbard" ],
      "venue" : "AGI",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2012
    }, {
      "title" : "Self-modeling agents evolving in our finite universe",
      "author" : [ "B. Hibbard" ],
      "venue" : "In: Goertzel, B, Orseau, L. and Snaider, J. (eds) AGI 2014. LNCS (LNAI), vol 8598, pp. 246-249. Springer, Heidelberg. Hogeveen, J., Inzlicht, M. and Obhi, S. 2014. Power changes how the brain responds to others. Journal of Experimental Psychology: General 143(2) pp. 755-762. Horvitz, E., and Selman, B. 2009. Interim Report from the Panel Chairs, AAAI Presidential",
      "citeRegEx" : "Hibbard,? 2014",
      "shortCiteRegEx" : "Hibbard",
      "year" : 2014
    }, {
      "title" : "Universal artificial intelligence: sequential decisions based on algorithmic probability",
      "author" : [ "M. Hutter" ],
      "venue" : "Springer, Heidelberg. Hutter, M. 2009a. Feature reinforcement learning: Part I. Unstructured MDPs. J. Artificial General Intelligence 1, pp. 3-24. Hutter, M. 2009b. Feature dynamic Bayesian networks. In: Goertzel, B., Hitzler, P., and Hutter,",
      "citeRegEx" : "Hutter,? 2005",
      "shortCiteRegEx" : "Hutter",
      "year" : 2005
    }, {
      "title" : "Who Do You Trust More: G.I",
      "author" : [ "M. (eds" ],
      "venue" : "AGI",
      "citeRegEx" : ".eds,? \\Q2009\\E",
      "shortCiteRegEx" : ".eds",
      "year" : 2009
    }, {
      "title" : "Replacing Testing with Formal Verification in Intel$ ® CoreTM i7 Processor Execution Engine Validation",
      "author" : [ "C. Taylor", "V. Frolov", "E. Reeber", "A. Naik" ],
      "venue" : "Proc. CAV '09 Proceedings of the 21st International Conference on Computer Aided Verification. LNCS, vol 5643, pp. 414 - 429. Springer, Heidelberg. Kraus, M., Côté, S. and Keltner, D. 2010. Social Class, Contextualism, and Empathic Accuracy.",
      "citeRegEx" : "Taylor et al\\.,? 2009",
      "shortCiteRegEx" : "Taylor et al\\.",
      "year" : 2009
    }, {
      "title" : "The singularity is near",
      "author" : [ "R. Kurzweil" ],
      "venue" : "Psychological Science",
      "citeRegEx" : "Kurzweil,? \\Q2005\\E",
      "shortCiteRegEx" : "Kurzweil",
      "year" : 2005
    }, {
      "title" : "Proc",
      "author" : [ "S. Legg", "M. Hutter" ],
      "venue" : "A Formal Measure of Machine Intelligence. 15th Annual Machine Learning Conference of Belgium and The Netherlands (Benelearn 2006), pp. 73-80.",
      "citeRegEx" : "Legg and Hutter,? 2006",
      "shortCiteRegEx" : "Legg and Hutter",
      "year" : 2006
    }, {
      "title" : "An introduction to Kolmogorov complexity and its applications",
      "author" : [ "M. Li", "P. Vitanyi" ],
      "venue" : "Springer, Heidleberg. Lloyd, S. 2002. Computational Capacity of the Universe. Phys.Rev.Lett. 88, 237901. McKibben, B. 2003. Enough: Staying Human in an Engineered Age. Times Books. Mnih, V., Kavukcuoglu, K., Silver, D., Graves, A., Antonoglou, I., Wierstra, D., and Riedmiller,",
      "citeRegEx" : "Li and Vitanyi,? 1997",
      "shortCiteRegEx" : "Li and Vitanyi",
      "year" : 1997
    }, {
      "title" : "Playing Atari with Deep Reinforcement Learning",
      "author" : [ "M." ],
      "venue" : "http://arxiv.org/abs/1312.5602 Muehlhauser, L., and Helm, L. 2012. The singularity and machine ethics. In Eden, Søraker, Moor, and Steinhart (eds) The Singularity Hypothesis: a Scientific and Philosophical Assessment. Springer, Heidelberg. Muehlhauser, L. 2013. Mathematical Proofs Improve But Don’t Guarantee Security, Safety, and",
      "citeRegEx" : "M.,? 2013",
      "shortCiteRegEx" : "M.",
      "year" : 2013
    }, {
      "title" : "Exploratory Engineering in AI",
      "author" : [ "B. Hibbard" ],
      "venue" : "Communications of the ACM",
      "citeRegEx" : "Muehlhauser and Hibbard,? \\Q2014\\E",
      "shortCiteRegEx" : "Muehlhauser and Hibbard",
      "year" : 2014
    }, {
      "title" : "septal area and other regions of rat brain",
      "author" : [ "S. Omohundro" ],
      "venue" : "J. Comp. Physiol. Psychol",
      "citeRegEx" : "Omohundro,? \\Q2008\\E",
      "shortCiteRegEx" : "Omohundro",
      "year" : 2008
    }, {
      "title" : "Space-Time Embedded Intelligence",
      "author" : [ "L. Orseau", "M. Ring" ],
      "venue" : "In: Bach, J., and Iklé, M. (eds) AGI 2012. LNCS (LNAI), vol. 7716, pp. 209-218. Springer, Heidelberg. Orseau, L. and Ring, M. 2012b. Memory Issues of Intelligence Agents. In: Bach, J., and Iklé, M. (eds) AGI 2012. LNCS (LNAI), vol. 7716, pp. 219-231. Springer, Heidelberg. Osborne, M. and Rubinstein, A. 1994. A course in game theory. MIT Press, Cambridge, MA.",
      "citeRegEx" : "Orseau and Ring,? 2012a",
      "shortCiteRegEx" : "Orseau and Ring",
      "year" : 2012
    }, {
      "title" : "Understanding Cryptography, A Textbook for Students and Practitioners",
      "author" : [ "C. Paar", "J. Pelzl" ],
      "venue" : "Springer, Heidelberg. Puterman, M. L. 1994. Markov decision processes - discrete stochastic dynamic programming. Wiley, New York. Rawls, J. 1971. A theory of justice. Harvard University Press, Cambridge, MA.",
      "citeRegEx" : "Paar and Pelzl,? 2009",
      "shortCiteRegEx" : "Paar and Pelzl",
      "year" : 2009
    }, {
      "title" : "Delusion, survival, and intelligent agents",
      "author" : [ "M. Ring", "L. Orseau" ],
      "venue" : "In: Schmidhuber, J., Thórisson, K.R., and Looks, M. (eds) AGI 2011. LNCS (LNAI), vol. 6830, pp. 11-20. Springer, Heidelberg. Rizzolatti, G. and Craighero, L. 2004. The mirror-neuron system. Annual Review of Neuroscience 27, pp. 169–192.",
      "citeRegEx" : "Ring and Orseau,? 2011b",
      "shortCiteRegEx" : "Ring and Orseau",
      "year" : 2011
    }, {
      "title" : "Artificial intelligence: a modern approach (3rd ed.)",
      "author" : [ "S. Russell", "P. Norvig" ],
      "venue" : "Some Studies in Machine Learning Using the Game of Checkers. IBM Journal",
      "citeRegEx" : "Russell and Norvig,? \\Q2010\\E",
      "shortCiteRegEx" : "Russell and Norvig",
      "year" : 2010
    }, {
      "title" : "A neural substrate of prediction and reward",
      "author" : [ "W. Schultz", "P. Dayan", "Montague", "PR." ],
      "venue" : "Science 275 (5306), pp. 1593–1599. Schmidhuber, J. 2009. Ultimate cognition à la Gödel. Cognitive Computation 1(2), pp. 177-193. Seymour, B., O'Doherty, J., Dayan, P., Koltzenburg, M., Jones, A., Dolan, R., Friston, K., and Frackowiak, R. 2004. Temporal difference models describe higher-order learning in humans.",
      "citeRegEx" : "Schultz et al\\.,? 1997",
      "shortCiteRegEx" : "Schultz et al\\.",
      "year" : 1997
    }, {
      "title" : "Intelligence as Inference or Forcing Occam on the World",
      "author" : [ "P. Sunehag", "M. Hutter" ],
      "venue" : "In: Goertzel, B, Orseau, L. and Snaider, J. (eds) AGI 2014. LNCA (LNAI), vol 8598, pp. 186-195. Springer, Heidelberg. Sutton, R.S., and Barto, A.G. 1998. Reinforcement learning: an introduction. MIT Press. Turing, A.M. 1936. On Computable Numbers, with an Application to the Entscheidungs",
      "citeRegEx" : "Sunehag and Hutter,? 2014",
      "shortCiteRegEx" : "Sunehag and Hutter",
      "year" : 2014
    }, {
      "title" : "The coming technological singularity",
      "author" : [ "V. Vinge" ],
      "venue" : "Proceedings of the London Mathematical Society",
      "citeRegEx" : "Vinge,? \\Q1937\\E",
      "shortCiteRegEx" : "Vinge",
      "year" : 1937
    }, {
      "title" : "Designing a safe motivational system for intelligent machines",
      "author" : [ "M. Waser" ],
      "venue" : "In: Baum, E., Hutter, M., and Kitzelmann, E. (eds) AGI 2010. Proc. Third Conf. on AGI, pp 170-175. Atlantis Press, Amsterdam. Waser, M. 2011. Rational universal benevolence: simpler, safer, and wiser than \"friendly AI.\" In: Schmidhuber, J., Thórisson, K.R., and Looks, M. (eds) AGI 2011. LNCS (LNAI), vol. 6830, pp.",
      "citeRegEx" : "Waser,? 2010",
      "shortCiteRegEx" : "Waser",
      "year" : 2010
    }, {
      "title" : "Instructions for Engineering Sustainable People",
      "author" : [ "Springer", "M. Heidelberg. Waser" ],
      "venue" : "J. (eds) AGI",
      "citeRegEx" : "Springer and Waser,? \\Q2014\\E",
      "shortCiteRegEx" : "Springer and Waser",
      "year" : 2014
    }, {
      "title" : "Causal entropic forces",
      "author" : [ "A.D. Wissner-Gross", "C.E. Freer" ],
      "venue" : "Physical Review Letters 110, 168702. Yampolskiy, R. and Fox, J. 2013. Safety Engineering for Artificial General Intelligence. Topoi 32(2), pp 217-226. Yudkowsky, E. 2001. Creating Friendly AI 1.0: The Analysis and Design of Benevolent Goal",
      "citeRegEx" : "Wissner.Gross and Freer,? 2013",
      "shortCiteRegEx" : "Wissner.Gross and Freer",
      "year" : 2013
    }, {
      "title" : "Tiling Agents for Self-Modifying AI, and the Löbian Obstacle",
      "author" : [ "M. Herreshoff" ],
      "venue" : null,
      "citeRegEx" : "Yudkowsky and Herreshoff,? \\Q2013\\E",
      "shortCiteRegEx" : "Yudkowsky and Herreshoff",
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 18,
      "context" : "Ray Kurzweil, who has a good track record at technology prediction, estimates this event will occur in 2029 (Kurzweil 2005).",
      "startOffset" : 108,
      "endOffset" : 123
    }, {
      "referenceID" : 27,
      "context" : "A current approach views AI as an agent interacting with an environment (Russell and Norvig 2010).",
      "startOffset" : 72,
      "endOffset" : 97
    }, {
      "referenceID" : 21,
      "context" : "Numerical values assigned to outcomes can express any set of preferences among outcomes that obey two reasonable assumptions, called completeness and transitivity (explained later in this section). The numerical function of outcomes is called a utility function. An agent can achieve its optimal preference by maximizing the utility function. However, as in the example of the hitman and the victim, agent actions are associated with sums of outcomes weighted by probabilities. These are called lotteries. John von Neumann and Oskar Morgenstern (1944) proved that numerical values assigned to outcomes can express any set of preferences among lotteries that obey four reasonable assumptions (for lotteries, continuity and independence are added to completeness and transitivity).",
      "startOffset" : 2,
      "endOffset" : 552
    }, {
      "referenceID" : 15,
      "context" : "Marcus Hutter (2005) had the insight that AI model learning is mathematically similar to Ray Solomonoff's work on sequence prediction (Solomonoff 1964).",
      "startOffset" : 7,
      "endOffset" : 21
    }, {
      "referenceID" : 15,
      "context" : "In order to define the search for programs mathematically, Solomonoff and Hutter used Turing machines (TM), named for their inventor Alan Turing (1936). A TM is an abstract mathematical model of computation and, according to the Church-Turing thesis, can express any computation that can be expressed in any other way.",
      "startOffset" : 74,
      "endOffset" : 152
    }, {
      "referenceID" : 20,
      "context" : "Kraft's Inequality implies that ρ(h) ≤ 1 (Li and Vitanyi, 1997) in equation (3.",
      "startOffset" : 41,
      "endOffset" : 63
    }, {
      "referenceID" : 15,
      "context" : "Legg's and Hutter's (2006) formal measure of intelligence is closely related to universal AI.",
      "startOffset" : 11,
      "endOffset" : 27
    }, {
      "referenceID" : 12,
      "context" : "I showed (Hibbard 2009) that given an arbitrary environment μ ∈ E and ε > 0, there exists a reference UTM Uμ such that for all agents π and for V computed according to Uμ,",
      "startOffset" : 9,
      "endOffset" : 23
    }, {
      "referenceID" : 14,
      "context" : "I argue that such difficulties are unnecessary if agent definitions are limited to finite sets (Hibbard 2014).",
      "startOffset" : 95,
      "endOffset" : 109
    }, {
      "referenceID" : 11,
      "context" : "I argue that such difficulties are unnecessary if agent definitions are limited to finite sets (Hibbard 2014). Seth Lloyd (2002) has calculated that the observable universe has a finite information capacity of no more than 10 bits.",
      "startOffset" : 96,
      "endOffset" : 129
    }, {
      "referenceID" : 21,
      "context" : "The agents described in Chapters 2 and 3 choose actions to maximize the sum of future discounted utility function values. Some research on ethical AI focuses on agents that only take actions that they can prove will satisfy a particular condition. For example, Schmidhuber (2009) defined the Gödel machine as a programmable agent that interacts with an environment to maximize its utility function, which is defined as the expected value of the sum of rewards from the environment, from the current time until some final time T.",
      "startOffset" : 59,
      "endOffset" : 280
    }, {
      "referenceID" : 15,
      "context" : "Sunehag and Hutter (2014) provide a critique of logical reasoning as far less efficient than probabilistic architectures for systems that interact with the real world.",
      "startOffset" : 12,
      "endOffset" : 26
    }, {
      "referenceID" : 21,
      "context" : "Agents based on logical proof must assume a prior distribution over environments. An agent may compute that there are statistical correlations among its actions and observations, but to make inferences about the probabilities of future observations requires assumptions about prior probabilities of observations. Even computing correlations among actions and observations makes the assumption that the agent's memory is reliable. Memory corruption is a risk for any agent embedded in our physical world (Orseau and Ring 2012b) and thus these correlation computations are conditional on assumed probabilities of memory reliability. These assumed prior probabilities of observations and of memory reliability are arbitrary so logical proofs by agents of propositions about the environment are no more reliable than statistical calculations by agents. Luke Muehlhauser (2013) offers some insights about the role of logical proofs in ethical AI.",
      "startOffset" : 30,
      "endOffset" : 873
    }, {
      "referenceID" : 14,
      "context" : "I argue that PA or any other logic theory involving infinite sets is unnecessary in our universe with a finite information capacity (Hibbard 2014).",
      "startOffset" : 132,
      "endOffset" : 146
    }, {
      "referenceID" : 21,
      "context" : "As noted previously, a utility-maximizing agent chooses actions to maximize the expected sum of its discounted future utility function values. However, as Stephen Omohundro (2008) pointed out, an agent will also choose actions (what Omohundro described as basic drives) that do not directly increase utility, but rather increase the agent's ability to maximize utility values.",
      "startOffset" : 31,
      "endOffset" : 180
    }, {
      "referenceID" : 18,
      "context" : "Thus Ray Kurzweil (2005) and others predict that AI will lead to a technological singularity, when the rate of discovery and invention goes far above the scale of human experience.",
      "startOffset" : 9,
      "endOffset" : 25
    }, {
      "referenceID" : 20,
      "context" : "The unintended instrumental behaviors of AI are too numerous, complex, and subtle to exhaustively catalog them and to devise individual defenses against their harmful effects. A more systematic approach is required. In the agent-environment framework of Sections 2.1 and 2.2, all agent actions are chosen to maximize the sum of future, discounted utility function values. There are no drives or goals other than those expressed by the utility function. Omohundro (2008) used the term \"basic AI drives\" and Bostrom (2012) used \"instrumental goals.",
      "startOffset" : 21,
      "endOffset" : 470
    }, {
      "referenceID" : 3,
      "context" : "Omohundro (2008) used the term \"basic AI drives\" and Bostrom (2012) used \"instrumental goals.",
      "startOffset" : 53,
      "endOffset" : 68
    }, {
      "referenceID" : 21,
      "context" : "If the utility function of our imagined Omniscience AI became corrupted the results could be catastrophic. In order to study this problem Mark Ring and Laurent Orseau (2011b) formalized utility function corruption as agent self-delusion.",
      "startOffset" : 32,
      "endOffset" : 175
    }, {
      "referenceID" : 25,
      "context" : "In their analysis of the delusion box Ring and Orseau (2001b) generalize the agent definition of equations (2.",
      "startOffset" : 38,
      "endOffset" : 62
    }, {
      "referenceID" : 21,
      "context" : "In the original wireheading paper (Olds and Milner 1954), a rat's action, pushing a bar, increased its reward by sending current through a wire connected to the reward center in the rat's brain. In Ring and Orseau's paper (2011), a reinforcement learning (RL) agent's action, choosing the delusion box, increases it's observed reward.",
      "startOffset" : 44,
      "endOffset" : 229
    }, {
      "referenceID" : 11,
      "context" : "How should we define values for interaction histories? Several proposals base ethical AI on human values (Hibbard 2001; Yudkowsky 2004; Goertzel 2004; Hibbard 2008a; Waser 2010; Waser 2011; Muehlhauser and Helm 2012; Waser 2014).",
      "startOffset" : 105,
      "endOffset" : 228
    }, {
      "referenceID" : 31,
      "context" : "How should we define values for interaction histories? Several proposals base ethical AI on human values (Hibbard 2001; Yudkowsky 2004; Goertzel 2004; Hibbard 2008a; Waser 2010; Waser 2011; Muehlhauser and Helm 2012; Waser 2014).",
      "startOffset" : 105,
      "endOffset" : 228
    }, {
      "referenceID" : 11,
      "context" : "How should we define values for interaction histories? Several proposals base ethical AI on human values (Hibbard 2001; Yudkowsky 2004; Goertzel 2004; Hibbard 2008a; Waser 2010; Waser 2011; Muehlhauser and Helm 2012; Waser 2014). These proposals are based on the assumption that AI agents based on human values will not choose unintended instrumental actions that humans dislike, such as taking resources from humans. A key problem for these proposals is finding a way to bridge the gap between the ambiguous, inconsistent, and subjectively infinite variety of human values and the precise, numerical, and clearly finite nature of computation. For example, Waser (2014) proposes basing AI systems on Haidt's morality (Haidt and Kesebir 2010).",
      "startOffset" : 106,
      "endOffset" : 670
    }, {
      "referenceID" : 21,
      "context" : "In our interactions with the world we humans do assign values to situations. In fact we reflexively and automatically assign value to all of our observations and to our interpretations of observations in our mental models of the world. However, Muehlhauser and Helm (2012) surveyed psychology literature and concluded that humans are unable to accurately write down their own values.",
      "startOffset" : 40,
      "endOffset" : 273
    }, {
      "referenceID" : 11,
      "context" : "In my first publication about ethical AI (Hibbard 2001), I wrote that AI should \"learn to recognize happiness and unhappiness in human facial expressions, human voices and human body language\" and use this to reinforce the agent's behaviors.",
      "startOffset" : 41,
      "endOffset" : 55
    }, {
      "referenceID" : 24,
      "context" : "This could be called a Cartesian dualist perspective (Orseau and Ring 2012a).",
      "startOffset" : 53,
      "endOffset" : 76
    }, {
      "referenceID" : 21,
      "context" : "The discussion so far has been about AI agents that interact with an environment but are otherwise separate from the environment. This could be called a Cartesian dualist perspective (Orseau and Ring 2012a). In reality agents are part of their environments and therefore dependent on the environment for resources. Agents are also vulnerable to spying, manipulation, and damage by the environment. We have assumed that AI agents have the necessary resources to compute whatever expressions we define, but the abilities of real AI agents are always limited by their resources. As Pei Wang (1995) wrote, \"intelligence is adaptation under insufficient knowledge and resources.",
      "startOffset" : 76,
      "endOffset" : 595
    }, {
      "referenceID" : 21,
      "context" : "These are complex issues to address in a formal model of agents and environments. As discussed in Section 4.4, Schmidhuber's (2009) Gödel machine modeled the agent's implementation as a program running on a computer.",
      "startOffset" : 12,
      "endOffset" : 132
    }, {
      "referenceID" : 21,
      "context" : "These are complex issues to address in a formal model of agents and environments. As discussed in Section 4.4, Schmidhuber's (2009) Gödel machine modeled the agent's implementation as a program running on a computer. However, it did not model the vulnerability of the computer or program to the environment, or the possibility that the resources of the computer may increase. Also discussed in Section 4.4, Yudkowsky and Herreshoff (2013) modeled a sequence of agents that evolve by creating successor agents in the environment.",
      "startOffset" : 12,
      "endOffset" : 439
    }, {
      "referenceID" : 23,
      "context" : "3 will discuss Orseau and Ring's (2012a) elegant framework for agents embedded in environments.",
      "startOffset" : 15,
      "endOffset" : 41
    }, {
      "referenceID" : 14,
      "context" : "4 will discuss a proposal for self-modeling agents (Hibbard 2014).",
      "startOffset" : 51,
      "endOffset" : 65
    }, {
      "referenceID" : 11,
      "context" : "4 will discuss a proposal for self-modeling agents (Hibbard 2014). Like the papers of Yudkowsky and Herreshoff (2013) and of Orseau and Ring (2012a), this proposal is open to possible future evolution.",
      "startOffset" : 52,
      "endOffset" : 118
    }, {
      "referenceID" : 11,
      "context" : "4 will discuss a proposal for self-modeling agents (Hibbard 2014). Like the papers of Yudkowsky and Herreshoff (2013) and of Orseau and Ring (2012a), this proposal is open to possible future evolution.",
      "startOffset" : 52,
      "endOffset" : 149
    }, {
      "referenceID" : 18,
      "context" : "The set of policy functions Π may be defined by a set of programs or in some other way, as long as π* ∈ Π. In Schmidhuber (2009), and in Orseau and Ring (2011a), the agent selfmodifies by changing its own program for some unalterable program execution hardware.",
      "startOffset" : 30,
      "endOffset" : 129
    }, {
      "referenceID" : 18,
      "context" : "The set of policy functions Π may be defined by a set of programs or in some other way, as long as π* ∈ Π. In Schmidhuber (2009), and in Orseau and Ring (2011a), the agent selfmodifies by changing its own program for some unalterable program execution hardware.",
      "startOffset" : 30,
      "endOffset" : 161
    }, {
      "referenceID" : 21,
      "context" : "However, an agent's definition may include modifications of its utility function. Dewey (2011) proposes that an agent may have a pool (i.",
      "startOffset" : 31,
      "endOffset" : 95
    }, {
      "referenceID" : 21,
      "context" : "It may be appropriate for utility functions to evolve as agents \"mature\" from a period of learning their environments to a period of learning and acting. The examples in Sections 6.3 and 6.4 both include an initial interval of M time steps during which agents learn their environments, possibly using the knowledge-seeking utility function u(h) = -ρ(h) of Orseau and Ring (2011b). The two-stage agent architecture of Section 7.",
      "startOffset" : 3,
      "endOffset" : 380
    }, {
      "referenceID" : 21,
      "context" : "95 its history h in the environment, the environment can modify that memory. Orseau and Ring (2012b) called these environments memory-modifying and studied the problem of the agent being able to determine when its memory has been modified, mainly by detecting that the history h is inconsistent with the agent's logic.",
      "startOffset" : 31,
      "endOffset" : 101
    }, {
      "referenceID" : 27,
      "context" : "In many games, random choices of actions are better than deterministic choices since deterministic choices can be predicted by competing agents (Russell and Norvig 2010; Osborne and Rubinstein 1994).",
      "startOffset" : 144,
      "endOffset" : 198
    }, {
      "referenceID" : 18,
      "context" : "We assume that the two agents play a series of games of matching pennies, so they may learn to predict each other's choices. For agents that choose actions using deterministic algorithms, this game is a computational resources arms race. Building on work of Shane Legg (2006), I defined classes of deterministic agents in terms of the quantity of computing resources used, and showed that, if either agent has sufficient resources to learn an accurate model of any agent in a class containing the other agent, it can predict the choices of the other agent and hence always win (Hibbard 2008b).",
      "startOffset" : 7,
      "endOffset" : 276
    }, {
      "referenceID" : 14,
      "context" : "One solution to this problem is for the agent to learn a model of itself, similar to its model λ(hm) of the environment, and to use this self-model to evaluate future self-improvements (Hibbard 2014).",
      "startOffset" : 185,
      "endOffset" : 199
    }, {
      "referenceID" : 21,
      "context" : "The game of chess provides an example of learning to model value (for chess, the agent's chances of winning) as a function of computing resources. Ferreira (2013) demonstrated an approximate functional relationship between a chess program's ELO rating and its search depth, which can be used to predict the performance of an improved chess-playing agent before it is built.",
      "startOffset" : 6,
      "endOffset" : 163
    }, {
      "referenceID" : 14,
      "context" : "A previous version of self-modeling agents (Hibbard 2014), which did not include the stochastic action a, learned a unified model of combined observations of the environment and the agent's values: (oi, ovt(i)).",
      "startOffset" : 43,
      "endOffset" : 57
    }, {
      "referenceID" : 9,
      "context" : "One key to approximation is finding inductive biases (Ghosn and Bengio 2003; Baum 2004), which are assumptions about the prior distribution of models that enable the system to limit its search to models that are likely to be close to optimal.",
      "startOffset" : 53,
      "endOffset" : 87
    }, {
      "referenceID" : 3,
      "context" : "This is related to the oracle AI approach of Armstrong, Sandberg, and Bostrom (2012), in that both approaches use an AI whose only actions are to provide information to humans.",
      "startOffset" : 70,
      "endOffset" : 85
    }, {
      "referenceID" : 3,
      "context" : "This is related to the oracle AI approach of Armstrong, Sandberg, and Bostrom (2012), in that both approaches use an AI whose only actions are to provide information to humans. The oracle AI is a general question answerer, whereas the decision support system would show us simulated worlds but not answer specific questions. The oracle AI interacts with humans but has restricted ability to act on its environment, whereas an AI agent being tested in the decision support system does not interact with humans. The decision support system applies part of the agent-environment framework to learn a model for the environment, and then uses that model to create a simulated environment for testing an AI system. Chalmers (2010) considers the problem of restricting an AI to a simulation and concludes that it is inevitable that information will flow in both directions between the real and simulated worlds.",
      "startOffset" : 70,
      "endOffset" : 725
    }, {
      "referenceID" : 21,
      "context" : "Human testers will understand and be tempted by their conflict of interest without any need for the agent π'(h') to offer a bribe. As intelligent people they will know that the agent π'(h') can serve their private purposes if they enable it to act on their behalf in the real world. An important element of the decision support system must be to make this temptation and risk a prominent part of the culture of those humans working on the development and testing if AI. As Elliott (2005) commented on the safety of US nuclear weapons, \"The human factor introduces perhaps the weakest link in nuclear weapon safety and control.",
      "startOffset" : 2,
      "endOffset" : 488
    }, {
      "referenceID" : 18,
      "context" : "This will include not only the ability to purchase above-human-level AI systems but also the ability of humans to enhance their own brains and minds (Kurzweil 2005).",
      "startOffset" : 149,
      "endOffset" : 164
    }, {
      "referenceID" : 21,
      "context" : "That is a likely scenario, but many other possible scenarios exist. There may be a technical flaw in AI designs that causes a catastrophe for humanity. Or the most intelligent minds may not be compassionate toward average humans, allowing them to simply perish. Or there may be an effort to create equality among the intelligence of all humans−a possible consequence of AI designed according to Rawls' Theory of Justice as described in Chapter 7. But in fact, it is impossible to predict the consequences of above-human-level AI. As Vernor Vinge (1993) wrote, the technological singularity (i.",
      "startOffset" : 31,
      "endOffset" : 553
    }, {
      "referenceID" : 21,
      "context" : "128 motivated by a desire to avoid the scenario of the Omniscience AI described in Chapter 1 and to avoid the instrumental behaviors described in Chapter 5. If above-human-level AI is inevitable, and if it will inevitably be intrusive and manipulative, then the best option is intrusion and manipulation by an AI design based on human values. However, Bill Joy (2000) and Bill McKibben (2003) advocate that humanity can and should forego AI, as well as nanotechnology and biotechnology.",
      "startOffset" : 4,
      "endOffset" : 368
    }, {
      "referenceID" : 21,
      "context" : "128 motivated by a desire to avoid the scenario of the Omniscience AI described in Chapter 1 and to avoid the instrumental behaviors described in Chapter 5. If above-human-level AI is inevitable, and if it will inevitably be intrusive and manipulative, then the best option is intrusion and manipulation by an AI design based on human values. However, Bill Joy (2000) and Bill McKibben (2003) advocate that humanity can and should forego AI, as well as nanotechnology and biotechnology.",
      "startOffset" : 4,
      "endOffset" : 393
    }, {
      "referenceID" : 21,
      "context" : "In 1887 John Dalberg-Acton, commonly known as Lord Acton, wrote, \"Power tends to corrupt and absolute power corrupts absolutely.\" His observation is supported by social science and neuroscience experiments. Susan Fiske and Eric Dépret (1996) found that people with social power seek less information about others and are more likely to stereotype them, while Michael Kraus and colleagues showed that people from lower social classes are able to more accurately judge the emotions of other people (Kraus, Côté, and Keltner 2010 2010).",
      "startOffset" : 30,
      "endOffset" : 242
    }, {
      "referenceID" : 8,
      "context" : "And there are examples of corporations behaving in ways that would horrify stockholders if they encountered such behavior in their own lives, rather than in distant communities largely invisible to stockholders (Gedicks 2001).",
      "startOffset" : 211,
      "endOffset" : 225
    }, {
      "referenceID" : 3,
      "context" : "Nick Bostrom (2003) argues that we may be living in a numerical simulation; there are proposals for ways to test this hypothesis (Beane, Davoudi and Savage 2012).",
      "startOffset" : 5,
      "endOffset" : 20
    }, {
      "referenceID" : 22,
      "context" : "Luke Muehlhauser and I (Muehlhauser and Hibbard 2014) made the point that errors in autonomous trading programs cost Knight Capital $440 million, and that we cannot expect that AI will be safe simply because it is a tool that does what we instruct it to do.",
      "startOffset" : 23,
      "endOffset" : 53
    }, {
      "referenceID" : 11,
      "context" : "Luke Muehlhauser and I (Muehlhauser and Hibbard 2014) made the point that errors in autonomous trading programs cost Knight Capital $440 million, and that we cannot expect that AI will be safe simply because it is a tool that does what we instruct it to do. Peter Neumann (2014) has documented errors and risks in a wide variety of computer systems over a period of 24 years, many rising to the level of national news stories.",
      "startOffset" : 40,
      "endOffset" : 279
    } ],
    "year" : 2014,
    "abstractText" : null,
    "creator" : "PScript5.dll Version 5.2.2"
  }
}