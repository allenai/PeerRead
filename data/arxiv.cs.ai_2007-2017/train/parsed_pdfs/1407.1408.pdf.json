{
  "name" : "1407.1408.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "The Complexity of Reasoning with FODD and GFODD∗",
    "authors" : [ "Benjamin J. Hescott" ],
    "emails" : [ "hescott@cs.tufts.edu", "roni@cs.tufts.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "p k+1 complete. For Πk formulas evalua-\ntion is Πpk complete, satisfiability is one level higher and is Σ p k+1 complete, and equivalence is Πpk+1 complete."
    }, {
      "heading" : "1 Introduction",
      "text" : "The complexity of inference in first order logic has been investigated intensively. It is well known that the problem is undecidable, and that this holds even with strong restrictions on the types and number of predicates allowed in the logical language. For example, the problem is undecidable for quantifier prefix ∀2∃∗ with a signature having a single binary predicate and equality [8]. Unfortunately, the problem is also undecidable if we restrict attention to satisfiability under finite structures [6, 24]. Thus, in either case, one cannot quantify the relative difficulty of problems without further specialization or assumptions. On the other hand, algorithmic progress in AI has made it possible to reason efficiently in some cases. In this paper we study such problems under the additional restriction that an upper bound on the intended model size is given explicitly. This restriction is natural for many applications, where the number of objects is either known in advance or known\n∗A preliminary version of this paper has appeared as [10]. This paper includes a broader exposition and a significant amount of additional details in proofs and constructions required to obtain the technical results.\nar X\niv :1\n40 7.\n14 08\nv2 [\ncs .A\nI] 2\n0 Fe\nb 20\nto be bounded by some quantity. Since the inference problem is decidable under this restriction, we can provide a more detailed complexity analysis.\nThis paper is motivated by recent work on decision diagrams, known as FODDs and GFODDs, and the computational questions associated with them. Binary decision diagrams [3, 1] are a successful knowledge representation capturing functions over propositional variables, that allows for efficient manipulation and composition of functions, and diagrams have been used in various applications in program verification and AI [3, 1, 11]. Motivated by this success, several authors have attempted generalizations to handle relational structure and first order quantification [9, 33, 30, 16]. In particular FODDs [33] and their generalization GFODDs [16] have been introduced and shown to be useful in the context of decision theoretic planning [2, 20, 12, 13] for problems with relational structure [15, 17].\nGFODDs can be seen to generalize the function-free portion of first order logic (i.e., signatures with constants but without higher arity functions) to allow for non-binary numerical values generalizing truth values, and for numerical quantifiers generalizing existential and universal quantification in logic. Efficient heuristic inference algorithms for such diagrams have been developed focusing on the finite model case, and using the notion of “reasoning from examples” [22, 23, 21]. This paper analyses the complexity of the evaluation, satisfiability, and equivalence problems for such diagrams, focusing on the GFODD subset with min and max aggregation that are defined in the next section. To avoid undecidability and get a more refined classification of complexity, we study a restricted form of the problem where the finite size of the intended model is given as part of the input to the problem. As we argue below this is natural and relevant in the applications of GFODDs for solving decision theoretic control problems. The same restrictions can be used for the corresponding (evaluation, satisfiability and equivalence) problems in first order logic, but to our knowledge this has not been studied before. We provide a complete characterization of the complexity showing an interesting structure. Our results are developed for the GFODD representation and require detailed arguments about the graphical representation of formulas in that language. The same lines of argument (with simpler proof details) yield similar results for first order logic. To translate our results to the language of logic, consider the quantifier prefix of a first order logic formula using the standard notation using Σk, Πk to denote alternation depth of quantifiers in the formula. With this translation, our results show that:\n(1) Evaluation over finite structures spans the polynomial hierarchy, that is, evaluation of Σk formulas is Σpk complete, and evaluation of Πk formulas is Π p k complete.\n(2) Satisfiability, with a given bound on model size, follows a different pattern: satisfiability of Σk formulas is Σ p k complete, and satisfiability of Πk formulas is Σ p k+1 complete.\n(3) Equivalence, under the set of models bounded by a given size, depends only on quantifier depth: both the equivalence of Σk formulas and equivalence of Πk formulas are Π p k+1 complete.\nThe positive results allow for constants in the signature but the hardness results, except for satisfiability for Π1 formulas, hold even without constants. For signatures without constants, satisfiability of Π1 formulas is in NP; when constants are allowed, it is Σ p 2 complete as in the general template. These results are useful in that they clearly characterize the complexity of the problems solved heuristically by implementations of GFODD systems [15, 17] and can be used to partly motivate or justify the use of these heuristics. For example, the “model checking reductions” of [16] that simplify the structure of diagrams replace equivalence tests with model evaluation on a “representative” set of models. When this set is chosen heuristically, as in [15], this leads to inference that is correct\nwith respect to these models but otherwise incomplete. Our results show that this indeed leads to a reduction of the complexity of the inference problem, so that the reduction in accuracy is traded for improved worst case run time. Importantly, it shows that without compromising correctness, the complexity of equivalence tests that are used to compress the representation will be higher. These issues and further questions for future work are discussed in the concluding section of the paper.\nThe rest of the paper is organized as follows. The next section defines FODDs and GFODDs and provides a more detailed motivation for the technical questions. Section 3 then develops the results for FODDs. We treat the FODD case separately for three reasons. First, this serves for an easy introduction into the results that avoids some of the more involved arguments that are required for GFODDs. Second, as will become clear, for FODDs we do not need the additional assumption on model size, so that the results are in a sense stronger. Finally, some of the proofs for GFODDs require alternation depth of at least two so that separate proofs are needed for FODDs in any case. Section 4 develops the results for GFODDs. The final section concludes with a discussion and directions for future work."
    }, {
      "heading" : "2 FODDs and GFODDs and their Computational Problems",
      "text" : "This section introduces the GFODD representation and associated computational problems, and explains how they are motivated by prior work on applying GFODDs in decision theoretic planning. We assume familiarity with basic concepts and notation in predicate logic [25, 29, 4] as well as basic notions from complexity theory [14, 32, 26].\nDecision diagrams are similar to expressions in first order logic (FOL). They are defined relative to a relational signature, with a finite set of predicates p1, p2, . . . , pn each with an associated arity (number of arguments), a countable set of variables x1, x2, . . ., and a set of constants c1, c2, . . . , cm. We do not allow function symbols other than constants (that is, functions with arity ≥ 1). In addition, we assume that the arity of predicates is bounded by some numerical constant. A term is a variable or constant and an atom is either an equality between two terms or a predicate with an appropriate list of terms as arguments. Intuitively, a term refers to an object in the world of interest and an atom is a property which is either true or false.\nTo motivate the diagram representation consider first a simpler language of generalized expressions which we illustrate informally by some examples. In FOL we can consider open formulas that have unbound variables. For example, the atom color(x, y) is such a formula and its truth value depends on the assignment of x and y to objects in the world. To simplify the discussion, we assume for this example that arguments are typed and x ranges over “objects” and y over “colors”. We can then quantify over these variables to get a sentence which will be evaluated to a truth value in any concrete possible world. For example, we can write ∃y,∀x, color(x, y) expressing the statement that there is a color associated with all objects. Generalized expressions allow for more general open formulas that evaluate to numerical values. For example, E1 = [if color(x, y) then 1 else 0] is similar to the logical expression and E2 = [if color(x, y) then 0.3 else 0.5] returns non binary values. Quantifiers from logic are replaced with aggregation operators that combine numerical values and provide a generalization of the logical constructs. In particular, when the open formula is restricted to values 0 and 1, the operators max and min simulate existential and universal quantification. Thus, [maxy,minx, if color(x, y) then 1 else 0] is equivalent to the sentence above. But we can allow for other types of aggregations. For example, [maxy, sumx, if color(x, y) then 1 else 0] evaluates to\nthe largest number of objects associated with one color, and [sumx,miny, if color(x, y) then 0 else 1] evaluates to the number of objects that have no color association. GFODDs are also related to work in statistical relational learning [28, 27, 5]. For example, if the expression E2 captures probability of ground facts which are mutually independent then [productx,producty, if color(x, y) then 0.3 else 0.5] captures the joint probability for all such facts. Of course, the open formulas in logic can include more than one atom and similarly expressions can be more involved. In this manner, a generalized expression represents a function from possible worlds to numerical values. GFODDs capture the same set of functions but provide an alternative representation for the open formulas through directed graphs. GFODDs were introduced together with a set of operations that can be used to manipulate and combine functions and in this way provide a tool for computation with numerical functions over possible worlds. Prior work includes implementation of the FODD fragment where the only aggregation operator allowed is max [17, 15] and more recently implementations for GFODDs with max and average aggregations [19, 18]. In this paper we investigate several computational questions for GFODDs with min and max aggregation."
    }, {
      "heading" : "2.1 Syntax",
      "text" : "First order decision diagrams (FODD) and their generalization (GFODD) were defined by [33, 16] inspired by previous work in [9]. GFODDs are composed of two parts, including the aggregation functions and the open formula portion which is captured by a diagram or graph. The aggregation portion is given by a listing of the variables in the diagram in some arbitrary order (wi1 , . . . , wim) and a corresponding list of length m specifying aggregation over each wij . In this paper we restrict aggregation operators for each variable to be min or max. To reflect the structure of GFODDs, and distinguish between aggregation list V and the graph portion of a diagram B, we sometimes denote a GFODD by 〈V,B〉. However, when clear from the context we use B as a shorthand for 〈V,B〉. FODDs are a special case of GFODDs where the aggregation function is max for all variables. Due to associativity and commutativity of max, the aggregation function for FODDs does not need to be represented explicitly.\nAs in propositional decision diagrams [3, 1], the diagram portion is a rooted acyclic graph with directed edges. Each node in the graph is labeled. A non-leaf node is labeled with an atom from the signature and it has exactly two outgoing edges. The directed edges correspond to the truth values of the node’s atom. A leaf is labeled with a non-negative numerical value. We sometimes restrict diagrams to have only binary leaves with values 0 or 1. In this case we can consider the values to be the logical values false and true. An example diagram is shown in Figure 1. In this diagram and all other diagrams in this paper, left going edges denote the true branch out of a node and right going edges represent the false branch.\nSimilar to the propositional case [3, 1], GFODD syntax is restricted to comply with a predefined total order on atoms. In the propositional case the ordering constraint yields a normal form (a unique minimal representation for each function) which is in turn the main source of efficient reasoning. For GFODDs, a normal form has not been established but the use of ordering makes for more efficient simplification of diagrams. In particular, following [33], we assume a fixed ordering on predicate names, e.g., p1 ≺ p2 ≺ . . . ≺ pn, and a fixed ordering on variable names, e.g., x1 ≺ x2 ≺ . . . and constants c1 ≺ c2 ≺ . . . cm and require that ci ≺ xj for all i and j. The order is extended to atoms by considering them as lists. That is, pi(. . .) ≺ pj(. . .) if i < j and pi(xk1 , . . . , xka) ≺ pi(xk′1 , . . . , xk′a) if (xk1 , . . . , xka) ≺ (xk′1 , . . . , xk′a) in the lexicographic ordering over the lists. Node labels in the GFODD must obey this order so that if node a is above node b\nin the diagram then the labels satisfy a ≺ b. The example of Figure 1 is ordered with predicate ordering E ≺ “ = ” and lexicographic variable ordering v1 ≺ v2 ≺ v3.\nThe ordering assumption is helpful when constructing systems using GFODDs because it simplifies the computations. Our complexity results hold in general, whether the assumption holds or not, therefore showing that while the assumption is convenient it does not fundamentally change the complexity of the problems. In particular, for the positive results, the algorithms showing membership in various complexity classes hold even in the more general case when the diagrams are not sorted. For the hardness results, the reductions developed hold even in the more restricted case when the diagrams are sorted. A significant amount of details in our analysis is devoted to handling ordering issues in hardness results.\nOur complexity analysis will use the following classification of GFODD into subclasses. We say that a GFODD is a max-k-alternating GFODD if its set of aggregation operators has k blocks of aggregation operators, where the first includes max aggregation, the second includes min aggregation, and so on. We similarly define min-k-alternating GFODD where the first block has min aggregation operators. A GFODD has aggregation depth k if it is in one of these two classes."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "Diagrams, like first order formulas, are evaluated in possible worlds that provide an interpretation of their symbols.1 In particular, a possible world or Interpretation , I, specifies a domain of objects, an assignment of each constant in the signature to an object in the domain, and the truth values of predicates over these objects.\nThe semantics assigns a value, denoted MAPB(I), for any diagram B on any interpretation I by considering all possible valuations. A variable valuation ζ is a mapping from the set of variables in B to domain elements in the interpretation I. This mapping assigns each node label\n1Possible worlds are known in the literature under various names including first order structures, first order models, and interpretations. In this paper we use the term interpretations.\nto a concrete (“ground”) atom in the interpretation and therefore to its truth value and in this way defines a single path from root to leaf. The value of this leaf is the value of the GFODD B under the interpretation, I, with variable valuation ζ and is denoted MAPB(I, ζ). The final value, MAPB(I), is defined by aggregating over MAPB(I, ζ). In particular, considering the aggregation order (wi1 , . . . , wim) we loop with j taking values from m to 1 aggregating values over wij using its aggregation operator. We denote this by MAPB(I) = AGζMAPB(I, ζ) where for the special case of FODDs this yields MAPB(I) = maxζ MAPB(I, ζ).\nConsider evaluating the FODD example in Figure 1 on interpretation I = ([1, 2, 3], {E(1, 3), E(3, 1), E(1, 2), E(2, 1)}). Then for ζ = {v1/1, v2/2, v3/3} we have MAPB(I, ζ) = 0 but for ζ = {v1/3, v2/1, v3/2} we have MAPB(I, ζ) = 1 and therefore MAPB(I) = maxζ MAPB(I, ζ) = 1."
    }, {
      "heading" : "2.3 Computations with GFODDs",
      "text" : "The GFODD representation was introduced as a tool for mechanizing and solving decision problems given by structured Markov Decision Processes (MDP), also known as Relational MDP or First Order MDP. A detailed exposition is beyond scope of this paper (see [33, 16]). This section provides some necessary technical details and some background to motivate the computational problems investigated in the paper. In this context, a planning problem world state can be described using an interpretation providing the objects in the world and the relations among them. An action moves the world from one state to another, where in MDPs this transition is non-deterministic. The so-called Q function Q(s, a) provides a quality estimate of each action a in each state s. Using this function, one can control the MDP by picking a = argmaxaQ(s, a) in state s. There are several algorithms to calculate such Q functions and previous work has introduced GFODDs as a compact representation for these functions. This is done by implementing a symbolic version of the well known Value Iteration (VI) algorithm, where the symbolic algorithm operates by manipulating GFODDs. Action selection provides our first computational question, that is, evaluating Q(s, a). In our context, this means calculating MAPB(I) where I captures s and a and B is the representation of the Q function. The same computational problem occurs in several other steps in the symbolic VI algorithm. We define this problem below as GFODD Evaluation.\nRecall that a GFODD represents a function from interpretations to real values. One of the main operations required for the symbolic VI algorithm is combination of such functions. In particular, let f1 and f2 be functions represented by two GFODDs, and let be any binary operation over real values (e.g., plus). The combination operation returns a GFODD representing a function f3 such that for all I we have f3(I) = f1(I) f2(I). That is, f3 is a symbolic representation of the pointwise operation over function values of f1 and f2. Note that since f1 and f2 are closed expressions we can standardize apart their variables before taking this operation.\nFigure 2 shows how to combine the diagram portions (i.e., the open expressions) in a semantically coherent manner using the Apply procedure of [33]. The following theorem identifies conditions for correctness of Apply when used with closed expressions. We say that a binary operation is safe with respect to aggregation operator agg if it distributes with respect to it, that is b agg{a1, a2, . . . , an} = agg{(a1 b), (a2 b), . . . , (an b)}. A list of safe pairs of binary operations and aggregation operators was provided by [16]. For the arguments of this paper we recall that the binary operations + and ∧ are safe with respect to max and min aggregation. For example 5 + max{1, 2, 3, 4} = max{6, 7, 8, 9}. With this definition we have:\nTheorem 1 (see Theorem 4 of [16]) Let B1 = 〈V1, D1〉 and B2 = 〈V2, D2〉 be GFODDs that do not share any variables and assume that opc is safe with respect to all operators in V1 and V2. Let D = apply(B1, B2, opc). Let V be any permutation of the list of variable in V1 and V2 so long as the relative order of operators in V1 and V2 remains unchanged, and let B = 〈V,D〉. Then for any interpretation I, MAPB(I) = MAPB1(I) opc MAPB2(I).\nTherefore, when adding (or taking the logical-and of) functions represented by diagrams that are standardized apart we can use the Apply procedure on the graphical representations of these functions, and at the same time we have some flexibility in putting together their list of aggregation functions. This will be useful in our reductions.\nThe Apply procedure can introduce redundancy into diagrams. By this we mean that a simpler syntactic form, often a sub-diagram, can represent the same function. To illustrate, consider the diagrams of Figure 2 as FODDs (i.e., with max aggregation) and consider edge marked by 0 + 4. It is easy to see that this edge can be redirected to a leaf with value zero without changing MAPB(I) for any I. This is true because if we can reach the leaf with value 6 using some valuation then we can also reach the leaf with value 14 using another valuation because x2 is not constrained. Therefore, the max aggregation will always ignore valuations reaching value 6. It is also easy to see that the\nedge marked 8 + 4 can be redirected to value 14 without changing MAPB(I). Simplification 2 of diagrams by removing unnecessary portions is crucial for efficiency of GFODD implementations and a significant amount of previous work was devoted to mechanizing this process. Note that it is most natural to keep the aggregation portion fixed and simply manipulate the diagram portion. In this paper we abstract this process as testing for GFODD Equivalence, that is, testing whether the diagram is equivalent to a second simpler one. Motivated by the focus in the implementations on algorithms that remove one edge at a time, as illustrated in the example, we also formalize this special case."
    }, {
      "heading" : "2.4 Complexity Theory Notation",
      "text" : "Recall that the polynomial hierarchy is defined from P, NP, and co-NP using an inductive constraction with reference to computation with oracles [14, 32, 26]. In particular we have that Σp1 =NP, and Πp1 =co-NP. An algorithm is in the class A B if it uses computation in A with a polynomial number of calls to an oracle for a problem in class B. Then we have Σpk+1 = NP Σpk , and Πpk+1 = co-NP Σpk . A problem is in Σpk iff its complement is in Π p k and thus (since the oracle always answers deterministically and correctly) either of these can serve as the oracle in the definition."
    }, {
      "heading" : "2.5 Computational Problems",
      "text" : "Before defining the computational problems we must define the representation of inputs. We assume that GFODDs are given using a list of aggregation operators and associated variables and a labelled graph representation of the diagram. This is clearly polynomially related to the number of variables and number of nodes in the GFODD. Some of our problems require interpretations as input. Here we assume a finite domain so as to avoid issues of representing the interpretation. Thus an interpretation is given as a list of objects serving as domain elements, a list specifying the mapping of constants to objects, and the extension of each predicate on these objects. Given that the signature is fixed and the arity of each predicate is constant, this implies that the size of I is polynomially related to the number of objects in I. As illustrated in the example of Figure 1, a graph G = (V,E) can be seen as an interpretation with domain V and with one predicate formed by the edge relation. We can now define the computational problems of interest. We separate the definitions for FODDs and GFODDs because for GFODDs the unrestricted problems are undecidable and they require further refinement. The simplest problem requires us to evaluate a diagram on a given interpretation.\nDefinition 2 (FODD Evaluation) Given diagram B, interpretation I with finite domain, and value V ≥ 0: return Yes iff MAPB(I) ≥ V . In the special case when the leaves are restricted to {0, 1} and V = 1 this can be seen as a returning Yes iff MAPB(I) is true.\nTo calculate MAPB(I) we can “run” a procedure for FODD Evaluation multiple times, once for each leaf value as V , and return the highest achievable result. Thus, if FODD Evaluation is in complexity class A, we can calculate the function value in PA. This fact is used several times in our constructions.\nSince diagrams generalize FOL it is natural to investigate satisfiability:\n2 Simplification was called reduction by [33]; to avoid confusion with the standard complexity theory meaning of the term reduction we use the term simplification instead.\nDefinition 3 (FODD Satisfiability) Given diagram B with leaves in {0, 1}: return Yes iff there is some I such that MAPB(I) is true.\nWhen B has more than two values in its leaves the satisfiability problem becomes:\nDefinition 4 (FODD Value) Given diagram B and value V ≥ 0: return Yes iff there is some I such that MAPB(I) = V .\nNotice that FODD Value requires that V is achievable but no value larger than V is achievable on the same I and, as the proofs below show, the extra requirement makes the problem harder. On the other hand, if we replace equality with ≥ V in FODD Value, the problem is equivalent to FODD Satisfiability because we can simply replace leaf values in the diagram with 0,1 according to whether they are ≥ V .\nFinally, as motivated above, we investigate the simplification problem and its special case with single edge removal.\nDefinition 5 (FODD Equivalence) Given diagrams B1 and B2: return Yes iff MAPB1(I) = MAPB2(I) for all I.\nDefinition 6 (FODD Edge Removal) Given diagrams B1 and B2, where B2 can be obtained from B1 by redirecting one edge to a zero valued leaf: return Yes iff MAPB1(I) = MAPB2(I) for all I.\nGiven the discussion above, GFODDs with binary leaves can be seen to capture the function free fragment of first order logic with equality. It is well known that satisfiability and therefore also equivalence of expressions in this fragment of first order logic is not decidable. In fact, the problem is undecidable even for very restricted forms of quantifier alternation (see survey and discussion in [8]). For example, the problem is undecidable for quantifier prefix ∀2∃∗ with a single binary predicate and equality. The problem is also undecidable if we restrict attention to satisfiability under finite structures. Therefore, without further restrictions, we cannot expect much by way of classification of the complexity of the problems stated above for GFODDs.\nWe therefore restrict the problems so that the size of interpretations is given as part of the input. This makes the problems decidable and reveals the structure promised above. There are two motivations for using such a restriction. The first is that in some applications we might know in advance that the number of relevant objects is bounded by some large constant. For example, the main application of GFODDs to date has been for solving decision theoretic planning problems; in this context the number of objects in an instance (e.g., the number of trucks or packages in a logistics transportation problem) might be bounded by some known quantity. The second is that our results show that even under such strong conditions the computational problems are hard, providing some justification for the heuristic approaches used in FODD and GFODD implementations [15, 17, 18].\nDefinition 7 (GFODD Model Evaluation) Given diagram B, interpretation I with finite domain, and value V ≥ 0: return Yes iff MAPB(I) ≥ V . Note that when the leaves are restricted to {0, 1} and V = 1 this can be seen as a returning Yes iff MAPB(I) is true.\nDefinition 8 (GFODD Satisfiability) Given diagram B with leaves in {0, 1} and integer N in unary: return Yes iff there is some I, with at most N objects, such that MAPB(I) is true.\nDefinition 9 (GFODD Value) Given diagram B, integer N in unary and value V ≥ 0: return Yes iff there is some I, with at most N objects, such that MAPB(I) = V .\nDefinition 10 (GFODD Equivalence) Given diagrams B1 and B2 (with the same aggregation functions) and integer N in unary: return Yes iff for all I with at most N objects, MAPB1(I) = MAPB2(I).\nDefinition 11 (GFODD Edge Removal) Given diagrams B1 and B2 (with the same aggregation functions), where where B2 can be obtained from B1 by redirecting one edge to a zero valued leaf, and given integer N in unary: return Yes iff for all I with at most N objects, MAPB1(I) = MAPB2(I).\nSince we are assuming a fixed arity k, the assumption that N is in unary is convenient because it implies that the size of an intended interpretation I is polynomial in N . Therefore, an algorithm for these problems can explicitly represent an interpretation of the required size and test it. Our hardness results use N which is at most linear in the size of the corresponding diagram B."
    }, {
      "heading" : "3 The Complexity of Reasoning with FODD",
      "text" : "In this section we develop the complexity results for the special case of FODDs. Evaluation of FODDs is essentially the same as evaluation of conjunctive queries in databases and can be analyzed similarly. We include the argument here for completeness.\nTheorem 12 FODD Evaluation is NP -complete.\nProof. Membership in NP is shown by the algorithm that guesses a valuation ζ, calculates MAPB(I, ζ) and returns Yes iff the leaf reached has value ≥ V . Yes is returned iff some valuation yields a value ≥ V as needed.\nFor hardness we reduce the directed Hamiltonian path to this problem. As illustrated in Figure 1, given the number of nodes in a graph we can represent a generic Hamiltonian path verifier as a FODD B. To do this we simply produce a left going path E(x1, x2), E(x2, x3), . . . , E(xn−1, xn) which verifies existence of the edges, followed by equality tests to verify that all nodes are distinct. All “failure exits” on this path go to 0 and the success exit of the last test yields 1. Call this diagram B. This diagram is ordered with E ≺ “ = ” and lexicographic ordering over arguments. Now, given any input G for Hamiltonian path, we represent it as an interpretation I and produce (B, I, 1) as the input for FODD Evaluation. Clearly, G has a Hamiltonian path iff MAPB(I) = 1.\nThe other results for FODDs rely on the existence of small models:\nLemma 13 For any FODD B with k variables and constants, if MAPB(I) = V for some I then there is an interpretation I ′ with at most k objects such that MAPB(I ′) = V .\nProof. Let I be as in the statement. Then there is a valuation ζ such that ζ reaches a leaf valued V in B. Let I ′ be an interpretation including the objects that are used in the path traversed by ζ where the truth value of any predicate over arguments from these objects agrees with I. We have that I ′ has at most k objects, ζ is a suitable valuation for I ′ and MAPB(I\n′, ζ) = V . In addition, no other valuation ζ ′ leads to a value larger than V because, if it did, the same value would be achievable in I. Hence, MAPB(I ′) = MAPB(I ′, ζ) = V .\nTheorem 14 FODD Satisfiability is NP-Complete.\nProof. For membership we can guess an interpretation I, which by the previous lemma can be small, and guess a valuation ζ for that interpretation. We return Yes if and only if MAPB(I, ζ) = 1.\nWe show hardness with a reduction from 3SAT. Let f be an arbitrary 3CNF formula. We create a new FODD variable for each literal in the CNF so that v(i,j) corresponds to the jth literal in the ith clause.\nOur FODD will have three portions connected in a chain. The first portion checks that the predicate PT () in the interpretation can be used to simulate Boolean assignments. To achieve this, we first ensure that the interpretation has at least two different objects, referred to by variables y1 and y2. We then use a small block that ensures that the truth value of PT (y1) is not equal to PT (y2). As a result PT (y1) and PT (y2) correspond to true and false logical values. This is shown in Figure 3.\nThe second portion ensures that if v(i,j) and v(i′,j′) correspond to the same Boolean variable then they map to the same object. For every variable xi we create a shadow FODD variable wi and equate it to all the v(i′,j′) that correspond to xi. We call this sequence of equalities a consistency block. For example, consider the CNF\n(x1 ∨ x2 ∨ x4) ∧ (x1 ∨ x2 ∨ x3) ∧ (x1 ∨ x3 ∨ x4)\nwhere the corresponding FODD variables are\nv(1,1), v(1,2), v(1,3), v(2,1), v(2,2), v(2,3), v(3,1), v(3,2), v(3,3).\nThe first block, corresponding to x1, ensures that w1, v(1,1), v(2,1), v(3,1) are all assigned the same value. In addition to testing that the values are equivalent the block tests that each variable gets bound to the same object as y1 or y2. The only possible way to not get a 0 in these blocks is to ensure that each variable in the block has the same value and that it is equal to either y1 or y2. Figure 4 shows the consistency blocks for our example.\nThe third portion tracks the structure of f to guarantee the same truth value in the FODD. To follow the structure of f , we build a block for each clause and chain these blocks together. Each block has 3 nodes corresponding to the 3 literals in the clause. In particular, if the jth literal in the ith clause is positive the true edge (literal satisfied; call this success) continues to the next clause, and the false edge (literal failed) continues to the next literal. For a negative literal the true\nand false directions are swapped. The fail exit of the 3rd literal is attached to 0. Clause blocks have one entry and one exit and they are chained together. The success exit of the last clause is connected to the leaf 1. The only way to reach a value of 1 is if every clause block was satisfied by the valuations to v(i,j). Figure 5 illustrates the clause blocks for our example.\nEach of the portions, including the clause blocks, has one entry and one exit and we chain them together to get the diagram B. For a valuation to be mapped to 1 it must succeed in all three portions. We claim that f is satisfied if and only if there is some interpretation I such that MAPB(I) = 1.\nConsider first the case where f is satisfiable. We introduce the interpretation I that has two objects, a and b, where PT (a) = true, and PT (b) = false. Let v be a satisfying assignment for f and let ζ(v) be a valuation for B on I where y1 = a, y2 = b and if v maps xi to 1 then wi and its block are mapped to a and otherwise the block is mapped to b. Here, ζ(v) succeeds in all blocks, implying that MAPB(I, ζ(v)) = 1 and therefore MAPB(I) = 1.\nConsider next the case where MAPB(I) = 1 for some I and let ζ be such that MAPB(I, ζ) = 1. Then we claim that ζ identifies a satisfying assignment. First, since ζ succeeds in the first block we identify two objects that correspond via PT () to truth values, without loss of generality assume that PT (y1) is true. Then success in the second portion implies that we can identify an assignment to the Boolean variables, if the ith block is assigned to y1 we let xi = 1 and otherwise xi = 0. Finally, success in the third portion implies that the clauses in f are satisfied by the assignment to\nthe xi’s. This completes the correctness proof. Finally we address node ordering in the diagram. The only violation of ordering is the use of PT () in the first block. Otherwise, we have all equalities above PT (), variable ordering yi ≺ wj ≺ Va,b, and lexicographic ordering within a group. Now because our diagram forms one chain of blocks leading to a single sink leaf with value 1 we can move the three PT () nodes to the bottom of the diagram in Figure 4. This does not change the map value for any valuation and thus does not affect correctness. We therefore conclude that B is consistently sorted and f is satisfiable iff MAPB(I) = 1 for some I.\nThis proof illustrates the differences in arguments needed for FODDs and GFODDs vs. First Order Logic. For the latter, the reduction can use the sentence ∃v, (px1(v) ∨ px2(v) ∨ px4(v)) ∧ (px1(v) . . .) to show the hardness result. However, this cannot be easily represented as a FODD because the literals appearing in the clauses will violate predicate order and, if we try to reorder the nodes from a naive FODD encoding, the result might be exponentially larger. An alternative formulation can use ∃x1 . . . (p(x1) ∨ p(x2) ∨ p(x4)) ∧ (p(x1) . . . to avoid the problem with predicate order. However, similar ordering issues now arise for the arguments. Our reduction introduces additional variables as well as the variable consistency gadget to get around these issues. The same structure of reduction from 3SAT instances and their QBF generalizations will be used in the results for GFODD.\nTheorem 15 FODD Equivalence and FODD Edge Removal are Πp2-complete.\nProof. Since Edge Removal is a special case of Equivalence it suffices to show membership for Equivalence and hardness for Edge Removal. The hardness result is given in two stages; we first present a reduction which does not respect the constraint on node ordering and Edge Removal structure, and then show how to fix the construction to respect these restrictions.\nMembership in Πp2: First observe that, by Lemma 13, if the diagrams are not equivalent then there is a small interpretation that serves as a witness for the difference. Using this fact, we can show that non-equivalence is in Σp2. Given B1, B2 we guess an interpretation I of the appropriate\nsize, and then appeal to an oracle for FODD Evaluation to calculate MAPB1(I) and MAPB2(I). Using these values we return Yes or No accordingly. To calculate the map values, let B be one of these diagrams, and let the leaf values of the diagram be v1, v2, . . . , vk. We make k calls to FODD Evaluation with (B, I, vi) as input. MAPB(I) is the largest value on which the oracle returns Yes. If a witness I for non-equivalence exists then this process can discover it and say No, and otherwise it will always say Yes. Therefore non-equivalence is in Σp2, and equivalence is in Π p 2.\nReduction basics: To show hardness, consider the problem of deciding arrowing from the Ramsey theory of graphs [31]. Given two graphs G1, G2 we say that G1 includes an embedding of G2 if there is a 1-1 mapping g from nodes of G2 to nodes of G1, such that for every edge (v1, v2) of G2, the edge (g(v1), g(v2)) is in G1. We say that G1 includes an isomorphic embedding of G2 if, in addition, g satisfies that for every edge (v1, v2) not in G2, the edge (g(v1), g(v2)) is not in G1.\nWe say that F arrows (G,H), denoted F → (G,H), if for every 2-color edge-coloring of F into colors red and blue, the red subgraph of F includes an embedding of G or the the blue subgraph of F includes an embedding of H.\nThe arrowing problem is as follows: Given 3 graphs F,G,H as input, return Yes iff F arrows (G,H). This problem was shown to be Πp2-complete by [31]. We reduce this problem to FODD equivalence. The signature includes equality and two arity-2 predicates EF and EC , where EF captures the edge relation of the main graph F and EC is a coloring of all possible edges such that when EC(xi, xj) is true the edge is colored red and when it is false the edge is colored blue.\nThe main construction: To transform arrowing into an instance of FODD equivalence we build two FODDs with binary leaves. The first FODD is satisfied iff I includes an isomorphic embedding of F in its edge relation EF . The second FODD is satisfied iff the same condition holds and the coloring defined by EC has a red embedding of G or a blue embedding of H. Note that, due to the 1-1 requirement, I must have at least as many objects as there are nodes in F . We illustrate the construction using the example input in Figure 6. Here the input graphs F, G, H are a positive instance of arrowing.\nTo build a FODD which verifies that I has an isomorphic embedding of F , we map each node to a variable in the FODD and test that each node has its correct neighbors. We first build a “node mapping” gadget that makes sure that each variable in the FODD is mapped to a different object in the interpretation. This is done by following a path of ( V 2 ) inequalities, where off-path edges go to 0 and the final exit continues to the next portion. This gadget, for our example graph F with\n5 nodes, is shown in Figure 7. To test isomorphism to F we test the neighbors of each node in sequence to verify that edges exist iff they are in F . The FODD fragment in Figure 8 shows how this can be tested for vertex f1 in the example. If the edge is present in the graph we continue left (using the true branch) to the next neighbor and if the edge is not in F we continue to the right child (the false branch). Edges off this path are directed to the zero leaf. The endpoint of the path will connect to the next portion of the FODD. This construction can be done for each node and the fragments can be connected together to yield the F verifier. This is illustrated in Figure 9. Finally, the diagram B1 is built by connecting the F verifier at the bottom of node mapping gadget, and replacing the bottom node of the F verifier with a leaf valued 1. We refer to this diagram as the “complete F verifier” below. This construction can be done in polynomial time for any graph F . It should be clear form the construction that MAPB1(I) = 1 iff I includes an isomorphic embedding of F in its edge relation EF . In addition, the verifier diagram is ordered where we have “ = ” ≺ EF , and where variables are ordered lexicographically.\nThe second digram B2 includes the complete F verifier and additional FODD fragments that are described next to capture the conditions on G and H respectively. In order to verify the embedding of colored subgraph G we first define a node mapping capturing the mapping of G nodes into F nodes, and then verify that the required edges exist and that they have the correct color. The FODD fragment in Figure 10 shows how we can select a node mapping for vertex g1. This fragment returns 0 unless g1 is mapped to one of the nodes in F that are identified in the B1 portion. As depicted in Figure 11, this can be repeated for all the nodes in G, verifying that each node in G is mapped to a node in F . Next we need to verify that the mapping is one to one. This can be done by using a path of inequalities between the variables referring to nodes of G. This FODD fragment is given in Figure 12. For correctness, we need to chain the two tests together, but this will violate node ordering. We therefore interleave the tests putting the uniqueness equality tests for a variable exactly after the equalities selecting its value. This change is possible because each such block has exactly one exit point. The resulting diagram, for our running example, is shown in Figure 13.\nTo complete the embedding test, we need to check that the edges are preserved and that they have the correct color. We do this by first checking that the corresponding edges in G are in F . We can do this using a left going path testing each edge in turn, where we test both EF (gi, gj) and EF (gj , gi) to account for the fact that the graph is undirected.\n3 This is illustrated on the left hand side of Figure 14. Note that, because we are testing for an embedding (i.e., not for an isomorphic embedding) we test only for the edges in G and do not need to verify nonexistence of the edges not in G (it just happens here that G is a clique so this is not visible in the example). The same FODD structure is repeated with predicate EC replacing EF to verify that the edges of G are colored red, as shown on the right of Figure 14.\n3The test of both directions of the edge is not necessary, because a different portion of the diagram already verifies that the embedding of F is undirected, but we include it here to simplify the argument.\nA similar construction with node mapping, edge verifier, and color verifier can be used for H. The node mapping construction is identical. Figure 15 shows the edge and color verifiers. The only difference in construction is that the color verifier tests that the edge is not in EC to capture the color blue and therefore has a mirror structure to the one verifying the EF edges. Note that in this case H is not a complete graph and we are indeed only testing for the edges in H. This construction can be done in polynomial time for any G and H.\nFinally we connect the three portions together to obtain B2 as follows. The final output of the complete F verifier is connected to the root of the G verifier. The final output of the G verifier is connected to 1. The zero leaf of the G verifier is removed and instead connected to the root of the H verifier. The final output of the H verifier is connected to 1. Therefore, there are exactly two edges leading to the 1 leaf in this diagram, corresponding to the positive outputs of the G and H verifiers. Figure 16 shows an overview of the two FODDs, B1 and B2, generated by the reduction.\nThe diagrams B1 and B2 are not consistent with any sorting order over node labels, and thus we need to modify them to get a consistent ordering. We show below how this can be done with only a linear growth in the size of the diagrams and without changing the semantics of B1 and B2. Before presenting this transformation we show that F → (G,H) iff B1 and B2 are equivalent.\nCorrectness of the construction: Consider the case when F → (G,H), that is, for every 2- color edge-coloring of F there is a red G or a blue H. We show that the two FODDs are equivalent by way of contradiction. Assume that B1 and B2 are not equivalent and let I be any witness to this fact. Now, MAPB1(I) = 0 implies MAPB2(I) = 0 because the only paths to 1 in B2 go through a copy of B1. Therefore, for the assumed witness I, it must be the case that MAPB1(I) = 1 and MAPB2(I) = 0.\nBy construction, MAPB1(I) = 1 implies that I has an isomorphic embedding of F . Because F → (G,H), any coloring of that embedding, including the coloring captured by EC in I, has a red G or a blue H. Assume that the embedding in I has a red G. Then we can construct the appropriate node mapping in a valuation ζ to show that MAPB2(I, ζ) = 1, contradicting the assumption. The same argument handles the case when the embedding has a blue H.\n0\nConsider the case when F does not arrow (G,H). Then there is a valid 2-color edge-coloring of F which does not have a red G and does not have a blue H. Construct the corresponding interpretation I that represents F and this edge-coloring. We claim that MAPB1(I) = 1 and MAPB2(I) = 0. The fact MAPB1(I) = 1 follows by mapping the nodes in F to the variables that represent them. Now if MAPB2(I) = 1 then MAPB2(I, ζ) = 1 for some ζ and we can trace the path that ζ traverses in B2. This path together with ζ can be used to identify either a red G or a blue H in I and therefore in the corresponding coloring of F . This contradicts the assumption that the coloring is a witness for non-arrowing.\nFixing the construction to handle ordering and edge removal special case: We next consider the node ordering in B1 and B2. The diagram B1 is sorted, where predicate order puts equalities above EF and arguments are lexicographically ordered. For B2 we consider the sub-block structure of the construction. Expanding each of the sub-blocks of F , G, H in Figure 16 we observe\nthat B2 has the structure shown in Figure 17. We further observe that each block is internally sorted, but blocks of equalities, EF and EC are interleaved. By analyzing this structure we see that the blocks can be reordered at the cost of duplicating some portions yielding the structure in Figure 18. It is easy to see that B2 is satisfied in I if and only if the reordered diagram is satisfied in I. The diagrams yield the same value for any valuation ζ which does not exit to 0 due to bad node mapping for G or H. Thus the original version might yield 1 (e.g., through G path) when the reordered diagram yields 0 on such a valuation (e.g., via the H equalities). But in such a case there is another valuation that is identical to ζ except that it modifies the bad node mapping (the H equalities) and that yields 1 for the new diagram. The final diagram is consistent with predicate ordering “ = ” ≺ EF ≺ EC and variable ordering where fi ≺ gj ≺ hk for all i, j, k.\nFinally, we further change B1 by adding the equality blocks of G and H to the construction, so that the modified B1 is as shown in Figure 19. Using the same argument as in B2 one can see that this does not change the semantics of B1. Moreover, with this change B1 can be obtained from B2 by one edge removal (of the edge below the F verifier in B2) so that the reduction holds for this more restricted case.\nAs mentioned above, FODD Value is defined similarly to FODD Satisfiability but requires more stringent conditions. The next result shows that this difference is important and FODD Value is one level higher in the hierarchy.\nTheorem 16 FODD Value is Σp2-complete.\nProof. The algorithm showing membership is as follows. We first observe that by Lemma 13 we can restrict our attention to small interpretations. Given input B and V we guess an interpretation I of the appropriate size. We then make two calls to an oracle for FODD Evaluation. Let V ′ be either the least leaf value greater than V or one greater than the max leaf if V is the maximum. We query the oracle for FODD Evaluation on (B, I, V ) and (B, I, V ′) and return Yes iff the oracle returns\nYes on the first and No on the second. The algorithm returns Yes iff there is an interpretation I with value V .\nFor hardness we present a reduction from non-Equivalence of FODDs with binary leaves, which was shown to be Σp2-hard in Theorem 15. We are given B1 = maxx1 B1(x1) and B2 = maxx2 B2(x2) as input for FODD non-Equivalence where B1 and B2 are standardized apart so that x1, x2 stand for disjoint sets of variables. We construct the diagram B = maxx1 maxx2 B(x1, x2) where B(x1, x2) = B1(x1)+B2(x2) can be calculated directly on the graph representation of B1 and B2 using the apply procedure of [33] (see Figure 2). Because x1 and x2 are disjoint, the diagram B has the following behavior for any interpretation I: if MAPB1(I) = 1 and MAPB2(I) = 1 then MAPB(I) = 2; otherwise if exactly one of them evaluates to 1 then MAPB(I) = 1; and otherwise MAPB(I) = 0. We produce (B, V = 1) as input for FODD Value.\nNow, if B1 and B2 are not equivalent then there is an interpretation such that their maps are different, and without loss of generality we may assume MAPB1(I) = 1 and MAPB2(I) = 0. As argued above in this case MAPB(I) = 1 as needed. For the other direction let I be such that MAPB(I) = 1. Then, again using the argument above, we have MAPB1(I) = 1 and MAPB2(I) = 0 or vice versa and the diagrams are not equivalent."
    }, {
      "heading" : "4 The Complexity of Reasoning with GFODD",
      "text" : "In this section we analyze the computational problems for GFODD. We start with some observations on a notion of “complements” for GFODDs. Let B be a GFODD associated with the ordered list of variables (wi1 , . . . , wim), and aggregation list (A1, . . . , Am) where each Ai is min or max. Let B′ = complement(B) (with respect to maximum value M) be the diagram corresponding to B where we change leaf values and aggregation operators as follows: Let M be any value greater or equal to the max leaf value in B. Any leaf value v is replaced with M − v. Each aggregation operator Ai is replaced with A ′ i where where if Ai is min then A ′ i is max and vice versa.\nTheorem 17 Let B be a GFODD with min and max aggregation and maximum leaf value ≤M , and let B′ = complement(B). For any interpretation I, MAPB(I) = M −MAPB′(I).\nProof. By the construction of B′, for any valuation ζ, we have that MAPB(I, ζ) = M − MAPB′(I, ζ). Considering the aggregation process, note that Ai MAPB(. . . wi) = Ai [M − MAPB′(. . . wi)] = M−A′i MAPB′(. . . wi). Now using this fact, we can argue by induction backward from the innermost (rightmost) aggregation that for any prefix of variables P = wi1 , . . . , wip , valuation ζp for these variables, and remaining variables R = wip+1 , . . . , wim , we have AR MAPB(I, (P = ζp;R)) = M − A′R MAPB′(I, (P = ζp;R)). When the prefix is empty we get the statement of the theorem.\nNotice that for diagrams with binary leaves this yields MAPB(I) = 1 − MAPB′(I), that is, negation. As an immediate application we get the following:\nCorollary 18 The complexity of GFODD Equivalence for min-k-alternating GFODD is the same as the complexity of GFODD Equivalence for max-k-alternating GFODD.\nProof. By Theorem 17, two min diagrams B1, B2 are equivalent if and only if their complements B′1, B ′ 2 are equivalent where we can use the maximum among the leaf values of the two diagrams as M .\nCorollary 19 The equivalence problem for min-GFODD is Πp2-complete.\nWe can now turn to analysis of the computational problems. Evaluation is similar to the FODD case but the hardness proof is more involved due to the interaction between quantifier order and node ordering in the diagram.\nTheorem 20 GFODD Evaluation for max-k-alternating GFODDs is Σpk-complete. GFODD Evaluation for min-k-alternating GFODDs is Πpk-complete.\nProof. We prove membership by induction on k. Since the inductive step includes diagrams that do not satisfy the sorting order we show that the claim holds in this more general case. Consider the input (B, I, V ). For the base case, k = 1, we guess a valuation ζ, calculate v = MAPB(I, ζ), and return Yes iff v ≥ V . In the max case, if the true value is at least V then we say Yes for some ζ, and if the true value is less than V then MAPB(I, ζ) < v for all ζ and therefore we always say No. Thus the problem is in NP. In the min case, if the true value is at least V then all ζ yield Yes, and if the true value is less than V then some ζ yields No. Thus the problem is in co-NP.\nFor the inductive step assume that the claim holds for k−1 and consider the input (B, I, V ) with an interpretation I, value bound V and a max-k-alternating diagram B = maxw1 minw2 . . . Q A wk B(w1, . . . ,wk) where in order to simplify the notation each wi may be a single variable or a set of variables and we use the boldface notation to denote this fact.\nNow for each tuple i of domain objects in I (which is appropriate for the number of variables in w1) let diagram B ′ be B′ = minw2 . . . Q A wk B(w1 = i, . . . ,wk). Clearly B\n′ is appropriate for evaluation on I and by the inductive hypothesis we can appeal to a Πpk−1 oracle to solve GFODD Evaluation on (B′, I, V ). Our algorithm guesses a value i, calculates B′, appeals to the oracle, and returns the same answer. Now, if the true value is < V then by definition any call to the oracle would yield No and we correctly answer No. If the true value is ≥ V then for some i the oracle would return Yes. Therefore we nondeterministically return Yes and our algorithm is in NPΣ p k−1 . The argument for the other aggregation prefix is symmetric and argued in the same manner yielding an algorithm in co-NPΣ p k−1 .\nTo show hardness we give a reduction from QBFk. Given a quantified 3CNF Boolean formula we transform this into a GFODD B and interpretation I so that the following claim holds:\nClaim 1: B evaluates to 1 in I if and only if the quantified Boolean formula is satisfied.\nThis claim establishes the theorem. The reduction uses a similar structure to the one used for FODD satisfiability with two main differences. First because here we consider evaluation and we can control I we do not need to test for an embedding of a Boolean predicate in I, that is, the first portion in that construction is not needed. On the other hand the construction and proof are more involved because of the alternation of quantifiers.\nThe interpretation I has two objects, a and b, where PT (a) =true, and PT (b) =false. Namely, I = {[a, b], PT (a) = true, and PT (b) = false}.\nLet the QBF formula be Q1x1Q2x2 . . . Qmxmf where Q is a quantifier ∀ or ∃ and the quantifiers come in k alternating blocks. As above, we start the construction by creating a set of “shadow variables” corresponding to each QBF variable xi. The corresponding GFODD variables include wi and the set of v(a,b) that refer to xi or xi in the QBF. We define wi to be the set of variables in the block corresponding to xi and associate these variables with an aggregation operator Q A i where if Qi is a ∃ then QAi is max and if Qi is a ∀ then QAi is min. Using these variables, we build GFODD fragments we call variable consistency blocks. For each xi, this gadget ensures that if two literals in the QBF refer to the same variable then the corresponding variables in the GFODD will have the same value. If this holds then a valuation goes through the block and continues to the next block. Otherwise, it exits to a default value, where for max blocks the default value is 0, and for min blocks the default value is 1.\nConsider the expression\n∀x1∃x2∀x3∃x4(x1 ∨ x2 ∨ x4) ∧ (x1 ∨ x2 ∨ x3) ∧ (x1 ∨ x3 ∨ x4),\nwhich has the same clauses as in the previous proof but where we have changed the quantification. Figure 20 shows the variable consistency blocks for this example. Since, v(1,1), v(2,1), and v(3,1) refer to x1 we need to ensure that when they are evaluated they are evaluated consistently and this is done by the first block. Because x1 is a ∀ variable the default output value is 1. The consistency blocks are chained in the same order as in the quantification of the QBF. Once every consistency block has been checked, we continue to the clause blocks whose construction is exactly the same as in the previous proof (see Figure 5). This yields the diagram B where we set the aggregation function\nto be QA1 w1, Q A 2 w2, . . . , Q A mwm. Note that if the QBF has k alternating blocks of quantifiers then B has aggregation depth k. The output of the reduction is the pair (B, I). The diagram is ordered with “ = ” ≺ PT and variables ordered lexicographically.\nWe next show that Claim 1 holds. We start by showing a correspondence between assignments to the Boolean formula f and object assignments from B to I. Let v be a Boolean assignment. If v assigns xi to 1 then ζ(v) maps the entire wi block to a. Otherwise ζ(v) maps the block to b. It is then easy to see that for all v, ζ(v) satisfies the consistency blocks and f(v) = 1 if and only if MAPB(I, ζ(v)) = 1. This, however, does not complete the proof because MAPB(I) must also consider valuations ζ that do not arise as maps of assignments v.\nWe divide the set of valuations to the GFODD into two groups. The first group of legal valuations, called Group 1 below, is the set of valuations that is consistent with some v.\nThe second group, Group 2, includes valuations that do not arise as ζ(v) and therefore they violate at least one of the consistency blocks. Let ζ be such a valuation and let QAj be the first block from the left whose constraint is violated. By the construction of B, in particular the order of equality blocks along paths in the GFODD, we have that the evaluation of the diagram on ζ “exits” to a default value on the first violation. Therefore, if Qj is a ∀ then MAPB(I, ζ) = 1 and if Qj is a ∃ then MAPB(I, ζ) = 0.\nWe can now show the correspondence in truth values. Consider any partition of the blocks 1, . . . ,m into a prefix 1, . . . , j and remainder (j + 1), . . . ,m, and any Boolean assignment v to the prefix blocks. We claim that for all such partitions\nQj+1xj+1, . . . , Qmxm, f ((x1, . . . , xj) = v, (xj+1, . . . , xm)) =\nQAj+1wj+1, . . . , Q A mwm, MAPB(I, [(w1, . . . ,wj) = ζ(v), (wj+1, . . . ,wm)]).\nNote that when j = 0, that is, the prefix is empty, the claim implies that MAPB(I) is equal to Q1x1, . . . , Qmxm, f , completing the proof. We prove the claim by induction, backwards from m to 0. For the base case, j = m, and the second part is empty. The claim then follows because the\nprefix includes all variables and there is a 1-1 correspondence in truth values for substitutions in group 1.\nFor the inductive step, the valuation v covers the first j− 1 blocks. Note that, by the inductive assumption, for any group 1 substitution vj for xj and corresponding, ζ(vj) for wj ,\nQj+1xj+1, . . . , Qmxm, f ((x1, . . . , xj−1) = v, (xj = vj), (xj+1, . . . , xm)) =\nQAj+1wj+1, . . . , Q A mwm, MAPB(I, [(w1, . . . ,wj−1) = ζ(v), (wj = ζ(vj)), (wj+1, . . . ,wm)]).\nOn the other hand, for any group 2 substitution ζj for wj and any values for (wj+1, . . . ,wm) we have that the leftmost block whose constraint is violated for the corresponding combined ζ is block j and therefore MAPB(I, [(w2, . . . ,wj−1) = ζ(v), (wj = ζj), (wj+1, . . . ,wm)]) gets the default value for that block. Therefore, the aggregation over the jth block is determined by group 1 valuations, which are in turn identical to the QBF value and\nQjxj , . . . , Qmxm, f(x1, . . . , xj−1) = v, (xj , . . . , xm)) =\nQAj wj , . . . , Qmwm, MAPB(I, [(w2, . . . ,wj−1) = ζ(v), (wj , . . . ,wm)])\nas required.\nIt turns out that the complexity of satisfiability is different for min and max diagrams, and their analysis requires different proofs. We therefore start with max-k-alternating GFODDs. The case of min-k-alternating GFODDs is analyzed after the analysis of equivalence because it is using similar techniques.\nTheorem 21 GFODD Satisfiability for max-k-alternating GFODDs (where k ≥ 2) is Σpk-complete.\nProof. We first show membership. LetB be a GFODD with aggregation max w1,min w2, . . . , Q A k wk. Our algorithm nondeterministically chooses an interpretation I and a tuple of values for w1, from the domain of objects for I. Let i refer to this tuple of objects. We create a new GFODD,\nB′ = min w2 . . . Q A kB(w1 = i, . . . , wk) and appeal to a Π p k−1 oracle to solve GFODD evaluation on (B′, I). If the oracle query returns 1 then we accept and otherwise we reject. The result is clearly correct using an algorithm in NPΣ p k−1 .\nThe hardness argument is similar to the proof for GFODD evaluation. The main extension is that in the current proof we verify that any satisfying I embeds the interpretation from the previous proof. The reduction gets a QBFk formula, Q1x1Q2x2 . . . Qmxmf , with Qi either a ∀ or ∃ quantifier. We first construct two diagrams B1 and B2, where B2, the QBF validation diagram, is exactly as in the proof of Theorem 20, that is, it includes consistency blocks followed by clause blocks. The diagram B1 has two portions. The first verifies that I has at least two objects and the truth values of PT () on these objects are different. The second portion verifies that I has at most two objects. This is implemented using min variables such that if we identify three distinct objects we set the value to 0. The two portions are put together so as to respect predicate order, and the final diagram B1 is shown in Figure 21. The aggregation function for B1 is maxy1 maxy2 minz1 minz2 minz3 .\nLet I∗ = {[a, b], PT (a) =true, and PT (b) =false} be the intended interpretation. We have the following two claims: (C1) for all I, MAPB1(I) = 1 if and only if I is isomorphic to I\n∗. (C2) if I is isomorphic to I∗ then MAPB2(I) = 1 if and only if (Q1x1Q2x2 . . . Qmxmf) = 1.\nC2 is exactly the same as Claim 1 in the proof of Theorem 20. For C1, given I which is isomorphic to I∗, the valuation of y1, y2 to a, b and any valuation to the z’s yields a map value of 1. Therefore, considering the aggregation order we see that for (y1, y2) = (a, b) in B1 the minimum over z yields 1, and then the maximum over y’s is 1. For the other direction, we need to consider interpretations not isomorphic to I∗. If I has only one object then its map is 0 for all valuations, and therefore the aggregated value is 0. If I has at least 3 objects then for any fixed valuation for y the minimum over z is 0, implying that the maximum over y also yields 0 and MAPB1(I) = 0. Finally consider any I with two objects where PT () has the same truth value on the two objects. In this case the map is 0 for any valuation and thus the final map value is 0. We have therefore shown that C1 holds.\nFor our reduction, we produce B = apply(B1, B2,∧) where for the aggregation we make use of Theorem 1 and interleave the aggregation functions of B1 and B2 so that B has at most k alternations of quantifiers. This is always possible because the QBF starts with a ∃ quantifier and k ≥ 2.\nBy the claims C1 and C2 and Theorem 1 we get that MAPB(I) = 1 if and only if I is isomorphic to I∗ and (Q1x1Q2x2 . . . Qmxmf) = 1. Therefore, the QBF is true if and only if there exists an interpretation I (which must be isomorphic to I∗) that satisfies B.\nEquivalence is one level higher in the hierarchy; using a reduction from QBF we show how to “peel off” one level of quantifiers and push that into the “existential quantification” over interpretations that potentially witness non-equivalence.\nTheorem 22 GFODD Equivalence and GFODD Edge Removal for diagrams with aggregation depth k (where k ≥ 2) are Πpk+1-complete.\nProof. By Corollary 18, it suffices to show that this holds for max-k-alternating GFODDs. Since Edge Removal is a special case of Equivalence it suffices to show membership for Equivalence and hardness for Edge Removal.\nTo show membership we show that the complement, nonequivalence, is in Σpk+1. Given two max-k-alternating GFODDs B1 and B2 as input, we guess an interpretation I of the appropriate size, and then appeal to an oracle for GFODD Evaluation to calculate MAPB1(I) and MAPB2(I). Using these values we return Yes or No accordingly. To calculate the map values, let B be one of these diagrams, and let the leaf values of the diagram be v1, v2, . . . , v`. We make ` calls to GFODD Evaluation with (B, I, vi) as input. Each call requires an oracle in Σ p k and MAPB(I) is the largest value on which the oracle returns Yes. Clearly if a witness for nonequivalence exists then this process can discover it and say Yes (per non-equivalence), and otherwise it will always say No. Therefore non-equivalence is in NPΣ\np k , that is Σpk+1 and equivalence is in Π p k+1.\nWe reduce QBF satisfiability with k ≥ 3 alternations of quantifiers to equivalence of max-(k−1)alternating GFODDs. The reduction is conceptually similar to the one from the previous theorem but the details are more involved. In particular, here we assume a QBF whose first quantifier is ∀, that is, ∀x1, Q2x2 . . . Qmxmf(x1, x2, . . . , xm) where this form has k blocks of quantifiers. To simplify the notation it is convenient to collect adjacent variables having the same quantifiers into groups so that the QBF has the form ∀x1 . . . Qkxkf(x1,x2, . . . ,xk) where xi refers to a set of variables.\nWe next define a notion of “legal interpretations” for our diagrams. A legal interpretation embeds the binary interpretation I∗ from the previous proof and in addition includes a truth setting for all the variables in the first ∀ block of the QBF. The reduction constructs diagrams B1, B2, and B = apply(B1, B2,∧) such that the following claims hold: (C1) for all I, MAPB1(I) = 1 if and only if I is legal. (C2) if I is legal and it embeds the substitution x1 = α then MAPB2(I) = 1 if and only if Q2x2 . . . Qkxkf((x1 = α),x2, . . . ,xk) = 1.\nWe then output the diagrams (B1, B) for GFODD equivalence. Note that, by C1 and Theorem 1, for non-legal interpretations we have MAPB1(I) = MAPB(I) = 0 and therefore if the diagrams are not equivalent it must be because of legal interpretations. Now, if the QBF is satisfied then, by definition, for all x1 = α we have that Q2x2 . . . Qkxkf((x1 = α),x2, . . . ,xk) = 1. Therefore, by C2, for all legal I, MAPB2(I) = 1 and by C1 and the construction MAPB(I) = 1. Thus B and B1 are equivalent.\nOn the other hand, if the QBF is not satisfied then there is a substitution x1 = α where Q2x2 . . . Qkxkf((x1 = α),x2, . . . ,xk) = 0. Therefore, by C2, for the corresponding interpretation I ′, MAPB2(I ′) = 0 and by Theorem 1 we also have MAPB(I ′) = 0. But by C1, MAPB1(I\n′) = 1 and therefore B1 and B are not equivalent.\nWe now proceed with the reduction, starting first with a simplified construction ignoring ordering of node labels and edge removal structure, and then elaborating to enforce these constraints. The set of predicates includes PT () and for every QBF variable xi in the first ∀ block we use a predicates Pxi(). Notice that each xi is a member of x1 (the first ∀ group) where the typeface distinguishes the individual variables in the first block, from blocks of variables. In the simplified construction, a legal interpretation has exactly two objects, say a and b, where PT (a) 6= PT (b) and where for each Pxi() we have Pxi(a) = Pxi(b). In other words, the assignment of an object to v in PT (v) simulates an assignment to Boolean values, but the truth value of Pxi(v) is the same regardless of which object is assigned to v.\nIn our example QBF ∀x1∃x2∀x3∃x4(x1 ∨x2 ∨x4)∧ (x1 ∨x2 ∨x3)∧ (x1 ∨x3 ∨x4) the first block includes only the variable x1 and the following interpretation is legal: I = {[a, b], PT (a) =true, PT (b) =false, Px1(a) = Px1(b) =false}.\nThe diagram B1 has three portions where the first two are exactly as in the previous proof, thus verifying that I has two objects and that PT () behaves as stated. The third portion verifies that each Pxi() behaves as stated, where we use a sequence of blocks, one for each Pxi(). The combined diagram B1 is shown in Figure 22 and the aggregation function is maxy1,y2 ,minz1,z2,z3 .\nTo see that C1 holds consider all possible cases for non-legal interpretations. If I has at most one object the map is 0 for all valuations and thus the aggregation is 0. If I has at least 3 objects, then for any values for y1, y2 the min aggregation over z yields 0, and therefore the map is 0. If I has 2 objects but it violates the condition on PT or Pxi then again the map is 0 for any valuation and the aggregation is 0. On the other hand, if I is legal, then the z block never yields 0 and the correct mapping to y1, y2 yields 1. Therefore the aggregation is 1.\nThe diagram B2 is constructed by modifying B2 from the proof of Theorem 20. The first modification is to handle the first ∀ block differently. As it turns out, all we need to do is replace the min aggregation for the w1 block with maximum aggregation and accordingly replace the default value on that block to 0. To avoid confusion we recall that the current proof uses a slightly different notation from the previous one. In the current proof xi is a set of variables from the QBF and therefore wi is a set of blocks of variables, all of which have the same aggregation function. The modified variable consistency diagram is shown in Figure 23. The clause blocks have the same structure as in the previous construction but use Pxi(V(i1,i2)) when xi is a ∀ variable from the first block and use PT (V(i1,i2)) otherwise. This is shown in Figure 24. B2 includes the variable consistency blocks followed by the clause blocks. Note that the new clause blocks are not sorted in any consistent order because the predicates Pxi() and PT () appear in an arbitrary ordering determined by the appearance of literals in the QBF. Other than this violation, all other portions of the diagrams described are sorted where the predicate order has =≺ PT ≺ Pxi and where variables wi are before v(i1,i2) and variables within group are sorted lexicographically. The combined aggregation function is maxw1 ,maxw2 ,minw3 , . . . , Q A wk .\nWe next show that claim C2 holds, which will complete the proof of the simplified construction. Consider any legal I, let the corresponding truth values for variables in x1 be denoted α, and consider valuations for the QBF extending x1 = α. Now consider any valuation v to the remaining variables in the QBF and the induced substitution to the GFODD variables ζ(v) that is easily identified from the construction. Add any consistent group assignment to w1 (that is, we assign a or b to each subgroup of variables in that group) to ζ(v) to get ζ̂(v). By the construction of B2 we have that f([x1 = α, (x2, . . . ,xk) = v]) = MAPB2(I, ζ̂(v)). To see this note that there are no quantifiers in this expression, there is a 1-1 correspondence between the valuations of x2, . . . ,xk and w2, . . . ,wk, and that as long as the assignment to the w1 block is group consistent it does not affect the value returned. We call this set of valuations, that arise as translations of substitutions for QBF variables, Group 1.\nThe second group, Group 2, includes valuations that do not arise as ζ̂(v) and therefore they violate at least one of the consistency blocks. Let ζ be such a valuation and let QAj be the first block from the left whose constraint is violated. By the construction of B2, in particular the order of equality blocks along paths in the GFODD, we have that the evaluation of the diagram on ζ “exits” to a default value on the first violation. Therefore, if j = 1, that is the violation is in the block of w1, MAPB(I, ζ) = 0 and for j ≥ 2 if Qj is a ∀ then MAPB(I, ζ) = 1 and if Qj is a ∃ then MAPB(I, ζ) = 0.\nWe can now show the correspondence in truth values. Consider any partition of the blocks 2, . . . , k into a prefix 2, . . . , j and remainder (j+ 1), . . . , k, and any valuation v to the prefix blocks. We claim that for all such partitions\nQj+1xj+1, . . . , Qkxk, f(x1 = α, (x2, . . . ,xj) = v,xj+1, . . . ,xk) =\nQj+1wj+1, . . . , Qkwk,MAPB2(I, [w1 = a, (w2, . . . ,wj) = ζ(v), (wj+1, . . . ,wk)]).\nNote that when j = 1, that is, the prefix is empty, this yields that Q2x2, . . . , Qkxk, f(x1 = α,x2, . . . ,xk) is equal to Q A 2 w2, . . . , Q A k wk,MAPB2(I, [w1 = a,w2, . . . ,wk)]). Now because the default value for violations of w1 is 0 and because the aggregation for w1 is max the latter ex-\npression is equal to QA1 w1, . . . , Q A k wk,MAPB2(I, [w1,w2, . . . ,wk)]). This means that MAPB2(I) is equal to Q2x2, . . . , Qkxk, f(x1 = α,x2, . . . ,xk) completing the proof of C2. We prove the claim by induction, backwards from k to 1. For the base case, j = k, and the second part is empty. The claim then follows because the prefix includes all variables and there is a 1-1 correspondence in truth values for substitutions in group 1.\nFor the inductive step, the valuation v covers the first j − 1 blocks. Note that, by the inductive assumption, for any group 1 substitution vj for xj and corresponding, ζ(vj) for wj , Qj+1xj+1, . . . , Qkxk, f(x1 = α, (x2, . . . ,xj−1) = v, (xj = vj),xj+1, . . . ,xk) = Q A j+1wj+1, . . . , Q A k wk, MAPB2(I, [w1 = a, (w2, . . . , wj−1) = ζ(v), (wj = ζ(vj)), (wj+1, . . . ,wk)]). On the other hand, for any group 2 substitution ζj for wj and any values for (wj+1, . . . ,wk) we have that the violating block for the corresponding combined ζ is block j and therefore MAPB2(I, [w1 = a, (w2, . . . ,wj−1) = ζ(v), (wj = ζj), (wj+1, . . . ,wk)]) gets the default value for that block. Therefore, the map is determined by group 1 valuations, which are in turn identical to the QBF value and Qjxj , . . . , Qkxk, f(x1 = α, (x2, . . . ,xj−1) = v, (xj , . . . ,xk)) = Q A j wj , . . . , Q A k wk,MAPB2(I, [w1 = a, (w2, . . . ,wj−1) = ζ(v) , (wj , . . . ,wk)]) as required. Therefore, the claim on the correspondence of values holds. This completes the proof of C2.\nExtending the reduction to handle ordering and edge removal special case: The main idea in the extended construction is to replace the unary predicates PT and Pxi with one binary predicate q(·, ·) where the “second argument” in q() serves to identify the corresponding predicate and hence its truth value. In addition we force q() to be symmetric so that for any A and B the truth value of q(A,B) is the same as the truth value of q(B,A). In this way we have freedom to use either q(A,B) or q(B,A) as the node label which provides sufficient flexibility to handle the ordering issues. To implement this idea we need a few additional constructions.\nLet the set of variables in the first ∀ block of the QBF be x1, x2, . . . , x`. The set of predicates in the extended reduction includes unary predicates T (), y1(), y2(), x1(), x2(), . . . , x`(), and one binary predicate q(·, ·). A legal interpretation includes exactly `+ 3 objects which are uniquely identified by the unary predicates. We therefore slightly abuse notation and use the same symbols for the\nobjects and predicates. In particular, the atoms y1(y1), y2(y2), T (T ), and x1(x1), x2(x2), . . . , x`(x`) are true in the interpretation and only these atoms are true for these unary predicates (e.g., x1(T ) is false). The truth values of q() reflect the simulation of PT () and Pxi() in addition to being symmetric. Thus the truth values of q(y1, T ) and q(T, y1) are the same and they are the negation of the truth values of q(y2, T ) and q(T, y2). For all i, the truth values of q(y1, xi), q(xi, y1), q(y2, xi) and q(xi, y2) are the same. The truth values of other instances of q(), for example, q(x2, T ), can be set arbitrarily. For example, the following interpretation is legal when ` = 1: I = {[a, b, c, d], y1(a), y2(b), T (c), x1(d), q(c, a) = q(a, c) = true, q(c, b) = q(b, c) = false, q(d, a) = q(a, d) = q(d, b) = q(b, d) = false, q(·, ·) = false} where q(·, ·) refers to any instance not explicitly mentioned in the list.\nWe next define the diagram B1 that is satisfied only in legal interpretations. We enforce exactly `+ 3 objects using two complementary parts. The first includes\n( `+4\n2\n) inequalities on a new set of\n` + 4 variables z1, . . . , z`+4 with min aggregation. If we identify ` + 4 distinct objects we set the value to 0. This is shown in Figure 25.\nTo enforce at least `+ 3 objects and identify them we use the following gadget. For each of the unary predicates we have a diagram identifying its object and testing its uniqueness where we use both max and min variables. This is shown for the predicate T () in Figure 26. The node T (T ) with max variable T identifies the object T . The nodes T (r1), T (r2) with min variables r1, r2 make sure that T holds for at most one object. We chain the diagrams together as shown in Figure 27 where the variables r1, r2 are shared among all unary predicates. The corresponding aggregation function is maxT,y1,y2,x1,...,x` ,minr1,r2 . This diagram associates each of the `+ 3 objects with one of the unary predicates and in this way provides a reference to specific objects in the interpretation.\nThe symmetry gadget for q() is shown in Figure 28 where the variables m1,m2 are min variables. If an input interpretation has two objects A,B where q(A,B) has a truth value different than q(B,A) then minimum aggregation will map the interpretation to 0.\nThe truth value gadget for the simulation of PT is shown in Figure 29 and the truth value gadget for the simulation of Pxi is shown in Figure 30. These diagram fragments refer to variables in other portions and they will be connected and aggregated together."
    }, {
      "heading" : "1 T(T)",
      "text" : "Finally, we add a component that is not needed for verifying that I is legal but will be useful later when we include the clauses. In particular, we include a variable consistency block which is similar to the one in the simple construction (see Figure 23) but where we force each subgroup in wi to bind to the same object as y1 or y2. This is shown in Figure 31.\nWe chain the diagrams together as shown in Figure 32 to get B1 where we have moved the node labelled r1 = r2 to be above the block consistency gadget. Note that the diagram is sorted where for predicate order we have “ = ” ≺ T ≺ y1 ≺ y2 ≺ xi ≺ q and for variables we have zi, T, yi, xi ≺ rj ≺ wl, and yi ≺ v(i1,i2), and mi ≺ T ≺ xj . The complete aggregation function is\nmax T,y1,y2,x1,...,x` max w1,w2 min m1,m2 min r1,r2 min z1,...,z`+4 min w3\n. . . QAwk .\nWe next show that the claim C1 holds for the extended reduction.4 We first consider all possible cases for illegal interpretations.\n• If the interpretation has ≥ ` + 4 objects then the top portion of the diagram yields 0 for some valuation of z’s. Consider any valuation ζp to the prefix of variables T, y1, y2, x1, . . . , x`, w1,w2, m1,m2, r1, r2, and any ζ which is an extension of this valuation, has the violating combination for z1, . . . , z`+4 and any valuation for the other variables. We have MAPB1(I, ζ) = 0. Therefore, all aggregations from wk to w3 yield a value of 0 for this prefix. Now continuing backwards, the minimization over z yields a value of 0 for ζp, and this holds for any ζp. Therefore, all remaining aggregations yield 0 and the final value is 0.\n• Next, consider the case where the interpretation has ≤ ` + 3 objects but one of the unary predicates is always false (i.e., it does not “pick” any object). The situation is similar to the previous case, but here we get a value of 1 for ζ where r1 = r2 or where there is a block violation for some wi block with min aggregation.\nConsider any valuation ζp to the prefix of variables T, y1, y2, x1, . . . , x`, w1,w2, m1,m2, which is block consistent on w1,w2 and any ζ which is an extension of this valuation, has r1 6= r2, and any valuation for the other variables. We have two cases: if ζ is in group 1 the map is 0 because the unary predicate test fails, and if ζ is in group 2 the map is the default value of the first violated block wi. Now, because there is at least one group 1 valuation, we can argue inductively backwards from k that all aggregations from k to 3 yield 0, and the same holds for the minimization over z. Next, because the value is 0 for r1 6= r2, the minimization over r yields 0 for ζp. Considering any variants of ζp which are not block consistent on w1,w2 but otherwise identical we see that their value is also 0. As a result all remaining aggregations yield 0.\n• Next consider the case where the previous two conditions are satisfied but where one of the unary predicates holds for two or more objects. The argument is identical to the previous case, except that ζ has the violating pair for r1, r2 (instead of any r1 6= r2).\n• Next consider any interpretation that has exactly `+3 objects and where the unary predicates identify the objects corresponding to T, y1, y2, x1, . . . , x` but where q() is not symmetric. In\n4 Note that we can remove the variable consistency block which complicates the argument (and does not test anything per legality of I) and still maintain correctness of C1. But including it here simplifies the argument for diagram B below and thus simplifies the overall proof.\nthis case we consider a valuation ζp to the prefix of variables T, y1, y2, x1, . . . , x`, w1,w2, and extensions ζ that have the violating pair for m1,m2. As above, starting with ζ that are block consistent on w1,w2 and have r1 6= r2 we can argue that the aggregations down to m yield 0, and as a result that the aggregation over m yields 0. As ζp is arbitrary, it follows that the final value is 0.\n• The only remaining cases are interpretations that are illegal only because the q() simulation of PT () or Pxi() is not as required. In this case, the same argument as in the 2nd item in this list shows that the value is 0.\nTherefore, if I is illegal then MAPB1(I) = 0. Consider next any legal interpretation and the intended valuation ζp to T, y1, y2, x1, . . . , x`. For any group 1 extension of this valuation and any valuation of the variables m, z, r the diagram yields 1. Therefore, we can argue inductively that all wi aggregations down to w3 yield 1, and the min aggregations over m, z, r yield 1 for ζp. Therefore, the max aggregation over T, y1, y2, x1, . . . , x` yields 1, and MAPB1(I) = 1. This completes the proof of C1.\nThe diagram B is obtained by adding the clause blocks below the q() tests of B1. The clause blocks have the same structure as above but they use q() instead of PT () and Pxi(). This is shown in Figure 33. The final diagram for B is shown in Figure 34 and it has the same aggregation function as B1. Note that the diagram is also sorted using the same order as in B1 with the addition that xi ≺ V(i1,i2). We next show that: (C2’) MAPB(I) = 1 if and only if I is legal and Q2x2 . . . Qkxkf((x1 = α),x2, . . . , xk) = 1 where I embeds the substitution x1 = α.\nThe property C2’ is slightly different from C2 above, in that it argues directly over B and includes the condition on legal interpretations. Nonetheless, the same argument from the simple case can be used to show that C1 and C2’ imply that B1 and B are equivalent iff the QBF is satisfied.\nTo prove the claim first note that by the construction B adds more tests on the path to a 1 leaf of B1 and does not add any other paths to a value of 1. Therefore, for any I and any ζ, if MAPB(I, ζ) = 1 then MAPB1(I, ζ) = 1 and as a result if MAPB(I) = 1 then MAPB1(I) = 1. Therefore, by C1, if MAPB(I, ζ) = 1 then I is legal. Next, consider any legal I and any unintended valuation ζp for the prefix T, y1, y2, x1, . . . , x`. Any valuation extending this prefix with a block consistent assignment for all wi and with r1 6= r2 will yield a zero. Therefore, the minimization over r1, r2 will yield 0 for this prefix, and so will the minimization over m1,m2 and maximization over w1,w2. We conclude that the aggregated value for this prefix is 0. Therefore, if MAPB(I) = 1 and thus the max aggregation over these prefix variables yields 1, it must be through the intended valuation ζp for the prefix T, y1, y2, x1, . . . , x`.\nHowever, when T, y1, y2, x1, . . . , x` are fixed to their intended values, the portions of the diagram testing for ≤ q+3 objects, the uniqueness of special objects T, y1, y2, x1, . . . , xk, the symmetry of q() and its simulation of PT () and Pxi do not affect the final value in the sense that a valuation reaching them always continues to the next block. Therefore, if we restrict attention to such valuations we can shrink B by removing these blocks and still obtain the same aggregated value. Now we observe that there is a 1-1 correspondence between valuations and values of the resulting B to valuations and values of B2 in the simple construction (where we extend the notion of block consistent to enforce that wi bind to y1, y2). Therefore, the claim holds by C2 of the simple construction.\nThe result for GFODD Value is similar to the FODD case.\nTheorem 23 GFODD Value for diagrams with aggregation depth k (where k ≥ 2) is Σpk+1complete.\nProof. The proof of Theorem 16 goes through almost directly and requires only a slight wording variation. For membership we get the bound on interpretation size by the assumption on the input; then the algorithm is the same.\nFor the reduction, we use Theorem 1 to calculate B = apply(B1, B2,+). As stated in that theorem, we can mesh together the aggregation lists of B1 and B2 interleaving the max and min\nblocks from each diagram without increasing quantifier depth and the diagram B has the same quantifier prefix and depth as those of B1 and B2.\nUnlike max-k-alternating GFODDs, for min diagrams the search for a satisfying interpretation cannot be absorbed into the first aggregation operator. This fact pushes the problem one level higher in the hierarchy.\nTheorem 24 GFODD Satisfiability for min-k-alternating GFODDs (where k ≥ 2) is Σpk+1-complete.\nProof Sketch. For membership, we guess an interpretation I of the appropriate size, and then appeal to a Σpk oracle to solve GFODD evaluation for (B, I). This is clearly in NP\nΣpk . The hardness result uses a slight modification of the equivalence proof, which we sketch next. One can verify that all the details of the modification go through to establish the result. In particular, we reduce QBF satisfiability with k ≥ 3 alternations of quantifiers to satisfiability of min-(k− 1)-alternating GFODDs. Here we assume a QBF whose first quantifier is ∃, that is has the form ∃1x1 . . . Qkxkf(x1,x2, . . . ,xk) where xi refers to a set of variables. We build B1, B2 and B exactly as in Theorem 22 with one exception: the leaf values on the diagram that checks for block consistency are flipped from the previous construction (because the corresponding aggregation operators are switched). The reduction still provides B1, B2, and B = apply(B1, B2,∧) such that the following claims hold: (C1) for all I, MAPB1(I) = 1 if and only if I is legal. (C2) if I is legal and it embeds the substitution x1 = α then MAPB2(I) = 1 if and only if Q2x2 . . . Qkxkf((x1 = α),x2, . . . ,xk) = 1.\nWe then output the diagram B for GFODD satisfiability. Now, if the QBF is satisfied then there exists a value α such that for x1 = α we have that Q2x2 . . . Qkxkf((x1 = α),x2, . . . ,xk) = 1. Therefore, by C2, for the legal I that embeds α, MAPB2(I) = 1, and by Theorem 1 we have that MAPB(I) = 1. On the other hand, if the QBF is not satisfied then for all substitutions x1 = α we have Q2x2 . . . Qkxkf((x1 = α),x2, . . . ,xk) = 0. Therefore, by C2, all legal I (and any α they embed) MAPB2(I) = 0 and by Theorem 1 we also have MAPB(I) = 0. By C1, MAPB(I) = 0 for non-legal interpretations. Therefore, B is not satisfiable.\nThe construction to handle ordering and edge removal structure can be similarly modified for the current proof.\nUp to this point, all hardness proof in the paper use a signature without any constants, i.e., we use equality and unary and binary predicates. For min-GFODDs (the case k = 1) the use of constants affects the complexity of the satisfiability problem. In particular, for a signature without constants, if a min-GFODD is satisfied by interpretation I, then it is satisfied by the subinterpretation of I with just one object (any object in I will do). Moreover, given diagram B and a specific I with one object, model evaluation is in P because there is only one valuation to consider. Therefore, in this case satisfiability is in NP: we can guess the interpretation (i.e. truth values of predicates) and evaluate MAPB(I) in polynomial time. On the other hand, if we allow constants in the signature the problem follows the same scheme as above and is Σp2-complete.\nTheorem 25 GFODD Satisfiability for min-GFODDs is Σp2-complete.\nProof Sketch. Membership is as in the general case. For hardness, we use the construction in the reduction of the previous proof which yields a GFODD with aggregation min∗max∗ (i.e., the\nportion starting with w3 does not exist) where the max variables are T, y1, y2, x1, . . . , x`. We then turn these variables into constants and remove the max aggregation to yield a min GFODD. One can verify that the proof of Theorem 24 goes through with very minor changes."
    }, {
      "heading" : "5 Discussion",
      "text" : "In this paper we explored the complexity of computations using FODD and GFODD using min and max aggregation, providing a classification placing them within the polynomial hierarchy, where, roughly speaking, equivalence is one level higher in the hierarchy than evaluation and satisfiability. These results are useful in that they clearly characterize the complexity of the problems solved heuristically by implementations of GFODD systems [15, 17, 18] and can be used to partly motivate or justify the use of these heuristics. For example, the “model checking reductions” of [15] replace equivalence tests with model evaluation on a “representative” set of models, and choosing this set heuristically leads to inference that is correct with respect to these models but otherwise incomplete. Our results here show that this indeed leads to reduction of the complexity of the inference problem so that the reduction in accuracy is traded for improved worst case run time. As mentioned above, the proofs in the paper can be used (in simpler form) to show the same complexity results for the corresponding problems in first order logic. To our knowledge the complexity questions with an explicit bound on model size have not been previously studied in this context. Yet they can be useful in many contexts where such a bound can be given in a practical setting. For example, in such cases existing optimized QBF algorithms can be used for inference in this restricted form of first order logic.\nThere are several important directions for further investigation. The first involves using a richer set of aggregation operators. In particular the definition of GFODDs allows for any function to aggregate values, and functions such as sum, product, and average are both natural and useful for modeling and solving Markov Decision Processes, which have been the main application for FODDs. The work of [18] extends the model checking reductions to GFODDs with average aggregation. Clarifying the complexity of these problems and identifying the best algorithms for them is an important effort for the efficiency of such systems. In this context it is also interesting to clarify the relationship to query languages in databases that allow for similar aggregations and to formulations of “logic with counting” that has been developed in the context of database theory [24].\nConsidering this wider family of GFODDs also raises new computational questions beyond the ones explored in this paper. One such question arises from the connection to statistical relational models and specifically to lifted inference in such models (see e.g. [28, 27, 5]). In particular, consider Markov Logic Networks (MLN) [28] that can be seen to define a distribution over first order structures through a log linear probability model, where features of this model are defined by simple first order formula templates. It is easy to show how to encode such templates and their weights using a GFODD with product aggregation, and how these can be combined using a variant of the Apply procedure. The main computational question in this context has been to calculate the probability of a query given the MLN model, and the number of objects n in the domain. Let I be the set of models with n objects over the relevant signature. In our case this question translates to calculating ∑\nI∈I MAPB(I)\nfor an appropriate B that combines the query and the MLN model. This is closely related to the\napproaches that solve this problem via lifted weighted model counting [5]. A similarly interesting question would require us to calculate the best I for a particular B\nargmaxI∈I MAPB(I).\nIn this case, if B captures say profit of some organization, then the computation optimizes the setting so as to maximize profit. Thirdly, we have defined a logic-inspired language but did not define or study any notion of implication. A natural notion of implication with numerical values, related to the one used by [7], is majorization:\nB1 |= B2 ⇔ ∀I∈I MAPB1(I) ≤ MAPB2(I).\nEfficient algorithms and complexity analysis for these new questions will expand the scope and applicability of GFODDs.\nFinally, efficient algorithms for model evaluation play an important role in GFODD implementations. The work of [18] provides a generic algorithm inspired by the variable elimination algorithm from probabilistic inference. Several application areas, including databases, AI, and probabilistic inference have shown that more efficient algorithms are possible when the input formula or graph have certain structural properties such as low graph width. We therefore conjecture that similar notions can be developed to provide more efficient evaluation for GFODDs with some structural properties. Coupled with model checking reductions, this can lead to realizations of GFODD systems that combine high expressive power going beyond first order logic with efficient algorithms."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work is partly supported by NSF grant IIS 0964457. Some of this work was done when Roni Khardon was on sabbatical leave at Trinity College Dublin."
    }, {
      "heading" : "A Detailed Proofs",
      "text" : "A.1 Proof of Theorem 24\nProof. We reduce QBF satisfiability with k ≥ 3 alternations of quantifiers to satisfiability of min(k − 1)-alternating GFODDs. The reduction borrows most of the construction from the proof of Theorem 22, swapping between min and max aggregation to adjust it to the new context.\nIn particular, here we assume a QBF whose first quantifier is ∃, that is, ∃x1, Q2x2 . . . Qmxm f(x1, x2, . . . , xm) where this form has k blocks of quantifiers. To simplify the notation it is convenient to group adjacent variables having the same quantifiers into groups so that the QBF has the form Q1x1 . . . Qkxkf(x1,x2, . . . ,xk) where xi refers to a set of variables.\nWe next define a notion of “legal interpretations” for our diagrams. A legal interpretation embeds the binary interpretation I∗ from previous proofs and in addition includes a truth setting for all the variables in the first ∃ block of the QBF. The reduction constructs diagrams B1, B2, and B = apply(B1, B2,∧) such that the following claims hold: (C1) for all I, MAPB1(I) = 1 if and only if I is legal. (C2) if I is legal and it embeds the substitution x1 = α then MAPB2(I) = 1 if and only if Q2x2 . . . Qkxkf((x1 = α),x2, . . . ,xk) = 1.\nWe then output the diagram B for GFODD satisfiability. Now, if the QBF is satisfied then there exists a value α such that for x1 = α we have that Q2x2 . . . Qkxkf((x1 = α),x2, . . . ,xk) = 1. Therefore, by C2, for the legal I that embeds α, MAPB2(I) = 1.\nOn the other hand, if the QBF is not satisfied then for all substitutions x1 = α we have Q2x2 . . . Qkxkf((x1 = α),x2, . . . ,xk) = 0. Therefore, by C2, all legal I (and any α they embed) MAPB2(I) = 0 and by Theorem 1 we also have MAPB(I) = 0. By C1, MAPB(I) = 0 for non-legal interpretations. Therefore, B is not satisfiable.\nWe now proceed with the reduction, starting first with a simplified construction ignoring ordering, and then elaborating to enforce these constraints. The set of predicates includes PT () and for every QBF variable xi in the first ∃ block we use a predicates Pxi(). Notice that each xi is a member of x1 (the first ∃ group) where the typeface distinguishes the individual variables in the first block, from blocks of variables. In the simplified construction, a legal interpretation has exactly two objects, say a and b, where PT (a) 6= PT (b) and where for each Pxi() we have Pxi(a) = Pxi(b). That is, the assignment of an object to v in PT (v) simulates an assignment to Boolean values, but the truth value of Pxi(v) is the same regardless of which object is assigned to v.\nConsider our example QBF modified to start with ∃ quantifier ∃x1∀x2∃x3∀x4(x1 ∨ x̄2 ∨ x4) ∧ (x̄1 ∨ x2 ∨ x3) ∧ (x1 ∨ x3 ∨ x̄4). The first block includes only the variable x1 and the following interpretation is legal: I = {[a, b], PT (a) =true, PT (b) =false, Px1(a) = Px1(b) =false}.\nThe diagram B1 has three portions where the first two are exactly as in the previous proof, thus verifying that I has two objects and that PT () behaves as stated. The third portion verifies that each Pxi() behaves as stated, where we use a sequence of blocks, one for each Pxi(). The combined diagram B1 is shown in Figure 22 and the aggregation function is minz1,z2,z3 ,maxy1,y2 .\nTo see that C1 holds consider all possible cases for non-legal interpretations. If I has at most one object the map is 0 for all valuations and thus the aggregation is 0. If I has at least 3 objects, then the min aggregation over z yields 0. If I has 2 objects but it violates the condition on PT or Pxi then again the map is 0 for any valuation and the aggregation is 0. On the other hand, if I is legal, then for any assignment to z, the correct mapping to y1, y2 yields 1. Therefore the aggregation over z yields 1.\nThe diagram B2 is constructed by modifying B2 from the proof of Theorem 20. The first modification is to handle the first ∃ block differently. As it turns out, all we need to do is replace the max aggregation for the w1 block with min aggregation and accordingly replace the default value on that block to 1. The modified variable consistency diagram is shown in [we flip leaf values in diagram] Figure 23. The clause blocks have the same structure as in the previous construction but use Pxi(V(i1,i2)) when xi is a ∃ variable from the first block and use PT (V(i1,i2)) otherwise. This is shown in Figure 24. B2 includes the variable consistency blocks followed by the clause blocks. Note that the new clause blocks are not sorted in any consistent order because the predicates Pxi() and PT () appear in an arbitrary ordering determined by the appearance of literals in the QBF. Other than this violation, all other portions of the diagrams described are sorted where the predicate order has =≺ PT ≺ Pxi and where variables wi are before V(i1,i2) and variables within group are sorted lexicographically. The combined aggregation function is minw1 ,minw2 ,maxw3 , . . . , Q A wk\n. We next show that claim C2 holds, which will complete the proof of the simplified construction. Consider any legal I, let the corresponding truth values for variables in x1 be denoted α, and consider valuations for the QBF extending x1 = α. Now consider any valuation v to the remaining variables in the QBF and the induced substitution to the GFODD variables ζ(v) that is easily identified from the construction. Add any consistent group assignment to w1 (that is, we assign a or b to all variables in that group) to ζ(v) to get ζ̂(v). By the construction of B2 we have that f([x1 = α, (x2, . . . ,xk) = v]) = MAPB2(I, ζ̂(v)). To see this note that there are no quantifiers in this expression, there is a 1-1 correspondence between the valuations of x2, . . . ,xk and w2, . . . ,wk, and that as long as the assignment to the w1 block is group consistent it does not affect the value returned. We call this set of valuations, that arise as translations of substitutions for QBF variables, Group 1.\nThe second group, Group 2, includes valuations that do not arise as ζ̂(v) and therefore they violate at least one of the consistency blocks. Let ζ be such a valuation and let QAj be the first block from the left whose constraint is violated. By the construction of B2, in particular the order of equality along paths in the GFODD, we have that the evaluation of the diagram on ζ “exits” to a default value on the first violation. Therefore, if j = 1, that is the violation is in the block of w1 MAPB(I, ζ) = 1 and for j ≥ 2 if Qj is a ∀ then MAPB(I, ζ) = 1 and if Qj is a ∃ then MAPB(I, ζ) = 0.\nWe can now show the correspondence in truth values. Consider any partition of the blocks 2, . . . , k into a prefix 2, . . . , j and remainder (j+ 1), . . . , k, and any valuation v to the prefix blocks. We claim that for all such partitions\nQj+1xj+1, . . . , Qkxk, f(x1 = α, (x2, . . . ,xj) = v,xj+1, . . . ,xk)\n= Qj+1wj+1, . . . , Qkwk,MAPB2(I, [w1 = a, (w2, . . . ,wj) = ζ(v), (wj+1, . . . ,wk)]).\nNote that when j = 1, that is, the prefix is empty, this yields that Q2x2, . . . , Qkxk, f(x1 = α,x2, . . . ,xk) is equal to Q A 2 w2, . . . , Q A k wk,MAPB2(I, [w1 = a,w2, . . . ,wk)]). Now because the default value for violations of w1 is 1 and because the aggregation for w1 is min the latter expression is equal to QA1 w1, . . . , Q A k wk,MAPB2(I, [w1,w2, . . . ,wk)]). This means that MAPB2(I) is equal to Q2x2, . . . , Qkxk, f(x1 = α,x2, . . . ,xk) completing the proof of C2. As above, we prove the claim by induction, backwards from k to 1. For the base case, j = k− 1 and the second part includes only one block. Consider any concrete substitution for wk participating in the equation. If the substitution is in group 2, then the map is 1 if Qj is ∀ and is 0 otherwise. Therefore, the value of QAk wk,MAPB2(I, [w1 = a, (w2, . . . ,wk−1) = ζ(v), (wk)]) is the same as that\nvalue when restricted to substitutions in group 1. But, as argued above, for group 1 this is exactly the same value returned by the QBF.\nFor the inductive step, the valuation v covers the first j − 1 blocks. Note that, by the inductive assumption, for any group 1 substitution vj for xj and corresponding, ζ(vj) for wj , Qj+1xj+1, . . . , Qkxk, f(x1 = α, (x2, . . . ,xj−1) = v, (xj = vj),xj+1, . . . ,xk) = Q A j+1wj+1, . . . , Q A k wk, MAPB2(I, [w1 = a, (w2, . . . , wj−1) = ζ(v), (wj = ζ(vj)), (wj+1, . . . ,wk)]). On the other hand, for any group 2 substitution ζj for wj and any values for (wj+1, . . . ,wk)) we have that the violating block for the corresponding combined ζ is block j and therefore MAPB2(I, [w1 = a, (w2, . . . ,wj−1) = ζ(v), (wj = ζj), (wj+1, . . . ,wk)]) gets the default value for that block. Therefore, as in the base case, the map is determined by group 1 valuations, which are in turn identical to the QBF value and Qjxj , . . . , Qkxk, f(x1 = α, (x2, . . . ,xj−1) = v, (xj , . . . ,xk)) = Q A j wj , . . . , Q A k wk,MAPB2(I, [w1 = a, (w2, . . . ,wj−1) = ζ(v), (wj , . . . ,wk)]) as required. Therefore, the claim on the correspondence of values holds, and as argued above this completes the proof of C2.\nExtending the reduction to handle ordering: The main idea in the extended construction is to replace the unary predicates PT and Pxi with one binary predicate q(·, ·) where the “second argument” in q() serves to identify the corresponding predicate and hence its truth value. In addition we force q() to be symmetric so that for any A and B the truth value of q(A,B) is the same as the truth value of q(B,A). In this way we have freedom to use either q(A,B) or q(B,A) as the node label which provides sufficient flexibility to handle the ordering issues. To implement this idea we need a few additional constructions.\nLet the set of variables in the first ∃ block of the QBF be x1, x2, . . . , x`. The set of predicates in the extended reduction includes unary predicates T (), y1(), y2(), x1(), x2(), . . . , x`(), and one binary predicate q(·, ·). A legal interpretation includes exactly `+ 3 objects which are uniquely identified by the unary predicates. We therefore slightly abuse notation and use the same symbols for the objects and predicates. In particular, the atoms y1(y1), y2(y2), T (T ), and x1(x1), x2(x2), . . . , x`(x`) are true in the interpretation and only these atoms are true for these unary predicates (e.g., x1(T ) is false). The truth values of q() reflect the simulation of PT () and Pxi() in addition to being symmetric. Thus the truth values of q(y1, T ) and q(T, y1) are the same and they are the negation of the truth values of q(y2, T ) and q(T, y2). For all i, the truth values of q(y1, xi), q(xi, y1), q(y2, xi) and q(xi, y2) are the same. The truth values of other instances of q(), for example, q(x2, T ), can be set arbitrarily. For example, the following interpretation is legal when ` = 1: I = {[a, b, c, d], y1(a), y2(b), T (c), x1(d), q(c, a) = q(a, c) =true, q(c, b) = q(b, c) =false, q(d, a) = q(a, d) = q(d, b) = q(b, d) =false, q(·, ·) =false} where q(·, ·) refers to any instance not explicitly mentioned in the list.\nWe next define the diagram B1 that is satisfied only in legal interpretations. We enforce exactly `+ 3 objects using two complementary parts. The first includes\n( `+4\n2\n) inequalities on a new set of\n` + 4 variables z1, . . . , z`+4 with min aggregation. If we identify ` + 4 distinct objects we set the value to 0. This is shown in Figure 25.\nTo enforce at least `+ 3 objects and identify them we use the following gadget. For each of the unary predicates we have a diagram identifying its object and testing its uniqueness where we use both max and min variables. This is shown for the predicate T () in Figure 26. The node T (T ) with max variable T identifies the object T . The nodes T (r1), T (r2) with min variables r1, r2 make sure that T holds for at most one object. We chain the diagrams together as shown in Figure 27 where the variables r1, r2 are shared among all unary predicates. The corresponding aggregation\nfunction is minr1,r2 ,maxT,y1,y2,x1,...,x` . This diagram associates each of the `+ 3 objects with one of the unary predicates and in this way provides a reference to specific objects in the interpretation.\nThe symmetry gadget for q() is shown in Figure 28 where the variables m1,m2 are min variables. If an input interpretation has two objects A,B where q(A,B) has a truth value different than q(B,A) then minimum aggregation will map the interpretation to 0.\nThe truth value gadget for the simulation of PT is shown in Figure 29 and the truth value gadget for the simulation of Pxi is shown in Figure 30. These diagram fragments refer to variables in other portions and they will be connected and aggregated together.\nFinally, we add a component that is not needed for verifying that I is legal but will be useful later when we include the clauses. In particular, we include a variable consistency block which is similar to the one in the simple construction but where we force wi to bind to the same object as y1 or y2. This is shown in [we flip leaf values in diagram] Figure 31.\nWe chain the diagrams together as shown in Figure 32 to get B1 where we have moved the node labelled r1 = r2 to be above the block consistency gadget. [here too leaf values in consistency block need to be flipped] Note that the diagram is sorted where for predicate order we have =≺ T ≺ y1 ≺ y2 ≺ xi ≺ q and for variables we have zi, T, yi, xi ≺ rj ≺ wl, and yi ≺ V(i1,i2), and mi ≺ T ≺ xj . The complete aggregation function is\nmin m1,m2 min r1,r2 min z1,...,z`+4 min w1,w2 max T,y1,y2,x1,...,x` max w3\n. . . QAwk\nWe next show that the claim C1 holds for the extended reduction.5 We first consider all possible cases for illegal interpretations.\n• If the interpretation has ≥ `+ 4 objects then the top portion of the diagram yields 0 for some valuation of z’s regardless of the values of other variables. Therefore aggregation over z yields 0, and then aggregations over r and m yield 0.\n• Next, consider the case where the interpretation has ≤ ` + 3 objects but one of the unary predicates is always false (i.e., it does not “pick” any object). The situation is similar to the previous case, but here we get a value of 1 for ζ where r1 = r2 or where there is a block violation for some wi block with min aggregation.\nConsider any valuation ζp to the prefix of variables up to x` in aggregation order which is block consistent on w1,w2, has r1 6= r2, and any valuation for the other variables. We have two cases: if ζ is in group 1 the map is 0 because the unary predicate test fails, and if ζ is in group 2 the map is the default value of the first violated block wi. Now, because there is at least one group 1 valuation, we can argue inductively backwards from k that all aggregations from k to 3 yield 0. Therefore, the maximization over T, y1, y2, x1, . . . , x` yields 0, and the minimization over z,w1,w2 yields 0. In the minimization over r, we have 0 for the cases where r1 6= r2, and 1 otherwise. Therefore the minimization over r yields 0 as well, and the minimization over m yields 0.\n• Next consider the case where the previous two conditions are satisfied but where one of the unary predicates holds for two or more objects. The argument is identical to the previous case, except that ζ has the violating pair for r1, r2 (instead of any r1 6= r2).\n5 Note that we can remove the variable consistency block which complicates the argument (and does not test anything per legality of I) and still maintain correctness of C1. But including it here simplifies the argument for diagram B below and thus simplifies the overall proof.\n• Next consider any interpretation that has exactly `+3 objects and where the unary predicates identify the objects corresponding to T, y1, y2, x1, . . . , x` but where q() is not symmetric. In this case we consider (as in the second item on this list) any valuation ζp to the prefix of variables up to x` in aggregation order which is block consistent on w1,w2, has r1 6= r2, has the violating pair for m1,m2 and any valuation for the other variables. As above, we can argue that the aggregations down to w3 and then down to r yield 0 when r1 6= r2 and m1,m2 has the violating pair. As a result, for this setting of m, minimization over r yields 0, and therefore the minimization over m also yields 0.\n• The only remaining cases are interpretations that are illegal only because the q() simulation of PT () or Pxi() is not as required. In this case, the same argument as in the 2nd item in this list shows that the value is 0.\nTherefore, if I is illegal then MAPB1(I) = 0. Consider next any legal interpretation and the intended valuation ζp to T, y1, y2, x1, . . . , x`. For any group 1 extension of this valuation and any valuation of the variables m, z, r the diagram yields 1. Therefore, we can argue inductively that all wi aggregations down to w3 yield 1. This implies that the maximization over T, y1, y2, x1, . . . , x` yields 1, and the remaining minimizations yield 1. This completes the proof of C1.\nThe diagram B is obtained by adding the clause blocks below the q() tests of B1. The clause blocks have the same structure as above but they use q() instead of PT () and Pxi(). This is shown in Figure 33. The final diagram for B is shown in Figure 34 [as above the only difference is that we flip the leaf values in the consistency block] and it has the same aggregation function as B1. Note that the diagram is also sorted using the same order as in B1 where we have in addition that xi ≺ V(i1,i2). We next show that: (C2’) MAPB(I) = 1 if and only if I is legal and Q2x2 . . . Qkxkf((x1 = α),x2, . . . ,xk) = 1 where I embeds the substitution x1 = α.\nThe same argument from the simple case can be used to show that C1,C2’ imply that B1 and B are equivalent iff the QBF is satisfied.\nTo prove the claim first note that by the construction B adds more tests on the path to a 1 leaf of B1 and does not add any other paths to a value of 1. Therefore, for any I and any ζ, if MAPB(I, ζ) = 1 then MAPB1(I, ζ) = 1 and as a result if MAPB(I) = 1 then MAPB1(I) = 1. Therefore, by C1, if MAPB(I) = 1 then I is legal. Next, consider any legal I and any unintended valuation ζp for the block of variables T, y1, y2, x1, . . . , x`. As above, the aggregated value down to w3 for this prefix is 0. Therefore, if MAPB(I) = 1 and thus the max aggregation over these variables yields 1 (for the prefix valuation for M,R,Z,w1,w2), it must be through the intended valuation for T, y1, y2, x1, . . . , x`. However, when T, y1, y2, x1, . . . , x` are fixed to their intended values, the portions of the diagram testing for ≤ q + 3 objects, the uniqueness of special objects T, y1, y2, x1, . . . , xk, the symmetry of q() and its simulation of PT () and Pxi do not affect the final value in the sense that a valuation reaching them always continues to the next block. Therefore, if we restrict attention to such valuations we can shrink B by removing these blocks and still obtain the same aggregated value. Now we observe that there is a 1-1 correspondence between valuations and values of the resulting B to valuations and values of B2 in the simple construction (where we extend the notion of block consistent to enforce that wi bind to y1, y2). Therefore, the claim holds by C2 of the simple construction.\nA.2 Proof of Theorem 25\nProof. We reduce QBF satisfiability with 2 alternations of quantifiers to satisfiability of min GFODDs. The construction follows the same steps as in Theorem 24 except that k = 2 and we swap the max variables with constants.\nIn particular, here we assume a QBF whose first quantifier is ∃, that is, ∃x1, Q2x2 . . . Qmxm f(x1, x2, . . . , xm) where this form has 2 blocks of quantifiers. To simplify the notation it is convenient to group adjacent variables having the same quantifiers into groups so that the QBF has the form ∃x1∀x2f(x1,x2) where xi refers to a set of variables.\nWe next define a notion of “legal interpretations” for our diagrams. A legal interpretation embeds the binary interpretation I∗ from previous proofs and in addition includes a truth setting for all the variables in the first ∃ block of the QBF. The reduction constructs diagrams B1, B2, and B = apply(B1, B2,∧) such that the following claims hold: (C1) for all I, MAPB1(I) = 1 if and only if I is legal. (C2) if I is legal and it embeds the substitution x1 = α then MAPB2(I) = 1 if and only if ∀x2f((x1 = α),x2) = 1.\nWe then output the diagram B for GFODD satisfiability. Now, if the QBF is satisfied then there exists a value α such that for x1 = α we have that ∀x2f((x1 = α),x2) = 1. Therefore, by C2, for the legal I that embeds α, MAPB2(I) = 1.\nOn the other hand, if the QBF is not satisfied then for all substitutions x1 = α we have ∀x2f((x1 = α),x2) = 0. Therefore, by C2, all legal I (and any α they embed) MAPB2(I) = 0 and by Theorem 1 we also have MAPB(I) = 0. By C1, MAPB(I) = 0 for non-legal interpretations. Therefore, B is not satisfiable.\nWe now proceed with the reduction, starting first with a simplified construction ignoring ordering of node labels, and then elaborating to enforce these constraints. The set of predicates includes PT () which is as before and for every QBF variable xi in the first ∃ block we use a predicates Pxi(). Notice that each xi is a member of x1 (the first ∃ group) where the typeface distinguishes the individual variables in the first block, from blocks of variables. In the simplified construction, a legal interpretation has exactly two objects, say a and b, where PT (a) 6= PT (b) and where for each Pxi() we have Pxi(a) = Pxi(b). That is, the assignment of an object to v in PT (v) simulates an assignment to Boolean values, but the truth value of Pxi(v) is the same regardless of which object is assigned to v. In addition we extend the signature to include y1, y2 as constants and a legal interpretation maps y1, y2 to a, b in a 1-1 manner.\nConsider our example QBF modified to start with ∃ quantifier and to have two alternations ∃x1∀x2∀x3∀x4(x1∨ x̄2∨x4)∧(x̄1∨x2∨x3)∧(x1∨x3∨ x̄4). The first block includes only the variable x1 and the following interpretation is legal: I = {[a, b], [y1/a, y2/b], PT (a) =true, PT (b) =false, Px1(a) = Px1(b) =false}.\nThe diagram B1 has three portions where the first two are exactly as in the previous proof, thus verifying that I has two objects and that PT () behaves as stated. The third portion verifies that each Pxi() behaves as stated, where we use a sequence of blocks, one for each Pxi(). The combined diagram B1 is shown in Figure 22 and the aggregation function is minz1,z2,z3 .\nTo see that C1 holds consider all possible cases for non-legal interpretations. If I has at most one object the map is 0 for all valuations and thus the aggregation is 0. The same holds if y1, y2 are mapped to the same object. If I has at least 3 objects, then the min aggregation over z yields 0. If I has 2 objects but it violates the condition on PT or Pxi then again the map is 0 for any valuation and the aggregation is 0. On the other hand, if I is legal, then for any assignment to z,\nthe diagram yields 1. Therefore the aggregation over z yields 1. The diagram B2 is constructed by modifying B2 from the proof of Theorem 20. The first modification is to handle the first ∃ block differently. As it turns out, all we need to do is replace the max aggregation for the w1 block with min aggregation and accordingly replace the default value on that block to 1. The modified variable consistency diagram is shown in [we modify leaf values again because of the change of quantifiers in the current example; in this construction all exit values are 1] Figure 23. The clause blocks have the same structure as in the previous construction but use Pxi(V(i1,i2)) when xi is a ∃ variable from the first block and use PT (V(i1,i2)) otherwise. This is shown in Figure 24. B2 includes the variable consistency blocks followed by the clause blocks. Note that the new clause blocks are not sorted in any consistent order because the predicates Pxi() and PT () appear in an arbitrary ordering determined by the appearance of literals in the QBF. Other than this violation, all other portions of the diagrams described are sorted where the predicate order has =≺ PT ≺ Pxi and where variables wi are before V(i1,i2) and variables within group are sorted lexicographically. The combined aggregation function is minw1 ,minw2 .\nWe next show that claim C2 holds, which will complete the proof of the simplified construction. Consider any legal I, let the corresponding truth values for variables in x1 be denoted α, and consider valuations for the QBF extending x1 = α. Now consider any valuation v to the remaining variables in the QBF and the induced substitution to the GFODD variables ζ(v) that is easily identified from the construction. Add any consistent group assignment to w1 (that is, we assign a or b to all variables in that group) to ζ(v) to get ζ̂(v). By the construction of B2 we have that f([x1 = α, (x2) = v]) = MAPB2(I, ζ̂(v)). To see this note that there are no quantifiers in this expression, there is a 1-1 correspondence between the valuations of x2 and w2, and that as long as the assignment to the w1 block is group consistent it does not affect the value returned. We call this set of valuations, that arise as translations of substitutions for QBF variables, Group 1.\nThe second group, Group 2, includes valuations that do not arise as ζ̂(v) and therefore they violate at least one of the consistency blocks. Let ζ be such a valuation and let QAj be the first block from the left whose constraint is violated. By the construction of B2, in particular the order of equality along paths in the GFODD, we have that the evaluation of the diagram on ζ “exits” to a default value on the first violation. In the current construction there are only two blocks and the default value for both blocks is 1. Now, since all aggregation operators are min operators, the final aggregated value in both blocks is determined by group 1 valuations. This implies that ∀x2, f(x1 = α,x2) = min w2,MAPB2(I, [w1 = a,w2]) as required.\nExtending the reduction to handle ordering: The main idea in the extended construction is to replace the unary predicates PT and Pxi with one binary predicate q(·, ·) where the “second argument” in q() serves to identify the corresponding predicate and hence its truth value. In addition we force q() to be symmetric so that for any A and B the truth value of q(A,B) is the same as the truth value of q(B,A). In this way we have freedom to use either q(A,B) or q(B,A) as the node label which provides sufficient flexibility to handle the ordering issues. To implement this idea we need a few additional constructions.\nLet the set of variables in the first ∃ block of the QBF be x1, x2, . . . , x`. The set of predicates in the extended reduction includes unary predicates T (), y1(), y2(), x1(), x2(), . . . , x`(), and one binary predicate q(·, ·). A legal interpretation includes exactly `+3 objects which are uniquely identified by the unary predicates. In addition, the same objects are identified by `+3 constants in the signature. We therefore slightly abuse notation and use the same symbols for 3 different entities: the objects,\nthe constants identifying them, and the predicates identifying them. In particular, the atoms y1(y1), y2(y2), T (T ), and x1(x1), x2(x2), . . . , x`(x`) are true in the interpretation and only these atoms are true for these unary predicates (e.g., x1(T ) is false). The truth values of q() reflect the simulation of PT () and Pxi() in addition to being symmetric. Thus the truth values of q(y1, T ) and q(T, y1) are the same and they are the negation of the truth values of q(y2, T ) and q(T, y2). For all i, the truth values of q(y1, xi), q(xi, y1), q(y2, xi) and q(xi, y2) are the same. The truth values of other instances of q(), for example, q(x2, T ), can be set arbitrarily. For example, the following interpretation is legal when ` = 1: I = {[a, b, c, d], [y1/a, y2/b, T/c, x1/d], y1(a), y2(b), T (c), x1(d), q(c, a) = q(a, c) =true, q(c, b) = q(b, c) =false, q(d, a) = q(a, d) = q(d, b) = q(b, d) =false, q(·, ·) =false} where q(·, ·) refers to any instance not explicitly mentioned in the list.\nWe next define the diagram B1 that is satisfied only in legal interpretations. We enforce exactly `+ 3 objects using two complementary parts. The first includes\n( `+4\n2\n) inequalities on a new set of\n` + 4 variables z1, . . . , z`+4 with min aggregation. If we identify ` + 4 distinct objects we set the value to 0. This is shown in Figure 25.\nTo enforce at least ` + 3 objects and identify them we use the following gadget. For each of the unary predicates we have a diagram identifying its object and testing its uniqueness using min variables. This is shown for the predicate T () in Figure 26. The node T (T ) with max variable T identifies the object T . The nodes T (r1), T (r2) with min variables r1, r2 make sure that T holds for at most one object. We chain the diagrams together as shown in Figure 27 where the variables r1, r2 are shared among all unary predicates. The corresponding aggregation function is minr1,r2 . This diagram associates each of the `+ 3 objects with one of the unary predicates and in this way provides a reference to specific objects in the interpretation. [Note that we could use the constants and some inequalities for the same purpose but here simply adapt the previous construction for consistency of presentation].\nThe symmetry gadget for q() is shown in Figure 28 where the variables m1,m2 are min variables. If an input interpretation has two objects A,B where q(A,B) has a truth value different than q(B,A) then minimum aggregation will map the interpretation to 0.\nThe truth value gadget for the simulation of PT is shown in Figure 29 and the truth value gadget for the simulation of Pxi is shown in Figure 30.\nFinally, we add a component that is not needed for verifying that I is legal but will be useful later when we include the clauses. In particular, we include a variable consistency block which is similar to the one in the simple construction but where we force wi to bind to the same object as y1 or y2. This is shown in [all leaf values change to 1 in this example] Figure 31.\nWe chain the diagrams together as shown in Figure 32 to get B1 where we have moved the node labelled r1 = r2 to be above the block consistency gadget [here too leaf values need to be adjusted in the consistency block; we also need a slight reordering of nodes so that the symmetry block testing m1,m2 is below the block testing simulation of Pxi ]. Note that the diagram is sorted where for predicate order we have =≺ T ≺ y1 ≺ y2 ≺ xi ≺ q and for variables we have zi, T, yi, xi ≺ rj ≺ wl, and yi ≺ V(i1,i2), and [was mi ≺ T ≺ xj now change to] T ≺ mi ≺ xj . The complete aggregation function is\nmin m1,m2 min r1,r2 min z1,...,z`+4 min w1,w2\nWe next show that the claim C1 holds for the extended reduction.6\n6 Note that we can remove the variable consistency block which complicates the argument (and does not test anything per legality of I) and still maintain correctness of C1. But including it here simplifies the argument for diagram B below and thus simplifies the overall proof.\nWe first consider all possible cases for illegal interpretations. Since B1 is a min diagram it is clear that if a zero leaf is reached along any path then the aggregated value is 0. If the interpretation has ≥ ` + 4 objects then the top portion of the diagram yields 0 for some valuation of z’s. The same is true if any of the unary predicates does not identify any variable, or is true for more than one variable, or if q() is not symmetric, or q()’s simulation of PT () and Pxi are not as intended, or if the contestant mapping is not as expected (this leads to 0 via the unary predicates). Therefore, if I is illegal then MAPB1(I) = 0.\nConsider next any legal interpretation. For any group 1 valuation of w1,w2 and any valuation of the variables m, z, r the diagram yields 1. Since group 2 valuations always yield 1 in this construction the final value is 1. This completes the proof of C1.\nThe diagram B is obtained by adding the clause blocks below the q() tests of B1. The clause blocks have the same structure as above but they use q() instead of PT () and Pxi(). This is shown in Figure 33. The final diagram for B is shown in Figure 34 [here too leaf values need to be adjusted in the consistency block] and it has the same aggregation function as B1. Note that the diagram is sorted using the same order as in B1.\nWe next show that MAPB(I) = 1 if and only if I is legal and ∀x2f((x1 = α),x2) = 1 where I embeds the substitution x1 = α. This has the same consequences as having B = apply(B1, B2,∧) in the simple construction.\nTo prove the claim first note that by the construction B adds more tests on the path to a 1 leaf of B1 and does not add any other paths to a value of 1. Therefore, for any I and any ζ, if MAPB(I, ζ) = 1 then MAPB1(I, ζ) = 1 and as a result if MAPB(I) = 1 then MAPB1(I) = 1. Therefore, by C1, if MAPB(I) = 1 then I is legal. Finally, when the interpretation is legal the portions of the diagram testing for ≤ q + 3 objects, the uniqueness of special objects T, y1, y2, x1, . . . , xk, the symmetry of q() and its simulation of PT () and Pxi do not affect the final value in the sense that a valuation reaching them always continues to the next block. Therefore, for legal interpretations we can shrink B by removing these blocks and still obtain the same aggregated value. Now we observe that there is a 1-1 correspondence between valuations and values of the resulting B to valuations and values of B2 in the simple construction (where we extend the notion of block consistent to enforce that wi bind to y1, y2). Therefore, the claim holds by C2 of the simple construction."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "<lb>Recent work introduced Generalized First Order Decision Diagrams (GFODD) as a knowl-<lb>edge representation that is useful in mechanizing decision theoretic planning in relational do-<lb>mains. GFODDs generalize function-free first order logic and include numerical values and<lb>numerical generalizations of existential and universal quantification. Previous work presented<lb>heuristic inference algorithms for GFODDs and implemented these heuristics in systems for<lb>decision theoretic planning. In this paper, we study the complexity of the computational prob-<lb>lems addressed by such implementations. In particular, we study the evaluation problem, the<lb>satisfiability problem, and the equivalence problem for GFODDs under the assumption that the<lb>size of the intended model is given with the problem, a restriction that guarantees decidability.<lb>Our results provide a complete characterization placing these problems within the polynomial<lb>hierarchy. The same characterization applies to the corresponding restriction of problems in first<lb>order logic, giving an interesting new avenue for efficient inference when the number of objects<lb>is bounded. Our results show that for Σk formulas, and for corresponding GFODDs, evaluation<lb>and satisfiability are<lb>Σpk complete, and equivalence is Π<lb>p<lb>k+1 complete. For Πk formulas evalua-<lb>tion is<lb>Πpk complete, satisfiability is one level higher and is Σ<lb>p<lb>k+1 complete, and equivalence is<lb>Πpk+1 complete.",
    "creator" : "LaTeX with hyperref package"
  }
}