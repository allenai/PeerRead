{
  "name" : "1511.00916.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Lowering the learning curve for declarative programming: a Python API for the IDP system",
    "authors" : [ "Joost Vennekens" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n51 1.\n00 91\n6v 1\n[ cs\n.P L\n] 3\nN ov"
    }, {
      "heading" : "1 Introduction",
      "text" : "While declarative systems may not be inherently more difficult to learn than, e.g., an object-oriented programming language, they are still often perceived as such, because many programmers are unfamiliar with their syntax, semantics or paradigm. This leads in turn to a chicken-and-egg problem, where programmers do not learn this technology, because companies are reluctant to adopt it, because there are not enough programmers who know the technology readily available.\nIn this paper, we propose to tackle both problems by means of an API that allows a declarative knowledge base (KB) to be used from within a well-known imperative host language. Our first goal is to integrate KB functionality into the host language as seamlessly as possible. In this way, it should be possible to use the knowledge base to prototype a single component of a large system, without affecting the rest of the code base. The second goal is to have a very low learning curve for the API. We achieve this by using as much as possible the syntax of the host language, and by requiring no more background in declarative languages than an introductory course on classical logic. We therefore expect our API to be immediately usable by, e.g., bachelor students in a typical CS curriculum.\nIn more detail, we postulate these guidelines for our development of the API:\n– The interaction between the KB and host language should be done through standard objects of the host language. – The need to learn KB-specific terminology should be kept to a minimum. – It should be as easy as possible to replace the KB by a piece of host language\ncode (or, vice versa, to replace a piece of host language code by a KB).\nA typical use for our API will be to off-load specific computational problems (e.g., detect connected components in a graph, find a permissible allocation of resources to jobs) to the KB, thereby avoiding the need to implement a specific algorithm and thus arriving at a working prototype more quickly. In such an early prototype, the modular, declarative nature of the KB will be particularly useful, because of its ability to easily cope with additional changes to the specification. Once the program has reached a certain level of maturity, it can of course be profiled to see whether all of the KB components meet the performance requirements. Whenever this is not the case, the KB can be replaced by a dedicated algorithm with minimal impact on the rest of the code.\nAs a host language, we use Python (in particular, version 2.7). Given our stated goals, this is the most obvious choice: “[a]t the time of writing (July 2014), Python is currently the most popular language for teaching introductory computer science courses at top-ranked U.S. departments.”1 We assume familiarity with the basics of Python throughout this paper. The KB system that we use will be discussed in Section 2. Section 3 then discusses our interface between host language and KB, which we validate by means of some examples in Section 4. In Section 5, we give some brief notes on the implementation of our API. Finally, Section 6 discusses some related work, in particular, other approaches that integrate a declarative knowledge base into an imperative language."
    }, {
      "heading" : "2 KB system",
      "text" : "As an underlying KB system, we will use IDP (Imperative Declarative Programming)2 [2], which combines techniques from SAT solving, Logic Programming and Answer Set Programming (ASP). It has performed well in previous ASP competitions, e.g., narrowly finishing second after Clasp in the System Track of 20113. IDP has a number of properties that fit well with our goals of achieving both a tight integration with the host language and a low learning curve.\nInput language. IDP uses a language that is a conservative extension of classical first-order logic (FO). Because most students of computer science are familiar with FO, this means that the learning curve for a large part of IDP’s input language consists only of learning a particular ASCII syntax for FO. One of the ways in which IDP extends FO is by adding inductive definitions [3]. Because such definitions cannot, in general, be expressed in FO, this is a real extension of the language. Moreover, since inductive datatypes (lists, trees, . . . ) are very common in computer programs, this feature will prove useful in our API.\nInference. In addition to its input language, a second useful property of IDP is that it aims to support a variety of different inference tasks. Particularly useful in the context of this article is the task of finite model expansion. As pointed out in [6], modal expansion for FO captures the complexity class NP, thereby\n1 http://cacm.acm.org/blogs/blog-cacm/176450-python-is-now-the-most-\npopular-introductory-teaching-language-at-top-us-universities/fulltext 2 https://dtai.cs.kuleuven.be/software/idp 3 https://www.mat.unical.it/aspcomp2011/\ncovering the kind of tasks that we would like to off-load to a declarative KB. Moreover, [7] have further demonstrated that model expansion is a key task when using declarative methods to build modular software systems."
    }, {
      "heading" : "2.1 FO: syntax and semantics",
      "text" : "We briefly recall the standard syntax and semantics of FO. A vocabulary Σ consists of a set of function symbols, each with an associated arity n, and a set of predicate symbols, also each with an arity n. A function with arity 0 is called a constant. A term is either a constant, a variable or an expression f(t1, . . . , tn) where f is an n-ary function symbol and the ti are terms. An atom is an expression P (t1, . . . , tn), with P an n-ary predicate and the ti again terms. A formula is either an atom or an expression ψ ∨ φ, ψ ∧ φ, ¬φ, ∀x : φ, or ∃x : φ, where ψ, φ are formulas and x is a variable. As usual, φ⇒ ψ abbreviates ¬φ∨ψ and φ⇔ ψ stands for (φ⇒ ψ) ∧ (ψ ⇒ φ). A sentence is a formula without free variables and a theory is a finite set of sentences.\nThe standard semantics of FO is defined in terms of structures for a vocabulary Σ. Each structure S consists of a domain D and a mapping of:\n– Each n-ary predicate symbol P in Σ to an n-ary relation R ⊆ Dn – Each n-ary function symbol f in Σ to an n-ary function f : Dn → D\nThe satisfaction relation |= is defined between structures for a vocabulary and theories of this vocabulary (or a subvocabulary thereof) by the usual induction. When S |= T , we also say that the structure S is a model of T .\n2.2 FO in the IDP system\nIDP uses the standard concepts of vocabularies, theories and structures. Each of these has a specific syntactic representation. For example, a map coloring problem can be described in the following vocabulary V .\nvocabulary V {\ntype Color type Area Border(Area,Area) Coloring(Area): Color\n}\nAs can be seen here, IDP in fact uses a typed variant of first-order logic. The first two statements define two types (which can be seen as unary predicates), whereas the last two statements define, respectively, a predicate and a function.\nThe following theory T in vocabulary V consists of a single sentence, expressing that neighboring areas must have a different color. Fig. 1 shows the ASCII symbols that are used in IDP to represent the logical connectives.\ntheory T : V {\n!a b: Border(a,b) => Coloring(a) ~= Coloring(b).\n}\nIDP is usually able to automatically derive the types of variables, based on the type declarations in the definition of the vocabulary. This information is important because most of its inference tasks require IDP to first ground (part of) the theory. Instead of depending on IDP’s automatic type derivation, it is also possible to explicitly declare the type of a variable, e.g.:\n!a [Area] b [Area]: Border(a,b) => Coloring(a) ~= Coloring(b).\nA structure S for a vocabulary V is represented by an enumeration (1) of the values that belong to each type, (2) of the tuples that belong to each predicate, and (3) of the mapping of tuples to values that is made by each function.\nstructure S : V {\nArea = { Belgium; Holland; Germany; } Color = { Blue; Red; Green; } Border = {(Belgium,Holland); (Belgium,Germany); (Holland,Germany)}\n}\nThis structure S for the vocabulary V interprets only part of the vocabulary V . In particular, the function Coloring is not interpreted. One of the inference tasks supported by the IDP system is that of model expansion: given a structure S′ for a subvocabulary Σ′ of the vocabulary Σ of a theory T , compute a structure S for the remaining symbols Σ \\Σ′ such that (S′ ∪ S) |= T .\nIDP exposes its functionality by means of an API in the Lua scripting language. The command printmodels(modelexpand(T,S)) performs the model expansion task for the above structure S and theory T , resulting in the output:\nColoring = {\"Belgium\"->\"Red\";\"Germany\"->\"Blue\";\"Holland\"->\"Green\"}\nBy default, a single model expansion is computed, but it is also possible to compute several or all of them. A special case of model expansion occurs when the initial structure S already interprets the entire vocabulary V of the theory T . In this case, it reduces to checking whether S |= T ."
    }, {
      "heading" : "3 Interfacing with the KB System",
      "text" : "This section presents our API for using the IDP KB system from within Python."
    }, {
      "heading" : "3.1 Vocabularies and structures",
      "text" : "All interaction with the IDP system is done through objects of the IDP class. Each such object represents a knowledge base consisting of a triple (V, S, T ) of a vocabulary V , a structure S and a theory T . It can be created as follows:\nkb = IDP( )\nThe following methods add symbols to the vocabulary of the KB:\nkb . Type (name [ , i n t e r p r e t a t i o n ] ) kb . Constant ( typed name [ , i n t e r p r e t a t i o n ] kb . Function ( typed name [ , i n t e r p r e t a t i o n ] ) kb . P r ed i ca te ( typed name [ , i n t e r p r e t a t i o n ] )\nAs in IDP itself, the typed_name of a predicate is a string of the form Foo(Type1, ..., Type2) and that of a function is Foo(Type1, ..., Type2): Return_type. Because constants are identical to 0-ary functions, their typed_name has the form Foo : Type. Once a symbol Foo has been added to the vocabulary of a knowledge base kb, it can thereafter be referred to as kb.Foo.\nIn addition to declaring a function/predicate symbol σ (i.e., adding it to the vocabulary of the KB), it is also possible to immediately extend the structure S with a particular interpretation σS for σ. This is done by adding this interpretation as a second argument. The interpretation of a type must be a set (or list) of values; that of a constant must be a single value; that of a function with arity ≥ 1 must be mapping (e.g., a dictionary); and that of a predicate must be a set/list of tuples of the correct arity (for predicates with arity 1, a set of simple values is also allowed). Obviously, the typing of the symbols must be respected.\nInstead of initialising the interpretation of a symbol upon construction, it is also possible to first declare a symbol and then later use the assignment operator to provide an interpretation for it. We illustrate using (part of) the graph coloring example of Sec. 2.2.\nc o l o r = IDP( ) c o l o r . Type (\"Color\" , [ \"Blue\" , \"Red\" , \"Green\" ] ) c o l o r . Type (\"Area\" , [ \"Belgium\" ,\"Holland\" , \"Germany\" ] ) c o l o r . P r ed i ca te (\"Border(Area,Area)\" ) c o l o r . Border=[(\"Belgium\" ,\"Holland\" ) , ( \"Belgium\" ,\"Germany\" ) , (\"Holland\" ,\"Germany\" ) ] c o l o r . Function (\"Coloring(Area): Color\" )\nThe “logical” objects that are thus created implement a number of common Python interfaces, allowing them to act as Python programmers would expect. A relation is, in mathematical terms, a set of tuples. Its natural counterpart is a Python MutableSet object4 (i.e., a set which allows adding/removing of elements). The following interactive session demonstrates some standard usages.\n>>> \"Belgium\" in c o l o r . Area True >>> c o l o r . Area . add (\"Austria\" ) >>> for x in c o l o r . Area :\n4 https://docs.python.org/2/library/collections.html#collections.Set\n. . . print x , . . . Holland Austr ia Germany Belgium\nIn addition to the standard MutableSet functionality, relations are also callable5, so that we may also use the standard FO notation for checking membership.\n>>> c o l o r . Area (\"Belgium\" ) True\nA function is a Mapping6, that is, an object that maps each tuple of values in its domain to a value in its range. Some standard usages are:\n>>> c o l o r . Co lo r ing . keys ( ) [ ’Austria’ , ’Germany’ , ’Holland’ , ’Belgium’ ] >>> c o l o r . Co lo r ing [ \"Belgium\" ] ’Blue’\nAs with predicates, function objects are callable to allow for the more FO-like:\n>>> c o l o r . Co lo r ing (\"Belgium\" ) ’Blue’"
    }, {
      "heading" : "3.2 Formulas and definitions",
      "text" : "In keeping with our goal of achieving a low learning curve, formulas are written in Python syntax. An overview is shown in Fig. 1. The Python language has the standard boolean operators and, or and not. In addition, it also has the functions all and any, which may be applied to lists of boolean values to return the conjunction/disjunction of these values. The latter two functions, together with Python’s list comprehension syntax, can be used as universal/existential quantification. The list comprehension syntax also has an optional if part, which may be used to represent the common pattern of a universally quantified implication:\n∀x[Type] : φ all(φ for x in Type) ∃x[Type] : φ any(φ for x in Type)\n∀x[Type] : φ⇒ ψ all(ψ for x in Type if φ)\nIn the graph coloring problem, we need to express the following property:\n∀a b : Border(a, b) ⇒ Coloring(a) 6= Coloring(b) (1)\nSection 2.2 already presented the IDP syntax for this. In Python, we can write the same property as:\n5 https://docs.python.org/2/library/functions.html#callable 6 https://docs.python.org/2/library/collections.html#collections.Mapping\na l l ( c o l o r . Co lo r ing ( a ) != co l o r . Co lo r ing (b) for ( a , b) in c o l o r . Border )\nNote that this is just a normal Python expression, which we can, e.g., just type into the interactive terminal. This expression evaluates to True precisely when property (1) is satisfied. We can make the KB aware of such a constraint by means of its Constraint method, which takes a string as its argument. So, the following code adds the above constraint to our graph coloring KB:\nc o l o r . Constra int (\"all(Coloring(a) != Coloring(b) for (a,b) in Border\" )\nThe string argument is completely identical to the Python expression we saw above, with one exception: the predicates/functions are simply called Coloring, Area and Border, instead of color.Coloring, color.Area and color.Border. This is because, just as a theory can only contain symbols that appear in its vocabulary, the constraints that are added to a KB always refer to the symbols of that KB.\nAn alternative formula, which is equivalent to the one above, quantifies over Area×Area and uses an if-expression to check for membership in Border:\nc o l o r . Constra int (\"all(Coloring(a) != Coloring(b) for a in Area for b in Area if (a,b) in Border)\" )"
    }, {
      "heading" : "3.3 Functional interfacing",
      "text" : "In keeping with our goal of making the API easy to use, the programmer does not need to explicitly invoke the IDP system. This avoids the need to learn new functions or new terminology, and reduces the possibility of bugs. Instead, invokation of the IDP system happens “automagically” in the following circumstances:\n– Symbols that have been declared, but for which no interpretation has been provided, are automatically assigned a valid interpretation (in accordance with FO semantics) when their content is inspected. In other words, IDP is used as an oracle to lazily fill in the interpretation of any declared symbols for which the user does not provide one herself. This is done in a way that the interpretations of all symbols together constitutes an FO model of the constraints, i.e., a model expansion task is performed. If the constraints admit multiple models, one is chosen arbitrarily. – The KB object has an attribute satisfiable, which is automatically set to True/False (depending on whether the KB is satisfiable) when the user converts it to a boolean (either explicitly with bool(.) or by use in an if-statement).\nIn the previous section, we declared a function color.Coloring without adding an interpretation for this function. Therefore, the IDP system will be invoked to compute a coloring of our graph if we execute the following code:\nfor x in c o l o r . Area : print \"Area %s has color %s\" % (x , c o l o r . Co lo r ing [ x ] )\nNote that if we had added an interpretation for the function Coloring before executing this code, then this for-loop would still continue work as expected. This is an important property, because it allows us to change whether a relation/function is computed by the KB base or by native Python code, without having to adjust the code that makes use of it. In the latter case, the call color.Coloring[x] will just retrieve the pre-computed coloring stored within the color object, without invoking IDP.\nSimilarly, if a coloring is not provided, then the following code will test whether a given graph can be colored, whereas if it is provided, the same code checks whether it is indeed valid.\ni f c o l o r . s a t i s f i a b l e : print \"The graph can be colored\""
    }, {
      "heading" : "3.4 Inductive definitions",
      "text" : "An important feature of the IDP system is its ability to handle inductive definitions. It uses a rule-based syntax for representing such definitions, in which, e.g., the transitive closure TC of a graph G can be defined as follows\n{\n∀x, y : TC(x, y) ← G(x, y).\n∀x, y : TC(x, y) ← ∃z : G(x, z) ∧ TC(z, y).\n}\nNote that the arrow symbol here is not material implication, but a special symbol that denotes a “case” in an inductive definition. Such an inductive definition is interpreted under the well-founded semantics [9], which in the case of a positive definition (such as the one above) boils down to a least-fixpoint construction. Each rule of such a definition represents a single case in which the defined predicate holds. In our Python API, we use a lambda-expression to represent such a case.\nkb . Def ine ( [ ( \"TC(Node,Node)\" , \"lambda x,y: G(x,y)\" ) , (\"TC(Node,Node)\" , \"lambda x,y:\nany(G(x,z) and TC(z,y) for z in Node)\" )\nThis both declares the predicate TC and defines it in terms of the “parameter” G. For definitions consisting of a single rule, a simpler syntax is also allowed:\nkb . Def ine (\"TC(Node,Node)\" , \"lambda x,y: G(x,y) or\nany(G(x,z) and TC(z,y) for z in Node)\" )\nSimilar to how an argument of kb.Constraint(.) can also be used as a simple boolean Python expression, the above lambda-expression can be used to compute the transitive closure of G by an explicit least-fixpoint computation:\ndef l f p ( f , x= [ ] ) : y = f (x ) return y i f y == s else f (x )\nnode pa i r s = [ ( x , y ) for x in kb . Node for y in kb . Node ] TC = l f p (lambda T: f i l t e r (lambda x , y : kb .G(x , y ) or\nany (kb .G(x , z ) and T( z , y ) for z in Node ) , node pa i r s ) )\nAn advantage of using IDP is that the definition of TC can then not only be used to compute the transitive closure of a given graph, but also to, e.g., compute a graph that would have a given relation as its transitive closure. In addition, IDP not only supports positive inductive definitions, but also nonmonotone inductive definitions (such as the standard definition of the relation “|=” in FO), for which a simple least-fixpoint construction does not work. Nonrecursive definitions (which are equivalent to a standard FO equivalence) are also allowed in IDP. In the latter case, we can of course choose whether to use the Define or Predicate method of our API.\nIDP can be configured to use XSB Prolog7 to speed up certain computation with definitions. We always use this option in the experiments below."
    }, {
      "heading" : "4 Experiments",
      "text" : "This section presents two examples of our API, with a particular focus on demonstrating that the integration into the surrounding Python code can be done in a natural way."
    }, {
      "heading" : "4.1 Sudoku",
      "text" : "The first example is a Sudoku solver. A Sudoku grid consists of 9× 9 = 81 cells.\nsud = KB( ) sud . Type (\"Cell\" , range (81) )\nThe grid is divided into in rows, columns and nine small 3× 3 squares.\nsud . Pr ed i ca te (\"SameRow(Cell, Cell)\" , [ ( i , j ) for i in sud . Ce l l for j in sud . Ce l l i f i / 9 == j / 9 ] ) sud . Pr ed i ca te (\"SameCol(Cell, Cell)\" ,\n[ ( i , j ) for i in sud . Ce l l for j in sud . Ce l l i f i % 9 == j % 9 ] )\n7 http://xsb.sourceforge.net/\nsud . Pr ed i ca te (\"SameSmallSq(Cell, Cell)\" , [ ( i , j ) for i in sud . Ce l l for j in sud . Ce l l\ni f ( i %9)/3 == ( j%9)/3 and ( i /9)/3 == ( j /9) /3 ] )\nHere, the Python list comprehensions compute an enumeration of these relations, by iterating over all tuples in the Cartesian product of the argument types and checking a certain condition for each tuple. Alternatively, we can make IDP do this work, by Defining the predicates with the appropriate lamba-expressions.\nsud . Def ine (\"SameRow(Cell, Cell)\" , \"lambda i, j: i / 9 == j / 9\" )\nThe cells must be filled with integers from 1 to 9. It will be convenient to represent an empty cell by the number 0, leading to the following type Number.\nsud . Type (\"Number\" , range (10) )\nWe make use of two functions that map cells to numbers: one records the problem statement and the other its solution. The problem statement comes from a list of numbers, that we convert to a dictionary by means of zip operation.\ns=[ 8 , 5 , 0 , 0 , 0 , 2 , 4 , 0 , 0 , 7 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , . . . . . . . . . ] sud . Function (\"Given(Cell):Number\" , d i c t ( z ip ( range ( l en ( s ) ) , s ) ) ) sud . Function (\"Sol(Cell): Number\" )\nThe function Sol will be computed by IDP, in accordance with the rules of sudoku. First, we state the difference constraint on the appropriate cells.\nsud . Def ine (\"Diff(Cell,Cell)\" , \"lambda x,y: x != y and (SameRow(x,y) or SameCol(x,y) or SameSmallSq(x,y))\" ) sud . Constra int (\"all(Sol(x) != Sol(y) for (x,y) in Diff)\" )\nNext, we state that the solution must match the problem statement on all non-empty cells (i.e., those 6= 0), and that it should fill in all cells.\nsud . Constra int (\"all(Sol(x) == Given(x) for x in Cell if Given(x) != 0)\" ) sud . Constra int (\"all(Sol(x) != 0 for x in Cell)\" )\nWith this, the sudoku problem is completely specified. The following code passes the sud.Sol object to a function that pretty-prints the sudoku. Only at the start of the for-loop in this function is the solution actually computed.\ndef show( g r id ) : row = −1 for x in g r id . keys ( ) :\nsys . s tdout . wr i t e (’ ’ i f x % 3 == 0 else ’’ ) i f x % 9 == 0 :\nrow += 1 print (’\\n’ i f row % 3 else ’’ )\nprint ( s t r ( g r id [ x ] ) + \" \" ) ,\nshow( sud . So l )\nWe remark that, because we use valid Python expressions to assert constraints, we can use the same expressions to check that the output indeed satisfies the constraints. For instance, at the interactive Python terminal:\n>>> a l l ( sud . So l ( x ) != sud . So l (y ) for (x , y ) in sud . D i f f ) True\nPeter Norvig has published a sudoku solver written entirely in Python using constraint solving techniques8. Not counting whitespace and comments, his code to compute solutions is about 40 lines, whereas the code we have presented in this section is 12 lines. Moreover, it is easy to replace the existing solve function in his code by a call to our knowledge base. This requires two small transformations: first, in Norvig’s code, input grids are given in the format of a single string, where an empty cell is represented by a dot; second, he produces output in the form of a dictionary in which the keys are strings of the form Xn with X ∈ A..I representing the row and n ∈ 1..9 the column.\ndef s o l v e ( sud , g r id ) : \"\"\" Solve sudoku \"grid\" using the KB \"sud\". \"\"\"\ndef t r a n s l a t e (n ) : rows = ’ABCDEFGHI’ d i g i t s = ’123456789’ return rows [ n/9 ] + d i g i t s [ n%9] sud . Given = d i c t ( z ip ( range (81) , [ i n t ( x ) for x in g r id . r e p l a c e (’.’ ,’0’ ) ] ) ) return d i c t ( z ip (map( t r an s l a t e , sud . So l . keys ( ) ) , map( s tr , sud . So l . va lue s ( ) ) ) )\nWhen it comes to runtime, our version is significantly slower than the original on Norvig’s test set, averaging 0.27s per sudoku versus 0.008s.\nAt the other end of the spectrum, we can also compare to a naive generateand-test approach. Using Python’s powerful itertools library, this can also be implemented in about 10 lines of code. (The code used to test whether a solution is correct can of course use the same syntactical expressions as those which we passed to our API.) However, the runtime of such a program is very poor: for a sudoku with just 5 empty cells (for comparison, a typical sudoku has around 50 to 60), it already takes over a minute to find a solution.\nOur main conclusions from this experiment are that, at least in this case:\n8 http://norvig.com/sudoku.html\n– Our API can handle, with a limited amount of overhead, the input/output format that a typical Python programmer would use; – Our API can be used to develop useful functionality in significantly fewer lines of code (12 versus 40) than a clever Python implementation. In fact, it takes only as many lines of code as a naive generate-and-test algorithm. – Even though our API is significantly slower than a clever Python algorithm, it still vastly outperforms the naive generate-and-test approach."
    }, {
      "heading" : "4.2 Working with graphs",
      "text" : "The following class GraphKB extends the generic IDP Knowledge Base class with some specific functionality for working with undirected graphs. When constructing such a GraphKB, the nodes of the graph can be initialised by means of a given set and the edges by means of an adjacency list. The predicate Edge is Defined as the symmetric closure of the adjacency list. This class also offers a convenience method to define the transitive closure of relations over this graph.\nclass GraphKB(IDP) :\ndef i n i t ( s e l f , nodes = [0 ] , a d j l i s t = [ ] ) : super (GraphKB , s e l f ) . i n i t ( ) s e l f . Type (\"Node\" , nodes ) s e l f . P r ed i ca te (\"Adjacent(Node,Node)\" , a d j l i s t ) s e l f . De f ine (\"Edge(Node,Node)\" ,\n\"lambda x,y: Adjacent(x,y) or Adjacent(y,x)\" )\ndef add TC( s e l f , o r i g i n a l , tc name ) : formula = \"lambda x,y: {0}(x,y) or any({0}(x,z)\nand {0}(z,y) for z in Node)\" . format ( o r i g i n a l ) s e l f . De f ine ( tc name + \"(Node, Node)\" , formula )\nWe can now check if a given adjacency list describes a fully connected graph:\nconnected = GraphKB( nodes , adj ) connected . define TC (\"Path\" , \"Edge\" ) connected . Constra int (\"all(Path(x,y) for x in Node for y in Node)\" ) i f connected . s a t i s f i a b l e :\nprint \"Graph is fully connected\"\nWe can use a similar KB to count the number of connected components in the graph. We do this by selecting a single representative from each component (its “Root”) and then counting the number of these representatives.\ncomp = GraphKB( nodes , adj ) comp . define TC (\"Path\" , \"Edge\" ) comp . Pr ed i ca te (\"Root(Node)\" )\ncomp . Constra int (\"all(any(Path(r,x) for r in Root) for x in Node if not Root(x))\" ) comp . Constra int (\"not any(Path(x,y) for x in Root for y in Root if x != y)\" ) print \"Number of components: {0}\" . format ( l en (comp . Root ) )\nFor a graph with 1000 nodes in 86 connected components, this program takes 23s to count the components. By comparison, the popular NetworkX Python library9 is two orders of magnitude faster, taking only 0.2s.\nIn graph theory, an undirected graph is called a tree if it is connected and does not contain cycles. When checking for a cycle in an undirected graph, we of course have to exclude the trivial two-node cycles that would result from traversing the same undirected edge in both directions. This in fact makes it easier to use IDP to check that there is a cycle, than to check that there is not one. The following knowledge base tries to guess the direction in which to traverse each edge in order to produce a cycle. If it is unsatisfiable, there are no cycles.\nc y c l i c = GraphKB( ) c y c l i c . P r ed i ca te (\"Traverse(Node,Node)\" ) c y c l i c . Constra int (\"all(Edge(x,y) for (x,y) in Traverse)\" ) c y c l i c . Constra int (\"not any(Traverse(y,x) for (x,y) in Traverse)\" ) c y c l i c . define TC (\"TravTC\" , \"Traverse\" ) c y c l i c . Constra int (\"any(TravTC(x,x) for x in Node)\" )\nWe can now combine the two knowledge bases to check whether a given adjacency list indeed describes a tree.\ndef i s t r e e ( a d j l i s t ) : c y c l i c . Adjacent = a d j l i s t connected . Adjacent = a d j l i s t return ( bool ( connected . s a t i s f i a b l e )\nand not bool ( c y c l i c . s a t i s f i a b l e ) )\nThis example illustrates how additional functionality can be built on top of the KB objects of our API. In addition, the ability to combine the results of calls to different KBs also allows us to implement functionality that would be harder to implement in a single IDP KB."
    }, {
      "heading" : "5 Implementation",
      "text" : "The implementation of our API and the examples are available for download.10 Interfacing with the IDP system is currently done in a decoupled way: when the\n9 https://networkx.github.io/ 10 https://bitbucket.org/joostv/pyidp/admin\nAPI detects that the IDP system needs to be called, it prepares a text file with the appropriate vocabulary, structure and theory, then calles the IDP system as an external process and parses its output. The results of this call are cached, so that the IDP system will not be invoked again until the KB changes."
    }, {
      "heading" : "6 Related work",
      "text" : "There is already a long history of work attempting to close the gap between imperative and declarative programming [1]. We briefly compare our approach to some recent work in this area.\nIn [8], an approach is presented in which a constraint solver is not added to a single host language, but can be used in the development of a domain-specific language in Racket. Like ours, the motivation behind this work is to allow the power of declarative systems to be more widely used. However, their approach differs, because they count on an intermediary—the designer of the domainspecific language—to hide the complexity of the declarative system, whereas our approach focuses on creating an interface that is natural enough to offer KB functionality directly.\nIn [4], a constraint solver is integrated into the Scala language. As ours does, their approach reuses the syntax of the host language to interface with the declarative system. A key difference is that, in their approach, the programmer is explicitly manipulating, combining and solving constraints, which makes the constraint solver more present in the eventual source code. A second difference is of course that Scala currently appears to be less widely known than Python.\nIn [5], a reasoner for FO extended with transitive closure is integrated into Java. Their KB language is therefore very similar to (but more restricted than) that of IDP. When it comes to the integration in Java, there are two main differences to our approach. First, the declarative knowledge is not written in expressions in the host language, but in a separate language (the Alloy-like JFSL [10]). Second, the integration into Java is done in an object-oriented way: the programmer defines classes in which formulas are added as, among others, class invariants, method pre-/postconditions and frame conditions. In comparison, our Python API seems more lightweight, since it does not require an object-oriented approach. When it comes to computational performance, [5] reports good results, which our implementation is not able to match.\nIn summary, our approach fills the niche of an easy-to-learn quick prototyping API, that, due to Python’s current popularity, may speak to a large audience."
    }, {
      "heading" : "7 Conclusions and future work",
      "text" : "When prototyping an application, a programmer may encounter a computational subproblem for which it would be cumbersome to develop a specific algorithm. The aim of our API is to allow such gaps to be declaratively stopped with as little effort as possible. As we have seen, our API might allow a feasible solution to be produced in only as many lines of code as an (infeasible) naive\ngenerate-and-test algorithm. Our use of standard Python objects such as sets and mappings means that no elaborate setup code is required to plug the KB into an existing code base, while our use of standard Python expressions for constraints and definitions leads to a low learning curve. In addition, both these properties also make it easier to eventually remove the KB if a more efficient solution is required: the same KB that first generated the solution, can later be used to check its correctness, or its constraints may simply be recuperated in the form of Python assert-statements.\nTo prevent changing/removing the KB from leading to code changes elsewhere, our API makes all calls to the IDP system automatically, whenever they are needed. This has the additional benefit of simplifying the API and not forcing the programmer to learn new terminology. A downside is that it is harder for the programmer to keep track of what is happening when in the program.\nOur current implementation of the API is naive in its interfacing with the IDP system, which happens by passing text files (built each time from skratch) to an external process. A better integration, which exploits the Lua interface of IDP, might offer a significant reduction in runtimes. However, since we mainly intend our API to be used in prototyping, this issue might not be pressing. Another consequence, which may be more severe, is that programs written in our API are currently hard to debug: it may be necessary to manually inspect the text file that was passed to the IDP system (in debug-mode, the API always sends this to standard output). However, this requires the user to be at least somewhat familiar with IDP input syntax, which is something we aimed to avoid.\nOur validation of the API currently consists only of examples that we have implemented ourselves. A better test would involve Python programmers who have no knowledge of IDP or indeed any declarative system. However, better debugging facilities seem necessary for such a trial to be successful."
    } ],
    "references" : [ {
      "title" : "Programming in alma-0, or imperative and declarative programming reconciled",
      "author" : [ "Krzysztof R. Apt", "Andrea Schaerf" ],
      "venue" : "In FroCos,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1998
    }, {
      "title" : "Predicate logic as a modeling language: Modeling and solving some machine learning and data mining problems with IDP3",
      "author" : [ "M. Bruynooghe", "H. Blockeel", "B. Bogaerts", "B. De Cat", "S. De Pooter", "J. Jansen", "A. Labarre", "J. Ramon", "M. Denecker", "S. Verwer" ],
      "venue" : "Theory and Practice of Logic Programming,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2014
    }, {
      "title" : "A logic of nonmonotone inductive definitions",
      "author" : [ "Marc Denecker", "Eugenia Ternovska" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2008
    }, {
      "title" : "Constraints as control",
      "author" : [ "A. Köksal", "V. Kuncak", "P. Suter" ],
      "venue" : "In POPL’12,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2012
    }, {
      "title" : "Unifying execution of imperative and declarative code",
      "author" : [ "A. Milicevic", "D. Rayside", "K. Yessenov", "D. Jackson" ],
      "venue" : "In Proc. 33rd Int’l Conference on Software Engineering (ICSE),",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "A framework for representing and solving NP search problems",
      "author" : [ "David G. Mitchell", "Eugenia Ternovska" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2005
    }, {
      "title" : "A semantic account for modularity in multi-language modelling of search problems",
      "author" : [ "Shahab Tasharrofi", "Eugenia Ternovska" ],
      "venue" : "In Proc. FroCos,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2011
    }, {
      "title" : "Growing solver aided languages with rosetta",
      "author" : [ "E. Torlak", "R. Bodik" ],
      "venue" : "In Proc. ACM international symposium on New ideas, new paradigms, and reflections on programming & software,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2013
    }, {
      "title" : "The well-founded semantics for general logic programs",
      "author" : [ "A. Van Gelder", "K.A. Ross", "J.S. Schlipf" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1991
    }, {
      "title" : "A lightweight specification language for bounded program verification",
      "author" : [ "K. Yessenov" ],
      "venue" : "Master’s thesis,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "As an underlying KB system, we will use IDP (Imperative Declarative Programming) [2], which combines techniques from SAT solving, Logic Programming and Answer Set Programming (ASP).",
      "startOffset" : 81,
      "endOffset" : 84
    }, {
      "referenceID" : 2,
      "context" : "One of the ways in which IDP extends FO is by adding inductive definitions [3].",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 5,
      "context" : "As pointed out in [6], modal expansion for FO captures the complexity class NP, thereby",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 6,
      "context" : "Moreover, [7] have further demonstrated that model expansion is a key task when using declarative methods to build modular software systems.",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 8,
      "context" : "Such an inductive definition is interpreted under the well-founded semantics [9], which in the case of a positive definition (such as the one above) boils down to a least-fixpoint construction.",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 0,
      "context" : "There is already a long history of work attempting to close the gap between imperative and declarative programming [1].",
      "startOffset" : 115,
      "endOffset" : 118
    }, {
      "referenceID" : 7,
      "context" : "In [8], an approach is presented in which a constraint solver is not added to a single host language, but can be used in the development of a domain-specific language in Racket.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 3,
      "context" : "In [4], a constraint solver is integrated into the Scala language.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 4,
      "context" : "In [5], a reasoner for FO extended with transitive closure is integrated into Java.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 9,
      "context" : "First, the declarative knowledge is not written in expressions in the host language, but in a separate language (the Alloy-like JFSL [10]).",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 4,
      "context" : "When it comes to computational performance, [5] reports good results, which our implementation is not able to match.",
      "startOffset" : 44,
      "endOffset" : 47
    } ],
    "year" : 2015,
    "abstractText" : "Programmers may be hesitant to use declarative systems, because of the associated learning curve. In this paper, we present an API that integrates the IDP Knowledge Base system into the Python programming language. IDP is a state-of-the-art logical system, which uses SAT, SMT, Logic Programming and Answer Set Programming technology. Python is currently one of the most widely used (teaching) languages for programming. The first goal of our API is to allow a Python programmer to use the declarative power of IDP, without needing to learn any new syntax or semantics. The second goal is allow IDP to be added to/removed from an existing code base with minimal changes.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}