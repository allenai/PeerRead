{
  "name" : "1706.03144.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "pei.cao@uconn.edu).", "zhaoyan.fan@oregonstate.edu).", "robert.gao@case.edu).", "jtang@engr.uconn.edu)." ],
    "sections" : [ {
      "heading" : null,
      "text" : "path-finding. A pruned version of visibility graph based on\nCandidate Vertices is formulated, followed by a new\nvisibility check technique. Such combination enables us to quickly identify the useful vertices and thus find the\noptimal path more efficiently. The algorithm proposed is demonstrated on various path-finding cases. The\nperformance of the new technique on visibility graphs is\ncompared to the traditional A* on Grids, Theta* and A* on Visibility Graphs in terms of path length, number of nodes\nevaluated, as well as computational time. The key\nalgorithmic contribution is that the new approach combines the merits of grid-based method and visibility\ngraph-based method and thus yields better overall performance.\nIndex Terms— path-finding, gridded graphs, visibility graphs,\nA*, Theta*, obstacle vertices, visibility check, ray-casting\nI. INTRODUCTION\nhe problem of finding the shortest path is frequently encountered in video games, robotics, GPS navigation, and path planning etc [1]~[7]. A recent research studied the method to obtain the shortest spatial path to plumbing multiple hydraulic components in additive manufacturing [8] where the plumbing length determines the weight, volume, and cost of product.\nKnown terrain pathfinding can be generally divided into two steps: 1) discretizing the continuous routing space, and 2) searching along the graph to find the path minimizing the cost value, which represents the overall length of the path from the starting node to the target node for a non-weighted graph. In\nthis research, without loss of generality, square grids are used to discretize the terrain owing to its simplicity and popularity in various applications [9]. A review of different terrain discretizations can be found in [10].\nPei Cao is with the Mechanical Engineering Department, University of\nConnecticut, Storrs, CT, 06269 USA (e-mail: pei.cao@uconn.edu).\nZhaoyan Fan is with the Mechanical, Industrial and Manufacturing Engineering Department, Oregon State University, Corvallis, OR 97330 USA (e-mail: zhaoyan.fan@oregonstate.edu).\nRobert X. Gao is with the Department of Mechanical and Aerospace Engineering, Case Western Reserve University, Cleveland, OH 44106 USA (e-mail: robert.gao@case.edu).\nJiong Tang is with the Mechanical Engineering Department, University of Connecticut, Storrs, CT, 06269 USA (e-mail: jtang@engr.uconn.edu).\nOne of the earliest investigations was the Dijkstra’s algorithm [11] where the cost value for the incremental search to the nearest goal is used. The well-known A* algorithm [12] made some improvements to Dijkstra’s algorithm by adding heuristic cost from the current node to the target node to the evaluation.\nDue to its simplicity and guaranteed optimality guarantees, A* is widely used for solving path-finding problems as it is guaranteed mathematically to find a solution. However, the shortest path in gridded graph is not equivalent to the shortest path in continuous space where polynomials along the edge of grids can be replaced by straight lines [13]. One example is shown in Fig. 1. Fig. 1(a) illustrates the shortest graph path obtained by A* algorithm. Since A* algorithm can only take horizontal, vertical or diagonal propagation steps (i.e., zigzag steps) towards neighbor nodes, the path heading (direction) is constrained by propagation headings. The shortest continuous path is depicted in Fig. 1(b), where the path length is apparently shorter than that in Fig. 1(a). A commonly adopted solution to such a problem is to apply post-smoothing techniques to\nshorten the shortest grid path at the cost of an increase of computational time [14], [15]. The post processing techniques usually find a shorter any-angle path compared to A*, but it is not guaranteed to find the true shortest path [16]. Since they directly make adjustment to paths obtained by A* without knowing whether the post-processed path is optimal or not. These post processing techniques are often ineffective [17] due to the unavailability of the knowledge of the post processed paths.\nAiming at overcoming the limitations of A*, Field D* [17], an advanced version of D* Lite [18], was proposed which uses the linear interpolation of path costs of vertices to obtain any-angle paths. However, Field D* could result in paths that have unnecessary heading changes and should thus be smoothed further [19]. Some other approaches, such as Theta* [16], [20] and Lazy Theta* [21], were also proposed which embeds smoothing process into the A* searching to release the constraint on path searching directions (45 or 90 degrees).\nT\nTheta* finds shorter paths in less time than Filed D* according to literature [20]. Nevertheless, optimality is still not guaranteed [16], [22]. Fig. 2 shows the optimal path found by Theta* and the true shortest path. Similar to Theta*, Accelerated A* [23] is an any-angle pathfinding algorithm that is conjectured to be optimal but without strong theoretical argument. It can include a large proportion of nodes on the Closed List, i.e., large number of node evaluations for challenging problems [24].\nAlthough in application areas such as video games and navigations, the property of having shortest path length was not well emphasized compared to computational efficiency, it may become a critical issue in manufacturing scenarios. For example, the plumbing paths between components determine the total volume of product being manufactured, and accordingly, the weight, fabrication time, and cost. A common approach to finding the shortest paths in known terrain with polygonal obstacles is A* on Visibility Graphs [25]. But A* on Visibility Graphs suffers from inefficiency because it propagates along the edges of a visibility graph, the number of which grows exponentially in the size of grid. Even though the process can be accelerated by performing visibility check dynamically or using reduced visibility graphs [26], [27], A* on Visibility Graphs is still considered to be slow. Path-planning algorithms such as continuous Dijkstra and its variants [28], [29] as well as the recent Anya [24] also find shortest paths but have not yet been thoroughly evaluated experimentally. For more pathfinding methods, interested readers may refer to [10]. Generally speaking, to balance between distance and speed, an any-angle pathfinding algorithm should be designed to find a path shorter than that of A* meanwhile faster than A* on Visibility Graphs.\nIn this paper, a focal pruned visibility graph based on Candidate Vertices (CV) is developed, followed by a ray-casting based visibility check technique. The new approach reduces the number of evaluations needed for\npath-finding compared to both gird-based and visibility graph-based methods without sacrificing the optimality. The data structure associated is also introduced which helps to mitigate inefficiencies that come with A* on Visibility Graphs. The performance of the new algorithm, hereafter referred to as Focal Any-Angle A* (FA-A*) in this paper, is compared to A*, Theta* and A* on Visibility Graphs in terms of path length, nodes evaluated as well as computational time.\nII. CANDIDATE VERTICES (CV)\nThe Visibility Graph of a gridded map contains the starting node, the target node and all the vertices of obstacle blocks [25]\n(Lozano-Perez and Wesley, 1979). The reason why we need such a visibility graph is because the true shortest paths have heading changes only at the vertices of the blocks if any. But the vertices that the true shortest path may pass by are comprised of only a small subset of all vertices (Fig. 3). Those are the vertices that we really want to keep track of. Here we introduce a method to identify the possible vertices that the optimal path may pass through. We call this subset of vertices the Candidate Vertices (CV). All the Candidate Vertices along with starting node and target node and their edges constitute the focal pruned visibility graph. The method is explained in detail below which includes a one-time preprocessing. The CV set is constructed dynamically in every step during the search."
    }, {
      "heading" : "A. Preprocessing",
      "text" : "For a problem with n obstacles, an n by n symmetric proximity matrix D is used to record pairwise distances. For example, the proximity value between the i-th obstacle and the j-th obstacle is specified by the distance between them if obstacles are unit squares,\n( , ) ,i j i jD (1)\nThen the obstacles that have proximity values smaller than 2 will be clustered if diagonal move between obstacles is allowed. If not, we cluster the pairs with proximity values less\nof equal to 2 (Fig. 4). Here single linkage method is applied for clustering obstacle points [31].\nNext, for each cluster, quick hull algorithm (Barber et al., 1995) is adopted to obtain the vertices on the convex hull of each cluster. It is possible that when non-convex clusters are tightly placed against each other like mortise and tenon, the optimal path may go through the vertices that are not on the convex hull of the clusters. Thus, it is recommended to consider all the vertices on the convex corners of a cluster when\nthe proportion of obstacles is large or when we are dealing with maze routing problems. However, for obstacle-avoidance problems, vertices on convex hull are adequate and thus will be adopted in the first three numerical tests in this paper (Tests A, B and C in Section V). In the fourth numerical test (Test D), vertices on the convex corners will be considered. After eliminating the vertices on boundaries, the remaining vertices are the vertices that will be further used to construct the CV, and we call this group of vertices V1. An example pathfinding problem after preprocessing can be found in Fig. 5(a) where 36 vertices are in the pool for Candidate Vertices. The preprocessing only needs to be performed once for each gridded map regardless the positions of starting node and target node. On the other hand, full visibility graphs need to be constructed for different starting node and target node setups.\nOne merit of this preprocessing technique is that, no matter how small the grid size is or how many obstacles are used to capture the silhouette of one blocking feature, it can be always regarded as one cluster instead of a large number of obstacles. It enhances the computational performance of the algorithm along the line when maps have more and more details.\nB. Generation of Candidate Vertices (CV)\nAfter preprocessing, the Candidate Vertices (CV) will be dynamically generated throughout the searching process. In each step, the clusters that block the straight line between the\ncurrent node and the target node are considered first. In other words, we first investigate the vertices on convex hulls of the clusters that block the straight line between the current node and the target node.\nFig. 5 illustrates the steps of finding Candidate Vertices in FA-A*. As shown in Fig. 5(b), the dotted box indicates the blocking cluster and associated vertices. We name this set of vertices V2 which is a subset of V1. The visibility is checked to determine whether any cluster blocks the straight line between two nodes. The visibility check technique adopted will be introduced in the following section. Next, we find the vertex on each side of the straight line from V2 that constructs the largest acute angle ( ) with the current node and the target node, as shown in Fig. 5(c). The vertex on each side that corresponds to the largest acute angel is represented by va and vb respectively. It is acute because if a blocking cluster stretches from one end\nto the other, our focus to the target will be blurred. Implicitly, clusters that stay close to the current node will have higher priority in terms of containing va and vb. Assume the current node is represented by p, the target node is q and the vertex is v. We use the linear equation of straight line to determine which side v falls into. The straight line defined by p and q is,\n0Ax By C   (2)\nwhere y yA p q  , x yB q p  , and x y x yC p q q p    .\nSubstituting the position of the vertex into the above\nequation, we have,\nx yD Av Bv C   (3)\nThe position of the vertex v with respect to the straight line can be determined by comparing D to 0. Then we can calculate the angel respectively for vertices on each side, i.e.,\narccos   pq pv\npq pv (4)\nWe now have a triangle that is defined by the current node, va, and vb. An extreme case is when va, vb are collinear and, consequently, no triangle or polygon can be formed. In that case only the vertices in V1 that are on the line segment between va and vb will be considered. Additionally, if all the vertices in V2 are at the same side of the straight line, va and vb then correspond to the largest and smallest acute angles, respectively. We also introduce a technique that enlarges the triangle by pushing va, and vb away from the barycenter o of the triangle. The updated va, and vb can be obtained as\n'a aw  v o ov (5)\n'b bw  v o ov (6)\nwhere w is a scale factor. The default value of w is 1 which means the triangle stays intact. Fig. 5(d) shows the comparison between va, vb and va’, vb’ when w is 2.\nThe vertices in V1 that belong to the clusters inside or tangential to this triangle are narrowed down as the vertices set V3 (Fig. 5(e)). Testing whether a point is inside a polygon is a straightforward operation. In this research, we use the algorithm proposed in [32]. Finally, we proceed to check if the vertices in V3 are visible from the current node; all the visible ones are the so-called Candidate Vertices (CV). The CV, along\nwith the current node, the target node and their edges constitute the focal pruned version of visibility graphs (Fig. 5(f)). Then the CV are used in A* algorithm as neighboring nodes instead of the nodes adjacent to the current node.\nA flowchart is drawn to articulate the process of determining the Candidate Vertices iteratively as a part of pathfinding algorithm in Fig. 6. With the procedures mentioned above, we are able to reduce the computational burden of A* on Visibility Graphs through checking the visibility of vertices in V3 instead of all the vertices and only propagating to CV whereas the key idea of A* on Visibility Graphs has been preserved.\nIII. VISIBILITY CHECK\nIn Theta*, a visibility check technique called line-of-sight is adopted which is derived from [33]. The idea of line-of-sight check is straightforward. It checks certain grids between two nodes based on their relative position. If the examined grid is an obstacle, the two nodes are non-visible to each other. Line-of-sight checks can be performed efficiently with only integer operations on square grids. However, such technique is ad-hoc when adapted to other discretizations or different searching rules because the grids to examine are different case by case. Thus, in this research, we propose a ray-casting algorithm to check for visibility between two nodes based on the algorithm proposed in [30]. The computational complexity of the two approaches is similar (O(n)), but the approach used in this paper is more flexible and can accommodate various applications systematically.\nThe steps of checking the visibility between two nodes with\nthe existence of obstacles are outlined below: 1) Consider the obstacles occurring between the nodes Observe Fig. 7. When an obstacle occurs between the nodes, the x, y values of the obstacle in Cartesians system cannot exceed the maximum or minimum x, y values of the two nodes. The obstacles marked with a cross in Fig. 7 should be eliminated. If two nodes have the same x value or y value, then the visibility can be determined directly by examining the grids in between."
    }, {
      "heading" : "2) Check if the obstacles block the ray between nodes",
      "text" : "We check the obstacles that are bounded by the nodes (Fig. 7) one after another to see if any of them intersect with the line segment between the two nodes. Consider Fig. 8 as an example. p and q are two nodes, and Obs is a unit obstacle where the vertices with the smallest and largest x, y values are vmin and vmax, respectively. If\nmaxmin\n( ) ( )x y\ntytx \npq pq (6)\nand\nmaxmin\n( ) ( )y x\ntxty \npq pq (7)\nthen the line segment connecting p and q goes through the\nobstacle (intersect). In Eqs. (6) and (7), ( )xpq , ( ) ypq are\nprojections of |pq| on x-axis and y-axis, txmin, tymin are projections of |pvmin| on x-axis and y-axis, and txmax, tymax are projections of |pvmax| on x-axis and y-axis, as shown in Fig. 8. If we change ‘  ’ to ‘  ’ in Eqs. (6) and (7), merely passing through a vertex will be considered as intersection.\nOnce an obstacle is calculated to have intersected with the line segment between the nodes, we can terminate the examination and conclude that the two nodes are non-visible to each other. For more details, interested readers may refer to [30]."
    }, {
      "heading" : "IV. FOCAL ANY-ANGLE A* ON VISIBILITY GRAPHS",
      "text" : ""
    }, {
      "heading" : "A. FA-A* Algorithm",
      "text" : "We propose the approach to reduce the visibility graph and check visibility. The A* algorithm that uses such techniques is referred to as FA-A* (Focal Any-Angle A*). The pseudo code for FA-A* is provided below:\nMain()\nopen =  g(nstart):=0 parent(nstart) = nstart open.Insert(nstart, parent(nstart), g(nstart), h(nstart)) ncurrent = nstart While ncurrent exists\npropagate = CV of ncurrent if ntarget  propagate\nopen.Insert(ntarget, ncurrent, g(ncurren)+c(ncurren, ntarget),0) return “path found”\nend if open.Refresh (propagate, ncurrent) open.Close(ncurrent) ncurrent = the node in open with the smallest g+h\nEnd while\nend\nopen.Refresh(propagate, ncurrent)\nfor every n’propagate g(n’)new= g(ncurrent)+c(ncurrent, n’)\nif n’open if g(n’)new<g(n’) value in open\nopen.Update(n’, ncurrent, g(n’)new, h(n’))\nend if\nelse open.Insert(n’, ncurrent, g(n’)new, h(n’)) end if\nend for\nend\nIn the pseudo-code, n means node. Therefore nstart, ntarget, ncurrent, are the starting node, the target node, and current node respectively. The notation g(n) represents the shortest path length from the starting node to node n found so far. c(n1, n2) is the cost travel from n1 to n2, i.e., the Euclidean distance between n1 and n2. And h(n) is the heuristic cost from node n to target node. In this research, without loss of generality, the heuristic cost is approximated by the Euclidean distance between two nodes.\nThe key difference between FA-A* and A* is that FA-A* only propagates to Candidate Vertices (CV) of the current node instead of all the neighboring nodes (please see the grayed line in the pseudo-code). Consider a simple case where there is no obstacle. A* or Theta* need to evaluate 17 nodes along the search until they find the target node (Fig. 9(a)), whereas FA-A* could find the target node directly from starting node\nbecause the target node is one of the Candidate Vertices of the starting node (Fig. 9(b)). The evaluated nodes are marked with dots in Fig. 9. Note that in the pseudo-code, we only maintain an open list, whereas in A* and Theta* a closed list co-exists with the open list. Such change is facilitated by using the open.Close operation which prevents the present current node from being either the current node or appearing in the CV again in the future. This change may help to enhance the performance of FA-A* in terms of efficiency."
    }, {
      "heading" : "B. Optimality",
      "text" : "The selection process of Candidate Vertices proposed could be regarded as a greedy approach to reduce the number of visibility checks and function evaluations compared to the methods that use complete visibility graphs.\nThe algorithm is inspired by the scenarios when two nodes are connected with rubber band as the optimal rubber band\nconnections always have the shortest distance possible and have heading changes mostly at or in between the vertices that belong to the clusters that play the biggest roles in blocking the two nodes. The role played by the obstacles in blocking two nodes is an abstract notion which is quantified in our research as . Then va and vb correspond to the largest outreaches of the blocking clusters on each side. By specifying V3, we aim to pinpoint all the vertices that the optimal path may pass through. While the algorithm finds better paths than A* and Theta*, the optimality is not always guaranteed for some highly discrete cases. These will be illustrated in numerical Tests A and B. Nevertheless, the proposed method finds paths that are very close to the shortest paths. That is why we introduce a scale factor w to enlarge the triangle, i.e., to include more vertices in\nV3 at the cost of worse computational efficiency. To begin with, we try to reduce the vertices considered compared to complete visibility graphs. Increasing the value of w will gradually recede such reduction effect and enable the algorithm to find the shortest path in particular situations. As the numerical test results in Section V indicates, in most cases, a default value 1 for w is good enough for the algorithm to find the shortest path."
    }, {
      "heading" : "C. Computational Complexity Analysis",
      "text" : "This section provides the complexity analysis of FA-A*. The operations of FA-A* and their worst-case complexity are outlined as follows. 1) Prepossessing: O(|Obs| log |Obs|) as it is the complexity for\nquick hull algorithm. |Obs| is the number of obstacles. 2) Check which clusters block the straight line between starting node and current node: O(n). O(n) is the complexity for visibility check where n represents the number of obstacles in between the two nodes. 3) Calculate  : O(|V2|). |V2| is the size of V2. 4) Check if a vertex is inside the triangle: O(3|V1|). O(3) is the complexity to check if a point is inside of a triangle. 5) Check if vertices in V3 are visible from current node: O(n|V3|).\nIn summary, the computational complexity for FA-A* is\nFA-A* 2 1 3\n(FA-A*) ( log )\n( ) ( | | 3 | | | |)\nO O\nO Expan O n n\n\n    \nObs Obs\nV V V (8)\nwhere ExpanFA-A* is the number of expansion in FA-A*. This can be simplified to\nFA-A* 2 1 3(FA-A*) ( ( | | 3 | | | |))O O Expan n n    V V V (9) The first term in Eq. 8 is omitted because that the second term has the dominant effect on complexity as the scale of the problem increases.\nMeanwhile, the computational complexity of A* is\nA*(8 )O Expan , the complexity of Theta* is\nθ*((8 ) )O n Expan  , and the complexity of A* on Visibility\nGraphs is A*onV( | | )O n ExpanV where | |V is the number of vertices. The number of expansion for each algorithm has the following empirical relations,\nA* FA-A*Expan Expan (10)\nθ* FA-A*Expan Expan (11)\nA*onV FA-A*Expan Expan (12)\nSince V is a set of all the vertices, we have,\n2 1 3| | | | 3 | | | |n n n   V V V V (13)\nFA-A* can be regarded as a light version of A* on Visibility Graphs in terms of computational complexity, given Eqs. (12) and (13). Since the sizes of V1, V2 and V3 are proportional to the number of clusters, FA-A* is efficient in solving problems with considerable clusters of obstacles rather than discrete small obstacles with the same proportion of obstacles. This will be validated in numerical Test C in Section V. As a result,\nFA-A* has advantages over methods that propagate to immediate neighbors like A* and Theta* computationally when handling maps that have small number of clusters of obstacles. Meanwhile, FA-A* is always more efficient than A* on Visibility Graphs. All of the above could make FA-A* useful in solving either obstacle avoidance or maze routing problems."
    }, {
      "heading" : "D. Data Structure",
      "text" : "In this research, we maintain a concise data structure where two main matrices are used. The first matrix, denoted as Vall, is\na | |V by 4 matrix, where | |V is the number of all vertices.\nEach row of Vall corresponds to one vertex in V where the first two columns are the position of the vertex in the coordinate system, the third column is the obstacle index to which the\nvertex belongs, and the last column is the cluster index to which the obstacle belongs. Similarly, the second matrix, denoted as\nVconvex, is a 1| |V by 4 matrix where each row corresponds to\none vertex in V1.\nVall is used to determine V1 in preprocessing, and Vconvex is formed accordingly. After using Vconvex to determine V2 , we use Vall to check whether a cluster is inside or tangential to the triangle. Finally, Vconvex can be used to determine V3."
    }, {
      "heading" : "V. NUMERICAL TESTS",
      "text" : "In this section, we evaluate the performances of four algorithms, i.e., A* on Grids (A* on G), Theta*, A* on\nVisibility Graphs (A* on V), and FA-A* under four representative test cases. In Tests A and B, we vary the location of the starting node and the target node, as well as the complexity of the map. A total number of 15 maps are used to assess the performance of each algorithm with respect to 2D benchmark cases. Next in Test C, we maintain the number of obstacles while changing the number of clusters to investigate the effect of the number of clusters to path-finding outcomes. Finally, in Test D we examine the algorithms on a maze-routing problem."
    }, {
      "heading" : "A. Placing starting and target nodes in the corners",
      "text" : "In this sub-section, 10 maps with different complexities are used when the starting node and the target node are placed respectively at the bottom left corner and the top right corner. The A* on Visibility Graphs used is optimized to the extent that we only consider the vertices in the convex corners when\nchecking visibility. The metrics employed are the length of the path (L), the number of node evaluations (No.), and the computational time (T). The scale factor w for FA-A* is set to the default value 1 unless FA-A* cannot find the shortest path. We then increase w gradually with a step size of 0.1 until the shortest path is found. In this case, the smallest w for the true shortest path to be found and the corresponding performance are recorded and compared as well. The h-value used for the experiments are the Euclidean distance from the current node to the target node. The computational time is the average over 5 runs. All algorithms are implemented in MATLAB and executed on a 2.40 GHz 2 processors (Xeon E5620) desktop. The runtime could be improved by using other programming languages.\nWe start off by comparing the algorithms on 50*50 gridded graphs. The obstacles are randomly generated with 5%, 10%, 20%, 30% and 50% fraction of the map respectively. The test results are plotted in Fig. 10 and listed in Table 1. FA-A* always finds the shortest path except that the proportion of obstacles is 10% where the shortest path found is 0.543% longer than true shortest path. As demonstrated, FA-A* outperforms the A* and Theta* in all obstacle scenarios in terms of path length and number of node evaluations. When the number of obstacle increases, FA-A* slows down because of CV calculations. It is always faster than A* on Visibility Graphs, and faster than A* on Grids and Theta* when the\nproportion of obstacles is 5%. Fig. 11 shows the path/shortest path versus the runtime which demonstrates how the algorithms balance between shortest distance and shortest runtime. Figs. 11(a), (c), (e) and (i) show that FA-A* stays in the left bottom corner indicating a good compromise of the grid-based technique and the visibility graph-based technique. For the case with 5% obstacles, as can be seen in Fig. 11(a), FA-A* prevails in all metrics.\nWe then proceed to 100*100 graphs with the same obstacles fractions as in 50*50 cases. The results are reported in Fig. 2 and visualized in Fig. 12. A demonstration of paths found by each algorithm and the comparison can be found in Fig. 13 where the evaluated nodes are filled with dots. Our observation from this set of experiments is consistent with 50*50 cases. When there are a small number of obstacles, FA-A* not only finds the best path, but also excels in computational speed. When the obstacle fraction increases, the runtime sacrifices; in\nreturn, the paths found by FA-A* are shorter than those of A* and Theta* significantly. Such observations are also supported by Fig. 11. In the test case where obstacles occupy 30% of the map, FA-A* is unable to find the shortest path until w is increased to 2.2. The path found by FA-A* is compared to the true shortest path in Fig. 14. The only difference is zoomed in while the rest of two paths coincide with each other. This happens because when w=1, FA-A* fails to include the vertex as Candidate Vertices in one particular step which is solved by increasing w to 2.2 if optimality is highly emphasized. Nevertheless, FA-A* with w=1 still finds better path than A* or Theta* as it is only 0.007428% longer than the true shortest path. Usually such difference is acceptable. Based on our experiment results, the choice of 1 for w should be adequate for the most of the time."
    }, {
      "heading" : "B. Placing starting node in middle",
      "text" : "Next we apply the algorithms to 300*300 maps with various proportions of obstacles. The starting node is placed in the middle of the map (150, 150), and the target node is randomly\nplaced. The test results are visualized in Fig. 15 and recorded in Table 3. Because it took A* on Visibility Graphs too long to find the optimal paths for last two cases, the results are omitted. The performance comparison of the other three algorithms is our focus here. FA-A* always finds better paths than A* on Grids and Theta*. Moreover, FA-A* shows the best performance in all three metrics when the fraction of obstacles are 5% and 10%.\nSimilar to A* on Visibility Graphs, the computational time of FA-A* increases as the number of obstacles increases. A comparison of paths is provided in Fig. 16, where A* on Grids evaluates a large number of nodes (4911) around the path found and Theta* managed to reduce the number of node evaluations on the basis of A* on Grids. Meanwhile, A* on Visibility Graphs evaluates 4589 nodes regardless the position of the target as shown in Fig. 16, and FA-A* only evaluates 137 nodes in the searching process which is significantly better than other three algorithms.\nThe results from the three sets of experiments above are consistent in the sense that FA-A* outperforms three other algorithms in all categories when the number of obstacles is small. However, the computational time performance of FA-A* deteriorates as the number of obstacles increases. Based on our complexity analysis, the main factor that affects the computational time of FA-A* is the number of clusters rather than the number of obstacles. Naturally, when the obstacles are randomly generated, the number of clusters is proportional to the number of obstacles because they are more discretely placed."
    }, {
      "heading" : "C. Different number of clusters",
      "text" : "Here we investigate the impact of the number of clusters. In many applications, the obstacles are clustered together to capture the details of the blocking features. Thus, in this test, we use 50*50 maps with 30% of obstacles but the number of clusters is confined. The position, size and shape of the cluster are all randomly generated. The test results are reported in\nTable 4 and Fig. 17. As can be observed, FA-A* always finds the shortest path and the time used decreases as the number of clusters increases. The runtime of A* on G and Theta* do not show much of an improvement. A comparison of the four algorithms with varying numbers of clusters is illustrated in Fig. 18. When the number of clusters is 35 (Fig. 19), FA-A* dominates in all categories. In an extreme case when there is only one obstacle, FA-A* finds the shortest path and takes 0.0268 longer than A* on G because of the overhead introduced by the calculation of Candidate Vertices.\nEvidently, visibility graph based methods are superior to methods that propagate to immediate neighbors for problems with small number of clusters. Therefore, they are more practical towards a series of applications such as car obstacle avoidance and plumbing designs.\nTable 4 Performance on 50*50 graphs\nMap Info Algorithm L No. T 50*50 30%\n316 clusters\nA* on G 75.9828 793 0.4056 Theta* 73.7824 633 0.5928 A*on V true shortest 72.2600 741 32.3234 FA-A*(w=1) 72.2600 372 5.1948\n50*50 30%\n75 clusters\nA* on G 75.1543 687 0.2964 Theta* 72.0079 401 0.2808 A*on V true shortest 71.2361 254 2.9484 FA-A*(w=1) 71.2631 102 1.2168\n50*50 30%\n57 clusters\nA* on G 74.5685 594 0.2496 Theta* 71.6930 453 0.3900 A*on V true shortest 71.2190 178 2.4024 FA-A*(w=1) 71.2190 84 0.8892\n50*50 30%\n35 clusters\nA* on G 74.5685 946 0.5928 Theta* 71.5985 743 0.8112 A*on V true shortest 71.1266 124 0.9360 FA-A*(w=1) 71.1266 36 0.2964\n50*50 30%\n1 cluster\nA* on G 85.6985 1403 0.7800 Theta* 80.0536 762 0.5304 A*on V true shortest 79.8618 4 0.0356 FA-A*(w=1) 79.8618 4 0.0624"
    }, {
      "heading" : "D. Maze Routing",
      "text" : "We further validate the findings reported in the preceding sub-sections by using one of the benchmark maze routing problems [3]. It is a 511*511 map with 2.79% obstacles and 17 clusters. The starting node and the target node are chosen as (15, 466) and (466, 15). In preceding tests, the set V1 is comprised of the vertices that belong to the convex hulls of clusters. In this test, we use the vertices on the convex corners instead, because clusters are nested together in such maze routing problems. The vertices on the convex hull of a cluster are essentially a simplified rendition of the vertices on the convex corners of a cluster. The term ‘convex corner’ means that the inner angle of the corner is less than 180 degrees. The results are shown in Table 5 and Fig. 20. FA-A* finds the shortest path among the four algorithms. Besides, as can be seen in Fig. 21, A* on Grids and Theta* are ‘trapped’ in the maze and evaluate a huge number of nodes throughout (149,689 and 147,896) whereas FA-A* only evaluates 104. Hence, FA-A* is 98.71% faster than A* on G and 99.23% faster than Theta*. Additionally, consistent with all previous test cases, FA-A* has the least node evaluations as shown in Fig. 22, which gains the algorithm advantage in computational time. But the runtime edge of evaluating less nodes in this test case is offset by Candidate Vertices calculations which serves as the reason that FA-A* is slower than A* on V by 0.42%. However, if the number of cluster increases, FA-A* could easily surpass A* on Visibility Graphs regarding the runtime as illustrated in the pre-ceding subsections.\n(a) A* on G (b) Theta*"
    }, {
      "heading" : "VI. CONCLUSION",
      "text" : "In this research, we develop a focal any-angle A* algorithm based on visibility graphs (FA-A*). FA-A* performs the path-finding with focuses on position of the target and prunes the full visibility graph accordingly. The algorithm enhances\nthe computational performance of A* on Visibility Graphs as demonstrated in the numerical tests. Meanwhile, it always finds better paths than A* on Grids and Theta*. Moreover, FA-A* has the least node evaluations for all the test cases. While in this paper all the path costs are evaluated as Euclidean distances, for problems that have more complicated path costs, FA-A* would gain more significant advantage in terms of computational time. FA-A* not only can preserve the optimality of visibility graph-based methods but also can keep up with grid-based methods computationally. As a result, the newly developed approach is capable of finding better paths than A* and Theta*, and yields better computational efficiency than A* on Visibility Graphs or even A* and Theta* for certain cases. The algorithm can be utilized in a variety of applications, e.g., to find the optimal path in a static environment for a robot to take, tackling obstacle avoidance problems for vehicles, or to find the best connections in additively manufactured components, etc."
    } ],
    "references" : [ {
      "title" : "Amit’s game programming information",
      "author" : [ "A. Patel" ],
      "venue" : "International Journal of Robotics Research, 2000.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Implementing a state machine language",
      "author" : [ "S. Rabin" ],
      "venue" : "AI Game Programming Wisdom, pp. 314-320, 2002.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "A comparison of high-level approaches for speeding up pathfinding",
      "author" : [ "N.R. Sturtevant", "R. Geisberger" ],
      "venue" : "AIIDE, Oct. 2010.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A deterministic improved Q-learning for path planning of a mobile robot",
      "author" : [ "A. Konar", "I.G. Chakraborty", "S.J. Singh", "L.C. Jain", "A.K. Nagar" ],
      "venue" : "IEEE Transactions on Systems, Man, and Cybernetics: Systems, vol. 43(5), pp.1141-1153, 2013.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Realization of an adaptive memetic algorithm using differential evolution and q-learning: a case study in multirobot path planning",
      "author" : [ "P. Rakshit", "A. Konar", "P. Bhowmik", "I. Goswami", "S. Das", "L.C. Jain", "A.K. Nagar" ],
      "venue" : "IEEE Transactions on Systems, Man, and Cybernetics: Systems, vol. 43(4), pp.814-831, 2013.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "he problem of finding the shortest path is frequently encountered in video games, robotics, GPS navigation, and path planning etc [1]~[7].",
      "startOffset" : 130,
      "endOffset" : 133
    }, {
      "referenceID" : 2,
      "context" : "We further validate the findings reported in the preceding sub-sections by using one of the benchmark maze routing problems [3].",
      "startOffset" : 124,
      "endOffset" : 127
    } ],
    "year" : 2017,
    "abstractText" : "In this research, we investigate the subject of path-finding. A pruned version of visibility graph based on Candidate Vertices is formulated, followed by a new visibility check technique. Such combination enables us to quickly identify the useful vertices and thus find the optimal path more efficiently. The algorithm proposed is demonstrated on various path-finding cases. The performance of the new technique on visibility graphs is compared to the traditional A* on Grids, Theta* and A* on Visibility Graphs in terms of path length, number of nodes evaluated, as well as computational time. The key algorithmic contribution is that the new approach combines the merits of grid-based method and visibility graph-based method and thus yields better overall",
    "creator" : "Microsoft® Word 2016"
  }
}