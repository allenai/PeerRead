{
  "name" : "1505.05365.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Towards Ideal Semantics for Analyzing Stream Reasoning",
    "authors" : [ "Harald Beck", "Michael Fink" ],
    "emails" : [ "beck@kr.tuwien.ac.at", "dao@kr.tuwien.ac.at", "eiter@kr.tuwien.ac.at", "fink@kr.tuwien.ac.at" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The emergence of sensors, networks, and mobile devices has generated a trend towards pushing rather than pulling of data in information processing. In the setting of stream processing [4] studied by the database community, input tuples dynamically arrive at the processing systems in form of possibly infinite streams. To deal with unboundedness of data, such systems typically apply window operators to obtain snapshots of recent data. The user then runs continuous queries which are either periodically driven by time or eagerly driven by the arrival of new input. The Continuous Query Language (CQL) [3] is a well-known stream processing language. It has a syntax close to SQL and a clear operational semantics.\nRecently, the rise of smart applications such as smart cities, smart home, smart grid, etc., has raised interest in the topic of stream reasoning [16], i.e., logical reasoning on streaming data. To illustrate our contributions on this topic, we use an example from the public transport domain.\nExample 1 To monitor a city’s public transportation, the city traffic center receives sensor data at every stop regarding tram/bus appearances of the form tr(X,P ) and bus(X,P ) where X , P hold the tram/bus and stop identifiers, respectively. On top of this streaming data tuples (or atoms), one may ask different queries, e.g., to monitor the status of the public transport system. To keep things simple, we start with stream processing queries:\n(q1) At stop P , did a tram and a bus arrive within the last 5 min? (q2) At stop P , did a tram and a bus arrive at the same time within\nthe last 5 min?\nConsider the scenario of Fig. 1 which depicts arrival times of trams and buses. The answer to query (q2) is yes for stop p2 and all time points from 2 to 7. Query (q1) also succeeds for p1 from 11 to 13.\nAs for stream reasoning, later we will additionally consider a more involved query, where we are interested in whether a bus always arrived within three minutes after the last two arrivals of trams.\n1 Supported by the Austrian Science Fund (FWF) project 26471. 2 Institut für Informationssysteme, Technische Universität Wien. email: {beck,dao,eiter,fink}@kr.tuwien.ac.at\nDifferent communities have contributed to different aspects of this topic. (i) The Semantic Web community extends SPARQL to allow querying on streams of RDF triples. Engines such as CQELS [14] and C-SPARQL [5] also follow the snapshot semantics approach of CQL. (ii) In Knowledge Representation and Reasoning (KRR), first attempts towards expressive stream reasoning have been carried out by considering continuous data in Answer Set Programming (ASP) [9, 11] or extending Datalog to sequential logic programs [17]. However, the state of the art in either field has several shortcomings.\nApproaches in (i) face difficulties with extensions of the formalism to incorporate the Closed World Assumption, nonmonotonicity, or non-determinism. Such features are important to deal with missing of incomplete data, which can temporarily happen due to unstable network connections or hardware failure. In this case, engines like C-SPARQL and CQELS remain idle, while some output based on default reasoning might be useful. Moreover, e.g., in the use case of dynamic planning on live data, multiple plans shall be generated based on previous choices and the availability of new data. This is not possible with current deterministic approaches.\nOn the other hand, advanced reasoning has extensively been investigated in (ii) but traditionally only on static data. First attempts towards stream reasoning reveal many problems to solve. The plain approach of [9] periodically calls the dlvhex solver [10] but is not capable of incremental reasoning and thus fails under heavy load of data. StreamLog [17] is an extension of Datalog towards stream reasoning. It always computes a single model and does not consider windows. Time-decaying logic programs [11] attempt to implement time-based windows in reactive ASP [13] but the relation to other stream processing/reasoning approaches has not yet been explored.\nMoreover, as observed in [8], conceptually identical queries may produce different results in different engines. While such deviations may occur due to differences (i.e., flaws) in implementations of a common semantics, they might also arise from (correct implementations of) different semantics. For a user it is important to know the exact capabilities and the semantic behavior of a given approach. However, there is a lack of theoretical underpinning or a formal framework for stream reasoning that allows to capture different (intended) semantics in precise terms. Investigations of specific languages, as well as comparisons between different approaches, are confined to experimental analysis [15], or informal examination on specific examples. A systematic investigation, however, requires a formalism to rigorously describe the expressivity and the properties of a language. ar X\niv :1\n50 5.\n05 36\n5v 1\n[ cs\n.A I]\n2 0\nM ay\n2 01\n5\nContributions. We present a first step towards a formal framework for stream reasoning that (i) provides a common ground to express concepts from different stream processing/reasoning formalisms and engines; (ii) allows systematic analysis and comparison between existing stream processing/reasoning semantics; and (iii) also provides a basis for extension towards more expressive stream reasoning. Moreover, we present (iv) exemplary formalizations based on a running example, and (v) compare our approach to existing work.\nThereby, we aim at capturing idealized stream reasoning semantics where no information is dropped and semantics are characterized as providing an abstract view over the entire stream. Second, we idealize with respect to implementations and do not consider processing time, delays or outages in the semantics itself. Moreover, we allow for a high degree of expressivity regarding time reference: We distinguish notions of truth of a formula (i) at specific time points, (ii) some time point within a window, or (iii) all time points in a window. Moreover, we allow (iv) for nested window operators, which provide a means to reason over streams within the language itself (a formal counterpart to repeated runs of continuous queries)."
    }, {
      "heading" : "2 Streams",
      "text" : "In this section, we introduce a logic-oriented view of streams and formally define generalized versions of prominent window functions."
    }, {
      "heading" : "2.1 Streaming Data",
      "text" : "A stream is usually seen as a sequence, set or bag of tuples with a timestamp. Here, we view streams as functions from a discrete time domain to sets of logical atoms and assume no fixed schema for tuples.\nWe build upon mutually disjoint sets of predicates P , constants C, variables V and time variables U . The set T of terms is given by C ∪ V and the set A of atoms is defined as {p(t1, . . . , tn) | p ∈ P, t1, . . . , tn ∈ T }. The set G of ground atoms contains all atoms p(t1, . . . , tn) ∈ A such that {t1, . . . , tn} ⊆ C. If i, j ∈ N, the set [i, j] = {k∈N | i ≤ k ≤ j} is called an interval.\nDefinition 1 (Stream) Let T be an interval and υ : N→ 2G an interpretation function such that υ(t) = ∅ for all t ∈ N \\ T . Then, the pair S = (T, υ) is called a stream, and T is called the timeline of S.\nThe elements of a timeline are called time points or timestamps. A stream S′ = (T ′, υ′) is a substream or window of stream S = (T, υ), denoted S′ ⊆ S, if T ′ ⊆ T and υ′(t′) ⊆ υ(t′) for all t′ ∈ T ′. The cardinality of S, denoted #S, is defined by Σt∈T |υ(t)|. The restriction of S to T ′ ⊆ T , denoted S|T ′ , is the stream (T ′, υ|T ′), where υ|T ′ is the usual domain restriction of function υ.\nExample 2 (cont’d) The input for the scenario in Example 1 can be modeled as a stream S = (T, υ) where T = [0, 13] and\nυ(2) = {tr(a, p1), bus(c, p1)} υ(11) = {bus(e, p2)} υ(8) = {tr(d, p2)} υ(t) = ∅ otherwise.\nThe interpretation υ can be equally represented as the following set: {2 7→{tr(a, p1),bus(c, p1)}, 8 7→{tr(d, p2)}, 11 7→{bus(e, p2)}}"
    }, {
      "heading" : "2.2 Windows",
      "text" : "An essential aspect of stream reasoning is to limit the considered data to so-called windows, i.e., recent substreams, in order to limit the amount of data and forget outdated information.\nDefinition 2 (Window function) A window function maps from a stream S = (T, υ) and a time point t ∈ T to a window S′ ⊆ S.\nThe usual time-based window of size ` [3] contains only the tuples of the last ` time units. We give a generalized definition where the window can also include the tuples of the future u time points. Based on query time t and a step size d, we derive a pivot point t′ from which an interval [t`, tu] is selected by looking backward (resp., forward) ` (resp., u) time units from t′, i.e., t` + ` = t′ and t′ + u = tu.\nDefinition 3 (Time-based window) Let S = (T, υ) be a stream with timeline T = [tmin, tmax], let t ∈ T , and let d, `, u ∈ N such that d ≤ `+ u. The time-based window with range (`, u) and step size d of S at time t is defined by\nw`,ud (S, t) = (T ′, υ|T ′),\nwhere T ′ = [t`, tu], t` = max{tmin, t′ − `} with t′ = b tdc · d, and tu = min{t′ + u, tmax}.\nFor time-based windows that target only the past ` time points, we abbreviate w`,0d with w ` d. For windows which target only the future, we write w+ud for w 0,u d . If the step size d is omitted, we take d = 1. Thus, the standard sliding window with range ` is denoted by w`. The CQL [3] syntax for w`d is [Range l Slide d] and w ` corresponds to [Range l]. Moreover, the window [Now] equals [Range 0] and thus corresponds to w0. The entire past stream, selected by [Range Unbounded] in CQL, is obtained by wt, where t is the query time. To consider the entire stream (including the future), we can use wn, where n = maxT .\nFurthermore, we obtain tumbling windows by setting d = `+ u.\nExample 3 (cont’d) To formulate the monitoring over the stream S of Example 2, one can use a time-based window w5 with a range of 5 minutes (to the past) and step size of 1 minute, i.e., the granularity of T . The results of applying this window function at t = 5, 11 are\nw5(S, 5) = ([0, 5], {2 7→ {tr(a, p1), bus(c, p1)}}), and w5(S, 11) = ([6, 11], {8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}).\nMoreover, consider a time-based (tumbling) window with range (2, 1) and step size 3. For t1 = 5, we have t′1 = b 53c · 3 = 3, thus T ′1 = [max{0, 3− 2},min{3 + 1, 13}] = [1, 4]. For t2 = 11, we get t′2 = 9 and T ′2 = [7, 10]. The windows for t = 5, 11 are\nw2,13 (S, 5) = ([1, 4], {2 7→ {tr(a, p1), bus(c, p1)}}), and w2,13 (S, 11) = ([7, 10], {8 7→ {tr(d, p2))}}).\nFigure 2 illustrates the progression of this window with time.\nThe goal of the standard tuple-based window with count n is to fetch the most recent n tuples. Again, we give a more general definition which may consider future tuples. That is, relative to a time point t ∈ T = [tmin, tmax], we want to obtain the most recent ` tuples (of the past) and next u tuples in the future. Thus, we must return the stream restricted to the smallest interval T ′ = [t`, tu] ⊆ T , where t` ≤ t ≤ tu, such that S contains ` tuples in the interval [t`, t] and u tuples in the interval [t+ 1, tu]. In general, we have to discard tuples arbitrarily at time points t` and tu in order to receive exactly ` and u tuples, respectively. In extreme cases, where fewer than ` tuples exist in [tmin, t], respectively fewer than u tuples in [t+ 1, tmax], we return all tuples of the according intervals. Given t ∈ T and the tuple counts `, u ∈ N, we define the tuple time bounds t` and tu as\nt` = max {tmin} ∪ {t′ | tmin ≤ t′ ≤ t ∧ #(S|[t′,t])≥`}, and tu = min {tmax} ∪ {t′ | t+1 ≤ t′ ≤ tmax ∧ #(S|[t+1,t′])≥u}.\nDefinition 4 (Tuple-based window) Let S = (T, υ) be a stream and t ∈ T . Moreover, let `, u ∈ N, T` = [t`, t] and Tu = [t+1, tu], where t` and tu are the tuple time bounds. The tuple-based window with counts (`, u) of S at time t is defined by\nw#`,u(S, t) = (T ′, υ′|T ′), where T ′ = [t`, tu], and\nv′(t′) =  v(t′) for all t′ ∈ T ′ \\ {t`, tu} v(t′) if t′ = t` and #(S|T`) ≤ ` X` if t′ = t` and #(S|T`) > ` v(t′) if t′ = tu and #(S|Tu) ≤ u Xu if t′ = tu and #(S|Tu) > u\nwhere Xq ⊆ υ(tq), q ∈ {`, u}, such that #(Tq, υ′|Tq ) = q.\nNote that the tuple-based window is unique only if for both q ∈ {`, u}, υ′(tq) = υ(tq), i.e., if all atoms at the endpoints of the selected interval are retained. There are two natural possibilities to enforce the uniqueness of a tuple-based window. First, if there is a total order over all atoms, one can give a deterministic definition of the sets Xq in Def. 4. Second, one may omit the requirement that exactly ` tuples of the past, resp. u tuples of the future are contained in the window, but instead demand the substream obtained by the smallest interval [t`, tu] containing at least ` past and u future tuples. Note that this approach would simplify the definition to w#`,u(S, t) = (T ′, υ|T ′), requiring only to select T ′ = [t`, tu]. We abbreviate the usual tuple-based window operator w#`,0, which looks only into the past, by w#`. Similarly, w#+u stands for w#0,u.\nExample 4 (cont’d) To get the last 3 appearances of trams or buses from stream S in Example 2 at time point 11, we can apply a tuple-based window with counts (3, 0). The application w#3(S, 11) can lead to two possible windows (T ′, υ′1) and (T ′, υ′2), where T ′ = [2, 11], and\nυ′1 = {2 7→ {tr(a, p1)}, 8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}, υ′2 = {2 7→ {bus(c, p1)}, 8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}.\nThe two interpretations differ at time point 2, where either tr(a, p1) or bus(c, p1) is picked to complete the collection of 3 tuples.\nThe CQL syntax for the tuple-based window is [Rows n], which corresponds to w#n. Note that in CQL a single stream contains tuples of a fixed schema. In the logic-oriented view, this would translate to having only one predicate. Thus, applying a tuple-based window on a stream in our sense would amount to counting tuples across different\nstreams. To enable counting of different predicates in separation, we introduce a general form of partition-based windows.\nThe partition-based window CQL applies a tuple-based window function on substreams which are determined by a sequence of attributes. The syntax [Partition By A1,...,Ak Rows N] means that tuples are grouped into substreams by identical values a1, . . . , ak of attributes A1,. . . , Ak. From each substream, the N tuples with the largest timestamps are returned.\nHere, we have no notion of attributes. Instead, we employ a general total index function idx : G → I from ground atoms to a finite index set I ⊆ N, where for each i ∈ I we obtain from a stream S = (T, υ) a substream idxi(S) = (T, υi) by taking υi(t) = {a ∈ υ(t) | idx(a) = i}. Moreover, we allow for individual tuple counts n(i) = (`i, ui) for each substream Si.\nDefinition 5 (Partition-based window) Let S = (T, υ) be a stream, idx : G → I ⊆ N, an index function, and for all i ∈ I let n(i) = (`i, ui) ∈ N× N and Si = idxi(S). Moreover, let t ∈ T and w#`i,ui(Si, t) = ([t`i , t u i ], υ ′ i) be the tuple-based window of counts (`i, ui) of Si at time t. Then, the partition-based window of counts {(`i, ui)}i∈I of S at time t relative to idx is defined by\nw#nidx (S, t) = (T ′, υ′), where T ′ = [min i∈I t`i ,max i∈I tui ],\nand υ′(t′) = ⋃\ni∈I υ ′ i(t ′) for all t′ ∈ T ′.\nNote that, in contrast to schema-based streaming approaches, we have multiple kinds of tuples (predicates) in one stream. Whereas other approaches may use tuple-based windows of different counts on separate streams, we can have separate tuple-counts on the corresponding substreams of a partition-based window on a single stream.\nExample 5 (cont’d) Suppose we are interested in the arrival times of the last 2 trams, but we are not interested in buses. To this end, we construct a partition-based window w#nidx as follows. We use index set I = {1, 2}, and idx(p(X,Y )) = 1 iff p = tr . For the counts in the tuple-based windows of the substreams, we use n(1) = (2, 0) and n(2) = (0, 0). We obtain the substreams\nS1 = ([2, 13], {2 7→ {tr(a, p1)}, 8 7→ {tr(d, p2)}}), and S2 = ([2, 13], {2 7→ {bus(c, p1)}, 11 7→ {bus(e, p2)}}),\nand the respective tuple-based windows\nw#2(S1, 13) = ([2, 13], {2 7→{tr(a, p1)}, 8 7→{tr(d, p2)}}), and w#0(S2, 13) = ([13, 13], ∅).\nConsequently, we get w#nidx (S, 13) = ([2, 13], υ ′), where υ′ is\n{2 7→ {tr(a, p1)}, 8 7→ {tr(d, p2)}."
    }, {
      "heading" : "3 Reasoning over Streams",
      "text" : "We are now going to utilize the above definitions of streams and windows to formalize a semantics for stream reasoning."
    }, {
      "heading" : "3.1 Stream Semantics",
      "text" : "Towards rich expressiveness, we provide different means to relate logical truth to time. Similarly as in modal logic, we will use operators 2 and 3 to test whether a tuple (atom) or a formula holds all the time, respectively sometime in a window. Moreover, we use an exact operator @ to refer to specific time points. To obtain a window of the stream, we employ window operators i.\nDefinition 6 (Formulas Fk) The set Fk of formulas (for k modalities) is defined by the grammar\nα ::= a | ¬α | α ∧ α | α ∨ α | α→ α | 3α | 2α | @tα | iα where a is any atom in A, i ∈ {1, . . . k}, and t ∈ N∪U .\nWe say a formula α is ground, if all its atoms are ground and for all occurrences of form @tβ in α it holds that t ∈ N. In the following semantics definition, we will consider the input stream (urstream) which remains unchanged, as well as dynamic substreams thereof which are obtained by (possibly nested) applications of window functions. To this end, we define a stream choice to be a function that returns a stream based on two input streams.Two straightforward stream choices are chi, for i ∈ {1, 2}, defined by chi(S1, S2) = Si. Given a stream choice ch, we obtain for any window function w an extended window function ŵ by ŵ(S1, S2, t) = w(ch(S1, S2), t) for all t ∈ N. We say ŵ is the extension of w (due to ch).\nDefinition 7 (Structure) Let SM = (T, υ) be a stream, I ⊆ N a finite index set and let Ŵ be a function that maps every i ∈ I to an extended window function. The triple M = 〈T, υ, Ŵ 〉 is called a structure and SM is called the urstream of M .\nWe now define when a ground formula holds in a structure.\nDefinition 8 (Entailment) Let M = 〈T, υ, Ŵ 〉 be a structure. For a substream S = (TS, υS) of (T, υ), we define the entailment relation between (M,S, t) and formulas. Let t ∈ T , a ∈ G, and α, β ∈ Fk be ground formulas and let ŵi = Ŵ(i). Then,\nM,S, t a iff a ∈ υS(t) , M, S, t ¬α iff M,S, t 1 α, M, S, t α ∧ β iff M,S, t α and M,S, t β, M, S, t α ∨ β iff M,S, t α or M,S, t β, M, S, t α→ β iff M,S, t 1 α or M,S, t β, M, S, t 3α iff M,S, t′ α for some t′∈ TS, M, S, t 2α iff M,S, t′ α for all t′∈ TS , M, S, t @t′α iff M,S, t′ α and t′∈ TS , M, S, t iα iff M,S′, t α where S′ = ŵi(SM , S, t).\nIf M,S, t α holds, we say (M,S, t) entails α. Intuitively, M contains the urstream SM which remains unchanged and S is the currently considered window. An application of a window operator i utilizes the extended window Ŵ(i) which can take into account both the urstream SM and the current window S to obtain a new view, as we will discuss later. The operators 3 and 2 are used to evaluate whether a formula holds at some time point, respectively at all time points in the timeline TS of S. The operator @t allows to evaluate whether a formula holds at a specific time point t in TS .\nExample 6 (cont’d) Let M = 〈T, υ, Ŵ 〉, where SM = (T, υ) is the stream S from Example 2 and Ŵ(1) = ŵ5, i.e., the extension of w5 of Example 3 due to ch2. Consider the following formula:\nα = 1(3tr(d, p2) ∧3bus(e, p2))\nWe verify that M,SM , 11 α holds. First, the window operator 1 selects the substream S′ = (TS′ , υ′), where TS′ = [6, 11] and υ′ = υ|T ′ = {8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}. Next, to see that (M,S′, 11) entails 3tr(d, p2) ∧3bus(e, p2), we have to find time points in the timeline TS′ of the current window S′, such that tr(d, p2) and bus(e, p2) hold, respectively. Indeed, for 8 and 11, we have M,S1, 8 tr(d, p2) and M,S1, 11 bus(e, p2).\nWe are now going to define the semantics of queries over streams.\nDefinition 9 (Query) Let S = (T, υ) be a stream, u ∈ T ∪ U and let α be a formula. Then α[u] denotes a query (on S). We say a query is ground, if α is ground and u ∈ T , else non-ground.\nFor the evaluation of a ground query α[t] we will use M,SM , t α. To define the semantics of non-ground queries, we need the notions of assignments and substitution. A variable assignment σ is a mapping V → C from variables to constants. A time variable assignment τ is a mapping U → N from time variables to time points. The pair (σ, τ) is called a query assignment. Table 1 defines the substitution Θ based on query assignment (σ, τ), where α, β ∈ Fk.\nLet q = α[u] be a query on S = (T, υ). We say a substitution Θ grounds q, if Θ(q) is ground, i.e., if Θ maps all variables and time variables occurring in q. If, in addition, τ(x) ∈ T for every time variable x ∈ U occurring in q, we say Θ is compatible with q.\nDefinition 10 (Answer) The answer ?q to a query q = α[t] on S is defined as follows. If q is ground, then ?q = yes if M,SM , t q holds, and ?q = no otherwise. If q is non-ground, then\n?q = {(σ, τ) | Θ is compatible with q and ?Θ(q) = yes}.\nThat is, the answer to a non-ground query is the set of query substitutions such that the obtained ground queries hold.\nExample 7 (cont’d) We formalize the queries of Ex. 1 as follows:\nq1 = 1(3tr(X,P ) ∧3bus(Y, P ))[u] q2 = 13(tr(X,P ) ∧ bus(Y, P ))[u]\nThe query q = 13(tr(a, p1) ∧ bus(c, p1))[t] is ground iff t ∈ N and ?q = yes iff t ∈ [2, 7]. We evaluate q1 on structure M of Ex. 6:\nM,SM , t 1(3tr(a, p1) ∧3bus(c, p1)) for all t ∈ [2, 7] M,SM , t 1(3tr(d, p2) ∧3bus(e, p2)) for all t ∈ [11, 13]\nThus, the following set of substitutions is the answer to q1 in M :\n?q1 = {({X 7→a, Y 7→c, P 7→p1}, {u 7→ t}) | t ∈ [2, 7]}∪ {({X 7→d, Y 7→e, P 7→p2}, {u 7→ t}) | t ∈ [11, 13]}\nExact time reference. With the operator @t we can ask whether a formula holds at a specific time point t. In its non-ground version, we can utilize this operator for the selection of time points.\nExample 8 (cont’d) Let α = tram(X,P ) ∧ bus(Y, P ). For each of the queries @Uα[13] and α[U ], the time assignments for U in the answers will map to time points when a tram and a bus arrived simultaneously at the same stop. In both cases, the single answer is ({X 7→ a, Y 7→ c, P 7→ p1}, {U 7→ 2}). Note that omitting @U in the first query would give an empty answer, since the subformula α does not hold at time point 13.\nWe observe that the operator @ allows to replay a historic query. At any time t′ > t, we can ask @tα[t′] to simulate a previous query α[t].\nNested windows. Typically, window functions are used exclusively to restrict the processing of streams to a recent subset of the input. In our view, window functions provide a flexible means to reason over temporally local contexts within larger windows. For these nested windows we carry both M and S for the entailment relation.\nExample 9 (cont’d) Consider the following additional query (q3): At which stops P , for the last 2 two trams X , did a bus Y arrive within 3 minutes? To answer (q3) at time point 13, we ask\nq3 = 12(tr(X,P )→ 23bus(Y, P ))[13].\nFor 1, we can use the extension ŵ#nidx of the partition-based window w#nidx of Example 5. Applying Ŵ(1) on the stream S = (T, υ) in the previous examples yields S′ = (T ′, υ′), where T ′ = [2, 13] and υ′ = {2 7→ {tr(a, p1)}, 8 7→ {tr(d, p2)}}. That is, after applying this window, the current window S′ no longer contains information on buses. Consequently, to check whether a bus came in both cases within 3 minutes, we must use the urstream SM . Thus, the second extended window Ŵ(2) = ŵ+3 is the extension of the timebased window w+3, which looks 3 minutes into the future, due to the stream choice ch1. Hence, ŵ+3 will create a window based on SM and not on S′. The two time points in T ′ where a tram appears are 2 and 8, with P matching p1 and p2, respectively. Applying Ŵ(2) there yields the streams S′′2 = (T ′′2 , υ′′2 ) and S′′8 = (T ′′8 , υ′′8 ), where\nT ′′2 = [2, 5], υ ′′ 2 = {2 7→ {tr(a, p1), bus(c, p1)}}, and T ′′8 = [8, 11], υ ′′ 8 = {8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}.\nIn both streams, we find a time point with an atom bus(Y, pj) with the same stop pj as the tram. Thus, in both cases the subformula 3bus(Y, P ) is satisfied and so the implication tr(X,P )→ 23bus(Y, P ) holds at every point in time of the stream selected by 1. Hence, the answer to the query is\n?q3 = {{(X 7→ a, Y 7→ c, P 7→ p1}, ∅)}, {(X 7→ d, Y 7→ e, P 7→ p2}, ∅)}}."
    }, {
      "heading" : "4 Discussion and Related Work",
      "text" : "In this section we discuss the relationship of this ongoing work with existing approaches from different communities.\nModal logic. The presented formalism employs operators 3 and 2 as in modal logic [6]. Also, the definition of entailment uses a structure similar to Kripke models for multi-modal logics. However, instead of static accessibility relations, we use window functions which take into account not only the worlds (i.e., the time points) but also the interpretation function. To our best knowledge, window operators have been considered neither in modal logics nor temporal logics.\nCQL. By extending SQL to deal with input streams, CQL queries are evaluated based on three sets of operators:\n(i) Stream-to-relation operators apply window functions to the input stream to create a mapping from execution times to bags of valid tuples (w.r.t. the window) without timestamps. This mapping is called a relation.\n(ii) Relation-to-relation operators allow for modification of relations similarly as in relational algebra, respectively SQL.\n(iii) Relation-to-stream operators convert relations to streams by directly associating the timestamp of the execution with each tuple (RStream). The other operators IStream/DStream, which report inserted/deleted tuples, are derived from RStream.\nThe proposed semantics has means to capture these operators:\n(i) The window operators i keep the timestamps of the selected atoms, whereas the stream-to-relation operator discards them. The CQL query for tuple x thus corresponds to a query 3x of the present setting. A stream in CQL belongs to a fixed schema. As noted earlier, this corresponds to the special case with only one predicate. CQL’s partition-based window is a generalization of the tuple-based window defined there. In turn, the presented partition-based window generalizes the one of CQL.\n(ii) Some relational operators can essentially be captured by logical connectives, e.g., the join by conjunction. Some operators like projection will require an extension of the formalism towards rules. Moreover, we did not consider arithmetic operators and aggregation functions, which CQL inherits from SQL.\n(iii) The answer to a non-ground query α[u] is a set of query assignments (σ, τ). To capture the RStream of CQL, we can group these assignments by the time variable u.\nExample 10 Queries (q1) and (q2) from Example 1 can be expressed in CQL. We assume that both streams have the attributesX and P , corresponding to the first, respectively second argument of predicates tr and bus . For (q1), we can use:\nSELECT * FROM tr [RANGE 5], bus [RANGE 5] WHERE tr.P = bus.P\nOn the other hand, (q2) needs two CQL queries.\nSELECT * AS tr_bus FROM tr [NOW], bus [NOW] WHERE tr.P = bus.P\nSELECT * FROM tr_bus [RANGE 5]\nHere, the first query produces a new stream that contains only simultaneous tuples and the second one covers the range of 5 minutes.\nTraditionally, stream reasoning approaches use continuous queries, i.e., repeated runs of queries with snapshot semantics to deal with changing information. In this work, we go a step further and enable reasoning over streams within the formalism itself by means of nested windows. One can only mimic this feature with CQL’s snapshot semantics when timestamps are part of the schema and explicitly encoded. Likewise, queries to future time points can be emulated in this way, as the next example shows.\nExample 11 (cont’d) In Example 9, we considered bus arrivals within 3 minutes after the last 2 trams. In CQL, such a query is not possible on the assumed schema. However, by adding a third attribute TS that carries the timestamps to the schema, the following CQL query yields the same results.\nSELECT * FROM tr [ROWS 2], bus [RANGE UNBOUNDED]\nWHERE tr.P = bus.P AND bus.TS - tr.TS <= 3\nNote that we need no partition-based window here, since trams and buses arrive from different input streams. Moreover, we must use the unbounded window for buses to cover nesting of windows in (q3) because windows in CQL are applied at query time and not the time where a tram appearance is notified.\nFurthermore, nested CQL queries and aggregation inherited from SQL are promising to mimic the behavior of operator 2. With according rewriting, CQL eingines like STREAM [2] could be used to realize the proposed semantics.\nSECRET. In [8] a model called SECRET is proposed to analyze the execution behavior of different stream processing engines (SPEs) from a practical point of view. The authors found that even the outcome of identical, simple queries vary significantly due to the different underlying processing models. There, the focus is on understanding, comparing and predicting the behaviour of engines. In contrast, we want to provide means that allow for a similar analytical study for the semantics of stream reasoning formalisms and engines. The two approaches are thus orthogonal and can be used together to compare stream reasoning engines based on different input feeding modes as well as different reasoning expressiveness.\nReactive ASP. The most recent work related to expressive stream reasoning with rules [11] is based on Reactive ASP [12]. This setting introduces logic programs that extend over time. Such programs have the following components. Two components P and Q are parametrized with a natural number t for time points. In addition, a basic component B encodes background knowledge that is not time-dependent. Moreover, sequences of pairs of arbitrary logic programs (Ei, Fj), called online progression are used. While P and Ei capture accumulated knowledge, Q and Fj are only valid at specific time points. Compared to reactive ASP, our semantics has no mechanism for accumulating programs, and we take only streams of atoms/facts, but no background theories. Therefore, a framework based on idealized semantics with extension to rules should be able to capture a fragment of reactive ASP where P and Fj are empty andEi contains only facts. The foreseeable conversion can be as follows: convert rules in Q by applying an unbounded window on all body atoms of a rule, using @t to query the truth value of the atoms at time point t. Then, conclude the head to be true at t and feed facts from Ei to the input stream S.\nStreamLog. Another logic-based approach towards stream reasoning is StreamLog [17]. It makes use of Datalog and introduces temporal predicates whose first arguments are timestamps. By introducing sequential programs which have syntactical restrictions on temporal rules, StreamLog defines non-blocking negation (for which Closed World Assumption can be safely applied) that can be used in recursive rules in a stream setting. Since sequential programs are locally stratified, they have efficiently computable perfect (i.e., unique) models. Similar to capturing a fragment of Reactive ASP, we can capture StreamLog by converting temporal atoms p(t, x1, . . . , xn) to expressions @tp(x1, . . . , xn) and employing safety conditions to rules to simulate non-blocking negation. Moreover, we plan for having weaker notions of negation that might block rules but just for a bounded number of time points to the future.\nETALIS. The ETALIS system [1] aims at adding expressiveness to Complex Event Processing (CEP). It provides a rule-based language for pattern matching over event streams with declarative monotonic semantics. Simultaneous events are not allowed and windows are not regarded as first-class objects in the semantics, but they are available at the system implementation level. Tuple-based windows are also not directly supported. Furthermore, nesting of windows is not possible within the language, but it can be emulated with multiple rules as in CQL. On the other hand, ETALIS models complex events with time intervals and has operators to express temporal relationships between events."
    }, {
      "heading" : "5 Conclusion",
      "text" : "We presented a first step towards a theoretical foundation for (idealistic) semantics of stream reasoning formalisms. Analytical tools to characterize, study and compare logical aspects of stream engines have been missing. To fill this gap, we provide a framework to reason over streaming data with a fine-grained control over relating the truth of tuples with their occurrences in time. It thus, e.g., allows to capture various kinds of window applications on data streams. We discussed the relationship of the proposed formalism with exsisting approaches, namely CQL, SECRET, Reactive ASP, StreamLog, and ETALIS.\nNext steps include extensions of the framework to formally capture fragments of existing approaches. Towards more advanced reasoning features like recursion and non-monotonicity, we aim at a rule-based semantics on top of the presented core. Furthermore, considering intervals of time as references is an interesting research issue. To improve practicality (as a tool for formal and experimental analysis) one might also develop an operational characterization of the framework. In a longer perspective, along the same lines with [7], we aim at a formalism for stream reasoning in distributed settings across heterogeneous nodes having potentially different logical capabilities."
    } ],
    "references" : [ {
      "title" : "Stream reasoning and complex event processing in ETALIS",
      "author" : [ "Darko Anicic", "Sebastian Rudolph", "Paul Fodor", "Nenad Stojanovic" ],
      "venue" : "Semantic Web Journal,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2012
    }, {
      "title" : "Stream: The stanford stream data manager",
      "author" : [ "Arvind Arasu", "Brian Babcock", "Shivnath Babu", "Mayur Datar", "Keith Ito", "Itaru Nishizawa", "Justin Rosenstein", "Jennifer Widom" ],
      "venue" : "in SIGMOD Conference,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2003
    }, {
      "title" : "The CQL continuous query language: semantic foundations and query execution",
      "author" : [ "Arvind Arasu", "Shivnath Babu", "Jennifer Widom" ],
      "venue" : "VLDB J.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2006
    }, {
      "title" : "Continuous queries over data streams",
      "author" : [ "Shivnath Babu", "Jennifer Widom" ],
      "venue" : "SIGMOD Record,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2001
    }, {
      "title" : "C-SPARQL: a continuous query language for rdf data streams",
      "author" : [ "Davide Francesco Barbieri", "Daniele Braga", "Stefano Ceri", "Emanuele Della Valle", "Michael Grossniklaus" ],
      "venue" : "Int. J. Semantic Computing,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2010
    }, {
      "title" : "Towards reactive multi-context systems",
      "author" : [ "Gerhard Brewka" ],
      "venue" : "in LPNMR, pp",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2013
    }, {
      "title" : "Modeling the execution semantics of stream processing engines with secret",
      "author" : [ "Nihal Dindar", "Nesime Tatbul", "Renée J. Miller", "Laura M. Haas", "Irina Botan" ],
      "venue" : "VLDB J.,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2013
    }, {
      "title" : "Answer set programming for stream reasoning",
      "author" : [ "Thang M. Do", "Seng Wai Loke", "Fei Liu" ],
      "venue" : "in AI, pp",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "dlvhex: A prover for semantic-web reasoning under the answer-set semantics",
      "author" : [ "Thomas Eiter", "Giovambattista Ianni", "Roman Schindlauer", "Hans Tompits" ],
      "venue" : "in Web Intelligence,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2006
    }, {
      "title" : "Stream reasoning with answer set programming",
      "author" : [ "Martin Gebser", "Torsten Grote", "Roland Kaminski", "Philipp Obermeier", "Orkunt Sabuncu", "Torsten Schaub" ],
      "venue" : "in KR,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2012
    }, {
      "title" : "Reactive answer set programming",
      "author" : [ "Martin Gebser", "Torsten Grote", "Roland Kaminski", "Torsten Schaub" ],
      "venue" : "in LPNMR, pp",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2011
    }, {
      "title" : "Engineering an incremental asp solver",
      "author" : [ "Martin Gebser", "Roland Kaminski", "Benjamin Kaufmann", "Max Ostrowski", "Torsten Schaub", "Sven Thiele" ],
      "venue" : "in ICLP,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2008
    }, {
      "title" : "Linked stream data processing engines: Facts and figures",
      "author" : [ "Danh Le Phuoc", "Minh Dao-Tran", "Minh-Duc Pham", "Peter Boncz", "Thomas Eiter", "Michael Fink" ],
      "venue" : "ISWC - ET,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "It’s a streaming world! reasoning upon rapidly changing information",
      "author" : [ "Emanuele Della Valle", "Stefano Ceri", "Frank van Harmelen", "Dieter Fensel" ],
      "venue" : "IEEE Intelligent Systems,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2009
    }, {
      "title" : "Logical foundations of continuous query languages for data streams",
      "author" : [ "Carlo Zaniolo" ],
      "venue" : "in Datalog,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : "In the setting of stream processing [4] studied by the database community, input tuples dynamically arrive at the processing systems in form of possibly infinite streams.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 2,
      "context" : "The Continuous Query Language (CQL) [3] is a well-known stream processing language.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 13,
      "context" : ", has raised interest in the topic of stream reasoning [16], i.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 4,
      "context" : "Engines such as CQELS [14] and C-SPARQL [5] also follow the snapshot semantics approach of CQL.",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 7,
      "context" : "(ii) In Knowledge Representation and Reasoning (KRR), first attempts towards expressive stream reasoning have been carried out by considering continuous data in Answer Set Programming (ASP) [9, 11] or extending Datalog to sequential logic programs [17].",
      "startOffset" : 190,
      "endOffset" : 197
    }, {
      "referenceID" : 9,
      "context" : "(ii) In Knowledge Representation and Reasoning (KRR), first attempts towards expressive stream reasoning have been carried out by considering continuous data in Answer Set Programming (ASP) [9, 11] or extending Datalog to sequential logic programs [17].",
      "startOffset" : 190,
      "endOffset" : 197
    }, {
      "referenceID" : 14,
      "context" : "(ii) In Knowledge Representation and Reasoning (KRR), first attempts towards expressive stream reasoning have been carried out by considering continuous data in Answer Set Programming (ASP) [9, 11] or extending Datalog to sequential logic programs [17].",
      "startOffset" : 248,
      "endOffset" : 252
    }, {
      "referenceID" : 7,
      "context" : "The plain approach of [9] periodically calls the dlvhex solver [10] but is not capable of incremental reasoning and thus fails under heavy load of data.",
      "startOffset" : 22,
      "endOffset" : 25
    }, {
      "referenceID" : 8,
      "context" : "The plain approach of [9] periodically calls the dlvhex solver [10] but is not capable of incremental reasoning and thus fails under heavy load of data.",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 14,
      "context" : "StreamLog [17] is an extension of Datalog towards stream reasoning.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 9,
      "context" : "Time-decaying logic programs [11] attempt to implement time-based windows in reactive ASP [13] but the relation to other stream processing/reasoning approaches has not yet been explored.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 11,
      "context" : "Time-decaying logic programs [11] attempt to implement time-based windows in reactive ASP [13] but the relation to other stream processing/reasoning approaches has not yet been explored.",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 6,
      "context" : "Moreover, as observed in [8], conceptually identical queries may produce different results in different engines.",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 12,
      "context" : "Investigations of specific languages, as well as comparisons between different approaches, are confined to experimental analysis [15], or informal examination on specific examples.",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 11,
      "context" : "Example 2 (cont’d) The input for the scenario in Example 1 can be modeled as a stream S = (T, υ) where T = [0, 13] and",
      "startOffset" : 107,
      "endOffset" : 114
    }, {
      "referenceID" : 2,
      "context" : "The usual time-based window of size ` [3] contains only the tuples of the last ` time units.",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 2,
      "context" : "The CQL [3] syntax for w d is [Range l Slide d] and w ` corresponds to [Range l].",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 4,
      "context" : "w(S, 5) = ([0, 5], {2 7→ {tr(a, p1), bus(c, p1)}}), and w(S, 11) = ([6, 11], {8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}).",
      "startOffset" : 11,
      "endOffset" : 17
    }, {
      "referenceID" : 9,
      "context" : "w(S, 5) = ([0, 5], {2 7→ {tr(a, p1), bus(c, p1)}}), and w(S, 11) = ([6, 11], {8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}).",
      "startOffset" : 68,
      "endOffset" : 75
    }, {
      "referenceID" : 0,
      "context" : "For t1 = 5, we have t1 = b 53c · 3 = 3, thus T ′ 1 = [max{0, 3− 2},min{3 + 1, 13}] = [1, 4].",
      "startOffset" : 85,
      "endOffset" : 91
    }, {
      "referenceID" : 3,
      "context" : "For t1 = 5, we have t1 = b 53c · 3 = 3, thus T ′ 1 = [max{0, 3− 2},min{3 + 1, 13}] = [1, 4].",
      "startOffset" : 85,
      "endOffset" : 91
    }, {
      "referenceID" : 5,
      "context" : "For t2 = 11, we get t2 = 9 and T ′ 2 = [7, 10].",
      "startOffset" : 39,
      "endOffset" : 46
    }, {
      "referenceID" : 8,
      "context" : "For t2 = 11, we get t2 = 9 and T ′ 2 = [7, 10].",
      "startOffset" : 39,
      "endOffset" : 46
    }, {
      "referenceID" : 0,
      "context" : "w 3 (S, 5) = ([1, 4], {2 7→ {tr(a, p1), bus(c, p1)}}), and w 3 (S, 11) = ([7, 10], {8 7→ {tr(d, p2))}}).",
      "startOffset" : 14,
      "endOffset" : 20
    }, {
      "referenceID" : 3,
      "context" : "w 3 (S, 5) = ([1, 4], {2 7→ {tr(a, p1), bus(c, p1)}}), and w 3 (S, 11) = ([7, 10], {8 7→ {tr(d, p2))}}).",
      "startOffset" : 14,
      "endOffset" : 20
    }, {
      "referenceID" : 5,
      "context" : "w 3 (S, 5) = ([1, 4], {2 7→ {tr(a, p1), bus(c, p1)}}), and w 3 (S, 11) = ([7, 10], {8 7→ {tr(d, p2))}}).",
      "startOffset" : 74,
      "endOffset" : 81
    }, {
      "referenceID" : 8,
      "context" : "w 3 (S, 5) = ([1, 4], {2 7→ {tr(a, p1), bus(c, p1)}}), and w 3 (S, 11) = ([7, 10], {8 7→ {tr(d, p2))}}).",
      "startOffset" : 74,
      "endOffset" : 81
    }, {
      "referenceID" : 1,
      "context" : "The application w(S, 11) can lead to two possible windows (T ′, υ′ 1) and (T ′, υ′ 2), where T ′ = [2, 11], and",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 9,
      "context" : "The application w(S, 11) can lead to two possible windows (T ′, υ′ 1) and (T ′, υ′ 2), where T ′ = [2, 11], and",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 1,
      "context" : "S1 = ([2, 13], {2 7→ {tr(a, p1)}, 8 7→ {tr(d, p2)}}), and S2 = ([2, 13], {2 7→ {bus(c, p1)}, 11 7→ {bus(e, p2)}}),",
      "startOffset" : 6,
      "endOffset" : 13
    }, {
      "referenceID" : 11,
      "context" : "S1 = ([2, 13], {2 7→ {tr(a, p1)}, 8 7→ {tr(d, p2)}}), and S2 = ([2, 13], {2 7→ {bus(c, p1)}, 11 7→ {bus(e, p2)}}),",
      "startOffset" : 6,
      "endOffset" : 13
    }, {
      "referenceID" : 1,
      "context" : "S1 = ([2, 13], {2 7→ {tr(a, p1)}, 8 7→ {tr(d, p2)}}), and S2 = ([2, 13], {2 7→ {bus(c, p1)}, 11 7→ {bus(e, p2)}}),",
      "startOffset" : 64,
      "endOffset" : 71
    }, {
      "referenceID" : 11,
      "context" : "S1 = ([2, 13], {2 7→ {tr(a, p1)}, 8 7→ {tr(d, p2)}}), and S2 = ([2, 13], {2 7→ {bus(c, p1)}, 11 7→ {bus(e, p2)}}),",
      "startOffset" : 64,
      "endOffset" : 71
    }, {
      "referenceID" : 1,
      "context" : "w(S1, 13) = ([2, 13], {2 7→{tr(a, p1)}, 8 7→{tr(d, p2)}}), and w(S2, 13) = ([13, 13], ∅).",
      "startOffset" : 13,
      "endOffset" : 20
    }, {
      "referenceID" : 11,
      "context" : "w(S1, 13) = ([2, 13], {2 7→{tr(a, p1)}, 8 7→{tr(d, p2)}}), and w(S2, 13) = ([13, 13], ∅).",
      "startOffset" : 13,
      "endOffset" : 20
    }, {
      "referenceID" : 11,
      "context" : "w(S1, 13) = ([2, 13], {2 7→{tr(a, p1)}, 8 7→{tr(d, p2)}}), and w(S2, 13) = ([13, 13], ∅).",
      "startOffset" : 76,
      "endOffset" : 84
    }, {
      "referenceID" : 11,
      "context" : "w(S1, 13) = ([2, 13], {2 7→{tr(a, p1)}, 8 7→{tr(d, p2)}}), and w(S2, 13) = ([13, 13], ∅).",
      "startOffset" : 76,
      "endOffset" : 84
    }, {
      "referenceID" : 1,
      "context" : "Consequently, we get w idx (S, 13) = ([2, 13], υ ′), where υ′ is",
      "startOffset" : 38,
      "endOffset" : 45
    }, {
      "referenceID" : 11,
      "context" : "Consequently, we get w idx (S, 13) = ([2, 13], υ ′), where υ′ is",
      "startOffset" : 38,
      "endOffset" : 45
    }, {
      "referenceID" : 9,
      "context" : "First, the window operator 1 selects the substream S′ = (TS′ , υ′), where TS′ = [6, 11] and υ′ = υ|T ′ = {8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}.",
      "startOffset" : 80,
      "endOffset" : 87
    }, {
      "referenceID" : 1,
      "context" : "The query q = 13(tr(a, p1) ∧ bus(c, p1))[t] is ground iff t ∈ N and ?q = yes iff t ∈ [2, 7].",
      "startOffset" : 85,
      "endOffset" : 91
    }, {
      "referenceID" : 5,
      "context" : "The query q = 13(tr(a, p1) ∧ bus(c, p1))[t] is ground iff t ∈ N and ?q = yes iff t ∈ [2, 7].",
      "startOffset" : 85,
      "endOffset" : 91
    }, {
      "referenceID" : 1,
      "context" : "M,SM , t 1(3tr(a, p1) ∧3bus(c, p1)) for all t ∈ [2, 7] M,SM , t 1(3tr(d, p2) ∧3bus(e, p2)) for all t ∈ [11, 13]",
      "startOffset" : 48,
      "endOffset" : 54
    }, {
      "referenceID" : 5,
      "context" : "M,SM , t 1(3tr(a, p1) ∧3bus(c, p1)) for all t ∈ [2, 7] M,SM , t 1(3tr(d, p2) ∧3bus(e, p2)) for all t ∈ [11, 13]",
      "startOffset" : 48,
      "endOffset" : 54
    }, {
      "referenceID" : 9,
      "context" : "M,SM , t 1(3tr(a, p1) ∧3bus(c, p1)) for all t ∈ [2, 7] M,SM , t 1(3tr(d, p2) ∧3bus(e, p2)) for all t ∈ [11, 13]",
      "startOffset" : 103,
      "endOffset" : 111
    }, {
      "referenceID" : 11,
      "context" : "M,SM , t 1(3tr(a, p1) ∧3bus(c, p1)) for all t ∈ [2, 7] M,SM , t 1(3tr(d, p2) ∧3bus(e, p2)) for all t ∈ [11, 13]",
      "startOffset" : 103,
      "endOffset" : 111
    }, {
      "referenceID" : 1,
      "context" : "?q1 = {({X 7→a, Y 7→c, P 7→p1}, {u 7→ t}) | t ∈ [2, 7]}∪ {({X 7→d, Y 7→e, P 7→p2}, {u 7→ t}) | t ∈ [11, 13]}",
      "startOffset" : 48,
      "endOffset" : 54
    }, {
      "referenceID" : 5,
      "context" : "?q1 = {({X 7→a, Y 7→c, P 7→p1}, {u 7→ t}) | t ∈ [2, 7]}∪ {({X 7→d, Y 7→e, P 7→p2}, {u 7→ t}) | t ∈ [11, 13]}",
      "startOffset" : 48,
      "endOffset" : 54
    }, {
      "referenceID" : 9,
      "context" : "?q1 = {({X 7→a, Y 7→c, P 7→p1}, {u 7→ t}) | t ∈ [2, 7]}∪ {({X 7→d, Y 7→e, P 7→p2}, {u 7→ t}) | t ∈ [11, 13]}",
      "startOffset" : 99,
      "endOffset" : 107
    }, {
      "referenceID" : 11,
      "context" : "?q1 = {({X 7→a, Y 7→c, P 7→p1}, {u 7→ t}) | t ∈ [2, 7]}∪ {({X 7→d, Y 7→e, P 7→p2}, {u 7→ t}) | t ∈ [11, 13]}",
      "startOffset" : 99,
      "endOffset" : 107
    }, {
      "referenceID" : 11,
      "context" : "For each of the queries @Uα[13] and α[U ], the time assignments for U in the answers will map to time points when a tram and a bus arrived simultaneously at the same stop.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 11,
      "context" : "q3 = 12(tr(X,P )→ 23bus(Y, P ))[13].",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 1,
      "context" : "Applying Ŵ(1) on the stream S = (T, υ) in the previous examples yields S′ = (T ′, υ′), where T ′ = [2, 13] and υ′ = {2 7→ {tr(a, p1)}, 8 7→ {tr(d, p2)}}.",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 11,
      "context" : "Applying Ŵ(1) on the stream S = (T, υ) in the previous examples yields S′ = (T ′, υ′), where T ′ = [2, 13] and υ′ = {2 7→ {tr(a, p1)}, 8 7→ {tr(d, p2)}}.",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 1,
      "context" : "T ′′ 2 = [2, 5], υ ′′ 2 = {2 7→ {tr(a, p1), bus(c, p1)}}, and T ′′ 8 = [8, 11], υ ′′ 8 = {8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}.",
      "startOffset" : 9,
      "endOffset" : 15
    }, {
      "referenceID" : 4,
      "context" : "T ′′ 2 = [2, 5], υ ′′ 2 = {2 7→ {tr(a, p1), bus(c, p1)}}, and T ′′ 8 = [8, 11], υ ′′ 8 = {8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}.",
      "startOffset" : 9,
      "endOffset" : 15
    }, {
      "referenceID" : 6,
      "context" : "T ′′ 2 = [2, 5], υ ′′ 2 = {2 7→ {tr(a, p1), bus(c, p1)}}, and T ′′ 8 = [8, 11], υ ′′ 8 = {8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}.",
      "startOffset" : 71,
      "endOffset" : 78
    }, {
      "referenceID" : 9,
      "context" : "T ′′ 2 = [2, 5], υ ′′ 2 = {2 7→ {tr(a, p1), bus(c, p1)}}, and T ′′ 8 = [8, 11], υ ′′ 8 = {8 7→ {tr(d, p2)}, 11 7→ {bus(e, p2)}}.",
      "startOffset" : 71,
      "endOffset" : 78
    }, {
      "referenceID" : 1,
      "context" : "With according rewriting, CQL eingines like STREAM [2] could be used to realize the proposed semantics.",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 6,
      "context" : "In [8] a model called SECRET is proposed to analyze the execution behavior of different stream processing engines (SPEs) from a practical point of view.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 9,
      "context" : "The most recent work related to expressive stream reasoning with rules [11] is based on Reactive ASP [12].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 10,
      "context" : "The most recent work related to expressive stream reasoning with rules [11] is based on Reactive ASP [12].",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 14,
      "context" : "Another logic-based approach towards stream reasoning is StreamLog [17].",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 0,
      "context" : "The ETALIS system [1] aims at adding expressiveness to Complex Event Processing (CEP).",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 5,
      "context" : "In a longer perspective, along the same lines with [7], we aim at a formalism for stream reasoning in distributed settings across heterogeneous nodes having potentially different logical capabilities.",
      "startOffset" : 51,
      "endOffset" : 54
    } ],
    "year" : 2015,
    "abstractText" : "The rise of smart applications has drawn interest to logical reasoning over data streams. Recently, different query languages and stream processing/reasoning engines were proposed in different communities. However, due to a lack of theoretical foundations, the expressivity and semantics of these diverse approaches are given only informally. Towards clear specifications and means for analytic study, a formal framework is needed to define their semantics in precise terms. To this end, we present a first step towards an ideal semantics that allows for exact descriptions and comparisons of stream reasoning systems.",
    "creator" : "LaTeX with hyperref package"
  }
}