{
  "name" : "1606.03657.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "InfoGAN: Interpretable Representation Learning by Information Maximizing Generative Adversarial Nets",
    "authors" : [ "Xi Chen", "Yan Duan", "Rein Houthooft", "John Schulman", "Ilya Sutskever", "Pieter Abbeel" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "This paper describes InfoGAN, an information-theoretic extension to the Generative Adversarial Network that is able to learn disentangled representations in a completely unsupervised manner. InfoGAN is a generative adversarial network that also maximizes the mutual information between a small subset of the latent variables and the observation. We derive a lower bound of the mutual information objective that can be optimized efficiently. Specifically, InfoGAN successfully disentangles writing styles from digit shapes on the MNIST dataset, pose from lighting of 3D rendered images, and background digits from the central digit on the SVHN dataset. It also discovers visual concepts that include hair styles, presence/absence of eyeglasses, and emotions on the CelebA face dataset. Experiments show that InfoGAN learns interpretable representations that are competitive with representations learned by existing supervised methods."
    }, {
      "heading" : "1 Introduction",
      "text" : "Unsupervised learning can be described as the general problem of extracting value from unlabelled data which exists in vast quantities. A popular framework for unsupervised learning is that of representation learning [1, 2], whose goal is to use unlabelled data to learn a representation that exposes important semantic features as easily decodable factors. A method that can learn such representations is likely to exist [2], and to be useful for many downstream tasks which include classification, regression, visualization, and policy learning in reinforcement learning.\nWhile unsupervised learning is ill-posed because the relevant downstream tasks are unknown at training time, a disentangled representation, one which explicitly represents the salient attributes of a data instance, should be helpful for the relevant but unknown tasks. For example, for a dataset of faces, a useful disentangled representation may allocate a separate set of dimensions for each of the following attributes: facial expression, eye color, hairstyle, presence or absence of eyeglasses, and the identity of the corresponding person. A disentangled representation can be useful for natural tasks that require knowledge of the salient attributes of the data, which include tasks like face recognition and object recognition. It is not the case for unnatural supervised tasks, where the goal could be, for example, to determine whether the number of red pixels in an image is even or odd. Thus, to be useful, an unsupervised learning algorithm must in effect correctly guess the likely set of downstream classification tasks without being directly exposed to them.\nA significant fraction of unsupervised learning research is driven by generative modelling. It is motivated by the belief that the ability to synthesize, or “create” the observed data entails some form of understanding, and it is hoped that a good generative model will automatically learn a disentangled representation, even though it is easy to construct perfect generative models with arbitrarily bad representations. The most prominent generative models are the variational autoencoder (VAE) [3] and the generative adversarial network (GAN) [4].\nar X\niv :1\n60 6.\n03 65\n7v 1\n[ cs\n.L G\n] 1\n2 Ju\nn 20\nIn this paper, we present a simple modification to the generative adversarial network objective that encourages it to learn interpretable and meaningful representations. We do so by maximizing the mutual information between a fixed small subset of the GAN’s noise variables and the observations, which turns out to be relatively straightforward. Despite its simplicity, we found our method to be surprisingly effective: it was able to discover highly semantic and meaningful hidden representations on a number of image datasets: digits (MNIST), faces (CelebA), and house numbers (SVHN). The quality of our unsupervised disentangled representation matches previous works that made use of supervised label information [5–9]. These results suggest that generative modelling augmented with a mutual information cost could be a fruitful approach for learning disentangled representations.\nIn the remainder of the paper, we begin with a review of the related work, noting the supervision that is required by previous methods that learn disentangled representations. Then we review GANs, which is the basis of InfoGAN. We describe how maximizing mutual information results in interpretable representations and derive a simple and efficient algorithm for doing so. Finally, in the experiments section, we first compare InfoGAN with prior approaches on relatively clean datasets and then show that InfoGAN can learn interpretable representations on complex datasets where no previous unsupervised approach is known to learn representations of comparable quality."
    }, {
      "heading" : "2 Related Work",
      "text" : "There exists a large body of work on unsupervised representation learning. Early methods were based on stacked (often denoising) autoencoders or restricted Boltzmann machines [10–13]. A lot of promising recent work originates from the Skip-gram model [14], which inspired the skip-thought vectors [15] and several techniques for unsupervised feature learning of images [16].\nAnother intriguing line of work consists of the ladder network [17], which has achieved spectacular results on a semi-supervised variant of the MNIST dataset. More recently, a model based on the VAE has achieved even better semi-supervised results on MNIST [18]. GANs [4] have been used by Radford et al. [19] to learn an image representation that supports basic linear algebra on code space. Lake et al. [20] have been able to learn representations using probabilistic inference over Bayesian programs, which achieved convincing one-shot learning results on the OMNI dataset.\nIn addition, prior research attempted to learn disentangled representations using supervised data. One class of such methods trains a subset of the representation to match the supplied label using supervised learning: bilinear models [21] separate style and content; multi-view perceptron [22] separate face identity and view point; and Yang et al. [23] developed a recurrent variant that generates a sequence of latent factor transformations. Similarly, VAEs [5] and Adversarial Autoencoders [9] were shown to learn representations in which class label is separated from other variations.\nRecently several weakly supervised methods were developed to remove the need of explicitly labeling variations. disBM [24] is a higher-order Boltzmann machine which learns a disentangled representation by “clamping” a part of the hidden units for a pair of data points that are known to match in all but one factors of variation. DC-IGN [7] extends this “clamping” idea to VAE and successfully learns graphics codes that can represent pose and light in 3D rendered images. This line of work yields impressive results, but they rely on a supervised grouping of the data that is generally not available. Whitney et al. [8] proposed to alleviate the grouping requirement by learning from consecutive frames of images and use temporal continuity as supervisory signal.\nUnlike the cited prior works that strive to recover disentangled representations, InfoGAN requires no supervision of any kind. To the best of our knowledge, the only other unsupervised method that learns disentangled representations is hossRBM [13], a higher-order extension of the spike-and-slab restricted Boltzmann machine that can disentangle emotion from identity on the Toronto Face Dataset [25]. However, hossRBM can only disentangle discrete latent factors, and its computation cost grows exponentially in the number of factors. InfoGAN can disentangle both discrete and continuous latent factors, scale to complicated datasets, and typically requires no more training time than regular GAN."
    }, {
      "heading" : "3 Background: Generative Adversarial Networks",
      "text" : "Goodfellow et al. [4] introduced the Generative Adversarial Networks (GAN), a framework for training deep generative models using a minimax game. The goal is to learn a generator distribution\nPG(x) that matches the real data distribution Pdata(x). Instead of trying to explicitly assign probability to every x in the data distribution, GAN learns a generator network G that generates samples from the generator distribution PG by transforming a noise variable z ∼ Pnoise(z) into a sample G(z). This generator is trained by playing against an adversarial discriminator network D that aims to distinguish between samples from the true data distribution Pdata and the generator’s distribution PG. So for a given generator, the optimal discriminator is D(x) = Pdata(x)/(Pdata(x) + PG(x)). More formally, the minimax game is given by the following expression:\nmin G max D\nV (D,G) = Ex∼Pdata [logD(x)] + Ez∼noise[log (1−D(G(z)))] (1)"
    }, {
      "heading" : "4 Mutual Information for Inducing Latent Codes",
      "text" : "The GAN formulation uses a simple factored continuous input noise vector z, while imposing no restrictions on the manner in which the generator may use this noise. As a result, it is possible that the noise will be used by the generator in a highly entangled way, causing the individual dimensions of z to not correspond to semantic features of the data.\nHowever, many domains naturally decompose into a set of semantically meaningful factors of variation. For instance, when generating images from the MNIST dataset, it would be ideal if the model automatically chose to allocate a discrete random variable to represent the numerical identity of the digit (0-9), and chose to have two additional continuous variables that represent the digit’s angle and thickness of the digit’s stroke. It is the case that these attributes are both independent and salient, and it would be useful if we could recover these concepts without any supervision, by simply specifying that an MNIST digit is generated by an independent 1-of-10 variable and two independent continuous variables.\nIn this paper, rather than using a single unstructured noise vector, we propose to decompose the input noise vector into two parts: (i) z, which is treated as source of incompressible noise; (ii) c, which we will call the latent code and will target the salient structured semantic features of the data distribution.\nMathematically, we denote the set of structured latent variables by c1, c2, . . . , cL. In its simplest form, we may assume a factored distribution, given by P (c1, c2, . . . , cL) = ∏L i=1 P (ci). For ease of notation, we will use latent codes c to denote the concatenation of all latent variables ci.\nWe now propose a method for discovering these latent factors in an unsupervised way: we provide the generator network with both the incompressible noise z and the latent code c, so the form of the generator becomes G(z, c). However, in standard GAN, the generator is free to ignore the additional latent code c by finding a solution satisfying PG(x|c) = PG(x). To cope with the problem of trivial codes, we propose an information-theoretic regularization: there should be high mutual information between latent codes c and generator distribution G(z, c). Thus I(c;G(z, c)) should be high.\nIn information theory, mutual information between X and Y , I(X;Y ), measures the “amount of information” learned from knowledge of random variable Y about the other random variable X . The mutual information can be expressed as the difference of two entropy terms:\nI(X;Y ) = H(X)−H(X|Y ) = H(Y )−H(Y |X) (2)\nThis definition has an intuitive interpretation: I(X;Y ) is the reduction of uncertainty in X when Y is observed. If X and Y are independent, then I(X;Y ) = 0, because knowing one variable reveals nothing about the other; by contrast, if X and Y are related by a deterministic, invertible function, then maximal mutual information is attained. This interpretation makes it easy to formulate a cost: given any x ∼ PG(x), we want PG(c|x) to have a small entropy. In other words, the information in the latent code c should not be lost in the generation process. Similar mutual information inspired objectives have been considered before in the context of clustering [26–28]. Therefore, we propose to solve the following information-regularized minimax game:\nmin G max D\nVI(D,G) = V (D,G)− λI(c;G(z, c)) (3)"
    }, {
      "heading" : "5 Variational Mutual Information Maximization",
      "text" : "In practice, the mutual information term I(c;G(z, c)) is hard to maximize directly as it requires access to the posterior P (c|x). Fortunately we can obtain a lower bound of it by defining an auxiliary\ndistribution Q(c|x) to approximate P (c|x): I(c;G(z, c)) = H(c)−H(c|G(z, c))\n= Ex∼G(z,c)[Ec′∼P (c|x)[logP (c′|x)]] +H(c) = Ex∼G(z,c)[DKL(P (·|x) ‖ Q(·|x))︸ ︷︷ ︸\n≥0\n+Ec′∼P (c|x)[logQ(c′|x)]] +H(c)\n≥ Ex∼G(z,c)[Ec′∼P (c|x)[logQ(c′|x)]] +H(c)\n(4)\nThis technique of lower bounding mutual information is known as Variational Information Maximization [29]. We note in addition that the entropy of latent codes H(c) can be optimized over as well since for common distributions it has a simple analytical form. However, in this paper we opt for simplicity by fixing the latent code distribution and we will treat H(c) as a constant. So far we have bypassed the problem of having to compute the posterior P (c|x) explicitly via this lower bound but we still need to be able to sample from the posterior in the inner expectation. Next we state a simple lemma, with its proof deferred to Appendix, that removes the need to sample from the posterior.\nLemma 5.1 For random variables X,Y and function f(x, y) under suitable regularity conditions: Ex∼X,y∼Y |x[f(x, y)] = Ex∼X,y∼Y |x,x′∼X|y[f(x′, y)].\nBy using Lemma A.1, we can define a variational lower bound, LI(G,Q), of the mutual information, I(c;G(z, c)):\nLI(G,Q) = Ec∼P (c),x∼G(z,c)[logQ(c|x)] +H(c) = Ex∼G(z,c)[Ec′∼P (c|x)[logQ(c′|x)]] +H(c) ≤ I(c;G(z, c))\n(5)\nWe note that LI(G,Q) is easy to approximate with Monte Carlo simulation. In particular, LI can be maximized w.r.t. Q directly and w.r.t. G via the reparametrization trick. Hence LI(G,Q) can be added to GAN’s objectives with no change to GAN’s training procedure and we call the resulting algorithm Information Maximizing Generative Adversarial Networks (InfoGAN).\nEq (4) shows that the lower bound becomes tight as the auxiliary distribution Q approaches the true posterior distribution: Ex[DKL(P (·|x) ‖ Q(·|x))] → 0. In addition, we know that when the variational lower bound attains its maximum LI(G,Q) = H(c) for discrete latent codes, the bound becomes tight and the maximal mutual information is achieved. In Appendix, we note how InfoGAN can be connected to the Wake-Sleep algorithm [30] to provide an alternative interpretation.\nHence, InfoGAN is defined as the following minimax game with a variational regularization of mutual information and a hyperparameter λ:\nmin G,Q max D\nVInfoGAN(D,G,Q) = V (D,G)− λLI(G,Q) (6)"
    }, {
      "heading" : "6 Implementation",
      "text" : "In practice, we parametrize the auxiliary distribution Q as a neural network. In most experiments, Q and D share all convolutional layers and there is one final fully connected layer to output parameters for the conditional distribution Q(c|x), which means InfoGAN only adds a negligible computation cost to GAN. We have also observed that LI(G,Q) always converges faster than normal GAN objectives and hence InfoGAN essentially comes for free with GAN.\nFor categorical latent code ci, we use the natural choice of softmax nonlinearity to represent Q(ci|x). For continuous latent code cj , there are more options depending on what is the true posterior P (cj |x). In our experiments, we have found that simply treating Q(cj |x) as a factored Gaussian is sufficient. Even though InfoGAN introduces an extra hyperparameter λ, it’s easy to tune and simply setting to 1 is sufficient for discrete latent codes. When the latent code contains continuous variables, a smaller λ is typically used to ensure that λLI(G,Q), which now involves differential entropy, is on the same scale as GAN objectives.\nSince GAN is known to be difficult to train, we design our experiments based on existing techniques introduced by DC-GAN [19], which are enough to stabilize InfoGAN training and we did not have to introduce new trick. Detailed experimental setup is described in Appendix."
    }, {
      "heading" : "7 Experiments",
      "text" : "The first goal of our experiments is to investigate if mutual information can be maximized efficiently. The second goal is to evaluate if InfoGAN can learn disentangled and interpretable representations by making use of the generator to vary only one latent factor at a time in order to assess if varying such factor results in only one type of semantic variation in generated images. DC-IGN [7] also uses this method to evaluate their learned representations on 3D image datasets, on which we also apply InfoGAN to establish direct comparison.\n7.1 Mutual Information Maximization\nTo evaluate whether the mutual information between latent codes c and generated images G(z, c) can be maximized efficiently with proposed method, we train InfoGAN on MNIST dataset with a uniform categorical distribution on latent codes c ∼ Cat(K = 10, p = 0.1). In Fig 1, the lower bound LI(G,Q) is quickly maximized to H(c) ≈ 2.30, which means the bound (4) is tight and maximal mutual information is achieved.\nAs a baseline, we also train a regular GAN with an auxiliary distribution Q when the generator is not explicitly encouraged to maximize the mutual information with the latent codes. Since we use expressive neural network to parametrize Q, we can assume that Q reasonably approximates the true posterior P (c|x) and hence there is little mutual information between latent codes and generated images in regular GAN. We note that with a different neural network architecture, there\nmight be a higher mutual information between latent codes and generated images even though we have not observed such case in our experiments. This comparison is meant to demonstrate that in a regular GAN, there is no guarantee that the generator will make use of the latent codes."
    }, {
      "heading" : "7.2 Disentangled Representation",
      "text" : "To disentangle digit shape from styles on MNIST, we choose to model the latent codes with one categorical code, c1 ∼ Cat(K = 10, p = 0.1), which can model discontinuous variation in data, and two continuous codes that can capture variations that are continuous in nature: c2, c3 ∼ Unif(−1, 1). In Figure 2, we show that the discrete code c1 captures drastic change in shape. Changing categorical code c1 switches between digits most of the time. In fact even if we just train InfoGAN without any label, c1 can be used as a classifier that achieves 5% error rate in classifying MNIST digits by matching each category in c1 to a digit type. In the second row of Figure 2a, we can observe a digit 7 is classified as a 9.\nContinuous codes c2, c3 capture continuous variations in style: c2 models rotation of digits and c3 controls the width. What is remarkable is that in both cases, the generator does not simply stretch or rotate the digits but instead adjust other details like thickness or stroke style to make sure the resulting images are natural looking. As a test to check whether the latent representation learned by InfoGAN is generalizable, we manipulated the latent codes in an exaggerated way: instead of plotting latent codes from −1 to 1, we plot it from −2 to 2 covering a wide region that the network was never trained on and we still get meaningful generalization.\nNext we evaluate InfoGAN on two datasets of 3D images: faces [31] and chairs [32], on which DC-IGN was shown to learn highly interpretable graphics codes.\nOn the faces dataset, DC-IGN learns to represent latent factors as azimuth (pose), elevation, and lighting as continuous latent variables by using supervision. Using the same dataset, we demonstrate that InfoGAN learns a disentangled representation that recover azimuth (pose), elevation, and lighting on the same dataset. In this experiment, we choose to model the latent codes with five continuous codes, ci ∼ Unif(−1, 1) with 1 ≤ i ≤ 5. Since DC-IGN requires supervision, it was previously not possible to learn a latent code for a variation that’s unlabeled and hence salient latent factors of variation cannot be discovered automatically from data. By contrast, InfoGAN is able to discover such variation on its own: for instance, in Figure 3d a\nlatent code that smoothly changes a face from wide to narrow is learned even though this variation was neither explicitly generated or labeled in prior work.\nOn the chairs dataset, DC-IGN can learn a continuous code that representes rotation. InfoGAN again is able to learn the same concept as a continuous code (Figure 4a) and we show in addition that InfoGAN is also able to continuously interpolate between similar chair types of different widths using a single continuous code (Figure 4b). In this experiment, we choose to model the latent factors with four categorical codes, c1, c2, c3, c4 ∼ Cat(K = 20, p = 0.05) and one continuous code c5 ∼ Unif(−1, 1). Next we evaluate InfoGAN on the Street View House Number (SVHN) dataset, which is significantly more challenging to learn an interpretable representation because it is noisy, containing images of variable-resolution and distracting digits, and it does not have multiple variations of the same object. In this experiment, we make use of four 10−dimensional categorical variables and two uniform continuous variables as latent codes. We show two of the learned latent factors in Figure 5.\nFinally we show in Figure 6 that InfoGAN is able to learn many visual concepts on another challenging dataset: CelebA [33], which includes 200, 000 celebrity images with large pose variations and background clutter. In this dataset, we model the latent variation as 10 uniform categorical variables, each of dimension 10. Surprisingly, even in this complicated dataset, InfoGAN can recover azimuth as in 3D images even though in this dataset no single face appears in multiple pose positions. Moreover InfoGAN can disentangle other highly semantic variations like presence or absence of glasses, hairstyles and emotion, demonstrating a level of visual understanding is acquired without any supervision."
    }, {
      "heading" : "8 Conclusion",
      "text" : "This paper introduces a representation learning algorithm called Information Maximizing Generative Adversarial Networks (InfoGAN). In contrast to previous approaches, which require supervision, InfoGAN is completely unsupervised and learns interpretable and disentangled representations on challenging datasets. In addition, InfoGAN adds only negligible computation cost on top of GAN and is easy to train. The core idea of using mutual information to induce representation can be applied to other methods like VAE [3], which is a promising area of future work. Other possible extensions to\nthis work include: learning hierarchical latent representations, improving semi-supervised learning with better codes [34], and using InfoGAN as a high-dimensional data discovery tool."
    }, {
      "heading" : "A Proof of Lemma 5.1",
      "text" : "Lemma A.1 For random variables X,Y and function f(x, y) under suitable regularity conditions: Ex∼X,y∼Y |x[f(x, y)] = Ex∼X,y∼Y |x,x′∼X|y[f(x′, y)]."
    }, {
      "heading" : "Proof",
      "text" : "Ex∼X,y∼Y |x[f(x, y)] = ∫\nx\nP (x)\n∫\ny\nP (y|x)f(x, y)dydx\n=\n∫\nx\n∫\ny\nP (x, y)f(x, y)dydx\n=\n∫\nx\n∫\ny\nP (x, y)f(x, y)\n∫\nx′ P (x′|y)dx′dydx\n=\n∫\nx\nP (x)\n∫\ny\nP (y|x) ∫\nx′ P (x′|y)f(x′, y)dx′dydx\n= Ex∼X,y∼Y |x,x′∼X|y[f(x′, y)]\n(7)\nB Interpretation as “Sleep-Sleep” Algorithm\nWe note that InfoGAN can be viewed as a Helmholtz machine [1]: PG(x|c) is the generative distribution and Q(c|x) is the recognition distribution. Wake-Sleep algorithm [2] was proposed to train Helmholtz machines by performing “wake” phase and “sleep” phase updates.\nThe “wake” phase update proceeds by optimizing the variational lower bound of logPG(x) w.r.t. generator:\nmax G Ex∼Data,c∼Q(c|x)[logPG(x|c)] (8) The “sleep” phase updates the auxiliary distribution Q by “dreaming” up samples from current generator distribution rather than drawing from real data distribution:\nmax Q\nEc∼P (c),x∼PG(x|c)[logQ(c|x)] (9)\nHence we can see that when we optimize the surrogate loss LI w.r.t. Q, the update step is exactly the “sleep” phase update in Wake-Sleep algorithm. InfoGAN differs from Wake-Sleep when we optimize LI w.r.t. G, encouraging the generator network G to make use of latent codes c for the whole prior distribution on latent codes P (c). Since InfoGAN also updates generator in “sleep” phase, our method can be interpreted as “Sleep-Sleep” algorithm. This interpretation highlights InfoGAN’s difference from previous generative modeling techniques: the generator is explicitly encouraged to convey information in latent codes and suggests that the same principle can be applied to other generative models."
    }, {
      "heading" : "C Experiment Setup",
      "text" : "For all experiments, we use Adam [3] for online optimization and apply batch normalization [4] after most layers, the details of which are specified for each experiment. We use an up-convolutional architecture for the generator networks [5]. We use leaky rectified linear units (lRELU) [6] with leaky rate 0.1 as the nonlinearity applied to hidden layers of the discrminator networks, and normal rectified linear units (RELU) for the generator networks. Unless noted otherwise, learning rate is 2e-4 for D and 1e-3 for G; λ is set to 1.\nFor discrete latent codes, we apply a softmax nonlinearity over the corresponding units in the recognition network output. For continuous latent codes, we parameterize the approximate posterior through a diagonal Gaussian distribution, and the recognition network outputs its mean and standard deviation, where the standard deviation is parameterized through an exponential transformation of the network output to ensure positivity.\nThe details for each set of experiments are presented below."
    }, {
      "heading" : "C.1 MNIST",
      "text" : "The network architectures are shown in Table 1. The discriminator D and the recognition network Q shares most of the network. For this task, we use 1 ten-dimensional categorical code, 2 continuous latent codes and 62 noise variables, resulting in a concatenated dimension of 74."
    }, {
      "heading" : "C.2 SVHN",
      "text" : "The network architectures are shown in Table 2. The discriminator D and the recognition network Q shares most of the network. For this task, we use 4 ten-dimensional categorical code, 4 continuous latent codes and 124 noise variables, resulting in a concatenated dimension of 168."
    }, {
      "heading" : "C.3 CelebA",
      "text" : "The network architectures are shown in Table 3. The discriminator D and the recognition network Q shares most of the network. For this task, we use 10 ten-dimensional categorical code and 128 noise variables, resulting in a concatenated dimension of 228."
    }, {
      "heading" : "C.4 Faces",
      "text" : "The network architectures are shown in Table 4. The discriminator D and the recognition network Q shares the same network, and only have separate output units at the last layer. For this task, we use 5 continuous latent codes and 128 noise variables, so the input to the generator has dimension 133.\nWe used separate configurations for each learned variation, shown in Table 5."
    }, {
      "heading" : "C.5 Chairs",
      "text" : "The network architectures are shown in Table 6. The discriminator D and the recognition network Q shares the same network, and only have separate output units at the last layer. For this task, we use 1 continuous latent code, 3 discrete latent codes (each with dimension 20), and 128 noise variables, so the input to the generator has dimension 189.\nWe used separate configurations for each learned variation, shown in Table 7. For this task, we found it necessary to use different regularization coefficients for the continuous and discrete latent codes."
    } ],
    "references" : [ {
      "title" : "The helmholtz machine",
      "author" : [ "P. Dayan", "G.E. Hinton", "R.M. Neal", "R.S. Zemel" ],
      "venue" : "Neural computation, vol. 7, no. 5, pp. 889–904, 1995.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "The\" wake-sleep\" algorithm for unsupervised neural networks",
      "author" : [ "G.E. Hinton", "P. Dayan", "B.J. Frey", "R.M. Neal" ],
      "venue" : "Science, vol. 268, no. 5214, pp. 1158–1161, 1995.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "D. Kingma", "J. Ba" ],
      "venue" : "ArXiv preprint arXiv:1412.6980, 2014.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
      "author" : [ "S. Ioffe", "C. Szegedy" ],
      "venue" : "ArXiv preprint arXiv:1502.03167, 2015.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Learning to generate chairs with convolutional neural networks",
      "author" : [ "A. Dosovitskiy", "J. Tobias Springenberg", "T. Brox" ],
      "venue" : "Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2015, pp. 1538–1546.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Rectifier nonlinearities improve neural network acoustic models",
      "author" : [ "A.L. Maas", "A.Y. Hannun", "A.Y. Ng" ],
      "venue" : "Proc. ICML, vol. 30, 2013, p. 1. 13 Table 7: The hyperparameters for Chairs dataset. Learning rate for D / Q Learning rate for G λcont λdisc Rotation 2e-4  1e-3 10.0 1.0 Width 2e-4  1e-3 0.05 2.0 14",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "A popular framework for unsupervised learning is that of representation learning [1, 2], whose goal is to use unlabelled data to learn a representation that exposes important semantic features as easily decodable factors.",
      "startOffset" : 81,
      "endOffset" : 87
    }, {
      "referenceID" : 1,
      "context" : "A popular framework for unsupervised learning is that of representation learning [1, 2], whose goal is to use unlabelled data to learn a representation that exposes important semantic features as easily decodable factors.",
      "startOffset" : 81,
      "endOffset" : 87
    }, {
      "referenceID" : 1,
      "context" : "A method that can learn such representations is likely to exist [2], and to be useful for many downstream tasks which include classification, regression, visualization, and policy learning in reinforcement learning.",
      "startOffset" : 64,
      "endOffset" : 67
    }, {
      "referenceID" : 2,
      "context" : "The most prominent generative models are the variational autoencoder (VAE) [3] and the generative adversarial network (GAN) [4].",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 3,
      "context" : "The most prominent generative models are the variational autoencoder (VAE) [3] and the generative adversarial network (GAN) [4].",
      "startOffset" : 124,
      "endOffset" : 127
    }, {
      "referenceID" : 4,
      "context" : "The quality of our unsupervised disentangled representation matches previous works that made use of supervised label information [5–9].",
      "startOffset" : 129,
      "endOffset" : 134
    }, {
      "referenceID" : 5,
      "context" : "The quality of our unsupervised disentangled representation matches previous works that made use of supervised label information [5–9].",
      "startOffset" : 129,
      "endOffset" : 134
    }, {
      "referenceID" : 3,
      "context" : "GANs [4] have been used by Radford et al.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 4,
      "context" : "Similarly, VAEs [5] and Adversarial Autoencoders [9] were shown to learn representations in which class label is separated from other variations.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 3,
      "context" : "[4] introduced the Generative Adversarial Networks (GAN), a framework for training deep generative models using a minimax game.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "The core idea of using mutual information to induce representation can be applied to other methods like VAE [3], which is a promising area of future work.",
      "startOffset" : 108,
      "endOffset" : 111
    } ],
    "year" : 2016,
    "abstractText" : "This paper describes InfoGAN, an information-theoretic extension to the Generative Adversarial Network that is able to learn disentangled representations in a completely unsupervised manner. InfoGAN is a generative adversarial network that also maximizes the mutual information between a small subset of the latent variables and the observation. We derive a lower bound of the mutual information objective that can be optimized efficiently. Specifically, InfoGAN successfully disentangles writing styles from digit shapes on the MNIST dataset, pose from lighting of 3D rendered images, and background digits from the central digit on the SVHN dataset. It also discovers visual concepts that include hair styles, presence/absence of eyeglasses, and emotions on the CelebA face dataset. Experiments show that InfoGAN learns interpretable representations that are competitive with representations learned by existing supervised methods.",
    "creator" : "LaTeX with hyperref package"
  }
}