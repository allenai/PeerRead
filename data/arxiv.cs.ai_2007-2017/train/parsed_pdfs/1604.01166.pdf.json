{
  "name" : "1604.01166.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "An Efficient Algorithm for Mining Frequent Sequence with Constraint Programming",
    "authors" : [ "John O.R. Aoga", "Tias Guns", "Pierre Schaus" ],
    "emails" : [ "john.aoga@uclouvain.be", "pierre.schaus@uclouvain.be", "tias.guns@cs.kuleuven.be" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 4.\n01 16\n6v 1\n[ cs\n.D B\n] 5\nA pr"
    }, {
      "heading" : "1 Introduction",
      "text" : "Sequence mining is a widely studied problem concerned with discovering subsequences in a dataset of given sequences, where each (sub) sequence is an ordered list of symbols. It has applications ranging from web usage mining, text mining, biological sequence analysis and human mobility mining [1].\nIn recent years, constraint programming (CP) has been proposed as a general framework for pattern mining [2,3,4,5]. The main benefit of CP-based approaches over dedicated algorithms is that it is modular. In a CP framework, a problem is expressed as a set of constraints that the solutions must satisfy. Each such a constraint can be seen as a module, and can range from being as simple as ensuring that a subsequence does not contain a certain symbol at a certain position, up to\ncomputing the frequency of a pattern in a database. This modularity allows for flexibility, in that certain constraints such as symbol restrictions, length, regular expressions etc can easily be added and removed to existing problems. Another advantage is that improving the efficiency of one constraint will improve the efficiency of all problems involving this constraint.\nHowever, this increased flexibility can come at a cost. Negrevergne et al. [4] have shown that a fine-grained modular approach to sequence mining can support any type of constraints, including gap and span constraints and any quality function beyond frequency, but that this is not competitive with state-of-theart specialized methods. On the other hand, by using a global constraint that computes the pseudo-projection of the sequences in the database similar to PrefixSpan [6], this overhead can be reduced. Kemmar et al. [5,7] have further extended this work by introducing one constraint (module) for both the pseudoprojection and the frequency pruning. While reasonable performance is obtained, especially for mining under regular expressions, the method does not achieve the same scalability as some of the best specialized systems such as Zaki’s cSpade [8].\nIn this work we focus on the problem of finding patterns in sequences of individual symbols, which is the most commonly used setting in applications such as web log mining and biological sequence analysis. We improve the projected frequency constraint in a modular CP solver by combining ideas from pattern mining as well as from CP. First, we improve the efficiency of computing the projected database and the projected frequency using last-position lists, similar to the LAPIN algorithm [9] but within a PrefixSpan approach. Second, we take into account not just the efficiency of computing the projected database, but also that of storing and restoring the pseudo-projected database during depthfirst search. We use ideas from trailing CP solvers to avoid unnecessary copying, an approach that is applicable to any depth-first pattern mining algorithm. We show that the resulting system is faster than previous CP-based sequence miners as well as state-of-the-art specialized systems. Furthermore, we show that by improving this one module, these improvements directly translate to other problems using this module, such as regular-expression based sequence mining."
    }, {
      "heading" : "2 Related works",
      "text" : "We review specialized methods as well as CP-based approaches. A more thorough review of algorithmic developments is given in [1].\nSpecialized methods. Introduced by Srikant and Agrawal [10], GSP was the first approach to extract sequential patterns from a sequential database. Many works have improved on this apriori-based method, typically employing depthfirst search. A seminal work is that of PrefixSpan [6]. A prefix in this context is a sequential pattern that can only be extended by appending symbols to it. Given a prefix, one can compute the projected database of all suffixes of the sequences that have the prefix as a subsequence. This projected database can then be used to compute the frequency of the prefix and of all its 1-extensions (projected\nfrequency). A main innovation in PrefixSpan is the use of a pseudo-projected database: instead of copying the entire (projected) database, one only has to maintain pointers to the position in each sequence where the prefix matched.\nAlternative methods such as SPADE [8] and SPAM [11] use a vertical representation of the database, having for each symbol a list of sequence identifiers and positions at which that symbol appears.\nYang et al. have shown [12] that algorithms with either data representation can be improved by precomputing the last position of each symbol in a sequence. This can avoid having to scan the projected database, as often the reason for scanning is to know whether a symbol still appears in the projected sequence.\nThe standard sequence mining settings have been extended in a number of directions, including user-defined constraints on length or on the gap or span of a sequence such as in the cSPADE algorithm [8], closed patterns [13] and algorithms that can handle regular expression constraints on the patterns such as SMA [14]. These constraints are typically hard-coded in the algorithms.\nCP-based approaches for SPM. CP-based approaches for sequence mining are gaining interest in the CP community. Early work has focused on fixedlength sequences with wildcards [3]. More generally, [4] proposed two approaches: a full decomposition of the problem in terms of constraints and an approach using a global constraint to construct the pseudo-projected database similar to PrefixSpan. It uses one such constraint for each sequence. Kemmar et al [7] propose to gather all these constraints into a unique global constraint to reduce the overhead of the multiple constraints. They further showed how the constraint can be modified to take a maximal gap constraint into account [5]."
    }, {
      "heading" : "3 Sequential Pattern Mining Background",
      "text" : "This section introduces the necessary concepts and definitions of sequence mining and constraint programming."
    }, {
      "heading" : "3.1 Sequence Mining Background",
      "text" : "Let I = {s1, . . . , sN} be a set of N symbols. In the remaining of the paper when there is no ambiguity a symbol is simply denoted by its identifier i with i ∈ {1, . . . , N}.\nDefinition 1. Sequence and sequence database. A sequence s = 〈s1s2 . . . sn〉 over I is an ordered list of (potentially repeating) symbols sj, j ∈ [1, n] with #s = n the length of the sequence s. A set of tuples (sid,s) where sid is a sequence identifier and s a sequence, is called sequence database (SDB).\nExample 1. Table. 1 shows an example SDB1 over symbols I = {A,B,C,D}. For the sequence s = 〈BABC〉: #s = 4 and s1 = B, s2 = A, s3 = B, s4 = C.\n1) SDB, 2) lastPosList, 3) lastPosMap\nDefinition 2. Sub-sequence ( ), super-sequence. A sequence α = 〈α1 . . . αm〉 is called a sub-sequence of s = 〈s1s2 . . . sn〉 and s is a super-sequence of α iff (i) m ≤ n and (ii) for all i ∈ [1,m] there exist integers ji s.t. 1 ≤ j1 ≤ · · · ≤ jm ≤ n, such that αi = sji .\nExample 2. For instance 〈BD〉 is a sub-sequence of 〈BCCD〉, and inversely 〈BCCD〉 is the super-sequence of 〈BD〉 : 〈BD〉 〈BCCD〉.\nDefinition 3. Cover, Support, Pattern, Frequent Pattern. The cover of sequence p in SDB, denoted by coverSDB(p), is the subset of sequences in SDB that are a super-sequence of p, i.e. coverSDB(p) = {(sid, s) ∈ SDB | p s}. The support of p in SDB, denoted by supSDB(p), is the number of super-sequencs of p in SDB: supSDB(p) = #coverSDB(p). Any sequence p over symbols in I can be a pattern, and we call a pattern frequent iff supSDB(p) ≥ θ, where θ is a given minimum support threshold.\nExample 3. Assume p = 〈BC〉 and θ = 2, coverSDB1 (p) = {(sid1, 〈ABCBC〉), (sid2, 〈BABC〉), (sid4, 〈BCD〉)} and hence supSDB1(p) = 3. Hence, p is a frequent pattern for that given threshold.\nThe sequential pattern mining (SPM) problem, first introduced by Agrawal and Srikant [10], is the following:\nDefinition 4. Sequential Pattern Mining (SPM). Given an minimum support threshold θ and a sequence database SDB, the SPM problem is to find all patterns p such that supSDB(p) ≥ θ.\nOur method uses the idea of a prefix and prefix-projected database for enumerating the frequent patterns. These concepts were first introduced in the seminal paper that presented the PrefixSpan algorithm [6].\nDefinition 5. Prefix, prefix-projected database Let α = 〈α1 . . . αm〉 be a pattern. If a sequence β = 〈β1 . . . βn〉 is a super-sequence of α: α β, then the prefix of α in β is the smallest prefix of β that is still a super-sequence of α: 〈β1 . . . βj〉 s.t. α 〈β1 . . . βj〉 and ∄j′ < j : α 〈β1 . . . βj′ 〉. The sequence 〈βj+1 . . . βn〉 is called the suffix and is obtained by projecting the prefix away. A prefix-projected database of a pattern α, denoted by SDB|α, is the set of prefixprojections of all sequences in SDB that are a super-sequence of α.\nExample 4. In SDB1, assume α = 〈A〉, then SDB1|α = {(sid1, 〈BCBC〉), (sid2, 〈BC〉), (sid3, 〈B〉)}.\nWe say that the prefix-projected frequency of the symbols I in a prefixprojected database is the number of sequences in which these symbols appear. For SDB1|〈A〉 the prefix-projected frequencies are A : 0, B : 3, C : 2, D : 0.\nThe PrefixSpan algorithm solves the SPM problem by starting from the empty pattern and extending this pattern using depth-first search. At each step it extends a pattern by a symbol and projects the database accordingly. The appended symbol is removed on backtrack. It hence grows the pattern incrementally, which is why it is called a pattern-growth method. A frequent pattern in the projected database is also frequent in the original database.\nThere are two important considerations for the efficiency of the method. The first is that one does not have to consider during search any symbol that is not frequent in the prefix-projected database. The second is that of pseudoprojection: to store the prefix-projected database during the depth-first search, it is not necessary to store (and later restore) an entire copy of the projected database. Instead, one only has to store for each sequence the pointer to the position j that marks the end of the prefix in that sequence (remember, the prefix of α in β is the smallest prefix 〈β1 . . . βj〉 α).\nExample 5. The projected database SDB1|α = {(sid1, 〈BCBC〉), (sid2, 〈BC〉), (sid3, 〈B〉)} can be represented as a pseudo-projected database as follows: {(sid1, 2), (sid2, 3), (sid3, 2)}."
    }, {
      "heading" : "3.2 Constraint Programming Background",
      "text" : "CP is a powerful declarative paradigm to solve combinatorial satisfaction and optimization problems (see, e.g., [15]). A CP problem (V,D,C) is defined by a set of variables V with their respective domain D (the values that can be assigned to a variable), and a set of constraints C on these variables. A solution of a CP problem is an assignment of the variables to a value from its domain, such that all constraints are satisfied.\nAt its core, CP solvers are depth-first search algorithms that iterate between searching over unassigned variables and propagating constraints. Propagation is the act of letting the constraints in C remove unfeasible values from the domains of its variables. This is repeated until fixed-point, that is, no more constraint can remove any unfeasible values. Then, a search exploration step is taken by choosing an unassigned variable and assigning it to a value from its current domain, after which propagation is executed again.\nExample 6. Let there be 2 variables x, y with domains D(x) = {1, 2, 3}, D(y) = {3, 4, 5}. Then constraint x+y ≥ 5 can derive during propagation that 1 /∈ D(x) because the lowest value y can take is 3 and hence x ≥ 5−min(D(y)) ≥ 5−3 ≥ 2.\nConstraints and global constraints Many different constraints and their propagation algorithms have been investigated in the CP community. This includes\nlogical and arithmetic ones like the above, up to constraints for enforcing regular expressions or graph theoretic properties. A constraint that enforces some non-trivial or application-dependent property is often called a global constraint. For example, [4] introduced a global constraint for the pseudo-projection of a single sequence, and [5] for the entire projected frequency subproblem.\nState restoration in CP In any depth-first solver, there must be some mechanism to store and restore some state, such that computations can be performed incrementally and intermediate values can be stored. In most of the CP solvers3 a general mechanism, called trailing is used for storing and restoring the state (on backtrack) [16]. Externally, the CP solvers typically expose some \"reversible\" objects whose values are automatically stored and restored on the trail when they change. The most important example are the domains of CP variables. Hence, for a variable the domain modifications (assign, removeValue) are automatically reversible operations. A CP solver also exposes reversible version of primitive types such as integers and sets for use within constraint propagators. They are typically used to store incremental computations. CP solvers consist of an efficient implementation of the DFS backtracking algorithm, as well as many constraints that can be called by the fix-point algorithm. The modularity of constraint solvers stems from this ability to add any set of constraints to the fix-point algorithm."
    }, {
      "heading" : "4 Global constraints for projected frequency",
      "text" : "We first introduce the basic CP model of frequent sequence mining introduced in [4] and extended in [7]. Then, we present how we improve the computation of the pseudo-projection, followed by the projected frequency counting and pruning."
    }, {
      "heading" : "4.1 Existing methods [4,7]",
      "text" : "As explained before, a constraint model consists of variables, domains and constraints. The CP model will be such that a single solution corresponds to a frequent sequence, meaning that all sequences can be extracted by enumerating all solutions.\nLet L be an upper bound on the pattern length, e.g. the length of the longest sequence in the database. The variables used to represent the unknown pattern P is modeled as an array of L integer variables P = [P1, P2, . . . , PL]. Each variable has an initial domain {0, . . . , N}, corresponding to all possible symbols identifiers and augmented with an additional identifier 0. The symbol with identifier 0 represents ǫ, the empty symbol. It will be used to denote the end of the sequence in P , using a trailing suffix of such 0’s.\nDefinition 6. A CP model over P represents the frequent sequence mining problem with threshold θ, iff the following three conditions are satisfied by every valid assignment to P :\n3 One notable exception is the Gecode copy-based solver.\nListing 1.1: PrefixProjection(SDB,P,i,θ)\n1 // pre: variables 〈P1, . . . , Pi〉 are bound, SDB is given 2 // Pi is the new instantiated variable since previous call. 3 if (Pi == 0) { 4 foreach (j ∈ {i+ 1, . . . , L}) { Pj .assign(0) } 5 } else if (i ≥ 2) { 6 projFreqs = ProjectAndGetFreqs(SDB,Pi, θ) 7 foreach (j ∈ {i+ 1, . . . , L}) 8 foreach (a ∈ D(Pj)) 9 if (a 6= 0 and projFreqs[a] < θ) { Pj .removeV alue(a) }\n10 }\n1. P1 6= 0 2. ∀i ∈ {2, . . . , L− 1} : Pi = 0 ⇒ Pi+1 = 0 3. #{(sid, s) ∈ SDB 〈P1 . . . Pj〉 s} ≥ θ, j = max({i ∈ {1 . . .L}|Pi 6= 0}).\nThe first requirement states that the sequence may not start with the empty symbol, e.g. no empty sequence. The second requirement enforces that the pattern is in a canonical form such that after the empty symbol, all other symbols are the empty symbol too. Hence, a sequence of length l < L is represented by l non-zero symbols, followed by L − l zero symbols. The last requirement states that the frequency of the non-zero part of the pattern must be above the threshold θ.\nPrefix projection global constraint Initial work [4] proposed to decompose these three conditions into separate constraints, including a dedicated global constraint for the inclusion relation 〈P1 . . . Pj〉 s for each sequence separately. It used the pseudo-projection technique of PrefixSpan for this, with the projected frequency enforced on each symbol in separate constraints.\nKemmar et al. [7] extended this idea by encapsulating the filtering of all three conditions into one single (global) constraint called PrefixProjection. It also uses the pseudo-projection idea of PrefixSpan, but over the entire database. The propagation algorithm for this constraint, as executed when the next unassigned variable Pi is assigned during search, is given in Listing 1.1.\nAn initial assumption is that the database SDB does not contain any infrequent symbols, which is a simple preprocessing step. The code is divided in three parts: (i) if Pi is assigned to 0 the remaining Pk with k > i is assigned to 0; else (ii) from the second position onwards (remember that the first position can take any symbol and be guaranteed to be frequent as every symbol is known to be frequent), the projected database and the projected frequency of each symbol is computed; and (iii) all symbols that have a projected frequency below the threshold are removed from the domain of the subsequent pattern variables.\nThe algorithm for computing the (pseudo) projected database and the projected frequencies of the symbols is given in Listing 1.2. It operates as follows\nListing 1.2: ProjectAndGetFreqs(SDB,a,θ)\n1 PSDBi = ∅ 2 foreach (sid,start) ∈ PSDBi−1 { 3 s = SDB[sid]; pos = start 4 while (pos < #s and a 6=s[pos]) { pos = pos+ 1 } 5 if (pos < #s) { PSDBi = PSDBi ∪ {(sid, pos)} } 6 } 7 projFreqs[a]=0 ∀a ∈ {1, . . . , N} 8 if (#PSDBi ≥ θ) { 9 foreach (sid,start) ∈ PSDBi {\n10 s = SDB[sid]; existsSymbol[b] = false ∀b ∈ {1, . . . , N} 11 foreach (i ∈ {start, . . . ,#s}) { 12 if (!existsSymbol[s[i]]) { 13 projFreqs[s[i]] = projFreqs[s[i]]+1 14 existsSymbol[s[i]] = true 15 } 16 } } } 17 return projFreqs\nwith a the new symbol appended to the prefix of assigned variables since previous call. The first loop at line 2 attempts to discover for each sequence s in the projected database if it can be a sub-sequence of the extended prefix. If yes, this sequence is added to the next projected database at line 5. The second loop at line 9 computes the frequency of each symbol occurring in the projected database but counting it at most once per sequence."
    }, {
      "heading" : "4.2 Improving propagation",
      "text" : "Although being the state-of-art approach for solving SPM with CP, the filtering algorithm of Kemmar et al [5] presents room for improvement. We identify four weaknesses and propose solutions to them. Weakness 1. Databases with long sequences will have a large upper-bound L. For such databases, removing infrequent symbols from all remaining pattern variables P in the loop defined at line 7 of Listing 1.1 can take time. This is not only the case for doing the action, but also for restoring the domains on backtracking. On the other hand, only the next pattern variable Pi+1 will be considered during search, and in most cases a pattern will never actually be of length L, so all subsequent domain changes are unnecessary. This weakness is a peculiarity of using a fixed-length array P to represent a variable-length sequence. Mining algorithms typically have a variable length representation of the pattern, and hence only look one position ahead. In our propagator we only remove values from the domain of Pi+1. Weakness 2. When computing the projected frequencies of the symbols, one has to scan each sequence from its current pseudo-projection pointer start till\nthe end of the sequence. This can be time consuming in case of many repetitions of only a few symbols for example. Thanks to the lastPosList defined next, it is possible to visit only the last position of each symbol occurring after start. This idea was first introduced in [12] and exploited in the LAPIN family of algorithms.\nDefinition 7. (Last position list). For a current sequence s, lastPosList is a sequence of pairs (symbol, pos) giving for each symbol that occurs in s its last position: pos = max{p ≤ #s : s[p] = symbol}. The sequence is of length m, the number of distinct symbols in s. This sequence is decreasing according to positions: lastPosList[i].pos > lastPosList[i+ 1].pos ∀i ∈ {1, . . . ,m− 1}.\nExample 7. Table. 1 shows the lastPosList sequences for SDB1. We consider the sequence with sid1 and a prefix 〈A〉. The computation of the frequencies starts at position 2, remaining suffix is 〈BCBC〉. Instead of visiting all the 4 positions of this suffix, only the last two can be visited thanks to the information contained in lastPosList[sid1]. Indeed according to lastPosList[sid1][1] the maximum last position is 5 (corresponding to the last C). Then according to lastPosList[sid1][2] the second maximum last position is 4 (corresponding to the last position of symbol B). The third maximum last position is 1 for symbol A. Since this position is smaller than 2 (our initial start), we can stop. Weakness 3. Related to weakness 2, line 4 in Listing 1.2 finds the new position (poss) of a in SDB[sid]. This code is executed even if the new symbol no longer appears in that sequence. Currently, the code has to loop over the entire sequence until it reaches the end before discovering this.\nAssume that the current position in the sequence s is already larger than the position of the last occurrence of a. Then we immediately know this sequence cannot be part of the projected database. To verify this in O(1) time, we use a lastPosMap as follows:\nDefinition 8. (Last position map of symbols). For a given sequence s with id sid, lastPosMap[sid] is a map such that lastPosMap[sid][i] is the last position of symbol i in the sequence s. In case the symbol i is not present: lastPosMap[sid][i] = 0 (positions are assumed to start at index 1).\nExample 8. Table 1 shows the lastPosMap arrays next to SDB1. For instance for sid2 the last position of symbol C is 4. Weakness 4. Listing 1.2 creates a new set PSDBi to represent the projected database. This projected database is computed many times during the search, namely at least once in each node of the search tree (more if there are other constraints in the fixPoint set). This is a source of inefficiency for garbage collected languages such as Java but also for C since it induces many \"slow\" system calls such as free and malloc leading to fragmentation of the memory. We propose to store and restore the pseudo-projected databases with reversible vectors making use of CP trailing techniques. The idea is to use one and the same array throughout the search in the propagator, and only maintain the relevant start/stop position during search. Each call to propagate will read from the previous start to stop position, and write after the previous stop position plus store\nthe new start/stop position. The projected data-bases are thus stacked in the array along a branch of the search tree. We implement the pseudo-projected database with two reversible vectors: sids and poss respectively for the sequence ids and the current position in the corresponding sequences. The position φ is the start entry (in sids and poss) of the current projected database, and ϕ is the size of the projected database. We thus have the current projected database contained in sub-arrays sids[φ, . . . , φ+ϕ−1] and poss[φ, . . . , φ+ϕ−1]. In order to make the projected database reversible, φ and ϕ are reversible integers. That is on backtrack to an ancestor node those integers retrieve their previous value and entries of sids and poss starting from φ can be reused.\nExample 9. Figure 1 is an example using SDB1. Initially all the sequences are present ϕ = 4 and position is initialized φ = 0. The A-projected database contains sequence 1, 2, 3 at positions 1, 2, 1 with φ = 4 and ϕ = 3.\nPrefix Projection Incremental Counting propagator (PPIC). Putting all the solutions to the identified weaknesses together, we list the code of the main function of our propagator’s in Listing 1.3.\nThe main loop at line 3 iterates over the previous (parent) projected database. In case the sequence at index i in the projected database contains the new symbol at a subsequent position larger or equal to start, the matching position is searched and added to the new projected database (at index j of reversible vectors sids and poss) at line 9. Then the contribution of the sequence to the projected frequencies is computed in the loop at line 11. Only the entries in the lastPosList with position larger than current pos are considered (recall that his list is decreasing according to positions). Finally line 17 updates the reversible integers φ and ϕ to reflect the newly computed projected data-base. Based on these projected frequencies a filtering similar to the one of Listing 1.1\nListing 1.3: ProjectAndGetFreqs(SDB,a, θ,sids,poss,φ,ϕ)\n1 projFreqs[b]=0 ∀b ∈ {1, . . . , N} 2 i = φ; j = φ+ ϕ; sup = 0 3 while (i < φ+ ϕ) { 4 sid = sids[i]; pos = poss[i]; s = SDB[sid] 5 if (lastPosMap[sid][a] − 1 ≥ start) { 6 //find the next position of a in s 7 while (pos < #s and a 6=s[pos]) { pos = pos+ 1 } 8 // update projected database 9 sids[j] = sid; poss[j] = pos+ 1; j = j + 1; sup = sup+ 1\n10 // recompute projected frequencies 11 foreach ((symbol, posx) in lastPosList[sid]) { 12 if (posx ≤ pos) { break } 13 projFreqs[symbol] = projFreqs[symbol] + 1 14 } } 15 i = i+ 1 16 } 17 φ = φ+ ϕ; ϕ = sup 18 return projFreqs\nis achieved except that only the domain of the next variable D(Pi+1) is filtered according to the solution to Weakness 1.\nPrefix Projection Decreasing Counting propagator (PPDC). The key idea of this approach is not to count the projected frequencies from scratch, but rather to decrement them. More specifically, when scanning the position of the current symbol at line 7, if pos happens to be the a symbol last position (pos==lastPosMap[sid][s[pos]]) then projFreqs[s[pos]] is decremented. This requires projFreqs to be an array of reversible integers. With this strategy the loop at line 11 disappears, but in case the current sequence is not added to the projected data-base, the frequencies of all its last symbols occurring after pos must also be decremented. This can be done by adding an else block to the if defined at line 5 that will iterate over the lastPosList and decrement the symbol frequencies.\nExample 10. Assume SDB1. The initial projected frequency array is projFreqs= [A:3,B:4,C:3,D:1]. Consider now the A-projected data-base illustrated on Fig. 1. The projected frequency array becomes projFreqs=[A:0,B:3,C:2,D:0]. The entry at A is decremented three times as pos moved beyond its lastPos for each of the sequences sid1, sid2 and sid3. Since sid4 is removed from the projected data-base, the frequency of all its last symbols occurring after pos is also decremented, that is for entries B, C and D.\nPP-mixed. Both PPID and PPDC approaches can be of interest depending on the number of removed sequences in the projected data-base. If the number\nof sequences removed is large then PPIC is preferable. On the other hand is only a few sequences are removed then PPDC can be more interesting. Inspired from the reset idea of [17] the PP-mixed approach dynamically chooses the best strategy: if projFreqsSDB(a) < #PSDBi/2 (i.e., more than half of sequences will be removed) then PPIC is used otherwise PPDC."
    }, {
      "heading" : "4.3 Constraints of SPM",
      "text" : "We implemented common constraints such as minimum and maximum pattern size, symbol inclusion/exclusion, and regular expression constraints. Time constraints (maxgap, mingap, maxspan,etc) are outside the scope of this work: they change the definition of what a valid prefix is, and hence require changing the propagator (as in [5])."
    }, {
      "heading" : "5 Experiments",
      "text" : "In this section, we report our experimental results on the performance of our approaches with six real-life datasets4 and one synthetic (data200k [14]) with various characteristics shown in Table. 2. Sparsity, representing the average of the number of symbols that appear in each sequence, is a good indicator of how sparse or dense a dataset is.\nOur work is implemented in Scala in OscaR solver [18] and run under JVM with maximum memory set to 8GB. All our software, datasets and results are available online as open source in order to make this research reproducible (http://sites.uclouvain.be/cp4dm/spm/).\nWe used a machine with a 2.7Hz Intel core i5 processor and 8GB of RAMwith Linux 3.19.0-32-generic 64 bits distribution Mint 17.3. Execution time limit is set to 3600 seconds (1 hour). Our proposals are compared, first, with CPSM5[4] and Gap-Seq6[5], the recently CP-based approaches including Gap constraint and the previous version of Gap-Seq, PP7[7] without Gap but with regular expression constraint. Second, we made comparison with cSpade8[8], PrefixSpan [6]9 and SPMF10.\nPPIC vs PPDC vs PPmixed. The CPU time of PPIC, PPDC and PPmixed models are shown in Fig. 2. PPIC is more efficient than PPDC in 80% of datasets. This is essentially because in many cases at the beginning of mining, there are many unsupported sequences for which the symbol counters must be decremented (compared to not having to increase the counters in PPIC). For instance with BIBLE SDB and minsup = 10% PPDC need to see 21,979,585 symbols to be complete while only 15,916,652 is needed for PPIC. Unsurprisingly, PPmixed is between these approaches.\n4 http://www.philippe-fournier-viger.com/spmf/ 5 https://dtai.cs.kuleuven.be/CP4IM/cpsm/ 6 https://sites.google.com/site/cp4spm/ 7 https://sites.google.com/site/prefixprojection4cp/ 8 http://www.cs.rpi.edu/~zaki/www-new/pmwiki.php/Software 9 http://goo.gl/goqHPL\n10 http://www.philippe-fournier-viger.com/spmf/index.php?link=download.php\nOur proposals vs Gap-Seq (CP method). Fig. 2 confirms CPSM is outperformed by Gap-Seq and shows that Gap-Seq improves on PP even without gap. We can clearly notice our approaches outperform Gap-Seq (and hence PP) in all cases. In the case of FIFA SDB, Gap-Seq reach time limit when minsup ≤ 9%. PPIC is very effective in large and dense datasets regarding of CPU-times.\nComparison with specialized algorithms. Our third experience is the comparison with specialized algorithms. As we can see in the Fig. 3, we perform better on 84% of the datasets. However, cSpade is still the most efficient for Kosarak. In fact, Kosarak doesn’t contain any symbol repetition in its sequences. So it is a bad case for prefixprojection-based algorithms which need to scan all the positions. On the contrary, with protein dataset (the sparse one) cSpade requires much more CPU time. The SPMF\nimplementation of SPAM, PrefixSpan and LAPIN appears to be consistently slower than cSpade but there is no clear domination among these.\nHandling different additional constraints. In order to illustrate the modularity of our approach we compare with a number of user-defined constraints that can be added as additional modules without changing the main propagator (Fig. 4). (a) We compared PPIC and PP (unfortunately the Gap-Seq tool does not support a regular expression command-line argument) under various size constraints on the protein dataset with minsup = 99.984. (b,c) We also selected data200k adding a regular expression constraint RE10 = A ∗ B(B|C)D ∗ EF ∗ (G|H)I∗ and RE14 = A ∗ (Q|BS ∗ (B|C))D ∗ E(I |S) ∗ (F |H)G ∗ R [14]. The last experiment reported on Fig.4d consists in combining size and symbols constraints on the protein dataset: only sequential patterns that contain VALINE and GLYCINE twice and ASPARATE and SERINE once are valid. PPIC under constraints still dominates PP."
    }, {
      "heading" : "6 Conclusion",
      "text" : "This work improved the existing CP-based sequential pattern mining approaches [4,5] up to the point that it also surpasses specialized mining systems in terms of efficiency. To do so, we combined advanced ideas from the sequence mining literature, namely last-position lists [9], as well as from the CP literature, namely memory-efficient data-structures for storing and restoring state during backtracking search. We introduced the PrefixProjection-Inc (PPIC), PrefixProjection-Dec (PPDC) and PrefixProjection-mixed (PPmixed) global constraints proposing different strategies to compute the projected frequencies: from scratch, by decreasing them, or a mix of both. These can be plugged in as modules in a CP solver. These constraints are\nimplemented in Scala and made available in the generic OscaR solver. Furthermore, the approach is compatible with a number of constraints including size and regular expression constraints. There are other constraints which change the subsequence relation and which would hence require hardcoding changes in the propagator (gap [5], span, etc). We think many of our improvements can be applied to such settings as well.\nOur work shows that generic CP solvers can indeed be used as framework to build scalable mining algorithms, not just for generic yet less scalable systems as was done for itemset mining [2]. Furthermore, advanced data-structures for backtracking search, such as trailing and reversible vectors, can be used in non-CP based mining algorithms too. We believe there is much more potential in such combinations of techniques from data mining and CP."
    } ],
    "references" : [ {
      "title" : "A taxonomy of sequential pattern mining algorithms",
      "author" : [ "N.R. Mabroukeh", "C.I. Ezeife" ],
      "venue" : "ACM Comput. Surv. 43(1)",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Itemset mining: A constraint programming perspective",
      "author" : [ "T. Guns", "S. Nijssen", "L. De Raedt" ],
      "venue" : "Artificial Intelligence 175(12)",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A SAT-based approach for discovering frequent, closed and maximal patterns in a sequence",
      "author" : [ "E. Coquery", "S. Jabbour", "L. Saïs", "Y. Salhi" ],
      "venue" : "ECAI.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Constraint-based sequence mining using constraint programming",
      "author" : [ "B. Negrevergne", "T. Guns" ],
      "venue" : "CPAIOR15. Springer",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "A global constraint for mining sequential patterns with gap constraint",
      "author" : [ "A. Kemmar", "S. Loudni", "Y. Lebbah", "P. Boizumault", "T. Charnois" ],
      "venue" : "CPAIOR16",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Prefixspan: Mining sequential patterns efficiently by prefix-projected pattern growth",
      "author" : [ "J. Pei", "J. Han", "B. Mortazavi-Asl", "H. Pinto", "Q. Chen", "U. Dayal", "M.C. Hsu" ],
      "venue" : "icccn, IEEE",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Prefixprojection global constraint for sequential pattern mining",
      "author" : [ "A. Kemmar", "S. Loudni", "Y. Lebbah", "P. Boizumault", "T. Charnois" ],
      "venue" : "Principles and Practice of Constraint Programming, Springer",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Sequence mining in categorical domains: incorporating constraints",
      "author" : [ "M.J. Zaki" ],
      "venue" : "Proceedings of the ninth international conference on Information and knowledge management, ACM",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "LAPIN-SPAM: An Improved Algorithm for Mining Sequential Pattern",
      "author" : [ "Z. Yang", "M. Kitsuregawa" ],
      "venue" : "International Conference on Data Engineering.",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Mining sequential patterns",
      "author" : [ "R. Agrawal", "R. Srikant" ],
      "venue" : "Data Engineering, 1995. Proceedings of the Eleventh International Conference on, IEEE",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Sequential pattern mining using a bitmap representation",
      "author" : [ "J. Ayres", "J. Flannick", "J. Gehrke", "T. Yiu" ],
      "venue" : "ACM SIGKDD.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "LAPIN: effective sequential pattern mining algorithms by last position induction for dense databases",
      "author" : [ "Z. Yang", "Y. Wang", "M. Kitsuregawa" ],
      "venue" : "DAFSAA.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Clospan: Mining closed sequential patterns in large datasets",
      "author" : [ "X. Yan", "J. Han", "R. Afshar" ],
      "venue" : "In SDM, SIAM",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Sequence mining automata: A new technique for mining frequent sequences under regular expressions",
      "author" : [ "R. Trasarti", "F. Bonchi", "B. Goethals" ],
      "venue" : "Data Mining, 2008. ICDM’08. Eighth IEEE International Conference on, IEEE",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Handbook of CP",
      "author" : [ "F. Rossi", "P. Van Beek", "T. Walsh" ],
      "venue" : "Elsevier",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Finite domain constraint programming systems",
      "author" : [ "C. Schulte", "M. Carlsson" ],
      "venue" : "Handbook of constraint programming",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Improving gac-4 for table and mdd constraints",
      "author" : [ "G. Perez", "J.C. Regin" ],
      "venue" : "Principles and Practice of Constraint Programming, Springer",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "It has applications ranging from web usage mining, text mining, biological sequence analysis and human mobility mining [1].",
      "startOffset" : 119,
      "endOffset" : 122
    }, {
      "referenceID" : 1,
      "context" : "In recent years, constraint programming (CP) has been proposed as a general framework for pattern mining [2,3,4,5].",
      "startOffset" : 105,
      "endOffset" : 114
    }, {
      "referenceID" : 2,
      "context" : "In recent years, constraint programming (CP) has been proposed as a general framework for pattern mining [2,3,4,5].",
      "startOffset" : 105,
      "endOffset" : 114
    }, {
      "referenceID" : 3,
      "context" : "In recent years, constraint programming (CP) has been proposed as a general framework for pattern mining [2,3,4,5].",
      "startOffset" : 105,
      "endOffset" : 114
    }, {
      "referenceID" : 4,
      "context" : "In recent years, constraint programming (CP) has been proposed as a general framework for pattern mining [2,3,4,5].",
      "startOffset" : 105,
      "endOffset" : 114
    }, {
      "referenceID" : 3,
      "context" : "[4] have shown that a fine-grained modular approach to sequence mining can support any type of constraints, including gap and span constraints and any quality function beyond frequency, but that this is not competitive with state-of-theart specialized methods.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "On the other hand, by using a global constraint that computes the pseudo-projection of the sequences in the database similar to PrefixSpan [6], this overhead can be reduced.",
      "startOffset" : 139,
      "endOffset" : 142
    }, {
      "referenceID" : 4,
      "context" : "[5,7] have further extended this work by introducing one constraint (module) for both the pseudoprojection and the frequency pruning.",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 6,
      "context" : "[5,7] have further extended this work by introducing one constraint (module) for both the pseudoprojection and the frequency pruning.",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 7,
      "context" : "While reasonable performance is obtained, especially for mining under regular expressions, the method does not achieve the same scalability as some of the best specialized systems such as Zaki’s cSpade [8].",
      "startOffset" : 202,
      "endOffset" : 205
    }, {
      "referenceID" : 8,
      "context" : "First, we improve the efficiency of computing the projected database and the projected frequency using last-position lists, similar to the LAPIN algorithm [9] but within a PrefixSpan approach.",
      "startOffset" : 155,
      "endOffset" : 158
    }, {
      "referenceID" : 0,
      "context" : "A more thorough review of algorithmic developments is given in [1].",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 9,
      "context" : "Introduced by Srikant and Agrawal [10], GSP was the first approach to extract sequential patterns from a sequential database.",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 5,
      "context" : "A seminal work is that of PrefixSpan [6].",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 7,
      "context" : "Alternative methods such as SPADE [8] and SPAM [11] use a vertical representation of the database, having for each symbol a list of sequence identifiers and positions at which that symbol appears.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 10,
      "context" : "Alternative methods such as SPADE [8] and SPAM [11] use a vertical representation of the database, having for each symbol a list of sequence identifiers and positions at which that symbol appears.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 11,
      "context" : "have shown [12] that algorithms with either data representation can be improved by precomputing the last position of each symbol in a sequence.",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 7,
      "context" : "The standard sequence mining settings have been extended in a number of directions, including user-defined constraints on length or on the gap or span of a sequence such as in the cSPADE algorithm [8], closed patterns [13] and algorithms that can handle regular expression constraints on the patterns such as SMA [14].",
      "startOffset" : 197,
      "endOffset" : 200
    }, {
      "referenceID" : 12,
      "context" : "The standard sequence mining settings have been extended in a number of directions, including user-defined constraints on length or on the gap or span of a sequence such as in the cSPADE algorithm [8], closed patterns [13] and algorithms that can handle regular expression constraints on the patterns such as SMA [14].",
      "startOffset" : 218,
      "endOffset" : 222
    }, {
      "referenceID" : 13,
      "context" : "The standard sequence mining settings have been extended in a number of directions, including user-defined constraints on length or on the gap or span of a sequence such as in the cSPADE algorithm [8], closed patterns [13] and algorithms that can handle regular expression constraints on the patterns such as SMA [14].",
      "startOffset" : 313,
      "endOffset" : 317
    }, {
      "referenceID" : 2,
      "context" : "Early work has focused on fixedlength sequences with wildcards [3].",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 3,
      "context" : "More generally, [4] proposed two approaches: a full decomposition of the problem in terms of constraints and an approach using a global constraint to construct the pseudo-projected database similar to PrefixSpan.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 6,
      "context" : "Kemmar et al [7] propose to gather all these constraints into a unique global constraint to reduce the overhead of the multiple constraints.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 4,
      "context" : "They further showed how the constraint can be modified to take a maximal gap constraint into account [5].",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 9,
      "context" : "The sequential pattern mining (SPM) problem, first introduced by Agrawal and Srikant [10], is the following:",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 5,
      "context" : "These concepts were first introduced in the seminal paper that presented the PrefixSpan algorithm [6].",
      "startOffset" : 98,
      "endOffset" : 101
    }, {
      "referenceID" : 14,
      "context" : ", [15]).",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 3,
      "context" : "For example, [4] introduced a global constraint for the pseudo-projection of a single sequence, and [5] for the entire projected frequency subproblem.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 4,
      "context" : "For example, [4] introduced a global constraint for the pseudo-projection of a single sequence, and [5] for the entire projected frequency subproblem.",
      "startOffset" : 100,
      "endOffset" : 103
    }, {
      "referenceID" : 15,
      "context" : "In most of the CP solvers a general mechanism, called trailing is used for storing and restoring the state (on backtrack) [16].",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 3,
      "context" : "We first introduce the basic CP model of frequent sequence mining introduced in [4] and extended in [7].",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 6,
      "context" : "We first introduce the basic CP model of frequent sequence mining introduced in [4] and extended in [7].",
      "startOffset" : 100,
      "endOffset" : 103
    }, {
      "referenceID" : 3,
      "context" : "1 Existing methods [4,7]",
      "startOffset" : 19,
      "endOffset" : 24
    }, {
      "referenceID" : 6,
      "context" : "1 Existing methods [4,7]",
      "startOffset" : 19,
      "endOffset" : 24
    }, {
      "referenceID" : 3,
      "context" : "Prefix projection global constraint Initial work [4] proposed to decompose these three conditions into separate constraints, including a dedicated global constraint for the inclusion relation 〈P1 .",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 6,
      "context" : "[7] extended this idea by encapsulating the filtering of all three conditions into one single (global) constraint called PrefixProjection.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "Although being the state-of-art approach for solving SPM with CP, the filtering algorithm of Kemmar et al [5] presents room for improvement.",
      "startOffset" : 106,
      "endOffset" : 109
    }, {
      "referenceID" : 11,
      "context" : "This idea was first introduced in [12] and exploited in the LAPIN family of algorithms.",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 0,
      "context" : "Indeed according to lastPosList[sid1][1] the maximum last position is 5 (corresponding to the last C).",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 1,
      "context" : "Then according to lastPosList[sid1][2] the second maximum last position is 4 (corresponding to the last position of symbol B).",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 16,
      "context" : "Inspired from the reset idea of [17] the PP-mixed approach dynamically chooses the best strategy: if projFreqsSDB(a) < #PSDBi/2 (i.",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 4,
      "context" : "Time constraints (maxgap, mingap, maxspan,etc) are outside the scope of this work: they change the definition of what a valid prefix is, and hence require changing the propagator (as in [5]).",
      "startOffset" : 186,
      "endOffset" : 189
    }, {
      "referenceID" : 13,
      "context" : "In this section, we report our experimental results on the performance of our approaches with six real-life datasets and one synthetic (data200k [14]) with various characteristics shown in Table.",
      "startOffset" : 145,
      "endOffset" : 149
    }, {
      "referenceID" : 3,
      "context" : "Our proposals are compared, first, with CPSM[4] and Gap-Seq[5], the recently CP-based approaches including Gap constraint and the previous version of Gap-Seq, PP[7] without Gap but with regular expression constraint.",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 4,
      "context" : "Our proposals are compared, first, with CPSM[4] and Gap-Seq[5], the recently CP-based approaches including Gap constraint and the previous version of Gap-Seq, PP[7] without Gap but with regular expression constraint.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 6,
      "context" : "Our proposals are compared, first, with CPSM[4] and Gap-Seq[5], the recently CP-based approaches including Gap constraint and the previous version of Gap-Seq, PP[7] without Gap but with regular expression constraint.",
      "startOffset" : 161,
      "endOffset" : 164
    }, {
      "referenceID" : 7,
      "context" : "Second, we made comparison with cSpade[8], PrefixSpan [6] and SPMF.",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 5,
      "context" : "Second, we made comparison with cSpade[8], PrefixSpan [6] and SPMF.",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 13,
      "context" : "(b,c) We also selected data200k adding a regular expression constraint RE10 = A ∗ B(B|C)D ∗ EF ∗ (G|H)I∗ and RE14 = A ∗ (Q|BS ∗ (B|C))D ∗ E(I |S) ∗ (F |H)G ∗ R [14].",
      "startOffset" : 160,
      "endOffset" : 164
    }, {
      "referenceID" : 3,
      "context" : "This work improved the existing CP-based sequential pattern mining approaches [4,5] up to the point that it also surpasses specialized mining systems in terms of efficiency.",
      "startOffset" : 78,
      "endOffset" : 83
    }, {
      "referenceID" : 4,
      "context" : "This work improved the existing CP-based sequential pattern mining approaches [4,5] up to the point that it also surpasses specialized mining systems in terms of efficiency.",
      "startOffset" : 78,
      "endOffset" : 83
    }, {
      "referenceID" : 8,
      "context" : "To do so, we combined advanced ideas from the sequence mining literature, namely last-position lists [9], as well as from the CP literature, namely memory-efficient data-structures for storing and restoring state during backtracking search.",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 4,
      "context" : "There are other constraints which change the subsequence relation and which would hence require hardcoding changes in the propagator (gap [5], span, etc).",
      "startOffset" : 138,
      "endOffset" : 141
    }, {
      "referenceID" : 1,
      "context" : "Our work shows that generic CP solvers can indeed be used as framework to build scalable mining algorithms, not just for generic yet less scalable systems as was done for itemset mining [2].",
      "startOffset" : 186,
      "endOffset" : 189
    } ],
    "year" : 2016,
    "abstractText" : "The main advantage of Constraint Programming (CP) approaches for sequential pattern mining (SPM) is their modularity, which includes the ability to add new constraints (regular expressions, length restrictions, etc). The current best CP approach for SPM uses a global constraint (module) that computes the projected database and enforces the minimum frequency; it does this with a filtering algorithm similar to the PrefixSpan method. However, the resulting system is not as scalable as some of the most advanced mining systems like Zaki’s cSPADE. We show how, using techniques from both data mining and CP, one can use a generic constraint solver and yet outperform existing specialized systems. This is mainly due to two improvements in the module that computes the projected frequencies: first, computing the projected database can be sped up by pre-computing the positions at which an symbol can become unsupported by a sequence, thereby avoiding to scan the full sequence each time; and second by taking inspiration from the trailing used in CP solvers to devise a backtracking-aware data structure that allows fast incremental storing and restoring of the projected database. Detailed experiments show how this approach outperforms existing CP as well as specialized systems for SPM, and that the gain in efficiency translates directly into increased efficiency for other settings such as mining with regular expressions.",
    "creator" : "LaTeX with hyperref package"
  }
}