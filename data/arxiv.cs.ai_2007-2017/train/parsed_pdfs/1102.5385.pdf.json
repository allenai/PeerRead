{
  "name" : "1102.5385.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "João Leite" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n10 2.\n53 85\nv2 [\ncs .A\nI] 1\nM ar"
    }, {
      "heading" : "1 Motivation",
      "text" : "In this paper we take a closer look at the relationship between the SE-model semantics and individual rules of a logic program. We identify a set of representatives of rule equivalence classes, which we dub canonical rules, characterise the class of sets of SE-interpretations that are representable by a single rule, and show how the corresponding canonical rules can be reconstructed from them. We believe that these results pave the way to view and manipulate a logic program as the set of sets of SE-models of each rule inside it. This is important in situations when the set of SE-models of the whole program fails to capture essential information encoded in individual rules inside it, such as when the program needs to be modified or further manipulated. With this in mind, we briefly discuss two new notions of equivalence, stronger than strong equivalence [1] and weaker than strong update equivalence [2].\nIn many extensions of Answer-Set Programming, individual rules of a program are treated as first-class citizens – apart from their prime role of encoding the answer sets\n⋆ This is an extended version of the paper accepted for publication at LPNMR 2011. Changes on March 1, 2011: minor substitutions to be in line with the LPNMR version.\nassigned to the program, they carry essential information about mutual interdependencies between literals that cannot be captured by answer sets. Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by “sacrificing” parts of an older program (such as in [3–11]). These approaches look at subsets of logic programs in search of plausible conflict resolutions. Some of them go even further and consider particular literals in heads and bodies of rules in order to identify conflicts and find ways to solve them. This often leads to definitions of new notions which are too syntax-dependent. At the same time, however, semantic properties of the very same notions need to be analysed, and their syntactic basis then frequently turns into a serious impediment.\nArguably, a more syntax-independent method for this kind of operations would be desirable. Not only would it be theoretically more appealing, but it would also allow for a better understanding of its properties with respect to the underlying semantics. Moreover, such a more semantic approach could facilitate the establishment of bridges with the area of Belief Change (see [12] for an introduction), and benefit from the many years of research where semantic change operations on monotonic logics have been studied, desirable properties for such operations have been identified, and constructive definitions of operators satisfying these properties have been introduced.\nHowever, as has repeatedly been argued in the literature [4, 13], fully semantic methods do not seem to be appropriate for the task at hand. Though their definition and analysis is technically possible and leads to very elegant and seemingly desirable properties, there are a number of simple examples for which these methods fail to provide results that would be in line with basic intuitions [4]. Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs. This can be demonstrated on simple programs P = { p., q. } and Q = { p., q ← p. } which are strongly equivalent, thus indistinguishable from the semantic perspective, but while P does not contain any dependencies, Q introduces a dependence of atom q upon atom p. This has far-reaching consequences, at least with respect to important notions from the logic programming point of view, such as that of support, which are themselves defined in syntactic rather than semantic terms. For example, if we change our beliefs about p, and come to believe that it is false, we may expect different beliefs regarding q, depending on whether we start form P , in which case q would still be true, or Q, in which case q would no longer be true because it is no longer supported.\nWe believe that rules indeed contain information that, to the best of our knowledge, cannot be captured by any of the existing semantics for Logic Programs. In many situations, this information is essential for making further decisions down the line. Therefore, any operation on logic programs that is expected to respect syntax-based properties like support cannot operate solely on the semantic level, but rather has to look inside the program and acknowledge rules as the atomic pieces of knowledge. At the same time, however, rules need not be manipulated in their original form. The abstraction provided by Logic Programming semantics such as SE-models can be used to discard\nunimportant differences between the syntactic forms of rules and focus on their semantic content. Thus, while a program cannot be viewed as the set of its models for reasons described above, it can still be viewed as a set of sets of models of rules in it. Such a shift of focus should make the approach easier to manage theoretically, while not neglecting the importance of literal dependencies expressed in individual rules. It could also become a bridge between existing approaches to rule evolution and properties as well as operator constructions known from Belief Change, not only highlighting the differences between them, but also clarifying why such differences arise in the first place.\nHowever, before a deeper investigation of such an approach can begin, we do need to know more about the relation of SE-models and individual rules. This is the aim of this paper, where we:\n– identify a set of representatives of rule equivalence classes induced by the SE-model semantics, which we dub canonical rules; – show how to reconstruct canonical rules from their sets of SE-models; – based on the above, characterise the sets of SE-interpretations that are repre-\nsentable by a single rule; – reveal connections between the set of SE-models of a rule and convex sublattices\nof the set of classical interpretations; – introduce two new notions of equivalence – stronger than strong equivalence [1]\nand weaker than strong update equivalence [2] – and argue that they are more suitable when rules are to be treated as first-class citizens.\nWe believe that these results provide important insights into the workings of SE-models with respect to individual rules and will serve as a toolset for manipulating logic programs at the semantic level.\nThe rest of this document is structured as follows: We introduce syntax and semantics of logic programs in Sect. 2 while in Sect. 3 we define the set of representatives for rule equivalence classes and introduce transformations pinpointing the expressivity of SE-model semantics with respect to individual rules. We also give two characterisations of the sets of SE-interpretations that are representable by a single rule. In Sect. 4 we discuss the relevance of our results and propose the two new notions of equivalence."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We assume to be given a nonempty, finite set of propositional atoms L from which we construct both propositional formulae and rules.\nPropositional formulae are formed in the usual way from propositional atoms in L, the logical constants ⊤ an ⊥, and the connectives ¬,∧,∨,⊂,⊃,≡. An interpretation is any subset of L, naturally inducing a truth assignment to all propositional formulae. If a formula φ is true under interpretation I , we also say that I is a model of φ. The set of all interpretations is denoted by I.\nSimilarly as for propositional formulae, the basic syntactic building blocks of rules are propositional atoms from L. A negative literal is an atom preceded by ∼, denoting default negation. A literal is either an atom or a negative literal. As a convention, double\ndefault negation is absorbed, so that ∼∼p denotes the atom p. Given a set of literals X , we introduce the following notation:\nX+ = { p ∈ L | p ∈ X } X− = { p ∈ L | ∼p ∈ X } ∼X = { ∼p | p ∈ X ∩ L }\nGiven natural numbers k, l,m, n and atoms p1, . . . , pk, q1, . . . , ql, r1, . . . , rm, s1, . . . , sn, we say the pair of sets of literals\n〈{ p1, . . . , pk,∼q1, . . . ,∼ql } , { r1, . . . , rm,∼s1, . . . ,∼sn }〉 (1)\nis a rule. The first component of a rule (1) is denoted by H(r) and the second by B(r). We say H(r) is the head of r, H(r)+ is the positive head of r, H(r)− is the negative head of r, B(r) is the body of r, B(r)+ is the positive body of r and B(r)− is the negative body of r. Usually, for convenience, instead of a rule r of the form (1) we write the expression\np1; . . . ; pk;∼q1; . . . ;∼ql ← r1, . . . , rm,∼s1, . . . ,∼sn. (2)\nor, alternatively, H(r)+;∼H(r)− ← B(r)+,∼B(r)−. A rule is called positive if its head and body contain only atoms. A program is any set of rules.\nWe also introduce the following non-standard notion which we will need throughout the rest of the paper:\nDefinition 1 (Canonical Tautology). Let pε be an arbitrary but fixed atom. The canonical tautology, denoted by ε, is the rule pε ← pε.\nIn the following, we define two semantics for rules. One is that of classical models, where a rule is simply treated as a classical implication. The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18]. This second semantics is strictly more expressive than both classical models and the stable model semantics [19].\nC-Models. We introduce the classical model of a rule by translating the rule into a propositional formula: Given a rule r of the form (2), we define the propositional formula r as ∨ { p1, . . . , pk,¬q1, . . . ,¬ql } ⊂ ∧\n{ r1, . . . , rm,¬s1, . . . ,¬sn }. Note that ∨ ∅ ≡ ⊥ and ∧\n∅ ≡ ⊤. A classical model, or C-model, of a rule r is any model of the formula r. The set of all C-models of a rule r is denoted by modC (r).\nWe say a rule r is a C-tautology, or C-tautological, if modC (r) = I. Otherwise, r is non-C-tautological. We say two rules r, r′ are C-equivalent if they have the same set of C-models. Note that the canonical tautology ε (c.f. Definition 1) is C-tautological.\nSE-Models. Given a rule r and an interpretation J , we define the reduct of r relative to J , denoted by rJ , as follows: If some atom from H(r)− is false under J or some atom from B(r)− is true under J , then rJ is ε; otherwise rJ is H(r)+ ← B(r)+. Intuitively, the reduct rJ is the positive part of a rule r that “remains” after all its negative literals are interpreted under interpretation J . The two conditions in the definition check whether the rule is satisfied based on the negative atoms in its head and body, interpreted under J . If this is the case, the reduct is by definition the canonical tautology. If none of\nthese conditions is satisfied, the positive parts of r are kept in the reduct, discarding the negative ones.\nAn SE-interpretation is a pair of interpretations 〈I, J〉 such that I is a subset of J . The set of all SE-interpretations is denoted by ISE. We say that an SE-interpretation 〈I, J〉 is an SE-model of a rule r if J is a C-model of r and I is a C-model of rJ . The set of all SE-models of a rule r is denoted by modSE (r). The SE-models of a program P are the SE-models of all rules in P . A set of SE-interpretations S is called rule-representable if there exists a rule r such that S = modSE (r).\nWe say that a rule r is SE-tautological if modSE (r) = ISE. Note that the canonical tautology ε (c.f. Definition 1) is SE-tautological. We say that two rules r, r′ are strongly equivalent, or SE-equivalent, if they have the same set of SE-models."
    }, {
      "heading" : "3 Rule Equivalence Classes and their Canonical Rules",
      "text" : "Our goal is to find useful insights into the inner workings of the SE-model semantics with respect to single rules. In order to do so, we first introduce a set of representatives of rule equivalence classes induced by SE-models and show how the representative of a class can be constructed given one of its members. Then we show how to reconstruct a representative from the set of its SE-models. Finally, we pinpoint the conditions under which a set of SE-interpretations is rule-representable."
    }, {
      "heading" : "3.1 Canonical Rules",
      "text" : "We start by bringing out simple but powerful transformations that simplify a given rule while preserving its SE-models. Most of these results have already been formulated in various ways [20, 2, 21]. The following result summarises the conditions under which a rule is SE-tautological:\nLemma 2 (Consequence of Theorem 4.4 in [2]; part i) of Lemma 2 in [21]). Let H and B be sets of literals and p be an atom. Then a rule is SE-tautological if it takes any of the following forms:\np;H ← p,B. H ;∼p ← B,∼p. H ← B, p,∼p.\nProof. See Appendix A, page 16. ⊓⊔\nThus, repeating an atom in different “components” of the rule frequently causes the rule to be SE-tautological. In particular, this happens if the same atom occurs in the positive head and positive body, or in the negative head and negative body, or in the positive and negative bodies of a rule. How about the cases when the head contains a negation of a literal from the body? The following Lemma clarifies this situation:\nLemma 3 (Consequence of (3) and (4) in Lemma 1 in [21]). Let H and B be sets of literals and L be a literal. Then rules of the following forms are SE-equivalent:\nH ;∼L ← L,B. H ← L,B. (3)\nProof. See Appendix A, page 17. ⊓⊔\nSo if a literal is present in the body of a rule, its negation can be removed from the head. Until now we have seen that a rule r that has a common atom in at least two of the sets H(r)+∪H(r)−, B(r)+ and B(r)− is either SE-tautological, or SE-equivalent to a rule where the atom is omitted from the rule’s head. So such a rule is always SE-equivalent either to the canonical tautology ε, or to a rule without such repetitions. Perhaps surprisingly, repetitions in positive and negative head cannot be simplified away. For example, over the alphabet Lp = { p }, the rule “p;∼p ← .” has two SE-models, 〈∅, ∅〉 and 〈{ p } , { p }〉, so it is not SE-tautological, nor is it SE-equivalent to any of the facts “p.” and “∼p.”. Actually, it is not very difficult to see that it is not SE-equivalent to any other rule, even over larger alphabets. So the fact that an atom is in both H(r)+ and H(r)− cannot all by itself imply that some kind of SE-models preserving rule simplification is possible.\nThe final Lemma reveals a special case in which we can eliminate the whole negative head of a rule and move it to its positive body. This occurs whenever the positive head is empty.\nLemma 4 (Related to Corollary 4.10 in [20] and Corollary 1 in [21]). Let H− be a set of negative literals, B be a set of literals and p be an atom. Then rules of the following forms are SE-equivalent:\n∼p;H− ← B. H− ← p,B.\nProof. See Appendix A, page 17. ⊓⊔\nArmed with the above results, we can introduce the notion of a canonical rule. Each such rule represents a different equivalence class on the set of all rules induced by the SE-model semantics. In other words, every rule is SE-equivalent to exactly one canonical rule. After the definition, we provide constructive transformations which show that this is indeed the case. Note that the definition can be derived directly from the Lemmas above:\nDefinition 5 (Canonical Rule). We say a rule r is canonical if either it is ε, or the following conditions are satisfied:\n1. The sets H(r)+ ∪H(r)−, B(r)+ and B(r)− are pairwise disjoint. 2. If H(r)+ is empty, then H(r)− is also empty.\nThis definition is closely related with the notion of a fundamental rule introduced in Definition 1 of [21]. There are two differences between canonical and fundamental rules: (1) a fundamental rule must satisfy condition 1. above, but need not satisfy condition 2.; (2) no SE-tautological rule is fundamental. As a consequence, fundamental rules do not cover all rule-representable sets of SE-interpretations, and two distinct fundamental rules may still be SE-equivalent. From the point of view of rule equivalence classes induced by SE-model semantics, there is one class that contains no fundamental rule, and some classes contain more than one fundamental rule. In the following we show that canonical rules overcome both of these limitations of fundamental rules. In\nother words, every rule is SE-equivalent to exactly one canonical rule. To this end, we define constructive transformations that directly show the mutual relations between rule syntax and semantics.\nThe following transformation provides a direct way of constructing a canonical rule that is SE-equivalent to a given rule r.\nDefinition 6 (Transformation into a Canonical Rule). Given a rule r, by can(r) we denote a canonical rule constructed as follows: If any of the sets H(r)+ ∩ B(r)+, H(r)− ∩B(r)− and B(r)+ ∩B(r)− is nonempty, then can(r) is ε. Otherwise, can(r) is of the form H+;∼H− ← B+,∼B−. where\n– H+ = H(r)+ \\B(r)−. – If H+ is empty, then H− = ∅ and B+ = B(r)+ ∪H(r)−. – If H+ is nonempty, then H− = H(r)− \\B(r)+ and B+ = B(r)+. – B− = B(r)−.\nCorrectness of the transformation follows directly from Lemmas 2 to 4.\nTheorem 7. Every rule r is SE-equivalent to the canonical rule can(r).\nProof. See Appendix A, page 18. ⊓⊔\nWhat remains to be proven is that no two different canonical rules are SE-equivalent. In the next Subsection we show how every canonical rule can be reconstructed from the set of its SE-models. As a consequence, no two different canonical rules can have the same set of SE-models."
    }, {
      "heading" : "3.2 Reconstructing Rules",
      "text" : "In order to reconstruct a rule r from the set S of its SE-models, we need to understand how exactly each literal in the rule influences its models. The following Lemma provides a useful characterisation of the set of countermodels of a rule in terms of syntax:\nLemma 8 (Different formulation of Theorem 4 in [21]). Let r be a rule. An SE-interpretation 〈I, J〉 is not an SE-model of r if and only if the following conditions are satisfied:\n1. H(r)− ∪B(r)+ ⊆ J and J ⊆ L \\B(r)−. 2. Either J ⊆ L \\H(r)+ or both B(r)+ ⊆ I and I ⊆ L \\H(r)+.\nProof. See Appendix A, page 18. ⊓⊔\nThe first condition together with the first disjunct of the second condition hold if and only if J is not a C-model of r. The second disjunct then captures the case when I is not a C-model of rJ .\nIf we take a closer look at these conditions, we find that the presence of a negative body atom in J guarantees that the first condition is falsified, so 〈I, J〉 is a model of r, regardless of the content of I . Somewhat similar is the situation with positive head atoms – whenever such an atom is present in I , it is also present in J , so the second\ncondition is falsified and 〈I, J〉 is a model of r. Thus, if S is the set of SE-models of a rule r, then every atom p ∈ B(r)− satisfies\np ∈ J implies 〈I, J〉 ∈ S (CB−)\nand every atom p ∈ H(r)+ satisfies\np ∈ I implies 〈I, J〉 ∈ S . (CH+ )\nIf we restrict ourselves to canonical rules different from ε, we find that these conditions are not only necessary, but, when combined properly, also sufficient to decide what atoms belong to the negative body and positive head of the rule.\nFor the rest of this Subsection, we assume that r is a canonical rule different from ε and S is the set of SE-models of r. Keeping in mind that every atom that satisfies condition (CB−) also satisfies condition (CH+ ) (because I is a subset of J), and that B(r)− is by definition disjoint from H(r)+, we arrive at the following results:\nLemma 9. An atom p belongs to B(r)− if and only if for all 〈I, J〉 ∈ ISE, the condition (CB−) is satisfied. An atom p belongs to H(r)+ if and only if it does not belong to B(r)− and for all 〈I, J〉 ∈ ISE, the condition (CH+ ) is satisfied.\nProof. See Appendix A, page 19. ⊓⊔\nAs can be seen from Lemma 8, the role of positive body and negative head atoms is dual to that of negative body and positive head atoms. Intuitively, their absence in J , and sometimes also in I , implies that 〈I, J〉 is an SE-model of r. It follows from the first condition of Lemma 8 that if p belongs to H(r)− ∪B(r)+, then the following condition is satisfied:\np /∈ J implies 〈I, J〉 ∈ S . (CH− )\nFurthermore, the second condition in Lemma 8 implies that every p ∈ B(r)+ satisfies the following condition:\np /∈ I and J ∩H(r)+ 6= ∅ implies 〈I, J〉 ∈ S . (CB+ )\nThese observations lead to the following results:\nLemma 10. An atom p belongs to B(r)+ if and only if for all 〈I, J〉 ∈ ISE, the conditions (CH− ) and (CB+ ) are satisfied. An atom p belongs to H(r)− if and only if it does not belong to B(r)+ and for all 〈I, J〉 ∈ ISE, the condition (CH− ) is satisfied.\nProof. See Appendix A, page 21. ⊓⊔\nTogether, the two Lemmas above are sufficient to reconstruct a canonical rule from its set of SE-models. The following definition sums up these results by introducing the notion of a rule induced by a set of SE-interpretations:\nDefinition 11 (Rule Induced by a Set of SE-Interpretations). Let S be a set of SE-interpretations. An atom p is called an S-negative-body atom if every SE-interpretation 〈I, J〉 with p ∈ J belongs to S. An atom p is called an S-positive-head atom if it is not an S-negative-body atom and every SE-interpretation 〈I, J〉 with p ∈ I belongs to S.\nAn atom p is called an S-positive-body atom if every SE-interpretation 〈I, J〉 with p /∈ J belongs to S, and every SE-interpretation 〈I, J〉 with p /∈ I and J containing some S-positive-head atom also belongs to S. An atom p is called an S-negative-head atom if it is not an S-positive-body atom and every SE-interpretation 〈I, J〉 with p /∈ J belongs to S.\nThe sets of all S-negative-body, S-positive-head, S-positive-body and S-negative-head atoms are denoted by B(S)−, H(S)+, B(S)+ and H(S)−, respectively. The rule induced by S, denoted by rule(S), is defined as follows: If S = ISE, then rule(S) is ε; otherwise, rule(S) is of the form\nH(S)+;∼H(S)− ← B(S)+,∼B(S)−.\nThe main property of induced rules is that every canonical rule is induced by its own set of SE-models and can thus be “reconstructed” from its set of SE-models. This follows directly from Definition 11 and Lemmas 9 and 10.\nTheorem 12. For every canonical rule r, rule(modSE (r)) = r.\nProof. See Appendix A, page 21. ⊓⊔\nThis result, together with Theorem 7, has a number of consequences. First, for any rule r, the canonical rule can(r) is induced by the set of SE-models of r.\nCorollary 13. For every rule r, rule(modSE (r)) = can(r).\nProof. Follows directly from Theorem 7 and Theorem 12. ⊓⊔\nFurthermore, Theorem 12 directly implies that for two different canonical rules r1, r2 we have rule(modSE (r1)) = r1 and rule(modSE (r2)) = r2, so modSE (r1) and modSE (r2) must differ.\nCorollary 14. No two different canonical rules are SE-equivalent.\nProof. Follows directly from the Theorem 12. ⊓⊔\nFinally, the previous Corollary together with Theorem 7 imply that for every rule there not only exists an SE-equivalent canonical rule, but this rule is also unique.\nCorollary 15. Every rule is SE-equivalent to exactly one canonical rule.\nProof. Follows directly from Theorem 7 and Corollary 14. ⊓⊔\n3.3 Sets of SE-Interpretations Representable by a Rule\nNaturally, not all sets of SE-interpretations correspond to a single rule, otherwise any program could be reduced to a single rule. The conditions under which a set of SE-interpretations is rule-representable are worth examining.\nA set of SE-models S of a program is always well-defined, i.e. whenever S contains 〈I, J〉, it also contains 〈J, J〉. Moreover, for every well-defined set of SE-interpretations S there exists a program P such that S = modSE (P) [10].\nWe offer two approaches to find a similar condition for the class of rulerepresentable sets of SE-interpretations. The first is based on induced rules defined in the previous Subsection, while the second is formulated using lattice theory and is a consequence of Lemma 8.\nThe first characterisation follows from two properties of the rule(·) transformation. First, it can be applied to any set of SE-interpretations, even those that are not rulerepresentable. Second, if rule(S) = r, then it holds that modSE (r) is a subset of S.\nLemma 16. The set of all SE-models of a canonical rule r is the least among all sets of SE-interpretations S such that rule(S) = r.\nProof. See Appendix A, page 22. ⊓⊔\nThus, to verify that S is rule-representable, it suffices to check that all interpretations from S are models of rule(S).\nThe second characterisation follows from Lemma 8 which tells us that if S is rulerepresentable, then its complement consists of SE-interpretations 〈I, J〉 following a certain pattern. Their second component J always contains a fixed set of atoms and is itself contained in another fixed set of atoms. Their first component I satisfies a similar property, but only if a certain further condition is satisfied by J . More formally, for the sets\nI⊥ = B(r)+, I⊤ = L \\H(r)+, J⊥ = H(r)− ∪B(r)+, J⊤ = L \\B(r)−,\nit holds that all SE-interpretations from the complement of S are of the form 〈I, J〉 where J⊥ ⊆ J ⊆ J⊤ and either J ⊆ I⊤ or I⊥ ⊆ I ⊆ I⊤. It turns out that this also holds vice versa: if the complement of S satisfies the above property, then S is rule-representable. Furthermore, to accentuate the particular structure that arises, we can substitute the condition J⊥ ⊆ J ⊆ J⊤ with saying that J belongs to a convex sublattice of I.1 A similar substitution can be performed for I , yielding:\nTheorem 17. Let S be a set of SE-interpretations. Then the following conditions are equivalent:\n1. The set of SE-interpretations S is rule-representable. 2. All SE-interpretations from S are SE-models of rule(S).\n1 A sublattice L of L′ is convex if c ∈ L whenever a, b ∈ L and a ≤ c ≤ b holds in L′. For more details see e.g. [22].\n3. There exist convex sublattices L1, L2 of 〈I,⊆〉 such that the complement of S relative to ISE is equal to\n{ 〈I, J〉 ∈ ISE ∣ ∣ I ∈ L1 ∧ J ∈ L2 } ∪ { 〈I, J〉 ∈ ISE ∣ ∣ J ∈ L1 ∩ L2 } .\nProof. See Appendix A, page 24. ⊓⊔"
    }, {
      "heading" : "4 Discussion",
      "text" : "The presented results mainly serve to facilitate the transition back and forth between a rule and the set of its SE-models. They also make it possible to identify when a given set of SE-models is representable by a single rule. We believe that in situations where information on literal dependencies, expressed in individual rules, is essential for defining operations on logic programs, the advantages of dealing with rules on the level of semantics instead of on the level of syntax are significant. The semantic view takes care of stripping away unnecessary details and since the introduced notions and operators are defined in terms of semantic objects, it should be much easier to introduce and prove their semantic properties.\nThese results can be used for example in the context of program updates to define an update semantics based on the rule rejection principle [4] and operating on sets of sets of SE-models. Such a semantics can serve as a bridge between syntax-based approaches to rule updates, and the principles and semantic distance measures known from the area of Belief Change. The next steps towards such a semantics involve a definition of the notion of support for a literal by a set of SE-models (of a rule). Such a notion can then foster a better understanding of desirable properties for semantic rule update operators.\nOn a different note, viewing a logic program as the set of sets of SE-models of rules inside it leads naturally to the introduction of the following new notion of program equivalence:\nDefinition 18 (Strong Rule Equivalence). Programs P1,P2 are SR-equivalent, denoted by P1 ≡SR P2, if\n{modSE (r) | r ∈ P1 ∪ { ε } } = {modSE (r) | r ∈ P2 ∪ { ε } } .\nThus, two programs are SR-equivalent if they contain the same rules, modulo the SE-model semantics. We add ε to each of the two programs in the definition so that presence or absence of tautological rules in a program does not influence program equivalence. SR-equivalence is stronger than strong equivalence, in the following sense:\nDefinition 19 (Strength of Program Equivalence). Let ≡1,≡2 be equivalence relations on the set of all programs. We say that ≡1 is at least as strong as ≡2, denoted by ≡1 ≡2, if P1 ≡1 P2 implies P1 ≡2 P2 for all programs P1,P2. We say that ≡1 is stronger than ≡2, denoted by ≡1≻≡2, if ≡1 ≡2 but not ≡2 ≡1.\nThus, using the notation of the above definition, we can write ≡SR ≻≡S, where ≡S denotes the relation of strong equivalence. An example of programs that are strongly\nequivalent, but not SR-equivalent is P = { p., q. } and Q = { p., q ← p. }, which in many cases need to be distinguished from one another. We believe that this notion of program equivalence is much more suitable for cases when the dependency information contained in a program is of importance.\nIn certain cases, however, SR-equivalence may be too strong. For instance, it may be desirable to treat programs such as P1 = { p ← q. } and P2 = { p ← q., p ← q, r. } in the same way because the extra rule in P2 is just a weakened version of the rule in P1. For instance, the notion of update equivalence introduced in [23], which is based on a particular approach to logic program updates, considers programs P1 and P2 as equivalent because the extra rule in P2 cannot influence the result of any subsequent updates. Since these programs are not SR-equivalent, we also introduce the following notion of program equivalence, which in terms of strength falls between strong equivalence and SR-equivalence.\nDefinition 20 (Strong Minimal Rule Equivalence). ProgramsP1,P2 are SMR-equivalent, denoted by P1 ≡SMR P2, if\nmin {modSE (r) | r ∈ P1 ∪ { ε } } = min {modSE (r) | r ∈ P2 ∪ { ε } } ,\nwhere minS denotes the set of subset-minimal elements of S.\nIn order for programs to be SMR-equivalent, they need not contain exactly the same rules (modulo strong equivalence), it suffices if rules with subset-minimal sets of SE-models are the same (again, modulo strong equivalence). Certain programs, such as P1 and P2 above, are not SR-equivalent but they are still SMR-equivalent.\nRelated to this is the very strong notion of equivalence which was introduced in [2]:\nDefinition 21 (Strong Update Equivalence, c.f. Definition 4.1 in [2]). Two programs P1, P1 are SU-equivalent, denoted by P1 ≡SU P2, if for any programs Q, R it holds that the program ((P1\\Q)∪R) has the same answer sets as the program ((P2\\Q)∪R).\nTwo programs are strongly update equivalent only under very strict conditions – it is shown in [2] that two programs are SU-equivalent if and only if their symmetric difference contains only SE-tautological rules. This means that programs such as Q1 = {∼p. }, Q2 = {← p. } and Q3 = {∼p ← p. } are considered to be mutually nonequivalent, even though the rules they contain are mutually SE-equivalent. This may be seen as too sensitive to rule syntax.\nThe following result formally establishes the relations between the discussed notions of program equivalence:\nTheorem 22. SU-equivalence is stronger than SR-equivalence, which itself is stronger than SMR-equivalence, which in turn is stronger than strong equivalence. That is,\n≡SU≻≡SR≻≡SMR≻≡S .\nProof. See Appendix A, page 24. ⊓⊔\nThe other notion of program equivalence introduced in [2], strong update equivalence on common rules, or SUC-equivalence, is incomparable in terms of strength to our new notions of equivalence. On the one hand, SR- and SMR-equivalent programs such as {∼p. } and {∼p.,← p. } are not SUC-equivalent. On the other hand, programs such as { p., q ← p. } and { q., p ← q. } are neither SR- nor SMR-equivalent, but they are SUC-equivalent. We believe that both of these examples are more appropriately treated by the new notions of equivalence.\nThe introduction of canonical rules, which form a set of representatives of rule equivalence classes induced by SE-models, also reveals the exact expressivity of SE-model semantics with respect to a single rule. From their definition we can see that SE-models are capable of distinguishing between any pair of rules, except for (1) a pair of rules that only differ in the number of repetitions of literals in their heads and bodies; (2) an integrity constraint and a rule whose head only contains negative literals. We believe that in the former case, there is little reason to distinguish between such rules and so the transition from rules to their SE-models has the positive effect of stripping away of unnecessary details. However, the latter case has more serious consequences. Although rules such as\n∼p ← q. and ← p, q.\nare usually considered to carry the same meaning, some existing work suggests that they should be treated differently – while the former rule gives a reason for atom p to become false whenever q is true, the latter rule simply states that the two atoms cannot be true at the same time, without specifying a way to resolve this situation if it were to arise [4, 8]. If we view a rule through the set of its SE-models, we cannot distinguish these two kinds of rules anymore. Whenever this is important, either strong update equivalence is used, which is perhaps too sensitive to the syntax of rules, or a new characterisation of Answer-Set Programming needs to be discovered, namely one that is not based on the logic of Here-and-There [16, 17]."
    }, {
      "heading" : "Acknowledgement",
      "text" : "We would like to thank Han The Anh, Matthias Knorr and the anonymous reviewers for their comments that helped to improve the paper. Martin Slota is supported by FCT scholarship SFRH / BD / 38214 / 2007."
    }, {
      "heading" : "A Proofs",
      "text" : "Lemma 2. Let H and B be sets of literals and p be an atom. Then a rule is SE-tautological if it takes any of the following forms:\np;H ← p,B. H ;∼p ← B,∼p. H ← B, p,∼p.\nProof. First assume that rule r is of the first form. We need to show that any SE-interpretation is an SE-model of r. Suppose 〈I, J〉 is some SE-interpretation. Rule r is C-tautological, so J is a C-model of r. Furthermore, rJ is either ε, or it inherits p in both its head and body from r. In any case, r is C-tautological, so I is a C-model of rJ . Consequently, 〈I, J〉 is an SE-model of r.\nNow suppose r is of the second form. As before, given an SE-interpretation 〈I, J〉, we see that J is a C-model of r because r is C-tautological. Furthermore, rJ will necessarily end up being equal to ε because of the atom p common to H(r)− and B(r)−, regardless of how J interprets p. So I is a C-model of rJ , and, consequently, 〈I, J〉 is an SE-model of r.\nFinally, suppose r takes the third form and take an SE-interpretation 〈I, J〉. Rule r can again easily be verified to be C-tautological, so J is a C-model of r. If all atoms from B(r)− are false under J , then rJ contains the atom p in its body that is false under J , thus also false under I since I is a subset of J . Consequently, I is a C-model of rJ . On the other hand, if at least one of atoms from B(r)− is true under J , then rJ is equal to ε, so again, I is a C-model of rJ . Consequently, 〈I, J〉 is an SE-model of r. ⊓⊔\nLemma 23. Let H and B be sets of literals and p be an atom. Then rules of the following forms are SE-equivalent:\np;H ← B,∼p. H ← B,∼p.\nProof. Let the first rule be denoted by r1 and the second by r2 and suppose 〈I, J〉 is an SE-interpretation. We will show that 〈I, J〉 is an SE-model of r1 if and only if it is an SE-model of r2. We can easily see that rules r1, r2 are C-equivalent. So J is either not a C-model of any of them or it is a C-model of both of them. In the former case, 〈I, J〉 is not an SE-model of any of the two rules and we are finished. In the latter case, we need to distinguish two cases:\na) If J is a not a model of the bodies of r1 and r2 (the bodies are identical), then either rJ1 and r J 2 are equal to ε, or they contain an atom in their bodies that is false under\nJ , thus also false under I because I is a subset of J . In any case, I is a C-model of both rJ1 and r J 2 , so 〈I, J〉 is an SE-model of both r1 and r2. b) If J is a model of the bodies of r1 and r2, then p is false under J , and, since J is a C-model of r1, some literal from H must be true under J . Consequently, either both rJ1 and r J 2 are equal to ε and I is a C-model of both of them, or r J 1 and r J 2\nonly differ in the single extra atom p that rJ1 has in the head. However, since I is a subset of J and p is false under J , p cannot be true under I , so I is either not a C-model of any of rJ1 , r J 2 , or it is a C-model of both of them. In any case, 〈I, J〉 is a SE-model of r1 if and only if it is an SE-model of r2.\nThus, we have proven that every SE-interpretation is an SE-model of r1 if and only if it is an SE-model of r2. In other words, r1 and r2 are SE-equivalent. ⊓⊔\nLemma 24. Let H and B be sets of literals and p be an atom. Then rules of the following forms are SE-equivalent:"
    }, {
      "heading" : "H ;∼p ← p,B. H ← p,B.",
      "text" : "Proof. Let the first rule be denoted by r1 and the second by r2. Suppose 〈I, J〉 is some SE-interpretation. If p is false under J , then J is a C-model of both r1 and r2. Furthermore, rJ1 is equal to ε and r J 2 is either equal to ε or its body contains p, and so is not true under I . In any case, I is a C-model of both rJ1 and r J 2 , so 〈I, J〉 is an SE-model of both r1 and r2. On the other hand, if p is true under J , then J is a C-model of r1 if and only if it is a C-model of r2 because the extra literal ∼a in the head of r1 cannot be satisfied. Also, rJ1 is identical to r J 2 , so I is a C-model of r J 1 if and only if it is a C-model of r J 2 . Consequently, 〈I, J〉 is an SE-model of r1 if and only if it is an SE-model of r2. Thus, we have proven that every SE-interpretation is an SE-model of r1 if and only if it is an SE-model of r2. In other words, r1 and r2 are SE-equivalent. ⊓⊔\nLemma 3. Let H and B be sets of literals and L be a literal. Then rules of the following forms are SE-equivalent:\nH ;∼L ← L,B. H ← L,B. (4)\nProof. Follows from Lemmas 23 and 24. ⊓⊔\nLemma 4. Let H− be a set of negative literals, B be a set of literals and p be an atom. Then rules of the following forms are SE-equivalent:\n∼p;H− ← B. H− ← p,B.\nProof. Let the first rule be denoted by r1 and the second by r2. Suppose 〈I, J〉 is some SE-interpretation. If p is false under J , then J is a C-model of both r1 and r2. Furthermore, rJ1 is equal to ε and the body of r J 2 cannot be satisfied by I because I is a subset of J and p is not in J . Thus, I is a C-model of both rJ1 and r J 2 , and 〈I, J〉 is an SE-model of both r1 and r2. On the other hand, if p is true under J , then we need to consider two cases:\na) If J is not a C-model of r1, then it also cannot be a C-model of r2 because, as can easily be verified, r1 is C-equivalent to r2. Hence, 〈I, J〉 is an SE-model of neither r1 nor r2. b) If J is a C-model of r1, then it must also be a C-model of r2 because r1 is C-equivalent to r2. Furthermore, rJ1 and r J 2 are either both equal to ε, or their heads are\nempty and rJ2 has the extra atom p in the body. In the latter case, if I were a model of the body of rJ1 , then J would be a model of the body of r1 but not of its head (which contains only negative literals), which contradicts the assumption that J is a model of r1. Thus, I is not a model of the body of rJ1 , so it cannot be a model of the body of rJ2 either. So I is a C-model of both r J 1 and r J 2 and 〈I, J〉 is an SE-model of both r1 and r2.\nThus, we have proven that every SE-interpretation is an SE-model of r1 if and only if it is an SE-model of r2. In other words, r1 and r2 are SE-equivalent. ⊓⊔\nTheorem 7. Every rule r is SE-equivalent to the canonical rule can(r).\nProof. This can be shown by a careful iterative application of Lemmas 2 to 4. First observe that if can(r) is equal to ε, then by Lemma 2 the rule r is indeed SE-equivalent to ε.\nIn the principal case we can use Lemma 23 on all atoms shared between the positive head and negative body of r and remove them one by one from the positive head of r while preserving SE-equivalence. Similar situation occurs with atoms shared between the negative head and positive body of r, which can be, according to Lemma 24, removed from the negative head of r while preserving SE-equivalence. After these steps are performed, we obtain the rule\n(H(r)+ \\B(r)−);∼(H(r)− \\B(r)+) ← B(r)+,∼B(r)−. (5)\nThis is also the result of the defined transformation, unless the set H(r)+ \\ B(r)− is empty. In that case, one can repeatedly apply Lemma 4 to move the atoms from the negative head of rule (5) into its positive body. In this case, the transformation returns the canonical rule\n← (B(r)+ ∪H(r)−),∼B(r)−. ⊓⊔\nLemma 8. Let r be a rule. An SE-interpretation 〈I, J〉 is not an SE-model of r if and only if the following conditions are satisfied:\n1. H(r)− ∪B(r)+ ⊆ J and J ⊆ L \\B(r)−. 2. Either J ⊆ L \\H(r)+ or both B(r)+ ⊆ I and I ⊆ L \\H(r)+.\nProof. Suppose first that the above conditions hold. We will show that 〈I, J〉 is not an SE-model of r. Due to the first condition, rJ is equal to H(r)+ ← B(r)+ and due to the second condition, either J is not a C-model of r, or I contains the body of rJ but does not contain any atom from its head, which means I is not a C-model of rJ . Consequently, 〈I, J〉 is not an SE-model of r.\nNow suppose I, J are two interpretations such that the above conditions do not hold. We will show that 〈I, J〉 is an SE-model of r. We need to consider the following four cases:\na) If J does not contain some atom from the negative head of r or it contains an atom from the negative body of r, then J is a C-model of r and rJ is ε, so I is a C-model of rJ . Consequently, 〈I, J〉 is an SE-model of r. b) If J does not contain some atom from the positive body of r, then J is a C-model of r and I is a C-model of rJ due to the fact that I is a subset of J . Consequently, 〈I, J〉 is an SE-model of r. c) If J contains an atom from the positive head of r and I does not include the positive body of r, then J is a C-model of r and I is a C-model of rJ . Consequently, 〈I, J〉 is an SE-model of r. d) If J contains some atom from the positive head of r and I also contains some atom from the positive head of r, then J is a C-model of r and I is a C-model of rJ . Consequently, 〈I, J〉 is an SE-model of r. ⊓⊔\nCorollary 25. Let r be a canonical rule different from ε, put I = B(r)+, J = H(r)−∪ B(r)+ and J ′ = L \\B(r)−, and let p be an atom. Then the following holds:\n(1) The SE-interpretation 〈I, J〉 is not an SE-model of r. (2) The SE-interpretation 〈I, J ∪ { p }〉 is an SE-model of r if and only if p belongs to\nB(r)−. (3) The SE-interpretation 〈I ∪ { p } , J ∪ { p }〉 is an SE-model of r if and only if p\nbelongs to H(r)+ ∪B(r)−. (4) The SE-interpretation 〈I, J ′〉 is not an SE-model of r.\nProof. All parts of the Corollary easily follow from Lemma 8 and the disjointness properties satisfied by canonical rules. ⊓⊔\nLemma 26. Let r be a canonical rule different from ε and S be the set of SE-models of r. An atom p belongs to B(r)− if and only if for all 〈I, J〉 ∈ ISE,\np ∈ J implies 〈I, J〉 ∈ S . (CB−)\nProof. Suppose p belongs to B(r)− and take some SE-interpretation 〈I, J〉 such that p is in J . Then J is a C-model of r and rJ is equal to ε, so I is a C-model of rJ . Hence, 〈I, J〉 is an SE-model of r, and since the choice of 〈I, J〉 was arbitrary, we conclude that p satisfies condition (CB−).\nNow let I0 = B(r)+ and J0 = H(r)−∪B(r)+ and suppose p is an atom satisfying condition (CB−). Then the SE-interpretation 〈I0, J0 ∪ { p }〉 must belong to S and by Corollary 25(2) we conclude that p belongs to B(r)−. ⊓⊔\nLemma 27. Let r be a canonical rule different from ε and S be the set of SE-models of r. An atom p belongs to H(r)+ if and only if it does not belong to B(r)− and for all 〈I, J〉 ∈ ISE,\np ∈ I implies 〈I, J〉 ∈ S . (CH+ )\nProof. Suppose p belongs to H(r)+. Since r is a canonical rule, p does not belong to B(r)−. Take some SE-interpretation 〈I, J〉 such that p belongs to I . Then p must also belong to J , so J is a C-model of r and, for the same reason, I is a C-model of rJ . Consequently, 〈I, J〉 is an SE-model of r. Since the choice of 〈I, J〉 was arbitrary, we conclude that p satisfies condition (CH+ ).\nNow let I0 = B(r)+ and J0 = H(r)−∪B(r)+ and suppose p is an atom satisfying condition (CH+ ). Then the SE-interpretation 〈I0 ∪ { p } , J0 ∪ { p }〉 must belong to S and by Corollary 25(3) we conclude that p belongs to H(r)+ ∪ B(r)−. Moreover, by assumption we know that p does not belong to B(r)−, so it belongs to H(r)+. ⊓⊔\nLemma 9. An atom p belongs to B(r)− if and only if for all 〈I, J〉 ∈ ISE, the condition (CB−) is satisfied.\nAn atom p belongs to H(r)+ if and only if it does not belong to B(r)− and for all 〈I, J〉 ∈ ISE, the condition (CH+ ) is satisfied.\nProof. Follows from Lemmas 26 and 27.\nLemma 28. Let r be a canonical rule different from ε and S be the set of SE-models of r. An atom p belongs to B(r)+ if and only if for all 〈I, J〉 ∈ ISE the following conditions are satisfied:\np /∈ J implies 〈I, J〉 ∈ S ; (CH− )\nJ ∩H(r)+ 6= ∅ and p /∈ I implies 〈I, J〉 ∈ S . (CB+ )\nProof. Suppose p belongs to B(r)+ and take some SE-interpretation 〈I, J〉 such that p is not in J . Since I is a subset of J , we obtain p is not in I either. Hence, J is a C-model of r and I is a C-model of rJ and we conclude that 〈I, J〉 is an SE-model of r. The choice of 〈I, J〉 was arbitrary, so this implies that condition (CH− ) is satisfied for p.\nNow take some SE-interpretation 〈I, J〉 such that J ∩ H(r)+ 6= ∅ and p is not in I . From the former it follows that J is a C-model of r and from the latter that I is a C-model of rJ . Thus, 〈I, J〉 is an SE-model of r and since the choice of 〈I, J〉 was arbitrary, we conclude that condition (CB+ ) holds for p.\nFor the converse implication, suppose p is an atom satisfying conditions (CH− ) and (CB+ ). We consider two cases:\n1. If H(r)+ is empty, then since r is canonical, we know that H(r)− is also empty. So according to Corollary 25(1), the SE-interpretation 〈I0, J0〉, where I0 = J0 = B(r)+, does not belong to S. Furthermore, by condition (CH− ) we can conclude that 〈I0 \\ { p } , J0 \\ { p }〉 belongs to S. Thus, J0 must be different from J0 \\{ p }, so p must belong to J0 = B(r)+. 2. If H(r)+ is nonempty, then it follows from Corollary 25(4) that the SE-interpretation 〈I0, J0〉, where I0 = B(r)+ and J0 = L \\ B(r)−, does not belong to S. We can also conclude that J contains some atom from H(r)+ because, since r is canonical, H(r)+ is disjoint from B(r)−. Thus, by condition (CB+ ) we conclude that 〈I0 \\ { p } , J0〉 belongs to S. Consequently, I0 must be different from I0\\{ p }, so p belongs to I0 = B(r)+. ⊓⊔\nLemma 29. Let r be a canonical rule different from ε and S be the set of SE-models of r.An atom p belongs to H(r)− if and only if it does not belong to B(r)+ and for all 〈I, J〉 ∈ ISE,\np /∈ J implies 〈I, J〉 ∈ S . (CH− )\nProof. Suppose p is some atom from H(r)− and take some SE-interpretation 〈I, J〉 such that p is not in J . Then J is a C-model of r and rJ is equal to ε so I is a C-model of rJ . Consequently, 〈I, J〉 is an SE-model of r and since the choice of 〈I, J〉 was arbitrary, we conclude that condition (CH− ) is satisfied for p.\nNow let I0 = B(r)+ and J0 = H(r)− ∪B(r)+ and suppose p is an atom that does not belong to B(r)+ and it satisfies condition (CH− ). Corollary 25(1) guarantees that the SE-interpretation 〈I0, J0〉 is not an SE-model of r. Furthermore, from condition (CH− ) we obtain that the SE-interpretation 〈I0 \\ { p } , J0 \\ { p }〉 belongs to S. Thus, J0 must differ from J0 \\ { p }, which implies that p belongs to J0. Furthermore, since J0 = H(r)\n− ∪ B(r)+ and p does not belong to B(r)+, we conclude that p belongs to H(r)−. ⊓⊔\nLemma 10. An atom p belongs to B(r)+ if and only if for all 〈I, J〉 ∈ ISE, the conditions (CH− ) and (CB+ ) are satisfied.\nAn atom p belongs to H(r)− if and only if it does not belong to B(r)+ and for all 〈I, J〉 ∈ ISE, the condition (CH− ) is satisfied.\nProof. Follows from Lemmas 28 and 29.\nTheorem 12. For every canonical rule r, rule(modSE (r)) = r.\nProof. If r is equal to ε, then modSE (r) = ISE and by Definition 11, the rule rule(ISE) is equal to ε so the identity is satisfied.\nIn the principal case, r is a canonical rule different from ε. Let S be the set of SE-models of r. It follows from Definition 11 and Lemmas 26 to 29 that r = rule(S).\n⊓⊔\nLemma 30. Let S be a set of SE-interpretations different from ISE. Then the sets of H(S)+ ∪H(S)−, B(S)+ and B(S)− are pairwise disjoint.\nProof. Suppose that p is a member of both H(S)+∪H(S)− and B(S)+. Then, since p is an S-positive-body atom, it cannot be an S-negative-head atom by definition. Thus, p belongs to both H(S)+ and B(S)+. We will show that this is impossible given our assumption that S is different from ISE. Take an arbitrary SE-interpretation 〈I, J〉. If p belongs to I , then since p is an S-positive-head atom, 〈I, J〉 belongs to S. If p does not belong to I but it belongs to J , then J contains the S-positive-head atom p, so since p is an S-positive-body atom, 〈I, J〉 belongs to S. Finally, if p does not belong to J , then since p is an S-positive-body atom, 〈I, J〉 belongs to S. This means that S must contain all SE-interpretations and is in conflict with our assumption.\nNow suppose that p is a member of both H(S)+ ∪H(S)− and B(S)−. Then, since p is an S-negative-body atom, it cannot be an S-positive-head atom by definition. Thus, p belongs to both H(S)− and B(S)−. We will show that this is impossible given our assumption that S is different from ISE. Take an arbitrary SE-interpretation 〈I, J〉. If p belongs to J , then since p is an S-negative-body atom, 〈I, J〉 belongs to S. On the other hand, if p does not belong to J , then since p is an S-negative-head atom, 〈I, J〉 belongs to S. This means that S must contain all SE-interpretations and is in conflict with our assumption to the contrary.\nNext, suppose that p is a member of both B(S)+ and B(S)−. By the same arguments as in the previous case, this implies that S must be equal to ISE, contrary to the assumption.\nLemma 31. For every set of SE-interpretations S, rule(S) is a canonical rule.\nProof. If S is equal to ISE, then rule(S) is equal to the canonical rule ε and the proof is finished. Otherwise, rule(S) is of the form\nH(S)+;∼H(S)− ← B(S)+,∼B(S)−.\nTo show that this rule is canonical, we need to prove that the following conditions are satisfied:\n1. The sets H(S)+ ∪H(S)−, B(S)+ and B(S)− are pairwise disjoint. 2. If H(S)+ is empty, then H(S)− is also empty.\nThe first condition follows from Lemma 30. To prove the second condition, suppose H(S)+ is empty. Then by definition B(S)+ contains all atoms whose absence in J implies that 〈I, J〉 belongs to S. By definition, then, H(S)− stays empty. ⊓⊔\nLemma 16. The set of all SE-models of a canonical rule r is the least among all sets of SE-interpretations S such that rule(S) = r.\nProof. Let r be a canonical rule with the set of SE-models Sr. From Theorem 12 we know that rule(Sr) = r, so it remains to show that Sr is a subset of every set of SE-interpretations S such that rule(S) = r. Take one such S. In case r is the canonical tautology pε ← pε, it follows that H(S)+ = B(S)+ = { pε }. According to Lemma 30, this is possible only in case S = ISE = Sr, so it trivially holds that Sr is a subset of S.\nIn the principal case, r is different from the canonical tautology, so S must be different from ISE and from rule(S) = r we obtain that H(r)+ = H(S)+, H(r)− = H(S)−, B(r)+ = B(S)+ and B(r)− = B(S)−. Let 〈I, J〉 be an SE-model of r. Then one of the conditions of Lemma 8 must be violated. We distinguish the following four possible violations:\na) If H(S)−∪B(S)+ * J , then J does not contain some atom fromH(S)−∪B(S)+. From the definitions of S-negative-head atoms and S-positive-body atoms we then obtain that 〈I, J〉 belongs to S. b) If J * L \\ B(S)−, then J contains some atom from B(S)−. From the definition of S-negative-body atoms we then infer that 〈I, J〉 belongs to S. c) If J * L \\H(S)+ and B(S)+ * I , then J contains some atom from H(S)+ and I does not contain some atom from B(S)+. By the definition of S-positive-body atoms, 〈I, J〉 belongs to S. d) If J * L \\H(S)+ and I * L \\H(S)+, then I contains some atom from H(S)+. By the definition of S-positive-head atoms, 〈I, J〉 belongs to S. ⊓⊔\nProposition 32. A set of SE-interpretations S is rule-representable if and only if all SE-interpretations from S are SE-models of rule(S).\nProof. If S is a rule-representable set of SE-interpretations, then there exists some rule r such that S = modSE (r). Let r′ be the canonical rule can(r). According to Theorem 7, S = modSE (r′), and so Theorem 12 implies that rule(S) = rule(modSE (r′)) = r′. Thus, all SE-interpretations from S are SE-models of rule(S).\nOn the other hand, if all SE-interpretations in S are SE-models of the rule r = rule(S), then S is a subset of modSE (r). Also, by Lemma 31 it follows that r is canonical and so Lemma 16 implies that modSE (r) is a subset of S. Consequently, S = modSE (r). ⊓⊔\nProposition 33. A set of SE-interpretations S is rule-representable if and only if there exist convex sublattices L1, L2 of 〈I,⊆〉 such that the complement of S relative to ISE is equal to {\n〈I, J〉 ∈ ISE ∣ ∣ I ∈ L1 ∧ J ∈ L2 } ∪ { 〈I, J〉 ∈ ISE ∣ ∣ J ∈ L1 ∩ L2 } .\nProof. Suppose that S is a rule-representable set of SE-interpretations. Then there exists some rule r such that S = modSE (r). Let the sets of interpretations L1, L2 be defined as follows:\nL1 = { I ∈ I ∣ ∣ B(r)+ ⊆ I ⊆ L \\H(r)+ } L2 = { J ∈ I ∣ ∣ H(r)− ∪B(r)+ ⊆ J ⊆ L \\B(r)− }\nIt can be straightforwardly verified that these sets are convex sublattices of 〈I,⊆〉. It remains to prove that the complement of S relative to ISE is equal to the set of SE-interpretations\n{ 〈I, J〉 ∈ ISE ∣ ∣ I ∈ L1 ∧ J ∈ L2 } ∪ { 〈I, J〉 ∈ ISE ∣ ∣ J ∈ L1 ∩ L2 } . (6)\nAccording to Lemma 8, an SE-interpretation 〈I, J〉 does not belong to S if and only if these two conditions are satisfied:\n1. H(r)− ∪B(r)+ ⊆ J and J ⊆ L \\B(r)−. 2. Either J ⊆ L \\H(r)+ or both B(r)+ ⊆ I and I ⊆ L \\H(r)+.\nIt is not difficult to see that whenever the first condition and first disjunct of the second condition are satisfied, 〈I, J〉 belongs to the second part of the set (6). Similarly, the first condition together with the second disjunct of the second condition imply that 〈I, J〉 belongs to the first part of the set (6). Conversely, given the definitions of L1 and L2, it is easy to see that any SE-interpretation belonging to the set (6) satisfies the conditions of Lemma 8. Thus, the set (6) coincides with the complement of S relative to ISE.\nNow suppose that L1, L2 are two convex sublattices of 〈I,⊆〉 such that the complement of S relative to ISE is equal to the set (6). Let ⊤1, ⊥1 be the top and bottom elements of L1 and ⊤2, ⊥2 be the top and bottom elements of L2. Furthermore, let r be a rule of the form\nH+;∼H− ← B+,∼B−.\nwhere H+ = L \\ ⊤1, H− = ⊥2, B+ = ⊥1 and B− = L \\ ⊤2. We will show that S = modSE (r).\nSuppose first that the SE-interpretation 〈I, J〉 is not an SE-model of r. Then, by Lemma 8, J includes H−∪B+ = ⊥2∪⊥1 and J is included in L\\B− = L\\(L\\⊤2) = ⊤2. By convexity of L2 we now obtain that J belongs to L2. Lemma 8 also implies that either J is included in L \\ H+ = ⊤1, or I includes B+ = ⊥1 and is included in L \\H+ = ⊤1. The convexity of L1 now implies that in the former case J belongs to L1, while in the latter case I belongs L1. In any of these cases, 〈I, J〉 is a member of the set (6).\nNow let 〈I, J〉 be some SE-interpretation not belonging to S. If 〈I, J〉 belongs to the first part of the set (6), then ⊥1 ⊆ I ⊆ ⊤1 and ⊥2 ⊆ J ⊆ ⊤2. Thus, I includes B+ and is included in L \\ H+, and J includes H− and is included in L \\ B−. Also, since I is a subset of J , J includes B+. Lemma 8 then implies that 〈I, J〉 is not an SE-model of r. If 〈I, J〉 belongs to the second part of the set (6), then ⊥1 ⊆ J ⊆ ⊤1 and ⊥1 ⊆ J ⊆ ⊤2. Thus, J includes both H− and B+ and is included in L \\ B− and in L \\H+. As a consequence of Lemma 8, 〈I, J〉 is not an SE-model of r. ⊓⊔\nTheorem 17. Let S be a set of SE-interpretations. Then the following conditions are equivalent:\n1. The set of SE-interpretations S is rule-representable. 2. All SE-interpretations from S are SE-models of rule(S). 3. There exist convex sublattices L1, L2 of 〈I,⊆〉 such that the complement of S rel-\native to ISE is equal to {\n〈I, J〉 ∈ ISE ∣ ∣ I ∈ L1 ∧ J ∈ L2 } ∪ { 〈I, J〉 ∈ ISE ∣ ∣ J ∈ L1 ∩ L2 } .\nProof. Follows from Propositions 32 and 33. ⊓⊔\nTheorem 22. SU-equivalence is stronger than SR-equivalence, which itself is stronger than SMR-equivalence, which in turn is stronger than strong equivalence. That is,\n≡SU≻≡SR≻≡SMR≻≡S .\nProof. We first need to show that if two programs are SU-equivalent, they are also SR-equivalent, but the converse does not hold. Suppose P1, P2 are SU-equivalent programs. Then, according to Theorem 4.3 in [2], their symmetric difference (P1 \\ P2) ∪ (P2 \\ P1) contains only SE-tautological rules.2 To show that P1 is SR-equivalent to P2, suppose S is a set of SE-interpretations belonging to the set\n{modSE (r) | r ∈ P1 ∪ { ε } } . (7)\nThen there exists some rule r with S = modSE (r) that either belongs to P1, or is SE-tautological. Furthermore, P1 = (P1 ∩ P2) ∪ (P1 \\ P2), so r either belongs to P2, or it belongs to P1 \\ P2, or it is SE-tautological. But all rules from P1 \\ P2 are SE-tautological, so we can conclude that r either belongs to P2 or it is SE-tautological. Consequently, S belongs to the set\n{modSE (r) | r ∈ P2 ∪ { ε } } . (8)\nA similar argument yields that the set (8) is a subset of the set (7). Consequently, the two sets are equal, so P1 is SR-equivalent to P2.\nTo see that the converse does not hold, take the programs P1 = {∼p ← . } and P2 = {← p. }. It can be easily verified that they are SR-equivalent, but since their symmetric difference contains rules that are not SE-tautological, they are not SU-equivalent (according to Theorem 4.3 in [2]).\nNext, need to show that if two programs are SR-equivalent, they are also SMR-equivalent, but the converse does not hold. It can be immediately seen that\n{modSE (r) | r ∈ P1 ∪ { ε } } = {modSE (r) | r ∈ P2 ∪ { ε } }\nimplies\nmin {modSE (r) | r ∈ P1 ∪ { ε } } = min {modSE (r) | r ∈ P2 ∪ { ε } } ,\n2 The Theorem actually states that the symmetric difference contains only valid rules. A rule is valid, as defined in [2], if and only if it is SE-tautological.\nso the first part of the proof is finished. As for the second part, it suffices to consider programs P1 = { p. } and P2 = { p., p ← q. } which are SMR-equivalent, but not SR-equivalent.\nFinally, we need to prove that if two programs are SMR-equivalent, they are also strongly equivalent, but not vice versa. So take some SMR-equivalent programs P1, P2. Then\nmin {modSE (r) | r ∈ P1 ∪ { ε } } = min {modSE (r) | r ∈ P2 ∪ { ε } } . (9)\nFurthermore,\nmodSE (P1) = ⋂ {modSE (r) | r ∈ P1 }\n= ⋂ ( {modSE (r) | r ∈ P1 } ∪ { ISE })\n= ⋂\n{modSE (r) | r ∈ P1 ∪ { ε } } ,\nand whenever some set of SE-interpretations S is non-minimal within\n{modSE (r) | r ∈ P1 ∪ { ε } } , (10)\nthere exists some set of SE-interpretations T from (10) such that T ( S. Thus, T ∩S = T , and so such non-minimal sets are irrelevant when determining the intersection of all sets in the set (10). Consequently,\nmodSE (P1) = ⋂ min {modSE (r) | r ∈ P1 ∪ { ε } } .\nBy similar arguments we obtain that\nmodSE (P2) = ⋂ min {modSE (r) | r ∈ P2 ∪ { ε } } .\nThus, (9) implies that P1 is strongly equivalent to P2. To see that the converse does not hold, consider programs P1 = { p., q. } and P2 = { p ← q., q. }, which are strongly equivalent, but not SMR-equivalent. ⊓⊔\nProposition 34. If S1,S2 are rule-representable sets of SE-models, then S1 ∪ S2 is also rule-representable.\nProof. Let LI1, L J 1 , L I 2, L J 2 be convex sublattices of 〈I,⊆〉 such that\nS1 = { 〈I, J〉 ∣ ∣ I ∈ LI1 ∧ J ∈ L J 1 } ∪ { 〈I, J〉 ∣ ∣ J ∈ LI1 ∩ L J 1 } , S2 = { 〈I, J〉 ∣ ∣ I ∈ LI2 ∧ J ∈ L J 2 } ∪ { 〈I, J〉 ∣ ∣ J ∈ LI2 ∩ L J 2 } .\nFurthermore, let S = S1 ∩ S2 and\nLI = { I | (∃J ∈ I)(〈J, J〉 /∈ S1 ∩ S2 ∧ 〈I, J〉 ∈ S1 ∩ S2 }\nLJ = { J | (∃I ∈ I)(〈I, J〉 ∈ S1 ∩ S2 }\nWe need to prove that LI , LJ are convex sublattices of 〈I,⊆〉 and that\nS = { 〈I, J〉 ∣ ∣ I ∈ LI ∧ J ∈ LJ } ∪ { 〈I, J〉 ∣ ∣ J ∈ LI ∩ LJ } ."
    } ],
    "references" : [ {
      "title" : "Strongly equivalent logic programs",
      "author" : [ "Vladimir Lifschitz", "David Pearce", "Agustı́n Valverde" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2001
    }, {
      "title" : "Equivalence of logic programs under updates",
      "author" : [ "Katsumi Inoue", "Chiaki Sakama" ],
      "venue" : "Proceedings of the 9th European Conference on Logics in Artificial Intelligence,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2004
    }, {
      "title" : "REVISE: Logic programming and diagnosis",
      "author" : [ "Carlos Viegas Damásio", "Luı́s Moniz Pereira", "Michael Schroeder" ],
      "venue" : "Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1997
    }, {
      "title" : "Dynamic updates of non-monotonic knowledge bases",
      "author" : [ "José Júlio Alferes", "João Alexandre Leite", "Luı́s Moniz Pereira", "Halina Przymusinska", "Teodor C. Przymusinski" ],
      "venue" : "The Journal of Logic Programming,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2000
    }, {
      "title" : "On properties of update sequences based on causal rejection",
      "author" : [ "Thomas Eiter", "Michael Fink", "Giuliana Sabbatini", "Hans Tompits" ],
      "venue" : "Theory and Practice of Logic Programming,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2002
    }, {
      "title" : "An abductive framework for computing knowledge base updates",
      "author" : [ "Chiaki Sakama", "Katsumi Inoue" ],
      "venue" : "Theory and Practice of Logic Programming,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2003
    }, {
      "title" : "Logic program-based updates",
      "author" : [ "Yan Zhang" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2006
    }, {
      "title" : "The refined extension principle for semantics of dynamic logic programming",
      "author" : [ "José Júlio Alferes", "Federico Banti", "Antonio Brogi", "João Alexandre Leite" ],
      "venue" : "Studia Logica,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2005
    }, {
      "title" : "A preference-based framework for updating logic programs",
      "author" : [ "James P. Delgrande", "Torsten Schaub", "Hans Tompits" ],
      "venue" : "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2007
    }, {
      "title" : "Belief revision of logic programs under answer set semantics",
      "author" : [ "James P. Delgrande", "Torsten Schaub", "Hans Tompits", "Stefan Woltran" ],
      "venue" : "Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2008
    }, {
      "title" : "A Program-Level Approach to Revising Logic Programs under the Answer Set Semantics",
      "author" : [ "James P. Delgrande" ],
      "venue" : "Theory and Practice of Logic Programming, 26th Int’l. Conference on Logic Programming Special Issue,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2010
    }, {
      "title" : "Belief Revision, chapter Belief Revision: An Introduction, pages 1–28",
      "author" : [ "Peter Gärdenfors" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1992
    }, {
      "title" : "On semantic update operators for answer-set programs",
      "author" : [ "Martin Slota", "João Leite" ],
      "venue" : "Proceedings of the 19th European Conference on Artificial Intelligence,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2010
    }, {
      "title" : "Towards a theory of declarative knowledge",
      "author" : [ "Krzysztof R. Apt", "Howard A. Blair", "Adrian Walker" ],
      "venue" : "In Foundations of Deductive Databases and Logic Programming,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1988
    }, {
      "title" : "A classification theory of semantics of normal logic programs: II",
      "author" : [ "Jürgen Dix" ],
      "venue" : "Weak properties. Fundamenta Informaticae,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1995
    }, {
      "title" : "Die Logik und das Grundlagenproblem",
      "author" : [ "Jan Łukasiewicz" ],
      "venue" : "In Les Entretiens de Zürich sue les Fondements et la méthode des sciences mathématiques",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1938
    }, {
      "title" : "A new logical characterisation of stable models and answer sets",
      "author" : [ "David Pearce" ],
      "venue" : "Proceedings of the 6th Workshop on Non-Monotonic Extensions of Logic Programming,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1997
    }, {
      "title" : "Strong equivalence made easy: nested expressions and weight constraints",
      "author" : [ "Hudson Turner" ],
      "venue" : "Theory and Practice of Logic Programming,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2003
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "Michael Gelfond", "Vladimir Lifschitz" ],
      "venue" : "Proceedings of the 5th International Conference and Symposium on Logic Programming,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1988
    }, {
      "title" : "Negation as failure in the head",
      "author" : [ "Katsumi Inoue", "Chiaki Sakama" ],
      "venue" : "Journal of Logic Programming,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1998
    }, {
      "title" : "Minimal logic programs",
      "author" : [ "Pedro Cabalar", "David Pearce", "Agustı́n Valverde" ],
      "venue" : "Proceedings of the 23rd International Conference on Logic Programming (ICLP 2007),",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2007
    }, {
      "title" : "Introduction to Lattices and Order",
      "author" : [ "Brian A. Davey", "Hilary A. Priestley" ],
      "venue" : null,
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1990
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Finally, we discuss the introduction of two notions of equivalence, both stronger than strong equivalence [1] and weaker than strong update equivalence [2], which seem more suitable whenever the dependency information found in rules is of interest.",
      "startOffset" : 106,
      "endOffset" : 109
    }, {
      "referenceID" : 1,
      "context" : "Finally, we discuss the introduction of two notions of equivalence, both stronger than strong equivalence [1] and weaker than strong update equivalence [2], which seem more suitable whenever the dependency information found in rules is of interest.",
      "startOffset" : 152,
      "endOffset" : 155
    }, {
      "referenceID" : 0,
      "context" : "With this in mind, we briefly discuss two new notions of equivalence, stronger than strong equivalence [1] and weaker than strong update equivalence [2].",
      "startOffset" : 103,
      "endOffset" : 106
    }, {
      "referenceID" : 1,
      "context" : "With this in mind, we briefly discuss two new notions of equivalence, stronger than strong equivalence [1] and weaker than strong update equivalence [2].",
      "startOffset" : 149,
      "endOffset" : 152
    }, {
      "referenceID" : 2,
      "context" : "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by “sacrificing” parts of an older program (such as in [3–11]).",
      "startOffset" : 248,
      "endOffset" : 254
    }, {
      "referenceID" : 3,
      "context" : "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by “sacrificing” parts of an older program (such as in [3–11]).",
      "startOffset" : 248,
      "endOffset" : 254
    }, {
      "referenceID" : 4,
      "context" : "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by “sacrificing” parts of an older program (such as in [3–11]).",
      "startOffset" : 248,
      "endOffset" : 254
    }, {
      "referenceID" : 5,
      "context" : "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by “sacrificing” parts of an older program (such as in [3–11]).",
      "startOffset" : 248,
      "endOffset" : 254
    }, {
      "referenceID" : 6,
      "context" : "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by “sacrificing” parts of an older program (such as in [3–11]).",
      "startOffset" : 248,
      "endOffset" : 254
    }, {
      "referenceID" : 7,
      "context" : "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by “sacrificing” parts of an older program (such as in [3–11]).",
      "startOffset" : 248,
      "endOffset" : 254
    }, {
      "referenceID" : 8,
      "context" : "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by “sacrificing” parts of an older program (such as in [3–11]).",
      "startOffset" : 248,
      "endOffset" : 254
    }, {
      "referenceID" : 9,
      "context" : "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by “sacrificing” parts of an older program (such as in [3–11]).",
      "startOffset" : 248,
      "endOffset" : 254
    }, {
      "referenceID" : 10,
      "context" : "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by “sacrificing” parts of an older program (such as in [3–11]).",
      "startOffset" : 248,
      "endOffset" : 254
    }, {
      "referenceID" : 11,
      "context" : "Moreover, such a more semantic approach could facilitate the establishment of bridges with the area of Belief Change (see [12] for an introduction), and benefit from the many years of research where semantic change operations on monotonic logics have been studied, desirable properties for such operations have been identified, and constructive definitions of operators satisfying these properties have been introduced.",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 3,
      "context" : "However, as has repeatedly been argued in the literature [4, 13], fully semantic methods do not seem to be appropriate for the task at hand.",
      "startOffset" : 57,
      "endOffset" : 64
    }, {
      "referenceID" : 12,
      "context" : "However, as has repeatedly been argued in the literature [4, 13], fully semantic methods do not seem to be appropriate for the task at hand.",
      "startOffset" : 57,
      "endOffset" : 64
    }, {
      "referenceID" : 3,
      "context" : "Though their definition and analysis is technically possible and leads to very elegant and seemingly desirable properties, there are a number of simple examples for which these methods fail to provide results that would be in line with basic intuitions [4].",
      "startOffset" : 253,
      "endOffset" : 256
    }, {
      "referenceID" : 12,
      "context" : "Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 13,
      "context" : "Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs.",
      "startOffset" : 249,
      "endOffset" : 257
    }, {
      "referenceID" : 14,
      "context" : "Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs.",
      "startOffset" : 249,
      "endOffset" : 257
    }, {
      "referenceID" : 0,
      "context" : "– identify a set of representatives of rule equivalence classes induced by the SE-model semantics, which we dub canonical rules; – show how to reconstruct canonical rules from their sets of SE-models; – based on the above, characterise the sets of SE-interpretations that are representable by a single rule; – reveal connections between the set of SE-models of a rule and convex sublattices of the set of classical interpretations; – introduce two new notions of equivalence – stronger than strong equivalence [1] and weaker than strong update equivalence [2] – and argue that they are more suitable when rules are to be treated as first-class citizens.",
      "startOffset" : 510,
      "endOffset" : 513
    }, {
      "referenceID" : 1,
      "context" : "– identify a set of representatives of rule equivalence classes induced by the SE-model semantics, which we dub canonical rules; – show how to reconstruct canonical rules from their sets of SE-models; – based on the above, characterise the sets of SE-interpretations that are representable by a single rule; – reveal connections between the set of SE-models of a rule and convex sublattices of the set of classical interpretations; – introduce two new notions of equivalence – stronger than strong equivalence [1] and weaker than strong update equivalence [2] – and argue that they are more suitable when rules are to be treated as first-class citizens.",
      "startOffset" : 556,
      "endOffset" : 559
    }, {
      "referenceID" : 15,
      "context" : "The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18].",
      "startOffset" : 50,
      "endOffset" : 58
    }, {
      "referenceID" : 16,
      "context" : "The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18].",
      "startOffset" : 50,
      "endOffset" : 58
    }, {
      "referenceID" : 17,
      "context" : "The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18].",
      "startOffset" : 173,
      "endOffset" : 177
    }, {
      "referenceID" : 18,
      "context" : "This second semantics is strictly more expressive than both classical models and the stable model semantics [19].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 19,
      "context" : "Most of these results have already been formulated in various ways [20, 2, 21].",
      "startOffset" : 67,
      "endOffset" : 78
    }, {
      "referenceID" : 1,
      "context" : "Most of these results have already been formulated in various ways [20, 2, 21].",
      "startOffset" : 67,
      "endOffset" : 78
    }, {
      "referenceID" : 20,
      "context" : "Most of these results have already been formulated in various ways [20, 2, 21].",
      "startOffset" : 67,
      "endOffset" : 78
    }, {
      "referenceID" : 1,
      "context" : "4 in [2]; part i) of Lemma 2 in [21]).",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 20,
      "context" : "4 in [2]; part i) of Lemma 2 in [21]).",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 20,
      "context" : "Lemma 3 (Consequence of (3) and (4) in Lemma 1 in [21]).",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 19,
      "context" : "10 in [20] and Corollary 1 in [21]).",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 20,
      "context" : "10 in [20] and Corollary 1 in [21]).",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 20,
      "context" : "This definition is closely related with the notion of a fundamental rule introduced in Definition 1 of [21].",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 20,
      "context" : "Lemma 8 (Different formulation of Theorem 4 in [21]).",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 9,
      "context" : "Moreover, for every well-defined set of SE-interpretations S there exists a program P such that S = modSE (P) [10].",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 21,
      "context" : "[22].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 3,
      "context" : "These results can be used for example in the context of program updates to define an update semantics based on the rule rejection principle [4] and operating on sets of sets of SE-models.",
      "startOffset" : 140,
      "endOffset" : 143
    }, {
      "referenceID" : 1,
      "context" : "Related to this is the very strong notion of equivalence which was introduced in [2]:",
      "startOffset" : 81,
      "endOffset" : 84
    }, {
      "referenceID" : 1,
      "context" : "1 in [2]).",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 1,
      "context" : "Two programs are strongly update equivalent only under very strict conditions – it is shown in [2] that two programs are SU-equivalent if and only if their symmetric difference contains only SE-tautological rules.",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 1,
      "context" : "The other notion of program equivalence introduced in [2], strong update equivalence on common rules, or SUC-equivalence, is incomparable in terms of strength to our new notions of equivalence.",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 3,
      "context" : "are usually considered to carry the same meaning, some existing work suggests that they should be treated differently – while the former rule gives a reason for atom p to become false whenever q is true, the latter rule simply states that the two atoms cannot be true at the same time, without specifying a way to resolve this situation if it were to arise [4, 8].",
      "startOffset" : 357,
      "endOffset" : 363
    }, {
      "referenceID" : 7,
      "context" : "are usually considered to carry the same meaning, some existing work suggests that they should be treated differently – while the former rule gives a reason for atom p to become false whenever q is true, the latter rule simply states that the two atoms cannot be true at the same time, without specifying a way to resolve this situation if it were to arise [4, 8].",
      "startOffset" : 357,
      "endOffset" : 363
    }, {
      "referenceID" : 15,
      "context" : "Whenever this is important, either strong update equivalence is used, which is perhaps too sensitive to the syntax of rules, or a new characterisation of Answer-Set Programming needs to be discovered, namely one that is not based on the logic of Here-and-There [16, 17].",
      "startOffset" : 261,
      "endOffset" : 269
    }, {
      "referenceID" : 16,
      "context" : "Whenever this is important, either strong update equivalence is used, which is perhaps too sensitive to the syntax of rules, or a new characterisation of Answer-Set Programming needs to be discovered, namely one that is not based on the logic of Here-and-There [16, 17].",
      "startOffset" : 261,
      "endOffset" : 269
    } ],
    "year" : 2017,
    "abstractText" : "Rules in logic programming encode information about mutual interdependencies between literals that is not captured by any of the commonly used semantics. This information becomes essential as soon as a program needs to be modified or further manipulated. We argue that, in these cases, a program should not be viewed solely as the set of its models. Instead, it should be viewed and manipulated as the set of sets of models of each rule inside it. With this in mind, we investigate and highlight relations between the SE-model semantics and individual rules. We identify a set of representatives of rule equivalence classes induced by SE-models, and so pinpoint the exact expressivity of this semantics with respect to a single rule. We also characterise the class of sets of SE-interpretations representable by a single rule. Finally, we discuss the introduction of two notions of equivalence, both stronger than strong equivalence [1] and weaker than strong update equivalence [2], which seem more suitable whenever the dependency information found in rules is of interest.",
    "creator" : "dvips(k) 5.98 Copyright 2009 Radical Eye Software"
  }
}