{
  "name" : "1609.07061.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Quantized Neural Networks Quantized Neural Networks: Training Neural Networks with Low Precision Weights and Activations",
    "authors" : [ "Itay Hubara", "Daniel Soudry", "Yoshua Bengio" ],
    "emails" : [ "itayh@campuse.technion.ac.il", "matthieu.courbariaux@gmail.com", "daniel.soudry@gmail.com", "rani@cs.technion.ac.il", "yoshua.umontreal@gmail.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\nKeywords: Deep Learning, Neural Networks Compression, Energy Efficient Neural Networks, Computer vision, Language Models."
    }, {
      "heading" : "1. Introduction",
      "text" : "Deep Neural Networks (DNNs) have substantially pushed Artificial Intelligence (AI) limits in a wide range of tasks, including but not limited to object recognition from images (Krizhevsky et al., 2012; Szegedy et al., 2014), speech recognition (Hinton et al., 2012; Sainath et al., 2013), statistical machine translation (Devlin et al., 2014; Sutskever et al., 2014; Bahdanau et al., 2015), Atari and Go games (Mnih et al., 2015; Silver et al., 2016), and even computer generation of abstract art (Mordvintsev et al., 2015).\nTraining or even just using neural network (NN) algorithms on conventional generalpurpose digital hardware (Von Neumann architecture) has been found highly inefficient due to the massive amount of multiply-accumulate operations (MACs) required to compute the weighted sums of the neurons’ inputs. Today, DNNs are almost exclusively trained on one or many very fast and power-hungry Graphic Processing Units (GPUs) (Coates et al., 2013). As a result, it is often a challenge to run DNNs on target low-power devices, and substantial research efforts are invested in speeding up DNNs at run-time on both generalpurpose (Vanhoucke et al., 2011; Gong et al., 2014; Romero et al., 2014; Han et al., 2015b) and specialized computer hardware (Farabet et al., 2011a,b; Pham et al., 2012; Chen et al., 2014a,b; Esser et al., 2015).\nThe most common approach is to compress a trained (full precision) network. HashedNets (Chen et al., 2015) reduce model sizes by using a hash function to randomly group connection weights and force them to share a single parameter value. Gong et al. (2014) compressed deep convnets using vector quantization, which resulteds in only a 1% accuracy loss. However, both methods focused only on the fully connected layers. A recent work by Han and Dally (2015) successfully pruned several state-of-the-art large scale networks and showed that the number of parameters could be reduced by an order of magnitude.\nRecent works have shown that more computationally efficient DNNs can be constructed by quantizing some of the parameters during the training phase. In most cases, DNNs are trained by minimizing some error function using Back-Propagation (BP) or related gradient descent methods. However, such an approach cannot be directly applied if the weights are restricted to binary values. Soudry et al. (2014) used a variational Bayesian approach with Mean-Field and Central Limit approximation to calculate the posterior distribution of the weights (the probability of each weight to be +1 or -1). During the inference stage (test phase), their method samples from this distribution one binary network and used it to predict the targets of the test set (More than one binary network can also be used). Courbariaux et al. (2015b) similarly used two sets of weights, real-valued and binary. They, however, updated the real valued version of the weights by using gradients computed by applying forward and backward propagation with the set of binary weights (which was obtained by quantizing the real-value weights to +1 and -1).\nThis study proposes a more advanced technique, referred to as Quantized Neural Network (QNN), for quantizing the neurons and weights during inference and training. In such networks, all MAC operations can be replaced with XNOR and population count (i.e., counting the number of ones in the binary number) operations. This is especially useful in\nQNNs with the extremely low precision — for example, when only 1-bit is used per weight and activation, leading to a Binarized Neural Network (BNN). The proposed method is particularly beneficial for implementing large convolutional networks whose neuron-to-weight ratio is very large.\nThis paper makes the following contributions:\n• We introduce a method to train Quantized-Neural-Networks (QNNs), neural networks with low precision weights and activations, at run-time, and when computing the parameter gradients at train-time. In the extreme case QNNs use only 1-bit per weight and activation(i.e., Binarized NN; see Section 2).\n• We conduct two sets of experiments, each implemented on a different framework, namely Torch7 and Theano, which show that it is possible to train BNNs on MNIST, CIFAR-10 and SVHN and achieve near state-of-the-art results (see Section 4). Moreover, we report results on the challenging ImageNet dataset using binary weights/activations as well as quantized version of it (more than 1-bit).\n• We present preliminary results on quantized gradients and show that it is possible to use only 6-bits with only small accuracy degradation.\n• We present results for the Penn Treebank dataset using language models (vanilla RNNs and LSTMs) and show that with 4-bit weights and activations Recurrent QNNs achieve similar accuracies as their 32-bit floating point counterparts.\n• We show that during the forward pass (both at run-time and train-time), QNNs drastically reduce memory consumption (size and number of accesses), and replace most arithmetic operations with bit-wise operations. A substantial increase in power efficiency is expected as a result (see Section 5). Moreover, a binarized CNN can lead to binary convolution kernel repetitions; we argue that dedicated hardware could reduce the time complexity by 60% .\n• Last but not least, we programmed a binary matrix multiplication GPU kernel with which it is possible to run our MNIST BNN 7 times faster than with an unoptimized GPU kernel, without suffering any loss in classification accuracy (see Section 6).\n• The code for training and applying our BNNs is available on-line (both the Theano 1 and the Torch framework 2)."
    }, {
      "heading" : "2. Binarized Neural Networks",
      "text" : "In this section, we detail our binarization function, show how we use it to compute the parameter gradients, and how we backpropagate through it.\n1https://github.com/MatthieuCourbariaux/BinaryNet 2https://github.com/itayhubara/BinaryNet"
    }, {
      "heading" : "2.1 Deterministic vs Stochastic Binarization",
      "text" : "When training a BNN, we constrain both the weights and the activations to either +1 or −1. Those two values are very advantageous from a hardware perspective, as we explain in Section 6. In order to transform the real-valued variables into those two values, we use two different binarization functions, as proposed by Courbariaux et al. (2015a). The first binarization function is deterministic:\nxb = sign(x) = { +1 if x ≥ 0, −1 otherwise, (1)\nwhere xb is the binarized variable (weight or activation) and x the real-valued variable. It is very straightforward to implement and works quite well in practice. The second binarization function is stochastic:\nxb = { +1 with probability p = σ(x), −1 with probability 1− p, (2)\nwhere σ is the “hard sigmoid” function:\nσ(x) = clip( x+ 1\n2 , 0, 1) = max(0,min(1,\nx+ 1\n2 )). (3)\nThis stochastic binarization is more appealing theoretically (see Section 4) than the sign function, but somewhat harder to implement as it requires the hardware to generate random bits when quantizing (Torii et al., 2016). As a result, we mostly use the deterministic binarization function (i.e., the sign function), with the exception of activations at traintime in some of our experiments."
    }, {
      "heading" : "2.2 Gradient Computation and Accumulation",
      "text" : "Although our BNN training method utilizes binary weights and activations to compute the parameter gradients, the real-valued gradients of the weights are accumulated in realvalued variables, as per Algorithm 1. Real-valued weights are likely required for Stochasic Gradient Descent (SGD) to work at all. SGD explores the space of parameters in small and noisy steps, and that noise is averaged out by the stochastic gradient contributions accumulated in each weight. Therefore, it is important to maintain sufficient resolution for these accumulators, which at first glance suggests that high precision is absolutely required.\nMoreover, adding noise to weights and activations when computing the parameter gradients provide a form of regularization that can help to generalize better, as previously shown with variational weight noise (Graves, 2011), Dropout (Srivastava et al., 2014) and DropConnect (Wan et al., 2013). Our method of training BNNs can be seen as a variant of Dropout, in which instead of randomly setting half of the activations to zero when computing the parameter gradients, we binarize both the activations and the weights."
    }, {
      "heading" : "2.3 Propagating Gradients Through Discretization",
      "text" : "The derivative of the sign function is zero almost everywhere, making it apparently incompatible with back-propagation, since the exact gradients of the cost with respect to the\nquantities before the discretization (pre-activations or weights) are zero. Note that this limitation remains even if stochastic quantization is used. Bengio (2013) studied the question of estimating or propagating gradients through stochastic discrete neurons. He found that the fastest training was obtained when using the “straight-through estimator,” previously introduced in Hinton’s lectures (Hinton, 2012). We follow a similar approach but use the version of the straight-through estimator that takes into account the saturation effect, and does use deterministic rather than stochastic sampling of the bit. Consider the sign function quantization\nq = Sign(r),\nand assume that an estimator gq of the gradient ∂C ∂q has been obtained (with the straightthrough estimator when needed). Then, our straight-through estimator of ∂C∂r is simply\ngr = gq1|r|≤1. (4)\nNote that this preserves the gradient information and cancels the gradient when r is too large. Not cancelling the gradient when r is too large significantly worsens performance. To better understand why the straight-through estimator works well, consider the stochastic binarization scheme in Eq. (2) and rewrite σ(r) = (HT(r) + 1) /2, where HT(r) is the well-known “hard tanh”,\nHT(r) =  +1 r > 1, r r ∈ [−1, 1], −1 r < −1.\n(5)\nIn this case the input to the next layer has the following form,\nWbhb (r) = WbHT (r) + n (r) ,\nwhere we use the fact that HT (r) is the expectation over hb (x) (see Eqs. (2) and (5)), and define n (r) as binarization noise with mean equal to zero. When the layer is wide, we expect the deterministic mean term HT (x) to dominate, because the noise term n (r) is a summation over many independent binarizations from all the neurons in the previous layer. Thus, we argue that the binarization noise n (x) can be ignored when performing differentiation in the backward propagation stage. Therefore, we replace ∂hb(r)∂r (which cannot be computed) with\n∂HT (r)\n∂x =  0 r > 1, 1 r ∈ [−1, 1], 0 r < −1,\n(6)\nwhich is exactly the straight-through estimator defined in Eq (4). The use of this straightthrough estimator is illustrated in Algorithm 1.\nA similar binarization process was applied for weights in which we combine two ingredients:\n• Project each real-valued weight to [-1,1], i.e., clip the weights during training, as per Algorithm 1. The real-valued weights would otherwise grow very large without any impact on the binary weights.\n• When using a weight wr, quantize it using wb = Sign(wr). Projecting the weights to [-1,1] is consistent with the gradient cancelling when |wr| > 1, according to Eq. ( 4)."
    }, {
      "heading" : "2.4 Shift-based Batch Normalization",
      "text" : "Batch Normalization (BN) (Ioffe and Szegedy, 2015) accelerates the training and reduces the overall impact of the weight scale (Courbariaux et al., 2015a). The normalization procedure may also help to regularize the model. However, at train-time, BN requires many multiplications (calculating the standard deviation and dividing by it, namely, dividing by the running variance, which is the weighted mean of the training set activation variance). Although the number of scaling calculations is the same as the number of neurons, in the case of ConvNets this number is quite large. For example, in the CIFAR-10 dataset (using our architecture), the first convolution layer, consisting of only 128 × 3 × 3 filter masks, converts an image of size 3 × 32 × 32 to size 128 × 28 × 28, which is almost two orders of magnitude larger than the number of weights (87.1 to be exact). To achieve the results that BN would obtain, we use a shift-based batch normalization (SBN) technique, presented in Algorithm 2. SBN approximates BN almost without multiplications. Define AP2(z) as the approximate power-of-2 of z (i.e., the index of the most significant bit (MSB)), and as both left and right binary shift. SBN replaces almost all multiplication with power-of-2approximation and shift operations:\nx× y → x AP2(y). (7)\nThe only operation which is not a binary shift or an add is the inverse square root (see normalization operation Algorithm 2). From the early work of Lomont (2003) we know that the inverse-square operation could be applied with approximately the same complexity as multiplication. There are also faster methods, which involve lookup table tricks that typically obtain lower accuracy (this may not be an issue, since our procedure already adds a lot of noise). However, the number of values on which we apply the inverse-square operation is rather small, since it is done after calculating the variance, i.e., after averaging (for a more precise calculation, see the BN analysis in Lin et al. (2015b). Furthermore, the size of the standard deviation vectors is relatively small. For example, these values make up only 0.3% of the network size (i.e., the number of learnable parameters) in the Cifar-10 network we used in our experiments.\nIn the experiment we observed no loss in accuracy when using the shift-based BN algorithm instead of the vanilla BN algorithm."
    }, {
      "heading" : "2.5 Shift Based AdaMax",
      "text" : "The ADAM learning method (Kingma and Ba, 2014b) also reduces the impact of the weight scale. Since ADAM requires many multiplications, we suggest using instead the shift-based AdaMax we outlined in Algorithm 3. In the experiment we conducted we observed no loss in accuracy when using the shift-based AdaMax algorithm instead of the vanilla ADAM algorithm.\n3Hardware implementation of AP2 is as simple as extracting the index of the most significant bit from the number’s binary representation.\nAlgorithm 1 Training a BNN. C is the cost function for minibatch, λ, the learning rate decay factor, and L, the number of layers. (◦) stands for element-wise multiplication. The function Binarize(·) specifies how to (stochastically or deterministically) binarize the activations and weights, and Clip(), how to clip the weights. BatchNorm() specifies how to batch-normalize the activations, using either batch normalization (Ioffe and Szegedy, 2015) or its shift-based variant we describe in Algorithm 2. BackBatchNorm() specifies how to backpropagate through the normalization. Update() specifies how to update the parameters when their gradients are known, using either ADAM (Kingma and Ba, 2014b) or the shift-based AdaMax we describe in Algorithm 3. Require: a minibatch of inputs and targets (a0, a ∗), previous weights W , previous Batch-\nNorm parameters θ, weight initialization coefficients from (Glorot and Bengio, 2010) γ, and previous learning rate η. Ensure: updated weights W t+1, updated BatchNorm parameters θt+1 and updated learning rate ηt+1. {1. Computing the parameter gradients:} {1.1. Forward propagation:} for k = 1 to L do W bk ← Binarize(Wk) sk ← abk−1W bk ak ← BatchNorm(sk, θk) if k < L then abk ← Binarize(ak)\nend if end for {1.2. Backward propagation:} {Note that the gradients are not binary.} Compute gaL = ∂C ∂aL knowing aL and a ∗ for k = L to 1 do if k < L then gak ← gabk ◦ 1|ak|≤1\nend if (gsk , gθk)← BackBatchNorm(gak , sk, θk) gabk−1\n← gskW bk gW bk ← g>ska b k−1\nend for {2. Accumulating the parameter gradients:} for k = 1 to L do θt+1k ← Update(θk, η, gθk) W t+1k ← Clip(Update(Wk, γkη, gW bk ),−1, 1) ηt+1 ← λη end for\nAlgorithm 2 Shift based Batch Normalizing Transform, applied to activation x over a mini-batch. AP2(x) = sign(x) × 2round(log2|x|) is the approximate power-of-2 3, and stands for both left and right binary shift. Require: Values of x over a mini-batch: B = {x1...m}; Parameters to be learned: γ, β Ensure: {yi = BN(xi,γ, β)} µB ← 1m ∑m i=1 xi {mini-batch mean}\nC(xi)← (xi − µB) {centered input} σ2B← 1 m ∑m i=1(C(xi) AP2(C(xi))) {apx variance}\nx̂i ← C(xi) AP2(( √ σ2B + )\n−1) {normalize} yi ← AP2(γ) x̂i {scale and shift}\nAlgorithm 3 Shift based AdaMax learning rule (Kingma and Ba, 2014b). g2t indicates the element-wise square gt ◦gt. Good default settings are α = 2−10, 1−β1 = 2−3, 1−β2 = 2−10. All operations on vectors are element-wise. With βt1 and β t 2 we denote β1 and β2 to the power t.\nRequire: Previous parameters θt−1, their gradient gt, and learning rate α. Ensure: Updated parameters θt {Biased 1st and 2nd raw moment estimates:} mt ← β1 ·mt−1 + (1− β1) · gt vt ← max(β2 · vt−1, |gt|) {Updated parameters:} θt ← θt−1 − (α (1− β1)) · m̂ v−1t )"
    }, {
      "heading" : "2.6 First Layer",
      "text" : "In a BNN, only the binarized values of the weights and activations are used in all calculations. As the output of one layer is the input of the next, the inputs of all the layers are binary, with the exception of the first layer. However, we do not believe this to be a major issue. First, in computer vision, the input representation typically has far fewer channels (e.g, red, green and blue) than internal representations (e.g., 512). Consequently, the first layer of a ConvNet is often the smallest convolution layer, both in terms of parameters and computations (Szegedy et al., 2014). Second, it is relatively easy to handle continuousvalued inputs as fixed point numbers, with m bits of precision. For example, in the common case of 8-bit fixed point inputs:\ns = x · wb, s = 8∑\nn=1\n2n−1(xn · wb), (8)\nwhere x is a vector of 1024 8-bit inputs, x81 is the most significant bit of the first input, w b is a vector of 1024 1-bit weights, and s is the resulting weighted sum. This method is used in Algorithm 4.\nAlgorithm 4 Running a BNN with L layers. Require: 8-bit input vector a0, binary weights W b, and BatchNorm parameters θ. Ensure: the MLP output aL. {1. First layer:} a1 ← 0 for n = 1 to 8 do a1 ← a1 + 2n−1 ×XnorDotProduct(an0 ,Wb1)\nend for ab1 ← Sign(BatchNorm(a1, θ1)) {2. Remaining hidden layers:} for k = 2 to L− 1 do ak ← XnorDotProduct(abk−1,W bk) abk ← Sign(BatchNorm(ak, θk)) end for {3. Output layer:} aL ← XnorDotProduct(abL−1,W bL) aL ← BatchNorm(aL, θL)"
    }, {
      "heading" : "3. Qunatized Neural network - More than 1-bit",
      "text" : "Observing Eq. (8), we can see that using 2-bit activations simply doubles the number of times we need to run our XnorPopCount Kernel (i.e., directly proportional to the activation bitwidth). This idea was recently proposed by Zhou et al. (2016) (DoReFa net) and Miyashita et al. (2016) (published on arXive shortly after our preliminary technical report was published there). However, in contrast to to Zhou et al., we did not find it useful to initialize the network with weights obtained by training the network with full precision weights. Moreover, the Zhou et al. network did not quantize the weights of the first convolutional layer and the last fully-connected layer, whereas we binarized both. We followed the quantization schemes suggested by Miyashita et al. (2016), namely, linear quantization:\nLinearQuant(x, bitwidth) = Clip ( round ( x bitwidth ) × bitwidth,minV,maxV ) (9)\nand logarithmic quantization:\nLogQuant(x, bitwidth) (x) = Clip (AP2(x),minV,maxV ) , (10)\nwhere minV and maxV are the minimum and maximum scale range respectively. Where AP2(x) is the approximate-power-of-2 of x as described in Section 2.4. In our experiments (detailed in Section 4) we applied the above quantization schemes on the weights, activations and gradients and tested them on the more challenging ImageNet dataset."
    }, {
      "heading" : "4. Benchmark Results",
      "text" : ""
    }, {
      "heading" : "4.1 Results on MNIST,SVHN, and CIFAR-10",
      "text" : "We performed two sets of experiments, each based on a different framework, namely Torch7 and Theano. Other than the framework, the two sets of experiments are very similar:\nMNIST MNIST is an image classification benchmark dataset (LeCun et al., 1998). It consists of a training set of 60K and a test set of 10K 28 × 28 gray-scale images representing digits ranging from 0 to 9. The Multi-Layer-Perceptron (MLP) we train on MNIST consists of 3 hidden layers. In our Theano implementation we used hidden layers of size 4096 whereas in our Torch implementation we used much smaller size 2048. This difference explains the accuracy gap between the two implementations.\nCIFAR-10 CIFAR-10 is an image classification benchmark dataset. It consists of a training set of size 50K and a test set of size 10K, where instances are 32 × 32 color images representing airplanes, automobiles, birds, cats, deer, dogs, frogs, horses, ships and trucks. Both implementations share the same structure as reported in Appendix A. Since the Torch implementation uses stochastic binarization, it achieved slightly better results.\nSVHN Street View House Numbers (SVHN) is also an image classification benchmark dataset. It consists of a training set of size 604K examples and a test set of size 26K, where instances are 32 × 32 color images representing digits ranging from 0 to 9. Here again we obtained a small improvement in the performance by using stochastic binarization scheeme."
    }, {
      "heading" : "4.2 Results on ImageNet",
      "text" : "To test the strength of our method, we applied it to the challenging ImageNet classification task, which is probably the most important classification benchmark dataset. It consists of a training set of size 1.2M samples and test set of size 50K. Each instance is labeled with one of 1000 categories including objects, animals, scenes, and even some abstract shapes. On ImageNet, it is customary to report two error rates: top-1 and top-5, where the top-x error rate is the fraction of test images for which the correct label is not among the x labels considered most probable by the model. Considerable research has been concerned with compressing ImageNet architectures while preserving high accuracy. Previous approaches include pruning near zero weights (Gong et al., 2014; Han et al., 2015a) using matrix factorization techniques (Zhang et al., 2015), quantizing the weights (Gupta et al., 2015), using shared weights (Chen et al., 2015) and applying Huffman codes (Han et al., 2015a) among others.\nTo the best of our knowledge, before the first revision of this paper was published on arXive, no one had reported on successfully quantizing the network’s activations. On the contrary, a recent work (Han et al., 2015a) showed that accuracy significantly deteriorates when trying to quantize convolutional layers’ weights below 4-bit (FC layers are more robust to quantization and can operate quite well with only 2 bits). In the present work we\nattempted to tackle the difficult task of binarizing both weights and activations. Employing the well-known AlexNet and GoogleNet architectures, we applied our techniques and achieved 41.8% top-1 and 67.1% top-5 accuracy using AlexNet and 47.1% top-1 and 69.1% top-5 accuracy using GoogleNet. While these performance results leave room for improvement (relative to full precision nets), they are by far better than all previous attempts to compress ImageNet architectures using less than 4-bit precision for the weights. Moreover, this advantage is achieved while also binarizing neuron activations."
    }, {
      "heading" : "4.3 Relaxing “hard tanh” boundaries",
      "text" : "We discovered that after training the network it is useful to widen the “hard tanh” boundaries and retrain the network. As explained in Section 2.3, the straight-through estimator (which can be written as “hard tanh”) cancels gradients coming from neurons with absolute values higher than 1. Hence, towards the last training iterations most of the gradient values are zero and the weight values cease to update. By relaxing the “hard tanh” boundaries we allow more gradients to flow in the back-propagation phase and improve top-1 accuracies by 1.5% on AlexNet topology using vanilla BNN."
    }, {
      "heading" : "4.4 2-bit activations",
      "text" : "While training BNNs on the ImageNet dataset we noticed that we could not force the training set error rate to converge to zero. In fact the training error rate stayed fairly close to the validation error rate. This observation led us to investigate a more relaxed activation quantization (more than 1-bit). As can be seen in Table 2, the results are quite impressive and illustrate an approximate 5.6% drop in performance (top-1 accuracy) relative to floating point representation, using only 1-bit weights and 2-bit activation. Following Miyashita et al. (2016), we also tried quantizing the gradients and discovered that only logarithmic quantization works. With 6-bit gradients we achieved 46.8% degradation. Those results are presently state-of-the-art, surpassing those obtained by the DoReFa net (Zhou et al., 2016). As opposed to DoReFa, we utilized a deterministic quantization process rather than a stochastic one. Moreover, it is important to note that while quantizing the gradients, DoReFa assigns for each instance in a mini-batch its own scaling factor, which increases the number of MAC operations.\nWhile AlexNet can be compressed rather easily, compressing GoogleNet is much harder due to its small number of parameters. When using vanilla BNNs, we observed a large degradation in the top-1 results. However, by using QNNs with 4-bit weights and activation, we were able to achieve 66.5% top-1 accuracy (only a 5.5% drop in performance compared to the 32-bit floating point architecture), which is the current state-of-the-art-compression result over GoogleNet. Moreover, by using QNNs with 6-bit weights, activations and gradients we achieved 66.4% top-1 accuracy. Full implementation details of our experiments are reported in Appendix A.6."
    }, {
      "heading" : "4.5 Language Models",
      "text" : "Recurrent neural networks (RNNs) are very demanding in memory and computational power in comparison to feed forward networks. There are a large variety of recurrent models with\nthe Long Short Term Memory networks (LSTMs) introduced by Hochreiter and Schmidhuber (1997) are being the most popular model. LSTMs are a special kind of RNN, capable of learning long-term dependencies using unique gating mechanisms. Recently, Ott et al. (2016) tried to quantize the RNNs weight matrices using similar techniques as described in Section 2. They observed that the weight binarization methods do not work with RNNs. However, by using 2-bits (i.e., −1, 0, 1), they have been able to achieve similar and even higher accuracy on several datasets. Here we report on the first attempt to quantize both weights and activations by trying to evaluate the accuracy of quantized recurrent models trained on the Penn Treebank dataset. The Penn Treebank Corpus (Marcus et al., 1993) contains 10K unique words. We followed the same setting as in (Mikolov and Zweig, 2012) which resulted in 18.55K words for training set, 14.5K and 16K words in the validation\nand test sets respectively. We experimented with both vanilla RNNs and LSTMs. For our vanilla RNN model we used one hidden layers of size 2048 and ReLU as the activation function. For our LSTM model we use 1 hidden layer of size 300. Our RNN implementation was constructed to predict the next character hence performance was measured using the bits-per-character (BPC) metric. In the LSTM model we tried to predict the next word so performance was measured using the perplexity per word (PPW) metric. Similar to (Ott et al., 2016), our preliminary results indicate that binarization of weight matrices lead to large accuracy degradation. However, as can be seen in Table 4, with 4-bits activations and weights we can achieve similar accuracies as their 32-bit floating point counterparts."
    }, {
      "heading" : "5. High Power Efficiency during the Forward Pass",
      "text" : "Computer hardware, be it general-purpose or specialized, is composed of memories, arithmetic operators and control logic. During the forward pass (both at run-time and train-time), BNNs drastically reduce memory size and accesses, and replace most arithmetic operations with bit-wise operations, which might lead to vastly improved power-efficiency. Moreover, a binarized CNN can lead to binary convolution kernel repetitions, and we argue that dedicated hardware could reduce the time complexity by 60% .\nMemory Size and Accesses Improving computing performance has always been and remains a challenge. Over the last decade, power has been the main constraint on performance (Horowitz, 2014). This is why considerable research efforts have been devoted to reducing the energy consumption of neural networks. Horowitz (2014) provides rough numbers for the energy consumed by the computation (the given numbers are for 45nm technology), as summarized in Tables 5 and 6. Importantly, we can see that memory accesses typically consume more energy than arithmetic operations, and memory access cost increases with memory size. In comparison with 32-bit DNNs, BNNs require 32 times smaller memory size and 32 times fewer memory accesses. This is expected to reduce energy consumption drastically (i.e., by a factor larger than 32).\nXNOR-Count Applying a DNN mainly involves convolutions and matrix multiplications. The key arithmetic operation of deep learning is thus the multiply-accumulate operation. Artificial neurons are basically multiply-accumulators computing weighted sums of their inputs. In BNNs, both the activations and the weights are constrained to either −1 or +1. As a result, most of the 32-bit floating point multiply-accumulations are replaced\nby 1-bit XNOR-count operations. This could have a big impact on dedicated deep learning hardware. For instance, a 32-bit floating point multiplier costs about 200 Xilinx FPGA slices (Govindu et al., 2004; Beauchamp et al., 2006), whereas a 1-bit XNOR gate only costs a single slice.\nWhen using a ConvNet architecture with binary weights, the number of unique filters is bounded by the filter size. For example, in our implementation we use filters of size 3 × 3, so the maximum number of unique 2D filters is 29 = 512. However, this should not prevent expanding the number of feature maps beyond this number, since the actual filter is a 3D matrix. Assuming we have M` filters in the ` convolutional layer, we have to store a 4D weight matrix of size M` × M`−1 × k × k. Consequently, the number of unique filters is 2k\n2M`−1 . When necessary, we apply each filter on the map and perform the required multiply-accumulate (MAC) operations (in our case, using XNOR and popcount operations). Since we now have binary filters, many 2D filters of size k×k repeat themselves. By using dedicated hardware/software, we can apply only the unique 2D filters on each feature map and sum the results to receive each 3D filter’s convolutional result. Note that an inverse filter (i.e., [-1,1,-1] is the inverse of [1,-1,1]) can also be treated as a repetition; it is merely a multiplication of the original filter by -1. For example, in our ConvNet architecture trained on the CIFAR-10 benchmark, there are only 42% unique filters per layer on average. Hence we can reduce the number of the XNOR-popcount operations by 3.\nQNNs complexity scale up linearly with the number of bits per weight/activation, since it requires the application of the XNOR kernel several times (see Section 3). As of now, QNNs still supply the best compression to accuracy ratio. Moreover, quantizing the gradients allows us to use the XNOR kernel for the backward pass, leading to fully fixed point layers with low bitwidth. By accelerating the training phase, QNNs can play an important role in future power demanding tasks."
    }, {
      "heading" : "6. Seven Times Faster on GPU at Run-Time",
      "text" : "It is possible to speed up GPU implementations of QNNs, by using a method sometimes called SIMD (single instruction, multiple data) within a register (SWAR). The basic idea of SWAR is to concatenate groups of 32 binary variables into 32-bit registers, and thus obtain a 32-times speed-up on bitwise operations (e.g., XNOR). Using SWAR, it is possible to evaluate 32 connections with only 3 instructions:\na1+ = popcount(xnor(a 32b 0 , w 32b 1 )), (11)\nwhere a1 is the resulting weighted sum, and a 32b 0 and w 32b 1 are the concatenated inputs and weights. Those 3 instructions (accumulation, popcount, xnor) take 1+4+1 = 6 clock cycles on recent Nvidia GPUs (and if they were to become a fused instruction, it would only take a single clock cycle). Consequently, we obtain a theoretical Nvidia GPU speed-up of factor of 32/6 ≈ 5.3. In practice, this speed-up is quite easy to obtain as the memory bandwidth to computation ratio is also increased 6 times.\nIn order to validate those theoretical results, we programmed two GPU kernels:\n• An unoptimized matrix multiplication kernel that serves as our baseline.\n• The XNOR kernel, which is nearly identical to the baseline, except that it uses the SWAR method, as in Equation (11).\nThe two GPU kernels return identical outputs when their inputs are constrained to −1 or +1 (but not otherwise). The XNOR kernel is about 23 times faster than the baseline kernel and 3.4 times faster than cuBLAS, as shown in Figure 3. Last but not least, the MLP from Section 4 runs 7 times faster with the XNOR kernel than with the baseline kernel, without suffering any loss in classification accuracy (see Figure 3). As MNIST’s images are not binary, the first layer’s computations are always performed by the baseline kernel. The last three columns show that the MLP accuracy does not depend on which kernel is used."
    }, {
      "heading" : "7. Discussion and Related Work",
      "text" : "Until recently, the use of extremely low-precision networks (binary in the extreme case) was believed to substantially degrade the network performance (Courbariaux et al., 2014). Soudry et al. (2014) and Cheng et al. (2015) proved the contrary by showing that good performance could be achieved even if all neurons and weights are binarized to ±1 . This was done using Expectation BackPropagation (EBP), a variational Bayesian approach, which infers networks with binary weights and neurons by updating the posterior distributions over the weights. These distributions are updated by differentiating their parameters (e.g., mean values) via the back propagation (BP) algorithm. Esser et al. (2015) implemented a fully binary network at run time using a very similar approach to EBP, showing significant\nimprovement in energy efficiency. The drawback of EBP is that the binarized parameters are only used during inference.\nThe probabilistic idea behind EBP was extended in the BinaryConnect algorithm of Courbariaux et al. (2015a). In BinaryConnect, the real-valued version of the weights is saved and used as a key reference for the binarization process. The binarization noise is independent between different weights, either by construction (by using stochastic quantization) or by assumption (a common simplification; see Spang and Schultheiss, 1962). The noise would have little effect on the next neuron’s input because the input is a summation over many weighted neurons. Thus, the real-valued version could be updated using the back propagated error by simply ignoring the binarization noise in the update. With this method, Courbariaux et al. (2015a) were the first to binarize weights in CNNs and achieved near state-of-the-art performance on several datasets. They also argued that noisy weights provide a form of regularization, which could help to improve generalization, as previously shown by Wan et al. (2013). This method binarized weights while still maintaining full precision neurons.\nLin et al. (2015a) carried over the work of Courbariaux et al. (2015a) to the backpropagation process by quantizing the representations at each layer of the network, to convert some of the remaining multiplications into binary shifts by restricting the neurons’ values to be power-of-two integers. Lin et al. (2015a)’s work and ours seem to share similar characteristics .However, their approach continues to use full precision weights during the test phase. Moreover, Lin et al. (2015a) quantize the neurons only during the back propagation process, and not during forward propagation.\nOther research (Baldassi et al., 2015) showed that full binary training and testing is possible in an array of committee machines with randomized input, where only one weight layer is being adjusted. Gong et al. (2014) aimed to compress a fully trained high precision network by using quantization or matrix factorization methods. These methods required training the network with full precision weights and neurons, thus requiring numerous MAC operations (which the proposed QNN algorithm avoids). Hwang and Sung (2014) focused on a fixed-point neural network design and achieved performance almost identical to that of the floating-point architecture. Kim and Smaragdis (2016) retrained neural networks with binary weights and activations.\nAs far as we know, before the first revision of this paper was published on arXive, no work succeeded in binarizing weights and neurons, at the inference phase and the entire training phase of a deep network. This was achieved in the present work. We relied on the idea that binarization can be done stochastically, or be approximated as random noise. This was previously done for the weights by Courbariaux et al. (2015a), but our BNNs extend this to the activations. Note that the binary activations are especially important for ConvNets, where there are typically many more neurons than free weights. This allows highly efficient operation of the binarized DNN at run time, and at the forward-propagation phase during training. Moreover, our training method has almost no multiplications, and therefore might be implemented efficiently in dedicated hardware. However, we have to save the value of the full precision weights. This is a remaining computational bottleneck during training, since it is an energy-consuming operation.\nShortly after the first version of this paper was posted on arXiv, several papers tried to improve and extend it. Rastegari et al. (2016) made a small modification to our algo-\nrithm (namely multiplying the binary weights and input by their L1 norm) and published promising results on the ImageNet dataset. Note that their method, named Xnor-Net, requires additional multiplication by a different scaling factor for each patch in each sample (Rastegari et al., 2016) Section 3.2 Eq. 10 and figure 2). This in itself, requires many multiplications and prevents efficient implementation of XnorNet on known hardware designs. Moreover, (Rastegari et al., 2016) didn’t quantize first and last layers, therefore XNOR-Net are only partially binarized NNs. Miyashita et al. (2016) suggested a more relaxed quantization (more than 1-bit) for both the weights and activation. Their idea was to quantize both and use shift operations as in our Eq. (4). They proposed to quantize the parameters in their non-uniform, base-2 logarithmic representation. This idea was inspired by the fact that the weights and activations in a trained network naturally have non-uniform distributions. They moreover showed that they can quantize the gradients as well to 6-bit without significant losses in performance (on the Cifar-10 dataset). Zhou et al. (2016) applied similar ideas to the ImageNet dataset and showed that by using 1-bit weights, 2-bit activations and 6-bit gradients they can achieve 46.1% top-1 accuracies using the AlexNet architecture. They named this method DoReFa net. Here we outperform DoReFa net and achieve 46.8% using a 1-2-6 bit quantization scheme (weight-activation-gradients) and 51% using a 1-2-32 quantization scheme. These results confirm that we can achieve comparable results even on a large dataset by applying the Xnor kernel several times. Merolla et al. (2016) showed that DNN can be robust to more than just weight binarization. They applied several different distortions to the weights, including additive and multiplicative noise, and a class of non-linear projections.This was shown to improve robustness to other distortions and even boost results. Zheng and Tang tried to apply our binarization scheme to recurrent neural network for language modeling and achieved comparable results as well. Andri et al. (2016) even created a hardware implementation to speed up BNNs.\nConclusion\nWe have introduced BNNs, which binarize deep neural networks and can lead to dramatic improvements in both power consumption and computation speed. During the forward pass (both at run-time and train-time), BNNs drastically reduce memory size and accesses, and replace most arithmetic operations with bit-wise operations. Our estimates indicate that power efficiency can be improved by more than one order of magnitude (see Section 5). In terms of speed, we programmed a binary matrix multiplication GPU kernel that enabled running MLP over the MNIST datset 7 times faster (than with an unoptimized GPU kernel) without any loss of accuracy (see Section 6).\nWe have shown that BNNs can handle MNIST, CIFAR-10 and SVHN while achieving nearly state-of-the-art accuracy. While our results for the challenging ImageNet are not on par with the best results achievable with full precision networks, they significantly improve all previous attempts to compress ImageNet-capable architectures. Moreover, by quantizing the weights and activations to more than 1-bit (i.e., QNNs), we have been able to achieve comparable results to the 32-bit floating point architectures (see Section 4.4 and supplementary material - Appendix B). A major open research avenue would be to further improve our results on ImageNet. Substantial progress in this direction might go a long way towards facilitating DNN usability in low power instruments such as mobile phones."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We would like to express our appreciation to Elad Hoffer, for his technical assistance and constructive comments. We thank our fellow MILA lab members who took the time to read the article and give us some feedback. We thank the developers of Torch, (Collobert et al., 2011) a Lua based environment, and Theano (Bergstra et al., 2010; Bastien et al., 2012), a Python library that allowed us to easily develop fast and optimized code for GPU. We also thank the developers of Pylearn2 (Goodfellow et al., 2013a) and Lasagne (Dieleman et al., 2015), two deep learning libraries built on the top of Theano. We thank Yuxin Wu for helping us compare our GPU kernels with cuBLAS. We are also grateful for funding from NSERC, the Canada Research Chairs, Compute Canada, and CIFAR. We are also grateful for funding from CIFAR, NSERC, IBM, Samsung. This research was supported by The Israel Science Foundation (grant No. 1890/14)"
    }, {
      "heading" : "Appendix A. Implementation Details",
      "text" : "In this section we give full implementation details over our MNIST,SVHN, CIFAR-10 and ImageNet datasets.\nA.1 MLP on MNIST (Theano)\nMNIST is an image classification benchmark dataset (LeCun et al., 1998). It consists of a training set of 60K and a test set of 10K 28 × 28 gray-scale images representing digits ranging from 0 to 9. In order for this benchmark to remain a challenge, we did not use any convolution, data-augmentation, preprocessing or unsupervised learning. The Multi-LayerPerceptron (MLP) we train on MNIST consists of 3 hidden layers of 4096 binary units and a L2-SVM output layer; L2-SVM has been shown to perform better than Softmax on several classification benchmarks (Tang, 2013; Lee et al., 2014). We regularize the model with Dropout (Srivastava et al., 2014). The square hinge loss is minimized with the ADAM adaptive learning rate method (Kingma and Ba, 2014b). We use an exponentially decaying global learning rate, as per Algorithm 1, and also scale the learning rates of the weights with their initialization coefficients from (Glorot and Bengio, 2010), as suggested by Courbariaux et al. (2015a). We use Batch Normalization with a minibatch of size 100 to speed up the training. As is typical, we use the last 10K samples of the training set as a validation set for early stopping and model selection. We report the test error rate associated with the best validation error rate after 1000 epochs (we do not retrain on the validation set).\nA.2 MLP on MNIST (Torch7)\nWe use a similar architecture as in our Theano experiments, without dropout, and with 2048 binary units per layer instead of 4096. Additionally, we use the shift base AdaMax and BN (with a minibatch of size 100) instead of the vanilla implementations, to reduce the number of multiplications. Likewise, we decay the learning rate by using a 1-bit right shift every 10 epochs.\nA.3 ConvNet on CIFAR-10 (Theano)\nCIFAR-10 is an image classification benchmark dataset. It consists of a training set of size 50K and a test set of size 10K, where instances are 32 × 32 color images representing airplanes, automobiles, birds, cats, deer, dogs, frogs, horses, ships and trucks. We do not use data-augmentation (which can really be a game changer for this dataset; see Graham 2014). The architecture of our ConvNet is identical to that used by Courbariaux et al. (2015b) except for the binarization of the activations. The Courbariaux et al. (2015a) architecture is itself mainly inspired by VGG (Simonyan and Zisserman, 2015). The square hinge loss is minimized with ADAM. We use an exponentially decaying learning rate, as we did for MNIST. We scale the learning rates of the weights with their initialization coefficients from (Glorot and Bengio, 2010). We use Batch Normalization with a minibatch of size 50 to speed up the training. We use the last 5000 samples of the training set as a validation set. We report the test error rate associated with the best validation error rate after 500 training epochs (we do not retrain on the validation set).\nA.4 ConvNet on CIFAR-10 (Torch7)\nWe use the same architecture as in our Theano experiments. We apply shift-based AdaMax and BN (with a minibatch of size 200) instead of the vanilla implementations to reduce the number of multiplications. Likewise, we decay the learning rate by using a 1-bit right shift every 50 epochs.\nA.5 ConvNet on SVHN\nSVHN is also an image classification benchmark dataset. It consists of a training set of size 604K examples and a test set of size 26K, where instances are 32 × 32 color images representing digits ranging from 0 to 9. In both sets of experiments, we follow the same procedure used for the CIFAR-10 experiments, with a few notable exceptions: we use half the number of units in the convolution layers, and we train for 200 epochs instead of 500 (because SVHN is a much larger dataset than CIFAR-10).\nA.6 ConvNet on ImageNet\nImageNet classification task consists of a training set of size 1.2M samples and test set of size 50K. Each instance is labeled with one of 1000 categories including objects, animals, scenes, and even some abstract shapes.\nAlexNet: Our AlexNet implementation consists of 5 convolution layers followed by 3 fully connected layers (see Section 8). Additionally, we use Adam as our optimization method and batch-normalization layers (with a minibatch of size 512). Likewise, we decay the learning rate by 0.1 every 20 epochs.\nGoogleNet: Our GoogleNet implementation consist of 2 convolution layers followed by 10 inception layers, spatial-average-pooling and a fully connected classifier. We also used the 2 auxilary classifiers. Additionally, we use Adam (Kingma and Ba, 2014a) as our optimization method and batch-normalization layers (with a minibatch of size 64). Likewise, we decay the learning rate by 0.1 every 10 epochs."
    } ],
    "references" : [ {
      "title" : "Yodann: An ultra-low power convolutional neural network accelerator based on binary weights",
      "author" : [ "Renzo Andri", "Lukas Cavigelli", "Davide Rossi", "Luca Benini" ],
      "venue" : "arXiv preprint arXiv:1606.05487,",
      "citeRegEx" : "Andri et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Andri et al\\.",
      "year" : 2016
    }, {
      "title" : "Neural machine translation by jointly learning to align and translate",
      "author" : [ "Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio" ],
      "venue" : "In ICLR’2015,",
      "citeRegEx" : "Bahdanau et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Bahdanau et al\\.",
      "year" : 2015
    }, {
      "title" : "Subdominant Dense Clusters Allow for Simple Learning and High Computational Performance in Neural Networks with Discrete Synapses",
      "author" : [ "Carlo Baldassi", "Alessandro Ingrosso", "Carlo Lucibello", "Luca Saglietti", "Riccardo Zecchina" ],
      "venue" : "Physical Review Letters,",
      "citeRegEx" : "Baldassi et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Baldassi et al\\.",
      "year" : 2015
    }, {
      "title" : "Embedded floating-point units in FPGAs",
      "author" : [ "Michael J Beauchamp", "Scott Hauck", "Keith D Underwood", "K Scott Hemmert" ],
      "venue" : "In Proceedings of the 2006 ACM/SIGDA 14th international symposium on Field programmable gate arrays,",
      "citeRegEx" : "Beauchamp et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Beauchamp et al\\.",
      "year" : 2006
    }, {
      "title" : "Estimating or propagating gradients through stochastic neurons",
      "author" : [ "Yoshua Bengio" ],
      "venue" : "Technical Report arXiv:1305.2982, Universite de Montreal,",
      "citeRegEx" : "Bengio.,? \\Q2013\\E",
      "shortCiteRegEx" : "Bengio.",
      "year" : 2013
    }, {
      "title" : "Theano: a CPU and GPU math expression compiler",
      "author" : [ "James Bergstra", "Olivier Breuleux", "Frédéric Bastien", "Pascal Lamblin", "Razvan Pascanu", "Guillaume Desjardins", "Joseph Turian", "David Warde-Farley", "Yoshua Bengio" ],
      "venue" : "In Proceedings of the Python for Scientific Computing Conference (SciPy),",
      "citeRegEx" : "Bergstra et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Bergstra et al\\.",
      "year" : 2010
    }, {
      "title" : "Diannao: A small-footprint high-throughput accelerator for ubiquitous machinelearning",
      "author" : [ "Tianshi Chen", "Zidong Du", "Ninghui Sun", "Jia Wang", "Chengyong Wu", "Yunji Chen", "Olivier Temam" ],
      "venue" : "In Proceedings of the 19th international conference on Architectural support for programming languages and operating systems,",
      "citeRegEx" : "Chen et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2014
    }, {
      "title" : "Compressing neural networks with the hashing trick",
      "author" : [ "Wenlin Chen", "James T Wilson", "Stephen Tyree", "Kilian Q Weinberger", "Yixin Chen" ],
      "venue" : "arXiv preprint arXiv:1504.04788,",
      "citeRegEx" : "Chen et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2015
    }, {
      "title" : "Dadiannao: A machine-learning supercomputer",
      "author" : [ "Yunji Chen", "Tao Luo", "Shaoli Liu", "Shijin Zhang", "Liqiang He", "Jia Wang", "Ling Li", "Tianshi Chen", "Zhiwei Xu", "Ninghui Sun" ],
      "venue" : "In Microarchitecture (MICRO),",
      "citeRegEx" : "Chen et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2014
    }, {
      "title" : "Training binary multilayer neural networks for image classification using expectation backpropgation",
      "author" : [ "Zhiyong Cheng", "Daniel Soudry", "Zexi Mao", "Zhenzhong Lan" ],
      "venue" : "arXiv preprint arXiv:1503.03562,",
      "citeRegEx" : "Cheng et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Cheng et al\\.",
      "year" : 2015
    }, {
      "title" : "Deep learning with COTS HPC systems",
      "author" : [ "Adam Coates", "Brody Huval", "Tao Wang", "David Wu", "Bryan Catanzaro", "Ng Andrew" ],
      "venue" : "In Proceedings of the 30th international conference on machine learning,",
      "citeRegEx" : "Coates et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Coates et al\\.",
      "year" : 2013
    }, {
      "title" : "Torch7: A matlab-like environment for machine learning",
      "author" : [ "Ronan Collobert", "Koray Kavukcuoglu", "Clément Farabet" ],
      "venue" : "In BigLearn, NIPS Workshop,",
      "citeRegEx" : "Collobert et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Collobert et al\\.",
      "year" : 2011
    }, {
      "title" : "Training deep neural networks with low precision multiplications",
      "author" : [ "Matthieu Courbariaux", "Yoshua Bengio", "Jean-Pierre David" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "Courbariaux et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Courbariaux et al\\.",
      "year" : 2014
    }, {
      "title" : "Binaryconnect: Training deep neural networks with binary weights during propagations",
      "author" : [ "Matthieu Courbariaux", "Yoshua Bengio", "Jean-Pierre David" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "Courbariaux et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Courbariaux et al\\.",
      "year" : 2015
    }, {
      "title" : "BinaryConnect: Training Deep Neural Networks with binary weights during propagations",
      "author" : [ "Matthieu Courbariaux", "Yoshua Bengio", "Jean-Pierre David" ],
      "venue" : "Nips, pages",
      "citeRegEx" : "Courbariaux et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Courbariaux et al\\.",
      "year" : 2015
    }, {
      "title" : "Fast and robust neural network joint models for statistical machine translation",
      "author" : [ "Jacob Devlin", "Rabih Zbib", "Zhongqiang Huang", "Thomas Lamar", "Richard Schwartz", "John Makhoul" ],
      "venue" : "In Proc. ACL’2014,",
      "citeRegEx" : "Devlin et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Devlin et al\\.",
      "year" : 2014
    }, {
      "title" : "Lasagne: First release",
      "author" : [ "Sander Dieleman", "Jan Schlter", "Colin Raffel", "Eben Olson", "Sren Kaae Snderby", "Daniel Nouri", "Daniel Maturana", "Martin Thoma", "Eric Battenberg", "Jack Kelly", "Jeffrey De Fauw", "Michael Heilman", "diogo", "Brian McFee", "Hendrik Weideman", "takacsg", "peterderivaz", "Jon", "instagibbs", "Dr. Kashif Rasul", "CongLiu", "Britefury", "Jonas Degrave" ],
      "venue" : "URL http://dx.doi.org/10.5281/zenodo.27878",
      "citeRegEx" : "Dieleman et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Dieleman et al\\.",
      "year" : 2015
    }, {
      "title" : "Backpropagation for energy-efficient neuromorphic computing",
      "author" : [ "Steve K Esser", "Rathinakumar Appuswamy", "Paul Merolla", "John V Arthur", "Dharmendra S Modha" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Esser et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Esser et al\\.",
      "year" : 2015
    }, {
      "title" : "Large-scale FPGA-based convolutional networks",
      "author" : [ "Clément Farabet", "Yann LeCun", "Koray Kavukcuoglu", "Eugenio Culurciello", "Berin Martini", "Polina Akselrod", "Selcuk Talay" ],
      "venue" : "Machine Learning on Very Large Data Sets,",
      "citeRegEx" : "Farabet et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Farabet et al\\.",
      "year" : 2011
    }, {
      "title" : "Neuflow: A runtime reconfigurable dataflow processor for vision",
      "author" : [ "Clément Farabet", "Berin Martini", "Benoit Corda", "Polina Akselrod", "Eugenio Culurciello", "Yann LeCun" ],
      "venue" : "In Computer Vision and Pattern Recognition Workshops (CVPRW),",
      "citeRegEx" : "Farabet et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Farabet et al\\.",
      "year" : 2011
    }, {
      "title" : "Understanding the difficulty of training deep feedforward neural networks",
      "author" : [ "Xavier Glorot", "Yoshua Bengio" ],
      "venue" : "In AISTATS’2010,",
      "citeRegEx" : "Glorot and Bengio.,? \\Q2010\\E",
      "shortCiteRegEx" : "Glorot and Bengio.",
      "year" : 2010
    }, {
      "title" : "Compressing deep convolutional networks using vector quantization",
      "author" : [ "Yunchao Gong", "Liu Liu", "Ming Yang", "Lubomir Bourdev" ],
      "venue" : "arXiv preprint arXiv:1412.6115,",
      "citeRegEx" : "Gong et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Gong et al\\.",
      "year" : 2014
    }, {
      "title" : "Pylearn2: a machine learning research",
      "author" : [ "Ian J. Goodfellow", "David Warde-Farley", "Pascal Lamblin", "Vincent Dumoulin", "Mehdi Mirza", "Razvan Pascanu", "James Bergstra", "Frédéric Bastien", "Yoshua Bengio" ],
      "venue" : "library. arXiv preprint arXiv:1308.4214,",
      "citeRegEx" : "Goodfellow et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Goodfellow et al\\.",
      "year" : 2013
    }, {
      "title" : "URL http://arxiv.org/ abs/1302.4389",
      "author" : [ "Ian J. Goodfellow", "David Warde-Farley", "Mehdi Mirza", "Aaron Courville", "Yoshua Bengio" ],
      "venue" : "Maxout Networks. arXiv preprint,",
      "citeRegEx" : "Goodfellow et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Goodfellow et al\\.",
      "year" : 2013
    }, {
      "title" : "Analysis of high-performance floating-point arithmetic on FPGAs",
      "author" : [ "Gokul Govindu", "Ling Zhuo", "Seonil Choi", "Viktor Prasanna" ],
      "venue" : "In Parallel and Distributed Processing Symposium,",
      "citeRegEx" : "Govindu et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Govindu et al\\.",
      "year" : 2004
    }, {
      "title" : "Spatially-sparse convolutional neural networks",
      "author" : [ "Benjamin Graham" ],
      "venue" : "arXiv preprint arXiv:1409.6070,",
      "citeRegEx" : "Graham.,? \\Q2014\\E",
      "shortCiteRegEx" : "Graham.",
      "year" : 2014
    }, {
      "title" : "Practical variational inference for neural networks",
      "author" : [ "Alex Graves" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Graves.,? \\Q2011\\E",
      "shortCiteRegEx" : "Graves.",
      "year" : 2011
    }, {
      "title" : "Deep learning with limited numerical precision",
      "author" : [ "Suyog Gupta", "Ankur Agrawal", "Kailash Gopalakrishnan", "Pritish Narayanan" ],
      "venue" : "CoRR, abs/1502.02551,",
      "citeRegEx" : "Gupta et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Gupta et al\\.",
      "year" : 2015
    }, {
      "title" : "Hardware-oriented approximation of convolutional neural networks",
      "author" : [ "Philipp Gysel", "Mohammad Motamedi", "Soheil Ghiasi" ],
      "venue" : "arXiv preprint arXiv:1604.03168,",
      "citeRegEx" : "Gysel et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Gysel et al\\.",
      "year" : 2016
    }, {
      "title" : "Deep Compression: Compressing Deep Neural Networks with Pruning, Trained Quantization and Huffman Coding",
      "author" : [ "Huizi Mao Han", "Song", "William J. Dally" ],
      "venue" : "arXiv preprint,",
      "citeRegEx" : "Han et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Han et al\\.",
      "year" : 2015
    }, {
      "title" : "Deep compression: Compressing deep neural networks with pruning, trained quantization and huffman coding",
      "author" : [ "Song Han", "Huizi Mao", "William J Dally" ],
      "venue" : "arXiv preprint arXiv:1510.00149,",
      "citeRegEx" : "Han et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Han et al\\.",
      "year" : 2015
    }, {
      "title" : "Learning both weights and connections for efficient neural network",
      "author" : [ "Song Han", "Jeff Pool", "John Tran", "William Dally" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Han et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Han et al\\.",
      "year" : 2015
    }, {
      "title" : "Neural networks for machine learning",
      "author" : [ "Geoffrey Hinton" ],
      "venue" : "Coursera, video lectures,",
      "citeRegEx" : "Hinton.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hinton.",
      "year" : 2012
    }, {
      "title" : "Deep neural networks for acoustic modeling in speech recognition",
      "author" : [ "Geoffrey Hinton", "Li Deng", "George E. Dahl", "Abdel-rahman Mohamed", "Navdeep Jaitly", "Andrew Senior", "Vincent Vanhoucke", "Patrick Nguyen", "Tara Sainath", "Brian Kingsbury" ],
      "venue" : "IEEE Signal Processing Magazine,",
      "citeRegEx" : "Hinton et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hinton et al\\.",
      "year" : 2012
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Sepp Hochreiter", "Jürgen Schmidhuber" ],
      "venue" : "Neural computation,",
      "citeRegEx" : "Hochreiter and Schmidhuber.,? \\Q1997\\E",
      "shortCiteRegEx" : "Hochreiter and Schmidhuber.",
      "year" : 1997
    }, {
      "title" : "Computing’s Energy Problem (and what we can do about it)",
      "author" : [ "Mark Horowitz" ],
      "venue" : "IEEE Interational Solid State Circuits Conference,",
      "citeRegEx" : "Horowitz.,? \\Q2014\\E",
      "shortCiteRegEx" : "Horowitz.",
      "year" : 2014
    }, {
      "title" : "Fixed-point feedforward deep neural network design using weights+",
      "author" : [ "Kyuyeon Hwang", "Wonyong Sung" ],
      "venue" : "In Signal Processing Systems (SiPS),",
      "citeRegEx" : "Hwang and Sung.,? \\Q2014\\E",
      "shortCiteRegEx" : "Hwang and Sung.",
      "year" : 2014
    }, {
      "title" : "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
      "author" : [ "Sergey Ioffe", "Christian Szegedy" ],
      "venue" : null,
      "citeRegEx" : "Ioffe and Szegedy.,? \\Q2015\\E",
      "shortCiteRegEx" : "Ioffe and Szegedy.",
      "year" : 2015
    }, {
      "title" : "Bitwise Neural Networks",
      "author" : [ "M. Kim", "P. Smaragdis" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "Kim and Smaragdis.,? \\Q2016\\E",
      "shortCiteRegEx" : "Kim and Smaragdis.",
      "year" : 2016
    }, {
      "title" : "Adam: A Method for Stochastic Optimization",
      "author" : [ "Diederik Kingma", "Jimmy Ba" ],
      "venue" : "[cs], pages 1–13,",
      "citeRegEx" : "Kingma and Ba.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kingma and Ba.",
      "year" : 2014
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Diederik Kingma", "Jimmy Ba" ],
      "venue" : "arXiv preprint arXiv:1412.6980,",
      "citeRegEx" : "Kingma and Ba.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kingma and Ba.",
      "year" : 2014
    }, {
      "title" : "ImageNet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevsky", "I. Sutskever", "G. Hinton" ],
      "venue" : "In NIPS’2012",
      "citeRegEx" : "Krizhevsky et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Krizhevsky et al\\.",
      "year" : 2012
    }, {
      "title" : "Gradient-based learning applied to document recognition",
      "author" : [ "Yann LeCun", "Leon Bottou", "Yoshua Bengio", "Patrick Haffner" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "LeCun et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 1998
    }, {
      "title" : "Generalizing pooling functions in convolutional neural networks: Mixed",
      "author" : [ "Chen-Yu Lee", "Patrick W Gallagher", "Zhuowen Tu" ],
      "venue" : "gated, and tree. arXiv preprint arXiv:1509.08985,",
      "citeRegEx" : "Lee et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2015
    }, {
      "title" : "Neural networks with few multiplications",
      "author" : [ "Zhouhan Lin", "Matthieu Courbariaux", "Roland Memisevic", "Yoshua Bengio" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "Lin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lin et al\\.",
      "year" : 2015
    }, {
      "title" : "Neural Networks with Few Multiplications",
      "author" : [ "Zhouhan Lin", "Matthieu Courbariaux", "Roland Memisevic", "Yoshua Bengio" ],
      "venue" : "Iclr, pages 1–8,",
      "citeRegEx" : "Lin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lin et al\\.",
      "year" : 2015
    }, {
      "title" : "Fast inverse square root",
      "author" : [ "Chris Lomont" ],
      "venue" : "Tech-315 nical Report,",
      "citeRegEx" : "Lomont.,? \\Q2003\\E",
      "shortCiteRegEx" : "Lomont.",
      "year" : 2003
    }, {
      "title" : "Building a large annotated corpus of english: The penn treebank",
      "author" : [ "Mitchell P Marcus", "Mary Ann Marcinkiewicz", "Beatrice Santorini" ],
      "venue" : "Computational linguistics,",
      "citeRegEx" : "Marcus et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Marcus et al\\.",
      "year" : 1993
    }, {
      "title" : "Deep neural networks are robust to weight binarization and other non-linear distortions",
      "author" : [ "Paul Merolla", "Rathinakumar Appuswamy", "John Arthur", "Steve K Esser", "Dharmendra Modha" ],
      "venue" : null,
      "citeRegEx" : "Merolla et al\\.,? \\Q1981\\E",
      "shortCiteRegEx" : "Merolla et al\\.",
      "year" : 1981
    }, {
      "title" : "Context dependent recurrent neural network language model",
      "author" : [ "Tomas Mikolov", "Geoffrey Zweig" ],
      "venue" : "In SLT,",
      "citeRegEx" : "Mikolov and Zweig.,? \\Q2012\\E",
      "shortCiteRegEx" : "Mikolov and Zweig.",
      "year" : 2012
    }, {
      "title" : "Convolutional neural networks using logarithmic data representation",
      "author" : [ "Daisuke Miyashita", "Edward H Lee", "Boris Murmann" ],
      "venue" : "arXiv preprint arXiv:1603.01025,",
      "citeRegEx" : "Miyashita et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Miyashita et al\\.",
      "year" : 2016
    }, {
      "title" : "Human-level control through deep reinforcement learning",
      "author" : [ "Volodymyr Mnih", "Koray Kavukcuoglo", "David Silver", "Andrei A. Rusu", "Joel Veness", "Marc G. Bellemare", "Alex Graves", "Martin Riedmiller", "Andreas K. Fidgeland", "Georg Ostrovski", "Stig Petersen", "Charles Beattie", "Amir Sadik", "Ioannis Antonoglou", "Helen King", "Dharsan Kumaran", "Daan Wierstra", "Shane Legg", "Demis Hassabis" ],
      "venue" : "Nature, 518:529–533,",
      "citeRegEx" : "Mnih et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Mnih et al\\.",
      "year" : 2015
    }, {
      "title" : "Recurrent neural networks with limited numerical precision",
      "author" : [ "Joachim Ott", "Zhouhan Lin", "Ying Zhang", "Shih-Chii Liu", "Yoshua Bengio" ],
      "venue" : "arXiv preprint arXiv:1608.06902,",
      "citeRegEx" : "Ott et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Ott et al\\.",
      "year" : 2016
    }, {
      "title" : "Neuflow: Dataflow vision processing system-on-a-chip",
      "author" : [ "Phi-Hung Pham", "Darko Jelaca", "Clement Farabet", "Berin Martini", "Yann LeCun", "Eugenio Culurciello" ],
      "venue" : "In Circuits and Systems (MWSCAS),",
      "citeRegEx" : "Pham et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Pham et al\\.",
      "year" : 2012
    }, {
      "title" : "Xnor-net: Imagenet classification using binary convolutional neural networks",
      "author" : [ "Mohammad Rastegari", "Vicente Ordonez", "Joseph Redmon", "Ali Farhadi" ],
      "venue" : "arXiv preprint arXiv:1603.05279,",
      "citeRegEx" : "Rastegari et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Rastegari et al\\.",
      "year" : 2016
    }, {
      "title" : "Fitnets: Hints for thin deep nets",
      "author" : [ "Adriana Romero", "Nicolas Ballas", "Samira Ebrahimi Kahou", "Antoine Chassang", "Carlo Gatta", "Yoshua Bengio" ],
      "venue" : "arXiv preprint arXiv:1412.6550,",
      "citeRegEx" : "Romero et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Romero et al\\.",
      "year" : 2014
    }, {
      "title" : "Deep convolutional neural networks for LVCSR",
      "author" : [ "Tara Sainath", "Abdel rahman Mohamed", "Brian Kingsbury", "Bhuvana Ramabhadran" ],
      "venue" : null,
      "citeRegEx" : "Sainath et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Sainath et al\\.",
      "year" : 2013
    }, {
      "title" : "Very deep convolutional networks for large-scale image recognition",
      "author" : [ "Karen Simonyan", "Andrew Zisserman" ],
      "venue" : "In ICLR,",
      "citeRegEx" : "Simonyan and Zisserman.,? \\Q2015\\E",
      "shortCiteRegEx" : "Simonyan and Zisserman.",
      "year" : 2015
    }, {
      "title" : "Expectation backpropagation: Parameter-free training of multilayer neural networks with continuous or discrete weights",
      "author" : [ "Daniel Soudry", "Itay Hubara", "Ron Meir" ],
      "venue" : "In NIPS’2014,",
      "citeRegEx" : "Soudry et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Soudry et al\\.",
      "year" : 2014
    }, {
      "title" : "Reduction of quantizing noise by use of feedback",
      "author" : [ "H Spang", "P Schultheiss" ],
      "venue" : "IRE Transactions on Communications Systems,",
      "citeRegEx" : "Spang and Schultheiss.,? \\Q1962\\E",
      "shortCiteRegEx" : "Spang and Schultheiss.",
      "year" : 1962
    }, {
      "title" : "Dropout: A simple way to prevent neural networks from overfitting",
      "author" : [ "Nitish Srivastava", "Geoffrey Hinton", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Srivastava et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Srivastava et al\\.",
      "year" : 2014
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "Ilya Sutskever", "Oriol Vinyals", "Quoc V. Le" ],
      "venue" : "In NIPS’2014,",
      "citeRegEx" : "Sutskever et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Sutskever et al\\.",
      "year" : 2014
    }, {
      "title" : "Going deeper with convolutions",
      "author" : [ "Christian Szegedy", "Wei Liu", "Yangqing Jia", "Pierre Sermanet", "Scott Reed", "Dragomir Anguelov", "Dumitru Erhan", "Vincent Vanhoucke", "Andrew Rabinovich" ],
      "venue" : "Technical report,",
      "citeRegEx" : "Szegedy et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Szegedy et al\\.",
      "year" : 2014
    }, {
      "title" : "Deep learning using linear support vector machines",
      "author" : [ "Yichuan Tang" ],
      "venue" : "Workshop on Challenges in Representation Learning,",
      "citeRegEx" : "Tang.,? \\Q2013\\E",
      "shortCiteRegEx" : "Tang.",
      "year" : 2013
    }, {
      "title" : "Asic implementation of random number generators using sr latches and its evaluation",
      "author" : [ "Naoya Torii", "Hirotaka Kokubo", "Dai Yamamoto", "Kouichi Itoh", "Masahiko Takenaka", "Tsutomu Matsumoto" ],
      "venue" : "EURASIP Journal on Information Security,",
      "citeRegEx" : "Torii et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Torii et al\\.",
      "year" : 2016
    }, {
      "title" : "Improving the speed of neural networks on CPUs",
      "author" : [ "Vincent Vanhoucke", "Andrew Senior", "Mark Z Mao" ],
      "venue" : "In Proc. Deep Learning and Unsupervised Feature Learning NIPS Workshop,",
      "citeRegEx" : "Vanhoucke et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Vanhoucke et al\\.",
      "year" : 2011
    }, {
      "title" : "Regularization of neural networks using dropconnect",
      "author" : [ "Li Wan", "Matthew Zeiler", "Sixin Zhang", "Yann LeCun", "Rob Fergus" ],
      "venue" : "In ICML’2013,",
      "citeRegEx" : "Wan et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Wan et al\\.",
      "year" : 2013
    }, {
      "title" : "Efficient and accurate approximations of nonlinear convolutional networks",
      "author" : [ "Xiangyu Zhang", "Jianhua Zou", "Xiang Ming", "Kaiming He", "Jian Sun" ],
      "venue" : null,
      "citeRegEx" : "Zhang et al\\.,? \\Q1984\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 1984
    }, {
      "title" : "Dorefa-net: Training low bitwidth convolutional neural networks with low bitwidth gradients",
      "author" : [ "Shuchang Zhou", "Zekun Ni", "Xinyu Zhou", "He Wen", "Yuxin Wu", "Yuheng Zou" ],
      "venue" : "arXiv preprint arXiv:1606.06160,",
      "citeRegEx" : "Zhou et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Zhou et al\\.",
      "year" : 2016
    } ],
    "referenceMentions" : [ {
      "referenceID" : 41,
      "context" : "Deep Neural Networks (DNNs) have substantially pushed Artificial Intelligence (AI) limits in a wide range of tasks, including but not limited to object recognition from images (Krizhevsky et al., 2012; Szegedy et al., 2014), speech recognition (Hinton et al.",
      "startOffset" : 176,
      "endOffset" : 223
    }, {
      "referenceID" : 62,
      "context" : "Deep Neural Networks (DNNs) have substantially pushed Artificial Intelligence (AI) limits in a wide range of tasks, including but not limited to object recognition from images (Krizhevsky et al., 2012; Szegedy et al., 2014), speech recognition (Hinton et al.",
      "startOffset" : 176,
      "endOffset" : 223
    }, {
      "referenceID" : 33,
      "context" : ", 2014), speech recognition (Hinton et al., 2012; Sainath et al., 2013), statistical machine translation (Devlin et al.",
      "startOffset" : 28,
      "endOffset" : 71
    }, {
      "referenceID" : 56,
      "context" : ", 2014), speech recognition (Hinton et al., 2012; Sainath et al., 2013), statistical machine translation (Devlin et al.",
      "startOffset" : 28,
      "endOffset" : 71
    }, {
      "referenceID" : 15,
      "context" : ", 2013), statistical machine translation (Devlin et al., 2014; Sutskever et al., 2014; Bahdanau et al., 2015), Atari and Go games (Mnih et al.",
      "startOffset" : 41,
      "endOffset" : 109
    }, {
      "referenceID" : 61,
      "context" : ", 2013), statistical machine translation (Devlin et al., 2014; Sutskever et al., 2014; Bahdanau et al., 2015), Atari and Go games (Mnih et al.",
      "startOffset" : 41,
      "endOffset" : 109
    }, {
      "referenceID" : 1,
      "context" : ", 2013), statistical machine translation (Devlin et al., 2014; Sutskever et al., 2014; Bahdanau et al., 2015), Atari and Go games (Mnih et al.",
      "startOffset" : 41,
      "endOffset" : 109
    }, {
      "referenceID" : 51,
      "context" : ", 2015), Atari and Go games (Mnih et al., 2015; Silver et al., 2016), and even computer generation of abstract art (Mordvintsev et al.",
      "startOffset" : 28,
      "endOffset" : 68
    }, {
      "referenceID" : 10,
      "context" : "Today, DNNs are almost exclusively trained on one or many very fast and power-hungry Graphic Processing Units (GPUs) (Coates et al., 2013).",
      "startOffset" : 117,
      "endOffset" : 138
    }, {
      "referenceID" : 65,
      "context" : "As a result, it is often a challenge to run DNNs on target low-power devices, and substantial research efforts are invested in speeding up DNNs at run-time on both generalpurpose (Vanhoucke et al., 2011; Gong et al., 2014; Romero et al., 2014; Han et al., 2015b) and specialized computer hardware (Farabet et al.",
      "startOffset" : 179,
      "endOffset" : 262
    }, {
      "referenceID" : 21,
      "context" : "As a result, it is often a challenge to run DNNs on target low-power devices, and substantial research efforts are invested in speeding up DNNs at run-time on both generalpurpose (Vanhoucke et al., 2011; Gong et al., 2014; Romero et al., 2014; Han et al., 2015b) and specialized computer hardware (Farabet et al.",
      "startOffset" : 179,
      "endOffset" : 262
    }, {
      "referenceID" : 55,
      "context" : "As a result, it is often a challenge to run DNNs on target low-power devices, and substantial research efforts are invested in speeding up DNNs at run-time on both generalpurpose (Vanhoucke et al., 2011; Gong et al., 2014; Romero et al., 2014; Han et al., 2015b) and specialized computer hardware (Farabet et al.",
      "startOffset" : 179,
      "endOffset" : 262
    }, {
      "referenceID" : 53,
      "context" : ", 2015b) and specialized computer hardware (Farabet et al., 2011a,b; Pham et al., 2012; Chen et al., 2014a,b; Esser et al., 2015).",
      "startOffset" : 43,
      "endOffset" : 129
    }, {
      "referenceID" : 17,
      "context" : ", 2015b) and specialized computer hardware (Farabet et al., 2011a,b; Pham et al., 2012; Chen et al., 2014a,b; Esser et al., 2015).",
      "startOffset" : 43,
      "endOffset" : 129
    }, {
      "referenceID" : 7,
      "context" : "HashedNets (Chen et al., 2015) reduce model sizes by using a hash function to randomly group connection weights and force them to share a single parameter value.",
      "startOffset" : 11,
      "endOffset" : 30
    }, {
      "referenceID" : 1,
      "context" : ", 2014; Bahdanau et al., 2015), Atari and Go games (Mnih et al., 2015; Silver et al., 2016), and even computer generation of abstract art (Mordvintsev et al., 2015). Training or even just using neural network (NN) algorithms on conventional generalpurpose digital hardware (Von Neumann architecture) has been found highly inefficient due to the massive amount of multiply-accumulate operations (MACs) required to compute the weighted sums of the neurons’ inputs. Today, DNNs are almost exclusively trained on one or many very fast and power-hungry Graphic Processing Units (GPUs) (Coates et al., 2013). As a result, it is often a challenge to run DNNs on target low-power devices, and substantial research efforts are invested in speeding up DNNs at run-time on both generalpurpose (Vanhoucke et al., 2011; Gong et al., 2014; Romero et al., 2014; Han et al., 2015b) and specialized computer hardware (Farabet et al., 2011a,b; Pham et al., 2012; Chen et al., 2014a,b; Esser et al., 2015). The most common approach is to compress a trained (full precision) network. HashedNets (Chen et al., 2015) reduce model sizes by using a hash function to randomly group connection weights and force them to share a single parameter value. Gong et al. (2014) compressed deep convnets using vector quantization, which resulteds in only a 1% accuracy loss.",
      "startOffset" : 8,
      "endOffset" : 1245
    }, {
      "referenceID" : 1,
      "context" : ", 2014; Bahdanau et al., 2015), Atari and Go games (Mnih et al., 2015; Silver et al., 2016), and even computer generation of abstract art (Mordvintsev et al., 2015). Training or even just using neural network (NN) algorithms on conventional generalpurpose digital hardware (Von Neumann architecture) has been found highly inefficient due to the massive amount of multiply-accumulate operations (MACs) required to compute the weighted sums of the neurons’ inputs. Today, DNNs are almost exclusively trained on one or many very fast and power-hungry Graphic Processing Units (GPUs) (Coates et al., 2013). As a result, it is often a challenge to run DNNs on target low-power devices, and substantial research efforts are invested in speeding up DNNs at run-time on both generalpurpose (Vanhoucke et al., 2011; Gong et al., 2014; Romero et al., 2014; Han et al., 2015b) and specialized computer hardware (Farabet et al., 2011a,b; Pham et al., 2012; Chen et al., 2014a,b; Esser et al., 2015). The most common approach is to compress a trained (full precision) network. HashedNets (Chen et al., 2015) reduce model sizes by using a hash function to randomly group connection weights and force them to share a single parameter value. Gong et al. (2014) compressed deep convnets using vector quantization, which resulteds in only a 1% accuracy loss. However, both methods focused only on the fully connected layers. A recent work by Han and Dally (2015) successfully pruned several state-of-the-art large scale networks and showed that the number of parameters could be reduced by an order of magnitude.",
      "startOffset" : 8,
      "endOffset" : 1445
    }, {
      "referenceID" : 1,
      "context" : ", 2014; Bahdanau et al., 2015), Atari and Go games (Mnih et al., 2015; Silver et al., 2016), and even computer generation of abstract art (Mordvintsev et al., 2015). Training or even just using neural network (NN) algorithms on conventional generalpurpose digital hardware (Von Neumann architecture) has been found highly inefficient due to the massive amount of multiply-accumulate operations (MACs) required to compute the weighted sums of the neurons’ inputs. Today, DNNs are almost exclusively trained on one or many very fast and power-hungry Graphic Processing Units (GPUs) (Coates et al., 2013). As a result, it is often a challenge to run DNNs on target low-power devices, and substantial research efforts are invested in speeding up DNNs at run-time on both generalpurpose (Vanhoucke et al., 2011; Gong et al., 2014; Romero et al., 2014; Han et al., 2015b) and specialized computer hardware (Farabet et al., 2011a,b; Pham et al., 2012; Chen et al., 2014a,b; Esser et al., 2015). The most common approach is to compress a trained (full precision) network. HashedNets (Chen et al., 2015) reduce model sizes by using a hash function to randomly group connection weights and force them to share a single parameter value. Gong et al. (2014) compressed deep convnets using vector quantization, which resulteds in only a 1% accuracy loss. However, both methods focused only on the fully connected layers. A recent work by Han and Dally (2015) successfully pruned several state-of-the-art large scale networks and showed that the number of parameters could be reduced by an order of magnitude. Recent works have shown that more computationally efficient DNNs can be constructed by quantizing some of the parameters during the training phase. In most cases, DNNs are trained by minimizing some error function using Back-Propagation (BP) or related gradient descent methods. However, such an approach cannot be directly applied if the weights are restricted to binary values. Soudry et al. (2014) used a variational Bayesian approach with Mean-Field and Central Limit approximation to calculate the posterior distribution of the weights (the probability of each weight to be +1 or -1).",
      "startOffset" : 8,
      "endOffset" : 1996
    }, {
      "referenceID" : 1,
      "context" : ", 2014; Bahdanau et al., 2015), Atari and Go games (Mnih et al., 2015; Silver et al., 2016), and even computer generation of abstract art (Mordvintsev et al., 2015). Training or even just using neural network (NN) algorithms on conventional generalpurpose digital hardware (Von Neumann architecture) has been found highly inefficient due to the massive amount of multiply-accumulate operations (MACs) required to compute the weighted sums of the neurons’ inputs. Today, DNNs are almost exclusively trained on one or many very fast and power-hungry Graphic Processing Units (GPUs) (Coates et al., 2013). As a result, it is often a challenge to run DNNs on target low-power devices, and substantial research efforts are invested in speeding up DNNs at run-time on both generalpurpose (Vanhoucke et al., 2011; Gong et al., 2014; Romero et al., 2014; Han et al., 2015b) and specialized computer hardware (Farabet et al., 2011a,b; Pham et al., 2012; Chen et al., 2014a,b; Esser et al., 2015). The most common approach is to compress a trained (full precision) network. HashedNets (Chen et al., 2015) reduce model sizes by using a hash function to randomly group connection weights and force them to share a single parameter value. Gong et al. (2014) compressed deep convnets using vector quantization, which resulteds in only a 1% accuracy loss. However, both methods focused only on the fully connected layers. A recent work by Han and Dally (2015) successfully pruned several state-of-the-art large scale networks and showed that the number of parameters could be reduced by an order of magnitude. Recent works have shown that more computationally efficient DNNs can be constructed by quantizing some of the parameters during the training phase. In most cases, DNNs are trained by minimizing some error function using Back-Propagation (BP) or related gradient descent methods. However, such an approach cannot be directly applied if the weights are restricted to binary values. Soudry et al. (2014) used a variational Bayesian approach with Mean-Field and Central Limit approximation to calculate the posterior distribution of the weights (the probability of each weight to be +1 or -1). During the inference stage (test phase), their method samples from this distribution one binary network and used it to predict the targets of the test set (More than one binary network can also be used). Courbariaux et al. (2015b) similarly used two sets of weights, real-valued and binary.",
      "startOffset" : 8,
      "endOffset" : 2416
    }, {
      "referenceID" : 12,
      "context" : "In order to transform the real-valued variables into those two values, we use two different binarization functions, as proposed by Courbariaux et al. (2015a). The first binarization function is deterministic:",
      "startOffset" : 131,
      "endOffset" : 158
    }, {
      "referenceID" : 64,
      "context" : "This stochastic binarization is more appealing theoretically (see Section 4) than the sign function, but somewhat harder to implement as it requires the hardware to generate random bits when quantizing (Torii et al., 2016).",
      "startOffset" : 202,
      "endOffset" : 222
    }, {
      "referenceID" : 26,
      "context" : "Moreover, adding noise to weights and activations when computing the parameter gradients provide a form of regularization that can help to generalize better, as previously shown with variational weight noise (Graves, 2011), Dropout (Srivastava et al.",
      "startOffset" : 208,
      "endOffset" : 222
    }, {
      "referenceID" : 60,
      "context" : "Moreover, adding noise to weights and activations when computing the parameter gradients provide a form of regularization that can help to generalize better, as previously shown with variational weight noise (Graves, 2011), Dropout (Srivastava et al., 2014) and DropConnect (Wan et al.",
      "startOffset" : 232,
      "endOffset" : 257
    }, {
      "referenceID" : 66,
      "context" : ", 2014) and DropConnect (Wan et al., 2013).",
      "startOffset" : 24,
      "endOffset" : 42
    }, {
      "referenceID" : 32,
      "context" : "He found that the fastest training was obtained when using the “straight-through estimator,” previously introduced in Hinton’s lectures (Hinton, 2012).",
      "startOffset" : 136,
      "endOffset" : 150
    }, {
      "referenceID" : 4,
      "context" : "Bengio (2013) studied the question of estimating or propagating gradients through stochastic discrete neurons.",
      "startOffset" : 0,
      "endOffset" : 14
    }, {
      "referenceID" : 37,
      "context" : "4 Shift-based Batch Normalization Batch Normalization (BN) (Ioffe and Szegedy, 2015) accelerates the training and reduces the overall impact of the weight scale (Courbariaux et al.",
      "startOffset" : 59,
      "endOffset" : 84
    }, {
      "referenceID" : 44,
      "context" : "From the early work of Lomont (2003) we know that the inverse-square operation could be applied with approximately the same complexity as multiplication.",
      "startOffset" : 23,
      "endOffset" : 37
    }, {
      "referenceID" : 44,
      "context" : ", after averaging (for a more precise calculation, see the BN analysis in Lin et al. (2015b). Furthermore, the size of the standard deviation vectors is relatively small.",
      "startOffset" : 74,
      "endOffset" : 93
    }, {
      "referenceID" : 37,
      "context" : "BatchNorm() specifies how to batch-normalize the activations, using either batch normalization (Ioffe and Szegedy, 2015) or its shift-based variant we describe in Algorithm 2.",
      "startOffset" : 95,
      "endOffset" : 120
    }, {
      "referenceID" : 20,
      "context" : "Require: a minibatch of inputs and targets (a0, a ∗), previous weights W , previous BatchNorm parameters θ, weight initialization coefficients from (Glorot and Bengio, 2010) γ, and previous learning rate η.",
      "startOffset" : 148,
      "endOffset" : 173
    }, {
      "referenceID" : 62,
      "context" : "Consequently, the first layer of a ConvNet is often the smallest convolution layer, both in terms of parameters and computations (Szegedy et al., 2014).",
      "startOffset" : 129,
      "endOffset" : 151
    }, {
      "referenceID" : 67,
      "context" : "This idea was recently proposed by Zhou et al. (2016) (DoReFa net) and Miyashita et al.",
      "startOffset" : 35,
      "endOffset" : 54
    }, {
      "referenceID" : 50,
      "context" : "(2016) (DoReFa net) and Miyashita et al. (2016) (published on arXive shortly after our preliminary technical report was published there).",
      "startOffset" : 24,
      "endOffset" : 48
    }, {
      "referenceID" : 50,
      "context" : "(2016) (DoReFa net) and Miyashita et al. (2016) (published on arXive shortly after our preliminary technical report was published there). However, in contrast to to Zhou et al., we did not find it useful to initialize the network with weights obtained by training the network with full precision weights. Moreover, the Zhou et al. network did not quantize the weights of the first convolutional layer and the last fully-connected layer, whereas we binarized both. We followed the quantization schemes suggested by Miyashita et al. (2016), namely, linear quantization:",
      "startOffset" : 24,
      "endOffset" : 538
    }, {
      "referenceID" : 2,
      "context" : "40% Committee Machines’ Array Baldassi et al. (2015) 1.",
      "startOffset" : 30,
      "endOffset" : 53
    }, {
      "referenceID" : 2,
      "context" : "40% Committee Machines’ Array Baldassi et al. (2015) 1.35% Binarized weights, during training and test BinaryConnect Courbariaux et al. (2015a) 1.",
      "startOffset" : 30,
      "endOffset" : 144
    }, {
      "referenceID" : 2,
      "context" : "40% Committee Machines’ Array Baldassi et al. (2015) 1.35% Binarized weights, during training and test BinaryConnect Courbariaux et al. (2015a) 1.29± 0.08% 2.30% 9.90% Binarized activations+weights, during test EBP Cheng et al. (2015) 2.",
      "startOffset" : 30,
      "endOffset" : 235
    }, {
      "referenceID" : 2,
      "context" : "40% Committee Machines’ Array Baldassi et al. (2015) 1.35% Binarized weights, during training and test BinaryConnect Courbariaux et al. (2015a) 1.29± 0.08% 2.30% 9.90% Binarized activations+weights, during test EBP Cheng et al. (2015) 2.2± 0.1% Bitwise DNNs Kim and Smaragdis (2016) 1.",
      "startOffset" : 30,
      "endOffset" : 283
    }, {
      "referenceID" : 2,
      "context" : "40% Committee Machines’ Array Baldassi et al. (2015) 1.35% Binarized weights, during training and test BinaryConnect Courbariaux et al. (2015a) 1.29± 0.08% 2.30% 9.90% Binarized activations+weights, during test EBP Cheng et al. (2015) 2.2± 0.1% Bitwise DNNs Kim and Smaragdis (2016) 1.33% Ternary weights, binary activations, during test Hwang and Sung (2014) 1.",
      "startOffset" : 30,
      "endOffset" : 360
    }, {
      "referenceID" : 2,
      "context" : "40% Committee Machines’ Array Baldassi et al. (2015) 1.35% Binarized weights, during training and test BinaryConnect Courbariaux et al. (2015a) 1.29± 0.08% 2.30% 9.90% Binarized activations+weights, during test EBP Cheng et al. (2015) 2.2± 0.1% Bitwise DNNs Kim and Smaragdis (2016) 1.33% Ternary weights, binary activations, during test Hwang and Sung (2014) 1.45% No binarization (standard results) No reg 1.3± 0.2% 2.44% 10.94% Maxout Networks Goodfellow et al. (2013b) 0.",
      "startOffset" : 30,
      "endOffset" : 473
    }, {
      "referenceID" : 2,
      "context" : "40% Committee Machines’ Array Baldassi et al. (2015) 1.35% Binarized weights, during training and test BinaryConnect Courbariaux et al. (2015a) 1.29± 0.08% 2.30% 9.90% Binarized activations+weights, during test EBP Cheng et al. (2015) 2.2± 0.1% Bitwise DNNs Kim and Smaragdis (2016) 1.33% Ternary weights, binary activations, during test Hwang and Sung (2014) 1.45% No binarization (standard results) No reg 1.3± 0.2% 2.44% 10.94% Maxout Networks Goodfellow et al. (2013b) 0.94% 2.47% 11.68% Gated pooling Lee et al. (2015) 1.",
      "startOffset" : 30,
      "endOffset" : 524
    }, {
      "referenceID" : 42,
      "context" : "MNIST MNIST is an image classification benchmark dataset (LeCun et al., 1998).",
      "startOffset" : 57,
      "endOffset" : 77
    }, {
      "referenceID" : 21,
      "context" : "Previous approaches include pruning near zero weights (Gong et al., 2014; Han et al., 2015a) using matrix factorization techniques (Zhang et al.",
      "startOffset" : 54,
      "endOffset" : 92
    }, {
      "referenceID" : 27,
      "context" : ", 2015), quantizing the weights (Gupta et al., 2015), using shared weights (Chen et al.",
      "startOffset" : 32,
      "endOffset" : 52
    }, {
      "referenceID" : 7,
      "context" : ", 2015), using shared weights (Chen et al., 2015) and applying Huffman codes (Han et al.",
      "startOffset" : 30,
      "endOffset" : 49
    }, {
      "referenceID" : 68,
      "context" : "Those results are presently state-of-the-art, surpassing those obtained by the DoReFa net (Zhou et al., 2016).",
      "startOffset" : 90,
      "endOffset" : 109
    }, {
      "referenceID" : 50,
      "context" : "Following Miyashita et al. (2016), we also tried quantizing the gradients and discovered that only logarithmic quantization works.",
      "startOffset" : 10,
      "endOffset" : 34
    }, {
      "referenceID" : 54,
      "context" : "1% Xnor-Nets4 (Rastegari et al., 2016) 44.",
      "startOffset" : 14,
      "endOffset" : 38
    }, {
      "referenceID" : 68,
      "context" : "67% DoReFaNet 2-bit activation4 (Zhou et al., 2016) 50.",
      "startOffset" : 32,
      "endOffset" : 51
    }, {
      "referenceID" : 28,
      "context" : "67% (Gysel et al., 2016) - 2-bit 0.",
      "startOffset" : 4,
      "endOffset" : 24
    }, {
      "referenceID" : 47,
      "context" : "The Penn Treebank Corpus (Marcus et al., 1993) contains 10K unique words.",
      "startOffset" : 25,
      "endOffset" : 46
    }, {
      "referenceID" : 49,
      "context" : "We followed the same setting as in (Mikolov and Zweig, 2012) which resulted in 18.",
      "startOffset" : 35,
      "endOffset" : 60
    }, {
      "referenceID" : 34,
      "context" : "the Long Short Term Memory networks (LSTMs) introduced by Hochreiter and Schmidhuber (1997) are being the most popular model.",
      "startOffset" : 58,
      "endOffset" : 92
    }, {
      "referenceID" : 34,
      "context" : "the Long Short Term Memory networks (LSTMs) introduced by Hochreiter and Schmidhuber (1997) are being the most popular model. LSTMs are a special kind of RNN, capable of learning long-term dependencies using unique gating mechanisms. Recently, Ott et al. (2016) tried to quantize the RNNs weight matrices using similar techniques as described in Section 2.",
      "startOffset" : 58,
      "endOffset" : 262
    }, {
      "referenceID" : 52,
      "context" : "Similar to (Ott et al., 2016), our preliminary results indicate that binarization of weight matrices lead to large accuracy degradation.",
      "startOffset" : 11,
      "endOffset" : 29
    }, {
      "referenceID" : 35,
      "context" : "Table 5: Energy consumption of multiply- accumulations; see Horowitz (2014) Operation MUL ADD 8-bit Integer 0.",
      "startOffset" : 60,
      "endOffset" : 76
    }, {
      "referenceID" : 35,
      "context" : "Table 6: Energy consumption of memory accesses; see Horowitz (2014) Memory size 64-bit Cache 8K 10pJ 32K 20pJ 1M 100pJ DRAM 1.",
      "startOffset" : 52,
      "endOffset" : 68
    }, {
      "referenceID" : 35,
      "context" : "Over the last decade, power has been the main constraint on performance (Horowitz, 2014).",
      "startOffset" : 72,
      "endOffset" : 88
    }, {
      "referenceID" : 35,
      "context" : "Over the last decade, power has been the main constraint on performance (Horowitz, 2014). This is why considerable research efforts have been devoted to reducing the energy consumption of neural networks. Horowitz (2014) provides rough numbers for the energy consumed by the computation (the given numbers are for 45nm technology), as summarized in Tables 5 and 6.",
      "startOffset" : 73,
      "endOffset" : 221
    }, {
      "referenceID" : 24,
      "context" : "For instance, a 32-bit floating point multiplier costs about 200 Xilinx FPGA slices (Govindu et al., 2004; Beauchamp et al., 2006), whereas a 1-bit XNOR gate only costs a single slice.",
      "startOffset" : 84,
      "endOffset" : 130
    }, {
      "referenceID" : 3,
      "context" : "For instance, a 32-bit floating point multiplier costs about 200 Xilinx FPGA slices (Govindu et al., 2004; Beauchamp et al., 2006), whereas a 1-bit XNOR gate only costs a single slice.",
      "startOffset" : 84,
      "endOffset" : 130
    }, {
      "referenceID" : 12,
      "context" : "Until recently, the use of extremely low-precision networks (binary in the extreme case) was believed to substantially degrade the network performance (Courbariaux et al., 2014).",
      "startOffset" : 151,
      "endOffset" : 177
    }, {
      "referenceID" : 11,
      "context" : "Until recently, the use of extremely low-precision networks (binary in the extreme case) was believed to substantially degrade the network performance (Courbariaux et al., 2014). Soudry et al. (2014) and Cheng et al.",
      "startOffset" : 152,
      "endOffset" : 200
    }, {
      "referenceID" : 9,
      "context" : "(2014) and Cheng et al. (2015) proved the contrary by showing that good performance could be achieved even if all neurons and weights are binarized to ±1 .",
      "startOffset" : 11,
      "endOffset" : 31
    }, {
      "referenceID" : 9,
      "context" : "(2014) and Cheng et al. (2015) proved the contrary by showing that good performance could be achieved even if all neurons and weights are binarized to ±1 . This was done using Expectation BackPropagation (EBP), a variational Bayesian approach, which infers networks with binary weights and neurons by updating the posterior distributions over the weights. These distributions are updated by differentiating their parameters (e.g., mean values) via the back propagation (BP) algorithm. Esser et al. (2015) implemented a fully binary network at run time using a very similar approach to EBP, showing significant",
      "startOffset" : 11,
      "endOffset" : 505
    }, {
      "referenceID" : 2,
      "context" : "Other research (Baldassi et al., 2015) showed that full binary training and testing is possible in an array of committee machines with randomized input, where only one weight layer is being adjusted.",
      "startOffset" : 15,
      "endOffset" : 38
    }, {
      "referenceID" : 11,
      "context" : "The probabilistic idea behind EBP was extended in the BinaryConnect algorithm of Courbariaux et al. (2015a). In BinaryConnect, the real-valued version of the weights is saved and used as a key reference for the binarization process.",
      "startOffset" : 81,
      "endOffset" : 108
    }, {
      "referenceID" : 11,
      "context" : "The probabilistic idea behind EBP was extended in the BinaryConnect algorithm of Courbariaux et al. (2015a). In BinaryConnect, the real-valued version of the weights is saved and used as a key reference for the binarization process. The binarization noise is independent between different weights, either by construction (by using stochastic quantization) or by assumption (a common simplification; see Spang and Schultheiss, 1962). The noise would have little effect on the next neuron’s input because the input is a summation over many weighted neurons. Thus, the real-valued version could be updated using the back propagated error by simply ignoring the binarization noise in the update. With this method, Courbariaux et al. (2015a) were the first to binarize weights in CNNs and achieved near state-of-the-art performance on several datasets.",
      "startOffset" : 81,
      "endOffset" : 737
    }, {
      "referenceID" : 11,
      "context" : "The probabilistic idea behind EBP was extended in the BinaryConnect algorithm of Courbariaux et al. (2015a). In BinaryConnect, the real-valued version of the weights is saved and used as a key reference for the binarization process. The binarization noise is independent between different weights, either by construction (by using stochastic quantization) or by assumption (a common simplification; see Spang and Schultheiss, 1962). The noise would have little effect on the next neuron’s input because the input is a summation over many weighted neurons. Thus, the real-valued version could be updated using the back propagated error by simply ignoring the binarization noise in the update. With this method, Courbariaux et al. (2015a) were the first to binarize weights in CNNs and achieved near state-of-the-art performance on several datasets. They also argued that noisy weights provide a form of regularization, which could help to improve generalization, as previously shown by Wan et al. (2013). This method binarized weights while still maintaining full precision neurons.",
      "startOffset" : 81,
      "endOffset" : 1003
    }, {
      "referenceID" : 11,
      "context" : "The probabilistic idea behind EBP was extended in the BinaryConnect algorithm of Courbariaux et al. (2015a). In BinaryConnect, the real-valued version of the weights is saved and used as a key reference for the binarization process. The binarization noise is independent between different weights, either by construction (by using stochastic quantization) or by assumption (a common simplification; see Spang and Schultheiss, 1962). The noise would have little effect on the next neuron’s input because the input is a summation over many weighted neurons. Thus, the real-valued version could be updated using the back propagated error by simply ignoring the binarization noise in the update. With this method, Courbariaux et al. (2015a) were the first to binarize weights in CNNs and achieved near state-of-the-art performance on several datasets. They also argued that noisy weights provide a form of regularization, which could help to improve generalization, as previously shown by Wan et al. (2013). This method binarized weights while still maintaining full precision neurons. Lin et al. (2015a) carried over the work of Courbariaux et al.",
      "startOffset" : 81,
      "endOffset" : 1101
    }, {
      "referenceID" : 11,
      "context" : "The probabilistic idea behind EBP was extended in the BinaryConnect algorithm of Courbariaux et al. (2015a). In BinaryConnect, the real-valued version of the weights is saved and used as a key reference for the binarization process. The binarization noise is independent between different weights, either by construction (by using stochastic quantization) or by assumption (a common simplification; see Spang and Schultheiss, 1962). The noise would have little effect on the next neuron’s input because the input is a summation over many weighted neurons. Thus, the real-valued version could be updated using the back propagated error by simply ignoring the binarization noise in the update. With this method, Courbariaux et al. (2015a) were the first to binarize weights in CNNs and achieved near state-of-the-art performance on several datasets. They also argued that noisy weights provide a form of regularization, which could help to improve generalization, as previously shown by Wan et al. (2013). This method binarized weights while still maintaining full precision neurons. Lin et al. (2015a) carried over the work of Courbariaux et al. (2015a) to the backpropagation process by quantizing the representations at each layer of the network, to convert some of the remaining multiplications into binary shifts by restricting the neurons’ values to be power-of-two integers.",
      "startOffset" : 81,
      "endOffset" : 1153
    }, {
      "referenceID" : 11,
      "context" : "The probabilistic idea behind EBP was extended in the BinaryConnect algorithm of Courbariaux et al. (2015a). In BinaryConnect, the real-valued version of the weights is saved and used as a key reference for the binarization process. The binarization noise is independent between different weights, either by construction (by using stochastic quantization) or by assumption (a common simplification; see Spang and Schultheiss, 1962). The noise would have little effect on the next neuron’s input because the input is a summation over many weighted neurons. Thus, the real-valued version could be updated using the back propagated error by simply ignoring the binarization noise in the update. With this method, Courbariaux et al. (2015a) were the first to binarize weights in CNNs and achieved near state-of-the-art performance on several datasets. They also argued that noisy weights provide a form of regularization, which could help to improve generalization, as previously shown by Wan et al. (2013). This method binarized weights while still maintaining full precision neurons. Lin et al. (2015a) carried over the work of Courbariaux et al. (2015a) to the backpropagation process by quantizing the representations at each layer of the network, to convert some of the remaining multiplications into binary shifts by restricting the neurons’ values to be power-of-two integers. Lin et al. (2015a)’s work and ours seem to share similar characteristics .",
      "startOffset" : 81,
      "endOffset" : 1399
    }, {
      "referenceID" : 11,
      "context" : "The probabilistic idea behind EBP was extended in the BinaryConnect algorithm of Courbariaux et al. (2015a). In BinaryConnect, the real-valued version of the weights is saved and used as a key reference for the binarization process. The binarization noise is independent between different weights, either by construction (by using stochastic quantization) or by assumption (a common simplification; see Spang and Schultheiss, 1962). The noise would have little effect on the next neuron’s input because the input is a summation over many weighted neurons. Thus, the real-valued version could be updated using the back propagated error by simply ignoring the binarization noise in the update. With this method, Courbariaux et al. (2015a) were the first to binarize weights in CNNs and achieved near state-of-the-art performance on several datasets. They also argued that noisy weights provide a form of regularization, which could help to improve generalization, as previously shown by Wan et al. (2013). This method binarized weights while still maintaining full precision neurons. Lin et al. (2015a) carried over the work of Courbariaux et al. (2015a) to the backpropagation process by quantizing the representations at each layer of the network, to convert some of the remaining multiplications into binary shifts by restricting the neurons’ values to be power-of-two integers. Lin et al. (2015a)’s work and ours seem to share similar characteristics .However, their approach continues to use full precision weights during the test phase. Moreover, Lin et al. (2015a) quantize the neurons only during the back propagation process, and not during forward propagation.",
      "startOffset" : 81,
      "endOffset" : 1570
    }, {
      "referenceID" : 2,
      "context" : "Other research (Baldassi et al., 2015) showed that full binary training and testing is possible in an array of committee machines with randomized input, where only one weight layer is being adjusted. Gong et al. (2014) aimed to compress a fully trained high precision network by using quantization or matrix factorization methods.",
      "startOffset" : 16,
      "endOffset" : 219
    }, {
      "referenceID" : 2,
      "context" : "Other research (Baldassi et al., 2015) showed that full binary training and testing is possible in an array of committee machines with randomized input, where only one weight layer is being adjusted. Gong et al. (2014) aimed to compress a fully trained high precision network by using quantization or matrix factorization methods. These methods required training the network with full precision weights and neurons, thus requiring numerous MAC operations (which the proposed QNN algorithm avoids). Hwang and Sung (2014) focused on a fixed-point neural network design and achieved performance almost identical to that of the floating-point architecture.",
      "startOffset" : 16,
      "endOffset" : 520
    }, {
      "referenceID" : 2,
      "context" : "Other research (Baldassi et al., 2015) showed that full binary training and testing is possible in an array of committee machines with randomized input, where only one weight layer is being adjusted. Gong et al. (2014) aimed to compress a fully trained high precision network by using quantization or matrix factorization methods. These methods required training the network with full precision weights and neurons, thus requiring numerous MAC operations (which the proposed QNN algorithm avoids). Hwang and Sung (2014) focused on a fixed-point neural network design and achieved performance almost identical to that of the floating-point architecture. Kim and Smaragdis (2016) retrained neural networks with binary weights and activations.",
      "startOffset" : 16,
      "endOffset" : 678
    }, {
      "referenceID" : 2,
      "context" : "Other research (Baldassi et al., 2015) showed that full binary training and testing is possible in an array of committee machines with randomized input, where only one weight layer is being adjusted. Gong et al. (2014) aimed to compress a fully trained high precision network by using quantization or matrix factorization methods. These methods required training the network with full precision weights and neurons, thus requiring numerous MAC operations (which the proposed QNN algorithm avoids). Hwang and Sung (2014) focused on a fixed-point neural network design and achieved performance almost identical to that of the floating-point architecture. Kim and Smaragdis (2016) retrained neural networks with binary weights and activations. As far as we know, before the first revision of this paper was published on arXive, no work succeeded in binarizing weights and neurons, at the inference phase and the entire training phase of a deep network. This was achieved in the present work. We relied on the idea that binarization can be done stochastically, or be approximated as random noise. This was previously done for the weights by Courbariaux et al. (2015a), but our BNNs extend this to the activations.",
      "startOffset" : 16,
      "endOffset" : 1164
    }, {
      "referenceID" : 2,
      "context" : "Other research (Baldassi et al., 2015) showed that full binary training and testing is possible in an array of committee machines with randomized input, where only one weight layer is being adjusted. Gong et al. (2014) aimed to compress a fully trained high precision network by using quantization or matrix factorization methods. These methods required training the network with full precision weights and neurons, thus requiring numerous MAC operations (which the proposed QNN algorithm avoids). Hwang and Sung (2014) focused on a fixed-point neural network design and achieved performance almost identical to that of the floating-point architecture. Kim and Smaragdis (2016) retrained neural networks with binary weights and activations. As far as we know, before the first revision of this paper was published on arXive, no work succeeded in binarizing weights and neurons, at the inference phase and the entire training phase of a deep network. This was achieved in the present work. We relied on the idea that binarization can be done stochastically, or be approximated as random noise. This was previously done for the weights by Courbariaux et al. (2015a), but our BNNs extend this to the activations. Note that the binary activations are especially important for ConvNets, where there are typically many more neurons than free weights. This allows highly efficient operation of the binarized DNN at run time, and at the forward-propagation phase during training. Moreover, our training method has almost no multiplications, and therefore might be implemented efficiently in dedicated hardware. However, we have to save the value of the full precision weights. This is a remaining computational bottleneck during training, since it is an energy-consuming operation. Shortly after the first version of this paper was posted on arXiv, several papers tried to improve and extend it. Rastegari et al. (2016) made a small modification to our algo-",
      "startOffset" : 16,
      "endOffset" : 1912
    }, {
      "referenceID" : 54,
      "context" : "Note that their method, named Xnor-Net, requires additional multiplication by a different scaling factor for each patch in each sample (Rastegari et al., 2016) Section 3.",
      "startOffset" : 135,
      "endOffset" : 159
    }, {
      "referenceID" : 54,
      "context" : "Moreover, (Rastegari et al., 2016) didn’t quantize first and last layers, therefore XNOR-Net are only partially binarized NNs.",
      "startOffset" : 10,
      "endOffset" : 34
    }, {
      "referenceID" : 48,
      "context" : "Miyashita et al. (2016) suggested a more relaxed quantization (more than 1-bit) for both the weights and activation.",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 48,
      "context" : "Miyashita et al. (2016) suggested a more relaxed quantization (more than 1-bit) for both the weights and activation. Their idea was to quantize both and use shift operations as in our Eq. (4). They proposed to quantize the parameters in their non-uniform, base-2 logarithmic representation. This idea was inspired by the fact that the weights and activations in a trained network naturally have non-uniform distributions. They moreover showed that they can quantize the gradients as well to 6-bit without significant losses in performance (on the Cifar-10 dataset). Zhou et al. (2016) applied similar ideas to the ImageNet dataset and showed that by using 1-bit weights, 2-bit activations and 6-bit gradients they can achieve 46.",
      "startOffset" : 0,
      "endOffset" : 585
    }, {
      "referenceID" : 47,
      "context" : "Merolla et al. (2016) showed that DNN can be robust to more than just weight binarization.",
      "startOffset" : 0,
      "endOffset" : 22
    }, {
      "referenceID" : 0,
      "context" : "Andri et al. (2016) even created a hardware implementation to speed up BNNs.",
      "startOffset" : 0,
      "endOffset" : 20
    }, {
      "referenceID" : 11,
      "context" : "We thank the developers of Torch, (Collobert et al., 2011) a Lua based environment, and Theano (Bergstra et al.",
      "startOffset" : 34,
      "endOffset" : 58
    }, {
      "referenceID" : 5,
      "context" : ", 2011) a Lua based environment, and Theano (Bergstra et al., 2010; Bastien et al., 2012), a Python library that allowed us to easily develop fast and optimized code for GPU.",
      "startOffset" : 44,
      "endOffset" : 89
    }, {
      "referenceID" : 16,
      "context" : ", 2013a) and Lasagne (Dieleman et al., 2015), two deep learning libraries built on the top of Theano.",
      "startOffset" : 21,
      "endOffset" : 44
    }, {
      "referenceID" : 42,
      "context" : "MNIST is an image classification benchmark dataset (LeCun et al., 1998).",
      "startOffset" : 51,
      "endOffset" : 71
    }, {
      "referenceID" : 63,
      "context" : "The Multi-LayerPerceptron (MLP) we train on MNIST consists of 3 hidden layers of 4096 binary units and a L2-SVM output layer; L2-SVM has been shown to perform better than Softmax on several classification benchmarks (Tang, 2013; Lee et al., 2014).",
      "startOffset" : 216,
      "endOffset" : 246
    }, {
      "referenceID" : 60,
      "context" : "We regularize the model with Dropout (Srivastava et al., 2014).",
      "startOffset" : 37,
      "endOffset" : 62
    }, {
      "referenceID" : 20,
      "context" : "We use an exponentially decaying global learning rate, as per Algorithm 1, and also scale the learning rates of the weights with their initialization coefficients from (Glorot and Bengio, 2010), as suggested by Courbariaux et al.",
      "startOffset" : 168,
      "endOffset" : 193
    }, {
      "referenceID" : 4,
      "context" : "We use an exponentially decaying global learning rate, as per Algorithm 1, and also scale the learning rates of the weights with their initialization coefficients from (Glorot and Bengio, 2010), as suggested by Courbariaux et al. (2015a). We use Batch Normalization with a minibatch of size 100 to speed up the training.",
      "startOffset" : 180,
      "endOffset" : 238
    }, {
      "referenceID" : 57,
      "context" : "(2015a) architecture is itself mainly inspired by VGG (Simonyan and Zisserman, 2015).",
      "startOffset" : 54,
      "endOffset" : 84
    }, {
      "referenceID" : 20,
      "context" : "We scale the learning rates of the weights with their initialization coefficients from (Glorot and Bengio, 2010).",
      "startOffset" : 87,
      "endOffset" : 112
    }, {
      "referenceID" : 11,
      "context" : "The architecture of our ConvNet is identical to that used by Courbariaux et al. (2015b) except for the binarization of the activations.",
      "startOffset" : 61,
      "endOffset" : 88
    }, {
      "referenceID" : 11,
      "context" : "The architecture of our ConvNet is identical to that used by Courbariaux et al. (2015b) except for the binarization of the activations. The Courbariaux et al. (2015a) architecture is itself mainly inspired by VGG (Simonyan and Zisserman, 2015).",
      "startOffset" : 61,
      "endOffset" : 167
    }, {
      "referenceID" : 57,
      "context" : "We only use ”same” convolutions as in VGG (Simonyan and Zisserman, 2015).",
      "startOffset" : 42,
      "endOffset" : 72
    } ],
    "year" : 2016,
    "abstractText" : "We introduce a method to train Quantized Neural Networks (QNNs) — neural networks with extremely low precision (e.g., 1-bit) weights and activations, at run-time. At traintime the quantized weights and activations are used for computing the parameter gradients. During the forward pass, QNNs drastically reduce memory size and accesses, and replace most arithmetic operations with bit-wise operations. As a result, power consumption is expected to be drastically reduced. We trained QNNs over the MNIST, CIFAR-10, SVHN and ImageNet datasets. The resulting QNNs achieve prediction accuracy comparable to their 32-bit counterparts. For example, our quantized version of AlexNet with 1-bit weights and 2-bit activations achieves 51% top-1 accuracy. Moreover, we quantize the parameter gradients to 6-bits as well which enables gradients computation using only bit-wise operation. Quantized recurrent neural networks were tested over the Penn Treebank dataset, and achieved comparable accuracy as their 32-bit counterparts using only 4-bits. Last but not least, we programmed a binary matrix multiplication GPU kernel with which it is possible to run our MNIST QNN 7 times faster than with an unoptimized GPU kernel, without suffering any loss in classification accuracy. The QNN code is available online. 1 ar X iv :1 60 9. 07 06 1v 1 [ cs .N E ] 2 2 Se p 20 16 Hubara, Courbariaux, Soudry, El-Yaniv and Bengio",
    "creator" : "LaTeX with hyperref package"
  }
}