{
  "name" : "1706.00327.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "One button machine for automating feature engineering in relational databases",
    "authors" : [ "Hoang Thanh Lam", "Johann-Michael Thiebaut", "Mathieu Sinn", "Bei Chen", "Tiep Mai", "Oznur Alkan" ],
    "emails" : [ "t.l.hoang@ie.ibm.com,", "johann-michael.thiebaut@epfl.ch,", "mathsinn@ie.ibm.com,", "beichen2@ie.ibm.com,", "maikhctiep@gmail.com", "oalcan2@ie.ibm.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "I. INTRODUCTION\nOver the last decade, data analytics has become an important trend in many industries including e-commerce, healthcare, manufacture and more. The reasons behind the increasing interest are the availability of data, variety of open-source machine learning tools and powerful computing resources. Nevertheless, machine learning tools for analyzing data are still difficult to be utilized by non-experts, since a typical data analytics project contains many tasks that have not been fully automated yet.\nIn fact, Figure 1 shows five basic steps in a predictive data analytics project. Although there exists many automation tools for the last step, no tools exist to fully automate the remaining steps. Among these steps, feature engineering is one of the most important tasks because it prepares inputs to machine learning models, thus deciding how machine learning models will perform.\nIn general, automation of feature engineering is hard because it requires highly skilled data scientists having strong data mining and statistics backgrounds in addition to domain knowledge to extract useful patterns from data. The given task is known as a bottle-neck in any data analytics project. In fact, in recent public data science competitions, top data scientists reported that most time they spent on such competitions was\nfor feature engineering, i.e. on working with raw data to prepare input for machine learning models (see the Kaggle’s blog post: Learning from the best1). In an extreme case such as in the Grupo Bimbo Inventory Prediction, the winners reported that 95% of their time was for feature engineering and only 5% is for modelling (see Grupo Bimbo inventory prediction winner interview2).\nTherefore, automation of feature engineering may help reducing data scientist’s workload significantly, allowing them to try and error many ideas to improve prediction results with significant less efforts. Moreover, in many data science projects, it is very popular that companies want to quickly try some simple ideas first to check if there is any value in their datasets before investing more time, effort and money on a data analytics project. Automation helps the company to make quick decision with lower cost. Last but not least, automation solves shortage of data scientists enabling nonexperts to extract values from their data by themselves.\nIn order to build a fully automatic system for feature engineering, we need to tackle the following challenges:\n• diverse basic data types: columns in tables can have different basic data types including simple ones like numerical or categorical, or complicated ones like text, trajectories, gps location, images, sequences and timeseries • collective data types: the complexity of data types is increased when the data is the result of joining multiple tables. The joint results may correspond to a set or sequence of basic types. • temporal information: the data might be associated with timestamps which introduces order in the data. • complex relational graph: the relational graph might be\n1http://blog.kaggle.com/2014/08/01/learning-from-the-best/ 2http://blog.kaggle.com/2016/09/27/grupo-bimbo-inventory-demand-\nwinners-interviewclustifier-alex-andrey/\nar X\niv :1\n70 6.\n00 32\n7v 1\n[ cs\n.D B\n] 1\nJ un\n2 01\n7\nvery complex, the number of possible relational paths can be exponential in the number of tables in the databases which make exhaustive data exploration intractable • large transformation search space: there is infinite ways of transform joint tables into features, which transformation is useful for a given type of problem is not known in advance given no domain knowledge about the data.\nIn this work, we propose the one button machine (OneBM), a framework that supports feature engineering from relational data, aiming at tackling the aforementioned challenges. OneBM works directly with multiple raw tables in a database. It joins the tables incrementally, following different paths on the relational graph. It automatically identifies data types of the joint results, including simple data types (numerical or categorical) and complex data types (set of numbers, set of categories, sequences, time series and texts), and applies corresponding pre-defined feature engineering techniques on the given types. In doing so, new feature engineering techniques could be plugged in via an interface with OneBM’s feature extractor modules to extract desired types of features in specific domain. OneBM supports data scientists by automating the most popular feature engineering techniques on different structured and unstructured data.\nIn summary, the key contribution of this work is as follows: • we proposed an efficient method based on depth-first\nsearch to explore complex relational graph for automating feature engineering from relational databases • we proposed methods to synthesize raw data and automatically extract advanced features from structured and unstructured data. The state-of-the-art system only supports numerical data and it extracts only basic features based on simple aggregation statistics. • OneBM, implemented in Apache Spark, is the first framework being able to automate feature engineering on large datasets with 100GB of raw data. • we demonstrate the significance of OneBM via Kaggle competitions in which OneBM competes with data scientists • we compared our results to the state-of-the-art system via a Kaggle competition in which our system outperformed the-state-of- the-art system in terms of prediction accuracy and ranking on leaderboards"
    }, {
      "heading" : "II. RELATED WORK",
      "text" : "Automation of data science is a broad topic which includes automation of five basic steps displayed in Figure 1. Most related work in the literature focuses on the last two steps: automation of model selection, hyper-parameter tuning and feature engineering. In the following subsections, related work regarding automation of these last two steps is discussed."
    }, {
      "heading" : "A. Automatic model selection and tuning",
      "text" : "Auto-Weka [8], [11] and Auto-SkLearn [3] are among the first works trying to find the best combination of data preprocessing, hyper-parameter tuning and model selection. Both works are based on Bayesian optimization [2] to avoid\nexhaustive grid-search parameter enumeration. These works are built on top of existing algorithms and data preprocessing techniques in Weka3 and Scikit-Learn4, thus they are very handy for practical use.\nCognitive Automation of Data Science (CADS) [1], [6] is another system built on top of Weka, SPSS and R to automate model selection and hyper-parameter tuning process. CADS was made of three basic components: a repository of analytics algorithm with meta data, a learning control strategy that determines model and configuration for different analytics tasks and an interactive user interface. CADS is one of the first solutions, that was deployed in industry.\nBesides the aforementioned works, Automatic Ensemble [12] is the most recent work which uses stacking and metadata to assist model selection and tuning. TPOT [10] is another system that uses genetic programming to find the best model configuration and preprocessing work-flow. Automatic Statistician [9] is similar to the works just described but focuses more on time-series data and interpretation of the models in natural language.\nIn summary, automation of hyper-parameter tuning and model selection is a very attractive research topic with very rich literature. The key difference between our work and these works is that, while the state-of-the-art focuses on optimization of models given a ready set of features stored in a single table, our work focuses on preparing features as an input to these systems from relational databases with multiple tables. Therefore, these works are orthogonal to each other. In principle, we can use any system in this category to fine-tune the models with the input provided by OneBM."
    }, {
      "heading" : "B. Automatic feature engineering",
      "text" : "Different from automation of model selection and tuning where the literature is very rich, only a few works have been proposed to automate feature engineering. The main reason is that feature engineering is both domain and data specific. In fact, it requires a lot of data exploration with deep domain knowledge to search for relevant patterns in the data. However, recent work shows that, for a specific type of problem and data such as provided in relational databases, automation of feature engineering is achievable [5].\nData Science Machine (DSM) [5] is the first system that automates feature engineering from a database of multiple tables. This feature engineering approach is based on an assumption that, for a given relational database, data scientists usually search for features via: 1. generating SQL queries to collect data for each example in the training set and 2. transforming the data into features. DSM automates the given two steps via creating an entity graph and performing automatic SQL query generation to join the tables along different paths of the entity graph. It converts the collected results into features using a predefined set of simple aggregation functions.\nA disadvantage of the DSM framework is that it does not support feature learning for unstructured data such as sets,\n3http://www.cs.waikato.ac.nz/ml/weka/ 4scikit-learn.org\nsequences, series, text and so on. Features extracted by DSM are simple basic statistics which were aggregated for every training example independently from the target variable and from other examples. In many cases, data scientists need a framework where they can perform feature learning from the entire collected data and the target variable. Moreover, for each type of unstructured data, the features are beyond simple statistics. In most cases, they concern important structure and patterns in the data. Searching for these patterns from structured/unstructured data is the key role of data scientists.\nTherefore, in this work we extend DSM to OneBM, a framework that allows data scientists to perform feature learning on different kinds of structured/unstructured data. OneBM supports basic feature learning algorithms which data scientists usually consider to examine first before starting deeper analysis when they see a specific type of data. Extensions to more specific types of features are possible in our framework via an interface that allows the user to plug-in external feature extractor.\nCognito [7] is another system that automates feature engineering but from a single database table. In each step, it recursively applies a set of predefined mathematical transformations on the table’s columns to obtain new features from the original table. In doing so, the number of features is exponential in the number of steps. Therefore, a feature selection strategy was proposed to remove redundant features. Cognito improved prediction accuracy on UCI datasets. Since Cognito does not support relational databases with multiple tables, in order to use Cognito, data scientists need to get as input one table produced from raw data of multiple tables. Cognito is orthogonal to our approach and the DSM system, it can be used to extend features engineered by OneBM or DSM.\nSince Cognito is orthogonal to both DSM and OneBM, we didn’t compare our work to Cognito. Instead we compared OneBM to DSM. Although DSM is not an open-source\nproject, the authors of DSM reported its results on three public competitions including KDD Cup 2014, KDD Cup 2015 and IJCAI Competition 2015. Among these competitions, only for KDD Cup 2014 competition, where we can still submit prediction to get comparison results, the other competitions do not accept prediction submissions any more. Therefore, we compared OneBM to DSM in the KDD Cup 2014 competition."
    }, {
      "heading" : "C. Statistical relational learning",
      "text" : "Our work has share common points with the fields of Inductive Logic Programming and Statistical Relational Learning (StarAI) [4]. StarAI also focuses on finding patterns over multiple tables or informative joint features. However, our an additional aspect of this work is the more extensive look towards data transformations."
    }, {
      "heading" : "III. METHODOLOGY",
      "text" : "OneBM takes a database of tables with one main table. The main table must have a target column, several key columns and optional attribute columns. Each entry in the main table corresponds to an entity that we use to train a machine learning model for predicting its target value. Tables in the database are linked via foreign keys.\nExample 1: Figure 2 shows a sample toy database with 4 tables, this simple database will serve as a running example throughout the paper:\n• main: contains information about arrival times of trains. The target column is the arrival time. Each entry in the main table is uniquely identified by the MessageID column corresponding to a message sent by a train upon arrival at a station. The main table has two foreign keys: StationID and TrainID. • delay: contains train delay information. It is similar to the main table but the arrival time is converted into delay in seconds. • info: detail information about train, e.g. train class.\n• event: a log of events occurring at the station where the train is scheduled to arrive.\nAn entity graph is a relational graph where nodes are tables and edges are links between tables. The entity graph of the sample database is provided in Figure 2.\nOneBM accomplishes feature engineering from a relational database in three main steps: data collection, data transformation and feature selection. The following sub-sections discuss each task in details."
    }, {
      "heading" : "A. Data collection",
      "text" : "Starting from the main table, we can follow any joining path to collect data for every entity in the main table. The formal definition of a joining path is given as follows:\nDefinition 1 (Joining path): A joining path is defined as a sequence p = T0 c1−→ T1 c2−→ T2 · · ·\nck−→ Tk 7→ c, where T0 corresponds to the main table, Ti are the tables in the database, ci are key columns connecting tables Ti−1 and Ti and c is a column in the last table Tk in the path.\nExample 2: For example, following the joining path p = main\nTrainID−−−−−−→ delay 7→ Delay, we can obtain delay history which corresponds to a series of delays recorded in the delay table. In particular, for the train IRE01, upon arrival at the Dublin station on 2017-01-01 10:02:00, its historical delay series is: {240, 240, 180, 60, 60} seconds.\nAn edge connecting two tables T1 c−→ T2 on a joining path is classified into three types: • one-to-many: when c is a primary key of T1 but not a\nprimary key of T2 • one-to-one: when c is a primary key of both tables • many-to-one: when c is a primary key of T2 but not T1 • many-to-many: when c is neither a primary key of T1 nor\nT2 Based on the property of edges on paths, we classify them into two classes: • one-to-one: when there is no one-to-many or many-to-\nmany edge • multiple: when there is at least one-to-many or many-to-\nmany edge As we will see later in subsection III-A3, different joining path types result in different types of collected data and therefore need a specific type of data transformation. Data collection is further divided into three major steps which will be discussed in detailed in the following subsections..\nExample 3: In Figure 2, the path p = main TrainID−−−−−−→ info is a one-to-one path, while p = main TrainID−−−−−−→ delay is a multiple path.\n1) Entity graph traversal: OneBM collects data by traversing the entity graph following different paths in the graph. This is equivalent to exploring different relationships between tables. Since, in general, the number of possible paths is exponential in the depth of the graph, OneBM limits the traversal to a maximum depth of MaxDepth that is defined a priori by the user, and it explores only the simple paths for efficiency considerations.\nIRE01\nSince arbitrary graph traversal may introduce redundant relations, OneBM only considers two different traversal modes: forward-only and full. In the forward-only traversal, there is no backward traversal from a node with depth d1 to a node with depth d2, where d1 ≥ d2. Node depth is defined by a breadth-first graph traversal starting from the main table. In a full traversal mode, backward traversals are allowed. As we will see in the experiments, in most cases forward-only traversal covers most of the interesting relations in a database. The full traversal mode, on the other hand, not only introduces redundant relations but also increases the computation costs.\nExample 4: With MaxDepth = 2, with breadth-first graph traversal, the depth of the main, delay, information and event tables are 0, 1, 1 and 1, respectively. Therefore, the path main\nTrainID−−−−−−→ delay StationID−−−−−−−→ event is not explored by the forward-only traversal. However, it is explored by full traversal mode.\n2) Data GroupBy: For a given joining path p = T0 c1−→ T1 · · · ck−→ Tk 7→ c and an entity e, the collected data for e can be represented as a tree shown in Figure 3. The root of the tree corresponds to the entity e, the leaves of the tree correspond to the values of the collected column c in the table Tk collected via the joining path p for the entity e. Every intermediate node at depth i corresponds to a row in table Ti generated via the joining path T0 c1−→ T1 c2−→ T2 · · ·\nci−→ Ti. We call the given tree a relational tree and denote it as T ep , which refers to the tree represented by the joining path p for the entity e.\nExample 5: The tree in Figure 3 corresponds to the entity identified by TrainID = IRE01 and StationID = Dublin and messageID = 1. The tree is generated via the joining path main TrainID−−−−−−→ delay StationID−−−−−−−→ event 7→ Event. At depth 1, there are 6 nodes, each of which corresponds to a row in the delay table with TrainID = IRE01. At depth 2, there are 5 nodes, each corresponds to a row in the event table that is collected for the given entity via the joining path: main\nTrainID−−−−−−→ delay StationID−−−−−−−→ event. The leaves of the tree correspond to the value of Event column in the event table of the joined results.\nFrom the tree representation of the collected data, OneBM needs to transform the tree into data types that it supports for feature engineering. This is done by a GroupBy operation that groups the leaves according to the nodes at a given depth.\nExample 6: For the tree in Figure 3, the GroupBy at depth = 1 results in the set of multi-sets of the values of the leaves: GroupBy(T ep , 1) = {{roadwork2, strike}, {roadwork, strike}, {roadwork2, strike} , {roadwork, strike}}. On the other hand, GroupBy operation at depth 0 results in the multi-set: GroupBy(T ep , 0) = {roadwork6, strike4}. In this example, we use xn to denote n instances of x.\nThe GroupBy operation at different levels of the trees reveals different information about the events affecting the train. For example, in Figure 3, each node at depth = 1 corresponds to a reported message of the train TrainID = IRE01 in the historical log. Therefore, GroupBy(T ep , 1) conveys information about the events that affect the train per reported message. From GroupBy(T ep , 1), one can extract simple features like the average number of roadworks per reported message. On the other hand, GroupBy(T ep , 0) aggregates all the runs from which we can extract features like the total number of roadworks.\n3) Data type identification: OneBM automatically identifies types of collected data and classifies them into one of the following basic groups depending on the joining path and the property of the collected columns. In particular, if the joining path is a one-to-one path, then the collected data is:\n• a numerical value if the collected column is numerical • a category if the collected column is categorical • a text if the collected column is a text • a timestamp if the collected column is a timestamp On the other hand, if the joining path is a multi-path, the following collection types are supported: • a multi-set of numbers if the column is numerical • a set of texts if the collected column is text • a multi-set of items if the collected column is categorical • a time-series if the collected column is numerical and\nthere is at least one timestamp column in any table along the joining path • a sequence of categorical values if the collected column is categorical and there is at least one timestamp column in any table along the joining path\nIn principle, the given lists can be easily extended to more advanced data types, such as a image or image sets within OneBM.\n4) Dealing with temporal data: When data is associated with timestamps, OneBM only collects data that was generated before the prediction cut-off time to avoid mining leakage. In order to achieve this, OneBM has to be informed explicitly which column within the main table is considered as cutoff timestamp via naming convention in the data header. For each entity, it compares the cut-off timestamp and if available data generation timestamp. It only keeps the ones that were generated before the cut-off time."
    }, {
      "heading" : "B. Data transformation",
      "text" : "Having data collected by GroupBy(T ep , d), features are obtained by applying a transformation function, f , on the collected data, where f refers to the function that maps GroupBy(T ep , d) to a fixed-size vector of numerical values. By default, OneBM supports the following transformation functions::\nData type transformation functions numerical as is categorical (un)normalized label distribution text see sequence features timestamp calendar features number multi-set avg, variance, max, min, sum, count set of texts see sequence features multi-set of items count, distinct count, high correlated items timeseries avg, max, min, sum, count, variance,\nrecent(k), Fast Fourier Transformation, Discrete Wavelet Transformation,\nAutocorrelation coefficients sequence count, distinct count,\nhigh correlated sub-sequences\nOneBM supports those transformations by default as they are among the most common features used by data scientists. For instance, if the collected data is an itemset or a sequence, data scientists may extract items or sub-sequences that have high correlation with the target variable. For each transformation, there is a configurable interface that allows users change their preference such as the number of high correlated subsequences or the number of auto-regressive coefficients. In addition to those default features, OneBM allows users to plugin extensions for particular types of data. E.g., a user could apply within OneBM special features for images or speech signals."
    }, {
      "heading" : "C. Feature selection",
      "text" : "Feature selection is used to remove irrelevant features extracted in the prior steps. First, duplicated features are removed. Second, if the training and test data have an implicit order defined by a column, e.g. timestamp, then drift features are detected by comparing the distribution between the value of features in the training and a validation set. If two distributions are different, the feature is identified as a drift feature which may cause over-fitting. Drift features are all removed from the feature set.\nBesides, we also employ Chi-square hypothesis testing to test whether there exists a dependency between a feature and the target variable. Features that are marginally independent from the target variable are removed. In principle, feature selection is an NP-hard problem. Automation of feature selection is out of scope of this work. Improving OneBM via careful feature selection is preserved as future work.\nAlgorithm 1 OneBM(D,MaxDepth, transformConfig) 1: Input: a database with multiple tables D, a desired\nmaximum depth MaxDepth and a transformation configuration\n2: Output: feature set F 3: F ← ∅ 4: G← entityGraph(D) 5: P ← depthF irstPathEnumeration(D,MaxDepth) 6: cacheStack ← {main} 7: for p in P do 8: cache← next(cacheStack) 9: cache, collectedData← collectData(cache, p)\n10: f ← transform(collectedData, transformConfig) 11: F = F ∪ f 12: n = next(P ) 13: Let p = T0 c1−→ T1 c2−→ T2 · · ·\nck−→ Tk 14: Let p∗ = T0 c1−→ T1 c2−→ T2 · · ·\nck−1−−−→ Tk−1 15: if n is an extension of p then 16: push(cacheStack, cache) 17: else 18: if n is not an extension of p∗ then 19: pop(cacheStack) 20: end if 21: end if 22: end for 23: F ← featureSelection(F ) 24: Return F"
    }, {
      "heading" : "IV. EFFICIENT IMPLEMENTATION",
      "text" : "In this section we discuss some optimization strategies that deal with the high computation costs of the feature engineering process. There are three main techniques for resolving the efficiency issues, which are further discussed in the following subsections respectively."
    }, {
      "heading" : "A. Depth first entity graph traversal",
      "text" : "There are two options for entity graph traversing: breadthfirst and depth-first traversal. In each traversal, we can cache the joined result to avoid re-calculating it from scratch every time we explore a deeper node in the graph. The number of cached results in the breadth-first and in the depth-first traversal is upper-bounded by the maximum breadth and depth, respectively. Due to the fact that the maximum depth is easily controlled by the users while the maximum breadth depends on entity graph’s structure, we choose the depth-first traversal. Intermediate joined tables are cached along the joining path, which reduces both the computation and memory costs. When the maximum depth is reached, cached tables are subsequently freed while different branches of the graph are being explored.\nExample 7: Assume that we have to explore two paths p1 = A a−→ B b−→ C 7→ c and p2 = A a−→ B b−→ D 7→ d. In a depthfirst traversal, the joined table join(A,B, a) is cached when we explore p1. That joined table is re-used when we explore p2 and is freed when all paths under B have been explored.\nAlgorithm 1 shows the pseudo-code of the solution implemented within OneBM. In line 5, all the paths are enumerated via a depth-first traversal through the entity graph G. For each path in the depth-first traversal, we subsequently generate features (lines 10-11). A cache stack (LIFO) is used to keep the intermediate joined tables, which contains only key columns to lower memory consumption. The stack is added with a new joined result if we are still extending the current path (lines 15-16). On the other hand, if the next path is not an extension of the current branch, the head of the cache stack is freed. The size of the cache stack cannot exceed MaxDepth."
    }, {
      "heading" : "B. Redundant path removal",
      "text" : "Two paths p1 and p2 are equivalent if, for any entity e, the relational trees T ep1 and T e p2 are the same. OneBM detects equivalent paths and removes redundant paths via transforming them into their canonical form and compare with travelled paths. The canonical form of a path p is the shortest path that is equivalent to p.\nExample 8: Consider two paths: p1 = A a−→ B a−→ C 7→ c and p2 = A a−→ C 7→ c. Assume that, column a is the primary key of A, B and C. We can see that p1 is equivalent to p2; therefore, p1 is redundant with respect to p2 and is not considered during feature extraction process."
    }, {
      "heading" : "C. Sub-sampling the joining results",
      "text" : "OneBM applies sub-sampling in order to reduce the memory space needed for the the joined large tables. This comes at the cost of loosing accuracy when the features are calculated on a sub-sample of the data. In order to overcome the negative effect of sub-sampling, the sampling rate is not fixed, but is dynamically controlled via a parameter call the MAX-JOINEDSIZE which is set a priori depending on the availability of system memory.\nIn order to achieve dynamic data sub-sampling, OneBM estimates the joined size before joining process and calculates the sampling ratio that leads to the desired joined size. A stratified uniform sampling is applied for every training example. When the entries in a table are associated with timestamps, OneBM doesn’t apply uniform sampling, but instead, it takes the samples that are most recent. In the experiments, this technique helped OneBM to scale up to large real-world datasets such as the Kaggle’s outbrain dataset with 119 million training examples and 100GB uncompressed data."
    }, {
      "heading" : "V. EXPERIMENTAL RESULTS",
      "text" : ""
    }, {
      "heading" : "A. Experiment settings and datasets",
      "text" : "In this section, we will discuss results on three Kaggle competitions (including one competition in which DSM reported its results). In all cases, a random forest (RF) with 100\ntrees and a XGBOOST model were used. In the experiments, XGBOOST was trained until converge, i.e. the number of training steps was set to infinite, training stops when no accuracy improvement is observed on a validation set. No hyperparameter tuning was considered, because it is not the main focus of this work. In practice, by combining OneBM with automatic hyper-parameter tuning techniques, the results could be improved even further. We apply a simple model selection as follows: in every competition, we first submitted the results of RF and XGBOOST to Kaggle. The observed results on public leaderboards were used to choose the better model. The final results were reported based on the private leaderboard scores. This process is standard in Kaggle competitions, where participants observed their score on a public leaderboard, the final rank is counted only on the private leaderboard.\nWe used an Apache Spark cluster with 12 machines to run OneBM, where every machine has 92 GBs of memory and 12 cores. Table 1 shows the datasets’ characteristics used in experiments. The results gathered using each dataset are described and discussed in the following subsections."
    }, {
      "heading" : "B. Comparison with DSM in KDD Cup 2014",
      "text" : "In KDD cup 2014, participants were asked to predict which project proposals are successful based on their data about project descriptions, school and teacher profiles and locations, donation information and requested resources of the projects. The entity graph of the data is shown on Figure 4. The maximum depth of the graph is one so we set the maximum search depth as 1. The donation table in the competition includes\ndata for training but no data for testing instances. Therefore, we ignored the donation table in the feature extraction process.\nThe results of OneBM using random forest, xgboost and the comparison to DSM are reported on Table 3. As we can see clearly that, even without tuning, OneBM outperformed DSM by improving its ranks on the private leaderboard from 145 to 80, i.e. improve the result from top 30% to top 17%. It is important to notice that DSM reported two numbers corresponding to the results before and after hyper-parameter tuning respectively. The result of DSM before tuning (top 60%) is much worse than after tuning. In the meantime, OneBM was not tuned at all, which shows that there is room for significant improvement with careful model selection and hyper parameter tuning."
    }, {
      "heading" : "C. Grupo Bimbo",
      "text" : "In the Grupo Bimbo inventory demand prediction competition, participants were asked to predict weekly sales of fresh bakery products on the shelves of over 1 million stores, along its 45,000 routes across Mexico. At the moment the paper was written, the competition had been finished. The database contains 4 different tables:\n• sale history: the main table with the target variable (weekly sale in units) of fresh bakery products. Since the evaluation is based on Root Mean Squared Logarithmic Error (RMSLE), we predict the logarithmic of demand rather than the absolute demand. • town state: geographical location of the stores • product: additional information, e.g. product names • client: information about the clients\nIt is well-known that for demand prediction, historical demand series is a good predictor. Therefore, in addition to the given 4 tables, we created a copy of the main table and named it as series with only three columns: the product sale identifier, the sale of the products and the timestamp reflecting the time products were sold. The series table was created to explicitly provide OneBM with sale demand series of every product.\nThe test data includes predictions of one and two weeks in advance, while the training dataset only includes training data for one week in advance. This artificial difficulty was added by the competition organizers, yet in practice we should prepare separate training data for each prediction horizon. Therefore, we solve the problem using two models for predicting the demand one week and two weeks in advance respectively. Besides, the competition asks for predicting the demand in week 10 and week 11 using historical data from week 3 to week 9. In order to keep the training not biased to the first few weeks when there is lacking of historical demand, we only use data of week 9 to train the model.\nFigure 4.b shows the entity graph of the created database. The maximum depth of the graph defined in the breadth-first traversal is 1, therefore we set MaxDepth = 1. The top 10 most correlated features are listed in Table 4. From this table, it can be observed that, recent demands are among the top predictors besides specific types of products discovered by itemset mining algorithms.\nFigure 5 shows the prediction error (0.48681) on the private leaderboard of OneBM compared to the participants. The solution was ranked 326th, i.e. in top 16% participants. As it is observed, the prediction error is at the plateau of the curve, which shows that the results of OneBM are very close to the best human results. This finding is encouraging because with a very little effort on data processing (creating the series table) and no effort on hand-crafting features, one could achieve the results outperforming 1642 out of 1969 teams."
    }, {
      "heading" : "D. Outbrain click prediction",
      "text" : "In this section, we demonstrate how to use OneBM to quickly explore the data, get some feedbacks and improve the prediction step by step with little efforts on feature engineering. In the Outbrain click prediction competition5, Outbrain’s users were presented a batch of ads placed randomly on a website. People were asked to predict which ads would be clicked and rank the ads in a batch according to their click likelihood. Training and test datasets contain 87 million and 32 million ads, respectively.\nBesides information about the ads, there are related meta data such as website category, ads categories, user geographical location and online activities stored in a database with 8\n5https://www.kaggle.com/c/outbrain-click-prediction\ntables as shown in Figure 4.a. Futher details about the dataset can be found on the competition website.\nIn the first experiment, raw data is input to OneBM and MaxDepth is set to 2, since the breadth-first maximum depth of the entity graph in Figure 4.a is 2. OneBM outputs 133 features extracted from all 8 tables in the data. The top 5 most relevant features ranked by a Random Forest using Mean Decrease in Impurity (MDI) are listed in Table 3. As can be seen, the geographical location of users is among the top predictors, together with ad id. Submitting the prediction to Kaggle, we received scores 0.6356 and 0.63534 on public and private leaderboard respectively. The first solution was ranked 643 in both leaderboards out of 979 teams.\nThe first solution was significantly better than the competition benchmark, which is 0.4895 but still much worse than the best human result (0.70). Our next refinement is based on a minor observation. Since the ad id plays an important role,\nwe discovered that ad id was treated as a numerical value instead of a categorical value by the default data parser. We explicitly told OneBM to treat it as a categorical value so that label distribution features could be extracted from the given column. With this minor change, our second solution, even was trained only on the main table, improved the score to 0.63627 and 0.63639 which were ranked as 633 and 634 on the public and private leaderboard, respectively.\nFinally, it is well-known that ensembles of different approaches usually lead to better results. Therefore, we created a linear ensemble of solution 1 and 2 with the same weight in order to produce a third solution. The new solution score was 0.65078 which was ranked at 227th position in both private and public leaderboards. Overall, we observe that the achieved results are based on a simple model (a random forest) and a simple observation during the data analysis process, with very limited efforts on data preprocessing and hand-crafting features. This result is interesting as we ensemble results from the first solution where features were extracted from all tables and from the second solution where features are extracted from the main table with different treatments of the input column types. This opens an opportunity to create a useful UI interface in the future that allows data scientists to explore data by simply navigating the relational graphs following different joining paths.\nIn principle, the given problem is a recommendation problem. When the competition finished, winning solutions were reported. These solutions were based on the factorization machine (FM). In the meanwhile, we treated the problem as a classification problem and used random forest instead of a FM model. Therefore, there is room for improvement, if a proper model is used instead of a random forest. Figure 5 shows prediction accuracy in terms of Mean Average Precision at 12 of all participants having the score greater than the baseline approaches, where the dotted line shows the score of OneBM. As it is observed, OneBM was among the top 24% of all the participants and achieved 77% of the best score."
    }, {
      "heading" : "VI. CONCLUSION AND FUTURE WORK",
      "text" : "In this paper, a framework is presented for automation of feature engineering from relational databases. It is proven with the experiments conducted on a real world data that, the given framework can aid data scientists during exploration of the data and enable them to save considerable amount of time during feature engineering phase. Besides, the framework outperformed many participants in Kaggle competitions. It outperformed the state of the art DSM system in a Kaggle competition. As future work, we intend to couple OneBM with automatic model selection and hyper-parameter tuning systems such as CADS or Auto-Sklearn to improve the results further."
    }, {
      "heading" : "VII. ACKNOWLEDGEMENTS",
      "text" : "We would like to thank Dr. Olivier Verscheure, Dr. Eric Bouillet, Dr. Pol McAonghusa, Dr. Horst C. Samulowitz, Dr. Udayan Khurana and Tejaswina Pedapat for useful discussion and support during the development of the project."
    } ],
    "references" : [ {
      "title" : "Towards cognitive automation of data science",
      "author" : [ "A. Biem", "M. Butrico", "M. Feblowitz", "T. Klinger", "Y. Malitsky", "K. Ng", "A. Perer", "C. Reddy", "A. Riabov", "H. Samulowitz", "D.M. Sow", "G. Tesauro", "D.S. Turaga" ],
      "venue" : "In Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence, January 25-30,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2015
    }, {
      "title" : "A tutorial on bayesian optimization of expensive cost functions, with application to active user modeling and hierarchical reinforcement learning",
      "author" : [ "E. Brochu", "V.M. Cora", "N. De Freitas" ],
      "venue" : "arXiv preprint arXiv:1012.2599,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2010
    }, {
      "title" : "Efficient and robust automated machine learning",
      "author" : [ "M. Feurer", "A. Klein", "K. Eggensperger", "J. Springenberg", "M. Blum", "F. Hutter" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2015
    }, {
      "title" : "Introduction to Statistical Relational Learning (Adaptive Computation and Machine Learning)",
      "author" : [ "L. Getoor", "B. Taskar" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2007
    }, {
      "title" : "Deep feature synthesis: Towards automating data science endeavors",
      "author" : [ "J.M. Kanter", "K. Veeramachaneni" ],
      "venue" : "In Data Science and Advanced Analytics (DSAA),",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2015
    }, {
      "title" : "READ: rapid data exploration, analysis and discovery",
      "author" : [ "U. Khurana", "S. Parthasarathy", "D.S. Turaga" ],
      "venue" : "In Proceedings of the 17th International Conference on Extending Database Technology,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2014
    }, {
      "title" : "Cognito: Automated Feature Engineering for Supervised Learning",
      "author" : [ "U. Khurana", "D. Turaga", "H. Samulowitz", "S. Parthasarathy", "editors" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2016
    }, {
      "title" : "Auto-weka 2.0: Automatic model selection and hyperparameter optimization in weka",
      "author" : [ "L. Kotthoff", "C. Thornton", "H.H. Hoos", "F. Hutter", "K. Leyton- Brown" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2016
    }, {
      "title" : "Automatic construction and Natural-Language description of nonparametric regression models",
      "author" : [ "J.R. Lloyd", "D. Duvenaud", "R. Grosse", "J.B. Tenenbaum", "Z. Ghahramani" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2014
    }, {
      "title" : "Evaluation of a tree-based pipeline optimization tool for automating data science",
      "author" : [ "R.S. Olson", "N. Bartley", "R.J. Urbanowicz", "J.H. Moore" ],
      "venue" : "In Proceedings of the Genetic and Evolutionary Computation Conference 2016,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2016
    }, {
      "title" : "Auto-WEKA: Combined selection and hyperparameter optimization of classification algorithms",
      "author" : [ "C. Thornton", "F. Hutter", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "In Proc. of KDD-2013",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2013
    }, {
      "title" : "Automatic frankensteining: Creating complex ensembles autonomously",
      "author" : [ "M. Wistuba", "S. Nicolas", "L. Schmidt-Thieme" ],
      "venue" : "In SIAM SDM",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2017
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "Auto-Weka [8], [11] and Auto-SkLearn [3] are among the first works trying to find the best combination of data preprocessing, hyper-parameter tuning and model selection.",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 10,
      "context" : "Auto-Weka [8], [11] and Auto-SkLearn [3] are among the first works trying to find the best combination of data preprocessing, hyper-parameter tuning and model selection.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 2,
      "context" : "Auto-Weka [8], [11] and Auto-SkLearn [3] are among the first works trying to find the best combination of data preprocessing, hyper-parameter tuning and model selection.",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 1,
      "context" : "Both works are based on Bayesian optimization [2] to avoid exhaustive grid-search parameter enumeration.",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 0,
      "context" : "Cognitive Automation of Data Science (CADS) [1], [6] is another system built on top of Weka, SPSS and R to automate model selection and hyper-parameter tuning process.",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 5,
      "context" : "Cognitive Automation of Data Science (CADS) [1], [6] is another system built on top of Weka, SPSS and R to automate model selection and hyper-parameter tuning process.",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 11,
      "context" : "Besides the aforementioned works, Automatic Ensemble [12] is the most recent work which uses stacking and metadata to assist model selection and tuning.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 9,
      "context" : "TPOT [10] is another system that uses genetic programming to find the best model configuration and preprocessing work-flow.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 8,
      "context" : "Automatic Statistician [9] is similar to the works just described but focuses more on time-series data and interpretation of the models in natural language.",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 4,
      "context" : "However, recent work shows that, for a specific type of problem and data such as provided in relational databases, automation of feature engineering is achievable [5].",
      "startOffset" : 163,
      "endOffset" : 166
    }, {
      "referenceID" : 4,
      "context" : "Data Science Machine (DSM) [5] is the first system that automates feature engineering from a database of multiple tables.",
      "startOffset" : 27,
      "endOffset" : 30
    }, {
      "referenceID" : 6,
      "context" : "Cognito [7] is another system that automates feature engineering but from a single database table.",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 3,
      "context" : "Our work has share common points with the fields of Inductive Logic Programming and Statistical Relational Learning (StarAI) [4].",
      "startOffset" : 125,
      "endOffset" : 128
    } ],
    "year" : 2017,
    "abstractText" : "Feature engineering is one of the most important and time consuming tasks in predictive analytics projects. It involves understanding domain knowledge and data exploration to discover relevant hand-crafted features from raw data. In this paper, we introduce a system called One Button Machine, or OneBM for short, which automates feature discovery in relational databases. OneBM automatically performs a key activity of data scientists, namely, joining of database tables and applying advanced data transformations to extract useful features from data. We validated OneBM in Kaggle competitions in which OneBM achieved performance as good as top 16% to 24% data scientists in three Kaggle competitions. More importantly, OneBM outperformed the state-of-the-art system in a Kaggle competition in terms of prediction accuracy and ranking on Kaggle leaderboard. The results show that OneBM can be useful for both data scientists and non-experts. It helps data scientists reduce data exploration time allowing them to try and error many ideas in short time. On the other hand, it enables non-experts, who are not familiar with data science, to quickly extract value from their data with a little effort, time and cost.",
    "creator" : "LaTeX with hyperref package"
  }
}