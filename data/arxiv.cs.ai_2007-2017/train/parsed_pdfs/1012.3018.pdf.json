{
  "name" : "1012.3018.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "lastname@dis.uniroma1.it" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n01 2.\n30 18\nv1 [\ncs .A\nI] 1\n4 D\nTemporal Logic Model Checking is a verification method in which we describe a system, the model, and then we verify whether some properties, expressed in a temporal logic formula, hold in the system. It has many industrial applications. In order to improve performance, some tools allow preprocessing of the model, verifying on-line a set of properties reusing the same compiled model; we prove that the complexity of the Model Checking problem, without any preprocessing or preprocessing the model or the formula in a polynomial data structure, is the same. As a result preprocessing does not always exponentially improve performance.\nSymbolic Model Checking algorithms work by manipulating sets of states, and these sets are often represented by BDDs. It has been observed that the size of BDDs may grow exponentially as the model and formula increase in size. As a side result, we formally prove that a superpolynomial increase of the size of these BDDs is unavoidable in the worst case. While this exponential growth has been empirically observed, to the best of our knowledge it has never been proved so far in general terms. This result not only holds for all types of BDDs regardless of the variable ordering, but also for more powerful data structures, such as BEDs, RBCs, MTBDDs, and ADDs."
    }, {
      "heading" : "1 Introduction",
      "text" : "Temporal Logic Model Checking [20] is a verification method for discrete systems. In a nutshell, the system, often called the model, is described by the possible transitions of its components, while the properties to verify are encoded in a temporal modal logic. It is used, for example, for the verification of protocols and hardware circuits [5]. Many tools, called model checkers, have been developed to this aim. The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].\nThere are many languages to express the model; the most widespread ones are Promela and SMV. Two temporal logics are mainly used to define the specification: CTL [20] and LTL [45]. In this paper we focus on the latter.\nIn many cases, the two inputs of the model checking problem (the model and the formula) can be processed in a different way. If we want to verify several properties of the same system, it makes sense to spend more time on the model alone, if the verification of the properties becomes faster. Many tools allow to build the model separately from checking the formula [16, 53, 36]. This way, one can reuse the same model, compiled into a data structure, in order to check several formulae.\nIn the same way, we may wish to verify the same property on different systems: the property is this time the part we can spend more time on. Many tools allow populating a property database [16, 53, 36], i.e., a collection of temporal formulae which will be checked on the models. We imagine a situation in which we early establish the requirements that our system must satisfy, even before the system is actually designed. As a result, and we can fill a database of temporal formulae, but we do not yet describe the system. While the design/modeling of the system goes on, we can preprocess the formulae (without knowledge of the model, which is not yet known). Whenever the system is specified, we can then use the result of this preprocessing step to check the model against the formulae.\nIn this paper, we analyze whether preprocessing a part of the model checking problem instances improve the performances. The technical tool we use is the compilability theory [15, 39]. This theory characterizes the complexity of problems when the problem instances can be divided into two parts (the fixed and the varying part), and we can spend more time on the first part alone, provided that the result of this preprocessing step has polynomial size respect the fixed part. We show that the Model Checking problem remains PSPACE-hard even if we can preprocess either the model or the formula, if this preprocessing step is constrained to have a polynomial size. These theorems hold for all model checkers.\nFinally, we answer to a long-time standing question in Symbolic Model Checking [43, 11]. It has been observed that the BDDs that are used by SMV and other Symbolic Model Checking systems become exponentially large in some cases. However, it has not yet been established whether this size increase is due to the choice of variable ordering, or to the kind of BDDs employed, or it is intrinsic of the problem. We show that, if PSPACE 6⊆ Πp2 ∩ Σ p 2, such a growth is, in the worst case, unavoidable. This result is independent from the particular class of BDDs and from the variable order of the BDDs. It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2]."
    }, {
      "heading" : "2 Preliminaries",
      "text" : ""
    }, {
      "heading" : "2.1 Model Checking",
      "text" : "In this section, we briefly recall the basic definitions about model checking that are needed in the rest of the paper. We follow the notation of [47, 46]. LTL (Linear Temporal Logic) is a modal logic aimed at encoding how states evolve over time. It has three unary modal operators (X , G, and F ) and one binary modal operator (U). Their meaning is: Xφ is true in particular state if and only\nif the formula φ is true in the next state; Gφ is true if and only φ is true from now on; Fφ is true if φ will become true at some time in the future; φUψ is true if ψ will eventually become true and φ stays true until then. We indicate with L(O1, . . . , On) the LTL fragment in which the only temporal operators allowed are O1, . . . , On; for instance, L(F,X) is the fragment of LTL in which only F and X are allowed.\nThe semantics of LTL is based on Kripke models. In the following, for an ’atomic proposition’ we mean a Boolean variable. Given a set of atomic proposition, a Kripke structure for LTL is a tuple 〈Q,R, ℓ, I〉, where Q is a set of states, R is a binary relation over states (the transition relation), ℓ is a function from states to atomic propositions (it labels every state with the atomic propositions that are true in that state), I is a set of initial states. A run of a Kripke structure is a Kripke model. A Kripke model for LTL is an infinite sequence of states, where the transition relation links each state with the one immediately following it in the sequence. The semantics of the modal operators is defined in the intuitive way: for example, Fφ is true in a state of a Kripke model if φ is true in some following state.\nThe main problem of interest in practice is to verify whether all runs of a Kripke structure (all of its Kripke models) satisfy the formula; this is the Universal Model Checking problem. The Existential Model Checking one is to verify whether there is a run of the Kripke structure that satisfies the formula. In formal verification, we encode the behavior of a system as a Kripke structure, and the property we want to check as an LTL formula. Checking the structure against the formula tells whether the system satisfies the property. Since the Kripke structure is usually called a “model” (which is in fact very different from a Kripke model, which is only a possible run), this problem is called Model Checking.\nIn practice, all model checkers describe a system by the Kripke structure of its components. A Kripke structure can be seen as a transition system [20]. Thus the global system is obtained by parallel composition of the transition systems representing its components and sharing some variables [42, 20]; using this approach, we can give results valid for all model checkers."
    }, {
      "heading" : "2.2 Composition of Transition Systems",
      "text" : "Each component of the global system is modeled using a transition system, which is a formal way to describe a possible transition a system can go through. Intuitively, all is needed is to specify the state variables, the possible initial states, and which transitions are possible, i.e., we have to say whether the transition from state s to state s′ is possible for any pair of states s and s′. The formal definition is as follows [42, 20].\nDefinition 1 A finite-state transition system is a triple (V, I, ̺), where V = {x1, . . . , xn} is a set of Boolean variables, I is a formula over V , and ̺(V, V ′) is a formula over V ∪ V ′, where V ′ = {x′1, . . . , x ′ n} is a set of new variables in one to one relation with elememts of V .\nIntuitively, V is the set of state variables, I is a formula that is true on a truth assignment if and only if it represents a possible initial state, and ̺ is true on a pair of truth assignments if they represent a possible transition of\nthe system. The set of variables V ′ is needed because ̺ must refer to both the value of a variable in the current state (xi) and in the next state (x ′ i). In other words, in this formula xi means the value of xi in the current state, while x ′ i is the value of the same variable in the next state. For example, the fact that xi remains true is encoded by ̺ = xi → x′i: if xi is true now, then x ′ i is true, i.e., xi is true in the next state. Formally, a state s is an assignment to the variables; a state s′ is successor of a state s iff 〈s, s′〉 |= ̺(V, V ′). A computation is an infinite sequence of states s0, s1, s2, . . . , satisfying the following requirements:\nInitiality: s0 is initial, i.e. s0 |= I\nConsecution: For each j ≥ 0, the state sj+1 is a successor of the state sj\nFor the sake of simplicity, without loss of any generality, we only consider Boolean variables and Boolean assertions.\nIn order to model a complex system, we assume that each of its parts can be modeled by a transition system. Clearly, there is usually some interaction between the parts; as a result, some variables may be shared between the transition systems. In the following, we consider k transition systems M1, . . . ,Mk. Every Mi is described by ((V L i ∪ V S i ), Ii(Vi), ̺i(Vi, V ′ i )) for i 1 ≤ i ≤ k where V Li is the set variables local to Mi, V S i is the set of shared variables of Mi, and Vi = V L i ∪ V S i . A group of transition systems can be composed in different ways: synchronous, interleaved asynchronous, and asynchronous. The third way is not frequently used in Model Checking, so we only define the first two ways of composition. In the following, a process is any of the transition systems Mi.\nThe synchronous parallel composition of k transition systems is obtained by assuming that the global transition is due to all processes Mi making a transition simultaneously. In other words, all processes must make a transition at any time step, and no process is allowed to “idle” at any time step.\nDefinition 2 The synchronous parallel composition of processes M1, . . . ,Mk, denoted by M1‖ . . . ‖Mk, is the transition system M = (V, I, ̺) described by:\nV = ⋃k i=1 Vi I(V ) = ∧k i=1 Ii(Vi)\n̺(V, V ′) = ∧k i=1 ̺i(Vi, V ′ i )\nThe basic idea of the interleaved asynchronous parallel composition is that only one process is active at the same time. As a result, a global transition can only result from the transition of a single process. The variables that are not changed by this process must maintain the same value.\nDefinition 3 The interleaved asynchronous parallel composition of M1, . . . ,Mk is the transition system M = (V, I, ̺): , where V and I are as in the synchronous composition and ̺ is:\n̺(V, V ′) = ∨k\ni=1\n[\n̺i(Vi, V ′ i ) ∧ ∧k j=1 j 6=i V Li = V L i\n′ ]\nThe interleaved asynchronous parallel composition of M1, . . . ,Mk, is denoted by M1| . . . |Mk.\nA model can be described as the composition of transition systems. As a result, we can define the model checking problem for concurrent transition systems as the problem of verifying whether the model described by the composition of the transition systems satisfies the given formula."
    }, {
      "heading" : "2.3 Complexity and Compilability",
      "text" : "We assume that the reader knows the basic concepts of complexity theory [48, 31]. What we mainly use in this paper are the concepts of polynomial reduction and the class PSPACE.\nThe Model Checking problem is PSPACE-complete, and is thus intractable. On the other hand, as said in the Introduction, it makes sense to preprocess only one part of the problem (either the model or the formula), if this reduces the remaining running time. The analysis of how much can be gained by such preprocessing, however, cannot be done using the standard tools of the polynomial classes and reductions. The compilability classes [15] have to be used instead.\nThe way in which the complexity of the problem is identified in the theory of NP-completeness is that of giving a set of increasing classes of problems. If a problem is in a class C but is not in an inner class C′, then we can say that this problem is more complex to solve that a problem in C′. A similar characterization, with similar classes, can be given when preprocessing is allowed. For example the class ‖;P is the class of problems that can be solved in polynomial time after a preprocessing step. Crucial to this definition are two points:\n1. which part of the problem instance can be preprocessed?\n2. how expensive is the preprocessing part allowed to be?\nThe first point depends on the specific problem and on the specific settings: depending on the scenario, for example, we can preprocess either the model or the formula for the model checking problem. The second question instead allows for a somehow more general answer. First, we cannot limit this phase to take polynomial time, as otherwise there would be no gain in doing preprocessing from the point of view of computational complexity. Second, we cannot allow the final result of this part to be exponentially large, for practical reasons; we bound the result of the preprocessing phase only to take a polynomial amount of space.\nIn order to denote problems in which only one part can be preprocessed, we assume that their instances are composed of two parts, and that the part that can be preprocessed is the first one. As a result, the model checking problem written as 〈M,φ〉 indicates that M can be preprocessed; written as 〈φ,M〉 indicates that φ can be preprocessed.\nThe “complexity when preprocessing is allowed” is established by characterizing how hard a problem is after the preprocessing step. This is done by building over the usual complexity classes: if C is a “regular” complexity class such as NP, then a problem is in the (non-uniform) compilability class ‖;C if the problem is in C after a preprocessing step whose result takes polynomial space. In other words, ‖;C is “almost” C, but preprocessing is allowed and will not be counted in the cost of solving the problem. More details can be found in [15].\nIn order to identify how hard a problem is, we also need a concept of hardness. Since the regular polynomial reductions are not appropriate when preprocessing is allowed, ad-hoc reductions (called nu-comp reductions in [15]) have been defined.\nIn this paper, we do not show the hardness of problems directly, but rather use a sufficient condition called representative equivalence. For example, in order to prove that model checking is ‖;PSPACE-hard, we first show a (regular) polynomial reduction from a PSPACE-hard problem to model checking and then show that this reduction satisfies the condition of representative equivalence.\nLet us assume that we know that a given problem A is ‖;C-hard and we have a polynomial reduction from the problem A to the problem B. Can we use this reduction to prove the ‖;C-hardness of B ? Liberatore [39] shows sufficient conditions that should hold on A as well as on the reduction. If all these conditions are verified, then there is a nucomp reduction from ∗A to B, where ∗A = {〈x, y〉 |y ∈ A}, thus proving the ‖;C-hardness of B.\nDefinition 4 (Classification Function) A classification function for a problem A is a polynomial function Class from instances of A to nonnegative integers, such that Class(y) ≤ ||y||.\nDefinition 5 (Representative Function) A representative function for a problem A is a polynomial function Repr from nonnegative integers to instances of A, such that Class(Repr(n)) = n, and that ||Repr(n)|| is bounded by some polynomial in n.\nDefinition 6 (Extension Function) An extension function for a problem A is a polynomial function from instances of A and nonnegative integers to instances of A such that, for any y and n ≥ Class(y), the instance y′ = Exte(y, n) satisfies the following conditions:\n1. y ∈ A if and only if y′ ∈ A; 2. Class(y′) = n.\nLet us give some intuitions about these functions. Usually, an instance of a problem is composed of a set of objects combined in some way. For problems on boolean formulas, we have a set of variables combined to form a formula. For graph problems, we have a set of nodes, and the graph is indeed a set of edges, which are pairs of nodes. The classification function gives the number of objects in an instance. The representative function thus gives an instance with the given number of objects. This instance should be in some way “symmetric”, in the sense that its elements should be interchangeable (this is because the representative function must be determined only from the number of objects). Possible results of the representative function can be the set of all clauses of\nthree literals over a given alphabet, the complete graph over a set of nodes, the graph with no edges, etc. Let for example A be the problem of propositional satisfiability. We can take Class(F ) as the number of variables in the formula F , while Repr(n) can be the set of all clauses of three literals over an alphabet of n variables. Finally, a possible extension function is obtained by adding tautological clauses to an instance. Note that these functions are related to the problem A only, and do not involve the specific problem B we want to prove hard, neither the specific reduction used. We now define a condition over the polytime reduction from A to B. Since B is a problem of pairs, we can define a reduction from A to B as a pair of polynomial functions 〈r, h〉 such that x ∈ A if and only if 〈r(x), h(x)〉 ∈ B.\nDefinition 7 (Representative Equivalence) Given a problem A (having the above three functions), a problem of pairs B, and a polynomial reduction 〈r, h〉 from A to B, the condition of representative equivalence holds if, for any instance y of A, it holds:\n〈r(y), h(y)〉 ∈ B iff 〈r(Repr(Class(y)), h(y)〉 ∈ B\nThe condition of representative equivalence can be proved to imply that the problem B is ‖;C-hard, if A is C-hard [39]. As an example, we show these three functions for the PLANSAT ∗1 problem. PLANSAT ∗ 1 is the following problem of planning: giving a STRIPS [29] instance y = 〈P,O, I,G〉 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT ∗1 is PSPACE-Complete [12]. Without loss of generality we consider y = (P,O∪o0, I, G), where o0 is a operator which is always usable (it has no preconditions) and does nothing (it has no postconditions). We use the following notation: P = {x1, . . . , xn}, I is the set of conditions true in the initial state, G = 〈M,N〉. A state in STRIPS is a set of conditions. In the following we indicate with φhi the hth positive precondition of the operator oi, with φi all its the positive preconditions, with η h i its hth negative precondition, and with ηi all its negative preconditions; αi is the positive postcondition of the operator oi, βi is the negative postcondition of the operator oi. Since any operator has only one postcondition, for every operator i it holds that ‖αi∪βi‖ = 1.\nSince we shall use them in the following, we define a classification function, a representative function and a extension function for PLANSAT ∗1 :\nClassification Function: Class(y) = ‖P‖. Clearly, it satisfies the condition Class(y) ≤ ‖y‖.\nRepresentative Function: Repr(n) = 〈Pn, ∅, ∅, ∅〉, where Pn = {x1, . . . , xn}. Clearly, this function is polynomial and satisfies the following conditions: (i) Class(Repr(n))=n, (ii) ‖Repr(n)‖ ≤ p(n) where p(n) is a polynomial.\nExtension Function: Let y = 〈P,O, I,G〉 and y′ = Exte(y, n) = 〈Pn, O, I,G〉. Clearly for any y and n s.t. n ≥ Class(y) y′ satisfies the following conditions: (i)y ∈ A iff y′ ∈ A, (ii) Class(y′) = n.\nGiven the limitation of space we cannot give the full definitions for compilability, for which the reader should refer to [15] for an introduction, to [14, 13] for an application to the succinctness of some formalisms, to [39] for further applications and technical advances."
    }, {
      "heading" : "3 Results",
      "text" : "The Model Checking problem for concurrent transition systems is PSPACEcomplete [37]. In Section 3.1, we prove that the following problems are ‖;PSPACEhard, which implies that they remain PSPACE-hard even if preprocessing is allowed.\n1. model checking on the synchronous and interleaved asynchronous composition of transition systems, where the transitions systems are the fixed part of the problem and the LTL formula is the varying part;\n2. the same problem, where the LTL formula is the fixed part and the transition system is the varying part;\n3. given a set of transition systems and a formula as the fixed part, a state as the varying part, checking whether the state is a legal initial state.\nWe can conclude that preprocessing the model or the formula does not lead to a polynomial algorithm for model checking. We recall that the fixed part is preprocessed off-line in a polynomial data structure during the preprocessing phase, and the varying part is given on-line.\nThe relevance of the first two problems is clear: in formal verification, it is often the case that many properties (formulae) have to be verified over the same system (the model, in this case modeled by the transition systems); on the other hand, it may also be that the same property has to be verified on different systems.\nThe result about the third problem is less interesting by itself. On the other hand, we use it to prove that the superpolynomial growth of the size of the data structures (e.g. OBDDs) currently used in model checkers based on the Symbolic Model Checking algorithms [43] (such as SMV and NuSMV) cannot be avoided in general. The result is independent from its variable ordering, and it holds for others data structures that can be employed. We show these results in Section 3.2.\nWe point out that most of Temporal Logic Model Checking algorithms [20] fall in one of three classes: Symbolic Model Checking algorithms, which work on symbolic representation of M ; algorithms based on Bounded Model Checking [7] (i.e. based on reduction from Model Checking into SAT); algorithms that work on an explicit representation of M (e.g. [32]). Our results concerning the size of the BDD (or some other decision diagrams) are valid for all algorithms of the first class.\nIn the proofs of the following sections we consider Existential Model Checking problems, but the results are valid also for the Universal case; in fact PSPACE is closed under complementation also for compilability."
    }, {
      "heading" : "3.1 Preprocessing Model Checking",
      "text" : "We now identify the complexity of the Model Checking problem when the preprocessing of the model (represented as the composition of transition systems) is allowed, both in the synchronous and in the interleaved case.\nTheorem 1 The model checking problem for k synchronous concurrent process MCsyn = 〈(M1|| . . . ||Mk), ϕ〉 where ϕ ∈ LTL is ‖;PSPACE-hard, and remains ‖;PSPACE-hard for ϕ ∈ L(F,G,X).\nProof. It is similar to the proof of the Theorem 2. We carry out a reduction from the PLANSAT ∗1 problem, that satisfies the conditions of representative equivalence; the main difference is about the LTL formula.\nWe now consider the Model Checking problem for concurrent processes composed in a interleaved way when the model can be preprocessed.\nTheorem 2 The model checking problem for k interleaved concurrent process MCasyn = 〈(M1| . . . |Mk), ϕ〉 where ϕ ∈ LTL is ‖;PSPACE-complete, and remains ‖;PSPACE-hard for ϕ ∈ L(F,G,X).\nProof. We show a reduction, that translates an instance y ∈ PLANSAT ∗1 into an instance 〈r(y), h(y)〉 ∈ Masyn, satisfying the condition of representative equivalence. Given y = 〈P,O, I,G〉 ∈ PLANSAT ∗1\n- r(y) defines a concurrent transition systems M1, . . . ,Mn, where each Mi is obtained from a variable xi ∈ P and it is described by:\nVi = {xi}\nIi(Vi) = (xi) ∨ (¬xi) ̺i(Vi, V ′ i ) = (xi = 0 ∧ x ′ i = 0) ∨ (xi = 0 ∧ x ′ i = 1) ∨\n(xi = 1 ∧ x′i = 0) ∨ (xi = 1 ∧ x ′ i = 1)\nThe process M = M1‖ . . . ‖Mn represents all possible computations, starting from all possible initial assignments, over the variables x1, . . . , xn.\n- h(y) = h(I,G,O) = ¬(φI ∧ φG ∧ φO) where:\nϕI = ∧\ni∈I xi ∧\n∧\ni/∈I\n¬xi\nϕG = F ( ∧\ni∈M xi ∧\n∧\ni∈N ¬xi)\nϕO = G m ∨\ni=0\n[ ‖φi‖ ∧\nh=1\nφhi ∧ ‖ηi‖ ∧\nh=1\n¬ηhi ∧Xγi ∧ n ∧\nj 6=i j=1\n(xj ↔ Xxj)]\nwhere\nγi =\n{\nαi if αi 6= ∅ ¬βi if βi 6= ∅\nϕI adds constraints about the initial states of y represented by I.\nϕG adds constraints about the goal states of y represented by G: it tells that a goal state will be reached.\nϕO describes the operators in O: globally (i.e. in every state) one of the operators must be used to go in the next state; ϕO also describes the nop operator o0.\nNow, we prove that y ∈ PLANSAT ∗1 iff 〈r(y), h(y)〉 ∈ Masyn. Given y = 〈P,O, I,G〉, a solution for y is a plan which generates the following sequence of states: (s1, . . . , sp) where s1 is an initial state and sp is a goal state. This sequence of states is obtained applying a sequence of operators (oh1 , . . . , ohp) chosen in O = {o1, . . . , om} in the following way: for all i s.t. 1 ≤ i ≤ p, preconditions for ohi are included in the state si, and the state si+1 is obtained from the state si modifying the postcondition associated with ohi . We remark that a state in STRIPS is the set of conditions.\nThe model M = r(y) = r(P ) represents all possible traces starting from all possible initial configurations, over the variables x1, . . . , xn. Thus, in this case the Existential Model Checking problem 〈M,ϕ〉 reduces to the satisfiability problem for ϕ: we check whether ther exists a trace among all traces over the variables x1, . . . , xn that satisfies the LTL formula ϕ. Therefore, we have to prove that y ∈ A iff ϕ = h(y) is satisfiable:\n⇒. Given a solution for y ∈ A, we identify a model for ϕ = h(y); by construction such a model has:\n- initial state sM1 s.t. ℓ(s1) = I ∪ {¬xi|xi /∈ I}\n- a state sMp s.t. ℓ(sp) ⊆ M∪ {¬xi|xi /∈ N}\n- given a state sMi , s M i+1 is successor of s M i iff\n- ℓ(sMi ) ⊆ Precond(ohi ), where Precond(ohi) = {xj |xj ∈ φhi} ∪ {¬xj |xj ∈ ηhi} - ℓ(sMi+1) = ℓ(s M i ) ∪ αi − βi\nwhere αi is the positive postcondition of ohi and βi is the negative postcondition of ohi .\n- an infinite number of states: when the state sp is reached this state is repeated for at least once or for ever (applying the nop operator o0), or it is possible, it depends from y, to apply any operators whose preconditions are satisfied by ℓ(sMp ).\n⇐. Let (sM1 , . . . , s M p , . . .) a model for ϕ, and let sp the goal state, that the first state satisfying ϕG. We obtain the sequence of states visited by a plan which is a solution for y, by cutting the states after the goal state sp and assigning si = ℓ(s M i ); thus this sequence of states (s1, . . . , sp), associated with the plan, has by construction:\n- initial state s1 s.t. s1 = I ∪ {¬xi|xi /∈ I}\n- a state sp s.t. sp ⊆ M∪ {¬xi|xi /∈ N}\n- given a state si, si+1 is successor of si iff\n- si ⊆ Precond(ohi )\n- si+1 = si ∪ αi − βi where αi is the positive postcondition of ohi and βi is the negative postcondition of ohi .\nNow we show the complexity results, both in the synchronous and in the interleaved case, when the formula can be preprocessed.\nTheorem 3 The model checking problem for k synchronous concurrent process MC′syn = 〈ϕ, (M1|| . . . ||Mk)〉 where ϕ ∈ LTL is ‖;PSPACE-complete, and remains ‖;PSPACE-hard for ϕ ∈ L(F,G,X).\nProof. PLANSAT ∗1 is the following problem of planning: giving a STRIPS [29] instance y = 〈P,O, I,G〉 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT ∗1 is PSPACE-complete [12]. Without loss of generality we consider y = (P,O ∪ o0, I, G), where o0 is a operator which is always usable (it has no preconditions) and does nothing (it has no postconditions). We use the following notation: P = {x1, . . . , xn}, I is the set of conditions true in the initial state, G = 〈M,N〉. A state in STRIPS is a set of conditions.\nIn the following we indicate with φhi the hth positive precondition of the operator oi, and with η h i the hth negative precondition of the operator oi; αi is the positive postcondition of the operator oi, βi is the negative postcondition of the operator oi. Since any operator has only one postcondition, for every operator i it hold that ‖αi ∪ βi‖ = 1.\nWe show a polynomial reduction from the problem A to the problem B that satisfies the condition of representative equivalence. This proves that B is ‖;C-hard, if A is C-hard; to apply this condition we must define a Classification Function, a Representative Function and a Extension Function for A. Thus we use such a proof schema: we define a Classification Function, a Representative Function and a Extension Function for PLANSAT ∗1 , then we show a polynomial reduction from an instance y ∈ PLANSAT ∗1 to an instance 〈r(y), h(y)〉 ∈ MC′SY N that satisfies the condition of representative equivalence.\nLet y = 〈P,O, I,G〉 ∈ PLANSAT ∗1 . We define r and h as follows:\n- r(y) = r(P ) = ¬ { F (xg) ∧G ∧n\ni=0\n[\n¬(xi ↔ Xxi) → ∧n j=1\nj 6=i (xj ↔ Xxj)\n]}\n- h(y) defines the transition systems M1‖ . . . ‖Mk. The generic Mi is obtained from the operators oi1 , . . . , oidi whose postcondition involves the variable xi ∈ P ; di is the number of such operators. We add the variable xg; thus we have at most as many processes as variables: if k is the number of variables used as postcondition of operators plus one, we have k ≤ n+1. Let Mk the process associated with the variable xg; this variable is 0 at the beginning and it becomes 1 only when the goal of the PLANSAT problem is reached. Mi, for i s.t. 1 ≤ i < k, is defined by:\nVi = ⋃di q=1 φiq ∪ ηiq ∪ αiq ∪ βiq Ii(Vi) = ∧\nxj∈I∩Vi\nxj ∧ ∧\nxj∈I∪Vi\n¬xj\n̺i(Vi, V ′ i ) = ∨di k=1\n‖φik‖ ∧\nh=1\nφhik ∧ ‖ηik‖ ∧\nh=1\n¬ηhik ∧ ¬( ∧\ni∈M xi ∧\n∧\ni∈N ¬xi) ∧ (x′i ≡ bik)\nwhere bik =\n{\n1 if αik 6= ∅ 0 if βik 6= ∅\nThe process Mk is defined by:\nVk = {xg}\nIk(V ) = (xg = 0) ̺k(Vk, V ′ k) = ∧ i∈M xi ∧ ∧ i∈N ¬xi ∧ x ′ g = 1\nNow we prove that this reduction is correct, i.e. y ∈ PLANSAT ∗1 iff 〈r(y), h(y)〉 ∈ MC′SY N .\n⇒. Given a solution for y ∈ PLANSAT ∗1 , we show a path of M which satisfies ϕ (r(y) defined above).\nA solution for y is a plan which generates the following sequence of states: (s1, . . . , sp) where s1 is a initial state and sp is a goal state. This sequence of states is obtained by applying a sequence of operators (oh1 , . . . , ohp).\nBy construction M admits a path (sM1 , . . . , s M p , s M p+1, . . . ) s.t.:\n- ℓ(sMi ) = si ∪ ¬xg for i 1 ≤ i ≤ p\n- ℓ(sMp+1) = sp ∪ xg\nThis path satisfies ϕ:\n- ϕ does not constrain about the initial state, therefore every initial state of the model is legal;\n- xg ⊆ ℓ(sMp+1), therefore F (xg) is true;\n- the path shown is s.t. only one variable change at a time, therefore the subformula under the Globally is true.\n⇐. Given a path of M which satisfies ϕ, we show a solution for y ∈ PLANSAT ∗1 . The path is a sequence (sM1 , . . . , s M p , s M p+1, . . . ). We can obtain the sequence of states visited by a plan for y in this way:\n- si = ℓ(s M i )− {¬xg} for i 1 ≤ i ≤ p;\n- we ignore the rest of the path of M .\nTheorem 4 The model checking problem for k interleaved concurrent process MC′asyn = 〈ϕ, (M1| . . . |Mk)〉 where ϕ ∈ LTL is ‖;PSPACE-complete, and remains ‖;PSPACE-hard for ϕ ∈ L(F ).\nProof. We carry out a reduction from the PLANSAT ∗1 problem, that satisfies the conditions of representative equivalence. The proof is similar to the proof of the Theorem 3.\nNow we introduce the decision problem MCs0 = 〈[M,ϕ], s0〉, where M is specified by the interleaved parallel composition of k transition systemsM1, . . . ,Mk, ϕ ∈ L(F ), and s0 is a specific state. MCs0 is true if the model checking problem for concurrent transition system 〈M,ϕ〉 has solution and s0 is a legal initial state i.e., is an initial state belonging to M that satisfies ϕ.\nTheorem 5 MCs0 is ‖;PSPACE-complete.\nProof. The hardness follows from a polynomial time reduction from the problem 〈(P,O,G), I〉, that can be easily shown ‖;PSPACE-complete on the basis of the results in [40].\nWe sketch the reduction. We encode each operator in O into each process Mi, and the goal G into the formula ϕ. We encode the set of initial states I using s0."
    }, {
      "heading" : "3.2 The Size of BDDs",
      "text" : "In this section we prove that the size of BDDs and others data structures increases superpolynomially with the size of the input data, in the worst case, when are used in a Symbolic Model Checking algorithm.\nLet M a model specified by k concurrent transition systems M1, . . . ,Mk, and let ϕ an LTL (or a CTL or CTL*) formula.\nTheorem 6 If PSPACE 6⊆ Πp2 ∩ Σ p 2, then there is not always a BDD of any kind and with any variable order that is polynomially large and represents the set of initial states consistent with M and ϕ.\nProof. The evaluation problem for any kind of BDD, i.e. giving a BDD and an assignment of its variables evaluate the BDD, is in P . If there exists a poly-size BDD representing the set of initial states consistent with M and ϕ, then we can compile M and ϕ in the BDD and evaluate the assignment (representing a initial state) in polynomial time. This implies that MCs0 is in ‖;P. We know from Theorem 5 that MCs0 is ‖;PSPACE-complete. Therefore if such a BDD exists, then ‖;PSPACE=‖;P. Now, by applying Theorem 2.12 in [15], we conclude that there is no poly-size reduction from MCs0 to the evaluation problem for a BDD, if PSPACE 6⊆ Πp2 ∩ Σ p 2.\nSymbolic Model Checking algorithms work by building a representation of the set of the initial states of M that satisfy ϕ. In particular, this set is represented by BDDs. Therefore, the last theorem proves that these algorithms, in the worst case, end up with a BDD of superpolynomial size. This result does not depend on the kind of BDD used (free, ordered, etc.) and on the variable ordering. On the contrary, it holds also when the states are labeled with enumerative variable; in other words it holds not only for BDD but also for any decision diagram, provided that the evaluation problem over this representation of the states is in a class of the polynomial hierarchy. More formally, we consider an arbitrary representation of a set of states. The evaluation problem is that of determining whether a state belongs to a set.\nTheorem 7 Given a method for representing a set of states whose evaluation problem is in a class Σpi of the polynomial hierarchy, it is not always possible to represent in polynomial space the set of legal initial states of a model M and a formula ϕ, provided that Σpi+1 6= Π p i+1.\nThe proof of this theorem has the same structure of the proof of the Theorem 6.\nInstances of such data structures, currently used in Symbolic Model Checking tools, are BDDs, Boolean Expression Diagrams (BEDs) [54] and Reduced Boolean Circuits (RBCs) [1]. Our results hold also for data structures used to represent integer-value functions, like Multi terminal binary decision diagrams (MTBDDs) [18], Algebraic Decision Diagrams (ADDs) [2]; see for details the survey [25].\nOn the other hand, it is also possible to prove that the above two theorems cannot be stated unconditionally: indeed if P = PSPACE, then there is a data structure of polynomial size allowing the representation of the set of initial states in such a way deciding whether a state is in this set can be decided in polynomial time. As a result, the non-conditioned version of the above two theorems implies a separation in the polynomial hierarchy."
    }, {
      "heading" : "4 Related Works",
      "text" : "Some works in the literature are related to the results in this article:\n1. the exponential growth of the BDD size respect to a particular problem (e.g. integer multiplication [10]); some results concern the size growth of other decision diagrams [25] respect to particular problems. While these results are not conditional to the collapse of the polynomial hierarchy as the ones reported in this paper, they are also more specific, as they concern only specific kinds of data structures (e.g. OBDDs) respect to particular problems (e.g. integer multiplication).\n2. the complexity of model checking:\n(a) the parametrized complexity [24] of a wide variety of model checking problems [23], analyzing the state explosion problem;\n(b) it has been shown that [28]:\ni. the complexity of model checking does not decrease under the ipotheses of some structural restrictions (e.g. treewidth) in the input.\nii. despite a CNF formula of bounded treewidth can be represented by an OBDD of polynomial size, the nice properties of treewidthbounded CNF formulas are not preserved under existential quantification or unrolling, that is a basic operation of model checking algorithms.\n(c) the compilability of the model checking problem [27]: it remains PSPACE-complete even if a part of the input, either the implicit model or the formula, is preprocessed using any amount of time and storing the result of this prerpocesing step in a polynomial-sized data structure.\n3. the theoretical limitations of Symbolic Model Checking. The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33]. Moreover, a\nclassic information theoretic argument shows that only a small fraction of all finite Kripke structures can be exponentially compressed [38].\n4. succinctness of languages; for instance [21], in which succinctness of language for preferences are discussed, and [22] that presents results on the succinctness of several formalism, including BDDs and CNF."
    } ],
    "references" : [ {
      "title" : "Symbolic reachability analisys based on SAT-solvers",
      "author" : [ "P.A. Abdullah", "P. Bjesse", "N. Een" ],
      "venue" : "Proceedings of the 6th International Conference on Tools and Algorithms for the Construction and Analisys of Systems (TACAS’00),",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Algebraic decision diagrams and their applications",
      "author" : [ "R.I. Bahar", "E.A. Frohm", "C.M. Gaona", "C.M. Hachtel", "G.D. Macii", "F. Somenzi" ],
      "venue" : "Proceedings of the International Conference CAD, pages 188–191,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "The complexity of searching implicit graphs",
      "author" : [ "José L. Balcázar" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1996
    }, {
      "title" : "The complexity of algorithmic problems on succinct instances, pages 351–377",
      "author" : [ "José L. Balcázar", "Antoni Lozano", "Jacobo Torán" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1992
    }, {
      "title" : "Methodology and system for pratical formal verification of reactive hardware",
      "author" : [ "I. Beer", "S. Ben David", "D. Geist", "R. Gewirtzman", "M. Yoeli" ],
      "venue" : "Proceedings of the 6th International Conference on Computer-Aided Verification (CAV’94), volume 818 of LNCS, pages 182–193. Springer,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "On the fly model checking for rctl formulas",
      "author" : [ "I. Beer", "S. Ben David", "A. Landver" ],
      "venue" : "Proceedings of the 10th International Conference on Computer-Aided Verification (CAV’98), volume 1427 of LNCS, pages 184– 194. Springer,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Symbolic model checking without BDDs",
      "author" : [ "A. Biere", "A. Cimatti", "E.M. Clarke", "Yunshan Zhu" ],
      "venue" : "In Proceedings of the 5th Int. Conf. Tools and Algorithms for the Construction and Analisys of Systems (TACAS’1999),",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1999
    }, {
      "title" : "VIS: a system for verification and syntesis",
      "author" : [ "R.K. Brayton", "G.D. Hachtel", "A. Sangiovanni Vincetelli", "F. Somenzi", "A. Aziz", "S.T. Cheng", "S. Edwards", "S. Khatri", "T. Kukimoto", "A. Pardo", "S. Qadeer", "R.K. Ranjan", "S. Sarwary", "T.R. Shiple", "G. Swamy", "T. Villa" ],
      "venue" : "Proceedings of the 8th International Conference on Computer-Aided Verification (CAV’96), volume 1102 of LNCS, pages 428–432. Springer,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Verification of arithmetic circuits using binary moment diagrams",
      "author" : [ "Randal E. Bryant", "Yirng-An Chen" ],
      "venue" : "STTT, 3(2):137–155,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2001
    }, {
      "title" : "On the complexity of vlsi implementations and graph representations of boolean functions with application to integer multiplication",
      "author" : [ "R.E. Bryant" ],
      "venue" : "IEEE Transactions on Computers, 40:205–213,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Symbolic model checking: 100 states and beyond",
      "author" : [ "Jerry R. Burch", "Edmund M. Clarke", "Kenneth L. McMillan", "David L. Dill", "L.J. Hwang" ],
      "venue" : "Inf. Comput.,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1992
    }, {
      "title" : "Complexity results for planning",
      "author" : [ "T. Bylander" ],
      "venue" : "Proceedings of the 12th International Joint Conference on Artificial Intelligence, LNCS, pages 274– 279, San Mateo, CA,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Space efficency of propositional knowledge representation formalisms",
      "author" : [ "M. Cadoli", "F.M. Donini", "P. Liberatore", "M. Schaerf" ],
      "venue" : "Journal of Artificial Intelligence Research, 13:25–64,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "The size of a revised knowledge base",
      "author" : [ "M. Cadoli", "F.M. Donini", "P. Liberatore", "M. Schaerf" ],
      "venue" : "Artificial Intelligence, 115:1–31,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Preprocessing of intractable problems",
      "author" : [ "M. Cadoli", "F.M. Donini", "P. Liberatore", "M. Schaerf" ],
      "venue" : "Information and Computation, 176:89–120,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "NuSMV 2.4 User’s Manual",
      "author" : [ "R. Cavada", "A. Cimatti", "E. Olivetti", "M. Pistore", "M. Roveri" ],
      "venue" : "IRST, http://nusmv.irst.itc.it,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2007
    }, {
      "title" : "NuSMV 2: An opensource tool for symbolic model checking",
      "author" : [ "A. Cimatti", "E.M. Clarke", "E. Giunchiglia", "F. Giunchiglia", "M. Pistore", "M. Roveri", "R. Sebastiani", "A. Tacchella" ],
      "venue" : "Proceedings of the 14th International Conference on Computer-Aided Verification (CAV’02),",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Multi terminal binary decision diagrams: An efficient data structure for matrix representation",
      "author" : [ "E. Clarke", "M. Fujita", "P. McGeer", "K.L. McMillan", "J. Yang", "X. Zhao" ],
      "venue" : "Proceedings of the International Workshop on Logic and Synthesis, pages 1–15,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Progress on the state explosion problem in model checking",
      "author" : [ "Edmund M. Clarke", "Orna Grumberg", "Somesh Jha", "Yuan Lu", "Helmut Veith" ],
      "venue" : "In Informatics,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2001
    }, {
      "title" : "Model Checking",
      "author" : [ "E.M. Clarke", "O. Grumberg", "D.A. Peled" ],
      "venue" : "MIT Press,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Expressive power and succinctness of propositional languages for preference representation",
      "author" : [ "Sylvie Coste-Marquis", "Jérôme Lang", "Paolo Liberatore", "Pierre Marquis" ],
      "venue" : null,
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2004
    }, {
      "title" : "A knowledge compilation",
      "author" : [ "Adnan Darwiche", "Pierre Marquis" ],
      "venue" : "map. J. Artif. Intell. Res. (JAIR),",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2002
    }, {
      "title" : "A parametric analysis of the state explosion problem in model checking",
      "author" : [ "Stéphane Demri", "François Laroussinie", "Ph. Schnoebelen" ],
      "venue" : "In STACS,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2002
    }, {
      "title" : "Parametrized Complexity",
      "author" : [ "R.G. Downey", "M.R. Fellows" ],
      "venue" : "Springer,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Binary decision diagrams in theory and practice",
      "author" : [ "R. Drechsler", "D. Sieling" ],
      "venue" : "International Journal on Software Tools for Technology Transfer (STTT), 3(2):112–136, May",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "The complexity of problems on graphs represented as obdds",
      "author" : [ "Joan Feigenbaum", "Sampath Kannan", "Moshe Y. Vardi", "Mahesh Viswanathan" ],
      "venue" : "Chicago J. Theor. Comput. Sci.,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1999
    }, {
      "title" : "Model checking and preprocessing",
      "author" : [ "Andrea Ferrara", "Paolo Liberatore", "Marco Schaerf" ],
      "venue" : "In AI*IA,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2007
    }, {
      "title" : "Treewidth in verification: Local vs. global",
      "author" : [ "Andrea Ferrara", "Guoqiang Pan", "Moshe Y. Vardi" ],
      "venue" : "In LPAR,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2005
    }, {
      "title" : "Strips: a new approach to the application of theorem proving to problem solving",
      "author" : [ "R. Fikes", "N. Nilson" ],
      "venue" : "Artificial Intelligence, 2:189–209,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1971
    }, {
      "title" : "Succinct representations of graphs",
      "author" : [ "Hana Galperin", "Avi Wigderson" ],
      "venue" : "Information and Control,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 1983
    }, {
      "title" : "Computers and Intractability: A Guide to the Theory of NP-Completeness",
      "author" : [ "M.R. Garey", "D.S. Johnson" ],
      "venue" : "W.H. Freeman and Company, San Francisco, Ca,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "Simple on-the-fly automatic verification of linear temporal logic",
      "author" : [ "R. Gerth", "D. Peled", "M.Y. Vardi", "P.Wolper" ],
      "venue" : "In Proceedings of the 13th Symposium on Protocol Specification, Testing and Verification,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 1995
    }, {
      "title" : "Succinctness as a source of complexity in logical formalisms",
      "author" : [ "Georg Gottlob", "Nicola Leone", "Helmut Veith" ],
      "venue" : "Ann. Pure Appl. Logic,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 1999
    }, {
      "title" : "The model checker spin",
      "author" : [ "G.J. Holzmann" ],
      "venue" : "IEEE Transactions on Software Engineering, 23(5):279–295,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "An automata theoretic approach to branching-time model checking",
      "author" : [ "O. Kupferman", "M.Y. Vardi", "P. Wolper" ],
      "venue" : "Journal of ACM, 47(2):312–360,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "An Introduction to Kolmogorov Complexity and Its Applications",
      "author" : [ "M. Li", "P. Vitanyi" ],
      "venue" : "Springer Verlag,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Monotonic reductions, representative equivalence, and compilation of intractable problems",
      "author" : [ "P. Liberatore" ],
      "venue" : "Journal of ACM, 48(6):1091–1125,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "On the complexity of case-based planning",
      "author" : [ "Paolo Liberatore" ],
      "venue" : "Technical Report cs.AI/0407034, Computing Research Repository (CoRR),",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2004
    }, {
      "title" : "The complexity of graph problems fore succinctly represented graphs",
      "author" : [ "Antoni Lozano", "José L. Balcázar" ],
      "venue" : "In WG,",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 1989
    }, {
      "title" : "Temporal Verification of Reactive Systems - Safety",
      "author" : [ "Z. Manna", "A. Pnueli" ],
      "venue" : "Springer Verlag,",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Symbolic Model Checking",
      "author" : [ "K.L. McMillan" ],
      "venue" : "Kluwer Academic,",
      "citeRegEx" : "43",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "A note on succinct representations of graphs",
      "author" : [ "Christos H. Papadimitriou", "Mihalis Yannakakis" ],
      "venue" : "Information and Control,",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 1986
    }, {
      "title" : "The temporal logic of programs",
      "author" : [ "A. Pnueli" ],
      "venue" : "Proceeding of the 18th IEEE Symposium on Foundations of Computer Science (FOCS’77), pages 46–57,",
      "citeRegEx" : "45",
      "shortCiteRegEx" : null,
      "year" : 1977
    }, {
      "title" : "The complexity of temporal logic model checking",
      "author" : [ "Ph. Schnoebelen" ],
      "venue" : "In Proceedings of the 4th Internationa Workshop in Advances in Modal Logic (AiML’02),",
      "citeRegEx" : "46",
      "shortCiteRegEx" : "46",
      "year" : 2002
    }, {
      "title" : "The complexity of propositional linear temporal logics",
      "author" : [ "A.P. Sistla", "E.M. Clarke" ],
      "venue" : "Journal of ACM, 32(3):733–749,",
      "citeRegEx" : "47",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "The polynomial-time hierarchy",
      "author" : [ "L.J. Stockmeyer" ],
      "venue" : "Theoretical Computer Science, 3:1–22,",
      "citeRegEx" : "48",
      "shortCiteRegEx" : null,
      "year" : 1976
    }, {
      "title" : "Succinct representations of counting problems",
      "author" : [ "Jacobo Torán" ],
      "venue" : "In AAECC, pages 415–426,",
      "citeRegEx" : "49",
      "shortCiteRegEx" : "49",
      "year" : 1988
    }, {
      "title" : "Succinct representation and leaf languages",
      "author" : [ "Helmut Veith" ],
      "venue" : "Electronic Colloquium on Computational Complexity (ECCC),",
      "citeRegEx" : "50",
      "shortCiteRegEx" : "50",
      "year" : 1995
    }, {
      "title" : "Languages represented by boolean formulas",
      "author" : [ "Helmut Veith" ],
      "venue" : "Inf. Process. Lett.,",
      "citeRegEx" : "51",
      "shortCiteRegEx" : "51",
      "year" : 1997
    }, {
      "title" : "Succinct representation, leaf languages, and projection reductions",
      "author" : [ "Helmut Veith" ],
      "venue" : "Inf. Comput.,",
      "citeRegEx" : "52",
      "shortCiteRegEx" : "52",
      "year" : 1998
    }, {
      "title" : "VIS User’s Manual",
      "author" : [ "T. Villa", "G. Swarny", "T. Shiple" ],
      "venue" : "VIS Group, http://vlsi.colorado.edu/∼vis/usrDoc.html,",
      "citeRegEx" : "53",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Combining decision diagrams and SAT procedures for efficient symbolic model checking",
      "author" : [ "P.F. Williams", "A. Biere", "E.M. Clarke", "A. Gupta" ],
      "venue" : "Proceedings of the 14th International Conference on Computer-Aided Verification (CAV 2000), volume 1855 of LNCS, pages 124–138. Springer,",
      "citeRegEx" : "54",
      "shortCiteRegEx" : null,
      "year" : 2000
    } ],
    "referenceMentions" : [ {
      "referenceID" : 19,
      "context" : "Temporal Logic Model Checking [20] is a verification method for discrete systems.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 4,
      "context" : "It is used, for example, for the verification of protocols and hardware circuits [5].",
      "startOffset" : 81,
      "endOffset" : 84
    }, {
      "referenceID" : 33,
      "context" : "The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 40,
      "context" : "The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 16,
      "context" : "The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 5,
      "context" : "The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].",
      "startOffset" : 98,
      "endOffset" : 101
    }, {
      "referenceID" : 7,
      "context" : "The most famous ones are SPIN [35] and SMV [43] (with its many incarnations: NuSMV [17], RuleBase [6]), VIS [8], and FormalCheck [34].",
      "startOffset" : 108,
      "endOffset" : 111
    }, {
      "referenceID" : 19,
      "context" : "Two temporal logics are mainly used to define the specification: CTL [20] and LTL [45].",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 42,
      "context" : "Two temporal logics are mainly used to define the specification: CTL [20] and LTL [45].",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 15,
      "context" : "Many tools allow to build the model separately from checking the formula [16, 53, 36].",
      "startOffset" : 73,
      "endOffset" : 85
    }, {
      "referenceID" : 50,
      "context" : "Many tools allow to build the model separately from checking the formula [16, 53, 36].",
      "startOffset" : 73,
      "endOffset" : 85
    }, {
      "referenceID" : 15,
      "context" : "Many tools allow populating a property database [16, 53, 36], i.",
      "startOffset" : 48,
      "endOffset" : 60
    }, {
      "referenceID" : 50,
      "context" : "Many tools allow populating a property database [16, 53, 36], i.",
      "startOffset" : 48,
      "endOffset" : 60
    }, {
      "referenceID" : 14,
      "context" : "The technical tool we use is the compilability theory [15, 39].",
      "startOffset" : 54,
      "endOffset" : 62
    }, {
      "referenceID" : 36,
      "context" : "The technical tool we use is the compilability theory [15, 39].",
      "startOffset" : 54,
      "endOffset" : 62
    }, {
      "referenceID" : 40,
      "context" : "Finally, we answer to a long-time standing question in Symbolic Model Checking [43, 11].",
      "startOffset" : 79,
      "endOffset" : 87
    }, {
      "referenceID" : 10,
      "context" : "Finally, we answer to a long-time standing question in Symbolic Model Checking [43, 11].",
      "startOffset" : 79,
      "endOffset" : 87
    }, {
      "referenceID" : 51,
      "context" : "It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2].",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 8,
      "context" : "It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2].",
      "startOffset" : 166,
      "endOffset" : 169
    }, {
      "referenceID" : 0,
      "context" : "It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2].",
      "startOffset" : 176,
      "endOffset" : 179
    }, {
      "referenceID" : 17,
      "context" : "It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2].",
      "startOffset" : 188,
      "endOffset" : 192
    }, {
      "referenceID" : 1,
      "context" : "It also holds for all decision diagrams representing integer-value functions whose evaluation problem is in the polynomial hierarchy, such as BEDs [54], BMD and *BMD [9], RBCs [1], MTBDDs [18], and ADDs [2].",
      "startOffset" : 203,
      "endOffset" : 206
    }, {
      "referenceID" : 44,
      "context" : "We follow the notation of [47, 46].",
      "startOffset" : 26,
      "endOffset" : 34
    }, {
      "referenceID" : 43,
      "context" : "We follow the notation of [47, 46].",
      "startOffset" : 26,
      "endOffset" : 34
    }, {
      "referenceID" : 19,
      "context" : "A Kripke structure can be seen as a transition system [20].",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 39,
      "context" : "Thus the global system is obtained by parallel composition of the transition systems representing its components and sharing some variables [42, 20]; using this approach, we can give results valid for all model checkers.",
      "startOffset" : 140,
      "endOffset" : 148
    }, {
      "referenceID" : 19,
      "context" : "Thus the global system is obtained by parallel composition of the transition systems representing its components and sharing some variables [42, 20]; using this approach, we can give results valid for all model checkers.",
      "startOffset" : 140,
      "endOffset" : 148
    }, {
      "referenceID" : 39,
      "context" : "The formal definition is as follows [42, 20].",
      "startOffset" : 36,
      "endOffset" : 44
    }, {
      "referenceID" : 19,
      "context" : "The formal definition is as follows [42, 20].",
      "startOffset" : 36,
      "endOffset" : 44
    }, {
      "referenceID" : 45,
      "context" : "3 Complexity and Compilability We assume that the reader knows the basic concepts of complexity theory [48, 31].",
      "startOffset" : 103,
      "endOffset" : 111
    }, {
      "referenceID" : 30,
      "context" : "3 Complexity and Compilability We assume that the reader knows the basic concepts of complexity theory [48, 31].",
      "startOffset" : 103,
      "endOffset" : 111
    }, {
      "referenceID" : 14,
      "context" : "The compilability classes [15] have to be used instead.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 14,
      "context" : "More details can be found in [15].",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 14,
      "context" : "Since the regular polynomial reductions are not appropriate when preprocessing is allowed, ad-hoc reductions (called nu-comp reductions in [15]) have been defined.",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 36,
      "context" : "Can we use this reduction to prove the ‖;C-hardness of B ? Liberatore [39] shows sufficient conditions that should hold on A as well as on the reduction.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 36,
      "context" : "The condition of representative equivalence can be proved to imply that the problem B is ‖;C-hard, if A is C-hard [39].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 28,
      "context" : "PLANSAT ∗ 1 is the following problem of planning: giving a STRIPS [29] instance y = 〈P,O, I,G〉 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT ∗ 1 is PSPACE-Complete [12].",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 11,
      "context" : "PLANSAT ∗ 1 is the following problem of planning: giving a STRIPS [29] instance y = 〈P,O, I,G〉 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT ∗ 1 is PSPACE-Complete [12].",
      "startOffset" : 242,
      "endOffset" : 246
    }, {
      "referenceID" : 14,
      "context" : "Given the limitation of space we cannot give the full definitions for compilability, for which the reader should refer to [15] for an introduction, to [14, 13] for an application to the succinctness of some formalisms, to [39] for further applications and technical advances.",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 13,
      "context" : "Given the limitation of space we cannot give the full definitions for compilability, for which the reader should refer to [15] for an introduction, to [14, 13] for an application to the succinctness of some formalisms, to [39] for further applications and technical advances.",
      "startOffset" : 151,
      "endOffset" : 159
    }, {
      "referenceID" : 12,
      "context" : "Given the limitation of space we cannot give the full definitions for compilability, for which the reader should refer to [15] for an introduction, to [14, 13] for an application to the succinctness of some formalisms, to [39] for further applications and technical advances.",
      "startOffset" : 151,
      "endOffset" : 159
    }, {
      "referenceID" : 36,
      "context" : "Given the limitation of space we cannot give the full definitions for compilability, for which the reader should refer to [15] for an introduction, to [14, 13] for an application to the succinctness of some formalisms, to [39] for further applications and technical advances.",
      "startOffset" : 222,
      "endOffset" : 226
    }, {
      "referenceID" : 34,
      "context" : "The Model Checking problem for concurrent transition systems is PSPACEcomplete [37].",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 40,
      "context" : "OBDDs) currently used in model checkers based on the Symbolic Model Checking algorithms [43] (such as SMV and NuSMV) cannot be avoided in general.",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 19,
      "context" : "We point out that most of Temporal Logic Model Checking algorithms [20] fall in one of three classes: Symbolic Model Checking algorithms, which work on symbolic representation of M ; algorithms based on Bounded Model Checking [7] (i.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 6,
      "context" : "We point out that most of Temporal Logic Model Checking algorithms [20] fall in one of three classes: Symbolic Model Checking algorithms, which work on symbolic representation of M ; algorithms based on Bounded Model Checking [7] (i.",
      "startOffset" : 226,
      "endOffset" : 229
    }, {
      "referenceID" : 31,
      "context" : "[32]).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "PLANSAT ∗ 1 is the following problem of planning: giving a STRIPS [29] instance y = 〈P,O, I,G〉 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT ∗ 1 is PSPACE-complete [12].",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 11,
      "context" : "PLANSAT ∗ 1 is the following problem of planning: giving a STRIPS [29] instance y = 〈P,O, I,G〉 in which the operators have an arbitrary number of preconditions and only one postcondition, is there a plan for y? PLANSAT ∗ 1 is PSPACE-complete [12].",
      "startOffset" : 242,
      "endOffset" : 246
    }, {
      "referenceID" : 37,
      "context" : "The hardness follows from a polynomial time reduction from the problem 〈(P,O,G), I〉, that can be easily shown ‖;PSPACE-complete on the basis of the results in [40].",
      "startOffset" : 159,
      "endOffset" : 163
    }, {
      "referenceID" : 14,
      "context" : "12 in [15], we conclude that there is no poly-size reduction from MCs0 to the evaluation problem for a BDD, if PSPACE 6⊆ Πp2 ∩ Σ p 2.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 51,
      "context" : "Instances of such data structures, currently used in Symbolic Model Checking tools, are BDDs, Boolean Expression Diagrams (BEDs) [54] and Reduced Boolean Circuits (RBCs) [1].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 0,
      "context" : "Instances of such data structures, currently used in Symbolic Model Checking tools, are BDDs, Boolean Expression Diagrams (BEDs) [54] and Reduced Boolean Circuits (RBCs) [1].",
      "startOffset" : 170,
      "endOffset" : 173
    }, {
      "referenceID" : 17,
      "context" : "Our results hold also for data structures used to represent integer-value functions, like Multi terminal binary decision diagrams (MTBDDs) [18], Algebraic Decision Diagrams (ADDs) [2]; see for details the survey [25].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 1,
      "context" : "Our results hold also for data structures used to represent integer-value functions, like Multi terminal binary decision diagrams (MTBDDs) [18], Algebraic Decision Diagrams (ADDs) [2]; see for details the survey [25].",
      "startOffset" : 180,
      "endOffset" : 183
    }, {
      "referenceID" : 24,
      "context" : "Our results hold also for data structures used to represent integer-value functions, like Multi terminal binary decision diagrams (MTBDDs) [18], Algebraic Decision Diagrams (ADDs) [2]; see for details the survey [25].",
      "startOffset" : 212,
      "endOffset" : 216
    }, {
      "referenceID" : 9,
      "context" : "integer multiplication [10]); some results concern the size growth of other decision diagrams [25] respect to particular problems.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 24,
      "context" : "integer multiplication [10]); some results concern the size growth of other decision diagrams [25] respect to particular problems.",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 23,
      "context" : "(a) the parametrized complexity [24] of a wide variety of model checking problems [23], analyzing the state explosion problem; (b) it has been shown that [28]: i.",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 22,
      "context" : "(a) the parametrized complexity [24] of a wide variety of model checking problems [23], analyzing the state explosion problem; (b) it has been shown that [28]: i.",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 27,
      "context" : "(a) the parametrized complexity [24] of a wide variety of model checking problems [23], analyzing the state explosion problem; (b) it has been shown that [28]: i.",
      "startOffset" : 154,
      "endOffset" : 158
    }, {
      "referenceID" : 26,
      "context" : "(c) the compilability of the model checking problem [27]: it remains PSPACE-complete even if a part of the input, either the implicit model or the formula, is preprocessed using any amount of time and storing the result of this prerpocesing step in a polynomial-sized data structure.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 18,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 25,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 29,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 41,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 2,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 38,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 3,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 46,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 47,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 48,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 49,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 32,
      "context" : "The state explosion problem can be partially explained by complexity theoretic results [19] ; in fact, problems (also whose inputs are graphs), usually increase their worst case complexity when the input is represented by BDD or other Boolean formalisms [26, 30, 44, 3, 41, 4, 49, 50, 51, 52, 33].",
      "startOffset" : 254,
      "endOffset" : 296
    }, {
      "referenceID" : 35,
      "context" : "classic information theoretic argument shows that only a small fraction of all finite Kripke structures can be exponentially compressed [38].",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 20,
      "context" : "succinctness of languages; for instance [21], in which succinctness of language for preferences are discussed, and [22] that presents results on the succinctness of several formalism, including BDDs and CNF.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 21,
      "context" : "succinctness of languages; for instance [21], in which succinctness of language for preferences are discussed, and [22] that presents results on the succinctness of several formalism, including BDDs and CNF.",
      "startOffset" : 115,
      "endOffset" : 119
    } ],
    "year" : 2010,
    "abstractText" : "Temporal Logic Model Checking is a verification method in which we describe a system, the model, and then we verify whether some properties, expressed in a temporal logic formula, hold in the system. It has many industrial applications. In order to improve performance, some tools allow preprocessing of the model, verifying on-line a set of properties reusing the same compiled model; we prove that the complexity of the Model Checking problem, without any preprocessing or preprocessing the model or the formula in a polynomial data structure, is the same. As a result preprocessing does not always exponentially improve performance. Symbolic Model Checking algorithms work by manipulating sets of states, and these sets are often represented by BDDs. It has been observed that the size of BDDs may grow exponentially as the model and formula increase in size. As a side result, we formally prove that a superpolynomial increase of the size of these BDDs is unavoidable in the worst case. While this exponential growth has been empirically observed, to the best of our knowledge it has never been proved so far in general terms. This result not only holds for all types of BDDs regardless of the variable ordering, but also for more powerful data structures, such as BEDs, RBCs, MTBDDs, and ADDs.",
    "creator" : "LaTeX with hyperref package"
  }
}