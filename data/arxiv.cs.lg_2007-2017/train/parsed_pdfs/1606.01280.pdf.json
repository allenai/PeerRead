{
  "name" : "1606.01280.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Dependency Parsing as Head Selection",
    "authors" : [ "Xingxing Zhang", "Jianpeng Cheng" ],
    "emails" : [ "x.zhang@ed.ac.uk,", "jianpeng.cheng@ed.ac.uk,", "mlap@inf.ed.ac.uk" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Dependency parsing plays an important role in many natural language applications, such as relation extraction (Fundel et al., 2007), machine translation (Carreras and Collins, 2009), and ontology construction (Snow et al., 2004). A dependency parser represents syntactic information as a set of headdependent relational arcs, typically constrained to be a tree structure. Practically all models proposed for dependency parsing in recent years can be described as graph-based (McDonald et al., 2005a) or transition-based (Yamada and Matsumoto, 2003; Nivre et al., 2006b).\nGraph-based dependency parsers are typically arc-factored, where the score of a tree is defined as the summation of the scores of all its arcs. An arc is scored with a set of local features and a linear model, the parameters of which can be effectively learned with online algorithms (Crammer and Singer, 2001; Crammer and Singer, 2003; Freund and Schapire, 1999; Collins, 2002). In order to efficiently find the best scoring tree during training and decoding, various maximization algorithms have been developed (Eisner, 1996; Eisner, 2000; McDonald et al., 2005b). In general, graph-based methods are optimized globally, using features of single arcs in order to make the learning and inference tractable. Transition-based algorithms factorize a tree into a set of parsing actions. At each transition state, the parser scores a candidate action conditioned on the state of the transition system and the parsing history, and greedily selects the highest-scoring action to execute. This score is typically obtained with a classifier based on non-local features defined over a rich history of parsing decisions (Yamada and Matsumoto, 2003; Zhang and Nivre, 2011).\nRegardless of the algorithm used, most wellknown dependency parsers, such as the MSTPaser (McDonald et al., 2005b) and the MaltPaser (Nivre et al., 2006a), rely on extensive feature engineering. Feature templates are typically manually designed and aim at capturing head-dependent relationships which are notoriously sparse and difficult to estimate. More recently, a few approaches (Chen and Manning, 2014; Pei et al., 2015; Kiperwasser and Goldberg, 2016) apply neural networks for learning dense feature representations. The learned features are subsequently used in a conventional graph- or transition-based parser, or better designed variants\nar X\niv :1\n60 6.\n01 28\n0v 1\n[ cs\n.C L\n] 3\nJ un\n2 01\n(Dyer et al., 2015). In this work, we propose a simple neural networkbased model which learns to select the head for each word in a sentence without enforcing tree structured output; as a result, no transition system or graph-based algorithm is needed during training. Our model which we call DENSE (as shorthand for Dependency Neural Selection) employs bidirectional recurrent neural networks to learn featural representations for words in a sentence. These features are subsequently used to predict the head of each word. We recast the task of dependency parsing as a classification problem with each headdependent decision being locally optimized. Although there is nothing inherent in the model to enforce tree-structured output, when tested on an English dataset, DENSE is able to generate trees for 95% of the sentences, 87% of which are projective. Since the model is decoupled from the underlying inference procedure, it can easily transfer between a projective and non-projective parser without much modification. Specifically, post-processing the output of DENSE with the Chu-Liu-Edmonds algorithm results in a non-projective parser; whereas post-processing the output with the Eisner algorithm yields a projective parser.\nWe evaluate our model on benchmark dependency parsing corpora, representing four languages (English, Chinese, Czech, and German) with varying degrees of non-projectivity. Despite the simplicity of our approach, experiments show that the resulting parsers are on par with or outperform the state of the art."
    }, {
      "heading" : "2 Related Work",
      "text" : "In this section we briefly review prior work on dependency parsing focusing on graph-based and transition-based models. We also discuss how our model relates to previously proposed neural network-based parsers.\nGraph-based Parsing Graph-based dependency parsers employ a model for scoring possible dependency graphs for a given sentence. The graphs are typically factored into their component arcs and the score of a tree is defined as the sum over all arcs. This factorization enables tractable search for the highest scoring graph structure. Dependency-tree parsing is commonly formulated as the search for the maximum spanning tree (MST) in a graph which\nyields efficient algorithms for both non-projective and projective dependency trees. For instance, the Chu-Liu-Edmonds algorithm (Chu and Liu, 1965; Edmonds, 1967; McDonald et al., 2005b) is often used to extract the MST in the case of non-projective trees, and the Eisner algorithm (Eisner, 1996; Eisner, 2000) in the case of projective trees. During training, weight parameters of the scoring function can be learned with margin-based algorithms (Crammer and Singer, 2001; Crammer and Singer, 2003) or the structured perceptron (Freund and Schapire, 1999; Collins, 2002). Beyond basic first-order models, the literature offers a few examples of higherorder models involving sibling and grand parent relations (Carreras, 2007; Koo et al., 2010; Zhang and McDonald, 2012). Although more expressive, such models render both training and inference more challenging.\nTransition-based Parsing As the term implies, transition-based parsers conceptualize the process of transforming a sentence into a dependency tree as a sequence of transitions. A transition system typically includes a stack for storing partially processed tokens, a buffer containing the remaining input, and a set of arcs containing all dependencies between tokens that have been added so far (Nivre, 2003; Nivre et al., 2006b). A dependency tree is constructed by manipulating the stack and buffer, and appending arcs with predetermined operations.\nIn an arc-standard system (Yamada and Matsumoto, 2003; Nivre, 2004), the transitions include a SHIFT operation which removes the first word in the buffer and pushes it onto the stack; a LEFT-ARC operation adds an arc from the word in the beginning of the buffer to the word on top of the stack; and a RIGHT-ARC operation adds an arc from the word on top of the stack to the word in the beginning of the buffer. During parsing, the transition from one configuration to the next is greedily scored with a linear classifier whose features are defined according to the stack and buffer. The above arc-standard system builds a projective dependency tree bottom up, with the assumption that an arc is only added when the dependent node has already found all its dependents. Extensions include the arc-eager system (Nivre, 2008) which always adds an arc at the earliest possible stage, a more elaborate (reduce) action space to handle non-projective parsing (Attardi, 2006), and the use of non-local training methods to\navoid greedy error propagation (Zhang and Clark, 2008; Huang and Sagae, 2010; Zhang and Nivre, 2011; Goldberg and Nivre, 2012).\nNeural Network-based Parsing Neural network representations have a long history in syntactic parsing (Mayberry and Miikkulainen., 1999; Henderson, 2004; Titov and Henderson, 2007). Recent work uses neural networks in lieu of the linear classifiers typically employed in conventional transitionor graph-based dependency parsers. For example, Chen and Manning (2014) use a feed forward neural network to learn features for a transition-based parser, whereas Pei et al. (2015) do the same for a graph-based parser. Lei et al. (2014) apply tensor decomposition to obtain word embeddings in their syntactic roles, which they subsequently use in a graph-based parser. Dyer et al. (2015) redesign components of a transition-based system where the the buffer, stack, and action sequences are modeled separately with stack long short-term memory networks. The hidden states of these LSTMs are concatenated and used as input features to a final transition classifier. Kiperwasser and Goldberg (2016) use a bi-directional LSTM to extract features for both a transition- and graph-based parser.\nCompared to previous work, we formalize dependency parsing as the task of finding for each word in a sentence its most probable head. Both head selection and the features it is based on are learned using neural networks. The model locally optimizes a set of head-dependent decisions without attempting to enforce any global consistency during training. As a result, DENSE predicts dependency arcs greedily following a simple training procedure without predicting a parse tree, i.e., without performing a sequence of transition actions or employing a graph algorithm during training. Nevertheless, it can be seamlessly integrated with a graph-based decoder to ensure tree-structured output. In common with recent neural network-based dependency parsers, we aim to alleviate the need for hand-crafting feature combinations. Beyond feature learning, we further show that it is possible to simplify inference and training with bi-directional recurrent neural networks."
    }, {
      "heading" : "3 Dependency Parsing as Head Selection",
      "text" : "In this section we present our parsing model, DENSE, which tries to predict the head of each word\nin a sentence. Specifically, the model takes as input a sentence of length N and outputs N 〈head, dependent〉 arcs. We describe the model focusing on unlabeled dependencies and then discuss how it can be straightforwardly extended to the labeled setting. We begin by explaining how words are represented in our model and then give details on how DENSE makes predictions based on these learned representations. Since there is no guarantee that the outputs of DENSE are trees (although they mostly are), we also discuss how to extend DENSE in order to enforce projective and non-projective tree outputs. Throughout this paper, lowercase boldface letters denote vectors (e.g., v or vi), uppercase boldface letters denote matrices (e.g., M or Mb), and lowercase letters denote scalars (e.g., w or wi)."
    }, {
      "heading" : "3.1 Word Representation",
      "text" : "Let S = (w0,w1, . . . ,wN) denote a sentence of length N; following common practice in the dependency parsing literature (Kubler et al., 2009), we add an artificial ROOT token represented by w0. Analogously, let A = (a0,a1, . . . ,aN) denote the representation of sentence S, with ai representing word wi (0 ≤ i ≤ N). Our model reads through the sentence and then produces a representation for each word based on the entire sentence. Besides encoding information about each wi in isolation (e.g., its lexical meaning or POS tag), ai must also encode wi’s positional information within the sentence. Such information has been previously shown to be important in dependency parsing (McDonald et\nal., 2005a). For example, in the following sentence:\nthe head of the first a is dog, whereas the head of the second a is cat. Without taking positional information into account, a model cannot easily decide which a (nearer or farther) to assign to dog. Long short-term memory networks (Hochreiter and Schmidhuber, 1997; LSTMs), a type of recurrent neural network with a more complex computational unit, have proven effective at capturing long-term dependencies. In our case LSTMs allow to represent each word on its own and within a sequence leveraging long-range contextual information.\nAs shown in Figure 1, we first use a forward LSTM (LSTMF ) to read the sentence from left to right and then a backward LSTM (LSTMB) to read the sentence from right to left, so that the entire sentence serves as context for each word:1\nhFi ,c F i = LSTM F(xi,hFi−1,c F i−1) (1)\nhBi ,c B i = LSTM B(xi,hBi+1,c B i+1) (2)\nwhere xi is the feature vector of word wi, hFi ∈ Rd and cFi ∈ Rd are the hidden states and memory cells for the ith word wi in LSTMF and d is the hidden unit size. hFi is also the representation for w0:i (wi and its left neighboring words) and cFi is an internal state maintained by LSTMF . hBi ∈ Rd and cBi ∈ Rd are the hidden states and memory cells for the backward LSTMB. Each token wi is additionally represented by xi, the concatenation of two vectors corresponding to wi’s lexical and POS tag embeddings:\nxi = [We · e(wi);Wt · e(ti)] (3)\nwhere e(wi) and e(ti) are one-hot vector representations of token wi and its POS tag ti; We ∈Rs×|V | and Wt ∈ Rq×|T | are the word and POS tag embedding matrices, where |V | is the vocabulary size, s is the word embedding size, |T | is the POS tag set size, and q the tag embedding size. The hidden states of the forward and backward LSTMs are concatenated to obtain ai, the final representation of wi:\nai = [hFi ;h B i ] i ∈ [0,N] (4)\n1For the details on LSTM networks, see e.g., Graves (2012) or Goldberg (2015)."
    }, {
      "heading" : "3.2 Head Selection",
      "text" : "We now move on to discuss our formalization of dependency parsing as head section. We first focus on unlabeled dependencies and then explain how the model can be extended to predict labeled ones.\nIn a dependency tree, a head can have multiple dependents, whereas a dependent can have only one head. Based on this fact, dependency parsing can be formalized as follows. Given a sentence S = (w0,w1, . . . ,wN), we aim to find for each word wi ∈ {w1,w2, . . . ,wn} the most probable head w j ∈ {w0,w1, . . . ,wN}. For example, in Figure 1, to find the head for the token love, we calculate probabilities Phead(ROOT|love,S), Phead(kids|love,S), and Phead(candy|love,S), and select the highest. More formally, we estimate the probability of token w j being the head of token wi as:\nPhead(w j|wi,S) = exp(g(a j,ai))\n∑Nk=0 exp(g(ak,ai)) (5)\nwhere ai and a j are vector-based representations of wi and w j, respectively (Section 3.1 describes how these are learned); g(a j,ai) is a neural network with a single hidden layer that computes the associative score between representations ai and a j:\ng(a j,ai) = v>a · tanh(Ua ·a j +Wa ·ai) (6)\nwhere va ∈R2d , Ua ∈R2d×2d , and Wa ∈R2d×2d are weight matrices of g. Note that the candidate head w j can be the ROOT; while the dependent wi cannot. Equations (5) and (6) compute the probability of adding an arc between two words, in a fashion similar to the neural attention mechanism in sequenceto-sequence models (Bahdanau et al., 2014).\nWe train our model by minimizing the negative log likelihood of the gold standard 〈head, dependent〉 arcs in all training sentences:\nJ(θ) =− 1 |T | ∑S∈T\nNS ∑ i=1 logPhead(h(wi)|wi,S) (7)\nwhere T is the training set, h(wi) is wi’s gold standard head2 within sentence S, and NS the number of words in S (excluding ROOT). During inference, for each word wi (i ∈ [1,NS]) in S, we greedily choose the most likely head w j ( j ∈ [0,NS]):\nw j = argmax w j: j∈[0,NS] Phead(w j|wi,S) (8)\n2Note that h(wi) can be ROOT.\nNote that the prediction for each word wi is made independently of the other words in the sentence.\nGiven our greedy inference method, there is no guarantee that the 〈head, dependent〉 arcs predicted for a sentence form a tree (maybe there are cycles). However, we empirically observed that most outputs during inference are indeed trees. For instance, on an English dataset, 95% of the arcs predicted on the development set are trees, and 87% of them are projective, whereas on a Chinese dataset, 87% of the arcs form trees, 73% of which are projective. This indicates that although the model does not explicitly model tree structure during training, it is able to figure out from the data (which consists of trees) that it should predict them.\nSo far we have focused on unlabeled dependencies, however it is relatively straightforward to extend DENSE to produce labeled dependencies. We basically train an additional classifier to predict labels for the arcs which have been already identified. The classifier takes as input features [ai;a j;xi;x j] representing properties of the arc 〈w j,wi〉. These consist of ai and a j, the LSTM-based representations for wi and w j (see Equation (4)), and their word and part-of-speech embeddings, xi and x j (see Equation (3)). Specifically, we use a trained DENSE model to go through the training corpus and generate features and corresponding dependency labels as training data. We employ a two-layer rectifier network (Glorot et al., 2011) for the classification task."
    }, {
      "heading" : "3.3 Maximum Spanning Tree Algorithms",
      "text" : "As mentioned earlier the greedy inference strategy may fail to produce well-formed trees. In this case, the output of DENSE can be adjusted with a maximum spanning tree algorithm. We use the Chu-LiuEdmonds algorithm (Chu and Liu, 1965; Edmonds, 1967) for building non-projective trees and the Eisner algorithm (Eisner, 1996) for projective ones.\nFollowing McDonald et al. (2005b), we view a sentence S = (w0 = ROOT,w1, . . . ,wN) as a graph GS = 〈VS,ES〉 with the sentence words and the dummy root symbol as vertices and a directed edge between every pair of distinct words and from the root symbol to every word. The directed graph GS is\ndefined as:\nVS = {w0 = ROOT,w1, . . . ,wN} ES = {〈i, j〉 : i 6= j,〈i, j〉 ∈ [0,N]× [1,N]}\ns(i, j) = Phead(wi|w j,S) 〈i, j〉 ∈ ES\nwhere s(i, j) is the weight of edge 〈i, j〉 and Phead(wi|w j,S) is known. The problem of dependency parsing now boils down to finding the tree with the highest score which is equivalent to finding a maximum spanning tree (MST) in GS (McDonald et al., 2005b).\nNon-projective Parsing To build a non-projective parser, we solve the MST problem with the Chu-LiuEdmonds algorithm (Chu and Liu, 1965; Edmonds, 1967). The algorithm selects for each vertex (excluding ROOT) the in-coming edge with the highest weight. If a tree results, it must be the maximum spanning tree and the algorithm terminates. Otherwise, there must be a cycle which the algorithm identifies, contracts into a single vertex and recalculates edge weights going into and out of the cycle. The greedy inference strategy described in Equation (8)) is essentially a sub-procedure in the ChuLiu-Edmonds algorithm with the algorithm terminating after the first iteration. In implementation, we only run the Chu-Liu-Edmonds algorithm through graphs with cycles, i.e., non-tree outputs.\nProjective Parsing For projective parsing, we solve the MST problem with the Eisner algorithm (Eisner, 1996). The time complexity of the Eisner algorithm is O(N3), while checking if a tree is projective can be done reasonably faster, with a O(N logN) algorithm. Therefore, we only apply the Eisner algorithm to the non-projective outputs of the greedy strategy. Finally, it should be noted that the training of our model does not rely on the Chu-LiuEdmonds or Eisner algorithm, or any other graphbased algorithm. MST algorithms are only used at test time to correct non-tree outputs which are in the minority; DENSE acquires underlying tree structure constraints from the data without an explicit learning algorithm."
    }, {
      "heading" : "4 Experiments",
      "text" : "We evaluated our parser in a projective and nonprojective setting. In the following, we describe the datasets we used and provide training details for our\nmodels. We also present comparisons against multiple previous systems and analyze the parser’s output."
    }, {
      "heading" : "4.1 Datasets",
      "text" : "In the projective setting, we assessed the performance of our parser on the English Penn Treebank (PTB) and the Chinese Treebank 5.1 (CTB). Our experimental setup closely follows Chen and Manning (2014) and Dyer et al. (2015).\nFor English, we adopted the Stanford basic dependencies (SD) representation (De Marneffe et al., 2006).3 We follow the standard splits of PTB, sections 2–21 were used for training, section 22 for development and section 23 for testing. POS tags were assigned using the Stanford tagger (Toutanova et al., 2003) with an accuracy of 97.3%. For Chinese, we follow the same split of CTB5 introduced in Zhang and Clark (2008). In particular, we used sections 001–815, 1001–1136 for training, sections 886–931, 1148–1151 for development and sections 816–885, 1137–1147 for testing. The original constituency trees in CTB were converted to dependency trees with the Penn2Malt tool.4 We used gold segmentation and gold POS tags as in Chen and Manning (2014) and Dyer et al. (2015).\nIn the non-projective setting, we assessed the performance of our parser on the Czech and German, the largest non-projective datasets released as part of the CoNLL 2006 multilingual dependency parsing shared task. Since there is no official development set in either dataset, we used the last 374/367 sentences in the Czech/German training set as development data.5 Projective statistics of the four datasets are summarized in Table 1.\n3Stanford basic dependencies (SD) representations were converted using Stanford parser v.3.3.0.\n4 http://stp.lingfil.uu.se/∼nivre/research/Penn2Malt.html 5We make the number of sentences in the development and\ntest sets comparable."
    }, {
      "heading" : "4.2 Training Details",
      "text" : "We trained our models on an Nvidia GPU card; training takes one to two hours. Model parameters were uniformly initialized in [−0.1,0.1]. We used Adam (Kingma and Ba, 2014) to optimize our models with hyper-parameters recommended by the authors (i.e., learning rate 0.001, first momentum coefficient 0.9, and second momentum coefficient 0.999). To alleviate the gradient exploding problem, we rescaled the gradient when its norm exceeded 5 (Pascanu et al., 2013). Dropout (Srivastava et al., 2014) was applied to our model with the strategy recommended in Zaremba et al. (2014). On all datasets, we used two-layer LSTMs and set d = s = 300, where d is the hidden unit size and s is the word embedding size.\nAs in previous neural dependency parsing work (Chen and Manning, 2014; Dyer et al., 2015), we used pre-trained word vectors to initialize our word embedding matrix We. For the PTB experiments, we used 300 dimensional pre-trained GloVe6 vectors (Pennington et al., 2014). For the CTB experiments, we trained 300 dimensional GloVe vectors on the Chinese Gigaword corpus which we segmented with the Stanford Chinese Segmenter (Tseng et al., 2005). For Czech and German, we did not use pretrained word vectors to initialize our word embedding matrix. We set the POS tag embedding size to q = 30 in the English experiments, q = 50 in the Chinese experiments and q = 40 in both Czech and German experiments."
    }, {
      "heading" : "4.3 Results",
      "text" : "For both English and Chinese experiments, we report unlabeled (UAS) and labeled attachment scores (LAS) on the development and test sets; following Chen and Manning (2014) punctuation is excluded from the evaluation.\nExperimental results on PTB are shown in Table 2. We compared our model with several recent papers following the same evaluation protocol and experimental settings. The first block in the table contains parsers which do not use neural networks. Bohnet10 (Bohnet, 2010), Martins13 (Martins et al., 2013), and Z&M14 (Zhang and McDonald, 2014) are graph based-parsers with different models or pruning strategies and their results are reported in Weiss et al. (2015). Z&N11 (Zhang and\n6http://nlp.stanford.edu/projects/glove/\nNivre, 2011) is a transition-based parser with nonlocal features and the result is also reported in Weiss et al. (2015).\nThe second block in Table 2 presents results obtained from neural network-based parsers. C&M14 (Chen and Manning, 2014) is a transition-based parser using features learned with a feed forward neural network. Although very fast, its performance is inferior compared to graph-based parsers or strong non-neural transition based parsers (e.g., Z&N11). Dyer15 (Dyer et al., 2015) uses (stack) LSTMs to model the states of the buffer, the stack, and the action sequence of a transition system. Weiss15 (Weiss et al., 2015) is another transition-based parser, however with a more elaborate training procedure. Features are learned with a neural network model similar to C&M14, but much larger with two layers. Then, the hidden states of the neural network are used to train a structured perceptron for better beam search decoding.\nUnlike all models above, DENSE does not use any kind of transition- or graph-based algorithm dur-\ning training and inference. Nonetheless, it obtains a UAS of 94.02%. Around 95% of the model’s outputs after inference are trees, 87% of which are projective. When we post-process the remaining 13% of non-projective outputs with the Eisner algorithm (DENSE+E), we obtain a slight improvement on UAS (94.10%). Kiperwasser and Goldberg (2016) use bidirectional LSTMs as features and feed them to a graph-based parser (K&G16 graph) and a transition-based parser (K&G16 trans), but obtain worse performance than our model. This suggests that a transition- or graph-based algorithm is of little value when training bidirectional LSTMs or may even prevent them to converge to a good solution.\nResults on CTB follow a similar pattern. As shown in Table 3, DENSE outperforms all previous neural and non-neural models (see the test set columns) on both UAS and LAS. Post-processing the output of the parser with the Eisner algorithm generally improves performance (by 0.21%; see last\nrow in Table 3). In Figure 2 we analyze the performance of our parser on sentences of different length. On both PTB and CTB, DENSE has an advantage on long sentences compared to C&M14 and and Dyer15. Finally, we report unlabeled sentence level exact match (UEM) in Table 4. Interestingly, even when using the greedy inference strategy, DENSE yields a UEM comparable to Dyer15 on PTB. Exact match results using labeled dependencies are similar, however we omit them due to lack of space.\nFor Czech and German, we closely follow the evaluation setup of CoNLL 2006. We report both UAS and LAS, although most previous work has focused on UAS. Our results are summarized in Table 5. We compare DENSE against three nonprojective graph-based dependency parsers: the MST parser (McDonald et al., 2005b), the Turbo parser (Martins et al., 2013), and the RBG parser (Lei et al., 2014). We show the performance of these parsers in the first order setting (e.g., MST-1st) and in higher order settings (e.g., Turbo-3rd). The results of MST-1st, MST-2nd, RBG-1st and RBG3rd are reported in Lei et al. (2014) and the results of Turbo-1st and Turbo-3rd are reported in Martins et al. (2013). We show results for our parser with greedy inference (see DENSE in the table) and when we use the Chu-Liu-Edmonds algorithm to postprocess non-tree outputs (DENSE+CLE).\nAs can been seen, DENSE outperforms all other\nfirst (and second) order parsers on both German and Czech. As in the projective experiments, we observe slight improvements on both UAS and LAS when using a MST algorithm. On German, DENSE is comparable with the best third-order parser (Turbo-3rd), while on Czech it lags behind Turbo-3rd and RBG-3rd. This is not surprising considering that DENSE is a first-order parser and only uses words and POS tags as features. Comparison systems use a plethora of hand-crafted features and more sophisticated high-order decoding algorithms.\nOur experimental results demonstrate that using a MST algorithm during inference can slightly improve the model’s performance. We further examined the extent to which the MST algorithm is necessary for producing dependency trees. Table 6 shows the percentage of trees before and after the application of the MST algorithm across the four languages. In the majority of cases DENSE outputs trees (ranging from 87.0% to 96.7%) and a significant proportion of them are projective (ranging from 65.5% to 86.6%). Therefore, only a small proportion of outputs (14.0% on average) need to be post-processed with the Eisner or Chu-Liu-Edmonds algorithm."
    }, {
      "heading" : "5 Conclusions",
      "text" : "In this work we presented DENSE, a neural dependency parser which we train without a transition system or graph-based algorithm. Experimental results show that DENSE achieves competitive performance across four different languages and can seamlessly transfer from a projective to a non-projective parser simply by changing the post-processing MST algorithm during inference. In the future, we would like to increase the coverage of our parser by using tri-training techniques (Li et al., 2014) and multitasking learning (Luong et al., 2015)."
    } ],
    "references" : [ {
      "title" : "Experiments with a multilanguage non-projective dependency parser",
      "author" : [ "Giuseppe Attardi" ],
      "venue" : "In Proceedings of CoNLL,",
      "citeRegEx" : "Attardi.,? \\Q2006\\E",
      "shortCiteRegEx" : "Attardi.",
      "year" : 2006
    }, {
      "title" : "Neural machine translation by jointly learning to align and translate",
      "author" : [ "Kyunghyun Cho", "Yoshua Bengio" ],
      "venue" : "arXiv preprint arXiv:1409.0473",
      "citeRegEx" : "Bahdanau et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Bahdanau et al\\.",
      "year" : 2014
    }, {
      "title" : "Top accuracy and fast dependency parsing is not a contradiction",
      "author" : [ "Bernd Bohnet" ],
      "venue" : "In Proceedings of COLING,",
      "citeRegEx" : "Bohnet.,? \\Q2010\\E",
      "shortCiteRegEx" : "Bohnet.",
      "year" : 2010
    }, {
      "title" : "Non-projective parsing for statistical machine translation",
      "author" : [ "Carreras", "Collins2009] Xavier Carreras", "Michael Collins" ],
      "venue" : "In Proceedings of the EMNLP,",
      "citeRegEx" : "Carreras et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Carreras et al\\.",
      "year" : 2009
    }, {
      "title" : "Experiments with a higher-order projective dependency parser",
      "author" : [ "Xavier Carreras" ],
      "venue" : "In Proceedings of the EMNLP,",
      "citeRegEx" : "Carreras.,? \\Q2007\\E",
      "shortCiteRegEx" : "Carreras.",
      "year" : 2007
    }, {
      "title" : "A fast and accurate dependency parser using neural networks",
      "author" : [ "Chen", "Manning2014] Danqi Chen", "Christopher D Manning" ],
      "venue" : "In Proceedings of the EMNLP,",
      "citeRegEx" : "Chen et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2014
    }, {
      "title" : "On shortest arborescence of a directed graph",
      "author" : [ "Chu", "Liu1965] Yoeng-Jin Chu", "Tseng-Hong Liu" ],
      "venue" : "Scientia Sinica,",
      "citeRegEx" : "Chu et al\\.,? \\Q1965\\E",
      "shortCiteRegEx" : "Chu et al\\.",
      "year" : 1965
    }, {
      "title" : "Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms",
      "author" : [ "Michael Collins" ],
      "venue" : "In Proceedings of the the EMNLP,",
      "citeRegEx" : "Collins.,? \\Q2002\\E",
      "shortCiteRegEx" : "Collins.",
      "year" : 2002
    }, {
      "title" : "On the algorithmic implementation of multiclass kernel-based vector machines",
      "author" : [ "Crammer", "Singer2001] Koby Crammer", "Yoram Singer" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "Crammer et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Crammer et al\\.",
      "year" : 2001
    }, {
      "title" : "Ultraconservative online algorithms for multiclass problems",
      "author" : [ "Crammer", "Singer2003] Koby Crammer", "Yoram Singer" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Crammer et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Crammer et al\\.",
      "year" : 2003
    }, {
      "title" : "Generating typed dependency parses from phrase structure parses",
      "author" : [ "Bill MacCartney", "Christopher D Manning" ],
      "venue" : "In Proceedings of LREC,",
      "citeRegEx" : "Marneffe et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Marneffe et al\\.",
      "year" : 2006
    }, {
      "title" : "Transition-based dependency parsing with stack long short-term memory",
      "author" : [ "Dyer et al.2015] Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A. Smith" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Dyer et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Dyer et al\\.",
      "year" : 2015
    }, {
      "title" : "Optimum branchings",
      "author" : [ "Jack Edmonds" ],
      "venue" : "Journal of Research of the National Bureau of Standards B,",
      "citeRegEx" : "Edmonds.,? \\Q1967\\E",
      "shortCiteRegEx" : "Edmonds.",
      "year" : 1967
    }, {
      "title" : "Three new probabilistic models for dependency parsing: An exploration",
      "author" : [ "Jason M Eisner" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Eisner.,? \\Q1996\\E",
      "shortCiteRegEx" : "Eisner.",
      "year" : 1996
    }, {
      "title" : "Bilexical grammars and their cubic-time parsing algorithms",
      "author" : [ "Jason Eisner" ],
      "venue" : "In Advances in probabilistic and other parsing technologies,",
      "citeRegEx" : "Eisner.,? \\Q2000\\E",
      "shortCiteRegEx" : "Eisner.",
      "year" : 2000
    }, {
      "title" : "Large margin classification using the perceptron algorithm",
      "author" : [ "Freund", "Schapire1999] Yoav Freund", "Robert E Schapire" ],
      "venue" : "Machine learning,",
      "citeRegEx" : "Freund et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Freund et al\\.",
      "year" : 1999
    }, {
      "title" : "Relation extraction using dependency parse trees",
      "author" : [ "Fundel et al.2007] Katrin Fundel", "Robert Küffner", "Ralf Zimmer" ],
      "venue" : null,
      "citeRegEx" : "Fundel et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Fundel et al\\.",
      "year" : 2007
    }, {
      "title" : "Deep sparse rectifier neural networks",
      "author" : [ "Glorot et al.2011] Xavier Glorot", "Antoine Bordes", "Yoshua Bengio" ],
      "venue" : "In International Conference on Artificial Intelligence and Statistics,",
      "citeRegEx" : "Glorot et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Glorot et al\\.",
      "year" : 2011
    }, {
      "title" : "A dynamic oracle for arc-eager dependency parsing",
      "author" : [ "Goldberg", "Nivre2012] Yoav Goldberg", "Joakim Nivre" ],
      "venue" : "In COLING,",
      "citeRegEx" : "Goldberg et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Goldberg et al\\.",
      "year" : 2012
    }, {
      "title" : "A primer on neural network models for natural language processing. CoRR, abs/1510.00726",
      "author" : [ "Yoav Goldberg" ],
      "venue" : null,
      "citeRegEx" : "Goldberg.,? \\Q2015\\E",
      "shortCiteRegEx" : "Goldberg.",
      "year" : 2015
    }, {
      "title" : "Supervised Sequence Labelling with Recurrent Neural Networks",
      "author" : [ "Alex Graves" ],
      "venue" : "Studies in Computational Intelligence. Springer",
      "citeRegEx" : "Graves.,? \\Q2012\\E",
      "shortCiteRegEx" : "Graves.",
      "year" : 2012
    }, {
      "title" : "Discriminative training of a neural network statistical parser",
      "author" : [ "James Henderson" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Henderson.,? \\Q2004\\E",
      "shortCiteRegEx" : "Henderson.",
      "year" : 2004
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Hochreiter", "Schmidhuber1997] Sepp Hochreiter", "Jürgen Schmidhuber" ],
      "venue" : "Neural computation,",
      "citeRegEx" : "Hochreiter et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Hochreiter et al\\.",
      "year" : 1997
    }, {
      "title" : "Dynamic programming for linear-time incremental parsing",
      "author" : [ "Huang", "Sagae2010] Liang Huang", "Kenji Sagae" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Huang et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Huang et al\\.",
      "year" : 2010
    }, {
      "title" : "Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980",
      "author" : [ "Kingma", "Ba2014] Diederik Kingma", "Jimmy Ba" ],
      "venue" : null,
      "citeRegEx" : "Kingma et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kingma et al\\.",
      "year" : 2014
    }, {
      "title" : "Simple and accurate dependency parsing using bidirectional LSTM feature representations. CoRR, abs/1603.04351",
      "author" : [ "Kiperwasser", "Yoav Goldberg" ],
      "venue" : null,
      "citeRegEx" : "Kiperwasser et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Kiperwasser et al\\.",
      "year" : 2016
    }, {
      "title" : "Dual decomposition for parsing with non-projective head automata",
      "author" : [ "Koo et al.2010] Terry Koo", "Alexander M Rush", "Michael Collins", "Tommi Jaakkola", "David Sontag" ],
      "venue" : "In Proceedings of the EMNLP,",
      "citeRegEx" : "Koo et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Koo et al\\.",
      "year" : 2010
    }, {
      "title" : "Dependency Parsing",
      "author" : [ "Kubler et al.2009] Sandra Kubler", "Ryan McDonald", "Joakim Nivre", "Graeme Hirst" ],
      "venue" : null,
      "citeRegEx" : "Kubler et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Kubler et al\\.",
      "year" : 2009
    }, {
      "title" : "Low-rank tensors for scoring dependency structures",
      "author" : [ "Lei et al.2014] Tao Lei", "Yuan Zhang", "Regina Barzilay", "Tommi Jaakkola" ],
      "venue" : "In Proceedings of the ACL",
      "citeRegEx" : "Lei et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Lei et al\\.",
      "year" : 2014
    }, {
      "title" : "Ambiguity-aware ensemble training for semi-supervised dependency parsing",
      "author" : [ "Li et al.2014] Zhenghua Li", "Min Zhang", "Wenliang Chen" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Li et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Li et al\\.",
      "year" : 2014
    }, {
      "title" : "Multi-task sequence to sequence learning",
      "author" : [ "Quoc V Le", "Ilya Sutskever", "Oriol Vinyals", "Lukasz Kaiser" ],
      "venue" : "arXiv preprint arXiv:1511.06114",
      "citeRegEx" : "Luong et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Luong et al\\.",
      "year" : 2015
    }, {
      "title" : "Turning on the turbo: Fast third-order non-projective turbo parsers",
      "author" : [ "Miguel Almeida", "Noah A. Smith" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Martins et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Martins et al\\.",
      "year" : 2013
    }, {
      "title" : "SardSrn: A neural network shift-reduce parser",
      "author" : [ "Mayberry", "Risto Miikkulainen" ],
      "venue" : "Proceedings of the IJCAI,",
      "citeRegEx" : "Mayberry et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Mayberry et al\\.",
      "year" : 1999
    }, {
      "title" : "Online largemargin training of dependency parsers",
      "author" : [ "Koby Crammer", "Fernando Pereira" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "McDonald et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "McDonald et al\\.",
      "year" : 2005
    }, {
      "title" : "Nonprojective dependency parsing using spanning tree algorithms",
      "author" : [ "Fernando Pereira", "Kiril Ribarov", "Jan Hajič" ],
      "venue" : "In Proceedings of the EMNLP,",
      "citeRegEx" : "McDonald et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "McDonald et al\\.",
      "year" : 2005
    }, {
      "title" : "Maltparser: A data-driven parsergenerator for dependency parsing",
      "author" : [ "Nivre et al.2006a] Joakim Nivre", "Johan Hall", "Jens Nilsson" ],
      "venue" : "In Proceedings of LREC,",
      "citeRegEx" : "Nivre et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Nivre et al\\.",
      "year" : 2006
    }, {
      "title" : "Labeled pseudo-projective dependency parsing with support vector machines",
      "author" : [ "Nivre et al.2006b] Joakim Nivre", "Johan Hall", "Jens Nilsson", "Gülşen Eryi?it", "Svetoslav Marinov" ],
      "venue" : "In Proceedings of CoNLL,",
      "citeRegEx" : "Nivre et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Nivre et al\\.",
      "year" : 2006
    }, {
      "title" : "An efficient algorithm for projective dependency parsing",
      "author" : [ "Joakim Nivre" ],
      "venue" : "In Proceedings of the IWPT. Citeseer",
      "citeRegEx" : "Nivre.,? \\Q2003\\E",
      "shortCiteRegEx" : "Nivre.",
      "year" : 2003
    }, {
      "title" : "Incrementality in deterministic dependency parsing",
      "author" : [ "Joakim Nivre" ],
      "venue" : "In Proceedings of the Workshop on Incremental Parsing: Bringing Engineering and Cognition Together,",
      "citeRegEx" : "Nivre.,? \\Q2004\\E",
      "shortCiteRegEx" : "Nivre.",
      "year" : 2004
    }, {
      "title" : "Algorithms for deterministic incremental dependency parsing",
      "author" : [ "Joakim Nivre" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Nivre.,? \\Q2008\\E",
      "shortCiteRegEx" : "Nivre.",
      "year" : 2008
    }, {
      "title" : "On the difficulty of training recurrent neural networks",
      "author" : [ "Tomas Mikolov", "Yoshua Bengio" ],
      "venue" : "In Proceedings of ICML,",
      "citeRegEx" : "Pascanu et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Pascanu et al\\.",
      "year" : 2013
    }, {
      "title" : "An effective neural network model for graphbased dependency parsing",
      "author" : [ "Pei et al.2015] Wenzhe Pei", "Tao Ge", "Baobao Chang" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Pei et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Pei et al\\.",
      "year" : 2015
    }, {
      "title" : "Glove: Global vectors for word representation",
      "author" : [ "Richard Socher", "Christopher D Manning" ],
      "venue" : "In Proceedings of the EMNLP,",
      "citeRegEx" : "Pennington et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Pennington et al\\.",
      "year" : 2014
    }, {
      "title" : "Learning syntactic patterns for automatic hypernym discovery",
      "author" : [ "Snow et al.2004] Rion Snow", "Daniel Jurafsky", "Andrew Y Ng" ],
      "venue" : "In Proceedings of COLING and ACL,",
      "citeRegEx" : "Snow et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Snow et al\\.",
      "year" : 2004
    }, {
      "title" : "Dropout: A simple way to prevent neural networks from overfitting",
      "author" : [ "Geoffrey Hinton", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "Srivastava et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Srivastava et al\\.",
      "year" : 2014
    }, {
      "title" : "Constituent parsing with incremental sigmoid belief networks",
      "author" : [ "Titov", "Henderson2007] Ivan Titov", "James Henderson" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Titov et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Titov et al\\.",
      "year" : 2007
    }, {
      "title" : "Feature-rich part-of-speech tagging with a cyclic dependency network",
      "author" : [ "Dan Klein", "Christopher D Manning", "Yoram Singer" ],
      "venue" : "In Proceedings of the NAACLHLT,",
      "citeRegEx" : "Toutanova et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Toutanova et al\\.",
      "year" : 2003
    }, {
      "title" : "A conditional random field word segmenter for sighan bakeoff",
      "author" : [ "Tseng et al.2005] Huihsin Tseng", "Pichuan Chang", "Galen Andrew", "Daniel Jurafsky", "Christopher Manning" ],
      "venue" : "In Proceedings of the fourth SIGHAN workshop on Chinese language Processing,",
      "citeRegEx" : "Tseng et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Tseng et al\\.",
      "year" : 2005
    }, {
      "title" : "Structured training for neural network transition-based parsing",
      "author" : [ "Weiss et al.2015] David Weiss", "Chris Alberti", "Michael Collins", "Slav Petrov" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Weiss et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Weiss et al\\.",
      "year" : 2015
    }, {
      "title" : "Statistical dependency analysis with support vector machines",
      "author" : [ "Yamada", "Matsumoto2003] Hiroyasu Yamada", "Yuji Matsumoto" ],
      "venue" : "In Proceedings of IWPT,",
      "citeRegEx" : "Yamada et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Yamada et al\\.",
      "year" : 2003
    }, {
      "title" : "Recurrent neural network regularization",
      "author" : [ "Ilya Sutskever", "Oriol Vinyals" ],
      "venue" : "arXiv preprint arXiv:1409.2329",
      "citeRegEx" : "Zaremba et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Zaremba et al\\.",
      "year" : 2014
    }, {
      "title" : "A tale of two parsers: investigating and combining graph-based and transition-based dependency parsing using beam-search",
      "author" : [ "Zhang", "Clark2008] Yue Zhang", "Stephen Clark" ],
      "venue" : "In Proceedings of the EMNLP,",
      "citeRegEx" : "Zhang et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2008
    }, {
      "title" : "Generalized higher-order dependency parsing with cube pruning",
      "author" : [ "Zhang", "McDonald2012] Hao Zhang", "Ryan McDonald" ],
      "venue" : "In Proceedings of the EMNLP,",
      "citeRegEx" : "Zhang et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2012
    }, {
      "title" : "Enforcing structural diversity in cubepruned dependency parsing",
      "author" : [ "Zhang", "McDonald2014] Hao Zhang", "Ryan McDonald" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Zhang et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2014
    }, {
      "title" : "Transition-based dependency parsing with rich non-local features",
      "author" : [ "Zhang", "Nivre2011] Yue Zhang", "Joakim Nivre" ],
      "venue" : "In Proceedings of the ACL,",
      "citeRegEx" : "Zhang et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 16,
      "context" : "Dependency parsing plays an important role in many natural language applications, such as relation extraction (Fundel et al., 2007), machine translation (Carreras and Collins, 2009), and ontology construction (Snow et al.",
      "startOffset" : 110,
      "endOffset" : 131
    }, {
      "referenceID" : 43,
      "context" : ", 2007), machine translation (Carreras and Collins, 2009), and ontology construction (Snow et al., 2004).",
      "startOffset" : 85,
      "endOffset" : 104
    }, {
      "referenceID" : 7,
      "context" : "An arc is scored with a set of local features and a linear model, the parameters of which can be effectively learned with online algorithms (Crammer and Singer, 2001; Crammer and Singer, 2003; Freund and Schapire, 1999; Collins, 2002).",
      "startOffset" : 140,
      "endOffset" : 234
    }, {
      "referenceID" : 13,
      "context" : "In order to efficiently find the best scoring tree during training and decoding, various maximization algorithms have been developed (Eisner, 1996; Eisner, 2000; McDonald et al., 2005b).",
      "startOffset" : 133,
      "endOffset" : 185
    }, {
      "referenceID" : 14,
      "context" : "In order to efficiently find the best scoring tree during training and decoding, various maximization algorithms have been developed (Eisner, 1996; Eisner, 2000; McDonald et al., 2005b).",
      "startOffset" : 133,
      "endOffset" : 185
    }, {
      "referenceID" : 41,
      "context" : "More recently, a few approaches (Chen and Manning, 2014; Pei et al., 2015; Kiperwasser and Goldberg, 2016) apply neural networks for learning dense feature representations.",
      "startOffset" : 32,
      "endOffset" : 106
    }, {
      "referenceID" : 11,
      "context" : "(Dyer et al., 2015).",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 12,
      "context" : "For instance, the Chu-Liu-Edmonds algorithm (Chu and Liu, 1965; Edmonds, 1967; McDonald et al., 2005b) is often used to extract the MST in the case of non-projective trees, and the Eisner algorithm (Eisner, 1996; Eisner, 2000) in the case of projective trees.",
      "startOffset" : 44,
      "endOffset" : 102
    }, {
      "referenceID" : 13,
      "context" : ", 2005b) is often used to extract the MST in the case of non-projective trees, and the Eisner algorithm (Eisner, 1996; Eisner, 2000) in the case of projective trees.",
      "startOffset" : 104,
      "endOffset" : 132
    }, {
      "referenceID" : 14,
      "context" : ", 2005b) is often used to extract the MST in the case of non-projective trees, and the Eisner algorithm (Eisner, 1996; Eisner, 2000) in the case of projective trees.",
      "startOffset" : 104,
      "endOffset" : 132
    }, {
      "referenceID" : 7,
      "context" : "During training, weight parameters of the scoring function can be learned with margin-based algorithms (Crammer and Singer, 2001; Crammer and Singer, 2003) or the structured perceptron (Freund and Schapire, 1999; Collins, 2002).",
      "startOffset" : 185,
      "endOffset" : 227
    }, {
      "referenceID" : 4,
      "context" : "Beyond basic first-order models, the literature offers a few examples of higherorder models involving sibling and grand parent relations (Carreras, 2007; Koo et al., 2010; Zhang and McDonald, 2012).",
      "startOffset" : 137,
      "endOffset" : 197
    }, {
      "referenceID" : 26,
      "context" : "Beyond basic first-order models, the literature offers a few examples of higherorder models involving sibling and grand parent relations (Carreras, 2007; Koo et al., 2010; Zhang and McDonald, 2012).",
      "startOffset" : 137,
      "endOffset" : 197
    }, {
      "referenceID" : 37,
      "context" : "A transition system typically includes a stack for storing partially processed tokens, a buffer containing the remaining input, and a set of arcs containing all dependencies between tokens that have been added so far (Nivre, 2003; Nivre et al., 2006b).",
      "startOffset" : 217,
      "endOffset" : 251
    }, {
      "referenceID" : 38,
      "context" : "In an arc-standard system (Yamada and Matsumoto, 2003; Nivre, 2004), the transitions include a SHIFT operation which removes the first word in the buffer and pushes it onto the stack; a LEFT-ARC operation adds an arc from the word in the beginning of the buffer to the word on top of the stack; and a RIGHT-ARC operation adds an arc from the word on top of the stack to the word in the beginning of the buffer.",
      "startOffset" : 26,
      "endOffset" : 67
    }, {
      "referenceID" : 39,
      "context" : "Extensions include the arc-eager system (Nivre, 2008) which always adds an arc at the earliest possible stage, a more elaborate (reduce) action space to handle non-projective parsing (Attardi, 2006), and the use of non-local training methods to",
      "startOffset" : 40,
      "endOffset" : 53
    }, {
      "referenceID" : 0,
      "context" : "Extensions include the arc-eager system (Nivre, 2008) which always adds an arc at the earliest possible stage, a more elaborate (reduce) action space to handle non-projective parsing (Attardi, 2006), and the use of non-local training methods to",
      "startOffset" : 183,
      "endOffset" : 198
    }, {
      "referenceID" : 21,
      "context" : "Neural Network-based Parsing Neural network representations have a long history in syntactic parsing (Mayberry and Miikkulainen., 1999; Henderson, 2004; Titov and Henderson, 2007).",
      "startOffset" : 101,
      "endOffset" : 179
    }, {
      "referenceID" : 19,
      "context" : ", 1999; Henderson, 2004; Titov and Henderson, 2007). Recent work uses neural networks in lieu of the linear classifiers typically employed in conventional transitionor graph-based dependency parsers. For example, Chen and Manning (2014) use a feed forward neural network to learn features for a transition-based parser, whereas Pei et al.",
      "startOffset" : 8,
      "endOffset" : 237
    }, {
      "referenceID" : 19,
      "context" : ", 1999; Henderson, 2004; Titov and Henderson, 2007). Recent work uses neural networks in lieu of the linear classifiers typically employed in conventional transitionor graph-based dependency parsers. For example, Chen and Manning (2014) use a feed forward neural network to learn features for a transition-based parser, whereas Pei et al. (2015) do the same for a graph-based parser.",
      "startOffset" : 8,
      "endOffset" : 346
    }, {
      "referenceID" : 19,
      "context" : ", 1999; Henderson, 2004; Titov and Henderson, 2007). Recent work uses neural networks in lieu of the linear classifiers typically employed in conventional transitionor graph-based dependency parsers. For example, Chen and Manning (2014) use a feed forward neural network to learn features for a transition-based parser, whereas Pei et al. (2015) do the same for a graph-based parser. Lei et al. (2014) apply tensor decomposition to obtain word embeddings in their syntactic roles, which they subsequently use in a graph-based parser.",
      "startOffset" : 8,
      "endOffset" : 402
    }, {
      "referenceID" : 11,
      "context" : "Dyer et al. (2015) redesign components of a transition-based system where the the buffer, stack, and action sequences are modeled separately with stack long short-term memory networks.",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 11,
      "context" : "Dyer et al. (2015) redesign components of a transition-based system where the the buffer, stack, and action sequences are modeled separately with stack long short-term memory networks. The hidden states of these LSTMs are concatenated and used as input features to a final transition classifier. Kiperwasser and Goldberg (2016) use a bi-directional LSTM to extract features for both a transition- and graph-based parser.",
      "startOffset" : 0,
      "endOffset" : 328
    }, {
      "referenceID" : 27,
      "context" : ",wN) denote a sentence of length N; following common practice in the dependency parsing literature (Kubler et al., 2009), we add an artificial ROOT token represented by w0.",
      "startOffset" : 99,
      "endOffset" : 120
    }, {
      "referenceID" : 19,
      "context" : ", Graves (2012) or Goldberg (2015).",
      "startOffset" : 2,
      "endOffset" : 16
    }, {
      "referenceID" : 19,
      "context" : ", Graves (2012) or Goldberg (2015). 3.",
      "startOffset" : 19,
      "endOffset" : 35
    }, {
      "referenceID" : 1,
      "context" : "Equations (5) and (6) compute the probability of adding an arc between two words, in a fashion similar to the neural attention mechanism in sequenceto-sequence models (Bahdanau et al., 2014).",
      "startOffset" : 167,
      "endOffset" : 190
    }, {
      "referenceID" : 17,
      "context" : "We employ a two-layer rectifier network (Glorot et al., 2011) for the classification task.",
      "startOffset" : 40,
      "endOffset" : 61
    }, {
      "referenceID" : 12,
      "context" : "We use the Chu-LiuEdmonds algorithm (Chu and Liu, 1965; Edmonds, 1967) for building non-projective trees and the Eisner algorithm (Eisner, 1996) for projective ones.",
      "startOffset" : 36,
      "endOffset" : 70
    }, {
      "referenceID" : 13,
      "context" : "We use the Chu-LiuEdmonds algorithm (Chu and Liu, 1965; Edmonds, 1967) for building non-projective trees and the Eisner algorithm (Eisner, 1996) for projective ones.",
      "startOffset" : 130,
      "endOffset" : 144
    }, {
      "referenceID" : 33,
      "context" : "Following McDonald et al. (2005b), we view a sentence S = (w0 = ROOT,w1, .",
      "startOffset" : 10,
      "endOffset" : 34
    }, {
      "referenceID" : 12,
      "context" : "Non-projective Parsing To build a non-projective parser, we solve the MST problem with the Chu-LiuEdmonds algorithm (Chu and Liu, 1965; Edmonds, 1967).",
      "startOffset" : 116,
      "endOffset" : 150
    }, {
      "referenceID" : 13,
      "context" : "Projective Parsing For projective parsing, we solve the MST problem with the Eisner algorithm (Eisner, 1996).",
      "startOffset" : 94,
      "endOffset" : 108
    }, {
      "referenceID" : 11,
      "context" : "Our experimental setup closely follows Chen and Manning (2014) and Dyer et al. (2015).",
      "startOffset" : 67,
      "endOffset" : 86
    }, {
      "referenceID" : 46,
      "context" : "POS tags were assigned using the Stanford tagger (Toutanova et al., 2003) with an accuracy of 97.",
      "startOffset" : 49,
      "endOffset" : 73
    }, {
      "referenceID" : 10,
      "context" : "For English, we adopted the Stanford basic dependencies (SD) representation (De Marneffe et al., 2006).3 We follow the standard splits of PTB, sections 2–21 were used for training, section 22 for development and section 23 for testing. POS tags were assigned using the Stanford tagger (Toutanova et al., 2003) with an accuracy of 97.3%. For Chinese, we follow the same split of CTB5 introduced in Zhang and Clark (2008). In particular, we used sections 001–815, 1001–1136 for training, sections 886–931, 1148–1151 for development and sections 816–885, 1137–1147 for testing.",
      "startOffset" : 80,
      "endOffset" : 420
    }, {
      "referenceID" : 10,
      "context" : "For English, we adopted the Stanford basic dependencies (SD) representation (De Marneffe et al., 2006).3 We follow the standard splits of PTB, sections 2–21 were used for training, section 22 for development and section 23 for testing. POS tags were assigned using the Stanford tagger (Toutanova et al., 2003) with an accuracy of 97.3%. For Chinese, we follow the same split of CTB5 introduced in Zhang and Clark (2008). In particular, we used sections 001–815, 1001–1136 for training, sections 886–931, 1148–1151 for development and sections 816–885, 1137–1147 for testing. The original constituency trees in CTB were converted to dependency trees with the Penn2Malt tool.4 We used gold segmentation and gold POS tags as in Chen and Manning (2014) and Dyer et al.",
      "startOffset" : 80,
      "endOffset" : 749
    }, {
      "referenceID" : 10,
      "context" : "For English, we adopted the Stanford basic dependencies (SD) representation (De Marneffe et al., 2006).3 We follow the standard splits of PTB, sections 2–21 were used for training, section 22 for development and section 23 for testing. POS tags were assigned using the Stanford tagger (Toutanova et al., 2003) with an accuracy of 97.3%. For Chinese, we follow the same split of CTB5 introduced in Zhang and Clark (2008). In particular, we used sections 001–815, 1001–1136 for training, sections 886–931, 1148–1151 for development and sections 816–885, 1137–1147 for testing. The original constituency trees in CTB were converted to dependency trees with the Penn2Malt tool.4 We used gold segmentation and gold POS tags as in Chen and Manning (2014) and Dyer et al. (2015).",
      "startOffset" : 80,
      "endOffset" : 772
    }, {
      "referenceID" : 40,
      "context" : "To alleviate the gradient exploding problem, we rescaled the gradient when its norm exceeded 5 (Pascanu et al., 2013).",
      "startOffset" : 95,
      "endOffset" : 117
    }, {
      "referenceID" : 44,
      "context" : "Dropout (Srivastava et al., 2014) was applied to our model with the strategy recommended in Zaremba et al.",
      "startOffset" : 8,
      "endOffset" : 33
    }, {
      "referenceID" : 40,
      "context" : "To alleviate the gradient exploding problem, we rescaled the gradient when its norm exceeded 5 (Pascanu et al., 2013). Dropout (Srivastava et al., 2014) was applied to our model with the strategy recommended in Zaremba et al. (2014). On all datasets, we used two-layer LSTMs and set d = s = 300, where d is the hidden unit size and s is the word embedding size.",
      "startOffset" : 96,
      "endOffset" : 233
    }, {
      "referenceID" : 11,
      "context" : "As in previous neural dependency parsing work (Chen and Manning, 2014; Dyer et al., 2015), we used pre-trained word vectors to initialize our word embedding matrix We.",
      "startOffset" : 46,
      "endOffset" : 89
    }, {
      "referenceID" : 42,
      "context" : "For the PTB experiments, we used 300 dimensional pre-trained GloVe6 vectors (Pennington et al., 2014).",
      "startOffset" : 76,
      "endOffset" : 101
    }, {
      "referenceID" : 47,
      "context" : "For the CTB experiments, we trained 300 dimensional GloVe vectors on the Chinese Gigaword corpus which we segmented with the Stanford Chinese Segmenter (Tseng et al., 2005).",
      "startOffset" : 152,
      "endOffset" : 172
    }, {
      "referenceID" : 2,
      "context" : "Bohnet10 (Bohnet, 2010), Martins13 (Martins et al.",
      "startOffset" : 9,
      "endOffset" : 23
    }, {
      "referenceID" : 31,
      "context" : "Bohnet10 (Bohnet, 2010), Martins13 (Martins et al., 2013), and Z&M14 (Zhang and McDonald, 2014) are graph based-parsers with different models or pruning strategies and their results are reported in Weiss et al.",
      "startOffset" : 35,
      "endOffset" : 57
    }, {
      "referenceID" : 2,
      "context" : "Bohnet10 (Bohnet, 2010), Martins13 (Martins et al., 2013), and Z&M14 (Zhang and McDonald, 2014) are graph based-parsers with different models or pruning strategies and their results are reported in Weiss et al. (2015). Z&N11 (Zhang and",
      "startOffset" : 0,
      "endOffset" : 218
    }, {
      "referenceID" : 11,
      "context" : "Dyer15 (Dyer et al., 2015) uses (stack) LSTMs to model the states of the buffer, the stack, and the action sequence of a transition system.",
      "startOffset" : 7,
      "endOffset" : 26
    }, {
      "referenceID" : 48,
      "context" : "Weiss15 (Weiss et al., 2015) is another transition-based parser, however with a more elaborate training procedure.",
      "startOffset" : 8,
      "endOffset" : 28
    }, {
      "referenceID" : 13,
      "context" : "When we post-process the remaining 13% of non-projective outputs with the Eisner algorithm (DENSE+E), we obtain a slight improvement on UAS (94.10%). Kiperwasser and Goldberg (2016) use bidirectional LSTMs as features and feed them to a graph-based parser (K&G16 graph) and a transition-based parser (K&G16 trans), but obtain worse performance than our model.",
      "startOffset" : 74,
      "endOffset" : 182
    }, {
      "referenceID" : 31,
      "context" : ", 2005b), the Turbo parser (Martins et al., 2013), and the RBG parser (Lei et al.",
      "startOffset" : 27,
      "endOffset" : 49
    }, {
      "referenceID" : 28,
      "context" : ", 2013), and the RBG parser (Lei et al., 2014).",
      "startOffset" : 28,
      "endOffset" : 46
    }, {
      "referenceID" : 27,
      "context" : ", 2013), and the RBG parser (Lei et al., 2014). We show the performance of these parsers in the first order setting (e.g., MST-1st) and in higher order settings (e.g., Turbo-3rd). The results of MST-1st, MST-2nd, RBG-1st and RBG3rd are reported in Lei et al. (2014) and the results of Turbo-1st and Turbo-3rd are reported in Martins et al.",
      "startOffset" : 29,
      "endOffset" : 266
    }, {
      "referenceID" : 27,
      "context" : ", 2013), and the RBG parser (Lei et al., 2014). We show the performance of these parsers in the first order setting (e.g., MST-1st) and in higher order settings (e.g., Turbo-3rd). The results of MST-1st, MST-2nd, RBG-1st and RBG3rd are reported in Lei et al. (2014) and the results of Turbo-1st and Turbo-3rd are reported in Martins et al. (2013). We show results for our parser with greedy inference (see DENSE in the table) and when we use the Chu-Liu-Edmonds algorithm to postprocess non-tree outputs (DENSE+CLE).",
      "startOffset" : 29,
      "endOffset" : 347
    }, {
      "referenceID" : 29,
      "context" : "In the future, we would like to increase the coverage of our parser by using tri-training techniques (Li et al., 2014) and multitasking learning (Luong et al.",
      "startOffset" : 101,
      "endOffset" : 118
    }, {
      "referenceID" : 30,
      "context" : ", 2014) and multitasking learning (Luong et al., 2015).",
      "startOffset" : 34,
      "endOffset" : 54
    } ],
    "year" : 2017,
    "abstractText" : "Conventional dependency parsers rely on a statistical model and a transition system or graph algorithm to enforce tree-structured outputs during training and inference. In this work we formalize dependency parsing as the problem of selecting the head (a.k.a. parent) of each word in a sentence. Our model which we call DENSE (as shorthand for Dependency Neural Selection) employs bidirectional recurrent neural networks for the head selection task. Without enforcing any structural constraints during training, DENSE generates (at inference time) trees for the overwhelming majority of sentences (95% on an English dataset), while remaining non-tree outputs can be adjusted with a maximum spanning tree algorithm. We evaluate DENSE on four languages (English, Chinese, Czech, and German) with varying degrees of non-projectivity. Despite the simplicity of our approach, experiments show that the resulting parsers are on par with or outperform the state of the art.",
    "creator" : "LaTeX with hyperref package"
  }
}