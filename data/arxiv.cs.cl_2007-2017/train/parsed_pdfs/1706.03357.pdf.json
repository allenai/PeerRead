{
  "name" : "1706.03357.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Generic Axiomatization of Families of Noncrossing Graphs in Dependency Parsing",
    "authors" : [ "Anssi Yli-Jyrä", "Carlos Gómez-Rodrı́guez" ],
    "emails" : [ "anssi.yli-jyra@helsinki.fi", "carlos.gomez@udc.es" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Dependency parsing has received wide attention in recent years, as accurate and efficient dependency parsers have appeared that are applicable to many languages. Traditionally, dependency parsers have produced syntactic analyses in tree form, including exact inference algorithms that search for maximum projective trees (Eisner and Satta, 1999) and maximum spanning trees (McDonald et al., 2005) in weighted digraphs, as well as greedy and beamsearch approaches that forgo exact search for extra efficiency (Zhang and Nivre, 2011).\nRecently, there has been growing interest in providing a richer analysis of natural language by going beyond trees. In semantic dependency parsing (Oepen et al., 2015; Kuhlmann and Oepen, 2016), the desired syntactic representations can have indegree greater than 1 (re-entrancy), suggesting the search for maximum acyclic subgraphs (Schluter, 2014, 2015). As this inference task is intractable (Guruswami et al., 2011), noncrossing digraphs have been studied instead, e.g. by Kuhlmann and Johnsson (2015) who provide a O(n3) parser for maximum noncrossing acyclic subgraphs.\nYli-Jyrä (2005) studied how to axiomatize dependency trees as a special case of noncrossing digraphs. This gave rise to a new homomorphic representation of context-free languages that proves the classical Chomsky and Schützenberger theorem using a quite different internal language. In this language, the brackets indicate arcs in a dependency tree in a way that is reminiscent to encoding schemes used earlier by Greibach (1973) and Oflazer (2003). Cubic-time parsing algorithms that are incidentally or intentionally applicable to this kind of homomorphic representations have been considered, e.g., by Nederhof and Satta (2003), Hulden (2011), and Yli-Jyrä (2012).\nExtending these insights to arbitrary noncrossing digraphs, or to relevant families of them, is far from obvious. In this paper, we develop (1) a linear encoding supporting general noncrossing digraphs, and (2) show that the encoded noncrossing digraphs form a context-free language. We then give it (3) two homomorphic, nonderivative representations and use the latent local features of the latter to characterize various families of digraphs.\nApart from the obvious relevance to the theory of context-free languages, this contribution has the practical potential to enable (4) generic contextfree parsers that produce different families of noncrossing graphs with the same set of inference rules while the search space in each case is restricted with lexical features and the grammar.\nOutline After some background on graphs and parsing as inference (Section 2), we use an ontology of digraphs to illustrate natural families of noncrossing digraphs in Section 3. We then develop, in Section 4, the first latent contextfree representation for the set of noncrossing digraphs, then extended in Section 5 with additional latent states supporting our finite-state axiomatization of digraph properties, and allowing us to\nar X\niv :1\n70 6.\n03 35\n7v 1\n[ cs\n.C L\n] 1\n1 Ju\nn 20\n17\ncontrol the search space using the lexicon. The experiments in Section 6 cross-validate our axioms and sample the growth of the constrained search spaces. Section 7 outlines the applications for practical parsing, and Section 8 concludes."
    }, {
      "heading" : "2 Background",
      "text" : "Graphs and Digraphs A graph is a pair (V,E) where V is a finite set of vertices and E ⊆ {{u,v} ⊆ V} is a set of edges. A sequence of edges of the form {v0,v1}, {v1,v2}, ..., {vm−1,vm}, with no repetitions in v1, ...,vm, is a path between vertices v0 and vm and empty if m = 0. A graph is a forest if no vertex has a non-empty path to itself and connected if all pairs of vertices have a path. A tree is a connected forest.\nA digraph is a pair (V,A) where A ⊆ V ×V is a set of arcs u→ v, thus a directed graph. Its underlying graph, (V,EA), has edges EA = {{u,v} | (u,v) ∈ A}. A sequence of arcs v0 → v1,v1 → v2, ...,vm−1→ vm, with no repetitions in v1, . . . ,vm, is a directed path, and empty if m = 0.\nA digraph without self-loops v→ v is loop-free (property DIGRAPHLF). We will focus on loopfree digraphs unless otherwise specified, and denote them just by DIGRAPH for brevity. A digraph is d-acyclic (ACYCD), aka a dag if no vertex has a non-empty directed path to itself, uacyclic (ACYCU) aka a m(ixed)-forest if its underlying graph is a forest, and weakly connected (w.c., CONNW) if its underlying graph is connected.\nDependency Parsing The complete digraph GS(V,A) of a sentence S = x1...xn consists of vertices V = {1, ...,n} and all possible arcs A = V × V −{(i, i)}. The vertex i ∈ V corresponds to the word xi and the arc i → j ∈ A corresponds to a possible dependency between the words xi and x j.\nThe task of dependency parsing is to find a constrained subgraph G′S(V,A\n′) of the complete digraph GS of the sentence. The standard solution is a rooted directed tree called a dependency tree or a dag called a dependency graph.\nConstrained Inference In arc-factored parsing (McDonald et al., 2005), each possible arc i→ j is equipped with a positive weight wi j, usually computed as a weighted sum wi j = w ·Φ(S, i → j) where w is a weight vector and Φ(x, i→ j) a feature vector extracted from the sentence x, considering the dependency relation from word xi to word x j. Parsing then consists in finding an arc\nsubset A′ ⊆ A that gives us a constrained subgraph (V,A′) ∈ Constrained(V,A) of the complete digraph (V,A) with maximum sum of arc weights:\n(V,A′) = argmax (V,A′) ∈ Constrained(V,A) ∑ i→ j∈A′ wi, j.\nThe complexity of this inference task depends on the constraints imposed on the subgraph. Under no constraints, we simply set A′ = A. Inference over dags is intractable (Guruswami et al., 2011). Efficient solutions are known for projective trees (Eisner, 1996), various classes of mildly nonprojective trees (Gómez-Rodrı́guez, 2016), unrestricted spanning trees (McDonald et al., 2005), and both unrestricted and weakly connected noncrossing dags (Kuhlmann and Johnsson, 2015).\nParsimony Semantic parsers must be able to produce more than projective trees because the share of projective trees is pretty low (under 3%) in semantic graph banks (Kuhlmann and Johnsson, 2015). However, if we know that the parses have some restrictions, it is better to use them to restrict the search space as much as possible.\nThere are two strategies for reducing the search space. One is to develop a specialized inference algorithm for a particular natural language or family of dags, such as weakly connected graphs (Kuhlmann and Johnsson, 2015). The other strategy is to control the local complexity of digraphs through lexical categories (Baldridge and Kruijff, 2003) or equivalent mechanisms. This strategy produces a more sensitive model of the language, but requires a principled insight on how the complexity of digraphs can be characterized."
    }, {
      "heading" : "3 Constraints on the Search Space",
      "text" : "We will now present a classification of digraphs on the basis of their formal properties.\nThe Noncrossing Property For convenience, graphs and digraphs may be ordered like in a complete digraph of a sentence. Two edges {i, j}, {k, l} in an ordered graph or arcs i → j,k → l in an ordered digraph are said to be crossing if min{i, j} < min{k, l} < max{i, j} < max{k, l}. A graph or digraph is noncrossing if it has no crossing edges or arcs. Noncrossing (di)graphs (NC-(DI)GRAPH) are the largest possible (di)graphs that can be drawn on a circle without crossing arcs. In the following, we assume that all digraphs and graphs are noncrossing.\nAn arc x→ y is (properly) covered by an arc z→ t if ({x,y} 6= {z, t}) and min{z, t} ≤ min{x,y} ≤ max{x,y} ≤max{z, t}.\nOntology Fig. 1 presents an ontology of such families of loop-free noncrossing digraphs that can be distinguished by digraphs with 5 vertices.\nIn the digraph ontology, a multitree aka mangrove is a dag with the property of being strongly unambiguous (UNAMBS), which asserts that, given two distinct vertices, there is at most one repeat-free path between them (Lange, 1997).1 A polytree (Rebane and Pearl, 1987) is a multitree whose underlying graph is a tree. The out property (OUT) of a digraph (V,E) means that no vertex i ∈V has two incoming arcs { j,k}→ i s.t. j 6= k.\nNC-DIGRAPH +5460\nCONNW +43571 UNAMBS +80 ORIENTED +140\nACYCU +1200 OUT +10 w.c.unamb. +600\nw.c.or. +1160 unamb.or. +80 ACYCD +840\nout oriented +130 out m-forest +435 mixed tree +3355\nmultitree +10 w.c.dag +2960 w.c.unamb.or. +370\nout mixed tree +220\nw.c. out oriented +132\nw.c.multitree +50 or.forest +300\npolytree +605 out or.forest +481\nout or.tree +275\nFigure 1: Basic properties split the set of 62464 noncrossing digraphs for 5 vertices into 23 classes\nAn ordered digraph is weakly projective (PROJW) if for all vertices i, j and k, if k→ j→ i, then either {i, j}< k or {i, j}> k. In other words, the constraint, aka the outside-to-inside constraint (Yli-Jyrä, 2005), states that no outgoing arc of a vertex properly covers an incoming arc. This is implied by a stronger constraint known as Harper, Hays, Lecerf and Ihm projectivity (Marcus, 1967).\nWe can embed the ontology of graphs (unrestricted, connected, forests and trees) into the ontology of digraphs by viewing an undirected graph (V,E) as an inverse digraph (V,{(i, j),( j, i) | {i, j} ∈ E}). This kind of digraph has an inverse property (INV). Its opposite is an oriented (or.) digraph (V,A) where i→ j ∈ A implies j → i /∈ A (defines the property ORIENTED). Out forests and trees are, by convention, oriented digraphs with an underlying forest or tree, respectively.\n1A different definition forbids diamonds as minors.\nDistinctive Properties A few important properties of digraphs are local and can be verified by inspecting each vertex separately with its incident arcs. These include (i) the out property (OUT), (ii) the nonstandard projectivity property (PROJW), (iii) the inverse property (INV) and (iv) the orientedness (or.) property.\nProperties UNAMBS, ACYCD, CONNW, and ACYCU are nonlocal properties of digraphs and cannot be generally verified locally, through finite spheres of vertices (Grädel et al., 2005). The following proposition covers the configurations that we have to detect in order to decide the nonlocal properties of noncrossing digraphs.\nProposition 1. Let G = (V,E) be a noncrossing digraph.\n• If G /∈ UNAMBS, then the digraph contains one of the following four configurations or their reversals:\nu v y u v y u v y u v x y\n• If G /∈ ACYCD, then the graph contains one of the configurations\nu v y u v y u v\n• If G /∈ ACYCU, then the underlying graph contains the following configuration:\nu v y\n• If G /∈ CONNW, then the underlying graph contains one of the following configurations:\n... v y ...\nno arc no arc\n... v ...\nno arc no arc\nProposition 1 gives us a means to implement the property tests in practice. It tells us intuitively that although the paths can be arbitrarily long, any underlying cycle containing more than 2 arcs consists of one covering arc and a linear chain of edges between its end points."
    }, {
      "heading" : "4 The Set of Digraphs as a Language",
      "text" : "In this section, we show that the set of noncrossing digraphs is isomorphic to an unambiguous context-free language over a bracket alphabet."
    }, {
      "heading" : "4.1 Basic Encoding",
      "text" : "Any noncrossing ordered graph ([1, ...,n],E), even with self-loops, can be encoded as a string of brackets using the algorithm enc in Fig. 2. For example, the output for the ordered graph\n1 2 3 4 n = 4, E = { {1,2}, {2,2} {2,4}, {1,4} } is the string [[{}][[]{}{}]]. Intuitively, pairs of brackets of the form {} can be interpreted as spaces between vertices, and then each set of matching brackets [...] encodes an arc that covers the spaces represented inside the brackets.\nAny noncrossing ordered digraph ([1, . . . ,n],A) can be encoded with slight modifications to the algorithm. Instead of printing [ ] for an edge {i, j} ∈ EA, i≤ j, the algorithm should now print\n/ > if (i, j) ∈ A,( j, i) 6∈ A; < / if (i, j) /∈ A,( j, i) ∈ A; [ ] if (i, j),( j, i) ∈ A.\nIn this way, we can simply encode the digraph ({1,2,3,4},{(1,2),(2,2),(4,1),(4,2)}) as the string </{}><[]{}{}//.\nProposition 2. The encoding respects concatenation where the adjacent nonempty operands have a common vertex.\nContext-Freeness Arbitrary strings with balanced brackets form a context-free language that is known, generically, as a Dyck language. It is easy to see that the graphs NC-GRAPH are encoded with strings that belong to the Dyck language D2 generated by the context-free grammar: S→ [S]S | {S}S | ε . The encoded graphs, LNC-GRAPH, are, however, generated exactly by the context-free grammar S → [S′] S | {} S | ε , S′→ [S′] T | {} S, T → [S′] S | {} S. This language is an unambiguous context-free language.\nProposition 3. The encoded graphs, LNC-GRAPH, make an unambiguous context-free language.\nThe practical significance of Proposition 3 is that there is a bijection between LNC-GRAPH and the derivation trees of a context-free grammar."
    }, {
      "heading" : "4.2 Bracketing Beyond the Encoding",
      "text" : "Non-Derivational Representation A nonderivational representation for any context-free\nlanguage L has been given by Chomsky and Schützenberger (1963). This replaces the stack with a Dyck language D and the grammar rules with co-occurrence patterns specified by a regular language Reg. To hide the internal alphabet from the strings of the represented language, there is a homomorphism that cleans the internal strings of Reg and D from internal markup to get actual strings of the target language:\nLNC-GRAPH = h(D∩Reg).\nTo make this concrete, replace the previous context free grammar by S′′ → [′S′]′ S | {} S | ε , S→ [S′] S | {} S | ε , S′→ [′S′]′ T | {} S, T → [S′] S | {} S. The homomorphism h (Fig. 3a) would now relate this language to the original language, mapping the string [′[′{}]′[[′{}]′{}]]′ to the string [[{}][[{}]{}]], for example. The Dyck language D = D3 checks that the internal brackets are balanced, and the regular component Reg (Fig. 3b) checks that the new brackets are used correctly. A similar representation for the language LNC-DIGRAPH of encoded digraphs can be obtained with straightforward extensions.\nThe representation L = h(D ∩ Reg) is unambiguous if, for every word w ∈ L, the preimage h−1(w)∩D∩Reg is a single string. This implies that L is an unambiguous context-free language.\nProposition 4. The set of encoded digraphs, LNC-DIGRAPH, has an unambiguous representation.\nProposition 5. Let Li = h(D∩ Ri), i ∈ {0,1,2} be unambiguous representations with R1,R2 ⊆ R0. Then L3 = h(D∩ (R1 ∩ R2)) is an unambiguous context-free language and the same as L1∩L2.\nProof. It is immediate that L3 ⊆ L1∩L2 and L3 is an unambiguous context-free language. To show that L1 ∩ L2 ⊆ L3, take an arbitrary s ∈ L1 ∩ L2. Since R1,R2 ⊆ R0 there is a unique s′ ∈ h−1(s) such that s′ ∈ D∩ (R1∩R2). Thus s ∈ L3."
    }, {
      "heading" : "5 Latent Bracketing",
      "text" : "In this section, we extend the internal strings of the non-derivational representation of LNC-DIGRAPH in\nsuch a way that the configurations given in Proposition 1 can be detected locally from these.\nClassification of Underlying Chains A maximal linear chain is a maximally long sequence of one or more edges that correspond to an underlying left-to-right path in the underlying graph in such a way that no edge in this chain is properly covered by an edge that does not properly cover all the edges in the chain. For example, the graph\n[′[′{}]′[[′{}]′[{}]][[′{}]′{}[{}]]]′[{}[{ }]{}]\nI\nII III\nII III\nII I\nIV V VI\ncontains six maximal linear chains, indicated with their Roman numbers on each arc. We decide nonlocal properties of noncrossing digraphs by recognizing maximal linear chains as parts of configurations presented in Proposition 1.\nEvery loose chain (like V and VI) starts with a bracket that is adjacent to a }-bracket. Such a chain can contribute only a covering edge to an underlying cycle. In contrast, a bracket with an apostrophe marks the beginning of a non-loose chain that can either start at the first vertex, or share starting point with a covering chain. When a nonloose chain is covered, it can be touched twice by a covering edge. The prefixes of chains are classified incrementally, from left to right, with a finite automaton (Figure 4). All states of the automaton are final and correspond to distinct classes of the chains. These classes are encoded to an extended set of brackets.\nThe automaton is symmetric: states with uppercase names are symmetrically related with\ncorresponding lowercase states. Thus, it suffices to define the initial and uppercase-named states:\n0 the initial state for a non-loose chain; I a bidirectional chain: u↔ (v↔)y; A a primarily bidirectional forward chain: u↔ v→ y; F a forward chain: u→ v→ y; Q a primarily forward chain: u→ v↔ (· · · →)y; C a primarily forward 1-turn chain: u→ v← y; E a primarily forward 2-turn chain: u→ v← x→ y; Z a 3-turn chain; 1 the initial (and only) state for a loose chain;\nRecognition of ambiguous paths in configurations u −−−−−→←−−→→v←y and u\n−−−−−−−−−−→←−−−−−−−← v→ x←←y involves three chain levels. To support the recognition, subtypes of edges are defined according to the chains they cover. The brackets >I’, \\I’, >I, \\I, \\A, >a, \\Q, >Q, >q,\\q, >C, \\c, \\E, >e indicate edges that constitute a cycle with the chain they cover. The brackets >V’, \\v’, >V, \\v indicate edges that cover 2-turn chains. Not all states make these distinctions.\nExtended Representation The extended brackets encode the latent structure of digraphs: the orientation and the subtype of the edge and the class of the chain. The total alphabet Σ of the strings now contains the boundary brackets {} and 54 pairs of brackets (Figure 4) for edges from which we obtain a new Dyck language, D55, and an extended homomorphism hlat.\nThe Reg component of the language representation is replaced with Reglat, that is, an intersection of (1) an inverse homomorphic image of Reg to strings over the extended alphabet, (2) a local language that constrains adjacent edges according to Figure 4, (3) a local language specifying how the chains start, and (4) a local language that distinguishes pure oriented edges from those that cover a cycle or a 2-turn chain. The new component requires only 24 states as a deterministic automaton.\nProposition 6. hlat(D55∩Reglat) is an unambiguous representation for LNC-DIGRAPH.\nThe internal language LNC-DIGRAPHlat = D55 ∩ Reglat is called the set of latent encoded digraphs.\nExample Here is a digraph with its latent encoding:\n<f′ [I′︸ ︷︷ ︸ 1 {}]I′ /0 /F′︸ ︷︷ ︸ 2 {} >F′︸︷︷︸ 3 {} <.︸︷︷︸ 4 {} /.︸︷︷︸ 5 {} >.︸︷︷︸ 6 {}/. >0 /f′︸ ︷︷ ︸ 7 The brackets in the extended representation contain information that helps us recognize, through local patterns, that this graph has a directed cycle\n(directed path 1→ 2→ 7→ 1), is strongly ambiguous (two directed paths 2→ 1 and 2→ 7→ 1) and is not weakly connected (vertices 5 and 6 are not connected to the rest of the digraph).\nExpressing Properties via Forbidden Patterns We now demonstrate that all the mentioned nonlocal properties of graphs have become local in the extended internal representation of the code strings LNC-DIGRAPH for noncrossing digraphs.\nThese distinctive properties of graph families reduce to forbidden patterns in bracket strings and then compile into regular constraint languages. These are presented in Table 1. To keep the patterns simple, subsets of brackets are defined:\nL/ [-,/-brackets L< [-,<-brackets R> ]-,>-brackets R/ ]-,\\-brackets B {, } R R>∪R\\ Rloose }, >., / ., ]. Rloose R−Rloose Rright R reaching F,Q,I,A Rleft R reaching f,q,i,a Rright2 >P, >2, >E, \\E, ]E Rleft2 \\p, \\2, \\e, >e, ]e Σin L<∪R> B Σ−B Rvergent non-’ R reaching I,Q,q,A,a,C,c Σor all brackets for oriented edges Σinv all brackets for inverted edges"
    }, {
      "heading" : "6 Validation Experiments",
      "text" : "The current experiments were designed (1) to help in developing the components of Reglat and the constraint languages of axiomatic properties, (2) to validate the representation, the constraint languages and their unambiguity, (3) to learn about the ontology and (4) to sample the integer sequences associated with the cardinality of each\nfamily in the ontology.\nFinding the Components Representations of Reglat were built with scripts written using a finitestate toolkit (Hulden, 2009) that supports rapid exploration with regular languages and transducers.\nValidation of Languages Our scripts presented alternative approaches to compute languages of encoded digraphs with n vertices up to n = 9. We also implemented a Python script that enumerated elements of families of graphs up to n = 6. The solutions were used to cross-validate one another.\nThe constraint Gn = B ∗ ({}B∗)n−1 ensures nvertices in encoded digraphs. The finite set of encoded acyclic 5-vertex digraphs was computed with a finite-state approach (Yli-Jyrä et al., 2012) that takes the input projection of the composition\nId(Reglat∩AD∩G5)◦T55◦T55◦T55◦T55◦T55◦ Id(ε)\nwhere Id defines an identity relation and transducer T55 eliminates matching adjacent brackets. This composition differs from the typical use where the purpose is to construct a regular relation (Kaplan and Kay, 1994) or its output projection (Roche, 1996; Oflazer, 2003).\nFor digraphs with a lot of vertices, we had an option to employ a dynamic programming scheme (Yli-Jyrä, 2012) that uses weighted transducers.\nBuilding the Ontology To build the ontology in Figure 1 we first found out which combinations of digraph properties co-occur to define distinguishable families of digraphs. After the nodes of the\nlattice were found, we were able to see the partial order between these.\nInteger Sequences We sampled, for important families of digraphs, the prefixes of their related integer sequences. We found out that each family of graphs is pretty much described by its cardinality, see Table 2. In many cases, the number sequence was already well documented (OEIS Foundation Inc., 2017)."
    }, {
      "heading" : "7 The Formal Basis of Practical Parsing",
      "text" : "While presenting a practical parser implementation is outside of the scope of this paper, which focuses in the theory, we outline in this section the aspects to take into account when applying our representation to build practical natural language parsers.\nPositioned Brackets In order to do inference in arc-factored parsing, we incorporate weights to the representation. For each vertex in Gn, the brackets are decorated with the respective position number. Then, we define an input-specific grammar representation where each pair of brackets in D gets an arc-factored weight given the directions and the vertex numbers associated with the brackets.\nGrammar Intersection We associate, to each Gn, a quadratic-size context-free grammar that generates all noncrossing digraphs with n vertices. This grammar is obtained by computing (or even precomputing) the intersection D55 ∩ Reglat ∩Gn in any order, exploiting the closure of contextfree languages under intersection with regular languages (Bar-Hillel et al., 1961). The introduction of the position numbers and weights in the Dyck language gives us, instead, a weighted grammar and its intersection (Lang, 1994). This grammar is a compact representation for a finite set of weighted latent encoded digraphs. Additional constraints during the intersection tailors the grammar to different families of digraphs.\nDynamic Programming The heaviest digraph is found with a dynamic programming algorithm that computes, for each nonterminal in the grammar, the weight of the heaviest subtree. A careful reader may notice some connections to Eisner algorithm (Eisner and Satta, 1999), context-free parsing through intersection (Nederhof and Satta, 2003), and a dynamic programming scheme that\nuses contracting transducers and factorized composition (Yli-Jyrä, 2012). Unfortunately, space does not permit discussing the connections here.\nLexicalized Search Space In practical parsing, we want the parser behavior and the dependency structure to be sensitive to the lexical entries or features of each word. We can replace the generic vertex description B∗ in Gn with subsets that depend on respective lexical entries. Graphical constraints can be applied to some vertices but relaxed for others. This application of current results gives a principled, graphically motivated solution to lexicalized control over the search space."
    }, {
      "heading" : "8 Conclusion",
      "text" : "We have investigated the search space of parsers that produce noncrossing digraphs. Parsers that can be adapted to different needs are less dependent on artificial assumptions on the search space. Adaptivity gives us freedom to model how the properties of digraphs are actually distributed in linguistic data. As the adaptive data analysis deserves to be treated in its own right, the current work focuses on the separation of the parsing algorithm from the properties of the search space.\nThis paper makes four significant contributions.\nContribution 1: Digraph Encoding The paper introduces, for noncrossing digraphs, an encoding that uses brackets to indicate edges.\nBracketed trees are widely used in generative syntax, treebanks and structured document formats. There are established conversions between phrase structure and projective dependency trees, but the currently advocated edge bracketing is expressive and captures more than just projective dependency trees. This capacity is welcome as syntactic and semantic analysis with dependency graphs is a steadily growing field.\nThe edge bracketing creates new avenues for the study of connections between noncrossing graphs and context-free languages, as well as their recognizable properties. By demonstrating that digraphs can be treated as strings, we suggest that practical parsing to these structures could be implemented with existing methods that restrict context-free grammars to a regular yield language.\nContribution 2: Context-Free Properties Acyclicity and other important properties of noncrossing digraphs are expressible as unambiguous context-free sets of encoded noncrossing\nTable 2: Characterizations for some noncrossing families of digraphs and graphs\nName Sequence prefix for n = 2,3, ... Example Name Sequence prefix for n = 2,3, ... Example digraph (KJ): 4,64,1792,62464,2437120,101859328\nhlat(D55 ∩Gn ∩Reglat) 1 2 3 4 5 weakly projective digraph 4,36,480,7744,138880,2661376 hlat(D55 ∩Gn ∩Reglat ∩PW ) 1 2 3 4 5\nw.c.digraph 3,54,1539,53298,2051406,84339468 hlat(D55 ∩Gn ∩Reglat ∩CW ) 1 2 3 4 5\nw.p. w.c.digraph 3,26,339,5278,90686,1658772 hlat(D55 ∩Gn ∩Reglat ∩PW ∩CW ) 1 2 3 4 5\nunamb.digr. 4,39,529,8333,142995,2594378 hlat(D55 ∩Gn ∩Reglat ∩US) 1 2 3 4 5\nw.p. unamb.digr. 4,29,275,3008,35884,453489 hlat(D55 ∩Gn ∩Reglat ∩PW ∩US) 1 2 3 4 5\nm-forest 4,37,469,6871,109369,1837396,32062711 hlat(D55 ∩Gn ∩Reglat ∩AU ) 1 2 3 4 5\nw.p. m-forest 4,29,273,2939,34273,421336 hlat(D55 ∩Gn ∩Reglat ∩PW ∩AU ) 1 2 3 4 5\nout digraph 4,27,207,1683,14229,123840,1102365 hlat(D55 ∩Gn ∩Reglat ∩Out) 1 2 3 4 5\nw.p. out digraph 4,21,129,867,6177,45840,350379 hlat(D55 ∩Gn ∩Reglat ∩PW ∩Out) 1 2 3 4 5\nor. digraph 3,27,405,7533,156735,3492639,77539113 hlat(D55 ∩Gn ∩Reglat ∩O) 1 2 3 4 5\nw.p. or.digraph see w.p.dag hlat(D55 ∩Gn ∩Reglat ∩PW ∩O) see w.p.dag\ndags (A246756): 3,25,335,5521,101551 hlat(D55 ∩Gn ∩Reglat ∩AD) 1 2 3 4 5\nw.p. dag 3,21,219,2757,38523, 574725, 8967675 hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD) 1 2 3 4 5\nw.c. dag (KJ): 2,18,242,3890,69074,1306466 hlat(D55 ∩Gn ∩Reglat ∩AD ∩CW ) 1 2 3 4 5\nw.p. w.c. dag 2,14,142,1706,22554,316998,4480592 hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD ∩CW ) 1 2 3 4 5\nmultitree 3,19,167,1721,19447,233283,2917843 hlat(D55 ∩Gn ∩Reglat ∩AD ∩US)\nsee oriented forest or w.c. multitree w.p. multitree 3,17,129,1139,11005,112797,1203595 hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD ∩US) 1 2 3 4 5\nor.forest 3,19,165,1661,18191,210407,2528777 hlat(D55 ∩Gn ∩Reglat ∩AD ∪AU ) 1 2 3 4 5\nw.p. or.forest 3,17,127,1089,10127,99329,1010189 hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD ∪AU ) 1 2 3 4 5\nw.c. multitree 2,12,98,930,9638,105798,1201062 hlat(D55 ∩Gn ∩Reglat ∩AD ∩US ∩CW ) 1 2 3 4 5\nw.p. w.c. multitree 2,10,68,538,4650,42572,404354 hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD ∩US ∩CW ) 1 2 3 4 5\nout or.forest 3,16,105,756,5738,45088,363221 hlat(D55 ∩Gn ∩Reglat ∩AD ∩Out) 1 2 3 4 5\nw.p. out or.forest (A003169): 3,14,79,494,3294,22952 hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD ∩Out) 1 2 3 4 5\npolytree (A153231): 2,12,96,880,8736,91392 hlat(D55 ∩Gn ∩Reglat ∩AD ∩CW ∩AU ) 1 2 3 4 5\nw.p. polytree (A027307):2,10,66,498,4066,34970 hlat(D55∩Gn∩Reglat∩PW ∩AD∩CW ∩AU ) 1 2 3 4 5\nout or.tree (A174687): 2,9,48,275,1638,9996 hlat(D55 ∩Gn ∩Reglat ∩AD ∩CW ∩Out) 1 2 3 4 5\nprojective out or.tree\n(A006013): 2,7,30,143,728,3876,21318 hlat(D55∩Gn∩Reglat∩PW ∩AD∩CW ∩Out) 1 2 3 4 5\ngraph (A054726): 2,8,48,352,2880,25216 hlat(D55 ∩Gn ∩Reglat ∩ I) 1 2 3 4 5\nconnected graph (A007297): 1,4,23,156,1162,9192 hlat(D55 ∩Gn ∩Reglat ∩ I∩CW ) 1 2 3 4 5\nforest (A054727): 2,7,33,181,1083,6854 hlat(D55 ∩Gn ∩Reglat ∩ I∩AU ) 1 2 3 4 5\ntree (A001764,YJ): 1,3,12,55,273,1428,7752 hlat(D55 ∩Gn ∩Reglat ∩ I∩AU ∩CW ) 1 2 3 4 5\nA = (OEIS Foundation Inc., 2017), KJ = Kuhlmann (2015) or Kuhlmann and Johnsson (2015), YJ = Yli-Jyrä (2012)\ndigraphs. This facilitates the incorporation of property testing to dynamic programming algorithms that implement exact inference.\nDescriptive complexity helps us understand to which degree various graphical properties are local and could be incorporated into efficient dynamic programming during exact inference. It is well known that acyclicity and connecticity are not definable in first-order logic (FO) while they can be defined easily in monadic second order logic (MSO) (Courcelle, 1997). MSO involves set-valued variables whose use in dynamic programming algorithms and tabular parsing is inefficient. MSO queries have a brute force transformation to first-order (FO) logic, but this does not generally help either as it is well known that MSO can express intractable problems.\nThe interesting observation of the current work is that some MSO definable properties of digraphs become local in our extended encoding. This encoding is linear compared to the size of digraphs: each string over the extended bracket alphabet encodes a fixed assignment of MSO variables. The properties of noncrossing digraphs now reduce to properties of bracketed trees with linear amount of\nfunc noncrossing_ACYCU(n,E): for {u,y} in E and u < y: # covering edge\n[v,p] = [u,u] while p != -1: # chain continues\n[v,p] = [p,-1] for vv in [v+1,...,y]: # next vertex\nif {v,vv} in E and {v,vv} != {u,y}: if vv == y:\nreturn False # found cycle uvy p = vv # find longest edge\nreturn True # acyclic\nFigure 5: Testing ACYCU in logarithmic space\nlatent information that is fixed for each digraph. A deeper explanation for our observation comes from the fact that the treewidth of noncrossing and other outerplanar graphs is bounded to 2. When the treewidth is bounded, all MSO definable properties, including the intractable ones, become linear time decidable for individual structures (Courcelle, 1990). They can also be decided in a logarithmic amount of writable space (Elberfeld et al., 2010), e.g. with element indices instead of sets. By combining this insight with Proposition 1, we obtain a logspace solution for testing acyclicity of a noncrossing graph (Figure 5).\nAlthough bounded treewidth is a weaker constraint than so-called bounded treedepth that would immediately guarantee first-order definabil-\nity (Elberfeld et al., 2016), it can sometimes turn intractable search problems to dynamic programming algorithms (Akutsu and Tamura, 2012). In our case, Proposition 1 gave rise to unambiguous context-free subsets of LNC-DIGRAPH. These can be recognized with dynamic programming and used in efficient constrained inference when we add vertex indices to the brackets and weights to the grammar of the corresponding Dyck language.\nContribution 3: Digraph Ontology The context-free properties of encoded digraphs have elegant nonderivative language representations and they generate a semi-lattice under language intersection. Although context-free languages are not generally closed under intersection, all combinations of the properties in this lattice are context-free and define natural families of digraphs. The nonderivative representations for our axiomatic properties share the same Dyck language D55 and homomorphism, but differ in terms of forbidden patterns. As a consequence, also any conjunctive combination of these two properties shares these components and thus define a context-free language. The obtained semilattice is an ontology of families of noncrossing digraphs.\nOur ontology contains important families of noncrossing digraphs used in syntactic and semantic dependency parsing: out trees, dags, and weakly connected digraphs. It shows the entailment between the properties and proves the existence of less known families of noncrossing digraphs such as strongly unambiguous digraphs and oriented graphs, multitrees, oriented forests and polytrees. These are generalizations of out oriented trees. However, these families can still be weakly projective. Table 2 shows integer sequences obtained by enumerating digraphs in each family. At least twelve of these sequences are previously known, which indicates that the families are natural.\nWe used a finite-state toolkit to build the components of the nongenerative language representation for latent encoded digraphs and the axioms.2\nContribution 4: Generic Parsing The fourth contribution of this paper is to show that parsing algorithms can be separated from the formal properties of their search space.\n2The finite-state toolkit scripts and a Python-based graph enumerator are available at https://github.com/amikael/ncdigraphs .\nAll the presented families of digraphs can be treated by parsers and other algorithms (e.g. enumeration algorithms) in a uniform manner. The parser’s inference rules can stay constant and the choice of the search space is made by altering the regular component of the language representation.\nThe ontology of the search space can be combined with a constraint relaxation strategy, for example, when an out tree is a preferred analysis, but a dag is also possible as an analysis when no tree is strong enough. The flexibility applies also to dynamic programming algorithms that complement with the encoding and allow inference of best dependency graphs in a family simply by intersection with a weighted CFG grammar for a Dyck language that models position-indexed edges of the complete digraph.\nSince the families of digraphs are distinguished by forbidden local patterns, the choice of search space can be made purely on lexical grounds, blending well with lexicalized parsing and allowing possibilities such as choosing, per each word, what kind of structures the word can go with.\nFuture work We are planning to extend the coverage of the approach by exploring 1-endpointcrossing and MHk trees (Pitler et al., 2013; Gómez-Rodrı́guez, 2016), and related digraphs — see (Yli-Jyrä, 2004; Gómez-Rodrı́guez et al., 2011). Properties such as weakly projective, out, and strongly unambiguous prompt further study.\nAn interesting avenue for future work is to explore higher order factorizations for noncrossing digraphs and the related inference. We would also like to have more insight on the transformation of MSO definable properties to the current framework and to logspace algorithms."
    }, {
      "heading" : "Acknowledgements",
      "text" : "AYJ has received funding as Research Fellow from the Academy of Finland (dec. No 270354 - A Usable Finite-State Model for Adequate Syntactic Complexity) and Clare Hall Fellow from the University of Helsinki (dec. RP 137/2013). CGR has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No 714150 - FASTPARSE) and from the TELEPARES-UDC project (FFI201451978-C2-2-R) from MINECO. The comments of Juha Kontinen, Mark-Jan Nederhof and the anonymous reviewers helped to improve the paper."
    } ],
    "references" : [ {
      "title" : "The monadic second-order",
      "author" : [ "Bruno Courcelle" ],
      "venue" : null,
      "citeRegEx" : "Courcelle.,? \\Q1990\\E",
      "shortCiteRegEx" : "Courcelle.",
      "year" : 1990
    }, {
      "title" : "The expression of graph prop",
      "author" : [ "H. Bruno Courcelle" ],
      "venue" : null,
      "citeRegEx" : "Courcelle.,? \\Q1997\\E",
      "shortCiteRegEx" : "Courcelle.",
      "year" : 1997
    }, {
      "title" : "Logspace versions of the theorems of Bodlaender and Courcelle",
      "author" : [ "Michael Elberfeld", "Andreas Jakoby", "Till Tantau." ],
      "venue" : "Proceedings of the 2010 IEEE 51st Annual Symposium on Foundations of Computer Science. IEEE Computer Society,",
      "citeRegEx" : "Elberfeld et al\\.,? 2010",
      "shortCiteRegEx" : "Elberfeld et al\\.",
      "year" : 2010
    }, {
      "title" : "Dependency parsing schemata and mildly non-projective dependency parsing. Computational Linguistics 37(3):541–586",
      "author" : [ "Carlos Gómez-Rodrı́guez", "John A. Carroll", "David J. Weir" ],
      "venue" : null,
      "citeRegEx" : "Gómez.Rodrı́guez et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Gómez.Rodrı́guez et al\\.",
      "year" : 2011
    }, {
      "title" : "Finite Model Theory and Its Applications (Texts in Theoretical Computer Science",
      "author" : [ "Erich Grädel", "P.G. Kolaitis", "L. Libkin", "M. Marx", "J. Spencer", "Moshe Y. Vardi", "Y. Venema", "Scott Weinstein." ],
      "venue" : "An EATCS Series). Springer-Verlag New York, Inc.,",
      "citeRegEx" : "Grädel et al\\.,? 2005",
      "shortCiteRegEx" : "Grädel et al\\.",
      "year" : 2005
    }, {
      "title" : "The hardest context-free language",
      "author" : [ "Sheila Greibach." ],
      "venue" : "SIAM Journal on Computing 2(4):304–310. https://doi.org/10.1137/0202025.",
      "citeRegEx" : "Greibach.,? 1973",
      "shortCiteRegEx" : "Greibach.",
      "year" : 1973
    }, {
      "title" : "Beating the random ordering is hard: Every ordering CSP is approximation resistant",
      "author" : [ "Venkatesan Guruswami", "Johan Håstad", "Rajsekar Manokaran", "Prasad Raghavendra", "Moses Charikar." ],
      "venue" : "SIAM Journal on Computing 40(3):878914.",
      "citeRegEx" : "Guruswami et al\\.,? 2011",
      "shortCiteRegEx" : "Guruswami et al\\.",
      "year" : 2011
    }, {
      "title" : "Foma: a finite-state compiler and library",
      "author" : [ "Mans Hulden." ],
      "venue" : "Proceedings of the Demonstrations Session at EACL 2009. Association for Computational Linguistics, Athens, Greece, pages 29–32. http://www.aclweb.org/anthology/E09-2008.",
      "citeRegEx" : "Hulden.,? 2009",
      "shortCiteRegEx" : "Hulden.",
      "year" : 2009
    }, {
      "title" : "Parsing CFGs and PCFGs with a Chomsky-Schützenberger representation",
      "author" : [ "Mans Hulden." ],
      "venue" : "Zygmunt Vetulani, editor, Human Language Technology. Challenges for Computer Science and Linguistics: 4th Language and Technology Confer-",
      "citeRegEx" : "Hulden.,? 2011",
      "shortCiteRegEx" : "Hulden.",
      "year" : 2011
    }, {
      "title" : "Regular models of phonological rule systems",
      "author" : [ "Ronald M. Kaplan", "Martin Kay." ],
      "venue" : "Computational Linguistics 20(3):331–378. http://dl.acm.org/citation.cfm?id=204915.204917.",
      "citeRegEx" : "Kaplan and Kay.,? 1994",
      "shortCiteRegEx" : "Kaplan and Kay.",
      "year" : 1994
    }, {
      "title" : "Tabulation of noncrossing acyclic digraphs",
      "author" : [ "Marco Kuhlmann." ],
      "venue" : "arXiv:1504.04993. https://arxiv.org/abs/1504.04993.",
      "citeRegEx" : "Kuhlmann.,? 2015",
      "shortCiteRegEx" : "Kuhlmann.",
      "year" : 2015
    }, {
      "title" : "Parsing to noncrossing dependency graphs",
      "author" : [ "Marco Kuhlmann", "Peter Johnsson." ],
      "venue" : "Transactions of the Association for Computational Linguistics 3:559– 570. http://aclweb.org/anthology/Q/Q15/Q151040.pdf.",
      "citeRegEx" : "Kuhlmann and Johnsson.,? 2015",
      "shortCiteRegEx" : "Kuhlmann and Johnsson.",
      "year" : 2015
    }, {
      "title" : "Towards a catalogue of linguistic graph banks",
      "author" : [ "Marco Kuhlmann", "Stephan Oepen." ],
      "venue" : "Computational Linguistics 42(4):819–827. https://doi.org/10.1162/COLI a 00268.",
      "citeRegEx" : "Kuhlmann and Oepen.,? 2016",
      "shortCiteRegEx" : "Kuhlmann and Oepen.",
      "year" : 2016
    }, {
      "title" : "An unambiguous class possessing a complete set",
      "author" : [ "Klaus-Jörn Lange." ],
      "venue" : "Morvan Reischuk, editor, STACKS’97 Proceedings. Springer, volume 1200 of Lecture Notes in Computer Science. http://dl.acm.org/citation.cfm?id=695352.",
      "citeRegEx" : "Lange.,? 1997",
      "shortCiteRegEx" : "Lange.",
      "year" : 1997
    }, {
      "title" : "Algebraic Linguistics; Analytical Models, volume 29 of Mathematics in Science and Engineering",
      "author" : [ "S. Marcus." ],
      "venue" : "Academic Press, New York and London.",
      "citeRegEx" : "Marcus.,? 1967",
      "shortCiteRegEx" : "Marcus.",
      "year" : 1967
    }, {
      "title" : "Non-projective dependency parsing using spanning tree algorithms",
      "author" : [ "Ryan McDonald", "Fernando Pereira", "Kiril Ribarov", "Jan Hajic." ],
      "venue" : "Proceedings of Human Language Technology Conference and Conference on Empirical",
      "citeRegEx" : "McDonald et al\\.,? 2005",
      "shortCiteRegEx" : "McDonald et al\\.",
      "year" : 2005
    }, {
      "title" : "Probabilistic parsing as intersection",
      "author" : [ "Mark-Jan Nederhof", "Giorgio Satta." ],
      "venue" : "8th International Workshop on Parsing Technologies. LORIA, Nancy, France, pages 137–148.",
      "citeRegEx" : "Nederhof and Satta.,? 2003",
      "shortCiteRegEx" : "Nederhof and Satta.",
      "year" : 2003
    }, {
      "title" : "The on-line encyclopedia of integer sequences",
      "author" : [ "OEIS Foundation Inc." ],
      "venue" : "http://oeis.org, read on 15 January 2017.",
      "citeRegEx" : "Inc.,? 2017",
      "shortCiteRegEx" : "Inc.",
      "year" : 2017
    }, {
      "title" : "Semeval 2015 task 18: Broad-coverage semantic dependency parsing",
      "author" : [ "Stephan Oepen", "Marco Kuhlmann", "Yusuke Miyao", "Daniel Zeman", "Silvie Cinkova", "Dan Flickinger", "Jan Hajic", "Zdenka Uresova." ],
      "venue" : "Proceedings of the 9th",
      "citeRegEx" : "Oepen et al\\.,? 2015",
      "shortCiteRegEx" : "Oepen et al\\.",
      "year" : 2015
    }, {
      "title" : "Dependency parsing with an extended finite-state approach",
      "author" : [ "Kemal Oflazer." ],
      "venue" : "Computational Linguistics 29(4):515–544. https://doi.org/10.1162/089120103322753338.",
      "citeRegEx" : "Oflazer.,? 2003",
      "shortCiteRegEx" : "Oflazer.",
      "year" : 2003
    }, {
      "title" : "Finding optimal 1-endpointcrossing trees",
      "author" : [ "Emily Pitler", "Sampath Kannan", "Mitchell Marcus." ],
      "venue" : "Transactions of the Association for Computational Linguistics 1:13–24. http://aclweb.org/anthology/Q13-1002.",
      "citeRegEx" : "Pitler et al\\.,? 2013",
      "shortCiteRegEx" : "Pitler et al\\.",
      "year" : 2013
    }, {
      "title" : "The recovery of causal poly-trees from statistical data",
      "author" : [ "George Rebane", "Judea Pearl." ],
      "venue" : "Proceedings of the 3rd Annual",
      "citeRegEx" : "Rebane and Pearl.,? 1987",
      "shortCiteRegEx" : "Rebane and Pearl.",
      "year" : 1987
    }, {
      "title" : "Transducer parsing of free and frozen sentences",
      "author" : [ "Emmanuel Roche." ],
      "venue" : "Natural Language Engineering 2(4):345–350. https://doi.org/10.1017/S1351324997001605.",
      "citeRegEx" : "Roche.,? 1996",
      "shortCiteRegEx" : "Roche.",
      "year" : 1996
    }, {
      "title" : "On maximum spanning DAG algorithms for semantic DAG parsing",
      "author" : [ "Natalie Schluter." ],
      "venue" : "Proceedings of the ACL 2014 Workshop on Semantic Parsing. Association for Computational Linguistics, Baltimore, MD, pages 61–65.",
      "citeRegEx" : "Schluter.,? 2014",
      "shortCiteRegEx" : "Schluter.",
      "year" : 2014
    }, {
      "title" : "The complexity of finding the maximum spanning DAG and other restrictions for DAG parsing of natural language",
      "author" : [ "Natalie Schluter." ],
      "venue" : "Proceedings of the Fourth Joint Conference on Lexical and Computational Semantics. Association for Compu-",
      "citeRegEx" : "Schluter.,? 2015",
      "shortCiteRegEx" : "Schluter.",
      "year" : 2015
    }, {
      "title" : "Axiomatization of restricted non-projective dependency trees through finite-state constraints that analyse crossing bracketings",
      "author" : [ "Anssi Yli-Jyrä." ],
      "venue" : "Geert-Jan M. Kruijff and Denys Duchier, editors, COLING 2004 Re-",
      "citeRegEx" : "Yli.Jyrä.,? 2004",
      "shortCiteRegEx" : "Yli.Jyrä.",
      "year" : 2004
    }, {
      "title" : "Approximating dependency grammars through intersection of star-free regular languages",
      "author" : [ "Anssi Yli-Jyrä." ],
      "venue" : "Int. J. Found. Comput. Sci. 16(3):565– 579. https://doi.org/10.1142/S0129054105003169.",
      "citeRegEx" : "Yli.Jyrä.,? 2005",
      "shortCiteRegEx" : "Yli.Jyrä.",
      "year" : 2005
    }, {
      "title" : "On dependency analysis via contractions and weighted FSTs",
      "author" : [ "Anssi Yli-Jyrä." ],
      "venue" : "Diana Santos, Krister Lindén, and Wanjiku Ng’ang’a, editors, Shall We Play the Festschrift Game?, Essays on the Occasion of Lauri Carlson’s 60th Birthday. Springer,",
      "citeRegEx" : "Yli.Jyrä.,? 2012",
      "shortCiteRegEx" : "Yli.Jyrä.",
      "year" : 2012
    }, {
      "title" : "Refining the design of a contracting finite-state dependency parser",
      "author" : [ "Anssi Yli-Jyrä", "Jussi Piitulainen", "Atro Voutilainen." ],
      "venue" : "Iñaki Alegria and Mans Hulden, editors, Proceedings of the 10th International Workshop on Finite",
      "citeRegEx" : "Yli.Jyrä et al\\.,? 2012",
      "shortCiteRegEx" : "Yli.Jyrä et al\\.",
      "year" : 2012
    }, {
      "title" : "Transition-based dependency parsing with rich non-local features",
      "author" : [ "Yue Zhang", "Joakim Nivre." ],
      "venue" : "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies. Association for Computational",
      "citeRegEx" : "Zhang and Nivre.,? 2011",
      "shortCiteRegEx" : "Zhang and Nivre.",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 15,
      "context" : "Traditionally, dependency parsers have produced syntactic analyses in tree form, including exact inference algorithms that search for maximum projective trees (Eisner and Satta, 1999) and maximum spanning trees (McDonald et al., 2005) in weighted digraphs, as well as greedy and beamsearch approaches that forgo exact search for extra efficiency (Zhang and Nivre, 2011).",
      "startOffset" : 211,
      "endOffset" : 234
    }, {
      "referenceID" : 29,
      "context" : ", 2005) in weighted digraphs, as well as greedy and beamsearch approaches that forgo exact search for extra efficiency (Zhang and Nivre, 2011).",
      "startOffset" : 119,
      "endOffset" : 142
    }, {
      "referenceID" : 18,
      "context" : "In semantic dependency parsing (Oepen et al., 2015; Kuhlmann and Oepen, 2016), the desired syntactic representations can have indegree greater than 1 (re-entrancy), suggesting the search for maximum acyclic subgraphs (Schluter, 2014, 2015).",
      "startOffset" : 31,
      "endOffset" : 77
    }, {
      "referenceID" : 12,
      "context" : "In semantic dependency parsing (Oepen et al., 2015; Kuhlmann and Oepen, 2016), the desired syntactic representations can have indegree greater than 1 (re-entrancy), suggesting the search for maximum acyclic subgraphs (Schluter, 2014, 2015).",
      "startOffset" : 31,
      "endOffset" : 77
    }, {
      "referenceID" : 6,
      "context" : "As this inference task is intractable (Guruswami et al., 2011), noncrossing digraphs have been studied instead, e.",
      "startOffset" : 38,
      "endOffset" : 62
    }, {
      "referenceID" : 5,
      "context" : "As this inference task is intractable (Guruswami et al., 2011), noncrossing digraphs have been studied instead, e.g. by Kuhlmann and Johnsson (2015) who provide a O(n3) parser for maximum noncrossing acyclic subgraphs.",
      "startOffset" : 39,
      "endOffset" : 149
    }, {
      "referenceID" : 5,
      "context" : "As this inference task is intractable (Guruswami et al., 2011), noncrossing digraphs have been studied instead, e.g. by Kuhlmann and Johnsson (2015) who provide a O(n3) parser for maximum noncrossing acyclic subgraphs. Yli-Jyrä (2005) studied how to axiomatize dependency trees as a special case of noncrossing digraphs.",
      "startOffset" : 39,
      "endOffset" : 235
    }, {
      "referenceID" : 5,
      "context" : "In this language, the brackets indicate arcs in a dependency tree in a way that is reminiscent to encoding schemes used earlier by Greibach (1973) and Oflazer (2003).",
      "startOffset" : 131,
      "endOffset" : 147
    }, {
      "referenceID" : 5,
      "context" : "In this language, the brackets indicate arcs in a dependency tree in a way that is reminiscent to encoding schemes used earlier by Greibach (1973) and Oflazer (2003). Cubic-time parsing algorithms that are incidentally or intentionally applicable to this kind of homomorphic representations have been considered, e.",
      "startOffset" : 131,
      "endOffset" : 166
    }, {
      "referenceID" : 5,
      "context" : "In this language, the brackets indicate arcs in a dependency tree in a way that is reminiscent to encoding schemes used earlier by Greibach (1973) and Oflazer (2003). Cubic-time parsing algorithms that are incidentally or intentionally applicable to this kind of homomorphic representations have been considered, e.g., by Nederhof and Satta (2003), Hulden (2011), and Yli-Jyrä (2012).",
      "startOffset" : 131,
      "endOffset" : 348
    }, {
      "referenceID" : 5,
      "context" : "In this language, the brackets indicate arcs in a dependency tree in a way that is reminiscent to encoding schemes used earlier by Greibach (1973) and Oflazer (2003). Cubic-time parsing algorithms that are incidentally or intentionally applicable to this kind of homomorphic representations have been considered, e.g., by Nederhof and Satta (2003), Hulden (2011), and Yli-Jyrä (2012).",
      "startOffset" : 131,
      "endOffset" : 363
    }, {
      "referenceID" : 5,
      "context" : "In this language, the brackets indicate arcs in a dependency tree in a way that is reminiscent to encoding schemes used earlier by Greibach (1973) and Oflazer (2003). Cubic-time parsing algorithms that are incidentally or intentionally applicable to this kind of homomorphic representations have been considered, e.g., by Nederhof and Satta (2003), Hulden (2011), and Yli-Jyrä (2012).",
      "startOffset" : 131,
      "endOffset" : 384
    }, {
      "referenceID" : 15,
      "context" : "Constrained Inference In arc-factored parsing (McDonald et al., 2005), each possible arc i→ j is equipped with a positive weight wi j, usually computed as a weighted sum wi j = w ·Φ(S, i → j) where w is a weight vector and Φ(x, i→ j) a feature vector extracted from the sentence x, considering the dependency relation from word xi to word x j.",
      "startOffset" : 46,
      "endOffset" : 69
    }, {
      "referenceID" : 6,
      "context" : "Inference over dags is intractable (Guruswami et al., 2011).",
      "startOffset" : 35,
      "endOffset" : 59
    }, {
      "referenceID" : 15,
      "context" : "Efficient solutions are known for projective trees (Eisner, 1996), various classes of mildly nonprojective trees (Gómez-Rodrı́guez, 2016), unrestricted spanning trees (McDonald et al., 2005), and both unrestricted and weakly connected noncrossing dags (Kuhlmann and Johnsson, 2015).",
      "startOffset" : 167,
      "endOffset" : 190
    }, {
      "referenceID" : 11,
      "context" : ", 2005), and both unrestricted and weakly connected noncrossing dags (Kuhlmann and Johnsson, 2015).",
      "startOffset" : 69,
      "endOffset" : 98
    }, {
      "referenceID" : 11,
      "context" : "Parsimony Semantic parsers must be able to produce more than projective trees because the share of projective trees is pretty low (under 3%) in semantic graph banks (Kuhlmann and Johnsson, 2015).",
      "startOffset" : 165,
      "endOffset" : 194
    }, {
      "referenceID" : 11,
      "context" : "One is to develop a specialized inference algorithm for a particular natural language or family of dags, such as weakly connected graphs (Kuhlmann and Johnsson, 2015).",
      "startOffset" : 137,
      "endOffset" : 166
    }, {
      "referenceID" : 13,
      "context" : "In the digraph ontology, a multitree aka mangrove is a dag with the property of being strongly unambiguous (UNAMBS), which asserts that, given two distinct vertices, there is at most one repeat-free path between them (Lange, 1997).",
      "startOffset" : 217,
      "endOffset" : 230
    }, {
      "referenceID" : 21,
      "context" : "1 A polytree (Rebane and Pearl, 1987) is a multitree whose underlying graph is a tree.",
      "startOffset" : 13,
      "endOffset" : 37
    }, {
      "referenceID" : 26,
      "context" : "In other words, the constraint, aka the outside-to-inside constraint (Yli-Jyrä, 2005), states that no outgoing arc of a vertex properly covers an incoming arc.",
      "startOffset" : 69,
      "endOffset" : 85
    }, {
      "referenceID" : 14,
      "context" : "This is implied by a stronger constraint known as Harper, Hays, Lecerf and Ihm projectivity (Marcus, 1967).",
      "startOffset" : 92,
      "endOffset" : 106
    }, {
      "referenceID" : 4,
      "context" : "Properties UNAMBS, ACYCD, CONNW, and ACYCU are nonlocal properties of digraphs and cannot be generally verified locally, through finite spheres of vertices (Grädel et al., 2005).",
      "startOffset" : 156,
      "endOffset" : 177
    }, {
      "referenceID" : 7,
      "context" : "Finding the Components Representations of Reglat were built with scripts written using a finitestate toolkit (Hulden, 2009) that supports rapid exploration with regular languages and transducers.",
      "startOffset" : 109,
      "endOffset" : 123
    }, {
      "referenceID" : 28,
      "context" : "The finite set of encoded acyclic 5-vertex digraphs was computed with a finite-state approach (Yli-Jyrä et al., 2012) that takes the input projection of the composition",
      "startOffset" : 94,
      "endOffset" : 117
    }, {
      "referenceID" : 9,
      "context" : "This composition differs from the typical use where the purpose is to construct a regular relation (Kaplan and Kay, 1994) or its output projection (Roche, 1996; Oflazer, 2003).",
      "startOffset" : 99,
      "endOffset" : 121
    }, {
      "referenceID" : 22,
      "context" : "This composition differs from the typical use where the purpose is to construct a regular relation (Kaplan and Kay, 1994) or its output projection (Roche, 1996; Oflazer, 2003).",
      "startOffset" : 147,
      "endOffset" : 175
    }, {
      "referenceID" : 19,
      "context" : "This composition differs from the typical use where the purpose is to construct a regular relation (Kaplan and Kay, 1994) or its output projection (Roche, 1996; Oflazer, 2003).",
      "startOffset" : 147,
      "endOffset" : 175
    }, {
      "referenceID" : 27,
      "context" : "For digraphs with a lot of vertices, we had an option to employ a dynamic programming scheme (Yli-Jyrä, 2012) that uses weighted transducers.",
      "startOffset" : 93,
      "endOffset" : 109
    }, {
      "referenceID" : 16,
      "context" : "A careful reader may notice some connections to Eisner algorithm (Eisner and Satta, 1999), context-free parsing through intersection (Nederhof and Satta, 2003), and a dynamic programming scheme that uses contracting transducers and factorized composition (Yli-Jyrä, 2012).",
      "startOffset" : 133,
      "endOffset" : 159
    }, {
      "referenceID" : 27,
      "context" : "A careful reader may notice some connections to Eisner algorithm (Eisner and Satta, 1999), context-free parsing through intersection (Nederhof and Satta, 2003), and a dynamic programming scheme that uses contracting transducers and factorized composition (Yli-Jyrä, 2012).",
      "startOffset" : 255,
      "endOffset" : 271
    }, {
      "referenceID" : 10,
      "context" : ", 2017), KJ = Kuhlmann (2015) or Kuhlmann and Johnsson (2015), YJ = Yli-Jyrä (2012)",
      "startOffset" : 14,
      "endOffset" : 30
    }, {
      "referenceID" : 10,
      "context" : ", 2017), KJ = Kuhlmann (2015) or Kuhlmann and Johnsson (2015), YJ = Yli-Jyrä (2012)",
      "startOffset" : 14,
      "endOffset" : 62
    }, {
      "referenceID" : 10,
      "context" : ", 2017), KJ = Kuhlmann (2015) or Kuhlmann and Johnsson (2015), YJ = Yli-Jyrä (2012)",
      "startOffset" : 14,
      "endOffset" : 84
    }, {
      "referenceID" : 1,
      "context" : "It is well known that acyclicity and connecticity are not definable in first-order logic (FO) while they can be defined easily in monadic second order logic (MSO) (Courcelle, 1997).",
      "startOffset" : 163,
      "endOffset" : 180
    }, {
      "referenceID" : 0,
      "context" : "When the treewidth is bounded, all MSO definable properties, including the intractable ones, become linear time decidable for individual structures (Courcelle, 1990).",
      "startOffset" : 148,
      "endOffset" : 165
    }, {
      "referenceID" : 2,
      "context" : "They can also be decided in a logarithmic amount of writable space (Elberfeld et al., 2010), e.",
      "startOffset" : 67,
      "endOffset" : 91
    }, {
      "referenceID" : 20,
      "context" : "Future work We are planning to extend the coverage of the approach by exploring 1-endpointcrossing and MHk trees (Pitler et al., 2013; Gómez-Rodrı́guez, 2016), and related digraphs — see (Yli-Jyrä, 2004; Gómez-Rodrı́guez et al.",
      "startOffset" : 113,
      "endOffset" : 158
    }, {
      "referenceID" : 25,
      "context" : ", 2013; Gómez-Rodrı́guez, 2016), and related digraphs — see (Yli-Jyrä, 2004; Gómez-Rodrı́guez et al., 2011).",
      "startOffset" : 60,
      "endOffset" : 107
    }, {
      "referenceID" : 3,
      "context" : ", 2013; Gómez-Rodrı́guez, 2016), and related digraphs — see (Yli-Jyrä, 2004; Gómez-Rodrı́guez et al., 2011).",
      "startOffset" : 60,
      "endOffset" : 107
    } ],
    "year" : 2017,
    "abstractText" : "We present a simple encoding for unlabeled noncrossing graphs and show how its latent counterpart helps us to represent several families of directed and undirected graphs used in syntactic and semantic parsing of natural language as contextfree languages. The families are separated purely on the basis of forbidden patterns in latent encoding, eliminating the need to differentiate the families of non-crossing graphs in inference algorithms: one algorithm works for all when the search space can be controlled in parser input.",
    "creator" : "LaTeX with hyperref package"
  }
}