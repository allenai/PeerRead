{
  "name" : "1511.07663.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Approximate Probabilistic Inference via Word-Level Counting",
    "authors" : [ "Supratik Chakraborty", "Kuldeep S. Meel", "Rakesh Mistry", "Moshe Y. Vardi" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Probabilistic inference on large and uncertain data sets is increasingly being used in a wide range of applications. It is well-known that probabilistic inference is polynomially inter-reducible to model counting (Roth 1996). In a recent line of work, it has been shown (Chakraborty, Meel, and Vardi 2013; Chakraborty et al. 2014; Ermon et al. 2013; Ivrii et al. 2015) that one can strike a fine balance between performance and approximation guarantees for propositional model counting, using 2-universal hash functions (Carter and Wegman 1977) on Boolean domains. This has propelled the model-counting formulation to emerge as a promising “assembly language” (Belle, Passerini, and Van den Broeck 2015) for inferencing in probabilistic graphical models.\nIn a large class of probabilistic inference problems, an important case being lifted inference on first order representations (Kersting 2012), the values of variables come from finite but large (exponential in the size of the representation) domains. Data values coming from such domains are naturally encoded as fixed-width words, where the width\n∗The author list has been sorted alphabetically by last name; this should not be used to determine the extent of authors’ contributions. Copyright c© 2016, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nis logarithmic in the size of the domain. Conditions on observed values are, in turn, encoded as word-level constraints, and the corresponding model-counting problem asks one to count the number of solutions of a word-level constraint. It is therefore natural to ask if the success of approximate propositional model counters can be replicated at the word-level.\nThe balance between efficiency and strong guarantees of hashing-based algorithms for approximate propositional model counting crucially depends on two factors: (i) use of XOR-based 2-universal bit-level hash functions, and (ii) use of state-of-the-art propositional satisfiability solvers, viz. CryptoMiniSAT (Soos, Nohl, and Castelluccia 2009), that can efficiently reason about formulas that combine disjunctive clauses with XOR clauses.\nIn recent years, the performance of SMT (Satisfiability Modulo Theories) solvers has witnessed spectacular improvements (Barrett et al. 2012). Indeed, several highly optimized SMTsolvers for fixed-width words are now available in the public domain (Brummayer and Biere 2009; Jha, Limaye, and Seshia 2009; Hadarean et al. 2014; De Moura and Bjørner 2008). Nevertheless, 2-universal hash functions for fixed-width words that are also amenable to efficient reasoning by SMT solvers have hitherto not been studied. The reasoning power of SMTsolvers for fixed-width words has therefore remained untapped for word-level model counting. Thus, it is not surprising that all existing work on probabilistic inference using model counting (viz. (Chistikov, Dimitrova, and Majumdar 2015; Belle, Passerini, and Van den Broeck 2015; Ermon et al. 2013)) effectively reduce the problem to propositional model counting. Such approaches are similar to “bit blasting” in SMT solvers (Kroening and Strichman 2008).\nThe primary contribution of this paper is an efficient word-level approximate model counting algorithm SMTApproxMC that can be employed to answer inference queries over high-dimensional discrete domains. Our algorithm uses a new class of word-level hash functions that are 2-universal and can be solved by word-level SMTsolvers capable of reasoning about linear equalities on words. Therefore, unlike previous works, SMTApproxMC is able to leverage the power of sophisticated SMT solvers.\nTo illustrate the practical utility of SMTApproxMC, we implemented a prototype and evaluated it on a suite of benchmarks. Our experiments demonstrate that\nar X\niv :1\n51 1.\n07 66\n3v 3\n[ cs\n.A I]\n9 F\neb 2\n01 6\nSMTApproxMC can significantly outperform the prevalent approach of bit-blasting a word-level constraint and using an approximate propositional model counter that employs XOR-based hash functions. Our proposed word-level hash functions embed the domain of all variables in a large enough finite domain. Thus, one would not expect our approach to work well for constraints that exhibit a hugely heterogeneous mix of word widths, or for problems that are difficult for word-level SMT solvers. Indeed, our experiments suggest that the use of word-level hash functions provides significant benefits when the original word-level constraint is such that (i) the words appearing in it have long and similar widths, and (ii) the SMTsolver can reason about the constraint at the word-level, without extensive bit-blasting.\n2 Preliminaries A word (or bit-vector) is an array of bits. The size of the array is called the width of the word. We consider here fixedwidth words, whose width is a constant. It is easy to see that a word of width k can be used to represent elements of a set of size 2k. The first-order theory of fixed-width words has been extensively studied (see (Kroening and Strichman 2008; Bruttomesso 2008) for an overview). The vocabulary of this theory includes interpreted predicates and functions, whose semantics are defined over words interpreted as signed integers, unsigned integers, or vectors of propositional constants (depending on the function or predicate). When a word of width k is treated as a vector, we assume that the component bits are indexed from 0 through k − 1, where index 0 corresponds to the rightmost bit. A term is either a word-level variable or constant, or is obtained by applying functions in the vocabulary to a term. Every term has an associated width that is uniquely defined by the widths of word-level variables and constants in the term, and by the semantics of functions used to build the term. For purposes of this paper, given terms t1 and t2, we use t1 + t2 (resp. t1 ∗ t2) to denote the sum (resp. product) of t1 and t2, interpreted as unsigned integers. Given a positive integer p, we use t1 mod p to denote the remainder after dividing t1 by p. Furthermore, if t1 has width k, and a and b are integers such that 0 ≤ a ≤ b < k, we use extract(t1, a, b) to denote the slice of t1 (interpreted as a vector) between indices a and b, inclusively.\nLet F be a formula in the theory of fixed-width words. The support of F , denoted sup(F ), is the set of word-level variables that appear in F . A model or solution of F is an assignment of word-level constants to variables in sup(F ) such that F evaluates to True. We use RF to denote the set of models of F . The model-counting problem requires us to compute |RF |. For simplicity of exposition, we assume henceforth that all words in sup(F ) have the same width. Note that this is without loss of generality, since if k is the maximum width of all words in sup(F ), we can construct a formula F̂ such that the following hold: (i) |sup(F )| = |sup(F̂ )|, (ii) all word-level variables in F̂ have width k, and (iii) |RF | = |RF̂ |. The formula F̂ is obtained by replacing every occurrence of word-level variable x having width m (< k) in F with extract(x̂, 0,m− 1), where x̂ is a new\nvariable of width k. We write Pr [X : P] for the probability of outcome X when sampling from a probability space P . For brevity, we omit P when it is clear from the context.\nGiven a word-level formula F , an exact model counter returns |RF |. An approximate model counter relaxes this requirement to some extent: given a tolerance ε > 0 and confidence 1 − δ ∈ (0, 1], the value v returned by the counter satisfies Pr[ |RF |1+ε ≤ v ≤ (1 + ε)|RF |] ≥ 1 − δ. Our model-counting algorithm belongs to the class of approximate model counters.\nSpecial classes of hash functions, called 2-wise independent universal hash functions play a crucial role in our work. Let sup(F ) = {x0, . . . xn−1}, where each xi is a word of width k. The space of all assignments of words in sup(F ) is {0, 1}n.k. We use hash functions that map elements of {0, 1}n.k to p bins labeled 0, 1, . . . p − 1, where 1 ≤ p < 2n.k. Let Zp denote {0, 1, . . . p − 1} and let H denote a family of hash functions mapping {0, 1}n.k to Zp. We use h R←− H to denote the probability space obtained by choosing a hash function h uniformly at random fromH. We say that H is a 2-wise independent universal hash family if for all α1, α2 ∈ Zp and for all distinct X1,X2 ∈ {0, 1}n.k, Pr [ h(X1) = α1 ∧ h(X2) = α2 : h R←− H ] = 1/p2."
    }, {
      "heading" : "3 Related Work",
      "text" : "The connection between probabilistic inference and model counting has been extensively studied by several authors (Cooper 1990; Roth 1996; Chavira and Darwiche 2008), and it is known that the two problems are interreducible. Propositional model counting was shown to be #P-complete by Valiant (Valiant 1979). It follows easily that the model counting problem for fixed-width words is also #P-complete. It is therefore unlikely that efficient exact algorithms exist for this problem. (Bellare, Goldreich, and Petrank 2000) showed that a closely related problem, that of almost uniform sampling from propositional constraints, can be solved in probabilistic polynomial time using an NP oracle. Subsequently, (Jerrum, Valiant, and Vazirani 1986) showed that approximate model counting is polynomially inter-reducible to almost uniform sampling. While this shows that approximate model counting is solvable in probabilstic polynomial time relative to an NP oracle, the algorithms resulting from this largely theoretical body of work are highly inefficient in practice (Meel 2014).\nBuilding on the work of Bellare, Goldreich and Petrank (2000), Chakraborty, Meel and Vardi (2013) proposed the first scalable approximate model counting algorithm for propositional formulas, called ApproxMC. Their technique is based on the use of a family of 2-universal bit-level hash functions that compute XOR of randomly chosen propositional variables. Similar bit-level hashing techniques were also used in (Ermon et al. 2013; Chakraborty et al. 2014) for weighted model counting. All of these works leverage the significant advances made in propositional satisfiability solving in the recent past (Biere et al. 2009).\nOver the last two decades, there has been tremendous\nprogress in the development of decision procedures, called Satisfiability Modulo Theories (or SMT) solvers, for combinations of first-order theories, including the theory of fixed-width words (Barrett, Fontaine, and Tinelli 2010; Barrett, Moura, and Stump 2005). An SMT solver uses a core propositional reasoning engine and decision procedures for individual theories, to determine the satisfiability of a formula in the combination of theories. It is now folklore that a well-engineered word-level SMT solver can significantly outperform the naive approach of blasting words into component bits and then using a propositional satisfiability solver (De Moura and Bjørner 2008; Jha, Limaye, and Seshia 2009; Bruttomesso et al. 2007). The power of word-level SMT solvers stems from their ability to reason about words directly (e.g. a+ (b− c) = (a− c) + b for every word a, b, c), instead of blasting words into component bits and using propositional reasoning.\nThe work of (Chistikov, Dimitrova, and Majumdar 2015) tried to extend ApproxMC (Chakraborty, Meel, and Vardi 2013) to non-propositional domains. A crucial step in their approach is to propositionalize the solution space (e.g. bounded integers are equated to tuples of propositions) and then use XOR-based bit-level hash functions. Unfortunately, such propositionalization can significantly reduce the effectiveness of theory-specific reasoning in an SMT solver. The work of (Belle, Passerini, and Van den Broeck 2015) used bit-level hash functions with the propositional abstraction of an SMT formula to solve the problem of weighted model integration. This approach also fails to harness the power of theory-specific reasoning in SMT solvers.\nRecently, (de Salvo Braz et al. 2015) proposed SGDPLL(T ), an algorithm that generalizes SMT solving to do lifted inferencing and model counting (among other things) modulo background theories (denoted T ). A fixedwidth word model counter, like the one proposed in this paper, can serve as a theory-specific solver in the SGDPLL(T ) framework. In addition, it can also serve as an alernative to SGDPLL(T ) when the overall problem is simply to count models in the theory T of fixed-width words, There have also been other attempts to exploit the power of SMT solvers in machine learning. For example, (Teso, Sebastiani, and Passerini 2014) used optimizing SMT solvers for structured relational learning using Support Vector Machines. This is unrelated to our approach of harnessing the power of SMT solvers for probabilistic inference via model counting."
    }, {
      "heading" : "4 Word-level Hash Function",
      "text" : "The performance of hashing-based techniques for approximate model counting depends crucially on the underlying family of hash functions used to partition the solution space. A popular family of hash functions used in propositional model counting is Hxor, defined as the family of functions obtained by XOR-ing a random subset of propositional variables, and equating the result to either 0 or 1, chosen randomly. The family Hxor enjoys important properties like 2-independence and easy implementability, which make it ideal for use in practical model counters for propositional formulas (Gomes, Sabharwal, and Selman 2007;\nErmon et al. 2013; Chakraborty, Meel, and Vardi 2013). Unfortunately, word-level universal hash families that are 2- independent, easily implementable and amenable to wordlevel reasoning by SMT solvers, have not been studied thus far. In this section, we presentHSMT , a family of word-level hash functions that fills this gap.\nAs discussed earlier, let sup(F ) = {x0, . . . xn−1}, where each xi is a word of width k. We use X to denote the ndimensional vector (x0, . . . xn−1). The space of all assignments to words in X is {0, 1}n.k. Let p be a prime number such that 2k ≤ p < 2n.k. Consider a familyH of hash functions mapping {0, 1}n.k to Zp, where each hash function is of the form h(X) = ( ∑n−1 j=0 aj ∗ xj + b) mod p, and the aj’s and b are elements of Zp, represented as words of width dlog2 pe. Observe that every h ∈ H partitions {0, 1}n.k into p bins (or cells). Moreover, for every ξ ∈ {0, 1}n.k and α ∈ Zp, Pr [ h(ξ) = α : h R←− H ] = p−1. For a hash func-\ntion chosen uniformly at random fromH, the expected number of elements per cell is 2n.k/p. Since p < 2n.k, every cell has at least 1 element in expectation. Since 2k ≤ p, for every word xi of width k, we also have xi mod p = xi. Thus, distinct words are not aliased (or made to behave similarly) because of modular arithmetic in the hash function.\nSuppose now we wish to partition {0.1}n.k into pc cells, where c > 1 and pc < 2n.k. To achieve this, we need to define hash functions that map elements in {0, 1}n.k to a tuple in (Zp)c. A simple way to achieve this is to take a ctuple of hash functions, each of which maps {0, 1}n.k to Zp. Therefore, the desired family of hash functions is simply the iterated Cartesian product H × · · · × H, where the product is taken c times. Note that every hash function in this family is a c-tuple of hash functions. For a hash function chosen uniformly at random from this family, the expected number of elements per cell is 2n.k/pc.\nAn important consideration in hashing-based techniques for approximate model counting is the choice of a hash function that yields cells that are neither too large nor too small in their expected sizes. Since increasing c by 1 reduces the expected size of each cell by a factor of p, it may be difficult to satisfy the above requirement if the value of p is large. At the same time, it is desirable to have p > 2k to prevent aliasing of two distinct words of width k. This motivates us to consider more general classes of word-level hash functions, in which each word xi can be split into thinner slices, effectively reducing the width k of words, and allowing us to use smaller values of p. We describe this in more detail below.\nAssume for the sake of simplicity that k is a power of 2, and let q be log2 k. For every j ∈ {0, . . . q−1} and for every xi ∈ X, define xi(j) to be the 2j-dimensional vector of slices of the word xi, where each slice is of width k/2j . For example, the two slices in x1(1) are extract(x1, 0, k/2− 1) and extract(x1, k/2, k − 1). Let X(j) denote the n.2jdimensional vector (x0(j),x1(j), . . .xn−1(j)). It is easy to see that the mth component of X(j), denoted X (j) m , is extract(xi, s, t), where i = bm/2jc, s = (m mod 2j) · (k/2j) and t = s + (k/2j) − 1. Let pj de-\nnote the smallest prime larger than or equal to 2(k/2 j). Note that this implies pj+1 ≤ pj for all j ≥ 0. In order to obtain a family of hash functions that maps {0, 1}n.k to Zpj , we split each word xi into slices of width k/2j , treat these slices as words of reduced width, and use a technique similar to the one used above to map {0, 1}n.k to Zp. Specifically, the family H(j) ={ h(j) : h(j)(X) = (∑n.2j−1 m=0 a (j) m ∗X(j)m + b(j) ) mod pj\n} maps {0, 1}n.k to Zpj , where the values of a (j) m and b(j) are chosen from Zpj , and represented as dlog2 pje-bit words. In general, we may wish to define a family of hash functions that maps {0, 1}n.k to D, where D is given by (Zp0) c0 × (Zp1) c1 × · · · ( Zpq−1\n)cq−1 and∏q−1j=0 pcjj < 2n.k. To achieve this, we first consider the iterated Cartesian product of H(j) with itself cj times, and denote it by ( H(j)\n)cj , for every j ∈ {0, . . . q − 1}. Finally, the desired family of hash functions is obtained as ∏q−1 j=0 ( H(j)\n)cj . Observe that every hash function h in this family is a (∑q−1 l=0 cl ) -tuple\nof hash functions. Specifically, the rth component of h, for r ≤ (∑q−1 l=0 cl ) , is given by (∑n.2j−1 m=0 a (j) m ∗X(j)m + b(j) ) mod pj , where (∑j−1 i=0 ci ) < r ≤ (∑j i=0 ci ) , and the\na (j) m s and b(j) are elements of Zpj . The case when k is not a power of 2 is handled by splitting the words xi into slices of size dk/2e, dk/22e and so on. Note that the family of hash functions defined above depends only on n, k and the vector C = (c0, c1, . . . cq−1), where q = dlog2 ke. Hence, we call this family HSMT (n, k, C). Note also that by setting ci to 0 for all i 6= blog2(k/2)c, and ci to r for i = blog2(k/2)c reduces HSMT to the family Hxor of XOR-based bit-wise hash functions mapping {0, 1}n.k to {0, 1}r. Therefore, HSMT strictly generalizesHxor.\nWe summarize below important properties of the HSMT (n, k, C) class. All proofs are available in full version..\nLemma 1. For every X ∈ {0, 1}n.k and every α ∈ D, Pr[h(X) = α | h R←− HSMT (n, k, C)] = ∏|C|−1 j=0 pj −cj\nTheorem 1. For every α1, α2 ∈ D and every distinct X1,X2 ∈ {0, 1}n.k, Pr[(h(X1) = α1 ∧ h(X2) = α2) | h R←− HSMT (n, k, C)] = ∏|C|−1 j=0 (pj)\n−2.cj . Therefore, HSMT (n, k, C) is pairwise independent.\nGaussian Elimination The practical success of XORbased bit-level hashing techniques for propositional model counting owes a lot to solvers like CryptoMiniSAT (Soos, Nohl, and Castelluccia 2009) that use Gaussian Elimination to efficiently reason about XOR constraints. It is significant that the constraints arising from HSMT are linear modular equalities that also lend themselves to efficient Gaussian Elimination. We believe that integration of Gaussian Elimination engines in SMT solvers will significantly improve the performance of hashing-based word-level model counters."
    }, {
      "heading" : "5 Algorithm",
      "text" : "We now present SMTApproxMC, a word-level hashing-based approximate model counting algorithm. SMTApproxMC takes as inputs a formula F in the theory of fixed-width words, a tolerance ε (> 0), and a confidence 1−δ ∈ (0, 1]. It returns an estimate of |RF | within the tolerance ε, with confidence 1− δ. The formula F is assumed to have n variables, each of width k, in its support. The central idea of SMTApproxMC is to randomly partition the solution space of F into “small” cells of roughly the same size, using word-level hash functions from HSMT (n, k, C), where C is incrementally computed. The check for “small”-ness of cells is done using a word-level SMT solver. The use of word-level hash functions and a word-level SMT solver allows us to directly harness the power of SMT solving in model counting.\nThe pseudocode for SMTApproxMC is presented in Algorithm 1. Lines 1– 3 initialize the different parameters. Specifically, pivot determines the maximum size of a “small” cell as a function of ε, and t determines the number of times SMTApproxMCCore must be invoked, as a function of δ. The value of t is determined by technical arguments in the proofs of our theoretical guarantees, and is not based on experimental observations Algorithm SMTApproxMCCore lies at the heart of SMTApproxMC. Each invocation of SMTApproxMCCore either returns an approximate model count of F , or ⊥ (indicating a failure). In the former case, we collect the returned value, m, in a list M in line 8. Finally, we compute the median of the approximate counts in M , and return this as FinalCount.\nAlgorithm 1 SMTApproxMC(F, ε, δ, k) 1: counter← 0;M ← emptyList; 2: pivot← 2× de−3/2 ( 1 + 1ε )2e; 3: t← d35 log2(3/δ)e; 4: repeat 5: m← SMTApproxMCCore(F,pivot, k); 6: counter← counter + 1; 7: if m 6= ⊥ then 8: AddToList(M,m); 9: until (counter < t) 10: FinalCount← FindMedian(M); 11: return FinalCount;\nThe pseudocode for SMTApproxMCCore is shown in Algorithm 2. This algorithm takes as inputs a word-level SMT formula F , a threshold pivot, and the width k of words in sup(F ). We assume access to a subroutine BoundedSMT that accepts a word-level SMT formula ϕ and a threshold pivot as inputs, and returns pivot + 1 solutions of ϕ if |Rϕ| > pivot; otherwise it returns Rϕ. In lines 1– 2 of Algorithm 2, we return the exact count if |RF | ≤ pivot. Otherwise, we initialize C by setting C[0] to 0 and C[1] to 1, where C[i] in the pseudocode refers to ci in the previous section’s discussion. This choice of initialization is motivated by our experimental observations. We also count the number of cells generated by an arbitrary hash function from\nAlgorithm 2 SMTApproxMCCore(F,pivot, k) 1: Y ← BoundedSMT(F,pivot); 2: if |Y | ≤ pivot) then return |Y |; 3: else 4: C ← emptyVector; C[0]← 0; C[1]← 1; 5: i← 1; numCells← p1; 6: repeat 7: Choose h at random fromHSMT (n, k, C); 8: Choose α at random from ∏i j=0 ( Zpj )C[j]\n; 9: Y ← BoundedSMT(F ∧ (h(X) = α),pivot);\n10: if (|Y | > pivot) then 11: C[i]← C[i] + 1; 12: numCells← numCells× pi; 13: if (|Y | = 0) then 14: if pi > 2 then 15: C[i]← C[i]− 1; 16: i← i+ 1; C[i]← 1; 17: numCells← numCells× (pi+1/pi); 18: else 19: break; 20: until ((0 < |Y | ≤ pivot) or (numCells > 2n.k)) 21: if ((|Y | > pivot) or (|Y | = 0)) then return ⊥; 22: else return |Y | × numCells;\nHSMT (n, k, C) in numCells. The loop in lines 6–20 iteratively partitions RF into cells using randomly chosen hash functions from HSMT (n, k, C). The value of i in each iteration indicates the extent to which words in the support of F are sliced when defining hash functions in HSMT (n, k, C) – specifically, slices that are dk/2ie-bits or more wide are used. The iterative partitioning of RF continues until a randomly chosen cell is found to be “small” (i.e. has ≥ 1 and ≤ pivot solutions), or the number of cells exceeds 2n.k, rendering further partitioning meaningless. The random choice of h and α in lines 7 and 8 ensures that we pick a random cell. The call to BoundedSMT returns at most pivot+1 solutions of F within the chosen cell in the set Y . If |Y | > pivot, the cell is deemed to be large, and the algorithm partitions each cell further into pi parts. This is done by incrementing C[i] in line 11, so that the hash function chosen from HSMT (n, k, C) in the next iteration of the loop generates pi times more cells than in the current iteration. On the other hand, if Y is empty and pi > 2, the cells are too small (and too many), and the algorithm reduces the number of cells by a factor of pi+1/pi (recall pi+1 ≤ pi) by setting the values of C[i] and C[i+1] accordingly (see lines15 –17). If Y is nonempty and has no more than pivot solutions, the cells are of the right size, and we return the estimate |Y | × numCells. In all other cases, SMTApproxMCCore fails and returns ⊥.\nSimilar to the analysis of ApproxMC (Chakraborty, Meel, and Vardi 2013), the current theoretical analysis of SMTApproxMC assumes that for some C during the execution of SMTApproxMCCore, log |RF | − log(numCells) + 1 = log(pivot). We leave analysis of SMTApproxMC without above assumption to future work. The following theorems concern the correctness and performance of\nSMTApproxMC.\nTheorem 2. Suppose an invocation of SMTApproxMC(F, ε, δ, k) returns FinalCount. Then Pr [ (1 + ε)−1|RF | ≤ FinalCount ≤ (1 + ε)|RF | ] ≥ 1−δ\nTheorem 3. SMTApproxMC(F, ε, δ, k) runs in time polynomial in |F |, 1/ε and log2(1/δ) relative to an NP-oracle.\nThe proofs of Theorem 2 and 3 can be found in full version.."
    }, {
      "heading" : "6 Experimental Methodology and Results",
      "text" : "To evaluate the performance and effectiveness of SMTApproxMC, we built a prototype implementation and conducted extensive experiments. Our suite of benchmarks consisted of more than 150 problems arising from diverse domains such as reasoning about circuits, planning, program synthesis and the like. For lack of space, we present results for only for a subset of the benchmarks.\nFor purposes of comparison, we also implemented a stateof-the-art bit-level hashing-based approximate model counting algorithm for bounded integers, proposed by (Chistikov, Dimitrova, and Majumdar 2015). Henceforth, we refer to this algorithm as CDM, after the authors’ initials. Both model counters used an overall timeout of 12 hours per benchmark, and a BoundedSMT timeout of 2400 seconds per call. Both used Boolector, a state-of-the-art SMT solver for fixed-width words (Brummayer and Biere 2009). Note that Boolector (and other popular SMT solvers for fixedwidth words) does not yet implement Gaussian elimination for linear modular equalities; hence our experiments did not enjoy the benefits of Gaussian elimination. We employed the Mersenne Twister to generate pseudo-random numbers, and each thread was seeded independently using the Python random library. All experiments used ε = 0.8 and δ = 0.2. Similar to ApproxMC, we determined value of t based on tighter analysis offered by proofs. For detailed discussion, we refer the reader to Section 6 in (Chakraborty, Meel, and Vardi 2013). Every experiment was conducted on a single core of high-performance computer cluster, where each node had a 20-core, 2.20 GHz Intel Xeon processor, with 3.2GB of main memory per core.\nWe sought answers to the following questions from our experimental evaluation:\n1. How does the performance of SMTApproxMC compare with that of a bit-level hashing-based counter like CDM?\n2. How do the approximate counts returned by SMTApproxMC compare with exact counts?\nOur experiments show that SMTApproxMC significantly outperforms CDM for a large class of benchmarks. Furthermore, the counts returned by SMTApproxMC are highly accurate and the observed geometric tolerance(εobs) = 0.04.\nPerformance Comparison Table 1 presents the result of comparing the performance of SMTApproxMC vis-a-vis CDM on a subset of our benchmarks. In Table 1, column 1 gives the benchmark identifier, column 2 gives the sum of widths of all variables, column 3 lists the number of\nvariables (numVars) for each corresponding width (w) in the format {w : numVars}. To indicate the complexity of the input formula, we present the number of operations in the original SMT formula in column 4. The runtimes for SMTApproxMC and CDM are presented in columns 5 and column 6 respectively. We use “–” to denote timeout after 12 hours. Table 1 clearly shows that SMTApproxMC significantly outperforms CDM (often by 2-10 times) for a large class of benchmarks. In particular, we observe that SMTApproxMC is able to compute counts for several cases where CDM times out.\nBenchmarks in our suite exhibit significant heterogeneity in the widths of words, and also in the kinds of word-level operations used. Propositionalizing all word-level variables eagerly, as is done in CDM, prevents the SMT solver from making full use of word-level reasoning. In contrast, our approach allows the power of word-level reasoning to be harnessed if the original formula F and the hash functions are such that the SMT solver can reason about them without bit-blasting. This can lead to significant performance improvements, as seen in Table 1. Some benchmarks, however, have heterogenous bit-widths and heavy usage of operators like extract(x, n1, n2) and/or word-level multiplication. It is known that word-level reasoning in modern SMT solvers is not very effective for such cases, and the solver has to resort to bit-blasting. Therefore, using word-level hash functions does not help in such cases. We believe this contributes to the degraded performance of SMTApproxMC vis-a-vis CDM in a subset of our benchmarks. This also points to an interesting direction of future research: to find the right hash function for a benchmark by utilizing SMT solver’s architecture.\nQuality of Approximation To measure the quality of the counts returned by SMTApproxMC, we selected a subset of benchmarks that were small enough to be bit-blasted and fed to sharpSAT (Thurley 2006) – a state-of-the-art exact model counter. Figure 1 compares the model counts computed by SMTApproxMC with the bounds obtained by scaling the exact counts (from sharpSAT) with the tolerance factor (ε = 0.8). The y-axis represents model counts on log-scale while the x-axis presents benchmarks ordered in\nascending order of model counts. We observe that for all the benchmarks, SMTApproxMC computes counts within the tolerance. Furthermore, for each instance, we computed observed tolerance ( εobs) as count|RF | −1, if count ≥ |RF |, and |RF | count − 1 otherwise, where |RF | is computed by sharpSAT and count is computed by SMTApproxMC. We observe that the geometric mean of εobs across all the benchmarks is only 0.04 – far less (i.e. closer to the exact count) than the theoretical guarantee of 0.8."
    }, {
      "heading" : "7 Conclusions and Future Work",
      "text" : "Hashing-based model counting has emerged as a promising approach for probabilistic inference on graphical models. While real-world examples naturally have word-level constraints, state-of-the-art approximate model counters effectively reduce the problem to propositional model counting due to lack of non-bit-level hash functions. In this work, we presented, HSMT , a word-level hash function and used it to build SMTApproxMC, an approximate word-level model counter. Our experiments show that SMTApproxMC can significantly outperform techniques based on bit-level hashing.\nOur study also presents interesting directions for future\nwork. For example, adapting SMTApproxMC to be aware of SMT solving strategies, and augmenting SMT solving strategies to efficiently reason about hash functions used in counting, are exciting directions of future work.\nOur work goes beyond serving as a replacement for other approximate counting techniques. SMTApproxMC can also be viewed as an efficient building block for more sophisticated inference algorithms (de Salvo Braz et al. 2015). The development of SMT solvers has so far been primarily driven by the verification and static analysis communities. Our work hints that probabilistic inference could well be another driver for SMT solver technology development."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank Daniel Kroening for sharing his valuable insights on SMT solvers during the early stages of this project and Amit Bhatia for comments on early drafts of the paper. This work was supported in part by NSF grants IIS-1527668, CNS 1049862, CCF-1139011, by NSF Expeditions in Computing project ”ExCAPE: Expeditions in Computer Augmented Program Engineering”, by BSF grant 9800096, by a gift from Intel, by a grant from the Board of Research in Nuclear Sciences, India, Data Analysis and Visualization Cyberinfrastructure funded by NSF under grant OCI-0959097."
    } ],
    "references" : [ {
      "title" : "The SMT-LIB standard - Version 2.5. http://smtlib.cs.uiowa.edu",
      "author" : [ "Fontaine Barrett", "C. Tinelli 2010] Barrett", "P. Fontaine", "C. Tinelli" ],
      "venue" : null,
      "citeRegEx" : "Barrett et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Barrett et al\\.",
      "year" : 2010
    }, {
      "title" : "SMT-COMP: Satisfiability Modulo Theories Competition",
      "author" : [ "Moura Barrett", "C. Stump 2005] Barrett", "L. Moura", "A. Stump" ],
      "venue" : "In Proc. of CAV,",
      "citeRegEx" : "Barrett et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Barrett et al\\.",
      "year" : 2005
    }, {
      "title" : "Uniform generation of NP-witnesses using an NP-oracle",
      "author" : [ "Goldreich Bellare", "M. Petrank 2000] Bellare", "O. Goldreich", "E. Petrank" ],
      "venue" : "Information and Computation",
      "citeRegEx" : "Bellare et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Bellare et al\\.",
      "year" : 2000
    }, {
      "title" : "Probabilistic inference in hybrid domains by weighted model integration",
      "author" : [ "A. Passerini", "G. Van den Broeck" ],
      "venue" : "In Proc. of IJCAI,",
      "citeRegEx" : "V. et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "V. et al\\.",
      "year" : 2015
    }, {
      "title" : "Handbook of Satisfiability",
      "author" : [ "Biere" ],
      "venue" : null,
      "citeRegEx" : "Biere,? \\Q2009\\E",
      "shortCiteRegEx" : "Biere",
      "year" : 2009
    }, {
      "title" : "and Biere",
      "author" : [ "R. Brummayer" ],
      "venue" : "A.",
      "citeRegEx" : "Brummayer and Biere 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "A lazy and layered smt(bv) solver for hard industrial verification problems",
      "author" : [ "Bruttomesso" ],
      "venue" : "In Proc. of CAV,",
      "citeRegEx" : "Bruttomesso,? \\Q2007\\E",
      "shortCiteRegEx" : "Bruttomesso",
      "year" : 2007
    }, {
      "title" : "M",
      "author" : [ "J.L. Carter", "Wegman" ],
      "venue" : "N.",
      "citeRegEx" : "Carter and Wegman 1977",
      "shortCiteRegEx" : null,
      "year" : 1977
    }, {
      "title" : "M",
      "author" : [ "S. Chakraborty", "D.J. Fremont", "K.S. Meel", "S.A. Seshia", "Vardi" ],
      "venue" : "Y.",
      "citeRegEx" : "Chakraborty et al. 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "M",
      "author" : [ "S. Chakraborty", "K.S. Meel", "Vardi" ],
      "venue" : "Y.",
      "citeRegEx" : "Chakraborty. Meel. and Vardi 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "and Darwiche",
      "author" : [ "M. Chavira" ],
      "venue" : "A.",
      "citeRegEx" : "Chavira and Darwiche 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Approximate Counting for SMT and Value Estimation for Probabilistic Programs",
      "author" : [ "Dimitrova Chistikov", "D. Majumdar 2015] Chistikov", "R. Dimitrova", "R. Majumdar" ],
      "venue" : "In Proc. of TACAS,",
      "citeRegEx" : "Chistikov et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Chistikov et al\\.",
      "year" : 2015
    }, {
      "title" : "G",
      "author" : [ "Cooper" ],
      "venue" : "F.",
      "citeRegEx" : "Cooper 1990",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "and Bjørner",
      "author" : [ "L. De Moura" ],
      "venue" : "N.",
      "citeRegEx" : "De Moura and Bjørner 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Probabilistic inference modulo theories",
      "author" : [ "de Salvo Braz" ],
      "venue" : "In Workshop on Hybrid Reasoning at IJCAI",
      "citeRegEx" : "Braz,? \\Q2015\\E",
      "shortCiteRegEx" : "Braz",
      "year" : 2015
    }, {
      "title" : "C",
      "author" : [ "Ermon, S.", "Gomes" ],
      "venue" : "P.; Sabharwal, A.; and Selman, B.",
      "citeRegEx" : "Ermon et al. 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "C",
      "author" : [ "Gomes" ],
      "venue" : "P.; Sabharwal, A.; and Selman, B.",
      "citeRegEx" : "Gomes. Sabharwal. and Selman 2007",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "A tale of two solvers: Eager and lazy approaches to bit-vectors",
      "author" : [ "Hadarean" ],
      "venue" : "In Proc. of CAV,",
      "citeRegEx" : "Hadarean,? \\Q2014\\E",
      "shortCiteRegEx" : "Hadarean",
      "year" : 2014
    }, {
      "title" : "M",
      "author" : [ "A. Ivrii", "S. Malik", "K.S. Meel", "Vardi" ],
      "venue" : "Y.",
      "citeRegEx" : "Ivrii et al. 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Random generation of combinatorial structures from a uniform distribution",
      "author" : [ "Valiant Jerrum", "M. Vazirani 1986] Jerrum", "L. Valiant", "V. Vazirani" ],
      "venue" : "Theoretical Computer Science",
      "citeRegEx" : "Jerrum et al\\.,? \\Q1986\\E",
      "shortCiteRegEx" : "Jerrum et al\\.",
      "year" : 1986
    }, {
      "title" : "Beaver: Engineering an efficient smt solver for bitvector arithmetic",
      "author" : [ "Limaye Jha", "S. Seshia 2009] Jha", "R. Limaye", "S. Seshia" ],
      "venue" : "In Computer Aided Verification,",
      "citeRegEx" : "Jha et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Jha et al\\.",
      "year" : 2009
    }, {
      "title" : "and Strichman",
      "author" : [ "D. Kroening" ],
      "venue" : "O.",
      "citeRegEx" : "Kroening and Strichman 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "K",
      "author" : [ "Meel" ],
      "venue" : "S.",
      "citeRegEx" : "Meel 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Extending SAT Solvers to Cryptographic Problems",
      "author" : [ "Nohl Soos", "M. Castelluccia 2009] Soos", "K. Nohl", "C. Castelluccia" ],
      "venue" : "In Proc. of SAT",
      "citeRegEx" : "Soos et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Soos et al\\.",
      "year" : 2009
    }, {
      "title" : "Structured learning modulo theories",
      "author" : [ "Sebastiani Teso", "S. Passerini 2014] Teso", "R. Sebastiani", "A. Passerini" ],
      "venue" : "CoRR abs/1405.1675",
      "citeRegEx" : "Teso et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Teso et al\\.",
      "year" : 2014
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "Hashing-based model counting has emerged as a promising approach for large-scale probabilistic inference on graphical models. A key component of these techniques is the use of xor-based 2-universal hash functions that operate over Boolean domains. Many counting problems arising in probabilistic inference are, however, naturally encoded over finite discrete domains. Techniques based on bit-level (or Boolean) hash functions require these problems to be propositionalized, making it impossible to leverage the remarkable progress made in SMT (Satisfiability Modulo Theory) solvers that can reason directly over words (or bit-vectors). In this work, we present the first approximate model counter that uses word-level hashing functions, and can directly leverage the power of sophisticated SMT solvers. Empirical evaluation over an extensive suite of benchmarks demonstrates the promise of the approach.",
    "creator" : "LaTeX with hyperref package"
  }
}