{
  "name" : "1203.3528.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Rollout Sampling Policy Iteration for Decentralized POMDPs",
    "authors" : [ "Feng Wu", "Xiaoping Chen" ],
    "emails" : [ "wufeng@mail.ustc.edu.cn", "shlomo@cs.umass.edu", "xpchen@ustc.edu.cn" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We present decentralized rollout sampling policy iteration (DecRSPI) — a new algorithm for multi-agent decision problems formalized as DEC-POMDPs. DecRSPI is designed to improve scalability and tackle problems that lack an explicit model. The algorithm uses MonteCarlo methods to generate a sample of reachable belief states. Then it computes a joint policy for each belief state based on the rollout estimations. A new policy representation allows us to represent solutions compactly. The key benefits of the algorithm are its linear time complexity over the number of agents, its bounded memory usage and good solution quality. It can solve larger problems that are intractable for existing planning algorithms. Experimental results confirm the effectiveness and scalability of the approach."
    }, {
      "heading" : "1 Introduction",
      "text" : "Planing under uncertainty in multi-agent settings is a challenging computational problem, particularly when agents with imperfect sensors and actuators, such as autonomous rovers or rescue robots, must reason about a large space of possible outcomes and choose a plan based on their incomplete knowledge. The partially observable Markov decision process (POMDP) has proved useful in modeling and analyzing this type of uncertainty in single-agent domains. When multiple cooperative agents are present, each agent must also reason about the decisions of the other agents and how they may affect the environment. Since each agent can only obtain partial information about the environment and sharing all the local information among the agents is often impossible, each agent must act based solely on its local information. These problems can be modeled as decentralized POMDPs (DEC-POMDPs) [2].\nWhen a complete model of the domain is available, DECPOMDPs can be solved using a wide range of optimal or\napproximate algorithms, particularly MBDP [18] and its descendants [1, 8, 17]. Unfortunately, these algorithms are quite limited in terms of the size of the problems they can tackle. This is not surprising given that finite-horizon DECPOMDPs are NEXP-complete [2]. Intuitively, the main reason is that it is hard to define a compact belief state and compute a value function for DEC-POMDPs, as is often done for POMDPs. The state and action spaces blow-up exponentially with the number of agents. Besides, it is very difficult to search over the large policy space and find the best action for every possible situation.\nAnother key challenge is modeling the dynamics of the entire domain, which may include complex physical systems. Existing DEC-POMDP algorithms assume that a complete model of the domain is known. This assumption does not hold in some real-world applications such as robot soccer. Incomplete domain knowledge is often addressed by reinforcement learning algorithms [19]. However, most cooperative multi-agent reinforcement learning algorithms assume that the system state is completely observable by all the agents [6]. Learning cooperative policies for multiagent partially-observable domains is extremely challenging due to the large space of possible policies given only the local view of each agent.\nIn reinforcement learning, a class of useful techniques such as Monte-Carlo methods allows agents to choose actions based on experience [19]. These methods require no prior knowledge of the dynamics, as long as sample trajectories can be generated online or using a simulator of the environment. Although a model is required, it must only provide enough information to generate samples, not the complete probability distributions of all possible transitions that are required by planning algorithms. In many cases it is easy to generate samples by simulating the target environment, but obtaining distributions in explicit form may be much harder. In the robot soccer domain, for example, there exist many high-fidelity simulation engines. It is also possible to put a central camera on top of the field and obtain samples by running the actual robots.\nThis paper introduces the decentralized rollout sampling\npolicy iteration (DecRSPI) algorithm for finite-horizon DEC-POMDPs. Our objective is to compute a set of cooperative policies using Monte-Carlo methods, without having an explicit representation of the dynamics of the underlying system. DecRSPI first samples a set of reachable belief states based on some heuristic policies. Then it computes a joint policy for each belief state based on the rollout estimations. Similar to dynamic programming approaches, policies are constructed from the last step backwards. A new policy representation is used to bound the amount of memory. To the best of our knowledge, this is the first rollout-based learning algorithm for finite-horizon DEC-POMDPs. DecRSPI has linear time complexity over the number of agents and it can solve much larger problems compared to existing planning algorithms.\nWe begin with some background on the DEC-POMDP model and the policy structure we use. We then describe each component of the rollout sampling algorithm and analyze its properties. Finally, we examine the performance of DecRSPI on a set of test problems, and conclude with a summary of related work and the contributions."
    }, {
      "heading" : "2 Decentralized POMDPs",
      "text" : "Formally, a finite-horizon DEC-POMDP can be defined as a tuple 〈I, S, {Ai}, {Ωi}, P,O,R, b0, T 〉, where • I is a collection of agents, identified by i ∈ {1 . . .m}, and T is the time horizon of the problem.\n• S is a finite state space and b0 is the initial belief state (i.e., a probability distribution over states).\n• Ai is a discrete action space for agent i. We denote by ~a = 〈a1, a2, · · · , am〉 a joint action where ai ∈ Ai and ~A = ×i∈IAi is the joint action space. • Ωi is a discrete observation space for agent i. Similarly ~o = 〈o1, o2, · · · , om〉 is a joint observation where oi ∈ Ωi and ~Ω = ×i∈IΩi is the joint observation space.\n• P : S× ~A→ ∆(S) is the state transition function and P (s′|s,~a) denotes the probability of the next state s′ when the agents take joint action ~a in state s.\n• O : S × ~A → ∆(~Ω) is an observation function and O(~o|s′,~a) denotes the probability of observing ~o after taking joint action ~a with outcome state s′.\n• R : S × ~A → R is a reward function and R(s,~a) is the immediate reward after agents take ~a in state s.\nIn a DEC-POMDP, each agent i ∈ I executes an action ai based on its policy at each time step t. Thus a joint action ~a of all the agents is performed, followed by a state transition of the environment and an identical joint reward obtained by the team. Then agent i receives its private observation oi from the environment and updates its policy for the next execution cycle. The goal of each agent is to choose a policy\nthat maximizes the accumulated reward of the team over the horizon T , i.e. ∑T t=1E[R(t)|b0].\nGenerally, a policy qi is a mapping from agent i’s observation history to an action ai and a joint policy ~q = 〈q1, q2, · · · , qm〉 is a vector of policies, one for each agent. The value of a fixed joint policy ~q at state s can be computed recursively by the Bellman equation:\nV (s, ~q) = R(s,~a) + ∑ s′,~o P (s′|s,~a)O(~o|s′,~a)V (s′, ~q~o)\nwhere ~a is the joint action specified by ~q, and ~q~o is the joint sub-policy of ~q after observing ~o. Given a state distribution b ∈ ∆(s), the value of a joint policy ~q can be computed by\nV (b, ~q) = ∑ s∈S b(s)V (s, ~q) (1)\nNote that in a DEC-POMDP, each agent can only receive its own local observations when executing the policy. Therefore the policy must be completely decentralized, which means the policy of an agent must be guided by its own local observation history only. It is not clear how to maintain a sufficient statistic, such as a belief state in POMDPs, based only on the local partial information of each agent. Thus, most of the works on multi-agent partially observable domains are policy-based and learning in DEC-POMDP settings is extremely challenging. While the policy execution is decentralized, planning or learning algorithms can operate offline and thus may be centralized [11, 18].\nThe policies for finite-horizon DEC-POMDPs are often represented as a set of local policy trees [1, 8, 11, 17, 18]. Each tree is defined recursively with an action at the root and a subtree for each observation. This continues until the horizon is reached at a leaf node. A dynamic programming (DP) algorithm was developed to build the policy trees optimally from the bottom up [11]. In this algorithm, the policies of the next iteration are enumerated by an exhaustive backup of the current trees. That is, for each action and each resulting observation, a branch to any of the current trees is considered. Unfortunately, the number of possible trees grows double-exponentially over the horizon. Recently, memory-bounded techniques have been introduced. These methods keep only a fixed number of trees at each iteration [1, 8, 17, 18]. They use a fixed amount of memory and have linear complexity over the horizon.\nThere are many possibilities for constructing policies with bounded memory. In this work we use a stochastic policy for each agent. It is quite similar to stochastic finite state controllers (FSC), used to solve infinite-horizon POMDPs [16] and DEC-POMDPs [3]. But our stochastic policies have a layered structure, one layer for each time step. Each layer has a fixed number of decision nodes. Each node is labeled with an action and includes a node selection function. The selection function is a mapping from an observation to\na probability distribution over the nodes of the next layer. In this paper, we denote by Qti the set of decision nodes of agent i ∈ I at time step t ∈ 1..T . Also, N denotes the predetermined size of Qti and π(q ′ i|oi) is the probability of selecting the node of the next layer q′i after observing oi.\nAn example of such stochastic policies is shown in Figure 1. In the planning phase, a set of stochastic polices are constructed offline, one for each agent. When executing the policy, each agent executes the action in the current node and then transitions to the next node based on the received observation as well as the node selection function. We show how the stochastic node selection function can be optimized easily by our policy improvement technique. The following sections describe the algorithm in details."
    }, {
      "heading" : "3 The Rollout Sampling Method",
      "text" : "In this section, we propose a new rollout sampling policy iteration (DecRSPI) for DEC-POMDPs that heuristically generates stochastic policies using an approximate policy improvement operator trained with Monte-Carlo simulation. The approximate operator performs policy evaluation by simulation, evaluating a joint policy ~q at state s by drawingK sample trajectories of ~q starting at s. Then, the operator performs policy improvement by constructing a series of linear programs with parameters computed from samples and then solving the linear programs to induce a new improved approximate policy. Similar to MBDP, DecRSPI generates policies using point-based dynamic programming, which builds policies according to heuristic state distributions from the bottom up. The key difference is that DecRSPI improves the policies by simulation without knowing the exact transition function P , observation function O and reward function R of the DEC-POMDP model.\nNote that DecRSPI is performed offline in a centralized way, but the computed policies are totally decentralized. The use of simulation assumes that the state of the environment can be reset and the system information (state, reward and observations) are available after executing a joint action by the agents. In the planning phase, this information is often available. In large real-world systems, modeling\nAlgorithm 1: Rollout Sampling Policy Iteration generate a random joint policy ~Q given T,N sample a set of beliefs B for t ∈ 1..T, n ∈ 1..N for t=T to 1 do\nfor n=1 to N do b← Btn, ~q ← ~Qtn repeat\nforeach agent i ∈ I do keep the other agents’ policies q−i fixed foreach action ai ∈ Ai do\nΦi ← estimate the parameter matrix build a linear program with Φi πi ← solve the linear program ∆i ← ∆i ∪ {〈ai, πi〉}\n〈ai, πi〉∗←argmax∆i Rollout(b, 〈ai, πi〉) update agent i’s policy qi by 〈ai, πi〉∗\nuntil no improvement in all agents’ policies\nreturn the joint policy ~Q\nthe exact DEC-POMDP is extremely challenging and even the representation itself is nontrivial for several reasons. First, the system may be based on some complex physical models and it may be difficult to compute the exact P , O and R. Second, the state, action and observation spaces may be very large, making it hard to store the entire transition table. Fortunately, simulators of these domains are often available and can be modified to compute the policies as needed.\nWe activate DecRSPI by providing it with a random joint policy and a set of reachable state distributions, computed by some heuristics. The joint policy is initialized by assigning a random action and random node selection functions for each decision node from layer-1 to layer-T . Policy iteration is performed from the last step t=T backward to the first step t=1. At each iteration, we first choose a state distribution and an unimproved joint policy. Then we try to improve the joint policy based on the state distribution. This is done by keeping the policies of the other agents fixed and searching for the best policy of one agent at a time. We continue to alternate between the agents until no improvement is achievable for the current policies of all the agents. This process is summarized in Algorithm 1."
    }, {
      "heading" : "3.1 Belief Sampling",
      "text" : "In this paper, the belief state b ∈ ∆(S) is a probability distribution over states. We use it interchangeably with the state distribution with the same meaning. Generally, given belief state bt at time t, we determine ~at, execute ~at and make a subsequent observation ~o t+1, then update our belief state to obtain bt+1. In single-agent POMDPs, this belief state is obtained via straightforward Bayesian updating, by computing bt+1 = Pr(S|bt, ~at, ~o t+1). Unfortunately, even if the transition and observation functions are available, the belief update itself is generally time-consuming\nAlgorithm 2: Belief Sampling for n=1 to N do\nBtn ← ∅ for t ∈ 1..T h← choose a heuristic policy for k=1 to K do\ns← draw a state from b0 for t=1 to T do\nθt ← θt ∪ {btk(s)} ~a← select a joint action based on h s′ ← simulate the model with s,~a s← s′\nfor t=1 to T do bt ← compute the belief by particle set θt Btn ← Btn ∪ {bt}\nreturn the belief set B\nbecause each belief state is a vector of size |S|. To approximate belief states by simulation, consider the following particle filtering procedure. At any time step t, we have a collection θt of K particles. The particle set θt, t ∈ 1..T represents the following state distribution:\nbt(s) = ∑K\nk=1{1 : btk(s) ∈ θt} K ,∀s ∈ S (2)\nwhere btk(s) is the k th particle of θt. As mentioned above, the significance of this method lies in the fact that, for many applications, it is easy to sample successor states according to the system dynamics. But direct computation of beliefs is generally intractable especially when the dynamics specification is unavailable.\nAnother key question is how to choose the heuristic policies. In fact, the usefulness of the heuristics and, more importantly, the computed belief states, are highly dependent on the specific problem. Instead of just using one heuristic, a whole portfolio of heuristics can be used to compute a set of belief states. Thus, each heuristic is used to select a subset of the policies. There are a number of possible alternatives. Our first choice is the random policy, where agents select actions randomly from a uniform distribution at each time step. Another choice is the policy of the underlying MDP. That is, agents can learn an approximate MDP value function by some MDP learning algorithms and then select actions greedily based on that value function. In specific domains such as robot soccer, where learning theMDP policy is also hard, hand-coded policies or policies learned by DecRSPI itself with merely random guidance are also useful as heuristics. The overall belief sampling method is detailed in Algorithm 2."
    }, {
      "heading" : "3.2 Policy Improvement",
      "text" : "In multi-agent settings, agents with only local information must reason about all the possible choices of the others and select the optimal joint policy that maximizes the team’s expected reward. One straightforward method for finding\nthe optimal joint policy is to simply search over the entire space of possible policies, evaluate each one, and select the policy with the highest value. Unfortunately, the number of possible joint policies is O((|Ai|(|Ωi|\nT−1)/(|Ωi|−1))|I|). Instead of searching over the entire policy space, dynamic programming (DP) constructs policies from the last step up to the first one and eliminates dominated policies at the early stages [11]. However, the exhaustive backup in the DP algorithm at t still generates agent i’s policies of the order O(|Ai||Qt−1i ||Ωi|). Memory-bounded techniques have been developed to combine the top-down heuristics and the bottom-up dynamic programming together, keeping only a bounded number of policies at each iteration [18]. This results in linear complexity over the horizon, but the one-step backup operation is still time-consuming [17].\nOur algorithm is based on the MBDP algorithm [18], but it approximates the backup operation with an alternating maximization process. As shown in Algorithm 1, the basic idea is to choose each agent in turn and compute the best-response policy, while keeping the policies of the other agents fixed. This process is repeated until no improvement is possible for all agents. That is, the process ends when the joint policy converges to a Nash equilibrium. This method was first introduced by Nair et al. [14] and later refined by Bernstein et al. [3]. The differences are: Nair et al. use the method to reformulate the problem as an augmented POMDP; Bernstein et al. use it to optimize the controllers of infinite-horizon DEC-POMDPs. In contrast, when an agent is chosen, our algorithm approximates the best-response policy that maximizes the following value:\nV (b, ~q) = R(b,~a)+ ∑\ns′,~o,~q ′ Pr(s′, ~o|b,~a) ∏ i π(q′i|oi)V (s′, ~q ′)\n(3) where Pr(s′, ~o|b,~a) = ∑ s∈S b(s)P (s\n′|s,~a)O(~o|s′,~a) and R(b,~a) = ∑ s∈S b(s)R(s,~a). This value function is similar to Equation 1, but for a stochastic joint policy.\nNotice that our algorithm is designed to work when an explicit form of system dynamics is not available. Our solution, as shown in Algorithm 1, is two-fold: first we find the best node selection function πi for every action ai ∈ Ai and generate a set of stochastic policies∆i; then we evaluate the policy qi ∈ ∆i for the given belief point b, choose the best one and update the current policy of agent i with it. In order to find the best πi that maximizes the value function of Equation 3 given ai and other agents’ policies q−i, we use the linear program shown in Table 1. Note that\nAlgorithm 3: Parameter Estimation Input: b, ai, q−i a−i ← get actions from q−i for k=1 to K do\ns← draw a state from b s′, ~o← simulate the model with s,~a ωoi(s\n′, o−i)← ωoi(s′, o−i) + 1 normalize ωoi for ∀oi ∈ Ωi foreach oi ∈ Ωi, q′i ∈ Qt+1i do\nfor k=1 to K do s′, o−i ← draw a sample from ωoi q′−i ← get other agents’ policy π(·|q−i, o−i) Φi(oi, q ′ i)k ← Rollout(s′, ~q ′) Φi(oi, q ′ i)← 1K ∑K k=1 Φi(oi, q ′ i)k\nreturn the parameter matrix Φi\nR(b,~a) is a constant given b, ai, q−i and is thus omitted. The matrix Φi of the linear program is defined as follows:\nΦi(oi, q′i) = ∑\ns′,o−i,q′−i\nPr(s′, ~o|b,~a)π(q′−i|o−i)V (s′, ~q ′)\nwhere π(q′−i|o−i) = ∏ k 6=i π(q ′ k|ok). Since the dynamics is unknown, Algorithm 3 is used to estimateΦi. It first estimates Pr(s′, ~o|b,~a) by drawing K samples from one-step simulation. Then it estimates each element of Φi by another K samples with π(q′−i|o−i). The value of V (s′, ~q\n′) is approximated by the rollout operation as follows."
    }, {
      "heading" : "3.3 Rollout Evaluation",
      "text" : "The rollout evaluation is a Monte-Carlo method to estimate the value of a policy ~q at a state s (or belief state b), without requiring an explicit representation of the value function as the DP algorithm does. A rollout for 〈s, ~q〉 simulates a trajectory starting from state s and choosing actions according to policy ~q up to the horizon T . The observed total accumulated reward is averaged overK rollouts to estimate the value V (s, ~q). If a belief state b is given, it is straightforward to draw a state s from b and perform this simulation. The outline of the rollout process is given in Algorithm 4.\nThe accuracy of the expected value estimate improves with the number of rollouts. Intuitively, the value starting from 〈s, ~q〉 can be viewed as a random variable whose expectation is V (s, ~q). Each rollout term vk is a sample of this random variable and the average of these Ṽ is an unbiased estimate of V (s, ~q). Thus, we can apply the following Hoeffding bounds to determine the accuracy of this estimate.\nProperty 1 (Hoeffding inequality). Let V be a random variable in [Vmin, Vmax] with V̄ = E[V ], observed values v1, v2, · · · , vK of V , and Ṽ = 1K ∑K k=1 vk. Then\nPr(Ṽ ≤ V̄ + ε) ≥ 1− exp ( −2Kε2/V 2∆ ) Pr(Ṽ ≥ V̄ − ε) ≥ 1− exp ( −2Kε2/V 2∆\n) where V∆ = Vmax − Vmin is the range of values.\nAlgorithm 4: Rollout Evaluation Input: t, s, ~q t for k=1 to K do\nvk ← 0 while t ≤ T do\n~a← get the joint action from ~q t s′, r, ~o← simulate the model with s,~a vk ← vk + r, ~q t+1 ← π(·|~q t, ~o) s← s′, t← t+ 1\nṼ ← 1 K ∑K k=1 vk return the average value Ṽ\nGiven a particular confidence threshold δ and a size of samples K, we can produce a PAC-style error bound ε on the accuracy of our estimate Ṽ :\nε =\n√ V 2∆ ln ( 1 δ )\n2K (4)\nProperty 2. If the number of rollouts K is infinitely large, the average value returned by the rollout algorithm Ṽ will converge to the expected value of the policy V̄ .\nThe required sample size given error tolerance ε and confidence threshold δ for the estimation of Ṽ is:\nK(ε, δ) = V 2∆ ln ( 1 δ )\n2ε2 (5)\nIt is difficult to compute a meaningful error bound for the overall algorithm. There are several reasons: (1) DecRSPI is an MBDP-based algorithm and MBDP itself has no guarantee on the solution quality since the belief sampling method is based on domain-dependent heuristics; (2) the local search technique — which updates one agent’s policy at a time — could get stuck in a suboptimal Nash equilibrium; and (3) the error may accumulate over the horizon, because the policies of the current iteration depend on the policies of previous iterations. Thus, we demonstrate the performance and benefits of DecRSPI largely based on experimental results."
    }, {
      "heading" : "3.4 Complexity Analysis",
      "text" : "Note that the size of each agent’s policy is predetermined with T layers and N decision nodes in each layer. At each iteration, DecRSPI chooses an unimproved joint policy and tries to improve the policy parameters (actions and node selection functions) of each agent. Thus, the amount of space is of the order O(mTN) for m agents. Several rollouts are performed in the main process of each iteration. The time per rollout grows linearly with T . Therefore, the total time with respect to the horizon is on the order of 1 + 2 + · · ·+ T = (T 2 + T )/2, i.e. O(T 2). Theorem 3. The DecRSPI algorithm has linear space and quadratic time complexity with respect to the horizon T .\nClearly, the amount of space grows linearly with the number of agents. At each iteration, the main loop chooses N joint policies. For each joint policy, the improvement process selects agents alternatively until no improvement is possible. In practice, we set thresholds both for the minimum improvement (e.g. 10−4) and the maximum repeat count (e.g. 100). The improvement process terminates when one of these bounds is reached. Theoretically, the runtime of a rollout inside the improvement process is independent of the number of agents. However in practice, systems with more agents will take significantly more time to simulate, thereby increasing the time per rollout. But this is due to the complexity of domains or simulators, not the complexity of the DecRSPI algorithm.\nTheorem 4. Ignoring system simulation time, the DecRSPI algorithm has linear time and space complexity with respect to the number of agents |I|."
    }, {
      "heading" : "4 Experiments",
      "text" : "We performed experiments on several common benchmark problems in the DEC-POMDP literature to evaluate the solution quality and runtime of DecRSPI. A larger distributed sensor network domain was used to test the scalability of DecRSPI with respect to the number of agents."
    }, {
      "heading" : "4.1 Benchmark Problems",
      "text" : "We first tested DecRSPI on several common benchmark problems for which the system dynamics— an explicit representation of the transition, observation and reward functions — is available. To run the learning algorithm, we implemented a DEC-POMDP simulator based on the dynamics and learned the joint policy from the simulator. We used two types of heuristic policies to sample belief states: the\nrandom policy that randomly chooses an action with a uniform distribution, and the MDP-based policy that chooses an action according to the global state (which is known during the learning phase). For the benchmark problems, we solved the underlying MDP models and used the policies for sampling. DecRSPI selects a heuristic each time with a chance of 0.55 acting randomly and 0.45 for MDP policies.\nThere are few work on learning policies in the general DEC-POMDP setting. In the experiments, we compared our results with the distributed gradient descent (DGD) [15] with different horizons. The DGD approach performs the gradient-descent algorithm for each agent independently to adapt the parameters of each agent’s local policy. We also present the results of PBIP-IPG [1] — the best existing planning algorithm— for these domains. Notice that PBIP-IPG computes the policy based on an explicit model of system dynamics. Thus, the values of PBIP-IPG can be viewed as upper bounds for learning algorithms. Due to the randomness of Monte-Carlo methods, we ran the algorithm 20 times per problem and reported average runtimes and values. The default number of policy nodes N is 3 and the number of samplesK is 20.\nWe experimented with three common DEC-POMDP benchmark problems, which are also used by PBIPIPG [1]. The Meeting in a 3×3 Grid problem [3] involves two robots that navigate in a 3×3 grid and try to stay as much time as possible in the same cell. We adopted the version used by Amato et al. [1], which has 81 states, 5 actions and 9 observations per robot. The results for this domain with different horizons are given in Figure 2(a). The Cooperative Box Pushing problem [17] involves two robots that cooperate with each other to push boxes to their destinations in a 3×4 grid. This domain has 100 states, 4 actions and 5 observations per robot. The results are given in Figure 2(b). The Stochastic Mars Rover problem [1] is\na larger domain with 2 robots, 256 states, 6 actions and 8 observations per robot. The results are given in Figure 2(c).\nIn all three domains, DecRSPI outperforms DGD with large margins. In the Meeting in Grid and Mars Rover domains, the learning results of DecRSPI are quite close to the planning values of PBIP-IPG. Note that PBIP-IPG is also an MBDP-based algorithm whose values represent good upper bounds on the learning quality of DecRSPI. Being close to the value of PBIP-IPG means that DecRSPI does learn good policies given the same heuristics and policy sizes. In the Cooperative Box Pushing domain, the gap between DecRSPI and PBIP-IPG is a little bit larger because this problem has more complex interaction structure than the other two domains. Interestingly, in this domain, the value of DGD decreases with the horizon.\nWe also present timing results for each domain with different horizons (T ) in Figure 2(d), which shows the same property (quadratic time complexity) as stated in Theorem 3. In Figure 2(e), we test DecRSPI with different number of trials (K) and a fixed horizon of 20. The value of the Meeting in Grid and Mars Rover domains becomes stable when the number of trials is larger than 10. But the Box Pushing problem needs more trials (about 40) to get to a stable value, which is very close to the value of PBIP-IPG. In Figure 2(f), we show that runtime grows linearly with the number of trials in all three domains. It is worthwhile to point out that in these experimental settings, DecRSPI runs much faster than PBIP-IPG. For example, in the Stochastic Mars Rover domain with horizon 20, PBIP-IPG may take 14947s while DecRSPI only needs 49.8s."
    }, {
      "heading" : "4.2 Distributed Sensor Network",
      "text" : "The distributed sensor network (DSN) problem, adapted from [20], consists of two chains with identical number of sensors as shown in Figure 3. The region between the chains is split into cells and each cell is surrounded by four sensors. The two targets can move around in the place, either moving to a neighboring cell or staying in place with equal probability. Each target starts with an energy level of 2. A target is captured and removed when it reaches 0. Each sensor can take 3 actions ( track-left, track-right and none) and has 4 observations (left and right cells are occupied or not), resulting in joint spaces of 3|I| actions and 4|I| observations (e.g. 320≈ 3.5 × 109 joint actions and 420≈ 1.1× 1012 joint observations for the 20 agents case). Each track action has a cost of 1. The energy of a target will be decreased by 1 if it is tracked by at least three of the\nfour surrounding sensors at the same time. When a target is captured, the team gets a reward of 10. When all targets are captured, the DSN restarts with random target positions.\nThis domain is designed to demonstrate the scalability of DecRSPI over the number of agents. Most of the planning algorithms for general DEC-POMDPs have only been tested in domains with 2 agents [1, 8, 11, 17, 18]. It is very challenging to solve a general DEC-POMDP problems with many agents because the joint action and observation spaces grow exponentially over the number of agents. Our results in the DSN domain with horizon 10 and random heuristics are shown in Figure 4. Again, DecRSPI achieves much better value than DGD. The value decreases with the growing number of agents because there are more cells for the targets to move around and greater chance of sensor miscoordination. Note that DecRSPI solves this problem without using any specific domain structure and the learned policies are totally decentralized, without any assumption of communication or global observability. The figure also shows two measures of timing results: DecRSPI-Time — the runtime of DecRSPI, and DecRSPI+SIM-Time — the overall runtime including domain simulation time. The two measures of runtime grow with the number of agents. As stated in Theorem 4, DecRSPI-Time grows linearly, which shows that it scales up very well with the number of agents."
    }, {
      "heading" : "5 Related Work",
      "text" : "Several policy search algorithms have been introduced to learn agents’ policies without the system dynamics. The distributed gradient descent (DGD) algorithm performs gradient-based policy search independently on each agent’s local controller using the experience data [15]. Zhang et al. [20] proposed an online natural actor-critic algorithm using conditional random fields (CRF). It can learn cooperative policies with CRFs, but it assumes that agents can communicate and share their local observations at every step. Melo [13] proposed another actor-critic algorithm with natural gradient, but it only works for transition-independent DEC-POMDPs. In contract, our algorithm learns cooperative policies for the general DEC-POMDP setting without any assumption about communication.\nThe rollout sampling method has been introduced to learn MDP policies without explicitly representing the value function [9, 10, 12]. The main idea is to produce training data through extensive simulation (rollout) of the previous policy and use a supervised learning algorithm (e.g. SVM) to learn a new policy from the labeled data. The rollout technique is also widely used to perform lookahead and estimate the value of action in online methods [4, 5, 7]. Our algorithm uses rollout sampling to estimate the parameters of policy improvements and select the best joint policy."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We have presented the decentralized rollout sampling policy iteration (DecRSPI) algorithm for learning cooperative policies in partially observable multi-agent domains. The main contribution is the ability to compute decentralized policies without knowing explicitly the system dynamics. In many applications, the system dynamics is either too complex to be modeled accurately or too large to be represented explicitly. DecRSPI learns policies from experience obtained by merely interacting with the environment. The learned policies are totally decentralized without any assumption about communication or global observability. Another advantage of DecRSPI is that it focuses the computation only on reachable states. As the experiments show, little sampling is needed for domains where agents have sparse interaction structures, and the solution quality calculated by a small set of samples is quite close to the best existing planning algorithms. Most importantly, DecRSPI has linear time complexity over the number of agents. Therefore DecRSPI can solve problems with up to 20 agents as shown in the experiments. Additionally, DecRSPI bounds memory usage as other MBDP-based algorithms. In the future, we plan to further exploit the interaction structure of agents and make even better use of samples, which will be helpful for large real-world domains."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work was supported in part by the Air Force Office of Scientific Research under Grant No. FA9550-08-1-0181, the National Science Foundation under Grant No. IIS0812149, the Natural Science Foundations of China under Grant No. 60745002, and the National Hi-Tech Project of China under Grant No. 2008AA01Z150."
    } ],
    "references" : [ {
      "title" : "Incremental policy generation for finite-horizon DEC- POMDPs",
      "author" : [ "Chistopher Amato", "Jilles S. Dibangoye", "Shlomo Zilberstein" ],
      "venue" : "In Proc. of the 19th Int’l Conf. on Automated Planning and Scheduling,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2009
    }, {
      "title" : "The complexity of decentralized control of Markov decision processes",
      "author" : [ "Daniel S. Bernstein", "Shlomo Zilberstein", "Neil Immerman" ],
      "venue" : "In Proc. of the 16th Conf. on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2000
    }, {
      "title" : "Bounded policy iteration for decentralized POMDPs",
      "author" : [ "Daniel S. Bernstein", "Eric A. Hansen", "Shlomo Zilberstein" ],
      "venue" : "In Proc. of the 19th Int’l Joint Conf. on Artificial Intelligence,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2005
    }, {
      "title" : "Rollout algorithms for combinatorial optimization",
      "author" : [ "Dimitri P. Bertsekas", "John N. Tsitsiklis", "Cynara Wu" ],
      "venue" : "Journal of Heuristics,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1997
    }, {
      "title" : "Parallel rollout for online solution of Dec-POMDPs",
      "author" : [ "Camille Besse", "Brahim Chaib-draa" ],
      "venue" : "In Proc. of the 21st Int’l FLAIRS Conf.,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2008
    }, {
      "title" : "A comprehensive survey of multiagent reinforcement learning",
      "author" : [ "Lucian Busoniu", "Robert Babuska", "Bart D. Schutter" ],
      "venue" : "IEEE Trans. on SMC, Part C,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2008
    }, {
      "title" : "Parallel rollout for online solution of partially observable Markov decision processes",
      "author" : [ "Hyeong Soo Chang", "Robert Givan", "Edwin K.P. Chong" ],
      "venue" : "Discrete Event Dynamic Systems,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2004
    }, {
      "title" : "Point-based incremental pruning heuristic for solving finite-horizon DEC-POMDPs",
      "author" : [ "Jilles S. Dibangoye", "Abdel-Illah Mouaddib", "Brahim Chaib-draa" ],
      "venue" : "In Proc. of the 8th Int’l Joint Conf. on Autonomous Agents and Multi-Agent Systems,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "Rollout sampling approximate policy iteration",
      "author" : [ "Christos Dimitrakakis", "Michail G. Lagoudakis" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2008
    }, {
      "title" : "Approximate policy iteration with a policy language bias",
      "author" : [ "Alan Fern", "Sung Wook Yoon", "Robert Givan" ],
      "venue" : "In Proc. of the 17th Conf. on Neural Info. Processing Systems,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2003
    }, {
      "title" : "Dynamic programming for partially observable stochastic games",
      "author" : [ "Eric A. Hansen", "Daniel S. Bernstein", "Shlomo Zilberstein" ],
      "venue" : "In Proc. of the 19th National Conf. on Artificial Intelligence,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2004
    }, {
      "title" : "Reinforcement learning as classification: Leveraging modern classifiers",
      "author" : [ "Michail G. Lagoudakis", "Ronald Parr" ],
      "venue" : "In Proc. of the 20th Int’l Conf. on Machine Learning,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2003
    }, {
      "title" : "Exploiting locality of interactions using a policy-gradient approach in multiagent learning",
      "author" : [ "Francisco S. Melo" ],
      "venue" : "In Proc. of the 18th European Conf. on Artificial Intelligence,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2008
    }, {
      "title" : "Taming decentralized POMDPs: Towards efficient policy computation for multiagent settings",
      "author" : [ "Ranjit Nair", "Milind Tambe", "Makoto Yokoo", "David V. Pynadath", "Stacy Marsella" ],
      "venue" : "In Proc. of the 18th Int’l Joint Conf. on Artificial Intelligence,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2003
    }, {
      "title" : "Learning to cooperate via policy search",
      "author" : [ "Leonid Peshkin", "Kee-Eung Kim", "Nicolas Meuleau", "Leslie Pack Kaelbling" ],
      "venue" : "In Proc. of the 16th Conf. on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2000
    }, {
      "title" : "Bounded finite state controllers",
      "author" : [ "Pascal Poupart", "Craig Boutilier" ],
      "venue" : "In Proc. of the 17th Annual Conference on Neural Information Processing Systems,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2003
    }, {
      "title" : "Improved memorybounded dynamic programming for decentralized POMDPs",
      "author" : [ "Sven Seuken", "Shlomo Zilberstein" ],
      "venue" : "In Proc. of the 23rd Conf. on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2007
    }, {
      "title" : "Memory-bounded dynamic programming for DEC-POMDPs",
      "author" : [ "Sven Seuken", "Shlomo Zilberstein" ],
      "venue" : "In Proc. of the 20th Int’ll Joint Conf. on Artificial Intelligence,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2015
    }, {
      "title" : "Reinforcement Learning: An Introduction",
      "author" : [ "Richard Sutton", "Andrew Barto" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1998
    }, {
      "title" : "Conditional random fields for multi-agent reinforcement learning",
      "author" : [ "Xinhua Zhang", "Douglas Aberdeen", "S.V.N. Vishwanathan" ],
      "venue" : "In Proc. of the 24th Int’l Conf. on Machine Learning,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "These problems can be modeled as decentralized POMDPs (DEC-POMDPs) [2].",
      "startOffset" : 67,
      "endOffset" : 70
    }, {
      "referenceID" : 17,
      "context" : "When a complete model of the domain is available, DECPOMDPs can be solved using a wide range of optimal or approximate algorithms, particularly MBDP [18] and its descendants [1, 8, 17].",
      "startOffset" : 149,
      "endOffset" : 153
    }, {
      "referenceID" : 0,
      "context" : "When a complete model of the domain is available, DECPOMDPs can be solved using a wide range of optimal or approximate algorithms, particularly MBDP [18] and its descendants [1, 8, 17].",
      "startOffset" : 174,
      "endOffset" : 184
    }, {
      "referenceID" : 7,
      "context" : "When a complete model of the domain is available, DECPOMDPs can be solved using a wide range of optimal or approximate algorithms, particularly MBDP [18] and its descendants [1, 8, 17].",
      "startOffset" : 174,
      "endOffset" : 184
    }, {
      "referenceID" : 16,
      "context" : "When a complete model of the domain is available, DECPOMDPs can be solved using a wide range of optimal or approximate algorithms, particularly MBDP [18] and its descendants [1, 8, 17].",
      "startOffset" : 174,
      "endOffset" : 184
    }, {
      "referenceID" : 1,
      "context" : "This is not surprising given that finite-horizon DECPOMDPs are NEXP-complete [2].",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 18,
      "context" : "Incomplete domain knowledge is often addressed by reinforcement learning algorithms [19].",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 5,
      "context" : "However, most cooperative multi-agent reinforcement learning algorithms assume that the system state is completely observable by all the agents [6].",
      "startOffset" : 144,
      "endOffset" : 147
    }, {
      "referenceID" : 18,
      "context" : "In reinforcement learning, a class of useful techniques such as Monte-Carlo methods allows agents to choose actions based on experience [19].",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 10,
      "context" : "While the policy execution is decentralized, planning or learning algorithms can operate offline and thus may be centralized [11, 18].",
      "startOffset" : 125,
      "endOffset" : 133
    }, {
      "referenceID" : 17,
      "context" : "While the policy execution is decentralized, planning or learning algorithms can operate offline and thus may be centralized [11, 18].",
      "startOffset" : 125,
      "endOffset" : 133
    }, {
      "referenceID" : 0,
      "context" : "The policies for finite-horizon DEC-POMDPs are often represented as a set of local policy trees [1, 8, 11, 17, 18].",
      "startOffset" : 96,
      "endOffset" : 114
    }, {
      "referenceID" : 7,
      "context" : "The policies for finite-horizon DEC-POMDPs are often represented as a set of local policy trees [1, 8, 11, 17, 18].",
      "startOffset" : 96,
      "endOffset" : 114
    }, {
      "referenceID" : 10,
      "context" : "The policies for finite-horizon DEC-POMDPs are often represented as a set of local policy trees [1, 8, 11, 17, 18].",
      "startOffset" : 96,
      "endOffset" : 114
    }, {
      "referenceID" : 16,
      "context" : "The policies for finite-horizon DEC-POMDPs are often represented as a set of local policy trees [1, 8, 11, 17, 18].",
      "startOffset" : 96,
      "endOffset" : 114
    }, {
      "referenceID" : 17,
      "context" : "The policies for finite-horizon DEC-POMDPs are often represented as a set of local policy trees [1, 8, 11, 17, 18].",
      "startOffset" : 96,
      "endOffset" : 114
    }, {
      "referenceID" : 10,
      "context" : "A dynamic programming (DP) algorithm was developed to build the policy trees optimally from the bottom up [11].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 0,
      "context" : "These methods keep only a fixed number of trees at each iteration [1, 8, 17, 18].",
      "startOffset" : 66,
      "endOffset" : 80
    }, {
      "referenceID" : 7,
      "context" : "These methods keep only a fixed number of trees at each iteration [1, 8, 17, 18].",
      "startOffset" : 66,
      "endOffset" : 80
    }, {
      "referenceID" : 16,
      "context" : "These methods keep only a fixed number of trees at each iteration [1, 8, 17, 18].",
      "startOffset" : 66,
      "endOffset" : 80
    }, {
      "referenceID" : 17,
      "context" : "These methods keep only a fixed number of trees at each iteration [1, 8, 17, 18].",
      "startOffset" : 66,
      "endOffset" : 80
    }, {
      "referenceID" : 15,
      "context" : "It is quite similar to stochastic finite state controllers (FSC), used to solve infinite-horizon POMDPs [16] and DEC-POMDPs [3].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 2,
      "context" : "It is quite similar to stochastic finite state controllers (FSC), used to solve infinite-horizon POMDPs [16] and DEC-POMDPs [3].",
      "startOffset" : 124,
      "endOffset" : 127
    }, {
      "referenceID" : 10,
      "context" : "Instead of searching over the entire policy space, dynamic programming (DP) constructs policies from the last step up to the first one and eliminates dominated policies at the early stages [11].",
      "startOffset" : 189,
      "endOffset" : 193
    }, {
      "referenceID" : 17,
      "context" : "Memory-bounded techniques have been developed to combine the top-down heuristics and the bottom-up dynamic programming together, keeping only a bounded number of policies at each iteration [18].",
      "startOffset" : 189,
      "endOffset" : 193
    }, {
      "referenceID" : 16,
      "context" : "This results in linear complexity over the horizon, but the one-step backup operation is still time-consuming [17].",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 17,
      "context" : "Our algorithm is based on the MBDP algorithm [18], but it approximates the backup operation with an alternating maximization process.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 13,
      "context" : "[14] and later refined by Bernstein et al.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 2,
      "context" : "[3].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 14,
      "context" : "In the experiments, we compared our results with the distributed gradient descent (DGD) [15] with different horizons.",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 0,
      "context" : "We also present the results of PBIP-IPG [1] — the best existing planning algorithm— for these domains.",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 0,
      "context" : "We experimented with three common DEC-POMDP benchmark problems, which are also used by PBIPIPG [1].",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 2,
      "context" : "The Meeting in a 3×3 Grid problem [3] involves two robots that navigate in a 3×3 grid and try to stay as much time as possible in the same cell.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 0,
      "context" : "[1], which has 81 states, 5 actions and 9 observations per robot.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 16,
      "context" : "The Cooperative Box Pushing problem [17] involves two robots that cooperate with each other to push boxes to their destinations in a 3×4 grid.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 0,
      "context" : "The Stochastic Mars Rover problem [1] is",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 19,
      "context" : "The distributed sensor network (DSN) problem, adapted from [20], consists of two chains with identical number of sensors as shown in Figure 3.",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 0,
      "context" : "Most of the planning algorithms for general DEC-POMDPs have only been tested in domains with 2 agents [1, 8, 11, 17, 18].",
      "startOffset" : 102,
      "endOffset" : 120
    }, {
      "referenceID" : 7,
      "context" : "Most of the planning algorithms for general DEC-POMDPs have only been tested in domains with 2 agents [1, 8, 11, 17, 18].",
      "startOffset" : 102,
      "endOffset" : 120
    }, {
      "referenceID" : 10,
      "context" : "Most of the planning algorithms for general DEC-POMDPs have only been tested in domains with 2 agents [1, 8, 11, 17, 18].",
      "startOffset" : 102,
      "endOffset" : 120
    }, {
      "referenceID" : 16,
      "context" : "Most of the planning algorithms for general DEC-POMDPs have only been tested in domains with 2 agents [1, 8, 11, 17, 18].",
      "startOffset" : 102,
      "endOffset" : 120
    }, {
      "referenceID" : 17,
      "context" : "Most of the planning algorithms for general DEC-POMDPs have only been tested in domains with 2 agents [1, 8, 11, 17, 18].",
      "startOffset" : 102,
      "endOffset" : 120
    }, {
      "referenceID" : 14,
      "context" : "The distributed gradient descent (DGD) algorithm performs gradient-based policy search independently on each agent’s local controller using the experience data [15].",
      "startOffset" : 160,
      "endOffset" : 164
    }, {
      "referenceID" : 19,
      "context" : "[20] proposed an online natural actor-critic algorithm using conditional random fields (CRF).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "Melo [13] proposed another actor-critic algorithm with natural gradient, but it only works for transition-independent DEC-POMDPs.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 8,
      "context" : "The rollout sampling method has been introduced to learn MDP policies without explicitly representing the value function [9, 10, 12].",
      "startOffset" : 121,
      "endOffset" : 132
    }, {
      "referenceID" : 9,
      "context" : "The rollout sampling method has been introduced to learn MDP policies without explicitly representing the value function [9, 10, 12].",
      "startOffset" : 121,
      "endOffset" : 132
    }, {
      "referenceID" : 11,
      "context" : "The rollout sampling method has been introduced to learn MDP policies without explicitly representing the value function [9, 10, 12].",
      "startOffset" : 121,
      "endOffset" : 132
    }, {
      "referenceID" : 3,
      "context" : "The rollout technique is also widely used to perform lookahead and estimate the value of action in online methods [4, 5, 7].",
      "startOffset" : 114,
      "endOffset" : 123
    }, {
      "referenceID" : 4,
      "context" : "The rollout technique is also widely used to perform lookahead and estimate the value of action in online methods [4, 5, 7].",
      "startOffset" : 114,
      "endOffset" : 123
    }, {
      "referenceID" : 6,
      "context" : "The rollout technique is also widely used to perform lookahead and estimate the value of action in online methods [4, 5, 7].",
      "startOffset" : 114,
      "endOffset" : 123
    } ],
    "year" : 2010,
    "abstractText" : "We present decentralized rollout sampling policy iteration (DecRSPI) — a new algorithm for multi-agent decision problems formalized as DEC-POMDPs. DecRSPI is designed to improve scalability and tackle problems that lack an explicit model. The algorithm uses MonteCarlo methods to generate a sample of reachable belief states. Then it computes a joint policy for each belief state based on the rollout estimations. A new policy representation allows us to represent solutions compactly. The key benefits of the algorithm are its linear time complexity over the number of agents, its bounded memory usage and good solution quality. It can solve larger problems that are intractable for existing planning algorithms. Experimental results confirm the effectiveness and scalability of the approach.",
    "creator" : "TeX"
  }
}