{
  "name" : "1107.0054.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Comprehensive Trainable Error Model for Sung Music Queries",
    "authors" : [ "Colin J. Meek", "William P. Birmingham" ],
    "emails" : [ "CMeek@microsoft.com", "WPBirmingham@gcc.edu" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Many approaches have been proposed for the identification of viable targets for a query in a music database. Query-by-humming systems attempt to address the needs of the nonexpert user, for whom a natural query format – for the purposes of finding a tune, hook or melody of unknown providence – is to sing it. Our goal is to demonstrate a unifying model, expressive enough to account for the complete range of modifications observed in the performance and transcription of sung musical queries. Given a complete model for singer error, we can accurately determine the likelihood that, given a particular target (or song in a database), the singer would produce some query. These likelihoods offer a useful measure of similarity, allowing a query-by-humming (QBH) system to identify strong matches to return to the user.\nGiven the rate at which new musical works are recorded, and given the size of multimedia databases currently deployed, it is generally not feasible to learn a separate model for each target in a multimedia database. Similarly, it may not be possible to customize an error model for every individual user. As such, a QBH matcher must perform robustly across a broad range of songs and singers. We develop a method for training our error model that functions well across singers with a broad range of abilities, and successfully generalizes to works for which no training examples have been given (see Section 11). Our approach (described in Section 9) is an extension of a standard re-estimation algorithm (Baum &\nc©2004 AI Access Foundation. All rights reserved.\nEagon, 1970), and a special case of Expectation Maximization (EM) (Dempster, Laird, & Jain, 1977). It is applicable to hidden Markov models (HMM) with the same dependency structure, and is demonstrated to be convergent (see Appendix A)."
    }, {
      "heading" : "2. Problem Formulation and Notation",
      "text" : "An assumption of our work is that pitch and IOI adequately represent both the target and the query. This limits our approach to monophonic lines, or sequences of non-overlapping note events. An event consists of a 〈Pitch, IOI〉 duple. IOI is the time difference between the onsets of successive notes, and pitch is the MIDI note number1.\nWe take as input a note-level abstraction of music. Other systems act on lower-level representations of the query. For instance, a frame-based frequency representation is often used (Durey, 2001; Mazzoni, 2001). Various methods for the translation of frequency and amplitude data into note abstraction exist (Pollastri, 2001; Shifrin, Pardo, Meek, & Birmingham, 2002). Our group currently uses a transcriber based on the Praat pitch-tracker (Boersma, 1993), designed to analyze voice pitch contour. A sample Praat analysis is shown in Figure 1. In addition to pitch extraction, the query needs to be segmented, or organized into contiguous events (notes). The query transcription process is described in greater detail in Section 3. Note that these processes are not perfect, and it is likely that error will be introduced in the transcription of the query.\nRestricting ourselves to this event description of target and query ignores several elements of musical style, including dynamics, articulation and timbre, among others. Objectively and consistently characterizing these features is quite difficult, and as such we have little confidence they can be usefully exploited for music retrieval at this point. We acknowledge, however, the importance of such elements in music query/retrieval systems in general. They will likely prove essential in refining or filtering the search space (Birmingham, Pardo,\n1. Musical Instrument Digital Interface (MIDI) has become a standard electronic transmission and storage protocol/format for music. MIDI note numbers essentially correspond to the keys of a piano, where ’middle C’ corresponds to the integer value 60.\nMeek, & Shifrin, 2002; Birmingham, Dannenberg, Wakefield, Bartsch, Bykowski, Mazzoni, Meek, Mellody, & Rand, 2001).\nWe further simplify the representation by using IOI quantization and by representing pitch in terms of pitch class. IOI is quantized to a logarithmic scale, using q = 29 quantization levels, within the range 30 msec. to 3840 msec., chosen such that there are precisely four gradations between an eighth note and sixteenth note (or quarter note and sixteenth note, and so forth.) This representation mirrors conventional notation in Western music, in which the alphabet of rhythmic symbols (eighth, quarter, half, etc.) corresponds to a logarithmic scale on duration (see Figure 2), and has been shown not to substantially influence discrimination between potential targets in a database (Pardo & Birmingham, 2002).\nTarget:\nQuery, warping insertion:\nQuery, non-warping insertion:\nFigure 3: Warping and non-warping insertions.\nPitch is translated to pitch class, a representation where all notes are projected into a single octave, and are considered in the context of the 12-tone, well-tempered scale. For instance, the frequency 453 Hz is “binned” into MIDI note number 70. The corresponding pitch class is mod 12(70) = 10. This addresses two issues: octave errors are quite common in some transcriber systems, and pitch class is an effective, if imperfect, musical (Pardo, 2002) and perceptual (Bartsch & Wakefield, 2001) abstraction. In addition, pitch class substantially reduces the model’s “alphabet” size.\nIn our implementation, pitch bins are not fixed, but vary from query to query. We first convert frequency (f) to what might be termed a floating-point MIDI note representation (m), using the assumption of equal-temperament (twelve equally spaced semitones per octave) and, according to convention, translating a frequency of 440 Hz to ‘A’ above middle ‘C’, or MIDI note value 69: m = 69 + 12 log2 f 440 . When we round to the nearest note number, we introduce a rounding error. To minimize this error, we add an offset to the note numbers, to account for any overall pitch tendency. For instance, consider a query consisting of a sequence of note numbers {48.4, 46.6, 44.4, 43.6}. This query tends to be sharp (or flat) by roughly a quarter-tone. By introducing an offset of +0.5 (a quarter-tone), we minimize the rounding error, and can thus more closely preserve the contour: without the offset, we round to {48, 47, 44, 44}; with the offset, we round to {49, 47, 45, 44}. Since transpositional invariance is a central feature of our model, the direction of the offset is\nirrelevant in this example. Adopting an approach proposed for a QBH “audio front end” (Pollastri, 2001), we consider several offsets (O = {0.0, 0.1, . . . , 0.9}). Given a sequence of note numbers (M = {m1, m2, . . . , mn}), we choose the offset (o ∈ O) such that the\nmean error squared (e = Pn i=1[m+o−round(m+o)] 2\nn ) is minimized, and set Pitch[i] equal to\nround(mi + o). We choose discrete sets of symbols to represent pitch and duration since, as will be seen, a continuous representation would necessitate an unbounded number of states in our model. This second event representation is notated:\not = 〈P [t], R[t]〉 (1)\nfor queries (using the mnemonic shorthand observation = 〈Pitch,Rhythm〉). Target events are similarly notated:\ndi = 〈P [i], R[i]〉 (2)\nFor clarity, we will return to the earlier representation 〈Pitch[i], IOI[i]〉 where appropriate. The second representation is derived from the first as follows, where 30 and 3840 are the IOI values associated with the centers of the shortest and longest bins, and q is the number of IOI quantization bins:\nP [i] = mod 12(Pitch[i]) (3)\nR[i] = round\n( log IOI[i]− log 30\nlog 3840 − log 30 · (q − 1)\n)\n(4)\nThe goal of this paper is to present a model for query errors within the scope of this simple event representation. We will first outline the relevant error classes, and then present an extended Hidden Markov Model accounting for these errors. Taking advantage of certain assumptions about the data, we can then efficiently calculate the likelihood of a target model generating a query. This provides a means of ranking potential targets in a database (denoted {D1,D2, . . .}, where Di = {d1, d2, . . .}) given a query (denoted O = {o1, o2, . . .}) based on the likelihood the models derived from those targets generated a given query. A summary of the notation used in this paper is provided in Appendix B."
    }, {
      "heading" : "3. Query Transcription",
      "text" : "Translating from an audio query to a sequence of note events is a non-trivial problem. We now outline the two primary steps in this translation: frequency analysis and segmentation."
    }, {
      "heading" : "3.1 Frequency Analysis",
      "text" : "We use the Praat pitch-tracker (Boersma, 1993), an enhanced auto-correlation algorithm developed for speech analysis, for this stage. This algorithm identifies multiple auto-correlation peaks for each analysis frame, and chooses a path through these peaks that avoids pitch jumps and favors high correlation peaks. For a particular frame, no peak need be chosen, resulting in gaps in the frequency analysis. In addition, the algorithm returns the autocorrelation value at the chosen peak (which we use as a measure of pitch-tracker confidence), and the RMS amplitude by frame (see Figure 1 for instance.)"
    }, {
      "heading" : "3.2 Segmentation",
      "text" : "A binary classifier is used to decide whether or not each analysis frame contains the beginning of a new note. The features considered by the classifier are derived from the pitchtracker output. This component is currently in development at the University of Michigan. In its present implementation, a five-input, single-layer neural network performs the classification. We assign a single pitch to each note segment, based on the weighted average pitch by confidence of the frames contained in the segment. An alternative implementation is currently being explored, which treats the query analysis as a signal (ideal query) with noise, and attempts to uncover the underlying signal using Kalman-filter techniques."
    }, {
      "heading" : "4. Error Classes",
      "text" : "A query model should be capable of expressing the following musical – or un-musical you might argue – transformations, relative to a target:\n1. Insertions and deletions: adding or removing notes from the target, respectively. These edits are frequently introduced by transcription tools as well.\n2. Transposition: the query may be sung in a different key or register than the target. Essentially, the query might sound “higher” or “lower” than the target.\n3. Tempo: the query may be slower or faster than the target.\n4. Modulation: over the course of a query, the transposition may change.\n5. Tempo change: the singer may speed up or slow down during a query.\n6. Non-cumulative local error: the singer might sing a note off-pitch or with poor rhythm."
    }, {
      "heading" : "4.1 Edit Errors",
      "text" : "Insertions and deletions in music tend to influence surrounding events. For instance, when an insertion is made, the inserted event and its neighbor tend to occupy the temporal space of the original note: if an insertion is made and the duration of the neighbors is not modified, the underlying rhythmic structure (the beat) is changed. We denote this type of insertion a “warping” insertion. For instance, notice the alignment of notes after the warping insertion in Figure 3, indicated by the dotted arrows. The inserted notes are circled. For the nonwarping insertion, the length of the second note is shortened to accommodate the new note.\nWith respect to pitch, insertions and deletions do not generally influence the surrounding events. However, previous work assumes this kind of influence: noting that intervallic contour tends to be the strongest component in our memory of pitch; one researcher has proposed that insertions and deletions could in some cases have a “modulating” effect (Lemstrom, 2000), where the edit introduces a pitch offset, so that pitch intervals rather than the pitches themselves are maintained. We argue that relative pitch, with respect to the query as a whole, should be preserved. Consider the examples in Figure 4. The first row of numbers below the staff indicates MIDI note numbers, the second row indicates the\nintervals in semitones (‘u’ = up, ‘d’ = down.) Notice that the intervallic representation is preserved in the modulating insertion, while the overall “profile” (and key) of the line is maintained in the non-modulating insertion.\nThe effects of these various kinds of insertions and deletions are now formalized, with respect to a target consisting of two events {〈Pitcha, IOIa〉, 〈Pitchb, IOIb〉}, and a query {〈Pitchc, IOIc〉, 〈PitchinsertIOIinsert〉 〈Pitchd, IOId〉}, where 〈PitchinsertIOIinsert〉 is the inserted event (see Figure 5). Note that deletion is simply the symmetric operation, so we show examples of insertions only:\n• Effects of a warping insertion on IOI: IOIc = IOIa, IOId = IOIb\n• Effects of a non-warping insertion on IOI: IOIc = IOIa − IOIinsert, IOId = IOIb\n• Effects of a modulating insertion on pitch: Pitchc = Pitcha, Pitchd = Pitchinsert + Pitchb − Pitcha ︸ ︷︷ ︸\npitch contour\n• Effects of a non-modulating insertion on pitch: Pitchc = Pitcha, Pitchd = Pitchb\nIn our model, we deal only with non-modulating and non-warping insertions and deletions explicitly, based on the straightforward musical intuition that insertions and deletions tend to operate within a rhythmic and modal context. The other types of edit are represented in combination with other error classes. For instance, a modulating insertion is simply an insertion combined with a modulation.\nAnother motivation for our “musical” definition of edit is transcriber error. In this context, we clearly would not expect the onset times or pitches of surrounding events to be influenced by a “false hit” insertion or a missed note. The relationships amongst successive events must therefore be modified to avoid warping and modulation. Reflecting this bias, we use the terms “join” and “elaboration” to refer to deletions and insertions, respectively. A system recognizing musical variation (Mongeau & Sankoff, 1990) uses a similar notion of insertion and deletion, described as “fragmentation” and “consolidation” respectively."
    }, {
      "heading" : "4.2 Transposition and Tempo",
      "text" : "We account for the phenomenon of persons reproducing the same “tune” at different speeds and in different registers or keys. Few people have the ability to remember and reproduce exact pitches (Terhardt & Ward, 1982), an ability known as “absolute” or “perfect” pitch. As such, transpositional invariance is a desirable feature of any query/retrieval model. The effect of transposition is simply to add a certain value to all pitches. Consider for example the transposition illustrated in Figure 6, Section a, of Trans = +4.\n0 1 2 3 4 5 6 7 8\nTime (sec.)\nFigure 7: Tempo increase\nTempo in this context is simply the translation of rhythm, which describes duration relationships, into actual time durations. Again, it is difficult to remember and reproduce an exact tempo. Moreover, it is very unlikely that two persons would choose the same metronome marking, much less unconstrained beat timing, for any piece of music. This is a natural “musical” interpretation. We measure tempo relative to the original using a scaling factor on rhythmic duration. Thus, if the query is 50% slower than the target, we have a scaling value of Scale = 1.5, as shown in Figure 6, Section a.\nIn practice, we use quantized tempo scaling and duration values. Note that addition in the logarithmic scale is equivalent to multiplication: with quantized IOI values, we replace floating point multiplication with integer addition when applying a scaling value. For instance, given our quantization bins, a doubling of tempo always corresponds to an addition of four: Scale = 2.0 ↔ Scalequantized = +4."
    }, {
      "heading" : "4.3 Modulation and Tempo Change",
      "text" : "Throughout a query, the degree of transposition or tempo scaling can change, referred to as modulation and tempo change, respectively. Consider a query beginning with the identity transposition Trans = 0 and identity tempo scaling Scale = 1, as in Figure 6, Section b. When a modulation or tempo change is introduced, it is always with respect to the previous transposition and tempo. For instance, on the third note of the example, a modulation of Modu = +2 occurs. For the remainder of the query, the transposition is equal to 0+2 = +2,\nfrom the starting reference transposition of 0. Similarly, the tempo change of Change = 1.5 on the second note means that all subsequent events occur with a rhythmic scaling of 1 · 1.5 = 1.5.\nConsider Figure 7, which plots the apparent tempo scaling in a rendition of “Row, Row, Row Your Boat” on a note-by-note basis. While our model considers several interpretations of such a rendition, one approach would be to consider a constantly increasing tempo, represented by the least-square deviation regression line, with local rhythmic errors (see Section 4.4), represented by the note-wise deviations from that line."
    }, {
      "heading" : "4.4 Local Pitch and IOI Errors",
      "text" : "In addition to the “gross” errors we have discussed thus far, there are frequently local errors in pitch and rhythm. These errors are relative to the modifications described above. A local pitch error of ∆(P ) simply adds some value to the “ideal” pitch, where the ideal is determined by the relevant target note and the current transposition. A local IOI error of ∆(R) has a scalar effect (or again, additive in the quantized domain) on the ideal IOI, derived from the relevant target note and the current tempo. Figure 6, Section c, shows examples of each error. Note that these errors do not propagate to subsequent events, and as such are termed non-cumulative or local errors. Transposition and tempo change are examples of cumulative error.\nIn some cases, there are multiple interpretations for the source of error in a query. Consider for instance Figure 8, which shows a specific interpretation of three disagreements between a target and query. The second note in the query is treated as a local pitch error of -1. The final two notes, which are a semi-tone sharper than expected (+1), are explained as a modulation. The error model, described in the next section, considers all possible interpretations, for instance considering the possibility that the error in the second note is accounted for by two modulations (before and after), and the final two notes by a pair of local errors. Depending on our expectation that such things might occur, one or the other interpretation might appear more likely. In general, we would prefer to find the most direct possible explanations for queries, since an increased likelihood of error in the model can be shown to reduce discrimination (see Section 10)."
    }, {
      "heading" : "5. Existing Error Models",
      "text" : "For edits, we assume that overall rhythm is maintained, and make the natural musical assumption that edits have a local impact on pitch. Many QBH applications adopt this approach to rhythm (Mazzoni, 2001; Meek & Birmingham, 2002; Pauws, 2002; McNab, Smith, Bainbridge, & Witten, 1997; McNab, Smith, Witten, Henderson, & Cunningham, 1996).\nIn this study, we are concerned primarily with local and cumulative error. Far less is known about this area. This is largely a matter of convenience: a particular musical representation will tend to favor one approach over the other. For instance, a pitch- and tempo-invariant representation (pitch interval and inter-onset interval ratio) (Shifrin et al., 2002; Pauws, 2002) establishes a new transposition and tempo context for each note, thus introducing the implicit assumption that all errors are cumulative (Pardo & Birmingham,\n2002). A study of sung queries (Pollastri, 2001) determined that cumulative error is in fact far less common than local error, a conclusion supported by our studies.\nAnother approach to the differences in transposition and tempo context is to attempt multiple passes over a fixed context model, and evaluate error rigidly within each pass by comparing the query to various permutations of the target. Dynamic time-warping approaches (Mazzoni, 2001) and non-distributed HMM techniques (Durey, 2001) are wellsuited to this technique. It is not possible to model, for instance, a modulation, using these methods, only local error. A preliminary QBH proposal (Wiggins, Lemstrom, & Meredith, 2002) recommends a similar approach, grouping together “transposition vectors” connecting query and target notes. Such approaches are amenable to extensions supporting cumulative error as well, but have not – to our knowledge – been extended in this way.\nAn alternative is to normalize the tempo of the query by either automated beat-tracking, a difficult problem for short queries, or, more effectively, by giving the querier an audible beat to sing along with – a simple enough requirement for users with some musical background (Chai, 2001). Again, there is an assumption that the transposition will not change during a query, but the beat-tracker can adapt to changing tempi."
    }, {
      "heading" : "5.1 Alternative Approaches",
      "text" : "We are concerned primarily with sequence based approaches to music retrieval. It is possible to relax this assumption somewhat, by translating targets into Markov models where the state is simply a characteristic relationship between consecutive notes, allowing for loops in the model (Shifrin et al., 2002). Borrowing from the text search world, we can also model music as a collection of note n-grams, and apply standard text retrieval algorithms (Downie, 1999; Tseng, 1999). In query-by-humming systems, the user is searching for a song that “sounds like...” rather than a song that is “about” some short snippet of notes, if it makes sense to discuss music in these terms at all2. For this reason, we believe that sequence-based methods can more accurately represent music in this context.\n2. Beethoven’s Fifth Symphony is a notable exception"
    }, {
      "heading" : "5.2 Indexing and Optimization Techniques",
      "text" : "It should be noted that as a general model, JCS cannot take advantage of optimizations specific to certain specializations. For instance, the cumulative-only version is amenable to a relative note representation, a transposition- and tempo- invariant representation, obviating the need to compare a query with multiple permutations of the target.\nExisting indexing techniques for string-edit distance metrics – for instance using suffix trees (Chávez & Navarro, 2002; Gusfield, 1997) and so-called ‘wavelet’ approximations (Kahveci & Singh, 2001) – are appropriate for k-distance searches, and thus might prove useful as a pre-filtering mechanism. However, they are not readily adaptable to more sophisticated probabilistic matching metrics, and, more importantly, rely on a global alignment assumption infeasible for QBH applications. A recent application of dynamic time-warping indexing to music retrieval (Zhu & Shasha, 2003) relies on the assumption that the query is globally aligned to the target, which is feasible only when the query covers precisely the material in the target.\nOther indexing techniques can provide benefits even in the general case. Lexical trees are commonly used in speech recognition for large-vocabulary recognition (Huang, Acero, & Hon, 2001), and can be adapted to the alignment and metric requirements of JCS using similar trie structures. Linear search using sub-optimal heuristics has been applied to sequence matching in bio-informatics (Pearson, 1998; Altschul, Madden, Schaffer, Zhang, Zhang, Miller, & Lipman, 1997). These approaches are fast for massive databases, and reasonably accurate even with low similarity distance metrics. Optimal alignment techniques – adaptable to arbitrary probabilistic sequence alignment models – are also being developed using trie indices (Meek, Patel, & Kasetty, 2003) and parallel architectures (Shpaer, Robinson, Yee, Candlin, Mines, & Hunkapiller, 1996).\nWe are concerned primarily with determining appropriate metrics for QBH applications. Once this has been accomplished, it will be possible to choose and develop appropriate optimizations and indexing techniques for large-scale deployment."
    }, {
      "heading" : "6. Hidden Markov Models",
      "text" : "Hidden Markov Models (HMM) are the basis for our approach. We will begin by describing a simple HMM, and then describe the extensions to the model necessary for the current task. As suggested by the name, HMMs contain hidden, or unobserved, states. As a simple example, consider a dishonest gambler, who is known to occasionally swap a fair dice for a loaded dice (with thanks to “Biological Sequence Analysis” (Durbin, Eddy, Krogh, & G.Mitchison, 1998) for the example). Unfortunately, it is impossible to observe (directly) which of the dice is being used, since they are visually indistinguishable. For this reason, we define two hidden states, a and b, representing the conjectures that the gambler is using fair and loaded dice, respectively. Further, we represent our expectation that the gambler will switch dice or stay with a dice using a transition diagram, where the transitions have associated probabilities (see Figure 9). For instance, the arc from a → b is labelled 0.1, indicating that the probability of the gambler switching from the fair dice to the loaded dice after a roll is 0.1, or formally Pr(qt+1 = b|qt = a, λ) where qt is the current state at time interval t, and λ is the model. What we can directly observe in this example is the result of each roll. While we do not know which dice is being used, we know some distribution\nover the roll values for each dice (shown at the bottom of Figure 9). These are refereed to as observation or emission probability functions, since they describe the probability of emitting a particular observation in a state.\nIn the music information-retrieval (MIR) context, we have a series of models, each representing a possible database target, and wish to determine which is most likely given a query, represented by a sequence of pitch and rhythm observations. To draw a parallel to our gambler example, we might want to determine whether we are dealing with the dishonest gambler described above, or an honest gambler (see Figure 10) who uses only fair dice. Given some sequence of observations, or dice rolls, we can determine the likelihood that each of the models generated that sequence."
    }, {
      "heading" : "6.1 Honest or Dishonest? An example",
      "text" : "The strength of the HMM approach is that it is straightforward to determine the likelihood of any observation sequence if the transition probabilities and emission probabilities are known. Conceptually, the idea is to consider all possible paths through the model consistent with the observation sequence (e.g., the observed dice rolls), and take the sum of the probabilities of each path given those observations. For instance, the roll sequence {1, 5, 4} could be generated by one of four paths in the dishonest gambler model, assuming that the dishonest gambler always begins with the fair dice: {{a, a, a}, {a, a, b}, {a, b, a}, {a, b, b}}. The probability of the second path, for instance, is equal to the probability of the transitions (Pr(a → a) ·Pr(a → b)=0.9 · 0.1 = 0.09) multiplied by the probabilities of the observations given the states in the path (the probability of rolling 1 then 5 with the fair dice, by the probability of rolling 4 with the loaded dice: 0.167 · 0.167 · 0.5 = 0.0139), which is equal to 1.25e-3. To determine the likelihood of the observation sequence given the model, we simply take the sum of the probabilities of each path (3.75e-3 + 1.25e-3 + 2.78e-5 + 7.50e-4 = 5.78e-3.) The honest gambler is in effect a fully observable model, since there is only a single hidden state. Only one path through this model is possible, and its likelihood is therefore a function of the observation probabilities only since the path is deterministic (1.0 transition probabilities): (0.167)3 = 4.63e−3. From this, we can conclude that the sequence\nof rolls 1, 5, 4 is more likely to have been generated by a dishonest gambler, though we should note that three rolls do not provide much evidence one way or the other!"
    }, {
      "heading" : "7. Extended HMM",
      "text" : "In the context of our query error model, we account for edit errors (insertions and deletions) in the “hidden” portion of the model. Using the notion of state “clusters,” we account for transposition, modulation, tempo and tempo changes. Fine pitch and rhythm errors are accounted for in the observation distribution function."
    }, {
      "heading" : "7.1 State Definition",
      "text" : "The state definition incorporates three elements: edit type (Edit), transposition (Key) and tempo (Speed). States are notated as follows:\nsx = 〈E[x],K[x], S[x]〉, 1 ≤ x ≤ n (5)\nIf E is the set of all edit types, K is the set of all transpositions, and S is the set of all tempi, then the set of all states S is equal to:\nE×K× S (6)\nWe now define each of these sets:"
    }, {
      "heading" : "7.1.1 Edit Type",
      "text" : "For the sake of notational clarity, we do not enumerate the edit types in E, but define them in terms of symbols that indirectly refer to events in the target sequence, encoding position information. There are three types of symbol:\n• Samei: refers to the correspondence between the i th note in the target and an event\nin the query.\n• Joinli: refers to a “join” of l notes, starting from the i th note in the target. In other\nwords, a single note in the query replaces l notes in the target.\n• Elabmi,j : refers to the j th query note elaborating the ith target note. In other words, a\nsingle note in the target is replaced by m notes in the query.\nNotice that Samei = Join 1 i = Elab 1 i,1, each referring to a one-to-one correspondence between target and query notes. In our implementation, Join1i plays all three roles. We generate a set of states for a given target consisting of, for each event in the target di:\n• A Samei state.\n• Join states Joinli, for 2 ≤ l ≤ L where L is some arbitrary limit on the number of events that can be joined.\n• Elaboration states Elabmi,j for 2 ≤ m ≤ M and 1 ≤ j ≤ m, where M is some arbitrary limit on the length of elaborations.\nWhy do we have so many states to describe each event in the target? We wish to establish a one-to-one correspondence between hidden states and query events, to simplify the implementation, which is why we introduce multiple states for each elaboration. We choose not to implement joins by “skips” through a reduced set of states, or elaborations as null states, since as discussed, edits influence our interpretation of the underlying target events. Figure 11 illustrates a model with skips and null states. Given our definition of insertion and deletion, state s1 would need separate emission probability tables for each outward arc (and thus would be functionally and computationally equivalent to the model we propose).\nAs mentioned, we explicitly handle only non-modulating and non-warping insertions and deletions (see Section 4.1). As such, when comparing target and query events with respect to a join, we generate a longer target note, with the sum duration of the relevant target events, and the pitch of the first. Similarly, for an elaboration, we treat a sequence of query notes as a single, longer event. Figure 12 shows a portion of the hidden state graph relating a target and query through a sequence of hidden states, where the dotted notes are examples of each generated note.\nSameState:\nTarget:\nQuery:\nElab 2 Join 2\nElab2 2\nFigure 12: Relationship between states and events\nWhere 〈Pitch[i], IOI[i]〉 is the ith query note, and 〈Pitch[t], IOI[t]〉 the tth target note, we have the following expected relationships between target and query based on the hidden state at time t, qt = 〈E[t], 0, 0〉, ignoring transposition, tempo and local error for the\nmoment:  \n\n〈Pitch[i], IOI[i]〉 = 〈Pitch[t], IOI[t]〉, if E[t] = Samei 〈Pitch[i], ∑i+l−1\nj=i IOI[j]〉 = 〈Pitch[t], IOI[t]〉, if E[t] = Join l i\n〈Pitch[i], IOI[i]〉 = 〈Pitch[t− j + 1],\nt+m−j ∑\nk=t\nIOI[k]〉\n︸ ︷︷ ︸\nNotice that all events in the elaboration point to a single larger event\nif E[t] = Elabmi,j (7)"
    }, {
      "heading" : "7.1.2 Transposition and Tempo",
      "text" : "In order to account for the various ways in which target and query could be related, we must further refine our state definition to include transposition and tempo cluster. The intuition here is that the edit type determines the alignment of events between the query with the target (see Figure 12 for instance) and the cluster determines the exact relationship between those events.\nUsing pitch class, there are only twelve possible distinct transpositions, because of the modulus-12 relationship to pitch. While any offset will do, we set K = {−5,−4, . . . ,+6}. We establish limits on how far off target a query can be with respect to tempo, allowing the query to be between half- and double- speed. This corresponds to values in the range S = {−4,−3, . . . ,+4} in terms of quantized tempo units (based on the logarithmic quantization scale described in Section B)."
    }, {
      "heading" : "7.2 Transition Matrix",
      "text" : "We now describe the transition matrix A, which maps from S × S → ℜ. Where qt is the state at time t (as defined by the position in the query, or observation sequence), axy is equal to the probability Pr(qt = sx|qt+1 = sy, λ), or in other words, the probability of a transition from state sx to state sy.\nThe transition probability is composed of three values, an edit type, modulation and tempo change probability:\naxy = a E xy · a K xy · a S xy (8)\nWe describe each of these values individually."
    }, {
      "heading" : "7.2.1 Edit Type Transition",
      "text" : "Most of the edit type transitions have zero probability, as suggested by the state descriptions. For instance, Samei states can only precede states pointing to index i + 1 in the target. Elaboration states are even more restrictive, as they form deterministic chains of the form: Elabmi,1 → Elab m i,2, → . . . → Elab m i,m. This last state can then proceed like Samei, to the i + 1 states. Similarly, Joinli states can only proceed to i + l states. A sample model topology is shown in Figure 13, for M = L = 2. Note that this is a left-right model, in which transitions impose a partial ordering on states.\nBased on properties of the target, we can generate these transition probabilities. We define PJoin(i, l) as the probability that the i\nth note in the target will be modified by an order l join. PElab(i,m) is the probability that the i th note in the target will be modified by\nan order m elaboration. PSame(i) has the expected meaning. Since every state has non-zero transitions to all states with a particular position in the target, we must insure that:\n∀i, PSame(i) +\nL∑\nl=2\nPJoin(i, l) +\nM∑\nm=2\nPElab(i,m) = 1 (9)\nThis also implies that along non-zero transitions, the probability is entirely determined by the second state. For example, the probability of the transition Join23 → Elab 2 5,1 is the same as for Same4 → Elab 2 5,1.\nEstablishing separate distributions for every index in the target would be problematic. For this reason, we need to tie distributions by establishing equivalence classes for edit type transitions. Each equivalence class is a context for transitions, where the kth edit context is denoted CEk . A state that is a member of the k th edit context (sx ∈ C E k ) shares its transition probability function with all other members of that context. Each state sy has an associated ∆(E) value, which is a classification according to the type (e.g. “Join”) and degree (e.g. l = 2) of edit type. We define the function PEk (∆\n(E)) as the probability of a transition to edit classification ∆(E) in edit context k, so that for a transition sx → sy:\naEXy = P E k (∆ (E)) ↔ sx ∈ C E k and sy has edit classification ∆ (E). (10)\nWe intentionally leave the definition of context somewhat open. With reference to broadly observed trends in queries and their transcription, we suggest these alternatives:\n• The simplest and easiest to train solution is simply to build up tables indicating the chances that, in general, a note will be elaborated or joined. Thus, the probabilities are independent of the particular event in the target. For instance, our current test implementation uses this approach with M = 2 and L = 2, with PSame = 0.95, PJoin = {0.03} and PElab = {0.02}.\n• Transcribers, in our experience, are more likely to “miss” shorter notes, as are singers (consider for instance Figure 1, in which the second and third note are joined.) As such, we believe it will be possible to take advantage of contextual information (durations of surrounding events) to determine the likelihood of joins and elaborations at each point in the target sequence."
    }, {
      "heading" : "7.2.2 Modulation and Tempo Change",
      "text" : "Modulation and tempo changes are modelled as transitions between clusters. We denote the probability of modulating by ∆(K) semitones on the ith target event as PModu(i,∆\n(K)) (again defined over the range −5 ≤ ∆(K) ≤ +6). The probability of a tempo change of ∆(S) quantization units is denoted PChange(i,∆ (S)), allowing for a halving to doubling of tempo at each step (−4 ≤ ∆(S) ≤ +4). Again, we need to tie parameters by establishing contexts for transposition (denoted CKi with associated probability function PKi ) and tempo change (denoted C S i with associated probability function PSi ). Without restricting the definition of these contexts, we suggest the following alternatives, for modulation:\n• In our current implementation, we simply apply a normal distribution over modulation centered at ∆(K) = 0, assuming that it is most likely a singer will not modulate on every note. The distribution is fixed across all events, so there is only one context.\n• We may wish to take advantage of some additional musical context. For instance, we have noted that singers are more likely to modulate during a large pitch interval.\nWe have observed no clear trend in tempo changes. Again, we simply define a normal distribution centered at ∆(S) = 0."
    }, {
      "heading" : "7.2.3 Anatomy of a Transition",
      "text" : "In a transition sx → sy (where sx = 〈E[x],K[x], S[x]〉), sx belongs to three contexts: C E i , CKj and C S k . The second state is an example of some edit classification ∆ (E), so aExy = PEi (∆ (E)). The transition corresponds to a modulation of ∆(K) = K[y] −K[x], so aKxy = PKj (∆ (K)). Finally, the transition contains a tempo change of ∆(S) = S[y]− S[x], so aSxy = PSk (∆ (S))."
    }, {
      "heading" : "7.3 Initial State Distribution",
      "text" : "We associate the initial state distribution in the hidden model with a single target event. As such, a separate model for each possible starting point must be built. Note, however, that we can actually reference a single larger model, and generate different initial state distributions for each separate starting-point model, addressing any concerns about the memory and time costs of building the models. Essentially, these various “derived” models correspond to various alignments of the start of the target with the query.\nThe probability of beginning in state sx is denoted πx. As with transition probabilities, this function is composed of parts for edit type (πEx ), transposition (π K x ) and tempo (π S x ).\nOur initial edit distribution (πEx ), for an alignment starting with the i th event in the\ntarget, is over only those edit types associated with i: Samei, {Join l i} L l=2 and {Elab m i,1} M m=2. We tie initial edit probabilities to the edit transition probabilities, such that if sz directly precedes sx in the hidden-state topology, π E x = a E zx. This means that, for instance, the probability of a two-note join on the ith target event is the same whether or not i happens to be the current starting alignment.\nThe initial distributions over transposition and tempo are as follows:\n• πK(χ): the probability of beginning a query in transposition χ. Since the overwhelming majority of people do not have absolute pitch, we can make no assumption about initial transposition, and set πK(χ) = 1 12 , −5 ≤ χ ≤ +6. This distribution could how-\never be tailored to individual users’ abilities, thus the distributions might be quite different between a musician with absolute pitch and a typical user.\n• πS(χ): the probability of beginning a query at tempo χ. Since we are able to remember roughly how fast a song “goes”, we currently apply a normal distribution3\n3. In our experiments, we frequently approximate normal distributions over a discrete domain, using the\nnormal density function: y = e −(µ−x)2 2σ2\nσ √ π , and then normalize to sum 1 over the function range.\nover initial tempo, with mean 0 and deviation σ = 1.5, again in the quantized tempo representation."
    }, {
      "heading" : "7.4 Emission Function",
      "text" : "Conventionally, a hidden state is said to emit an observation, from some discrete or continuous domain. A matrix B maps from S ×O → ℜ, where S is the set of all states, and O is the set of all observations. bx(ot) is the probability of emitting an observation ot in state sx (Pr(ot|qt = sx, λ)). In our model, it is simpler to view a hidden state as emitting observation errors, relative to our expectation about what the pitch class and IOI should be based on the edit type, transposition and tempo.\nEquation 7 defines our expectation about the relationship between target and query events given edit type. For the hidden state sx = 〈E[x],K[x], S[x]〉, we will represent this relationship using the shorthand 〈P [i], R[i]〉 → 〈P [t], R[t]〉, mindful of the modifications suggested by the edit type. The pitch error is relative to the current transposition:\n∆(P ) = P [t]− (P [i] +K[x]) (11)\nSimilarly, we define an IOI error relative to tempo:\n∆(R) = R[t]− (R[i] + S[x]) (12)\nTo simplify the parameterization of our model, we assume that pitch and IOI error are conditionally independent given state. For this reason, we define two emission probability functions, for pitch (bPsx(ot)) and rhythm (b R x (ot)), where bx(ot) = b P x (ot) · b R x (ot). To avoid the need for individual functions for each state, we again establish equivalence classes, such that if sx ∈ C P i , then b P x (ot) = P P i (∆\n(P )), using the above definition of ∆(P ). Similarly, sx ∈ C R i implies that b R x (ot) = P R i (∆\n(R)). This means that as a fundamental feature, we tie emission probabilities based on the error, reflecting the “meaning” of our states."
    }, {
      "heading" : "7.5 Alternative View",
      "text" : "For expository purposes, we define state as a tuple incorporating edit, transposition and tempo information. Before proceeding, we will introduce an alternate view of state, which is useful in explaining the dependency structure of our model. In Figure 14.A, the first interpretation is shown. In the hidden states (S), each state is defined by si = 〈E[i],K[i], S[i]〉, and according to the first-order Markov assumption, the current state depends only on the previous state. Observations (O) are assumed to depend only on the hidden state, and are defined by ot = 〈P [t], R[t]〉.\nThe second view provides more detail (Figure 14.B). Dependencies among the individual components are shown. The E, K and S′ hidden chains denote the respective components of a hidden state. The edit type (E) depends only on the previous edit type (for a detailed illustration of this component, see Figure 13). The transposition (K) depends on both the previous transposition and the current edit type, since the degree of modulation and the current position in the target influence the probability of arriving at some transposition level. A pitch observation (P ) depends only on the current edit type and the current transposition, which tell us which pitch we expect to observe: the “emission” probability is\nthen simply the probability of the resulting error, or discrepancy between what we expect and what we see. There is a similar relationship between the edit type (E), tempo (S′), and rhythm observation (R)."
    }, {
      "heading" : "8. Probability of a Query",
      "text" : "In the context of music retrieval, a critical task is the calculation of the likelihood that a certain target would generate a query given the model. Using these likelihood values, we can rank a series of potential database targets in terms of their relevance to the query.\nConceptually, the idea is to consider every possible path through the hidden model. Each path is represented by a sequence of hidden states Q = {q1, q2, . . . , qT }. This path has a probability equal to the product of the transition probabilities of each successive pair of states. In addition, there is a certain probability that each path will generate the observation sequence O = {o1, o2, . . . , oT } (or, the query.) Thus, the probability of a query given the model (denoted λ) is:\nPr(O|λ) = ∑\n∀Q Pr(O|Q,λ)Pr(Q|λ) (13)\n= ∑\n∀Q\n[ T∏\nt=1\nbqt(ot)\n] [\nπq1\nT∏\nt=2\naqt−1qt\n]\n(14)\nFortunately, there is considerable redundancy in the näıve computation of this value. The “standard” forward-variable algorithm (Rabiner, 1989) provides a significant reduction in complexity. This is a dynamic programming approach, where we inductively calculate the likelihood of successively longer suffixes of the query with respect to the model. We define a forward variable as follows:\nαt(x) = Pr({o1, o2, . . . , ot}, qt = sx|λ) (15)\nThis is the probability of being in state sx at time t given all prior observations. We initialize the forward variable using the initial state probabilities, and the observation probabilities\nover the initial observation:\nα1(x) = Pr({o1}, qt = sx|λ) = πxbx(o1) (16)\nBy induction, we can then calculate successive values, based on the probabilities of the states in the previous time step:\nαt+1(y) =\nn∑\nx=1\nαt(x)axyby(ot+1) (17)\nFinally, the total probability of the model generating the query is the sum of the probabilities of ending in each state (where T is the total sequence length):\nPr(O|λ) =\nn∑\nx=1\nαT (x) (18)"
    }, {
      "heading" : "8.1 Complexity Analysis",
      "text" : "Based on the topology of the hidden model, we can calculate the complexity of the forwardvariable algorithm for this implementation. Since each edit type has non-zero transition probabilities for at most L+M − 1 other edit types, this defines a branching factor (b) for the forward algorithm. In addition, any model can have at most b|D| states, where |D| is the length of the target.\nUpdating the transposition and tempo probabilities between two edit types (including all cluster permutations) requires k = (9 · 12)2 multiplications given the current tempo quantization, and the limits on tempo change. Notice that increasing either the allowable range for tempo fluctuation, or the resolution of the quantization, results in a super-linear increase in time requirements!\nSo, at each induction step (for t=1, 2, . . .), we require at most k|D|b2 multiplications. As such, for query length T , the cost is O(k|D|b2T ). Clearly, controlling the branching factor (by limiting the degree of join and elaboration) is critical. k is a non-trivial scaling factor, so we recommend minimizing the number of quantization levels as far as possible without overly sacrificing retrieval performance."
    }, {
      "heading" : "8.2 Optimizations",
      "text" : "While asymptotic improvements in complexity are not possible, certain optimizations have proven quite effective, providing over a ten-fold improvement in running times. An alternate approach to calculating the probability of a query given the model is to find the probability of the most likely (single) path through the model, using the Viterbi algorithm. This is a classical dynamic programming approach, which relies on the observation that the optimal path must consist of optimal sub-paths. It works by finding the highest probability path to every state at time t+1 based on the highest probability path to every state at time t. The algorithm is therefore a simple modification of the forward-variable algorithm. Instead of taking the sum probability of all paths leading into a state, we simply take the maximum probability:\nαt+1(y) = n\nmax x=1 [αt(x)axyby(ot+1)] (19)\nA side-effect of this change is that all arithmetic operations are multiplications for Viterbi (no summations.) As a result, we can affect a large speed-up by switching to a log-space, and adding log probabilities rather than multiplying.\nSome other implementation details:\n• The edit topology is quite sparse (see Figure 13), so it is advantageous to identify successors for each edit state rather than exhaustively try transitions.\n• There is considerable redundancy in the feed-forward step (for both Viterbi and the forward-algorithm) since many state transitions share work. For instance, all transitions of the form 〈E[x],K[x],∪〉 → 〈E[y],K[y],∪〉 share several components: the same edit transition probability, the same modulation probability and the same pitch observation probability. By caching the product of those probabilities, we avoid both repeated look-ups and repeated multiplications or additions, a non-trivial effect when the depth of the nesting is considered over edit type, transposition and tempo."
    }, {
      "heading" : "8.2.1 Branch and Bound",
      "text" : "Using Viterbi, it is possible to use branch and bound to preemptively prune paths when it can be shown that no possible completion can result in a high enough probability. First, we should explain what we mean by “high enough”: if only a fixed number (k) of results are required, we reject paths not capable of generating a probability greater or equal to the kth highest probability observed thus far in the database. How can we determine an upperbound on the probability of a path? We note that each event (or observation) in an optimal Viterbi path introduces a factor, which is the product of the observation probability, the edit transition probability, and the inter-cluster transition probabilities. Knowing the maximum possible value of this factor (f) allows us to predict the minimum “cost” of completing the algorithm along a given path. For instance, given a query of length T , and an interim probability of αt(x), we can guarantee that no possible sequence of observations along this path can result in a probability greater than αt(x)f\nT−t We use this last value as a heuristic estimate of the eventual probability.\nWe can determine f in several ways. Clearly, there is an advantage to minimizing this factor, though setting f = 1 is feasible (since no parameter of the model can be greater than 1). A simple and preferable alternative is to choose f as the product of the maximum transition and maximum emission probabilities:\nf = n\nmax x,y=1\naxy · n\nmax y=1\n(\nmax ∀o by(o)\n)\n(20)\nIn effect, we are defining the behavior of the ideal query – a model parameterization in in which there is no error, modulation or tempo change."
    }, {
      "heading" : "9. Training",
      "text" : "We need to learn the following parameters for our HMM:\n• the probabilities of observing all pitch and rhythm errors (the functions PPc and P R c\nfor all contexts c);\n• the probabilities of modulating and changing tempo by all relevant amounts (PKc and PSc ); and,\n• the probabilities of transitions to each of the edit types (PEc ).\nWe fix some parameters in our model. For instance, the initial edit type distributions are not explicitly trained, since as described, these are tied to the edit type transition function. In addition, we assume a uniform distribution over initial transposition and a normal distribution over initial tempo. This is because we see no way of generalizing initial distribution data to songs for which we have no training examples. Consider that, for instance, the tendency for users to sing “Hey Jude” sharp and fast should not be seen to influence their choice of transposition or tempo in “Moon River”.\nWe will describe the training procedure in terms of a simple HMM, and then describe the extensions required for our model."
    }, {
      "heading" : "9.1 Training a Simple HMM",
      "text" : "With a fully-observable Markov Model, it is fairly straightforward to learn transition probabilities: we simply count the number of transitions between each pair of states. While we cannot directly count transitions in an HMM, we can use the forward variable and a backward variable (defined below) to calculate our expectation that each hidden transition occurred, and thus “count” the number of transitions between each pair of states indirectly. Until we have parameters for the HMM, we cannot calculate the forward- and backwardvariables. Thus we pick starting parameters either randomly or based on prior expectations, and iteratively re-estimate model parameters. This procedure is known as the Baum-Welch, or expectation-maximization algorithm (Baum & Eagon, 1970).\nConsider a simple HMM (denoted λ) with a transition matrix A, where axy is the probability of the transition from state sx to state sy, an observation matrix B where by(ot) is the probability of state sy emitting observation ot, and an initial state distribution Π where πx is the probability of beginning in state sx. Given an observation sequence O = {o1, o2, . . . ,, oT }, we again define a forward variable, calculated according to the procedure defined in Section 8:\nαt(x) = Pr({o1, o2, . . . , ot}, qt = sx|λ) (21)\nIn addition, we define a backward variable, the probability of being in a state given all subsequent observations:\nβt(x) = Pr({ot+1, ot+2, . . . , oT }, qt = sx|λ) (22)\nWe calculate values for the backward-variable inductively, as with the forward-variable, except working back from the final time step T :\nβT (x) = 1, arbitrarily (23)\nβt−1(x) = n∑\ny=1\naxyby(ot)βt(y) (24)\nWe define an interim variable ξt(x, y), the probability of being in state sx at time t and state sy at time t+ 1, given all observations:\nξt(x, y) = Pr(qt = sx, qt+1 = sy|O,λ) (25)\n= Pr(qt = sx, qt+1 = sy, O|λ)\nPr(O|λ) (26)\n= αt(x)axyby(ot+1)βt+1(y)\n∑n x=1 ∑n y=1 αt(x)axyby(ot+1)βt+1(y)\n(27)\nFinally, we introduce the variable γt(x), the probability of being in state sx at time t. This can be derived from ξt(x, y):\nγt(x) =\nn∑\ny=1\nξt(x, y) (28)\nThese values can be used to determine the expected probability of transitions and the expected probability of observations in each state, and thus can be used to re-estimate model parameters. Where the new parameters are denoted Π̂, Â and B̂, we have:\nπ̂x = γ1(x) (29)\nâxy =\nexpected number of transitions from sx → sy ︷ ︸︸ ︷\nT−1∑\nt=1\nξt(x, y)\nT−1∑\nt=1\nγt(x)\n︸ ︷︷ ︸\nexpected number of transitions from sx\n(30)\nb̂y(o) =\nexpected number of times in state sy observing o ︷ ︸︸ ︷\nT∑\nt=1\n{\nγt(y), if ot = o\n0 otherwise\nT∑\nt=1\nγt(y)\n︸ ︷︷ ︸\nexpected number of times in state sy\n(31)\nBy iteratively re-estimating the parameter values, we converge to a local maximum (with respect to the expectation of a training example) in the parameter space. In practice, the procedure stops when the parameter values change by less than some arbitrary amount between iterations."
    }, {
      "heading" : "9.2 Training the Query Error Model",
      "text" : "Our query model has a few key differences to the model outlined above: heavy parameter tying, and multiple components for both transitions and observations. The procedure is\nfundamentally the same, however. Instead of asking “How likely is a transition from sx → sy (or what is âxy)?”, we ask, for instance “How likely is a modulation of ∆\n(K) in modulation context c (or what is P̂Kc (∆ (K)))?” To answer this question, we define an interim variable,\nξKt (∆ (K), c) =\n∑\nsx∈CKc\n{\nξt(x, y), if K[y]−K[x] = ∆ (K) 0 otherwise , (32)\nthe probability of a modulation of ∆(K) in modulation context c between time steps t and t+ 1. We can now answer the question as follows:\nP̂Kc (∆ (K)) =\n∑T−1 t=1 ξ K t (∆\n(K), c) ∑T−1\nt=1 ∑6 χ=−5 ξ K t (χ, c)\n(33)\nWe use a similar derivation for the other two components of a transition. For the edit type function, we have:\nξEt (∆ (E), c) =\n∑\nsx∈CEc\n{\nξt(xy), if E[y] is an instance of ∆ (E) 0 otherwise (34)\nP̂Ec (∆ (E)) =\n∑T−1 t=1 ξ E t (∆\n(E), c) ∑T−1\nt=1\n∑\n∀∆(E)′ ξ E t (∆\n(E)′, c) ; (35)\nand, for the tempo change function, we have:\nξSt (∆ (S), c) =\n∑\nsx∈CSc\n{\nξt(x, y), if S[y]− S[x] = ∆ (S) 0 otherwise (36)\nP̂Sc (∆ (S)) =\n∑T−1 t=1 ξ S t (∆\n(S), c) ∑T−1\nt=1 ∑4 χ=−4 ξ S t (χ, c)\n(37)\nThe emission function re-estimation is more straightforward. For pitch error, we have:\nP̂Pc (∆ (P )) =\n∑T t=1 ∑\nsy∈CPc\n{\nγt(y), if observing ∆ (P ) in this state\n0 otherwise ∑T\nt=1\n∑ sy∈CPc γt(y) ; (38)\nand, for rhythm error we have:\nP̂Rc (∆ (R)) =\n∑T t=1 ∑\nsy∈CRc\n{\nγt(y), if observing ∆ (R) in this state\n0 otherwise ∑T\nt=1\n∑ sy∈CRc γt(y) . (39)\nAgain, we are simply “counting” the number of occurrences of each transition type and observation error, with the additional feature that many transitions are considered evidence for a particular context, and every transition is in turn considered evidence for several contexts. A formal derivation of the re-estimation formulae is given in Appendix A."
    }, {
      "heading" : "9.3 Starting Parameters",
      "text" : "The components of our model have clear musical meanings, which provide guidance for the selection of starting parameters in the training process. We apply normal distributions over the error and cluster change parameters, centered about “no error” and “no change”, respectively. This is based solely on the conjecture (without which the entire MIR exercise would be a lost cause) that singers are in general more likely to introduce small errors than large ones. Initial edit probabilities can be determined by the hand-labelling of a few automatically transcribed queries. It is important to make a good guess at initial parameters, because the re-estimation approach only converges to a local maximum."
    }, {
      "heading" : "10. Analysis",
      "text" : "To maintain generality in our discussion, and draw conclusions not specific to our experimental data or approach to note representation, it is useful to analyze model entropy with respect to cumulative and local error. What influences retrieval performance? From an information perspective, entropy provides a clue. Intuitively, the entropy measures our uncertainty about what will happen next in the query. Formally, the entropy value of a process is the mean amount of information required to predict its outcome. When the entropy is higher, we will cast a wider net in retrieval, because our ability to anticipate how the singer will err is reduced.\nWhat happens if we assume cumulative error with respect to pitch when local error is in fact the usual case? Consider the following simplified analysis: assume that two notes are generated with pitch error distributed according to a normal Gaussian distribution, where X is the random variable representing the error on the first note, and Y represents\nthe second. Therefore we have: fX(x) = Pr(X = x) = 1√ 2π e\n−x2 2 and fY (y) = Pr(Y =\ny) = 1√ 2π e\n−y2 2 . What is the distribution over the error on the interval? If Z is the random\nvariable representing the interval error, we have: Z = Y −X. Since fX(x) is symmetrical about x = 0, where ∗ is the convolution operator, we have: fZ(z) = fX ∗ fY (z) = 1√ 4π e −z2 4 , which corresponds to a Gaussian distribution with variance σ2 = 2 (as compared with a variance of σ2 = 1 for the local error distribution). Given this analysis, the derivative entropy for local error is equal to 12(log(2πσ\n2)+1) ≈ 1.42, and the derivative entropy of the corresponding cumulative error is roughly 1.77. The underlying distributions are shown in Figure 15. It is a natural intuition that when we account for local error using cumulative error – as is implicitly done with intervallic pitch representations – we flatten the error distribution.\nWhile experimental results indicate that local error is most common, sweeping cumulative error under the rug can also be dangerous, particularly with longer queries. When we use local error to account for a sequence of normally distributed cumulative errors represented by the random variables X1,X2, . . . ,Xn, the local error (Z) must absorb the sum over all previous cumulative errors: Z =\n∑n i=1Xi. For example, when a user sings four\nconsecutive notes cumulatively sharp one semi-tone, the final note will be, in the local view, four semi-tones sharp. If cumulative error is normally distributed with variance σ2, the expected distribution on local error after n notes is normally distributed with variance nσ2 (a\nstandard result for the summation of Gaussian variables). As such, even a low probability of cumulative error can hurt the performance of a purely local model over longer queries.\nThe critical observation here is that each simplifying assumption results in the compounding of error. Unless the underlying error probability distribution corresponds to an impulse function (implying that no error is expected), the summation of random variables always results in an increase of entropy. Thus, we can view these results as fundamental to any retrieval mechanism."
    }, {
      "heading" : "11. Results",
      "text" : "160 queries were collected from five people – who will be described as subjects A-E, none involved in MIR research. Subject A is a professional instrumental musician, and subject C has some pre-college musical training, but the remaining subjects have no formal musical background. Each subject was asked to sing eight passages from well-known songs. We recorded four versions of each passage for each subject, twice with reference only to the lyrics of the passage. After these first two attempts, the subjects were allowed to listen to a MIDI playback of that passage – transposed to their vocal range – as many times as needed to familiarize themselves with the tune, and sang the queries two more times."
    }, {
      "heading" : "11.1 Training",
      "text" : "JCS can be configured to support only certain kinds of error by controlling the starting parameters for training. For instance, if we set the probability of a transposition to zero, the re-estimation procedure will maintain this value throughout.\nThe results of this training, for three versions of the model over the full set of 160 queries, are shown in Figure 16, which indicates the overall parameters learned for each model. For all versions, a similar edit distribution results: the probability of no edit is roughly 0.85, the probability of consolidation is 0.05 and the probability of fragmentation is 0.1. These values are related primarily to the behavior of the underlying note segmentation mechanism.\nIn one of the models, both local and cumulative error are considered, labelled “Full” in the figure. Constrained versions, with the expected assumptions, are labelled “Local” and “Cumulative” respectively. It should be apparent that the full model permits a tighter distribution over local error (rhythm error and pitch error) than the simplified local model, and a tighter distribution over cumulative error (tempo change and modulation) than the simplified cumulative model.\nWhen JCS has the luxury of considering both cumulative and local error, it converges to a state where cumulative error is nonetheless extremely unlikely (with probability 0.94 there is no change in tempo at each state, and with probability of 0.93 there is no modulation), further evidence (Pollastri, 2001) that local error is indeed the critical component. This flexibility however allows us to improve our ability to predict the local errors produced by singers, as evidenced by the sharper distribution as compared with the purely local version. The practical result is that the full model is able to explain the queries in terms of the fewest errors, and converges to a state where the queries have the highest expectation.\n−4 −3 −2 −1 0 1 2 3 4 0\n0.05\n0.1\n0.15\n0.2\n0.25\n0.3\n0.35\n0.4 Local error Cumulative error\nFigure 15: Assuming cumulative error when error is local"
    }, {
      "heading" : "11.2 Retrieval Performance",
      "text" : "Given the analysis in Section 10, it is interesting to consider the effects on retrieval performance when we assume that only local or only cumulative error occurs. To this end, we generated a collection of 10000 synthetic database songs, based on the statistical properties (pitch intervals and rhythmic relationships) of a 300 piece collection of MIDI representations of popular and classical works. In our experiments, we compare several versions of JCS:\n1. ‘Full’ model: this version of JCS models both local and cumulative error.\n2. ‘Restricted’ model: a version of the full model which limits the range of tempo changes and modulations (±40% and ±1 semitone respectively). This seems like a reasonable approach because training reveals that larger cumulative errors are extremely infrequent.\n3. ‘Local’ model: only local error is modelled.\n4. ‘Cumulative’ model: only cumulative error is modelled.\nWe first randomly divided our queries into two sets for training the models and testing respectively. After training each of the models on the 80 training queries, we evaluated retrieval performance on the remaining 80 testing queries. In evaluating performance, we consider the rank of the correct target’s match score, where the score is determined by the probability that each database song would “generate” the query given our error model. In case of ties in the match score, we measure the worst-case rank: the correct song is counted below all songs with an equivalent score. In addition to the median and mean rank, we provide the mean reciprocal rank (MRR): this is a metric used by Text REtrieval Conference (Voorhees & Harman, 1997) to measure text retrieval performance. If the ranks of the correct song for each query in a test set are r1, r2, . . . , rn, the MRR is equal to, as the name suggests: 1\nn ∑n i=1 1 ri .\nThe distribution of ranks is summarized in Figure 18. The rank statistics are shown in Table 1. In addition, we provide the Receiver Operating Characteristic (ROC) curves for each model (see Figure 17) which indicate the precise tradeoffs between sensitivity and specificity, as characterized by the true positive and false positive rates for the model. Because there is only one true example in each test, we are concerned primarily with results where the false positive rate is very low. For this reason, we present false positives on a logarithmic scale. Note that a false positive rate of 10−4 corresponds to a single false positive for the size database we are using. For reference, we indicate the performance of a theoretical random model. For comparison, we provide results from another HMM-based QBH system, listed as “Simple HMM” (Shifrin et al., 2002), using default parameters. This system uses a relative note representation, and has hidden states corresponding to quantized instances of the pitch interval and IOI ratio pairs found in the target.\n1 2-10 11-100 101-1000 1001-10000\nRank\nFull Restricted Local Cumulative Simple HMM\nFigure 18: Distribution of ranks\nThe cumulative error model and the simple model perform quite poorly in comparison with the other approaches, owing to the prevalence of local error in our query collection. We see little evidence of the reverse phenomenon: notice that restricting or ignoring cumulative error does not have a notable impact on retrieval performance except on the longest queries, where there is evidence of degradation in performance using the local approach. This result agrees with the basic entropy analysis, which predicts greater difficulty for ‘local’ approaches on longer queries.\nIt is informative to examine where JCS fails. We identify two classes of failure:\n• Alignment assumption failure: This is the most common type of error. JCS assumes that the entire query is contained in the database. When the segmenter misclassifies regions before and after the query proper as notes, this situation arises. JCS must explain the entire query in the context of each target, including these margins. JCS does however model such added notes within the query, using the elaboration operation.\n• Entropy failure: errors are so prevalent in the query that many target to query mappings appear equally strong. Interestingly, we achieve solid performance in many cases where the queries are – subjectively – pretty wildly off the mark. While using a different underlying representation might allow us to extract additional useful information from queries, this does not alter the fundamental conclusions drawn about retrieval behavior with different approaches to error."
    }, {
      "heading" : "11.3 Training Generalization",
      "text" : "Because of the redundancy in the query collection – multiple versions of each of the passages, and multiple examples of each subject’s singing – it is informative to examine retrieval performance when the models are trained using examples completely unrelated to the test set. We randomly selected four of the eight passages in our study, and two of the five subjects, and used these queries for training. The remaining passages, performed by the remaining subjects, were used for training. In this way, the two sets do not share either singers or passages.\nAs a baseline, we provide retrieval results when the model is trained on the test set (see Table 2, Figures 19 and 20).\nIn these experiments, we see evidence of over-fitting for the more heavily parameterized “full” model, attributable in some part to the relatively small training set available for this experiment. There is a considerable difference in performance between the baseline and generalization results. The restricted model is a good compromise, because the relatively small number of parameters limits the risk of over-fitting, while modelling a broad range of errors."
    }, {
      "heading" : "11.4 Run-time Performance",
      "text" : "While various parametrization-specific optimizations are possible, the general implementation of JCS has lowest-common-denominator behavior with respect to running time performance. Running on a 1.6GHz Pentium 4 Linux machine, a Java version of JCS performs on\n10 −4\n10 −3\n10 −2\n10 −1\n10 0\n0\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n1\nFalse positive rate (log scale)\nT ru\ne po\nsi tiv\ne ra\nte\nFigure 19: Retrieval performance for unrelated test and training sets\n10 −4\n10 −3\n10 −2\n10 −1\n10 0\n0\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n1\nFalse positive rate (log scale)\nT ru\ne po\nsi tiv\ne ra\nte\nFull Restricted Local Cumulative Simple HMM Random\nFigure 20: Baseline performance\naverage 15 query to target comparisons per second. Training converges to a local-maximum after 16 iterations on average, or just over seven minutes on the same system using 80 training examples."
    }, {
      "heading" : "12. Future Work",
      "text" : "Even with the generalizations described in this model, a large number of parameters remain. We are currently gathering query data to train the model, as more in-depth evaluations of performance on non-synthetic queries will be essential. Various important questions remain to be answered, such as the following:\n• What is the effect of query representation, for instance using a conventional note representation rather than pitch-class?\n• How can we best tie parameters for training? For efficient training, how many contexts can (or should) be established?\n• HMMs are amenable to “frame-based” representations, which would allow us to bypass the problematic note-segmentation stage of query transcription. Instead of modelling the query as a sequence of discrete note events, it is represented as a sequence of fixedwidth time-frame analyses. Each state in the target model then has an associated distribution over duration - the probability of remaining in the state for some number of time-frames. We would like to explore the effectiveness of this approach, particularly with regards to the tradeoffs between time and retrieval performance.\nFinally, tests on much larger databases will be necessary. While we believe that meta-data in the query process (genre, era, instrumentation) will allow us to restrict searches to a subset of a database or library, it is reasonable to assume that a large number of targets will be relevant to many searches."
    }, {
      "heading" : "13. Conclusion",
      "text" : "We have presented a comprehensive model for singer error when creating a musical query. Some of these errors are tempo, pitch (both octave and absolute), melodic contour, and the particularly difficult class of joins (“skipped” notes in the query) and elaborations (note inserted into the query). It has been shown that a natural “musical” interpretation of these edits helps alleviate the problem of target similarity when edits are observed, noted in an earlier QBH feasibility study (Sorsa, 2001).\nOur experimental results show that the model is effective in handling these errors. By this, we mean that we can identify when these errors occur and can account for them in the retrieval task when necessary. The experimental results indicate good retrieval performance when these errors occur in queries. Moreover, our model is able to separately model cumulative error and local error, or a combination of both. Generally, music-information retrieval researchers have been divided on the importance of these errors. We have been able to both theoretically and experimentally show that local error is more important. That is, ignoring cumulative error, in general, has a less deleterious effect on retrieval performance than ignoring local error. In addition, modelling both errors is may give improved performance, but at a computation cost.\nFinally, our model demonstrates the most parsimonious way to model errors. We use the idea of a distributed state representation in our HMM to express the difference between a query and a target. This allows us to keep the model compact, improving both runtime efficiency and retrieval precision."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We gratefully acknowledge the support of the National Science Foundation under grant IIS0085945, and The University of Michigan College of Engineering seed grant to the MusEn project. The opinions in this paper are solely those of the authors and do not necessarily reflect the opinions of the funding agencies."
    }, {
      "heading" : "Appendix A. Deriving Re-estimation Formulae",
      "text" : "The reestimation procedure converges to a critical point in the parameter space with respect to likelihood. Baum defines an auxiliary function q, where λ′ represents the “current” model parameter values, and we are attempting to iteratively reestimate λ:\nq(λ′, λ) = ∑\nQ\nP (O,Q|λ′) log P (O,Q|λ) (40)\nBy maximizing this function, we maximize P (O|λ) because:\nq(λ′, λ) ≥ q(λ′, λ′) ⇒ P (O|λ) ≥ P (O|λ′) (41)\nWe will now derive this implication. Notice that P (O|λ) = ∑\nQ P (O,Q|λ), or the sum of the probabilities of all possible paths through the model. There are a finite number N of paths. Where Qi is the i th path, pi = P (O,Qi|λ ′), ∑ is shorthand for ∑N i=1 and qi = P (O,Qi|λ), we can rewrite the implication:\n∑ pi log qi ≥ ∑ pi log pi ⇒ ∑ qi ≥ ∑ pi (42)\nThe derivation is as follows: ∑\npi log qi ≥ ∑\npi log pi (43) ∑\npi log qi\npi ≥ 0 (44)\nSince x− 1 ≥ log x, we can deduce from Equation 44 the following inequality:\n∑\npi( qi\npi − 1) ≥\n∑\npi log qi\npi ≥ 0 (45)\n∑ qi − ∑ pi ≥ ∑ pi log qi − ∑ pi log pi (46)\nWe know from the original implicant that ∑ pi log qi ≥ ∑\npi log pi, so the right-hand side of Equation 46 is known to be non-negative. Therefore, the left-hand side of the inequality must also be non-negative. Since P (O|λ) = ∑ qi and P (O|λ ′) = ∑\npi, it is clear that P (O|λ)− P (O|λ′) ≥ 0 and therefore P (O|λ) ≥ P (O|λ′).\nTo derive our reestimation formulae, we first decompose q(λ′|λ) into a sum of auxiliary functions of the form:\nf(y) =\nN∑\nj=1\nwj log yj, (47)\nWhere we are constrained by yi ≥ 0 and g(y) = ∑N\ni yi = 1 (a discrete probability function), the auxiliary functions can then be individually maximized using Lagrange multipliers. In general, where ∇g(y) is the gradient of the function g(y), we know that extremes values of the function f(y) subject to constraint g(y) are solutions to the equation: ∇g(y) = k∇f(y) where k is some constant:\n\n     ∇g(y) =\n\n    \n∂g ∂y1\n= 1 ∂g ∂y2\n= 1 ...\n∂g ∂yN = 1\n\n    \n\n     =\n\n     k∇f(y) =\n\n     kw1 y1 kw2 y2 ...\nkwN yN\n\n    \n\n    \n(48)\n1 = kwi\nyi (49)\nyj = wj\n∑N 1=1 wi\nfrom the constraint\nN∑\ni=1\nwi = 1 (50)\nTo reduce q to this form, we rewrite:\nP (O,Q|λ) = πq1\nT∏\nt=2\naqt−1qtbqt(ot) (51)\nIncorporating the various components of transition and emission probabilities, we have:\nP (O,Q|λ) = πq1\nT∏\nt=2\naEqt−1qta K qt−1qta S qt−1qtb P qt (ot)b R qt (ot) (52)\nFinally, we incorporate the notion of context (i, j, k, l,m) and amount/error/symbol (∆), determined according to the procedure defined in Section 7:\nP (O,Q|λ) = PEi (∆ (E))\nT∏\nt=2\nPEi (∆ (E))PKj (∆ (K))PSk (∆ (S))PPl (∆ (P ))PRm(∆ (R)) (53)\nConverting to a log-scale, we have:\nT∑\nt=1\nlog PEi (∆ (E)) +\nT∑\nt=2\nlogPKj (∆ (K)) + (54)\nT∑\nt=2\nlog PSk (∆ (S)) +\nT∑\nt=2\nlog PPl (∆ (P )) +\nT∑\nt=2\nlog PRm(∆ (R))\nUsing this derivation, we rewrite q:\nq(λ′, λ) = ∑\n∀i qEi (λ\n′,aEx ) + ∑\n∀j qKj (λ ′,aKx ) + (55)\n∑\n∀k qSk (λ\n′,aSx ) + ∑\n∀l qPl (λ\n′,aPx ) + ∑\n∀m qRm(λ ′,aRx )\nwhere\nqEi (λ ′,aEi ) =\nT∑\nt=1\n∑\n∀∆(E) P (O, qt ∈ C\nE i , qt instance of ∆ (E)|λ′) log PEi (∆ (E)) (56)\nqKj (λ ′,aKj ) =\nT∑\nt=2\n∑\n∀∆(K) P (O, qt−1 → qt instance of ∆\n(K), qt ∈ C K j |λ ′) log PKj (∆ (K)) (57)\nqSk (λ ′,aSk ) =\nT∑\nt=2\n∑\n∀∆(S) P (O, qt−1 → qt instance of ∆\n(S), qt ∈ C S k |λ ′) log PSk (∆ (S)) (58)\nqPl (λ ′,bPl ) =\nT∑\nt=1\nP (O, qt → ot instance of ∆ (P ), qt ∈ C P l |λ ′) log PPl (∆ (P )) (59)\nqRm(λ ′,bRm) =\nT∑\nt=1\nP (O, qt → ot instance of ∆ (R), qt ∈ C R m|λ ′) log PRm(∆ (R)) (60)\nUsing the result in Equation 50, it is then trivial to derive the reestimation equations described in Section 9."
    }, {
      "heading" : "Appendix B. Notation",
      "text" : "We will now outline the notation used in describing the error model: Notation Description\n〈Pitch[x], IOI[x]〉 xth note event 〈P [x],R[x]〉 xth note event, quantized ot and di t th observation (query note) and\nith target event (database note) respectively\n∆(P) = −1 a pitch error, one semi-tone flat ∆(R) = +1 a rhythm error, one quantization unit too long\nsx = 〈E[x],K[x], S[x]〉 xth HMM hidden state = 〈Same1,+2,−3〉 E[x] = Same1: Edit type, replacement of first target note\nK[x] = +2: transposition (Key), 2 semi-tones sharp S[x] = −3: tempo Scaling, 3 units faster\naxy = a E xy · a K xy · a S xy probability of a transition from hidden state sx → sy\naExy = P E i (∆ (E)) edit transition probability, with edit symbol ∆(E) in context CEi aKxy = P K j (∆ (K)) probability of a modulation ∆(K) in context CKj aSxy = P S k (∆\n(S)) probability of a tempo change ∆(S) in context CSk ∆(E) ∈ {Samei} ∪ {Joinli} L l=2 set of all possible edit symbols,\n∪{Elabi, jm}M,mm=2,j=1 where L and M are the “order” of the edit topology αt(x) = P ({o1, o2, . . . , ot}, qt = sx|λ) forward-variable, the probability of ending in state t at time t\ngiven model λ βt(x) = P ({ot+1, ot+2, . . . , oT }, qt = sx|λ) backward-variable, the probability of beginning in state x at time t"
    } ],
    "references" : [ {
      "title" : "Gapped BLAST and PSI-BLAST: A New Generation of Protein Database Search Programs",
      "author" : [ "S. Altschul", "T. Madden", "A. Schaffer", "J. Zhang", "Z. Zhang", "W. Miller", "D. Lipman" ],
      "venue" : "Nucleic Acids Research,",
      "citeRegEx" : "Altschul et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Altschul et al\\.",
      "year" : 1997
    }, {
      "title" : "To catch a chorus: Using chroma-based representations for audio thumbnailing",
      "author" : [ "M. Bartsch", "G. Wakefield" ],
      "venue" : "In Proceedings of Workshop on Applications of Signal Processing to Audio and Acoustics",
      "citeRegEx" : "Bartsch and Wakefield,? \\Q2001\\E",
      "shortCiteRegEx" : "Bartsch and Wakefield",
      "year" : 2001
    }, {
      "title" : "A maximization technique occurring in the statistical analysis of probabilistic functions of markov chains",
      "author" : [ "L.E. Baum", "J.A. Eagon" ],
      "venue" : "Annals of Mathematical Statistics,",
      "citeRegEx" : "Baum and Eagon,? \\Q1970\\E",
      "shortCiteRegEx" : "Baum and Eagon",
      "year" : 1970
    }, {
      "title" : "Musart: Music retrieval via aural queries",
      "author" : [ "W. Birmingham", "R. Dannenberg", "G. Wakefield", "M. Bartsch", "D. Bykowski", "D. Mazzoni", "C. Meek", "M. Mellody", "W. Rand" ],
      "venue" : "In Proceedings of International Symposium on Music Information Retrieval",
      "citeRegEx" : "Birmingham et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Birmingham et al\\.",
      "year" : 2001
    }, {
      "title" : "The musart music-retrieval system: An overview",
      "author" : [ "W. Birmingham", "B. Pardo", "C. Meek", "J. Shifrin" ],
      "venue" : "D-Lib Magazine,",
      "citeRegEx" : "Birmingham et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Birmingham et al\\.",
      "year" : 2002
    }, {
      "title" : "Accurate short-term analysis of the fundamental frequency and the harmonics-to-noise ratio of a sampled sound",
      "author" : [ "P. Boersma" ],
      "venue" : "Proceedings of the Institute of Phonetic Sciences, Vol. 17.",
      "citeRegEx" : "Boersma,? 1993",
      "shortCiteRegEx" : "Boersma",
      "year" : 1993
    }, {
      "title" : "Melody retrieval on the web",
      "author" : [ "W. Chai" ],
      "venue" : "Master’s thesis, Massachussetts Institute of Technology.",
      "citeRegEx" : "Chai,? 2001",
      "shortCiteRegEx" : "Chai",
      "year" : 2001
    }, {
      "title" : "A Metric Index for Approximate String Matching",
      "author" : [ "E. Chávez", "G. Navarro" ],
      "venue" : "In LATIN,",
      "citeRegEx" : "Chávez and Navarro,? \\Q2002\\E",
      "shortCiteRegEx" : "Chávez and Navarro",
      "year" : 2002
    }, {
      "title" : "Maximum likelihood from incomplete data via the em algorithm",
      "author" : [ "M. Dempster", "N. Laird", "D. Jain" ],
      "venue" : "Journal of the Royal Statistical Society,",
      "citeRegEx" : "Dempster et al\\.,? \\Q1977\\E",
      "shortCiteRegEx" : "Dempster et al\\.",
      "year" : 1977
    }, {
      "title" : "Evaluating a simple approach to music information retrieval: conceiving melodic n-grams as text",
      "author" : [ "S. Downie" ],
      "venue" : "Ph.D. thesis, University of Western Ontario.",
      "citeRegEx" : "Downie,? 1999",
      "shortCiteRegEx" : "Downie",
      "year" : 1999
    }, {
      "title" : "Biological Sequence Analysis",
      "author" : [ "R. Durbin", "S. Eddy", "A. Krogh" ],
      "venue" : "G.Mitchison",
      "citeRegEx" : "Durbin et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Durbin et al\\.",
      "year" : 1998
    }, {
      "title" : "Melody spotting using hidden markov models",
      "author" : [ "A. Durey" ],
      "venue" : "Proceedings of International Symposium on Music Information Retrieval.",
      "citeRegEx" : "Durey,? 2001",
      "shortCiteRegEx" : "Durey",
      "year" : 2001
    }, {
      "title" : "Algorithms on strings, trees, and sequences",
      "author" : [ "D. Gusfield" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "Gusfield,? 1997",
      "shortCiteRegEx" : "Gusfield",
      "year" : 1997
    }, {
      "title" : "Spoken language processing, chap. Large-vocabulary search algorithms, pp",
      "author" : [ "X. Huang", "A. Acero", "H. Hon" ],
      "venue" : null,
      "citeRegEx" : "Huang et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Huang et al\\.",
      "year" : 2001
    }, {
      "title" : "An Efficient Index Structure for String Databases",
      "author" : [ "T. Kahveci", "A.K. Singh" ],
      "venue" : "In Proceedings of 27th International Conference on Very Large Data Bases,",
      "citeRegEx" : "Kahveci and Singh,? \\Q2001\\E",
      "shortCiteRegEx" : "Kahveci and Singh",
      "year" : 2001
    }, {
      "title" : "String matching techniques for music retrieval",
      "author" : [ "K. Lemstrom" ],
      "venue" : "Tech. rep., University of Helsinki.",
      "citeRegEx" : "Lemstrom,? 2000",
      "shortCiteRegEx" : "Lemstrom",
      "year" : 2000
    }, {
      "title" : "Melody matching directly from audio",
      "author" : [ "D. Mazzoni" ],
      "venue" : "Proceedings of International Symposium on Music Information Retrieval.",
      "citeRegEx" : "Mazzoni,? 2001",
      "shortCiteRegEx" : "Mazzoni",
      "year" : 2001
    }, {
      "title" : "Towards the digital music library: Tune retrieval from acoustic input",
      "author" : [ "R.J. McNab", "L.A. Smith", "I.H. Witten", "C.L. Henderson", "S.J. Cunningham" ],
      "venue" : "In Digital Libraries,",
      "citeRegEx" : "McNab et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "McNab et al\\.",
      "year" : 1996
    }, {
      "title" : "The new zealand digital library MELody inDEX",
      "author" : [ "R. McNab", "L. Smith", "D. Bainbridge", "I. Witten" ],
      "venue" : null,
      "citeRegEx" : "McNab et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "McNab et al\\.",
      "year" : 1997
    }, {
      "title" : "Johnny can’t sing: A comprehensive error model for sung music queries",
      "author" : [ "C. Meek", "W. Birmingham" ],
      "venue" : "In Proceedings of International Symposium on Music Information Retrieval, pp",
      "citeRegEx" : "Meek and Birmingham,? \\Q2002\\E",
      "shortCiteRegEx" : "Meek and Birmingham",
      "year" : 2002
    }, {
      "title" : "Oasis: An online and accurate technique for localalignment searches on biological sequences",
      "author" : [ "C. Meek", "J. Patel", "S. Kasetty" ],
      "venue" : "In Proceedings of the 29th International Conference on Very Large Data Bases,",
      "citeRegEx" : "Meek et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Meek et al\\.",
      "year" : 2003
    }, {
      "title" : "Comparison of musical sequences",
      "author" : [ "M. Mongeau", "D. Sankoff" ],
      "venue" : "Computers and the Humanities,",
      "citeRegEx" : "Mongeau and Sankoff,? \\Q1990\\E",
      "shortCiteRegEx" : "Mongeau and Sankoff",
      "year" : 1990
    }, {
      "title" : "Timing information for musical query matching",
      "author" : [ "B. Pardo", "W. Birmingham" ],
      "venue" : "In Proceedings of International Symposium on Music Information Retrieval",
      "citeRegEx" : "Pardo and Birmingham,? \\Q2002\\E",
      "shortCiteRegEx" : "Pardo and Birmingham",
      "year" : 2002
    }, {
      "title" : "Algorithms for chordal analysis",
      "author" : [ "B. Pardo", "W. Birmingham" ],
      "venue" : "Computer Music Journal, 26, 27 – 49.",
      "citeRegEx" : "Pardo and Birmingham,? 2002",
      "shortCiteRegEx" : "Pardo and Birmingham",
      "year" : 2002
    }, {
      "title" : "Cubyhum: a fully functional, “query by humming” system",
      "author" : [ "S. Pauws" ],
      "venue" : "Proceedings of International Symposium on Music Information Retrieval.",
      "citeRegEx" : "Pauws,? 2002",
      "shortCiteRegEx" : "Pauws",
      "year" : 2002
    }, {
      "title" : "Flexible sequence similarity searching with the fasta3 program package",
      "author" : [ "W. Pearson" ],
      "venue" : "http://www.people.virginia.edu/ wrp/papers/mmol98f.pdf.",
      "citeRegEx" : "Pearson,? 1998",
      "shortCiteRegEx" : "Pearson",
      "year" : 1998
    }, {
      "title" : "An audio front end for query-by-humming systems",
      "author" : [ "E. Pollastri" ],
      "venue" : "Proceedings of International Symposium on Music Information Retrieval.",
      "citeRegEx" : "Pollastri,? 2001",
      "shortCiteRegEx" : "Pollastri",
      "year" : 2001
    }, {
      "title" : "A tutorial on hidden markov models and selected applications in speech recognition",
      "author" : [ "L.R. Rabiner" ],
      "venue" : "Proceedings of IEEE, Vol. 77 (2), pp. 257 – 286.",
      "citeRegEx" : "Rabiner,? 1989",
      "shortCiteRegEx" : "Rabiner",
      "year" : 1989
    }, {
      "title" : "Hmm-based musical query retrieval",
      "author" : [ "J. Shifrin", "B. Pardo", "C. Meek", "W. Birmingham" ],
      "venue" : "In Proceedings of Joint Conference on Digital Libraries",
      "citeRegEx" : "Shifrin et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Shifrin et al\\.",
      "year" : 2002
    }, {
      "title" : "Sensitivity and Selectivity in Protein Similarity Searches: A Comparison of Smith-Waterman in Hardware to BLAST and FASTA",
      "author" : [ "E. Shpaer", "M. Robinson", "D. Yee", "J. Candlin", "R. Mines", "T. Hunkapiller" ],
      "venue" : null,
      "citeRegEx" : "Shpaer et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Shpaer et al\\.",
      "year" : 1996
    }, {
      "title" : "Melodic resolution in music retrieval",
      "author" : [ "T. Sorsa" ],
      "venue" : "Proceedings of International Symposium on Music Information Retrieval.",
      "citeRegEx" : "Sorsa,? 2001",
      "shortCiteRegEx" : "Sorsa",
      "year" : 2001
    }, {
      "title" : "Recognition of musical key: Exploratory study",
      "author" : [ "E. Terhardt", "W. Ward" ],
      "venue" : "Journal of the Acoustical Society of America, 72,",
      "citeRegEx" : "Terhardt and Ward,? \\Q1982\\E",
      "shortCiteRegEx" : "Terhardt and Ward",
      "year" : 1982
    }, {
      "title" : "Content-based retrieval for music collections",
      "author" : [ "Tseng", "Y.-H." ],
      "venue" : "Proceedings of the 22nd annual international ACM SIGIR conference on Research and development in information retrieval, pp. 176 – 182. ACM Press.",
      "citeRegEx" : "Tseng and Y..H.,? 1999",
      "shortCiteRegEx" : "Tseng and Y..H.",
      "year" : 1999
    }, {
      "title" : "Overview of the fifth text retrieval conference",
      "author" : [ "E.M. Voorhees", "D.K. Harman" ],
      "venue" : "In The Fifth Text REtrieval Conference",
      "citeRegEx" : "Voorhees and Harman,? \\Q1997\\E",
      "shortCiteRegEx" : "Voorhees and Harman",
      "year" : 1997
    }, {
      "title" : "Sia(m)ese: An algorithm for transposition invariant, polyphonic content-based music retrieval",
      "author" : [ "G. Wiggins", "K. Lemstrom", "D. Meredith" ],
      "venue" : "In Proceedings of International Symposium on Music Information Retrieval",
      "citeRegEx" : "Wiggins et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Wiggins et al\\.",
      "year" : 2002
    }, {
      "title" : "Warping indexes with envelope transforms for query by humming",
      "author" : [ "Y. Zhu", "D. Shasha" ],
      "venue" : "In Proceedings of SIGMOD",
      "citeRegEx" : "Zhu and Shasha,? \\Q2003\\E",
      "shortCiteRegEx" : "Zhu and Shasha",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 11,
      "context" : "For instance, a frame-based frequency representation is often used (Durey, 2001; Mazzoni, 2001).",
      "startOffset" : 67,
      "endOffset" : 95
    }, {
      "referenceID" : 16,
      "context" : "For instance, a frame-based frequency representation is often used (Durey, 2001; Mazzoni, 2001).",
      "startOffset" : 67,
      "endOffset" : 95
    }, {
      "referenceID" : 26,
      "context" : "Various methods for the translation of frequency and amplitude data into note abstraction exist (Pollastri, 2001; Shifrin, Pardo, Meek, & Birmingham, 2002).",
      "startOffset" : 96,
      "endOffset" : 155
    }, {
      "referenceID" : 5,
      "context" : "Our group currently uses a transcriber based on the Praat pitch-tracker (Boersma, 1993), designed to analyze voice pitch contour.",
      "startOffset" : 72,
      "endOffset" : 87
    }, {
      "referenceID" : 26,
      "context" : "Adopting an approach proposed for a QBH “audio front end” (Pollastri, 2001), we consider several offsets (O = {0.",
      "startOffset" : 58,
      "endOffset" : 75
    }, {
      "referenceID" : 5,
      "context" : "1 Frequency Analysis We use the Praat pitch-tracker (Boersma, 1993), an enhanced auto-correlation algorithm developed for speech analysis, for this stage.",
      "startOffset" : 52,
      "endOffset" : 67
    }, {
      "referenceID" : 15,
      "context" : "However, previous work assumes this kind of influence: noting that intervallic contour tends to be the strongest component in our memory of pitch; one researcher has proposed that insertions and deletions could in some cases have a “modulating” effect (Lemstrom, 2000), where the edit introduces a pitch offset, so that pitch intervals rather than the pitches themselves are maintained.",
      "startOffset" : 252,
      "endOffset" : 268
    }, {
      "referenceID" : 16,
      "context" : "Many QBH applications adopt this approach to rhythm (Mazzoni, 2001; Meek & Birmingham, 2002; Pauws, 2002; McNab, Smith, Bainbridge, & Witten, 1997; McNab, Smith, Witten, Henderson, & Cunningham, 1996).",
      "startOffset" : 52,
      "endOffset" : 200
    }, {
      "referenceID" : 24,
      "context" : "Many QBH applications adopt this approach to rhythm (Mazzoni, 2001; Meek & Birmingham, 2002; Pauws, 2002; McNab, Smith, Bainbridge, & Witten, 1997; McNab, Smith, Witten, Henderson, & Cunningham, 1996).",
      "startOffset" : 52,
      "endOffset" : 200
    }, {
      "referenceID" : 28,
      "context" : "For instance, a pitch- and tempo-invariant representation (pitch interval and inter-onset interval ratio) (Shifrin et al., 2002; Pauws, 2002) establishes a new transposition and tempo context for each note, thus introducing the implicit assumption that all errors are cumulative (Pardo & Birmingham,",
      "startOffset" : 106,
      "endOffset" : 141
    }, {
      "referenceID" : 24,
      "context" : "For instance, a pitch- and tempo-invariant representation (pitch interval and inter-onset interval ratio) (Shifrin et al., 2002; Pauws, 2002) establishes a new transposition and tempo context for each note, thus introducing the implicit assumption that all errors are cumulative (Pardo & Birmingham,",
      "startOffset" : 106,
      "endOffset" : 141
    }, {
      "referenceID" : 26,
      "context" : "A study of sung queries (Pollastri, 2001) determined that cumulative error is in fact far less common than local error, a conclusion supported by our studies.",
      "startOffset" : 24,
      "endOffset" : 41
    }, {
      "referenceID" : 16,
      "context" : "Dynamic time-warping approaches (Mazzoni, 2001) and non-distributed HMM techniques (Durey, 2001) are wellsuited to this technique.",
      "startOffset" : 32,
      "endOffset" : 47
    }, {
      "referenceID" : 11,
      "context" : "Dynamic time-warping approaches (Mazzoni, 2001) and non-distributed HMM techniques (Durey, 2001) are wellsuited to this technique.",
      "startOffset" : 83,
      "endOffset" : 96
    }, {
      "referenceID" : 6,
      "context" : "An alternative is to normalize the tempo of the query by either automated beat-tracking, a difficult problem for short queries, or, more effectively, by giving the querier an audible beat to sing along with – a simple enough requirement for users with some musical background (Chai, 2001).",
      "startOffset" : 276,
      "endOffset" : 288
    }, {
      "referenceID" : 28,
      "context" : "It is possible to relax this assumption somewhat, by translating targets into Markov models where the state is simply a characteristic relationship between consecutive notes, allowing for loops in the model (Shifrin et al., 2002).",
      "startOffset" : 207,
      "endOffset" : 229
    }, {
      "referenceID" : 9,
      "context" : "Borrowing from the text search world, we can also model music as a collection of note n-grams, and apply standard text retrieval algorithms (Downie, 1999; Tseng, 1999).",
      "startOffset" : 140,
      "endOffset" : 167
    }, {
      "referenceID" : 12,
      "context" : "Existing indexing techniques for string-edit distance metrics – for instance using suffix trees (Chávez & Navarro, 2002; Gusfield, 1997) and so-called ‘wavelet’ approximations (Kahveci & Singh, 2001) – are appropriate for k-distance searches, and thus might prove useful as a pre-filtering mechanism.",
      "startOffset" : 96,
      "endOffset" : 136
    }, {
      "referenceID" : 25,
      "context" : "Linear search using sub-optimal heuristics has been applied to sequence matching in bio-informatics (Pearson, 1998; Altschul, Madden, Schaffer, Zhang, Zhang, Miller, & Lipman, 1997).",
      "startOffset" : 100,
      "endOffset" : 181
    }, {
      "referenceID" : 27,
      "context" : "The “standard” forward-variable algorithm (Rabiner, 1989) provides a significant reduction in complexity.",
      "startOffset" : 42,
      "endOffset" : 57
    }, {
      "referenceID" : 26,
      "context" : "93 there is no modulation), further evidence (Pollastri, 2001) that local error is indeed the critical component.",
      "startOffset" : 45,
      "endOffset" : 62
    }, {
      "referenceID" : 28,
      "context" : "For comparison, we provide results from another HMM-based QBH system, listed as “Simple HMM” (Shifrin et al., 2002), using default parameters.",
      "startOffset" : 93,
      "endOffset" : 115
    }, {
      "referenceID" : 30,
      "context" : "It has been shown that a natural “musical” interpretation of these edits helps alleviate the problem of target similarity when edits are observed, noted in an earlier QBH feasibility study (Sorsa, 2001).",
      "startOffset" : 189,
      "endOffset" : 202
    } ],
    "year" : 2011,
    "abstractText" : "We propose a model for errors in sung queries, a variant of the hidden Markov model (HMM). This is a solution to the problem of identifying the degree of similarity between a (typically error-laden) sung query and a potential target in a database of musical works, an important problem in the field of music information retrieval. Similarity metrics are a critical component of “query-by-humming” (QBH) applications which search audio and multimedia databases for strong matches to oral queries. Our model comprehensively expresses the types of error or variation between target and query: cumulative and noncumulative local errors, transposition, tempo and tempo changes, insertions, deletions and modulation. The model is not only expressive, but automatically trainable, or able to learn and generalize from query examples. We present results of simulations, designed to assess the discriminatory potential of the model, and tests with real sung queries, to demonstrate relevance to real-world applications.",
    "creator" : "dvips(k) 5.94a Copyright 2003 Radical Eye Software"
  }
}