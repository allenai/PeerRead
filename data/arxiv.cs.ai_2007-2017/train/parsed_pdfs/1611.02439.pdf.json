{
  "name" : "1611.02439.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Arg-LPNMR 2016 Proceedings",
    "authors" : [ "Sarah Alice Gaggl", "Juan Carlos Nieves", "Hannes Strass", "Sylvie Doutre", "Toshiko Wakaki", "Matti Järvisalo" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Arg-LPNMR 2016 Proceedings\nSarah Alice Gaggl, Juan Carlos Nieves, Hannes Strass (Eds.)\nNovember 2016\nar X\niv :1\n61 1.\n02 43\n9v 1\n[ cs\n.A I]\n8 N\nov 2\n01 6\nPreface This volume contains the papers presented at Arg-LPNMR 2016: First International Workshop on Argumentation in Logic Programming and Nonmonotonic Reasoning held on July 8-10, 2016 in New York City, NY.\nResearch on argumentation and an Artificial Intelligence (AI) began in full force in the early eighties. The initial efforts showed how argumentation results in a very natural way of conceptualizing commonsense reasoning, appropriately reflecting its defeasible nature. In the mid-nineties, Dung (1995) has shown that argumentation provides a useful perspective for relating different non-monotonic formalisms. Currently, argumentation has been applied in different subfields of AI like Multi-Agent Systems, Semantic Web, knowledge representation and reasoning, etc.\nWorks in the knowledge representation and reasoning community have shown that argumentation inferences in terms of the so called argumentation semantics have strong roots in logic-based theories and non-monotonic reasoning. In this sense, the relationship between logic programming and argumentation has attracted increased attention in the last years. Studies range from translating one into the other and back, using argumentation to explain logic programming models, and using logic programming systems to implement argumentation-based languages (ASPARTIX, DIAMOND). Influences go both ways and we believe that both fields can benefit from learning from each other. Moreover, argumentation allows to relate several non-monotonic formalisms such as belief revision, reasoning about actions and probabilistic reasoning.\nMore recently, argumentation has been revealed as a powerful conceptual tool for exploring the theoretical foundations of reasoning and interaction in autonomous systems and Multi-Agent Systems. Different dialogue models have been proposed based on the roots of argumentation. Indeed considering argumentation roots, the so called Agreement Technologies have been suggested in order to deal with the new requirement of interaction between autonomous systems and Multi-Agent Systems.\nThe workshop centered around four current research strands in abstract argumentation, namely analyzing argumentation semantics, studying dynamics in argumentation, and implementations of systems for abstract argumentation.\nThe committee decided to accept 2 papers. The program also includes 3 invited talks.\nNovember 2016 Sarah Alice Gaggl Juan Carlos Nieves\nHannes Strass\nProgram Committee\nGerhard Brewka Leipzig University Sylvie Doutre University of Toulouse 1 - IRIT Dov Gabbay King’s College, London Sarah Alice Gaggl Technische Universität Dresden Gabriele Kern-Isberner Technische Universitaet Dortmund Juan Carlos Nieves Umeå University Mauricio Osorio UDLAP Phan Phan Minh Dung AIT Chiaki Sakama Wakayama University Jan Sefranek Comenius University, Bratislava Guillermo Simari Dep of Computer Science and Engineering, Universidad Nacional del Sur in\nBahia Blanca Hannes Strass Leipzig University Paolo Torroni University of Bologna Toshiko Wakaki Shibaura Institute of Technology Stefan Woltran TU Wien\niii\niv\nConference Program\nInvited Talks 1 1 SAT-Based Approaches to Reasoning about Argumentation Frameworks\nMatti Järvisalo 3 Acceptability semantics for argumentation frameworks\nLeila Amgoud"
    }, {
      "heading" : "5 Aggregating Opinions in Abstract Argumentation",
      "text" : "Richard Booth\nTechnical Talks 7 7 Collaborative Planning and Decision Support for Practical Reasoning in Decentralized Supply Chains\nNaeem Janjua 15 Revision of Abstract Dialectical Frameworks: Preliminary Report\nThomas Linsbichler, Stefan Woltran\nv\nvi\nSAT-Based Approaches to Reasoning about Argumentation Frameworks∗\nMatti Järvisalo Helsinki Institute for Information Technology HIIT, Department of Computer Science,\nUniversity of Helsinki, Finland\nIntroduction Argumentation is a central topic in modern Artificial Intelligence (AI) research [Bench-Capon and Dunne, 2007] with connections to a range of scientific disciplines, from computational complexity theory and automated reasoning to philosophy and social sciences, with applications to domains such as legal reasoning, multi-agent systems, and decision support. Argumentation frameworks (AFs) [Dung, 1995] have become the graph-based formal model of choice for many approaches to argumentation in AI, with semantics defining sets of jointly acceptable arguments, i.e., extensions.\nSystem implementations for reasoning over AFs have recently received much attention. Many central AF reasoning tasks can be represented in a natural way as Boolean combinations of logical constraints via developing propositional (SAT) encodings. This is true for both what we here refer to as static (or non-dynamic) problems, as well as problems related to AF dynamics, dealing with adjusting (or revising) a given AF to support new knowledge represented as extensions the AF should support. Interestingly, the study of AF dynamics gives rise to optimization problems, inviting the employment of Boolean optimization solvers, such as maximum satisfiability (MaxSAT) solvers, the optimization counterpart of SAT—relying again heavily on SAT solvers.\nThe state-of-the-art SAT solver technology readily available today offers the core NP decision engines employed in many of the current state-of-the-art argumentation reasoning systems focusing on static reasoning problems [Thimm et al., 2016]. The use of SAT solvers is not restricted to problems in NP. Rather, SAT solvers allow for solving hard decision problems presumably well beyond NP via harnessing instantiations of the general SAT-based counterexample-guided abstraction refinement (CEGAR) approach [Clarke et al., 2004; 2003]. In short, SAT-based CEGAR is based on iterative and incremental applications of SAT solvers, iteratively solving a sequence of abstractions and ruling out non-solutions through counterexample-based refinements to the abstraction towards finding one or more solutions to the actual problem instance at hand. As complexity-theoretically very challenging problems are abundant in AF reasoning—various types of decision and optimization problems under different AF semantics\n∗Work supported by Academy of Finland (251170 COIN, 276412, 284591) and Research Funds of the University of Helsinki.\nexhibiting completeness for different levels of the polynomial hierarchy—developing CEGAR-type SAT-based procedures for AF reasoning tasks is an intuitive choice.\nThe development of SAT-based procedures for AF reasoning tasks poses interesting research challenges of both theoretical and more applied nature.\nComplexity-theoretic analysis. Understanding the complexity of AF reasoning tasks with respect to different parameterizations (AF semantics, reasoning modes, and other problem-specific parameters) is essential for understanding whether a specific reasoning task allows for direct SAT encodings (in NP) and on the other hand is not “too trivial” for SAT solvers (NP-complete, or at least not solvable in close to linear time). For reasoning tasks complete for higher levels of the polynomial hierarchy (Σpi / Π p i complete for some i > 1), the level i on which a specific task is situated gives guidelines on the requirements for SAT-based CEGAR suitable for the task, connecting theory to practice.\nNP encodings and CEGAR. Development of SAT-based approaches is thus guided by complexity analysis for choosing the “right” approach to the AF reasoning task at hand. For problems in NP, a challenge is to develop reasonably compact direct SAT encodings (for decision problems) or MaxSAT encodings (or other constraint optimization formulations, for optimization problems) for the problem. Compactness here refers to ensuring scalability to larger AFs (with the understanding that, at times, SAT solvers can readily solve instances with millions or even tens of millions of variables and clauses [Järvisalo et al., 2012]). For CEGAR, a suitable NPabstraction is needed, as well as refinement strategies which effectively rule out non-solutions from consideration.\nImplementation-level details. From encodings and procedures to implementation, the choice of the SAT and MaxSAT solvers can have a noticeable impact on scalability and efficiency, in connection to the interplay between the underlying structure of a specific AF reasoning problem, the SAT/MaxSAT encoding, and the search techniques and heuristics applying within the solvers. The incremental APIs offered by some of the central SAT solvers also play a key role in implementing CEGAR-style iterative approaches. The use of MaxSAT solvers in CEGAR has been less studied, and poses more challenges, e.g. in that few MaxSAT solvers offer APIs, and still only few are available in open source.\n1\nSAT-Based Systems: A Personal View Cegartix SAT-based CEGAR procedures for acceptance problems under various semantics. A successful approach to static AF reasoning is provided by our Cegartix system [Dvořák et al., 2014]. Implementing a SAT-based CEGAR approach to second-level complete skeptical and credulous acceptance problems, the system ranked at the top on second-level problems in the ICCMA 2015 competition [Thimm et al., 2016].\nPakota MaxSAT-based procedures for enforcement. Addressing the so-called extension enforcement problem [Baumann, 2012; Bisquert et al., 2013; Coste-Marquis et al., 2015] in abstract argumentation and its generalizations, in [Wallner et al., 2016] we provide a nearly complete computational complexity map of fixed-argument extension enforcement under various major AF semantics, with results ranging from polynomial-time algorithms to completeness for the secondlevel of the polynomial hierarchy. Complementing the complexity results, we give algorithms for NP-hard extension enforcement via constrained optimization. Going beyond NP, we propose novel MaxSAT-based CEGAR for the secondlevel complete problems, as well as an open-source system implementation of the approach. As a continuation, we have generalized the approach to the so-called status enforcement problem [Niskanen et al., 2016a], bringing together concepts from both static credulous/skeptical acceptance and AF dynamics, most closely, extension enforcement, resulting in Pakota, a MaxSAT-based enforcement system first of its kind in terms of generality [Niskanen et al., 2016b].\nAF synthesis MaxSAT approaches to synthesizing AFs from examples. A fundamental knowledge representational aspect related to AFs is realizability [Dunne et al., 2015], i.e., the question of whether a specific AF semantics allows for exactly representing a given set of extensions as an AF [Dunne et al., 2015; Baumann et al., 2014; Dyrkolbotn, 2014; Pührer, 2015; Linsbichler et al., 2016; 2015]. A set E of extensions is realizable (under a specific semantics) if and only if there is an AF the extensions of which are exactly those in E; this requires that we have complete knowledge of the extensions of interest, and, in order to actually construct a corresponding AF of interest, relies on the assumption that the set of extensions are not conflicting in terms of allowing them to be exactly represented by an AF. Recently in [Niskanen et al., 2016c], we generalized the concept of realizability to accommodate incomplete and noisy information on extensions, proposing what we call the AF synthesis problem. Establishing NP-complete and tractable cases of AF synthesis, we have developed a first MaxSAT-based approach to optimal AF synthesis—again going from complexity-theoretic analysis to on actual implemented system for AF synthesis."
    }, {
      "heading" : "An argument is a reason or justification of a claim.",
      "text" : "It has an intrinsic strength and may be attacked by other arguments. Hence, the evaluation of its overall strength is mandatory. Such an evaluation is done by acceptability semantics.\nIn this talk, we provide the foundations of a semantics, i.e., key concepts and principles on which an evaluation is based. Each concept (principle) is described by an axiom. We then present two families of semantics: extension semantics and ranking semantics. We analyze them against the axioms shedding thus light on the assumptions and choices they made. The analysis allows also a clear comparison between semantics of the same family, and between extension semantics and ranking ones."
    }, {
      "heading" : "1 Introduction",
      "text" : "An argument gives reason to support a claim that is questionable, or open to doubt. It is made of three components: premises representing the reason, a conclusion which is the supported claim, and a link showing how the premises lead to the conclusion. The link is hence the logical “glue” that binds premises and conclusions together.\nAn argument has an intrinsic strength which may come from different sources: the certainty degree of its reason [Amgoud and Cayrol, 2002], the importance of the value it promotes if any [Bench-Capon, 2003], the reliability of its source [Parsons et al., 2011], . . .. Whatever its intrinsic strength (strong or weak), an argument may be attacked by other arguments. An attack amounts to undermining one of the components of an argument, and has thus a negative impact on its target. An evaluation of the overall strength (or overall acceptability) of an argument becomes mandatory, namely for judging whether or not its conclusion is reliable.\nThe evaluation of arguments has received great interest from the computational argumentation community. Indeed, two families of acceptability semantics were defined for this purpose: extension semantics and ranking semantics.\nInspired from logic programming, extension semantics were initially introduced by Dung [1995]. Starting with a\nset of arguments and attacks between them, they return a set of extensions, each of which is a set of arguments that are acceptable together. Some semantics allow multiple extensions while others allow only a single extension. Using a membership criterion, a qualitative acceptability degree is assigned to each argument. Examples of such semantics are the classical semantics of Dung (complete, stable, preferred, ...) and their different refinements (e.g. [Baroni et al., 2005; Caminada, 2006; Dung et al., 2007]).\nUnlike extension semantics, ranking semantics do not compute extensions. They use scoring functions which assign a numerical acceptability degree to each argument. The degree of an argument is computed in an iterative way on the basis of the degrees of its direct attackers. Examples of such semantics are h-Categorizer [Besnard and Hunter, 2001], its generalized version [Cayrol and Lagasquie-Schiex, 2005; Pu et al., 2014], game-theoretic semantics [Matt and Toni, 2008], Bbs, Dbs [Amgoud and BenNaim, 2013], parametrized semantics [Amgoud et al., 2016], and those proposed in [Gabbay, 2012; Gabbay and Rodrigues, 2015; Leite and Martins, 2011; da Costa Pereira et al., 2011].\nIn this talk, we compare the two families of semantics (extension semantics and ranking semantics). For that purpose, we start by providing a unified definition of semantics. Then, we present the axiomatic foundations of a semantics as developed in [Amgoud and Ben-Naim, 2016]. We recall the set of axioms that was proposed. Each axiom represents a property that a semantics would satisfy or a principle on which it should be based. Furthermore, some axioms are mandatory while others are optional and represent strategic choices. We then analyze existing extension/ranking semantics against the axioms. The analysis shows the assumptions underlying each semantics, and compares the various semantics. We show that ranking semantics take into account both the number of attackers and their strengths while extension semantics neglect the number of attackers. Unlike ranking semantics, in extension semantics the effect of an attack may be lethal."
    }, {
      "heading" : "1 Introduction and Background",
      "text" : "The problem of judgment aggregation (JA), i.e., the problem of aggregating the opinions of a group of agents over a set of logically inter-connected propositions, has received quite a lot of attention recently from researchers in multi-agent systems, philosophy and economics. In this talk we report recent and ongoing work on a version of this problem in the setting of abstract argumentation.\nWe assume a fixed set Ag “ t1, . . . , nu of agents, who are evaluating arguments of a given argumentation framework (AF) A. Each evaluation takes the form of an A-labelling, i.e., an assignment of one of the labels in (denoting accepted), out (rejected) or undec (undecided) to each argument of A. Not all possible A-labellings are feasible. The feasible labellings are the ones that conform to the particular argumentation semantics under consideration. This could be, for example, the complete, stable or preferred semantics, etc. We assume each agent submits a feasible A-labelling. In this talk we will just use complete semantics, because that has been the focus of our work until now.\nGiven an AF A “ xArgs,áy, a complete A-labelling is a function L : Args Ñ tin, out, undecu that satisfies, for all a, b P Args: • Lpaq “ in iff Lpbq “ out for all b P Args s.t. bá a. • Lpaq “ out iff Lpbq “ in for some b P Args s.t. bá a.\nWe will sometimes also talk about admissible A-labellings, i.e, labellings that are required to satisfy only the left-to-right directions of the above two conditions.\nAn A-profile L “ pL1, . . . , Lnq is a sequence of complete A-labellings, one for each agent. Our aim is to define, in a principled manner, a concrete aggregation method for the agents.\nDefinition 1 A (resolute) aggregation method is a function F that assigns, to every AF A and every A-profile L, an Alabelling FApLq. FApLq represents the A-labelling of the group, given each agent i submits Li."
    }, {
      "heading" : "2 Postulates for Aggregation Methods",
      "text" : "What properties do we want our aggregation methods to satisfy? A most basic requirement is that we want the output to\nbe feasible1: Collective Completeness FApLq is a complete A-labelling.\nCompatibility enforces a level of consistency of the output with each of the agents’ individual labellings. Here, for any label x, x denotes in if x “ out, out if x = in, and undec otherwise. Compatibility For all i P Ag and a P ArgsA we haverFApLqspaq “ Lipaq implies rFApLqspaq “ undec.\nA weakening of Compatibility is the following. in/out-Plurality If x is the in{out-loser in pLipaqqiPAg then rFApLqspaq ‰ x Here, the in{out-loser (resp. winner) of a given tuple of labels is that label among tin, outu that appears the fewer (resp. more) number of times.\nThe next property says that the collective labelling of a given argument a is independent of whichever other arguments might be present or absent in the given AF. Here LrAs denotes the restriction of a given profile L to just the arguments in A for any A Ď ArgsA. AF-Independence If L1 and L2 are profiles over A1 and A2 respectively and a P ArgsA1 X ArgsA2 then L1ras “ L2ras implies rFA1pL1qspaq “ rFA2pL2qspaq. AF-Independence turns out to be incompatible with Collective Completeness in the presence of a couple more mild requirements [Booth et al., 2014]. A weaker version, that is arguably more appropriate anyway in an argumentation setting, is: Directionality Suppose A Ďf A1 and suppose ArgsA is unattacked in A1. Then for any A1-profile L and a P ArgsA we have rFA1pLqspaq “ rFApLrArgsAsqspaq."
    }, {
      "heading" : "3 Families of Aggregation Methods",
      "text" : ""
    }, {
      "heading" : "3.1 Interval Methods",
      "text" : "In interval aggregation methods [Booth et al., 2014], the collective label for a P ArgsA is taken to be the in/outwinner x in Lras, provided that the victory of x over x is “sufficiently decisive”. Otherwise we just take undec. Formally, let Intn “ tpk, lq | k ă l, k, l P t0, 1, . . . , nuu. Let\n1These and other postulates are discussed in [Booth et al., 2014].\n5\nY Ď Intn be such that p0, nq P Y . Then we define aggregation method FY by setting, for each A, A-labelling profile L and a P ArgsA:\nrFYA pLqspaq “ $ & % x if x P tin, outu and p|V La: x|, |V La:x|q P Y\nundec otherwise\nHere, V La:x denotes the set of agents who labelled argument a with x. If Y satisfies [pk, lq P Y implies ps, tq P Y whenever s ď k and l ď t] then FY is a widening interval method. If Y satisfies [pk, lq P Y implies k “ 0] then FY is zero-based. As special cases of both of these classes we have the sceptical initial aggregation method, for which Y “ tp0, nqu, and the credulous initial aggregation method, for which Y “ tp0, lq | l ą 0u [Caminada and Pigozzi, 2011].\nInterval methods have been axiomatised in [Booth et al., 2014]. Their characteristic postulates include AFIndependence and in/out-Plurality. Also the widening and zero-based interval methods have been characterised. An interval method is zero-based iff it satisfies Compatibility."
    }, {
      "heading" : "3.2 DAUC Interval Methods",
      "text" : "Interval methods don’t satisfy Collective Completeness. To remedy this we use the down-admissible and up-complete procedures to repair FY pLq and make it complete. The down-admissible labelling ç L of an arbitrary labelling L is obtained by relabelling every illegally in- or out-labelled argument with undec. The resulting labelling will be admissible but not necessarily complete. The up-complete labelling äL of a given admissible labelling can be obtained by relabelling every illegally undec-labelled argument with in or out as appropriate. (See [Caminada and Pigozzi, 2011] for details.)\nThe DAUC version of an interval method FY is obtained by taking as output, for any given AF A and Aprofile L, êFYA pLq. Collective Completeness is guaranteed by construction. DAUC interval methods don’t satisfy AFIndependence but they satisfy instead Directionality. Surprisingly, in/out-Plurality holds only if FY is zero-based [Booth et al., 2014]. In [Caminada and Booth, 2016] we outline discussion-based procedures for determining whether an argument should be labelled in by ê FYA pLq for the special cases in which FY is the sceptical initial and credulous initial methods."
    }, {
      "heading" : "3.3 Partial Resolution-based Methods",
      "text" : "Another way to use a family of intervals Y to define an aggregation method is the partial resolution approach [Baroni et al., 2011]. Let’s say a P ArgsA is Y -supported in L ifp|V La:out|, |V La:in|q P Y . Then modify A by resolving any mutual attack in favour of Y -supported arguments, i.e., if aé b, remove one of these attacks if it goes from an un-Y -supported argument to a Y -supported one. Then GYApLq is defined by taking the grounded labelling of this modified AF. The resulting method GY satisfies Collective Completeness. Furthermore if FY is widening then FY and GY give the same results when restricting to the class of symmetric AFs (i.e., AFs for which every attack is mutual)."
    }, {
      "heading" : "3.4 Distance-based Approaches",
      "text" : "Another approach to aggregation is to base it on some notion of distance dpL1, L2q between labellings. For instance, given such a distance, we could take the result of aggregation to be that complete labelling that is closest to the group. Of course it may well turn out that we end up with several closest labellings, which means the output will be a set of labellings rather than a single one. We also need to define an appropriate distance measure. One possibility here is the issue-based distance [Booth et al., 2012]. Roughly, the arguments in an AF can be partitioned into a set of issues, i.e., arguments whose labels are either always the same or always opposite (in vs out) in every complete labelling. The distance dpL1, L2q is then determined by taking one representative a from each issue and summing diff pL1paq, L2paqq over all these representatives, where diff is some measure of difference between labels (e.g., diff pin, outq “ 2, diff pin, undecq “ diff pout, undecq “ 1, etc.). By summing just over these representatives rather than over all arguments we avoid double counting, i.e., we disregard some differences in the labelling that might already be necessary consequences of some other differences. An initial study of the resulting aggregation methods can be found in [Podlaszewski, 2015]."
    }, {
      "heading" : "4 Further and Ongoing Work",
      "text" : "We are in the process of expanding the results not just to AFs but also to abstract dialectical frameworks (ADFs). Indeed DAUC interval methods have been extended to ADFs in [Booth, 2015]. Secondly, it remains to explore the precise relation with JA: does our setting subsume the JA one, or the other way around? Finally we’d like to fully characterise the families of aggregation methods described here."
    }, {
      "heading" : "1 Introduction",
      "text" : "Supply chain (SC) activities move the entire economy of the world and are one of the major contributors to nation’s GDP [3]. The increase in outsourcing and the rise of digital technologies has led to the widespread adoption of ebusiness models and businesses are involved in collaboration and mergers with others on a global scale, competing as a SC rather than as individuals [4]. Due to the decentralized nature of SCs, the current SC trading partners are still far from structured collaborative planning and decision support in presence of information asymmetry. This means one SC trading partner might possess some important information (potentially incomplete and/or contradictory) that is neither available in the public domain nor verifiable by a third party. The inability to\nshare and use such information in collaborative planning and decision support may result in suboptimal decisions.\nOver the past decade, SC trading partners focused on building a Systems of Record (SoR) i.e. structured product data, orders and demand forecasts [5]. The decision support derived from the SoR can answer questions related to the pattern “What is happening” but provides no information to answer questions related to the pattern “Why it is happening and what is the rationale behind it”. As a result, complex SC networks have a tendency to become vulnerable to uncertainties and operational risks [6]. Therefore, collaborative planning and decision support faces the challenge of aligning the activities of SC trading partners in a decentralized network which contributes to the value creation of the product or service for the customer in the presence of information asymmetry to overcome operational risks. This article aims to explore the logical foundations and implementation of efficient and effective CP-DSS for practical reasoning in decentralized supply chains. Although a large body of knowledge exists on collaborative planning and decision support, this approach of practical reasoning is novel due to the following two features:\n1. Incomplete and contradictory planning information is considered. Developing and agreeing on plans that involve multiple players is not a trivial task, especially when there is a lack of information pertaining to the potential risk. In real life, when the underlying available information is incomplete and/or contradictory, people are reluctant to make decisions. As a result, they indulge themselves into the process of argumentation. Argumentation involves building arguments in favour and against a certain issue. Arguments are defeasible in nature i.e. additional information may invalidate what has been previously accepted as an argument. Propositions accepted on the basis of given arguments don’t grow monotonically with the available information. Using this approach, not only can we reason and deliberate over the means by which choices are compared, we can critically analyse the information upon which this comparison takes place.\n2. Planning is interleaved with reasoning about preferences. Preferences are often context-dependent and conflicting preferences contribute towards the growing complexity of collaborative planning and the decision-\n7\nmaking processes. In order to create balanced proposals, conflicting preferences between SC trading partners need to be considered as early as possible during the planning phase for further deliberation to find a consensus over a course of action. This process is known as meta-argumentation. During meta-argumentation, reasoning and supporting data are provided by each member to support their viewpoint, and they agree or disagree by providing a justification for their opinion. The re-configuration of positions as a result of meta-argumentation between members strengthens each other’s cumulative contribution towards practical planning."
    }, {
      "heading" : "2 State-of-the-art.",
      "text" : "The collaboration problem in decentralized SCs consists of two interleaving functions, namely planning and decision support. Planning involves generating plans whose success is warranted by some evidence coming from either one or different SC trading partners and decision support to evaluate the acceptability of these plans by comparing the evidence supporting them against possible objections. A planner needs to reason about their actions. Therefore, during collaborative planning, decision makers need decision support models for choosing, organising, and revisiting their actions and plans [7]. There is a plethora of work on planning and decision support in supply chains which can be divided into the following three categories:"
    }, {
      "heading" : "2.1 Mathematical and analytical based approaches",
      "text" : "Several supply chain collaboration practices, such as the Vendor Managed Inventory, Just In Time, Efficient Consumer Response, Continuous Replenishment and Accurate Response, Collaborative Planning, Forecasting and Replenishment (CPFR) that have been suggested in the literature focus on better planning through tight processes, integration and sharing the forecasting information among the SC trading partners [8]. However, in these applications, either no or very little decision-making aid is provided with respect to the negotiation process. Several researchers introduced a process model concerned with the decision-making and negotiation aspect of collaborative planning between trading partners while respecting their local decision-making authority [9; 10]. The research approaches discussed above are drawn from applied mathematics, such as optimization, statistics and decision theory and act as a black box for decision makers. They take in information and generate results but provide no visibility as to the underlying reasoning and justification behind the results. As a result, there is limited adoption of such approaches in SCs [11]."
    }, {
      "heading" : "2.2 Logic-based approaches for automated planning and decision making",
      "text" : "Multi-agent planning systems are advanced planning systems (APS) applied to independent or loosely-coupled problems to enhance the benefit of distributed planning between autonomous software agents [12]. During coordination, software agents who are engaged in collaboration build a model\nof other agents’ mental states and update their own beliefs and goals as the dialogue progresses[13]. To handle uncertainty, argumentation-driven frameworks that allow different software agents to share their knowledge and resolve conflicts between them to reach the common goal have been proposed [12]. However, in most APS systems, planning provides the solution, and on execution it merely traverses the identified path. Such systems work well in the Closed-World Assumption where all the possible effects of each action are known in advance. However, planning becomes very challenging if the environment is dynamically changing (the Open-World Assumption) and is not pre-engineered to conform to software agent’s needs. Furthermore, planners want to use tools for better visibility of the planning process but want to control the decision-making part of the planning phase."
    }, {
      "heading" : "2.3 Logic based approaches supporting planning and decision making",
      "text" : "The introduction of Semantic Web technology tools for collaboration has addressed some of the issues of collaboration among SC trading partners, such as information has meaning attached to it that makes it understandable across organisational boundaries and facilitates data sharing and integration [14]. Attempts have been made to represent incomplete and contradictory information in information systems such as Dr-Prolog, Dr-Device, and Situated Courteous logic [15]. These implementations only represent and handle individual conflicting preferences by defining priorities based on a single criterion between them before engaging in collaboration. Therefore, these attempts do not provide a solution for collaborative planning that is subject to inconsistencies that derive from multiple data/information sources and multiple users. Furthermore, these techniques have not yet been applied to collaborative planning and decision support domains. The Collaborative Planning and Acting Model [16] is the first attempt to support planners in managing and planning information and facilitates the planning process with automated reasoning. However, the model lacks the means to represent incomplete and contradictory information and logical relations that define constraints and the axioms of the domain being modeled.\nThis research is first of its kind to study collaborative planning and decision support for practical reasoning in decentralized SCs. It aims to better align the activities of SC trading partners to overcome the operational risks as shown in Figure 1. The challenge is two-fold: firstly, how to take into account incomplete and contradictory planning information, reason and integrate it for proactive risk prediction and better planning; secondly, the current logic-based approaches supporting planning and decision making only handle individual preferences in the form of priorities. Additionally, the use of these priorities is usually embedded in the reasoning mechanism and competing rules are compared individually during the reasoning process. Therefore, the derivation notion is bound to one single comparison criterion. In such a scenario, the explanation of the results is based on a single criterion only and fails to take into account the multiple factors important for decision-making.\n8"
    }, {
      "heading" : "3 Motivation",
      "text" : "Despite the increasing use of advanced planning tools and technologies, the current SC trading partners are far from structured collaborative planning and decision support for practical reasoning. Of the various factors, data integration has been considered as one of the core problems in business information systems [17]. In the last decade, the focus of SC trading partners was on Systems of Records (SoR) i.e. structured data about sales, customer and product information, inventory forecasts and so, and it was used for planning and decision making. As a result, centralized enterprise information systems such as data warehousing systems, exclusively dealt with record-oriented data that was carefully mapped using schema-centric mediation approaches by knowledge experts to support planning decisions. In such information systems, the business intelligence derived for planning can often provide decision support by answering the questions related to patterns of “what is happening”. To answer questions related to patterns of “why is it happening and what is the rationale behind it”, it is necessary to conjointly mine the SoR with the information generated as a result of the Systems of Engagement (SoE) with business partners or customers. The SoE are more decentralized, incorporate digital technologies for peer-to-peer interactions, and enable SC members in a network to collaborate and engage across a range of pivotal transactional processes on a global scale as shown in Figure 2. Therefore, SoE information complements SoR data with better insight, reason and interpretation. For example, by using SoR, a supplier can predict SC disruptions that may be caused by unexpected demand patterns from other trading partners through predictive analytics, however, they would not able to obtain information on the nature of complaints or requests made by the trading partner during the negotiation process which are not captured and stored as SoE in the repositories’ holding emails or transcribed phone call information records during the planning and decision-making process. Therefore, this problem of knowledge sharing and practical reasoning involves creating SoE along with SoR and uses them conjointly to find patterns, knowledge and relationships for better deci-\nsion support during collaborative planning to overcome the issue of information asymmetry. Practical reasoning is reasoning about what is to be done and it includes some actions or the adoption of an intension to initiate a sequence of actions later [1]. It underlines the need for informed and experienced judgment in many situations for decision support applications in SCs."
    }, {
      "heading" : "4 Proposed conceptual framework",
      "text" : "In this section, the solution for Collaborative planning and Decision Support in Decentralized Supply Chains is proposed to aligned the activities of trading partners in a supply chain. The proposed framework uses Defeasible logic programming (DeLP) as knowledge representation and reasoning language [18]. DeLP which is general-purpose defeasible argumentation formalism based on logic programming, is used to model inconsistent and potentially contradictory knowledge. A defeasible logic program has the form ψ= (Π,∆), where Π and ∆ stand for strict knowledge (non-defeasible) and defeasible knowledge (tentative), respectively. DeLP uses the argumentation formalism for reasoning over contradictory information by identifying conflicting information in the knowledge base and applying the dialectical process to decide which information prevails during the argumentative reasoning process. DeLP only uses goal-driven reasoning with the objective of serving only the users queries. It does not provide a solution for data-driven reasoning to infer new knowledge from existing information [19]. In my previous work [20], DeLP has been extended in order to make it suitable for information representation and reasoning in a Semantic Web application. The extensions made are as follows :\n• Defined syntax and semantics for DeLP to represent business (planning) rules for hybrid reasoning. • Proposed an argumentative production system that uses\nDeLP as the information representation language, and performs hybrid reasoning over incomplete and/or contradictory information.\nIn this research, I use extended DeLP for Semantic Web application to represent the planning tasks in the CP-DSS. Figure 2 depicts the proposed framework for CP-DSS and the\n9\nnext sub-sections outline the functionality of framework in detail."
    }, {
      "heading" : "4.1 Translating PDDL to DeLP",
      "text" : "The PDDL (Planning Domain Description Langauge) is a standard language to describe real world planning domains [21]. Various tools such as GIPO [22] and itSIMPLE [23] provide graphical user interface to planning experts to model the real-world problems and export the plans in PDDL format so that they can be consumed by decision support tools and automated planners.\nA PDDL planning problem is described in two sections: domain definition and problem specification. The domain describes all the elements which characterize the domain for planning, i.e., object types, predicates, actions (by specifying their inputs, outputs, preconditions and effects), etc. The problem essentially describes initial and goal states, by specifying the set of predicates assumed to be true in the initial state and the set of predicates to be satisfied in the goal state.\nFigure 4 depicts the translation mapping from PDDL to DeLP constructs using PDDL-DeLP translator and algorithm 1 shows the entire process of the translation to DeLP constructs from PDDL in a higher level algorithm language. The first step is to download the trading partners PDDL files. During this process, the translator reads the PDDL files and saves certain information about the planning tasks such as file URL, owner/creator of planning tasks, download date etc., and saves the information in a database for their profiling. Once the download is complete, the next step is translation of PDDL files to DeLP rules and facts and save them in the knowledge base.\nIn the knowledge base, a planning task takes the following form: [rule identifier][rule body] [type of rule] [head].\nThe rule body represents the precondition and rule head represent the effects. There are two types of rules supported b the systems i.e., strict rule represented by solid arrow and defeasible rule represented by dotted arrow. During translation, a planning action (DeLP rule) that is in conflict with another planning action (DeLP rule) in the knowledge base is represented as defeasible rule while rest of the DeLP rules are represented as strict rules. Once the translation is complete, the CP-DSS also reads the relevant SQL data from CPFR and translate them into DeLP facts, stores them in the knowledge base.\nData: PDDL files {a,b,c} Result: DeLP Knowledge base Array trans []= {a, b, c} int i=0; foreach trans.length do\npddlfile[i].profiling(trans[i]); foreach action in pddlfile[i] do\nArray actions[] = readActions(action); foreach action in actions[i] do\nArray predicates=create(predicate); Array types=createtypes; Array constants=create(constants); Array delpRules=create(predicates,types,\nconstants, action[i]) end i++;\nend end i =0; CreateKnowledgeBase(delpRules);\nAlgorithm 1: Translation of PDDL file to DeLP knowledge base\nConsidering supplier chain scenario discussed in figure 2, the trading partner z downloads the trading partners PDDL files, translated and resulted into ψ as follows:\n10\n   [a.d1]shopper(X), product(Y ), not advancePyament(X, Y ) 99K∼ giveDiscount(X) [b.d2]shopper(X), purhcase(X, Y ), bulkOrder(X, Y ) 99K giveDiscount(X) [a.d3]eShop(Z), packaging(Y, Z) 99K gstFree(Y ) [c.d5]eShop(Z), not packaging(Y, Z) 99K∼ gstFree(Y ) [z.s2]gstFree(Y ), giveDiscount(X) → ordinaryDiscount(X) [z.s1]not gstFree(Y ), giveDiscount(X) → normalDiscount(X) [z.d7]shopper(X), normalDiscount(X) 99K platinumDiscount(X) [c.d8]shopper(X), normalDiscount(X), plansSlowToPay(X) 99K∼ platinumDiscount(X)   \n[a.d1] is rule identifier where ‘a’ represents the trading partner and ‘d1’ represents the rule identifier."
    }, {
      "heading" : "4.2 Hybrid reasoning for arguments construction",
      "text" : "and conflicts handling\nOnce the translation from PDDL to DeLP is complete then the next step is arguments construction. This step is further divided into the following two sub-steps: Firstly, compilation of DeLP rules as a Rete network; Secondly, data driven reasoning for arguments construction.\nIn the proposed framework, the general Rete network [24] has been extended to represent incomplete and/or contradictory information as Rete nodes in the network. The extensions made to one-input nodes are as follows:\n• AssertCondition: The one-input nodes have been extend to represent contradictory information by introduction strong negation i.e.∼ , as an attribute in the AssertCondition class.\n• NegativeConditionNAF: A new type of one-input node was introduced to indicate incomplete information represented by the symbol ‘not’.\nTo explain the compilation of DeLP rules in a Rete network, consider the rule base ψ outlined in section 4.1 and its subset of rules compilation represented in fig. 6 in the form of a Rete network. The predicates that make up the body of the planning rules such as bulkOrder(X,Y), shopper(X) etc are represented as one input node and the claim of the DeLP rules such as a.d1, b.d2 and a.d3 are depicted as terminal nodes. The nodes in between the one-input node and the terminal nodes are represented as two-input nodes.\nOnce the compilation of DeLP as a rete network is complete, the next step is to perform data-driven reasoning over underlying information in the knowledge base by passing the DeLP facts in the working memory through the Rete network. Data-driven reasoning is a forward chain reasoning that starts by the introduction of DeLP facts in the Rete network. This results in the activation and firing of the DeLP rules. The derived DeLP facts flow back into the Rete network which, in turn, results in the activation of new DeLP rules. This process continues until no more rule/s are activated. During this process, the activated DeLP rules are saved arguments in an arguments set. It is important to note here is that if the activated DeLP rules’ body represents some predicate starting with the symbol ‘not’, then before its firing, a query is sent to the DeLP server to compute its truthfulness by querying the knowledge base. If the query returns yes, then the DeLP rule is fired, otherwise the activated DeLP rule will be removed from the activated rule set. It is important to note here is that in current research rete network has been extended from the\nsingle rule execution strategy to execute all rules that are activated during data-driven reasoning. Taking into consideration the scenario depicted in figure 3, forward chain reasoning is used to digitize the planning tasks and make them alive for the planners as shown in the following illustration:\n   [a.d1]shopper(david), purchase(david, rawMaterial) 99K giveDiscount(david) [b.d2]shopper(david), notadvancePayment(david, rawMaterial) 99K∼ giveDiscount(david) [a.d3]shopper(david), purchase(david, rawMaterial), bulkOrder(david, rawMaterial) 99K giveDiscount(david). [c.d5]eShop(BigW ), not packaging(BigW, rawMaterial) 99K ∼ gstFree(rawMaterial) [z.s1]notgstFree(rawMaterial), giveDiscount(david) → normalDiscount(david) [z.d7]shopper(david), normalDiscount(david) 99K platinumDiscount(david) [c.d8]shopper(david), product(rawMaterial), havefeedback(rawMaterial, feedback), reviewRate(feedback, good) 99K purchase(david), rawMaterial)   \nIt is important to note here is that the DeLP rules are initiated with the domain knowledge defined in the descriptive model and the DeLP facts imported from CPFR. Once the arguments construction is complete, the next step is conflicts identification and their resolution using goal-driven reasoning. Conflicts identification and their resolution is a recursive process consisting of the following two steps:\n• Identification of an argument and its counter-argument. • Compute priority between conflicting arguments by\nbuilding and marking of dialectical trees as depicts in Algorithm 2.\n(Dialectical tree [18]) If an argumentA counter-argues argument B, and no static defeat exists, then we construct a dialectical tree for argument A to determine whether argument A defeats argument B or vice versa.\nLet A be an argument. A dialectical tree for argument A, is Σ(A, h) where h is claim(A), is recursively defined as follows:\n(1) A single node labeled with an argument (A, h) with no counter-argument is by itself a dialectical tree for (A, h). This node is also the root of the tree.\n(2) Suppose that Σ(A, h) is an argument with counterarguments (A1,h1), (A2,h2),.........,(An,hn), we construct the dialectical tree for (A, h), Σ(A, h) by labeling the root node\n11\nwith (A,h) and by making this node the parent of the root of dialectical trees for (A1,h1), (A2,h2),.........,(An,hn) i.e. Σ(A1, h1),Σ(A2, h2),........,Σ(An, hn).\n(Marking of dialectical tree [18] ):\n• Leaves of Σ(A, h) are U-nodes.\n• Let (B, q) be an inner node of Σ(A, h). Then (B, q) will be a U-node iff every child of (B, q) is a D-node. The node (B, q) will be a D-node if it has at least one U-node as a child.\nIf dialectical tree is marked as undefeated then this will trigger the process of meta-argumentation which is described in section 4.3. Once the hybrid reasoning is complete, the CP-DSS will display the reasoning results in a graphical format so that decision makers are able to better comprehend the results.\n(Reasoning Chain): An argument A supported by a chain of sub-arguments produces a reasoning chain λA= (A1, ......,An) for an argument A . The claim of supported argument A, is called a ‘result’ of the reasoning chain and the chain of sub-arguments is called a ‘support’ for the result of the reasoning chain and is define as follows: ∀r, s ∈ Args { if( s ξ r) then λ(r,j)= λ(r,,j)∪ s where ξ is used to represent sub-argument relationship and λ(r,j)is used to represent a reasoning chain with result j. Algorithm 3 outline the process of reasoning chains construction. To share the reasoning chain with other Semantic Web applications, the reasoning chains will be annotated with an argument interchange format (AIF)[25] and is shared with trading partners in RDF\\XML format.\nData: (A, h) Result: Σstatus(A, h) Let C← get all counter-arguments of (A, h); if C 6= ∅ then\nwhile there is no ΣU (Ai, hi) ∈ C do for every argument in C do\nLet (Ai, hi)← minimal non-labelled element BuildDialecticalTree((Ai, hi)) getting result as Σ(Ai, hi);\nPut Σ(Ai, hi) ξ (A, h) end if there exist some ΣU (Ai, hi) then\nSet ΣD(A, h); else\nSet ΣU (A, h); end\nend else\nΣ(A, h)= (A, h); Set Σ(A, h)← defeated;\nend Algorithm 2: Building and marking of Dialectical trees"
    }, {
      "heading" : "4.3 Interleaving planning and reasoning over conflicting preference using meta-argumentation",
      "text" : "Meta-argumentation is a deliberation dialogue that involves participants who share responsibility and collaborate on deciding what action or course of actions should be undertaken in a given situation [26]. In such dialogues, participants don’t have fixed positions at the start of the dialogue and the goal and need for action can originate from any of the various participants involved. During the course of action, however, participants may be involved in a persuasion dialogue which may motivate them to model a persuasion dialogue as embedded in a deliberation dialogue. In particular, the following tasks will be performed in this sub-aim:\nA plethora of work exists on building dialogue-based systems for software agents. This research focus on extending the work done by [27] using argumentation schemes [28]. During the process of argumentation, relationships between the arguments are linked with each other in a certain pattern to support the ultimate conclusion. Such linking patterns are called ‘argumentation schemes’ and allow reasoning to be performed using a set of premises and a conclusion. These argumentation schemes have emerged from informal logic [29]. The schemes help to categorize the way that arguments are built. They bridge the gap between logicbased application and human reasoning by capturing stereotypical patterns of human reasoning. An example is an argument from an expert opinion scheme. Formally, an argumentation scheme is composed of a set of premises Ai, a conclusion denoted as S, and a set of critical questions CQi is aimed at defeating the derivation of the consequent. In this research, arguments are built using argumentation schemes during meta-argumentation. The objective is two-fold, firstly; to enable planners to put forward their arguments that may be incomplete statements and offer them ways of advancing wellformed arguments as well as to reuse arguments that often\n12\nappear in discussions; secondly, with the help of algorithms, to compute the acceptability of arguments at any stage of the discussion.\nData: (A, h) Result: λ(A,h) Let S← get all sub-arguments of (A, h); if S 6= ∅ then\nforeach (Ai, hi) ∈ S do if noCounterArgument(Ai, hi) or ΣU (Ai, hi) then\nBuildReasoningChain((Ai, hi)) ; Put λ(Ai, hi) ξ (A, h);\nend end\nelse λ(A,h) = (A, h); end Algorithm 3: Construction of a reasoning chain\nThe deliberation dialogue system is defined by: 1. Topic Language: DeLP as a logical language. 2. Argumentation Logic: as defined in [15]. The only dif-\nference is that in our previous work it was assumed that the system has collated all the relevant information and reasoning engine reasoning over it. In this system, human planners are collaborating and conflict resolution process is a dialogue -driven activity. We reuse the definition of argument, sub-argument, attack, static defeat and dynamic defeat.\n3. Communication Language to define set of Locutions S and two binary relation Ra and Rs of attacking and surrendering reply on S. Dialogue moves and termination as defined in [27].\nTo answer the questions of a decision maker which may help him to understand the reasoning process (that is, to obtain an explanation on the conclusion achieved), CP-DSS provides a querying mechanism to query the knowledge base. A query ‘q’ consists of a predicate, and can be executed on the argument set ‘Args’ with the help of function executeQuery(q) to check the support for the predicate in the argument set and returns the dialectical tree. Taking into considering a supply chain scenario depicts in figure 3, the figure 7 depicts the two conflicting reasoning chains produced by hybrid reasoning engine that will call for meta-argumentation in order to proceed for an action."
    }, {
      "heading" : "4.4 Prototype development and future work",
      "text" : "The development of to address the requirements of different collaborative planning for pratical reasoning in supply chains is carried out with help Microsoft Visual Studio 20101, NRuler 2 whis is a fast production system library based on the RETE algorithm, written in C sharp. This library is extended for the development of the hybrid reasoning engine. QuickGraph 3 that provides generic directed/undirected graph data\n1http://www.microsoft.com/visualstudio/en-us 2http://nruler.codeplex.com/ 3http://quickgraph.codeplex.com/\nstructures and algorithms for .NET. It also supports Graphviz 4 to render the graphs. It is used to generate the graphical representation of the reasoning results produced by theCP-DSS and DeLP Server that is is an implementation of defeasible logic programming (DeLP). It is used as a back-end server for the development of the hybrid reasoning engine. MySQL 5 open source relational database for storing PDDL profiling information.\nIn future, CP-DSS will be extend with Information sharing and integration for proactive operational risk prediction. In a static environment, SC members may choose to share specific and efficient process linkages and information sharing/exchange mechanisms with selected partners. However, in a dynamic environment SC business partners need to develop more robust and reconfigurable digital linkages that can deal with changes in the business environment [30]. For example, a SC works as a network and when some event such as operational risk occurs, it is not the entire supply chain that needs to deal with this event. Once the semantic-annotated information is shared, it is used for proactive risk identification to reduce uncertainty. Uncertainty in this context is a lack of knowledge regarding the occurrence of an event in a SC to overcome operational risk. Using information for event detection requires the identification of the correlation between events and shared information among SC members. The idea is how to relate concepts to a certain event and predict the occurrence of the event using shared information."
    }, {
      "heading" : "1 Introduction",
      "text" : "Within the research field of argumentation in artificial intelligence (Bench-Capon and Dunne, 2007), abstract argumentation frameworks (AFs) as introduced by Dung (1995) have turned out to be a suitable modelling tool for various argumentation problems. This is partly due to their conceptional simplicity, being just a directed graph where nodes represent abstract arguments and edges represent conflicts between arguments. However, this comes also with limitations in terms of expressibility, which has led to the introduction of several enhancements of Dung’s AFs, incorporating support (Cayrol and Lagasquie-Schiex, 2005), preferences (Modgil, 2009), attacks on attacks (Baroni et al., 2011) and other concepts (see (Brewka et al., 2014) for an overview). One of the most recent and powerful generalizations of AFs constitute abstract dialectical frameworks (ADFs) (Brewka and Woltran, 2010; Brewka et al., 2013), where the relation between arguments is modelled via acceptance conditions for each argument (in the form of Boolean functions), capturing various forms of attack and support. This enhanced modelling capability of ADFs has been used for preferential reasoning (Brewka et al., 2013), judgment aggregation (Booth, 2015), and legal reasoning (Al-Abdulkarim et al., 2016).\n∗Supported by FWF through projects I1102, I2854, and P25521.\nArgumentation as such is a highly dynamic process. Therefore the evaluation of formalisms modelling argumentation problems is subject to constant changes in the model. As a consequence, there has been a tremendous amount of research on the dynamics of argumentation frameworks and in particular on the revision of Dung AFs (see e.g. (Falappa et al., 2011)) in the last years. The prominent AGM approach for belief change (Alchourrón et al., 1985; Katsuno and Mendelzon, 1991) was applied to AFs by Coste-Marquis et al. (2014), characterizing minimal change revision operators by so-called representation results. Diller et al. (2015) used recent insights on the expressiveness of AFs (Dunne et al., 2015) as well as on how to deal with fragments of classical logic in belief revision (Delgrande and Peppas, 2015) to characterize AGM revision operators which return a single AF instead of a set of such.\nIn this work we study such AGM revision operators for ADFs. We obtain representation theorems characterizing all operators satisfying an adapted version of the AGM postulates by rankings on interpretations. The main challenge is the fact that ADFs are not able to express arbitrary sets of interpretations under these semantics (supported models being an exception in this matter). Fortunately, the exact expressiveness of ADF-semantics has recently been established by Pührer (2015) and Strass (2015), who gave exact characterizations for realizability under three-valued and two-valued semantics, respectively. We will extend and employ these results which will result in a different characterization for each semantics. Most semantics evaluate ADFs based on threevalued interpretations, generalizing labelling-based semantics of AFs (Caminada and Gabbay, 2009). Therefore, to obtain concrete operators, we employ a distance measure for three-valued interpretations to define rankings.\nWe will focus on preferred and admissible semantics – preferred interpretations are defined as maximal admissible interpretations. For revision under preferred semantics we obtain a representation result by adjusting the conditions on rankings to the limited expressiveness of the semantics and adding an additional postulate inspired by (Delgrande and Peppas, 2015) preventing cycles. The approach is similar to revision of AFs (Diller et al., 2015), but deals with sets of three-valued interpretations instead of two-valued extensions. Moreover, will define a three-valued version of Dalal’s wellknown revision operator (Dalal, 1988). Admissible seman-\n15\ntics, on the other hand, yield only a single operator satisfying the postulates. Since, as we will argue, both approaches have some weaknesses, we propose a novel hybrid approach which bases rankings on preferred interpretations but allows admissible interpretations of the revising ADF to be the result of the revision.\nFinally, we informally discuss the representation of operators for the two-valued semantics, namely stable and supported models. Moreover, we argue that complete and grounded semantics cannot be captured by the AGM approach, i.e. there are no operators satisfying the postulates."
    }, {
      "heading" : "2 Background",
      "text" : "We assume a fixed finite set of statements A. An interpretation is a mapping v : A→ {t, f ,u} assigning one of the truth values true (t), false (f ) or unknown (u) to each statement. The set of statements to which v assigns a particular truth value x ∈ {t, f ,u} is denoted by vx. An interpretation is two-valued if vu = ∅, i.e. the truth value u is not assigned. Two-valued interpretations v can be extended to assign truth values v(ϕ) ∈ {t, f} to propositional formulas ϕ as usual.\nThe three truth values are partially ordered according to their information content: we have u <i t and u <i f and no other pair in <i, meaning that the classical truth values contain more information than the truth value unknown. As usual,≤i denotes the partial order associated to the strict partial order<i. The pair ({t, f ,u} ,≤i) forms a complete meetsemilattice with the information meet operation ui. This meet can intuitively be interpreted as consensus and assigns t ui t = t, f ui f = f , and returns u otherwise. The information ordering ≤i extends in a straightforward way to interpretations v1, v2 over A in that v1 ≤i v2 iff v1(a) ≤i v2(a) for all a ∈ A. We then say, for two interpretations v1, v2, that v2 extends v1 iff v1 ≤i v2. The set V of all interpretations over A forms a complete meet-semilattice with respect to the information ordering ≤i. The consensus meet operation ui of this semilattice is given by (v1 ui v2)(a) = v1(a) ui v2(a) for all a ∈ A. By V2 we denote the set of two-valued interpretations; they are the ≤i-maximal elements of the meetsemilattice (V,≤i). We denote by [v]2 the set of all twovalued interpretations that extend v.\nTwo interpretations v1 and v2 are compatible if vt1 ∩ vf2 = vf1 ∩ vt2 = ∅ and incompatible otherwise. A set of interpretations V ⊆ V is compatible if each pair v1, v2 ∈ V is compatible and incompatible otherwise; its adm-closure, cl(V ), contains exactly those v ∈ V such that ∀a ∈ (vt ∪ vf )∀v2 ∈ [v]2∃v′ ∈ V s.t. v′ ≤i v2 ∧ v′(a) = v(a). We will use cl(v1, v2) as shorthand for cl({v1, v2}).\nWe define the symmetric distance function 4 between truth values as follows: t4f = 1, t4u = f4u = 12 , and x4x = 0 for x ∈ {t, f ,u}. Lifted to interpretations v1, v2 ∈ V , it is defined as v14v2 = ∑ a∈A v1(a)4v2(a).\nFinally note that we will represent interpretations by sequences of truth values, assuming a total ordering on the underlying vocabulary. For instance the interpretation {a 7→ u, b 7→ t, c 7→ f} will be abbreviated by utf ."
    }, {
      "heading" : "2.1 Abstract Dialectical Frameworks",
      "text" : "An ADF F is a set of tuples 〈s, ϕs〉 where s ∈ A is a statement andϕs is a propositional formula overA, the acceptance condition of s. Note that this formalization syntactically differs from the original one (Brewka and Woltran, 2010), where an ADF is represented by a triple (A,L,C) where L is a set of links between statements and C a set of total functions 2A 7→ {t, f}. It is however easy to see that these two notions are equivalent, as the set of links L is implicitly given by the atoms occurring in the acceptance conditions and the fact that the total functions C can be expressed by propositional formulas. We denote the set of all ADFs by FA.\nThe semantics of ADFs can be defined via an operator ΓF over three-valued interpretations. Given an ADF F and an interpretation v, it is defined as\nΓF (v)(a) = l\nw∈[v]2 w(ϕa).\nIntuitively, the operator returns, for each statements a, the consensus truth value of the evaluation of the acceptance formula ϕa with each two-valued interpretation extending v. The semantics can now be defined as follows: Definition 1. Given an ADF F , an interpretation v is • admissible for F iff v ≤i ΓF (v), • complete for F iff v = ΓF (v), • preferred for F iff v is admissible for F and each v′ ∈ V\nwith v <i v′ is not admissible for F , • grounded for F iff v is complete for F and each v′ ∈ V\nwith v′ <i v is not complete for F , • a (supported) model of F iff v is two-valued and v =\nΓF (v), • a stable model of F iff v is a model of F and vt = wt, where w is the grounded interpretation of F v = {〈a, ϕa[x/⊥ : v(x) = f ]〉 | a ∈ vt}.\nWe denote the admissible, complete, preferred, and grounded interpretations for, and supported and stable models of an ADF F by ad(F ), co(F ), pr(F ), gr(F ), mo(F ), and st(F ), respectively. For alternative semantics we refer to (Strass, 2013; Polberg, 2014).\nThe semantics have been shown to be proper generalizations of AF-semantics (Brewka and Woltran, 2010; Brewka et al., 2013), with both supported and stable models generalizing stable semantics of AFs, differing only in the treatment of support cycles. Example 1. Consider the ADF F depicted in Figure 1. The admissible interpretations of F are as follows: ad(F ) = {uuuu, tfuu, tff f , tftt, ftuu, ftfu, ftf f ,uuff}. Further\n16\nobserve that co(F ) = ad(F ) \\ {ftuu, ftfu}, pr(F ) = {tff f , tftt, ftf f}, gr(F ) = {uuuu}, mo(F ) = pr(F ), and st(F ) = pr(F ) \\ {tftt}.\nA set of interpretations V is realizable under a semantics σ if there is an ADF F with σ(F ) = V . The following proposition recalls results which are either explicitly stated or immediate consequences of (Pührer, 2015) and (Strass, 2015). Proposition 1. A set of interpretations V is realizable under • ad iff V 6= ∅ and V = cl(V ); • pr iff V 6= ∅ and V is incompatible; • mo iff V ⊆ V2; • st iff V ⊆ V2 and vt1 6⊆ vt2, vt2 6⊆ vt1 for all v1, v2 ∈ V . For σ ∈ {ad, pr,mo, st} it holds that σ(F ) ∩ σ(G) is realizable under σ for arbitrary ADFs F and G, given that σ(F )∩σ(G) 6= ∅. This does not hold for co and gr in general. Definition 2. Given a semantics σ, the function fσ : 2V 7→ FA maps sets of interpretations to ADFs such that σ(fσ(V )) = V if V is realizable under σ and σ(fσ(V )) = u. . .u otherwise.\nNote that canonical constructions for fσ(V ) for realizable sets V can be found in (Pührer, 2015) and (Strass, 2015). Although fσ is not unique in general, it is assumed to be fixed for every σ throughout the paper. In particular, fσ(V ) = {〈a,¬a〉 | a ∈ A} for V not realizable under σ."
    }, {
      "heading" : "2.2 Belief Revision",
      "text" : "The most prominent approach to belief revision was introduced by Alchourrón et al. (1985) and reformulated for propositional formulas by Katsuno and Mendelzon (1991). They define an equivalent version of the AGM-postulates for operators ∗ mapping pairs of formulas to a revised formula. (R1) ψ ∗ µ |= µ. (R2) If ψ ∧ µ is satisfiable, then ψ ∗ µ = ψ ∧ µ. (R3) If µ is satisfiable, then ψ ∧ µ is also satisfiable. (R4) If ψ1 ≡ ψ2 and µ1 ≡ µ2, then ψ1 ∗ µ1 ≡ ψ2 ∗ µ2. (R5) (ψ ∗ µ) ∧ φ |= ψ ∗ (µ ∧ φ). (R6) If (ψ∗µ)∧φ is satisfiable, then ψ∗(µ∧φ) |= (ψ∗µ)∧φ.\nWhile postulates R1 to R4 are self-explanatory, note that R5 and R6 ensure that revision is performed with minimal change to the revised formula ψ.\nThe main result of (Katsuno and Mendelzon, 1991) is that there is a one-to-one correspondence between operators which are rational according to the AGM postulates and functions mapping each formula to a certain binary relation among interpretations. Thus, for constructing an AGM operator, a necessary and sufficient condition is the existence of such a function. Definition 3. A preorder on V is a reflexive, transitive binary relation on V . The preorder is • total if v1 v2 or v2 v1 for any v1, v2 ∈ V , • i-max-total if v1 v2 or v2 v1 for any v1, v2 ∈ V with v1 6≤i v2 and v2 6≤i v1.\nMoreover, for v1, v2 ∈ V , v1 ≺ v2 denotes the strict part of , i.e. v1 v2 and v2 6 v1. We write v1 ≈ v2 in case v1 v2 and v2 v1.\nGiven a preorder, the construction of the corresponding operator is then based on the following selection function:\nmin(V, ) = {v1 ∈ V | @v2 ∈ V : v2 ≺ v1}."
    }, {
      "heading" : "3 Revising ADFs",
      "text" : "In this section we apply the AGM approach to the revision of ADFs by studying operators ∗ : FA × FA 7→ FA. It is inspired by the approach by Diller et al. (2015) to revision of AFs. We begin by reformulating the postulates for our setting, parameterized by the used semantics.\n(A1σ) σ(F ∗G) ⊆ σ(G). (A2σ) If σ(F )∩ σ(G) 6= ∅, then σ(F ∗G) = σ(F ) ∩ σ(G). (A3σ) If σ(G) 6= ∅, then σ(F ∗G) 6= ∅. (A4σ) If σ(G) = σ(H), then σ(F ∗G) = σ(F ∗H). (A5σ) σ(F ∗G) ∩ σ(H) ⊆ σ(F ∗ fσ(σ(G) ∩ σ(H))). (A6σ) If σ(F ∗ G) ∩ σ(H) 6= ∅, then\nσ(F ∗ fσ(σ(G) ∩ σ(H))) ⊆ σ(F ∗G) ∩ σ(H). Next we define two types of rankings which will be the\ncounterpart to the postulates in the representation results.\nDefinition 4. Given a semantics σ and an ADF F , a preorder F is a (i-max-)faithful ranking for F if it is (i-max-)total and for all (incompatible) interpretations v1, v2 ∈ V it holds that (i) if v1, v2 ∈ σ(F ) then v1 ≈F v2, and\n(ii) if v1 ∈ σ(F ) and v2 /∈ σ(F ) then v1 ≺F v2. A function mapping each ADF to a (i-max-)faithful ranking is called (i-max-)faithful assignment."
    }, {
      "heading" : "3.1 Revision under Preferred Semantics",
      "text" : "In the remainder of this section we will focus on the preferred semantics. To fulfill the postulates, a revision operator will have to result in an ADF having certain preferred interpretations. However, as can be already seen by Proposition 1, preferred semantics (and all the others) underlie certain limits in terms of expressiveness. That is, certain desired outcomes may not be realizable. We first give sufficient conditions for realizability we will make use of in the following.\nProposition 2. A set of interpretations V ⊆ V is realizable under pr if one of the following holds:\n1. V ⊆ pr(F ) and V 6= ∅ for some F ∈ FA; 2. V = {v1, v2} and v1 and v2 are incompatible; or 3. V = {v}. The following example shows that the standard set of postulates is not enough to get a correspondence to preorders on interpretations.\nExample 2. Consider an arbitrary ADF F and the binary relation having pr(F ) as least elements, containing the cycle uft ≺ ttf ≺ fut ≺ tuf ≺ uft and being a linear order otherwise. Note that is not transitive and therefore\n17\nonly a pseudo-preorder. However, the revision operator ∗ induced by can be shown to satisfy all postulatesA1pr−A6pr. Moreover, every binary relation ′ inducing the same operator ∗ must contain this cycle. Consider the pair of interpretations uft and ttf . They are incompatible, hence realizable (cf. Proposition 1). Therefore the revision of F by fpr({uft, ttf}) must have uft as single preferred interpretation, hence uft ≺′ ttf . This holds for every neighboring pair of the cycle, hence ′ must contain the same cycle.\nThe following postulate, which is adapted from Delgrande and Peppas (2015), closes this gap. Note that it is redundant in classical AGM revision.\n(Acycσ) If for 1 ≤ i < n, σ(F ∗ Gi+1) ∩ σ(Gi) 6= ∅ and σ(F ∗G1) ∩ σ(Gn) 6= ∅ then σ(F ∗Gn) ∩ σ(G1) 6= ∅.\nWe are now ready to give our first representation result. Theorem 1. Let F be an ADF and F an i-max-faithful ranking for F . Define an operator ∗ : FA ×FA 7→ FA by\nF ∗G = fpr(min(pr(G), F )). Then ∗ satisfies postulates A1pr −A6pr and Acycpr. Proof. By definition of fpr and the fact that any non-empty V ⊆ pr(G) is realizable under pr (cf. Proposition 2.1) it holds that pr(fpr(min(pr(G), F ))) = min(pr(G), F ), hence pr(F ∗G) = min(pr(G), F ). Thus A1pr and A4pr follow.\nFor A2pr, assume pr(F ) ∩ pr(G) 6= ∅. Since F is imax-faithful and all v1, v2 ∈ pr(G) are pairwise incompatible we get that min(pr(G), F ) = pr(F ) ∩ pr(G) and hence pr(F ∗G) = pr(F ) ∩ pr(G).\nAs F is transitive (by being a preorder) and A is finite, min(pr(G), F ) 6= ∅, hence A3pr holds.\nFor A5pr and A6pr we consider the non-trivial case where pr(F ∗ G) ∩ pr(H) 6= ∅. Recalling that pr(F ) ∩ pr(G) is realizable under pr (cf. Proposition 1), we have to show that min (pr(G), F )∩pr(H) = min (pr(G) ∩ pr(H), F ). Towards a contradiction assume there is some v ∈ min(pr(G), F ) ∩ pr(H) such that v /∈ min(pr(G) ∩ pr(H), F ). As then v ∈ pr(G) and v ∈ pr(H) there must be some v′ ∈ pr(G) ∩ pr(H) with v′ ≺F v, contradicting v ∈ min(pr(G), F ). On the other hand assume, again to the contrary, that there is some v ∈ min(pr(G) ∩ pr(H), F ) such that v /∈ min(pr(G), F ) ∩ pr(H). From v ∈ pr(H) we get v /∈ min(pr(G), F ). As by assumption pr(F ∗ G) ∩ prf(H) 6= ∅, let v′ ∈ min(pr(G), F ) and v′ ∈ pr(H). Then also v′ ∈ pr(G) ∩ pr(H). Since v, v′ ∈ pr(H), v and v′ are incompatible, F is i-maxtotal and v ∈ min(pr(G) ∩ pr(H), F ) by assumption, we get v F v′. Thus v ∈ min(pr(G), F ) because v′ ∈ min(pr(G), F ), a contradiction.\nFor Acycpr consider a sequence of ADFs G1, . . . , Gn such that pr(F ∗ Gi+1) ∩ pr(Gi) 6= ∅ for 1 ≤ i < n and pr(F ∗ G1) ∩ pr(Gn) 6= ∅. Let 1 ≤ i < n. By definition of ∗ we have pr(fpr(min(pr(Gi+1), F ))) ∩ pr(Gi) 6= ∅. Then, by Proposition 2, min(pr(Gi+1), F ) ∩ pr(Gi) 6= ∅ follows. Hence there is some v′i ∈ pr(Gi) such that v′i F vi+1 for all vi+1 ∈ pr(Gi+1). From transitivity of F we infer that there is a v′1 ∈ pr(G1) such that v′1 F vn for all vn ∈ pr(Gn).\nFrom pr(F ∗G1) ∩ pr(Gn) 6= ∅ it follows that there is some v′′1 ∈ min(G1, F ) (hence also v′′1 ∈ pr(G1) and v′′1 F v′1) with v′′1 ∈ pr(Gn). We have v′′1 F v′1 F vn (for each vn ∈ pr(Gn)), hence v′′1 ∈ min(pr(Gn), F ). This together with v′′1 ∈ pr(G0) means that pr(F ∗ Gn) ∩ pr(G1) 6= ∅, which was to show.\nTheorem 2. Let ∗ : FA × FA 7→ FA be a revision operator satisfying postulatesA1pr−A6pr and Acycpr. Then there is an assignment mapping each ADF F to an i-max-faithful ranking such that pr(F ∗G) = min(pr(G), ) for every ADF G. Proof. Assume an arbitrary ADF F . We will define and show that it is an i-max-faithful ranking for F and that pr(F ∗ G) = min(pr(G), ).\nFirst let ′ be the relation on V such that for each v ∈ V , v ≈′ v, and for any incompatible interpretations v1, v2 ∈ V ,\nv1 ′ v2 ⇔ v1 ∈ pr(F ∗ fpr({v1, v2})). The relation is defined as the transitive closure of ′: v v′ ⇔ ∃w1, . . . , wn : v ′ w1 ′ · · · ′ wn ′ v′.\nFirst, is clearly reflexive and transitive, making it a preorder on V . Moreover, for incompatible interpretations v1, v2 ∈ V we know from Proposition 2.2 that {v1, v2} is realizable under pr, hence pr(fpr({v1, v2})) = {v1, v2}. By A1pr and A3pr we therefore get that either v1 ′ v2 or v2 ′ v1, and, consequently, also v1 v2 or v2 v1, hence is i-maxtotal.\nWe proceed by showing that is i-max-faithful. To show (i), let v1, v2 ∈ pr(F ) and note that pr(fpr({v1, v2})) = {v1, v2}. Hence, by A2pr, we get pr(F ∗ fpr({v1, v2})) = {v1, v2}. Therefore, by definition of , v1 v2 and v2 v1, i.e. v1 ≈ v2. For (ii), we begin with the intermediate statement\nfor v1 . . . vn ∈ V : v1 ′ · · · ′ vn ′ v1 ⇒ v1 ′ vn (1) For n ≤ 2 the statement is immediate. Assume n > 2. By definition of ′ we first get that vi and vi+1 for i ∈ {1, . . . , n − 1} as well as vn and v1 are incompatible, hence fpr({vi, vi+1}) = {vi, vi+1} and fpr({vn, v1}) = {vn, v1} by Proposition 2. Moreover, we get vi ∈ pr(F ∗ fpr({vi, vi+1})) for i ∈ {1, . . . , n − 1} and vn ∈ pr(F ∗ fpr({vn, v1})). It follows that v1 ∈ pr(F ∗ fpr({v1, v2})) ∩ {vn, v1}, vi ∈ pr(F ∗fpr({vi, vi+1}))∩{vi−1, vi} for i ∈ {2, . . . , n−1}, and vn ∈ pr(F ∗ fpr({vn, v1})) ∩ {vn−1, vn}. Considering Acyc we get pr(F ∗ fpr({vn, v1})) ∩ {v1, v2} 6= ∅, meaning further by A5pr and A6pr that pr(F ∗ fpr({vn, v1}))∩{v1, v2} = pr(F ∗ fpr({vn, v1} ∩ {v1, v2})) = pr(F ∗ fpr({v1})). By pr(fpr({v1})) = {v1} (cf. Proposition 2.3), A1pr and A3pr, we follow that v1 ∈ pr(F ∗ fpr({vn, v1})), meaning that v1 ′ vn, concluding the proof for (1). We proceed by showing the statement\nfor v1, v2 ∈ V : v1 ≺′ v2 ⇒ v1 ≺ v2 (2) v1 v2 is clear by definition. Assume, towards a contradiction, that v2 v1. Then ∃w1, . . . , wn such that v1 ′\n18\nw1 ′ · · · ′ wn ′ v2. As by assumption v1 ′ v2 we follow by (1) that v2 ′ v1, a contradiction to v1 ≺′ v2, showing (2). Now let v1 and v2 be incompatible interpretations such that v1 ∈ pr(F ) and v2 /∈ pr(F ). By A2pr we get pr(F ∗ fpr({v1, v2})) = pr(F ) ∩ {v1, v2} = {v1}, implying v1 ′ v2. Therefore, by (2), also v1 v2, showing (ii) and, consequently, that is i-max-faithful.\nBefore showing that ∗ is indeed simulated by , we prove for v1, v2 ∈ V s.t. v1 ′ v2, G ∈ FA : v1 ∈ pr(G) ∧ v2 ∈ pr(F ∗G)⇒ v1 ∈ pr(F ∗G) (3)\nLet G ∈ FA such that v1 ∈ pr(G) and v2 ∈ pr(F ∗ G). First note that, by ∗ fulfilling A1pr, v2 ∈ pr(G), meaning that v1 and v2 are incompatible and therefore pr(fpr({v1, v2})) = {v1, v2}. From A5pr and A6pr we then get that pr(F ∗ G) ∩ {v1, v2} = pr(F ∗ fpr(pr(G) ∩ {v1, v2})) = pr(F ∗ fpr({v1, v2})). By the assumption that v1 ′ v2 it holds that v1 ∈ pr(F ∗ fpr({v1, v2})), hence (3) follows. The last intermediate step is to show that\nfor G ∈ FA : min(pr(G), ) = min(pr(G), ′) (4) Consider some G ∈ FA. (⊆) Let v1 ∈ min(pr(G), ) and suppose there exists an v2 ∈ pr(G) with v2 ≺′ v1. This means, by (2), that also v2 v1, a contradiction. Hence v2 6≺′ v1 for all v2 ∈ pr(G), i.e. v1 ∈ min(pr(G), ′). (⊇) Let v1 ∈ min(pr(G), ′) and v2 ∈ pr(G). We show that v1 ′ v2, since then v1 v2 and, consequently, v1 ∈ min(pr(G), ) follows by definition of . If v1 = v2 we have v1 ′ v2 by definition of ′. If v1 6= v2 observe that, by v1, v2 ∈ pr(G), v1 and v2 are incompatible, hence at least one of v1 ′ v2 and v2 ′ v1 must hold. By v1 ∈ min(pr(G), ′) it cannot hold that v2 ≺′ v1, hence v1 ′ v2.\nWe are now ready to show that, for any ADF G, pr(F∗G) = min(pr(G), ). Considering (4) we just have to show that\nfor G ∈ FA : pr(F ∗G) = min(pr(G), ′) (5) (⊆) Let v ∈ pr(F ∗ G) and keep in mind that, by A1pr, also v ∈ pr(G). We show for each w ∈ pr(G) that v ′ w. Consider an arbitrary w ∈ pr(G). Note that by v, w ∈ pr(G) we have that pr(fpr({v, w})) = {v, w}. From A5pr and A6pr we get pr(F ∗G)∩ {v, w} = pr(F ∗ fpr(pr(G)∩ {v, w})) = pr(F ∗ fpr({v, w})). As by assumption v ∈ pr(F ∗ G) we get v ′ w by definition of ′. (⊇) Towards a contradiction, assume some v ∈ min(pr(G), ′) such that v /∈ pr(F ∗ G) (again note that also v ∈ pr(G) by A1pr). By A3pr and the fact that pr(G) 6= ∅ there is somew ∈ pr(F ∗G). From (3) we infer that v 6 ′ w. But the by assumption also w 6 ′ v. Since v and w must be incompatible by v, w ∈ pr(G) this means pr(F ∗ fpr({v, w})) ∩ {v, w} = ∅ and by ∗ fulfilling A1pr even pr(F ∗ fpr({v, w})) = ∅, a contradiction to ∗ satisfying A3pr.\nWith Theorems 1 and 2 we have obtained a one-to-one correspondence between i-max-faithful rankings and revision operators satisfying all postulates. In particular, we can use standard revision operators from the literature which work on faithful rankings (as each faithful ranking is also i-maxfaithful) to get concrete revision operators. To exemplify\nthe obtained result, we consider Dalal’s operator (1988), customized to the three-valued setting (using the same distance measure as, for instance, in (Arieli, 2008)): Definition 5. Given an ADF F and semantics σ, the ranking σF based on three-valued distance is defined as\nv1 σF v2 ⇔ min v∈σ(F ) (v4v1) ≤ min v∈σ(F ) (v4v2).\nfor each v1, v2 ∈ V . The operator ∗Dσ induced by σF returns F ∗Dσ G = fpr(min(σ(G), σF )) for each G ∈ FA.\nIt is easy to see that σF is i-max-faithful, as the minimal distance to σ(F ) is 0 for interpretations v ∈ σ(F ) and greater than 0 for interpretations v /∈ σ(F ). Hence, by Theorem 1, ∗Dσ satisfies all postulates. Example 3. Consider the ADF F = {〈a, a〉, 〈b, a〉, 〈c,¬a ∧ b〉}, having pr(F ) = {ttf , f f f}. First note that the minimal elements of prF coincide with pr(F ), i.e. ttf ≈ pr F f f f ≺prF others. Now consider the revision by the ADF G having pr(G) = {tft, ttu, f fu} and observe that ttu ≈prF f fu ≺prF tft (ttu and f fu have minimal distance to pr(F ) of 12 , while tft has 2). Therefore we get F ∗Dpr G = fpr({ttu, f fu}). On the other hand consider the ADF G′ = {〈a,>〉, 〈b,¬a〉, 〈c,¬b〉}, having pr(G′) = {tft}. The revision of F by G′ obviously results in an ADF also having tft – minimal distance 2 to pr(F ) – as only preferred interpretation. Inspecting the set of admissible interpretations of G′, which can be seen as reasonable (but not maximal) positions in the revising ADF, ad(G′) = {tft, tfu, tuu,uuu}, we observe that it contains elements which are closer to pr(F ) than tft. In particular, the interpretation tuu has distance 1 to pr(F ) and is even admissible in F ."
    }, {
      "heading" : "3.2 Revision under Admissible Semantics",
      "text" : "Example 3 suggests to take the admissible interpretations into account when revising with respect to the preferred interpretations. A quite radical step would be to just revise with respect to admissible interpretations instead. By the fact that ad(F1) ∩ ad(F2) 6= ∅ for all ADFs F1, F2 ∈ FA we get only one operator satisfying postulate A2ad and the following result immediately follows: Theorem 3. An operator ∗ : FA×FA 7→ FA fulfills A1ad− A6ad iff ∗ is defined as F ∗G = fad(ad(F ) ∩ ad(G)).\nIt is important to note that admissible semantics is closed under intersection (cf. Proposition 1), therefore fad(ad(F ) ∩ ad(G)) always realizes ad(F ) ∩ ad(G). Example 4. Again consider the ADFs F and G′ from Example 3 and note that ad(F ) = {ttf , f f f , ttu, tuf , f fu, tuu, fuu,uuu} and ad(G′) = {tft, tfu, tuu,uuu}. Moreover, let ∗ad be the operator from Theorem 3. As expected, we get F ∗ad G′ = fad({tuu,uuu}), i.e. the resulting ADF has tuu as single preferred interpretation, which was somehow seen as one of the more desired scenarios in Example 3.\nBut now consider the ADF G′′ having ad(G′′) = {utf ,uuu} and observe that F ∗ad G′′ = fad({uuu}). From the perspective of the preferred interpretations of F (being {ttf , f f f}) this might not be desired, as utf is admissible in G′′ and has a distance of only 12 to pr(F ), while the result of the revision has distance 32 .\n19"
    }, {
      "heading" : "3.3 Hybrid Approach",
      "text" : "Due to the problem illustrated in Example 4 we are interested in operators selecting out of the admissible interpretations of the revising ADF (in a sense accepting all reasonable positions as valid outcomes of the revision), but basing the amount of change on the preferred interpretations of the original ADF. To this end we reformulate the postulates to this setting:\n(P1) pr(F ? G) ⊆ ad(G). (P2) If pr(F )∩ad(G) 6= ∅, then pr(F?G) = pr(F )∩ad(G). (P3) If ad(G) 6= ∅, then pr(F ? G) 6= ∅. (P4) If ad(G) = ad(H), then pr(F ? G) = pr(F ? H).\n(P5) pr(F ? G) ∩ ad(H) ⊆ pr(F ? fad(ad(G) ∩ ad(H))). (P6) If pr(F ? G) ∩ ad(H) 6= ∅, then\npr(F ? fad(ad(G) ∩ ad(H))) ⊆ pr(F ? G) ∩ ad(H). (Acyc) If for 1 ≤ i < n, pr(F ∗ Gi+1) ∩ ad(Gi) 6= ∅ and\npr(F ∗G1)∩ad(Gn) 6= ∅ then pr(F ∗Gn)∩ad(G1) 6= ∅. As admissible semantics may give pairwise compatible interpretations, we will not restrict ourselves to i-max-faithful rankings for the representation result. However, we face another challenge, as illustrated in the following example.\nExample 5. Consider the ranking f f ≺ others ≺ tu ≈ ut ≺ tt ≺ uu and the ADFs F = {〈a,⊥〉, 〈b,⊥〉}, G = {〈a,>〉, 〈b,>〉}, and H = {〈a,¬a ∨ b〉, 〈b, a ∨ ¬b〉}. We have pr(F ) = {f f}, ad(G) = {uu,ut, tu, tt}, and ad(H) = {uu, tt}. It can be seen that is a faithful ranking for F . However, the revision operator ? induced by gives us F ? G = fpr({ut, tu}) and we further get • pr(F ? G) ∩ ad(H) = {uu}, but • pr(F ? fad(ad(G) ∩ ad(H))) = {tt}.\nTherefore ? violates P5. The problem is somehow hidden in the fact that ut and tu are compatible. That is, the set of interpretations {ut, tu} cannot be realized under preferred semantics, hence pr(fpr({ut, tu})) = {uu}.\nTo overcome this issue we introduce the concept of compliance, generalizing similar notions from (Delgrande et al., 2013; Delgrande and Peppas, 2015; Diller et al., 2015).\nDefinition 6. A preorder is σ-τ -compliant if, for every ADF F ∈ FA, min(τ(F ), ) is realizable under σ.\nIn general, this condition depends on the concrete capabilities in terms of realizability of σ and τ . Fortunately, we can capture pr-ad-compliance with conditions on the ranking.\nProposition 3. A preorder is pr-ad-compliant iff: if v1, v2 ∈ V are compatible and v1 ≈ v2 then ∃v3 ∈ cl(v1, v2) : v3 ≺ v1, v2.\nWe will make use of the following properties of the admclosure in the following results.\nLemma 1. For each V, V1, V2 ⊆ V and v, v′ ∈ V it holds: 1. cl(V ) = cl(cl(V )) (idempotence)\n2. V1 ⊆ V2 ⇒ cl(V1) ⊆ cl(V2) (monotonicity) 3. ∀v′′ ∈ cl(v, v′) : cl(v, v′′) ⊆ cl(v, v′).\nProof. Note that V ⊆ cl(V ) for any V ⊆ V is clear by definition. (1) cl(V ) ⊆ cl(cl(V )) follows from the initial observation. Assume there is some v ∈ cl(cl(V )) with v /∈ cl(V ). The latter means that ∃a ∈ (vt ∪ vf )∃v2 ∈ [v]2 s.t. @v′ ∈ V : v′ ≤i v2 ∧ v′(a) = v(a). Now for this particular a and v2 it holds, by v ∈ cl(cl(V )), that ∃w ∈ cl(V ) : w ≤i v2∧w(a) = v(a). Hence ∃w′ ∈ V : w′ ≤i v2 ∧ w′(a) = w(a). We have w′(a) = w(a) = v(a), a contradiction. (2) Let v ∈ cl(V1) and consider some a ∈ vt ∪ vf and v2 ∈ [v]2. There is some v′ ∈ V1 s.t. v′ ≤i v2 and v(a) = v′(a). As V1 ⊆ V2 by assumption, also v ∈ V2, hence v ∈ cl(V2). (3) Consider some v′′ ∈ cl(v, v′), i.e. ∀a ∈ v′′t ∪ v′′f∀v2 ∈ [v′′]2(v ≤i v2∧v(a) = v′′(a))∨ (v′ ≤i v2∧v′(a) = v′′(a)). Assume there is some w ∈ cl(v, v′′) and w /∈ cl(v, v′). The latter means that ∃a ∈ wt ∪ wf∃w2 ∈ [w]2 s.t. ¬(v ≤i w2 ∧ v(a) = w(a)) ∧ ¬(v′ ≤i w2 ∧ v′(a) = w(a)). Hence, by w ∈ cl(v, v′′), we get for this particular a and w2 that v′′ ≤i w2 and v′′(a) = w(a). From a ∈ wt ∪wf and v′′(a) = w(a) it follows that a ∈ v′′t ∪ v′′f and from v′′ ≤i w2 we get w2 ∈ [v′′]2. Therefore, from v′′ ∈ cl(v, v′) and ¬(v′ ≤i w2 ∧ v′(a) = w(a)), we get v ≤i w2 and v(a) = v′′(a) and, consequently, v(a) = w(a), a contradiction.\nWe now show the representation result for our hybrid operators which work on the admissible interpretations of the revising ADF but basing the distance measure on the preferred interpretations of the original ADF. The first direction follows similar to Theorem 1 with the help of pr-ad-compliance. Theorem 4. Let F be an ADF and F a pr-ad-compliant, faithful ranking for F . Define operator ? : FA × FA 7→ FA by F ?G = fpr(min(ad(G), F )). Then ? satisfies postulates P1− P6 and Acyc. Theorem 5. Let ? be a revision operator satisfying P1−P6 and Acyc. Then there is an assignment mapping each ADF F to a faithful ranking for F that is pr-ad-compliant and pr(F ? G) = min(ad(G), ) for every ADF G. Proof. Given a revision operator ? satisfying P1 − P6 and Acyc, let F be an arbitrary ADF. We will gradually define the ranking and show that it is faithful and pr-ad-compliant and it indeed simulates ?. First, we define ′ as\nv1 ′ v2 ⇔ v1 ∈ pr(F ? fad(cl(v1, v2))) for each v1, v2 ∈ V . Note that ′ is reflexive, but neither transitive nor total. This is because there might be interpretations v1, v2 ∈ V for which pr(F ? fad(cl(v1, v2))) ∩ {v1, v2} = ∅ due to cl(v1, v2) ⊃ {v1, v2}. After showing three properties of ′ we will extend it first to the transitive t and then to the desired ranking .\nfor v1, v2 ∈ V s.t. v1 ′ v2, G ∈ FA : v1 ∈ ad(G) ∧ v2 ∈ pr(F ? G)⇒ v1 ∈ pr(F ? G) (6)\nLet G ∈ FA, v1 ∈ ad(G), v2 ∈ pr(F ? G) with v1 ′ v2. First, we get v2 ∈ ad(G) from P1. Moreover, from P5 and P6 we get pr(F ? G) ∩ cl(v1, v2) = pr(F ? fad(ad(G) ∩ cl(v1, v2)). As both v1, v2 ∈ ad(G) we get that cl(v1, v2) ⊆ ad(G) from Lemma 1.2, hence pr(F ? G) ∩ cl(v1, v2) = pr(F ?fad(cl(v1, v2)). Now as v1 ′ v2 by assumption it must hold that v1 ∈ pr(F ? fad(v1, v2)), hence v1 ∈ pr(F ? G).\n20\nWe proceed with\nfor G ∈ FA : min(ad(G), ′) = pr(F ? G) (7) (⊆): To the contrary, assume some v1 ∈ min(ad(G), ′) with v1 /∈ pr(F ? G). From P3 we know pr(F ? G) 6= ∅, so assume an arbitrary v2 ∈ pr(F ?G). From (6) we follow that v1 6 ′ v2 and, consequently, from v1 ∈ min(ad(G, ′) also v2 6 ′ v1. By the definition of ′ and considering P3 there must then be some v3 ∈ pr(F ? fad(cl(v1, v2))). From P1 it follows that v3 ∈ fad(cl(v1, v2)), i.e. v3 ∈ cl(v1, v2). Then from P5 and P6 we get pr(F ? fad(cl(v1, v2)))∩ cl(v1, v3) = pr(F?fad(cl(v1, v2)∩cl(v1, v3))). From Lemma 1.3 it follows that cl(v1, v3) ⊆ cl(v1, v2), hence pr(F ? fad(cl(v1, v2))) ∩ cl(v1, v3) = pr(F ? fad(cl(v1, v3))). Therefore v1 /∈ pr(F ? fad(cl(v1, v3))) and v3 ∈ pr(F ? fad(cl(v1, v3))), hence v3 ≺′ v1. Finally, note that cl(v1, v2) ⊆ ad(G), hence v3 ∈ ad(G) contradicting v1 ∈ min(ad(G, ′). (⊇): Let v1 ∈ pr(F ? G) and consider an arbitrary v2 ∈ ad(G). Observing v1 ∈ ad(G) by P1 we get pr(F ? G) ∩ cl(v1, v2) = pr(F ? fad(ad(G) ∩ cl(v1, v2))) by P5 and P6. Moreover, cl(v1, v2) ⊆ ad(G) by Lemma 1.2, hence pr(F ? G) ∩ cl(v1, v2) = pr(F ? fad(cl(v1, v2))) and, consequently, v1 ∈ pr(F ? fad(cl(v1, v2))), meaning v1 ′ v2. Therefore, recalling that v2 was chosen arbitrarily, v1 ∈ min(ad(G), ′).\nThe following can be shown similarly as (1).\nfor v1, . . . , vn ∈ V : v1 ′ · · · ′ vn ′ v1 ⇒ v1 ′ vn (8) Now we define t to be the transitive closure of ′. As a\nconsequence of (8) we infer\nfor v1, v2 ∈ V : v1 ≺′ v2 ⇒ v1 ≺t v2 (9) Defining, for any set of interpretations V , max(V, t) as the set {v1 ∈ V | @v2 ∈ V : v1 ≺t v2} we get, by (8) and the fact that V is finite, that\nfor V ⊆ V : V 6= ∅ ⇒ max(V, t) 6= ∅ (10) We are now ready to define . To this end consider the\nsequence of sets of interpretations V0, V1, . . . defined as\nV0 = max(V, t), V1 = max ( V \\ V0, t ) , Vi = max(V \\ ⋃\n0≤j<i Vj , t) for i > 1.\nSince V is finite we conclude from (10) that the sequence will reach the empty set of interpretations at some point and each of the following elements will also be empty. The sequence V1, . . . , Vm of non-empty sets of interpretation then forms a partition of V . Based on this we define as\nv1 v2 ⇔ ∃Vi, Vj s.t. v1 ∈ Vi, v2 ∈ Vj , i ≥ j for each v1, v2 ∈ V . It is easy to see that is total, reflexive, and transitive. Its minimal elements coincide with ′:\nfor G ∈ FA : min(ad(G), ) = min(ad(G), ′) (11) Let Vk be the last set in the sequence V0, . . . , Vm such that Vk ∩ ad(G) 6= ∅. By definition of , min(ad(G), ) = Vk ∩ ad(G). Hence we have to show that Vk ∩ ad(G) =\nmin(ad(G), ′). (⊆): Assume there is some v ∈ Vk ∩ ad(G) such that v /∈ min(ad(G), ′). From the latter it follows that ∃v0 ∈ ad(G) : v0 ≺′ v. From (9) we get v0 ≺t v, hence v0 /∈ max(Vk, t). As Vk is the last set with Vk ∩ ad(G) 6= ∅ it must hold that v0 ∈ Vj with j < k, i.e. v0 ∈ max(V \\ ⋃ 0≤i<j Vi, t). Therefore, recalling\nv0 ≺t v, v /∈ V \\ ⋃\n0≤i<j Vi, contradicting v ∈ Vk and j < k. (⊇): Assume there is some v0 ∈ min(ad(G), ′) such that v0 /∈ Vk ∩ ad(G). That means v0 ∈ ad(G) and v0 /∈ Vk and further that v0 ∈ Vj for j < k. Now let v1 ∈ Vk ∩ ad(G). As j < k hence v1 ∈ V \\ ⋃ 0≤i<j Vi. Since v0 is maximal wrt. t in this set, v0 6≺t v1 and further by (9) v0 6≺′ v1. It holds that v0 ∈ pr(F ? fad(cl(v0, v1))) and therefore v0 ′ v1 though. We show this by assuming, towards a contradiction, that v0 /∈ pr(F ? fad(cl(v0, v1))). Hence v0 6 ′ v1. As v0 ∈ min(ad(G), ′) by assumption, then also v1 6 ′ v0. By P3 there has to be some v2 ∈ pr(F ? fad(cl(v0, v1))). As also v2 ∈ cl(v0, v2) we get by P5 and P6 that v2 ∈ pr(F ? fad(cl(v0, v1)∩cl(v0, v2))). From Lemma 1.2 we infer that cl(v0, v2) ⊆ cl(v0, v1), hence v2 ∈ pr(F ? fad(v0, v2)), meaning that v2 ′ v0. Moreover, v0 /∈ pr(F ? fad(v0, v2)), hence even v2 ≺′ v0. As v2 ∈ ad(G) from v0, v1 ∈ ad(G) and cl(v0, v1) ⊆ cl(ad(G)) = ad(G), we get a contradiction to v0 ∈ min(ad(G), ′). Now consider an arbitrary v3 ∈ V \\ ⋃ 0≤i<j Vi such that v1 t v3. From v0 ′ v1 t v3\nwe get v0 t v3. But since v0 ∈ max(V \\ ⋃\n0≤i<j Vi, t) it must also hold that v3 t v0, meaning, together with v0 ′ v1, that v3 t v1. As v3 was chosen arbitrarily we have that v1 ∈ max(V \\ ⋃ 0≤i<j Vi, t), i.e. v1 ∈ Vj , a contradiction to v1 ∈ Vk and j < k. The fact that indeed simulates ? is now obtained from (7) and (11): We get that pr(F ? G) = min(ad(G), ) for each ADF G. This also makes pr-ad-compliant. To show that is faithful for F assume pr(F ) 6= ∅ (otherwise faithfulness is trivial). By P2 it holds that pr(F ? fad(V)) = pr(F ), hence pr(F ) = min(V, ), meaning that (i) v1 ≈ v2 for v1, v2 ∈ pr(F ) and (ii) v1 ≺ v2 for v1 ∈ pr(F ) and v2 /∈ pr(F ).\nWith the insights from Theorems 4 and 5 we obtain concrete operators from faithful and pr-ad-compliant rankings. For instance, a valid operator is induced from the ranking F where pr(F ) are the minimal elements and all other interpretations form a ≺F -chain. The three-valued version of Dalal’s operator (cf. Definition 5) is not directly applicable here, as prF does not yield a pr-ad-compliant ranking for every ADF: Example 6. Consider the ADF F = {〈a, a ∧ b〉, 〈b, a ∧ b〉} having pr(F ) = {tt, f f}. It yields the ranking tt ≈prF f f ≺ pr F tu ≈prF ut ≈ pr F uf ≈ pr F fu ≺ pr F tf ≈ pr F ft ≈ pr F uu. Now consider the compatible interpretations tu and uf and observe that all v ∈ cl(tu,uf) = {uu, tu,ut, tf} have v 6≺prF tu,uf . Therefore, according to Proposition 3, pr F is not pr-ad-compliant. In practice, this means that F ∗Dpr G, where ad(G) = {uu, tu,uf , tf}, would yield fpr({tu,uf}); but as {tu,uf} is not realizable under pr we do net get the preferred interpretations prescribed by the postulates.\nA refinement of the distance measure in order to result in pr-ad-compliant rankings is subject to future work.\n21"
    }, {
      "heading" : "4 Discussion",
      "text" : "Summary. We have characterized operators for the revision of ADFs under preferred semantics. Using recent insights on realizability we showed that rankings giving rise to concrete operators underlie milder conditions than in classical AGM revision (i-max-faithful versus faithful). We have exemplified these results by a three-valued version of Dalal’s operator. While admissible semantics yield a single rational operator, we have proposed an alternative family of revision operators combining admissible and preferred semantics. Their representation by rankings is based on pr-ad-compliance. Other semantics. First consider complete semantics and recall that there might be ADFs F and G such that their common complete interpretations might not be realizable under complete semantics. Therefore, when revising F by G, it is impossible to satisfy A2co since it would require the resulting ADF to have exactly co(F ) ∩ co(G) as complete interpretations. The same applies to grounded semantics. Therefore it holds that for σ ∈ {co, gr} there is no operator ∗ : FA ×FA 7→ FA satisfying A1σ −A6σ .\nFor supported models, on the other hand, we observe that they have the same expressiveness as propositional logic, therefore results from classical AGM revision carry over.\nFinally, stable models have similar sufficient conditions for realizability as preferred semantics, namely that a set of interpretations V is realizable if (1) V ⊆ st(F ) for some F ∈ FA, (2) V = {v1, v2} for v1, v2 ∈ V2 with vt1 and vt2 being ⊆- incomparable, or (3) V = {v} with v ∈ V2. Therefore we expect to get similar representation results as for preferred semantics, just with slightly different conditions on the ranking. Future work. While in this work we only dealt with the semantic outcome of operators, we also plan to study syntactic aspects of revision. Moreover, we want to study the computational complexity of Dalal’s operator under preferred semantics, given that the complexity of reasoning tasks in ADFs is studied comprehensively (Strass and Wallner, 2015; Gaggl et al., 2015). Finally, we want to see how gained insights carry over to the revision of AFs: operators combining preferred and admissible semantics as well as revision under three-valued semantics (Caminada and Gabbay, 2009)."
    } ],
    "references" : [ {
      "title" : "A theory of practical reasoning",
      "author" : [ "R. Audi" ],
      "venue" : "American Philosophical Quarterly, vol. 19, no. 1, pp. 25–39, 1982.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "Systems of engagement and the future of enterprise IT-a sea change in enterprise IT",
      "author" : [ "G. Moore" ],
      "venue" : "Association for Information and Image Managment, Silver Spring, 2011.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "The economic significance of the Australian Logistics Industry",
      "author" : [ "A.L. Council" ],
      "venue" : "tech. rep., Australian http://www.graphviz.org/ http://www.mysql.com/ 13  Logistics Council, http://austlogistics.com.au/wpcontent/uploads/2014/07/Economic-Significance-ofthe-Australian-Logistics-Indsutry-FINAL.pdf, 2014.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "The extended enterprise: a decade later",
      "author" : [ "R. Spekman", "E.W. Davis" ],
      "venue" : "International Journal of Physical Distribution & Logistics Management, vol. 46, no. 1, pp. 43– 61, 2016.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Conjoint mining of data and content with applications in business, bio-medicine, transport logistics and electrical power systems",
      "author" : [ "T.S. Dillon", "Y.-P.P. Chen", "E. Chang", "M. Mohania" ],
      "venue" : "Artificial Intelligence Applications and Innovations, 2014.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "A supply chain network equilibrium model for operational and opportunism risk mitigation",
      "author" : [ "Y. Daultani", "S. Kumar", "O.S. Vaidya", "M.K. Tiwari" ],
      "venue" : "International Journal of Production Research, vol. 53, no. 18, pp. 5685–5715, 2015.",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "The actor’s view of automated planning and acting: A position paper",
      "author" : [ "M. Ghallab", "D. Nau", "P. Traverso" ],
      "venue" : "AI, vol. 208, no. 0, pp. 1–17, 2014.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "The value of CPFR",
      "author" : [ "Y. Sheffi" ],
      "venue" : "Proceedings of the Fourth International Congress on Logistics Research, IMRL, Lisbon, Portugal, 2002.",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Collaborative demand forecasting: Toward the design of an exception-based forecasting mechanism",
      "author" : [ "Y. Dong", "X. Huang", "K.K. Sinha", "K. Xu" ],
      "venue" : "Journal of Management Information Systems, vol. 31, no. 2, pp. 245–284, 2014.",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Collaborative planning in supply chains: a negotiation-based approach, vol. 533",
      "author" : [ "G. Dudek" ],
      "venue" : "Springer Science & Business Media,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2013
    }, {
      "title" : "Enterprise resource planning: Implementation procedures and critical success factors",
      "author" : [ "E.J. Umble", "R.R. Haft", "M.M. Umble" ],
      "venue" : "European journal of Operational Research, vol. 146, no. 2, pp. 241–257, 2003.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "An approach to multi-agent planning with incomplete information",
      "author" : [ "A. Torreño", "E. Onaindia", "Ó. Sapena" ],
      "venue" : "ECAI, pp. 762–767, 2012.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Dialogue understanding in a logic of action and belief",
      "author" : [ "A. Gabaldon", "P. Langley" ],
      "venue" : "Twenty-Ninth AAAI Conference on Artificial Intelligence, 2015.",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "A defeasible logic programming-based framework to support argumentation in Semantic Web applications",
      "author" : [ "N.K. Janjua" ],
      "venue" : "Springer Science & Business Media,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2014
    }, {
      "title" : "Web@ IDSSargumentation-enabled web-based IDSS for reasoning over incomplete and conflicting information",
      "author" : [ "N.K. Janjua", "F.K. Hussain" ],
      "venue" : "Knowledge-Based Systems, vol. 32, pp. 9–27, 2012.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Improving coalition planning by making plans alive",
      "author" : [ "J. Patel", "M. Dorneich" ],
      "venue" : "Intelligent Systems, IEEE, vol. 28, pp. 17–25, Jan 2013.",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Integrating the supply chain 25 years on",
      "author" : [ "G.C. Stevens", "M. Johnson" ],
      "venue" : "International Journal of Physical  Distribution & Logistics Management, vol. 46, no. 1, pp. 19–42, 2016.",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Defeasible logic programming: an argumentative approach",
      "author" : [ "A.J. Garcia", "G.R. Simari" ],
      "venue" : "Theory and Practice of Logic Programming, vol. 4, no. 1+2, pp. 95– 138, 2004.",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Philosophical and logic-based argumentation-driven reasoning approaches and their realization on the WWW: A survey",
      "author" : [ "N.K. Janjua", "O.K. Hussain", "F.K. Hussain", "E. Chang" ],
      "venue" : "The Computer Journal, vol. 58, no. 9, pp. 1967–1999, 2015.",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 1967
    }, {
      "title" : "Web@idss @ argumentation-enabled web-based idss for reasoning over incomplete and conflicting information",
      "author" : [ "N.K. Janjua", "F.K. Hussain" ],
      "venue" : "Knowledge-Based Systems, no. 0, pp. –, 2011.",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Pddlthe planning domain definition language",
      "author" : [ "D. McDermott", "M. Ghallab", "A. Howe", "C. Knoblock", "A. Ram", "M. Veloso", "D. Weld", "D. Wilkins" ],
      "venue" : "Tech Report CVC TR-98-003/DCS TR-1165, 1998.",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Planning domain definition using gipo",
      "author" : [ "R.M. Simpson", "D.E. Kitchin", "T. McCluskey" ],
      "venue" : "The Knowledge Engineering Review, vol. 22, no. 02, pp. 117–134, 2007.",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "From requirements and analysis to pddl in itsimple3. 0",
      "author" : [ "T.S. Vaquero", "J.R. Silva", "M. Ferreira", "F. Tonidandel", "J.C. Beck" ],
      "venue" : "Proceedings of the Third International Competition on Knowledge Engineering for Planning and Scheduling, ICAPS 2009, pp. 54–61, 2009.",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Rete: A fast algorithm for the many pattern/many object pattern match problem",
      "author" : [ "C.L. Forgy" ],
      "venue" : "Artificial Intelligence, vol. 19, no. 1, pp. 17–37, 1982.",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "The argument interchange format",
      "author" : [ "I. Rahwan", "C. Reed" ],
      "venue" : "Argumentation in Artificial Intelligence (I. Rahwan and G. R. Simari, eds.), ch. 19, pp. 383–402, Springer, 2009.",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Commitment in dialogue: Basic concepts of interpersonal reasoning",
      "author" : [ "D.N. Walton", "E.C. Krabbe" ],
      "venue" : "State University of New York Press, vol. 35, 1995.",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "A formal argumentation framework for deliberation dialogues",
      "author" : [ "E.M. Kok", "J.-J.C. Meyer", "H. Prakken", "G.A. Vreeswijk" ],
      "venue" : "Argumentation in Multi-Agent Systems, pp. 31–48, Springer, 2011.",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Semantic information and knowledge integration through argumentative reasoning to support intelligent decision making",
      "author" : [ "N.K. Janjua", "F.K. Hussain", "O.K. Hussain" ],
      "venue" : "Information Systems Frontiers, vol. 15, no. 2, pp. 167–192, 2013.",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Advances in the theory of argumentation schemes and critical questions",
      "author" : [ "D.J. Godden", "D. Walton" ],
      "venue" : "Informal Logic, vol. 27, pp. 267–292, 2007.",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2007
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "An argument is a reason or justification of a claim. It has an intrinsic strength and may be attacked by other arguments. Hence, the evaluation of its overall strength is mandatory. Such an evaluation is done by acceptability semantics. In this talk, we provide the foundations of a semantics, i.e., key concepts and principles on which an evaluation is based. Each concept (principle) is described by an axiom. We then present two families of semantics: extension semantics and ranking semantics. We analyze them against the axioms shedding thus light on the assumptions and choices they made. The analysis allows also a clear comparison between semantics of the same family, and between extension semantics and ranking ones.",
    "creator" : "LaTeX + confproc v0.7"
  }
}