{
  "name" : "1405.3637.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Vicious Circle Principle and Logic Programs with Aggregates",
    "authors" : [ "Michael Gelfond", "Yuanlin Zhang" ],
    "emails" : [ "y.zhang}@ttu.edu)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 5.\n36 37\nv2 [\ncs .A\nI] 1\nKEYWORDS: Aggregates, Answer Set Programming"
    }, {
      "heading" : "1 Introduction",
      "text" : "The development of answer set semantics for logic programs (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) led to the creation of powerful knowledge representation language, Answer Set Prolog (ASP), capable of representing recursive definitions, defaults, effects of actions and other important phenomena of natural language. The design of algorithms for computing answer sets and their efficient implementations in systems called ASP solvers (Niemela et al. 2002; Leone et al. 2006; Gebser et al. 2007) allowed the language to become a powerful tool for building non-trivial knowledge intensive applications (Brewka et al. 2011; Erdem et al. 2012). There are a number of extensions of the ASP which also contributed to this success. This paper is about one such extension – logic programs with aggregates. By aggregates we mean functions defined on sets of objects of the domain. (For simplicity of exposition we limit our attention to aggregates defined on finite sets.) Here is a typical example.\nExample 1 (Classes That Need Teaching Assistants) Suppose that we have a complete list of students enrolled in a class c that is represented by the following collection of atoms:\nenrolled(c,mike).\nenrolled(c,john).\n...\nSuppose also that we would like to define a new relation need ta(C) that holds iff the class C needs a teaching assistant. In this particular school need ta(C) is true iff the number of students enrolled in the class is greater than 20. The definition can be given by a simple rule in the language of logic programs with aggregates:\nneed ta(C)← card{X : enrolled(C,X)}> 20\nwhere card stands for the cardinality function. Let us call the resulting program P0.\nThe program is simple, has a clear intuitive meaning, and can be run on some of the existing ASP solvers. However, the situation is more complex than that. Unfortunately, currently there is no the language of logic programs with aggregates. Instead there is a comparatively large collection of such languages with different syntax and, even more importantly, different semantics (Pelov et al. 2007; Niemela et al. 2002; Son and Pontelli 2007; Faber et al. 2011; Gelfond 2002; Kemp and Stuckey 1991). As an illustration consider the following example:\nExample 2\nLet P1 consist of the following rule:\np(a)← card{X : p(X)}= 1.\nEven for this seemingly simple program, there are different opinions about its meaning. According to (Faber et al. 2011) the program has one answer set A = { }; according to (Gelfond 2002; Kemp and Stuckey 1991) it has two answer sets: A1 = { } and A2 = {p(a)}.\nIn our judgment this and other similar “clashes of intuition” cause a serious impediment to the use of aggregates for knowledge representation and reasoning. In this paper we aim at addressing this problem by suggesting yet another logic programming language with aggregates, called A log, which is based on the following design principles:\n• the language should have a simple syntax and intuitive semantics based on understandable informal principles, and\n• the informal semantics should have clear and elegant mathematics associated with it.\nIn our opinion existing extensions of ASP by aggregates often do not have clear intuitive principles underlying the semantics of the new constructs. Moreover, some of these languages violate such original foundational principles of ASP as the rationality principle. The problem is compounded by the fact that some of the semantics of aggregates use rather non-trivial mathematical constructions which makes it difficult to understand and explain their intuitive meaning.\nThe semantics of A log is based on Vicious Circle Principle (VCP): no object or property can be introduced by the definition referring to the totality of objects satisfying this property. According to Feferman (Feferman 2002) the principle was first formulated by Poincare (Poincare 1906) in his analysis of paradoxes of set theory. Similar ideas were already successfully used in a collection of logic programming definitions of stratification including that of stratified aggregates (see, for instance, (Faber et al. 2011). Unfortunately, limiting the language to stratified aggregates eliminates some of the useful forms of circles (see Example 9 below). In this paper we give a new form of VCP which goes beyond stratification: p(a) cannot be introduced by the definition referring to a set of objects satisfying p if this set can contain a. Technically, the principle is incorporated in our new definition of answer set (which coincides with the original definition for programs without aggregates). The definition is short and simple. We hope that, combined with a number of informal examples, it will be sufficient for developing an intuition necessary for the use of the language. The paper is organized as follows. In Section 2, we define the syntax and semantics of A log. We give some properties of A log programs in Section 3 and present an algorithm for computing an answer set of an A log program in Section 4. A comparison with the existing work is done in Section 5, and we conclude the paper in Section 6.\n2 Syntax and Semantics of A log\nWe start with defining the syntax and intuitive semantics of the language."
    }, {
      "heading" : "2.1 Syntax",
      "text" : "Let Σ be a (possibly sorted) signature with a finite collection of predicate, function, and object constants and A be a finite collection of symbols used to denote functions from finite sets of terms of Σ into integers. Terms and literals over signature Σ are defined as usual and referred to as regular. Regular terms are called ground if they contain no variables and no occurrences of symbols for arithmetic functions. Similarly for literals. An aggregate term is an expression of the form\nf{X̄ : cond} (1)\nwhere f ∈ A , cond is a collection of regular literals, and X̄ is a list of variables occurring in cond. We refer to an expression\n{X̄ : cond} (2)\nas a set name. An occurrence of a variable from X̄ in (2) is called bound within (2). If the condition from (2) contains no variables except those in X̄ then it is read as the set of all objects of the program satisfying cond. If cond contains other variables, say Ȳ = 〈Y1, . . . ,Yn〉, then {X̄ : cond} defines the function mapping possible values c̄ = 〈c1, . . . ,cn〉 of these variables into sets {X̄ : cond|Ȳc̄ } where cond| Ȳ c̄ is the result of replacing Y1, . . . ,Yn by c1, . . . ,cn. By an aggregate atom we mean an expression of the form\n〈aggregate term〉〈arithmetic relation〉〈arithmetic term〉 (3)\nwhere arithmetic relation is >,≥,<,≤,= or !=, and arithmetic term is constructed from variables and integers using arithmetic operations, +, −, ×, etc. By e-literals we mean regular literals possibly preceded by default negation not. The latter (former) are called negative (positive) e-literals. A rule of A log is an expression of the form\nhead ← pos,neg,agg (4)\nwhere head is a disjunction of regular literals, pos and neg are collections of regular literals and regular literals preceded by not respectively, and agg is a collection of aggregate atoms. All parts of the rule, including head, can be empty. An occurrence of a variable in (4) not bound within any set name in this rule is called free in (4). A rule of A log is called ground if it contains no occurrences of free variables and no occurrences of arithmetic functions.\nA program of A log is a finite collection of A log’s rules. A program is ground if its rules are ground.\nAs usual for ASP based languages, rules of A log program with variables are viewed as collections of their ground instantiations. A ground instantiation of a rule r is the program obtained from r by replacing free occurrences of variables in r by ground terms of Σ and evaluating all arithmetic functions. If the signature Σ is sorted (as, for instance, in (Balai et al. 2013)) the substitutions should respect sort requirements for predicates and functions. Clearly the grounding of an A log program is a ground program. The following examples illustrate the definition:\nExample 3 (Grounding: all occurrences of the set variable are bound) Consider a program P2 with variables:\nq(Y) :- card{X:p(X,Y)} = 1, r(Y).\nr(a). r(b). p(a,b).\nHere all occurrences of a set variable X are bound; all occurrences of a variable Y are free. The program’s grounding, ground(P2), is\nq(a) :- card{X:p(X,a)} = 1, r(a).\nq(b) :- card{X:p(X,b)} = 1, r(b).\nr(a). r(b). p(a,b).\nThe next example deal with the case when some occurrences of the set variable in a rule are free and some are bound.\nExample 4 (Grounding: some occurrences of a set variable are free) Consider an A log program P3\nr :- card{X:p(X)} >= 2, q(X).\np(a). p(b). q(a).\nHere the occurrence of X in q(X) is free. Hence the ground program ground(P3) is:\nr :- card{X:p(X)} >= 2, q(a).\nr :- card{X:p(X)} >= 2, q(b).\np(a). p(b). q(a).\nNote that despite its apparent simplicity the syntax of A log differs substantially from syntax of most other logic programming languages allowing aggregates (with the exception of that in (Gelfond 2002)). We illustrate the differences using the language presented in (Faber et al. 2011). (In what follows we refer to this language as F log.) While syntactically programs of A log can also be viewed as programs of F log the opposite is not true. Among other things F log allows parameters of aggregates to be substantially more complex than those of A log. For instance, an expression f{a : p(a,a),b : p(b,a)}= 1 where f is an aggregate atom of F log but not of A log. This construction which is different from a usual set-theoretic notation used in A log is important for the F log definition of grounding. For instance the grounding of the first rule of program P2 from Example 3 understood as a program of F log consists of F log rules\nq(a) :- card{a:p(a,a),b:p(b,a)} = 1, r(a).\nq(b) :- card{a:p(a,b),b:p(b,b)} = 1, r(b).\nwhich is not even a program of A log. Another important difference between the grounding methods of these languages can be illustrated by the F log grounding ground f (P3) of program P3 from Example 4 that looks as follows:\nr :- card{a:p(a)} >= 2, q(a).\nr :- card{b:p(b)} >= 2, q(b).\np(a). p(b). q(a).\nClearly this is substantially different from the A log grounding of P3 from Example 4. In Section 5 we show that this difference in grounding reflects substantial semantic differences between the two languages."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "To define the semantics of A log programs we expand the standard definition of answer set from (Gelfond and Lifschitz 1988). The resulting definition captures the rationality principle - believe nothing you are not forced to believe (Gelfond and Kahl 2014) - and avoids vicious circles. As usual the definition of answer set is given for ground programs. Some terminology: a ground aggregate atom f{X : p(X)}⊙ n (where ⊙ is one of the arithmetic relations allowed in the language) is true in a set of ground regular literals S if f{X : p(X) ∈ S}⊙ n; otherwise the atom is false in I.\nDefinition 1 (Aggregate Reduct) The aggregate reduct of a ground program Π of A log with respect to a set of ground regular literals S is obtained from Π by\n1. removing from Π all rules containing aggregate atoms false in S. 2. replacing every remaining aggregate atom f{X : p(X)}⊙ n by the set {p(t) : p(t) ∈ S}\n(which is called the reduct of the aggregate with respect to S).\n(Here p(t) is the result of replacing variable X by ground term t). The second clause of the definition reflects the principle of avoiding vicious circles – a rule with aggregate atom f{X : p(X)}⊙ n in the body can only be used if “the totality” of all objects satisfying p has already being constructed. Attempting to apply this rule to define p(t) will either lead to contradiction or to turning the rule into tautology (see Examples 7 and 9).\nDefinition 2 (Answer Set) A set S of ground regular literals over the signature of a ground program Π of A log is an answer set of Π if it is an answer set of an aggregate reduct of Π with respect to S.\nWe will illustrate this definition by a number of examples.\nExample 5 (Example 3 Revisited) Consider a program P2 and its grounding from Example 3. It is easy to see that the aggregate reduct of the program with respect to any set S not containing p(a,b) consists of the program facts, and hence S is not an answer set of P2. However the program’s aggregate reduct with respect to A = {q(b),r(a),r(b), p(a,b)} consists of the program’s facts and the rule\nq(b) :- p(a,b),r(b).\nHence A is an answer set of P2.\nExample 6 (Example 4 Revisited) Consider now the grounding\nr :- card{X:p(X)} >= 2, q(a).\nr :- card{X:p(X)} >= 2, q(b).\np(a). p(b). q(a).\nof program P3 from Example 4. Any answer set S of this program must contain its facts. Hence {X : p(X) ∈ S}= {a,b}. S satisfies the body of the first rule and must also contain r. Indeed, the aggregate reduct of P3 with respect to S = {p(a), p(b),q(a),r} consists of the facts of P3 and the rules\nr :- p(a),p(b),q(a).\nr :- p(a),p(b),q(b).\nHence S is the answer set of P3.\nNeither of the two examples above required the application of VCP. The next example shows how this principle influences our definition of answer sets and hence our reasoning.\nExample 7 (Example 2 Revisited) Consider a program P1 from Example 2. The program, consisting of a rule\np(a) :- card{X : p(X)}=1\nis grounded. It has two candidate answer sets, S1 = { } and S2 = {p(a)}. The aggregate reduct of the program with respect to S1 is the empty program. Hence, S1 is an answer set of P1. The program’s aggregate reduct with respect to S2 however is\np(a) :- p(a).\nThe answer set of this reduct is empty and hence S1 is the only answer of P1.\nExample 7 shows how the attempt to define p(a) in terms of totality of p turns the defining rule into a tautology. The next example shows how it can lead to inconsistency of a program.\nExample 8 (Vicious Circles through Aggregates and Inconsistency) Consider a program P4:\np(a).\np(b) :- card{X:p(X)} > 0.\nSince every answer set of the program must contain p(a), the program has two candidate answer sets: S1 = {p(a)} and S2 = {p(a), p(b)}. The aggregate reduct of P4 with respect to S1 is\np(a).\np(b) :- p(a).\nThe answer set of the reduct is {p(a), p(b)} and hence S1 is not an answer set of P4. The reduct of P4 with respect to S2 is\np(a).\np(b) :- p(a),p(b).\nAgain its answer set is not equal to S2 and hence P4 is inconsistent (i.e., has no answer sets). The inconsistency is the direct result of an attempt to violate the underlying principle of the semantics. Indeed, the definition of p(b) refers to the set of objects satisfying p that can contain b which is prohibited by our version of VCP. One can, of course, argue that S2 can be viewed as a reasonable collection of beliefs which can be formed by a rational reasoner associated with P4. After all, we do not need the totality of p to satisfy the body of the rule defining p(b). It is sufficient to know that p contains a. This is indeed true but this reasoning depends on the knowledge which is not directly incorporated in the definition of p(b). If one were to replace P4 by\np(a).\np(b) :- card{X:p(X), X != b} > 0.\nthen, as expected, the vicious circle principle will not be violated and the program will have unique answer set {p(a), p(b)}.\nWe end this section by a simple but practical example of a program which allows recursion through aggregates but avoids vicious circles.\nExample 9 (Defining Digital Circuits) Consider part of a logic program formalizing propagation of binary signals through simple digital circuits. We assume that the circuit does not have a feedback, i.e., a wire receiving a signal from a gate cannot be an input wire to this gate. The program may contain a simple rule\nval(W,0) :-\ngate(G, and),\noutput(W, G),\ncard{W: val(W,0), input(W, G)} > 0.\n(partially) describing propagation of symbols through an and gate. Here val(W,S) holds iff the digital signal on a wire W has value S. Despite its recursive nature the definition of val avoids vicious circle. To define the signal on an output wire W of an and gate G one needs to only construct a particular subset of input wires of G. Since, due to absence of feedback in our circuit, W can not belong to the latter set our definition is reasonable. To illustrate that our definition of answer set produces the intended result let us consider program P5 consisting of the above rule and a collection of facts:\ngate(g, and).\noutput(w0, g).\ninput(w1, g).\ninput(w2, g).\nval(w1,0).\nThe grounding, ground(P5), of P5 consists of the above facts and the three rules of the form\nval(w,0) :-\ngate(g, and),\noutput(w, g),\ncard{W: val(W,0), input(W, g)} > 0.\nwhere w is w0, w1 ,and w2. Let S = {gate(g,and),val(w1,0),val(w0,0),out put(w0,g), input(w1,g), input(w2,g)}. The aggregate reduct of ground(P5) with respect to S is the collection of facts and the rules\nval(w,0) :-\ngate(g, and),\noutput(w, g),\ninput(w1, g),\nval(w1, 0).\nwhere w is w0, w1, and w2. The answer set of the reduct is S and hence S is an answer set of P5. As expected it is the only answer set. (Indeed it is easy to see that other candidates do not satisfy our definition.)\n3 Properties of A log programs\nIn this section we give some basic properties of A log programs. Propositions 1 and 2 ensure that, as in regular ASP, answer sets of A log program are formed using the program rules together with the rationality principle. Proposition 3 is the A log version of the basic technical tool used\nin theoretical investigations of ASP and its extensions. Proposition 4 shows that complexity of entailment in A log is the same as that in regular ASP.\nWe will use the following terminology: e-literals p and not p are called contrary; not l denotes a literal contrary to e-literal l; a partial interpretation I over signature Σ is a consistent set of eliterals of this signature; an e-literal l is true in I if l ∈ I; it is false if not l ∈ I; otherwise l is undefined in I. An aggregate atom f{X : q(X)} ⊙ n is true in I if f{t : q(t)∈ I} ⊙ n is true, i.e., the value of f on the set {t : q(t) ∈ I} and the number n satisfy property ⊙. Otherwise, the atom is false in I. The head of a rule is satisfied by I if at least one of its literals is true in I; the body of a rule is satisfied by I if all of its aggregate atoms and e-literals are true in I. A rule is satisfied by I if its head is satisfied by I or its body is not satisfied by I.\nProposition 1 (Rule Satisfaction and Supportedness) Let A be an answer set of a ground A log program Π. Then\n1. A satisfies every rule r of Π. 2. If p ∈ A then there is a rule r from Π such that the body of r is satisfied by A and p is the\nonly atom in the head of r which is true in A. (It is often said that rule r supports atom p.)\nProposition 2 (Anti-chain Property) Let A1 be an answer set of an A log program Π. Then there is no answer set A2 of Π such that A1 is a proper subset of A2.\nProposition 3 (Splitting Set Theorem) Let Π1 and Π2 be programs of A log such that no atom occurring in Π1 is a head atom of Π2. Let S be a set of atoms containing all head atoms of Π1 but no head atoms of Π2. A set A of atoms is an answer set of Π1 ∪Π2 iff A∩S is an answer set of Π1 and A is an answer set of (A∩S)∪Π2.\nProposition 4 (Complexity) The problem of checking if a ground atom a belongs to all answer sets of an A log program is ΠP2 complete."
    }, {
      "heading" : "4 An Algorithm for Computing Answer Sets",
      "text" : "In this section we briefly outline an algorithm, called A solver, for computing answer sets of A log programs. We follow the tradition and limit our attention to programs without classical negation. Hence, in this section we consider only programs of this type. By an atom we mean an e-atom or an aggregate atom.\nDefinition 3 (Strong Satisfiability and Refutability) • An atom is strongly satisfied (strongly refuted) by a partial interpretation I if it is true (false)\nin every partial interpretation containing I; an atom which is neither strongly satisfied nor strongly refuted by I is undecided by I.\n• A set S of atoms is strongly satisfied by I if all atoms in S are strongly satisfied by I; • S is strongly refuted by I if for every partial interpretation I′ containing I, some atom of S\nis false in I′.\nFor instance, an e-atom is strongly satisfied (refuted) by I iff it is true (false) in I; an atom card{X : p(X)} > n which is true in I is strongly satisfied by I; an atom card{X : p(X)} < n which is false in I is strongly refuted by I; and a set { f{X : p(X)} > 5, f{X : p(X)} < 3} is strongly refuted by any partial interpretation.\nA solver consists of three functions: Solver, Cons, and IsAnswerSet. The main function, Solver, is similar to that used in standard ASP algorithms (See, for instance, Solver1 from (Gelfond and Kahl 2014)). But unlike these functions which normally have two parameters - partial interpretation I and program Π - Solver has two additional parameters, TA and FA containing aggregate atoms that must be true and false respectively in the answer set under construction. Solver returns 〈I, true〉 where I is an answer set of Π compatible with its parameters and f alse if no such answer set exists. The Solver’s description will be omitted due to space limitations. The second function, Cons, computes the consequences of its parameters - a program Π, a partial interpretation I, and two above described sets TA and FA of aggregates atoms. Due to the presence of aggregates the function is sufficiently different from a typical Cons function of ASP solvers so we describe it in some detail. The new value of I, containing the desired consequences is computed by application of the following inference rules:\n1. If the body of a rule r is strongly satisfied by I and all atoms in the head of r except p are false in I then p must be in I. 2. If an atom p ∈ I belongs to the head of exactly one rule r of Π then every other atom from the head of r must have its complement in I, the e-atoms from the body of r must be in I and its aggregate atoms must be in TA. 3. If every atom of the head of a rule r is false in I, and l is the only premise of r which is either an undefined e-atom or an aggregate atom not in FA, and the rest of the body is strongly satisfied by I, then\n(a) if l is an e-atom, then the complement of l must be in I, (b) if l is an aggregate atom, then it must be in FA.\n4. If the body of every rule with p in the head is strongly refuted by I, then (not p) must be in I.\nGiven an interpretation I, a program Π, inference rule i∈ [1..4] and r ∈Π, let function iCons(i, I,Π,r) return < δ I,δTA,δFA > where δ I, δTA and δFA are the results of applying inference rule i to r. (Note, that inference rule 4 does not really use r). We also need the following terminology. We say that I is compatible with TA if TA is not strongly refuted by I; I is compatible with FA if no atom from FA is strongly satisfied by I. A set A of regular atoms is compatible with TA and FA if the set compl(A) = {p : p ∈ A}∪{not a : a /∈ A} is compatible with TA and FA; A is compatible with I if I ⊆ compl(A). The algorithm Cons is listed below.\nfunction Cons input: partial interpretation I0, sets TA0 and FA0 of aggregate atoms compatible with I0,\nand program Π0 with signature Σ0; output: 〈Π, I,TA,FA, true〉 where I is a partial interpretation such that I0 ⊆ I,\nTA and FA are sets of aggregate atoms such that TA0 ⊆ TA and FA0 ⊆ FA, I is compatible with TA and FA, and Π is a program with signature Σ0 such that for every A,\nA is an answer set of Π0 that is compatible with I0 iff A is an answer set of Π that is compatible with I.\n〈Π0, I0,TA0,FA0, f alse〉 if there is no answer set of Π0 compatible with I0; var I,T : set of e-atoms; TA,FA: set of aggregate atoms; Π: program;\n1. Initialize I, Π, TA and FA to be I0, Π0, TA0 and FA0 respectively; 2. repeat 3. T := I; 4. Remove from Π all the rules whose bodies are strongly falsified by I; 5. Remove from the bodies of rules of Π all negative e-atoms true in I and aggregate atoms strongly satisfied by I; 6. Non-deterministically select an inference rule i from (1)–(4); 8. for every r ∈ Π 9. < δ I,δTA,δFA > := iCons(I,Π, i,r); 10. I := I ∪δ I, TA := TA∪δTA, FA := FA∪δFA; 11. until I = T ; 12. if I is consistent, TA and FA are compatible with I then 13. return < Π, I,TA,FA, true >; 14. else return < Π0, I0,TA0,FA0, f alse >;\nThe third function, IsAnswerSet of our solver A solver checks if interpretation I is an answer set of a program Π. It computes the aggregate reduct of Π with respect to I and applies usual checking algorithm (see, for instance, (Koch et al. 2003)).\nProposition 5 (Correctness of the Solver) If, given a program Π0, a partial interpretation I0, and sets TA0 and FA0 of aggregate atoms Solver(I0,TA0,FA0,Π0) returns 〈I, true〉 then I is an answer set of Π0 compatible with I0, TA0 and FA0. If there is no such answer set, the solver returns f alse.\nTo illustrate the algorithm consider a program Π\n:- p(a).\np(a) :- card{X:q(X)} > 0.\nq(a) or p(b).\nand trace Solver(Π, I,TA,FA) where I, TA, and FA are empty. Solver starts by calling Cons which computes the consequence not p(a) (from the first rule of the program), FA = {card{X : q(X)}> 0} (from the second rule of the program) and not q(b) (from the fourth inference rule), and returns true, I = {not q(b),not p(a)} and new FA; TA is unchanged. Solver then guesses q(a) to be true, i.e., I = {not q(b),not p(a),q(a)}, and calls Cons again. Cons does not produce any new consequences but finds that FA is not compatible with I (line 12 of the algorithm). So, it returns f alse, which causes Solver to set q(a) to be false, i.e., I = {not q(b),not p(a), not q(a)}. Solver then calls Cons again which returns I = {not q(b),not p(a),not q(a), p(b)}. Solver finds that I is complete and calls IsAnswerSet which returns true. Finally, Solver returns I as an answer set of the program."
    }, {
      "heading" : "5 Comparison with Other Approaches",
      "text" : "There are a large number of approaches to the syntax and semantics of extensions of ASP by aggregates. In this section we concentrate on languages from (Son and Pontelli 2007) and (Faber\net al. 2011) which we refer to as S log and F log respectively. Due to multiple equivalence results discussed in these papers this is sufficient to cover most of the approaches. The main difference between the syntax of aggregates in A log and F log is in treatment of variables occurring in aggregate terms. A log uses usual logical concept of bound and free occurrence of a variable (the occurrence of X within S = {X : p(X ,Y )} is bound while the occurrence of Y is free). F log uses very different concepts of global and local variable of a rule. A variable is local in rule r if it occurs solely in an aggregate term of r; otherwise, the variable is global. As the result, in A log, every aggregate term {X : p(X)} can be replaced by a term {Y : p(Y )} while it is not the case in F log. In our opinion the approach of F log (and many other languages and systems which adopted this syntax) makes declarative reading of aggregate terms substantially more difficult1. To see the semantic ramifications of the F log treatment of variables consider the following example:\nExample 10 (Variables in Aggregate Terms: Global versus Bound) Consider program P3 from Example 4. According to F log the meaning of an occurrence of an expression {X : p(X)} in the body of the program’s first rule changes if X is replaced by a different variable. In A log, where X is understood as bound this is not the case. This leads to substantial difference in grounding and in the semantics of the program. In A log P3 has one answer set, {p(a), p(b),q(a),r}. In F log answer sets of P3 are those of ground f (P3). The answer set of the latter is {p(a), p(b),q(a)}.\nOther semantic differences are due to the multiplicity of informal (and not necessarily clearly spelled out) principles underlying various semantics.\nExample 11 (Vicious Circles in F log) Consider the following program, P6, adopted from (Son and Pontelli 2007):\np(1) :- p(0).\np(0) :- p(1).\np(1) :- count{X: p(X)} != 1.\nwhich, if viewed as F log program, has one answer set A = {p(0), p(1)}. Informal argument justifying this result goes something like this: Clearly, A satisfies the rules of the program. To satisfy the minimality principle no proper subset of A should be able to do that, which is easily checked to be true. Faber et al use so called black box principle: “when checking stability they [aggregate literals] are either present in their entirety or missing altogether”, i.e., the semantics of F log does not consider the process of derivation of elements of the aggregate parameter. Note however, that the program’s definition of p(1) is given in terms of fully defined term {X : p(X)}, i.e., the definition contains a vicious circle. This explains why A is not an answer set of P6 in A log. In this particular example we are in agreement with S log which requires that the value of an aggregate atom can be computed before the rule with this atom in the body can be used in the construction of an answer set.\nThe absence of answer set of P6 in S log may suggest that it adheres to our formalization of the VCP. The next example shows that it is not the case.\n1 The other difference in reading of S is related to the treatment of variable Y . In F log the variable is bound by an unseen existential quantifier. If all the variables are local then S = {X : p(X ,Y )} is really S1 = {X : ∃Y p(X ,Y )}. In A log Y is free. Both approaches are reasonable but we prefer to deal with the different possible readings by introducing an explicit existential quantifier as in Prolog. It is easy semantically and we do not discuss it in the paper.\nExample 12 (VCP and Constructive Semantics of aggregates) Let us consider a program P7.\np(a) :- count{X:p(X)} > 0.\np(b) :- not q.\nq :- not p(b).\nAs shown in (Son and Pontelli 2007) the program has two S log answer sets, A = {q} and B = {p(a), p(b)}. If viewed as a program of A log, P7 will have one answer set, A. This happens because the S log construction of B uses knowledge about properties of the aggregate atom of the first rule; the semantics of A log only takes into account the meaning of the parameter of the aggregate term. Both approaches can, probably, be successfully defended but, in our opinion, the constructive semantics has a disadvantage of being less general (it is only applicable to nondisjunctive programs), and more complex mathematically.\nA key difference between our algorithm and those in the existing work (Faber et al. 2008; Gebser et al. 2009) is that the other work needs rather involved methods to ground the aggregates while our algorithm does not need to ground the aggregate atoms. As a result, the ground program used by our algorithm may be smaller, and our algorithm is simpler.\nThere is also a close connection between the above semantics of aggregates all of which are based on some notion of a reduct or a fixpoint computation and approaches in which aggregates are represented as special cases of more general constructs, such as propositional formulas (Ferraris 2005; Harrison et al. 2013) and abstract constraint atoms (Marek et al. 2004; Liu et al. 2010; Wang et al. 2012) (Our semantics can be easily extended to the latter). Some of the existing equivalence results allow us to establish the relationship between these approaches and A log. Others require further investigation."
    }, {
      "heading" : "6 Conclusion and Future Work",
      "text" : "We presented an extension, A log, of ASP which allows for the representation of and reasoning with aggregates. We believe that the language satisfies design criteria of simplicity of syntax and formal and informal semantics. There are many ways in which this work can be continued. The first, and simplest, step is to expand A log by allowing choice rules similar to those of (Niemela et al. 2002). This can be done in a natural way by combining ideas from this paper and that from (Gelfond 2002). We also plan to investigate mapping of A log into logic programs with arbitrary propositional formulas. There are many interesting and, we believe, important questions related to optimization of the A log solver from Section 4. After clarity is reached in this area one will, of course, try to address the questions of implementation."
    }, {
      "heading" : "7 Acknowledgment",
      "text" : "We would like to thank Amelia Harrison, Patrick Kahl, Vladimir Lifschitz, and Tran Cao Son for useful comments. The authors’ work was partially supported by NSF grant IIS-1018031."
    }, {
      "heading" : "8 Appendix",
      "text" : "In this appendix, given an A log program Π, a set A of literals and a rule r ∈ Π, we use α(r,A) to denote the rule obtained from r in the aggregate reduct of Π with respect to A. α(r,A) is nil, called an empty rule, if r is discarded in the aggregate reduct. We use α(Π,A) to denote the aggregate reduct of Π, i.e., {α(r,A) : r ∈ Π and α(r,A) 6= nil}.\nProposition 1 (Rule Satisfaction and Supportedness) Let A be an answer set of a ground A log program Π. Then\n1. A satisfies every rule r of Π. 2. If p ∈ A then there is a rule r from Π such that the body of r is satisfied by A and p is the\nonly atom in the head of r which is true in A. (It is often said that rule r supports atom p.)\nProof: Let\n(1) A be an answer set of Π.\nWe first prove A satisfies every rule r of Π. Let r be a rule of Π such that\n(2) A satisfies the body of r.\nStatement (2) implies that every aggregate atom, if there is any, of the body of r is satisfied by A. By the definition of the aggregate reduct, there must be a non-empty rule r′ ∈ α(Π,A) such that\n(3) r′ = α(r,A).\nBy the definition of aggregate reduct, A satisfies the body of r iff it satisfies that of r′. Therefore, (2) and (3) imply that\n(4) A satisfies the body of r′.\nBy the definition of answer set of A log, (1) implies that\n(5) A is an answer set of α(Π,A).\nSince α(Π,A) is an ASP program, (3) and (5) imply that\n(6) A satisfies r′.\nStatements (4) and (6) imply A satisfies the head of r′ and thus the head of r because r and and r′ have the same head.\nTherefore r is satisfied by A, which concludes our proof of the first part of the proposition.\nWe next prove the second part of the propostion. Consider p ∈ A. (1) implies that A is an answer set of α(Π,A). By the supportedness Lemma for ASP programs (Gelfond and Kahl 2014), there is a rule r′ ∈ α(Π,A) such that\n(7) r′ supports p.\nLet r ∈ Π be a rule such that r′ = α(r,A). By the definition of aggregate reduct,\n(8) A satisfies the body of r iff A satisfies that of r′.\nSince r and r′ have the same heads, (7) and (8) imply that rule r of Π supports p in A, which concludes the proof of the second part of the proposition.\nProposition 2 (Anti-chain Property) Let A1 be an answer set of an A log program Π. Then there is no answer set A2 of Π such that A1 is a proper subset of A2.\nProof: Let us assume that there are A1 and A2 such that\n(1) A1 ⊆ A2 and\n(2) A1 and A2 are answer sets of Π\nand show that A1 = A2.\nLet R1 and R2 be the aggregate reducts of Π with respect to A1 and A2 respectively. Let us first show that A1 satisfies the rules of R2. Consider\n(3) r2 ∈ R2.\nBy the definition of aggregate reduct there is r ∈ Π such that\n(4) r2 = α(r,A2).\nConsider\n(5) r1 = α(r,A1).\nIf r contains no aggregate atoms then\n(6) r1 = r2.\nBy (5) and (6), r2 ∈ R1 and hence, by (2) A1 satisfies r2.\nAssume now that r contains one aggregate term, f{X : p(X)}, i.e. r is of the form\n(7) h ← B,C( f{X : p(X)})\nwhere C is some property of the aggregate.\nThen r2 has the form\n(8) h ← B,P2\nwhere\n(9) P2 = {p(t) : p(t) ∈ A2} and f (P2) satisfies condition C.\nLet\n(10) P1 = {p(t) : p(t) ∈ A1}\nand consider two cases:\n(11a) α(r,A1) = /0.\nIn this case C( f (P1)) does not hold. Hence, P1 6= P2. Since A1 ⊆ A2 we have that P1 ⊂ P2, the body of rule (8) is not satisfied by A1, and hence the rule (8) is.\n(11b) α(r,A1) 6= /0.\nThen r1 has the form\n(12) h ← B,P1\nwhere\n(13) P1 = {p(t) : p(t) ∈ A1} and f (P1) satisfies condition C.\nAssume that A1 satisfies the body, B,P2, of rule (8). Then\n(14) P2 ⊆ A1\nThis, together with (9) and (10) implies\n(15) P2 ⊆ P1.\nFrom (1), (9), and (10) we have P1 ⊆ P2. Hence\n(16) P1 = P2.\nThis means that A1 satisfies the body of r1 and hence it satisfies h and, therefore, r2.\nSimilar argument works for rules containing multiple aggregate atoms and, therefore, A1 satisfies R2.\nSince A2 is a minimal set satisfying R2 and A1 satisfies R2 and A1 ⊆ A2 we have that A1 = A2.\nThis completes our proof.\nProposition 3 (Splitting Set Theorem) Let\n1. Π1 and Π2 be ground programs of A log such that no atom occurring in Π1 is unifiable with any atom occurring in the heads of Π2, 2. S be a set of ground literals containing all head literals of Π1 but no head literals of Π2,\nThen\n(3) A is an answer set of Π1 ∪Π2\niff\n(4a) A∩S is an answer set of Π1 and\n(4b) A is an answer set of (A∩S)∪Π2.\nProof. By the definitions of answer set and aggregate reduct\n(3) holds iff\n(5) A is an answer set of α(Π1,A)∪α(Π2,A)\nIt is easy to see that conditions (1), (2), and the definition of α imply that α(Π1,A), α(Π2,A), and S satisfy condition of the splitting set theorem for ASP (Lifschitz and Turner 1994). Hence\n(5) holds iff\n(6a) A∩S is an answer set of α(Π1,A)\nand\n(6b) A is an answer set of (A∩S)∪α(Π2,A).\nTo complete the proof it suffices to show that\n(7) Statements (6a) and (6b) hold iff (4a) and (4b) hold.\nBy definition of α ,\n(8) (A∩S)∪α(Π2,A) = α((A∩S)∪Π2,A)\nand hence, by the definition of answer set we have\n(9) (6b) iff (4b).\nNow notice that from (4b), clause 2 of Proposition 1, and conditions (1) and (2) of our theorem we have that for any ground instance p(t) of a literal occurring in an aggregate atom of Π1\n(10) p(t) ∈ A iff p(t) ∈ A∩S\nand, hence\n(11) α(Π1,A) = α(Π1,A∩S).\nFrom (9), (11), and the definition of answer set we have that\n(12) (6a) iff (4a)\nwhich completes the proof of our theorem.\nLemma 1 Checking whether a set M of literals is an answer set of P, a program with aggregates, is in co-NP.\nProof: To prove that M is not an answer set of P, we first check if M is not a model of the aggregate reduct of P, which is in polynomial time. If M is not a model, M is not an answer set of P. Otherwise, we guess a set M′ of P, and check if M′ is a model of the aggregate reduct of P and M′ ⊂ M. This checking is also in polynomial time. Therefore, the problem of checking whether a set M of literals is an answer set of P is in co-NP.\nProposition 4 (Complexity) The problem of checking if a ground atom a belongs to all answer sets of an A log program is ΠP2 complete.\nProof: First we show that the cautious reasoning problem is in ΠP2 . We verify that a ground atom a is not a cautious consequence of a program P as follows: Guess a set M of literals and check that (1) M is an answer set for P, and (2) a is not true wrt M. Task (2) is clearly polynomial, while (1) is in co-NP by virtue of Lemma 1. The problem therefore lies in ΠP2 .\nNext, cautious reasoning over programs without aggregates is ΠP2 hard by (Dantsin et al. 2001). Therefore, cautious reasoning over programs with aggregates is ΠP2 hard too.\nIn summary, cautious reasoning over programs with aggregates is ΠP2 complete."
    } ],
    "references" : [ {
      "title" : "Towards answer set programming with sorts",
      "author" : [ "E. BALAI", "M. GELFOND", "Y. ZHANG" ],
      "venue" : "LPNMR. 135–147.",
      "citeRegEx" : "BALAI et al\\.,? 2013",
      "shortCiteRegEx" : "BALAI et al\\.",
      "year" : 2013
    }, {
      "title" : "Answer set programming at a glance",
      "author" : [ "G. BREWKA", "T. EITER", "M. TRUSZCZYNSKI" ],
      "venue" : "Commun. ACM 54, 12, 92–103.",
      "citeRegEx" : "BREWKA et al\\.,? 2011",
      "shortCiteRegEx" : "BREWKA et al\\.",
      "year" : 2011
    }, {
      "title" : "Complexity and expressive power of logic programming",
      "author" : [ "E. DANTSIN", "T. EITER", "G. GOTTLOB", "A. VORONKOV" ],
      "venue" : "ACM Comput. Surv. 33, 3, 374–425.",
      "citeRegEx" : "DANTSIN et al\\.,? 2001",
      "shortCiteRegEx" : "DANTSIN et al\\.",
      "year" : 2001
    }, {
      "title" : "Theory and practice of answer set programming",
      "author" : [ "E. ERDEM", "J. LEE", "Y. LIERLER" ],
      "venue" : "AAAI-2012 Tutorial (http://peace.eas.asu.edu/aaai12tutorial/asp-tutorial-aaai.pdf).",
      "citeRegEx" : "ERDEM et al\\.,? 2012",
      "shortCiteRegEx" : "ERDEM et al\\.",
      "year" : 2012
    }, {
      "title" : "Semantics and complexity of recursive aggregates in answer set programming",
      "author" : [ "W. FABER", "G. PFEIFER", "N. LEONE" ],
      "venue" : "Artificial Intelligence 175, 1, 278–298.",
      "citeRegEx" : "FABER et al\\.,? 2011",
      "shortCiteRegEx" : "FABER et al\\.",
      "year" : 2011
    }, {
      "title" : "Design and implementation of aggregate functions in the dlv system",
      "author" : [ "W. FABER", "G. PFEIFER", "N. LEONE", "T. DELL’ARMI", "G. IELPA" ],
      "venue" : "TPLP 8,",
      "citeRegEx" : "FABER et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "FABER et al\\.",
      "year" : 2008
    }, {
      "title" : "Predicativity",
      "author" : [ "S. FEFERMAN" ],
      "venue" : "http://math.stanford.edu/~feferman/papers/. FERRARIS, P. 2005. Answer sets for propositional theories. In LPNMR. 119–131.",
      "citeRegEx" : "FEFERMAN,? 2002",
      "shortCiteRegEx" : "FEFERMAN",
      "year" : 2002
    }, {
      "title" : "On the implementation of weight constraint rules in conflict-driven asp solvers",
      "author" : [ "M. GEBSER", "R. KAMINSKI", "B. KAUFMANN", "T. SCHAUB" ],
      "venue" : "ICLP. 250–264.",
      "citeRegEx" : "GEBSER et al\\.,? 2009",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2009
    }, {
      "title" : "Conflict-driven answer set enumeration",
      "author" : [ "M. GEBSER", "B. KAUFMAN", "A. NEUMANN", "T. SCHAUB" ],
      "venue" : "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’07), C. Baral, G. Brewka, and J. Schlipf, Eds. lnai, vol. 3662. Springer, 136–148.",
      "citeRegEx" : "GEBSER et al\\.,? 2007",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2007
    }, {
      "title" : "Representing Knowledge in A-Prolog",
      "author" : [ "M. GELFOND" ],
      "venue" : "Computational Logic: Logic Programming and Beyond, Essays in Honour of Robert A. Kowalski, Part II, A. C. Kakas and F. Sadri, Eds. Vol. 2408. Springer Verlag, Berlin, 413–451.",
      "citeRegEx" : "GELFOND,? 2002",
      "shortCiteRegEx" : "GELFOND",
      "year" : 2002
    }, {
      "title" : "Knowledge Representation, Reasoning, and the Design of Intelligent Agents",
      "author" : [ "M. GELFOND", "Y. KAHL" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "GELFOND and KAHL,? 2014",
      "shortCiteRegEx" : "GELFOND and KAHL",
      "year" : 2014
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "Proceedings of ICLP-88. 1070–1080.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1988",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1988
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "New Generation Computing 9, 3/4, 365–386.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1991",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1991
    }, {
      "title" : "On the semantics of gringo",
      "author" : [ "A. HARRISON", "V. LIFSCHITZ", "F. YANG" ],
      "venue" : "Working Notes of the Workshop on Answer Set Programming and Other Computing Paradigms.",
      "citeRegEx" : "HARRISON et al\\.,? 2013",
      "shortCiteRegEx" : "HARRISON et al\\.",
      "year" : 2013
    }, {
      "title" : "Semantics of logic programs with aggregates",
      "author" : [ "D.B. KEMP", "P.J. STUCKEY" ],
      "venue" : "ISLP. Vol. 91. Citeseer, 387–401.",
      "citeRegEx" : "KEMP and STUCKEY,? 1991",
      "shortCiteRegEx" : "KEMP and STUCKEY",
      "year" : 1991
    }, {
      "title" : "Enhancing disjunctive logic programming systems by sat checkers",
      "author" : [ "C. KOCH", "N. LEONE", "G. PFEIFER" ],
      "venue" : "Artif. Intell. 151, 1-2, 177–212.",
      "citeRegEx" : "KOCH et al\\.,? 2003",
      "shortCiteRegEx" : "KOCH et al\\.",
      "year" : 2003
    }, {
      "title" : "The DLV system for knowledge representation and reasoning",
      "author" : [ "N. LEONE", "G. PFEIFER", "W. FABER", "T. EITER", "G. GOTTLOB", "S. PERRI", "F. SCARCELLO" ],
      "venue" : "ACM Transactions on Computational Logic 7, 499–562.",
      "citeRegEx" : "LEONE et al\\.,? 2006",
      "shortCiteRegEx" : "LEONE et al\\.",
      "year" : 2006
    }, {
      "title" : "Splitting a logic program",
      "author" : [ "V. LIFSCHITZ", "H. TURNER" ],
      "venue" : "Proceedings of the eleventh international conference on Logic programming. MIT Press, Cambridge, MA, USA, 23–37.",
      "citeRegEx" : "LIFSCHITZ and TURNER,? 1994",
      "shortCiteRegEx" : "LIFSCHITZ and TURNER",
      "year" : 1994
    }, {
      "title" : "Logic programs with abstract constraint atoms: The role of computations",
      "author" : [ "L. LIU", "E. PONTELLI", "T.C. SON", "M. TRUSZCZYNSKI" ],
      "venue" : "Artif. Intell. 174, 3-4, 295–315.",
      "citeRegEx" : "LIU et al\\.,? 2010",
      "shortCiteRegEx" : "LIU et al\\.",
      "year" : 2010
    }, {
      "title" : "Logic programs with abstract constraint atoms",
      "author" : [ "V.W. MAREK", "M TRUSZCZYNSKI" ],
      "venue" : "AAAI. Vol. 4. 86–91.",
      "citeRegEx" : "MAREK and TRUSZCZYNSKI,? 2004",
      "shortCiteRegEx" : "MAREK and TRUSZCZYNSKI",
      "year" : 2004
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "I. NIEMELA", "P. SIMONS", "T. SOININEN" ],
      "venue" : "Artificial Intelligence 138, 1–2 (Jun), 181–234.",
      "citeRegEx" : "NIEMELA et al\\.,? 2002",
      "shortCiteRegEx" : "NIEMELA et al\\.",
      "year" : 2002
    }, {
      "title" : "Well-fouded and stable semantics of logic programs with aggregates",
      "author" : [ "N. PELOV", "M. DENECKER", "M. BRUYNOOGHE" ],
      "venue" : "Theory and Practice of Logic Programming 7, 355–375.",
      "citeRegEx" : "PELOV et al\\.,? 2007",
      "shortCiteRegEx" : "PELOV et al\\.",
      "year" : 2007
    }, {
      "title" : "Les mathematiques et la logique",
      "author" : [ "H. POINCARE" ],
      "venue" : "Review de metaphysique et de morale 14, 294–317.",
      "citeRegEx" : "POINCARE,? 1906",
      "shortCiteRegEx" : "POINCARE",
      "year" : 1906
    }, {
      "title" : "A constructive semantic characterization of aggregates in answer set programming",
      "author" : [ "T.C. SON", "E. PONTELLI" ],
      "venue" : "TPLP 7, 3, 355–375.",
      "citeRegEx" : "SON and PONTELLI,? 2007",
      "shortCiteRegEx" : "SON and PONTELLI",
      "year" : 2007
    }, {
      "title" : "A well-founded semantics for basic logic programs with arbitrary abstract constraint atoms",
      "author" : [ "Y. WANG", "F. LIN", "M. ZHANG", "YOU", "J.-H." ],
      "venue" : "AAAI.",
      "citeRegEx" : "WANG et al\\.,? 2012",
      "shortCiteRegEx" : "WANG et al\\.",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 11,
      "context" : "1 Introduction The development of answer set semantics for logic programs (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) led to the creation of powerful knowledge representation language, Answer Set Prolog (ASP), capable of representing recursive definitions, defaults, effects of actions and other important phenomena of natural language.",
      "startOffset" : 74,
      "endOffset" : 130
    }, {
      "referenceID" : 12,
      "context" : "1 Introduction The development of answer set semantics for logic programs (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) led to the creation of powerful knowledge representation language, Answer Set Prolog (ASP), capable of representing recursive definitions, defaults, effects of actions and other important phenomena of natural language.",
      "startOffset" : 74,
      "endOffset" : 130
    }, {
      "referenceID" : 20,
      "context" : "The design of algorithms for computing answer sets and their efficient implementations in systems called ASP solvers (Niemela et al. 2002; Leone et al. 2006; Gebser et al. 2007) allowed the language to become a powerful tool for building non-trivial knowledge intensive applications (Brewka et al.",
      "startOffset" : 117,
      "endOffset" : 177
    }, {
      "referenceID" : 16,
      "context" : "The design of algorithms for computing answer sets and their efficient implementations in systems called ASP solvers (Niemela et al. 2002; Leone et al. 2006; Gebser et al. 2007) allowed the language to become a powerful tool for building non-trivial knowledge intensive applications (Brewka et al.",
      "startOffset" : 117,
      "endOffset" : 177
    }, {
      "referenceID" : 8,
      "context" : "The design of algorithms for computing answer sets and their efficient implementations in systems called ASP solvers (Niemela et al. 2002; Leone et al. 2006; Gebser et al. 2007) allowed the language to become a powerful tool for building non-trivial knowledge intensive applications (Brewka et al.",
      "startOffset" : 117,
      "endOffset" : 177
    }, {
      "referenceID" : 1,
      "context" : "2007) allowed the language to become a powerful tool for building non-trivial knowledge intensive applications (Brewka et al. 2011; Erdem et al. 2012).",
      "startOffset" : 111,
      "endOffset" : 150
    }, {
      "referenceID" : 3,
      "context" : "2007) allowed the language to become a powerful tool for building non-trivial knowledge intensive applications (Brewka et al. 2011; Erdem et al. 2012).",
      "startOffset" : 111,
      "endOffset" : 150
    }, {
      "referenceID" : 21,
      "context" : "Instead there is a comparatively large collection of such languages with different syntax and, even more importantly, different semantics (Pelov et al. 2007; Niemela et al. 2002; Son and Pontelli 2007; Faber et al. 2011; Gelfond 2002; Kemp and Stuckey 1991).",
      "startOffset" : 138,
      "endOffset" : 257
    }, {
      "referenceID" : 20,
      "context" : "Instead there is a comparatively large collection of such languages with different syntax and, even more importantly, different semantics (Pelov et al. 2007; Niemela et al. 2002; Son and Pontelli 2007; Faber et al. 2011; Gelfond 2002; Kemp and Stuckey 1991).",
      "startOffset" : 138,
      "endOffset" : 257
    }, {
      "referenceID" : 23,
      "context" : "Instead there is a comparatively large collection of such languages with different syntax and, even more importantly, different semantics (Pelov et al. 2007; Niemela et al. 2002; Son and Pontelli 2007; Faber et al. 2011; Gelfond 2002; Kemp and Stuckey 1991).",
      "startOffset" : 138,
      "endOffset" : 257
    }, {
      "referenceID" : 4,
      "context" : "Instead there is a comparatively large collection of such languages with different syntax and, even more importantly, different semantics (Pelov et al. 2007; Niemela et al. 2002; Son and Pontelli 2007; Faber et al. 2011; Gelfond 2002; Kemp and Stuckey 1991).",
      "startOffset" : 138,
      "endOffset" : 257
    }, {
      "referenceID" : 9,
      "context" : "Instead there is a comparatively large collection of such languages with different syntax and, even more importantly, different semantics (Pelov et al. 2007; Niemela et al. 2002; Son and Pontelli 2007; Faber et al. 2011; Gelfond 2002; Kemp and Stuckey 1991).",
      "startOffset" : 138,
      "endOffset" : 257
    }, {
      "referenceID" : 14,
      "context" : "Instead there is a comparatively large collection of such languages with different syntax and, even more importantly, different semantics (Pelov et al. 2007; Niemela et al. 2002; Son and Pontelli 2007; Faber et al. 2011; Gelfond 2002; Kemp and Stuckey 1991).",
      "startOffset" : 138,
      "endOffset" : 257
    }, {
      "referenceID" : 4,
      "context" : "According to (Faber et al. 2011) the program has one answer set A = { }; according to (Gelfond 2002; Kemp and Stuckey 1991) it has two answer sets: A1 = { } and A2 = {p(a)}.",
      "startOffset" : 13,
      "endOffset" : 32
    }, {
      "referenceID" : 9,
      "context" : "2011) the program has one answer set A = { }; according to (Gelfond 2002; Kemp and Stuckey 1991) it has two answer sets: A1 = { } and A2 = {p(a)}.",
      "startOffset" : 59,
      "endOffset" : 96
    }, {
      "referenceID" : 14,
      "context" : "2011) the program has one answer set A = { }; according to (Gelfond 2002; Kemp and Stuckey 1991) it has two answer sets: A1 = { } and A2 = {p(a)}.",
      "startOffset" : 59,
      "endOffset" : 96
    }, {
      "referenceID" : 6,
      "context" : "According to Feferman (Feferman 2002) the principle was first formulated by Poincare (Poincare 1906) in his analysis of paradoxes of set theory.",
      "startOffset" : 22,
      "endOffset" : 37
    }, {
      "referenceID" : 22,
      "context" : "According to Feferman (Feferman 2002) the principle was first formulated by Poincare (Poincare 1906) in his analysis of paradoxes of set theory.",
      "startOffset" : 85,
      "endOffset" : 100
    }, {
      "referenceID" : 4,
      "context" : "Similar ideas were already successfully used in a collection of logic programming definitions of stratification including that of stratified aggregates (see, for instance, (Faber et al. 2011).",
      "startOffset" : 172,
      "endOffset" : 191
    }, {
      "referenceID" : 0,
      "context" : "If the signature Σ is sorted (as, for instance, in (Balai et al. 2013)) the substitutions should respect sort requirements for predicates and functions.",
      "startOffset" : 51,
      "endOffset" : 70
    }, {
      "referenceID" : 9,
      "context" : "Note that despite its apparent simplicity the syntax of A log differs substantially from syntax of most other logic programming languages allowing aggregates (with the exception of that in (Gelfond 2002)).",
      "startOffset" : 189,
      "endOffset" : 203
    }, {
      "referenceID" : 4,
      "context" : "We illustrate the differences using the language presented in (Faber et al. 2011).",
      "startOffset" : 62,
      "endOffset" : 81
    }, {
      "referenceID" : 11,
      "context" : "2 Semantics To define the semantics of A log programs we expand the standard definition of answer set from (Gelfond and Lifschitz 1988).",
      "startOffset" : 107,
      "endOffset" : 135
    }, {
      "referenceID" : 10,
      "context" : "The resulting definition captures the rationality principle - believe nothing you are not forced to believe (Gelfond and Kahl 2014) - and avoids vicious circles.",
      "startOffset" : 108,
      "endOffset" : 131
    }, {
      "referenceID" : 10,
      "context" : "The main function, Solver, is similar to that used in standard ASP algorithms (See, for instance, Solver1 from (Gelfond and Kahl 2014)).",
      "startOffset" : 111,
      "endOffset" : 134
    }, {
      "referenceID" : 15,
      "context" : "It computes the aggregate reduct of Π with respect to I and applies usual checking algorithm (see, for instance, (Koch et al. 2003)).",
      "startOffset" : 113,
      "endOffset" : 131
    }, {
      "referenceID" : 23,
      "context" : "In this section we concentrate on languages from (Son and Pontelli 2007) and (Faber",
      "startOffset" : 49,
      "endOffset" : 72
    }, {
      "referenceID" : 23,
      "context" : "Example 11 (Vicious Circles in F log) Consider the following program, P6, adopted from (Son and Pontelli 2007):",
      "startOffset" : 87,
      "endOffset" : 110
    }, {
      "referenceID" : 23,
      "context" : "As shown in (Son and Pontelli 2007) the program has two S log answer sets, A = {q} and B = {p(a), p(b)}.",
      "startOffset" : 12,
      "endOffset" : 35
    }, {
      "referenceID" : 7,
      "context" : "A key difference between our algorithm and those in the existing work (Faber et al. 2008; Gebser et al. 2009) is that the other work needs rather involved methods to ground the aggregates while our algorithm does not need to ground the aggregate atoms.",
      "startOffset" : 70,
      "endOffset" : 109
    }, {
      "referenceID" : 13,
      "context" : "There is also a close connection between the above semantics of aggregates all of which are based on some notion of a reduct or a fixpoint computation and approaches in which aggregates are represented as special cases of more general constructs, such as propositional formulas (Ferraris 2005; Harrison et al. 2013) and abstract constraint atoms (Marek et al.",
      "startOffset" : 278,
      "endOffset" : 315
    }, {
      "referenceID" : 18,
      "context" : "2013) and abstract constraint atoms (Marek et al. 2004; Liu et al. 2010; Wang et al. 2012) (Our semantics can be easily extended to the latter).",
      "startOffset" : 36,
      "endOffset" : 90
    }, {
      "referenceID" : 24,
      "context" : "2013) and abstract constraint atoms (Marek et al. 2004; Liu et al. 2010; Wang et al. 2012) (Our semantics can be easily extended to the latter).",
      "startOffset" : 36,
      "endOffset" : 90
    }, {
      "referenceID" : 20,
      "context" : "The first, and simplest, step is to expand A log by allowing choice rules similar to those of (Niemela et al. 2002).",
      "startOffset" : 94,
      "endOffset" : 115
    }, {
      "referenceID" : 9,
      "context" : "This can be done in a natural way by combining ideas from this paper and that from (Gelfond 2002).",
      "startOffset" : 83,
      "endOffset" : 97
    } ],
    "year" : 2014,
    "abstractText" : "The paper presents a knowledge representation language A log which extends ASP with aggregates. The goal is to have a language based on simple syntax and clear intuitive and mathematical semantics. We give some properties of A log, an algorithm for computing its answer sets, and comparison with other approaches.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}