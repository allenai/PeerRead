{
  "name" : "1307.4440.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Parameterized Complexity Results for Plan Reuse",
    "authors" : [ "Ronald de Haan", "Anna Roubickova", "Stefan Szeider" ],
    "emails" : [ "dehaan@kr.tuwien.ac.at", "stefan@szeider.net", "anna.roubickova@stud-inf.unibz.it" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n30 7.\n44 40\nv1 [\ncs .A\nI] 1\n6 Ju\nWe provide theoretical results that identify situations in which plan reuse is provably tractable. We perform our analysis in the framework of parameterized complexity, which supports a rigorous worst-case complexity analysis that takes structural properties of the input into account in terms of parameters. A central notion of parameterized complexity is fixed-parameter tractability which extends the classical notion of polynomial-time tractability by utilizing the effect of structural properties of the problem input.\nWe draw a detailed map of the parameterized complexity landscape of several variants of problems that arise in the context of case-based planning. In particular, we consider the problem of reusing an existing plan, imposing various restrictions in terms of parameters, such as the number of steps that can be added to the existing plan to turn it into a solution of the planning instance at hand."
    }, {
      "heading" : "Introduction",
      "text" : "Planning is one of the central problems of AI with a wide range of applications from industry to academics (Ghallab, Nau, and Traverso 2004). Planning gives rise to challenging computational problems. For instance, deciding whether there exists a plan for a given planning instance is PSPACE-complete, and the problem remains at least NP-hard under various restrictions (Bylander 1994). To overcome this high worst-case complexity, various heuristics, restrictions, and relaxations of planning problems have been developed that work surprisingly well in practical settings (Hoffmann 2001; Helmert 2006). Among the heuristic approaches is case-based planning, which proceeds from the idea that significant planning efforts may be saved by reusing previous solutions (Kambhampati and Hendler 1992; Veloso 1994). This approach is based on the assumption that planning tasks tend to recur and that if the tasks are similar, then so are their solutions. Empirical evidence suggests that this assumption holds in many settings, and that the case-based approach works particularly well if the planning tasks require complex solutions while the modifications required on the known plans are considerably small.\nSo far the research on the worst-case complexity of case-based planning did not take into account the essential assumption that similar planning tasks require similar solutions. Indeed, as shown by Liberatore (2005), if none of the known solutions are helpful, then the case-based system needs to invest an effort comparable to generating the solution from scratch, and hence does not benefit from the previous experience. There is no way to benefit from the knowledge of an unrelated solution. However, the result disregards the case-based assumptions which are meant to avoid such\n∗Supported by the European Research Council (ERC), project COMPLEX REASON, 239962.\nworst cases. It seems that the classical complexity framework is not well-suited for taking such assumptions into account.\nNew Contribution In this paper we provide theoretical results that identify situations in which the plan reuse of the case-based approach is provably tractable. We perform our analysis in the framework of parameterized complexity, which supports a rigorous worst-case complexity analysis that takes structural properties of the input into account (Downey, Fellows, and Stege 1999; Niedermeier 2006; Gottlob and Szeider 2006). These structural properties are captured in terms of parameters, which are integer numbers that are small compared to the size of the total problem input. The theoretical analysis now considers the impact of these parameters on the worst-case complexity of the considered problems. A central notion of parameterized complexity is fixed-parameter tractability, which extends the classical notion of polynomial-time tractability by utilising the impact of parameters. Parameterized complexity also provides a hardness theory that, similar to the theory of NP-completeness, provides strong evidence that certain parameterized problems are not fixed-parameter tractable (fixed-parameter intractable).\nIn the problems we study we are given a planning task together with a stored solution for a different planning task, where this solution consists of a plan and an initial state the plan is applied to. The question is to modify the existing solution to obtain a solution for the new planning task. By means of various parameters we control the modifications applied to the stored solution. For instance, we can require that the number of additional planning steps added to fit the stored solution to the new planning task is small compared to the length of the stored solution.\nIn order to evaluate the impact of structural properties on the overall complexity we use parameters based on the following four restrictions, each restriction is associated with one of the four symbols L, A, V, and D.\nL: bounds on the number of added planning steps\nA: bounds on the size of a specified set of actions from which the added planning steps are built (each action from the set can be added several times)\nV: bounds on the size of a specified set of variables that may be mentioned by the added planning steps\nD: bounds on the size of a specified set of values that may be mentioned by the added planning steps\nWe show that parameterized by L the problem is fixed-parameter intractable even if the additional steps may only be added to the beginning and end of the plan. Parameterized by A the problem is fixed-parameter tractable. Parameterized either by V or D, the problem is fixed-parameter intractable; however, if we combine these two parameters, we achieve fixed-parameter tractability. Combining the restriction L with either V or D is not enough to achieve fixed-parameter tractability.\nWe obtain a full classification as shown in Figure 1. In addition, we show that the same results hold even if we reuse only some “infix” of the stored solution, i.e., if it is allowed to discard any number of actions from the beginning\nand end of the stored solution before the modification takes place. Finally, we prove that in more general settings where we reuse only the syntactical sequence of actions as represented by the stored solution (disregarding the actual states of the stored solution), all the combinations of parameters considered yield fixed-parameter intractability."
    }, {
      "heading" : "Preliminaries",
      "text" : "In this section we introduce basic notions and notation related to (case-based) planning and parameterized complexity, which are used further in the paper.\nPlanning In this study, we use the SAS+ planning framework (Bäckström and Nebel 1996) in the notational variant of Chen and Giménez (2010): An instance of the planning problem, or a planning instance, is a tupleΠ = (V, I,G,A), whose components are described as follows.\n• V is a finite set of variables, where each v ∈ V has an associated finite domain D(v). A state s is a mapping defined on a set V of variables such that s(v) ∈ D(v) for each v ∈ V . A partial state p is a mapping defined on a subset vars(p) of V such that for all v ∈ vars(p) it holds that p(v) ∈ D(v). We sometimes denote a partial state p by a set of explicit mappings { v 7→ p(v) : v ∈ vars(p) }.\n• I is a state called the initial state.\n• G is a partial state called the goal.\n• A is a set of actions; each action a ∈ A is of the form a = (pre(a) ⇒ post(a)), where pre(a) is a partial state called precondition, and post(a) is a partial state called postcondition.\nFor a (partial) state s and a subset W ⊆ V , we let (s ↾ W ) be the (partial) state resulting from restricting s to W . We say that a (partial) state s is a goal state, or that s satisfies the goal, if (s ↾ vars(G)) = G. A plan (for an instance Π) is a sequence of actions p = (a1, . . . , an). The application of a plan p on a state s yields a state s[p], which is defined inductively as follows. The application of an empty plan (p = ǫ) does not change the state (s[ǫ] = s). For a non-empty plan p = (a1, . . . , an), we define s[p] based on the inductively defined state s[p′], where p′ = (a1, . . . , an−1).\n• If (s[p′] ↾ vars(pre(an))) 6= pre(an) then s[p] = s[p′], i.e., if the precondition of an does not hold in s[p′], the action an is not applicable and does not change the state.\n• Otherwise, an is applicable and s[p] is the state equal to post(an) on variables v ∈ vars(post(an)), and equal to s[p′] on v ∈ V \\ vars(post(an)).\nA plan p is a solution plan if I[p] is a goal state. If |D(v)| ≤ 2 for each v ∈ V , then we have a Boolean (or binary) instance, which in fact gives us a notational variant of the STRIPS planning framework (Bylander 1994). Consider the following example instance, that we will use as a running example in the remainder of this paper.\nExample 1. We let Π = (V, I,G,A) be the planning instance defined below. A solution plan for Π would be p = (a3, a1, a2).\nV = {v1, v2, v3}\nD(v1) = {0, 1, 2} D(v2) = D(v3) = {0, 1}\nI = {v1 7→ 0, v2 7→ 0, v3 7→ 0} G = {v1 7→ 2} A = {a1, a2, a3, a4}\na1 = ({v1 7→ 0, v2 7→ 1}, {v1 7→ 1}) a2 = ({v1 7→ 1, v2 7→ 1}, {v1 7→ 2}) a3 = (∅, {v2 7→ 1, v3 7→ 1}) a4 = (∅, {v3 7→ 0})\nCase-Based Planning Case-based planning (CBP) is a type of case-based reasoning that involves the use of stored experiences (called cases) of solving analogous problems. Often, a case is composed of a planning instance Π′ = (V, J,H,A) and a solution plan c of Π′. The plan c can be replaced by some other information related to the search for a solution to Π′, e.g., a set of justifications (Kambhampati and Hendler 1992; Veloso 1994; Hanks and Weld 1995). A plan library, or a case base, is a collection of such cases, constituting the experience of the planner. For more detailed explanation of implementation choices of specific planners we refer to the survey of Spalazzi (2001).\nExample 2. Consider the case (Π′, c), where the planning instanceΠ′ coincides with the instance defined in Example 1 on V,A, and where J = {v1 7→ 0, v2 7→ 1, v3 7→ 0} and H = {v1 7→ 2}. The solution plan c = (a1, a2) can be reused to find the solution p given in Example 1.\nWhen faced with a new problem, the case-based planner follows a sequence of steps common in case-based reasoning (Aamodt and Plaza 1994). First, it queries the library to retrieve cases suitable for reuse. The reuse step modifies the retrieved solution(s) to solve the new problem and such a new solution is validated in the revision phase by execution, simulated execution, etc. The verified solution may be eventually stored in the case base during a retention process.\nIn this paper, we focus on theoretical properties of plan reuse and therefore we skip the retrieval, we simply assume that together with the problem to solve we are also given a case which contains a suitable solution for reuse. In other words, we assume that the instance Π to be solved coincides on the sets V,A with the instance Π′ provided in the case.\nParameterized Complexity Here we introduce the relevant concepts of parameterized complexity theory. For more details, we refer to the works of Downey and Fellows (1999), Downey, Fellows, and Stege (1999), Flum and Grohe (2006), Niedermeier (2006), and Gottlob and Szeider (2006).\nIn the traditional setting of considering the complexity of a problem, the input size n of the instance is the only measure available. Parameterized complexity is a two-dimensional framework to classify the complexity of problems based on their input size n and some additional parameter k. An instance of a parameterized problem is a pair (I, k) where I is the main part of the instance, and k is the parameter. A parameterized problem is fixed-parameter tractable if it can be solved by a fixed-parameter algorithm, i.e., if instances (I, k) can be solved in time O(f(k)nc), where f is a computable function of k, c is a constant, and n is the size of I . FPT denotes the class of all fixed-parameter tractable decision problems. Many problems that are classified as intractable in the classical setting can be shown to be fixed-parameter tractable.\nParameterized complexity also offers a completeness theory, similar to the theory of NP-completeness. This allows the accumulation of strong theoretical evidence that a parameterized problem is not fixed-parameter tractable. Hardness for parameterized complexity classes is based on fpt-reductions, which are many-one reductions where the parameter of one problem maps into the parameter for the other. A parameterized problemL is fpt-reducible to another parameterized problem L′ if there is a mapping R from instances of L to instances of L′ such that (i) (I, k) ∈ L if and only if (I ′, k′) = R(I, k) ∈ L′, (ii) k′ ≤ g(k) for a computable function g, and (iii) R can be computed in time O(f(k)nc) for a computable function f and a constant c, where n is the size of I .\nCentral to the completeness theory is the hierarchy of parameterized complexity classes FPT ⊆ W[1] ⊆ W[2] ⊆ · · · ⊆ W[P] ⊆ para-PSPACE, where all inclusions are believed to be strict. Each of the classes W[t] for t ≥ 1 and W[P] contains all parameterized problems that can be reduced to a certain parameterized satisfiability problem under fpt-reductions. For instance, for W[2], the corresponding satisfiability problem asks whether a given CNF formula has a satisfying assignment that sets exactly k variables to true. A sufficient condition for a problem to be hard for the class para-PSPACE is that the problem is PSPACE-hard for a single value of the parameter (Flum and Grohe 2003). There is strong evidence that a parameterized problem that is hard for any of these intractability classes is not in FPT.\nWe use the following problems to prove some fixed-parameter intractability results.\nPARTITIONED-CLIQUE is a W[1]-complete problem (Fellows et al. 2009). The instances are tuples (V,E, k), where V is a finite set of vertices partitioned into k subsets V1, . . . , Vk , (V,E) is a simple graph, and 1 ≤ k is a parameter. The question is whether there exists a k-clique in (V,E) that contains a vertex in each Vi.\nHITTING-SET is a W[2]-complete problem (Downey and Fellows 1995). The instances are tuples (S,C, k), where S is a finite set of nodes, C is a collection of subsets of S, and 1 ≤ k ≤ |C| is a parameter. The question is whether there exists a hitting set H ⊆ S such that |H | ≤ k and H ∩ c 6= ∅ for all c ∈ C.\np-WSAT(CIRC) (weighted circuit satisfiability) is a W[P]-complete problem (Downey and Fellows 1995). The instances are pairs (C, k), where C is a Boolean circuit, and 1 ≤ k is a parameter. The question is whether there exists a satisfying assignment of C that sets at most k input nodes to true.\nLONGEST-COMMON-SUBSEQUENCE-I is a parameterized problem that is W[t]-hard for all t ≥ 1 (Bodlaender et al. 1995). As input, it takes k strings X1, . . . , Xk over an alphabet Σ, and a positive integer m. The parameter is k. The question is whether there is a string X ∈ Σ∗ of length at least m that is a subsequence of Xi for all 1 ≤ i ≤ k."
    }, {
      "heading" : "Related Work",
      "text" : "The first paper providing a complexity-theoretical study of plan reuse (Nebel and Koehler 1995) considered so-called conservative plan reuse. Conservative plan reuse maximizes the unchanged part of the known solution. The authors showed that such a plan reuse is not provably more efficient than plan generation. Moreover, they show that identifying what is the maximal reusable part of the stored solution is an additional source of hardness.\nLiberatore (2005) studied the problem of plan reuse in a different fashion, interpreting the case (or the case base) as a “hint” that makes the search for the solution plan more informed. The complexity results he provides do not improve over the complexity of uninformed plan generation. He does however give a tractable compilation result for planning instances that differ from the stored instances only in a constant number of valuations from the initial state and goal.\nThe parameterized complexity of planning was first studied by Downey, Fellows, and Stege (1999) and, more recently, by Bäckström et al. (2012, 2013), using the solution length as the parameter. The analysis by Bäckström et al. reveals that the planning problem is W[2]-complete and there exist fragments that are W[1]-complete and other fragments that are fixed-parameter tractable. More specifically, they provide a full classification of SAS+ planning under all combinations of the P, U, B and S restrictions introduced by Bäckström and Klein (1991), and they provide a full classification of STRIPS planning under the syntactical restrictions studied by Bylander (1994)."
    }, {
      "heading" : "Parameterized Complexity of Plan Reuse",
      "text" : "In this paper, we study the parameterized complexity of reusing a plan. However, as this work is motivated by plan reuse in the context of case-based planning, we exploit assumptions common in the case-based approaches to ensure that there is a solution at hand that can be reused. Also, we consider a more specific form of a plan reuse (case reuse) and generalizations thereof.\nReusing the Case In its general form, the classical complexity of plan reuse is not better than the one of plan generation. Liberatore (2005) has shown it to be PSPACE-complete. However, the case-based approach assumes that similar problems have similar solutions (Leake 1996). This means that cases can either be used to yield a solution by applying only a limited number of modifications or will not be helpful at all in finding a solution. When considering the complexity of plan reuse in the classical setting, we cannot exclude the worst case in which the case provides no guidance and where an uninformed search similar to the traditional plan generation is needed. When using the framework of parameterized complexity instead, we can capture the computational complexity of reusing a case in those settings where it can be used to get a solution plan with only a limited amount of modification.\nWe consider a case (Π′, c) useful for solving an instance Π if c can be modified to a solution plan p for Π by means of limited modification. We define the following template CASEMOD for the decision problems, intended to find such useful cases.\nCASEMOD\nInstance: a planning instance Π = (V, I,G,A); a case (Π′, c) consisting of an instance Π′ = (V, J,H,A)1 and its solution plan c = (c1, . . . , cl); a subset of actions A′ ⊆ A; and an integer M .\nQuestion: Does there exist a sequence of actions (g1, . . . , gm) ∈ (A′)m for some m ≤ M , and does there exist some 0 ≤ i ≤ m, such that (g1, . . . , gi, c1, . . . , cl, gi+1, . . . , gm) is a solution plan for Π and I[(g1, . . . , gi)] = J?\nThe sequence g = (g1, . . . , gm) in the definition above can be thought of as the “glue” that enables the reuse of the plan c by connecting the new initial state I to the beginning of the case (Π′, c), using the plan c to reach its goal and connecting it to the goal required by instance Π. In the following, we will often refer to these action occurrences (or steps) as glue steps. Though such a reuse may seem naive, CASEMOD is in fact implemented and used by CBP system FAROFF (Tonidandel and Rillo 2002).\nExample 3. Let Π be the planning instance from Example 1 and (Π′, c) the case from Example 2. Consider the instance for CASEMOD, given by (Π, (Π′, c), A′,M), where A′ = {a3, a4} and M = 3. This is a positive instance, since the solution plan p = (a3, a4, a1, a2) can be constructed from c by adding the sequence of actions (a3, a4) from A′, I[(a3, a4)] = J and |(a3, a4)| ≤ M .\nWe will consider a number of different parameterizations for CASEMOD, where in each case the parameter is intended to capture the assumption that the plan given in the case is similar to the solution we are looking for. In order to define these variants, we define the problems R-CASEMOD, for any subset R of {L,V,D,A}. The choice of the parameterization depends on this set R of restrictions.\n• If R includes L, we add to the parameterization the allowed maximum length of the glue sequence g.\n• If R includes V, we add to the parameterization the number of variables mentioned in the actions in A′.\n• If R includes D, we add to the parameterization the number of values mentioned in the actions in A′.\n• If R includes A, we add to the parameterization the number of actions in A′.\nFor instance, the parameter in the problem {L,A}-CASEMOD is k+ l, where k is the maximum length allowed for the sequence of glue steps and l = |A′|.\nIn order to establish the parameterized complexity landscape for various combinations of these restrictions as sketched in Figure 1, we need to prove the following results. We show that R-CASEMOD is fixed-parameter tractable for R ∈ {{A}, {V,D}}, that it is W[1]-complete for R = {L, V }, that it is W[2]-complete for R ∈ {{L}, {L,D}}, that it is W[t]-hard for all t ≥ 1, for R = {V }, and that it is para-PSPACE-complete for R = {D}. These results are summarized in Table 1.\nThe modification of a plan (or a case) concerns addition of actions to the plan stored in the case. One intuitive way to restrict the amount of modification that is allowed in order to reuse the case is to restrict the number of allowed\n1In the remainder of the paper, we will often specify an instance Π′ in the definition above only by its value of J . Since Π and Π′ coincide on V and A, and the choice of H is not relevant for answering the question, this will suffice for most purposes.\nadditional steps, resulting in the L restriction. It is believed (Kambhampati and Hendler 1992) that the presence of a similar solution, or rather the fact that only k actions need to be added to the stored plan c in order to find the plan p, will make the decision problem of existence of p (and also its generation) easier than if no suitable solution c is available. Unfortunately, the following result shows that the corresponding problem {L}-CASEMOD remains hard.\nProposition 1. {L}-CASEMOD is W[2]-complete.\nProof. The result follows from the W[2]-completeness proof of finding a solution plan of at most k action occurrences (the k-step planning problem) given by Bäckström et al. (2012). They proved that W[2]-hardness already holds for complete goal states. Now, by letting (c, J) = (ǫ,G), the k-step planning problem directly reduces to {L}-CASEMOD.\nTo show W[2]-membership, we sketch the following reduction to the k-step planning problem. We introduce an additional operator (J ∪ {⋆ 7→ 0} ⇒ J [c] ∪ {⋆ 7→ 1}), where ⋆ is a fresh variable. Furthermore, we let {⋆ 7→ 0} ∈ I and {⋆ 7→ 1} ∈ G, and we let k′ = k + 1. It is straightforward to verify that this reduces {L}-CASEMOD to the k′-step planning problem.\nIntuitively, the reason of such a result is that the large number of different actions to choose from is a source of hardness. Bäckström et al. showed that for the k-step planning problem, complexity results can be improved by considering only planning instances whose actions satisfy the condition of post-uniqueness. Similarly, we can require the set of actions A′, from which glue steps can be taken, to be post-unique (Bäckström et al. 2012). This parameterized problem is in fact fixed-parameter tractable (this result follows from Theorem 5 in Bäckström et al. (2012)).\nIn a similar way, parameterizing directly by the cardinality of A′ also provides fixed-parameter tractability:\nTheorem 1. {A}-CASEMOD is in FPT.\nProof. We have that k = |A′|. Then the number of states s′ reachable from any state s by actions from A′ is bounded by a function of k and can be enumerated in fixed-parameter tractable time. Similar bounds hold for all the states s′′ reachable from s′[c] for each such s′. Overall, checking if any of these states s′′ satisfies the goal state can thus be done in fixed-parameter tractable time.\nAs a consequence of Theorem 1, we get another fixed-parameter tractability result.\nCorollary 1. {V,D}-CASEMOD is in FPT.\nProof. If the set A′ of actions refers to at most k variables and at most m values, then the number of different actions that A′ can possibly contain is bounded by (m+ 1)2k. The result then follows from Theorem 1.\nThe fact that the above results are the only fixed-parameter tractable results under the considered restrictions suggests that plan reuse is not the answer to the high computational complexity of planning in general. However, we can use these results to identify settings in which plan reuse is likely to perform well. For example, Theorem 1 suggests that replanning in case of an execution failure is tractable to implement as plan reuse, provided that the number of applicable actions is limited due to, e.g., limited resources.\nThese results for plan reuse as implemented in case-based planning are quite unpleasant as in such settings usually A = A′. Additionally, |A| tends to be quite high, as the set of actions is obtained by grounding a set of (few) operators (propositional implication rules) over a set of potentially many objects, giving a rise to a rich set of actions which only very rarely satisfies the condition of post-uniqueness to make {L}-CASEMOD fixed-parameter tractable. Nevertheless, these claims suggest that, besides identifying where to apply the glue steps, a case-based planning system needs to employ heuristics to identify which glue steps may be useful. Even though {V,D}-CASEMOD is in FPT, parameterizing only on the number of variables occurring in actions in A′, or only on the number of values occurring in actions in A′, yields fixed-parameter intractability.\nTheorem 2. {V}-CASEMOD is W[t]-hard for all t ≥ 1.\nProof. We prove the result by giving an fpt-reduction from LONGEST-COMMON-SUBSEQUENCE-I, which is W[t]hard for all t ≥ 1. Let the strings X1, . . . , Xk over the alphabet Σ and the integer m constitute an instance of\nLONGEST-COMMON-SUBSEQUENCE-I. For a string X of length l we write X [0]. . .X [l − 1]. For each Xi we let li = |Xi|. We construct an instance of {V}-CASEMOD specified by Π = (V, I,G,A), (c, J), A′ and M . We let (c, J) = (ǫ,G), A′ = A and M be a sufficiently large number (that is, M ≥ ∑\n1≤i≤k |Xi| + (k + 1)m + k). Also, we define:\nV = {v1, . . . , vk, s1, . . . , sk, t1, . . . , tk, w}; D(vi) = {0, . . . , li}; D(si) = Σ ∪ {⋆}; D(ti) = {none, read, used}; D(w) = {0, . . . ,m};\nA = Askip ∪ Aread ∪Acheck ∪ Afinish; Askip = { ({vi 7→ u, ti 7→ none} ⇒ {vi 7→ u+ 1,\nti 7→ none}), ({vi 7→ u, ti 7→ used} ⇒ {vi 7→ u+ 1, ti 7→ none}) : 1 ≤ i ≤ k, 0 ≤ u < li };\nAread = { ({vi 7→ u, ti 7→ none} ⇒ {si 7→ Xi[u], ti 7→ read}) : 1 ≤ i ≤ k, 0 ≤ u < li };\nAcheck = { ({t1 7→ read, . . . , tk 7→ read, s1 7→ σ, . . . , sk 7→ σ,w = u} ⇒ {t1 7→ used, . . . , tk 7→ used, w 7→ u+ 1}) : 0 ≤ u < m, σ ∈ Σ }; Afinish = { ({vi 7→ li} ⇒ {ti 7→ none, si 7→ ⋆}) : 1 ≤ i ≤ k };\nI = { vi 7→ 0, si 7→ ⋆, ti 7→ none : 1 ≤ i ≤ k } ∪ {w 7→ 0}; and\nG = { vi 7→ li, si 7→ ⋆, ti 7→ none : 1 ≤ i ≤ k } ∪ {w 7→ m}.\nNote that |V | = 3k + 1. The idea behind the reduction is that any solution plan that results in an assignment of variable w to any d ≥ 1 corresponds to a witness that the strings X1, . . . , Xk have a common subsequence of length d. The variables v1, . . . , vk correspond to the position of reading heads on the strings that can only move from left to right, and the variables s1, . . . , sk are used to read symbols in the string on the position of the reading heads. The variables t1, . . . , tk are used to ensure that each symbol is read at most once (each symbol is either read by using an action in Aread or skipped by using an action in Askip). Then the variable w can only be increased if in all strings the same symbol is read (by using an action in Acheck). The actions Afinish are used to be able to enforce a complete goal state.\nIt is now straightforward to verify that there exists a common subsequence X for X1, . . . , Xk of length m if and only if the constructed instance is a yes-instance.\nAs mentioned above in the preliminaries, if we restrict the planning instances to Boolean values, we get a framework corresponding to the STRIPS planning framework. By the fact that {V,D}-CASEMOD is fixed-parameter tractable, we get that {V}-CASEMOD for STRIPS instances is also fixed-parameter tractable.\nBy naively keeping track of all states reachable from the initial state (which are at most nk many, for n = |D| and k = |V |) we get that {V}-CASEMOD can be solved in polynomial time for each constant value of k. As a consequence, the following theorem shows that {D}-CASEMOD is of higher complexity than {V}-CASEMOD (unless P = PSPACE).\nTheorem 3. {D}-CASEMOD is para-PSPACE-complete.\nProof. The para-PSPACE-membership result follows from the fact that {D}-CASEMOD, when unparameterized, is in PSPACE (Bäckström and Nebel 1996).\nFor the hardness result, consider the case where the number k of values allowed in the set of actions A′ is 2. The problem then reduces to the problem of finding a solution plan for the Boolean planning instance Π, in case we let (c, J) = (ǫ,G). Bäckström and Nebel (1996) showed that finding a solution plan for Boolean planning instances\n(even for complete goal states) is PSPACE-hard. Since this hardness result holds already for a single value of k, the para-PSPACE-hardness result follows (Flum and Grohe 2003).\nParameterizing on the combination of the number of allowed additional steps together with either the number of variables or the number of values occurring in actions in A′ is not enough to ensure fixed-parameter tractability.\nTheorem 4. {L,V}-CASEMOD is W[1]-complete.\nProof. W[1]-membership can be proven analogously to the W[1]-membership proof given by Bäckström et al. (2012, Theorem 4) for the k-step planning problem restricted to actions with one postcondition. In this proof the problem is reduced to a certain first-order model checking problem.\nFor the hardness result, we reduce from the W[1]-complete problem PARTITIONED-CLIQUE. Let (V,E, k) be an instance of PARTITIONED-CLIQUE, where V is partitioned into V1, . . . , Vk. We define the instance (Π, (Π′, c), A′, k′) of {L,V}-CASEMOD as follows: Π = (W, I,G,A), Π′ is specified by its initial state J , (c, J) = (ǫ,G), k′ = 2k+ (\nk 2\n)\nand A′ = A. We define: W = {x1, . . . , xk} ∪ { yi,j : 1 ≤ i < j ≤ k };\nD(xi) = Vi ∪ {⋆} for all xi (and arbitrary ⋆ 6∈ V ); D(yi,j) = {0, 1} for all yi,j ;\nA = { guessid, clear i d : 1 ≤ i ≤ k, d ∈ Vi } ∪\n{ checkv,wi,j : 1 ≤ i < j ≤ k, v ∈ Vi,\nw ∈ Vj , {v, w} ∈ E }; guessid = (∅ ⇒ {xi 7→ d}), for each guess i d;\nclearid = (∅ ⇒ {xi 7→ ⋆}), for each clear i d;\ncheckv,wi,j = ({xi 7→ v, xj 7→ w} ⇒ {yi,j 7→ 1}), for each checkv,wi,j ;\nI = { xi 7→ ⋆ : 1 ≤ i ≤ k } ∪ { yi,j 7→ 0 : 1 ≤ i < j ≤ k }; and\nG = { xi 7→ ⋆ : 1 ≤ i ≤ k } ∪ { yi,j 7→ 1 : 1 ≤ i < j ≤ k }.\nThe intuition behind the reduction is as follows. The budget of k′ actions allows for k guessing steps, to set the variables xi using actions guessid; ( k 2 ) verification steps, to set the variables yi,j to 1 using actions check v,w i,j ; and k cleanup steps, to reset the variables xi using actions clear i d. The only way to achieve the goal state is by guessing a k-clique. It is now straightforward to verify that the graph (V,E) has a k-clique if and only if there exist plans p, p′ of total length k′ such that I[p] = J and J [c][p′] satisfies G.\nCorollary 2. {L,D}-CASEMOD is W[2]-complete.\nProof. The claim follows directly from the proof of Proposition 1, since k-step planning is W[2]-complete already for Boolean planning instances (Bäckström et al. 2012).\nThe above results together give us the complete parameterized complexity characterization as depicted in Figure 1.\nReusing an infix of the case As a slight generalization of the CASEMOD problem, we consider the problem CASEMOD⋆. In this problem, we require not that the full plan c from the case is being reused together with its initial state J , but that any infix c′ of the plan (i.e., any subplan c′ resulting from removing any prefix and postfix from c) is reused with its corresponding initial state J ′. Formally, the question becomes whether there exists a sequence of actions (g1, . . . , gm) ∈ (A′)m for some m ≤ M , and whether there exists some 0 ≤ i ≤ m and some 1 ≤ i1 ≤ i2 ≤ l such that (g1, . . . , gi, ci1 , . . . , ci2 , gi+1, . . . , gm) solves the new planning instance Π and I[(g1, . . . , gi)] = J [(c1, . . . , ci1−1)], where c = (c1, . . . , cl).\nThe following results show that this generalization does not change the parameterized complexity results that we obtained in the previous section.\nObservation 1. Whenever R-CASEMOD is in FPT, then also R-CASEMOD⋆ is in FPT.\nProof. Let c = (c1, . . . , cn) ∈ An. There are only n2 different ways of selecting subplans (cd, . . . , ce) to consider, for 1 ≤ d ≤ e ≤ n. For each of these, we can compute the initial state J [(c1, . . . , cd−1] in linear time. Simply trying all these n2 possibilities using the algorithm for R-CASEMOD results in an fixed-parameter tractable algorithm for R-CASEMOD⋆.\nTheorem 5. The completeness results in Proposition 1, Theorems 2, 3 and 4 and Corollary 2 also hold for the corresponding variants for R-CASEMOD⋆.\nProof (sketch). For the hardness results, it suffices to note that the hardness proofs of these theorems use a case containing the empty plan ǫ.\nFor the membership results, we note that the R-CASEMOD⋆ problem can be solved by answering the disjunction of polynomially many (independent) R-CASEMOD instances. The W[t]-membership results can then be proved by encoding the R-CASEMOD instances as instances of certain first-order model checking problems (Bäckström et al. 2012), and combining these into one model checking problem instance that is equivalent to the disjunction of the separate R-CASEMOD instances. For the para-PSPACE-membership result, we can straightforwardly evaluate the disjunction of the R-CASEMOD instances in polynomial space.\nGeneralized infix reuse The problem of CASEMOD can be generalized even further by reusing an infix of the stored solution plan c from any state that satisfies the preconditions of the plan infix. For this problem, the instances coincide with those of CASEMOD, but the question is:\nQuestion: Does there exist a sequence of actions (g1, . . . , gm) ∈ (A′)m for some m ≤ M , and does there exist 0 ≤ i ≤ m and 0 ≤ i1 ≤ i2 ≤ l such that (g1, . . . , gi, ci1 , . . . , ci2 , gi+1, . . . , gm) is a solution plan for Π and for all i1 ≤ j ≤ i2 we have that action cj is applicable in I[(g1, . . . , gi, ci1 , . . . , cj−1)]?\nThis generalization does not change the parameterized complexity results stated in Table 1. In all cases whereR-CASEMOD is fixed-parameter tractable, we can obtain a fixed-parameter tractable algorithm to solve the above problem, since in those cases we can enumerate all states reachable from a given state in fixed-parameter tractable time. For the fixed-parameter intractability results, the hardness follows straightforwardly from the hardness proofs for the corresponding R-CASEMOD problems.\nReusing a sequence of actions In principle, there is no need to require anything from the state to which the stored plan is applied. Therefore we will consider the following generalization of the CASEMOD problems discussed above. In this problem, denoted by PLANMOD, we remove the requirement that the additional steps added before the plan c result in the initial state J or some other state that satisfies the preconditions of (the infix of) the plan c. Also, we allow the insertion of additional steps in the middle of the plan c. Formally, the question then becomes whether there exists some m ≤ k, a sequence of actions g = (g1, . . . , gm) ∈ Am, and some sequence of actions p = (p1, . . . , pl+m) such that p is a solution plan of Π and p can be divided into two subsequences c and g, i.e., interleaving c and g yields p. In other words, the additional steps g can be used anywhere before, after or in the middle of the plan c. Since we do not restrict ourselves to any particular state being visited in our solution plan, the actions in the glue sequence g can be used anywhere before, after or in the middle of the plan c. Similarly to the case for CASEMOD, we define the variants PLANMOD⋆, R-PLANMOD and R-PLANMOD⋆. In the following, we show that all variants of PLANMOD are fixed-parameter intractable.\nTheorem 6. {L,V,D,A}-PLANMOD is W[P]-complete.\nProof (sketch). For W[P]-membership, we sketch how to reduce {L,V,D,A}-PLANMOD to the problem of determining whether a nondeterministic Turing machine T accepts the empty string within a bounded number of steps using at most k′ nondeterministic steps (parameterized by k′). Since this parameterized halting problem is in W[P] (Cesati 2003), this suffices to show W[P]-membership. First T guesses k pairs (mi, ai), for 0 ≤ mi ≤ |c| and ai ∈ A′. Pair (m1, a1) corresponds to the application of the first m1 actions from the given plan c, followed by the application\nof action ai. Similarly, for each i > 1, pair (mi, ai) corresponds to the application of the next mi actions from the given plan c, followed by the application of action ai. Then T (deterministically) verifies whether applying the plan corresponding to (m1, ai), . . . , (mk, ak) is a solution plan.\nTo prove W[P]-hardness, we reduce from p-WSAT(CIRC). Let C be a circuit for which we want to check whether there exists a satisfying assignment of weight at most k. Let x1, . . . , xn be the input nodes, y1, . . . , ym the internal nodes, and z the output node of C, together denoted nodes(C). We assume without loss of generality that C contains only AND and NEGATION nodes. Since C is acyclic, we let the sequence (g1, . . . , gl) denote the nodes of C in any order such that for each gi we have that j < i for all input nodes gj of gi. We construct an instance of {L,V,D,A}-PLANMOD consisting of a planning instance Π = (V, I,G,A), a plan c, and an integer k′. We let k′ = k, and we define:\nV = nodes(C) ∪ {σ}; D(v) = {0, 1} for all v ∈ V ;\nI = { v 7→ 0 : v ∈ V }; G = {z 7→ 1}; A = {ax1, . . . , axn} ∪ {aon, aoff} ∪ {ag1 , . . . , agl}; A′ = {aon}; axi = ({σ 7→ 1} ⇒ {xi 7→ 1}) for each xi; aon = (∅ ⇒ {σ 7→ 1}); aoff = (∅ ⇒ {σ 7→ 0}); and c = (aoff, ax1 , aoff, ax2 , . . . , aoff, axn , ag1 , . . . , agl).\nWe define agi for each gi as follows. If gi is a NEGATION node with input y, we let agi = ({y 7→ 0} ⇒ {gi 7→ 1}). If gi is an AND node with inputs y1, . . . , yu, we let agi = ({y1 7→ 1, . . . , yu 7→ 1} ⇒ {gi 7→ 1}).\nIt is now straightforward to verify that (Π, c, k′) is a yes-instance of {L,V,D,A}-PLANMOD if and only if the circuit C has a satisfying assignment of weight k.\nNote that the proof of the above theorem suffices to show fixed-parameter intractability of all variants of the PLANMOD and PLANMOD⋆ problems. We also point out that this fixed-parameter intractability result holds even when the problem is restricted to instances for which the entire set A of actions satisfies post-uniqueness."
    }, {
      "heading" : "Conclusion",
      "text" : "We provided theoretical results, using the framework of parameterized complexity, to identify situations in which plan reuse is provably tractable. We drew a detailed map of the parameterized complexity landscape of several variants of problems that arise in the context of case-based planning. In particular, we considered the problem of reusing an existing plan, imposing various restrictions in terms of parameters, such as the number of steps that can be added to the existing plan to turn it into a solution of the planning instance at hand.\nThe results show that contrary to the common belief, the fact that the number of modifying actions is small does not guarantee tractability on its own. We additionally need to restrict the set of actions that can participate in the modifications. This indicates the need for a good heuristic function that identifies a limited set of actions used for modifications.\nIn the future, these results may be extended to richer planning formalisms, e.g., considering variables of different types or using predicates to express certain properties related to a planning domain rather than planning instance."
    } ],
    "references" : [ {
      "title" : "Case-based reasoning: foundational issues, methodological variations, and system approaches",
      "author" : [ "A. Aamodt", "E. Plaza" ],
      "venue" : "AI Communications 7(1):39–59.",
      "citeRegEx" : "Aamodt and Plaza,? 1994",
      "shortCiteRegEx" : "Aamodt and Plaza",
      "year" : 1994
    }, {
      "title" : "Planning in polynomial time: the SAS-PUBS class",
      "author" : [ "C. Bäckström", "I. Klein" ],
      "venue" : "Computational Intelligence 7:181–197.",
      "citeRegEx" : "Bäckström and Klein,? 1991",
      "shortCiteRegEx" : "Bäckström and Klein",
      "year" : 1991
    }, {
      "title" : "Complexity results for SAS+ planning",
      "author" : [ "C. Bäckström", "B. Nebel" ],
      "venue" : "Computational Intelligence 11:625–655.",
      "citeRegEx" : "Bäckström and Nebel,? 1996",
      "shortCiteRegEx" : "Bäckström and Nebel",
      "year" : 1996
    }, {
      "title" : "The complexity of planning revisited - a parameterized analysis",
      "author" : [ "C. Bäckström", "Y. Chen", "P. Jonsson", "S. Ordyniak", "S. Szeider" ],
      "venue" : "Twenty-Sixth AAAI Conference on Artificial Intelligence.",
      "citeRegEx" : "Bäckström et al\\.,? 2012",
      "shortCiteRegEx" : "Bäckström et al\\.",
      "year" : 2012
    }, {
      "title" : "Parameterized complexity and kernel bounds for hard planning problems",
      "author" : [ "C. Bäckström", "P. Jonsson", "S. Ordyniak", "S. Szeider" ],
      "venue" : "Spirakis, P., and Serna, M., eds., Algorithms and Complexity (CIAC 2013), volume 7878 of Lecture Notes in Computer Science.",
      "citeRegEx" : "Bäckström et al\\.,? 2013",
      "shortCiteRegEx" : "Bäckström et al\\.",
      "year" : 2013
    }, {
      "title" : "The parameterized complexity of sequence alignment and consensus",
      "author" : [ "H.L. Bodlaender", "R.G. Downey", "M.R. Fellows", "H.T. Wareham" ],
      "venue" : "Theoretical Computer Science 147:31–54.",
      "citeRegEx" : "Bodlaender et al\\.,? 1995",
      "shortCiteRegEx" : "Bodlaender et al\\.",
      "year" : 1995
    }, {
      "title" : "The computational complexity of propositional STRIPS planning",
      "author" : [ "T. Bylander" ],
      "venue" : "Artificial Intelligence 69:165– 204.",
      "citeRegEx" : "Bylander,? 1994",
      "shortCiteRegEx" : "Bylander",
      "year" : 1994
    }, {
      "title" : "The Turing way to parameterized complexity",
      "author" : [ "M. Cesati" ],
      "venue" : "Journal of Computer and System Sciences 67:654–685.",
      "citeRegEx" : "Cesati,? 2003",
      "shortCiteRegEx" : "Cesati",
      "year" : 2003
    }, {
      "title" : "Causal graphs and structurally restricted planning",
      "author" : [ "H. Chen", "O. Giménez" ],
      "venue" : "Journal of Computer and System Sciences 76(7):579–592.",
      "citeRegEx" : "Chen and Giménez,? 2010",
      "shortCiteRegEx" : "Chen and Giménez",
      "year" : 2010
    }, {
      "title" : "Fixed-parameter tractability and completeness I: Basic results",
      "author" : [ "R.G. Downey", "M.R. Fellows" ],
      "venue" : "SIAM J. Comput. 24(4):873–921.",
      "citeRegEx" : "Downey and Fellows,? 1995",
      "shortCiteRegEx" : "Downey and Fellows",
      "year" : 1995
    }, {
      "title" : "Parameterized Complexity",
      "author" : [ "R.G. Downey", "M.R. Fellows" ],
      "venue" : "Monographs in Computer Science. New York: Springer Verlag.",
      "citeRegEx" : "Downey and Fellows,? 1999",
      "shortCiteRegEx" : "Downey and Fellows",
      "year" : 1999
    }, {
      "title" : "Parameterized complexity: A framework for systematically confronting computational intractability",
      "author" : [ "R. Downey", "M.R. Fellows", "U. Stege" ],
      "venue" : "Contemporary Trends in Discrete Mathematics: From DIMACS and DIMATIA to the Future, volume 49 of AMS-DIMACS, 49–99. American Mathematical Society.",
      "citeRegEx" : "Downey et al\\.,? 1999",
      "shortCiteRegEx" : "Downey et al\\.",
      "year" : 1999
    }, {
      "title" : "On the parameterized complexity of multipleinterval graph problems",
      "author" : [ "M.R. Fellows", "D. Hermelin", "F.A. Rosamond", "S. Vialette" ],
      "venue" : "Theoretical Computer Science 410(1):53–61.",
      "citeRegEx" : "Fellows et al\\.,? 2009",
      "shortCiteRegEx" : "Fellows et al\\.",
      "year" : 2009
    }, {
      "title" : "Describing parameterized complexity classes",
      "author" : [ "J. Flum", "M. Grohe" ],
      "venue" : "Information and Computation 187(2):291–319.",
      "citeRegEx" : "Flum and Grohe,? 2003",
      "shortCiteRegEx" : "Flum and Grohe",
      "year" : 2003
    }, {
      "title" : "Parameterized Complexity Theory, volume XIV of Texts in Theoretical Computer Science",
      "author" : [ "J. Flum", "M. Grohe" ],
      "venue" : "An EATCS Series. Berlin: Springer Verlag.",
      "citeRegEx" : "Flum and Grohe,? 2006",
      "shortCiteRegEx" : "Flum and Grohe",
      "year" : 2006
    }, {
      "title" : "Automated Planning: Theory & Practice",
      "author" : [ "M. Ghallab", "D. Nau", "P. Traverso" ],
      "venue" : "Morgan Kaufmann.",
      "citeRegEx" : "Ghallab et al\\.,? 2004",
      "shortCiteRegEx" : "Ghallab et al\\.",
      "year" : 2004
    }, {
      "title" : "Fixed-parameter algorithms for artificial intelligence, constraint satisfaction, and database problems",
      "author" : [ "G. Gottlob", "S. Szeider" ],
      "venue" : "The Computer Journal 51(3):303–325. Survey paper.",
      "citeRegEx" : "Gottlob and Szeider,? 2006",
      "shortCiteRegEx" : "Gottlob and Szeider",
      "year" : 2006
    }, {
      "title" : "A domain-independent algorithm for plan adaptation",
      "author" : [ "S. Hanks", "D. Weld" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR) 2:319–360.",
      "citeRegEx" : "Hanks and Weld,? 1995",
      "shortCiteRegEx" : "Hanks and Weld",
      "year" : 1995
    }, {
      "title" : "The fast downward planning system",
      "author" : [ "M. Helmert" ],
      "venue" : "Journal of Artificial Intelligence Research 26(1):191–246.",
      "citeRegEx" : "Helmert,? 2006",
      "shortCiteRegEx" : "Helmert",
      "year" : 2006
    }, {
      "title" : "Ff: The fast-forward planning system",
      "author" : [ "J. Hoffmann" ],
      "venue" : "AI magazine 22(3):57.",
      "citeRegEx" : "Hoffmann,? 2001",
      "shortCiteRegEx" : "Hoffmann",
      "year" : 2001
    }, {
      "title" : "A validation-structure-based theory of plan modification and reuse",
      "author" : [ "S. Kambhampati", "J.A. Hendler" ],
      "venue" : "Artificial Intelligence 55:193–258.",
      "citeRegEx" : "Kambhampati and Hendler,? 1992",
      "shortCiteRegEx" : "Kambhampati and Hendler",
      "year" : 1992
    }, {
      "title" : "On the complexity of case-based planning",
      "author" : [ "P. Liberatore" ],
      "venue" : "Journal of Experimental & Theoretical Artificial Intelligence 17(3):283–295.",
      "citeRegEx" : "Liberatore,? 2005",
      "shortCiteRegEx" : "Liberatore",
      "year" : 2005
    }, {
      "title" : "Plan reuse versus plan generation: A complexity-theoretic perspective",
      "author" : [ "B. Nebel", "J. Koehler" ],
      "venue" : "Artificial Intelligence- Special Issue on Planning and Scheduling 76:427–454.",
      "citeRegEx" : "Nebel and Koehler,? 1995",
      "shortCiteRegEx" : "Nebel and Koehler",
      "year" : 1995
    }, {
      "title" : "Invitation to Fixed-Parameter Algorithms",
      "author" : [ "R. Niedermeier" ],
      "venue" : "Oxford Lecture Series in Mathematics and its Applications. Oxford: Oxford University Press.",
      "citeRegEx" : "Niedermeier,? 2006",
      "shortCiteRegEx" : "Niedermeier",
      "year" : 2006
    }, {
      "title" : "A survey on case-based planning",
      "author" : [ "L. Spalazzi" ],
      "venue" : "Artificial Intelligence Review 16(1):3–36.",
      "citeRegEx" : "Spalazzi,? 2001",
      "shortCiteRegEx" : "Spalazzi",
      "year" : 2001
    }, {
      "title" : "The FAR-OFF system: A heuristic search case-based planning",
      "author" : [ "F. Tonidandel", "M. Rillo" ],
      "venue" : "Ghallab, M.; Hertzberg, J.; and Traverso, P., eds., AIPS, 302–311. AAAI.",
      "citeRegEx" : "Tonidandel and Rillo,? 2002",
      "shortCiteRegEx" : "Tonidandel and Rillo",
      "year" : 2002
    }, {
      "title" : "Planning and Learning by Analogical Reasoning, volume 886 of Lecture Notes in Artificial Intelligence and Lecture Notes in Computer Science",
      "author" : [ "M. Veloso" ],
      "venue" : "New York, USA: Springer-Verlag Inc.",
      "citeRegEx" : "Veloso,? 1994",
      "shortCiteRegEx" : "Veloso",
      "year" : 1994
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "For instance, deciding whether there exists a plan for a given planning instance is PSPACE-complete, and the problem remains at least NP-hard under various restrictions (Bylander 1994).",
      "startOffset" : 169,
      "endOffset" : 184
    }, {
      "referenceID" : 19,
      "context" : "To overcome this high worst-case complexity, various heuristics, restrictions, and relaxations of planning problems have been developed that work surprisingly well in practical settings (Hoffmann 2001; Helmert 2006).",
      "startOffset" : 186,
      "endOffset" : 215
    }, {
      "referenceID" : 18,
      "context" : "To overcome this high worst-case complexity, various heuristics, restrictions, and relaxations of planning problems have been developed that work surprisingly well in practical settings (Hoffmann 2001; Helmert 2006).",
      "startOffset" : 186,
      "endOffset" : 215
    }, {
      "referenceID" : 20,
      "context" : "Among the heuristic approaches is case-based planning, which proceeds from the idea that significant planning efforts may be saved by reusing previous solutions (Kambhampati and Hendler 1992; Veloso 1994).",
      "startOffset" : 161,
      "endOffset" : 204
    }, {
      "referenceID" : 26,
      "context" : "Among the heuristic approaches is case-based planning, which proceeds from the idea that significant planning efforts may be saved by reusing previous solutions (Kambhampati and Hendler 1992; Veloso 1994).",
      "startOffset" : 161,
      "endOffset" : 204
    }, {
      "referenceID" : 6,
      "context" : "For instance, deciding whether there exists a plan for a given planning instance is PSPACE-complete, and the problem remains at least NP-hard under various restrictions (Bylander 1994). To overcome this high worst-case complexity, various heuristics, restrictions, and relaxations of planning problems have been developed that work surprisingly well in practical settings (Hoffmann 2001; Helmert 2006). Among the heuristic approaches is case-based planning, which proceeds from the idea that significant planning efforts may be saved by reusing previous solutions (Kambhampati and Hendler 1992; Veloso 1994). This approach is based on the assumption that planning tasks tend to recur and that if the tasks are similar, then so are their solutions. Empirical evidence suggests that this assumption holds in many settings, and that the case-based approach works particularly well if the planning tasks require complex solutions while the modifications required on the known plans are considerably small. So far the research on the worst-case complexity of case-based planning did not take into account the essential assumption that similar planning tasks require similar solutions. Indeed, as shown by Liberatore (2005), if none of the known solutions are helpful, then the case-based system needs to invest an effort comparable to generating the solution from scratch, and hence does not benefit from the previous experience.",
      "startOffset" : 170,
      "endOffset" : 1218
    }, {
      "referenceID" : 23,
      "context" : "We perform our analysis in the framework of parameterized complexity, which supports a rigorous worst-case complexity analysis that takes structural properties of the input into account (Downey, Fellows, and Stege 1999; Niedermeier 2006; Gottlob and Szeider 2006).",
      "startOffset" : 186,
      "endOffset" : 263
    }, {
      "referenceID" : 16,
      "context" : "We perform our analysis in the framework of parameterized complexity, which supports a rigorous worst-case complexity analysis that takes structural properties of the input into account (Downey, Fellows, and Stege 1999; Niedermeier 2006; Gottlob and Szeider 2006).",
      "startOffset" : 186,
      "endOffset" : 263
    }, {
      "referenceID" : 2,
      "context" : "Planning In this study, we use the SAS+ planning framework (Bäckström and Nebel 1996) in the notational variant of Chen and Giménez (2010): An instance of the planning problem, or a planning instance, is a tupleΠ = (V, I,G,A), whose components are described as follows.",
      "startOffset" : 59,
      "endOffset" : 85
    }, {
      "referenceID" : 2,
      "context" : "Planning In this study, we use the SAS+ planning framework (Bäckström and Nebel 1996) in the notational variant of Chen and Giménez (2010): An instance of the planning problem, or a planning instance, is a tupleΠ = (V, I,G,A), whose components are described as follows.",
      "startOffset" : 60,
      "endOffset" : 139
    }, {
      "referenceID" : 6,
      "context" : "If |D(v)| ≤ 2 for each v ∈ V , then we have a Boolean (or binary) instance, which in fact gives us a notational variant of the STRIPS planning framework (Bylander 1994).",
      "startOffset" : 153,
      "endOffset" : 168
    }, {
      "referenceID" : 20,
      "context" : ", a set of justifications (Kambhampati and Hendler 1992; Veloso 1994; Hanks and Weld 1995).",
      "startOffset" : 26,
      "endOffset" : 90
    }, {
      "referenceID" : 26,
      "context" : ", a set of justifications (Kambhampati and Hendler 1992; Veloso 1994; Hanks and Weld 1995).",
      "startOffset" : 26,
      "endOffset" : 90
    }, {
      "referenceID" : 17,
      "context" : ", a set of justifications (Kambhampati and Hendler 1992; Veloso 1994; Hanks and Weld 1995).",
      "startOffset" : 26,
      "endOffset" : 90
    }, {
      "referenceID" : 17,
      "context" : ", a set of justifications (Kambhampati and Hendler 1992; Veloso 1994; Hanks and Weld 1995). A plan library, or a case base, is a collection of such cases, constituting the experience of the planner. For more detailed explanation of implementation choices of specific planners we refer to the survey of Spalazzi (2001).",
      "startOffset" : 70,
      "endOffset" : 318
    }, {
      "referenceID" : 0,
      "context" : "When faced with a new problem, the case-based planner follows a sequence of steps common in case-based reasoning (Aamodt and Plaza 1994).",
      "startOffset" : 113,
      "endOffset" : 136
    }, {
      "referenceID" : 13,
      "context" : "A sufficient condition for a problem to be hard for the class para-PSPACE is that the problem is PSPACE-hard for a single value of the parameter (Flum and Grohe 2003).",
      "startOffset" : 145,
      "endOffset" : 166
    }, {
      "referenceID" : 9,
      "context" : "For more details, we refer to the works of Downey and Fellows (1999), Downey, Fellows, and Stege (1999), Flum and Grohe (2006), Niedermeier (2006), and Gottlob and Szeider (2006).",
      "startOffset" : 43,
      "endOffset" : 69
    }, {
      "referenceID" : 9,
      "context" : "For more details, we refer to the works of Downey and Fellows (1999), Downey, Fellows, and Stege (1999), Flum and Grohe (2006), Niedermeier (2006), and Gottlob and Szeider (2006).",
      "startOffset" : 43,
      "endOffset" : 104
    }, {
      "referenceID" : 9,
      "context" : "For more details, we refer to the works of Downey and Fellows (1999), Downey, Fellows, and Stege (1999), Flum and Grohe (2006), Niedermeier (2006), and Gottlob and Szeider (2006).",
      "startOffset" : 43,
      "endOffset" : 127
    }, {
      "referenceID" : 9,
      "context" : "For more details, we refer to the works of Downey and Fellows (1999), Downey, Fellows, and Stege (1999), Flum and Grohe (2006), Niedermeier (2006), and Gottlob and Szeider (2006).",
      "startOffset" : 43,
      "endOffset" : 147
    }, {
      "referenceID" : 9,
      "context" : "For more details, we refer to the works of Downey and Fellows (1999), Downey, Fellows, and Stege (1999), Flum and Grohe (2006), Niedermeier (2006), and Gottlob and Szeider (2006). In the traditional setting of considering the complexity of a problem, the input size n of the instance is the only measure available.",
      "startOffset" : 43,
      "endOffset" : 179
    }, {
      "referenceID" : 12,
      "context" : "PARTITIONED-CLIQUE is a W[1]-complete problem (Fellows et al. 2009).",
      "startOffset" : 46,
      "endOffset" : 67
    }, {
      "referenceID" : 9,
      "context" : "HITTING-SET is a W[2]-complete problem (Downey and Fellows 1995).",
      "startOffset" : 39,
      "endOffset" : 64
    }, {
      "referenceID" : 9,
      "context" : "p-WSAT(CIRC) (weighted circuit satisfiability) is a W[P]-complete problem (Downey and Fellows 1995).",
      "startOffset" : 74,
      "endOffset" : 99
    }, {
      "referenceID" : 5,
      "context" : "LONGEST-COMMON-SUBSEQUENCE-I is a parameterized problem that is W[t]-hard for all t ≥ 1 (Bodlaender et al. 1995).",
      "startOffset" : 88,
      "endOffset" : 112
    }, {
      "referenceID" : 22,
      "context" : "The first paper providing a complexity-theoretical study of plan reuse (Nebel and Koehler 1995) considered so-called conservative plan reuse.",
      "startOffset" : 71,
      "endOffset" : 95
    }, {
      "referenceID" : 17,
      "context" : "Liberatore (2005) studied the problem of plan reuse in a different fashion, interpreting the case (or the case base) as a “hint” that makes the search for the solution plan more informed.",
      "startOffset" : 0,
      "endOffset" : 18
    }, {
      "referenceID" : 17,
      "context" : "Liberatore (2005) studied the problem of plan reuse in a different fashion, interpreting the case (or the case base) as a “hint” that makes the search for the solution plan more informed. The complexity results he provides do not improve over the complexity of uninformed plan generation. He does however give a tractable compilation result for planning instances that differ from the stored instances only in a constant number of valuations from the initial state and goal. The parameterized complexity of planning was first studied by Downey, Fellows, and Stege (1999) and, more recently, by Bäckström et al.",
      "startOffset" : 0,
      "endOffset" : 571
    }, {
      "referenceID" : 1,
      "context" : "More specifically, they provide a full classification of SAS+ planning under all combinations of the P, U, B and S restrictions introduced by Bäckström and Klein (1991), and they provide a full classification of STRIPS planning under the syntactical restrictions studied by Bylander (1994).",
      "startOffset" : 142,
      "endOffset" : 169
    }, {
      "referenceID" : 1,
      "context" : "More specifically, they provide a full classification of SAS+ planning under all combinations of the P, U, B and S restrictions introduced by Bäckström and Klein (1991), and they provide a full classification of STRIPS planning under the syntactical restrictions studied by Bylander (1994).",
      "startOffset" : 142,
      "endOffset" : 290
    }, {
      "referenceID" : 21,
      "context" : "Liberatore (2005) has shown it to be PSPACE-complete.",
      "startOffset" : 0,
      "endOffset" : 18
    }, {
      "referenceID" : 25,
      "context" : "Though such a reuse may seem naive, CASEMOD is in fact implemented and used by CBP system FAROFF (Tonidandel and Rillo 2002).",
      "startOffset" : 97,
      "endOffset" : 124
    }, {
      "referenceID" : 20,
      "context" : "It is believed (Kambhampati and Hendler 1992) that the presence of a similar solution, or rather the fact that only k actions need to be added to the stored plan c in order to find the plan p, will make the decision problem of existence of p (and also its generation) easier than if no suitable solution c is available.",
      "startOffset" : 15,
      "endOffset" : 45
    }, {
      "referenceID" : 3,
      "context" : "The result follows from the W[2]-completeness proof of finding a solution plan of at most k action occurrences (the k-step planning problem) given by Bäckström et al. (2012). They proved that W[2]-hardness already holds for complete goal states.",
      "startOffset" : 150,
      "endOffset" : 174
    }, {
      "referenceID" : 3,
      "context" : "Similarly, we can require the set of actions A, from which glue steps can be taken, to be post-unique (Bäckström et al. 2012).",
      "startOffset" : 102,
      "endOffset" : 125
    }, {
      "referenceID" : 3,
      "context" : "Bäckström et al. showed that for the k-step planning problem, complexity results can be improved by considering only planning instances whose actions satisfy the condition of post-uniqueness. Similarly, we can require the set of actions A, from which glue steps can be taken, to be post-unique (Bäckström et al. 2012). This parameterized problem is in fact fixed-parameter tractable (this result follows from Theorem 5 in Bäckström et al. (2012)).",
      "startOffset" : 0,
      "endOffset" : 446
    }, {
      "referenceID" : 2,
      "context" : "The para-PSPACE-membership result follows from the fact that {D}-CASEMOD, when unparameterized, is in PSPACE (Bäckström and Nebel 1996).",
      "startOffset" : 109,
      "endOffset" : 135
    }, {
      "referenceID" : 2,
      "context" : "The para-PSPACE-membership result follows from the fact that {D}-CASEMOD, when unparameterized, is in PSPACE (Bäckström and Nebel 1996). For the hardness result, consider the case where the number k of values allowed in the set of actions A is 2. The problem then reduces to the problem of finding a solution plan for the Boolean planning instance Π, in case we let (c, J) = (ǫ,G). Bäckström and Nebel (1996) showed that finding a solution plan for Boolean planning instances",
      "startOffset" : 110,
      "endOffset" : 409
    }, {
      "referenceID" : 13,
      "context" : "Since this hardness result holds already for a single value of k, the para-PSPACE-hardness result follows (Flum and Grohe 2003).",
      "startOffset" : 106,
      "endOffset" : 127
    }, {
      "referenceID" : 3,
      "context" : "The claim follows directly from the proof of Proposition 1, since k-step planning is W[2]-complete already for Boolean planning instances (Bäckström et al. 2012).",
      "startOffset" : 138,
      "endOffset" : 161
    }, {
      "referenceID" : 3,
      "context" : "The W[t]-membership results can then be proved by encoding the R-CASEMOD instances as instances of certain first-order model checking problems (Bäckström et al. 2012), and combining these into one model checking problem instance that is equivalent to the disjunction of the separate R-CASEMOD instances.",
      "startOffset" : 143,
      "endOffset" : 166
    }, {
      "referenceID" : 7,
      "context" : "Since this parameterized halting problem is in W[P] (Cesati 2003), this suffices to show W[P]-membership.",
      "startOffset" : 52,
      "endOffset" : 65
    } ],
    "year" : 2013,
    "abstractText" : "Planning is a notoriously difficult computational problem of high worst-case complexity. Researchers have been investing significant efforts to develop heuristics or restrictions to make planning practically feasible. Case-based planning is a heuristic approach where one tries to reuse previous experience when solving similar problems in order to avoid some of the planning effort. Plan reuse may offer an interesting alternative to plan generation in some settings. We provide theoretical results that identify situations in which plan reuse is provably tractable. We perform our analysis in the framework of parameterized complexity, which supports a rigorous worst-case complexity analysis that takes structural properties of the input into account in terms of parameters. A central notion of parameterized complexity is fixed-parameter tractability which extends the classical notion of polynomial-time tractability by utilizing the effect of structural properties of the problem input. We draw a detailed map of the parameterized complexity landscape of several variants of problems that arise in the context of case-based planning. In particular, we consider the problem of reusing an existing plan, imposing various restrictions in terms of parameters, such as the number of steps that can be added to the existing plan to turn it into a solution of the planning instance at hand.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}