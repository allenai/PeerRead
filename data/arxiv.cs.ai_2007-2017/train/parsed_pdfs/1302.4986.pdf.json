{
  "name" : "1302.4986.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Exploiting System Hierarchy to Compute Repair Plans in Probabilistic Model-Based Diagnosis",
    "authors" : [ "Sampath Srinivas", "Eric Horvitz" ],
    "emails" : [ "srinivas@cs.stanford.edu", "horvitz@microsoft.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 INTRODUCTION\nThe goal of probabilistic model-based diagnosis is com putation of a minimum expected cost sequence of ob servation and repair actions to restore a malfunction ing system to working order. In general, the computa tion of such an optimal repair strategy is intractable. We must consider each possible strategy in a combina torial space of repair strategies to compute the optimal strategy.\nThe intractability of general diagnosis can be ad dressed in several ways. Several researchers have\nexplored methods that rely on the imposition of a greedy, myopic assumption for generation of repair strategies (for example, [Friedrich & Nejdl, 1992; Beckerman et al, 1995]). These methods compute a good immediate repair action or policy. A best next action is carried out, revealing additional in formation about the world which is used to com pute a revised policy. Investigators have also im posed restrictions on the system model. A com mon restriction is the assumption that only a sin gle fault is present [Kalagnanam & Benrion, 1988; Beckerman et al, 1995].\nIn this paper, we take a different approach. Rather than relaxing the goal of optimality via assumptions of greediness or imposition of modeling restrictions, we gain tractability by exploiting the hierarchical struc ture of complex systems. The rest of the paper is struc tured as follows: First, we formalize the general repair problem in non-hierarchical systems and develop an algorithm to generate optimal repair policies. The ini tial algorithm we develop is only suitable for systems with small numbers of components because the prob lem it solves is inherently exponential in the number of components. We show how we can extend the applica bility of the approach by adapting the optimal repair algorithm to handling systems cast as a hierarchy of components. This results in an algorithm that can be used off-line to tractably compute optimal repair policies for large hierarchical systems. We show how the algorithm exploits the hierarchy to gain tractabil ity. We then introduce flexibility into the algorithm so that it can be used in real time. We do so by in corporating an iterative-deepening scheme that trades off the timeliness of a response for the quality of the computed strategy. We conclude with a discussion ex amining related work.\n2 PROBLEM DEFINITION\nConsider a system with n components, any of which may fail. Each component C; has a set of discrete valued inputs Il, I[, ... , I;k and one discrete-valued output 0;. We refer to the vector of variables (Il, I[, . .. , In as I;.\n524 Srinivas and Horvitz\nLet us assume that the outputs and inputs of the com ponents are connected in accordance with the causal flow of a system-we assume that there are no feed back loops in the system. We also assume that the system has a single designated output variable. Hence, when viewed as a black box, the system has a set of input variables which we will call the system input vari ables and one output variable which we will call the system output variable.\nEach component C; can assume any of a set of pos sible operating states. One of these states ok; is a distinguished state which corresponds to the compo nent's normal mode of operation. The other states of C; correspond to states where the component is not operating normally. We will assume that components fail independently. The state of C; is modeled by a probabilistic state variable M;. The user specifies a prior probability distribution over the states of M;. This distribution quantifies the reliability of C; and is specified based on empirical data and expert knowl edge.\nThe model of operation of the component specifies the value of the output of the component given the state of the component and the values of the inputs. When the component C; is in the state ok; we will assume that a deterministic model of operation is available - that is, given an input state, exactly one output state is possible. However, for the other states, we will leave open the possibility that the behavior is non-deterministic; for each of these states, the user can specify a probability distribution over the output for every possible input state. Specifying the model of operation of the component amounts to specifying the distribution P( 0; \\M;, I;) (with the restriction that P(O; = o;\\M; = ok;,l; = i;) always takes the value 0 or 1 for any o; and i;). Finally, the user specifies a cost of replacement c; for C;. c; is the materials and labor cost of simply discarding the existing part and replacing it with a new one.\nSay we are observing the artifact modeled by our sys tem model and we observe some anomaly. That is, the system is given an input vector (which we can observe) and we observe that the system output is inconsistent with the correct operation of the system.\nWe wish to take actions to repair the system. We will define repairing the system as correcting the perceived anomalous observation. The actions available to us are replacement of components. A repair strategy is a sequence in which the components are replaced. After each successive replacement we check the output of the system. We assume the input is fixed to the input vector associated with the observed anomaly. If the output is still anomalous, we continue to replace the next component recommended by the strategy. If the output is no longer anomalous we stop. Executing each possible repair strategy (i.e., each repair sequence) has an expected cost. The optimal repair strategy is the one with the least expected cost for a particular system\ninput.\nIf we compute the optimal strategy for each possible system input value, we determine the optimal repair plan for the system. The optimal repair plan is a set of situation-action rules. If a system has anomalous behavior, the optimal repair plan gives us a repair strategy to use as a function of the input. We will now develop an algorithm to compute optimal repair plans.\n2.1 COMPUTING THE OPTIMAL REPAIR PLAN\nConsider a system which has a vector of input variables I. Let the system output variable be X. Let us assume that the system has been given an input i. Further, we assume that the correct system output for this input is x(i) and we have observed that the output X has some value other than the correct output1.\nConsider a repair strategy R = (C1, C2, . . . , Cn) · R is a sequence describing the order in which components will be replaced. We now develop an expression for the expected cost of R. We will refer to the action of replacing C; as fix;. In addition, we will refer to the system output X after replacement of the i-th com ponent in the sequence as X;. Note in particular that the variable Xo denotes the value of X before replace ment of any component. Let Sj be the sequence of observations and actions up to and including the re placement of Cj. That is: Sj = [I = i, Xo = -,x(i), jix1, X1 = -,x(i), jix2, X2 = •X(i), . . . , /iXj-1, Xj-1 = •x(i), fixj]· The expected cost of R is given by:\nEC(R\\1 = i, X= -,x(i)) = (c1 + P(X1 = •x(i)\\S1)(c2 + P(X2 = •x(i)\\S2)(ca +\nP(Xn-1 = •x(i)\\Sn-1)Cn . . . ) . · .)))\n(1)\nTo determine the expected cost as described in Equa tion 1,we need to compute the conditional probabilities P(Xj = -,x(i)\\Sj), 1 � j < n. We demonstrate how these probabilities can be com puted using an example. Consider the electronic cir cuit in Fig 1(a). This system model for this cir cuit can be translated into a Bayesian network as displayed in Fig 1(b) (see [Srinivas, 1994] for de tails about this transformation). We will elucidate\n1 Note that we can determine the correct system output by simply simulating the system forward from the input i while assuming that each of the components C; are in the ok; state.\n(a)\nFigure 1: An electronic-circuit example. (a) A system model showing components and interconnectivity, and (b) the corresponding Bayesian network for the system model.\nFigure 2: Representation of the situation after replac ing the AND gate. Arcs between copies of the static network represent persistence of state.\nthe computation of the conditional distribution using this Bayesian network. Consider the repair sequence R = (AND, XOR, OR). The network of Fig 2 repre sents the situation after the AND gate has been re placed. The modes of the X 0 R and 0 R gates are un affected by this replacement and have the same value both before and after the repair action. The arcs be tween the copies of the static network in Fig 2 model this persistence2 .\nThe probability P(X1 = •x(i)ISl) can be computed by declaring the evidence sl in the network, propagat ing it and then looking up the posterior belief of the event X 1 = •x(i) in node X 1· The evidence S1 con sists of: (a) the known state of the input both before and after the repair action, (b) the output X0 (which has the value •x(i) ) , and (c) the state of the AND gate after repair (M�ND = ok). The corresponding nodes are shown shaded gray in the figure.\nWe will now develop an iterative scheme for making this computation without explicitly constructing the dynamic Bayesian network of Fig 3. We begin by de scribing one step of this iterative scheme.\nWe note that there are active paths (see [Pearl, 1988])\n2See [Balke & Pearl, 1994; Heckerman & Shachter, 1994; Darwiche & Goldszmidt, 1994] for details on modeling persistence.\nHierarchical Repair 525\nto node X1 from node Xo through the nodes MxaR and MaR· Hence the computation of the posterior of X1 will necessarily have to consider cases for every possible joint state3 of the variables MxaR and MaR· The computation can be written as follows:\nP(X1 = •x(i)IS!) = EmxoR,ffiORP(Xl = •x(i)II = i, M�ND = ok,\nMxaR = mxaR, MaR = maR) x P(MxaR = mxaR, MaR= maRl\nI = i, Xo = •x(i) ) (2)\nIn the above equation, mxaR and maR represent generic states of MxaR and MaR respectively. Hence the summation in the equation iterates over all possi ble joint states of MxaR and MaR· The equation also accounts for the fact that knowing the state of MxoR and MaR makes X1 conditionally independent of Xo.\nAssume that we have access to the probability distri bution P(MxaR,MaRII = i,Xo = •x(i) ) (i.e., the second term of Equation 2). As we shall see later, this distribution is the output of the previous step of the it erative scheme. We note that the probabilities needed for the first term of the equation, P(X1 = •x(i) II = i, M�ND = ok, MxaR = mxaR, MaR = maR), can be computed directly from the static Bayesian network of Fig 1 (b). This is so because knowing the states of MxaR and MaR makes the post-repair network frag ment (shown within the dotted lines in Fig 2) inde pendent of the rest of the network. The post-repair network fragment is identical to the static Bayesian network. Thus, the required probability can be com puted by (a) declaring the evidence MAND = ok, MxaR = mxaR, MaR = maR, I = i in the static network, and (b) propagating the evidence and look ing up the posterior of the event X = •x(i) in node X.\nNow, let us consider the replacement of the next com ponent specified by the repair strategy, i.e., the XOR gate. The situation is shown in Fig 3. By analogy the previous situation, we can compute P(X2 = •x(i)IS2) as:\nP(X2 = •x(i)IS2) = EmoRP(X2 = •x(i)II = i, M�aR = ok,\nM�ND = ok, MaR= moR) x P(MaR =maR I = i, Xo = •x(i) ,\nM�ND = ok, xl = •x(i)) (3)\nHere, again, the probabilities for the first term in the equation can be directly computed from the system model. We will now see how the probabilities for the second term can be computed from the computations of the previous repair step (i.e., Equation 2). Note that the product within the summation of Equation 2\n3 A joint state of a set of dis�rete random variables as signs a value to each of the variables in the set.\n526 Srinivas and Horvitz\nIf we sum the distribution above over all joint states of MxaR and MaR we obtain the marginal P(X1 = -.x(i)II = i, Xo = -.x(i) , M�ND = ok). Dividing each element the distribution above by this marginal gives us:\nP(MxaR = mxaR, MaR= maR II= i,\nXo = -.x(i),M�ND = ok,X1 = -.x(i) ) (4)\nNow, we consider the action of replacing the X 0 R gate. This does not affect our estimate of what state the OR gate is in; it has no affect on the posterior probability distribution of MaR given the current state of information. This posterior probability is:\nP(MaR =maR II = i, Xo = -.x(i) , M�ND = ok, xl = -.x(i) )\nThis posterior distribution can be computed by sum ming the distribution of Equation 4 over all states of MxaR· Note that this distribution is precisely what we need to solve Equation 3.\nThis example can be generalized to yield a simple it erative scheme for computing P(Xj = -.x(i)ISj) for 1 � j < n, given a repair sequence R. The key idea is that all of the information coming from the first j - 1 observation repair actions is summarized by the pos terior probability distribution over the joint states of the components which have not yet been fixed (i.e., C i through Cn). This posterior probability is used itera tively to perform the following calculations:\n• Compute the probability of an anomaly after the j-th fix action (i.e. , P(Xj = -.x(i)ISi) ) .\n• Compute the new updated posterior, accounting for the j-th action. Note that this posterior is over the joint states of Ci+1 through Cn.\nTo begin the iteration, we need to have the posterior over all joint states of all the components, given that no observation and repair actions have been performed. Note that this posterior probability is just the prior probability over the joint states of the components. As components fail independently, this distribution is the product of the marginal distributions over the modes of each component.\nIn general, when computing P(Xj = -.x(i)ISi) we note that there is an active path in the corresponding dy namic Bayesian network from the observed node Xj _1 to the target node Xj through the mode variable of each unfixed component (i.e., there are active paths through Mj+1, Mj+2, ... , Mn)· As a result, a cutset for the network necessarily includes each of these vari ables. This implies that any inference algorithm com puting P(Xj = -.x(i) !Si) will necessarily have to con dition on each joint state of the modes of the unfixed components. Our iterative scheme explicitly does this conditioning by carrying forward the posterior over the cutset nodes. Thus, its complexity is of the same order as any other scheme for performing this computation. In this sense, our scheme is for computing the proba bilities P(Xj = -.x(i) ISj) is optimal.\n2.1.1 Computing the best strategy\nWe now have the probabilities required to solve Equa tion 1, enabling us to compute the expected cost EC(RII = i, X = -.x(i)) , given a strategy R and a system input I = i. Identifying the best strategy can be done by checking the expected cost of all strategies. Computing the best strategy can be done in O(n!SM) where n is the number of components and SM is the joint space size of the mode variables of all the com ponents. SM is exponential in n.\nTo compute the optimal repair plan, we must compute the best possible strategy for every possible input value to the system. Let the joint space size of the inputs to the system be S1. The overall complexity of com puting the optimal strategy for every possible input to the system is then O(n! x SM x SJ) . Computing the optimal repair plan with the algorithm described above is impractical for large systems. We now modify our algorithm to exploit the hierarchical structure of systems so that the method can be scaled up to large systems.\n3 HIERARCHICAL SYSTEMS\nIt is common in engineering practice to manage the complexity of systems by organizing them into hierar chical assemblies of components. Hierarchical config urations simplify the task of design, construction, and repair of complex systems by grouping system compo-\nnents into subsystems with well-defined functionalities and manageable interdependencies. We will now focus on the details of an extension to the general repair formulation and inference procedure that allows us to take advantage of hierarchical system specifications. The extension builds on a formulation of hierarchical systems in [Srinivas, 1994].\n3.1 DEFINING THE HIERARCHICAL MODEL\nWhen performing hierarchical modeling, an engineer has the option of modeling each component of the system either atomically or hierarchically. An atomic component model has no further substructure, and is defined exactly as in Section 2. A hierarchical com ponent model specifies the behavior of components in terms of the behaviors of its subcomponents. Thus, a hierarchically modeled component is really a subsys tem.\nWe use the term component to refer to a portion of a system that can be tested and replaced as a unit, whether or not it can be decomposed into subcompo nents. To specify a component hierarchically, the user has to specify the component's input variables, the output variable, and the mode variable for the compo nent (as in the case of an atomic model). Specifying a variable involves identifying its name and its states. In addition, the user has to specify a subcomponent model for the component. A subcomponent model is simply another hierarchical system model. The system input variables of the subcomponent model are the same as the input variables of the component and the system output variable of the subcomponent model is the the output variable of the component. Note that each sub component in the subcomponent model can itself be modeled hierarchically or atomically.\nIn repairing hierarchically structured systems, we must consider two costs for each component C-the replace ment cost and the inspection cost. The replacement cost c is the cost of replacing the entire component. The inspection cost d \"buys access\" to the values of the component's input variables and output variable during the repair process. If we decide to pay the inspection cost and then find that the observed out put reading of the component is anomalous for the observed input, we have two options: (1) replace the entire component, or (2) successively repair subcompo nents of the component, checking whether the anoma lous output has been fixed after each subcomponent repatr.\nAs in Section 2.1, we assume that the input value remains fixed. We also assume that a hierarchically modeled component is in the ok state if and only if every one of its subcomponents is in the ok state. Any joint state of the subcomponents which includes any non-ok state thus has to correspond to some non-ok state of the component. This correspondence is spec ified as an abstraction function (see [Srinivas, 1994]).\nHierarchical Repair 527\nFor simplicity, in this presentation we will assume that each component has only two possible states-normal ( ok) and broken (b). In this case, every possible joint state of the subcomponents which contains at least one b state will automatically map to the b state of the containing component.\n3.2 COMPILING THE HIERARCHICAL MODEL\nSay a component C with inputs I, output 0 and mode variable M is modeled hierarchically, and its sub components Ci are modeled atomically. We can eas ily compute the distribution P(M). We do this as P(M = ok) = II;P(Mt = ok;) and P(M = b) = 1- P(M = ok). In addition, we can sum out all the internal variables of the subcomponent model to ob tain the distribution P(OI , M) (see [Srinivas, 1994]). Thus, we can compile the subcomponent model into an atomic description of the component. As we shall see, we will use these atomic descriptions when computing the optimal repair plan.\nIt is not necessary that the subcomponents Ci be mod eled atomically for this compilation process to be pos sible. We need only to ensure that an atomic descrip tion of each Ci is available when computing the atomic description of C. This can be ensured by a bottom up traversal of the hierarchy tree of the system dur ing which each component's atomic description is com puted.\n3.3 HIERARCHICAL REPAIR PLANS\nA component's hierarchical repair plan specifies a re pair strategy for each joint value i of the input variables I of the component. The repair strategy specifies what needs to be done if the input value is i and the output is anomalous. The repair strategy can either specify (a) replacement of the component or (b) repair of sub components. We will make the assumption that if an anomaly in a component is fixed by repair of subcom ponents, this results in the component being returned to the ok state (as in the case of replacement).\nWhen a strategy calls for repair of subcomponents, it also specifies an order in which the subcomponents are to be successively repaired until the output is no longer anomalous. In addition, the strategy also speci fies a repair method for each subcomponent. The repair method for the subcomponent can be either (a) replace ment (without inspection) or (b) inspection followed by repair (this repair is according to the subcompo nent's hierarchical repair plan). The specification of a hierarchical plan for a component also includes a specification of a hierarchical repair plan for each of its subcomponents.\nAn optimal hierarchical repair plan for a component specifies the strategy of least expected cost for each joint input value i. At the top level of the hierarchical system, the entire system can be viewed as a single\n528 Srinivas and Horvitz\ncomponent. The optimal hierarchical repair plan for a system is simply the optimal hierarchical repair plan for the component.\n3.4 COMPUTING THE OPTIMAL HIERARCHICAL REPAIR PLAN\nConsider a component C with inputs I, output 0 and mode variable M which is modeled hierarchically. Let the component's replacement cost be c. Assume it has subcomponents c�, c�, ... , c�, each of which has an atomic description available.\nConsider computing the optimal strategy for repair of C given that the input has the value i and the output is anomalous. Let us suppose that the subcomponents cannot be inspected. In this case, the only repair avail able for each subcomponent C'; is to replace it, incur ring cost ci . We note that we can use the algorithm developed in Section 2.1 to compute the optimal se quence OptSeq(i) in which to replace the components for this particular input. Let the expected cost of this sequence be EC(OptSeq(i)).\nWe note that if EC(OptSeq(i)) ;::::: c then the optimal strategy for input I = i is simply to replace compo nent C if the output is anomalous. In the case where EC(OptSeq(i)) < c then the optimal strategy for in put I = i is to replace the components successively in the order OptSeq(i).\nNow, let us consider the general situation where we have the choice of either replacing a subcomponent or inspecting it and then repairing it according to its hierarchical repair plan. Assume that each subcompo nent's hierarchical repair plan has already been com puted and stored. Given a particular input i and some sequence Seq in which the subcomponents are to be re paired, we will develop a algorithm (Section 3.4.1) that chooses the repair method for each subcomponent such that the expected cost of repair is minimized. The al gorithm outputs the sequence Seq annotated with the best repair method for each component. Let us call this annotated sequence Seqm. The algorithm also outputs the expected cost EC(Seqm) of this optimal strategy.\nIf we now compare EC(Seqm) across every possible sequence Seq we can find the best repair sequence (and the accompanying repair methods) for the in put i. Let this best sequence be OptSeqm(i). We can choose the best strategy of repair for C given the input is i and the output is anomalous as follows. If c ::=:; EC( OptSeqm (i)) then the optimal strategy is sim ply to replace component C. If c > EC(OptSeqm(i)), then the optimal strategy is to repair subcomponents in the sequence (and with the methods) specified by EC(OptSeqm(i)).\nAn optimal hierarchical repair plan for the hierarchical system can be computed through a bottom-up traver sal of the tree representing the hierarchical decomposi tion of the system. At each node of the tree (represent-\ning each component), the algorithm described above can be used to synthesize an optimal hierarchical re pair plan for the component from the subcomponent model, as well as the optimal hierarchical repair plans of the subcomponents.\n3.4.1 Computing Seqm\nLet us consider the case where a system component C has n subcomponents. Let X be the component's output variable. Assume that the optimal hierarchical repair plan for each subcomponent Cj of C has already been computed and is available. Let OptECJ (IJ = i�, XJ = •xj (ij)) be the optimal repair cost of Cj given tbat Its input is ij and that its output XJ is anomalous. Note that this repair cost is available from the precom puted optimal hierarchical plan for the subcomponent c;. Let Seqa be some annotated sequence in which the components are to be repaired. The annotation spec ifies a repair method mi for each subcomponent Cj. If mj = replace then Cj is simply replaced. If mi = inspect then Cj is inspected and then repaired according to its optimal hierarchical repair plan. The cost of repair of Cj in Seqa is a function of the method of repair mj. We refer to this cost as Cost( Cj, mj).\nWe can compute the expected cost of Seqa as: EC(Seqaii = i, X= •x(i)) = (5)\n(Cost(CL ml) + P(X1 = •xiiS1)(Cost(C�, m2) + P(X2 = •xiiS2)(Cost(C�, m3) +\nThe probabilities P(Xj = •xi lSi) for 1 ::=:; j ::=:; n can computed as described earlier with the iterative algo rithm of Section 2.1. However, we have yet to specify how to compute Cost(Cj,mj)·\nIf mj = replace then Cost( Cj, ffij) is simply the re placement cost cj of Cj . If mj = inspect then the cost has two components. The first is the inspection cost. The second is the expected cost of fixing Cj hier archically. This expected cost depends on the current context. The current context includes the observations Sj-1 and the observation Xj = ..,x(i). Thus we have Cost(CJ ,mi) = dj + ECHR(Cj 1Si- 1 , Xi = •x(i)). Here, EC H R is the expected cost of repair of Cj us ing its optimal hierarchical repair plan in the current context.\nThe current context gives us updated informa tion about the probability distribution over the in put and output of Cj. This updated informa tion is summarized by the conditional distribution\nP(Ij, XJ lSi, Xi = •x(i)). Given this conditional dis tribution, ECH R(Cj 1Si_1, Xi = •x(i)) can be com puted as:\nECH R(CJISi-1, Xi = •x(i)) = Ei�OptECJ(Ij = ij, XJ = •xj(ij)) x J\nP(Ij = ij, XJ = •xj(ij)ISi-1, Xi = •x(i))\nNote that the second term within the summation is just the posterior probability of seeing input i1 in con junction with an anomalous output. When this situ ation occurs we use the optimal hierarchical strategy of cost OptEC�(P = i� X� = •x� (i�)) Thus the J J J' J J J • ' above equation computes the expected cost. The problem now reduces to that of computing the distribution P(Ij,XJ ISi, Xi = •x(i)). We will solve this below.\nIn summary, we now have an algorithm for calculat ing the expected cost of the annotated sequence Seqa. This algorithm can be modified to give the optimal an notated sequence Seqm as follows: Given a sequence Seq, if Cost(Cj,replace) < Cost (Cj ,inspect), we choose to replace rather than inspect Cj . If the in equality is reversed, we choose to inspect rather than to replace the component.\nThe distribution P(Ij, XJ lSi, Xi = •x(i)) can be com puted using the same idea which was used to compute P(Xi = •x(i) ISi) in Section 2.1. That is, we can use the fact that knowing the state (mode) of every com ponent and the system input makes Ij independent of the history of observations and repairs Si. Let M[i,i) represent the set of variables { M;, Mi+1, . . . , Mi}. Let m[i,j) be a generic joint state of these variables. Let ok[i,i) be the state where each of the variables in the ok state.\nWe can then compute the needed probability distribu tion as:\nP(Ij = ij,XJ = xjiSi,Xi = •x(i)) = (6)\nEmli+t.nJ P(Ij = ij, XJ = xj I = i, M[1,i) = ok[1,i)• M[j+1,n) = m[j+1,n)> Xi= •x(i)) X\nP(M[j+1,nJ = mu+1,nJISi)\nThe first term in the summation can be computed di rectly from the static Bayesian network corresponding to the model. Consider applying the clustering in ference algorithm to the static network ([Lauritzen & Spiegelhalter, 1988; Jensen et al, 1990]). The cluster ing inference algorithm guarantees that for each com ponent Cj, the output variable XJ and the variables in Ij necessarily will be in the same clique. This is because each variable in Ij is a parent of XJ . Let this clique be Cliquej. If we propagate the evidence i, ok[1,i)• m[j+1,n) and X = •x(i) in this network, and then sum over all the variables other than Ij and XJ in the posterior belief of Cliquej and renormalize, we obtain the distribution P(Ij, XJ I = i, M[1,n) = m[1,n)• Xi = •x(i)). Note that the computation of\nHierarchical Repair 529\nP(Ij = iJ, XJ = xjiSi, Xi = •x(i)) can be integrated into the tterative algorithm of Section 2.1.\nThe distribution P(M[j+1,n) = m[j+l,nJISi) in the sec ond term of the above equation is computed by the iterative algorithm of Section 2.1.\n3.4.2 Repair Algorithm: Review\nIn review, the algorithm for computing the optimal hierarchical repair plan proceeds as follows:\n1. Model compilation: An atomic description for each component is computed by a bottom up traversal of the hierarchy tree.\n2. Plan computation: In a bottom up traversal of the hierarchy tree, for each component C with output 0 and input I and subcomponents Cj, 1 :::; j:::; n:\nFor every possible input i of C:\n- For every possible sequence Seq of the subcomponents, compute the optimal an notation Seqm and its expected cost. Let the cheapest of these annotated se quences be OptSeqm(i).\n- Compare the cost ofOptSeqm(i) with the replacement cost c to compute the opti mal repair strategy for input i.\n3.5 COMPLEXITY OF THE ALGORITHM\nSay that any variable in the hierarchical system model (input, output or mode) has at most s states, and that s is small. This is reasonable for discrete systems with a small number of states for any state variable (e.g., such as digital circuits). Let the maximum num ber of subcomponents of any component be b-this is also the branching factor of the tree representing the system hierarchy. If each component has at most m input variables, the number of variables in the sub component model is O(m x b).\nIt is straightforward to show that the computation of the optimal hierarchical repair algorithm at every node of the hierarchy tree is bounded by O(b!s(m x b)). If we assume that the b and mare small (which is reasonable if we are modeling a system hierarchically) the com putation is tractable (see Section 3.7). Let us refer to the expression (b!s(m x b)) as B. If a hierarchical model has N leaf level components in the hierarchy tree, then the total number of compo nents (including interior nodes in the tree) is O(N). The optimal hierarchical repair algorithm for this model has an overall complexity of 0( N B). Hence, the performance of the algorithm is linear in the size of the hierarchical system. The algorithm is thus tractable if B is reasonably small.\n530 Srinivas and Horvitz\n3.6 INTRODUCING FLEXIBILITY\nWe can modify the algorithm to flexibly trade off the quality of repair plans with computation time. Flexi ble, incremental-refinement procedures make it possi ble to maximize the value of computational procedures �iven variation and uncertainty in the costs of time [Horvitz, 1988]. Consider a hierarchy tree with d lev els of branching and a branching factor of b. The top (first) level of the hierarchy tree has one component, the next (second) level has b components, the third level has b2 components and so on till the d-th level which has bd-l components. Say that we apply the exhaustive algorithm for computing the optimal hier archical repair plan repeatedly, but with the following modification: At the k-th iteration, we assume that the components at the k-th level cannot be inspected - they can only be replaced. As a result, in the k-th iteration we need to consider only those components which are between level 1 and level k when computing the optimal hierarchical plan.\nThus, in the first iteration, the modified algorithm con siders only replacement of the entire system if the out put is anomalous. In the second phase, the method compares replacement of the entire system with in specting it and carrying out an optimal replacement sequence of its direct subcomponents - the compo nents at the second level of the hierarchy tree. The third iteration considers inspection of the subcompo nents at the second level of the hierarchy tree but only replacement of components at the third level of the hierarchy tree, and so on. The k-th iteration of the algorithm will compute an optimal hierarchical plan in O(b'\" B). Thus early iterations run very quickly but give crude answers. Later iterations take longer but give more refined answers. Note that the iterative pro cess can be interrupted at any time to yield the current answer. Essentially, we are applying the exhaustive al gorithm with iterative deepening.\n3. 7 IMPLEMENTATION\nWe have implemented the algorithm in LISP on a Sun workstation. Running on a hierarchical digital circuit with a branching factor b = 4 and m = 3, the (un optimized) implementation takes about 3.2 minutes to compute the policy at each node of the hierarchy tree. For a system with 256 leaf level components this amounts to about 18 hours of computation to com pute the global optimal hierarchical plan. Thus, the present implementation can be considered suitable for off-line precomputation of optimal hierarchical repair plans for medium sized systems. Of course, if we em ploy the iterative-deepening version of the algorithm, we can get lower quality answers more quickly. For example, if the flexible repair strategy looks only 3 levels down the hierarchy tree, the optimal plan can be computed in 67 minutes. We expect that an opti mized implementation of the algorithm should be able to scale up to systems with thousands of components.\n4 DISCUSSION\nComputing an optimal repair strategy is intractable for a general formulation of the repair problem (see for example, [Beckerman et al, 1995]). In the general case, we must identify the best repair strategy from a com binatorial space of strategies. Two types of simplifica tions have been employed to address this complexity. With one approach, the repair problem is restricted by assuming or identifying additional structure in the problem. In the other approach, attempts are made to compute some good immediate repair action, based on a limited lookahead. Such greedy approaches are applied in an interactive procedure, where a recom mended action is used to gather additional informa tion that is used in the next iteration of the myopic analysis. We have taken the first of these approaches we exploit the system hierarchy to get computational gains.\nLet us explore in more detail the basis for the efficien cies we gain by exploiting hierarchical structure. Con sider a hierarchical system where Ci and C� are sub components of cl and c� and c� are subcomponents of C2• Say the inspection costs of non-leaf components is zero, that their replacement cost is very high, and that leaf components cannot be inspected. In such a case, the optimal repair sequence is a sequence of leaf component replacements. If we ignored hierarchy, we would have to consider every possible sequence of the leaf components. However, when we represent and exploit the hierarchy, some of these sequences are im possible (for example, (Ci, C�, C�, C�)). This is because the repair protocol specifies that either cl is fixed first or C2 is fixed first. Thus we are effectively considering only those repair sequences in which both of ci and c� appear (in some order) before c� and c� (in some order) and those sequences in which both of c� and c� appear before Ci and C�. Thus, the hierarchy gives us a substantial reduction in the search space.\nThe approach we have taken takes advantage of the system model, rather than restricting it. Other researchers have shown how restricting the system model can make precomputation of repair strategies tractable. [Kalagnanam & Henrion, 1988] derive an optimality condition for the optimal repair strategy in a multi-component system which is assumed to have a single fault. The repair protocol is similar to the one described in this paper with the exception that only component replacements are allowed. There is no no tion of inspection of components. [Srinivas, 1995] gen eralizes the result of [Kalagnanam & Henrion, 1988] to the case of multiple independent failures and intro duces a formulation of component inspection. [Beck erman et al, 1995] also employs the single-fault restric tion. In this work, repair is formulated as an interac tive process. The system is modeled with a Bayesian network and both component replacement and infor mation gathering actions are possible. An action is\nchosen at each step of the process, taking advantage of a myopic heuristic.\nThe work in the model-based diagnosis community ([Hamscher et al, 1992]) has also addressed the re pair problem as an interactive process. [deKleer & Williams, 1987] introduce an entropy-based method for observation planning. [Friedrich & Nejdl, 1992] develop a set of greedy algorithms for choosing obser vation and repair actions in interactive model-based diagnosis. Their approach explicitly considers down time costs of unanticipated failures. Hence their repair scheme implicitly includes a notion of preventive main tenance. [Poole & Provan, 1991] use repair actions to partition the world into a set of classes. All the worlds in a class result in the same action response. In their formulation, the diagnosis problem becomes one of determining the class of the current state of the system. [Yuan, 1993] proposes a decision-theoretic framework for modeling interactive model-based diag nosis. At each step of the diagnosis, a decision model, in the form of an influence diagram, is synthesized and solved to compute the next action. The model is suc cessively refined along the system hierarchy using a single fault assumption until the fault is located.\nThe emphasis in this paper has been to address the problem of precomputing good strategies rather than interleaving action and repair planning. We have pre sented the hierarchical repair algorithm developed in this paper in the context of model-based diagnosis. However, it is equally applicable to diagnosis models which are developed directly as hierarchical Bayesian networks.\nReferences\n[Balke & Pearl, 1994) Balke, A. and Pearl, J. (1994) Counterfactual probabilities: Com putational bounds, methods and applications. In Proceedings of the Tenth conference on Uncertainty in Artifi cial Intelligence, Seattle, WA.\n[Darwiche & Goldszmidt, 1994] Darwiche, A. and Goldszmidt, M. (1994) Action Networks: A framework for reasoning about actions and change under uncertainty. In Proceedings of the Tenth conference on Uncertainty in Artificial Intel ligence, Seattle, WA.\n[deKleer & Williams, 1987] de Kleer, J. and Williams, B. (1987) Diagnosing Multiple Faults. Artificial Intelligence, 32:97-130.\n[Friedrich & Nejdl, 1992] Friedich, G. and Nejdl, W. (1992) Choosing observations and actions in model based diagnosis/repair systems. In The Third Inter national Workshop on Principles of Diagnosis, Oc tober 1992.\n[Hamscher et al, 1992] Hamscher, W., Console, L., and de Kleer, J. (1992) Readings in Model-Based Diagnosis. Morgan Kaufmann Publishers, Inc., San Mateo, Calif.\nHierarchical Repair 531\n[Heckerman & Shachter, 1994] Heckerman, D. and Shachter, R. ( 1994) A Decision-based view of causal ity. In Proceedings of the Tenth conference on Un certainty in Artificial Intelligence, Seattle, WA.\n[Heckerman et al, 1995] Heckerman, D., Breese, J. and Rommelse, K. (1995) Decision-theoretic Trou bleshooting In Communications of the ACM, 38(3), pp 49-57, March 1995.\n[Horvitz, 1988] Horvitz, E. (1988) Reasoning under varying and uncertain resource constraints. In Pro ceedings of the Seventh National Conference on Ar tificial Intelligence, pp 111-116.\n[Jensen et al, 1990] Jensen, F. V., Lauritzen S. L. and Olesen K. G. (1990) Bayesian updating in causal probabilistic networks by local computations. Com putational Statistics Quarterly 4, pp 269-282.\n[Kalagnanam & Henrion, 1988] Kalagnanam, J. and Henrion, M. (1988). A comparison of decision analy sis and expert rules for sequential diagnosis. In Pro ceedings of the Fourth Workshop on Uncertainty in Artifi cial Intelligence, Minneapolis, MN. pages 205- 212. Also in Shachter, R., Levitt, T., Kana!, L., and Lemmer, J ., editors, Uncertainty in Artificial Intel ligence 4, pages 271-281, North-Holland, New York, 1990.\n[Lauritzen & Spiegelhalter, 1988] Lauritzen, S. L. and Spiegelhalter, D. J. (1988) Local computations with probabilities on graphical structures and their appli cations to expert systems. J. R. Statist. Soc. B, 50, No. 2, 157-224.\n[Pearl, 1988] Pearl, J. (1988) Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Infer ence. Morgan Kaufmann Publishers, Inc., San Ma teo, Calif.\n[Poole & Provan, 1991) Poole, D. and Provan, G. (1991) Use and granularity in consistency-based di agnosis. In The Second International Workshop on Principles of Diagnosis, September 1991.\n[Srinivas, 1994] Srinivas, S. (1994) A probabilistic ap proach to hierarchical model-based diagnosis. In Proceedings of the Tenth conference on Uncertainty in Artificial Intelligence, July 94, Seattle.\n[Srinivas, 1995] Srinivas, S. (1995) A polynomial al gorithm for computing the optimal repair strategy in a system with independent component failures. In Proceedings of the Eleventh conference on Uncer tainty in Aritficial Intelligence, Aug 95, Montreal, Canada.\n[Yuan, 1993] Yuan, S. (1993) Knowledge-based deci sion model construction for hierarchical diagnosis: A preliminary report. In Proceedings of the Ninth conference on Uncertainty in Artificial Intelligence, pp 274-281."
    } ],
    "references" : [ {
      "title" : "Action Networks: A framework for reasoning about actions and change under uncertainty",
      "author" : [ "Darwiche", "Goldszmidt", "A. 1994] Darwiche", "M. Goldszmidt" ],
      "venue" : "In Proceedings of the Tenth conference on Uncertainty in Artificial Intel­",
      "citeRegEx" : "Darwiche et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Darwiche et al\\.",
      "year" : 1994
    }, {
      "title" : "Diagnosing Multiple Faults",
      "author" : [ "deKleer", "Williams", "J. 1987] de Kleer", "B. Williams" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "deKleer et al\\.,? \\Q1987\\E",
      "shortCiteRegEx" : "deKleer et al\\.",
      "year" : 1987
    }, {
      "title" : "Choosing observations and actions in model­ based diagnosis/repair systems",
      "author" : [ "Friedrich", "Nejdl", "G. 1992] Friedich", "W. Nejdl" ],
      "venue" : "In The Third Inter­ national Workshop on Principles of Diagnosis,",
      "citeRegEx" : "Friedrich et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Friedrich et al\\.",
      "year" : 1992
    }, {
      "title" : "Readings in Model-Based Diagnosis",
      "author" : [ "Hamscher et al", "W. 1992] Hamscher", "L. Console", "J. de Kleer" ],
      "venue" : null,
      "citeRegEx" : "al et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "al et al\\.",
      "year" : 1992
    }, {
      "title" : "A Decision-based view of causal­ ity",
      "author" : [ "Heckerman", "Shachter", "D. 1994] Heckerman", "R. Shachter" ],
      "venue" : "In Proceedings of the Tenth conference on Un­ certainty in Artificial Intelligence,",
      "citeRegEx" : "Heckerman et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Heckerman et al\\.",
      "year" : 1994
    }, {
      "title" : "Decision-theoretic Trou­ bleshooting",
      "author" : [ "Heckerman et al", "D. 1995] Heckerman", "J. Breese", "K. Rommelse" ],
      "venue" : "In Communications of the ACM,",
      "citeRegEx" : "al et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "al et al\\.",
      "year" : 1995
    }, {
      "title" : "Bayesian updating in causal probabilistic networks by local computations",
      "author" : [ "Jensen et al", "F.V. 1990] Jensen", "Lauritzen S. L", "Olesen K. G" ],
      "venue" : "Com­ putational Statistics Quarterly",
      "citeRegEx" : "al et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "al et al\\.",
      "year" : 1990
    }, {
      "title" : "A comparison of decision analy­ sis and expert rules for sequential diagnosis",
      "author" : [ "Kalagnanam", "Henrion", "J. 1988] Kalagnanam", "M. Henrion" ],
      "venue" : "In Pro­ ceedings of the Fourth Workshop on Uncertainty in Artifi cial Intelligence,",
      "citeRegEx" : "Kalagnanam et al\\.,? \\Q1988\\E",
      "shortCiteRegEx" : "Kalagnanam et al\\.",
      "year" : 1988
    }, {
      "title" : "Local computations with probabilities on graphical structures and their appli­ cations to expert systems",
      "author" : [ "Lauritzen", "Spiegelhalter", "S.L. 1988] Lauritzen", "D.J. Spiegelhalter" ],
      "venue" : "J. R. Statist. Soc. B,",
      "citeRegEx" : "Lauritzen et al\\.,? \\Q1988\\E",
      "shortCiteRegEx" : "Lauritzen et al\\.",
      "year" : 1988
    }, {
      "title" : "Use and granularity in consistency-based di­ agnosis",
      "author" : [ "Poole", "Provan", "D. 1991) Poole", "G. Provan" ],
      "venue" : "In The Second International Workshop on Principles of Diagnosis,",
      "citeRegEx" : "Poole et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Poole et al\\.",
      "year" : 1991
    } ],
    "referenceMentions" : [ ],
    "year" : 2011,
    "abstractText" : "The goal of model-based diagnosis is to iso­ late causes of anomalous system behavior and recommend cost-effective repair actions. In general, precomputing optimal repair policies is intractable. To date, investigators address­ ing this problem have explored approxima­ tions that either impose restrictions on the system model, such as a single fault assump­ tion, or that compute an immediate best ac­ tion with limited lookahead. In this paper, we develop a formulation of repair in model­ based diagnosis and a repair algorithm that computes optimal sequences of actions. This optimal approach is costly but can be applied to precompute an optimal repair strategy for compact systems. We show how we can ex­ ploit a hierarchical system specification to make this approach tractable for larger sys­ tems. When introducing hierarchy, we also consider the tradeoff between simply replac­ ing a component and decomposing it to repair its subcomponents. The hierarchical repair algorithm is suitable for off-line precomputa­ tion of an optimal repair strategy. A modi­ fication of the algorithm takes advantage of an iterative-deepening scheme to trade off in­ ference time and the quality of the computed strategy.",
    "creator" : "pdftk 1.41 - www.pdftk.com"
  }
}