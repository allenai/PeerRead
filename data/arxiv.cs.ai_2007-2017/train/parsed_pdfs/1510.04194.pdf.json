{
  "name" : "1510.04194.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Dmytro Terletskyi", "Alexandr Provotar" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Dynamic Network (OODN), which gives us an opportunity to represent knowledge, which can be modified in time, to build new relations between objects and classes of objects and to represent results of their modifications. The model is based on representation of objects via their properties and methods. It gives us a possibility to classify the objects and, in a sense, to build hierarchy of their types. Furthermore, it enables to represent relation of modification between concepts, to build new classes of objects based on existing classes and to create sets and multisets of concepts. OODN can be represented as a connected and directed graph, where nodes are concepts and edges are relations between them. Using such model of knowledge representation, we can consider modifications of knowledge and movement through the graph of network as a process of logical reasoning or finding the right solutions or creativity, etc. The proposed approach gives us an opportunity to model some aspects of human knowledge system and main mechanisms of human thought, in particular getting a new experience and knowledge.\nKeywords: class of objects, inhomogeneous class of objects, sets of objects.\nACM Classification Keywords: E.2 Data Storage Representations — Object representation, D.3.3 Language Constructs and Features — Abstract data types, Classes and objects, Data types and structures, D.1.5 Object-oriented Programming, F.4.1 Mathematical Logic — Set theory."
    }, {
      "heading" : "Introduction",
      "text" : "Modern AI includes many directions, which differ from each other, but at the same time they have something in common. One of the main targets for researchers of all these directions is the development of intelligent information systems (IIS) for solving particular practical problems in corresponding areas. Nowadays, development of IIS is often reduced to heuristic programming. Nevertheless, there is a variety of IIS, which are based on knowledge representation model (KRM). The most famous and common are Semantic Nets, Conceptual Dependency, Frames, Scripts, Logical and Production Models, Ontologies, etc. Each of these models has own specifics and is useful in the particular domain. However, we need to implement a KRM while developing certain IIS. That is why our IIS is going to have at least two levels: the level of KR model and the level of its practical implementation. Sometimes, implementation of certain KRM can cause additional problems and difficulties, which are connected with interaction between two abstraction levels of IIS. This situation led to the development of logical programing and such programming language as Prolog, where KRM is integrated within the language. Such approach gives us an opportunity to represent knowledge using just programming language, because corresponding KRM is integrated within it.\nClearly, the development of software for solving particular tasks, management by some process, etc. is easier than the development of software, which has some level of individuality and intellectuality and can do more complicated tasks than just some computations. That is why questions about useful and powerful tool for such development appear. Modern programming includes many different paradigms, approaches, techniques and programming languages. Object-Oriented Programming (OOP) is one of the famous, useful and powerful programming paradigms nowadays. Indeed, according to [Langpop; Tiobe; Sourseforge] the most popular programming languages in 2013 were languages, which support OOP. Furthermore, many of\nprogramming languages have been extended to object-oriented languages: C to C++; Prolog to Object Prolog; COBOL to Object COBOL; SQL to OQL; and LISP to COOL [Sowa, 2000]. That is why questions about usefulness of OOP approach for development IIS, which are based on some KRM, appear."
    }, {
      "heading" : "Object-Oriented Knowledge Representation Models",
      "text" : "As it was mentioned before, there are many different types of KR models. However, as in the case with Prolog, if we want to use an OOP language, as a tool for implementation of IIS, we need to use certain object-oriented KR models as a base for them. Nowadays, the most known and developed object-oriented KR models are frames and scripts, that is why let us consider some their basic and important aspects.\nFrames. Generally, frame consists of set of slots, where the corresponding value is assigned for each slot. Every slot has some filler for itself and in such a way provides information about one of the frame’s attributes. Furthermore, some of fillers can be frames. According to [Brachman, Levesque, 2004], there are two types of frames: individual frames, which are used for representation of single objects, and generic frames, which are used for representation of classes of objects. There are special slots as instance-of, is-a, a-kind-of, etc., which help to organize the relations between different frames and types of frames, in particular between individual frames and generic frames, and in such a way to build up the frame system.\nIn addition, frames have some methods associated with them, which are called procedures or procedural attachments. Each procedure is a set of some instructions, associated with a frame that can be executed on request. Particular examples of procedural attachments are slot-reader, slot-writer, etc. Other important procedures are instance constructors, which create instances of classes. Such procedures called whenneeded or if-needed procedures and can execute only when they are really required.\nFrames have a powerful tool for creating new knowledge called inheritance. It means that frames can inherit the attributes of other frames in the hierarchical structure. Such kinds of slots as instance-of and is-a play an important part in this process, in particular they fill individual frames using other individual or generic frames. Furthermore, frames have such tool as multiple inheritance, which give an opportunity for the frame to inherit properties from more than one other frame.\nAnalyzing structure of the frames, we can conclude about such their advantages as ability to be represented in the form of a table; to store and use default values in the reasoning process; ability to be structured hierarchically and thus allow easy classification of knowledge; to combine procedural and declarative knowledge using one knowledge representation scheme; to constrain allowed values, or make values be entered within a specific range [Kendal, Creen, 2007]. In addition, frames make semantic nets more powerful by allowing complex objects to be represented as a single frame, rather than as a large network structure. It also provides a common way to represent stereotypic entities, classes, inheritance, and default values [Luger, 2008]. Frame systems tend to have a centralized, conventional control regime, whereas OOP systems have objects acting as small, independent agents sending each other messages, that is why, there can be some applications for which a frame-based system can provide some advantages over a more generic OOP system [Brachman, Levesque, 2004]. Likewise, frames can be used as a data structure for Expert Systems [Coppin, 2004].\nHowever, frames also have some disadvantages. They do not provide the most efficient method to store data for a computer; can lead to “procedural fever”; require care in the design stage to ensure that suitable taxonomies [Kendal, Creen, 2007]. In addition, frames can be considered as a simplified version of a semantic network where only is-a relationships are applied. That is why, the inheritance of default properties of frames in a hierarchy leads to problems with exceptions and multiple inheritance. First problem arises when a property of a supertype applies to most but not all of its subtypes. The second one arises when a\nparticular subtype may have more than one supertype from which it can inherit properties, which may conflict [Way, 1991; Coppin, 2004].\nScripts. The scripts are structured representation describing stereotyped sequences of events in a particular context. They are frame-like structures for organizing conceptual dependency structures into descriptions of typical situations. Scripts consist of entry conditions that must be true for the script to be called; results that are true once the script has terminated; props that support the content of the script; roles that the individual participants perform; scenes that presents a temporal aspect of the script.\nFrames and scripts are particularly appealing as means for knowledge representation because psychological studies have shown that people tend to rely on knowledge from previous experience whenever possible, and they use this knowledge and adapt it to handle new or slightly different situations. Therefore, instead of analyzing and building descriptions of each new situation as it occurs, people draw on a large collection of structures, which represents their previous experience with objects, people, and situations, and use these past expectations to guide them in analyzing and representing new experiences [Way, 1991].\nNevertheless, scripts, like other KRM have certain problems, in particular the script match problem and between-the-lines problem. The first problem is that not exists algorithm, which can guarantee correct choices of script in particular situation. The second problem is that not possible to know beforehand the possible occurrences that can break a script. These problems are not unique to script technology but are inherent in the problem of modelling semantic meaning [Graham, Barrett, 1997].\nDespite all advantages and disadvantages of frames, which were mentioned above, we can conclude, that frames help us to describe and somehow to represent relations between objects and classes, which are represented through relations with other objects and classes, using inheritance and special slots as instance-of, is-a, a-kind-of, etc. However, such representation of objects and classes does not describe their properties and types without additional information as links with other objects and classes. It means, for representation of some objects we need to represent a lot of other objects and classes, which have higher level in the particular hierarchy of frames. Thus, logical reasoning within particular structure of frames reduces to manipulations with its hierarchy. Nevertheless, questions about what is a starting point in the logical reasoning, how many frames we need for such reasoning, what is superclass in the hierarchy, etc. appear.\nConcerning scripts, we can conclude that they have similar to frames nature, but at the same time, they are used for representation of sequences of actions in particular locations. The main feature of scripts is a representation of possible scenarios in the certain locations. However, they do not pay enough attention to features of certain location, in particular objects, which form it. Nevertheless, question about how many related scripts we need for managing by different situations in certain location also appears."
    }, {
      "heading" : "Objects and Classes",
      "text" : "We can represent different objects and classes, using frames and scripts. The difference between them is that they represent different types of objects and classes. Frames represent relations between some objects and classes, creating a hierarchy in such a way. Scripts represent actions and relations between them, creating some scenarios. However, both of them do not describe features of their objects and classes and thus do not express fully their semantics. In contrast to frames and scripts, OOP pays more attention to description of features of objects and classes, herewith also creating some hierarchy. That is why, let us consider some features of OOP and try to figure out what an object and a class is.\nIn OOP object and class are the main concepts. Objects are the building blocks for object-oriented programs. We associate these blocks with the objects of real world, during developing programs. Every object is defined by two terms: attributes and behaviors. Attributes are properties of object, which describe it, and behaviors are procedures, functions (methods) which we can apply to this object and change its state, form and so on [Weisfeld, 2008]. Real world consists of objects, and OOP is the approach for description and simulation of this world or some its particular parts [Pecinovský, 2013].\nLet consider such object as “natural number”. It is clear that every natural number must be integer and positive. These are characteristic properties of natural numbers. It is obvious, that 12 is really a natural number, but −1 and 7.32, for example, are not natural numbers. While analyzing this fact, we can conclude that each object has certain properties, which define it as some essence. In contrast to OOP, generally properties of objects can be divided into two types – quantitative and qualitative. We are going to define these two types of object’s properties formally, but their semantics has intuitive nature.\nDefinition 1. Quantitative property of object A is a tuple ( ) ( ( ( )), ( ( )))i i ip A v p A u p A where 1,i n , ( ( ))iv p A is an quantitative value of ( )ip A and ( ( ))iu p A are units of measure of quantitative value of\n( )ip A .\nExample 1. Suppose we have a car and one of its properties is speed. We can present this property as\n( ) ( ( ( )), ( ( )))s s sp Car v p Car u p Car and if our car has speed 150 km/hour, then property is the\nfollowing 150( ) ( , / )sp Car km hour .\nDefinition 2. Two quantitative properties ( )ip A and ( )jp B where 1,i n , 1,j m are equivalent, i.e.\n1( ( ), ( ))i jEq p A p B  , if and only if ( ( )) ( ( ))i ju p A u p B .\nDefinition 3. Qualitative property of object A is a verification function ( ) ( )i ip A vf A , 1,i n which is defined as a mapping 0 1( ) : ( ) [ , ]i ivf A p A  .\nExample 2. Suppose we have a natural number n , and one of its properties is positivity. We can present\nthis property as follows ( ) ( )pos posp n vf n , where ( )posvf n is verification function of property ( )posp n . In\nthis case, function is defined as a mapping 0 1( ) : ( ) { , }pos posvf n p n  , and it is a particular case of\nverification function – predicate or Boolean-valued function.\nDefinition 4. Two qualitative properties ( )ip A and ( )jp B where 1,i n , 1,j m are equivalent, i.e.\n1( ( ), ( ))i jEq p A p B  , if and only if ( ( ) ( )) ( ( ) ( ))i j i jvf A vf A vf B vf B   .\nDefinition 5. Specification of object A is a vector 1 ( ) ( ( ),..., ( ))nP A p A p A where ( )ip A , 1,i n is quantitative or qualitative property of object A .\nDefinition 6. Object is a pair / ( )A P A , where A is object’s identifier and ( )P A is a specification of\nobject.\nEssentially, object is a carrier of some properties, which define it as some essence, and help us recognize it among other objects.\nDefinition 7. Two objects A and B are similar, if and only if they have the same properties and behavior, i.e. ( ) ( )P A P B and ( ) ( )F A F B .\nBesides properties of objects, we should allocate operations (methods) which we can apply to objects, considering the features of their specifications. That is why, it will be useful to define concept of object’s operation (method).\nDefinition 8. Operation (method) of object A is a function ( )f A , which we can apply to object A\nconsidering the features of its specification.\nDefinition of method of object is similar to corresponding definition in OOP. However, there is a difference between them. Usually methods in OOP are functions, which we can execute for objects. In contrast to OOP, we divide methods of objects on two types, depending on character of their action: modifiers and exploiters. Modifiers are functions, which can change objects, in particular some fields of objects. Exploiters are functions, which use objects as arguments and cannot change them.\nExample 3. Let us consider such objects as natural numbers n , m . Operations of sum and multiplication,\ni.e. 1 ( , )f n m n m  and 2 ( , )f n m nm are the simplest examples of exploiters for them.\nExample 4. Let us consider integer number k . Incrementation operation 1 ( )f k k w  is the simplest example of modifier.\nExample 5. Other simple examples of modifiers and exploiters are ( )get Object and\n( , )set Object Value functions, which are common in many OO languages.\nDefinition 9. Signature of object A is a vector 1 ( ) ( ( ),..., ( ))mF A f A f A , where ( )if A , 1,i m is an operation (method) of object A .\nGenerally, we can divide objects on concrete and abstract, and does not matter when or how someone has created each particular object. It is implementation of its abstract image – a prototype, which is essentially an abstract specification for creating the future particular objects. In other words, classes are blueprints, which we use as the basis for objects building [Weisfeld, 2008]. In OOP class consists of fields and methods. Fields form specification of class and methods are functions, which we can apply to objects of this class. We will define concept of class of objects using corresponding idea of OO class.\nDefinition 10. Class of objects T is a tuple ( ( ), ( ))T P T F T , where ( )P T is abstract specification of\nsome quantity of objects, and ( )F T is their signature.\nWhen we talk about class of objects, we mean properties of these objects and methods, which we can apply to them. In other words, class of objects is a generalized form of consideration of objects and operations on them, without these objects. In OOP every particular object has the same fields and behavior as its class, i.e. it has the same specification and signature. According to this, we can define concept of homogeneous class of objects.\nDefinition 13. Homogeneous class of objects T is a class of objects, which contains only similar objects.\nExample 6. The simplest examples of homogeneous classes of objects are class of natural numbers, class of letters of English alphabet, class of colors of the rainbow, etc.\nThere are many different objects of real world, which belong to different classes, and if we need to work with them, we can describe them, using new separate homogeneous class for each new type of objects. Especially, if we work with not very big quantity of different types of objects, we can do it without any fears. However, if we need to work, for example, with a few thousands of different types or more, just a process of description of such types is very complex and time-consuming not to mention size of code and performance of such programs. Nevertheless, besides homogeneous classes there are inhomogeneous classes of objects, which describe objects of different types within one class. It means that each object of such class can have different properties and methods.\nDefinition 14. Inhomogeneous class of objects T is a tuple 1 1 ( ( ), ( ),..., ( ))n nT Core T pr A pr A , where ( ) ( ( ), ( ))Core T P T F T is the core of class of objects T , which includes only properties and methods\nsimilar to corresponding properties of specifications 1 ( ),..., ( )nP A P A and corresponding methods of\nsignatures 1 ( ),..., ( )nF A F A respectively, and where ( ) ( ( ), ( ))i i i ipr A P A F A , 1,i n are projections of objects 1 ,..., nA A , which consist of properties and methods typical only for these objects.\nExample 7. Let us consider such class of objects as natural numbers N . Clearly that it is a member of such\nclasses as integer numbers, rational numbers and real numbers simultaneously, i.e. N Z Q R   . As\nwe can see, class R is the biggest in this case. Furthermore, it consists of objects of different types that contradicts concept of OO class. Of course, in programing languages such types are basic and are built in language. However, in OOP we need to use separate class for description of each such class, because different objects from one OO class cannot have different specifications and signatures. That is why we cannot describe such classes of objects using only one OO class."
    }, {
      "heading" : "Operations on Objects and Classes of Objects",
      "text" : "As it was mentioned above, in OOP objects have methods, however, majority of them are local with respect to objects, and cannot be applied to objects of different types, i.e. they are not polymorphic. Of course, there are some methods, which we can apply to objects of different types, but usually we need to use overloading operators for it [Stroustrup, 2013]. Nevertheless, union, intersection, difference, symmetric difference and cloning operations on objects and classes of objects, were proposed in [Terletskyi, Provotar, 2014]. These operations have set-theoretic nature and they are universal in this sense as they can be applied to any objects and classes of objects regardless of their features. We will not concentrate much attention on these operations and just will consider some examples of their using.\nExample 8. Let us consider such geometrical objects as triangle, square and trapeze. It is obvious, that these objects belong to different classes of convex polygons. Let us denote triangle as A square as B ,\ntrapeze as C and describe their classes as follows\n1 5 1 2\n1 5 1 2\n1 5 1 2\n( ) ( ( ), ( )) (( ( ),..., ( )),( ( ), ( ))),\n( ) ( ( ), ( )) (( ( ),..., ( )),( ( ), ( ))),\n( ) ( ( ), ( )) (( ( ),..., ( )),( ( ), ( ))).\nT A P A F A p A p A f A f A\nT B P B F B p B p B f B f B\nT C P C F C p C p C f C f C\n \n \n \nThe meaning of each property and method is defined by the Table 1.\nSpecifications and signatures of objects , ,A B C can include more or less properties and methods, than we\nhave presented in Table 1, everything depends on the level of detail.\nUnion. Let us apply the union operation to objects , ,A B C and create new set of objects.\n/ ( ) / ( ) / ( ) { , , } / ( )S A T A B T B C T C A B C T S   \nWe have obtained a new set of objects S and a new class of objects\n1 2 3 ( ) ( ( ( )), ( ), ( ), ( )),T S Core T S pr A pr B pr C\nwhere 1 2 3 4 1 ( ( )) ( ( ( )), ( ( )), ( ( )), ( ( )), ( ( )))Core T S p T S p T S p T S p T S f T S , property 1 ( ( ))p T S is a\nquantity of sides of figures, property 2 ( ( ))p T S is size of sides of figures, 3( ( ))p T S is a quantity of angles\nof figures, 4 ( ( ))p T S is measure of angles of figures, method 1 ( ( ))f T S is a function of figures’ perimeter calculation and 1 5 2 ( ) ( ( ), ( ))pr A p A f A , 2 5 2 ( ) ( ( ), ( ))pr B p B f B , 3 5 2 ( ) ( ( ), ( ))pr C p C f C .\nEssentially, a set of objects S is the set of triangles of class A , squares of class B and trapezes of class\nC . Class of objects ( )T S describes three types of geometrical figures ( )T A , ( )T B and ( )T C .\nIntersection. Let us calculate intersection of triangle A and square B .\n/ ( ) / ( ) ( )A T A B T B T A B  \nAs the result, we have obtained new class of objects ( )T A B , which does not contain any projections of\nobjects, i.e. ( ) ( ( ( )))T A B Core T A B   , where\n1 2 3 4 1 ( ( )) ( ( ( )), ( ( )), ( ( )), ( ( )), ( ( )))Core T A B p T A B p T A B p T A B p T A B f T A B       .\nMeaning of all properties and methods of ( ( ))Core T A B is definitely the same as in the case of union.\nClass of objects ( )T A B describes some type of geometrical figures. However, we do not know exactly\nwhich one, but it consists of properties and methods which are simultaneously common for triangle A and square B . Moreover, this class of objects is a part of description of any convex polygon, because each polygon has sides and angles.\nDifference. Let us calculate difference of triangle A and trapeze C .\n/ ( ) \\ / ( ) ( \\ )A T A C T C T A C\nAs the result, we have obtained new class of objects ( \\ )T A C , which does not contain core, i.e.\n1 ( \\ ) ( ( ))T A C pr A , where 1 5 2( ) ( ( ), ( ))pr A p A f A . The obtained new class ( \\ )T A C , describes,\nunlike the previous case, the concrete geometric figure - triangle, but using less specification, than given in the Table 1. Symmetric Difference. Let us calculate symmetrical difference using the same figures, i.e.\ntriangle A and trapeze C .\n/ ( ) / ( ) ( )A T A C T C T A C  \nAs the result, we have obtained a new class of objects ( )T A C , which as in the previous case, does not\ncontain core, i.e. 1 2 ( ) ( ( ), ( ))T A C pr A pr C  , where 1 5 2( ) ( ( ), ( ))pr A p A f A and\n2 5 2 ( ) ( ( ), ( ))pr C p C f C . The class of objects ( )T A C , describes two types of geometrical figures, one\nof them is a triangle, another one is ambiguously defined.\nCloning. Let us apply cloning operation to triangle A .\n1 1 ( ) / ( )Clone A A T A\nAs the result, we have obtained a new indexed copy of triangle A .\nClearly, that these five operations are exploiters, by using which we can create new classes of objects and sets of objects. It is directly connected to creation of the inhomogeneous classes of objects that means obtaining of new knowledge, in particular classes of these sets. The Example 8 illustrates the basic ideas of these operations in a context of their application to classes of objects. In addition, they can be extended for objects [Terletskyi, 2013].\nCreation of new classes of objects, using proposed operations, is directly connected to process of Runtime Class Generation (RCG) in OOP. The main idea of RCG is an opportunity to obtain new classes of objects during program execution. Nowadays, there are few approaches for implementation of this task for some OOP languages, in particular [CGLib] for Java and [CodeDOM] for C#. However, these tools are implemented for such platforms of programming as Java and .NET and based on manipulating with bytecode, which limits their application.\nOne of the main tools for class creation in OOP is inheritance of basic classes. Furthermore, some of the OOP languages provide multiple inheritance, in particular C++ [Stroustrup, 2013]. However, such approach leads to the same problems, which we have mentioned about frames. That is why we propose another approach to generation of classes of objects. Operations, which were considered in the Example 8, are parts of it. In addition, we will propose another kind of operations, which are modifiers.\nDefinition 15. Modification function ( ( ))im p A is a function, which can change somehow a property\n( )ip A .\nDefinition 16. Modifier of object A is a vector 1 1 ( ) ( ( ( )),..., ( ( )))n nM A m p A m p A , where ( ( ))i im p A ,\n1,i n is a modification function of i -th property of object A .\nDefinition 17. Modifier of class of objects T is a vector\n1 1 1 1 ( ) ( ( ( )),..., ( ( )), ( ( )),..., ( ( )))n n k kM T m p T m p T m f T m f T ,\nwhere ( ( ))i im p A , 1,i n is a modification function of i -th property of class of objects T and\n( ( ))j jm f T , 1,j k is a modification function of i -th methods of class of objects T\nWe can divide modifiers on complete, partial, generating, destroying and commutable, depending on the character of changes of objects or their classes.\nDefinition 18. Full modifier of object (class) is an object’s (class’s) modifier, which can simultaneously modify all properties (properties and methods) of particular object (class).\nDefinition 20. Partial modifier of object (class) is an object’s (class’s) modifier, which can simultaneously modify some part of properties (properties and methods) of particular object (class).\nDefinition 21. Generating modifier of object (class) is an object’s (class’s) modifier, which can add some new properties (properties and methods) to specification (specification and signature) of particular object (class).\nDefinition 22. Destroying modifier of object (class) is an object’s (class’s) modifier, which can destroy some properties (properties and methods) of particular object (class).\nDefinition 23. Commutable modifier of object (class) is an object’s (class’s) modifier, which can exchange some properties (properties and methods) of particular object (class) to other properties (properties and methods).\nIn addition, there are combined modifiers that simultaneously merge a few different types of modification. We propose a way of creating these combinations (look Table 2).\nUsing Table 2, we can create modifiers that have more complex structure and allow us to describe more difficult transformations of objects and classes of objects. Generally, modifications of objects and classes of objects give us opportunities to create new classes of objects and thus extend OOP paradigm in this direction."
    }, {
      "heading" : "Object-Oriented Dynamic Networks",
      "text" : "Taking into account advantages and disadvantages of previously considered object-oriented KR models, we tried to propose new object-oriented KRM, which is based on more detail description of objects and classes of objects than frames or scripts, in a sense it is closer to OOP. Let us define it.\nDefinition 25. Object-Oriented Dynamic Network is a 5-tuple ( , , , , )OODN O C R E M , where:\n O – a set of objects;\n C – a set of classes of objects, which describe objects from set O ;\n R – a set of relations, which are defined on set O and C ;\n E – a set of exploiters, which are defined on set O and C ;\n M – a set of modifiers, which are defined on set O and C .\nAs you can see, this model uses concepts of object, object’s class and operations on them, which were formulated previously. Concerning set of relations, it can contain any relations between objects, classes, including such as is-a, a-kind-of, instance-of, etc., which are common for semantic nets, frames and scripts. Let us consider some examples for more detail explanation of main principals of OODN.\nExample 9. Suppose we have classes of objects ( )T P , ( )T R and ( )T S which describe class of\npolygons, class of rhombuses, class of squares respectively. Let us define these classes as follows\n1 4 1\n1 5 1 2\n1 6 1 2\n( ) ( ( ), ( )) (( ( ),..., ( )),( ( ))),\n( ) ( ( ), ( )) (( ( ),..., ( )),( ( ), ( ))),\n( ) ( ( ), ( )) (( ( ),..., ( )),( ( ), ( ))).\nT P P P F P p P p P f P\nT R P R F R p R p R f R f R\nT S P S F S p S p S f S f S\n \n \n \nThe meaning of each property and method is defined by the Table 3.\nIn addition, let us consider particular objects of these classes of objects, i.e. rhombus 1 R and square 1 S . The meaning of each property and method is defined by the Table 4 and Table 5 respectively.\nLet us build object-oriented dynamic network for these objects and classes of objects. Clearly, that set of\nobjects is 1 1 { , }O R S and set of classes of objects is the following { ( ), ( ), ( )}C T P T R T S . It is obvious, that classes ( )T R and ( )T S are kinds of class ( )T P . It is basically know, that the square is a\nrhombus. According to these facts, we can conclude that sets of relations are the following\n1 1\ninstance-of instance-of{ ( ), ( ),R R T R S T S  \n( ) ( ), ( ) ( ), ( ) ( )}a kind of a kind of is aT R T P T S T P T S T R       .\nWe also can rewrite these relations in the following way\n1 1 { ( ), ( ), ( ) ( ), ( ) ( ), ( ) ( )}R R T R S T S T P T R T P T S T R T S      .\nLet us define the next set of modifiers 1 1 2 1 1 1 { ( ( )), ( ( )), ( ( )), ( ( )), ( )}M M T S M T R M T R M T P M R , where: 1 ( ( ))M T S , 1 ( ( ))M T R , 2 ( ( ))M T R , 1 ( ( ))M T P , transform classes of objects ( )T S , ( )T R , ( )T R , ( )T P , into classes of objects ( )T R , 1 ( )T L , ( )T S , ( )T L respectively, 1 1 ( )M R transforms object 1 R to object 11 L . Definitions of classes ( )T L and 1 ( )T L will be given later. The parts of OODN for\nobjects 1 R , 1 S and classes of objects ( )T P , ( )T R , ( )T S are shown on Figure 1 and Figure 2.\nOn the Figure 1 the part of OODN’s graph, which graphically illustrates the structure of the OODN, is drawn. We can divide this graph on left and right parts. Second of them shows the dependencies between classes of polygons and their modifiers, which transform them into other classes. Let us consider modifiers\n1 ( ( ))M T S and 2 ( ( ))M T R in more detail. The first one modifies class of objects ( )T S to class of objects ( )T R , deleting property 6( )p S . The second one modifies class of objects ( )T R to class of objects\n( )T S , adding property 6( )p S . Clearly that they are inverse to each other. These two modifiers illustrate\nthe process of redrawing of geometrical figures and they are examples of partial-deleting modifier.\nNow, let us consider modifiers 1 ( ( ))M T R , 1 ( ( ))M T P and 1 1 ( )M R in more detail. The first one transforms class of objects ( )T R to class of objects 1 ( )T L , which is a class of polylines of type 1 L . This transformation occurs, changing property 1 ( )p R , namely\n1 1 1 1 4 3( ( )) ( ( )) ( , ) ( , )M T R m p R m sizes sizes   . This modifier is an example of partial modifier. Modifier 1 ( ( ))M T P is similar to 1 ( ( ))M T R . It transforms class of objects ( )T P to class of objects ( )T L – a class of all polylines. The last one – 1 1 ( )M R modifies object 1 R to object 11 L just as 1 ( ( ))M T R\nmodifies ( )T R to 1 ( )T L . Analyzing Figure 1, we can conclude that modifiers are kind of transitions between different objects and classes of objects. In such a way, we can model knowledge, which can be modified in time. Furthermore, modifiers form new kind of relations between objects and set of objects.\nGenerally, these kinds of relations can be represented as modification-of. Modifiers can also be considered in temporal context, in particular as future results of modifications.\nOn the Figure 2 the set of exploiters, which create new objects and classes of objects, using sets O and\nC , without any changing of their elements, is drawn. Analyzing this figure, we can see that it illustrates\nwhole operations on objects and classes of objects from Example 8.\nThere are some edges, which are drown by dotted line. It is because results of corresponding operations do not always exist [Terletskyi, Provotar, 2014]. In contrast to modifiers, which act as transitions, exploiters\ncreate new classes of objects based on basic classes from set C . In other words, in such a way we can create new classes, which are non-obvious at first glance. Clearly, that there are other types of exploiters, which can be applicable in this example, however there is a question about their generality in comparison with those, which were considered in the Example 8. Analyzing Figure 2, we can conclude that proposed\nkind of exploiters extend basic set of objects O and classes of objects C . In such a way, they increase description’s concentration of particular domain."
    }, {
      "heading" : "Conclusions",
      "text" : "This paper contains analysis of such common object-oriented KRM as frames and scripts, which advantages and disadvantages were considered. Furthermore, concepts of object and class were considered from different sides, in particular from OOP's one. The concepts of object and class of objects, which differ from OOP’s version, and operations on them, which give us an opportunity to create new sets of objects and new classes of objects, in particular inhomogeneous, were proposed. The operations have set-theoretical nature and are quite general, that gives us a possibility to apply them to any object and class of objects.\nThe main result of this paper is new object-oriented KRM – Object-Oriented Dynamic Network. It gives us an opportunity to represent knowledge, which can be modified in time, to build new relations between objects and classes of objects and to represent results of their modifications. OODN is based on representation of objects and classes of objects via their properties and methods. It allows us to classify the objects and, in a sense, to build hierarchy of their types. Furthermore, it enables to represent relation of modification between concepts, to build new classes of objects based on existing classes and to create sets and multisets of concepts. Using such model of knowledge representation, we can consider modifications of knowledge and movement through the graph of model as a process of logical reasoning or finding the right solutions or creativity, etc. The proposed approach gives us a possibility to model some aspects of human knowledge\nsystem and main mechanisms of human thought, in particular getting a new experience and knowledge. The OODN, in a sense, is similar to OOP languages, but at the same time, it extends classical OOP paradigm, forming new view on the creation of classes of objects. However, despite all advantages, proposed KRM requires further research."
    } ],
    "references" : [ {
      "title" : "Knowledge Representation: Logical",
      "author" : [ "J.F. Sowa" ],
      "venue" : "Philosophical and Computational Foundations. – Brooks/Cole",
      "citeRegEx" : "Sowa. 2000",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Knowledge Representation and Reasoning",
      "author" : [ "R.J. Brachman", "H.J. Levesque" ],
      "venue" : "– Morgan Kaufmann Publishers",
      "citeRegEx" : "Brachman. Levesque. 2004",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "An Introduction to Knowledge Engineering",
      "author" : [ "S.L. Kendal", "M. Creen" ],
      "venue" : "– Springer Verlag",
      "citeRegEx" : "Kendal. Creen. 2007",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Artificial Intelligence",
      "author" : [ "G.F. Luger" ],
      "venue" : "Structures and Strategies for Complex Problem Solving: 6-th edition. – Addison-Wesley",
      "citeRegEx" : "Luger. 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Jones and Bartlett Publishers",
      "author" : [ "B. Coppin. Artificial intelligence illuminated" ],
      "venue" : "Inc.",
      "citeRegEx" : "Coppin. 2004",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Knowledge Representation and Metaphor",
      "author" : [ "E.C. Way" ],
      "venue" : "– Springer Science + Business Media, B.V.",
      "citeRegEx" : "Way. 1991",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Knowledge-Based Image Processing Systems",
      "author" : [ "D. Graham", "A. Barrett" ],
      "venue" : "– SpringerVerlag",
      "citeRegEx" : "Graham. Barrett. 1997",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "The Object-Oriented Thought Process",
      "author" : [ "M. Weisfeld" ],
      "venue" : "Third Edition. – Addison-Wesley Professional",
      "citeRegEx" : "Weisfeld. 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "OOP – Learn Object Oriented Thinking and Programming",
      "author" : [ "R. Pecinovský" ],
      "venue" : "– Tomáš Bruckner, Řepín-Živonín",
      "citeRegEx" : "Pecinovský. 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "The C+ + Programming Language: Fourth Edition",
      "author" : [ "B. Stroustrup" ],
      "venue" : "– Addison-Wesley Professional",
      "citeRegEx" : "Stroustrup. 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Mathematical Foundations for Designing and Development of Intelligent Systems of Information Analysis",
      "author" : [ "Terletskyi", "Provotar", "2014] D.O. Terletskyi", "A.I. Provotar" ],
      "venue" : "Scientific Journal “Problems in Programing”,",
      "citeRegEx" : "Terletskyi et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Terletskyi et al\\.",
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "programming languages have been extended to object-oriented languages: C to C++; Prolog to Object Prolog; COBOL to Object COBOL; SQL to OQL; and LISP to COOL [Sowa, 2000].",
      "startOffset" : 158,
      "endOffset" : 170
    }, {
      "referenceID" : 1,
      "context" : "According to [Brachman, Levesque, 2004], there are two types of frames: individual frames, which are used for representation of single objects, and generic frames, which are used for representation of classes of objects.",
      "startOffset" : 13,
      "endOffset" : 39
    }, {
      "referenceID" : 2,
      "context" : "Analyzing structure of the frames, we can conclude about such their advantages as ability to be represented in the form of a table; to store and use default values in the reasoning process; ability to be structured hierarchically and thus allow easy classification of knowledge; to combine procedural and declarative knowledge using one knowledge representation scheme; to constrain allowed values, or make values be entered within a specific range [Kendal, Creen, 2007].",
      "startOffset" : 449,
      "endOffset" : 470
    }, {
      "referenceID" : 3,
      "context" : "It also provides a common way to represent stereotypic entities, classes, inheritance, and default values [Luger, 2008].",
      "startOffset" : 106,
      "endOffset" : 119
    }, {
      "referenceID" : 1,
      "context" : "Frame systems tend to have a centralized, conventional control regime, whereas OOP systems have objects acting as small, independent agents sending each other messages, that is why, there can be some applications for which a frame-based system can provide some advantages over a more generic OOP system [Brachman, Levesque, 2004].",
      "startOffset" : 303,
      "endOffset" : 329
    }, {
      "referenceID" : 4,
      "context" : "Likewise, frames can be used as a data structure for Expert Systems [Coppin, 2004].",
      "startOffset" : 68,
      "endOffset" : 82
    }, {
      "referenceID" : 2,
      "context" : "They do not provide the most efficient method to store data for a computer; can lead to “procedural fever”; require care in the design stage to ensure that suitable taxonomies [Kendal, Creen, 2007].",
      "startOffset" : 176,
      "endOffset" : 197
    }, {
      "referenceID" : 5,
      "context" : "particular subtype may have more than one supertype from which it can inherit properties, which may conflict [Way, 1991; Coppin, 2004].",
      "startOffset" : 109,
      "endOffset" : 134
    }, {
      "referenceID" : 4,
      "context" : "particular subtype may have more than one supertype from which it can inherit properties, which may conflict [Way, 1991; Coppin, 2004].",
      "startOffset" : 109,
      "endOffset" : 134
    }, {
      "referenceID" : 5,
      "context" : "Therefore, instead of analyzing and building descriptions of each new situation as it occurs, people draw on a large collection of structures, which represents their previous experience with objects, people, and situations, and use these past expectations to guide them in analyzing and representing new experiences [Way, 1991].",
      "startOffset" : 316,
      "endOffset" : 327
    }, {
      "referenceID" : 6,
      "context" : "These problems are not unique to script technology but are inherent in the problem of modelling semantic meaning [Graham, Barrett, 1997].",
      "startOffset" : 113,
      "endOffset" : 136
    }, {
      "referenceID" : 7,
      "context" : "Attributes are properties of object, which describe it, and behaviors are procedures, functions (methods) which we can apply to this object and change its state, form and so on [Weisfeld, 2008].",
      "startOffset" : 177,
      "endOffset" : 193
    }, {
      "referenceID" : 8,
      "context" : "Real world consists of objects, and OOP is the approach for description and simulation of this world or some its particular parts [Pecinovský, 2013].",
      "startOffset" : 130,
      "endOffset" : 148
    }, {
      "referenceID" : 7,
      "context" : "In other words, classes are blueprints, which we use as the basis for objects building [Weisfeld, 2008].",
      "startOffset" : 87,
      "endOffset" : 103
    }, {
      "referenceID" : 9,
      "context" : "Of course, there are some methods, which we can apply to objects of different types, but usually we need to use overloading operators for it [Stroustrup, 2013].",
      "startOffset" : 141,
      "endOffset" : 159
    }, {
      "referenceID" : 9,
      "context" : "Furthermore, some of the OOP languages provide multiple inheritance, in particular C++ [Stroustrup, 2013].",
      "startOffset" : 87,
      "endOffset" : 105
    } ],
    "year" : 2014,
    "abstractText" : "This paper contains description of such knowledge representation model as Object-Oriented Dynamic Network (OODN), which gives us an opportunity to represent knowledge, which can be modified in time, to build new relations between objects and classes of objects and to represent results of their modifications. The model is based on representation of objects via their properties and methods. It gives us a possibility to classify the objects and, in a sense, to build hierarchy of their types. Furthermore, it enables to represent relation of modification between concepts, to build new classes of objects based on existing classes and to create sets and multisets of concepts. OODN can be represented as a connected and directed graph, where nodes are concepts and edges are relations between them. Using such model of knowledge representation, we can consider modifications of knowledge and movement through the graph of network as a process of logical reasoning or finding the right solutions or creativity, etc. The proposed approach gives us an opportunity to model some aspects of human knowledge system and main mechanisms of human thought, in particular getting a new experience and knowledge.",
    "creator" : "Microsoft® Office Word 2007"
  }
}