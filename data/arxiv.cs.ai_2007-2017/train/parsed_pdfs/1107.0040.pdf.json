{
  "name" : "1107.0040.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Heidi E. Dixon" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Generalizing Boolean Satis ability I: Ba kground and\nSurvey of Existing Work\nHeidi E. Dixon dixon irl.uoregon.edu CIRL Computer and Information S ien e 1269 University of Oregon Eugene, OR 97403 USA\nMatthew L. Ginsberg ginsberg otsys. om On Time Systems, In . 1850 Millra e, Suite 1 Eugene, OR 97403 USA\nAndrew J. Parkes parkes irl.uoregon.edu CIRL 1269 University of Oregon Eugene, OR 97403 USA\nAbstra t\nThis is the rst of three planned papers des ribing zap, a satis ability engine that substantially generalizes existing tools while retaining the performan e hara teristi s of modern high-performan e solvers. The fundamental idea underlying zap is that many problems passed to su h engines ontain ri h internal stru ture that is obs ured by the Boolean representation used; our goal is to de ne a representation in whi h this stru ture is apparent and an easily be exploited to improve omputational performan e. This paper is a survey of the work underlying zap, and dis usses previous attempts to improve the performan e of the Davis-Putnam-Logemann-Loveland algorithm by exploiting the stru - ture of the problem being solved. We examine existing ideas in luding extensions of the Boolean language to allow ardinality onstraints, pseudo-Boolean representations, symmetry, and a limited form of quanti ation. While this paper is intended as a survey, our resear h results are ontained in the two subsequent arti les, with the theoreti al stru ture of zap des ribed in the se ond paper in this series, and zap's implementation des ribed in the third."
    }, {
      "heading" : "1. Introdu tion",
      "text" : "This is the rst of a planned series of three papers des ribing zap, a satis ability engine that substantially generalizes existing tools while retaining the performan e hara teristi s of modern high-performan e solvers su h as zChaff (Moskewi z, Madigan, Zhao, Zhang, & Malik, 2001). 1 Many Boolean satis ability problems in orporate a ri h stru ture that re-\ne ts properties of the domain from whi h the problems themselves arise, and zap in ludes a representation language that allows this stru ture to be des ribed and a proof engine that exploits the stru ture to improve performan e. This rst paper des ribes the work on\n1. The se ond two papers have been published as te hni al reports (Dixon, Ginsberg, Luks, & Parkes,\n2003b; Dixon, Ginsberg, Hofer, Luks, & Parkes, 2003a) but have not yet been peer reviewed.\n2004 AI A ess Foundation. All rights reserved.\nwhi h zap itself is based, and is intended to be a survey of existing results that attempt to use problem stru ture to improve the performan e of satis ability engines. The results we dis uss in lude generalizations from Boolean satis ability to in lude ardinality onstraints, pseudo-Boolean representations, symmetry, and a limited form of quanti ation. The se - ond paper in this series (Dixon et al., 2003b) des ribes the theoreti al generalization that subsumes and extends these ideas, and the third paper (Dixon et al., 2003a) des ribes the zap system itself.\nOur intention is to review work on satis ability from the introdu tion of the DavisPutnam-Logemann-Loveland algorithm (Davis, Logemann, & Loveland, 1962) to the present day. Not all of this work (thankfully), but only that portion of the work that an be thought of as an attempt to improve the performan e of systemati methods by exploiting the general stru ture of the problem in question.\nWe therefore in lude a des ription of re ent work extending the language of Boolean satis ability to in lude a restri ted form of quanti ation (Ginsberg & Parkes, 2000) or pseudo-Boolean onstraints (Barth, 1995, 1996; Chandru & Hooker, 1999; Dixon & Ginsberg, 2000; Hooker, 1988; Nemhauser & Wolsey, 1988); in ea h ase, the representational extension orresponds to the existen e of stru ture that is hidden by the Boolean axiomatization. We dis uss at length the interplay between the desire to speed sear h by exploiting stru ture and the danger of slowing sear h by using unwieldy representations. Somewhat surprisingly, we will see that the most e e tive representational extensions appear to in-\nur little or no overhead as a result of implementation on erns. It was this observation { that better representations an have better implementations { that led us to sear h for the general sort of stru ture that zap exploits.\nWe will also dis uss the attempts that have been made to exploit the symmetri al stru - ture of some satis ability problems (Brown, Finkelstein, & Paul Walton Purdom, 1988; Crawford, 1992; Crawford, Ginsberg, Luks, & Roy, 1996; Joslin & Roy, 1997; Krishnamurthy, 1985; Puget, 1993). This work appears to have had only a modest impa t on the development of satis ability engines generally, and we explain why: Most authors (Crawford, 1992; Crawford et al., 1996; Joslin & Roy, 1997; Krishnamurthy, 1985; Puget, 1993) exploit only global symmetries, and su h symmetries are vanishingly rare in naturally o -\nurring problems. The methods that have been des ribed for exploiting lo al or emergent symmetries (Brown et al., 1988; Szeider, 2003) in ur una eptable omputational overhead at ea h node of the sear h. Our general arguments regarding the interplay between representation and sear h suggest that one should identify lo al symmetries when a problem is formulated, and then exploit those symmetries throughout the sear h.\nWe will not dis uss heuristi sear h or any of the substantial literature relating to it. To our olle tive eye, just as a Boolean axiomatization an obs ure the natural stru ture in a sear h problem, so an heuristi s. We have argued elsewhere (Ginsberg & Geddis, 1991) that domain-dependent sear h ontrol rules an never be more than a poor man's standin for general prin iples based on problem stru ture. Our sele tion of survey material re e ts this bias.\nWe have remarked that this entry in the zap series is a survey paper; to the extent that there is a resear h ontribution, it is in the overall (and, we believe, novel) fo us we are taking. Our basi view is that the target of new work in this area should not be a spe i representational extension su h as a pseudo-Boolean or rst-order en oding,\nbut a dire t exploitation of the underlying problem stru ture. This paper is original in des ribing existing work in this way, for the rst time viewing the rst-order and pseudoBoolean extensions purely as stru ture-exploitation te hniques. First-order and pseudoBoolean representations are e e tive not be ause of their history of usefulness, but be ause { and to our mind only be ause { they allow the identi ation and apture of two parti ular types of stru ture inherent in many lasses of problems. It is our hope that the reader views the material we are presenting here (and in the ompanion papers as well) in this light: Re ent progress in Boolean satis ability is best thought of in terms of stru ture exploitation. That is the perspe tive with whi h we approa h this paper, and we hope that you, the reader, will ome to share it.\nBut let us return to the Davis-Putnam-Logemann-Loveland pro edure itself (Davis et al., 1962), whi h appears to have begun the body of work on the development of solvers that are suÆ iently powerful to be used in pra ti e on a wide range of problems. Des endants of the dpll algorithm are now the solution method of hoi e on many su h problems in luding mi ropro essor testing and veri ation (Biere, Clarke, Raimi, & Zhu, 1999; Copty, Fix, Giun higlia, Kamhi, Ta hella, & Vardi, 2001; Velev & Bryant, 2001), and are ompetitive in other domains su h as planning (Kautz & Selman, 1992).\nWe will return to the pure algorithmi s of dpll and its su essors shortly, but let us begin by noting that in spite of impressive engineering su esses on many diÆ ult problems, there are many easy problems with whi h Boolean satis ability engines struggle. These in lude problems involving parity, the well known \\pigeonhole problem\" (stating that you annot put n + 1 pigeons into n holes if ea h pigeon needs its own hole), and problems that are des ribed most naturally using a rst-order as opposed to a ground representation.\nIn all of these ases, there is stru ture to the problem being solved and this stru ture is lost when the ground en oding is built. While it is a testament to the power of Boolean methods that they an solve large and diÆ ult problems without a ess to this underlying stru ture, it seems reasonable to expe t that in orporating and using the stru ture would improve performan e further. Our survey of te hniques that improve dpll will suggest that this is in fa t the ase, sin e all of the te hniques that underpin the performan e of modern Boolean satis ability engines an be well understood in this way.\nBefore turning to the details of this analysis, however, let us esh out our framework a bit more. If any omputational pro edure is to have its performan e improved, there seem to be only three ways in whi h this an be done:\n1. Repla e the algorithm.\n2. Redu e the time spent on a single iteration of the inner loop.\n3. Redu e the number of times the inner loop must be exe uted.\nThe rst approa h is not our fo us here; while there are many potential ompetitors to dpll, none of them seems to outperform dpll in pra ti e. 2 Work on the se ond approa h\n2. Systemati alternatives in lude the original Davis-Putnam (1960) method, polynomial al ulus solvers\n(Clegg, Edmonds, & Impagliazzo, 1996) based on Bu hberger's (1965, 1985) Groebner basis algorithm, methods based on binary de ision diagrams or bdds (Bryant, 1986, 1992), and dire t rst-order methods\nhas histori ally fo used on redu ing the amount of time spent in unit propagation, whi h does indeed appear to represent the inner loop of most dpll implementations.\nThere are a variety of te hniques available for redu ing the number of alls to the inner\nloop, whi h we will divide as follows:\n3a. Algorithmi improvements that do not require representational hanges.\n3b. Algorithmi improvements requiring representational hanges.\nAttempts to improve dpll without hanging the underlying Boolean representation have fo used on (i) the development of a me hanism for retaining information developed in one portion of the sear h for subsequent use ( a hing or, more ommonly, learning) and (ii) the development of sear h heuristi s that an be expe ted to redu e the size of the spa e being examined. In all su h work, however, using dpll to analyze problems where no solution exists is equivalent to building a resolution proof of the unsatis ability of the underlying theory, so that the number of inferen e steps is bounded by the number of inferen es in the shortest su h proof (Mit hell, 1998). These lengths are generally exponential in problem size in the worst ase.\nWork involving representation hange an over ome this diÆ ulty by redu ing the length of the proof that dpll or a similar algorithm is impli itly trying to onstru t. Representations are sought for whi h ertain problems known to require proofs of exponential length in the Boolean ase admit proofs of polynomial length after the representational shift is made. This leads to a hierar hy of representational hoi es, where one representation r\n1\nis said to\npolynomially simulate or p-simulate another r\n2\nif proofs using the representation r\n2\nan be\nonverted to proofs using r\n1\nin polynomial time. In general, representations that lead to\neÆ ient proofs do so via more eÆ ient en odings, so that a single axiom in the improved representation orresponds to exponentially many in the original. There are many ex ellent surveys of the proof omplexity literature (Beame & Pitassi, 2001; Pitassi, 2002; Urquhart, 1995), and we will generally not repeat that material here.\nOf ourse, it is not suÆ ient to simply improve the epistemologi al adequa y of a proof system; its heuristi adequa y must be maintained or improved as well (M Carthy, 1977). We therefore assume that any representation introdu ed for the purposes of navigating the p-simulation hierar hy also preserves the basi inferen e me hanism of dpll (resolution) and maintains, and ideally builds upon, the improvements made in propagation performan e (2) and learning (3a). It is in this ontext that our survey shall onsider these representational\nhanges.\nThe representations that we will onsider are the following:\nBoolean axiomatizations. This is the original representation used in dpll, and provides the basi setting in whi h progress in propagation, learning and bran hing has taken pla e.\nsu h as those employed by otter (M Cune & Wos, 1997). Nonsystemati methods in lude the wsat family (Selman, Kautz, & Cohen, 1993), whi h re eived a great deal of attention in the 1990's and still appears to be the method of hoi e for randomly generated problems and some spe i other sets of instan es. In general, however, systemati algorithms with their roots in dpll tend to outperform the alternatives.\nCardinality onstraints. If a disjun tive Boolean axiom states that at least one of the disjun ts is true, a ardinality onstraint allows one to state that at least n of the disjun ts are true for some integer n.\nPseudo-Boolean onstraints. Taken from operations resear h, a pseudo-Boolean onstraint is of the form\nX\ni\nw\ni\nl\ni\nk\nwhere the w\ni\nare positive integral weights, the l\ni\nare literals, and k is a positive integer.\nCardinality onstraints are the spe ial ase where w\ni\n= 1 for all i; a Boolean onstraint\nhas k = 1 as well.\nSymmetri representations. Some problems (su h as the pigeonhole problem) are highly symmetri , and it is possible to apture this symmetry dire tly in the axiomatization. A variety of authors have developed proof systems that exploit these symmetries to redu e proof size (Brown et al., 1988; Crawford, 1992; Crawford et al., 1996; Joslin & Roy, 1997; Krishnamurthy, 1985; Puget, 1993).\nQuanti ed representations. While there are many approa hes to quanti ed satis - ability, we will fo us only on those that do not hange the underlying omplexity of the problem being solved. 3 This requires that all domains of quanti ation be\nnite, and is the fo us of a \\propositional\" restri tion of rst-order logi known as\nqprop (Ginsberg & Parkes, 2000).\nGiven the arguments regarding heuristi adequa y generally, our goal in this survey is\nto omplete the following table:\nrepresentational p-simulation unit\neÆ ien y hierar hy inferen e propagation learning\nSAT\nardinality\npseudo-Boolean\nsymmetry\nQPROP\nThe rst olumn simply names the representational system in question. Then for ea h,\nwe des ribe:\nRepresentational eÆ ien y (3b): How many Boolean axioms an be aptured in a single axiom in the given representation?\np-simulation hierar hy (3b): Where is the representation relative to others in the p-simulation hierar hy?\nInferen e: Is it possible to lift the basi dpll inferen e me hanism of resolution to the new representation without in urring signi ant additional omputational expense?\n3. Problems involving quanti ed Boolean formulae, or qbf, are pspa e- omplete (Cadoli, S haerf, Giova-\nnardi, & Giovanardi, 2002) as opposed to the np- omplete problems onsidered by dpll and its dire t su essors.\nUnit propagation (2): Can the te hniques used to speed unit propagation be lifted to the new setting? Are new te hniques available that are not available in the Boolean\nase?\nLearning (3a): Can existing learning te hniques be lifted to the new setting? Are new te hniques available that are not available in the Boolean ase?\nWe annot overstress the fa t that no single olumn in our table is more important than the others. A redu tion in proof length is of little pra ti al value if there is no asso iated redu tion in the amount of omputation time required to nd a proof. Speeding the time needed for a single inferen e is hardly useful if the number of inferen es required grows exponentially.\nThe Boolean satis ability ommunity has pioneered many te hniques used to redu e perinferen e running time and to understand learning in a de larative setting. In spite of the fa t that resolution and Boolean satis ability are among the weakest inferen e systems in terms of representational eÆ ien y and their position in the p-simulation hierar hy (Pudlak, 1997), almost none of the more powerful proof systems is in wide omputational use. Finding proofs in these more sophisti ated settings is diÆ ult; even dire t attempts to lift dpll to a rst-order setting (Baumgartner, 2000) seem fraught with omplexity and an inability to exploit re ent ideas that have led to substantial improvements in algorithmi performan e. The most usable proof systems are often not the theoreti ally most powerful.\nThis paper is organized along the rows of the table we are trying to omplete. Boolean te hniques are des ribed in the next se tion; we re ount the demonstration that the pigeonhole problem is exponentially diÆ ult in this setting (Haken, 1985). We go on in Se tion 3 to dis uss ardinality onstraints and pseudo-Boolean methods, showing that the earlier diÆ ulties with the pigeonhole problem an be over ome using either method but that similar issues remain in other ases. Following the des riptions of implemented pseudoBoolean reasoning systems (Barth, 1995; Dixon & Ginsberg, 2000), we show that the key\nomputational ideas from the Boolean ase ontinue to be appli able in a pseudo-Boolean\nsetting.\nAxiomatizations that attempt to exploit symmetry dire tly are dis ussed in Se tion 4. We draw a distin tion between approa hes that require the existen e of global symmetries, whi h tend not to exist in pra ti e, and those that use only lo al ones, whi h exist but are diÆ ult to nd as inferen e pro eeds.\nIn Se tion 5, we dis uss axiomatizations that are Boolean des riptions of problems that are more naturally represented using quanti ed axioms. We dis uss the problems arising from the fa t that the ground theories tend to be exponentially larger than their lifted\nounterparts, and show that working with the rst-order axiomatization dire tly an lead\nto large improvements in the eÆ ien y of the overall system (Ginsberg & Parkes, 2000).\nCon luding remarks are ontained in Se tion 6."
    }, {
      "heading" : "2. Boolean Satis ability",
      "text" : "De nition 2.1 A variable is simply a letter (e.g., a) that an be either true or false. A literal is either a variable or the negation of a variable. A lause is a disjun tion of literals,\nand a Boolean satis ability problem (in onjun tive normal form), or a sat problem, is a\nonjun tion of lauses.\nA solution to a sat problem C is an assignment of values to ea h of the letters so that\nevery lause in C is satis ed.\nNone of this should be new. Satis ability of sat instan es is well-known to be NPomplete (Cook, 1971), and the language is a reasonably natural one for en oding realworld problems. As we remarked in the introdu tion, the lassi algorithm for solving these problems is depth- rst sear h augmented with an ability to set variables whose values are for ed:\nPro edure 2.2 (Davis-Putnam-Logemann-Loveland) Given a sat problem C and a partial assignment P of values to variables, to ompute dpll(C;P ):\n1 P Unit-Propagate(P ) 2 if P ontains a ontradi tion 3 then return failure 4 if P assigns a value to every variable 5 then return su ess 6 l a literal not assigned a value by P 7 if dpll(C;P [ fl = trueg) = su ess 8 then return su ess 9 else return dpll(C;P [ fl = falseg)\nVariables are assigned values in two ways. In the rst, unit propagation, the lause set is examined under the existing partial assignment and new onsequential assignments are identi ed. Somewhat more spe i ally (see below), lauses are found that have no satis ed literals and exa tly one unvalued literal. In ea h su h lause, the unvalued literal is valued so as to satisfy the lause. This pro ess is repeated until a ontradi tion is en ountered, a solution is found, or no more lauses meet the ne essary onditions. If the unit propagation fun tion terminates without rea hing a ontradi tion or nding a solution, then a variable is sele ted and assigned a value, and the pro edure re urs.\nIn pra ti e, the hoi e of bran h literal is ru ial to the performan e of the algorithm. (Note that by hoosing a bran h literal :l instead of l, we an also sele t the order in whi h values are tried for the underlying variable.) Relatively early work on dpll fo used on the sele tion of bran h variables that produ ed as many unit propagations as possible, thus redu ing the size of the residual problems that had to be solved re ursively. As we will see in Se tion 2.3, however, more re ent ideas appear to be more e e tive.\nMissing from Pro edure 2.2, however, is a des ription of the propagation pro ess. Here\nit is:\nPro edure 2.3 (Unit propagation) To ompute Unit-Propagate(P ):\n1 while no ontradi tion is found and there is a 2 C that under P\nhas no satis ed literals and exa tly one unassigned literal\n2 do v the variable in unassigned by P 3 P P [ fv = V : V is sele ted so that is satis edg 4 return P\nDpll has a variety of well-known theoreti al properties. It is sound and omplete in that every andidate solution returned is a solution of the original problem, and su h a solution will be returned if one exists (and failure eventually reported if no solution exists).\nFrom a pra ti al point of view, the running time of dpll is obviously potentially exponential in the size of the problem, sin e at ea h iteration, possibly only a single variable is assigned a value before the routine is invoked re ursively. In pra ti e, of ourse, unit propagation an redu e the number of bran h points substantially, but the running time remains exponential on diÆ ult instan es (Crawford & Auton, 1996).\nWe also point out that on diÆ ult problem instan es, most of the running time is ne essarily spent exploring portions of the sear h spa e in whi h there are no solutions. After all, if P is a partial assignment that an be extended to a solution, the algorithm will never ba ktra k away from P . (Indeed, it annot and retain ompleteness, sin e P may be the only variable assignment that extends to a full solution at this point.) Given that there an be no ba ktra k away from a satis able partial assignment, and that the number of ba ktra ks is exponential in the problem size, it is lear that most of the time spent by the program is indeed in evaluating unsatis able regions of the sear h spa e."
    }, {
      "heading" : "2.1 Unit Propagation: The Inner Loop",
      "text" : "When the dpll algorithm 2.2 is implemented and run on pra ti al problems, the bulk of the running time is spent in unit propagation. As an example, Figure 1 gives the amount of time spent by zChaff on a variety of mi ropro essor test and veri ation examples made available by Velev (http://www.e e. mu.edu/~mvelev). 4 As the problems be ome more diÆ ult, an in reasing fra tion of the omputational resour es are devoted to unit propagation. For this reason, mu h early work on improving the performan e of dpll fo used on improving the speed of unit propagation.\n4. The examples used to generate the graph are those solved by zChaff within 100 se onds using an Intel\nPentium 4M running at 1.6GHz. For those not solved within the 100 se ond limit, an average of 89.4% of the time was spent unit propagating.\nWithin the unit propagation pro edure 2.3, the bulk of the time is spent identifying lauses that propagate; in other words, lauses that are not satis ed by the partial assign-\nment and ontain at most one unvalued literal:\nObservation 2.4 EÆ ient implementations of dpll typi ally spend the bulk of their e ort sear hing for lauses satisfying the onditions required for unit propagation.\nBefore we go on to examine the te hniques that have been used to speed unit propagation in pra ti e, let us remark that other implementations of sat solvers have similar properties. Nonsystemati solvers su h as wsat (Selman et al., 1993), for example, spend the bulk of their time looking for lauses ontaining no satis ed or unvalued literals (or, equivalently, maintaining the data stru tures needed to make su h sear h eÆ ient). We an generalize Observation 2.4 to get:\nObservation 2.5 EÆ ient implementations of sat solvers typi ally spend the bulk of their e ort sear hing for lauses satisfying spe i synta ti onditions relative to a partial or\nomplete truth assignment.\nWhile the fo us of our survey is on systemati methods, we remark that be ause of the similarity of the te hniques used in dpll and in wsat, te hniques that speed the inner loop of one are likely to speed the inner loop of the other as well.\nThat said, let us des ribe the series of ideas that have been employed in speeding the\npro ess of identifying lauses leading to unit propagations:\n1. After binding a variable v, examine ea h lause to determine whether or not it satis es\nthe onditions of Pro edure 2.3.\n2. Slightly more sophisti ated is to restri t the sear h for a suitable lause to those lauses\n2 C that in lude :v as one of the disjun ts (assuming that v has been assigned the value true). After all, if v appears in , is satis ed after v is set to true; if v is not mentioned in there an be no hange in 's ability to unit propagate when v's value is set.\n3. When we set v to true above, as we examine lauses ontaining :v, we have to walk\nea h su h lause to determine just whi h literals are satis ed (if any) and whi h are still unbound. It is more eÆ ient to keep a re ord, for ea h lause , of the number s( ) of satis ed and the number u( ) of unbound literals.\nIn order to keep these ounts urrent when we set a variable v to true, we need to in rement s( ) and de rement u( ) for ea h lause where v appears, and to simply de rement u( ) for ea h lause where :v appears. If we ba ktra k and unset v, we need to reverse these adjustments.\nCompared to the previous approa h, we need to examine four times as many lauses (those where v appears with either sign, and both when v is set and unset), but ea h examination takes onstant time instead of time proportional to the lause length. If the average lause length is greater than four, this approa h, due to Crawford and Auton (1996), will be more e e tive than its prede essor.\n4. Currently, the most eÆ ient s heme for sear hing for unit propagations is the wat hed\nliterals family of implementations (Moskewi z et al., 2001; Zhang & Sti kel, 2000). For ea h lause , we identify two \\wat hed\" literals l\n1\n( ) and l\n2\n( ); the basi idea\nis that as long as these two literals are both either unvalued or satis ed, the lause\nannot produ e a unit propagation.\nIt is only when one of the wat hed literals is set to false that the lause must be examined in detail. If there is another unset (and unwat hed) literal, we wat h it. If there is a satis ed literal in the lause, we need do nothing. If there is no satis ed literal, the lause is ready to unit propagate.\nIf the average lause length is l, then when we set a variable v (say to true), the probability is approximately 2=l that we will need to analyze a lause in whi h :v appears, and the work involved is proportional to the length of the lause. So the expe ted amount of work involved is twi e the number of lauses in whi h :v appears, an improvement on the previous methods. In fa t, the approa h is somewhat more eÆ ient than this ursory analysis suggests be ause the adjustment of the wat hed literals tends to favor wat hing those that are set deep in the sear h tree.\nBefore we move on to dis uss learning in Boolean satis ability, let us remark brie y on the so- alled \\pure literal\" rule. To understand the rule itself, suppose that we have a theory T and some partial variable assignment P . Suppose also that while a literal q appears in some of the lauses in T that are not yet satis ed by P , the negation :q does not appear in any su h lauses. Now while q may not be a onsequen e of the partial assignment P , we an learly set q to true without removing any solutions from the portion of the sear h spa e that remains.\nThe pure literal rule is not generally in luded in implementations of either the dpll or the unit propagation pro edure be ause it is relatively expensive to work with. Counts of the number of unsatis ed lauses ontaining variables and their negations must be maintained at all times, and he ked to see if a literal has be ome pure. In addition, we will see in Se tion 2.3 that many bran hing heuristi s obviate the need for the pure literal rule to be employed."
    }, {
      "heading" : "2.2 Learning and Relevan e",
      "text" : "Let us now turn to the nal olumn of our table, onsidering the progress that has been made in avoiding rework in Boolean satis ability engines. The basi idea is to avoid situations where a onventional implementation will \\thrash\", solving the same subproblem many times in di erent ontexts.\nTo understand the sour e of the diÆ ulty, onsider an example involving a sat problem\nC with variables v\n1\n; v\n2\n; : : : ; v\n100\n, and suppose also that the subset of C involving only\nvariables v\n50\n; : : : ; v\n100\nin fa t implies that v\n50\nmust be true.\nNow imagine that we have onstru ted a partial solution that values the variables\nv\n1\n; : : : ; v\n49\n, and that we initially set v\n50\nto false. After some amount of ba ktra king,\nwe realize that v\n50\nmust be true. Unfortunately, if we subsequently hange the value of\none of the v\ni\n's for i < 50, we will \\forget\" that v\n50\nneeds to be true and are in danger of\nsetting it to false on e again, followed by a repetition of the sear h that showed v\n50\nto be a\nonsequen e of C. Indeed, we are in danger of solving this subproblem not just twi e, but\non e for ea h sear h node that we examine in the spa e of v\ni\n's for i < 50.\nAs we have indi ated, the solution to this problem is to a he the fa t that v\n50\nneeds\nto be true; this information is generally saved in the form of a new lause alled a nogood . In this ase, we re ord the unary lause v\n50\n. Modifying our original problem C in this\nway will allow us to immediately prune any subproblem for whi h we have set v\n50\nto false.\nThis te hnique was introdu ed by Stallman and Sussman (1977) in dependen y dire ted ba ktra king .\nLearning new onstraints in this way an prevent thrashing. When a ontradi tion is en ountered, the set of assignments that aused the ontradi tion is identi ed; we will\nall this set the on i t set. A new onstraint an then be onstru ted that ex ludes the assignments in the on i t set. Adding this onstraint to the problem will ensure that the faulty set of assignments is avoided in the future.\nThis des ription of learning is fairly synta ti ; we an also give a more semanti des ription. Suppose that our partial assignment ontains fa;:b; d;:eg and that our problem\nontains the lauses\n:a _ b _ _ :d _ e (1)\nand\n: _ :d: (2)\nThe rst lause unit propagates to allow us to on lude ; the se ond allows us to on lude : . This ontradi tion auses us to ba ktra k, learning the nogood\n:a _ b _ :d _ e: (3)\nFrom a semanti point of view, the derived nogood (3) is simply the result of resolving the reason (1) for : with the reason (2) for .\nThis is a general phenomenon. At any point, suppose that v is a variable that has been set in the partial assignment P . If v's value is the result of a bran h hoi e, there is no asso iated reason. If v's urrent value is the result of a unit propagation, however, we asso iate to v as a reason the lause that produ ed the propagation. If v's value is the result of a ba ktra k, that value must be the result of a ontradi tion identi ed for some subsequent variable v 0 and we set the reason for v to be the result of resolving the reasons for v 0 and :v 0 . At any point, any variable whose value has been for ed will have an asso iated reason, and these a umulated reasons will avoid the need to reexamine any parti ular portion of the sear h spa e.\nModifying dpll to exploit the derived information requires that we in lude the derived lauses in the overall problem C, thus enabling new unit propagations and restri ting subsequent sear h. But there is an impli it hange as well.\nIn our earlier example, suppose that we have set the variables v\n1\n; : : : ; v\n49\nin that order,\nand that we have learned the nogood\nv\n7\n_ :v\n9\n(4)\n(presumably in a situation where v\n7\nis false and v\n9\nis true). Now as long as v\n7\nremains false\nand v\n9\nremains true, unit propagation will fail immediately be ause (4) is unsatis ed. This\nwill allow us to ba ktra k dire tly to v\n9\nin this example. This is the semanti justi ation\nfor a te hnique known as ba kjumping (Gas hnig, 1979) be ause the sear h \\jumps ba k\" to a variable that is relevant to the problem at hand. 5\nWhile attra tive in theory, however, this te hnique is diÆ ult to apply in pra ti e. The reason is that a new nogood is learned with every ba ktra k; sin e the number of ba ktra ks is proportional to the running time of the program, an exponential number of nogoods an be learned. This an be expe ted both to overtax the memory available on the system where the algorithm is running, and to in rease the time for ea h node expansion. As the number of lauses ontaining any parti ular variable v grows without bound, the unit propagation pro edure 2.3 will grind to a halt.\nAddressing this problem was the primary fo us of work on systemati sat solvers during the 1990's. Sin e it was impra ti al to retain all of the nogoods that had been learned, some method needed to be found that would allow a polynomial number of nogoods to be retained while others were dis arded. The hope was that a relatively small number of nogoods ould still be used to prune the sear h spa e e e tively. 6\nLength-bounded Learning The rst method used to bound the size of the set of learned\nlauses was to only retain lauses whose length is less than a given bound k (De hter, 1990; Frost & De hter, 1994). In addition to providing a polynomial bound on the number of nogoods retained, this approa h was felt likely to retain the most important learned lauses, sin e a lause of length l will in general prune 1\n2\nl\nof the possible assignments of values to\nvariables. Length-bounded learning draws from this observation the on lusion that short\nlauses should be retained in preferen e to long ones.\nRelevan e-bounded Learning Unfortunately, length may not be the best indi ator of the value of a parti ular learned lause. If we restri t our attention to any parti ular subproblem in the sear h, some short lauses may not be appli able at all, while other longer lauses may lead to signi ant pruning. As an example, onsider a node de ned by the partial assignment P = fa; b; g together with the two learned lauses:\na _ b _ e (5)\n:a _ :b _ : _ d _ e (6)\nAs long as the assignments in P are retained, the lause (5) annot be used for pruning be ause it is satis ed by P itself. In fa t, this lause will not be useful until we ba ktra k and hange the values for both a and for b. The lause (6) is more likely to be useful in the\nurrent subproblem, sin e it will lead to a unit propagation if either d or e is set to false. If the subproblem below the node given by P is large, (6) may be used many times. Within the ontext of this subproblem, the longer lause is a tually the more useful.\n5. In this parti ular example, it is also possible to ba ktra k over v\n8\nas well, although no reason is re orded.\nThe bran h point for v\n8\nis removed from the sear h, and v\n9\nis set to false by unit propagation. The\nadvantage of this is that there is now exibility in either the hoi e of value for v\n8\nor the hoi e of\nbran h variable itself. This idea is related to Baker's (1994) work on the diÆ ulties asso iated with some ba kjumping s hemes, and is employed in zChaff (Moskewi z et al., 2001). 6. Indeed, the nal olumn of our table might better be named \\forgetting\" than \\learning\". Learning\n(everything) is easy; it's forgetting in a oherent way that's hard.\nAt some level, the appearan e of :a, :b, and : in (6) shouldn't ontribute to the e e tive length of the learned lause be ause that all of these literals are urrently false. Length-bounded learning annot make this distin tion.\nWe see from this example that it is useful to retain lauses of arbitrary length provided that they are relevant to the urrent sear h ontext. If the ontext subsequently hanges, we an remove some lauses to make room for new ones that are more suitable to the new\nontext. This is what relevan e-bounded learning does.\nIn relevan e-bounded learning, the e e tive length of a lause is de ned in terms of the urrent partial assignment. The irrelevan e of a lause is de ned as one less than the number of unvalued or satis ed literals it ontains. For example, the lause (6) under the partial assignment P has an irrelevan e of 1. The idea of relevan e-bounded learning originated in dynami ba ktra king (Ginsberg, 1993), in whi h lauses were deleted if their irrelevan e ex eeded 1. This idea was generalized by Bayardo and Miranker (1996), who de ned a general relevan e bound and then deleted all lauses whose irrelevan e ex eeded that bound. This generalization is implemented in the relsat satis ability engine (Bayardo & S hrag, 1997).\nLike length-bounded learning, relevan e-bounded learning retains all lauses of length less than the irrelevan e bound k, sin e the irrelevan e of a lause an never ex eed its length. But the te hnique of relevan e-bounded learning also allows the retention of longer\nlauses if they are appli able to the urrent portion of the sear h spa e. Su h lauses are\nonly removed when they are no longer relevant.\nReturning to our example, if we ba ktra k from the original partial assignment with fa; b; g and nd ourselves exploring f:a;:b;: g, the short nogood (5) will be 0-irrelevant (sin e we an unit propagate to on lude e) and the long one (6) will be 4-irrelevant. Using a relevan e bound of 3 or less, this nogood would be dis arded.\nThe ondition that nogoods are only retained until their irrelevan e ex eeds a bound k\nis suÆ ient to ensure that only a polynomial number of nogoods are retained at any point.\n7\nExperimental results (Bayardo & Miranker, 1996) show that relevan e-bounded learning is more e e tive than its length-bounded ounterpart and, even with a relevan e bound of 1, the results are omparable to those of learning without restri tion. 8\nHybrid Approa hes Finally, we note that some solvers employ a hybrid approa h. The\nhaff algorithm (Moskewi z et al., 2001) uses both a relevan e bound and a (larger) length bound. Clauses must meet both the relevan e bound and the length bound to be retained.\nYet another approa h is taken by the berkmin algorithm (Goldberg & Novikov, 2002). Here, the set of nogoods is partitioned into two separate groups based on how re ently the nogoods were a quired; 15\n16\nof the nogoods are kept in a \\re ent\" group and the remaining\n1\n16\nin an \\old\" group. A relatively large length bound is used to ull the re ently a quired nogoods while a smaller length bound is used to aggressively ull the smaller group of older\n7. Although a epted wisdom, we know of no proof in the literature of this result; Bayardo and Miranker's\n(1996) proof appears to assume that the order in whi h bran h variables are hosen is xed. We present a general proof in the next paper in this series (Dixon et al., 2003b). 8. Results su h as these ne essarily be ome somewhat suspe t as algorithmi methods mature; an unfortu-\nnate onsequen e of the extremely rapid progress in satis ability engines over re ent years is the la k of\nareful experimental work evaluating the host of new ideas that have been developed.\nnogoods. We are not aware of any studies omparing these hybrid approa hes to pure length-bounded or relevan e-bounded methods."
    }, {
      "heading" : "2.3 Bran hing Heuristi s",
      "text" : "Let us now turn to an examination of the progress that has been made in the development of e e tive heuristi s for the sele tion of bran h variables in dpll. As dis ussed in the introdu tion, we fo us not on spe i heuristi s that work in sele ted domains, but on general ideas that attempt to exploit the stru ture of the axiomatization dire tly.\nPrior to the development of su essful learning te hniques, bran hing heuristi s were the primary method used to redu e the size of the sear h spa e. It seems likely, therefore, that the role of bran hing heuristi s is likely to hange signi antly for algorithms that prune the sear h spa e using learning. While the heuristi s used in zChaff appear to be a rst step in this dire tion, very little is known about this new role.\nInitially, however, the primary riterion for the sele tion of a bran h variable was to pi k one that would enable a as ade of unit propagations; the result of su h a as ade is a smaller and more tra table subproblem. 9\nThe rst rule based on this idea is alled the moms rule, whi h bran hes on the variable that has Maximum O urren es in lauses of Minimum Size (Crawford & Auton, 1996; Dubois, Andre, Boufkhad, & Carlier, 1993; Hooker & Vinay, 1995; Jeroslow & Wang, 1990; Pretolani, 1993). Moms provides a rough but easily omputed approximation to the number of unit propagations that a parti ular variable assignment might ause.\nAlternatively, one an use a \\unit propagation rule\" (Crawford & Auton, 1996; Freeman, 1995), and ompute the exa t number of propagations that would be aused by a bran hing\nhoi e. Given a bran hing andidate v\ni\n, the variable is separately xed to true and to false\nand the unit propagation pro edure is exe uted for ea h hoi e. The pre ise number of unit propagations aused is then used to evaluate possible bran hing hoi es. Unlike the moms heuristi , this rule is obviously exa t in its attempt to judge the number of unit propagations\naused by a potential variable assignment. Unfortunately, it is also onsiderably more expensive to ompute be ause of the expense of unit propagation itself. This led to the adoption of omposite approa hes (Li & Anbulagan, 1997) where moms is used to identify a small number of bran hing andidates, ea h of whi h is then evaluated exa tly using the more expensive unit propagation heuristi . On randomly generated problems, the omposite te hnique outperforms either heuristi in isolation.\nAnother strategy is to bran h on variables that are likely to be ba kbone variables (Dubois & Dequen, 2001). A ba kbone literal (also often referred to as a unary prime impli ate of a theory) is one that must be true in all solutions to a given problem. Given a problem C and a partial assignment P , the ba kbone heuristi attempts to bran h on variables that are ba kbones of the subset of those lauses in C that are satis ed by P ; the likelihood that any parti ular variable is a ba kbone literal is approximated by ounting the appearan es\n9. This idea tends to obviate the need for use of the pure literal rule, as well. If p is a pure literal, there is\nno parti ular reason to hurry to set p to true; the key thing is to avoid setting it to false. But if p is pure, :p annot generate any unit propagations, so p will tend not to be sele ted as a bran h variable. Pure literals an obviously never be set false by unit propagation, so heuristi s based on unit propagation\nounts tend to a hieve most of the advantages of the pure literal rule without in urring the asso iated omputational osts.\nof that literal in the satis ed lauses in C. This heuristi outperforms those dis ussed in the previous paragraphs.\nThe heuristi s des ribed thus far were developed when the ommunity's resear h emphasis was fo used on the solution of randomly generated satis ability problems. The development of bounded learning methods enabled solvers to address the issue of thrashing, and aused a natural shift in fo us toward more stru tured, realisti problems. There are no formal studies omparing the previously dis ussed heuristi s on stru tured problems, and the value of the studies that do exist is redu ed be ause all of the implementations were of dpll in isolation and without the learning te hniques that have sin e proved so important. Bran hing te hniques and learning are deeply related, and the addition of learning to a dpll implementation will have a signi ant e e t on the e e tiveness of any of these bran hing strategies. As new lauses are learned, the number of unit propagations an assignment will\nause an be expe ted to vary; the reverse is also true in that the hoi e of bran h variable an a e t whi h lauses the algorithm learns. A formal omparison of bran hing te hniques' performan e on stru tured problems and in the presen e of learning would be extremely useful.\nBran hing heuristi s that are designed to fun tion well in the ontext of a learning algorithm generally try to bran h on variables about whi h things have been learned re ently. This tends to allow the implementation to keep \\making progress\" on a single se tion of the sear h spa e as opposed to moving from one area to another; an additional bene t is that existing nogoods tend to remain relevant, avoiding the ineÆ ien ies asso iated with losing the information present in nogoods that be ome irrelevant and are deleted. In zChaff, for example, a ount is maintained of the number of times ea h literal o urs in the theory being solved. When a new lause is added, the ount asso iated with ea h literal in the\nlause is in remented. The bran h heuristi then sele ts a variable that appears in as many lauses as possible. By periodi ally dividing all of the ounts by a onstant fa tor, a bias is introdu ed toward bran hing on variables that appear in re ently learned lauses. Like the moms rule, this rule is inexpensive to al ulate.\nThe heuristi used in berkmin (Goldberg & Novikov, 2002) builds on this idea but responds more dynami ally to re ently learned lauses. The berkmin heuristi prefers to bran h on variables that are unvalued in the most re ently learned lause that is not yet satis ed, with a zChaff-like heuristi used to break ties.\nAll told, there are many ompeting bran hing heuristi s for satis ability solvers, and there is still mu h to be done in evaluating their relative e e tiveness. The most interesting experiments will be done using implementations that learn, and on realisti , stru tured problems as opposed to randomly generated ones."
    }, {
      "heading" : "2.4 Proof Complexity",
      "text" : "We have already ommented brie y on the fa t that proof systems an be evaluated based on provable bounds on the proofs of ertain lasses of formulae, or by the development of polynomial transformations from proofs in one system into proofs in another.\nWith regard to the rst metri , there are at least three lasses of problems known to be exponentially diÆ ult for onventional resolution-based provers (in luding any dpll implementation): 10\n1. Pigeonhole problems (Haken, 1985)\n2. Parity problems (Tseitin, 1970)\n3. Clique oloring problems (Bonet, Pitassi, & Raz, 1997; Kraj'i ek, 1997; Pudlak, 1997)\nBefore turning to a dis ussion of these problems spe i ally, however, let us point out that there are many proof systems that are known to be more powerful than any of the ones we dis uss in this paper. From our perspe tive, the most interesting is extended resolution and involves the introdu tion of new variables that orrespond to arbitrary logi al expressions built up out of the original variables in the theory.\nSin e su h logi al expressions an always be built up term-by-term, it suÆ es to allow the introdu tion of new variables orresponding to pairwise ombinations of existing ones; sin e disjun tion an be repla ed with onjun tion using de Morgan's laws, it suÆ es to introdu e new variables of the form\nw x ^ y (7)\nfor literals x and y. Writing (7) in disjun tive normal form, we get:\nDe nition 2.6 (Tseitin, 1970) An extended resolution proof for a theory T is one where T is rst augmented by a olle tion of groups of axioms, ea h group of the form\n:x _ :y _ w\nx _ :w (8)\ny _ :w\nwhere x and y are literals in the (possibly already extended) theory T and w is a new variable. Following this, derivation pro eeds using onventional resolution on the augmented theory.\nThere is no proof system known to be stronger than extended resolution; in fa t, there is no lass of problems for whi h there are known to be no polynomially sized proofs in extended resolution.\nAs we have stressed, however, the fa t that a proof system is strong does not mean that it works well in pra ti e. We know of no implementation of extended resolution for the simple reason that virtually nothing is known about how to sele t new variables so as to shorten proof length.\nUnderstanding why the introdu tion of these new variables an redu e proof length is onsiderably simpler. As an example, suppose that during a resolution proof, we have managed to derive the nogood a_x, and that we have also derived a_y. In order to omplete the proof, we need to perform lengthy { but identi al { analyses of ea h of these nogoods, eventually deriving simply x from the rst and y from the se ond (and then resolving against :x _ :y, for example).\n10. There are other hard problems as well, su h as Haken's (1995) broken mosquito s reen problem. The\nthree examples quoted here are suÆ ient for our purposes.\nIf we ould repla e the pair of nogoods a _ x and a _ y with the single nogood a _ w using (8), the two proofs from a _ x and a _ y ould be ollapsed into a single proof, potentially halving the size of the proof in its entirety. Introdu ing still more variables an repeat the e e t, resulting in exponential redu tions in proof size.\nAnother way to look at this is as an improvement in expressivity. There is simply no way to write (a _ x) ^ (a _ y) or the equivalent a _ (x ^ y) as a single Boolean axiom in disjun tive normal form. The power of extended resolution rests on the fa t that subexpression substitution makes it possible to apture expressions su h as a_ (x^ y) in a single axiom.\nNone of the proof systems being onsidered in this survey is as powerful as extended resolution, and we will therefore evaluate them based on their performan e on the three problems mentioned at the beginning of this se tion. Let us therefore des ribe ea h of those problems in some detail."
    }, {
      "heading" : "2.4.1 Pigeonhole problems",
      "text" : "The pigeonhole problem involves showing that it is impossible to put n+ 1 pigeons into n holes if ea h pigeon must go into a distin t hole. If we write p\nij\nfor the fa t that pigeon i is\nin hole j, then a straightforward axiomatization says that every pigeon must be in at least one hole:\np\ni1\n_ p\ni2\n_ _ p\nin\nfor i = 1; : : : ; n+ 1 (9)\nand that no two pigeons an be in the same hole:\n:p\nik\n_ :p\njk\nfor 1 i < j n+ 1 and k = 1; : : : ; n (10)\nNote that there are in all (n\n3\n) axioms of the form (10).\nIt is well known that there is no polynomial-sized proof of the unsatis ability of the axioms (9){(10) (Haken, 1985). The proof is te hni al, but the essential reason is that the pigeonhole problem is \\all about\" ounting. At some point, proving that you an't put n+ 1 pigeons into n holes requires saying that you an't put n pigeons into the last n 1 holes, thus n 1 pigeons into the last n 2 holes, and so on. Saying this in the language of sat is awkward, and it is possible to show that no proof of the pigeonhole problem an be\nompleted without, at some point, working with extremely long individual lauses. On e again, we see the onne tion to expressive eÆ ien y; for readers interested in additional details, Pitassi's (2002) explanation is reasonably a essible."
    }, {
      "heading" : "2.4.2 Parity problems",
      "text" : "By a parity problem, we will mean a olle tion of axioms spe ifying the parity of sets of inputs. So we will write, for example,\nx\n1\nx\nn\n= 1 (11)\nto indi ates that an odd number of the x\ni\nare true; a right hand side of zero would indi ate\nthat an even number were true. The here indi ates ex lusive or.\nRedu tion of (11) to a olle tion of Boolean axioms is best des ribed by an example.\nThe parity onstraint x y z = 1 is equivalent to\nx _ y _ z\nx _ :y _ :z\n:x _ y _ :z\n:x _ :y _ z\nIn general, the number of Boolean axioms needed is exponential in the length of the parity\nlause (11), but for lauses of a xed length, the number of axioms is obviously xed as\nwell.\nFor the proof omplexity result of interest, suppose that G is a graph, where ea h node in G will orrespond to a lause and ea h edge to a literal. We label the edges with distin t literals, and label ea h node of the graph with a zero or a one. Now if n is a node of the graph that is labeled with a value v\nn\nand the edges e\n1n\n; : : : ; e\ni(n);n\nin ident on n are labeled\nwith literals l\n1n\n; : : : ; l\ni(n);n\n, we add to our theory the Boolean version of the lause\nl\n1n\nl\ni(n);n\n= v\nn\n(12)\nSin e every edge onne ts two nodes, every literal in the theory appears exa tly twi e in axioms of the form (12). Adding all of these onstraints therefore produ es a value that is equivalent to zero mod 2 and must be equal to P\nn\nv\nn\nas well. If\nP\nn\nv\nn\nis odd, the theory\nis unsatis able. Tseitin's (1970) prin ipal result is to show that this unsatis ability annot in general be proven in a number of resolution steps polynomial in the size of the Boolean en oding."
    }, {
      "heading" : "2.4.3 Clique oloring problems",
      "text" : "The last examples we will onsider are known as \\ lique oloring problems.\" These are derivatives of pigeonhole problems where the exa t nature of the pigeonhole problem is obs ured. Somewhat more spe i ally, the problems indi ate that a graph in ludes a lique of n+ 1 nodes (where every node in the lique is onne ted to every other), and that the graph must be olored in n olors. If the graph itself is known to be a lique, the problem is equivalent to the pigeonhole problem. But if we know only that the lique an be embedded into the graph, the problem is more diÆ ult.\nIn the axiomatization, we use e\nij\nto des ribe the edges of the graph,\nij\nto des ribe the\noloring of the graph, and q\nij\nto des ribe the embedding of the liQue into the graph. The\ngraph has m nodes, the lique is of size n + 1, and there are n olors available. So the axiomatization is:\n:e\nij\n_ :\nil\n_ :\njl\nfor 1 i < j m, l = 1; : : : ; n (13)\ni1\n_ _\nin\nfor i = 1; : : : ;m (14)\nq\ni1\n_ _ q\nim\nfor i = 1; : : : ; n+ 1 (15)\n:q\nij\n_ :q\nkj\nfor 1 i < k n+ 1, j = 1; : : : ;m (16)\ne\nij\n_ :q\nki\n_ :q\nlj\nfor 1 i < j m, 1 k 6= l n+ 1 (17)\nHere e\nij\nmeans that there is an edge between graph nodes i and j,\nij\nmeans that graph\nnode i is olored with the jth olor, and q\nij\nmeans that the ith element of the lique is\nmapped to graph node j. Thus the rst axiom (13) says that two of the m nodes in the graph annot be the same olor (of the n olors available) if they are onne ted by an edge. (14) says that every graph node has a olor. (15) says that every element of the lique appears in the graph, and (16) says that no two elements of the lique map to the same node in the graph. Finally, (17) says that the lique is indeed a lique { no two lique elements an map to dis onne ted nodes in the graph.\nSin e there is no polynomially sized resolution proof of the pigeonhole problem in Boolean satis ability, there is obviously no polynomially sized proof of the lique oloring problems, either. But as we shall see, lique oloring problems an in some ases be used to distinguish among elements of the proof omplexity hierar hy."
    }, {
      "heading" : "2.5 Boolean Summary",
      "text" : "We summarize the results of this se tion by ompleting the rst row of our table as follows:\np-simulation unit\nrep. e . hierar hy inferen e propagation learning\nSAT 1 EEE resolution wat hed literals relevan e\nardinality\nPB\nsymmetry\nQPROP\nThe entries are really just an informal shorthand:\nRepresentational eÆ ien y: Boolean satis ability is the ben hmark against whi h other languages will be measured; we give here the relative savings to be had by\nhanging representation.\np-simulation hierar hy: We give the proof omplexity for the three problem lasses dis ussed in Se tion 2.4. For Boolean satis ability, all of the problems require proofs of exponential length.\nInferen e: The basi inferen e me hanism used by dpll is resolution.\nPropagation: Wat hed literals lead to the most eÆ ient implementation.\nLearning: Relevan e-based learning appears to be more e e tive than other polysized methods."
    }, {
      "heading" : "3. Pseudo-Boolean and Cardinality Constraints",
      "text" : "The entries in the previous table summarize the fa t that Boolean satis ability is a weak method that admits eÆ ient implementations. The representation is relatively ineÆ ient, and none of our anoni al problems an be solved in polynomial time. Some of these diÆ ulties, at least, an be over ome via a representational shift.\nTo understand the shift, note that we an write an axiom su h as\nx _ y _ :z\nas\nx+ y + z 1 (18)\nwhere we are now thinking of x; y and z as variables with value either 0 (false) or 1 (true) and have written z for 1 z or, equivalently, :z. If v is a variable, we will ontinue to refer to v as the negation of v.\nAll of the familiar logi al operations have obvious analogs in this notation. If, for\nexample, we want to resolve\na _ :b _\nwith\nb _ :d\nto get a _ _ :d, we simply add\na+ b+ 1\nto\nb+ d 1\nand simplify using the identity b+ b = 1 to get\na+ + d 1\nas required.\nWhat's ni e about this notation is that it extends easily to more general des riptions.\nIf the general form of a disjun tion _l\ni\nof literals is\nP\nl\ni\n1 as in (18), we an drop the\nrequirement that the right-hand side be 1:\nDe nition 3.1 A ardinality onstraint or extended lause is a onstraint of the form\nX\ni\nl\ni\nk\nwhere k is an integer and ea h of the l\ni\nis required to have value 0 or 1.\nThe ardinality onstraint simply says that at least k of the literals in question are true.\nProposition 3.2 (Cook, Coullard and Turan (1987)) There is an unsatis ability proof of polynomial length of the pigeonhole problem using ardinality onstraints.\nProof. Cook et al. (1987) give a derivation in o(n\n3\n) steps; we have presented an o(n\n2\n)\nderivation elsewhere (Dixon & Ginsberg, 2000).\nOf ourse, the fa t that this extension to the sat language allows us to nd polynomiallength derivations of pigeonhole problem does not ne essarily show that the hange will have omputational value; we need to examine the other olumns of the table as well. In the remainder of this se tion, we will show this and will go further, des ribing new\nomputational te hniques that an only be applied in the broader setting that we are now onsidering. Experimental results are also presented. But let us begin by examining the rst olumn of the table:\nProposition 3.3 (Benhamou, Sais, & Siegel, 1994) The ardinality onstraint\nx\n1\n+ + x\nm\nk (19)\nis logi ally equivalent to the set of\nm\nk 1\naxioms\nx\ni\n1\n+ + x\ni\nm k+1\n1 (20)\nfor every set of m k + 1 distin t variables fx\ni\n1\n; : : : ; x\ni\nm k+1\ng. Furthermore, there is no\nmore ompa t Boolean en oding of (19).\nProof. We rst show that (19) implies (20). To see this, suppose that we have a set S of m k+1 variables. Suppose also that T is the set of x\ni\n's that are true, so that T is of size\nat least k. Sin e there are only m variables, S \\ T 6= and at least one x\ni\n2 S must be\ntrue.\nTo see that (20) implies (19), suppose that (20) is true for all appropriate sets of x\ni\n's.\nNow if (19) were false, the set of false x\ni\n's would be of size at least m k+1, so that some\ninstan e of (20) would be unsatis ed.\nTo see that there is no more eÆ ient en oding, rst note that if (19) implies a Boolean\naxiom\nx\n1\n_ _ x\nk\n_ :x\nk+1\n_ _ :x\nm\nthen it must also imply\nx\n1\n_ _ x\nk\nsin e we an always hange an x\ni\nfrom false to true without redu ing the satis ability\nof (19).\nNext, note that no axiom of length less than m k + 1 is a onsequen e of (19), sin e any su h axiom an be falsi ed while satisfying (19) by setting every unmentioned variable to true and the rest to false.\nFinally, suppose that we leave out a single instan e i of (20) but in lude all of the others as well as every lause of length greater than m k+1. By setting the variables in i to false and every other variable to true, all of the given lauses will be satis ed but (19) will not be. It follows that any Boolean equivalent of (19) must in lude at least the m\nk 1\ninstan es\nof (20). It follows from Proposition 3.3 that provided that no new variables are introdu ed, ardinality onstraints an be exponentially more eÆ ient than their Boolean ounterparts.\nBefore dis ussing the other olumns in the table, let us onsider further extending our\nrepresentation to in lude what are known as pseudo-Boolean onstraints:\nDe nition 3.4 A pseudo-Boolean onstraint is an axiom of the form\nX\ni\nw\ni\nl\ni\nk (21)\nwhere ea h w\ni\nand k is a positive integer and ea h of the l\ni\nis required to have value 0 or 1.\nPseudo-Boolean representations typi ally allow both linear inequalities and linear equalities over Boolean variables. Linear equalities an easily be translated into a pair of inequalities of the form in the de nition; we prefer the inequality-based des ription (Barth, 1996; Chandru & Hooker, 1999, also known as pseudo-Boolean normal form) be ause of the better analogy with Boolean satis ability and be ause unit propagation be omes unmanageable if equality onstraints are onsidered. Indeed, simply determining if an equality lause is satis able subsumes subset-sum and is therefore (weakly) NP- omplete (Garey & Johnson, 1979).\nCompare (21) with De nition 3.1; the w\ni\nare the weights atta hed to various literals. The\npseudo-Boolean language is somewhat more exible still, allowing us to say (for example)\n2a+ b+ 2\nindi ating that either a is true or both b and : are (equivalent to the ru ial representational eÆ ien y obtained in extended resolution). As we will see shortly, it is natural to make this further extension be ause the result of resolving two ardinality onstraints an be most naturally written in this form."
    }, {
      "heading" : "3.1 Unit Propagation",
      "text" : "Let us begin by dis ussing propagation te hniques in a ardinality or pseudo-Boolean setting. 11\nA pseudo-Boolean version of unit propagation was rst presented by Barth (1996) and is des ribed in a number of papers (Aloul, Ramani, Markov, & Sakallah, 2002; Dixon & Ginsberg, 2000). In the Boolean ase, we an des ribe a lause as unit if it ontains no satis ed literals and at most one unvalued one. To generalize this to the pseudo-Boolean setting, we make the following de nition, where we view a partial assignment P simply as the set of literals that it values to true:\nDe nition 3.5 Let\nP\ni\nw\ni\nl\ni\nk be a pseudo-Boolean lause, whi h we will denote by .\nNow suppose that P is a partial assignment of values to variables. We will say that the\nurrent value of under P is given by\nurr( ; P ) =\nX\nfijl\ni\n2Pg\nw\ni\nk\nIf no ambiguity is possible, we will write simply urr( ) instead of urr( ; P ). In other words, urr( ) is the sum of the weights of literals that are already satis ed by P , redu ed by the required total weight k.\nIn a similar way, we will say that the possible value of under P is given by\nposs( ; P ) =\nX\nfij:l\ni\n62Pg\nw\ni\nk\n11. As we have remarked, our table is designed to re e t the issues involved in lifting dpll to a more\nexpressive representation. Extending a nonsystemati sear h te hnique su h as wsat to a pseudoBoolean setting has been dis ussed by Walser (1997) and Prestwi h (2002).\nIf no ambiguity is possible, we will write simply poss( ) instead of poss( ; P ). In other words, poss( ) is the sum of the weights of literals that are either already satis ed or not valued by P , redu ed by the required total weight k. 12\nDe nition 3.6 Let be a lause, and P a partial assignment. We will say that is unit if there is a variable v not appearing in P su h that either P [ fvg or P [ f:vg annot be extended to an assignment that satis es .\nIn this situation, the variable v is for ed to take a value that will help satisfy the lause. This reates a new onsequential assignment. Note that if is already unsatis able, we an meet the onditions of the de nition by hoosing v to be any variable not assigned a value by P . Note also that in the pseudo-Boolean ase, a lause may a tually ontain more than one variable that is for ed to a spe i value. It should be lear that in the Boolean ase, this de nition dupli ates the onditions of the original unit propagation pro edure 2.3.\nLemma 3.7 A partial assignment P an be extended in a way that satis es a lause if and only if poss( ; P ) 0.\nProof. Assume rst that poss( ; P ) 0, and suppose that we value every remaining variable in a way that helps to satisfy . Having done so, every literal in that is not\nurrently made false by P will be true, and the resulting value of will be\nX\ni\nw\ni\nl\ni\n=\nX\nfij:l\ni\n62Pg\nw\ni\n= poss( ; P ) + k k\nso that be omes satis ed.\nConversely, suppose that poss( ; P ) < 0. Now the best we an do is still to value the\nunvalued literals favorably, so that the value of be omes\nX\ni\nw\ni\nl\ni\n=\nX\nfij:l\ni\n62Pg\nw\ni\n= poss( ; P ) + k < k\nand is unsatis able.\nProposition 3.8 A lause ontaining at least one unvalued literal is unit if and only if\nontains an unvalued literal l\ni\nwith weight w\ni\n> poss( ).\nProof. If there is a literal with weight w\ni\n> poss( ), setting that literal to false will redu e\nposs( ) by w\ni\n, making it negative and thus making the unsatis able. Conversely, if there\nis no su h literal, then poss( ) will remain positive after any single unvalued literal is set, so that remains satis able and is therefore not unit.\nGiven the above result, there is little impa t on the time needed to nd unit lauses. We need simply keep the literals in ea h lause sorted by weight and maintain, for ea h\nlause, the value of poss and the weight of the largest unvalued literal. If we value a literal with di erent weight, we an apply the test in Proposition 3.8 dire tly. If we value a literal of the given weight, a short walk along the lause will allow us to identify the new unvalued literal of maximum weight, so that the proposition ontinues to apply.\n12. Chai and Kuehlmann (2003) refer to poss as sla k.\nWat hed literals Generalizing the idea of wat hed literals is no more diÆ ult. We make the following de nition:\nDe nition 3.9 Let be a lause. A wat hing set for is any set S of variables with the property that annot be unit as long as all of the variables in S are either unvalued or satis ed.\nProposition 3.10 Given a lause of the form\nP\ni\nw\ni\nl\ni\nk, let S be any set of variables.\nThen S is a wat hing set for if and only if\nX\ni\nw\ni\nmax\ni\nw\ni\nk (22)\nwhere the sum and maximum are taken over literals involving variables in S.\nProof. Suppose that all of the variables in S are unvalued or satis ed. Now let l\nj\nbe any\nunvalued literal in . If l\nj\n62 S, then poss( ) w\nj\n+\nP\ni\nw\ni\nk and thus poss( ) w\nj\nsin e\nP\ni\nw\ni\nP\ni\nw\ni\nmax\ni\nw\ni\nk. If, on the other hand, l\nj\n2 S, then\nposs( )\nX\ni\nw\ni\nk\nand\nX\ni\nw\ni\nw\nj\nX\ni\nw\ni\nmax\ni\nw\ni\nk\nCombining these, we get\nposs( ) w\nj\nEither way, we annot have poss( ) < w\nj\nand Proposition 3.8 therefore implies that\nannot be unit. It follows that S is a wat hing set.\nThe onverse is simpler. If\nP\ni\nw\ni\nmax\ni\nw\ni\n< k, value every literal outside of S so as\nto make false. Now poss( ) =\nP\ni\nw\ni\nk, so if l\nj\nis the literal in S with greatest weight,\nthe asso iated weight w\nj\nsatis es w\nj\n> poss( ) and is unit. Thus S annot be a wat hing\nset.\nThis generalizes the de nition from the Boolean ase, a fa t made even more obvious\nby:\nCorollary 3.11 Given a ardinality onstraint requiring at least k of the asso iated literals to be true, S is a wat hing set for if and only if it in ludes at least k + 1 literals in .\nProof. The expression (22) be omes\nX\ni\n1 max\ni\n1 k\nor\njSj 1 k:"
    }, {
      "heading" : "3.2 Inferen e and Resolution",
      "text" : "As with unit propagation, resolution also lifts fairly easily to a pseudo-Boolean setting. The general omputation is as follows:\nProposition 3.12 Suppose that we have two lauses and\n0\n, with given by\nX\ni\nw\ni\nl\ni\n+wl k (23)\nand\n0\ngiven by\nX\ni\nw\n0 i l 0 i + w 0 l k 0\n(24)\nThen it is legitimate to on lude\nX\ni\nw\n0\nw\ni\nl\ni\n+\nX\ni\nww\n0 i l 0 i\nw\n0\nk + wk\n0\nww\n0\n(25)\nProof. This is immediate. Multiply (23) by w\n0\n, multiply (24) by w, add and simplify using\nl + l = 1.\nIf all of the weights, k and k\n0\nare 1, this generalizes onventional resolution provided\nthat the sets of nonresolving literals in and\n0\nare disjoint. To deal with the ase where\nthere is overlap between the set of l\ni\nand the set of l\n0 i , we need:\nLemma 3.13 Suppose that is lause\nP\ni\nw\ni\nl\ni\nk. Then is equivalent to\nP\ni\nw\n0 i l i\nk,\nwhere the w\n0 i are given by:\nw\n0 i (j) =\nw\ni\n; if w\ni\n< k;\nk; otherwise.\nProof. If l\nj\nis a literal with w\nj\nk, then both and the rewrite are true if l\nj\nis satis ed.\nIf l\nj\n= 0, then and the rewrite are equivalent.\nIn other words, we an redu e any oeÆ ient that is greater than what is required to\nsatisfy the lause in its entirety, for example rewriting\n3x+ y + z 2\nas\n2x+ y + z 2\nbe ause either is equivalent to x _ (y ^ :z).\nProposition 3.14 (Cook et al., 1987; Hooker, 1988) The onstru tion of Proposition 3.12 generalizes onventional resolution.\nProof. We have already dis ussed the ase where the sets of l\ni\nand l\n0 i are disjoint. If there\nis a literal l\ni\nin that is the negation of a literal in\n0\n, then we will have l\ni\n+ :l\ni\nin (25),\nwhi h we an simplify to 1 to make the resolved onstraint trivial; resolution produ es the same result. If there is a literal l\ni\nin that also appears in\n0\n, the oeÆ ient of that literal\nin the resolvent (25) will be 2 but an be redu ed to 1 by virtue of the lemma.\nCardinality onstraints are a bit more interesting. Suppose that we are resolving the\ntwo lauses\na + b + 2 a + + d 1\nwhi h we add to get\n2a+ b+ d 2 (26)\nIn other words, either a is true or b and d both are. The problem is that this is not a\nardinality onstraint, and annot be rewritten as one.\nOne possibility is to rewrite (26) as a pair of ardinality onstraints\na+ b 1 (27)\na+ d 1 (28)\nIf, however, we want the result of \\resolving\" a pair of onstraints to be a single axiom, we must either sele t one of the above axioms or extend our language further."
    }, {
      "heading" : "3.3 Learning and Relevan e Bounds",
      "text" : "The idea of relevan e also has a natural generalization to the pseudo-Boolean setting. Re all the basi de nition from Se tion 2.2:\nDe nition 3.15 Let be a lause and P a partial assignment. Then is i-irrelevant if the number of literals in that are either unvalued or true under P is at least i+ 1.\nProposition 3.16 Given a partial assignment P and a Boolean lause , is i-irrelevant if and only if poss( ; P ) i.\nProof. In the Boolean ase, the number of literals in that are either unvalued or true is poss( ; P ) + 1 sin e the right hand side of the onstraint is always 1. So the irrelevan e\nondition is\nposs( ; P ) + 1 i+ 1\nand the result follows.\nIn the pseudo-Boolean ase, additional learning te hniques are also possible. Before we present these ideas in detail, however, let us point out that some sort of inferential extension is needed if we are to over ome the short omings of dpll as revealed by the pigeonhole and other problems. After all, re all Proposition 3.14: pseudo-Boolean inferen e generalizes Boolean resolution. So if we begin with a Boolean axiomatization (as we did in the pigeonhole problem), any derivation using our te hniques will be reprodu ible using\nonventional resolution-based methods, and will therefore be of exponential length. (A majority of the inferen e steps in the various proofs of Proposition 3.2 are not resolution steps in that no literal an ellations o ur.)\nStrengthening The spe i method that we will dis uss is from operations resear h and is used to prepro ess mixed integer programming problems (Guignard & Spielberg, 1981; Savelsbergh, 1994).\nSuppose that after setting l\n0\nto true and applying some form of propagation to our\nonstraint set, we dis over that under this assumption a onstraint given by\nP\nw\ni\nl\ni\nr\nbe omes oversatis ed by an amount s in that the sum of the left hand side is greater (by s) than the amount required by the right hand side of the inequality; in the terms of De nition 3.5, urr( ) = s. The oversatis ed onstraint an now be repla ed by the following:\nsl\n0\n+\nX\nw\ni\nl\ni\nr + s (29)\nIf l\n0\nis true, we know that\nP\nw\ni\nl\ni\nr + s, so (29) holds. If l\n0\nis false, then sl\n0\n= s and we\nstill must satisfy the original onstraint\nP\nw\ni\nl\ni\nr, so (29) still holds. The new onstraint\nimplies the original one, so no information is lost in the repla ement.\nAs we have remarked, the OR ommunity uses this te hnique during prepro essing. A literal is xed, propagation is applied, and any oversatis ed onstraint is strengthened. Consider the following set of lauses:\na+ b 1\na+ 1\nb+ 1\nIf we set a to false, we must then value both b and true in order to satisfy the rst two\nonstraints. The third onstraint is now oversatis ed and an thus be repla ed by\na+ b+ 2\nThe power of this method is that it allows us to build more omplex axioms from a set of simple ones. The strengthened onstraint will often subsume some or all of the onstraints involved in generating it. In this ase, the new onstraint subsumes all three of the generating onstraints.\nProposition 3.17 Let be a onstraint and P a partial assignment. Then if we an on-\nlude that urr( ) s for any solution to our overall problem that extends P , we an repla e\nwith\ns\nX\nP\nl\ni\n+\nX\nw\ni\nl\ni\nr + s (30)\nwhere the rst summation is over literals l\ni\n2 P .\nProof. For any truth assignment that extends P , (30) follows from the fa t that urr( ) s. For any truth assignment P 0 that does not extend P , there is some l\nj\n2 P that is false\nin P\n0\n, and so\ns\nX\nP\nl\ni\ns\nCombining this with the original onstraint on e again produ es (30).\nLearning and inferen e Before we present some experimental results related to the e e tiveness of pseudo-Boolean inferen e, we should point out one additional problem that\nan arise in this setting. It is possible that for some bran h variable v, the result of resolving the reasons for v and :v is a new nogood that is not falsi ed by the partial assignment above v in the sear h spa e.\nAs an example (Dixon & Ginsberg, 2002), suppose that we have a partial assignment\nf:a;:b; ; dg and onstraints\n2e+ a+ 2 (31)\n2e+ b+ d 2 (32)\nNow we an unit propagate to on lude e by virtue of (31) and :e by virtue of (32); it isn't hard to on lude that the on i t set is a _ b in that either a or b must be true if (31) and (32) are to be simultaneously satis able. But if we simply add (31) and (32) and simplify, we get\na+ b+ + d 2\nwhi h still allows a and b to both be false. This diÆ ulty an be addressed by deriving a\nardinality onstraint that is guaranteed to be falsi ed by the urrent partial solution being investigated (Dixon & Ginsberg, 2002); Chai and Kuehlmann (2003) have developed a still stronger method.\nExperimental results Many of the ideas that we have des ribed have been implemented in the pb haff satis ability solver. In an earlier paper (Dixon & Ginsberg, 2002), we ompared results obtained using prs, a pseudo-Boolean version of relsat, and those obtained using relsat (Bayardo & Miranker, 1996). Pb haff is an updated version of prs that is modeled losely on zChaff (Moskewi z et al., 2001). It implements wat hed literals for\nardinality onstraints and applies the strengthening idea. Here we ompare pb haff's\nperforman e to its Boolean ounterpart zChaff.\nResults on some (unsatis able) problem instan es from the Velev suite dis ussed at the beginning of Se tion 2.1 are shown in Table 1. As an be seen, performan e is omparable; pb haff pays a small (although noti eable) ost for its extended expressivity. The\nexperiments were run on a 1.5 GHz AMD Athlon pro essor, and both solvers used the same values for the various tuning parameters available (relevan e and length bounds, et .).\nResults for the pigeonhole problem appear in Table 2. In this ase, pb haff was permitted to prepro ess the problem using strengthening as des ribed earlier in this se tion. ZChaff was unable to solve the problem for twelve or more pigeons with a 1000-se ond timeout using a 1.5 GHz Athlon pro essor. Not surprisingly, pb haff with prepro essing dramati ally outperformed zChaff on these instan es. 13"
    }, {
      "heading" : "3.4 Proof Complexity",
      "text" : "We have already shown in Proposition 3.2 that pseudo-Boolean or ardinality-based axiomatizations an produ e polynomially sized proofs of the pigeonhole problem. It is also known that these methods do not lead to polynomially sized proofs of the lique oloring problem (Bonet et al., 1997; Kraj'i ek, 1997; Pudlak, 1997). The situation with regard to parity onstraints is a bit more interesting.\nLet us rst point out that it is possible to apture parity onstraints, or modularity\nonstraints generally in a pseudo-Boolean setting:\nDe nition 3.18 A modularity onstraint is a onstraint of the form\nX\ni\nw\ni\nl\ni\nn(mod m) (33)\nfor positive integers w\ni\n, n and m.\nIn the remainder of this se tion, we show that modularity onstraints an be easily en oded using pseudo-Boolean axioms, and also that onstraint sets onsisting entirely of mod 2 onstraints are easily solved either dire tly or using the above en oding, although it is not lear how to re over the pseudo-Boolean en odings from the Boolean versions.\n13. Without prepro essing, the two systems perform omparably on this lass of problems. As we have\nstressed, representational extensions are of little use without mat hing modi ations to inferen e methods.\nModularity onstraints and pseudo-Boolean en odings To en ode a modularity\nonstraint in this way, we rst note that we an easily apture an equality axiom of the\nform\nX\ni\nw\ni\nl\ni\n= k (34)\nin a pseudo-Boolean setting, simply by rewriting (34) as the pair of onstraints\nX\ni\nw\ni\nl\ni\nk\nX\ni\nw\ni\nl\ni\nX\ni\nw\ni\nk\nIn what follows, we will therefore feel free to write axioms of the form (34).\nWe now denote by bx the oor of x, whi h is to say the smallest integer not greater\nthan x, and have:\nProposition 3.19 Suppose that we have a modularity onstraint of the form (33). We set w = P\ni\nw\ni\nand introdu e new variables s\ni\nfor i = 1; : : : ; b\nw m . Then (33) is equivalent to\nX\ni\nw\ni\nl\ni\n+\nX\ni\nms\ni\n= m\nj\nw\nm\nk\n+ n (35)\nProof. Redu ing both sides of (35) mod m shows that (35) learly implies (33). For the\nonverse, note if (33) is satis ed, there is some integer s su h that\nP\ni\nw\ni\nl\ni\n= sm + n.\nFurther, sin e\nP\ni\nw\ni\nl\ni\nP\ni\nw\ni\n= w, it follows that sm+ n w, so that s\nw n\nm\nw m and\nthus s b\nw m . We an therefore satisfy (35) by valuing exa tly that many of the s i to be\ntrue.\nUnderstand that the introdu tion of new variables here is not part of any intended inferen e pro edure; it is simply the fashion in whi h the modularity onstraints an be\naptured within a pseudo-Boolean setting.\nIn the ase where all of the onstraints are parity onstraints, we have:\nProposition 3.20 A set of mod 2 onstraints an be solved in polynomial time.\nProof. An individual onstraint (re all that orresponds to ex lusive or, or addition mod 2)\nl\ni\nl\ni\n= n\nan be viewed simply as de ning\nl = n\ni\nl\ni\nand this de nition an be inserted to remove l from the remaining onstraints. Continuing in this way, we either de ne all of the variables (and an then return a solution) or derive 1 = 0 and an return failure.\nThis result, whi h an be thought of as little more than an appli ation of Gaussian\nelimination, is also an instan e of a far more general result of S haefer's (1978).\nProposition 3.21 A set of mod 2 onstraints an be solved in polynomial time using the pseudo-Boolean axiomatization given by (35).\nProof. The te hnique is un hanged. When we ombine\nl +\nX\ni\nl\ni\n+ 2\nX\ni\ns\ni\n= n\nand\nl +\nX\ni\nl\n0 i + 2\nX\ni\ns\n0 i = n 0\nwe get\nX\ni\nl\ni\n+\nX\ni\nl\n0 i + 2(\nX\ni\ns\ni\n+\nX\ni\ns\n0 i + l) = n+ n 0\nand an now treat l as one of the auxiliary s variables. Eventually, we will get\n2\nX\ni\ns\ni\n= n\nfor a large (but polynomially sized) set S of auxiliary variables and some n that is either even or odd. If n is even, we an value the variables and return a solution; if n is odd and there are k auxiliary variables, we have\nX\ni\ns\ni\n=\nn\n2\nso\nX\ni\ns\ni\nn+ 1\n2\n(36)\nsin e ea h s\ni\nis integral. But we also have\n2\nX\ni\ns\ni\n2k n\nso that\nX\ni\ns\ni\nk\nn 1\n2\n(37)\nAdding (36) and (37) produ es k k + 1, a ontradi tion.\nLet us point out, however, that if a mod 2 onstraint is en oded in a normal Boolean\nway, so that x y z = 1 be omes\nx _ y _ z (38)\nx _ :y _ :z\n:x _ y _ :z\n:x _ :y _ z (39)\nit is not obvious how the pseudo-Boolean analog an be re onstru ted. Here is the problem we mentioned at the beginning of this se tion: it is not enough to simply extend the representation; we need to extend the inferen e methods as well. In fa t, even the question of whether families of mod 2 onstraints an be solved in polynomial time by pseudo-Boolean methods without the introdu tion of auxiliary variables as in (35) is open. Other authors have also onsidered the problem of reasoning with these onstraints dire tly (Li, 2000).\nPseudo-Boolean onstraints and extended resolution Finally, let us larify a point that we made earlier. Given that there is an en oding of a_(b^ ) as a single pseudo-Boolean\nlause, how an it be that pseudo-Boolean inferen e is properly below extended resolution\nin the p-simulation hierar hy?\nThe answer is as follows. While the fa t that a _ (b ^ ) is logi ally equivalent to 2a+ b+ 2 allows us to remove one of the variables introdu ed by extended resolution, we annot ombine this en oding with others to remove subsequent variables. As a spe i example, suppose that we learn both\na _ (b ^ )\nand\nd _ (b ^ )\nand wish to on lude from this that\n(a ^ d) _ (b ^ ) (40)\nThere is no single pseudo-Boolean axiom that is equivalent to (40)."
    }, {
      "heading" : "3.5 Summary",
      "text" : "p-simulation unit\nrep. e . hierar hy inferen e propagation learning\nSAT 1 EEE resolution wat hed literals relevan e\nardinality exp P?E not unique wat hed literals relevan e\nPB exp P?E uniquely de ned wat hed literals + strengthening\nsymmetry\nQPROP\nAs before, a few notes are in order:\nWhile both ardinality and pseudo-Boolean representations an be exponentially more eÆ ient than their Boolean ounterpart, it is not lear how often ompressions of this magnitude will o ur in pra ti e.\nThe entries in the p-simulation olumn indi ate that the pigeonhole problem is easy,\nlique oloring remains hard, and the omplexity of parity problems is unknown if no\nnew variables are introdu ed.\nThe ardinality entry for \\inferen e\" is intended to re e t the fa t that the natural resolvent of two ardinality onstraints need not be one.\nPseudo-Boolean systems an use existing learning te hniques, augmented with the strengthening idea."
    }, {
      "heading" : "4. Symmetry",
      "text" : "Given that the pigeonhole problem and lique- oloring problems involve a great deal of symmetry in their arguments, a variety of authors have suggested extending Boolean representation or inferen e in a way that allows this symmetry to be exploited dire tly. We will dis uss the variety of approa hes that have been proposed by separating them based on whether or not a modi ation to the basi resolution inferen e rule is suggested. In any event, we make the following de nition:\nDe nition 4.1 Let T be a olle tion of axioms. By a symmetry of T we will mean any permutation of the variables in T that leaves T itself un hanged.\nAs an example, if T onsists of the single axiom x_y, then T is learly symmetri under\nthe ex hange of x and y. If T ontains the two axioms\na _ x\nand\na _ y\nthen T is on e again symmetri under the ex hange of x and y.\nExploiting symmetry without hanging inferen e One way to exploit symmetry is to modify the set of axioms in a way that aptures the power of the symmetry. In the pigeonhole problem, for example, we an argue that sin e there is a symmetry under the ex hange of pigeons or of holes, we an assume \\without loss of generality\" that pigeon 1 is in hole 1, and then by virtue of a residual symmetry that pigeon 2 is in hole 2, and so on.\nThe basi idea is to add so- alled symmetry-breaking axioms to our original theory, axioms that break the existing symmetry without a e ting the overall satis ability of the theory itself. This idea was introdu ed by Crawford et al. (1996).\nWhile attra tive in theory, there are at least two fundamental diÆ ulties with the\nsymmetry-breaking approa h:\n1. Luks and Roy (2002) have shown that breaking all of the symmetries in any parti -\nular problem may require the introdu tion of a set of symmetry-breaking axioms of exponential size. This problem an be sidestepped by breaking only \\most\" of the symmetries, although little is known about how the set of broken symmetries is to be sele ted.\n2. Far more serious, the te hnique an only be applied if the symmetry in question\nis global. This is be ause the basi argument that satis ability is una e ted by the introdu tion of the new axioms requires that there be no additional axioms to onsider.\nIn theoreti al problems, global symmetries exist. But in pra ti e, even the addition of asymmetri axioms that onstrain the problem further (e.g., you an't put pigeon 4 in hole 7) will break the required global symmetry and render this method inappli able. More problemati still is the possibility of the symmetries being \\obs ured\" by repla ing the single axiom\n:p\n11\n_ :p\n21\n(41)\nwith the equivalent pair\na _ :p\n11\n_ :p\n21\nand\n:a _ :p\n11\n_ :p\n21\nfrom whi h (41) an obviously be re overed using resolution. On e again, the symmetry in the original problem has vanished and the method annot be applied.\nThese arguments ould perhaps have been anti ipated by onsideration of our usual table; sin e the inferen e me hanism itself is not modi ed (and it is possible to break global symmetries), none of the entries has hanged. Let us turn, then, to other te hniques that modify inferen e itself.\nExploiting symmetry by hanging inferen e Rather than modifying the set of lauses in the problem, it is also possible to modify the notion of inferen e, so that on e a parti ular nogood has been derived, symmetri equivalents an be derived in a single step. The basi idea is due to Krishnamurthy (1985) and is as follows:\nLemma 4.2 Suppose that T j= q for some theory T and nogood q. If is a symmetry of T , then T j= (q).\nIt is not hard to see that this te hnique allows the pigeonhole problem to be solved in polynomial time, sin e symmetri versions of spe i on lusions (e.g., pigeon 1 is not in hole 1) an be derived without repeating the analysis that led to the original. The dependen e on global symmetries remains, but an be addressed by the following modi ation:\nProposition 4.3 Let T be a theory, and suppose that T\n0\nj= q for some T\n0\nT and nogood\nq. If is a symmetry of T\n0\n, then T j= (q).\nInstead of needing to nd a symmetry of the theory T in its entirety, it suÆ es to nd a \\lo al\" symmetry of the subset of T that was a tually used in the proof of q.\nThis idea, whi h has been generalized somewhat by Szeider (2003), allows us to avoid the fa t that the introdu tion of additional axioms an break a global symmetry. The problem of symmetries that have been obs ured as in (41) remains, however, and is a ompanied by a new one, the need to identify lo al symmetries at ea h inferen e step (Brown et al., 1988).\nWhile it is straightforward to identify the support of any new nogood q in terms of a\nsubtheory T\n0\nof the original theory T , nding the symmetries of any parti ular theory is\nequivalent to the graph isomorphism problem (Crawford, 1992). The pre ise omplexity of graph isomorphism is unknown, but it is felt likely to be properly between P and NP (Babai, 1995). Our basi table be omes:\np-simulation unit\nrep. e . hierar hy inferen e propagation learning\nSAT 1 EEE resolution wat hed literals relevan e\nardinality exp P?E not unique wat hed literals relevan e\nPB exp P?E unique wat hed literals + strengthening\nsymmetry 1 EEE\nnot in P same as sat same as sat\nQPROP\nIt is not lear how the representational eÆ ien y of this system is to be des ribed, sin e a single on luded nogood an serve as a standin for its image under the symmetries of the proof that produ ed it.\nWhile spe i instan es of the pigeonhole problem and lique oloring problems an be addressed using symmetries, even trivial modi ations of these problems render the te hniques inappli able. Hen e the appearan e of the asterisk in the above table: \\Textbook\" problem instan es may admit polynomially sized proofs, but most instan es require proofs of exponential length. Parity problems do not seem to be amenable to these te hniques at all.\nAs we have remarked, inferen e using Krishnamurthy's or related ideas appears to require multiple solutions of the graph isomorphism problem, and is therefore unlikely to remain in P .\nWe know of no implemented system based on the ideas dis ussed in this se tion."
    }, {
      "heading" : "5. Quanti ation and QPROP",
      "text" : "We on lude our survey with an examination of ideas that have been used in trying to extend the Boolean work to ope with theories that are most naturally thought of using quanti ation of some sort. Indeed, as Boolean satis ability engines are applied to ever larger problems, many of the theories in question are produ ed in large part by onstru ting the set of ground instan es of quanti ed axioms su h as\n8xyz:[a(x; y) ^ b(y; z)! (x; z)℄ (42)\nIf d is the size of the domain from whi h x, y and z are taken, this single axiom has d\n3\nground instan es. Resear hers have dealt with this diÆ ulty by buying ma hines with more memory or by nding lever axiomatizations for whi h ground theories remain manageably sized (Kautz & Selman, 1998). In general, however, memory and leverness are both s ar e resour es and a more natural solution needs to be found.\nWe will all a lause su h as (42) quanti ed , and assume throughout this se tion that the quanti ation is universal as opposed to existential, and that the domains of quanti ation are nite. 14\nAs we remarked at the beginning of this se tion, quanti ed lauses are ommon in en odings of realisti problems, and these problems have in general been solved by onverting quanti ed lauses to standard propositional formulae. The quanti ers are expanded rst (possible be ause the domains of quanti ation are nite), and the resulting set of predi ates is then \\linearized\" by relabeling all of the atoms so that, for example, a(2; 3) might be ome v\n24\n. The number of ground lauses produ ed is exponential in the number of variables in\nthe quanti ed lause."
    }, {
      "heading" : "14. There appears to be no e e tive alternative but to treat existentially quanti ed lauses as simple dis-",
      "text" : "jun tions, as in (9)."
    }, {
      "heading" : "5.1 Unit Propagation",
      "text" : "Our primary goal here is to work with the quanti ed formulation dire tly, as opposed to its mu h larger ground translation. Unfortunately, there are signi ant onstant-fa tor osts in urred in doing so, sin e ea h inferen e step will need to deal with issues involving the bindings of the variables in question. Simply nding the value assigned to a(2; 3) might well take several times longer than nding the value assigned to the equivalent v\n24\n. Finding\nall o urren es of a given literal an be a hieved in the ground ase by simple indexing s hemes, whereas in the quanti ed ase this is likely to require a uni ation step. While uni ation an be performed in time linear in the length of the terms being uni ed, it is obviously not as eÆ ient as a simple equality he k. Su h routine but essential operations\nan be expe ted to signi antly slow the ost of every inferen e undertaken by the system.\nOur fundamental point here is that while there are osts asso iated with using quanti ed axioms, there are signi ant savings as well. These savings are a onsequen e of the fa t that the basi unit propagation pro edure uses an amount of time that s ales roughly linearly with the size of the theory; use of quanti ed axioms an redu e the size of the theory so substantially that the onstant-fa tor osts an be over ome.\nWe will make this argument in two phases. In Se tion 5.1.1, we generalize a spe i\nomputational subtask that is shared by unit propagation and other satis ability pro edures su h as wsat. We will show this generalization to be NP- omplete in a formal sense, and we all it subsear h for that reason. The spe i pro edures for unit propagation and as needed by wsat en ounter this NP- omplete subproblem at ea h inferen e step, and we show that while subsear h is generally not a problem for randomly generated theories, the subsear h ost an be expe ted to dominate the running time on more realisti instan es.\nIn Se tion 5.1.2, we dis uss other onsequen es of the fa t that subsear h is NP- omplete. Sear h te hniques an be used to speed the solution of NP- omplete problems, and subsear h is no ex eption. We show that quanti ed axiomatizations support the appli ation of simple sear h te hniques to the subsear h problem, and argue that realisti examples are likely to lead to subsear h problems of only polynomial diÆ ulty although existing unit propagation implementations solve them exponentially."
    }, {
      "heading" : "5.1.1 Subsear h",
      "text" : "Ea h iteration of dpll (or wsat) involves a sear h through the original theory for lauses that satisfy some numeri property. The spe i examples that we have already seen of this are the following:\n1. In Pro edure 2.2 (dpll) (and similarly in wsat), we need to determine if P is a\nsolution to the problem at hand. This involves sear hing for an unsatis ed lause.\n2. In Pro edure 2.3 (unit propagation), we need to nd unsatis ed lauses that ontain\nat most one unvalued literal.\nIn addition, wsat needs to ompute the number of lauses that will be ome unsatis ed when a parti ular variable is ipped.\nAll of these tasks an be rewritten using the following:\nDe nition 5.1 Suppose C is a set of quanti ed lauses, and P is a partial assignment of values to the atoms in those lauses. We will denote by S s\nu\n(C;P ) the set of ground instan es\nof C that have u literals unvalued by P and s literals satis ed by the assignments in P .\n15\nWe will say that the he king problem is that of determining whether S\ns u (C;P ) 6= . By\na subsear h problem, we will mean an instan e of the he king problem, or the problem of either enumerating S s\nu\n(C;P ) or determining its size.\nProposition 5.2 For xed u and s, the he king problem is NP- omplete.\nProof. Che king is in NP, sin e a witness that S\ns u (C;P ) 6= need simply give suitable\nbindings for the variables in ea h lause of C.\nTo see NP-hardness, we assume u = s = 0; other ases are not signi antly di erent. We redu e from a binary onstraint satisfa tion problem ( sp), produ ing a single lause C and set of bindings P su h that S 0\n0\n(C;P ) 6= if and only if the original binary sp was\nsatis able. The basi idea is that ea h variable in the onstraint problem will be ome a quanti ed variable in C.\nSuppose that we have a binary sp with variables v\n1\n; : : : ; v\nn\nand with m binary\nonstraints of the form (v\ni1\n; v\ni2\n) 2\ni\n, where (v\ni1\n; v\ni2\n) is the pair of variables onstrained by\ni\n. For ea h su h onstraint, we introdu e a orresponding binary relation r\ni\n(v\ni1\n; v\ni2\n), and\ntake C to be the single quanti ed lause 8v\n1\n; : : : ; v\nn\n: _\ni\nr\ni\n(v\ni1\n; v\ni2\n). For the assignment P ,\nwe set r\ni\n(v\ni1\n; v\ni2\n) to false for all (v\ni1\n; v\ni2\n) 2\ni\n, and to true otherwise.\nNow note that sin e P values every instan e of every r\ni\n, S\n0 0 (C;P ) will be nonempty if\nand only if there is a set of values for v\ni\nsu h that every literal in _\ni\nr\ni\n(v\ni\n1\n; v\ni\n2\n) is false. Sin e\na literal r\ni\n(v\ni\n1\n; v\ni\n2\n) is false just in the ase the original onstraint\ni\nis satis ed, it follows\nthat S\n0 0 (C;P ) 6= if and only if the original sp was satis able.\nBefore moving on, let us pla e this result in ontext. First, and most important, note that the fa t that the he king problem is NP- omplete does not imply that qprop is an unwieldy representation; the subsear h problem does indeed appear to be exponential in the size of the qprop axioms, but there are exponentially fewer of them than in the ground\nase. So, as for similar results elsewhere (Galperin & Wigderson, 1983; Papadimitriou,\n1994), there is no net e e t on omplexity.\nSe ond, the result embodied in Proposition 5.2 appears to be a general phenomenon in that propagation is more diÆ ult for more ompa t representations. Our earlier dis ussion of ardinality and pseudo-Boolean axioms, for whi h the omplexity of unit propagation was un hanged from the Boolean ase, appears to be mu h more the ex eption than the rule. As we have already remarked, if we extend the pseudo-Boolean representation only slightly, so that in addition to axioms of the form\nX\ni\nw\ni\nl\ni\nk (43)\nas in De nition 3.4 we allow axioms su h as\nX\ni\nw\ni\nl\ni\n= k\n15. In interpreting the expression S\ns u (C;P ), the set C of lauses and partial assignment P should generally\nbe lear from ontext. The supers ript refers to the number of satis ed literals be ause satis ed literals are \\super good\" and the subs ript refers to the unvalued literals be ause unvalued literals aren't so good.\n(repla ing the inequality in (43) with an equality), determining whether a single axiom is satis able be omes weakly NP- omplete. Symmetry, the other example we have examined, involves no e e tive hange in the representational power of a single axiom.\nHere is a re asting of unit propagation in terms of De nition 5.1:\nPro edure 5.3 (Unit propagation) To ompute Unit-Propagate(P ):\n1 while S\n0 0 (C;P ) = and S 0 1 (C;P ) 6=\n2 do sele t 2 S\n0 1 (C;P )\n3 v the variable in unassigned by P 4 P P [ fv = V : V is sele ted so that is satis edg 5 return P\nIt is important to re ognize that this re asting is not hanging the pro edure in any signifi ant way; it is simply making expli it the subsear h tasks that were previously des ribed only impli itly. The pro edure itself is un hanged, and other pro edural details su h as variable and value hoi e heuristi s are irrelevant to the general point that unit propagation depends on solving a subsear h instan e at every step. Wsat is similar."
    }, {
      "heading" : "5.1.2 Subsear h and quantifi ation",
      "text" : "As we dis ussed in Se tion 2.1, eÆ ient implementations of sat solvers go to great lengths to minimize the amount of time spent solving subsear h problems. While the wat hed literal idea is the most eÆ ient me hanism known here, we will dis uss the problem in terms of a simpler s heme that maintains and updates poss and urr ounts for ea h lause. As dis ussed earlier, this s heme is about half as fast as the wat hed literal approa h, and the general arguments that we will make an be expe ted to lead to more than onstant-fa tor improvements. 16\nFor notational onvenien e in what follows, suppose that C is a quanti ed theory and\nthat l is a ground literal. By C\nl\nwe will mean that subset of the lauses in C that in lude\nterms of whi h l is an instan e. If C ontains quanti ed lauses, then C\nl\nwill as well; the\nlauses in C\nl\nan be found by mat hing the literal l against the lauses in C.\nAs dis ussed in Se tion 2.1, it is possible to ompute S\ns u (C;P ) on e during an initial-\nization phase, and then update it in rementally. In terms of De nition 5.1, the update rule might be one su h as\nS\n0 0 (C;P 0 ) = S 0 0 (C;P ) [ S 0 1 (C :l ; P )\nif the literal l is hanged from unvalued to true. P\n0\nhere is the partial assignment after the\nupdate; P is the assignment before. To ompute the number of fully assigned but unsatis ed\nlauses after the update, we start with the number before, and add newly unsatis ed lauses\n(unsatis ed lauses previously ontaining the single unvalued literal :l).\nAs we argued previously, reorganizing the omputation in this way leads to substantial speedups be ause the subsear h problem being solved is no longer NP- omplete in the size\n16. We know of no e e tive way to lift the wat hed literal idea to the qprop setting. But as we will see when\nwe dis uss the zap implementation (Dixon et al., 2003a), a still broader generalization allows wat hed literals to return in an elegant and far more general way.\nof C, but only in the size of C\nl\nor C\n:l\n. These in remental te hniques are essential to the per-\nforman e of modern sear h implementations be ause the runtime of these implementations is dominated by the time spent in propagation (i.e., subsear h).\nGiven that the subsear h omputation time is potentially exponential in the size of the\nsubtheory C\nl\nwhen the literal l is valued or unvalued, let us now onsider the questions of\nhow mu h of a on ern this is in pra ti e, and of what (if anything) an be done about it. After all, one of the primary lessons of re ent satis ability resear h is that problems that are NP-hard in theory tend strongly not to be exponentially diÆ ult in pra ti e.\nLet us begin by noting that subsear h is not likely to be mu h of an issue for the randomly generated satis ability problems that were the fo us of resear h in the 1990's and drove the development of algorithms su h as wsat. The reason for this is that if n is the number of lauses in a theory C and v is the number of variables in C, then random problems are diÆ ult only for fairly narrow ranges of values of the ratio n=v (Coarfa, Demopoulos, San Miguel Aguirre, Subramanian, & Vardi, 2000). For 3-SAT (where every lause in C\nontains exa tly three literals), diÆ ult random problems appear at n=v 4:2 (Kirkpatri k & Selman, 1994). For su h a problem, the number of lauses in whi h a parti ular literal l appears will be small (on average 3 4:2=2 = 6:3 for random 3-SAT). Thus the size of the relevant subtheory C\nl\nor C\n:l\nwill also be small, and while subsear h ost still tends\nto dominate the running time of the algorithms in question, there is little to be gained by applying sophisti ated te hniques to redu e the time needed to examine a relative handful of lauses.\nFor realisti problems, the situation is dramati ally di erent. Here is an axiom from a\nlogisti s domain en oded in satplan style (Kautz & Selman, 1992):\nat(o; l; t) ^ duration(l; l\n0\n; dt) ^\nbetween(t; t\n0\n; t+ dt)! :at(o; l\n0\n; t\n0\n) (44)\nThis axiom says that if an obje t o is at lo ation l at time t and it takes time dt to y from l to l 0 , and t 0 is between t and t+ dt, then o annot be at l 0 at t 0 .\nA given ground atom of the form at(o; l; t) will appear in jtj\n2\njlj lauses of the above form,\nwhere jtj is the number of time points or in rements and jlj is the number of lo ations. Even if there are only 100 of ea h, the 10 6 axioms reated seem likely to make omputing S s\nu\n(C\nl\n; P )\nimpra ti al.\nLet us examine this omputation in a bit more detail. Suppose that we do indeed have a variable a = at(O;L; T ) for xed O, L and T , and that we are interested in ounting the number of unit propagations that will be possible if we set a to true. In other words, we want to know how many instan es of (44) will be unsatis ed and have a single unvalued literal after we do so.\nExisting implementations, fa ed with this problem (or an analogous one if wsat or another approa h is used), will now onsider axioms of the form (44) for o, l and t bound and as l 0 , t 0 and dt are allowed to vary. They examine every axiom of this form and simply\nount the number of possible unit propagations.\nThe wat hed literal idea in isolation annot help with this problem. If, for example, we wat h only the duration and between predi ates in (44), we redu e by half the probability\nthat we need to solve a subsear h problem when a parti ular variable is valued, but in those\nases where the problem is en ountered, it is as er e as ever.\nThe existing approa h to solving subsear h problems is taken be ause existing systems use not quanti ed lauses su h as (44), but the set of ground instan es of those lauses. Computing S s\nu\n(C;P ) for ground C involves simply he king ea h axiom individually; indeed,\non e the axiom has been repla ed by its set of ground instan es, no other approa h seems possible.\nSet against the ontext of a quanti ed axiom, however, this seems inappropriate. Com-\nputing S\ns u (C;P ) for a quanti ed C by redu ing C to a set of ground lauses and then\nexamining ea h is equivalent to solving the original NP- omplete problem by generate and test { and if there is one thing that we an state with on den e about NP- omplete problems, it is that generate and test is not in general an e e tive way to solve them.\nReturning to our example with at(O;L; T ) true, we are looking for variable bind-\nings for l\n0\n, dt and t\n0\nsu h that, amongst :duration(L; l\n0\n; dt), :between(T; t\n0\n; T + dt) and\n:at(O; l\n0\n; t\n0\n), pre isely two of these literals are false and the third is unvalued. Proposi-\ntion 5.2 suggests that subsear h will be exponentially hard (with respe t to the number of quanti ers) in the worst ase, but what is it likely to be like in pra ti e?\nIn pra ti e, things are going to be mu h better. Suppose that for some possible desti-\nnation l\n0\n, we know that duration(L; l\n0\n; dt) is false for all dt ex ept some spe i value D.\nWe an immediately ignore all bindings for dt ex ept for dt = D, redu ing the size of the subsear h spa e by a fa tor of jtj. If D depended on previous hoi es in the sear h (air raft loads, et .), it would be impossible to perform this analysis in advan e and thereby remove the unne essary bindings in the ground theory.\nPushing this example somewhat further, suppose that D is so small that T + D is\nthe time point immediately after T . In other words, between(T; t\n0\n; T +D) will always be\nfalse, so that :between(T; t\n0\n; T + D) will always be true and no unit propagation will be\npossible for any value of t\n0\nat all. We an \\ba ktra k\" away from the unfortunate hoi e of\ndestination l\n0\nin our (sub)sear h for variable bindings for whi h unit propagation is possible.\nSu h ba ktra king is not supported by the generate-and-test subsear h philosophy used by existing implementations.\nThis sort of omputational savings is likely to be possible in general. For naturally o urring theories, most of the variables involved are likely to be either unvalued (be ause we have not yet managed to determine their truth values) or false (by virtue of the losedworld assumption, Reiter, 1978, if nothing else). Domain onstraints will typi ally be of the form a\n1\n^ ^ a\nk\n! l, where the premises a\ni\nare variables and the on lusion l is a literal\nof unknown sign. Unit propagation (or other likely instan es of the subsear h problem) will thus involve nding a situation where at most one of the a\ni\nis unvalued, and the rest are\ntrue. If we use eÆ ient data stru tures to identify those instan es of relational expressions that are true, it is not unreasonable to expe t that most instan es of the subsear h problem will be soluble in time polynomial in the length of the lauses involved, as opposed to exponential in that length."
    }, {
      "heading" : "5.2 Inferen e and Learning",
      "text" : "As in Se tion 3, working with a modi ed representation allows ertain inferen e te hniques that are not appli able in the Boolean ase.\nAs an example, suppose that we are resolving\n:a(A;B) _ :b(B;C) _ (C)\nwith\n: (C) _ d(C;D)\nto on lude\n:a(A;B) _ :b(B;C) _ d(C;D) (45)\nwhere the apital letters indi ate ground elements of the domain as before and the resolvents are a tually ground instan es of\n:a(x; y) _ :b(y;C) _ (C) (46)\nand\n: (z) _ d(z; w) (47)\nIt is obviously possible to resolve (46) and (47) dire tly to obtain\n:a(x; y) _ :b(y;C) _ d(C;w) (48)\nwhi h is more general than (45). For a pro edure that learns new nogoods and uses them to prune the resulting sear h, the impa t of learning the more general (48) an be substantial and an easily outweigh the ost of the uni ation step required to on lude that (C) and : (z) resolve if z = C. We have also dis ussed this elsewhere (Parkes, 1999).\nThere are two new diÆ ulties that arise when we implement these ideas. The rst is a onsequen e of the fa t that resolution an be ambiguously de ned for two quanti ed\nlauses. Consider resolving\na(A; x) _ a(y;B) (49)\nwith\na(A;B) _ b(A;B) (50)\nIf we unify the rst term in (50) with the rst term in (49), we obtain a(y;B) _ b(A;B) as the resolvent; if we unify with the se ond term of (49), we obtain a(A; x) _ b(A;B).\nIn pra ti e, however, this need not be a problem:\nProposition 5.4 Let\n1\nand\n2\nbe two lifted lauses, and g\n1\nand g\n2\nground instan es that\nresolve to produ e g. Then there is a unique natural resolvent of\n1\nand\n2\nof whi h g is a\nground instan e.\nProof. If there is more than one pair of resolving literals in g\n1\nand g\n2\nthe result of the\nresolution will be va uous, so we an assume that there is a single literal l in g\n1\nwith :l in\ng\n2\n. If l is the ith literal in g\n1\nand :l the jth literal in g\n2\n, it follows that we an resolve the\noriginal\n1\nand\n2\nby unifying the ith literal in\n1\nand the jth literal in\n2\n. It is lear that\nthis resolution will be a generalization of g.\nWhat this suggests is that the reasons being asso iated with literal values be not the lifted nogoods that are retained as lauses, but ground instan es thereof that were initially used to prune the sear h spa e and an subsequently be used to break ambiguities in learning.\nThe se ond diÆ ulty is far more substantial. Suppose that we have the axiom\n:a(x; y) _ :a(y; z) _ a(x; z)\nor, in a more familiar form, the usual transitivity axiom\na(x; y) ^ a(y; z)! a(x; z)\nThis might be used in reasoning about a logisti s problem, for example, if it gave onditions under whi h two ities were onne ted by roads.\nNow suppose that we are trying to prove a(A;B) for an A and a B that are \\far apart\" given the skeleton of the relation a that we already know. It is possible that we use resolution to derive\na(A; x) ^ a(x;B)! a(A;B)\nas we sear h for a proof involving a single intermediate lo ation, and then\na(A; x) ^ a(x; y) ^ a(y;B)! a(A;B)\nas we sear h for a proof involving two su h lo ations, and so on, eventually deriving the wonderfully on ise\na(A; x\n1\n) ^ ^ a(x\nn\n; B)! a(A;B) (51)\nfor some suitably large n.\nThe problem is that if d is the size of our domain, (51) will have d\nn\nground instan es\nand is in danger of overwhelming our unit propagation algorithm even in the presen e of reasonably sophisti ated subsear h te hniques. Some te hnique needs to be adopted to ensure that this diÆ ulty is sidestepped in pra ti e. One way to do this is to learn not the fully general (51), but a partially bound instan e that has fewer ground instan es.\nPro edure 5.5 To onstru t learn( ; g), the nogood that will be learned after a lause has been produ ed in response to a ba ktra k, with g the ground reason asso iated with :\n1 while has a ground instan e that is i-irrelevant 2 do v a variable in 3 bind v to its value in g 4 return\nWe may still learn a nogood with an exponential number of ground instan es, but at least have some reason to believe that ea h of these instan es will be useful in pruning subsequent sear h. Note that there is a subsear h omponent to Pro edure 5.5, sin e we need to nd ground instan es of that are irrelevant. This ost is in urred only on e when the lause is learned, however, and not at every unit propagation or other use.\nIt might seem more natural to learn the general (51), but to modify the subsear h algorithm used in unit propagation so that only a subset of the andidate lauses is onsidered. As above, the most natural approa h would likely be to restri t the subsear h to lauses of a parti ular irrelevan e or better. Unfortunately, this won't help, sin e irrelevant lauses\nannot be unit. Restri ting the subsear h to relevant lauses is no more useful in pra ti e\nthan requiring that any sear h algorithm expand only su essful nodes.\nBefore moving on, let us note that a similar phenomenon o urs in the pseudo-Boolean\nase. Suppose we have a partial assignment f:b; ;:d; eg and onstraints\na+ d+ e 1 (52)\na+ b+ 2 (53)\nUnit propagation now auses the variable a to be simultaneously true (by virtue of (52)) and false (be ause of (53)). Resolving these reasons together as in Proposition 3.12 gives us\nb+ + d+ e 2 (54)\nThe on i t set here is easily seen to be f:b;:d; eg, and this is indeed prohibited by the derived onstraint (54). But (54) eliminates some additional bad assignments as well, su h as f: ;:d; eg. Just as in the lifted ase, we have learned something about a portion of the sear h spa e that has yet to be examined."
    }, {
      "heading" : "5.3 Summary",
      "text" : "p-simulation unit\nrep. e . hierar hy inferen e propagation learning\nSAT 1 EEE resolution wat hed literals relevan e\nardinality exp P?E not unique wat hed literals relevan e\nPB exp P?E unique wat hed literals + strengthening\nsymmetry 1 EEE\nnot in P same as sat same as sat\nQPROP exp ??? in P using reasons exp improvement + rst-order\nAs usual, there are a few points to be made.\nThere is an important di eren e in pra ti e between the exponential savings in representation provided by qprop and the savings provided by pseudo-Boolean or ardinality en odings. While the exponential savings in previous ases were mathemati al possibilities that were of un ertain use in pra ti e, the savings provided by qprop an be expe ted to be a hieved in any axiomatization that is onstru ted by grounding out a relative handful of universally quanti ed physi al laws.\nIt is not lear whether qprop leads to polynomially sized solutions to the pigeonhole and lique oloring problems. It appears at rst blush that it should, sin e quanti ation over pigeons or holes is the qprop analog of the identi ation of the\norresponding symmetry as in the previous se tion. We know of no detailed proof in the literature, however, and our attempts to onstru t one have been unsu essful. Similar remarks apply to parity problems.\nInferen e in qprop requires the introdu tion of a (linear omplexity) uni ation step, and is only uniquely de ned if reasons are maintained for the hoi es made in the sear h.\nThe exponential savings laimed for unit propagation are obviously an average ase result, as opposed to a worst ase one. They are a onsequen e of the fa t that it is possible to use subsear h as part of unit propagation, as opposed to the \\generate and test\" me hanism used by ground methods.\nIn addition to the usual idea of relevan e-based learning, quanti ed methods an extend the power of individual nogoods by resolving quanti ed lauses instead of their ground instan es.\nFinally, we remark that a representation very similar to qprop has also been used in Answer Set Programming (asp) (Marek & Trusz zynski, 1999; Niemel a, 1999) under the name \\propositional s hemata\" (East & Trusz zy nski, 2001, 2002). The approa h used in asp resembles existing satis ability work, however, in that lauses are always grounded out. The potential advantages of intelligent subsear h are thus not exploited, although we expe t that many of the motivations and results given here would also apply in asp. In fa t, asp has many features in ommon with sat:\nIn the most ommonly used semanti s, that of (non-disjun tive) stable model logi programming (Gelfond & Lifs hitz, 1988), the representational power is pre isely that of NP (or NP NP for disjun tive programming).\nCardinality onstraints are allowed (East & Trusz zy nski, 2002; Simons, 2000).\nSolution methods (Leone, Pfeifer, & et al., 2002; Niemel a, 1999; Simons, 2000) use dpll and some form of propagation.\nThe most signi ant di eren e between onventional satis ability work and asp with stable model semanti s is that the relevant logi is not lassi al but the \\logi of here and there\" (Pear e, 1997). In the logi of here and there, the law of the ex luded middle does not hold, only the weaker :p _ ::p. This is suÆ ient for dpll to be applied, but does imply that lassi al resolution is no longer valid. As a result, there seems to be no proof theory for the resulting system, and learning within this framework is not yet understood. Ba kjumping is used, but the me hanism does not seem to learn new rules from failed subtrees in the sear h. In an analogous way, ardinality onstraints are used but utting plane proof systems are not. Despite the many parallels between sat and asp, in luding the approa h in this survey seems to be somewhat premature."
    }, {
      "heading" : "6. Con lusion",
      "text" : "Satis ability algorithms have too often been developed against the framework provided by either random instan es or, worse still, instan es that have been designed solely to show that the te hnique being proposed has omputational merit. The algorithms themselves have thus tended to ignore problem features that dominate the omputational requirements when they are applied to real problems.\nOn su h realisti problems, it is possible to both improve the speed of the algorithms' inner loops (via qprop and subsear h) and to redu e the number of times that the inner loops need to be exe uted (via learning and a move up the p-simulation hierar hy). Both of these lasses of improvements arise be ause the problems in question have stru ture. The stru ture an be learned as nogoods, or used to re-represent the problem using pseudoBoolean or quanti ed expressions.\nIt is true that the table in the previous subse tion an be viewed as a survey of reent work on satis ability, and it is also true that the table an be viewed as a rational re onstru tion of the goals of the resear hers who have investigated various representational extensions. But to our mind, the table is more a urately viewed as a report on the extent to whi h these linguisti or semanti modi ations su essfully apture problem stru ture.\nEvery olumn in the table is about stru ture. Improved representational eÆ ien y is only possible if the problem itself has stru ture that a Boolean axiomatization typi ally obs ures. It is stru ture that allows progress to be made in terms of proof omplexity. The stru ture must be preserved by the basi inferen e me hanism of the system in question if it is to remain useful, and qprop's ability to speed the inner loop of unit propagation is a dire t onsequen e of the stru ture present in the subsear h problem. Finally, learning itself an be thought of as a sear h for reasonably on ise des riptions of large se tions of the sear h spa e that ontain no solutions { in other words, learning is the dis overy of stru ture in the sear h spa e itself.\nThis is the setting against whi h the next two papers in this series are set. If so mu h of the progress in satis ability te hniques an be thought of as stru ture exploitation, then surely it is natural to attempt to understand and to exploit that stru ture dire tly. As we will see, not only do the te hniques we have dis ussed work by exploiting stru ture, but they all exploit di erent instan es of a single stru ture. The zap work is an attempt to understand, generalize and streamline previous results by setting them in this uniform setting."
    }, {
      "heading" : "A knowledgments",
      "text" : "We would like to thank the members of irl, the te hni al sta of On Time Systems, and Eugene Luks and David Hofer from the CIS department at the University of Oregon for their assistan e with the ideas in this series of papers. We would also like to thank the anonymous reviewers for their omments and suggestions, whi h we found extremely valuable.\nThis work was sponsored in part by grants from Air For e OÆ e of S ienti Resear h (afosr) number F49620-92-J-0384, the Air For e Resear h Laboratory (afrl) number F30602-97-0294, Small Business Te hnology Transfer Resear h, Advan ed Te hnology Institute (sttr-ati) number 20000766, OÆ e of Naval Resear h (onr) number N00014-00-C0233, and the Defense Advan ed Resear h Proje ts Agen y (darpa) and the Air For e Resear h Laboratory, Rome, NY, under agreements numbered F30602-95-1-0023, F30602-971-0294, F30602-98-2-0181, F30602-00-2-0534, and F33615-02-C-4032. The views expressed are those of the authors.\nReferen es\nAloul, F., Ramani, A., Markov, I., & Sakallah, K. (2002). PBS: A ba ktra k sear h pseudo-\nBoolean solver. In Symposium on the Theory and Appli ations of Satis ability Testing.\nBabai, L. (1995). Automorphism groups, isomorphism, re onstru tion. In Lov asz, L., Gra-\nham, R., & Gr ots hel, M. (Eds.), Handbook for Combinatori s, hap. 27, pp. 1447{ 1540. North-Holland-Elsevier.\nBaker, A. B. (1994). The hazards of fan y ba ktra king. In Pro eedings of the Twelfth\nNational Conferen e on Arti ial Intelligen e.\nBarth, P. (1995). A Davis-Putnam based enumeration algorithm for linear pseudo-\nboolean optimization. Te h. rep. MPI-I-95-2-003, Max Plan k Institut f ur Informatik, Saarbr u ken, Germany.\nBarth, P. (1996). Logi -Based 0-1 Constraint Programming, Vol. 5 of Operations Re-\nsear h/Computer S ien e Interfa es Series. Kluwer.\nBaumgartner, P. (2000). FDPLL { A First-Order Davis-Putnam-Logeman-Loveland Pro-\nedure. In M Allester, D. (Ed.), CADE-17 { The 17th International Conferen e on\nAutomated Dedu tion, Vol. 1831, pp. 200{219. Springer.\nBayardo, R. J., & Miranker, D. P. (1996). A omplexity analysis of spa e-bounded learning\nalgorithms for the onstraint satisfa tion problem. In Pro eedings of the Thirteenth National Conferen e on Arti ial Intelligen e, pp. 298{304.\nBayardo, R. J., & S hrag, R. C. (1997). Using CSP look-ba k te hniques to solve real-world\nSAT instan es. In Pro eedings of the Fourteenth National Conferen e on Arti ial Intelligen e, pp. 203{208.\nBeame, P., & Pitassi, T. (2001). Propositional proof omplexity: Past, present and future.\nIn Paun, G., Rozenberg, G., & Salomaa, A. (Eds.), Current Trends in Theoreti al Computer S ien e, Entering the 21th Century, pp. 42{70. World S ienti .\nBenhamou, B., Sais, L., & Siegel, P. (1994). Two proof pro edures for a ardinality based\nlanguage in propositional al ulus. In Pro eedings of STACS94, volume 775 de Le ture Notes in Computer S ien e.\nBiere, A., Clarke, E., Raimi, R., & Zhu, Y. (1999). Verifying safety properties of a Pow-\nerPC mi ropro essor using symboli model he king without BDDs. Le ture Notes in Computer S ien e, 1633.\nBonet, M. L., Pitassi, T., & Raz, R. (1997). Lower bounds for utting planes proofs with\nsmall oeÆ ients. Journal of Symboli Logi , 62 (3), 708{728.\nBrown, C. A., Finkelstein, L., & Paul Walton Purdom, J. (1988). Ba ktra k sear hing in\nthe presen e of symmetry. In Mora, T. (Ed.), Applied Algebra, Algebrai Algorithms and Error-Corre ting Codes, 6th Int'l. Conf., pp. 99{110. Springer-Verlag.\nBryant, R. E. (1986). Graph-based algorithms for Boolean fun tion manipulation. IEEE\nTransa tions on Computers, C-35 (8), 677{691.\nBryant, R. E. (1992). Symboli Boolean manipulation with ordered binary-de ision dia-\ngrams. ACM Computing Surveys, 24 (3), 293{318.\nBu hberger, B. (1965). Ein Algorithmus zum AuÆnden der Basiselemente des Restklassen-\nringes na h einum nulldimensionalen Polynomideal. Ph.D. thesis, University of Innsbru k, Innsbru k.\nBu hberger, B. (1985). Gr obner bases: An algorithmi method in polynomial ideal theory.\nIn Bose, N. (Ed.), Multidimensional Systems Theory. D. Reidel, Dordre ht, Holland.\nCadoli, M., S haerf, M., Giovanardi, A., & Giovanardi, M. (2002). An algorithm to evaluate\nquanti ed boolean formulae and its experimental evaluation. Journal of Automated Reasoning, 28 (2), 101{142.\nChai, D., & Kuehlmann, A. (2003). A fast pseudo-Boolean onstraint solver. In Pro eedings\nof the 40th Design Automation Conferen e, pp. 830{835.\nChandru, V., & Hooker, J. N. (1999). Optimization Mehtods for Logi al Inferen e. Wiley-\nInters ien e.\nClegg, M., Edmonds, J., & Impagliazzo, R. (1996). Using the Groebner basis algorithm\nto nd proofs of unsatis ability. In Pro eedings of the Twenty-Eighth Annual ACM Symp. on Theory of Computing, pp. 174{183.\nCoarfa, C., Demopoulos, D. D., San Miguel Aguirre, A., Subramanian, D., & Vardi, M.\n(2000). Random 3-SAT: The plot thi kens. In Pro eedings of the International Conferen e on Constraint Programming.\nCook, S. A. (1971). The omplexity of theorem-proving pro edures. In Pro eedings of the\n3rd Annual ACM Symposium on the Theory of Computing, pp. 151{158.\nCook, W., Coullard, C., & Turan, G. (1987). On the omplexity of utting-plane proofs.\nDis rete Applied Mathemati s, 18, 25{38.\nCopty, F., Fix, L., Giun higlia, E., Kamhi, G., Ta hella, A., & Vardi, M. (2001). Bene ts\nof bounded model he king in an industrial setting. In 13th Conferen e on Computer Aided Veri ation, CAV'01, Paris, Fran e.\nCrawford, J. M. (1992). A theoreti al analysis of reasoning by symmetry in rst-order logi\n(extended abstra t). In AAAI Workshop on Tra table Reasoning.\nCrawford, J. M., & Auton, L. D. (1996). Experimental results on the rossover point in\nrandom 3SAT. Arti ial Intelligen e, 81, 31{57.\nCrawford, J. M., Ginsberg, M. L., Luks, E., & Roy, A. (1996). Symmetry breaking predi ates\nfor sear h problems. In Pro eedings of the Fifth International Conferen e on Prin iples of Knowledge Representation and Reasoning, Boston, MA.\nDavis, M., & Putnam, H. (1960). A omputing pro edure for quanti ation theory. J.\nAsso . Comput. Ma h., 7, 201{215.\nDavis, M., Logemann, G., & Loveland, D. (1962). A ma hine program for theorem-proving.\nCommuni ations of the ACM, 5 (7), 394{397.\nDe hter, R. (1990). Enhan ement s hemes for onstraint pro essing: Ba kjumping, learning,\nand utset de omposition. Arti ial Intelligen e, 41, 273{312.\nDixon, H. E., & Ginsberg, M. L. (2000). Combining satis ability te hniques from AI and\nOR. Knowledge Engrg. Rev., 15, 31{45.\nDixon, H. E., & Ginsberg, M. L. (2002). Inferen e methods for a pseudo-Boolean satis-\nability solver. In Pro eedings of the Eighteenth National Conferen e on Arti ial\nIntelligen e.\nDixon, H. E., Ginsberg, M. L., Hofer, D., Luks, E. M., & Parkes, A. J. (2003a). Generalizing\nBoolean satis ability III: Implementation. Te h. rep., Computational Intelligen e Resear h Laboratory, Eugene, Oregon.\nDixon, H. E., Ginsberg, M. L., Luks, E. M., & Parkes, A. J. (2003b). Generalizing Boolean\nsatis ability II: Theory. Te h. rep., Computational Intelligen e Resear h Laboratory, Eugene, Oregon.\nDubois, O., Andre, P., Boufkhad, Y., & Carlier, J. (1993). SAT versus UNSAT. In Se ond\nDIMACS Challenge: Cliques, Colorings and Satis ability, Rutgers University, NJ.\nDubois, O., & Dequen, G. (2001). A ba kbone-sear h heuristi for eÆ ient solving of hard\n3-SAT formulae. In Pro eedings of the Seventeenth International Joint Conferen e on Arti ial Intelligen e, pp. 248{253.\nEast, D., & Trusz zy nski, M. (2001). Propositional satis ability in answer-set programming.\nLe ture Notes in Computer S ien e, 2174.\nEast, D., & Trusz zy nski, M. (2002). Propositional satis ability in de larative program-\nming. Extended version of papers that appeared in Pro eedings of AAAI-2000 and Pro eedings of KI-2001. http://xxx.lanl.gov/abs/ s.LO/0211033.\nFreeman, J. W. (1995). Improvements to propositional satis ability sear h algorithms. Ph.D.\nthesis, University of Pennsylvania, PA.\nFrost, D., & De hter, R. (1994). Dead-end driven learning. In Pro eedings of the Twelfth\nNational Conferen e on Arti ial Intelligen e, pp. 294{300.\nGalperin, H., & Wigderson, A. (1983). Su in t representation of graphs. Information and\nControl, 56, 183{198.\nGarey, M., & Johnson, D. (1979). Computers and Intra tability. W.H. Freeman and Co.,\nNew York.\nGas hnig, J. (1979). Performan e measurement and analysis of ertain sear h algorithms.\nTe h. rep. CMU-CS-79-124, Carnegie-Mellon University.\nGelfond, M., & Lifs hitz, V. (1988). The stable semanti s for logi programs. In Pro eedings\nof the 5th International Conferen e on Logi Programming, pp. 1070{1080. MIT Press.\nGinsberg, M. L. (1993). Dynami ba ktra king. Journal of Arti ial Intelligen e Resear h,\n1, 25{46.\nGinsberg, M. L., & Geddis, D. F. (1991). Is there any need for domain-dependent ontrol\ninformation?. In Pro eedings of the Ninth National Conferen e on Arti ial Intelligen e.\nGinsberg, M. L., & Parkes, A. J. (2000). Sear h, subsear h and QPROP. In Pro eedings of\nthe Seventh International Conferen e on Prin iples of Knowledge Representation and Reasoning, Bre kenridge, Colorado.\nGoldberg, E., & Novikov, Y. (2002). Berkmin: A fast and robust SAT solver. In Design\nAutomation and Test in Europe (DATE), pp. 142{149.\nGuignard, M., & Spielberg, K. (1981). Logi al redu tion methods in zero-one programming.\nOperations Resear h, 29.\nHaken, A. (1985). The intra tability of resolution. Theoreti al Computer S ien e, 39, 297{\n308.\nHaken, A. (1995). Counting bottlene ks to show monotone P 6= NP . In Pro eedings 36th\nAnnual IEEE Symp. on Foundations of Computer S ien e (FOCS-95), pp. 36{40, Milwaukee, MN. IEEE.\nHooker, J. N. (1988). Generalized resolution and utting planes. Annals of Operations\nResear h, 12, 217{239.\nHooker, J. N., & Vinay, V. (1995). Bran hing rules for satis ability. J. Automated Reasoning,\n15, 359{383.\nJeroslow, R., & Wang, J. (1990). Solving the propositional satis ability problem. Annals\nof Mathemati s and Arti ial Intelligen e, 1, 167{187.\nJoslin, D., & Roy, A. (1997). Exploiting symmetry in lifted CSPs. In Pro eedings of the\nFourteenth National Conferen e on Arti ial Intelligen e, pp. 197{202.\nKautz, H., & Selman, B. (1998). BLACKBOX: A new approa h to the appli ation of\ntheorem proving to problem solving. In Arti ial Intelligen e Planning Systems: Pro-\needings of the Fourth International Conferen e. AAAI Press.\nKautz, H. A., & Selman, B. (1992). Planning as satis ability. In Pro eedings of the Tenth\nEuropean Conferen e on Arti ial Intelligen e (ECAI'92), pp. 359{363.\nKirkpatri k, S., & Selman, B. (1994). Criti al behavior in the satis ability of random\nBoolean expressions. S ien e, 264, 1297{1301.\nKraj'i ek, J. (1997). Interpolation theorems, lower bounds for proof systems, and indepen-\nden e results for bounded arithmeti . J. Symb. Logi , 62 (2), 457{486.\nKrishnamurthy, B. (1985). Short proofs for tri ky formulas. A ta Informati a, 22 (3), 253{\n275.\nLeone, N., Pfeifer, G., & et al. (2002). The DLV system for knowledge representation and\nreasoning. Te h. rep. 1843-02-14, Te hni al University of Vienna.\nLi, C. M. (2000). Integrating equivalen y reasoning into Davis-Putnam pro edure. In\nPro eedings of the Seventeenth National Conferen e on Arti ial Intelligen e, pp. 291{ 296.\nLi, C. M., & Anbulagan (1997). Heuristi s based on unit propagation for satis ability\nproblems. In Pro eedings of the Fifteenth International Joint Conferen e on Arti ial Intelligen e, pp. 366{371.\nLuks, E., & Roy, A. (2002). Symmetry breaking in onstraint satisfa tion. In Intl. Conf. of\nArti ial Intelligen e and Mathemati s, Ft. Lauderdale, Florida.\nMarek, V. W., & Trusz zynski, M. (1999). Stable models and an alternative logi program-\nming paradigm..\nM Carthy, J. (1977). Epistemologi al problems of arti ial intelligen e. In Pro eedings\nof the Fifth International Joint Conferen e on Arti ial Intelligen e, pp. 1038{1044, Cambridge, MA.\nM Cune, W., & Wos, L. (1997). Otter - the CADE-13 ompetition in arnations. Journal\nof Automated Reasoning, 18 (2), 211{220.\nMit hell, D. G. (1998). Hard problems for CSP algorithms. In Pro eedings of the Fifteenth\nNational Conferen e on Arti ial Intelligen e, pp. 398{405.\nMoskewi z, M., Madigan, C., Zhao, Y., Zhang, L., & Malik, S. (2001). Cha : Engineering\nan eÆ ient SAT solver. In 39th Design Automation Conferen e.\nNemhauser, G., & Wolsey, L. (1988). Integer and Combinatorial Optimization. Wiley, New\nYork.\nNiemel a, I. (1999). Logi programs with stable model semanti s as a onstraint programming\nparadigm. Annals of Mathemati s and Arti ial Intelligen e, 25, 241{273.\nPapadimitriou, C. (1994). Computational Complexity. Addison-Wesley.\nParkes, A. J. (1999). Lifted Sear h Engines for Satis ability. Ph.D. thesis, University of\nOregon. Available from http://www. irl.uoregon.edu/parkes.\nPear e, D. (1997). A new logi al hara terization of stable models and answer sets. In\nDix, J., Pereira, L., & Przymusinski, T. (Eds.), Non-monotoni Extensions of Logi Programming, Vol. 1216 of Le ture Notes in Arti ial Intelligen e, pp. 57{70.\nPitassi, T. (2002). Propositional proof omplexity le ture notes.\nwww. s.toronto.edu/~toni/Courses/Proof omplexity/Le tures/Le ture1/le ture1.ps (other le tures titled similarly).\nPrestwi h, S. (2002). Randomised ba ktra king for linear pseudo-Boolean onstraint prob-\nlems. In Pro eedings of the 4th International Workshop on Integration of AI and OR Te hniques in Constraint Programming for Combinatorial Optimisation Problems (CPAIOR-02), pp. 7{20.\nPretolani, D. (1993). Satis ability and hypergraphs. Ph.D. thesis, Universita di Pisa.\nPudlak, P. (1997). Lower bounds for resolution and utting planes proofs and monotone\nomputations. J. Symboli Logi , 62 (3), 981{998.\nPuget, J.-F. (1993). On the satis ability of symmetri al onstrained satisfa tion problems.\nIn In J. Komorowski and Z.W. Ras, editors, Pro eedings of ISMIS'93, pages 350{361. Springer-Verlag, 1993. Le ture Notes in Arti ial Intelligen e 689.\nReiter, R. (1978). On losed world data bases. In Gallaire, H., & Minker, J. (Eds.), Logi\nand Data Bases, pp. 119{140. Plenum, New York.\nSavelsbergh, M. W. P. (1994). Prepro essing and probing for mixed integer programming\nproblems. ORSA Journal on Computing, 6, 445{454.\nS haefer, T. J. (1978). The omplexity of satis ability problems. In Pro eedings of the\nTenth Annual ACM Symposium on the Theory of Computing, pp. 216{226.\nSelman, B., Kautz, H. A., & Cohen, B. (1993). Lo al sear h strategies for satis ability test-\ning. In Pro eedings 1993 DIMACS Workshop on Maximum Clique, Graph Coloring, and Satis ability.\nSimons, P. (2000). Extending and implementing the stable model semanti s.. Resear h\nReport 58, Helsinki University of Te hnology, Helsinki, Finland.\nStallman, R. M., & Sussman, G. J. (1977). Forward reasoning and dependen y-dire ted\nba ktra king in a system for omputer-aided ir uit analysis. Arti ial Intelligen e, 9, 135{196.\nSzeider, S. (2003). The omplexity of resolution with generalized symmetry rules. In Alt,\nH., & Habib, M. (Eds.), Pro eedings of STACS03, volume 2607 of Springer Le ture Notes in Computer S ien e, pp. 475{486.\nTseitin, G. (1970). On the omplexity of derivation in propositional al ulus. In Slisenko,\nA. (Ed.), Studies in Constru tive Mathemati s and Mathemati al Logi , Part 2, pp. 466{483. Consultants Bureau.\nUrquhart, A. (1995). The omplexity of propositional proofs. Bull. Symboli Logi , 1 (4),\n425{467.\nVelev, M. N., & Bryant, R. E. (2001). E e tive use of boolean satis ability pro edures in the\nformal veri ation of supers alar and VLIW. In Pro eedings of the 38th Conferen e on Design Automation Conferen e 2001, pp. 226{231, New York, NY, USA. ACM Press.\nWalser, J. P. (1997). Solving linear pseudo-Boolean onstraint problems with lo al sear h.\nIn Pro eedings of the Fourteenth National Conferen e on Arti ial Intelligen e, pp. 269{274.\nZhang, H., & Sti kel, M. E. (2000). Implementing the Davis-Putnam method. Journal of\nAutomated Reasoning, 24 (1/2), 277{296."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "This is the rst of three planned papers des ribing zap, a satis ability engine that substantially generalizes existing tools while retaining the performan e hara teristi s of modern high-performan e solvers. The fundamental idea underlying zap is that many problems passed to su h engines ontain ri h internal stru ture that is obs ured by the Boolean representation used; our goal is to de ne a representation in whi h this stru ture is apparent and an easily be exploited to improve omputational performan e. This paper is a survey of the work underlying zap, and dis usses previous attempts to improve the performan e of the Davis-Putnam-Logemann-Loveland algorithm by exploiting the stru ture of the problem being solved. We examine existing ideas in luding extensions of the Boolean language to allow ardinality onstraints, pseudo-Boolean representations, symmetry, and a limited form of quanti ation. While this paper is intended as a survey, our resear h results are ontained in the two subsequent arti les, with the theoreti al stru ture of zap des ribed in the se ond paper in this series, and zap's implementation des ribed in the third.",
    "creator" : "dvips(k) 5.86 Copyright 1999 Radical Eye Software"
  }
}