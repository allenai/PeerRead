{
  "name" : "1605.07728.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Small Representations of Big Kidney Exchange Graphs",
    "authors" : [ "John P. Dickerson", "Aleksandr M. Kazachkov", "Tuomas Sandholm" ],
    "emails" : [ "john@cs.umd.edu,", "arielpro@cs.cmu.edu,", "sandholm@cs.cmu.edu,", "akazachk@cmu.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "There are over 100,000 needy patients waiting for a kidney transplant in the United States, with similar—and increasing—demand worldwide.1 Complementing potential cadaveric transplantation via the deceased donor waiting list, a recent innovation—kidney exchange (Rapaport 1986; Roth, Sönmez, and Ünver 2004)—allows patients with willing living donors to participate in cyclic donor swaps or altruist-initiated donation chains to receive a life-saving organ. Kidney exchange now accounts for over 10% of living donation in the US, with that percentage increasing annually.\nIn reality, participating patients and donors are endowed with a set of attributes: blood type, tissue type, age, insurance, home transplant center, willingness to travel, and myriad other measurements of health, personal preference, and logistical constraints. While some of these features can, at a cost, be temporarily or permanently changed, the attributes determine the feasibility of a potential donation from each donor to each patient. For example, a donor with blood type AB can only give to a patient with that blood type.\nCopyright c© 2017, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\n1 https://optn.transplant.hrsa.gov/converge/data/\nA central aspect of kidney exchange is the clearing problem, that is, determining the “best” set of cyclic and chainbased swaps to perform in a given compatibility graph, which consists of all participating patients, donors, and their potential feasible transactions. For even simple (but realistic) models of kidney exchange, the clearing problem is NP-hard (Abraham, Blum, and Sandholm 2007; Biró, Manlove, and Rizzi 2009) and also extremely difficult to solve in practice (Glorie, van de Klundert, and Wagelmans 2014; Anderson et al. 2015; Dickerson et al. 2016).\nIn this paper, we tackle the complexity of the clearing problem via the introduction of a novel model for kidney exchange that explicitly takes into account all attributes of the participating patients and donors. Under the assumption that real kidney exchange graphs can be represented using a constant number of attributes, we show that our model permits polynomial-time solutions to central NP-hard problems in general kidney exchange. Inspired by classical results from intersection graph theory, we give conditions on the representation of arbitrary graphs in our model, and generalize to the case where participants are allowed to have a thresholded number of negative interactions between attributes. Noting that real-life kidney exchange graphs are not arbitrary, we show on actual data from the United Network for Organ Sharing (UNOS) US-wide kidney exchange that our model permits lossless representation of true graphs with far fewer attributes than the worst-case theoretical results require."
    }, {
      "heading" : "2 A New Model for Kidney Exchange",
      "text" : "In this section, we formalize our model of kidney exchange. We prove that under this model certain well-known NPhard problems in general kidney exchange are solvable in polynomial time. We also show that, given a compatibility graph, determining the best set of attributes to change (at some cost) is solvable in polynomial time."
    }, {
      "heading" : "2.1 Notation & Preliminaries",
      "text" : "A kidney exchange can be represented by a directed compatibility graph G = (V,E). Each patient-donor pair, or unpaired altruistic donor, forms a vertex v ∈ V , and a directed edge exists from one vertex to another if the donor at the former can give to the patient at the latter, i.e., are compatible (Roth, Sönmez, and Ünver 2004; Roth, Sönmez, and Ünver 2005).\nar X\niv :1\n60 5.\n07 72\n8v 2\n[ cs\n.A I]\n1 6\nD ec\n2 01\n6\nIn kidney exchange, patients and donors participate in cycles or chains. In a cycle, each participating vertex receives the kidney of the previous vertex. All transplants in a cycle must be performed simultaneously to ensure participation, and thus are limited to some small length in practice. This ensures that no donor backs out after her patient has received a kidney but before she has donated her kidney. Most fielded kidney exchanges—including UNOS—allow only 2- and 3-cycles. In a chain, a donor without a paired patient enters the pool, donating his kidney to a patient, whose paired donor donates his kidney to another patient, and so on (Montgomery et al. 2006; Roth et al. 2006; Rees et al. 2009). Chains can be executed non-simultaneously2 and thus chains can be longer (but typically not infinite) in length. Most exchanges—including UNOS—see great gains through the use of such “altruist-initiated” chains.\nWe consider a model that imposes additional structure on an arbitrary compatibility graph. For each vertex vi ∈ V , associate attribute vectors di and pi with its constituent donor and patient, respectively. The qth element dqi of di takes on one of a fixed number of types—for example, one of four blood types (O, A, B, AB), or one of a few hundred standard insurance plans. Then, for vi 6= vj ∈ V , we define a compatibility function f(di,pj), a boolean function that returns the compatibility of the donor of vi with the patient of vj . We remark that our approach relates to techniques that take advantage of symmetries in a problem; see, e.g., (Meseguer and Torras 2001).\nGiven V and associated attribute vectors, we can uniquely determine a compatibility graph G = (V,E) such that E = {(vi, vj) : f(di,pj) = 1 ∀vi 6= vj ∈ V }. We claim that this model accurately mimics reality, and we later support that claim with strong experimental results on realworld data. Furthermore, under this new model, certain complexity results central to kidney exchange change (for the better), as we discuss next."
    }, {
      "heading" : "2.2 The Clearing Problem is Easy (in Theory)",
      "text" : "We now tackle the central computational challenge of kidney exchange: the clearing problem. Well-known to beNPhard (Abraham, Blum, and Sandholm 2007; Biró, Manlove, and Rizzi 2009), a variety of custom clearing algorithms address adaptations of the clearing problem in practice.3 We show that, in our model, the clearing problem itself is solvable in polynomial time.\nFormally, we are interested in a polynomial-time algorithm that solves the L-CYCLE-COVER problem—that is, finding the largest disjoint packing of cycles of length at most L. For ease of exposition, in this section we use “cycles” to refer to both cycles and chains; indeed, it is easy to see that altruist donors are equivalent to standard patient-\n2To see why this is, take the case where a donor backs out of a chain after his paired patient received a kidney, but before his own donation. Unlike in the case of a broken cycle, no pair in the remaining tail of the planned chain is strictly worse off; that is, no donor was “used up” before her paired patient received a kidney.\n3For an overview of practical approaches to solving the clearing problem, see a recent survey due to Mak-Hau (2015).\ndonor pairs with a patient who is compatible with all nonaltruist vertices in the pool. Then, a chain is equivalent to a cycle with a “dummy” edge returning to the altruist. Also, again for ease of exposition, we assume the value of a chain of length L is equal to a cycle of length L, due to the final donor giving to a patient on the deceased donor waiting list.\nRecall that we are working in a model where each vertex vi belongs to one of a fixed number of types determined solely by its attribute vectors di and pi. Let Θ be the set of all possible types, and θ ∈ Θ represent one such individual type. With a slight abuse of notation, we can define a type compatibility function f(θ, θ′) = 1 if and only if there is a directed edge between vertices of type θ and θ′. (Note that this captures chains and altruist donors as described above.)\nA key observation of this section is that any additional edge structure that is imposed on the graph—such as a cycle cover—would be independent of the identity of specific vertices; rather, it would only depend on their types, as vertices of the same type have the exact same incoming and outgoing neighborhoods. For example, in any cycle cover, if vi and vj are two vertices of the same type, we can swap vi and vj and obtain a feasible cycle cover of the same size. This observation drives our theoretical algorithmic results.\nIn more detail, every cycle through vertices of G can be interpreted as a closed walk through the type space. Every such cycle can be represented by θ = (θ1, . . . , θ`) ∈ Θ`, where ` is the length of the cycle. Let us define fC as the boolean function with fC(θ) = 1 if and only if\nf(θ1, θ2) = · · · = f(θ`−1, θ`) = f(θ`, θ1) = 1. Furthermore, for L ≤ n = |V |, let T (L) denote the set of closed walks through the type space of length at most L. Formally\nT (L) = L⋃\n`=2\n{θ ∈ Θ` : fC(θ) = 1}.\nLet C be a cycle cover in G, and denote the number of unique vertices matched in C by ‖C‖V . Suppose C has cycle cap L; then it is equivalent, in our setting, to a vector m ∈ Z|T (L)|+ , where, for θ ∈ T (L), mθ equals the number of cycles in C that can be represented in the type space by θ. Let |θ| be the length of the vector θ, and ‖m‖V =∑\nθ∈T (L)mθ|θ|. Then ‖m‖V = ‖C‖V , that is, ‖m‖V is another way to express the number of matched vertices in the equivalent cycle cover.\nNow consider Algorithm 1 for L-CYCLE-COVER in our model, which we claim is optimal and computationally efficient in our setting. Theorem 1. Given constants L and |Θ|, Algorithm 1 is a polynomial-time algorithm for L-CYCLE-COVER.\nProof. We start by verifying that Algorithm 1 is indeed optimal. Consider the optimal cycle cover C∗. For each θ ∈ T (L), let m∗θ be the number of cycles in C∗ that are consistent with the types in θ. Clearly ∑ θ∈T (L)m ∗ θ|θ| ≤ n, as there are only n vertices. Therefore, Algorithm 1 considers the collection of numbers m∗θ in Step 2. Because this collection of numbers does induce a valid cycle cover that is of the\nAlgorithm 1 L-CYCLE-COVER 1. C∗ ← ∅ 2. for every vector of non-negative integers m ∈ Z|T (L)|+\nsuch that ‖m‖V ≤ n • if ‖m‖V > ‖C∗‖V and there exists cycle cover C in G\nsuch that for each θ ∈ T (L), C contains mθ cycles of type θ, then C∗ ← C\n3. return C∗\nsame size as C∗, the algorithm would update its incumbent cycle cover if it were not already optimal.\nWe next analyze the running time of the algorithm. First, note that it is straightforward to check whether the vector m induces a valid cycle cover. Since T (L) consists only of valid cycles according to the compatibility function fC , we just need to check that there are enough vertices of each type θ ∈ Θ to construct all the cycles that require them. This can be checked individually for each θ ∈ Θ. For a particular θ ∈ T (L), the number of vertices of type θ required is mθ multiplied by the number of times type θ appears in θ. Then the sum of these products over all θ ∈ T (L) is at most the number of vertices of type θ in G.\nSecond, there is only a polynomial number of possibilities to construct a collection of numbers m = {mθ}θ∈T (L) such that ‖m‖V ≤ n. Indeed, this number is at most (n + 1)|T (L)|. Moreover, |T (L)| ≤ L · |Θ|L. Because |Θ| and L are constants, |T (L)| is also a constant. The expression (n+ 1)|T (L)| is therefore a polynomial in n.\nEven for constant L, the running time of Algorithm 1 is exponential in |Θ|. But this is to be expected. Indeed, any graph can trivially be represented using a set Θ of types of size n, where each vertex has a unique type, and a compatibility function fC that assigns 1 to an ordered pair of types if the corresponding edge exists in G. Therefore, if the running time of Algorithm 1 were polynomial in n and |Θ|, we would solve the general L-CYCLE-COVER problem in polynomial time—and that problem is NP-hard (Abraham, Blum, and Sandholm 2007)."
    }, {
      "heading" : "2.3 Flipping Attributes is Also Easy (in Theory)",
      "text" : "While patients and donors in a kidney exchange are endowed with an initial set of attributes, it may be possible in practice to—at a cost—change some number of those attributes to effect change in the final matching. For example, the human body naturally tries to reject, to varying degrees, a transplanted organ. Due to this, nearly all recipients of kidneys are placed on immunosuppressant drugs after transplantation occurs.4 However, preoperative immunosuppression can also be performed to increase transplant opportunity—but at some cost to the patient’s overall health.\nWith this in mind, we extend the model of Section 2.2 as follows. Associate with each pair of types θ, θ′ ∈ Θ a cost function c : Θ×Θ→ R representing the cost of changing a\n4 https://www.kidney.org/atoz/content/immuno\nvertex of type θ to type θ′. Then, the L-FLIP-AND-CYCLECOVER problem is to find a disjoint packing of cycles of length at most L that maximizes the size of the packing minus the sum of costs spent changing types. Building on Theorem 1, this problem is also solvable in polynomial time.\nTheorem 2. Suppose that L and |Θ| are constants. Then LFLIP-AND-CYCLE-COVER is solvable in polynomial-time.\nProof sketch. For any type θ ∈ Θ, there are nθ vertices. Then, for each of the (|Θ|−1) choices of which type θ′ 6= θ to switch to, choose how many vertices from θ will switch to that type; there are at most (nθ + 1) possibilities. Do this for all types in Θ, resulting in∏\nθ∈Θ\n(nθ + 1) |Θ|−1 ≤ (n+ 1)|Θ|2\npossibilities. Since |Θ| is a constant, this is polynomial in n. For each of these polynomially-many type-switch possibilities, we can compute the optimal cycle cover in polynomial time using Algorithm 1, and subtract c(θ, θ′) for each vertex that switched from θ to θ′. Taking the best of these solutions gives the optimal solution in polynomial time."
    }, {
      "heading" : "3 A Concrete Instantiation: Thresholding",
      "text" : "As motivated in Sections 1 and 2, compatibility in real kidney exchange graphs is determined by patient and donor attributes, such as blood or tissue type. In particular, if an attribute for a donor and patient is in conflict, they are deemed incompatible. Motivated by that reality, in this section, we associate with each patient and donor a bit vector of length k, and count incompatibilities based on any shared activated bits between a patient and potential donor.\nAs a concrete example, consider human blood types. At a high level, human blood contains A antigens, B antigens, both (type AB), or neither (type O). AB-type patients can receive from any donor, A-type (B-type) can receive from O-type and A-type (B-type) donors, and O-type patients can only receive from O-type donors. In our bit model, this is represented with k = 2. The first bit represents compatibility with A antigens and the second bit represents compatibility with B antigens. Thus, the type space Θ = 2{has-A,has-B}× 2{no-A,no-B}; in general, |Θ| = 22k.\nFormally, unless otherwise stated, throughout this section G will refer to a directed graph with vertex set V = [n] := {1, . . . , n} and edge set E, and with each i ∈ V associated with two k-bit vectors di,pi ∈ {0, 1}k. Let Qd(i) = {q ∈ [k] : diq = 1} be the set of conflict bits for the donor associated with vertex i ∈ V , and similarly let Qp(i) = {q ∈ [k] : piq = 1}. For i, j ∈ V such that i 6= j, the threshold feasibility function f tthresh is defined as\nf tthresh(di,pj) = { 1 if |Qd(i) ∩Qp(j)| ≤ t, 0 otherwise. .\nNote that |Qd(i) ∩Qp(j)| ≤ t if and only if 〈di,pj〉 ≤ t. Kidney exchange graphs constructed using threshold compatibility functions are closely related to complements of intersection graphs (McKee and McMorris 1999), which\nare graphs that have a set associated with each vertex and an edge between two vertices if and only if the sets intersect. Given t ∈ N, the function f tthresh is related to pintersection graphs (Chung and West 1994; Eaton, Gould, and Rödl 1996), where an edge connects two vertices if their corresponding sets intersect in at least p ≥ 1 elements.\nIn particular, our model is similar to that of intersection digraphs (Sen et al. 1989), or equivalently bipartite intersection graphs (Harary, Kabell, and McMorris 1982), both also considered in (Orlin 1977). These have mainly been studied under the assumption that the sets used to represent the graph have the “consecutive ones” property, i.e., each set is an interval from the set of integers. Our model is more general: we do not place such an assumption on the set of conflict bits. Moreover, most treatments of intersection digraphs consider loops on the vertices, whereas in our thresholding model, whether or not donor i and patient i are compatible is not considered. In addition, the directed and bipartite intersection graph literature has focused on the case that t = 0 (in our terminology). To the best of our knowledge, this paper is the first treatment p-intersection digraphs, and certainly their first real-world application."
    }, {
      "heading" : "3.1 Existence of Small Representations",
      "text" : "It is natural to ask for what values of t and k we can select vertices with bit vectors di and pi of length k such that f tthresh can create any graph of a specific size?\nFormally, we say that G is (k, t)-representable (by feasibility function f tthresh) if, for all i ∈ V there exist di,pi ∈ {0, 1}k such that for all j1 ∈ V , j2 ∈ V \\{j1}, (j1, j2) ∈ E if and only if f tthresh(dj1 ,pj2) = 1.\nIt is known (Erdős, Goodman, and Pósa 1966) that any graph can be represented as an intersection graph with k ≤ n2/4. Yet, we show next that, in our model, k ≤ n suffices to represent any graph. It is akin to a result on the term rank of the adjacency matrix of G (Orlin 1977, Thm 6.6).\nTheorem 3. Let G = (V,E) be a digraph on n vertices. Let n1 be the number of vertices with outgoing edges, Let n2 be the number of vertices with incoming edges, and n′ = min{n1 + 1, n2 + 1, n}. Then G can be (n′, 0)-represented.\nProof. We first show that the graph can be (n1 + 1, 0)- represented. Assume without loss of generality that vertices 1, . . . , n1 have outgoing edges. We show how to set di,pi ∈ {0, 1}n1+1 for each vertex i in V . To set the donor attributes, for each i ∈ [n1], let di be ei, the ith standard basis vector, i.e., the vector of length n1 + 1 with a 1 in the ith coordinate and 0 everywhere else. For i > n1, set di to be en1+1. For the patient attributes of vertex j ∈ [n], for each i ∈ [n] such that (i, j) ∈ E, set pji = 0, and set pji = 1 otherwise. Note that if all the vertices have outgoing edges, then n1 = n unit vectors suffice. A similar approach works to (min{n, n2 + 1}, 0)-represent G, by using the n2 unit vectors as the patient vectors of those vertices with incoming edges, and (if needed) one additional unit vector for any remaining vertices. In both of these cases, 〈di,pj〉 = 0 if and only if (i, j) ∈ E, which represents G by f0thresh.\nIn particular, Theorem 3 implies that any graph is (n, 0)- representable. The next theorem shows a matching lower bound. The same construction and bound also hold if loops are considered (Sen et al. 1989).\nTheorem 4. For any n ≥ 3, there exists a graph on n vertices that is not (k, 0)-representable for all k < n.\nProof. Define G to be the digraph on n vertices, V = [n], with an edge from vertex i, for each i ∈ V , to every vertex except i−1 (and itself), where vertex n is also referred to as vertex 0.\nAssume that G is (k, 0)-representable, and consider vertex 1. Since (1, n) /∈ E, and (i, n) ∈ E for all i /∈ {1, n}, there exists a conflict bit q1 ∈ Qd(1) ∩ Qp(n) such that q1 /∈ Qp(V \\ {1, n}). More generally, there exists such a conflict bit qi for all i ∈ V .\nWe claim that these conflict bits are all unique, which directly implies that k ≥ n. Indeed, otherwise we can assume that q1 = qi for some i 6= 1 (without loss of generality, as the graph is symmetric subject to cyclic permutations). But then (1, i− 1) and (i, n) do not appear as edges in G, which is not true for any i ∈ V \\ {1}.\nMore generally, it is easy to see that any graph that is (k, 0)-representable is also (k + t, t)-representable for any t ≥ 0. Indeed, simply take the (k, 0)-representation of the graph, and append t ones to every vector. Together with Theorem 3, this shows that any graph is (n+ t, t)-representable. However, the lower bound given by Theorem 4 does not extend to t > 0. We conjecture that for any n and t there exists a graph that can only be (k, t)-represented with k = Ω(n)— this remains an open question."
    }, {
      "heading" : "3.2 Computational Issues",
      "text" : "Given a real compatibility graph with n vertices, we know by Theorem 3 that we can (k, 0)-represent that graph for k = n. But, in practice, how large of a k is actually needed?\nVarious problems related to intersection graphs are NPcomplete for general graphs (Kou, Stockmeyer, and Wong 1978; Orlin 1977), but we work in a setting with additional structure. And while we do not show that finding a (k, t)representation isNP-hard, we do show that a slightly harder problem, which we refer to as (k, t)-REPRESENTATIONWITH-IGNORED-EDGES, is NP-hard. Given an input of a directed graph G = (V,E), a subset F of ( V 2 ) , and integers k ≥ 1 and t ≥ 0, this problem asks whether there exist bit vectors di and pi of length k for each i ∈ V such that for any (i, j) ∈ F , we have (i, j) ∈ E if and only if 〈di,pj〉 ≤ t. Theorem 5. The (k, t)-REPRESENTATION-WITHIGNORED-EDGES problem is NP-complete.\nThe theorem’s nontrivial proof is relegated to Appendix A. Here we give a proof sketch. One major idea is the construction of a bit-grounding gadget Gk—a subgraph where the bits are set uniquely (up to permutations) in any valid representation, and can be used to set the bits in other vertices. The gadget has ( k 2 ) vertices; we prove that there is a unique (up to permutations) (k, 1)-representation of Gk,\nwhere each donor vector has a unique pair of ones, and similarly for each patient vector. Figure 5 shows G4.\nThen, we proveNP-hardness by reduction from 3SAT. In the constructed instance of our problem, we set the threshold to 1. The crux of the reduction is to add a vertex for each clause in the given 3SAT formula, where in the patient vector, the bit corresponding to each literal in the clause is set to 1. This can be done by connecting the vertex to the bitgrounding gadget. Moreover, there is a special vertex that does not have outgoing edges to any of the clause vertices. This means that it must have a 1 in a position that corresponds to one of the literals in each clause. A different part of the construction ensures that there is at most a single 1 in the two positions corresponding to a variable and its negation. Therefore, a valid assignment of the donor bits corresponds to a satisfying assignment for the 3SAT formula."
    }, {
      "heading" : "4 Computing Small Representations of Real Kidney Exchange Compatibility Graphs",
      "text" : "In this section, we test our hypothesis that real compatibility graphs can be represented by a substantially smaller number of attributes than required by the worst-case theoretical results of Section 3. We begin by presenting general math programming techniques to determine, given k, t ∈ Z, whether a specific graph G = (V,E) is (k, t)-representable. We then show on real and generated compatibility graphs from the UNOS US-wide kidney exchange that small k suffices for (k, 0)-representation, and conclude by exploring the allowance of greater thresholds t on match size. Even small thresholds t > 0 result in substantial societal gain.5"
    }, {
      "heading" : "4.1 Mathematical Programming Formulations",
      "text" : "Implementation of f tthresh can be written succinctly as a quadratically-constrained discrete feasibility program (QCP) with 2k|V | binary variables, given as M1 below.\n5All code for this section can be found at https://github. com/JohnDickerson/KidneyExchange.\n〈di,pj〉 ≤ t ∀(vi, vj) ∈ E 〈di,pj〉 ≥ (t+ 1) ∀(vi, vj) 6∈ E di,pi ∈ {0, 1}k ∀vi ∈ V\n(M1)\nThe constraint matrix for this program is not positive semi-definite, and thus the problem is not convex. Exploratory use of heuristic search via state-of-the-art integer nonlinear solvers (Bonami et al. 2008) resulted in poor performance (in terms of runtime and solution quality) on even small graphs. With that in mind, and motivated by the presence of substantially more mature integer linear program (ILP) solvers, we linearize M1, presented as M2 below.\nmin ∑ vi∈V ∑\nvj 6=vi∈V ξij s.t. dqi ≥ c q ij ∧ p q j ≥ c q ij ∀vi 6= vj ∈ V, q ∈ [k]\ndqi + p q j ≤ 1 + c q ij ∀vi 6= vj ∈ V, q ∈ [k]∑\nq c q ij ≤ t+ (k − t)ξij ∀(vi, vj) ∈ E∑ q c q ij ≥ (t+ 1)ξij ∀(vi, vj) ∈ E∑\nq c q ij ≥ t+ 1− kξij ∀(vi, vj) 6∈ E∑\nq c q ij ≤ k − (k − t)ξij ∀(vi, vj) 6∈ E\ndqi , p q i ∈ {0, 1} ∀vi ∈ V, q ∈ [k]\ncqij , ξij ∈ {0, 1} ∀vi 6= vj ∈ V, q ∈ [k] (M2)\nM2 generalizes M1; while M1 searches for a feasible solution to the (k, t)-representation problem, M2 finds the “best” (possibly partially-incorrect) solution by minimizing the total number of edges that exist in the solution but not in the base graph G, or do not exist in the solution but do in G. This flexibility may be desirable in practice to strike a tradeoff between small k and accuracy of representation.\nInterestingly, neither the fully general ILP nor its (smaller) instantiations for the special cases of feasibility and/or threshold t = 0 were solvable by a leading commercial ILP solver (IBM ILOG Inc 2015) within 12 hours for even small graphs, primarily due to the model’s loose LP relaxation. Indeed, the model we are solving is inherently logical, which is known to cause such problems in traditional mathematical programming (Hooker 2002). With that in mind, we note that the special case of t = 0 can be represented compactly as a satisfiability (SAT) problem in conjunctive normal form, given below as M3.\n∧ q∈[k] (¬dqi ∨ ¬p q j) ∀(vi, vj) ∈ E\n(z1ij ∨ z2ij ∨ . . . ∨ zkij) ∧∧ q∈[k] [ (¬zqij ∨ d q i ) ∧ (¬z q ij ∨ p q j) ] ∀(vi, vj) 6∈ E (M3)\nThis formulation maintains two sets of clauses: the first set enforces no bit-wise conflicts for edges in the underlying graph, while the second set enforces at least one conflict via k auxiliary variables z·ij for each possible edge (vi, vj) 6∈ E. M3 was amenable to parallel SAT solving (Biere 2014). Next, we present results on real graphs with this formulation.\n4.2 (k, 0)-representations of Real Graphs Can real kidney exchange graphs be represented by a small number of attributes? To answer that question, we begin by\ntesting on real match run data from the first two years of the United Network for Organ Sharing (UNOS) kidney exchange, which now contains 143 transplant centers, that is, 60% of all transplant centers in the US. We translate each compatibility graph into a CNF-SAT formulation according to M3, and feed that into a SAT solver (Biere 2014) with access to 16GB of RAM, 4 cores, and 60 minutes of wall time. (Timeouts are counted—conservatively against our paper’s qualitative message—as negative answers.)\nFigure 2 shows a classical phase transition from unsatisfiability to satisfiability as k increases as a fraction of graph size, as well as an associated substantial increase in computational intractability centered around that phase transition. This phenomenon is common to many central problems in artificial intelligence (Cheeseman, Kanefsky, and Taylor 1991; Hogg, Huberman, and Williams 1996; Walsh 2011). Indeed, we see that substantially fewer than |V | attributes are required to represent real graphs; compare with the lower bound of Theorem 4.\nFigure 3 explores the minimum k required to represent each graph as a function of |V |, compared against the theoretical upper bound of |V |. The shaded area represents those values of k where the SAT solver timed out; thus, the reported values of k are a conservative upper bound on the required minimum, which is still substantially lower than |V |."
    }, {
      "heading" : "4.3 Thresholding Effects on Matching Size",
      "text" : "A motivation of this work is to provide a principled basis for optimally “flipping bits” of participants (via, e.g., immunosuppresion) in fielded kidney exchanges, in the hope that additional edges in the compatibility graph will result in gains in the final algorithmic matchings. We now explore this line of reasoning—that is, increasing the t in f tthresh instead of the k, which is now endogenous to the underlying model— on realistic generated UNOS graphs of varying sizes.\nFigure 4 shows the effect on the percentage of patientdonor pairs matched by 2- and 3-cycles as a global threshold t is raised incrementally from t = 0 (the current status quo) to t = 5. Intuitively, larger compatibility graphs result in a\nhigher fraction of pairs being matched; however, a complementary approach—making the graph denser via even small increases in t—also results in tremendous efficiency gains of 3–4x (depending on |V |) over the baseline for t = 0, and quickly increasing to all pairs being matched by t = 5.\nWe note that any optimal matching found after increasing a global threshold t could also be created by paying to change at most t bits per vertex in a graph; however, the practical selection of the minimum-sized set of at most t bits per vertex such that the size of the resulting optimal matching is equal to that found under the global threshold of t is a difficult two-stage problem and is left as future research. The large efficiency gains realized by moving from f0thresh to even f1thresh motivate this direction of research."
    }, {
      "heading" : "5 Conclusions & Future Research",
      "text" : "Motivated by the increasing size of real-world kidney exchanges, we presented a compact approach to modeling kidney exchange compatibility graphs. Our approach is intimately connected to classical intersection graph theory, and can be viewed as the first exploration and practical application of p-intersection digraphs. We gave necessary and sufficient conditions for losslessly shrinking the representation of an arbitrary compatibility graph in this model. Real compatibility graphs, however, are not arbitrary, and are created from characteristics of the patients and donors; using real data from the UNOS US-wide kidney exchange, we showed that using only a small number of attributes suffices to represent real graphs. This observation is of potential practical importance; if real graphs can be represented by a constant number of attributes, then centralNP-hard problems in general kidney exchange are solvable in polynomial time.\nThis paper only addresses the representation of static compatibility graphs; in reality, exchanges are dynamic, with patients and donors arriving and departing over time (Ünver 2010). Extending the proposed method to cover time-evolving graphs is of independent theoretical interest, but may also be useful in speeding up the (presentlyintractable) dynamic clearing problem (Awasthi and Sandholm 2009; Dickerson, Procaccia, and Sandholm 2012; Anderson 2014; Dickerson and Sandholm 2015; Glorie et al. 2015). Better exact and approximate methods for computing (k, t)-representations of graphs would likely be a prerequisite for that research. Adaptation of the theoretical results to models of lung, liver, and multi-organ exchange would also be of practical use (Ergin, Sönmez, and Ünver 2014; Ergin, Sönmez, and Ünver 2015; Luo and Tang 2015; Dickerson and Sandholm 2016)."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This material is based on work supported by the National Science Foundation (NSF) under grants CCF-1215883, CCF-1525932, IIS-1350598, IIS-1617590, IIS-1320620, and IIS-1546752, the Army Research Office (ARO) under award W911NF-16-1-0061, the Office of Naval Research (ONR) under award N00014-16-1-3075, a Sloan Research Fellowship, a Facebook Fellowship, and a Siebel Scholarship. It made use of XSEDE computing resources provided by the Pittsburgh Supercomputing Center. The authors thank participants at EXPLORE-16, EURO-16, and INFORMS16 sessions, and particularly the anonymous reviewers at AAAI-17 and James Trimble, for helpful discussion."
    }, {
      "heading" : "A Additional Proofs",
      "text" : "In this section, we provide the full proof of Theorem 5. Recall the (k, t)-REPRESENTATION WITH IGNORED EDGES: given an input of a directed graph G = (V,E), a subset F of E, and integers k ≥ 1 and t ≥ 0, this problem asks whether there exist bit vectors di and pi of length k for each i ∈ V such that the {i, j} ∈ F if and only if 〈di,pj〉 ≤ t.\nConsider the gadget Gk defined as follows on a graph on( k 2 ) + k vertices. Let G1k be the graph defined in Theorem 4\non ( k 2 ) vertices, i.e., the complement of a directed cycle on this many vertices. Associate with each vertex u ∈ G1k a unique element from ( [k] 2 ) (all subsets of [k] of size 2). Let G2k be an independent set of k vertices. For each vertex i ∈ G2k, i ∈ [k], add an incoming edge into i from u ∈ G2k if and only if i ∈ Su. Figure 5 shows G4.\nDenote the donor neighborhood of i ∈ V by Nd(i) = {j ∈ V : (i, j) ∈ E, i 6= j}, i.e., the set of patients compatible with donor i. Similarly, the patient neighborhood of j ∈ V is Np(j) = {i ∈ V : {i, j} ∈ E, i 6= j}. Lemma 1. There is a unique (up to permutations) (k, 1)- representation of Gk.\nProof. First consider G1k. For all u ∈ V (G1k), since {u, u− 1} /∈ E(G1k), and the compatibility function is f1thresh, there exist two distinct conflict bits qu1 and q u 2 in Qd(u)∩Qp(u− 1). Moreover, for any u, v distinct, {qu1 , qu2 } 6= {qv1 , qv2}. Otherwise, {qu1 , qu2 } ⊆ Qp(v−1) and {qv1 , qv2} ⊆ Qp(u−1), but at least one of the edges {u, v − 1} or {v, u − 1} exists in G1k.\nIn addition, |Qd(u)| = 2 for all u ∈ V (G1k). Suppose not, and there exists a third distinct (from qu1 and q u 2 ) conflict bit\nqu3 in Qd(u). As the number of vertices is ( k 2 ) , there exists a vertex v1 with {qv11 , qv12 } = {qu1 , qu3 }, and a (different) vertex v2 with {qv21 , qv22 } = {qu2 , qu3 }. Then {u, v1 − 1} and {u, v2 − 1} are both not in E(G1k). However, u has edges to all vertices except itself and u− 1, which is a contradiction, as u, v1, and v2 are all distinct. From this, it also follows that |Qp(u)| = 2.\nWe have thus shown that every vertex u ∈ G1k has exactly two bits set to one in its donor attribute vector, with a unique pair of bits per vertex, and Qd(u) = Qp(u − 1). However, without more structure, it is not possible to tell in which donor vectors a particular conflict bit appears. The additional graph G2k allows us to identify this, up to permutations.\nSince there are no outgoing edges from any of the vertices in G2k, and every pair of bits in ( [k] 2 ) appears in exactly one patient vector of a vertex in G1k, each donor vector in G 2 k must be the all-ones vector of length k. Consider vertex i ∈ [k] in G2k. It has an incoming edge from each vertex u ∈ V (G1k) such that i ∈ Su and it is missing the ( k−1\n2\n) other possible incoming edges from\nG1k (note that the labeling of the vertices, as well as the choices of the sets Su, are made without any knowledge of the bit-vectors associated with the vertices). We next show that\n∣∣∩u∈Np(i)Qd(u)∣∣ = 1. That this quantity is at most 1 is clear, as Qd(u) and Qd(v) intersect in at most one conflict bit for all u, v ∈ V (G1k), u 6= v. If this quantity were 0, then for some u, v ∈ Np(i),Qd(u)∩Qd(v) = ∅. But then at least two zeroes would appear in Qp(i), which is a contradiction as it implies that i would have more than k incoming edges. Thus, the patient vector pi for i ∈ V (G2k) has exactly one zero and ones elsewhere. Moreover, since Np(i) 6= Np(j) for any distinct i, j ∈ [k], it follows that pi 6= pj , so each patient vector is distinct and the position of its only zero is unique.\nLemma 2. Consider a digraph G having Gk as a subgraph and an additional vertex x /∈ V (Gk). We use the compatibility function f1thresh and seek to find a (k, 1)-representation for the induced subgraph G[V (Gk)∪{x}]. Let U ⊆ V (G1k) having that property that if v ∈ V (G1k) with Qd(v) ⊆ ∪u∈UQd(u), then v ∈ U . Let U ′ = {u ∈ V (G1k) : u + 1 ∈ U}. Let Q = ∪u∈UQd(u).\nIf Np(x) = V (Gk1) \\ U , then Qp(x) = Q. If Nd(x) = V (Gk1) \\ U ′, then Qd(x) = Q.\nProof. We use the fact that there are exactly two bits set to one in the donor and patient vectors of each vertex in Gk in any (k, 1)-representation. For the first statement, since x has no edge from u ∈ U , Qp(x) ⊇ Qd(u). Thus Qp(x) ⊇ Q. Now let v ∈ V (G1k) \\ U and qv ∈ Qd(v) \\ Q. If qv ∈ Qp(x), then for each q ∈ Q, there exists a vertex w in G1k with Qd(w) = {q, qv}, so that {w, x} would also not be an edge of G, a contradiction. Hence, Qp(x) = Q. The second statement follows analogously.\nTheorem 5. The (k, t)-REPRESENTATION WITH IGNORED EDGES problem is NP-complete.\nProof. Consider a 3SAT formula on n variables and with m clauses. Set k = 2n + 2, and build the following graph on 2+n+m+ ( k 2 ) +k vertices. The first two vertices are labeled v and u. Then there is a vertex vi for each variable i ∈ [n], a vertex c for each clause c ∈ [m]. Call the subgraph induced by these 2 +n+m vertices G′. The last vertices come from the gadget Gk.\nThe vertices in G2k ground the k bits used in each donor and patient vector.. We think of the k bits, in order, as corresponding to the n positive literals, then their n negations, followed by two “extra” bits. Then the index of literal xi will be i, and the index of literal x̄i will be n+ i. For i and j distinct in V (G2k), |Np(i) ∩Np(j)| = 1 within Gk. Denote this vertex of G1k by v(i, j), and without loss of generality we can assume that Qd(v(i, j)) = {i, j}.\nThe edges among vertices in the induced subgraph Gk are already defined; we define (a subset) of the rest of the edges. Together, these comprise precisely the subset F of the edges and non-edges specified as an input the instance we are creating of (k, t)-REPRESENTATION WITH IGNORED EDGES.\nVertex v has no incoming edges, and the only outgoing edges from v to V (G′) are to every variable vertex vi, i ∈ [n]. The rest of the vertices that are not in Gk have no outgoing edges at all, to either V (G′) or V (Gk), and the only incoming edges are from vertices of G1k. Vertex u has an incoming edge from every vertex of G1k except v(2n + 1, 2n + 2). For each variable vertex vi, i ∈ [n], it has an incoming edge from every vertex in V (G1k) except v(i, n+i). For each clause c ∈ [m], let {c1, c2, c3} be the indices of the three literals that appear in c. LetC ⊂ V (G1k) be {v(c1, c2), v(c1, c3), v(c2, c3), v(c1, k), v(c2, k), v(c3, k)}. Then the vertex corresponding to c has an incoming edge from every vertex in V (G1k) \\ C.\nEvery vertex of V (G′) except for v will have a donor vector with every bit set to one because there are no outgoing\nedges to any vertex of G1k, and v will have an all-ones patient vector because it has no incoming edges from G1k. By Lemma 2, in any (k, 1)-representation of G, vertex u will have Qp(u) = {2n+ 1, 2n+ 2}. Variable vertex vi, i ∈ [n], will have Qp(vi) = {i, n + i}. Clause vertex c ∈ [m] will have Qp(c) = {c1, c2, c3, 2n+ 2}.\nSince the graph does not have an edge from v to u, {2n + 1, 2n + 2} ⊆ Qd(v) (these are the only two conflict bits in Qp(u) and the threshold is 1). Since the graph has an edge from v to each variable vertex vi, i ∈ [n],Qd(v) must contain at most one of the indices corresponding to the variable or its negation (there are no conflicts from the extra bits, which are set to 0 in the patient vector of vi). Since the graph does not have an edge from v to any of the clause vertices, it has to have at least one conflict bit in a position corresponding to one of the three literals in the clause (the other conflict comes from the extra bit 2n+ 2).\nThus, finding a suitable (k, 1)-representation that satisfies the adjacencies of edges that appear in F would involve finding an appropriate set Qd(v), which we have shown corresponds to choosing at most one value for each xi, as well as choosing at least one literal that appears in each clause. This is the same as the problem of finding a satisfying formula for the initial instance of 3SAT.\nAs an example, consider the 3SAT formula x1 ∨ x̄2 ∨ x3. Figure 6 shows the most relevant part of the graph used in the reduction. One possible (k, 1)-representation may have Qd(v) = {1, 7, 8}, indicating x1 = 1 and the rest of the variables are arbitrary. Another example of a possible represen-\ntation is Qd(v) = {1, 3, 5, 7, 8}, meaning x1 = 1, x2 = 0 (index 5 appears), and x3 = 1."
    } ],
    "references" : [ {
      "title" : "Clearing algorithms for barter exchange markets: Enabling nationwide kidney exchanges",
      "author" : [ "Blum Abraham", "D. Sandholm 2007] Abraham", "A. Blum", "T. Sandholm" ],
      "venue" : "In Proceedings of the ACM Conference on Electronic Commerce (EC),",
      "citeRegEx" : "Abraham et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Abraham et al\\.",
      "year" : 2007
    }, {
      "title" : "A",
      "author" : [ "R. Anderson", "I. Ashlagi", "D. Gamarnik", "Roth" ],
      "venue" : "E.",
      "citeRegEx" : "Anderson et al. 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Stochastic models and data driven simulations for healthcare",
      "author" : [ "R. Anderson" ],
      "venue" : null,
      "citeRegEx" : "Anderson,? \\Q2014\\E",
      "shortCiteRegEx" : "Anderson",
      "year" : 2014
    }, {
      "title" : "and Sandholm",
      "author" : [ "P. Awasthi" ],
      "venue" : "T.",
      "citeRegEx" : "Awasthi and Sandholm 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "A",
      "author" : [ "Biere" ],
      "venue" : "2014. Yet another local search solver and lingeling and friends entering the SAT Competition",
      "citeRegEx" : "Biere 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "D",
      "author" : [ "Biró, P.", "Manlove" ],
      "venue" : "F.; and Rizzi, R.",
      "citeRegEx" : "Biró. Manlove. and Rizzi 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "C",
      "author" : [ "P. Bonami", "L.T. Biegler", "A.R. Conn", "G. Cornuéjols", "I.E. Grossmann", "Laird" ],
      "venue" : "D.; Lee, J.; Lodi, A.; Margot, F.; Sawaya, N.; et al.",
      "citeRegEx" : "Bonami et al. 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Where the really hard problems are",
      "author" : [ "Kanefsky Cheeseman", "P. Taylor 1991] Cheeseman", "B. Kanefsky", "W. Taylor" ],
      "venue" : "In Proceedings of the Twelfth International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Cheeseman et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Cheeseman et al\\.",
      "year" : 1991
    }, {
      "title" : "D",
      "author" : [ "M.S. Chung", "West" ],
      "venue" : "B.",
      "citeRegEx" : "Chung and West 1994",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "and Sandholm",
      "author" : [ "J.P. Dickerson" ],
      "venue" : "T.",
      "citeRegEx" : "Dickerson and Sandholm 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "and Sandholm",
      "author" : [ "J.P. Dickerson" ],
      "venue" : "T.",
      "citeRegEx" : "Dickerson and Sandholm 2016",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "J",
      "author" : [ "Dickerson" ],
      "venue" : "P.; Manlove, D.; Plaut, B.; Sandholm, T.; and Trimble, J.",
      "citeRegEx" : "Dickerson et al. 2016",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "A",
      "author" : [ "Dickerson, J.P.", "Procaccia" ],
      "venue" : "D.; and Sandholm, T.",
      "citeRegEx" : "Dickerson. Procaccia. and Sandholm 2012",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "R",
      "author" : [ "Eaton, N.", "Gould" ],
      "venue" : "J.; and Rödl, V.",
      "citeRegEx" : "Eaton. Gould. and Rödl 1996",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "A",
      "author" : [ "Erdős, P.", "Goodman" ],
      "venue" : "W.; and Pósa, L.",
      "citeRegEx" : "Erdős. Goodman. and Pósa 1966",
      "shortCiteRegEx" : null,
      "year" : 1966
    }, {
      "title" : "M",
      "author" : [ "H. Ergin", "T. Sönmez", "Ünver" ],
      "venue" : "U.",
      "citeRegEx" : "Ergin. Sönmez. and Ünver 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "M",
      "author" : [ "H. Ergin", "T. Sönmez", "Ünver" ],
      "venue" : "U.",
      "citeRegEx" : "Ergin. Sönmez. and Ünver 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Robust models for the kidney exchange problem",
      "author" : [ "Glorie" ],
      "venue" : "Working paper",
      "citeRegEx" : "Glorie,? \\Q2015\\E",
      "shortCiteRegEx" : "Glorie",
      "year" : 2015
    }, {
      "title" : "K",
      "author" : [ "Glorie" ],
      "venue" : "M.; van de Klundert, J. J.; and Wagelmans, A. P. M.",
      "citeRegEx" : "Glorie. van de Klundert. and Wagelmans 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "F",
      "author" : [ "F. Harary", "J.A. Kabell", "McMorris" ],
      "venue" : "R.",
      "citeRegEx" : "Harary. Kabell. and McMorris 1982",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "C",
      "author" : [ "T. Hogg", "B.A. Huberman", "Williams" ],
      "venue" : "P.",
      "citeRegEx" : "Hogg. Huberman. and Williams 1996",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "J",
      "author" : [ "Hooker" ],
      "venue" : "N.",
      "citeRegEx" : "Hooker 2002",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "C",
      "author" : [ "L.T. Kou", "L.J. Stockmeyer", "Wong" ],
      "venue" : "K.",
      "citeRegEx" : "Kou. Stockmeyer. and Wong 1978",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "and Tang",
      "author" : [ "S. Luo" ],
      "venue" : "P.",
      "citeRegEx" : "Luo and Tang 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "F",
      "author" : [ "T.A. McKee", "McMorris" ],
      "venue" : "R.",
      "citeRegEx" : "McKee and McMorris 1999",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "and Torras",
      "author" : [ "P. Meseguer" ],
      "venue" : "C.",
      "citeRegEx" : "Meseguer and Torras 2001",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "D",
      "author" : [ "R. Montgomery", "S. Gentry", "W.H. Marks", "D.S. Warren", "J. Hiller", "J. Houp", "A.A. Zachary", "J.K. Melancon", "W.R. Maley", "H. Rabb", "C. Simpkins", "Segev" ],
      "venue" : "L.",
      "citeRegEx" : "Montgomery et al. 2006",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "F",
      "author" : [ "Rapaport" ],
      "venue" : "T.",
      "citeRegEx" : "Rapaport 1986",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "A nonsimultaneous, extended, altruistic-donor chain",
      "author" : [ "Rees" ],
      "venue" : null,
      "citeRegEx" : "Rees,? \\Q2009\\E",
      "shortCiteRegEx" : "Rees",
      "year" : 2009
    }, {
      "title" : "S",
      "author" : [ "A. Roth", "T. Sönmez", "U. Ünver", "F. Delmonico", "Saidman" ],
      "venue" : "L.",
      "citeRegEx" : "Roth et al. 2006",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A kidney exchange clearinghouse in New England",
      "author" : [ "Sönmez Roth", "A. Ünver 2005] Roth", "T. Sönmez", "U. Ünver" ],
      "venue" : "American Economic Review 95(2):376–380",
      "citeRegEx" : "Roth et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Roth et al\\.",
      "year" : 2005
    }, {
      "title" : "D",
      "author" : [ "M. Sen", "S. Das", "A.B. Roy", "West" ],
      "venue" : "B.",
      "citeRegEx" : "Sen et al. 1989",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "Where are the hard manipulation problems",
      "author" : [ "T. Walsh" ],
      "venue" : "Journal of Artificial Intelligence Research",
      "citeRegEx" : "Walsh,? \\Q2011\\E",
      "shortCiteRegEx" : "Walsh",
      "year" : 2011
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "Kidney exchanges are organized markets where patients swap willing but incompatible donors. In the last decade, kidney exchanges grew from small and regional to large and national—and soon, international. This growth results in more lives saved, but exacerbates the empirical hardness of the NP-complete problem of optimally matching patients to donors. State-of-the-art matching engines use integer programming techniques to clear fielded kidney exchanges, but these methods must be tailored to specific models and objective functions, and may fail to scale to larger exchanges. In this paper, we observe that if the kidney exchange compatibility graph can be encoded by a constant number of patient and donor attributes, the clearing problem is solvable in polynomial time. We give necessary and sufficient conditions for losslessly shrinking the representation of an arbitrary compatibility graph. Then, using real compatibility graphs from the UNOS US-wide kidney exchange, we show how many attributes are needed to encode real graphs. The experiments show that, indeed, small numbers of attributes suffice.",
    "creator" : "LaTeX with hyperref package"
  }
}