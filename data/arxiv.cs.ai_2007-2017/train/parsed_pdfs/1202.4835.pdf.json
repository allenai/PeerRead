{
  "name" : "1202.4835.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Isabelle/PIDE as Platform for Educational Tools",
    "authors" : [ "Makarius Wenzel", "Burkhart Wolff" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "P. Quaresma and R.-J. Back (Eds.); THedu’11 EPTCS 79, 2012, pp. 143–153, doi:10.4204/EPTCS.79.9\nc© M. Wenzel & B. Wolff This work is licensed under the Creative Commons Attribution License.\nIsabelle/PIDE as Platform for Educational Tools\nMakarius Wenzel and Burkhart Wolff\nUniversité Paris-Sud 11, LRI, Orsay, France\nThe Isabelle/PIDE platform addresses the question whether proof assistants of the LCF family are suitable as technological basis for educational tools. The traditionally strong logical foundations of systems like HOL, Coq, or Isabelle have so far been counter-balanced by somewhat inaccessible interaction via the TTY (or minor variations like the well-known Proof General / Emacs interface). Thus the fundamental question of math education tools with fully-formal background theories has often been answered negatively due to accidental weaknesses of existing proof engines.\nThe idea of “PIDE” (which means “Prover IDE”) is to integrate existing provers like Isabelle into a larger environment, that facilitates access by end-users and other tools. We use Scala to expose the proof engine in ML to the JVM world, where many user-interfaces, editor frameworks, and educational tools already exist. This shall ultimately lead to combined mathematical assistants, where the logical engine is in the background, without obstructing the view on applications of formal methods, formalized mathematics, and math education in particular."
    }, {
      "heading" : "1 Introduction",
      "text" : "“Isabelle’s user interface is no advance over LCF’s, which is widely condemned as ‘user-unfriendly’: hard to use, bewildering to beginners. Hence the interest in proof editors, where a proof can be constructed and modified rule-by-rule using windows, mouse, and menus. But Edinburgh LCF was invented because real proofs require millions of inferences. Sophisticated tools – rules, tactics and tacticals, the language ML, the logics themselves – are hard to learn, yet they are essential. We may demand a mouse, but we need better education and training.” (L.C. Paulson, in “Isabelle: The Next 700 Theorem Provers”, 1990)"
    }, {
      "heading" : "1.1 The LCF prover family",
      "text" : "Isabelle [21] is an interactive theorem prover platform in the tradition of LCF [7]. Other notable descendants of LCF are HOL and Coq, see also [28]. Even after several decades, current systems share the following main traits of the original LCF approach:\n1. Strong logical foundations. Some well-understood logical basis is taken as starting point, and mathematical theories are explicitly constructed by reduction to first principles. This follows the tradition of “honest toil” in the sense of Bertrand Russel: results are not just postulated as axioms, but derived from definitions as actual theorems.\n2. Free programmability and extensibility. Derived proof tools can be implemented on top of the logical core, while fully retaining its integrity. This works by the strong type-safety properties of the ML implementation platform of the prover.\n3. Primitive read-eval-print loop. User interaction works by issuing individual commands, which the prover interprets on the spot and prints results accordingly. Prover commands update an implicit state, which most newer provers allow to undo in a linear fashion, to support the well-known proof scripting mode of Proof General [2].\nOn the one hand, this general architecture proved quite successful in building reasonably large libraries of formal theories (such as the Archive of Formal Proof1 for Isabelle). On the other hand, integrating an LCF-style prover into into a combined mathematical assistant, especially one intended for math education, poses some challenges:\nInteraction. How can casual users interact with the prover, without getting exposed to the full details of logic implemented on the computer? How can specific interaction scenarios that are relevant for computer-assisted math education be supported, hiding the fact that there is a fully-featured prover engine at the bottom?\nIntegration. How can other systems connect to the prover engine? How can we overcome the traditional plumbing of the read-eval-print loop via pipes, typically with synchronous / sequential protocols. How can we proceed to the next generation of integrated mathematical assistants, with sophisticated front-ends and back-ends, using asynchronous / parallel evaluation?\nIn the past few years, Isabelle has acquired more and more support for Prover IDE concepts, to address the above issues systematically. This facilitates future implementations of mathematical assistants and applications to math education. In particular, the read-eval-print loop is replaced by a document model for direct editing with asynchronous interaction and parallel checking. This is a continuation of earlier work on parallel proof checking [24, 13] and modern prover interfaces [25]. Some aspects of formal document-content have already been covered in [20]. In the present paper, we discuss the overall PIDE framework and its technological side-conditions as integrative platform for educational tools that happen to care about logical foundations."
    }, {
      "heading" : "1.2 Formal logic for education",
      "text" : "Formality in educational tools cannot be taken for granted. Major teaching tools for dynamic geometry like Geogebra2 have managed to ignore formal background theory for many years. This raises the general question if the informality of contemporary math education tools is substantial or accidental.\nSubstantial lack of formal foundations would mean that logical principles are considered irrelevant or unwanted for math education. Even the principle of mathematical proof appears to be challenged occasionally, and removed from many curricula of high-school mathematics. This could be the starting point of philosophical and political discussions of the meaning of profound mathematical understanding for our technological society, but that is beyond the scope of the present paper.\nAccidental lack of formal foundations can be explained easily by technical side-conditions. Inaccessible and arcane theorem provers are unlikely to be considered as a platform for educational tools. Classic Isabelle has not been any better than HOL or Coq in this respect. In the past, there have been attempts to make LCF-style provers easier to access for their own right nonetheless, but the resulting culture of crude user-interfaces for theorem provers is still confined by the interaction model of Proof General [2]. This proved successful in its time, because it fits tightly with the TTY-based read-eval-print loop of existing systems, but it was difficult to continue from there. The PGIP initiative [3], which was essentially based on the same old command line model, could not repeat the acceptance of classic Proof General / Emacs, even though Eclipse was propagated as new front-end technology.\nOur PIDE approach is meant to change the rules of the game again, to expose interactive theorem proving to a broader audience, especially for education in mathematics, and other disciplines that depend\n1http://afp.sf.net 2http://www.geogebra.org\non mathematical and logical foundations (e.g. formal-methods or systems engineering). By overcoming the technical restrictions of interactive provers wrt. interaction and integration into educational tools, it should eventually become possible to investigate formal foundations of math education again.\nIn the present paper, we outline the current status of the Isabelle/PIDE platform with its approach to domain-specific formal languages for embeddings into the logical environment that are accessible to IDE front-ends. This includes some architecture for structured specifications and proofs (Isabelle/Isar), parallel symbolic computation (Isabelle/ML), and higher-order object-oriented system integration (Isabelle/Scala). Moreover, the current release of Isabelle2011-1 (October 2011)3 already includes Isabelle/jEdit as concrete Prover IDE implementation within the generic framework. We shall also sketch further potential application scenarios, especially for educational purposes."
    }, {
      "heading" : "2 Isabelle/Isar proof documents",
      "text" : "One of the specific strengths of the Isabelle platform is the Isar proof language [27] that allows to express formal reasoning in a way that is both human-readable and machine-checkable. Unlike other systems in this category (notably Mizar [28]), the Isar proof language is merely an application of a more general framework for structured logical environments: the notion of Isar proof context provides flexible means to operate within the scope of locally fixed parameters and assumptions. Over the years the general framework has already been re-used for structured specifications and module systems in Isabelle (such as locales and type-classes [8, 9]).\nBeyond the default Isar proof language, it is possible to implement domain-specific languages for structured reasoning. To illustrate some possibilities, we show outlines for calculational reasoning and induction in Isabelle/Isar. The subsequent examples use the recent notepad element that allows to sketch formal reasoning independently of any pending goals.\nnotepad begin\nhave a = b sorry also have ... = c sorry also have ... = d sorry finally have a = d .\nend\nnotepad begin\nfix n :: nat have P n proof (induct n) case 0 show P 0 sorry next case (Suc n) from 〈P n〉 show P (Suc n) sorry\nqed end\nHere the language elements also and finally for calculational sequences, and the specific induct proof method with its symbolic cases are defined in user-space, although they happen to be part of the standard library of Isabelle. By understanding Isabelle/Isar as generic framework for domain-specific formal languages, rather than a particular proof language, tool builders can start to implement their own sublanguages. See also the main Isabelle/Isar reference manuals [23, 22] for further details.\nThe idea of integrating a variety of formal languages into Isar proof documents has been there from the beginning [27], and continues the “generic framework” tradition of early Isabelle [16]. In the past this was mostly limited to command-line interaction and batch-processing of plain text sources, with some\n3http://isabelle.in.tum.de\noff-line presentation in PDF-LATEX. In Isabelle/PIDE the concept of formal proof document is extended for online interaction, with continuous proof checking and visualization of formal content in the editor (semantic highlighting, tooltips, popups, hyperlinks etc.).\nIn order to make this work systematically, the traditional prover engine is connected to the JVM, using the Isabelle/Scala integration layer that is already part of recent Isabelle versions."
    }, {
      "heading" : "3 Isabelle/ML versus Isabelle/Scala",
      "text" : "Isabelle/ML is both the implementation and extension language of Isabelle/Isar. ML is embedded into the formal Isar context, such that user code can refer to formal entities in the text, to achieve some static type-checking of logical syntax [26]. It is also possible to make ML tools depend on logical parameters and assumptions, and apply them later in a different context with concrete terms and theorems [5].\nThe relation of Isabelle/ML versus the Isabelle logical framework is best understood as an elaboration of the original LCF approach [7], where ML was introduced as meta-language to manipulate logical entities with full access to formal syntax.\nIsabelle/Scala is a new layer around the Isabelle prover that was introduced to facilitate system interaction and integration as discussed before. The idea is to wrap the traditional ML prover process into some library for Scala/JVM [14]. Thus the prover can be accessed via some statically-typed Scala API, while the connection between the two different processes (ML back-end versus JVM front-end) is hidden in some internal protocol. The implementation leverages the existing concurrent and parallel infrastructure of both ML [13] and Scala [10].\nOur principle of public API and private protocol turns out as important to achieve high-performance prover communication and flexibility for future refinements of the interaction model (precise evaluation strategies for document sub-structure etc.).\ninternal protocolAPI API\nSc al a\nM L\nML threads\nML futures\nPOSIX processesPOSIX processes\nJava threads\nScala actors\nTCP/IP servers\nMLScala/JVM\nJVM bridge\nThe Isabelle/Scala interaction model is asynchronous: the front-end can send batches of document updates to the prover, which will be processed in pipelined and parallel mode. Results are accumulated in monotonic fashion in a persistent document model, which consists of collections of XML trees that are incrementally extended for each document version, and can be visualized on demand according to physical GUI events. Document updates are pure mathematical operations that work on a family of versions with immutable content.\nOur mixed ML/Scala architecture allows to re-use decades of research into core prover technology, while integrating with more mainstream front-ends. A typical example is the concrete Prover IDE as implemented in Isabelle/jEdit [25]. Here the existing editor framework jEdit4, which is based on standard\n4http://www.jedit.org\nJava/Swing together with some simple plugin architecture, is connected to the semantic document content provided by the Isabelle process in the background. Thus the user gets an impression of continuous proof checking, with IDE-style visualization of error messages, proof states, results etc. Additional semantic information is attached to the source text, and can be displayed as tooltips, popups, hyperlinks etc. within the editor.\nIsabelle/jEdit can be understood as reference application for other projects. At the same time it is already usable as IDE for Isabelle theory development, which includes embedded Isabelle/ML for addons tools. The following screenshot illustrates the immediate Isabelle/Isar/ML IDE aspect.\nThe ML snippet within the logical notepad above refers to some logical entity embedded into the program text (“certified proposition” @{cprop}). The term structure is annotated by semantic content from the prover using common document-oriented markup infrastructure of PIDE. This enables a hyperlink to the formal entity of Isabelle/HOL that corresponds to the notation for conjunction “∧”. This connection of formal content with surface syntax works reliably despite somewhat complex nesting of several user-defined formal languages within the Isabelle/Isar framework.\nThe underlying Poly/ML compiler5 participates in the same document model of Isabelle/Scala, to provide immediate interactive feedback via semantic highlighting for keywords, sub-expressions and tooltips for inferred types. This has required modest changes of the compiler by its author David Matthews. Other implementations of “domain-specific formal languages” may participate in a similar manner, after minimal reforms of such classic command-line oriented tools.\nPhysical rendering within the editor uses whatever happens to be available on the Java/Swing platform: mathematical symbols from the Unicode repertoire, font-styles with affine transformations (for sub/superscripts), colors with transparency (alpha-channel) etc. This approximates poor-man’s mathematical type-setting within the bounds of the plain-text editor engine of jEdit."
    }, {
      "heading" : "4 Document-oriented prover interaction",
      "text" : "Conceptually, the main abstraction of the PIDE framework is an interactive document-model that provides a timeless / stateless view on the results of the parallel and asynchronous proof engine in the background. The main aspects of document-oriented prover interaction are as follows.\n5http://www.polyml.org\n• Physical editor events stemming from conventional GUI components are turned into mathematical entities with explicit version information (algebra of document changes). This continuous stream of changes is processed incrementally, with some intermediate pipelining and preprocessing. The detachment from physical time and space enables sophisticated scheduling, parallel processing etc. on the prover side.\n• Corresponding prover results are streamed towards the front-end. Versions are identified explicitly, and content of common sub-structures of related document versions is shared to some extent. The Isabelle/Scala document model absorbs all markup that is produced by the prover in an incremental manner. The editor can query that information at any time, and interpret its XML content in terms of conventional GUI metaphors.\n• Asynchronous streaming back and forth between the two processes naturally leads to time shifts and delays in the propagation of information. The document API includes a notion of outdated content and some approximation of future results by reverting text edits on old versions. The implementation of the two-sided protocol engine works generally in a lock-free manner. Data access is not synchronized, but certain values converge to the intended meaning, by accumulating approximative information over time in a monotonic fashion.\n• Document-content is persistent by default. This means that conceptually, old version are never destroyed. The implementation eventually disposes unreachable parts of the history to reclaim memory (garbage collection). In particular, current Isabelle/jEdit merely maintains a relatively narrow window on versions that are being pipelined between the two processes. So far there is no connection to the editor history: undo or redo operations on the text will reconstruct content by replaying relevant parts within the prover.\nThe subsequent screenshot illustrates the mathematical idea of document snapshot within the physical editor. The content is shown in various projections (via interpretation functions), using standard GUI metaphors as well as direct program access in the Scala console that is part of Isabelle/jEdit.\nThe assembly of dockable panels in Isabelle/jEdit is managed within the same JVM process. Conventional multithreading achieves smooth operation, while other editor tasks continue.6 The prover process is fully detached: neither the editor nor the prover are ever forced to wait for the other side.\nUser tools implemented within the ML world of the prover may participate in the document-oriented approach by minimal means. The general programming model is a continuous extension of the TTY model: ML code runs within a certain transaction context, so regular text messages can be associated with a certain execution state of particular document versions. The result will be associated with the document content in the proper position, thanks to mathematically captured space and time.\nFurthermore, the traditional text operations for prover output can be augmented to support full XML markup, by using our refined YXML transfer syntax [20, §2.3], which allows text and markup to be composed orthogonally as byte sequence. Due to augmented standard display operations of the prover, user code will automatically benefit from rich markup information that can be post-processed on the front-end side.\nThe following example illustrates how the prover is able to speak XML natively, despite the appearance of plain-old text-oriented application code.\nML 〈〈 warning (\"Term: \" ^ Syntax.string_of_term ctxt t ^ Position.str_of pos) 〉〉\nThis prints term t which is x + y containing some undeclared variables that Isabelle highlights to warn the user. There is also some reference to the logical constant behind the “+” notation. The Isabelle/Scala document-model receives the following XML tree:\n<warning serial=\"553408\" offset=\"1\" end_offset=\"3\" id=\"124\">Term: <term><block indent=\"0\"><block indent=\"0\"><hilite><block indent=\"0\"><free><block indent=\"0\">x</block></free></block></hilite> <entity ref=\"20935\" def_line=\"134\" def_offset=\"3517\" def_end_offset=\"3522\" def_file=\"~~/src/HOL/Groups.thy\" name=\"Groups.plus_class.plus\" kind=\"constant\"><block indent=\"0\">+</block></entity><break width=\"1\"> </break><hilite><block indent=\"0\"><free><block indent=\"0\">y</block></free></block></hilite></block></block></term><position offset=\"69\" end_offset=\"72\" id=\"-114\"/></warning>\nHere we also see that the traditional pretty-printing of terms according to Oppen [15] is turned into symbolic markup. Physical formatting is done later within some GUI container, based on precise window size and font-metrics — no more fixed-width ASCII text on the TTY.\nThe above idea of augmenting plain-text output by document-oriented markup depends on some minimal requirements of existing ML user code: standard Isabelle/ML functions to format term structures and to output text messages need to be used exclusively. Direct writing to stdio channels of the operating system is not appropriate.7\nIsabelle/ML also provides some explicit markup operations, such that user code may indicate additional semantic aspects in the text. Furthermore the classic canon of writeln, warning and error\n6Contrast this to the single-threaded LISP interpreter of Emacs. 7In early attempts with PGIP the protocol machine would crash, but PIDE uses a private byte channel between the two processes and leaves stdin/stdout/stderr open for exceptional situations. Thus raw stdout steps outside the document model, producing an accidental side-effect as physical process I/O. The front-end might capture that and display it on some system console for diagnostic purposes, or just ignore it.\nmessages is extended by Output.status and Output.report, which augment document content without immediate display to the user. The latter is used for semantic syntax-highlighting of the sources, for example."
    }, {
      "heading" : "5 Further Application Scenarios",
      "text" : "The ongoing development of the Isabelle/Scala layer and the Isabelle/jEdit application demonstrate that it is feasible to build combined mathematical assistants with LCF-style formal basis. We can anticipate the following further application scenarios, which are particularly relevant for educational tool development.\n1. Document preparation with rich semantic content, based on the logical context of a given theory library. The idea is to render the markup information that the prover provides for formal source text into XHTML/CSS, or similar technologies. This would allow to browse annotated text within a JVM-based HTML browser. A typical application could be an interactive text-book, where highquality rendering is combined with some querying or exploration of formal prover content.\n2. Client-side mathematical editors with specific support for typical patterns like calculational reasoning and induction. Such mathematical worksheets should also address proper mathematical notation, instead of the direct source presentation of the existing Prover IDE. This requires some means for high-quality typesetting of mathematical formulae on the JVM, which are unfortunately not easily available in open-source, though.\n3. Rich-client IDE components as extensions to the Prover IDE. The design of jEdit makes it easy to assemble JVM/Swing components as plugins. Thus existing tools like Geogebra that happen to work with the same platform can be easily integrated, at least at the GUI level. The actual logical connection to some theory of geometry is a different issue, e.g. see [17] for recent work with Coq.\n4. Server-side applications using JVM-based web frameworks. Java/Swing GUI components for rich clients are adequate, but the true strength of the JVM platform are its server components. We have only started to investigate the possibilities: JVM-based web servers like Apache Tomcat or Jetty are commonplace; sophisticated application frameworks like Lift8 or Play9 are built on top, and allow easy integration of Scala components in particular.\nThe web application scenario might turn out particularly interesting for educational purposes, especially in combination with the aspects of document preparation and mathematical editors. For example, Isabelle/Scala + Lift could be used as a basis for some mathematical Wiki [18] that can be used by students immediately within their usual browser, tablet computer, or smart-phone. Rich clients like our existing Prover IDE fit into this scenario as high-end authoring tools to produce formal libraries in the first place."
    }, {
      "heading" : "6 Conclusion",
      "text" : "The main contributions of the Isabelle/PIDE platform are some answers to old issues of prover interaction and integration. The combination of ML/Scala successfully bridges the technological (and cultural) gap of higher-order functional and object-oriented programming. This results in improved accessibility of\n8http://liftweb.net 9http://www.playframework.org/\nfully-foundational LCF-style provers. The particular benefits for educational scenarios are a corollary from that, among other possibilities not covered here (e.g. tools for formal methods)."
    }, {
      "heading" : "6.1 Related work",
      "text" : "The problem of prover integration has been tackled many times in the past. Often the idea is to define each program as independent “component” with explicit communication protocols, say between provers, computer algebra systems, front-ends, etc. This approach has been followed in the PROSPER project [6] and PGIP [3], for example.\nWe argue that cutting components at process boundary leads to rather complex interfaces defined by the protocols, which need to be standardized, implemented and maintained. Some of this was attempted for PGIP and Isabelle in 2004–2006, but with limited success. The postulated properties of the protocol and the reality of the prover did not fit together. Moreover, the full potential of the prover was inhibited by the sequential / synchronous interaction model of PGIP, which was inherited from classic Proof General.\nIn Isabelle/PIDE these limitations have been overcome by cutting the main conceptual building blocks differently: a simple Scala API for declarative document editing, which is implemented by a complex protocol that bridges Scala/ML internally. This scheme allows to follow the ongoing evolution of prover technology. For example, when first versions of PGIP were drafted in 2004, the multicore revolution of 2005/2006 was not yet anticipated. Parallel Isabelle is routinely available since 2008/2009 [24, 13], but prover interaction protocols were lagging behind for a long time.\nProver interaction and prover interfaces in the LCF-tradition usually means TTY commands, but this has been challenged occasionally in the past, e.g. in CtCoq/Pcoq [4] or PLATΩ [19]. Matita [1] is probably the best-known proof assistant that was designed with some IDE support (based on OCaml/GTk) and advanced presentation formats (MathML) from the start, although its interaction model imitates classic Proof General / Emacs [2] again.\nProofWeb [12] transfers the Proof General model to the web, using standard AJAX web technology: a custom-made webserver in OCaml is wrapped around the prover process on the server, the client uses JavaScript on Firefox. This web application has been successfully applied for logic courses for university students [11]."
    }, {
      "heading" : "6.2 Future work",
      "text" : "We expect that the current state of the Isabelle/Scala integration layer in Isabelle2011-1 is only the start of renewed interest in advanced prover integration scenarios. An important trajectory for the existing document-model is scalability of the built-in editing history towards distributed version control with multiple users.\nThis means, the current two-sided communication would eventually cover multiple end-points that work in a distributed manner world-wide. Continuous formal checking could be backed by some server farm (or “cloud”), managing many prover processes, each of them again running threads parallel.\nFurther infrastructure will be required to organize collaborative users, which is especially interesting for education where teachers and students collaborate naturally."
    } ],
    "references" : [ {
      "title" : "User Interaction with the Matita Proof Assistant",
      "author" : [ "Andrea Asperti", "Claudio Sacerdoti Coen", "Enrico Tassi", "Stefano Zacchiroli" ],
      "venue" : "Journal of Automated Reasoning",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2007
    }, {
      "title" : "Proof General: A Generic Tool for Proof Development",
      "author" : [ "David Aspinall" ],
      "venue" : "editors: European Joint Conferences on Theory and Practice of Software (ETAPS),",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2000
    }, {
      "title" : "A Framework for Interactive Proof",
      "author" : [ "David Aspinall", "Christoph Lüth", "Daniel Winterstein" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2007
    }, {
      "title" : "A generic approach to building user interfaces for theorem provers",
      "author" : [ "Yves Bertot", "Laurent Théry" ],
      "venue" : "Journal of Symbolic Computation",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1998
    }, {
      "title" : "Context aware Calculation and Deduction — Ring Equalities via Gröbner Bases in Isabelle",
      "author" : [ "Amine Chaieb", "Makarius Wenzel" ],
      "venue" : "editors: Towards Mechanized Mathematical Assistants (CALCULEMUS",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2007
    }, {
      "title" : "Constructive Type Classes in Isabelle",
      "author" : [ "Florian Haftmann", "Makarius Wenzel" ],
      "venue" : "editors: Types for Proofs and Programs,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2007
    }, {
      "title" : "Local theory specifications in Isabelle/Isar",
      "author" : [ "Florian Haftmann", "Makarius Wenzel" ],
      "venue" : "editors: Types for Proofs and Programs,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2009
    }, {
      "title" : "Event-Based Programming without Inversion of Control",
      "author" : [ "P. Haller", "M. Odersky" ],
      "venue" : "Joint Modular Languages Conference, Springer LNCS",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2006
    }, {
      "title" : "Teaching logic using a state-of-the-art proof assistant",
      "author" : [ "Maxim Hendriks", "Cezary Kaliszyk", "Femke van Raamsdonk", "Freek Wiedijk" ],
      "venue" : "Acta Didactica Napocensia",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2010
    }, {
      "title" : "Web interfaces for proof assistants",
      "author" : [ "Cezary Kaliszyk" ],
      "venue" : "editors: User Interfaces for Theorem Provers (UITP",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2007
    }, {
      "title" : "Efficient Parallel Programming in Poly/ML and Isabelle/ML",
      "author" : [ "David C.J. Matthews", "Makarius Wenzel" ],
      "venue" : "ACM SIGPLAN Workshop on Declarative Aspects of Multicore Programming (DAMP",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2010
    }, {
      "title" : "An Overview of the Scala Programming Language",
      "author" : [ "M. Odersky" ],
      "venue" : "Technical Report IC/2004/64,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2004
    }, {
      "title" : "Isabelle: The Next 700 Theorem Provers",
      "author" : [ "Lawrence C. Paulson" ],
      "venue" : "In P. Odifreddi, editor: Logic and Computer Science,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1990
    }, {
      "title" : "A combination of a dynamic geometry software with a proof assistant for interactive formal proofs",
      "author" : [ "Tuan Minh Pham", "Yves Bertot" ],
      "venue" : "FLOC 2010 Satellite Workshop",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2010
    }, {
      "title" : "A Wiki for Mizar: Motivation, Considerations, and Initial Prototype",
      "author" : [ "J. Urban", "J. Alama", "P. Rudnicki", "H. Geuvers" ],
      "venue" : "In: Conference on Intelligent Computer Mathematics (CICM",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2010
    }, {
      "title" : "PLATΩ: A Mediator between Text-Editors and Proof Assistance Systems",
      "author" : [ "Marc Wagner", "S. Autexier", "C. Benzmüller" ],
      "venue" : "editors: User Interfaces for Theorem Provers (UITP",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2007
    }, {
      "title" : "Isabelle as Document-oriented Proof Assistant",
      "author" : [ "M. Wenzel" ],
      "venue" : "In: Conference on Intelligent Computer Mathematics / Mathematical Knowledge Management (CICM/MKM",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2011
    }, {
      "title" : "The Isabelle Framework. In: Theorem Proving in Higher Order Logics (TPHOLs",
      "author" : [ "M. Wenzel", "L.C. Paulson", "T. Nipkow" ],
      "venue" : null,
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2008
    }, {
      "title" : "Parallel Proof Checking in Isabelle/Isar",
      "author" : [ "Makarius Wenzel" ],
      "venue" : "editors: ACM SIGSAM 2009 International Workshop on Programming Languages for Mechanized Mathematics Systems (PLMMS),",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2009
    }, {
      "title" : "Asynchronous Proof Processing with Isabelle/Scala and Isabelle/jEdit",
      "author" : [ "Makarius Wenzel" ],
      "venue" : "FLOC 2010 Satellite Workshop",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2010
    }, {
      "title" : "SML with antiquotations embedded into Isabelle/Isar",
      "author" : [ "Makarius Wenzel", "Amine Chaieb" ],
      "venue" : "editors: Workshop on Programming Languages for Mechanized Mathematics (PLMMS",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2007
    }, {
      "title" : "Isar — a Generic Interpretative Approach to Readable Formal Proof Documents",
      "author" : [ "Markus Wenzel" ],
      "venue" : "editors: Theorem Proving in Higher Order Logics (TPHOLs",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 1999
    } ],
    "referenceMentions" : [ {
      "referenceID" : 17,
      "context" : "Isabelle [21] is an interactive theorem prover platform in the tradition of LCF [7].",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 1,
      "context" : "Prover commands update an implicit state, which most newer provers allow to undo in a linear fashion, to support the well-known proof scripting mode of Proof General [2].",
      "startOffset" : 166,
      "endOffset" : 169
    }, {
      "referenceID" : 18,
      "context" : "This is a continuation of earlier work on parallel proof checking [24, 13] and modern prover interfaces [25].",
      "startOffset" : 66,
      "endOffset" : 74
    }, {
      "referenceID" : 10,
      "context" : "This is a continuation of earlier work on parallel proof checking [24, 13] and modern prover interfaces [25].",
      "startOffset" : 66,
      "endOffset" : 74
    }, {
      "referenceID" : 19,
      "context" : "This is a continuation of earlier work on parallel proof checking [24, 13] and modern prover interfaces [25].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 16,
      "context" : "Some aspects of formal document-content have already been covered in [20].",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 1,
      "context" : "In the past, there have been attempts to make LCF-style provers easier to access for their own right nonetheless, but the resulting culture of crude user-interfaces for theorem provers is still confined by the interaction model of Proof General [2].",
      "startOffset" : 245,
      "endOffset" : 248
    }, {
      "referenceID" : 2,
      "context" : "The PGIP initiative [3], which was essentially based on the same old command line model, could not repeat the acceptance of classic Proof General / Emacs, even though Eclipse was propagated as new front-end technology.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 21,
      "context" : "One of the specific strengths of the Isabelle platform is the Isar proof language [27] that allows to express formal reasoning in a way that is both human-readable and machine-checkable.",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 5,
      "context" : "Over the years the general framework has already been re-used for structured specifications and module systems in Isabelle (such as locales and type-classes [8, 9]).",
      "startOffset" : 157,
      "endOffset" : 163
    }, {
      "referenceID" : 6,
      "context" : "Over the years the general framework has already been re-used for structured specifications and module systems in Isabelle (such as locales and type-classes [8, 9]).",
      "startOffset" : 157,
      "endOffset" : 163
    }, {
      "referenceID" : 21,
      "context" : "The idea of integrating a variety of formal languages into Isar proof documents has been there from the beginning [27], and continues the “generic framework” tradition of early Isabelle [16].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 12,
      "context" : "The idea of integrating a variety of formal languages into Isar proof documents has been there from the beginning [27], and continues the “generic framework” tradition of early Isabelle [16].",
      "startOffset" : 186,
      "endOffset" : 190
    }, {
      "referenceID" : 20,
      "context" : "ML is embedded into the formal Isar context, such that user code can refer to formal entities in the text, to achieve some static type-checking of logical syntax [26].",
      "startOffset" : 162,
      "endOffset" : 166
    }, {
      "referenceID" : 4,
      "context" : "It is also possible to make ML tools depend on logical parameters and assumptions, and apply them later in a different context with concrete terms and theorems [5].",
      "startOffset" : 160,
      "endOffset" : 163
    }, {
      "referenceID" : 11,
      "context" : "The idea is to wrap the traditional ML prover process into some library for Scala/JVM [14].",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 10,
      "context" : "The implementation leverages the existing concurrent and parallel infrastructure of both ML [13] and Scala [10].",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 7,
      "context" : "The implementation leverages the existing concurrent and parallel infrastructure of both ML [13] and Scala [10].",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 19,
      "context" : "A typical example is the concrete Prover IDE as implemented in Isabelle/jEdit [25].",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 13,
      "context" : "see [17] for recent work with Coq.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 14,
      "context" : "For example, Isabelle/Scala + Lift could be used as a basis for some mathematical Wiki [18] that can be used by students immediately within their usual browser, tablet computer, or smart-phone.",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 2,
      "context" : "This approach has been followed in the PROSPER project [6] and PGIP [3], for example.",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 18,
      "context" : "Parallel Isabelle is routinely available since 2008/2009 [24, 13], but prover interaction protocols were lagging behind for a long time.",
      "startOffset" : 57,
      "endOffset" : 65
    }, {
      "referenceID" : 10,
      "context" : "Parallel Isabelle is routinely available since 2008/2009 [24, 13], but prover interaction protocols were lagging behind for a long time.",
      "startOffset" : 57,
      "endOffset" : 65
    }, {
      "referenceID" : 3,
      "context" : "in CtCoq/Pcoq [4] or PLATΩ [19].",
      "startOffset" : 14,
      "endOffset" : 17
    }, {
      "referenceID" : 15,
      "context" : "in CtCoq/Pcoq [4] or PLATΩ [19].",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 0,
      "context" : "Matita [1] is probably the best-known proof assistant that was designed with some IDE support (based on OCaml/GTk) and advanced presentation formats (MathML) from the start, although its interaction model imitates classic Proof General / Emacs [2] again.",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 1,
      "context" : "Matita [1] is probably the best-known proof assistant that was designed with some IDE support (based on OCaml/GTk) and advanced presentation formats (MathML) from the start, although its interaction model imitates classic Proof General / Emacs [2] again.",
      "startOffset" : 244,
      "endOffset" : 247
    }, {
      "referenceID" : 9,
      "context" : "ProofWeb [12] transfers the Proof General model to the web, using standard AJAX web technology: a custom-made webserver in OCaml is wrapped around the prover process on the server, the client uses JavaScript on Firefox.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 8,
      "context" : "This web application has been successfully applied for logic courses for university students [11].",
      "startOffset" : 93,
      "endOffset" : 97
    } ],
    "year" : 2012,
    "abstractText" : "The Isabelle/PIDE platform addresses the question whether proof assistants of the LCF family are suitable as technological basis for educational tools. The traditionally strong logical foundations of systems like HOL, Coq, or Isabelle have so far been counter-balanced by somewhat inaccessible interaction via the TTY (or minor variations like the well-known Proof General / Emacs interface). Thus the fundamental question of math education tools with fully-formal background theories has often been answered negatively due to accidental weaknesses of existing proof engines. The idea of “PIDE” (which means “Prover IDE”) is to integrate existing provers like Isabelle into a larger environment, that facilitates access by end-users and other tools. We use Scala to expose the proof engine in ML to the JVM world, where many user-interfaces, editor frameworks, and educational tools already exist. This shall ultimately lead to combined mathematical assistants, where the logical engine is in the background, without obstructing the view on applications of formal methods, formalized mathematics, and math education in particular.",
    "creator" : "LaTeX with hyperref package"
  }
}