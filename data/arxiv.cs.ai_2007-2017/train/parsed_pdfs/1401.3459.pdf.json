{
  "name" : "1401.3459.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Generic Preferences over Subsets of Structured Objects",
    "authors" : [ "Maxim Binshtok", "Ronen I. Brafman", "Carmel Domshlak", "Solomon E. Shimony" ],
    "emails" : [ "MAXIMBI@CS.BGU.AC.IL", "BRAFMAN@CS.BGU.AC.IL", "DCARMEL@IE.TECHNION.AC.IL", "SHIMONY@CS.BGU.AC.IL" ],
    "sections" : [ {
      "heading" : null,
      "text" : "subset of a given set of items. Here we focus on problems where the individual items are described using a set of characterizing attributes, and a generic preference specification is required, that is, a specification that can work with an arbitrary set of items. For example, preferences over the content of an online newspaper should have this form: At each viewing, the newspaper contains a subset of the set of articles currently available. Our preference specification over this subset should be provided offline, but we should be able to use it to select a subset of any currently available set of articles, e.g., based on their tags. We present a general approach for lifting formalisms for specifying preferences over objects with multiple attributes into ones that specify preferences over subsets of such objects. We also show how we can compute an optimal subset given such a specification in a relatively efficient manner. We provide an empirical evaluation of the approach as well as some worst-case complexity results."
    }, {
      "heading" : "1. Introduction",
      "text" : "Work on reasoning with preferences focuses mostly on the task of recognizing preferred elements within a given set. However, another problem of interest is that of selecting an optimal subset of elements. Optimal subset selection is an important problem with many applications: the choice of feature subsets in machine learning, selection of a preferred bundle of goods (as in, e.g., a home entertainment system), finding the best set of items to display on the user’s screen, selecting the best set of articles for a newspaper or the best members for a committee, etc.\nEarlier work on this problem has mostly focused on the question of how one can construct an ordering over subsets of elements given an ordering over the elements of the set (Barberà, Bossert, & Pattanaik, 2004). The main distinction made has been between sets of items that are mutually exclusive, in the sense that only one can eventually materialize, and sets in which the items will jointly materialize. Our formalism is agnostic on this issue, although we are clearly motivated by the latter case. As Barberà et al. note, most past work focused on the case of mutually exclusive elements. This, for example, would be the case if we are selecting a set of alternatives from which some decision-maker (or nature) will ultimately choose only one (e.g., courses of action). However,\n©2009 AI Access Foundation. All rights reserved.\nthere is a substantial body of work on the latter setting in which items might materialize jointly, and individual items are preferentially comparable.\nThis paper focuses on a somewhat different context for set-preference specification. First, we assume that the items from which our subsets are composed are structured, in the sense that some set of attributes is associated with them. For example, if the items are movies, these attributes could be the genre, language, year, director; if the “items” are politicians, the attributes could be the political views of the politicians on various topics, their party affiliation, their level of experience. Second, we require a generic preference specification, in the sense that it can be used with diverse collections of items. For example, if we are specifying guidelines for the composition of some committee, these guidelines are generic, and can be used to induce a preference relation over subsets of any given set of politicians, provided that the set of attributes is fixed. Third, we do not assume any preferential ordering over the individual items, although that can certainly be captured by one of the attributes describing the items.\nAn instructive example of the type of domain we have in mind is that of personalized online newspapers. First, the problem of selection for a newspaper is one of subset selection – we have to select a subset of the set of available articles to place in the newspaper. Second, the database of articles is constantly changing. Therefore, an approach that requires explicitly specifying preferences for the inclusion of each specific item is inappropriate, both because the number of such items is very large, and because this would require us to constantly change the preference specification as the set of items changes. Finally, we would not want to base our approach on a method for transforming an ordering over items into an ordering over subsets of items, because we do not want to have to rank each item, and because there are obvious instances of complementarity and substitutability. For instance, even if I prefer articles on Britney Spears to articles on any other topic, two very similar articles about her may be less interesting than a set comprising one about her and one about the Spice Girls.1\nOne recent work that considers a similar setting is that of desJardins andWagstaff (2005), which works by specifying preferences over more abstract properties of sets. In particular, desJardins and Wagstaff offer a formalism for preference specification in which users can specify their preferences about the set of values each attribute attains within the selected set of items. One could assert whether the values attained by an attribute on the selected subset should be diverse or concentrated around some specific value. In addition, desJardins and Wagstaff also suggest a heuristic search algorithm for finding good, though not necessarily optimal, such sets of items.\nIn this work, we present a more general, two-tiered approach for dealing with set preferences in the above setting. This approach combines a language for specifying certain types of set properties, and an arbitrary preference specification language for expressing preferences over single, attributed items. The basic idea is to first specify the set properties we care about, and then specify preferences over the values of these properties. Such a specification induces a preference ordering over sets based on the values these sets provide to the properties of interest. We believe that the suggested approach is both intuitive and powerful. Although in this paper we focus on a particular set of properties for which we have devised a relatively efficient optimization algorithm, in its most general form, this two-tiered approach generalizes the approach of desJardins and Wagstaff (2005) because diversity and specificity are just two set properties. In principle, one can express both more general\n1. We realize that common rules of rationality may not apply to users with such preferences.\nproperties referring to multiple attributes, as well as more general conditional preferences over the values of these properties.\nEssentially, our approach re-states the problem of specifying preferences over sets in terms used to specify preferences over single items. In our formulation, “items” stand for the possible sets, and attributes of such “items” are their (user-defined) set-property values. Thus, in principle, this approach allows us to re-use any formalism for specifying preferences over single items. In this paper we will consider two specific instantiations of such a formalism: qualitative preferences based on CP or TCP-nets (Boutilier, Brafman, Domshlak, Hoos, & Poole, 2004; Brafman, Domshlak, & Shimony, 2006a), and quantitative preferences represented as generalized additively independent (GAI) value functions (Bacchus & Grove, 1995; Fishburn, 1969). The algorithm we suggest for computing an optimal subset given qualitative preferences is based on a similar optimization algorithm for TCP-nets. But because the number of “items” in our case is very large, this algorithm is modified substantially to exploit the special structure of these “items”. These modifications enable us to compute an optimal subset faster."
    }, {
      "heading" : "2. Specifying Set Preferences",
      "text" : "The formalism we use for set-preference specification makes one fundamental assumption: the items from which sets of interest are built are described in terms of some attributes, and the values of these attributes are what distinguishes different items. We shall use S to denote the set of individual items, and X to denote the set of attributes describing these items. For example, imagine that the “items” in question are US senate members, and the attributes and their values are: Party affiliation (Republican, Democrat), Views (liberal, conservative, ultra conservative), and Experience (experienced, inexperienced)."
    }, {
      "heading" : "2.1 From Properties of Items to Properties of Item Sets",
      "text" : "Given the set X of item-describing attributes, first, we can already talk about more complex item properties, e.g., “senate members with liberal views”, or “inexperienced, conservative senate members”. More formally, let X be the union of the attribute domains, that is,\nX = {X = x | X ∈ X , x ∈ Dom(X)} ,\nand let LX be the propositional language defined over X with the usual logical operators. LX provides us with a language for describing complex properties of individual items. Since items in S can be viewed as models of LX , we can write o |= ϕ whenever o ∈ S and o is an item that satisfies the property ϕ ∈ LX .\nGiven the language LX , we can now specify arbitrary properties of item sets based on the attribute values of items in a set, such as the property of having at least two Democrats, or having more Democrats than Republicans. More generally, given any item property ϕ ∈ LX , we can talk about the number of items in a set that have property ϕ, which we denote by |ϕ|(S), that is, |ϕ|(S) = |{o ∈ S|o |= ϕ}|. Often the set S is implicitly defined, and we simply write |ϕ|. Thus, |Experience=experienced|(S) is the number of experienced members in S. Often, we simply abbreviate this as |experienced|.\nWhile |ϕ|(·) is an integer-valued property of sets, we can also specify boolean set properties as follows: 〈|ϕ| REL k〉, where ϕ ∈ LX , REL is a relational operator over integers, and k ∈ Z∗ is a\nnon-negative integer. This property is satisfied by a set S if |{o ∈ S|o |= ϕ}| REL k. In our running example we use the following three set properties:\n• P1 : 〈|Party affiliation = Republican ∨ Political view = conservative| ≥ 2〉\n• P2 : 〈|Experience = experienced| ≥ 2〉\n• P3 : 〈|Political view = liberal| ≥ 1〉\nP1 is satisfied (only) by sets with at least two members that are either Republican or conservative. P2 is satisfied by sets with at least 2 experienced members. P3 is satisfied by sets with at least one liberal.\nWe can also write 〈|ϕ| REL |ψ|〉, with a similar interpretation. For example, 〈|Republican| > |Democrat|〉 holds for sets containing more Republicans than Democrats. An even more general language could include arithmetic operators (e.g., require twice as many Republicans as Democrats) and aggregate functions (e.g., the average number of years on the job). All these are instances of the general notion of specifying properties of sets as a function of the attribute values of the set’s members. In this paper, we focus on the above language with the relational operators restricted to equalities and inequalities. We do so because having a clear, concrete setting eases the presentation, and because restricting the language allows us to provide more efficient subset-selection algorithms. Indeed, many of the ideas we present here apply to more general languages. In particular, this generality holds both for the overall preference-specification methodology, and for the search-overCSPs technique for computing optimal subsets introduced later in the paper. However, the more specific techniques we use to implement these ideas, such as bounds generation, and the specific translation of properties into CSPs, rely heavily on the use of specific, more restrictive languages.\nFinally, we note an important property of our preference specification approach of being independent of the actual set of items available at the moment. This generality is important for many applications where the same reasoning about set preferences must be performed on different, and often initially unknown sets of items. For example, this is the case with specifying guidelines for selecting articles for an online newspaper, or for selecting a set of k results for an information query."
    }, {
      "heading" : "2.2 Reasoning with Set Preferences",
      "text" : "Once we have specified the set properties of interest, we can define preferences over the values of these properties using any preference specification formalism. Here we discuss two specific formalisms, namely TCP-nets (Brafman et al., 2006a), an extension of CP-nets (Boutilier et al., 2004), and Generalized Additively Independent (GAI)-value functions (Bacchus & Grove, 1995; Fishburn, 1969). The former is a formalism for purely qualitative preference specification, yielding a partial preference order over the objects of interest. The latter is a quantitative specification formalism that can represent any value function.\nLet P = {P1, . . . , Pk} be some collection of set properties. A TCP-net over P captures statements of the following two types:\n(1) Conditional Value Preference Statements. “If Pi1 = pi1 ∧ · · · ∧ Pij = pij then Pl = pl is preferred to Pl = p′l.” That is, when Pi1 , . . . , Pij have a certain value, we prefer one value for Pl to another value for Pl.\n(2) Relative Importance Statements. “If Pi1 = pi1 ∧ · · · ∧Pij = pij then Pl is more important than Pm.” That is, when Pi1 , . . . , Pij have a certain value, we prefer a better value for Pl even if we have to compromise on the value of Pm.\nEach such statement allows us to compare between certain pairs of item sets as follows:\n- The statement “if Pi1 = pi1 ∧ · · · ∧ Pij = pij then Pl = pl is preferred to Pl = p′l” implies that given any two sets S, S′ for which (1) Pi1 = pi1 ∧ · · · ∧ Pij = pij holds, (2) S satisfies Pl = pl and S′ satisfies Pl = p′l, and (3) S and S\n′ have identical values on all properties except Pl, we have that S is preferred to S′.\n- The statement “if Pi1 = pi1 ∧ · · · ∧ Pij = pij then Pl is more important than Pm” implies that given any two sets S, S′ for which (1) Pi1 = pi1 ∧· · ·∧Pij = pij holds, (2) S has a more preferred value for Pl, and (3) S and S′ have identical values on all attributes except Pl and Pm, we have that S is preferred to S′. (Notice that we do not care about the value of Pm if Pl is improved.)\nWe refer the reader to the work of Brafman et al. (2006a) for more details on TCP-nets, their graphical structure, their consistency, etc. The algorithms in this paper, when used with TCP-nets, assume an acyclic TCP-net Brafman et al.. The latter property ensures both consistency of the provided preferences, as well as existence of certain “good” orderings of P with respect to the TCP-net.\nAs an example, consider the following preferences of the president for forming a committee. He prefers at least two members that are either Republican or conservative, that is, he prefers P1 to P1 unconditionally. (Depending on the context, we use P to denote both the property P and the value P = true. We use P to denote P = false.) If P1 holds, he prefers P2 over P2 (that is, at least two experienced members), so that the committee recommendations carry more weight. If P1 holds, he prefers P2 to P2 (that is, all but one are inexperienced) so that it would be easier to influence their decision. The president unconditionally prefers to have at least one liberal, that is, he prefers P3 to P3, so as to give the appearance of balance. However, P3 is less important than both P1 and P2. There is an additional “external” constraint (or possibly a preference) that the total number of members be three.2\nGAI value functions map the elements of interest (item sets in our case) into real values quantifying the relative desirability of these elements. Structure-wise, GAI value functions have the form U(S) = ∑ i=1,...,n Ui(Pi(S)), where each Pi ⊂ P is a subset of properties. For example, the President’s preferences imply the following GAI structure: U(S) = U1(P1(S), P2(S)) + U2(P3(S)) because the President’s conditional preferences over P2’s value tie P1 and P2 together, but are independent of P3’s value. U1 would capture the weight of this conditional preference, combined with the absolute preference for P1’s value. U2 would represent the value of property P3. We might quantify these preferences as follows: U1(P1, P2) = 10, U1(P1, P2) = 8, U1(P1, P2) = 2, U1(P1, P2) = 5; while U2(P3) = 1, U2(P3) = 0. Of course, infinitely many other quantifications are possible.\n2. Some external constraints, such as this cardinality constraint, can be modeled as a preference with high value/importance. In fact, this is how we model cardinality constraints in our implementation."
    }, {
      "heading" : "3. Finding an Optimal Subset",
      "text" : "In general, given a preference specification and a set S of available items, our goal is to find an optimal subset Sopt ⊆ S with respect to the preference specification. That is, for any other set S′ ⊆ S, we have that the properties Sopt satisfies are no less desirable than the properties S′ satisfies. We now consider two classes of algorithms for finding such an optimal subset. These two classes of algorithm differ in the space in which they search. In the next section, we describe a comparative empirical evaluation of these algorithms. For our running example we use the following set of available items S:\no1 Republican conservative inexperienced o2 Republican ultra conservative experienced o3 Democrat conservative experienced o4 Democrat liberal experienced"
    }, {
      "heading" : "3.1 Searching in Sets Space",
      "text" : "The most obvious approach for generating an optimal subset is to search directly in the space of subsets. A priori this approach is not too attractive, and indeed, we shall see later that our implementation of this approach did not scale up. However, given that often we are interested in sets of small size and that heuristics can be used to enhance search quality, we thought it is worth exploring this approach.\nA branch-and-bound (B&B) algorithm in the space of sets is depicted in Figure 1. For each set S, the algorithm assumes access to an upper bound UB(S) and to a lower bound LB(S) estimates on the maximal value of a superset of S. The algorithm maintains a queue Q of sets, and this queue is initialized to contain only the empty set. At each step, the algorithm selects a highest upper-bound set S from the queue. Next, the algorithm removes from Q all sets S′ with upper bound UB(S′) being at most as good as the lower bound LB(S) of the selected set S, and adds toQ all the minimal (that is, one-item) extensions of S. The latter sets correspond to the successors of S in the search space. Different implementations of the algorithm differ in how they sort the queue. The best-first version depicted in the pseudo-code sorts the queue according to a heuristic value of the set, and in\nour case this heuristic is an upper bound on the value of the set’s supersets. In contrast, the depthfirst version always positions the children of the newly expanded node at the front of the queue. We implemented and tested both versions.\nThe method used to generate bounds for a set S must depend on the actual preference representation formalism, as well as on the type of set properties being used, and the idea is more natural given a quantitative value function. For a lower bound LB(S) we can use the actual value Value(S) of S. Note that it is possible that all descendants of S will have lower values because, in general, set-properties may not be monotonic (e.g., “average value higher than 5.”) However, since S itself is a possible solution, this is a valid lower bound.\nFor an upper bound, we proceed as follows: First, we consider which set-property values are consistent with S. That is, for each set property, we examine what values S and any of its supersets can potentially provide to that property. For example, consider P2 and suppose S contains a single experienced member. So currently, P2 holds. However, we can satisfy P2 if we add one more experienced member. Thus, both values of P2 are consistent with S. In contrast, if we had two experienced members in S, then P2 is inconsistent with S because no matter who we add to S, we can never satisfy P2. Next, given such sets of possible set-properties’ values with respect to the set S, we can bound the value of S and of any of its supersets by maximizing values locally. Specifically, in a GAI value function, we can look at each local function Ui, and consider which assignment to it, from among the consistent values, would maximize Ui. Clearly, this may result in an overall value overestimation, since we do not know whether these “locally optimizing” joint assignments are consistent. Similar ideas can be used with other quantitative representations, as in various soft-constraint formalisms (Bistarelli, Fargier, Montanari, Rossi, Schiex, & Verfaillie, 1999).\nConsider our running example with the GAI value function as at the end of Section 2, and consider searching for an optimal subset of S = {o1, o2, o3, o4} using a depth-first version of B&B. We start with the empty set, and the property values provided by the empty set are P1, P2, P3. Thus, the lower bound LB(∅), which is the value of the empty-set, is 5. For the upper bound UB(∅), we consider the best property values that are individually consistent with the extensions of ∅, which are P1, P2, P3, and their accumulative value is 11. Sopt is also initialized to the empty set, and next we generate all of the children of the (only possible) selected set ∅, which are all singleton sets: {o1}, {o2}, {o3}, {o4}. Except for {o4}, they all have lower and upper bounds identical to those of the empty set, and are inserted into the queue. {o4} has a lower bound of 6 and the upper bound is 11. Suppose {o1} is the first queue element, and we select it for expansion. This results in adding {o1, o2}, {o1, o3}, {o1, o4} into the queue, and the lower and upper bounds of these sets are (8, 11), (8, 11), (6, 11), respectively. Next, the set {o1, o2} is examined with respect to the current Sopt = ∅, and Sopt is assigned to {o1, o2}. Since we assumed here a depth-first version of B&B we proceed with expanding {o1, o2}, obtaining {o1, o2, o3}, {o1, o2, o4} with lower and upper bounds being, respectively, (10, 11) and (11, 11). With a lower bound of 11 for {o1, o2, o4} we can prune away all the rest of the nodes in the queue, and we are done.\nAn important issue for depth-first B&B is the order in which sets are generated. In our implementation, at each node in the search space, the items in S are ordered according to the sum of the value of the properties they can help satisfy. For example, initially, a conservative member such as o1 could help us satisfy P1.\nIn contrast to quantitative preference representation formalisms, qualitative preferences typically induce a partial ordering over property collections. In this case, it is harder to generate strict\nupper and lower bounds – as they must be comparable to any possible solution. One way to handle this is to linearize the ordering and require the stronger property of optimality with respect to the resulting total order. Here, TCP-nets present themselves as a good choice because there is an efficient and simple way of generating a value function consistent with an acyclic TCP-net (Brafman & Domshlak, 2008). This value function retains the structure of the original network which is important to make the bounds computation efficient (notably, each Ui depends on a small number of property values)."
    }, {
      "heading" : "3.2 Searching over CSPs",
      "text" : "The attractiveness of the item subsets is evaluated in terms of a fixed collection of set-properties P , and thus different sets that provide all identical property values are equivalent from our perspective. The immediate conclusion is that considering separately such preferentially equivalent subsets of available items S is redundant. To remove this redundancy, we suggest an alternative method in which we search directly over set-property value combinations. Of course, the problem is that given a set-property value combination, it is not obvious whether we can find an actual subset of S that has such a combination of properties. To answer this question, we generate a CSP that is satisfiable if and only if there exists a subset of S with the considered set-property values. The overall search procedure schematically works as follows.\n1. Systematically generate combinations of set-property values.\n2. For each such combination, search for a subset of S providing that combination of setproperty values.\n3. Output a subset of S satisfying an optimal (achievable) combination of set-property values.\nTo make this approach as efficient as possible, we have to do two things, namely:\n(1) Find a way to prune sub-optimal set-property value combinations as early as possible.\n(2) Given a set-property value combination, quickly determine whether a subset of S satisfies this combination.\nConsidering the first task, let P1, . . . , Pk be an ordering of the set-properties P .3 Given such an ordering of P , we incrementally generate a tree of property combinations. The root of that tree corresponds to an empty assignment to P . For each node n corresponding to a partial assignment P1 = p1, . . . , Pj = pj , and for every possible value pj+1 of the property Pj+1, the tree contains a child of n corresponding to the partial assignment P1 = p1, . . . , Pj = pj , Pj+1 = pj+1. The tree leaves correspond to (all) complete assignments to P . Such a tree for our running example is depicted in Figure 2. Note that, implicitly, each node in this tree is associated with a (possibly empty) set of subsets of S, notably, the subsets that provide the set-property value combination associated with that node.\nIn our search for an optimal set, we expand this tree of set-property value combinations while trying to expand as few tree nodes as possible by pruning certain value combinations of P as either\n3. Throughout this paper, we will assume that in preference specifications using TCP nets, there are only conditional preference (CP) arcs, and importance arcs, but no conditional importance (CI) arcs. While our scheme and implementations allow these arcs, CI arcs force the ordering of the set properties to be dynamic, as it may depend on value assignments to previous properties. For clarity of exposition, we thus preferred not to present these technical details.\nsub-optimal with respect to set preferences, or unsatisfiable with respect to S. A standard way to do this is, again, by using a branch-and-bound search procedure, and this requires from us to derive effective upper and lower bounds on the value of the best subset satisfying a partial value combination for P . In addition, the order we associate with properties and their values affects our pruning ability throughout the search process. To get the most leverage out of our bounds, we would like to explore the children of a node in the decreasing order of their purported attractiveness. Moreover, when fixing the ordering of the set-properties themselves, we would like properties that can potentially contribute more to appear earlier in this ordering. For instance, P1’s value in our running example has a greater influence on the overall attractiveness of a subset than the value of P2, and thus P1 should better be branched on first. In addition, P1 is preferred to be true, and thus the subtree corresponding to P1 = true should better be explored first. Similarly, P2 is preferred to be true when P1 = true, and preferred to be false, otherwise. This ordering is reflected in the tree in Figure 2, for a left to right pre-order traversal of the tree.\nNow, let us consider the second task of determining whether a subset of S satisfies a given setproperty value combination. Given such a partial assignment α to P , we set up the following CSP. First, the CSP has a boolean variable xi for every available item oi ∈ S. In our example, the CSP contains the variables x1, . . . , x4 for items o1, . . . , o4 respectively. Intuitively, xi = 1 encodes oi being a part of our (searched for) subset of S, whereas xi = 0 means that oi is not in that subset. Next, we translate every set-property value in α into a certain constraint on these variables. For instance, if α[P1] = true, the constraint C1 : x1 + x2 + x3 ≥ 2 is added to the CSP. Note that C1 explicitly encodes the requirement (of P1 = true) for the subset to have at least two of the elements that satisfy Republican ∨ conservative. That is because {o1, o2, o3} are all the candidates in S that are either Republican or conservative. Alternately, if α[P1] = false, then the constraint C1 : x1 + x2 + x3 < 2 is added to the CSP. Finally, if α does not specify a value for P1, then no constraints related to P1 should be added at all. Likewise, for α[P2] = true and α[P3] = true we would add the constraints C2 : x2 + x3 + x4 ≥ 2 and C3 : x4 ≥ 1, respectively. In general, it is not hard to verify that the CSP constructed this way for a concrete item set S and a set-property value combination α is solvable if and only if S has a subset satisfying α. Moreover, if this CSP is solvable, then any of its solutions explicitly provides us with such a subset of S.\nIt is worth briefly pointing out the difference between the CSPs we generate here and the more typical CSPs usually discussed in the literature. Most work on general CSPs deals with constraints\nover small, typically just two-variable, subsets of problem variables. In contrast, the constraints in the CSPs generated in our optimization process are global, with each constraint being possibly defined over all the CSP variables. Yet another special property of CSPs constructed for our purposes is that there is a sense in which it is meaningful to talk about partial assignments in our context—unassigned variables can always be regarded de facto as if assigned the value “0” since the corresponding items, by default, do not belong to the subset we search for.\nBecause partial assignments to set-properties P map to CSPs, each node in our tree of setproperty value combinations maps to a CSP, and the entire tree can be viewed as a tree of CSPs. The important property of this tree-of-CSPs is that the children of each CSP node are CSPs obtained by adding one additional constraint to the parent CSP, notably the constraint corresponding to the additional property value that we want the set to satisfy. This implies that if some CSP node in the tree is unsatisfiable, then all of its descendants are unsatisfiable as well. In fact, we can make a stronger use of the nature of this search tree, recognizing that we can reuse the work done on a parent node to speed up the solution of its children. To see the latter, consider some CSP C in our tree-of-CSPs, some child CSP C ′ of C , and let S ⊆ S be a solution to C . As C ′ extends C with a constraint C, any subset S′ ⊆ S ruled out by C will be also ruled out by C ′. Hence, if solving C and C ′ considers subsets of S in the same order (that is, by using the same ordering over set elements), then solving C ′ can start from the leaf node corresponding to S, the solution generated for C . Moreover, if a constraint C represents a boolean set property, and S is not a solution to C ′ = C ∪ {C}, then S has to be a solution to C ∪ {¬C}, which is the sibling of C ′. Using these ideas, we share the work done on different CSP nodes of our tree-of-CSPs. In fact, when all set properties are boolean, this approach needs to backtrack over each property at most once (we call this property “limited backtracking”), thereby considerably improving the empirical performance of the algorithm.\nThe overall branch-and-bound algorithm in the space of CSPs is depicted in Figure 3. As is, the algorithm is formulated for the case of quantitative preference formalisms. The formulation of the algorithm for the qualitative case is essentially the same, with minor technical differences and an important computational property. For CP/TCP-nets, we can guarantee that only limited backtracking is required if we follow the following guidelines. First, we must order the variables (line 1) in an order consistent with the topology of the network. Note that for TCP-nets, this ordering may be conditional, that is, the order of two variables may vary depending on the value of some of the earlier variables. Second, in line 2, the property values must be (possibly partially) ordered from best to worst, given the values of the parent properties (which must be and will be instantiated earlier). In that case, the first satisfiable set of properties constitutes an optimal choice (Brafman et al., 2006a). Assuming we solve intermediate nodes in the tree-of-CSPs, we know that we should backtrack at most once in each level assuming boolean set-properties, but, again, more backtracks may occur with integer-valued properties.\nThe node data structure used by the algorithm has two attributes. For a search node n,\n• n.α captures a partial assignment to the set-properties P associated with the node n, and\n• n.S captures a subset of S satisfying n.α if such exists, and otherwise has the value false.\nThe functions Value, LB, and UB have the same semantics as in the subset-space search algorithm in Figure 1. In the pseudocode we assume a fixed ordering over set-property values (line 2), but one can vary it depending on earlier values (and we exploit that in our implementation). Finally, the\n1: Fix an ordering over set-properties P 2: Fix an ordering over the values of each set property P ∈ P 3: Fix an ordering over all available items S 4: Q ← {n[∅; ∅]} 5: Sopt ← ∅ 6: while Q is not empty do 7: n← pop(Q) 8: construct-and-solve-csp(n) 9: if n.S 6= false and UB(n.S) > Value(Sopt) then 10: if Value(n.S) > Value(Sopt) then 11: Sopt ← n.S 12: end if 13: Let P be the highest-ordered set property unassigned by n.α 14: for each possible value p of P do 15: n′ ← [n.α ∪ {P = p};n.S] 16: Q ← Q∪ {n′} . The position of n′ inQ depends on the search strategy 17: end for 18: end if 19: end while 20: return Sopt\nFigure 3: CSP-space branch-and-bound search for an optimal subset of available items S.\npseudo-code leaves open the choice of search strategy for used by the branch-and-bound, and this choice is fully captured by the queue insertion strategy in line 16.\nTo illustrate the flow of the algorithm, let us consider again our running example. Recall that the example already has a requirement for the discovered subset to be of size 3, and this translates into a constraint C : x1 + x2 + x3 + x4 = 3. The first CSP we consider has {C,C1} as its only constraints. Assume the CSP variables are ordered as {x1, x2, x3, x4}, with value 1 preceding value 0 for all xi. In that case, the first solution we find is S1 : x1 = 1, x2 = 1, x3 = 1, x4 = 0. Our next CSP adds the constraint C2. When solving this CSP, we continue to search (using the same order on the xi’s and their values) from the current solution S1, which turns out to satisfy C2 as well. Thus, virtually no effort is required to solve this CSP. Next, we want to also satisfy C3. This set of constraints corresponds to a leaf node in the tree-of-CSPs which corresponds to the complete assignment P1P2P3 to the set-properties. Our current item set Sopt = S1 does not have a liberal, so we have to continue to the assignment S2 : x1 = 1, x2 = 1, x3 = 0, x4 = 1 (requiring us to backtrack in the CSP-solution space over the assignments to x4 and x3). We now have a set that satisfies the properties in the leftmost leaf node in our tree-of-CSPs. If we can prove that this setproperty value combination is optimal using our upper/lower bounds, we are done. Otherwise, we need to explore additional nodes in our tree-of-CSPs. In the latter case, the next CSP will correspond to P1, P2, P3, with constraints {C,C1, C2, C3}. However, we already have a solution to this node, and it is exactly S1. To see that, note that S1 was a solution to the parent of our current CSP, but it was not a solution to its sibling {C,C1, C2, C3}. Hence, since P3 is a boolean property, S1 must satisfy {C,C1, C2, C3}."
    }, {
      "heading" : "3.3 Solving the underlying CSPs",
      "text" : "Our algorithm for solving the intermediate CSPs is based on the well known backtrack-search algorithm, first presented by Prosser (1993) in a simple iterative form. At the same time, we have adapted both the algorithm and some well known enhancements in CSP solving (such as NoGood recording and forward checking (FC)) to the specifics of the CSPs in our setting.\nInitially, variables and their values are statically ordered from the most to least constrained (although we also discuss a few experiments performed with dynamic variable/value ordering). Our motivation for static ordering is two-fold. First, because the constraints are very much global, we can do the ordering at a preprocessing stage. Second, as discussed in the previous section, static ordering allows us to better utilize solutions of CSPs when solving descendent CSPs.\nThe basic backtrack algorithm, which on its own, unsurpisingly performs quite poorly in our setting, is refined by utilizing the following observations and techniques.\n• Monotonicity of improving constraints. If the operator of the constraint is “=” and there are more items having the constrained property already in the current partial solution, then one cannot satisfy the constraint by making additional assignments. The same property holds for the constraint operators “< ” and “≤”. Using this observation, it is possible to detect the need to backtrack early on in the search.\n• Forward Checking. A certain type of “forward checking” can be performed for our constraints. Clearly, if satisfying some constraint requires at least k items to be added to the subset, and the number of remaining items that satisfy the desired property is less than k, then the search algorithm must backtrack.\n• “Can/Must” strategy. The “can/must” strategy corresponds to a more advanced check of the interactions between the constraints. The idea is quite simple: if (i) at least p items must be added to the constructed subset to satisfy the constraint Ci, (ii) at most q items can be added to the constructed subset without violating another constraint Cj , (iii) all the items that can be added and have the property constrained by Ci also have the property constrained by Cj , and, finally, (iv) p > q, then both Ci and Cj cannot be satisfied simultaneously. Moreover, no further assignments to yet unassigned variables can resolve this conflict, and thus the situation is a dead end. This kind of reasoning allows discovery of such barren nodes quite early in the search, pruning large portions of the search tree. To reason correctly about the “can/must” strategy, we have to maintain a data structure of unique items for each pair of constraints, as well as to keep track of the number of remaining items that influence property constrained by Ci and do not influence properties constrained by Cj .\nAs an example, assume we are in the middle of the search and we have two set properties: SP1 : |A1 = a| ≥ 5 and SP2 : |A2 = b| ≤ 3. Suppose that we have already picked 3 items that influence SP1 and 2 items that influence SP2. As a result, to satisfy SP1, we must add at least another two items that influence it and to satisfy SP2 we can add at most one item that influences SP2. If all the items that we can choose from {ok...on} have a value “a” for the attribute A1 and value “b” for the attribute A2, then obviously we cannot satisfy both SP1 and SP2 within this setting, and thus we should backtrack.\nFinally, below we discuss recording NoGoods, an improvement of the basic backtracking algorithm that proved to have the most impact in our setting."
    }, {
      "heading" : "3.3.1 NOGOOD RECORDING",
      "text" : "The standard definition of a NoGood in the CSP literature is that of a partial assignment that cannot be extended into a full solution of the problem. Once we learn a NoGood, we can use it to prune certain paths in the search tree. The smaller the NoGood, the more occasions we can use it, the greater its pruning power. Thus, it is of interest to recognize minimal NoGoods, and different techniques have been developed to perform NoGood resolution in order to produce the best and most general NoGoods possible (see, e.g., Dechter, 1990; Schiex & Verfaillie, 1993; Dago & Verfaillie, 1996).\nAs noted earlier, the CSPs we generate differ significantly from the more typical binary CSPs. Consequently, the NoGood recording algorithm has to be adapted accordingly. In particular, because our constraints are global, it makes sense to try generating NoGoods that are global, too. Thus, instead of recording assignments to variables, we record the influence of the current assignment on the constraints. Every variable influences a set of constraints.4 Thus, as a NoGood, we store the influence the set selected so far has on all the constraints. Specifically, suppose we have generated the set S1, and recognized that it is not extensible into a set satisfying the constraints. (This immediately follows from the fact that we backtracked over this set.) We now generate a NoGood N that records for each property associated with each constraint, how many items satisfying that property occur in S1. Now, suppose we encounter a different set S2 that has the same effect N on the constraints. If there are fewer options to extend S2 than there are to extend S1, we know that S2, as well, cannot be extended into a solution. However, if there are more options to extend S2 than S1, we cannot conclude that S2 is a NoGood at this point. In order to better quantify the options that were available to extend S1 we record, beyond the actual NoGood N , the level (depth) in the assignment tree at which it was generated. Given that the CSP solver uses a static variable ordering, we know that if we encounter a set S that generates the same properties as the NoGood N , at a level no higher than that of S1, we can safely prune its extensions. The reason for that is, there are no additional extension options available for S than there were for S1.\nThe correctness of the NoGood recording mechanism proposed here depends on having a static variable ordering, as well as a specific value ordering for all the variables in the CSP, namely, 〈1, 0〉. To show correctness, we should note that a NoGood can be used only after it is recorded. Consequently, any node using a NoGood would be to the right in the search tree of a node the NoGood was recorded at. Here we would like to stress again that, since the constraints are global, it does not matter which items are added to the subset, but rather what influence these items had on the constraints. Any two sets having exactly the same influence on the constraints are identical with respect to the optimization process."
    }, {
      "heading" : "3.3.2 SEARCH ALGORITHM",
      "text" : "The procedure depicted in Figure 4 extends the basic backtrack algorithm by a subroutine CANIMPROVE which can be altered to include any combination of the in-depth checks discussed earlier, to utilize early conflict detection techniques, including the NoGoods check. Also added is a call to the ADDNOGOOD subroutine for recording NoGoods while backtracking. P and n, the generated instance of a CSP problem with variables indexed from 1 to |S| and the node in the tree-space search\n4. We assume without loss of generality that every item in the set of available items influences at least one constraint in the constraint set C , since items that influence no constraint can be safely eliminated.\nrespectively, are the inputs to the procedure. The algorithm systematically tries to assign values to the problem variables, backtracking and recording NoGoods when facing a dead end."
    }, {
      "heading" : "4. Experimental Results",
      "text" : "We evaluate the different algorithms using a subset of the movie database publicly available from imdb.com. We simulated a scenario of selecting movies for a three-day film festival according to organizers preferences. Three models of growing complexity have been engineered to reflect the preferences of the organizers; these models are defined in terms of 5, 9, and 14 set-properties, respectively. In addition, the total number of films is constrained to be 5 (which we actually modeled using a very strong preference). Figure 5 depicts the list P14 of the 14 properties and their alterations; P5 and P9 consist of the corresponding prefixes (SP1 through SP5, and SP1 through SP9, respectively) of P14. To produce even more complex problem instances that cause many backtracks in the space of set-property assignments we slightly altered the 14-properties model, creating two additional models that are denoted henceforth as P ′14 and P ′′14."
    }, {
      "heading" : "4.1 Preference Specification",
      "text" : "Figure 6 provides a verbal description of qualitative preferences for the film festival program which we used in our experiments. Figure 7 depicts a TCP-net that encodes these preferences in terms of the more concrete set-properties listed in Figure 5. For the experiments with GAI value functions, these preferences were quantified by compiling this TCP-net into a GAI value function that orders the items consistently with that TCP-net (Brafman & Domshlak, 2008). The task in our empirical evaluation was to find an optimal subset of a set of available movies S ∈ {S400,S1000,S1600,S3089}, where Si corresponds to a set of i movies, and that with respect to each of the five models of preferences over sets. All the experiments were conducted using Pentium 3.4 GHz processor with 2GB memory running Java 1.5 under Windows XP Professional. The runtimes reported in the tables below are all in seconds, with “–” indicating process incompletion after four hours.\nFirst, our initial experiments quickly showed that the search in the space of subsets (Table 1) does not scale up. With just over 20 elements, it did not converge to an optimal solution within an hour, even when the preference specification involved only 5 set-properties. This outcome holds for all combinations of qualitative and quantitative preference specifications, depth-first and best-first schemes of branch-and-bound, and queue ordering based on set’s upper bound, lower bound, and\nweighted combinations of both. Table 1 provides a snapshot of the corresponding results for a TCPnet specified over nine set properties. The table describes the total number of subsets generated until an optimal subset was found (see the column “Subset until Sopt”), the total number of subsets generated until the optimal subset was recognized as optimal (under “Subsets generated”). DFS appears to be much more effective than BFS, but the branching factor of larger databases overwhelms this approach. Also, it may be thought that with larger databases it should be easier to quickly generate good sets, but we found that for moderately larger (e.g,. 25+) and much larger (e.g., 3000) datasets, this approach is too slow. Various improvements may be possible, but given the much better performance of the other approach discussed later, they are unlikely to make a difference.\nNext, we consider the CSP-space branch-and-bound search. In particular, here we compared between the two variants of this approach that use dynamic and static variable and value orderings. In what follows, these two variants are denoted as BB-D and BB-S, respectively. While static variable/value orderings are usually considered to be a weaker approach to CSP solving, earlier we have shown that, in our domain, static ordering allows for certain optimizations that have a potential to improve the efficiency of the overall problem solving. In particular, static variable ordering allows to record global NoGoods as described in Section 3.3.1; the results for algorithms that record NoGoods are denoted by a name suffix “+ng”. In addition, we have tried to share\ninformation between consecutive CSP problem instances while doing the search in the tree of CSPs; the algorithms adopting this technique are denoted by a name suffix “+inc”.\nTable 2 depicts the results of the evaluation of all variants of the CSP-space branch-and-bound search algorithm (Figure 3). First, the table shows that the overhead of maintaining NoGoods does not pay off for the simple preference specifications. However, for the more complex problems requiring more intense CSP solving, the use of NoGood recording proved to be very useful, letting us\nsolve previously unsolvable instances. Next, the reader may notice from the table that, at least for the problems used in our tests, the contribution of the incremental approach is not substantial. For instance, NoGood recording by itself seems to contribute much more to the efficiency of the optimization process. Moreover, for the more complex problems, switching to the incremental version sometimes even leads to performance degradation. It appears that the overhead of maintaining and copying the partial solution in these cases does not pay off.\nOur next set of experiments mirrored the first one, but now with GAI value functions instead of the purely qualitative TCP-nets. The GAI functions were obtained by properly quantifying the qualitative preferences used for the first tests. Table 3 provides a representative snapshots of the results. With value functions over set-properties P5 and P9 the basic branch-and-bound algorithm with static variable/value orderings performs and scales up (with growing set of alternatives S) quite well. With the more complex value functions over the larger set of properties P14 the performance significantly degrades, and even the incrementality-enhanced algorithm cannot solve problem instances with more than 1000 CSP variables. On the other hand, adding NoGoods recording proves to dramatically improve the performance, leading to solving even the largest problem instances.\nTables 2 and 3 suggest a qualitative difference in the performance of the CSP-space search with quantitative and qualitative preference representation models. There are good reasons to expect such behavior. First, compact qualitative models of preference may (and typically do) admit more than one optimal (that is, non-dominated) solution. That, in principle, makes finding one such optimal solution easier. Second, if the preferences are captured by a TCP-net, then there are variable orderings ensuring that the first solution found will be an optimal one. In contrast, with GAI value functions, after we generate an optimal solution, typically we still have to explore the search tree to prove that no better solution exists. In the worst case, we have to explore the entire tree of CSPs, forcing us to explore a number of CSPs that is exponential in |P|.\nIn summary, the first conclusion to be taken from our experiments is that subsets-space search fails to escape the trap of the large branching factor, while the stratified procedures for CSP-space search show a much higher potential. On the problems that require little backtracking in the space of CSPs, the latter procedures are actually very effective for both TCP-net and GAI function preference specification. Obviously, if the procedure is forced to explore many different CSPs, the performance unavoidably degrades. We note that, on larger databases, such backtracks often indicate an inherent conflict between desirable set-properties, and such conflicts might possibly be recognized and resolved off-line. In this work we do not investigate this issue, leaving it as an optional direction for future improvement.\nThe rather non-trivial example used in this section provides the reader also with the opportunity to assess the suitability of different preference specification languages. For example, although we\nused boolean-valued set properties, it may be argued that some of our natural-language preference statements would better be expressed using integer-valued set properties. Similarly, users may find that some other preference specification formalism, such as soft-constraints (Bistarelli et al., 1999), can more naturally capture these natural language preferences. This is an opportunity for us to reemphasize that while, for obvious reasons, we had to focus on a concrete choice of language, we believe that the two-tiered approach suggested here is far more general."
    }, {
      "heading" : "5. Complexity Analysis",
      "text" : "Though reasonable runtimes have been obtained by us empirically with search over CSPs, both algorithm classes described above have a worst-case exponential running time. This begs the question of whether the problem itself is computationally hard. Obviously, with external constraints, subset optimization is NP-hard. Below we show that even without external constraints, the problem typically remains NP-hard, even with significant restrictions on the problem.\nNaturally, the complexity of subset selection depends on the precise nature of the preference specification formalism used. Most of the results presented here assume TCP-net-based specification. Hardness results for this model immediately apply to the GAI model, based on an existing reduction (Brafman & Domshlak, 2008). In some cases, problems that are tractable under the TCPnet model become NP-hard when a GAI model is used, instead. Thus, unless stated otherwise, we assume henceforth that preferences over properties are specified by a TCP-net.\nIn analyzing the complexity of the problem we consider the following problem parameters:\n• n, the overall number of items in the data set.\n• a, the number of attributes of the items.\n• m, the number of set properties, i.e. number of nodes in the TCP-net.\n• k, maximal property formula size, defined as the number of logical connectives (and, or, not) in the formula.\n• d maximum attribute domain size, i.e. the maximum number of distinct values for each attribute.\n• µ, the number of times an attribute value can appear in the dataset."
    }, {
      "heading" : "5.1 NP-Hard Classes",
      "text" : "Theorem 1. When using TCP-based preferences over set properties, finding an optimal subset of a given set of items (POS) is NP-hard even if the items are described only in terms of binary-valued attributes, and all the set properties are atomic (that is, we have d = 2 and k = 0).\nProof. The proof is by a polynomial reduction from the well-known NP-hard Vertex Cover (VC) problem. Given a graph G = (V,E), a vertex cover of G is a vertex subset V ′ ⊆ V covering all the edges in the graph, that is, for every edge e ∈ E, there is a vertex v ∈ V ′ such that e is incident on v. The optimization version of VC corresponds to finding a minimal size vertex cover of G.\nGiven an VC problem instance G = (V,E), we construct a POS problem instance by specifying a TCP-net N and an item set S as follows. For each vertex v ∈ V we create an item o (denoted\nby ov), and thus we have |S| = |V | = n items. For each edge e ∈ E we define an attribute X (denoted by Xe), and thus we have |X | = |E| = a attributes. All the attributes in X are defined to have a binary, {0, 1}, domain. For each item ov, the value of each attribute Xe is ov[Xe] = 1 if and only if e is incident on v in G. Next, for each edge e ∈ E, we define a binary set property Pe = 〈|Xe| > 0〉 that takes the value true if and only if at least one item in the selected subset provides the value 1 to the attributeXe. In addition, we define a single multi-valued empty set property SUM ≡ 〈||〉5. The domain of the SUM property is defined to be the integer-value range [0..n]. Note that, by construction, the properties utilize only one attribute per property, and thus no logical connectives, providing us with k = 0. The preferences over these set properties are\n1. For each binary property Pe, the preference is for the value true, that is, Pe Pe.\n2. For the empty property SUM we simply prefer smaller values, that is\n(SUM = 0) (SUM=1) (SUM=2) . . . (SUM=n)\nThe only edges in the TCP-net N , depicted in Figure 8, are the importance arcs from each Pe to SUM, meaning that we would rather have to temporize in the value of the SUM property than have any of the Pe being false.\nProposition 1 ensures that any optimal subset in the POS problem constructed as above always corresponds to a proper vertex cover of G.\nProposition 1. For any subset S of S that is undominated with respect to the constructed TCP-net N , and every edge e ∈ E, we have Pe(S) = true.\nProof. Given an undominated (with respect to N ) subset S ⊆ S, let Pe be a set property such that Pe(S) = false. By construction, there exists an item o ∈ S such that o[Xe] = 1. Considering S′ = S ∪ {o}, we have S′ being preferred to S with respect to N because (i) S and S′ provide exactly the same values to all the set properties except for Pe and SUM, (ii) S provides a preferred\n5. Since the formula ϕ inside this set property is degenerate, and in fact equivalent to 〈|true|〉, every item in the selection set will have to comply with it. This set property is the simplest implementation of a counter\nvalue to SUM while S′ provides a preferred value to Pe, and (iii) preferential improvement of Pe dominates that of SUM. Thus S′ dominates S, contradicting the assumption that S is undominated.\nLemma 1. For any subset S of S that is undominated with respect to the constructed TCP-net N , there exists a vertex cover VS of G with |VS | = |S|.\nProof. The proof is straightforward. Let VS = {v | ov ∈ S}. Because S is undominated with respect to N , from Proposition 1 we have Pe(S) = true for all binary “edge-related” properties Pe. In turn, Pe(S) = true implies that o[Xe] = 1 for at least one item o ∈ S. By the construction, o[Xe] = 1 if and only if vertex v covers edge e. Together with the mapping between the vertices V and items S being bijective, the latter implies |VS | = |S|.\nLemma 2. There exists a minimal vertex cover of G of size s if and only if there exists a subset S ⊆ S undominated with respect to N such that SUM(S) = s.\nProof. Let S be an undominated subset of S with |S| = s. By construction, we have Pe(S) = true for all binary set properties Pe, and SUM(S′) = s. By Lemma 1, there exists a vertex cover VS of G with |VS | = s. Suppose to the contrary that VS is not minimal, that is, there exists a vertex cover V ′ of G with |V ′| < s. Now, construct the subset S′ = {ov | v ∈ V ′}. Since the mapping between S and V is bijective, we have |S′| = |V ′| < s, and thus SUM(S′) < s. Likewise, by construction of our set properties and V ′ being a vertex cover, we have Pe(S) = true for all Pe. This, however, implies that S′ is preferred to S with respect to N , contradicting the statement that S is undominated.\nTheorem 1 now follows immediately from Lemma 2 and the fact that the reduction is clearly polynomial.\nTheorem 2. Given TCP-based preferences over set properties, finding an optimal subset of a given set of items (POS) is NP-hard even if the items are described in terms of a single attribute, all the set properties are binary-valued, each containing at most 2 logical connectives (that is, we have a = 1 and k = 2).\nProof. The proof is by a polynomial reduction from k-SAT, for any k ≥ 3. Given a k-SAT problem instance over propositional variables V and logical formula Φ, we construct a POS problem instance by specifying a TCP-net N and an item set S as follows. For each variable v ∈ V , construct an item ov and an item ov̄, and thus S contains an item for every possible literal in the formula. The value of the only attributeX is defined as follows: for each item ol, we have A(ol) = l (where l is a literal, either v or v̄, for all v ∈ V ). The binary set properties P for the TCP-net N are now defined as follows.\n• Properties ensuring that a variable assignment is legitimate. For each variable v ∈ V ,\nPv =〈|X = v ∨X = v̄| = 1〉,\nthat is, for any S ⊆ S, Pv(S) = true if and only if S contains exactly one of the items {ov, ov̄}.\n• Properties ensuring that Φ is satisfied. For each clause C = (l1 ∨ l2 ∨ l3 ∨ ...) ∈ Φ:\nPC =〈|X = l1 ∨X = l2 ∨X = l3 ∨ ...| ≥ 1〉\nthat is, for any S ⊆ S, PC(S) = true if and only if S contains at least one item corresponding to a literal in C.\nFinally, to complete the preference specification, we make all properties independent (that is, the TCP-net has no edges), and for each of the properties we prefer value true to value false.\nTo illustrate the above construction, consider a 3-SAT formula Φ = (x∨ y ∨ z)∧ (y)∧ (x∨ z). For this formula, the construction leads to\nitem X ox x\nox x̄ oy y oy ȳ oz z oz z̄\nSet properties: Px =〈|X = x ∨X = x| = 1〉 Py =〈|X = y ∨X = y| = 1〉 Pz =〈|X = z ∨X = z| = 1〉\nPC1 =〈|X = x ∨X = y ∨X = z| ≥ 1〉 PC2 =〈|X = y| ≥ 1〉 PC3 =〈|X = x ∨X = z| ≥ 1〉\nWe now show that finding an undominated subset of S with respect to N as above is equivalent to finding a satisfying assignment to Φ. Let S ⊆ S be undominated with respect toN . We can show that S provides value true to all set propositions Pv and PC (in this case we call S an ultimately preferred subset) if and only if Φ is satisfiable.\nFirst, let S be an ultimately preferred subset of S. Given such S, we can construct a mapping A : V 7→ {true, false} such that A(v) = true if ov ∈ S, and A(v) = false if ov̄ ∈ S. Note that A is well-defined because, for an ultimately preferred subset S, all Pv(S) = true, and thus, for each v ∈ V , exactly one item from {ov, ov̄} is present in S. Clearly, A is a legal assignment for Φ. In addition, we have all PC(S) = true. Thus, for each clause C ∈ Φ, at least one item with X = li ∈ C belongs to S. By construction, this implies that A satisfies all the clauses in Φ, and thus Φ is satisfiable.\nConveresly, suppose that S ⊆ S is preferentially undominated with respect to N , but is not ultimately preferred. If our POS problem has such an undominated subset S, we show that Φ is unsatisfiable. Assuming the contrary, let A be a satisfying assignment of Φ. Given A, we construct a subset SA ⊆ S as SA = {ol | literal l ∈ A}, and show that SA dominates S with respect to N (contradicting the assumed undominance of S, and finalizing the proof of Theorem 2).\nBy construction, since A is a legal assignment to V , we have Pv(SA) = true for all set properties Pv. Also, since A is a satisfying assignment for Φ, we have PC(SA) = true for all set properties PC . Therefore, SA is actually an ultimately preferred subset of S. Finally, since all the set properties P are preferentially independent in N , and value true is always preferred to value false for all the set properties, we have that SA dominates S with respect to N .\nNotice that Theorems 1 and 2 do not subsume each other. Theorem 1 poses no restriction on the number of item attributes in the problem instance, but does restrict the domain of all the attributes. Theorem 2 restricts the number of attributes to 1, but has no restriction on the domain size of this attribute, and its restriction on the property size is looser than that imposed in Theorem 1.\nFinally, we note that tightening the condition of Theorem 2, by allowing only at most 1 connective in each set-property definition prevents us from using the same reduction as in the proof of Theorem 2 because the respectibe satisfiability problems would be the polynomial-time solvable 2-SAT problems. Our conjecture, however, is that this fragment of POS is still NP-hard. In fact, in Section 5.3 we show that the corresponding fragment ofPOS with the GAI preference specification (instead of TCP-nets) is indeed NP-hard."
    }, {
      "heading" : "5.2 Tractable Classes",
      "text" : "Several tractable classes of POS, obtained by further restricting the problem class discussed in Theorem 2, and characterized by single-attribute item description (that is, a = 1), are discussed below. In both trivially tractable (Section 5.2.1) and non-trivially tractable (Section 5.2.2) cases, we assume that the relational symbols are either equalities or inequalities, that in the specification of a property only equalities (“attribute = value”) are used, and in addition we do not allow an empty set property to be specified. The latter restriction is due to the fact that the empty set property is somewhat special, as it enriches the descriptive power by allowing one to simulate an additional attribute in certain cases, and the single-attribute restriction is crucial for our tractability result.\nBefore we proceed with the actual results, note that, with a single-attribute item description, no two set properties can be in a conflict that demands backtracking while choosing items (i.e. during CSP solution). To illustrate such conflicts, consider the following examples.\n1. 1.a 〈|A = ai| ≤ 5〉 1.b 〈|A = ai| ≤ 3〉 Set property 1.a is redundant, subsumed by 1.b\n2. 2.a 〈|A = as| = 5〉 2.b 〈|A = as| > 6〉 One of these set properties must be false.\n3. 3.a 〈|A = al| < 7〉 3.b 〈|A = al| ≥ 9〉 One of these set properties must be false.\nAll such conflicts between set-properties can be resolved offline, prior to the actual process of subset selection, totally disregarding the available items. Hence, within the process of subset selection, we assume that there are no conflicts between set properties. Consequently, subset selection can be done in a greedy manner."
    }, {
      "heading" : "5.2.1 TRIVIALLY TRACTABLE CLASS",
      "text" : "Theorem 3. Finding an optimal subset of a given set of items (POS) with respect to a TCP-net preference specification is in P if the items are described in terms of a single attribute, and all the set properties are atomic (that is, we have a = 1 and k = 0).\nAn algorithm for the problem class in Theorem 3 is depicted in Figure 9. The algorithm runs in time O(m2n), where m is the number of set properties and n is the number of available items S. The for loop in line 4 of the algorithm iterates over all the set properties, each time checking compatibility with the previously considered properties, which requires Θ(m2) time. The procedures GETSATISFYINGSET(·) and HASSATISFYINGSET(·) have to process each item in S only once. Hence, the total running time of the algorithm is O(m2n).6\n6. This runtime analysis does not include the ordering of the TCP-net variables that is assumed to be given. One way to do that would be a topological sort of the net, that obviously can be done in polynomial time."
    }, {
      "heading" : "5.2.2 NON-TRIVIALLY TRACTABLE CLASS",
      "text" : "At the end of Section 5.1 we have mentioned that the complexity of POS under limiting the setproperty description to at most one logical connective is still an open problem. If, however, we impose the limitations summarized in Table 4, we can show that the problem becomes tractable.\nTheorem 4. Finding an optimal subset of a given set of items (POS) with respect to a TCP-net preference specification is in P if it is restricted as in Table 4.\nFirst we should discuss the implicit limitations (or special problem properties) that are imposed by the explicit limitations listed in Table 4.\n1. All the items have only one attribute (a = 1)\n2. All the property formulas have at most 1 connective (k = 1), and are positive (that is, we disallow negation)\n3. The empty property is disallowed\n4. The number of attribute value appearances is limited to at most µ = 1 (that is, values in the attribute domain cannot be repeated)\nThe algorithm for the problem class in Theorem 4 is depicted in Figure 10. This algorithm bears some similarity to the algorithm in Figure 9, except that here the procedures GETSATISFYINGSET and HASSATISFYINGSET reason simultaneously about satisfaction of collections of set-property values, and do that by utilizing 2-SAT solving. Specifically, in Table 5 we show how any valid property in such a POS problem can be translated into a 2-SAT CNF formula. In Lemma 3 we prove the correctness of this translation. We should note that by using 2-SAT we can have an answer to the question “Is there a subset of items satisfying some already evaluated set-property values”. The procedures GETSATISFYINGSET and HASSATISFYINGSET use the aforementioned reduction to 2-SAT to provide the answer in polynomial time.\nLemma 3. There is a subset S satisfying all the property-values Pass if and only if there is a satisfying assignment A to the 2-SAT formula constructed from Pass.\nProof. By construction, we have an injective correspondence between the properties in the POS problem and clauses in the 2-SAT problem. Every property P ∈ P injectively corresponds to a certain clause ϕP . Every item o ∈ S injectively corresponds to a propositional variable vi ∈ V . Thus, the correspondence between the selected subset S and the assignment A is simply\nvi = true ⇔ o ∈ S. (1)\nBecause the translation is injective and rather straightforward (without introducing any auxiliary clauses or properties), it is trivial that S is a subset that satisfies all the properties in Pass if and only if A is an assignment that satisfies all the clauses in the corresponding 2-SAT formula.\nThe above shows correctness of the algorithm in Figure 10, and finalizes the proof of Theorem 4.\n5.3 Complexity of POS: TCP-nets vs. GAI Preference Specification\nWith the restrictions as in Table 4 we were able to show that the POS problem with TCP-net preference specification is tractable by reduction to 2-SAT, because there is no need to backtrack while searching in the attribute value space. An interesting question is, what if the specification were done using GAI functions?\nTheorem 5. Finding an optimal subset of a given set of items (POS) with respect to a GAI preference specification is NP-hard even if the items are described in terms of a single attribute, all the set properties are binary-valued, each containing at most 1 logical connective (that is, we have a = 1 and k = 1).\nProof. The proof is by a polynomial reduction from MAX-2SAT. As far as item definitions and properties are concerned, the reduction is essentially the same as the reduction from k-SAT in the proof of Theorem 2. That is, for each variable v ∈ V , construct an item ov and an item ov̄. The value of the only attribute X is defined as follows: for item ol, we have A(ol) = l (where l is a literal, either v or v̄, for all v ∈ V ). Set properties are also as in the proof of Theorem 2, but now they are limited to only 2 variables per clauses (re-stated for convenience below):\n• For each variable v ∈ V :\nPv =〈|X = v ∨X = v̄| = 1〉,\nthat is, properties ensuring that a variable assignment is legitimate.\n• For each clause C = (l1 ∨ l2) ∈ Φ:\nPC =〈|X = l1 ∨X = l2| ≥ 1〉,\nthat is, properties ensuring that Φ is satisfied.\nThe value function specification is such that legitimate variable assignments are enforced, and a larger number of clauses satisfied is preferred. This is achieved by using an additively independent value function (i.e., where each factor contains a single variable), with values being as follows. Each clause-satisfying property has a value of 1 for being true, and 0 for being false. Each literalsatisfying property has a value of 0 for being true, and a negative value of −2m for being false, wherem is the number of clauses.\nLemma 4. Given a GAI value function and item set S constructed as above for a 2-CNF formula Φ, there exists a subset S ⊆ S with value of U(S) = p if and only if there exists an assignment A satisfying p clauses in Φ.\nProof. Let S be any subset of S that has non-negative value. This implies by construction (since there are only m clause-satisfying properties PC) that all literal-satisfying properties must be true for S, and the respective assignment AS can be constructed as in Equation 1. Conversely, let A be a legitimate assignment to the variables V . One can define a corresponding set SA, for which (by construction) all properties Pv are true. Also, observe that by construction the number of PC set properties that are true on SA is the same as the number of clauses satisfied by the assignment A.\nThe theorem follows immediately from the properties of the construction of the set properties and preferences.\nAt the end of Section 5.1 we have noted that if the restrictions on the problem parameters are more severe than in Theorem 2, by limiting the number of logical connectives per set property to at most 1, we can no longer show whether the problem is tractable or NP-hard under the TCPnet preference specification. However, Theorem 5 shows that, with preferences specified using a GAI value function, the problem is in fact NP-hard. Moreover, the problem class from Theorem 5 subsumes the class from Theorem 4, and thus provides an additional result showing that even though with the TCP-net specification the respective problem is tractable, with a GAI preference specification it becomes NP-hard."
    }, {
      "heading" : "6. Related Work",
      "text" : "In the introduction, we mentioned the closely related work of desJardins and Wagstaff (2005). In that approach, the motivation to provide the user with a diverse collection of values is either to reflect the set of possible choices better for applications where the user must eventually select a single item, or when the diversity of the selected set is an objective on its own. The work of Price and Messinger (2005) is explicitly concerned with this problem. Specifically, they consider the problem of recommending items to a user, and view it as a type of subset selection problem. For example, suppose we want to recommend a digital camera to a user. We have a large set of available cameras, and we are able to recommend k cameras. Price and Messinger consider the question of how to select this set, proposing that the candidate set will maximize the expected value of the user’s choice from this set. They suggest a concrete algorithmic approach for handling this problem. The input to their problem is some form of partial representation of the user’s preferences (which can be diverse, as in our work) and naturally, the concrete techniques are different from ours. Both these papers share the assumption on ranking sets, common to most previous work as discussed by Barberà et al. (2004), that ultimately one item will be selected from this set. However, they do not necessarily start out with an initial ranking over single items, and as in our case, the work of desJardins and Wagstaff utilizes the attribute value of items in the selection process.\nEarlier work on ranking subsets was motivated by problems such as the college admissions problem (Gale & Shapley, 1962), where we need to select the best set of fixed cardinality among a pool of college candidates. The admissions officer has various criteria for a good class of students and wishes to come up with an optimal choice. Some of the key questions that concerned this line of work were what are good properties of such set rankings and whether they have some simple representation. An example of a property of the set ranking that may be desirable is the following: given a set S, if we replace some member c ∈ S with some other member c′ to obtain the set S′, and c′ is preferred to c, then S′ is preferred to S. An example of a representation of the ranking\nis an additive representation where items are associated with real values and one set is preferred to another if the sum of its elements’ values is larger. It would be interesting to study similar question in our context of structured objects.\nThis question of ranking sets appears in other areas, such as logics of preference and likelihood. For example, the main question considered by Halpern (1997) is how to construct an ordering over formulas based on an ordering over truth assignments. Formulas are associated with the set of worlds in which they are satisfied, and hence, the question of comparing the likelihood of formulas ψ and φ corresponds to that of ranking their respective set of models given the initial ranking on single models. Much work on non-monotonic logics uses Shoham’s preference semantics (Shoham, 1987), and semantically, such work (see, e.g., Kraus, Lehmann, & Magidor, 1990) can be viewed as attempting to answer the opposite question – define a ranking over single truth assignments given some, possibly partial, ordering over formulas, i.e., sets of models.\nA number of lines of work are related to our specification and solution methods. The first is the work on Russian Doll Search (RDS), a well known algorithm for combinatorial optimization, originally presented by Verfaillie, Lemaı̂tre, and Schiex (1996) as an efficient algorithm for Constraint Optimization Problems (COP). The idea behind the approach is to solve consecutively harder problems. Initially, the problem is solved while considering only one variable. The optimal result provides a lower bound. Each iteration, additional variables are considered, until eventually the original problem is solved. By using the lower bound obtained from the previous iteration (and other optimizations) this technique is often able to solve the original problem more efficiently. Recently Rollon and Larrosa (2007) extended Russian Doll Search to support multi-objective optimization problems. In a multi-objective optimization problem the goal is to optimize several parameters (attributes) of the variables in the problem. Usually all the parameters cannot be simultaneously optimized. The technique of Rollon and Larrosa involves incremental solution with more and more objectives included, and, in this sense, it is related to our search over CSPs approach in which we incrementally consider more and more set properties. Indeed, different desirable set properties can be viewed as different objectives.\nAnother related area is that of Pseudo-Boolean Constraint (PBC) Satisfaction Problems (Sheini & Sakallah, 2005). A PBC has the form: ∑\ni\nwili ≥ k.\nHere the li’s are literals and we interpret their values as being either 0 (false) or 1 (true); the wi are real-valued coefficients; and k is an integer. Thus Pseudo-Boolean CSPs are a special form of integer programs, and can nicely represent the cardinality constraints we generate. Thus, one option for solving the type of CSPs generated here would be using a dedicated PBC solver. We run several popular PBC solvers on the satisfiability instances generated during the optimization: Pueblo (Sheini & Sakallah, 2005), MiniSat (Eén & Sörensson, 2005), and Galena (Dixon & Ginsberg, 2002). These solvers showed comparable results for satisfiable cases, while for the unsatisfiable cases, the PBC solvers showed better performance. This appears to be due to their use of linear programming as a preliminary test for satisfiability.\nAnother line of work that bears important connection to ours is that of winner determination in combinatorial auctions. In regular auctions, bidders bid for a single item. In combinatorial auctions, bidders bid on bundles of items. Thus, bidders must provide their preferences over different subsets of the set of auctioned items. The goal in combinatorial auctions is to allocate the set of\ngoods to different bidders in the best manner (e.g., maximizing the payment to the seller or maximizing total welfare). This differs from the problem of selecting a single optimal subset with which we are concerned. However, in both cases, preferences over subsets must be provided to the optimization algorithm. As the number of subsets is exponential in the number of items, researchers in combinatorial auctions have sought bidding languages that can succinctly describe preferences of interest (Boutilier & Hoos, 2001; Nisan, 2006). What distinguishes our specification approach is its reliance on the existence of item features and the desire to provide a generic specification that does not depend on the concrete set of items. Work in combinatorial auctions also attempts to break the specification in some way. This is typically done by specifying values for small bundles and providing rules for deriving the value of larger sets from the values of the smaller sets."
    }, {
      "heading" : "7. Conclusion",
      "text" : "We suggested a simple, yet general approach to lifting any attribute-based preference specification formalism to one for specifying preferences over sets. We then focused one instantiation of this idea via a concrete language for specifying set properties, and suggested two methods for computing an optimal subset given such a specification. One method is based on searching the space of explicit subsets, while the other searches over implicit subsets represented as CSPs. Both search spaces are meaningful regardless of the specific underlying preference specification algorithm although the precise search and bounds generation method will vary. We focused on two concrete and popular specification formalisms, one qualitative and one quantitative, on which we experiment and provide complexity results. Although the problem is generally NP-hard, as expected, the experimental results are quite encouraging.\nWe wish to reemphasize that other choices, both for the set property language and the preference specification formalism are possible, and may be more appropriate in various cases. Indeed, an interesting topic for future research would be to see which choices fit best some natural application areas; whether and how the algorithm presented in this paper can be modified to handle such languages; and how the complexity of the optimal subset selection problem is affected by such choices.\nThough incremental search over CSPs appears to be the better method for optimal subset selection, it leaves a few questions open. First, it is an interesting question whether an efficient NoGood recording scheme that does not rely on static variable and value orderings exists. Intuitively, such a scheme should exist since the CSPs generated can be efficiently encoded into SAT as a boolean CNF formula (Bailleux & Boufkhad, 2004; Eén & Sörensson, 2005), and clause learning is a well known technique in SAT solving. Second, we have seen that while the incremental approach usually improves the overall performance, its contribution is not substantial and what really improves the performance is better individual CSP solving. This begs two questions: (1) Can we better utilize solutions across CSPs, and (2) Would representing and solving the CSPs generated as pseudo-boolean CSPs (Manquinho & Roussel, 2006) or SAT instances lead to faster solution times? Naturally, alternative approaches are also feasible.\nFinally, in various applications, the set of elements gradually changes, and we need to adapt the selected subset to these changes. An example is when we use this approach to choose the most interesting current articles, and new articles constantly appear. It is likely that in this case the preferred set is similar to the current set, and we would like to formulate an incremental approach that adapts to such changes quickly."
    }, {
      "heading" : "Acknowledgments",
      "text" : "Preliminary versions of this work appeared in (Brafman, Domshlak, Shimony, & Silver, 2006b; Binshtok, Brafman, Shimony, Mani, & Boutilier, 2007). The authors wish to thank our anonymous reviewers for their useful comments and suggestions. Brafman was supported in part by NSF grant IIS-0534662, Brafman and Domshlak were supported by the COST action IC0602, Binshtok, Brafman and Shimony were supported by Deutsche Telekom Laboratories at Ben-Gurion University, by the Paul Ivanier Center for Robotics Research and Production Management, and by the Lynn and William Frankel Center for Computer Science."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2009,
    "abstractText" : "Various tasks in decision making and decision support systems require selecting a preferred subset of a given set of items. Here we focus on problems where the individual items are described using a set of characterizing attributes, and a generic preference specification is required, that is, a specification that can work with an arbitrary set of items. For example, preferences over the content of an online newspaper should have this form: At each viewing, the newspaper contains a subset of the set of articles currently available. Our preference specification over this subset should be provided offline, but we should be able to use it to select a subset of any currently available set of articles, e.g., based on their tags. We present a general approach for lifting formalisms for specifying preferences over objects with multiple attributes into ones that specify preferences over subsets of such objects. We also show how we can compute an optimal subset given such a specification in a relatively efficient manner. We provide an empirical evaluation of the approach as well as some worst-case complexity results.",
    "creator" : "TeX"
  }
}