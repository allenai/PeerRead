{
  "name" : "1701.01724.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "DeepStack: Expert-Level Artificial Intelligence in No-Limit Poker",
    "authors" : [ "Matej Moravčı́k", "Martin Schmid", "Neil Burch", "Viliam Lisý", "Dustin Morrill", "Nolan Bard", "Trevor Davis", "Kevin Waugh", "Michael Johanson", "Michael Bowling" ],
    "emails" : [ "bowling@cs.ualberta.ca" ],
    "sections" : [ {
      "heading" : null,
      "text" : "DeepStack: Expert-Level Artificial Intelligence in No-Limit Poker\nMatej Moravčı́k♠,♥,†, Martin Schmid♠,♥,†, Neil Burch♠, Viliam Lisý♠,♣, Dustin Morrill♠, Nolan Bard♠, Trevor Davis♠,\nKevin Waugh♠, Michael Johanson♠, Michael Bowling♠,∗ ♠Department of Computing Science, University of Alberta,\nEdmonton, Alberta, T6G2E8, Canada ♥Department of Applied Mathematics, Charles University,\nPrague, Czech Republic ♣Department of Computer Science, FEE, Czech Technical University,\nPrague, Czech Republic\n†These authors contributed equally to this work and are listed in alphabetical order. ∗To whom correspondence should be addressed; E-mail: bowling@cs.ualberta.ca\nArtificial intelligence has seen a number of breakthroughs in recent years, with games often serving as significant milestones. A common feature of games with these successes is that they involve information symmetry among the players, where all players have identical information. This property of perfect information, though, is far more common in games than in real-world problems. Poker is the quintessential game of imperfect information, and it has been a longstanding challenge problem in artificial intelligence. In this paper we introduce DeepStack, a new algorithm for imperfect information settings such as poker. It combines recursive reasoning to handle information asymmetry, decomposition to focus computation on the relevant decision, and a form of intuition about arbitrary poker situations that is automatically learned from selfplay games using deep learning. In a study involving dozens of participants and 44,000 hands of poker, DeepStack becomes the first computer program to beat professional poker players in heads-up no-limit Texas hold’em. Furthermore, we show this approach dramatically reduces worst-case exploitability compared to the abstraction paradigm that has been favored for over a decade.\nGames have long served as a benchmark and set of milestones for progress in artificial\nar X\niv :1\n70 1.\n01 72\n4v 1\n[ cs\n.A I]\n6 J\nan 2\n01 7\nintelligence. In the last two decades, we have seen computer programs reach a performance that exceeds expert human players in many games, e.g., backgammon (1), checkers (2), chess (3), Jeopardy! (4), Atari video games (5), and go (6). These successes all involve games with information symmetry, where all players have identical information about the current state of the game. This property of perfect information is also at the heart of the algorithms that enabled these successes, e.g., local search during play (7, 8).\nThe founder of modern game theory and computing pioneer, von Neumann, envisioned reasoning in games without perfect information. “Real life is not like that. Real life consists of bluffing, of little tactics of deception, of asking yourself what is the other man going to think I mean to do. And that is what games are about in my theory.” (9) One game that fascinated von Neumann was poker, where players are dealt private cards and take turns making bets or bluffing on holding the strongest hand, calling opponents’ bets, or folding and giving up on the hand and the bets already added to the pot. Poker is a game of imperfect information, where players’ private cards give them asymmetric information about the state of game.\nThere has been some AI success in heads-up (i.e., two-player) limit Texas hold’em, the smallest variant of poker played by humans.1 However, heads-up limit Texas hold’em has fewer than 1014 decision points. By comparison, computers have exceeded expert human performance in go (6), a perfect information game with approximately 10170 decision points (12). The comparable variant of poker is heads-up no-limit Texas hold’em (HUNL). In HUNL, the two players can bet any number of chips, resulting in over 10160 decision points (13).\nImperfect information games require more complex reasoning than their perfect information counterparts. The correct decision at a particular moment depends upon the probability distribution over private information that the opponent holds, which is revealed through their past actions. However, how the opponent’s actions reveal that information depends upon their knowledge of our private information and how our actions reveal it. This kind of recursive reasoning is why one cannot easily reason about game situations in isolation, which is at the heart of local search methods for perfect information games. Competitive AI approaches in imperfect information games typically reason about the entire game and produce a complete strategy prior to play (14, 15).2 Counterfactual regret minimization (CFR) (11, 14, 17) is one such technique that uses self-play to do recursive reasoning through adapting its strategy against itself over successive iterations. If the game is too large to be solved directly, the common solution is to solve a smaller, abstracted game. To play the original game, one translates situations and actions from the original game in to the abstract game.\nWhile this approach makes it feasible for programs to reason in a game like HUNL, it does so by squeezing HUNL’s 10160 situations into the order of 1014 abstract situations. Likely\n1In 2008, Polaris defeated a team of professional poker players in heads-up limit Texas hold’em (10). In 2015, Cepheus essentially solved the game (11).\n2End-game solving (16–18) is one exception to computation occurring prior to play. When the game nears the end, a new computation is invoked over the remainder of the game. Thus, the program need not store this part of the strategy or can use a finer-grained abstraction aimed to improve the solution quality. We discuss this as re-solving when we introduce DeepStack’s new technique of continuous re-solving.\nas a result of this loss of information, such programs are well behind expert human play. In 2015, the computer program Claudico lost to a team of professional poker players by a margin of 91 mbb/g,3 which is a “huge margin of victory” (19) and significant at a 90% confidence level. Furthermore, it has been recently shown that abstraction-based programs from the Annual Computer Poker Competition have massive flaws (20). Four such programs (including top programs from the 2016 competition) were evaluated using a local best-response technique that produces an approximate lower-bound on how much a strategy can lose. All four abstractionbased programs are beatable by over 3,000 mbb/g, which is four times as large as simply folding each game.\nDeepStack takes a fundamentally different approach. It continues to use the recursive reasoning of CFR to handle information asymmetry. However, it does not compute and store a complete strategy prior to play and so has no need for explicit abstraction. Instead it considers each particular situation as it arises during play, but not in isolation. It avoids reasoning about the entire remainder of the game by substituting the computation beyond a certain depth with a fast approximate estimate. This estimate can be thought of as DeepStack’s intuition: a gut feeling of the value of holding any possible private cards in any possible poker situation. Finally, DeepStack’s intuition, much like human intuition, needs to be trained. We train it with deep learning using examples generated from random poker situations. We show that DeepStack is theoretically sound, produces substantially less exploitable strategies than abstraction-based techniques, and is the first program to beat professional poker players at HUNL with a remarkable average win rate of over 450 mbb/g."
    }, {
      "heading" : "DeepStack",
      "text" : "DeepStack is a general-purpose algorithm for a large class of sequential imperfect information games. For clarity, we will describe its operation in the game of HUNL. The state of a poker game can be split into the players’ private information, hands of two cards dealt face down, and the public state, consisting of the cards laying face up on the table and the sequence of betting actions made by the players. Possible sequences of public states in the game form a public tree with every public state having an associated public subtree. See Figure 1.\nA player’s strategy defines a probability distribution over valid actions for each decision point, which is a combination of the public state and the hand for the acting player. Given a player’s strategy, for any public state one can compute the player’s range, which is the probability distribution over the player’s possible hands given that the public state is reached.\nGiven both players’ strategies, the expected utility of a terminal public state, where the game has ended, can be computed as a bilinear function of the players’ ranges using a payoff matrix\n3We use milli-big-blinds per game (mbb/g) to measure performance in poker, where a milli-big-blind is one thousandth of the size of the big blind bet amount. This normalizes performance for the number of games played and the size of stakes. For comparison, a win rate of 50 mbb/g is considered a sizable margin by professional players and 750 mbb/g is the rate that would be lost if a player folded each game.\ndetermined by the rules of the game. The expected utility of any other public state s, including the initial state, is the expected utility over terminal states reached given the players’ strategies. A best response strategy is one which maximizes a player’s expected utility against an opponent strategy. In two-player, zero-sum games like HUNL, a solution or Nash equilibrium strategy (21) maximizes the expected utility when playing against a best response opponent strategy. The exploitability of a strategy is the difference in expected utility against its best response opponent and the expected utility under a Nash equilibrium.\nThe DeepStack algorithm seeks to compute and play a low-exploitability strategy for the game, i.e., solve for an approximate Nash equilibrium. DeepStack computes this strategy during play4 and only for the states of the public tree that actually arise during play as illustrated in Figure 2. This local computation lets DeepStack reason in games that are too big for existing algorithms without having to abstract the game’s 10160 decision points down to 1014 to make solving tractable. The DeepStack algorithm is composed of three ingredients: a sound local strategy computation for the current public state, depth-limited lookahead using a learned value function over arbitrary poker situations, and a restricted set of lookahead actions. We explain each ingredient in turn, starting with the local lookahead procedure that by itself is computationally infeasible, before discussing the ingredients that make DeepStack tractable.\n4While DeepStack’s strategy is computed during play, its strategy is static, albeit stochastic, since it is the result of a deterministic computation that produces a probability distribution over the available actions."
    }, {
      "heading" : "Continuous Re-Solving",
      "text" : "Suppose we have a solution for the entire game, but then in some public state we forget this strategy. Can we reconstruct a solution for the subtree without having to solve the entire game again? We can, through the process of re-solving (17). We need to know both our range at the public state and a vector of expected values achieved by the opponent under the previous solution for each opponent hand. With these values, we can reconstruct a strategy for only the remainder of the game, which does not increase our overall exploitability. Each value in the opponent’s vector is a counterfactual value, a conditional “what-if” value that gives the expected value if the opponent reaches the public state with a particular hand. The CFR algorithm also uses counterfactual values, and if we use CFR as our solver, it is easy to compute the vector of opponent counterfactual values at any public state.\nRe-solving, though, begins with a solution strategy, whereas our goal is to avoid ever maintaining a strategy for the entire game. We get around this by doing continuous re-solving: reconstructing a strategy by re-solving every time we need to act; never using the strategy beyond our next action. To be able to re-solve at any public state, we need only keep track of our own range and a suitable vector of opponent counterfactual values. These values must be an upper bound on the value the opponent can achieve with each hand in the current public state, while being no larger than the value the opponent could achieve had they deviated from reaching the public state.5\nAt the start of the game, our range is uniform and the opponent counterfactual values are initialized to the value of holding each private hand at the start.6 When it is our turn to act\n5This is an important relaxation of the counterfactual values used in re-solving, with a proof of sufficiency part of our proof of Theorem 1 below (22)\nwe re-solve the subtree at the current public state using the stored range and opponent values, and act according to the computed strategy, discarding the strategy before we act again. After each action — our own, our opponent’s, and chance — we update our range and opponent counterfactual values according to the following rules:\n• Own Action. Replace the opponent counterfactual values with those computed in the resolved strategy for our chosen action. Update our own range using the computed strategy and Bayes’ rule.\n• Chance Action. Replace the opponent counterfactual values with those computed for this chance action from the last re-solve. Update our own range by zeroing hands in the range that are impossible given any new public cards.\n• Opponent Action. Do nothing.\nThese updates ensure the opponent counterfactual values satisfy our sufficient conditions, and the whole procedure produces arbitrarily close approximations of a Nash equilibrium (see Theorem 1). Notice that continuous re-solving never keeps track of the opponent’s range, instead only keeping track of counterfactual values. Furthermore, it never requires knowledge of the opponent’s action to update these values, which is an important difference from traditional resolving. Both will prove key to making this algorithm efficient and avoiding any need for the translation step required with action abstraction methods (23, 24)."
    }, {
      "heading" : "Limited Lookahead and Sparse Trees",
      "text" : "Continuous re-solving is theoretically sound, but also impractical. While it does not ever maintain a complete strategy, re-solving itself is intractable except near the end of the game. For example, re-solving for the first action would require temporarily computing an approximate solution for the whole game. In order to make continuous re-solving practical, we need the second and third ingredients of DeepStack.\nLimited Depth Lookahead via Intuition. When using CFR to solve or re-solve games, each player’s strategy is improved locally on each iteration to smoothly approach a best-response. In any public subtree(s), we could replace the iterative improvement with an explicit best-response. Using explicit best-responses for both players means computing a Nash equilibrium strategy for these subtrees on each iteration. This results in CFR-D (17), a game solving algorithm that saves space by not requiring subtree strategies (for example, in public states exceeding a fixed depth) to be stored. However, it increases computation time by requiring the subtree strategies be recomputed on each iteration when only the vector of counterfactual values are needed.\nInstead of solving subtrees to get the counterfactual values, DeepStack uses a learned value function intended to return an approximation of the values that would have been returned by solving. The inputs to this function are the ranges for both players, the current pot size, and the\npublic cards. The outputs are a vector for each player containing the counterfactual values of holding each hand in that situation. In other words, the input is itself a description of a poker game: the probability distribution of being dealt individual private hands, the stakes of the game, and any public cards revealed; the output is an estimate of how valuable holding certain cards would be in such a game. The value function is a sort of intuition, a fast estimate of the value of finding oneself in an arbitrary poker situation. Limiting the lookahead to depth four, and using a value function for all public states exceeding that depth, reduces the size of game for re-solving from 10160 decision points down to no more than 1017 decision points. DeepStack uses a deep neural network to approximate this function, which is described later.\nA simpler form of using value functions to limit lookahead is at the heart of algorithms for perfect information games. Deep Blue searched to a minimum depth of 12 moves on average, with some lines searching much deeper, before applying an evaluation function at positions beyond that depth (3). AlphaGo at shallow depths combined Monte Carlo rollout evaluations with the results of a trained evaluation function (6). In both cases the evaluation function needed to only return a single value given a single position in the game. DeepStack’s value function must be able to provide a vector of values given a probability distribution over positions in the game.\nSound Reasoning. DeepStack’s depth-limited continuous re-solving is sound. If DeepStack’s intuition is “good” and “enough” computation is used in each re-solving step, then DeepStack plays an arbitrarily close approximation to a Nash equilibrium.\nTheorem 1 If the values returned by the value function used when the depth limit is reached has error less than , and T iterations of CFR is used to re-solve, then the resulting strategy’s exploitability is less than k1 + k2/ √ T , where k1 and k2 are game-specific constants. (22)\nSparse Lookahead Trees. The final ingredient in DeepStack is the reduction in the number of actions considered so as to construct a sparse lookahead tree. DeepStack builds the lookahead tree using only the actions fold (if valid), call, 2 or 3 bet/raise actions, and all-in. While this step loses the soundness property of Theorem 1 it moves DeepStack’s re-solving time into the range of conventional human play. With sparse and depth limited lookahead trees, the re-solved games have approximately 107 decision points, and can be solved in under five seconds.6\nWhile this ingredient looks very similar to action abstraction (23,24), which often results in highly exploitable strategies (20), there are important distinctions. Each re-solve in DeepStack starts from the actual public state and so always knows the exact size of the pot. Second, the algorithm never uses the opponent’s actual action to update its range or the opponent counterfactual values, and so no translation of opponent bets are ever needed.\n6We also use our sparse and depth limited lookahead computation to solve for the opponent’s counterfactual values at the start of the game, which are used to initialize DeepStack’s continuous re-solving."
    }, {
      "heading" : "Deep Counterfactual Value Networks",
      "text" : "Deep neural networks (DNNs) have proven to be powerful models and are responsible for major advances in image and speech recognition (25, 26), automated generation of music (27), and game-playing (5, 6). DeepStack uses DNNs, with a tailor-made architecture, as the value function for its depth-limited lookahead. See Figure 3. Two separate networks are trained: one estimates the counterfactual values after the first three public cards are dealt (flop network), the other after dealing the fourth public card (turn network). An auxiliary network for values before any public cards are dealt is used to speed up the re-solving for early actions (22).\nArchitecture. DeepStack uses a standard feed-forward network with seven fully connected hidden layers each with 500 nodes and parametric rectified linear units (28) for the output. This basic architecture is embedded in an outer network that guarantees the counterfactual values satisfy the zero-sum property. The outer computation takes the estimated counterfactual values, and computes a weighted sum using the two players’ input ranges resulting in separate estimates of the game value. These two values should sum to zero, but may not. Half the actual sum is then subtracted from the two players’ estimated counterfactual values. This entire computation is differentiable and can be trained with gradient descent. The network’s inputs are the pot-size as a fraction of the players’ total stacks and an encoding of the players’ ranges as a function of the public cards. The ranges are encoded by bucketing hands, as in traditional abstraction methods (29–31), and input as a vector of probabilities over the buckets. Note that while this bucketing results in some loss of information, it is only used to estimate counterfactual values at the end of a lookahead tree rather than limiting what information the player has about their cards when acting. The output of the network are vectors of counterfactual values for each player and hand, interpreted as fractions of the pot size.\nTraining. The turn network was trained by solving 10 million randomly generated poker turn games. These turn games used randomly generated ranges (22), public cards, and a random pot size. The target counterfactual values for each training game were generated by solving the game with players’ actions restricted to fold, call, a pot-sized bet, and an all-in bet, but no card abstraction. The flop network was trained similarly with 1 million randomly generated flop games. However, the target counterfactual values were computed using our limited-depth solving procedure and our trained turn network. The networks were trained using the Adam gradient descent optimization procedure (32) with a Huber loss (33)."
    }, {
      "heading" : "Evaluating DeepStack",
      "text" : "We evaluated DeepStack by playing it against a pool of professional poker players recruited by the International Federation of Poker (34). Thirty-three players from 17 countries were recruited. Each was asked to complete a 3,000 game match over a period of four weeks between\nNovember 7th and December 12, 2016. Cash incentives were given to the top three performers ($5,000, $2,500, and $1,250 CAD).\nEvaluating performance in HUNL is challenging because of the large variance in per-game outcomes due to randomly dealt private and public cards and stochastic choices made by the players. The better player may lose in a short match simply because they were dealt weaker hands or their rare bluffs were made at inopportune times. As seen in the Claudico match (19), even 80,000 games may not be enough to statistically significantly separate players whose skill differs by a considerable margin. We evaluate performance using AIVAT (35), a provably unbiased low-variance technique for evaluating performance in imperfect information games based on carefully constructed control variates. AIVAT requires an estimated value of holding each hand in each public state, and then uses the expected value changes that occur due to chance events and actions of players with known strategies to compute its control variate. DeepStack’s own value function estimate is perfectly suited for AIVAT. And indeed when used with AIVAT we get an unbiased performance estimate with an impressive 85% reduction in standard deviation. Thanks to this technique, we can show statistical significance in matches with as few as 3,000 games.\nIn total 44,852 games were played by the thirty-three players with 11 players completing the requested 3,000 games. Over all games played, DeepStack won 492 mbb/g. This is over 4 standard deviations away from zero, and so highly significant. Note that professional poker\nplayers consider 50 mbb/g a sizable margin. Using AIVAT to evaluate performance, we see DeepStack was overall a bit lucky, with its estimated performance actually 486 mbb/g. However, as a lower variance estimate, this margin is over 20 standard deviations from zero, and so we are certain to be outperforming our pool of professional players.\nThe performance of individual participants measured with AIVAT is summarized in Figure 4. Amongst those players that completed the full 3,000 games, DeepStack is estimated to be winning by 394 mbb/g, and individually beating 10 out of 11 such players by a statistically significant margin. Only for the top player, still estimated to be losing by 70 mbb/g, is the result not a statistically significant margin. More details on the participants and their results are presented in the supplemental material (22)."
    }, {
      "heading" : "Exploitability",
      "text" : "The main goal of DeepStack is to approximate Nash equilibrium play, i.e., minimize exploitability. While the exact exploitability of a HUNL poker strategy is intractable to compute, the recent local best-response technique (LBR) can provide a lower bound on a strategy’s exploitability (20) given full access to its action probabilities. LBR uses the action probabilities to compute the strategy’s range at any public state. Using this range it chooses its response action from a fixed set using the assumption that no more bets will be placed for the remainder of the game.\nThus it best-responds locally to the opponent’s actions, providing a lower-bound on their overall exploitability. As already noted, abstraction-based programs from the Annual Computer Poker Competition are highly exploitable by LBR: four times more exploitable than folding every game. However, even under a variety of settings, LBR fails to exploit DeepStack at all — itself losing by over 350 mbb/g to DeepStack (22). Either a more sophisticated lookahead is required to identify its weaknesses or DeepStack is substantially less exploitable."
    }, {
      "heading" : "Discussion",
      "text" : "DeepStack is the first computer program to defeat professional poker players at heads-up nolimit Texas Hold’em, an imperfect information game with 10160 decision points. Notably it achieves this goal with almost no domain knowledge or training from expert human games. The implications go beyond just being a significant milestone for artificial intelligence. DeepStack is a paradigmatic shift in approximating solutions to large, sequential imperfect information games. Abstraction and offline computation of complete strategies has been the dominant approach for almost 20 years (29,36,37). DeepStack allows computation to be focused on specific situations that arise when making decisions and the use of automatically trained value functions. These are two of the core principles that have powered successes in perfect information games, albeit conceptually simpler to implement in those settings. As a result, for the first time the gap between the largest perfect and imperfect information games to have been mastered is mostly closed.\nAs “real life consists of bluffing... deception... asking yourself what is the other man going to think” (9), DeepStack also has implications for seeing powerful AI applied more in settings that do not fit the perfect information assumption. The old paradigm for handling imperfect information has shown promise in applications like defending strategic resources (38) and robust decision making as needed for medical treatment recommendations (39). The new paradigm will hopefully open up many more possibilities."
    }, {
      "heading" : "Game of Heads-Up No-Limit Texas Hold’em",
      "text" : "Heads-up no-limit Texas hold’em (HUNL) is a two-player poker game. It is a repeated game, in which the two players play a match of individual games, usually called hands, while alternating who is the dealer. In each of the individual games, one player will win some number of chips from the other player, and the goal is to win as many chips as possible over the course of the match.\nEach individual game begins with both players placing a number of chips in the pot: the player in the dealer position puts in the small blind, and the other player puts in the big blind, which is twice the small blind amount. During a game, a player can only wager and win up to a fixed amount known as their stack. In the particular format of HUNL used in the Annual Computer Poker Competition (40) and this article, the big blind is 100 chips and the stack is 20,000 chips or 200 big blinds. Resetting the stacks after each game is called “Doyle’s Game”, named for the professional poker player Doyle Brunson who publicized this variant (23). It is used in the Annual Computer Poker Competitions because it allows for each game to be an independent sample of the same game.\nA game of HUNL progresses through four rounds: the pre-flop, flop, turn, and river. Each round consists of cards being dealt followed by player actions in the form of wagers as to who will hold the strongest hand at the end of the game. In the pre-flop, each player is given two private cards, unobserved by their opponent. In the later rounds, cards are dealt face-up in the center of the table, called public cards. A total of five public cards are revealed over the four rounds: three on the flop, one on the turn, and one on the river.\nAfter the cards for the round are dealt, players alternate taking actions of three types: fold, call, or raise. A player folds by declining to match the last opponent wager, thus forfeiting to the opponent all chips in the pot and ending the game with no player revealing their private cards. A player calls by adding chips into the pot to match the last opponent wager, which causes the next round to begin. A player raises by adding chips into the pot to match the last wager followed by adding additional chips to make a wager of their own. At the beginning of a round when there is no opponent wager yet to match, the raise action is called bet, and the call action is called check, which only ends the round if both players check. An all-in wager is one involving all of the chips remaining the player’s stack. If the wager is called, there is no further wagering in later rounds. The size of any other wager can be any whole number of chips remaining in the player’s stack, as long as it is not smaller than the last wager in the current round or the big blind.\nThe dealer acts first in the pre-flop round and must decide whether to fold, call, or raise the opponent’s big blind bet. In all subsequent rounds, the non-dealer acts first. If the river round ends with no player previously folding to end the game, the outcome is determined by a showdown. Each player reveals their two private cards and the player that can form the strongest five-card poker hand (see “List of poker hand categories” on Wikipedia; accessed January 1, 2017) wins all the chips in the pot. To form their hand each player may use any cards from their two private cards and the five public cards. At the end of the game, whether ended by fold or showdown, the players will swap who is the dealer and begin the next game.\nSince the game can be played for different stakes, such as a big blind being worth $0.01 or $1 or $1000, players commonly measure their performance over a match as their average number of big blinds won per game. Researchers have standardized on the unit milli-big-blinds per game, or mbb/g, where one milli-big-blind is one thousandth of one big blind. A player that always folds will lose 750 mbb/g (by losing 1000 mbb as the big blind and 500 as the small blind). A human rule-of-thumb is that a professional should aim to win at least 50 mbb/g from their opponents. Milli-big-blinds per game is also used as a unit of exploitability, when it is computed as the expected loss per game against a worst-case opponent. In the poker community, it is common to use big blinds per one hundred games (bb/100) to measure win rates, where 10 mbb/g equals 1 bb/100."
    }, {
      "heading" : "Poker Glossary",
      "text" : "all-in A wager of the remainder of a player’s stack. The opponent’s only response can be call\nor fold.\nbet The first wager in a round; putting more chips into the pot.\nbig blind Initial wager made by the non-dealer before any cards are dealt. The big blind is twice the size of the small blind.\ncall Putting enough chips into the pot to match the current wager; ends the round.\ncheck Declining to wager any chips when not facing a bet.\nchip Marker representing value used for wagers; all wagers must be a whole numbers of chips.\ndealer The player who puts the small blind into the pot. Acts first on round 1, and second on the later rounds. Traditionally, they would distribute public and private cards from the deck.\nflop The second round; can refer to either the 3 revealed public cards, or the betting round after these cards are revealed.\nfold Give up on the current game, forfeiting all wagers placed in the pot. Ends a player’s participation in the game.\nhand Many different meanings: the combination of the best 5 cards from the public cards and private cards, just the private cards themselves, or a single game of poker (for clarity, we avoid this final meaning).\nmilli-big-blinds per game (mbb/g) Average winning rate over a number of games, measured in thousandths of big blinds.\npot The collected chips from all wagers.\npre-flop The first round; can refer to either the hole cards, or the betting round after these cards are distributed.\nprivate cards Cards dealt face down, visible only to one player. Used in combination with public cards to create a hand. Also called hole cards.\npublic cards Cards dealt face up, visible to all players. Used in combination with private cards to create a hand. Also called community cards.\nraise Increasing the size of a wager in a round, putting more chips into the pot than is required to call the current bet.\nriver The fourth and final round; can refer to either the 1 revealed public card, or the betting round after this card is revealed.\nshowdown After the river, players who have not folded show their private cards to determine the player with the best hand. The player with the best hand takes all of the chips in the pot.\nsmall blind Initial wager made by the dealer before any cards are dealt. The small blind is half the size of the big blind.\nstack The maximum amount of chips a player can wager or win in a single game.\nturn The third round; can refer to either the 1 revealed public card, or the betting round after this card is revealed."
    }, {
      "heading" : "Performance Against Professional Players",
      "text" : "To assess DeepStack relative to expert humans, professional poker players were recruited by referral from the International Federation of Poker (34). Players were given four weeks to complete a 3,000 game match. To incentivize players, monetary prizes of $5,000, $2,500, and\n$1,250 (CAD) were awarded to the top three players (measured by AIVAT) that completed their match. Matches were played between November 7th and December 12th, 2016, and run using an online user interface (41) where players had the option to play up to four games simultaneously as is common in online poker sites. A total of 33 players from 17 countries played against DeepStack. DeepStack’s performance against each individual is presented in Table 1, with complete game histories to be made available with the supplemental online materials.\nDeepStack Implementation Details Here we describe the specifics for how DeepStack employs continuous re-solving and its deep counterfactual value networks were trained."
    }, {
      "heading" : "Continuous Re-Solving",
      "text" : "As with traditional re-solving (17, 18), the re-solving step of the DeepStack algorithm solves an augmented game. The augmented game is designed to produce a strategy for the player such that the bounds for the opponent’s counterfactual values are satisfied. DeepStack uses a modification of the original CFR-D gadget (17) for its augmented game, as discussed below. While the max-margin gadget (18) is designed to improve the performance of poor strategies for abstracted agents near the end of the game, the CFR-D gadget performed better in early testing.\nThe algorithm DeepStack uses to solve the augmented game is a hybrid of vanilla CFR (14) and CFR+ (42), which uses regret matching+ like CFR+, but does uniform weighting and simultaneous updates like vanilla CFR. When computing the final average strategy and average counterfactual values, we omit the early iterations of CFR in the averages. In order to make DeepStack take actions in a consistently reasonable timeframe, we used different lookahead trees and number of re-solving iterations on each round. The lookahead trees varied in the actions available to the player acting, the actions available for the opponent’s response, and the actions available to either player for the remainder of the round. Finally, we used the end of the round as our depth limit, using the trained counterfactual value networks for values after the flop or turn card(s) were revealed. Table 2 gives the lookahead tree specifics for each round.\nThe pre-flop round is particularly expensive as it requires enumerating all 22,100 possible public cards on the flop and evaluating each with the flop network. To speed up pre-flop play, we trained an additional auxiliary neural network to estimate the expected value of the flop network over all possible flops. However, we only used this network during the initial omitted iterations of CFR. During the final iterations used to compute the average strategy and counterfactual values, we did the expensive enumeration and flop network evaluations. Additionally, we cache the re-solving result for every observed pre-flop situation. When the same betting sequence occurs again, we simply reuse the cached results rather than recomputing. For the turn round, we did not use a neural network after the final river card, but instead solved to the end of the\ngame. However, we used a bucketed abstraction for all actions on the river. For acting on the river, the re-solving includes the remainder of the game and so no counterfactual value network was used.\nOpponent Ranges in Re-Solving. Continuous re-solving does not require keeping track of the opponent’s range. The re-solving step essentially reconstructs a suitable range using the bounded counterfactual values. In particular, the CFR-D gadget does this by giving the opponent the option, after being dealt a uniform random hand, of terminating the game (T) instead of following through with the game (F), allowing them to simply earn that hand’s bound on its counterfactual value. Only hands which are valuable to bring into the subgame will then be observed by the re-solving player. However, this process of the opponent learning which hands to follow through with can make re-solving require many iterations. An estimate of the opponent’s range can be used to help speed up the re-solving.\nOne conservative option is to replace the uniform random deal of opponent hands with any distribution over hands as long as it assigns non-zero probability to every hand. For example, we could linearly combine an estimated range of the opponent from the previous re-solve (with weight b) and a uniform range (with weight 1− b). This approach still has the same theoretical guarantees as re-solving, but can reach better approximate solutions in fewer iterations. Another option is more aggressive and sacrifices the re-solving guarantees when the opponent’s range estimate is wrong. It forces the opponent with probability b to follow through into the game with a hand sampled from the estimated opponent range. With probability 1− b they are given a uniform random hand and can choose to terminate or follow through. This could prevent the opponent’s strategy from reconstructing a correct range, but can speed up re-solving further when we have a good opponent range estimate.\nDeepStack uses an estimated opponent range during re-solving only for the first action of a round, as this is the largest lookahead tree to re-solve. The range estimate comes from the last re-solve in the previous round. When DeepStack is second to act in the round, the opponent has already acted, biasing their range, so we use the conservative approach. When DeepStack\nis first to act, though, the opponent could only have checked or called since our last re-solve. Thus, the lookahead has an estimated range following their action. So in this case, we use the aggressive approach. In both cases, we set b = 0.9.\nSpeed of Play. The re-solving computation and neural network evaluations are implemented on a GPU. This makes it possible to do fast batched calls to the counterfactual value networks for multiple public subtrees at once, which is key to making DeepStack fast. It was implemented in Torch7 (43) and run on a single NVIDIA GeForce GTX 1080 graphics card.\nMany of the above implementation choices were made with the aim to make DeepStack act quickly; ideally as fast as humans play. Table 3 reports the average times between the end of the previous (opponent or chance) action and submitting the next action by both humans and DeepStack in our study. DeepStack, on average, acted considerably faster than our human players. It should be noted that some human players were playing up to four games simultaneously (although few players did more than two), and so the human players may have been focused on another game when it became their turn to act."
    }, {
      "heading" : "Deep Counterfactual Value Networks",
      "text" : "DeepStack uses two counterfactual value networks, one for the flop and one for the turn, as well as an auxiliary network that gives counterfactual values at the end of the pre-flop. In order to train the networks, we generated random poker situations at the start of the flop and turn. Each poker situation is defined by the pot size, ranges for both players, and dealt public cards. The complete betting history is not necessary as the pot and ranges are a sufficient representation. The output of the network are vectors of counterfactual values, one for each player. The output values are interpreted as fractions of the pot size to improve generalization across poker situations.\nThe training situations were generated by first sampling a pot size from a fixed distribution\nwhich was designed to approximate observed pot sizes from older HUNL programs.7 The player ranges for the training situations need to cover the space of possible ranges that CFR might encounter during re-solving, not just ranges that are likely part of a solution. So we generated pseudo-random ranges that attempt to cover the space of possible ranges. We used a recursive procedure R(S, p), that assigns probabilities to the hands in the set S that sum to probability p, according to the following procedure.\n1. If |S| = 1, then Pr(s) = p.\n2. Otherwise,\n(a) Choose p1 uniformly at random from the interval (0, p), and let p2 = p− p1. (b) Let S1 ⊂ S and S2 = S \\ S1 such that |S1| = b|S|/2c and all of the hands in S1\nhave a lower hand strength than hands in S2. Hand strength is the probability of a hand beating a uniformly selected random hand from the current public state.\n(c) Use R(S1, p1) and R(S2, p2) to assign probabilities to hands in S = S1 ⋃ S2.\nGenerating a range involves invokingR(all hands, 1). To obtain the target counterfactual values for the generated poker situations for the main networks, the situations were approximately solved using 1,000 iterations of CFR+ with only betting actions fold, call, a pot-sized bet, and all-in. For the turn network, ten million poker turn situations (from after the turn card is dealt) were generated and solved with 6,144 CPU cores of the Calcul Québec MP2 research cluster, using over 175 core years of computation time. For the flop network, one million poker flop situations (from after the flop cards are dealt) were generated and solved. These situations were solved using DeepStack’s depth limited solver with the turn network used for the counterfactual values at public states immediately after the turn card. We used a cluster of 20 GPUS and one-half of a GPU year of computation time. For the auxiliary network, ten million situations were generated and the target values were obtained by enumerating all 22,100 possible flops and averaging the counterfactual values from the flop network’s output.\nNeural Network Training. All networks were trained using the Adam stochastic gradient descent procedure (32) using the average of the Huber losses over the counterfactual value errors. Training used a mini-batch size of 1000, and a learning rate 0.001, which was decreased to 0.0001 after the first 200 epochs. Networks were trained for approximately 350 epochs over two days on a single GPU, and the epoch with the lowest validation loss was chosen.\nNeural Network Range Representation. In order to improve generalization over input player ranges, we map the distribution of individual hands (combinations of public and private cards)\n7The fixed distribution selects an interval from the set of intervals {[100, 100), [200, 400), [400, 2000), [2000, 6000), [6000, 19950]} with uniform probability, followed by uniformly selecting an integer from within the chosen interval.\ninto distributions of buckets. The buckets were generated using a clustering-based abstraction technique, which cluster strategically similar hands using k-means clustering with earth mover’s distance over hand-strength-like features (31, 44). For both the turn and flop networks we used 1,000 clusters and map the original ranges into distributions over these clusters as the first layer of the neural network (see Figure 3 of the main article). This bucketing step was not used on the auxiliary network as there are only 169 strategically distinct hands pre-flop, making it feasible to input the distribution over distinct hands directly.\nNeural Network Accuracies. The turn network achieved an average Huber loss of 0.016 of the pot size on the training set and 0.026 of the pot size on the validation set. The flop network, with a much smaller training set, achieved an average Huber loss of 0.008 of the pot size on the training set, but 0.034 of the pot size on the validation set. Finally, the auxiliary network had average Huber losses of 0.000053 and 0.000055 on the training and validation set, respectively. Note that there are, in fact, multiple Nash equilibrium solutions to these poker situations, with each giving rise to different counterfactual value vectors. So, these losses may overestimate the true loss as the network may accurately model a different equilibrium strategy."
    }, {
      "heading" : "Local Best Response of DeepStack",
      "text" : "Local best-response (LBR) is a simple, yet powerful technique to produce a lower bound on a strategy’s exploitability (20). It explores a fixed set of options to find a “locally” good action against the strategy. While it seems natural that more options would be better, this is not always true. More options may cause it to find a locally good action that misses out on a future opportunity to exploit an even larger flaw in the opponent. In fact, LBR sometimes results in the largest lower bounds when not considering any bets in the early rounds, so as to increase the size of pot and thus the magnitude of a strategy’s future mistakes. As noted in the main text of the article, LBR was recently used to show that abstraction-based agents are significantly exploitable. In all tested cases, the strategies were found to be even more exploitable than simply folding every game. As shown in Table 4, this is not true for DeepStack. Under all settings of the LBR’s available actions, it fails to find any exploitable flaw in DeepStack. In fact, it is losing over 350 mbb/g to DeepStack. While this does not prove that DeepStack is flawless, it does suggest its flaws require a more sophisticated search procedure than what is needed to exploit abstraction-based programs."
    }, {
      "heading" : "Proof of Theorem 1",
      "text" : "The formal proof of Theorem 1, which establishes the soundness of DeepStack’s depth-limited continuous re-solving, is conceptually easy to follow. It requires three parts. First, we establish that the exploitability introduced in a re-solving step has two linear components; one due\nto approximately solving the subgame, and one due to the error in DeepStack’s counterfactual value network (see Lemmas 1 through 5). Second, we enable estimates of subgame counterfactual values that do not arise from actual subgame strategies (see Lemma 6). Together, parts one and two enable us to use DeepStack’s counterfactual value network for a single re-solve.8 Finally, we show that using the opponent’s values from the best action, rather than the observed action, does not increase overall exploitability (see Lemma 7). This allows us to carry forward estimates of the opponent’s counterfactual value, enabling continuous re-solving. Put together, these three parts bound the error after any finite number of continuous re-solving steps, concluding the proof. We now formalize each step.\nThere are a number of concepts we use throughout this section. We use the notation from Burch et al. (17) without any introduction here. We assume player 1 is performing the continuous re-solving. We call player 2 the opponent. We only consider the re-solve player’s strategy σ, as the opponent is always using a best response to σ. All values are considered with respect to the opponent, unless specifically stated. We say σ is -exploitable if the opponent’s best response value against σ is no more than away from the game value for the opponent.\nA public state S corresponds to the root of an imperfect information subgame. We write IS2 for the collection of player 2 information sets in S. Let G〈S, σ, w〉 be the subtree gadget game (the re-solving game of Burch et al. (17)), where S is some public state, σ is used to get player 1 reach probabilities πσ−2(h) for each h ∈ S, and w is a vector where wI gives the value of player 2 taking the terminate action (T) from information set I ∈ IS2 . Let\nBVI(σ) = max σ∗2 ∑ h∈I πσ−2(h)u σ,σ∗2 (h)/πσ−2(I),\nbe the counterfactual value for I given we play σ and our opponent is playing a best response. For a subtree strategy σS , we write σ → σS for the strategy that plays according to σS for any\n8The first part is a generalization and improvement on the re-solving exploitability bound given by Theorem 3 in Burch et al. (17), and the second part generalizes the bound on decomposition regret given by Theorem 2 of the same work.\nstate in the subtree and according to σ otherwise. For the gadget game G〈S, σ, w〉, the gadget value of a subtree strategy σS is defined to be:\nGVSw,σ(σ S) = ∑ I∈IS2 max(wI ,BVI(σ → σS)),\nand the underestimation error is defined to be:\nUSw,σ = min σS GVSw,σ(σ S)− ∑ I∈IS2 wI .\nLemma 1 The game value of a gadget game G〈S, σ, w〉 is∑ I∈IS2 wI + USw,σ. (1)\nProof. Let σ̃S2 be a gadget game strategy for player 2 which must choose from the F and T actions at starting information set I . Let ũ be the utility function for the gadget game.\nmin σS1 max σ̃S2\nũ(σS1 , σ̃ S 2 ) = min\nσS1 max σS2 ∑ I∈IS2 πσ−2(I)∑ I′∈IS2 πσ−2(I ′) max a∈{F,T} ũσ S (I, a)\n= min σS1 max σS2 ∑ I∈IS2 max(wI , ∑ h∈I πσ−2(h)u σS(h))\nA best response can maximize utility at each information set independently:\n= min σS1 ∑ I∈IS2 max(wI ,max σS2 ∑ h∈I πσ−2(h)u σS(h))\n= min σS1 ∑ I∈IS2 max(wI ,BVI(σ → σS1 ))\n= USw,σ + ∑ I∈IS2 wI\nLemma 2 If our strategy σS is -exploitable in the gadget game G〈S, σ, w〉, then GVSw,σ(σS) ≤∑ I∈IS2 wI + USw,σ +\nProof. This follows from Lemma 1 and the definitions of -Nash, USw,σ, and GV S w,σ(σ S).\nLemma 3 Given an O-exploitable σ in the original game, if we replace a subgame with a strategy σS such that BVI(σ → σS) ≤ wI for all I ∈ IS2 , then the new combined strategy has an exploitability no more than O + EXPSw,σ where\nEXPSw,σ = ∑ I∈IS2 max(BVI(σ), wI)− ∑ I∈IS2 BVI(σ)\nProof. We only care about the information sets where the opponent’s counterfactual value increases, and a worst case upper bound occurs when the opponent best response would reach every such information set with probability 1, and never reach information sets where the value decreased.\nLet Z[S] ⊆ Z be the set of terminal states reachable from some h ∈ S and let v2 be the game value of the full game for player 2. Let σ2 be a best response to σ and let σS2 be the part of σ2 that plays in the subtree rooted at S. Then necessarily σS2 achieves counterfactual value BVI(σ) at each I ∈ IS2 .\nmax σ∗2\n(u(σ → σS, σ∗2))\n= max σ∗2 [ ∑ z∈Z[S] πσ→σ S −2 (z)π σ∗2 2 (z)u(z) + ∑ z∈Z\\Z[S] πσ→σ S −2 (z)π σ∗2 2 (z)u(z) ]\n= max σ∗2 [ ∑ z∈Z[S] πσ→σ S −2 (z)π σ∗2 2 (z)u(z)− ∑ z∈Z[S] πσ−2(z)π σ∗2→σS2 2 (z)u(z)\n+ ∑ z∈Z[S] πσ−2(z)π σ∗2→σS2 2 (z)u(z) + ∑ z∈Z\\Z[S] πσ−2(z)π σ∗2 2 (z)u(z)\n]\n≤ max σ∗2 [ ∑ z∈Z[S] πσ→σ S −2 (z)π σ∗2 2 (z)u(z)− ∑ z∈Z[S] πσ−2(z)π σ∗2→σS2 2 (z)u(z) ]\n+ max σ∗2 [ ∑ z∈Z[S] πσ−2(z)π σ∗2→σS2 2 (z)u(z) + ∑ z∈Z\\Z[S] πσ−2(z)π σ∗2 2 (z)u(z) ]\n≤ max σ∗2 [∑ I∈IS2 ∑ h∈I πσ−2(h)π σ∗2 2 (h)u σS ,σ∗2 (h)\n− ∑ I∈IS2 ∑ h∈I πσ−2(h)π σ∗2 2 (h)u σ,σS2 (h) ] + max σ∗2 (u(σ, σ∗2))\nBy perfect recall π2(h) = π2(I) for each h ∈ I:\n≤ max σ∗2 [∑ I∈IS2 π σ∗2 2 (I) (∑ h∈I πσ−2(h)u σS ,σ∗2 (h)− ∑ h∈I πσ−2(h)u σ,σS2 (h) )] + v2 + O\n= max σ∗2 [∑ I∈IS2 π σ∗2 2 (I)π σ −2(I) ( BVI(σ → σS)− BVI(σ) )] + v2 + O\n≤ [∑ I∈IS2 max(BVI(σ → σS)− BVI(σ), 0) ] + v2 + O\n≤ [∑ I∈IS2 max(wI − BVI(σ),BVI(σ)− BVI(σ)) ] + v2 + O\n=\n[∑ I∈IS2 max(BVI(σ), wI)− ∑ I∈IS2 BVI(σ) ] + v2 + O\nLemma 4 Given an O-exploitable σ in the original game, if we replace the strategy in a subgame with a strategy σS that is S-exploitable in the gadget game G〈S, σ, w〉, then the new combined strategy has an exploitability no more than O + EXPSw,σ + U S w,σ + S .\nProof. We use that max(a, b) = a+ b−min(a, b). From applying Lemma 3 with wI = BVI(σ → σS) and expanding EXPSBV(σ→σS),σ we get exploitability no more than\nO − ∑\nI∈IS2 BVI(σ) plus∑\nI∈IS2\nmax(BVI(σ → σS),BVI(σ)) ≤ ∑ I∈IS2 max(BVI(σ → σS),max(wI ,BVI(σ))\n= ∑ I∈IS2 ( BVI(σ → σS) + max(wI ,BVI(σ))\n−min(BVI(σ → σS),max(wI ,BVI(σ))) )\n≤ ∑ I∈IS2 ( BVI(σ → σS) + max(wI ,BVI(σ))\n−min(BVI(σ → σS), wI) )\n= ∑ I∈IS2 ( max(wI ,BVI(σ)) + max(wI ,BVI(σ → σS))− wI ) = ∑ I∈IS2 max(wI ,BVI(σ)) + ∑ I∈IS2 max(wI ,BVI(σ → σS))− ∑ I∈IS2 wI\nFrom Lemma 2 we get\n≤ ∑ I∈IS2 max(wI ,BVI(σ)) + USw,σ + S\nAdding O − ∑ I BVI(σ) we get the upper bound O + EXP S w,σ + U S w,σ + S .\nLemma 5 Assume we are performing one step of re-solving on subtree S, with constraint values w approximating opponent best-response values to the previous strategy σ, with an approximation error bound ∑ I |wI − BVI(σ)| ≤ E . Then we have EXP S w,σ + U S w,σ ≤ E .\nProof. EXPSw,σ measures the amount that the wI exceed BVI(σ), while U S w,σ bounds the amount that the wI underestimate BVI(σ → σS) for any σS , including the original σ. Thus, together\nthey are bounded by |wI − BVI(σ)|:\nEXPSw,σ + U S w,σ = ∑ I∈IS2 max(BVI(σ), wI)− ∑ I∈IS2 BVI(σ)\n+ min σS ∑ I∈IS2 max(wI ,BVI(σ → σS))− ∑ I∈IS2 wI\n≤ ∑ I∈IS2 max(BVI(σ), wI)− ∑ I∈IS2 BVI(σ)\n+ ∑ I∈IS2 max(wI ,BVI(σ))− ∑ I∈IS2 wI\n= ∑ I∈IS2 [max(wI − BVI(σ), 0) + max(BVI(σ)− wI , 0)]\n= ∑ I∈IS2 |wI − BVI(σ)| ≤ E\nLemma 6 Assume we are solving a game G with T iterations of CFR-D where for both players p, subtrees S, and times t, we use subtree values vI for all information sets I at the root of S from some suboptimal black box estimator. If the estimation error is bounded, so that minσ∗S∈NES ∑ I∈IS2 |vσ∗S(I)−vI | ≤ E , then the trunk exploitability is bounded by kG/ √ T+jG E for some game specific constant kG, jG ≥ 1 which depend on how the game is split into a trunk and subgames.\nProof. This follows from a modified version the proof of Theorem 2 of Burch et al. (17), which uses a fixed error and argues by induction on information sets. Instead, we argue by induction on entire public states.\nFor every public state s, let Ns be the number of subgames reachable from s, including any subgame rooted at s. Let Succ(s) be the set of our public states which are reachable from s without going through another of our public states on the way. Note that if s is in the trunk, then every s′ ∈ Succ(s) is in the trunk or is the root of a subgame. Let DTR(s) be the set of our trunk public states reachable from s, including s if s is in the trunk. We argue that for any public state s where we act in the trunk or at the root of a subgame∑\nI∈s\nRT,+full(I) ≤ ∑\ns′∈DTR(s)\n∑ I∈s′ RT,+(I) + TNs E (2)\nFirst note that if no subgame is reachable from s, then Ns = 0 and the statement follows from Lemma 7 of (14). For public states from which a subgame is reachable, we argue by induction on |DTR(s)|.\nFor the base case, if |DTR(s)| = 0 then s is the root of a subgame S, and by assumption there is a Nash Equilibrium subgame strategy σ∗S that has regret no more than E . If we implicitly play σ∗S on each iteration of CFR-D, we thus accrue ∑ I∈sR T,+ full(I) ≤ T E .\nFor the inductive hypothesis, we assume that (2) holds for all s such that |DTR(s)| < k. Consider a public state s where |DTR(s)| = k. By Lemma 5 of (14) we have\n∑ I∈s RT,+full(I) ≤ ∑ I∈s RT (I) + ∑ I′∈Succ(I) RT,+full(I)  = ∑ I∈s RT (I) + ∑ s′∈Succ(s) ∑ I′∈s′ RT,+full(I ′)\nFor each s′ ∈ Succ(s), D(s′) ⊂ D(s) and s 6∈ D(s′), so |D(s′)| < |D(s)| and we can apply the inductive hypothesis to show\n∑ I∈s RT,+full(I) ≤ ∑ I∈s RT (I) + ∑ s′∈Succ(s)  ∑ s′′∈D(s′) ∑ I∈s′′ RT,+(I) + TNs′ E  ≤\n∑ s′∈D(s) ∑ I∈s′ RT,+(I) + T E ∑ s′∈Succ(s) Ns′\n= ∑\ns′∈D(s) ∑ I∈s′ RT,+(I) + T ENs\nThis completes the inductive argument. By using regret matching in the trunk, we ensure RT (I) ≤ ∆ √ AT , proving the lemma for kG = ∆|IT R| √ A and jG = Nroot.\nLemma 7 Given our strategy σ, if the opponent is acting at the root of a public subtree S from a set of actions A, with opponent best response values BVI·a(σ) after each action a ∈ A, then replacing our subtree strategy with any strategy that satisfies the opponent constraints wI = maxa∈A BVI·a(σ) does not increase our exploitability.\nProof. If the opponent is playing a best response, every counterfactual value wI before the action must either satisfy wI = BVI(σ) = maxa∈A BVI·a(σ), or not reach state s with private information I . If we replace our strategy in S with a strategy σ′S such that BVI·a(σ ′ S) ≤ BVI(σ) we preserve the property that BVI(σ′) = BVI(σ).\nTheorem 2 Assume we have some initial opponent constraint values w from a solution generated using at least T iterations of CFR-D, we use at least T iterations of CFR-D to solve each resolving game, and we use a subtree value estimator such that minσ∗S∈NES ∑ I∈IS2 |vσ∗S(I)−vI | ≤\nE , then after d re-solving steps the exploitability of the resulting strategy is no more than (d+ 1)k/ √ T + (2d+ 1)j E for some constants k, j specific to both the game and how it is split into subgames.\nProof. Continuous re-solving begins by solving from the root of the entire game, which we label as subtree S0. We use CFR-D with the value estimator in place of subgame solving in order to generate an initial strategy σ0 for playing in S0. By Lemma 6, the exploitability of σ0 is no more than k0/ √ T + j0 E .\nFor each step of continuous re-solving i = 1, ..., d, we are re-solving some subtree Si. From the previous step of re-solving, we have approximate opponent best-response counterfactual values B̃VI(σi−1) for each I ∈ ISi−12 , which by the estimator bound satisfy | ∑ I∈I\nSi−1 2\nBVI(σi−1)−\nB̃VI(σi−1)| ≤ E . Updating these values at each public state between Si−1 and Si as described in the paper yields approximate values B̃VI(σi−1) for each I ∈ ISi2 which by Lemma 7 can be used as constraints wI,i in re-solving. Lemma 5 with these constraints gives us the bound EXPSiwi,σi−1 + U Si wi,σi−1\n≤ E . Thus by Lemma 4 and Lemma 6 we can say that the increase in exploitability from σi−1 to σi is no more than E + Si ≤ E +ki/ √ T + ji E ≤ ki/ √ T + 2ji E .\nLet k = maxi ki and j = maxi ji. Then after d re-solving steps, the exploitability is bounded by (d+ 1)k/ √ T + (2d+ 1)j E .\nBest-response Values Versus Self-play Values DeepStack uses self-play values within the continuous re-solving computation, rather than the best-response values described in Theorem 2. Preliminary tests using CFR-D to solve smaller games suggested that strategies generated using self-play values were generally less exploitable and had better one-on-one performance against test agents, compared to strategies generated using best-response values. Figure 5 shows an example of DeepStack’s exploitability in a particular river subgame with different numbers of re-solving iterations. Despite lacking a theoretical justification for its soundness, using self-play values appears to converge to low exploitability strategies just as with using best-response values.\nOne possible explanation for why self-play values work well with continuous re-solving is that at every re-solving step, we give away a little more value to our best-response opponent because we are not solving the subtrees exactly. If we use the self-play values for the opponent, the opponent’s strategy is slightly worse than a best response, making the opponent values smaller and counteracting the inflationary effect of an inexact solution. While this optimism could hurt us by setting unachievable goals for the next re-solving step (an increased USw,σ term), in poker-like games we find that the more positive expectation is generally correct (a decreased EXPSw,σ term.)"
    } ],
    "references" : [ {
      "title" : "The ascent of man, Documentary",
      "author" : [ "J. Bronowski" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1973
    }, {
      "title" : "Searching for solutions in games and artificial intelligence",
      "author" : [ "V.L. Allis" ],
      "venue" : "Ph.D. thesis,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1994
    }, {
      "title" : "Measuring the size of large no-limit poker games, Technical Report TR13-01",
      "author" : [ "M. Johanson" ],
      "venue" : "Department of Computing Science, University of Alberta",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2013
    }, {
      "title" : "Polk and team beat Claudico to win $100,000 from Microsoft & The Rivers Casino, Pokerfuse",
      "author" : [ "J. Wood", "Doug" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2015
    }, {
      "title" : "Annual computer poker competition poker GUI client, https://github.com/dmorrill10/acpc poker gui client/tree/v1.2",
      "author" : [ "D. Morrill" ],
      "venue" : null,
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 2012
    } ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Artificial intelligence has seen a number of breakthroughs in recent years, with games often serving as significant milestones. A common feature of games with these successes is that they involve information symmetry among the players, where all players have identical information. This property of perfect information, though, is far more common in games than in real-world problems. Poker is the quintessential game of imperfect information, and it has been a longstanding challenge problem in artificial intelligence. In this paper we introduce DeepStack, a new algorithm for imperfect information settings such as poker. It combines recursive reasoning to handle information asymmetry, decomposition to focus computation on the relevant decision, and a form of intuition about arbitrary poker situations that is automatically learned from selfplay games using deep learning. In a study involving dozens of participants and 44,000 hands of poker, DeepStack becomes the first computer program to beat professional poker players in heads-up no-limit Texas hold’em. Furthermore, we show this approach dramatically reduces worst-case exploitability compared to the abstraction paradigm that has been favored for over a decade.",
    "creator" : "LaTeX with hyperref package"
  }
}