{
  "name" : "1604.03243.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Finding Patterns is Almost Always Hard",
    "authors" : [ "Guiseppe Lancia", "Luke Mathieson", "Pablo Moscato" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 4.\n03 24\n3v 1\n[ cs\n.C C\nWe study the complexity of the problem of searching for a set of patterns that separate two given sets of strings. This problem has applications in a wide variety of areas, most notably in data mining, computational biology, and in understanding the complexity of genetic algorithms. We show that the basic problem of finding a small set of patterns that match one set of strings but do not match any string in a second set is difficult (NP-complete, W[2]hard when parameterized by the size of the pattern set, and APX-hard). We then perform a detailed parameterized analysis of the problem, separating tractable and intractable variants. In particular we show that parameterizing by the size of pattern set and the number of strings, and the size of the alphabet and the number of strings give FPT results, amongst others.\nKeywords: pattern identification, parameterized complexity, computational complexity"
    }, {
      "heading" : "1. Introduction",
      "text" : "Finding patterns in a collection of data is one of the fundamental problems in data mining, data science, artificial intelligence, bioinformatics and many other areas of both theoretical and applied computer science. Accordingly there are a large number of formulations of this problem. In this paper we develop a particular formulation, drawn from two central motivations:\nPreprint submitted to Elsevier April 13, 2016\n1. multiparent recombination in genetic and evolutionary algorithms, and\n2. the construction of explanatory patterns in single-nucleotide polymorphisms related to disease.\nIt should not be construed however that these motivations are limitations on the applicability of the problem we develop and study. As will be seen, the form is a general one that occurs as a fundamental component of many other computational problems."
    }, {
      "heading" : "1.1. Separating Healthy Patterns from Diseased",
      "text" : "A significant portion of bioinformatics and computational medicine efforts are focused on developing diagnostic tools. The identification of explanatory genes, uncovering of biomarkers, metabolic network analysis and protein interaction analysis all have as a key (but not sole) motivation the identification of differential markers of disease and consequently routes to treatment. Consider the following problem as a motivating archetypical example: we have two sets of individuals, healthy and diseased and for each example we are given a string that encodes the single-nucleotide polymorphism (SNPs) states across the two copies of each genome. A SNP has several alleles of which an individual has two. The individual may thus be homozygous in any of the alleles, or heterozygous with any choice of pairs of alleles. It is easy to see that if we can identify patterns of SNPs that separate the healthy from the diseased individuals, we have a source of genetic information that may assist in explaining and treating the disease. Computationally, we may view this as a problem where we have two sets of strings over a fixed alphabet (biologically the number of possible SNP variations is small and limited), and we wish to identify a set of patterns which match the diseased individuals but do not match the healthy individuals (or vice-versa). This problem is even more apparent in its computational form when considering a biologically motivated form of computation, i.e., evolutionary algorithms."
    }, {
      "heading" : "1.2. Patterns in Multiparent Recombination",
      "text" : "The central mechanism for optimisation in Genetic Algorithms (GAs) is the recombination of parent solutions to produce a new child solution which ideally retains the positive aspects of the parents. The mechanism derives from an analogy with sexual reproduction in biological evolution and hence typically combines two existing solutions to produce the offspring. In the optimisation setting however, there’s no conceptual reason for this restriction. Given that recombination can be viewed as a local move in the search space from one individual solution to another as mediated by a third individual\nsolution, a natural generalisation of this is to employ multiple parents in the hope of further refining the components of the solution that promote quality, while producing new solutions that effectively cover the search space. The central theoretical formalisation for describing this process is that of schemata1. An individual solution in a (simple) GA is described by an array, which we can represent as a string, of length n over a given alphabet. A schema is a string of length n over the same alphabet augmented with a special “wild card” character ∗. A schema then represents a set of strings which are identical in those positions where a character from the alphabet is specified, but may take either value at the wild card positions. A schema can then also be thought of as representing a portion of the search space. The preservation of desirable shared characteristics of two parent individuals can then be viewed as the problem of defining suitable a schema. The child individual can then be generated from this schema with the wild cards replaced in whichever manner is chosen. Thus we can use schema to model the basic operation of genetic recombination operators."
    }, {
      "heading" : "1.3. Computational Complexity Considerations",
      "text" : "Of course we can easily generalise this idea to multi-parent recombination (i.e. more than two parents) and indeed multi-child recombination. When considering simply a set of parents from which we wish to generate a set of children, constructing schema that are compatible with the parents is straighforward. A single schema that is a string of n ∗ symbols would suffice as a trivial solution and the natural solution where for each position, if all the parents agree on the same symbol, the schema has that symbol and ∗ otherwise also provides a simple solution. However in these cases it is reasonably easy to see that the schemata generated can easily be underspecified, leading to a loss of useful information, rendering the recombination ineffective. One solution to this problem is to ask for a small set of schemata that are compatible with the parents, but are incompatible with a set of forbidden strings – akin to the list of forbidden elements in Tabu search. We formalise this problem and examine its complexity. In most cases this problem turns out to be hard. Unsurprisingly this problem is NP-hard. We naturally then consider the problem from a Parameterized Complexity perspective. The problem has a rich parameter ecology and also provides an interesting example of a non-graph theoretic problem. Unfortunately for many parameterizations the problem turns out to be hard in this setting as well. The\n1We use the third declension neuter form of schema, as it matches better the Greek\nroots of the word.\nnatural parameterization by the number of desired schemata is W[2]-hard. Even if we take the length of the strings as the parameter, the problem is para-NP-complete. It is also inapproximable and for some cases we obtain parameterized inapproximability results as well. The only case for which we are able to obtain fixed-parameter tractability relies on a small number of input strings which have a limited number of symbols which are different from a given “base” symbol."
    }, {
      "heading" : "1.4. Related Work",
      "text" : "The identification of patterns describing a set of strings forms a well studied family of problems with a wide series of applications. Although, as best as we can determine, the precise problems we studied here have not yet been considered, a number of interesting related problems are explored in the literature. We present here a selection of some of the more relevant and interesting results, however these can at best form a basis for further exploration by the interested reader. One of most immediately similar variants is that where pattern variables are allowed. In contrast to the work here, these variables can act as substrings of arbitrary length. Keans and Pitt [12] give a family of polynomial time algorithms for learning the language generated by a single such pattern with\na given number k of pattern variables. Angluin [1] studies the inverse problem of generating a pattern, with the central result a poylnomial time algorithm for the case where the pattern contains a single pattern variable. We note a central difference here is the repeated use of variables, allowing the same undefined substring to be repeated. The properties of these pattern languages have since been studied in some detail, far beyond the scope of this paper. Bredereck, Nichterlein and Niedermeier [4] employ a similar, but not identical, formalism to that employed here, but study the problem of taking a set of strings and a set of patterns and determining whether the set of strings can be altered to match the set of patterns. We note in particular though that their definition of matching differs from our definition of compatibility in that a string matches a pattern iff the string has the special symbol ⋆ exactly where the pattern does. They show this problem to be NP-hard, but in FPT when parameterized by the combined parameter of the number of patterns and the number of strings. They also present an ILP based implementation and computational results. Using a similar basis, excepting that the special ⋆ symbol in a pattern now matches any symbol in a string, Bredereck et al. [3] examine forming teams, i.e., mapping the set of strings to the set of patterns in a consistent manner. They give a series of classification results, with the problem mostly being intractible, but in FPT for the number of input strings, the number of different input strings and the combined parameter of alphabet size with the length of the strings."
    }, {
      "heading" : "2. Preliminaries and Definitions",
      "text" : "We now give the relevant definitions for the complexity analysis that follows. In the reductions we use the Dominating Set and Vertex Cover problems. As these problems are well known, we do not define them here, however we note the following key well-known classification results:\n• Dominating Set is NP-complete, O(logn) − APX-hard and W[2]complete when parameterized by k, the size of the dominating set.\n• Vertex Cover is NP-complete and APX-hard, and remains NPcomplete when the input is a planar graph [10].\n• Set Cover is W[2]-complete when parameterized by the size of the set cover.\n• k-Feature Set is W[2]-complete when parameterized by the size of the feature set [7].\nThe graphs taken as input for these problems are simple, undirected and unweighted. To assist with notation and indexing, we take the vertex set V (G) of a graph G to be the set {1, . . . , n}. The edge set E(G) is then a set of pairs drawn from V (G) and we denote the edge between vertices i and j by ij (= ji). We also employ a parameterized version of the Model Checking problem, which takes as input a finite structure and a logical formula and asks the question of whether the structure is a model of the formula, i.e. whether there is a suitable assignment of elements of the universe of the structure to variables of the formula such that the formula evaluates to true under that assignment. The parameter is the length of the logic formula. While we informally introduce the finite structural elements as needed, we briefly describe here the fragments of first-order logic we employ. Let Σ0 = Π0 be the set of unquantified boolean formulae. The classes Σt and Πt for t > 0 can be defined recursively as follows:\nΣt = {∃x1 . . .∃xkϕ | ϕ ∈ Πt−1}\nΠt = {∀x1 . . .∀xkϕ | ϕ ∈ Σt−1}\nThe class Σt,u is the subclass of Σt where each quantifier block after the first existential block has length at most u. We note that trivially Πt−1 ⊂ Σt. We note that these classes are specified in prenex normal form, and are, in general, not robust against boolean combinations of formulae. An analog of the Σ classes is Σ∗t,u. Let Θ0,u be the set of quantifier free formulae, and Θt,u for t > 0 be the set of boolean combinations of formulae where the leading quantifier block is existential and quantifies over a formula in Θt−1,u. We can deal with leading universal quantification by the normal expedient of the introduction of a trivial existential block. Note also that each quantifier block is of length at most u, including the leading block. Then Σ∗t,u is the class of formulae of the form ∃x1, . . .∃xkϕ where ϕ ∈ Θt−1,u, where k may be greater than u. Thus we refer to the Model Checking problem as MC(Φ) where Φ is the first-order fragment employed. In the parameterized setting, MC(Σt,u) is W[t]-complete for every u ≥ 1, and MC(Σ∗t,u) is W\n∗[t]-complete for every u ≥ 1. The W∗-hierachy is the hierachy analagous to the W-hierarchy obtained from using MC(Σ∗t,u) as the complete problem instead of MC(Σt,u). While it is known that W[1] = W∗[1] and W[2] = W∗[2], for t ≥ 3, the best known containment relationship is W[t] ⊆ W∗[t] ⊆ W[2t− 2]. For more detail on these results and the full definitions relating to first-order logic and structures we refer the reader to [9]. In several of our intractability results we make use of the class para-NP, and a useful result due to Flum and Grohe with a detailed explanation in [9]\n(presented as Corollary 2.16). para-NP is the direct parameterized complexity translation of NP, where we replace “polynomial-time” with “fixed-parameter tractable time” in the definition. Flum and Grohe’s result states that if, given a parameterized problem (Π, κ), the classical version of the problem Π is NPcomplete for at least one fixed value of κ, then (Π, κ) is para-NP-complete. As may be expected, FPT = para-NP if and only if P = NP, thus para-NPcompleteness is strong evidence of intractability. We also employ the W∗hierarchy [5, 9]. This is a parameterized hierarchy which takes into account the boolean combinations of quantified first-order formulae, but is otherwise similar to the the more usual W-hierarchy. The other parameterized complexity theory employed is more standard, thus for general definitions we refer the reader to standard texts [8, 9]. We denote parameterized reductions by ≤FPT and polynomial-time manyone reductions by ≤P .\nDefinition 2.1 (Pattern). A pattern is a string over an alphabet Σ and a special symbol ∗.\nGiven a string s ∈ Σ∗ and an integer i, we denote the ith symbol of s by s[i].\nDefinition 2.2 (Compatible). A pattern p is compatible with a string g, denoted p → g, if for all i such that p[i] 6= ∗ we have g[i] = p[i]. If a pattern and string are not compatible, we write p 6→ g. We extend this notation to sets of strings, writing p → G to denote ∀g ∈ G, p → g and P → G for ∀g ∈ G∃p ∈ P, p → g.\nDefinition 2.3 (G-B-Separated Sets). A set P of patterns G-B-separates an ordered pair (G,B) of sets of strings, written P → (G,B) if\n• P → G, and\n• for every b ∈ B and p ∈ P we have p 6→ b.\nThus we can state the central problem for this paper:\nPattern Identification: Instance: A finite alphabet Σ, two disjoint sets G,B ⊆\nΣn of strings and an integer k.\nQuestion: Is there a set P of patterns such that |P | ≤ k and P → (G,B)?\nThe complexity analysis of the problem in the parameterized setting leads to the definition of a second, subsidiary problem which allows a convenient examination of sets of strings which are very similar.\nDefinition 2.4 (Small String). A string s over an alphabet Σ is d-small if, given an identified symbol σ ∈ Σ, for exactly d values of i, p[i] = σ. We call σ the base symbol. A set of strings S is d-small if, given a fixed base symbol all strings in S are d-small.\nThis restriction on the structure of the input gives further insight into the complexity of Pattern Identification and is key to some of the tractability results in Section 4. For convenience we phrase a restricted version of the Pattern Identification problem:\nPI with Small Strings: Instance: An alphabet Σ, two disjoint d-small sets\nG,B ⊆ Σn, an integer k.\nQuestion: Is there a set P of patterns with |P | ≤ k such that P → (G,B)?\nFrom the perspective of multi-parent recombination, minimising the number of wildcard symbols in each pattern is also an interesting objective:\nPI with Large Patterns: Instance: An alphabet Σ, two disjoint sets G,B ⊆ Σn,\nintegers k and b.\nQuestion: Is there a set P of patterns with |P | ≤ k such that P → (G,B) and for each p ∈ P the number of ∗ symbols in p is at most r?\nWe implicitly define the obvious intersection of the two restricted problems, PI with Large Patterns and Small Strings. From a combinatorial perspective, the inverse problem is also interesting:\nPI with Small Patterns: Instance: An alphabet Σ, two disjoint sets G,B ⊆ Σn,\nintegers k and b.\nQuestion: Is there a set P of patterns with |P | ≤ k such that P → (G,B) and for each p ∈ P the number of non-∗ symbols in p is at most s?"
    }, {
      "heading" : "3. Hard Cases of the Pattern Identification Problem",
      "text" : "We first examine the intractable cases of the Pattern Identification problem. This narrows down the source of the combinatorial complexity of the problem.\nTheorem 3.1. Pattern Identification is W[2]-hard when parameterized by k, even if |Σ| = 2 and |B| = 1.\nLemma 3.2. Dominating Set ≤FPT Pattern Identification.\nProof. Let (G, k) be an instance of Dominating Set. Let n = |V (G)| and assume V (G) = {1, . . . , n}. We construct an instance (Σ, G,B, k) as follows:\n1. Σ = {1, 0}, 2. G = {g1, . . . , gn} where for each i, gi ∈ Σ n where for every j, gi[j] = 1\nif ij ∈ E(G) or i = j and gi[j] = 0 otherwise,\n3. B = {0n}.\nClaim 3.3. If (G, k) is a Yes instance of Dominating Set then (Σ, G,B, k) is a Yes instance of Pattern Identification.\nLet D ⊆ V (G) with |D| ≤ k be the witness that (G, k) is a Yes instance. We can construct a witness set of patterns P with |P | = |D| such that P → (G,B). For each i ∈ D, we create a pattern pi where pi[i] = 1 and pi[j] = ∗ for all j 6= i. As D is a dominating set, for every vertex j ∈ V (G) there is a vertex i ∈ D such that ij ∈ E(G). Then for string gj ∈ G, pattern pi is compatible with gj as by construction gj[i] = 1. Therefore for every string g ∈ G there exists p ∈ P such that p → g. Moreover there is no p ∈ P such that p → b where b ∈ B. As B consists of the single string b = 0n and for each p ∈ P exactly one element is neither 0 nor ∗ there is one position where the pattern does not match b. Thus (Σ, G,B, k) is a Yes instance.\nClaim 3.4. If (Σ, G,B, k) is a Yes instance of Pattern Identification then (G, k) is a Yes instance of Dominating Set\nLet P with |P | ≤ k be the witness set of patterns that (Σ, G,B, k) is a Yes instance. Inductively, we may assume that every p ∈ P is compatible with at least one element of G, if not, P \\ {p} constitutes an alternate witness. First we note that no p ∈ P can consist of only ∗ and 0 symbols, as this would be compatible the single element of B. Therefore each p ∈ P has at least one i such that p[i] = 1. Consider a p ∈ P , and the corresponding set of vertices Vp (i.e. each position i where p[i] = 1). Let gj ∈ G be a string such that p → gj. By construction for every i ∈ Vp, ij ∈ E(G). Let Vp→g be the set of vertices corresponding to the set Gp ⊆ G where p → Gp. Each vertex j ∈ Vp→g is adjacent (or identical) to every vertex in Vp. Thus we may select arbitrarily a single vertex from Vp to be in the dominating set D.\nThus we have D with |D| = |P | ≤ k, where every vertex in V (G) is adjacent (or identical) to some vertex in D. Therefore (G, k) is a Yes instance. The construction can be clearly performed in fpt time (in fact, polynomial time), and the lemma follows.\nProof of Theorem 3.1. The theorem follows immediately from Lemma 3.2.\nThe structure of the reduction then gives the following:\nCorollary 3.5. PI with Small Patterns is W[2]-complete when parameterized by k and NP-complete even when s = 1, |Σ| = 2 and |B| = 1.\nProof. The W[2]-hardness is apparent from the proof of Lemma 3.2 (in fact the restriction would make the proof simpler). To show containment in W[2], we reduce PI with Small Patterns to MC(Σ2,1). The first-order structure is equipped with four unary relations N , Σ, G and B and a binary function symbol C. Each string is represented by an integer, according to an arbitrary fixed ordering. Gi is true if string i is in G, Bi is true if string i is in B. Σσ is true if σ ∈ Σ and Ni is true if i ∈ N. The function C : N×N → Σ is defined Cij = σ if σ is the jth symbol of string i. We now provide the first-order formula expressing PI with Small Patterns:\n∃i1,1, . . . , ik,s, c1,1, . . . , ck,s∀j(( ∧\nl∈[k],b∈[s]\nNil,b)∧\n( ∧\nl∈[k],b∈[s]\nΣcl,b)∧\n(Gj → ( ∨\nl∈[k]\n( ∧\nb∈[s]\nCjil,b = cl,b)))∧\n(Bj → ( ∧\nl∈[k]\n( ∨\nb∈[s]\nCjil,b 6= cl,b))))\nThe formula states that a solution to PI with Small Patterns consists of k sets of s symbols along with positions such that for each string in G, for at least one set of symbols, the string is compatible and for each string in B no set of symbols is compatible. Containment in NP can be demonstrated by the usual polynomial verification approach (indeed in much the same format as the above formula).\nCorollary 3.6. Pattern Identification has no constant factor fptapproximation algorithm and no c · logn polynomial time approximation algorithm for any c, even when |Σ| = 2.\nProof. As Dominating Set has no constant factor fpt-approximation [6] and no c · log n polynomial time approximation [13] and the reduction of Lemma 3.2 is a strict reduction polynomial time reduction, the corollary follows.\nGiven the construction in the proof of Lemma 3.2, we can deduce that one source of complexity might be the freedom in the alphabet and the structure of the strings. We demonstrate that restricting these parameters is fruitless from a computational complexity perspective.\nCorollary 3.7. PI with Small Strings is NP complete even when |Σ| = 2, d = 4 and |B| = 1.\nProof. As Dominating Set is NP-complete on planar graphs of maximum degree 3 [10], the number of 1s in each string in the construction of the proof of Lemma 3.2 is at most 4.\nThis result also demonstrates the following:\nLemma 3.8. PI with Large Patterns and Small Strings and PI with Large Patterns are both NP-complete even when |Σ| = 2, d = 3, r = 6 and |B| = 1.\nProof. Following Corollary 3.7, we can see from the construction given in the proof of Lemma 3.2 that for each p ∈ P , instead of setting p[i] = ∗ for each i not in the dominating set, we can choose r to be six, and set p[i] := 1 if i is in the dominating set, p[j] = ∗ for the at most two values of j such that ij ∈ E(G) and the at most four values of j at distance two from i, and p[l] = 0 for all other l ∈ {1, . . . , n}. For the reverse argument, we have similar conditions as before, at least one symbol of each pattern must be a 1 and at most three can be 1s. With at most six ∗ symbols, the pattern is compatible with all the strings that the corresponding vertex dominates, and all other symbols in these strings are 0.\nCorollary 3.9. The following are true:\n1. PI with Large Patterns and Small Strings is para-NP-complete when parameterized by |Σ|+ d+ r + |B|.\n2. PI with Large Patterns is para-NP-complete when parameterized by |Σ|+ r + |B|.\n3. PI with Small Patterns and Small Strings is para-NP-complete when parameterized by |Σ|+ d+ s+ |B|.\n4. PI with Small Patterns is para-NP-complete when parameterized by |Σ|+ s+ |B|.\nProof. The result follows from Lemma 3.8, Corollary 3.5 and Corollary 2.16 from [9].\nWe note that Dominating Set is in FPT for graphs of bounded degree, so we do obtain a W[2]-hardness result. However we can tighten this result a little further:\nTheorem 3.10. Pattern Identification is NP-complete and APX-hard even when Σ = {0, 1} and all strings have at most two symbols as 1 (equiv. at most two symbols as 0) and |B| = 1.\nLemma 3.11. Vertex Cover ≤P Pattern Identification.\nProof. Given an instance of Vertex Cover with V (G) = {1, . . . , n}, we construct an instance (Σ, G,B, k) of Pattern Identification as follows:\n1. Σ = {0, 1}. 2. G = {gij | ij ∈ E(G)} with gij ∈ Σ n where gij[i] = gij[j] = 1 and\ngij[u] = 0 for u 6= i, j.\n3. B = {0n}.\nClearly this construction can be performed in polynomial time.\nClaim 3.12. If (G, k) is a Yes instance of Vertex Cover then (Σ, G,B, k) is a Yes instance of Pattern Identification.\nLet V ′ ⊆ V (G) where |V ′| ≤ k be the witness that (G, k) is a Yes instance of Vertex Cover. We construct a set of patterns P with |P | = |V ′| that is a solution for (Σ, G,B, k) where for each i ∈ V ′ there is a pattern pi ∈ P with pi[i] = 1 and pi[j] = ∗ for j 6= i. For each edge ij ∈ E(G), either i ∈ V ′ or j ∈ V ′ (or both). Therefore for the string gij corresponding to ij, we have either pi ∈ P or pj ∈ P such that pi → gij or pj → gij. Hence P → G. Moreover there is no pi ∈ P such that pi → b where b is the single element of B as each pi, by construction, contains a 1, whereas b consists of only 0s. Therefore (Σ, G,B, k) is a Yes instance of Pattern Identification.\nClaim 3.13. If (Σ, G,B, k) is a Yes instance of Pattern Identification then (G, k) is a Yes instance of Vertex Cover.\nLet P with |P | ≤ k be the set of patterns witnessing the fact that (Σ, G,B, k) is a Yes instance of Pattern Identification. We may assume without loss of generality that for every p ∈ P , there exists some g ∈ G such that p → g. Each p ∈ P must contain at least one 1, otherwise p → b where b is the single element of B. No p ∈ P can contain more than two 1s, as there exists g ∈ G such that p → g, and every such g has exactly two 1s. We note that if a pattern p has two 1s, then there is exactly one g ∈ G such that p → g.\nLet P1 ⊆ P be the set of patterns with exactly one 1 and P2 ⊆ P be the set of patterns with exactly two 1s. We have P1 ∪ P2 = P . We construct a vertex cover V ′ ⊆ V (G) with |V ′| ≤ |P | as follows:\n1. for each p ∈ P1 add i to V ′ where p[i] = 1, 2. for each p ∈ P2 where p[i] = p[j] = 1, arbitrarily add one of i or j to V ′.\nConsider every edge ij ∈ E(G), then for the corresponding gij ∈ G there exists a p ∈ P such that p → gij . As each p has at least one 1, this 1 must be at position i or j (or both). Therefore i or j is in V ′ (or perhaps both), therefore V ′ forms a valid vertex cover for G.\nProof of Theorem 3.10. The NP-hardness follows from Lemma 3.11. The containment in NP follows from the usual verification algorithm. The APX-hardness follows as the reduction of Lemma 3.11 is strict and Vertex Cover is APX-hard [11].\nFinally, as restricting the alphabet did not reduce the complexity, we consider the case where the strings themselves are short. Again the problem is hard, but we note that to achieve this reduction we relax the bound on Σ (or in Parameterized Complexity terms, it is no longer a parameter).\nTheorem 3.14. PI with Small Strings is NP-complete even when n = 4, d = 4 and |B| = 1.\nLemma 3.15. Planar Vertex Cover ≤P PI with Small Strings even when the length of strings is restricted to 4.\nProof. Let (G, k) be an instance of Planar Vertex Cover. We assume without loss of generality that V (G) = {1, . . . , n}. As G is planar, we can compute a proper 4-colouring in polynomial time [2]. Let C : V (G) → {1, 2, 3, 4} be such a colouring. We construct an instance (Σ, G,B, k′, d) of PI with Small Strings as follows:\n1. Σ = {σ1, . . . , σn+1}. 2. G = {gij | ij ∈ E(G)} where for k ∈ {1, . . . , 4} we set\ngij[k] :=\n\n \n \nσi if C(i) = k\nσj if C(j) = k\nσn+1 otherwise.\n3. B = {σ4n+1}. 4. d = 4.\nWe note that as C is a proper colouring, C(i) 6= C(j) for any ij ∈ E(G). Moreover for i ∈ V (G), σi only appears as the C(i)\nth symbol in any string. The construction can clearly be performed in polynomial time.\nClaim 3.16. If (G, k) is a Yes instance of Planar Vertex Cover then (Σ, G,B, k, d) is a Yes instance of PI with Small Strings.\nLet V ′ ⊆ V (G) with |V ′| ≤ k be a vertex cover witnessing that (G, k) is a Yes instance of Planar Vertex Cover. We construct a set P with |P | = |V ′| ≤ k of patterns that forms a solution for (Σ, G,B, k, d) in the following manner: for each i ∈ V ′, we add the pattern pi to P where pi[C(i)] = σi and all other symbols in pi are ∗. No pattern in P is compatible with the singleton element of B, as each has a symbol σi with 1 ≤ i ≤ n. For every edge ij ∈ E(G), at least one of i and j is in V ′. Without loss of generality assume that i ∈ V ′. By construction the string gij is compatible with the pattern pi ∈ P , therefore every string in G is compatible with some pattern in P .\nClaim 3.17. If (Σ, G,B, k, d) is a Yes instance of PI with Small Strings then (G, k) is a Yes instance of Planar Vertex Cover.\nLet P with |P | ≤ k be a set of patterns such that P → (G,B). As before we may assume that P is minimal in the sense that each pattern is compatible with some string in G. Each p ∈ P must have at least one symbol drawn from the set {σ1, . . . , σn}, otherwise p → B. No pattern p ∈ P can have more than two symbols from {σ1, . . . , σn}, otherwise p 6→ G. As before, we partition P into P1, the subset of patterns with one symbol from {σ1, . . . , σn}, and P2, the subset of patterns with two symbols from {σ1, . . . , σn}. We construct a vertex cover V ′ ⊆ V (G) for G with |V ′| ≤ |P | ≤ k as follows:\n• for each p ∈ P1 add i to V ′ if p[C(i)] = σi,\n• for each p ∈ P2 where p[C(j)] = σj and p[C(i)] = σi, arbitrarily add either i or j to V ′.\nConsider every edge ij ∈ E(G). The string gij is compatible with some pattern p ∈ P , therefore at least one of i and j is in V ′, thus V ′ forms a proper vertex cover for G.\nProof of Theorem 3.14. The construction used in the proof of Lemma 3.15 has the required structural properties. Again containment in NP is apparent from the usual verification algorithm techniques.\nCorollary 3.18. PI with Small Strings is para-NP-complete when parameterized by n + d+ |B|.\nProof. The corollary follows from Theorem 3.10 and Corollary 2.16 from [9]."
    }, {
      "heading" : "3.1. Containment",
      "text" : "Although the W[2]-hardness reduction is quite direct, containment of Pattern Identification when parameterized by k is not apparent. In fact it is not clear that the problem lies in W[P] or even XP. As the nonparameterized version of the problem is NP-complete, it is at least contained in para-NP. For PI with Small Patterns we have shown containment in W[2]. In contrast, for PI with Large Patterns we can show containment in W∗[5].\nTheorem 3.19. PI with Large Patterns ∈ W∗[5] when parameterized by k + r.\nProof. We reduce the problem to MC(Σ∗5,1), which is complete for W ∗[5]. We use the same first-order structure as in the proof of Corollary 3.5, and give a suitable first-order formula:\n∃s1, . . . , sk, i1,1, . . . , ik,r∀j (Gj → (∃l( ∨\nc∈[k]\nl = sc ∧ ∀b(Cjb = Clb ∨ ∨\nd∈[r]\nb = ic,d))))∧\n(Bj → (∀l( ∧\nc∈[k]\nl = sc ∧ ∃b(Cjb 6= Clb ∧ ∧\nd∈[r]\nb 6= ic,d))))∧\n( ∧\nc∈[k]\n(Nsc ∧ ∧\nd∈[r]\nNic,d))\nThe formula picks out k indices of strings (implicitly in G, as a choice of a string from B will fail) and for each of these, r indices which will be the location of the ∗ symbols in the patterns. For each index, if the index selects a string in G, then one of the patterns is compatible with the string, if it selects a string in B, no pattern is compatible with the string. We note that the B clause is in Π2,1, and hence Σ3,1, giving the final bound of Σ ∗ 5,1.\nThis also places PI with Large Patterns somewhere between W[5] and W[8] [5]. We note that the above formula could be converted into prenex form, giving a tighter containment, however the central observation is that it will be greater than W[2], in contrast to the hardness result and the containment of PI with Small Patterns."
    }, {
      "heading" : "4. Tractable Cases of Pattern Identification Problem",
      "text" : "Guided by the results of Section 3, we identify the following cases where the Pattern Identification problem is tractable.\nTheorem 4.1. PI with Small Strings is fixed-parameter tractable when parameterized by d+ |G|+ |B|, with a kernel of size O(d · (|G|+ |B|)2) in both the total number of symbols across all strings and the size of the alphabet.\nProof. As G and B are d-small, there can be at most d · (|G|+ |B|) positions where any pair of strings in G∪B differ, that is, every other position must be the base symbol uniformly across all strings. The positions where every string is identical cannot be of use in generating patterns, thus we may ignore these positions. This gives restricted sets G′ and B′ of size |G′|+ |B′| ≤ |G|+ |B| containing strings of length at most d · (|G|+ |B|). Furthermore this restricts the number of symbols used from Σ to at most d · (|G| + |B|)2. Thus we can restrict our alphabet to these symbols alone, denote this new alphabet by Σ′. This gives our required kernel size. The initial determination of which positions to ignore can be computed in O(n ·(|G|+ |B|)) time, thus the kernelization can be performed in polynomial time.\nTheorem 4.2. Pattern Identification is fixed-parameter tractable when parameterized by |Σ|+ n.\nProof. Taking the alphabet size and the string length as a combinded parameter gives an immediate kernelization. The total number of strings of length n over alphabet Σ is |Σ|n. Thus |G|+ |B| ≤ |Σ|n.\nTheorem 4.3. Pattern Identification is fixed-parameter tractable when parameterized by k + n.\nProof. Let (Σ, G,B, k) be an instance of Pattern Identification. If (Σ, G,B, k) is a Yes instance, by definition, there exists a P with |P | ≤ k such every string g ∈ G must be compatible with at least one p ∈ P . Therefore given g, the compatible p must consist of, at each position, either the ∗ symbol, or the symbol at the same position in g. This gives a direct bounded search tree algorithm for Pattern Identification. At each node in the tree we select an available g from G. We then branch on all possible patterns p that are compatible with g, with a new set G := G \\ {h ∈ G | p → h}. If there is a b ∈ B such that p → b, then we terminate the branch. If we reach depth\nk and G 6= ∅, we terminate the branch. Otherwise if at any point we have G = ∅, we answer Yes. Obviously the depth of the search tree is explicitly bounded by k. The branching factor is equal to the number of patterns compatible with a string of length n, which is 2n. The adjustment of G and checks against B at each node individually take O(n) time, giving O((|G|+ |B|) ·n) time at each node. Combined the algorithm takes O(2kn · (|G|+ |B|) · n) time, and the theorem follows.\nTheorem 4.4. PI with Large Patterns and Small Strings is fixedparameter tractable when parameterized by k + Σ + d+ r + |B|.\nProof. As each pattern can have at most r ∗ symbols, every other symbol in each pattern is fixed. Thus each pattern is compatible with |Σ|r strings. This limits the number of strings in G to k · |Σ|r. The tractability then follows from Theorem 4.1."
    }, {
      "heading" : "5. Discussion",
      "text" : ""
    }, {
      "heading" : "5.1. Ties to Other Problems",
      "text" : "The Pattern Identification problem, as would be expected, has ties to other problems that (can) model the general search for patterns that separate two sets of data. These ties also illustrate some features of the computational complexity of the problem."
    }, {
      "heading" : "5.1.1. Set Covering",
      "text" : "When the length n of the strings is small, Pattern Identification can be easily reduced to Set Cover. Given an instance (Σ, G,B, k) of Pattern Identification, we can generate the set P of all patterns that are compatible with some string in G. We know that |P | ≤ |G| · 2n. From P we remove any pattern that is compatible with a string in B. Let P ′ be the set thus obtained. For each p ∈ P ′, let sp = {g ∈ G | p → g}, and let S = {sp | p ∈ P\n′}. Taking G as the base set, (G, S, k) forms an instance of Set Cover (parameterized by k). This leads to the following theorem:\nTheorem 5.1. Pattern Identification ∈ W[2] when n ≤ f(k) · log |I| where |I| is the overall size of the instance and f(k) is a computable function of the parameter.\nProof. The reduction above is a parameterized reduction if 2n ∈ O(g(k) · |I|c) for some computable function g.\nIt is not clear that we retain W[2]-hardness in this case however, so we unfortunately do not obtain a W[2]-completeness result."
    }, {
      "heading" : "5.1.2. Feature Set",
      "text" : "The k-Feature Set problem bears a strong resemblence to the Pattern Identification problem, except in the k-Feature Set case, the problem asks for a set of features that separate the “good” examples from the “bad” rather than a set of patterns. In fact, given a feasible solution for one problem, we can construct a feasible (but not necessarily optimal) solution to the other. Given a set I = {i1, . . . , ik} of indices of columns forming a feature set, we can construct a set of patterns that separates G and B as follows: for each g ∈ G, let pg be the pattern where pg[i] = g[i] if i ∈ I and pg[i] = ∗ otherwise. We note that this gives a set of small patterns (i.e., s = k), however the number of patterns may be as large as |G|. Conversely, given a set of patterns P with at most s non-∗ symbols in each pattern, the set I = {i ∈ [n] | ∃p ∈ P (p[i] 6= ∗)} forms a feature set. Again we note that the size of the feature set may be as large as |G| · s. If we consider a variant of PI with Small Patterns where we relax the constraint on the number of patterns in the solution, it is easy to see that this problem is inW[2]. This suggests that the solution size plays a significant role in raising the complexity of the problem from a parameterized perspective."
    }, {
      "heading" : "6. Conclusion and Future Directions",
      "text" : "There are a number of open complexity questions prompted by this paper, three of which we think are particularly interesting. The central question is of course the precise classification of Pattern Identification. Although PI with Small Patterns is W[2]-complete, the general problem is only W[2]-hard, and the containment of PI with Large Patterns simply gives a loose upper bound, although does suggest that the problem is harder than PI with Small Patterns. The problem, intuitively, also shares some similarities with p-Hypergraph(Non)-Dominating-Set which is W[3]-complete [5]. p-ColoredHypergraph-(Non)-Dominating-Set however is W∗[3]-complete [5] and appears “harder” than Pattern Identification, hence we conjecture:\nConjecture 6.1. Pattern Identification is W[3]-complete when parameterized by k.\nThere are also some interesting parameterizations for which the complexity remains open. We (optimistically) conjecture the following:\nConjecture 6.2. PI with Small Strings is fixed-parameter tractable when parameterized by k + |Σ|+ d.\nConjecture 6.3. PI with Large Patterns and Small Strings is fixed-parameter tractable when parameterized by k + d+ r."
    }, {
      "heading" : "7. Acknowledgements",
      "text" : "PM acknowledges funding of his research by the Australian Research Council (ARC, http://www.arc.gov.au/) grants Future Fellowship FT120100060 and Discovery Project DP140104183."
    }, {
      "heading" : "8. References",
      "text" : ""
    } ],
    "references" : [ {
      "title" : "Finding patterns common to a set of strings",
      "author" : [ "Dana Angluin" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1980
    }, {
      "title" : "Every Planar Map is Four- Colorable, volume 98 of Contemporary Mathematics",
      "author" : [ "Kenneth Appel", "Wolfgang Haken" ],
      "venue" : "American Mathematical Society, Providence, RI,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1989
    }, {
      "title" : "Using patterns to form homogeneous teams",
      "author" : [ "Robert Bredereck", "Thomas Köhler", "André Nichterlein", "Rolf Niedermeier", "Geevarghese Philip" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2015
    }, {
      "title" : "An analysis of the Whierarchy",
      "author" : [ "Yijia Chen", "Jörg Flum", "Martin Grohe" ],
      "venue" : "The Journal of Symbolic Logic,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2007
    }, {
      "title" : "The k-Feature Set problem is W[2]complete",
      "author" : [ "Carlos Cotta", "Pablo Moscato" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2002
    }, {
      "title" : "Fundamentals of Parameterized Complexity",
      "author" : [ "Rodney G. Downey", "Michael R. Fellows" ],
      "venue" : "Texts in Computer Science. Springer,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2013
    }, {
      "title" : "Parameterized Complexity Theory. Texts in Theoretical Computer Science",
      "author" : [ "Jörg Flum", "Martin Grohe" ],
      "venue" : "An EATCS Series. Springer,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2006
    }, {
      "title" : "Computers and Intractability – A Guide to the Theory of NP–completeness",
      "author" : [ "M.R. Garey", "D.S. Johnson" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1979
    }, {
      "title" : "Some optimal inapproximability results",
      "author" : [ "J. H̊astad" ],
      "venue" : "In Proceedings of the 29th ACM Symposium on the Theory of Computing (STOC),",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1997
    }, {
      "title" : "A polynomial-time algorithm for learning k–variable pattern languages from examples",
      "author" : [ "Michael Kearns", "Leonard Pitt" ],
      "venue" : "In Proceedings of the 2nd Annual ACM Workshop on Computational Learning Theory,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1991
    }, {
      "title" : "A sub-constant error-probability low-degree test, and a sub-constant error-probability PCP characterization of NP",
      "author" : [ "Ran Raz", "Shmuel Safra" ],
      "venue" : "In Proceedings of the 29th ACM Symposium on the Theory of Computing (STOC),",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "We show that the basic problem of finding a small set of patterns that match one set of strings but do not match any string in a second set is difficult (NP-complete, W[2]hard when parameterized by the size of the pattern set, and APX-hard).",
      "startOffset" : 168,
      "endOffset" : 171
    }, {
      "referenceID" : 1,
      "context" : "k + |Σ| + |B| W[2]-hard 3.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 1,
      "context" : "1 k + |Σ| + s+ |B| W[2]-complete 3.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 1,
      "context" : "natural parameterization by the number of desired schemata is W[2]-hard.",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 9,
      "context" : "Keans and Pitt [12] give a family of polynomial time algorithms for learning the language generated by a single such pattern with",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 0,
      "context" : "Angluin [1] studies the inverse problem of generating a pattern, with the central result a poylnomial time algorithm for the case where the pattern contains a single pattern variable.",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 2,
      "context" : "[3] examine forming teams, i.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "• Dominating Set is NP-complete, O(logn) − APX-hard and W[2]complete when parameterized by k, the size of the dominating set.",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 7,
      "context" : "• Vertex Cover is NP-complete and APX-hard, and remains NPcomplete when the input is a planar graph [10].",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 1,
      "context" : "• Set Cover is W[2]-complete when parameterized by the size of the set cover.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 1,
      "context" : "• k-Feature Set is W[2]-complete when parameterized by the size of the feature set [7].",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 4,
      "context" : "• k-Feature Set is W[2]-complete when parameterized by the size of the feature set [7].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 0,
      "context" : "While it is known that W[1] = W[1] and W[2] = W[2], for t ≥ 3, the best known containment relationship is W[t] ⊆ W[t] ⊆ W[2t− 2].",
      "startOffset" : 24,
      "endOffset" : 27
    }, {
      "referenceID" : 0,
      "context" : "While it is known that W[1] = W[1] and W[2] = W[2], for t ≥ 3, the best known containment relationship is W[t] ⊆ W[t] ⊆ W[2t− 2].",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 1,
      "context" : "While it is known that W[1] = W[1] and W[2] = W[2], for t ≥ 3, the best known containment relationship is W[t] ⊆ W[t] ⊆ W[2t− 2].",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 1,
      "context" : "While it is known that W[1] = W[1] and W[2] = W[2], for t ≥ 3, the best known containment relationship is W[t] ⊆ W[t] ⊆ W[2t− 2].",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 6,
      "context" : "For more detail on these results and the full definitions relating to first-order logic and structures we refer the reader to [9].",
      "startOffset" : 126,
      "endOffset" : 129
    }, {
      "referenceID" : 6,
      "context" : "In several of our intractability results we make use of the class para-NP, and a useful result due to Flum and Grohe with a detailed explanation in [9]",
      "startOffset" : 148,
      "endOffset" : 151
    }, {
      "referenceID" : 3,
      "context" : "We also employ the Whierarchy [5, 9].",
      "startOffset" : 30,
      "endOffset" : 36
    }, {
      "referenceID" : 6,
      "context" : "We also employ the Whierarchy [5, 9].",
      "startOffset" : 30,
      "endOffset" : 36
    }, {
      "referenceID" : 5,
      "context" : "The other parameterized complexity theory employed is more standard, thus for general definitions we refer the reader to standard texts [8, 9].",
      "startOffset" : 136,
      "endOffset" : 142
    }, {
      "referenceID" : 6,
      "context" : "The other parameterized complexity theory employed is more standard, thus for general definitions we refer the reader to standard texts [8, 9].",
      "startOffset" : 136,
      "endOffset" : 142
    }, {
      "referenceID" : 1,
      "context" : "Pattern Identification is W[2]-hard when parameterized by k, even if |Σ| = 2 and |B| = 1.",
      "startOffset" : 27,
      "endOffset" : 30
    }, {
      "referenceID" : 1,
      "context" : "PI with Small Patterns is W[2]-complete when parameterized by k and NP-complete even when s = 1, |Σ| = 2 and |B| = 1.",
      "startOffset" : 27,
      "endOffset" : 30
    }, {
      "referenceID" : 1,
      "context" : "The W[2]-hardness is apparent from the proof of Lemma 3.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 1,
      "context" : "To show containment in W[2], we reduce PI with Small Patterns to MC(Σ2,1).",
      "startOffset" : 24,
      "endOffset" : 27
    }, {
      "referenceID" : 10,
      "context" : "As Dominating Set has no constant factor fpt-approximation [6] and no c · log n polynomial time approximation [13] and the reduction of Lemma 3.",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 7,
      "context" : "As Dominating Set is NP-complete on planar graphs of maximum degree 3 [10], the number of 1s in each string in the construction of the proof of Lemma 3.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 6,
      "context" : "16 from [9].",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 1,
      "context" : "We note that Dominating Set is in FPT for graphs of bounded degree, so we do obtain a W[2]-hardness result.",
      "startOffset" : 87,
      "endOffset" : 90
    }, {
      "referenceID" : 8,
      "context" : "11 is strict and Vertex Cover is APX-hard [11].",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 1,
      "context" : "As G is planar, we can compute a proper 4-colouring in polynomial time [2].",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 6,
      "context" : "16 from [9].",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 1,
      "context" : "Containment Although the W[2]-hardness reduction is quite direct, containment of Pattern Identification when parameterized by k is not apparent.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 1,
      "context" : "For PI with Small Patterns we have shown containment in W[2].",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 3,
      "context" : "In contrast, for PI with Large Patterns we can show containment in W[5].",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 3,
      "context" : "PI with Large Patterns ∈ W[5] when parameterized by k + r.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 3,
      "context" : "We reduce the problem to MC(Σ∗5,1), which is complete for W [5].",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 3,
      "context" : "This also places PI with Large Patterns somewhere between W[5] and W[8] [5].",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 5,
      "context" : "This also places PI with Large Patterns somewhere between W[5] and W[8] [5].",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 3,
      "context" : "This also places PI with Large Patterns somewhere between W[5] and W[8] [5].",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 1,
      "context" : "We note that the above formula could be converted into prenex form, giving a tighter containment, however the central observation is that it will be greater than W[2], in contrast to the hardness result and the containment of PI with Small Patterns.",
      "startOffset" : 163,
      "endOffset" : 166
    }, {
      "referenceID" : 1,
      "context" : "Pattern Identification ∈ W[2] when n ≤ f(k) · log |I| where |I| is the overall size of the instance and f(k) is a computable function of the parameter.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 1,
      "context" : "It is not clear that we retain W[2]-hardness in this case however, so we unfortunately do not obtain a W[2]-completeness result.",
      "startOffset" : 32,
      "endOffset" : 35
    }, {
      "referenceID" : 1,
      "context" : "It is not clear that we retain W[2]-hardness in this case however, so we unfortunately do not obtain a W[2]-completeness result.",
      "startOffset" : 104,
      "endOffset" : 107
    }, {
      "referenceID" : 1,
      "context" : "If we consider a variant of PI with Small Patterns where we relax the constraint on the number of patterns in the solution, it is easy to see that this problem is inW[2].",
      "startOffset" : 166,
      "endOffset" : 169
    }, {
      "referenceID" : 1,
      "context" : "Although PI with Small Patterns is W[2]-complete, the general problem is only W[2]-hard, and the containment of PI with Large Patterns simply gives a loose upper bound, although does suggest that the problem is harder than PI with Small Patterns.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 1,
      "context" : "Although PI with Small Patterns is W[2]-complete, the general problem is only W[2]-hard, and the containment of PI with Large Patterns simply gives a loose upper bound, although does suggest that the problem is harder than PI with Small Patterns.",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 2,
      "context" : "The problem, intuitively, also shares some similarities with p-Hypergraph(Non)-Dominating-Set which is W[3]-complete [5].",
      "startOffset" : 104,
      "endOffset" : 107
    }, {
      "referenceID" : 3,
      "context" : "The problem, intuitively, also shares some similarities with p-Hypergraph(Non)-Dominating-Set which is W[3]-complete [5].",
      "startOffset" : 117,
      "endOffset" : 120
    }, {
      "referenceID" : 2,
      "context" : "p-ColoredHypergraph-(Non)-Dominating-Set however is W[3]-complete [5] and appears “harder” than Pattern Identification, hence we conjecture:",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 3,
      "context" : "p-ColoredHypergraph-(Non)-Dominating-Set however is W[3]-complete [5] and appears “harder” than Pattern Identification, hence we conjecture:",
      "startOffset" : 66,
      "endOffset" : 69
    }, {
      "referenceID" : 2,
      "context" : "Pattern Identification is W[3]-complete when parameterized by k.",
      "startOffset" : 27,
      "endOffset" : 30
    } ],
    "year" : 2017,
    "abstractText" : "We study the complexity of the problem of searching for a set of patterns that separate two given sets of strings. This problem has applications in a wide variety of areas, most notably in data mining, computational biology, and in understanding the complexity of genetic algorithms. We show that the basic problem of finding a small set of patterns that match one set of strings but do not match any string in a second set is difficult (NP-complete, W[2]hard when parameterized by the size of the pattern set, and APX-hard). We then perform a detailed parameterized analysis of the problem, separating tractable and intractable variants. In particular we show that parameterizing by the size of pattern set and the number of strings, and the size of the alphabet and the number of strings give FPT results, amongst others.",
    "creator" : "LaTeX with hyperref package"
  }
}