{
  "name" : "1704.01691.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Multi-space Variational Encoder-Decoders for Semi-supervised Labeled Sequence Transduction",
    "authors" : [ "Chunting Zhou", "Graham Neubig" ],
    "emails" : [ "ctzhou@cs.cmu.edu", "gneubig@cs.cmu.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "This paper proposes a model for labeled sequence transduction tasks, tasks where we are given an input sequence and a set of labels, from which we are expected to generate an output sequence that reflects the content of the input sequence and desiderata specified by the labels. Several examples of these tasks exist in prior work: using labels to moderate politeness in machine translation results (Sennrich et al., 2016), modifying the output language of a machine translation system (Johnson et al., 2016), or controlling the length of a summary in summarization (Kikuchi et al., 2016). In particular, however, we are motivated by the task of morphological reinflection (Cotterell et al.,\n1An implementation of our model are available at https://github.com/violet-zct/ MSVED-morph-reinflection.\n2016), which we will use as an example in our description and test bed for our models.\nIn morphologically rich languages, different affixes (i.e. prefixes, infixes, suffixes) can be combined with the lemma to reflect various syntactic and semantic features of a word. The ability to accurately analyze and generate morphological forms is crucial to creating applications such as machine translation (Chahuneau et al., 2013; Toutanova et al., 2008) or information retrieval (Darwish and Oard, 2007) in these languages. As shown in 1, re-inflection of an inflected form given the target linguistic labels is a challenging subtask of handling morphology as a whole, in which we take as input an inflected form (in the example, “playing”) and labels representing the desired form (“pos=Verb, tense=Past”) and must generate the desired form (“played”).\nApproaches to this task include those utilizing hand-crafted linguistic rules and heuristics (Taji et al., 2016), as well as learning-based approaches using alignment and extracted transduction rules (Durrett and DeNero, 2013; Alegria and Etxeberria, 2016; Nicolai et al., 2016). There have also been methods proposed using neural sequenceto-sequence models (Faruqui et al., 2016; Kann et al., 2016; Ostling, 2016), and currently ensembles of attentional encoder-decoder models (Kann and Schütze, 2016a,b) have achieved state-of-art results on this task. One feature of these neural models however, is that they are trained in a\nar X\niv :1\n70 4.\n01 69\n1v 2\n[ cs\n.C L\n] 1\n7 A\nug 2\n01 7\nlargely supervised fashion (top of Fig. 1), using data explicitly labeled with the input sequence and labels, along with the output representation. Needless to say, the ability to obtain this annotated data for many languages is limited. However, we can expect that for most languages we can obtain large amounts of unlabeled surface forms that may allow for semi-supervised learning over this unlabeled data (entirety of Fig. 1).2\nIn this work, we propose a new framework for labeled sequence transduction problems: multi-space variational encoder-decoders (MSVED, §3.3). MSVEDs employ continuous or discrete latent variables belonging to multiple separate probability distributions3 to explain the observed data. In the example of morphological reinflection, we introduce a vector of continuous random variables that represent the lemma of the source and target words, and also one discrete random variable for each of the labels, which are on the source or the target side.\nThis model has the advantage of both providing a powerful modeling framework for supervised learning, and allowing for learning in an unsupervised setting. For labeled data, we maximize the variational lower bound on the marginal log likelihood of the data and annotated labels. For unlabeled data, we train an auto-encoder to reconstruct a word conditioned on its lemma and morphological labels. While these labels are unavailable, a set of discrete latent variables are associated with each unlabeled word. Afterwards we can perform posterior inference on these latent variables and maximize the variational lower bound on the marginal log likelihood of data.\nExperiments on the SIGMORPHON morphological reinflection task (Cotterell et al., 2016) find that our model beats the state-of-the-art for a single model in the majority of languages, and is particularly effective in languages with more complicated inflectional phenomena. Further, we find that semi-supervised learning allows for significant further gains. Finally, qualitative evaluation of lemma representations finds that our model is able to learn lemma embeddings that match with human intuition.\n2Faruqui et al. (2016) have attempted a limited form of semi-supervised learning by re-ranking with a standard ngram language model, but this is not integrated with the learning process for the neural model and gains are limited.\n3Analogous to multi-space hidden Markov models (Tokuda et al., 2002)"
    }, {
      "heading" : "2 Labeled Sequence Transduction",
      "text" : "In this section, we first present some notations regarding labeled sequence transduction problems in general, then describe a particular instantiation for morphological reinflection. Notation: Labeled sequence transduction problems involve transforming a source sequence x(s) into a target sequence x(t), with some labels describing the particular variety of transformation to be performed. We use discrete variables y (t) 1 , y (t) 2 , · · · , y (t) K to denote the labels associated with each target sequence, where K is the total number of labels. Let y(t) = [y(t)1 , y (t) 2 , · · · , y (t) K ] denote a vector of these discrete variables. Each discrete variable y(t)k represents a categorical feature pertaining to the target sequence, and has a set of possible labels. In the later sections, we also use y(t) and y(t)k to denote discrete latent variables corresponding to these labels.\nGiven a source sequence x(s) and a set of associated target labels y(t), our goal is to generate a target sequence x(t) that exhibits the features specified by y(t) using a probabilistic model p(x(t)|x(s),y(t)). The best target sequence x̂(t) is then given by:\nx̂(t) = argmax x(t) p(x(t)|x(s),y(t)). (1)\nMorphological Reinflection Problem: In morphological reinflection, the source sequence x(s) consists of the characters in an inflected word (e.g., “played”), while the associated labels y(t) describe some linguistic features (e.g., y(t)pos = Verb, y(t)tense = Past) that we hope to realize in the target. The target sequence x(t) is therefore the characters of the re-inflected form of the source word (e.g., “played”) that satisfy the linguistic features specified by y(t). For this task, each discrete variable y(t)k has a set of possible labels (e.g. pos=V, pos=ADJ, etc) and follows a multinomial distribution."
    }, {
      "heading" : "3 Proposed Method",
      "text" : ""
    }, {
      "heading" : "3.1 Preliminaries: Variational Autoencoder",
      "text" : "As mentioned above, our proposed model uses probabilistic latent variables in a model based on neural networks. The variational autoencoder (Kingma and Welling, 2014) is an efficient way to handle (continuous) latent variables in neural\nmodels. We describe it briefly here, and interested readers can refer to Doersch (2016) for details. The VAE learns a generative model of the probability p(x|z) of observed data x given a latent variable z, and simultaneously uses a recognition model q(z|x) at learning time to estimate z for a particular observation x (Fig. 2(a)). q(·) and p(·) are modeled using neural networks parameterized by φ and θ respectively, and these parameters are learned by maximizing the variational lower bound on the marginal log likelihood of data:\nlog pθ(x) ≥ Ez∼qφ(z|x)[log pθ(x|z)]− KL(qφ(z|x)||p(z)) (2)\nThe KL-divergence term (a standard feature of variational methods) ensures that the distributions estimated by the recognition model qφ(z|x) do not deviate far from our prior probability p(z) of the values of the latent variables. To optimize the parameters with gradient descent, Kingma and Welling (2014) introduce a reparameterization trick that allows for training using simple backpropagation w.r.t. the Gaussian latent variables z. Specifically, we can express z as a deterministic variable z = gφ( ,x) where is an independent Gaussian noise variable ∼ N (0, 1). The mean µ and the variance σ2 of z are reparameterized by the differentiable functions w.r.t. φ. Thus, instead of generating z from qφ(z|x), we sample the auxiliary variable and obtain z = µφ(x)+σφ(x)◦ , which enables gradients to backpropagate through φ."
    }, {
      "heading" : "3.2 Multi-space Variational Autoencoders",
      "text" : "As an intermediate step to our full model, we next describe a generative model for a single sequence with both continuous and discrete latent variables, the multi-space variational auto-encoder (MSVAE). MSVAEs are a combination of two threads of previous work: deep generative models with both continuous/discrete latent variables for classification problems (Kingma et al., 2014;\nMaaløe et al., 2016) and VAEs with only continuous variables for sequential data (Bowman et al., 2016; Chung et al., 2015; Zhang et al., 2016; Fabius and van Amersfoort, 2014; Bayer and Osendorfer, 2014). In MSVAEs, we have an observed sequence x, continuous latent variables z like the VAE, as well as discrete variables y.\nIn the case of the morphology example, x can be interpreted as an inflected word to be generated. y is a vector representing its linguistic labels, either annotated by an annotator in the observed case, or unannotated in the unobserved case. z is a vector of latent continuous variables, e.g. a latent embedding of the lemma that captures all the information about x that is not already represented in labels y.\nMSVAE: Because inflected words can be naturally thought of as “lemma+morphological labels”, to interpret a word, we resort to discrete and continuous latent variables that represent the linguistic labels and the lemma respectively. In this case when the labels of the sequence y is not observed, we perform inference over possible linguistic labels and these inferred labels are referenced in generating x.\nThe generative model pθ(x,y, z) = p(z)pπ(y)pθ(x|y, z) is defined as:\np(z) = N (z|0, I) (3) pπ(y) = ∏ k Cat(yk|πk) (4) pθ(x|y, z) = f(x;y, z, θ). (5)\nLike the standard VAE, we assume the prior of the latent variable z is a diagonal Gaussian distribution with zero mean and unit variance. We assume that each variable in y is independent, resulting in a factorized distribution in Eq. 4, where Cat(yk|πk) is a multinomial distribution with parameters πk. For the purposes of this study, we set these to a uniform distribution πk,j = 1 |πk| . f(x;y, z, θ) calculates the likelihood of x, a function parametrized by deep neural networks. Specifically, we employ an RNN decoder to generate the target word conditioned on the lemma variable z and linguistic labels y, detailed in §5.\nWhen inferring the latent variables from the given data x, we assume the joint distribution of latent variables z and y has a factorized form, i.e. q(z,y|x) = q(z|x)q(y|x) as shown in Fig. 2(c).\nThe inference model is defined as follows:\nqφ(z|x) = N (z|µφ(x), diag(σ2φ(x))) (6) qφ(y|x) = ∏ k qφ(yk|x)\n= ∏ k Cat(yk|πφ(x)) (7)\nwhere the inference distribution over z is a diagonal Gaussian distribution with mean and variance parameterized by neural networks. The inference model q(y|x) on labels y has the form of a discriminative classifier that generates a set of multinomial probability vectors πφ(x) over all labels for each tag yk. We represent each multinomial distribution q(yk|x) with an MLP.\nThe MSVAE is trained by maximizing the following variational lower bound U(x) on the objective for unlabeled data:\nlog pθ(x) ≥ E(y,z)∼qφ(y,z|x) log pθ(x,y, z)\nqφ(y, z|x) = Ey∼qφ(y|x)[Ez∼qφ(z|x)[log pθ(x|z,y)] − KL(qφ(z|x)||p(z)) + log pπ(y) − log qφ(y|x)] = U(x) (8)\nNote that this introduction of discrete variables requires more sophisticated optimization algorithms, which we will discuss in §4.1. Labeled MSVAE: When y is observed as shown in Fig. 2(b), we maximize the following variational lower bound on the marginal log likelihood of the data and the labels:\nlog pθ(x,y) ≥ Ez∼qφ(z|x) log pθ(x,y, z)\nqφ(z|x) =\nEz∼qφ(z|x)[log pθ(x|y, z) + log pπ(y)] − KL(qφ(z|x)||p(z)) (9)\nwhich is a simple extension to Eq. 2. Note that when labels are not observed, the inference model qφ(y|x) has the form of a discriminative classifier, thus we can use observed labels as the supervision signal to learn a better classifier. In this case we also minimize the following cross entropy as the classification loss:\nD(x,y) = E(x,y)∼pl(x,y)[− log qφ(y|x)] (10)\nwhere pl(x,y) is the distribution of labeled data. This is a form of multi-task learning, as this additional loss also informs the learning of our representations."
    }, {
      "heading" : "3.3 Multi-space Variational Encoder-Decoders",
      "text" : "Finally, we discuss the full proposed method: the multi-space variational encoder-decoder (MSVED), which generates the target x(t) from the source x(s) and labels y(t). Again, we discuss two cases of this model: labels of the target sequence are observed and not observed. MSVED: The graphical model for the MSVED is given in Fig. 2 (e). Because the labels of target sequence are not observed, once again we treat them as discrete latent variables and make inference on the these labels conditioned on the target sequence. The generative process for the MSVED is very similar to that of the MSVAE with one important exception: while the standard MSVAE conditions the recognition model q(z|x) on x, then generates x itself, the MSVED conditions the recognition model q(z|x(s)) on the source x(s), then generates the target x(t). Because only the recognition model is changed, the generative equations for pθ(x\n(t),y(t), z) are exactly the same as Eqs. 3–5 with x(t) swapped for x and y(t) swapped for y. The variational lower bound on the conditional log likelihood, however, is affected by the recognition model, and thus is computed as:\nlog pθ(x (t)|x(s))\n≥E(y(t),z)∼qφ(y(t),z|x(s),x(t)) log pθ(x (t),y(t), z|x(s)) qφ(y(t), z|x(s),x(t))\n=Ey(t)∼qφ(y(t)|x(t))[Ez∼qφ(z|x(s))[log pθ(x (t)|y(t), z)]\n− KL(qφ(z|x(s))||p(z)) + log pπ(y(t)) − log qφ(y(t)|x(t))] = Lu(x(t)|x(s)) (11)\nLabeled MSVED: When the complete form of x(s), y(t), and x(t) is observed in our training data, the graphical model of the labeled MSVED model is illustrated in Fig. 2 (d). We maximize the variational lower bound on the conditional log likelihood of observing x(t) and y(t) as follows:\nlog pθ(x (t),y(t)|x(s))\n≥ Ez∼qφ(z|x(s)) log pθ(x (t),y(t), z|x(s)) qφ(z|x(s))\n= Ez∼qφ(z|x(s))[log pθ(x (t)|y(t), z) + log pπ(y(t))]−\nKL(qφ(z|x(s))||p(z)) = Ll(x(t),y(t)|x(s)) (12)"
    }, {
      "heading" : "4 Learning MSVED",
      "text" : "Now that we have described our overall model, we discuss details of the learning process that prove\nuseful to its success."
    }, {
      "heading" : "4.1 Learning Discrete Latent Variables",
      "text" : "One challenge in training our model is that it is not trivial to perform back-propagation through discrete random variables, and thus it is difficult to learn in the models containing discrete tags such as MSVAE or MSVED.4 To alleviate this problem, we use the recently proposed Gumbel-Softmax trick (Maddison et al., 2014; Gumbel and Lieblein, 1954; Jang et al., 2017; J. et al., 2017) to create a differentiable estimator for categorical variables.\nThe Gumbel-Max trick (Gumbel and Lieblein, 1954) offers a simple way to draw samples from a categorical distribution with class probabilities π1, π2, · · · by using the argmax operation as follows: one hot(argmaxi[gi + log πi]), where g1, g2, · · · are i.i.d. samples drawn from the Gumbel(0,1) distribution.5 When making inferences on the morphological labels y1, y2, · · · , the GumbelMax trick can be approximated by the continuous softmax function with temperature τ to generate a sample vector ŷi for each label i:\nŷij = exp((log(πij) + gij)/τ)∑Ni k=1 exp((log(πik) + gik)/τ\n(13)\nwhereNi is the number of classes of label i. When τ approaches zero, the generated sample ŷi becomes a one-hot vector. When τ > 0, ŷi is smooth w.r.t πi. In experiments, we start with a relatively large temperature and decrease it gradually."
    }, {
      "heading" : "4.2 Learning Continuous Latent Variables",
      "text" : "MSVED aims at generating the target sequence conditioned on the latent variable z and the target labels y(t). This requires the encoder to generate an informative representation z encoding the content of the x(s). However, the variational lower bound in our loss function contains the KL-divergence between the approximate posterior qφ(z|x) and the prior p(z), which is relatively easy to learn compared with learning to generate output from a latent representation. We observe that with the vanilla implementation the KL cost quickly decreases to near zero, setting qφ(z|x) equal to standard normal distribution. In\n4 Kingma et al. (2014) solve this problem by marginalizing over all labels, but this is infeasible in our case where we have an exponential number of label combinations.\n5The Gumbel (0,1) distribution can be sampled by first drawing u ∼ Uniform(0,1) and computing g = − log(− log(u)).\nthis case, the RNN decoder can easily rely on the true output of last time step during training to decode the next token, which degenerates into an RNN language model. Hence, the latent variables are ignored by the decoder and cannot encode any useful information. The latent variable z learns an undesirable distribution that coincides with the imposed prior distribution but has no contribution to the decoder. To force the decoder to use the latent variables, we take the following two approaches which are similar to Bowman et al. (2016). KL-Divergence Annealing: We add a coefficient λ to the KL cost and gradually anneal it from zero to a predefined threshold λm. At the early stage of training, we set λ to be zero and let the model first figure out how to project the representation of the source sequence to a roughly right point in the space and then regularize it with the KL cost. Although we are not optimizing the tight variational lower bound, the model balances well between generation and regularization. This technique can also be seen in (Kočiskỳ et al., 2016; Miao and Blunsom, 2016). Input Dropout in the Decoder: Besides annealing the KL cost, we also randomly drop out the input token with a probability of β at each time step of the decoder during learning. The previous ground-truth token embedding is replaced with a zero vector when dropped. In this way, the RNN decoder could not fully rely on the ground-truth previous token, which ensures that the decoder uses information encoded in the latent variables."
    }, {
      "heading" : "5 Architecture for Morphological",
      "text" : "Reinflection\nTraining details: For the morphological reinflection task, our supervised training data consists of source x(s), target x(t), and target tags y(t). We test three variants of our model trained using different types of data and different loss functions. First, the single-directional supervised model (SDSup) is purely supervised: it only decodes the target word from the given source word with the loss function Ll(x(t),y(t)|x(s)) from Eq. 12. Second, the bi-directional supervised model (BDSup) is trained in both directions: decoding the target word from the source word and decoding the source word from the target word, which corresponds to the loss function Ll(x(t),y(t)|x(s)) + Lu(x(s)|x(t)) using Eqs. 11–12. Finally, the semisupervised model (Semi-sup) is trained to maxi-\nmize the variational lower bounds and minimize the classification cross-entropy error of 10.\nL(x(s),x(t),y(t),x) = α · U(x) + Lu(x(s)|x(t)) + Ll(x(t),y(t)|x(s))−D(x(t),y(t)) (14)\nThe weight α controls the relative weight between the loss from unlabeled data and labeled data.\nWe use Monte Carlo methods to estimate the expectation over the posterior distribution q(z|x) and q(y|x) inside the objective function 14. Specifically, we draw Gumbel noise and Gaussian noise one at a time to compute the latent variables y and z.\nThe overall model architecture is shown in Fig. 3. Each character and each label is associated with a continuous vector. We employ Gated Recurrent Units (GRUs) for the encoder and de-\ncoder. Let −→ ht and ←− ht denote the hidden state of the forward and backward encoder RNN at time step t. u is the hidden representation of x(s) concatenating the last hidden state from both directions i.e. [ −→ hT ; ←− hT ] where T is the word length. u is used as the input for the inference model on z. We represent µ(u) and σ2(u) as MLPs and sample z fromN (µ(u), diag(σ2(u))), using z = µ+ σ ◦ , where ∼ N (0, I). Similarly, we can obtain the hidden representation of x(t) and use this as input to the inference model on each label y(t)i which is also an MLP following a softmax layer to generate the categorical probabilities of target labels.\nIn decoding, we use 3 types of information in calculating the probability of the next character : (1) the current decoder state, (2) a tag context vector using attention (Bahdanau et al., 2015) over the tag embeddings, and (3) the latent variable z. The intuition behind this design is that we would like the model to constantly consider the lemma represented by z, and also reference the tag corresponding to the current morpheme being generated at this point. We do not marginalize over the latent variable z however, instead we use the mode µ of z as the latent representation for z. We use beam search with a beam size of 8 to perform search over the character vocabulary at each decoding time step. Other experimental setups: All hyperparameters are tuned on the validation set, and include the following: For KL cost annealing, λm is set to be 0.2 for all language settings. For character drop-out at the decoder, we empirically set β to be 0.4 for all languages. We set the dimension of character embeddings to be 300, tag label embeddings to be 200, RNN hidden state to be 256, and\nlatent variable z to be 150. We set α the weight for the unsupervised loss to be 0.8. We train the model with Adadelta (Zeiler, 2012) and use earlystop with a patience of 10."
    }, {
      "heading" : "6 Experiments",
      "text" : ""
    }, {
      "heading" : "6.1 Background: SIGMORPHON 2016",
      "text" : "SIGMORPHON 2016 is a shared task on morphological inflection over 10 different morphologically rich languages. There are a total of three tasks, the most difficult of which is task 3, which requires the system to output the reinflection of an inflected word.6 The training data format in task 3 is in triples: (source word, target labels, target word). In the test phase, the system is asked to generate the target word given a source word and the target labels. There are a total of three tracks for each task, divided based the amount of supervised data that can be used to solve the problem, among which track 2 has the strictest limitation of only using data for the corresponding task. As this is an ideal testbed for our method, which can learn from unlabeled data, we choose track 2 and task 3 to test our our model’s ability to exploit this data.\nAs a baseline, we compare our results with the MED system (Kann and Schütze, 2016a) which achieved state-of-the-art results in the shared task. This system used an encoder-decoder model with attention on the concatenated source word and target labels. Its best result is obtained from an ensemble of five RNN encoder-decoders (Ensemble). To make a fair comparison with our models, which don’t use ensembling, we also calculated single model results (Single).\nAll models are trained using the labeled training data provided for task 3. For our semi-supervised model (Semi-sup), we also leverage unlabeled data from the training and validation data for tasks 1 and 2 to train variational auto-encoders."
    }, {
      "heading" : "6.2 Results and Analysis",
      "text" : "From the results in Tab. 1, we can glean a number of observations. First, comparing the results of our full Semi-sup model, we can see that for all languages except Spanish, it achieves accuracies better than the single MED system, often by a large margin. Even compared to the MED ensembled model, our single-model system is quite competitive, achieving higher accuracies for Hungarian,\n6Task 1 is inflection of a lemma word and task 2 is reinflection but also provides the source word labels.\nNavajo, Maltese, and Arabic, as well as achieving average accuracies that are state-of-the-art.\nNext, comparing the different varieties of our proposed models, we can see that the semisupervised model consistently outperforms the bidirectional model for all languages. And similarly, the bidirectional model consistently outperforms the single direction model. From these results, we can conclude that the unlabeled data is beneficial to learn useful latent variables that can be used to decode the corresponding word.\nExamining the linguistic characteristics of the models in which our model performs well provides even more interesting insights. Cotterell et al. (2016) estimate how often the inflection process involves prefix changes, stem-internal changes or suffix changes, the results of which are shown in Tab. 2. Among the many languages, the inflection processes of Arabic, Maltese and Navajo are relatively diverse, and contain a large amount of all three forms of inflection. By examining the experimental results together with the morphological inflection process of different languages, we found that among all the languages, Navajo, Maltese and Arabic obtain the largest gains in performance compared with the ensem-\nbled MED system. To demonstrate this visually, in Fig. 4, we compare the semi-supervised MSVED with the MED single model w.r.t. the percentage of suffixing inflection of each language, showing this clear trend.\nThis strongly demonstrates that our model is agnostic to different morphological inflection forms whereas the conventional encoder-decoder with attention on the source input tends to perform better on suffixing-oriented morphological inflection. We hypothesize that for languages that the inflection mostly comes from suffixing, transduction is relatively easy because the source and target words share the same prefix and the decoder can copy the prefix of the source word via attention. However, for languages in which different inflections of a lemma go through different morphological processes, the inflected word and the target word may differ greatly and thus it is crucial to first analyze the lemma of the inflected word before generating the corresponding the reinflection form based on the target labels. This is precisely what our model does by extracting the lemma representation z learned by the variational inference model."
    }, {
      "heading" : "6.3 Analysis on Tag Attention",
      "text" : "To analyze how the decoder attends to the linguistic labels associated with the target word, we randomly pick two words from the Arabic and Navajo test set and plot the attention weight in Fig. 5. The Arabic word “al-’imārātiyyātu” is an adjective which means “Emirati”, and its source word in the test data is “’imārātiyyin” 7. Both of these are declensions of “’imārātiyy”. The source word is\n7https://en.wiktionary.org/wiki/%D8% A5%D9%85%D8%A7%D8%B1%D8%A7%D8%AA%D9%8A\nsingular, masculine, genitive and indefinite, while the required inflection is plural, feminine, nominative and definite. We can see from the left heat map that the attention weights are turned on at several positions of the word when generating corresponding inflections. For example, “al-” in Arabic is the definite article that marks definite nouns. The same phenomenon can also be observed in the Navajo example, as well as other languages, but due to space limitation, we don’t provide detailed analysis here."
    }, {
      "heading" : "6.4 Visualization of Latent Lemmas",
      "text" : "To investigate the learned latent representations, in this section we visualize the z vectors, examining whether the latent space groups together words with the same lemma. Each sample in SIGMORPHON 2016 contains source word and target words which share the same lemma. We run a heuristic process to assign pairs of words to groups that likely share a lemma by grouping together word pairs for which at least one of the words in each pair shares a surface form. This process is not error free – errors may occur in the case where multiple lemmas share the same surface form – but in general the groupings will generally reflect lemmas except in these rare erroneous cases, so we dub each of these groups a pseudo-lemma.\nIn Fig. 6, we randomly pick 1500 words from Maltese and visualize the continuous latent vectors of these words. We compute the latent vectors as µφ(x) in the variational posterior inference (Eq. 6) without adding the variance. As expected, words that belong to the same pseudo-lemma (in the same color) are projected into adjacent points in the two-dimensional space. This demonstrates that the continuous latent variable captures the canonical form of a set of words and demonstrates the effectiveness of the proposed representation."
    }, {
      "heading" : "6.5 Analyzing Effects of Size of Unlabeled Data",
      "text" : "From Tab. 1, we can see that semi-supervised learning always performs better than supervised learning without unlabeled data. In this section, we investigate to what extent the size of unlabeled data can help with performance. We process a German corpus from a 2017 Wikipedia dump and obtain more than 100,000 German words. These words are ranked in order of occurrence frequency in Wikipedia. The data contains a certain amount of noise since we did not apply any special processing. We shuffle all unlabeled data from both the Wikipedia and the data provided in the shared task used in previous experiments, and increase the number of unlabeled words used in learning by 10,000 each time, and finally use all the unlabeled data (more than 150,000 words) to train the model. Fig. 7 shows that the performance on the test data improves as the amount of unlabeled data increases, which implies that the unsupervised learning continues to help improve the model’s ability to model the latent lemma representation even as we scale to a noisy, real, and relatively large-scale dataset. Note that the growth rate of the performance grows slower as more data is added, because although the number of unlabeled data is increasing, the model has seen most word patterns in a relatively small vocabulary."
    }, {
      "heading" : "6.6 Case Study on Reinflected Words",
      "text" : "In Tab. 3, we examine some model outputs on the test data from the MED system and our model respectively. It can be seen that most errors of MED and our models can be ascribed to either over-copy or under-copy of characters. In particular, from the complete outputs we observe that our model tends to be more aggressive in its changes, resulting in\nit performing more complicated transformations, both successfully (such as Maltese “ndammhomli” to “tindammhiex”) and unsuccessfully (“tqożżx” to “qażżejtx”). In contrast, the attentional encoderdecoder model is more conservative in its changes, likely because it is less effective in learning an abstracted representation for the lemma, and instead copies characters directly from the input."
    }, {
      "heading" : "7 Conclusion and Future Work",
      "text" : "In this work, we propose a multi-space variational encoder-decoder framework for labeled sequence transduction problem. The MSVED performs well in the task of morphological reinflection, outperforming the state of the art, and further improving with the addition of external unlabeled data. Future work will adapt this framework to other sequence transduction scenarios such as machine translation, dialogue generation, question answering, where continuous and discrete latent variables can be abstracted to guide sequence generation."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The authors thank Jiatao Gu, Xuezhe Ma, Zihang Dai and Pengcheng Yin for their helpful discussions. This work has been supported in part by an Amazon Academic Research Award."
    } ],
    "references" : [ {
      "title" : "Ehu at the sigmorphon 2016 shared task",
      "author" : [ "Iñaki Alegria", "Izaskun Etxeberria." ],
      "venue" : "a simple proposal: Grapheme-to-phoneme for inflection. In Proceedings of the 2016 Meeting of SIGMORPHON .",
      "citeRegEx" : "Alegria and Etxeberria.,? 2016",
      "shortCiteRegEx" : "Alegria and Etxeberria.",
      "year" : 2016
    }, {
      "title" : "Neural machine translation by jointly learning to align and translate",
      "author" : [ "Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio." ],
      "venue" : "The International Conference on Learning Representations .",
      "citeRegEx" : "Bahdanau et al\\.,? 2015",
      "shortCiteRegEx" : "Bahdanau et al\\.",
      "year" : 2015
    }, {
      "title" : "Learning stochastic recurrent networks",
      "author" : [ "Justin Bayer", "Christian Osendorfer." ],
      "venue" : "arXiv preprint arXiv:1411.7610 .",
      "citeRegEx" : "Bayer and Osendorfer.,? 2014",
      "shortCiteRegEx" : "Bayer and Osendorfer.",
      "year" : 2014
    }, {
      "title" : "Generating sentences from a continuous space",
      "author" : [ "Samuel R Bowman", "Luke Vilnis", "Oriol Vinyals", "Andrew M Dai", "Rafal Jozefowicz", "Samy Bengio." ],
      "venue" : "Proceedings of CoNLL .",
      "citeRegEx" : "Bowman et al\\.,? 2016",
      "shortCiteRegEx" : "Bowman et al\\.",
      "year" : 2016
    }, {
      "title" : "Translating into morphologically rich languages with synthetic phrases",
      "author" : [ "Victor Chahuneau", "Eva Schlinger", "Noah A Smith", "Chris Dyer." ],
      "venue" : "Association for Computational Linguistics.",
      "citeRegEx" : "Chahuneau et al\\.,? 2013",
      "shortCiteRegEx" : "Chahuneau et al\\.",
      "year" : 2013
    }, {
      "title" : "A recurrent latent variable model for sequential data",
      "author" : [ "Junyoung Chung", "Kyle Kastner", "Laurent Dinh", "Kratarth Goel", "Aaron C Courville", "Yoshua Bengio." ],
      "venue" : "Advances in neural information processing systems. pages 2980–2988.",
      "citeRegEx" : "Chung et al\\.,? 2015",
      "shortCiteRegEx" : "Chung et al\\.",
      "year" : 2015
    }, {
      "title" : "The sigmorphon 2016 shared taskmorphological reinflection",
      "author" : [ "R. Cotterell", "C. Kirov", "J. Sylak-Glassman", "D. Yarowsky", "J. Eisner", "M. Hulden." ],
      "venue" : "Proceedings of the 54th Annual Meeting of the Association for Computational",
      "citeRegEx" : "Cotterell et al\\.,? 2016",
      "shortCiteRegEx" : "Cotterell et al\\.",
      "year" : 2016
    }, {
      "title" : "Adapting morphology for arabic information retrieval",
      "author" : [ "Kareem Darwish", "Douglas W Oard." ],
      "venue" : "Arabic Computational Morphology, Springer, pages 245–262.",
      "citeRegEx" : "Darwish and Oard.,? 2007",
      "shortCiteRegEx" : "Darwish and Oard.",
      "year" : 2007
    }, {
      "title" : "Tutorial on variational autoencoders",
      "author" : [ "Carl Doersch." ],
      "venue" : "arXiv preprint arXiv:1606.05908 .",
      "citeRegEx" : "Doersch.,? 2016",
      "shortCiteRegEx" : "Doersch.",
      "year" : 2016
    }, {
      "title" : "Supervised learning of complete morphological paradigms",
      "author" : [ "Greg Durrett", "John DeNero." ],
      "venue" : "Proceedings of the 2013 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies.",
      "citeRegEx" : "Durrett and DeNero.,? 2013",
      "shortCiteRegEx" : "Durrett and DeNero.",
      "year" : 2013
    }, {
      "title" : "Variational recurrent auto-encoders",
      "author" : [ "Otto Fabius", "Joost R van Amersfoort." ],
      "venue" : "arXiv preprint arXiv:1412.6581 .",
      "citeRegEx" : "Fabius and Amersfoort.,? 2014",
      "shortCiteRegEx" : "Fabius and Amersfoort.",
      "year" : 2014
    }, {
      "title" : "Morphological inflection generation using character sequence to sequence learning",
      "author" : [ "Manaal Faruqui", "Yulia Tsvetkov", "Graham Neubig", "Chris Dyer." ],
      "venue" : "Proceedings of the 2016 Conference of the North American Chapter of the Association for",
      "citeRegEx" : "Faruqui et al\\.,? 2016",
      "shortCiteRegEx" : "Faruqui et al\\.",
      "year" : 2016
    }, {
      "title" : "Statistical theory of extreme values and some practical applications: a series of lectures",
      "author" : [ "Emil Julius Gumbel", "Julius Lieblein." ],
      "venue" : "US Government Printing Office Washington .",
      "citeRegEx" : "Gumbel and Lieblein.,? 1954",
      "shortCiteRegEx" : "Gumbel and Lieblein.",
      "year" : 1954
    }, {
      "title" : "The concrete distribution: A continuous relaxation of discrete random variables",
      "author" : [ "Maddison Chris J.", "Andriy Mnih", "Yee Whye Teh." ],
      "venue" : "The International Conference on Learning Representations..",
      "citeRegEx" : "J. et al\\.,? 2017",
      "shortCiteRegEx" : "J. et al\\.",
      "year" : 2017
    }, {
      "title" : "Categorical reparameterization with gumbel-softmax",
      "author" : [ "Eric Jang", "Shixiang Gu", "Ben Poole." ],
      "venue" : "The International Conference on Learning Representations..",
      "citeRegEx" : "Jang et al\\.,? 2017",
      "shortCiteRegEx" : "Jang et al\\.",
      "year" : 2017
    }, {
      "title" : "Google’s multilingual neural machine translation system: Enabling zero-shot translation",
      "author" : [ "Melvin Johnson", "Mike Schuster", "Quoc V Le", "Maxim Krikun", "Yonghui Wu", "Zhifeng Chen", "Nikhil Thorat", "Fernanda Viégas", "Martin Wattenberg", "Greg Corrado" ],
      "venue" : null,
      "citeRegEx" : "Johnson et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Johnson et al\\.",
      "year" : 2016
    }, {
      "title" : "Neural multi-source morphological reinflection",
      "author" : [ "Katharina Kann", "Ryan Cotterell", "Hinrich Schütze." ],
      "venue" : "arXiv preprint arXiv:1612.06027 .",
      "citeRegEx" : "Kann et al\\.,? 2016",
      "shortCiteRegEx" : "Kann et al\\.",
      "year" : 2016
    }, {
      "title" : "Med: The lmu system for the sigmorphon 2016 shared task on morphological reinflection",
      "author" : [ "Katharina Kann", "Hinrich Schütze." ],
      "venue" : "In Proceedings of the 14th SIGMORPHON Workshop on Computational Research in Phonetics, Phonology, and Mor-",
      "citeRegEx" : "Kann and Schütze.,? 2016a",
      "shortCiteRegEx" : "Kann and Schütze.",
      "year" : 2016
    }, {
      "title" : "Singlemodel encoder-decoder with explicit morphological representation for reinflection",
      "author" : [ "Katharina Kann", "Hinrich Schütze." ],
      "venue" : "In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics. Berlin, Germany.",
      "citeRegEx" : "Kann and Schütze.,? 2016b",
      "shortCiteRegEx" : "Kann and Schütze.",
      "year" : 2016
    }, {
      "title" : "Controlling output length in neural encoder-decoders",
      "author" : [ "Yuta Kikuchi", "Graham Neubig", "Ryohei Sasano", "Hiroya Takamura", "Manabu Okumura." ],
      "venue" : "Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing. Associ-",
      "citeRegEx" : "Kikuchi et al\\.,? 2016",
      "shortCiteRegEx" : "Kikuchi et al\\.",
      "year" : 2016
    }, {
      "title" : "Semi-supervised learning with deep generative models",
      "author" : [ "Diederik P Kingma", "Shakir Mohamed", "Danilo Jimenez Rezende", "Max Welling." ],
      "venue" : "Advances in Neural Information Processing Systems. Montréal, Canada, pages 3581–3589.",
      "citeRegEx" : "Kingma et al\\.,? 2014",
      "shortCiteRegEx" : "Kingma et al\\.",
      "year" : 2014
    }, {
      "title" : "Auto-encoding variational bayes",
      "author" : [ "D.P. Kingma", "M. Welling." ],
      "venue" : "The International Conference on Learning Representations.",
      "citeRegEx" : "Kingma and Welling.,? 2014",
      "shortCiteRegEx" : "Kingma and Welling.",
      "year" : 2014
    }, {
      "title" : "Semantic parsing with semi-supervised sequential autoencoders",
      "author" : [ "Tomáš Kočiskỳ", "Gábor Melis", "Edward Grefenstette", "Chris Dyer", "Wang Ling", "Phil Blunsom", "Karl Moritz Hermann." ],
      "venue" : "the 2016 Conference on Empirical Methods in Natural Lan-",
      "citeRegEx" : "Kočiskỳ et al\\.,? 2016",
      "shortCiteRegEx" : "Kočiskỳ et al\\.",
      "year" : 2016
    }, {
      "title" : "Auxiliary deep generative models",
      "author" : [ "Lars Maaløe", "Casper Kaae Sønderby", "Søren Kaae Sønderby", "Ole Winther." ],
      "venue" : "Proceedings of the 33rd International Conference on Machine Learning .",
      "citeRegEx" : "Maaløe et al\\.,? 2016",
      "shortCiteRegEx" : "Maaløe et al\\.",
      "year" : 2016
    }, {
      "title" : "A* sampling",
      "author" : [ "Chris J Maddison", "Daniel Tarlow", "Tom Minka." ],
      "venue" : "Advances in Neural Information Processing Systems. pages 3086–3094.",
      "citeRegEx" : "Maddison et al\\.,? 2014",
      "shortCiteRegEx" : "Maddison et al\\.",
      "year" : 2014
    }, {
      "title" : "Language as a latent variable: Discrete generative models for sentence compression",
      "author" : [ "Yishu Miao", "Phil Blunsom." ],
      "venue" : "the 2016 Conference on Empirical Methods in Natural Language Processing (EMNLP) .",
      "citeRegEx" : "Miao and Blunsom.,? 2016",
      "shortCiteRegEx" : "Miao and Blunsom.",
      "year" : 2016
    }, {
      "title" : "Morphological reinflection via discriminative string transduction",
      "author" : [ "Garrett Nicolai", "Bradley Hauer", "Adam St. Arnaud", "Grzegorz Kondrak." ],
      "venue" : "Proceedings of the 2016 Meeting of SIGMORPHON .",
      "citeRegEx" : "Nicolai et al\\.,? 2016",
      "shortCiteRegEx" : "Nicolai et al\\.",
      "year" : 2016
    }, {
      "title" : "Morphological reinflection with convolutional neural networks",
      "author" : [ "Robert Ostling." ],
      "venue" : "Proceedings of the 14th SIGMORPHON Workshop on Computational Research in Phonetics, Phonology, and Morphology page 23.",
      "citeRegEx" : "Ostling.,? 2016",
      "shortCiteRegEx" : "Ostling.",
      "year" : 2016
    }, {
      "title" : "Controlling politeness in neural machine translation via side constraints",
      "author" : [ "Rico Sennrich", "Barry Haddow", "Alexandra Birch." ],
      "venue" : "Proceedings of the 2016 Conference of The North American Chapter of the Association for Computational Linguistics",
      "citeRegEx" : "Sennrich et al\\.,? 2016",
      "shortCiteRegEx" : "Sennrich et al\\.",
      "year" : 2016
    }, {
      "title" : "The columbia university - new york university abu dhabi sigmorphon 2016 morphological reinflection shared task submission",
      "author" : [ "Dima Taji", "Ramy Eskander", "Nizar Habash", "Owen Rambow." ],
      "venue" : "Proceedings of the 2016 Meeting of SIGMORPHON .",
      "citeRegEx" : "Taji et al\\.,? 2016",
      "shortCiteRegEx" : "Taji et al\\.",
      "year" : 2016
    }, {
      "title" : "Multi-space probability distribution hmm",
      "author" : [ "Keiichi Tokuda", "Takashi Masuko", "Noboru Miyazaki", "Takao Kobayashi." ],
      "venue" : "IEICE TRANSACTIONS on Information and Systems 85(3):455–464.",
      "citeRegEx" : "Tokuda et al\\.,? 2002",
      "shortCiteRegEx" : "Tokuda et al\\.",
      "year" : 2002
    }, {
      "title" : "Applying morphology generation models to machine translation",
      "author" : [ "Kristina Toutanova", "Hisami Suzuki", "Achim Ruopp." ],
      "venue" : "Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics. pages 514–522.",
      "citeRegEx" : "Toutanova et al\\.,? 2008",
      "shortCiteRegEx" : "Toutanova et al\\.",
      "year" : 2008
    }, {
      "title" : "Adadelta: an adaptive learning rate method",
      "author" : [ "Matthew D Zeiler." ],
      "venue" : "arXiv preprint arXiv:1212.5701 .",
      "citeRegEx" : "Zeiler.,? 2012",
      "shortCiteRegEx" : "Zeiler.",
      "year" : 2012
    }, {
      "title" : "Variational neural machine translation",
      "author" : [ "Biao Zhang", "Deyi Xiong", "Jinsong Su", "Hong Duan", "Min Zhang." ],
      "venue" : "Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics .",
      "citeRegEx" : "Zhang et al\\.,? 2016",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2016
    } ],
    "referenceMentions" : [ {
      "referenceID" : 28,
      "context" : "Several examples of these tasks exist in prior work: using labels to moderate politeness in machine translation results (Sennrich et al., 2016), modifying the output language of a machine translation system (Johnson et al.",
      "startOffset" : 120,
      "endOffset" : 143
    }, {
      "referenceID" : 15,
      "context" : ", 2016), modifying the output language of a machine translation system (Johnson et al., 2016), or controlling the length of a summary in summarization (Kikuchi et al.",
      "startOffset" : 71,
      "endOffset" : 93
    }, {
      "referenceID" : 19,
      "context" : ", 2016), or controlling the length of a summary in summarization (Kikuchi et al., 2016).",
      "startOffset" : 65,
      "endOffset" : 87
    }, {
      "referenceID" : 4,
      "context" : "The ability to accurately analyze and generate morphological forms is crucial to creating applications such as machine translation (Chahuneau et al., 2013; Toutanova et al., 2008) or information retrieval (Darwish and Oard, 2007) in these languages.",
      "startOffset" : 131,
      "endOffset" : 179
    }, {
      "referenceID" : 31,
      "context" : "The ability to accurately analyze and generate morphological forms is crucial to creating applications such as machine translation (Chahuneau et al., 2013; Toutanova et al., 2008) or information retrieval (Darwish and Oard, 2007) in these languages.",
      "startOffset" : 131,
      "endOffset" : 179
    }, {
      "referenceID" : 7,
      "context" : ", 2008) or information retrieval (Darwish and Oard, 2007) in these languages.",
      "startOffset" : 33,
      "endOffset" : 57
    }, {
      "referenceID" : 29,
      "context" : "Approaches to this task include those utilizing hand-crafted linguistic rules and heuristics (Taji et al., 2016), as well as learning-based approaches using alignment and extracted transduction rules (Durrett and DeNero, 2013; Alegria and Etxeberria, 2016; Nicolai et al.",
      "startOffset" : 93,
      "endOffset" : 112
    }, {
      "referenceID" : 9,
      "context" : ", 2016), as well as learning-based approaches using alignment and extracted transduction rules (Durrett and DeNero, 2013; Alegria and Etxeberria, 2016; Nicolai et al., 2016).",
      "startOffset" : 95,
      "endOffset" : 173
    }, {
      "referenceID" : 0,
      "context" : ", 2016), as well as learning-based approaches using alignment and extracted transduction rules (Durrett and DeNero, 2013; Alegria and Etxeberria, 2016; Nicolai et al., 2016).",
      "startOffset" : 95,
      "endOffset" : 173
    }, {
      "referenceID" : 26,
      "context" : ", 2016), as well as learning-based approaches using alignment and extracted transduction rules (Durrett and DeNero, 2013; Alegria and Etxeberria, 2016; Nicolai et al., 2016).",
      "startOffset" : 95,
      "endOffset" : 173
    }, {
      "referenceID" : 11,
      "context" : "There have also been methods proposed using neural sequenceto-sequence models (Faruqui et al., 2016; Kann et al., 2016; Ostling, 2016), and currently ensembles of attentional encoder-decoder models (Kann and Schütze, 2016a,b) have achieved state-of-art results on this task.",
      "startOffset" : 78,
      "endOffset" : 134
    }, {
      "referenceID" : 16,
      "context" : "There have also been methods proposed using neural sequenceto-sequence models (Faruqui et al., 2016; Kann et al., 2016; Ostling, 2016), and currently ensembles of attentional encoder-decoder models (Kann and Schütze, 2016a,b) have achieved state-of-art results on this task.",
      "startOffset" : 78,
      "endOffset" : 134
    }, {
      "referenceID" : 27,
      "context" : "There have also been methods proposed using neural sequenceto-sequence models (Faruqui et al., 2016; Kann et al., 2016; Ostling, 2016), and currently ensembles of attentional encoder-decoder models (Kann and Schütze, 2016a,b) have achieved state-of-art results on this task.",
      "startOffset" : 78,
      "endOffset" : 134
    }, {
      "referenceID" : 6,
      "context" : "Experiments on the SIGMORPHON morphological reinflection task (Cotterell et al., 2016) find that our model beats the state-of-the-art for a single model in the majority of languages, and is particularly effective in languages with more complicated inflectional phenomena.",
      "startOffset" : 62,
      "endOffset" : 86
    }, {
      "referenceID" : 30,
      "context" : "Analogous to multi-space hidden Markov models (Tokuda et al., 2002) 2 Labeled Sequence Transduction",
      "startOffset" : 46,
      "endOffset" : 67
    }, {
      "referenceID" : 21,
      "context" : "The variational autoencoder (Kingma and Welling, 2014) is an efficient way to handle (continuous) latent variables in neural",
      "startOffset" : 28,
      "endOffset" : 54
    }, {
      "referenceID" : 8,
      "context" : "We describe it briefly here, and interested readers can refer to Doersch (2016) for details.",
      "startOffset" : 65,
      "endOffset" : 80
    }, {
      "referenceID" : 21,
      "context" : "To optimize the parameters with gradient descent, Kingma and Welling (2014) introduce a reparameterization trick that allows for training using simple backpropagation w.",
      "startOffset" : 50,
      "endOffset" : 76
    }, {
      "referenceID" : 20,
      "context" : "MSVAEs are a combination of two threads of previous work: deep generative models with both continuous/discrete latent variables for classification problems (Kingma et al., 2014; Maaløe et al., 2016) and VAEs with only continuous variables for sequential data (Bowman et al.",
      "startOffset" : 156,
      "endOffset" : 198
    }, {
      "referenceID" : 23,
      "context" : "MSVAEs are a combination of two threads of previous work: deep generative models with both continuous/discrete latent variables for classification problems (Kingma et al., 2014; Maaløe et al., 2016) and VAEs with only continuous variables for sequential data (Bowman et al.",
      "startOffset" : 156,
      "endOffset" : 198
    }, {
      "referenceID" : 3,
      "context" : ", 2016) and VAEs with only continuous variables for sequential data (Bowman et al., 2016; Chung et al., 2015; Zhang et al., 2016; Fabius and van Amersfoort, 2014; Bayer and Osendorfer, 2014).",
      "startOffset" : 68,
      "endOffset" : 190
    }, {
      "referenceID" : 5,
      "context" : ", 2016) and VAEs with only continuous variables for sequential data (Bowman et al., 2016; Chung et al., 2015; Zhang et al., 2016; Fabius and van Amersfoort, 2014; Bayer and Osendorfer, 2014).",
      "startOffset" : 68,
      "endOffset" : 190
    }, {
      "referenceID" : 33,
      "context" : ", 2016) and VAEs with only continuous variables for sequential data (Bowman et al., 2016; Chung et al., 2015; Zhang et al., 2016; Fabius and van Amersfoort, 2014; Bayer and Osendorfer, 2014).",
      "startOffset" : 68,
      "endOffset" : 190
    }, {
      "referenceID" : 2,
      "context" : ", 2016) and VAEs with only continuous variables for sequential data (Bowman et al., 2016; Chung et al., 2015; Zhang et al., 2016; Fabius and van Amersfoort, 2014; Bayer and Osendorfer, 2014).",
      "startOffset" : 68,
      "endOffset" : 190
    }, {
      "referenceID" : 24,
      "context" : "4 To alleviate this problem, we use the recently proposed Gumbel-Softmax trick (Maddison et al., 2014; Gumbel and Lieblein, 1954; Jang et al., 2017; J. et al., 2017) to create a differentiable estimator for categorical variables.",
      "startOffset" : 79,
      "endOffset" : 165
    }, {
      "referenceID" : 12,
      "context" : "4 To alleviate this problem, we use the recently proposed Gumbel-Softmax trick (Maddison et al., 2014; Gumbel and Lieblein, 1954; Jang et al., 2017; J. et al., 2017) to create a differentiable estimator for categorical variables.",
      "startOffset" : 79,
      "endOffset" : 165
    }, {
      "referenceID" : 14,
      "context" : "4 To alleviate this problem, we use the recently proposed Gumbel-Softmax trick (Maddison et al., 2014; Gumbel and Lieblein, 1954; Jang et al., 2017; J. et al., 2017) to create a differentiable estimator for categorical variables.",
      "startOffset" : 79,
      "endOffset" : 165
    }, {
      "referenceID" : 13,
      "context" : "4 To alleviate this problem, we use the recently proposed Gumbel-Softmax trick (Maddison et al., 2014; Gumbel and Lieblein, 1954; Jang et al., 2017; J. et al., 2017) to create a differentiable estimator for categorical variables.",
      "startOffset" : 79,
      "endOffset" : 165
    }, {
      "referenceID" : 12,
      "context" : "The Gumbel-Max trick (Gumbel and Lieblein, 1954) offers a simple way to draw samples from a categorical distribution with class probabilities π1, π2, · · · by using the argmax operation as follows: one hot(argmaxi[gi + log πi]), where g1, g2, · · · are i.",
      "startOffset" : 21,
      "endOffset" : 48
    }, {
      "referenceID" : 19,
      "context" : "4 Kingma et al. (2014) solve this problem by marginalizing over all labels, but this is infeasible in our case where we have an exponential number of label combinations.",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 3,
      "context" : "To force the decoder to use the latent variables, we take the following two approaches which are similar to Bowman et al. (2016).",
      "startOffset" : 108,
      "endOffset" : 129
    }, {
      "referenceID" : 22,
      "context" : "This technique can also be seen in (Kočiskỳ et al., 2016; Miao and Blunsom, 2016).",
      "startOffset" : 35,
      "endOffset" : 81
    }, {
      "referenceID" : 25,
      "context" : "This technique can also be seen in (Kočiskỳ et al., 2016; Miao and Blunsom, 2016).",
      "startOffset" : 35,
      "endOffset" : 81
    }, {
      "referenceID" : 1,
      "context" : "In decoding, we use 3 types of information in calculating the probability of the next character : (1) the current decoder state, (2) a tag context vector using attention (Bahdanau et al., 2015) over the tag embeddings, and (3) the latent variable z.",
      "startOffset" : 170,
      "endOffset" : 193
    }, {
      "referenceID" : 32,
      "context" : "We train the model with Adadelta (Zeiler, 2012) and use earlystop with a patience of 10.",
      "startOffset" : 33,
      "endOffset" : 47
    }, {
      "referenceID" : 17,
      "context" : "As a baseline, we compare our results with the MED system (Kann and Schütze, 2016a) which achieved state-of-the-art results in the shared task.",
      "startOffset" : 58,
      "endOffset" : 83
    }, {
      "referenceID" : 6,
      "context" : "Table 2: Percentage of inflected word forms that have modified each part of the lemma (Cotterell et al., 2016) (some words can be inflected zero or multiple times, thus sums may not add to 100%).",
      "startOffset" : 86,
      "endOffset" : 110
    }, {
      "referenceID" : 6,
      "context" : "Cotterell et al. (2016) estimate how often the inflection process involves prefix changes, stem-internal changes or suffix changes, the results of which are shown in Tab.",
      "startOffset" : 0,
      "endOffset" : 24
    } ],
    "year" : 2017,
    "abstractText" : "Labeled sequence transduction is a task of transforming one sequence into another sequence that satisfies desiderata specified by a set of labels. In this paper we propose multi-space variational encoderdecoders, a new model for labeled sequence transduction with semi-supervised learning. The generative model can use neural networks to handle both discrete and continuous latent variables to exploit various features of data. Experiments show that our model provides not only a powerful supervised framework but also can effectively take advantage of the unlabeled data. On the SIGMORPHON morphological inflection benchmark, our model outperforms single-model state-ofart results by a large margin for the majority of languages.1",
    "creator" : "LaTeX with hyperref package"
  }
}