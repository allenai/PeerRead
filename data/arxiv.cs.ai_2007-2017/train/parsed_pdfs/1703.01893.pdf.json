{
  "name" : "1703.01893.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Approximate Muscle Guided Beam Search for Three-Index Assignment Problem",
    "authors" : [ "He Jiang", "Shuwei Zhang", "Zhilei Ren", "Xiaochen Lai", "Yong Piao" ],
    "emails" : [ "jianghe@dlut.edu.cn" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Problem (AP3) has attracted lots of research efforts for developing heuristics. However, existing heuristics either obtain less competitive solutions or consume too much running time. In this paper, a new heuristic named Approximate Muscle guided Beam Search (AMBS) is developed to achieve a good trade-off between solution quality and running time. By combining the approximate muscle with beam search, the solution space size can be significantly decreased, thus the time for searching the solution can be sharply reduced. Extensive experimental results on the benchmark indicate that the new algorithm is able to obtain solutions with competitive quality and it can be employed on instances with large-scale. Work of this paper not only proposes a new efficient heuristic, but also provides a promising method to improve the efficiency of beam search.\nKeywords: Combinatorial Optimization, Heuristic, Muscle, Beam Search"
    }, {
      "heading" : "1 Introduction",
      "text" : "The Three-Index Assignment Problem (AP3) was first introduced by Pierskalla [1, 2], which is a well-known NP-hard problem with wide applications, including addressing a rolling mill, scheduling capital investments, military troop assignment, satellite coverage optimization [1, 2], scheduling teaching practice [3], and production of printed circuit boards [4]. It can be viewed as an optimization problem on a 0-1 programming model:\nmin   Ii Jj Kk ijkijk xc\nsubject to\n1  Jj Kk ijkx , Ii\n1  Ii Kk ijkx , Jj\n1  Ii Jj ijkx , Kk\n}1,0{ijkx , KkJjIi  ,,\nwhere },...,3,2,1{ nKJI  .\nThe solution of AP3 can be presented by two permutations:\nmin n\ni\niqipic )(),(, , Niqip )(),(\nwhere N presents the set of all permutations on the integer set },...,2,1{ NN  . Due to its intractability, there have been lots of exact and heuristic algorithms proposed to solve it, including Balas and Saltzman [5], Crama and Spieksma [6], Burkard and Rudolf [7], Pardalos and Pitsoulis [8], Voss [9], Aiex, Resende, Pardalos, and Toraldo [10], Huang and Lim [11], Jiang, Xuan, and Zhang [12]. Among these algorithms, LSGA proposed by Huang and Lim [11], and AMGO proposed by Jiang, Xuan, and Zhang [12] perform better than the other heuristics. LSGA is a hybridization of a genetic algorithm and a local search algorithm, which projects AP3 into AP2. It can obtain a solution within quite a short time. However, on difficult instances, LSGA might not perform well in terms of the solution quality. AMGO includes two phases, the sampling phase and the global optimization phase. In the sampling phase, a number of local optima are produced, and make up a smaller search space. In the second phase, a recursive procedure is employed on the new search space to find a better solution. In contrast to LSGA, AMGO can obtain better solutions with high quality. However, the running time of AMGO is intolerable on large instances. It would be ideal to achieve a good trade-off between solution quality and running time.\nTo tackle the challenges in balancing solution quality and running time, we propose a new heuristic named Approximate Muscle guided Beam Search (AMBS), which combines two phases. In the first phase, namely the sampling phase, a multirestart local search algorithm is used to generate the approximate muscle. The muscle is the union of optimal solutions. Obviously, if we could get the muscle, it would be quite easy for us to obtain the optimal solution because the search space is significantly reduced. However, it has been proved that there is no polynomial time algorithm to get the muscle of an AP3 instance [12]. We can use an alternative method by using the union of local optima to approximate the muscle. The search will be restricted in the approximate muscle so that the search space is reduced dramatically. In the latter phase, namely the search phase, beam search is employed to obtain a solution on the approximate muscle. Beam search is an adaptation of breadthfirst search, in which only the most promising nodes are selected for further branching at each level rather than all the nodes. Because it just searches the promising branches, the running time will not be intolerable. By combining the approximate muscle and beam search, we can obtain solutions with relatively high quality in a short time. Experimental results on the standard AP3 benchmark indicate that the new heuristic is able to obtain solutions with competitive quality and it can be employed on instances with large-scale. In terms of solution quality, the solutions obtained by AMBS are better than LSGA and not worse than the pure beam search, while in terms of running time, AMBS is able to deal with large instances that AMGO and the pure beam search cannot.\nThe rest of this paper is organized as follow. In Section 2, we shall give a review of the muscle and beam search. In section 3, we shall propose the framework of AMBS. Experiment results will be reported in Section 4. Finally, the conclusion of this paper will be presented in Section 5."
    }, {
      "heading" : "2 Muscle and Beam Search",
      "text" : "In this section, we present the two conceptions related to this paper, namely the muscle and beam search. For each concept, we first briefly review its related work and then present its details."
    }, {
      "heading" : "2.1 Muscle",
      "text" : "The proposition of the concept muscle is inspired by the backbone. The backbone is an important tool for NP-hard problem, which means the shared common parts of optimal solutions for an instance. Lots of heuristic algorithms have been proposed with the concept backbone. For example, Schneider used the intersection of local optima as the approximate backbone to solve the traveling salesman problem (TSP) [13], Zhang and Looks developed a LK algorithm guided by backbone for the traveling salesman problem [14], Xuan, Jiang, Ren, and Luo presented a backbonebased multilevel algorithm to solve the large scale next release problem [15].\nIn contrast to the backbone, the muscle is the union of optimal solutions. It was first proposed by Jiang, Xuan, and Zhang in 2008 [12]. Some efficient algorithms have been proposed using the muscle. For example, Jiang and Chen developed an algorithm for solving the Generalized Minimum Spanning Tree problem with the muscle [16]. Obviously, if the muscle could be obtained, the search space for an instance would be decreased sharply. However, Jiang has proved that there is no polynomial time algorithm to obtain the muscle for AP3 problem under the assumption NPP  . It is intractable to obtain a fraction of the muscle as well [12].\nNow that the muscle cannot be obtained directly, there are some other ways to approximate the muscle for AP3. The \"big valley\" structure appears in lots of problem models, including the travelling salesman problem (TSP) [17], the graph partitioning problem [18], the job shop scheduling [19], etc. This structure suggests that the clusters formed by a lot of local optima will be around the optimal solutions. The experiments conducted by Jiang indicate that the probability that the union of local optima contains the optimal solution increases with the growth of the number of local optimum, while the size of the union increases slower [12]. Hence, we can use the union of local optima to approximate the muscle to decrease the search space, and we can name the union as the approximate muscle.\nHowever, the approximate muscle varies with the difficulty of instances. On difficult instances, the local optima have less common triples, thus, the size of the approximate muscle will be larger. On easy instances, the local optima have more common triples, thus, the size of the approximate muscle will be smaller. Although the search space has been decreased by using the approximate muscle, the search space for AP3 problem still increases exponentially. If an exhaustive search algorithm is employed on the approximate muscle of a large instance, the running time will be unacceptable."
    }, {
      "heading" : "2.2 Beam Search",
      "text" : "Beam search is a widely-used heuristic algorithm. For example, Cazenave combined Nested Monte-Carlo Search with beam search to enhance Nested Monte-Carlo Search [20], López-Ibáñez and Blum combined beam search with ant colony optimization to solve the travelling salesman problem (TSP) with time windows [21].\nBeam search can be viewed as an adaptation of branch-and-bound search, or an optimization of best-first search. By branching the most promising nodes at each level rather than the whole search tree, beam search can find a solution with relatively high quality within practical time and memory limits.\nThe standard version of beam search builds its search tree using breadth-first search. At each level of the search tree, a heuristic algorithm is employed to estimate all the successors, and the nodes are sorted in the order of the heuristic cost, then a predetermined number of best nodes are stored, while the others are pruned off permanently. The predetermined number is called the beam width. By varying the beam width, beam search varies from greedy search to a complete breadth-first search. When the beam width equals to 1, it becomes a greedy search. When there is no limit to the beam width, it becomes a breadth-first search. By limiting the beam width, the complexity of the search becomes polynomial instead of exponential. We call the standard version of beam search as the pure beam search, in order to distinguish it with AMBS."
    }, {
      "heading" : "3 Approximate Muscle Guided Beam Search for AP3",
      "text" : "In this section, we introduce the details of our algorithm AMBS. As mentioned before, AMBS includes two phases, the sampling phase and the search phase. We will first present the framework of our algorithm, and then show the details of each phase in the following subsections."
    }, {
      "heading" : "3.1 AMBS for AP3",
      "text" : "The framework of the algorithm is shown in Algorithm 1. There are three inputs for AMBS, i.e. the AP3 instance, denoted by ),,,(3 cKJIAP , the number of sampling,\ndenoted by k , and the beam width, denoted by width. The output of this algorithm\nis the solution of the input instance, denoted by *s . The instance of AP3 is stored in a\nthree-dimensional array, in which an element represents cost ijkc , as introduced in\nsection 1. The solution is stored in two arrays, which record the two permutations.\nAs shown in Algorithm 1, AMBS has two phases. In the beginning of the search phase, the order of search level for beam search is sorted. This is a preprocessing for beam search to get the map of level of the search tree and the index of I of the approximate muscle. A search level means an index of I . For example, the level ][iorder of the search tree has the nodes which corresponds to the triples whose index\nI is i in the approximate muscle. More details about building the search tree is\nintroduced in section 3.3. The order of search level is sorted in ascending order by the\nnumber of triples at the corresponding index, i.e. the number of nodes in each level in the search tree. In this way, there will be fewer nodes in the higher level. When calculating the lower bound of each branch, which is employed in beam search frequently, more time will be consumed when the branch is at the higher level. Thus, after the sorting, beam search will take less searching time.\nIn the following subsections, we will discuss the details of two phases, respectively."
    }, {
      "heading" : "3.2 Approximate Muscle for AP3",
      "text" : "In the first phase, namely the sampling phase, the muscle is obtained for the further searching. Although the muscle cannot be obtained directly, we can use the union of local optima to approximate the muscle. Thus, the main purpose of this phase is to obtain different local optima and get the union of them.\nThe detail of generating the local optima is shown in Algorithm 2. The inputs of Algorithm 2 are an instance of AP3 problem and the number of sampling times of sampling. The instance is denoted by ),,,(3 cKJIAP , and the number of sampling\ntime is denoted by k . The output of Algorithm 2 includes the approximate muscle of\nthe input instance, which is denoted by musclea _ , and the best solution obtained in\nthe sampling phase, which is used as the upper bound of the search phase. The approximate muscle is stored in a three-dimensional array, the same as the storage of an instance, where the cost is the same value as the instance if this cost is sampled, or infinite if the corresponding cost is not sampled.\nIn the beginning, the approximate muscle is initialized as an empty set, which means all the values of the approximate muscle is infinite (line(1)). Then k local\noptima are obtained, and make up the approximate muscle (line(2)-line(15)). A random feasible solution is generate by swapping the order of permutations p and\nq randomly (line(3)-line(11)). Then a local search algorithm is applied to the\nrandom solution to obtain a local optimum (line(12)). The local search algorithm we use here is the Hungarian local search, which is proposed by Huang and Lim [11]. Once a local optimum is obtained, it is added to the approximate muscle(line(13)),\nAlgorithm 1: AMBS for AP3 Input: AP3 instance ),,,(3 cKJIAP , k , width\nOutput: solution s\nBegin //the sampling phase (1) obtain the approximate muscle musclea _ and a solution 's as the\nupper bound with the algorithm )),,,,(3( kcKJIAPGenerateAM ;\n//the search phase (2) sort the search order of the approximate muscle and get the order ;\n(3) obtain the solution s with the beam search algorithm\n),',,_( orderswidthmuscleaBS ;\nEnd\nand compared to the best local optimum ever found, then the better solution will be kept as the best local optimum (line(14))."
    }, {
      "heading" : "3.3 Beam Search for AP3",
      "text" : "In the second phase, namely the search phase, we use beam search on the approximate muscle to find a better solution.\nBefore the introduction of beam search for AP3, we will first present how we build the breadth-first search tree for AP3 problem. An instance of AP3 can be represented as a three-dimensional matrix. First, the matrix is divided into n layers based on the\nindex I , i.e. the triples with the same index I are in the same layer. Each layer corresponds to a level in the search tree. For example, an instance with the size of 4 is divided into 4 layers. Select a layer to be level 1 of the search tree (level 0 of the search tree is the root, which represents nothing). Thus, there are 16 (4*4) nodes in level 1. Then another layer is selected to build level 2 of the search tree. Since one triple has been determined in level 1, the triples in the same row and column will no longer be considered, there are 9 (3*3) successors of each node in level 1. Thus, 144 (9*16) nodes are in level 2 in all. In the same way, level 3 and level 4 are built. If we use the muscle rather than the whole instance to build the search tree, only the triples in the muscle are taken into consideration, rather than all the triples in each layers. Every node in the search tree represents a triple of the instance, except the root node. A path from the root to a leaf in the search tree represents a solution of the instance.\nAlgorithm 2: GenerateAM (Generate Approximate Muscle) Input: AP3 instance ),,,(3 cKJIAP , k\nOutput: musclea _ , solution 's\nBegin (1) musclea _\n(2) for 1counter to k do\n(3) for 1i to n do\n(4) iip ][ , iiq ][ ;\n(5) for 1i to n do\n(6) let j be a random integer between 1 and n ;\n(7) swap ][ip and ][ jp ;\n(8) for 1i to n do\n(9) let j be a random integer between 1 and n ;\n(10) swap ][iq and ][ jq ;\n(11) let }1|])[],[,{( niiqipis  ;\n(12) obtain a local optimum locals by applying the local search to s ; (13) localsmucleamusclea __  ; (14) if )'()( scsc local  then localss '\nEnd\nThe detail of beam search for AP3 is presented in Algorithm 3. The inputs of Algorithm 3 are the approximate muscle musclea _ , the beam width width, the best\nlocal 's , and the search order order . The output of Algorithm 3 is the solution s of this AP3 instance.\nAs mentioned before, beam search builds its search tree using breadth-first search. The nodes in each level of the search tree represent the triples with the same index I . The algorithm searches the tree level by level first (line(1)-line(13)). A candidate represents an incomplete solution, or the nodes on an incomplete search path, i.e. part of the triples in a solution, or a branch stored to be searched. When the search comes to a certain level, the lower bounds of all the successors of each candidate are generated (line(2)-line(8)). For each candidate, the determined triples are recorded first using the array fp and fq . In this way, the constraints of AP3 can be\nguaranteed, and the sub-problem can be obtained (line(3)-line(4)). Then the lower bounds of successors of this candidate are calculated (line(5)-line(8)). The lower bound of a successor includes three parts: the value of candidate, which means the sum of the triples' cost in the candidate, the cost of the triple relevant to the successor, and lower bound of the sub-problem. The sub-problem is the approximate muscle without the layers containing the determined triples. The algorithm that we use here for calculating the lower bound is the Projection method followed by a Hungarian algorithm, which is proposed by Kim et al. [22]. All the successors of each candidate are sorted in ascending order according to their lower bounds (line(9)). If some successors have the same lower bound, the successor whose predecessor (i.e. the\nAlgorithm 3: BS (Beam Search) Input: musclea _ , width, solution 's , order\nOutput: solution s\nBegin (1) for every level based on order in the search tree do\n(2) for every candidate do (3) for every triple ),,( kji candidate do\n(4) truekfqtruejfp  ][,][ ;\n(5) for every triple muscleakjlevelorder _),],[(  do\n(6) if falsejfp ][ and falsekfq ][ then\n(7) generate the sub-problem; (8) calculate the lower bound of the branch; (9) sort the branches of all the candidate; (10) for 1i to width do\n(11) if lower bound of the branch < )'(sc then\n(12) this branch belongs to the new candidates; (13) else break; (14) employ the local search algorithm on every candidate and choose the\nbest to be the solution s\nEnd\ncandidate) has the smaller average lower bounds of all the successors will rank more forward. In the end, at most width successors are kept to be the new candidates, and\nall the new candidates must have a smaller lower bound than the cost of solution 's\n(line(10)-line(13)). After the search in the search tree, a local search algorithm is employed to the remaining candidates, which have become the solutions of the instance. Then the best candidate is chosen to be the solution s . If all the candidates\nhave higher lower bound or cost than the cost of solution 's , there will be no\ncandidate remained, the solution 's will be chosen as the s (line(14)).\nSince the approximate muscle is stored in the same way as an instance, beam\nsearch algorithm can be used to solve AP3 problem independently."
    }, {
      "heading" : "4 Experimental Result",
      "text" : "In this section, we first show the result of parameter tuning. Then we present the experimental results of our algorithm on the benchmark compared with LSGA, AMGO, and the pure beam search. The codes are implemented with C++ under windows 7 using visual studio 2010 on a computer with Intel Core i3-M330 2.13G."
    }, {
      "heading" : "4.1 Parameter Tuning",
      "text" : "Two parameters are used in AMBS, the number of sampling and the beam width. We determine the number of sampling as 1000, the same value in AMGO [12]. As for the beam width, we test different beam widths {100, 200, 300, 400} on some instances from Balas and Saltzman Dataset (see Section 4.2) and Crama and Spieksma Dataset (see Section 4.3). The instances of Balas and Saltzman Dataset we used are the instances of large size, i.e. bs_14_x.dat, bs_18_x.dat, bs_22_x.dat, and bs_26_x.dat. Here x means 1 to 5, since there are 5 instances of each size. The instances of Crama and Spieksma Dataset we used are the first instance of each type, each size, i.e. 3DA99N1 (Type I, size 33), 3DA198N1 (Type I, size 66), 3DIJ99N1 (Type II, size 33), 3DI198N1 (Type II, size 66), 3D1299N1 (Type III, size 33), and 3D1198N1 (Type III, size 66).\nTable 1 shows the result of our parameter tuning experiment. We run the algorithm 10 times on the instances of the Balas and Saltzman Dataset with each beam width, while run it once on the instances of Crama and Spieksma Dataset with each beam width since the instances of Crama and Spieksma Dataset are much larger but the result of each instance varies little. The value of Balas and Saltzman Dataset in the table is the average value of each size. The experimental result indicates that, on most of the instances, the quality of the solution rises with the increase of the beam width, while the running time grows, too. The running time grows linearly with the increase of the beam width. Note that the running time of 3DA99N1, 3DA198N1 and 3D1299N1 keeps the same in different beam widths. The approximate muscle space for 3DA99N1 is so small that when the beam width is 100, beam search has become a complete search. As for 3DA198N1, after the sort for search level, the number of node on the higher level is 1, while the search on the lower level is quite quick, thus the running time varies little when the beam width changes. When testing 3D1299N1,\nthe upper bound found in the sampling phase is the same as the smallest lower bound of the first level in the search tree, thus the upper bound is the optimal solution of the instance and all the branches are pruned, the search terminates. Among these instances, the running time of 3DI198N1 is the longest. When the beam width is 300, the running time is about 20 minutes. In order to balance the quality of the solution and the running time, we determine the beam width as 300 in the rest of experiments."
    }, {
      "heading" : "4.2 Balas and Saltzman Dataset",
      "text" : "This dataset is generated by Balas and Saltzman [5] which contains 60 instances with size of 4, 6, 8, ..., 24, 26. For each size, five instances are generated randomly with the cost between 0 and 100.\nTable 2 shows the experimental result on this dataset. Each row represents the average cost of the same size. The column \"Opt.\" is the optimal solution reported by Balas and Saltzman [5]. The column \"LSGA\" is the result reported in Huang's paper [11], where a Pentium III 800MHz PC is used for the experiment. The column \"AMGO\" is the results of the program implemented according to Jiang's paper [12]. Interestingly, the average cost of size 26 is 1 in this column, which is better than the optimal solution reported by Balas and Saltzman. Because the average of any five integers cannot be 1.3, we think than it may be a typo in Balas's paper. The solutions of these five instances found in this paper are 0, 0, 2, 1, 2, respectively. The column \"Beam Search\" is the result of the pure beam search for AP3. The sampling phase remains to get the upper bound of an instance. The column \"AMBS\" is the result of our algorithm. The results of AMGO, the pure beam search and AMBS are the average cost after running the algorithm 10 times on each instance.\nThe result indicates that AMBS can get solutions with higher quality than LSGA. AMGO can generate the best solutions, and the running time is quite short on this dataset, because it employs a global search on the approximate muscle and the search space of the approximate is quite small. AMBS uses an incomplete search and needs to estimate the lower bound of each branch, thus, the quality of solutions is a little\nworse and the running time is longer than AMGO. Compared with the pure beam search, the running time of AMBS is about one-tenth of the pure beam search, but the quality of the solutions of AMBS is comparable to that of beam search. The reason is that with the introduction of the muscle, when calculating the lower bounds of all the successors of each level, there are much fewer successors in the approximate muscle."
    }, {
      "heading" : "4.3 Crama and Spieksma Dataset",
      "text" : "This dataset is generated by Crama and Spieksma [6]. This dataset contains three types of instance. In each types, there are three instances with the size of 33, and three instances with the size of 66.\nTable 2 shows the experimental result on this dataset. The column \"LSGA\" is the result reported in Huang's paper [11]. The column \"AMGO\" is the result of AMGO implemented according Jiang's paper, too. The column \"Beam Search\" is the result of the pure beam search without the approximate muscle. The column \"AMBS\" is the result of our algorithm. AMGO, the pure beam search and AMBS are executed once, and the results of the algorithms are reported in Table 2. In the table, there are some cells with no value in it, this is because the running time is longer than 30 minutes, and we regard this time as unacceptable.\nFrom the result, we can see that AMBS is able to run on every instance, and obtain a solution with high quality, however, AMGO and the pure beam search are not able to deal with a number of instances in this dataset because it takes too much time. The running time of LSGA is quite short, but the solution quality is high, this is because LSGA is an iterative algorithm rather than a tree search, and the instances in this dataset are easy to solve. If the instance is hard to solve, like the large instance in Balas and Saltzman Dataset, the quality of solutions of LSGA might not be that high."
    }, {
      "heading" : "33 3DA99N1 1608 0.03 1608 7.60 1608 649.74 1608 7.24",
      "text" : ""
    }, {
      "heading" : "33 3DA99N2 1401 0.11 1401 7.11 1401 1733.90 1401 6.52",
      "text" : ""
    }, {
      "heading" : "33 3DA99N3 1604 0.11 1586 7.61 1604 1606.99 1604 7.30",
      "text" : ""
    }, {
      "heading" : "66 3DA198N1 2662 0.55 2662 71.22 - - 2662 63.15",
      "text" : ""
    }, {
      "heading" : "66 3DA198N2 2449 0.27 - - - - 2449 74.20",
      "text" : ""
    }, {
      "heading" : "66 3DA198N3 2758 0.58 - - - - 2758 82.07",
      "text" : ""
    }, {
      "heading" : "33 3DIJ99N1 4797 0.11 - - - - 4797 20.33",
      "text" : ""
    }, {
      "heading" : "33 3DIJ99N2 5067 0.26 - - - - 5067 35.95",
      "text" : ""
    }, {
      "heading" : "33 3DIJ99N3 4287 0.26 - - - - 4287 26.07",
      "text" : ""
    }, {
      "heading" : "66 3DI198N1 9684 4.86 - - - - 9684 1219.82",
      "text" : ""
    }, {
      "heading" : "66 3DI198N2 8944 3.35 - - - - 8944 929.51",
      "text" : ""
    }, {
      "heading" : "66 3DI198N3 9745 3.09 - - - - 9745 767.66",
      "text" : ""
    }, {
      "heading" : "33 3D1299N1 133 0.01 - - 133 3.50 133 1.73",
      "text" : ""
    }, {
      "heading" : "33 3D1299N2 131 0.03 - - 131 1128.17 131 3.94",
      "text" : ""
    }, {
      "heading" : "33 3D1299N3 131 0.02 131 1.98 131 580.97 131 3.31",
      "text" : ""
    }, {
      "heading" : "66 3D1198N1 286 0.15 - - - - 286 383.95",
      "text" : ""
    }, {
      "heading" : "66 3D1198N2 286 0.16 - - - - 286 341.05",
      "text" : ""
    }, {
      "heading" : "66 3D1198N3 282 0.23 - - - - 282 329.67",
      "text" : ""
    }, {
      "heading" : "5 CONCLUSION",
      "text" : "In this paper, we propose a new heuristic named Approximate Muscle guided Beam Search (AMBS) for AP3 problem. This algorithm combines the approximate muscle and beam search. AMBS includes two phases, the sampling phase, in which the approximate muscle is obtained, and the search phase, in which beam search is employed. In this way, the solution space size of AP3 problem is decreased significantly, and the search time is reduced sharply, too. Thus, AMBS can achieve a good trade-off between the solution quality and the running time. Experimental results indicate that the new algorithm is able to obtain solutions with competitive quality, and it can be employed on large-scale instances."
    } ],
    "references" : [ {
      "title" : "The tri-substitution method for the three-dimensional assignment problem",
      "author" : [ "W.P. Pierskalla" ],
      "venue" : "CORS Journal 5, 71-81",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1967
    }, {
      "title" : "Letter to the Editor—The Multidimensional Assignment Problem",
      "author" : [ "W.P. Pierskalla" ],
      "venue" : "Operations Research 16, 422-431",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1968
    }, {
      "title" : "An Algorithm for Solving 3-Dimensional Assignment Problems with Application to Scheduling a Teaching Practice",
      "author" : [ "A.M. Frieze", "J. Yadegar" ],
      "venue" : "The Journal of the Operational Research Society 32, 989-995",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1981
    }, {
      "title" : "Throughput rate optimization in the automated assembly of printed circuit boards",
      "author" : [ "Y. Crama", "A.W.J. Kolen", "A.G. Oerlemans", "F.C.R. Spieksma" ],
      "venue" : "Ann. Oper. Res. 26, 455480",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "An Algorithm for the Three-Index Assignment Problem",
      "author" : [ "E. Balas", "M.J. Saltzman" ],
      "venue" : "Operations Research 39, 150-161",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Approximation algorithms for three-dimensional assignment problems with triangle inequalities",
      "author" : [ "Y. Crama", "F.C.R. Spieksma" ],
      "venue" : "European Journal of Operational Research 60, 273-279",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "Three-dimensional axial assignment problems with decomposable cost coefficients",
      "author" : [ "R.E. Burkard", "R. Rudolf", "G.J. Woeginger" ],
      "venue" : "Discrete Applied Mathematics 65, 123-139",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Nonlinear assignment problems: algorithms and applications",
      "author" : [ "P.M. Pardalos", "L.S. Pitsoulis" ],
      "venue" : "Springer",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Heuristics for Nonlinear Assignment Problems",
      "author" : [ "S. Voss" ],
      "venue" : "Pardalos, P., Pitsoulis, L. (eds.) Nonlinear Assignment Problems, vol. 7, pp. 175-215. Springer US",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "GRASP with Path Relinking for Three-Index Assignment",
      "author" : [ "R.M. Aiex", "M.G.C. Resende", "P.M. Pardalos", "G. Toraldo" ],
      "venue" : "INFORMS J. on Computing 17, 224-247",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "A hybrid genetic algorithm for the Three-Index Assignment Problem",
      "author" : [ "G. Huang", "A. Lim" ],
      "venue" : "European Journal of Operational Research 172, 249-257",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "An approximate muscle guided global optimization algorithm for the Three-Index Assignment Problem",
      "author" : [ "H. Jiang", "J. Xuan", "X. Zhang" ],
      "venue" : "Evolutionary Computation,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2008
    }, {
      "title" : "Searching for Backbones—a high-performance parallel algorithm for solving combinatorial optimization problems",
      "author" : [ "J. Schneider" ],
      "venue" : "Future Generation Computer Systems 19, 121-131",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "A novel local search algorithm for the traveling salesman problem that exploits backbones",
      "author" : [ "W. Zhang", "M. Looks" ],
      "venue" : "Proceedings of the 19th international joint conference on Artificial intelligence, pp. 343-348. Morgan Kaufmann Publishers Inc., Edinburgh, Scotland",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Solving the Large Scale Next Release Problem with a Backbone-Based Multilevel Algorithm",
      "author" : [ "J. Xuan", "H. Jiang", "Z. Ren", "Z. Luo" ],
      "venue" : "Software Engineering, IEEE Transactions on 38, 1195-1212",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "An efficient algorithm for generalized minimum spanning tree problem",
      "author" : [ "H. Jiang", "Y. Chen" ],
      "venue" : "Proceedings of the 12th annual conference on Genetic and evolutionary computation, pp. 217-224. ACM, Portland, Oregon, USA",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Cost Versus Distance In the Traveling Salesman Problem",
      "author" : [ "K.D. Boese" ],
      "venue" : "Technical Report CSD-950018",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Fitness Landscapes, Memetic Algorithms, and Greedy Operators for Graph Bipartitioning",
      "author" : [ "P. Merz", "B. Freisleben" ],
      "venue" : "Evol. Comput. 8, 61-91",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Landscapes, operators and heuristic search",
      "author" : [ "C.R. Reeves" ],
      "venue" : "Annals of Operations Research 86, 473-490",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Monte Carlo Beam Search",
      "author" : [ "T. Cazenave" ],
      "venue" : "Computational Intelligence and AI in Games, IEEE Transactions on 4, 68-72",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Beam-ACO for the travelling salesman problem with time windows",
      "author" : [ "M. López-Ibáñez", "C. Blum" ],
      "venue" : "Computers & Operations Research 37, 1570-1583",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Lower bounds for the axial three-index assignment problem",
      "author" : [ "Kim", "B.-J.", "W.L. Hightower", "P.M. Hahn", "Zhu", "Y.-R.", "L. Sun" ],
      "venue" : "European Journal of Operational Research 202, 654-668",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "The Three-Index Assignment Problem (AP3) was first introduced by Pierskalla [1, 2], which is a well-known NP-hard problem with wide applications, including addressing a rolling mill, scheduling capital investments, military troop assignment, satellite coverage optimization [1, 2], scheduling teaching practice [3], and production of printed circuit boards [4].",
      "startOffset" : 76,
      "endOffset" : 82
    }, {
      "referenceID" : 1,
      "context" : "The Three-Index Assignment Problem (AP3) was first introduced by Pierskalla [1, 2], which is a well-known NP-hard problem with wide applications, including addressing a rolling mill, scheduling capital investments, military troop assignment, satellite coverage optimization [1, 2], scheduling teaching practice [3], and production of printed circuit boards [4].",
      "startOffset" : 76,
      "endOffset" : 82
    }, {
      "referenceID" : 0,
      "context" : "The Three-Index Assignment Problem (AP3) was first introduced by Pierskalla [1, 2], which is a well-known NP-hard problem with wide applications, including addressing a rolling mill, scheduling capital investments, military troop assignment, satellite coverage optimization [1, 2], scheduling teaching practice [3], and production of printed circuit boards [4].",
      "startOffset" : 274,
      "endOffset" : 280
    }, {
      "referenceID" : 1,
      "context" : "The Three-Index Assignment Problem (AP3) was first introduced by Pierskalla [1, 2], which is a well-known NP-hard problem with wide applications, including addressing a rolling mill, scheduling capital investments, military troop assignment, satellite coverage optimization [1, 2], scheduling teaching practice [3], and production of printed circuit boards [4].",
      "startOffset" : 274,
      "endOffset" : 280
    }, {
      "referenceID" : 2,
      "context" : "The Three-Index Assignment Problem (AP3) was first introduced by Pierskalla [1, 2], which is a well-known NP-hard problem with wide applications, including addressing a rolling mill, scheduling capital investments, military troop assignment, satellite coverage optimization [1, 2], scheduling teaching practice [3], and production of printed circuit boards [4].",
      "startOffset" : 311,
      "endOffset" : 314
    }, {
      "referenceID" : 3,
      "context" : "The Three-Index Assignment Problem (AP3) was first introduced by Pierskalla [1, 2], which is a well-known NP-hard problem with wide applications, including addressing a rolling mill, scheduling capital investments, military troop assignment, satellite coverage optimization [1, 2], scheduling teaching practice [3], and production of printed circuit boards [4].",
      "startOffset" : 357,
      "endOffset" : 360
    }, {
      "referenceID" : 4,
      "context" : "Due to its intractability, there have been lots of exact and heuristic algorithms proposed to solve it, including Balas and Saltzman [5], Crama and Spieksma [6], Burkard and Rudolf [7], Pardalos and Pitsoulis [8], Voss [9], Aiex, Resende, Pardalos, and Toraldo [10], Huang and Lim [11], Jiang, Xuan, and Zhang [12].",
      "startOffset" : 133,
      "endOffset" : 136
    }, {
      "referenceID" : 5,
      "context" : "Due to its intractability, there have been lots of exact and heuristic algorithms proposed to solve it, including Balas and Saltzman [5], Crama and Spieksma [6], Burkard and Rudolf [7], Pardalos and Pitsoulis [8], Voss [9], Aiex, Resende, Pardalos, and Toraldo [10], Huang and Lim [11], Jiang, Xuan, and Zhang [12].",
      "startOffset" : 157,
      "endOffset" : 160
    }, {
      "referenceID" : 6,
      "context" : "Due to its intractability, there have been lots of exact and heuristic algorithms proposed to solve it, including Balas and Saltzman [5], Crama and Spieksma [6], Burkard and Rudolf [7], Pardalos and Pitsoulis [8], Voss [9], Aiex, Resende, Pardalos, and Toraldo [10], Huang and Lim [11], Jiang, Xuan, and Zhang [12].",
      "startOffset" : 181,
      "endOffset" : 184
    }, {
      "referenceID" : 7,
      "context" : "Due to its intractability, there have been lots of exact and heuristic algorithms proposed to solve it, including Balas and Saltzman [5], Crama and Spieksma [6], Burkard and Rudolf [7], Pardalos and Pitsoulis [8], Voss [9], Aiex, Resende, Pardalos, and Toraldo [10], Huang and Lim [11], Jiang, Xuan, and Zhang [12].",
      "startOffset" : 209,
      "endOffset" : 212
    }, {
      "referenceID" : 8,
      "context" : "Due to its intractability, there have been lots of exact and heuristic algorithms proposed to solve it, including Balas and Saltzman [5], Crama and Spieksma [6], Burkard and Rudolf [7], Pardalos and Pitsoulis [8], Voss [9], Aiex, Resende, Pardalos, and Toraldo [10], Huang and Lim [11], Jiang, Xuan, and Zhang [12].",
      "startOffset" : 219,
      "endOffset" : 222
    }, {
      "referenceID" : 9,
      "context" : "Due to its intractability, there have been lots of exact and heuristic algorithms proposed to solve it, including Balas and Saltzman [5], Crama and Spieksma [6], Burkard and Rudolf [7], Pardalos and Pitsoulis [8], Voss [9], Aiex, Resende, Pardalos, and Toraldo [10], Huang and Lim [11], Jiang, Xuan, and Zhang [12].",
      "startOffset" : 261,
      "endOffset" : 265
    }, {
      "referenceID" : 10,
      "context" : "Due to its intractability, there have been lots of exact and heuristic algorithms proposed to solve it, including Balas and Saltzman [5], Crama and Spieksma [6], Burkard and Rudolf [7], Pardalos and Pitsoulis [8], Voss [9], Aiex, Resende, Pardalos, and Toraldo [10], Huang and Lim [11], Jiang, Xuan, and Zhang [12].",
      "startOffset" : 281,
      "endOffset" : 285
    }, {
      "referenceID" : 11,
      "context" : "Due to its intractability, there have been lots of exact and heuristic algorithms proposed to solve it, including Balas and Saltzman [5], Crama and Spieksma [6], Burkard and Rudolf [7], Pardalos and Pitsoulis [8], Voss [9], Aiex, Resende, Pardalos, and Toraldo [10], Huang and Lim [11], Jiang, Xuan, and Zhang [12].",
      "startOffset" : 310,
      "endOffset" : 314
    }, {
      "referenceID" : 10,
      "context" : "Among these algorithms, LSGA proposed by Huang and Lim [11], and AMGO proposed by Jiang, Xuan, and Zhang [12] perform better than the other heuristics.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 11,
      "context" : "Among these algorithms, LSGA proposed by Huang and Lim [11], and AMGO proposed by Jiang, Xuan, and Zhang [12] perform better than the other heuristics.",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 11,
      "context" : "However, it has been proved that there is no polynomial time algorithm to get the muscle of an AP3 instance [12].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 12,
      "context" : "For example, Schneider used the intersection of local optima as the approximate backbone to solve the traveling salesman problem (TSP) [13], Zhang and Looks developed a LK algorithm guided by backbone for the traveling salesman problem [14], Xuan, Jiang, Ren, and Luo presented a backbonebased multilevel algorithm to solve the large scale next release problem [15].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 13,
      "context" : "For example, Schneider used the intersection of local optima as the approximate backbone to solve the traveling salesman problem (TSP) [13], Zhang and Looks developed a LK algorithm guided by backbone for the traveling salesman problem [14], Xuan, Jiang, Ren, and Luo presented a backbonebased multilevel algorithm to solve the large scale next release problem [15].",
      "startOffset" : 236,
      "endOffset" : 240
    }, {
      "referenceID" : 14,
      "context" : "For example, Schneider used the intersection of local optima as the approximate backbone to solve the traveling salesman problem (TSP) [13], Zhang and Looks developed a LK algorithm guided by backbone for the traveling salesman problem [14], Xuan, Jiang, Ren, and Luo presented a backbonebased multilevel algorithm to solve the large scale next release problem [15].",
      "startOffset" : 361,
      "endOffset" : 365
    }, {
      "referenceID" : 11,
      "context" : "It was first proposed by Jiang, Xuan, and Zhang in 2008 [12].",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 15,
      "context" : "For example, Jiang and Chen developed an algorithm for solving the Generalized Minimum Spanning Tree problem with the muscle [16].",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 11,
      "context" : "It is intractable to obtain a fraction of the muscle as well [12].",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 16,
      "context" : "The \"big valley\" structure appears in lots of problem models, including the travelling salesman problem (TSP) [17], the graph partitioning problem [18], the job shop scheduling [19], etc.",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 17,
      "context" : "The \"big valley\" structure appears in lots of problem models, including the travelling salesman problem (TSP) [17], the graph partitioning problem [18], the job shop scheduling [19], etc.",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 18,
      "context" : "The \"big valley\" structure appears in lots of problem models, including the travelling salesman problem (TSP) [17], the graph partitioning problem [18], the job shop scheduling [19], etc.",
      "startOffset" : 177,
      "endOffset" : 181
    }, {
      "referenceID" : 11,
      "context" : "The experiments conducted by Jiang indicate that the probability that the union of local optima contains the optimal solution increases with the growth of the number of local optimum, while the size of the union increases slower [12].",
      "startOffset" : 229,
      "endOffset" : 233
    }, {
      "referenceID" : 19,
      "context" : "For example, Cazenave combined Nested Monte-Carlo Search with beam search to enhance Nested Monte-Carlo Search [20], López-Ibáñez and Blum combined beam search with ant colony optimization to solve the travelling salesman problem (TSP) with time windows [21].",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 20,
      "context" : "For example, Cazenave combined Nested Monte-Carlo Search with beam search to enhance Nested Monte-Carlo Search [20], López-Ibáñez and Blum combined beam search with ant colony optimization to solve the travelling salesman problem (TSP) with time windows [21].",
      "startOffset" : 254,
      "endOffset" : 258
    }, {
      "referenceID" : 10,
      "context" : "The local search algorithm we use here is the Hungarian local search, which is proposed by Huang and Lim [11].",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 21,
      "context" : "[22].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "We determine the number of sampling as 1000, the same value in AMGO [12].",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 4,
      "context" : "This dataset is generated by Balas and Saltzman [5] which contains 60 instances with size of 4, 6, 8, .",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 4,
      "context" : "\" is the optimal solution reported by Balas and Saltzman [5].",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 10,
      "context" : "The column \"LSGA\" is the result reported in Huang's paper [11], where a Pentium III 800MHz PC is used for the experiment.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 11,
      "context" : "The column \"AMGO\" is the results of the program implemented according to Jiang's paper [12].",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 5,
      "context" : "This dataset is generated by Crama and Spieksma [6].",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 10,
      "context" : "The column \"LSGA\" is the result reported in Huang's paper [11].",
      "startOffset" : 58,
      "endOffset" : 62
    } ],
    "year" : 2017,
    "abstractText" : "As a well-known NP-hard problem, the Three-Index Assignment Problem (AP3) has attracted lots of research efforts for developing heuristics. However, existing heuristics either obtain less competitive solutions or consume too much running time. In this paper, a new heuristic named Approximate Muscle guided Beam Search (AMBS) is developed to achieve a good trade-off between solution quality and running time. By combining the approximate muscle with beam search, the solution space size can be significantly decreased, thus the time for searching the solution can be sharply reduced. Extensive experimental results on the benchmark indicate that the new algorithm is able to obtain solutions with competitive quality and it can be employed on instances with large-scale. Work of this paper not only proposes a new efficient heuristic, but also provides a promising method to improve the efficiency of beam search.",
    "creator" : "Microsoft® Office Word 2007"
  }
}