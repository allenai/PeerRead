{
  "name" : "1105.5451.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Maria Fox", "Derek Long" ],
    "emails" : [ "maria.fox@dur.ac.uk", "d.p.long@dur.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Journal of Arti cial Intelligence Research 9 (1998) 367-421 Submitted 7/98; published 12/98The Automatic Inference of State Invariants in TIMMaria FoxDerek LongDepartment of Computer ScienceUniversity of Durham, UK maria.fox@dur.ac.ukd.p.long@dur.ac.ukAbstractAs planning is applied to larger and richer domains the e ort involved in constructingdomain descriptions increases and becomes a signi cant burden on the human applicationdesigner. If general planners are to be applied successfully to large and complex domainsit is necessary to provide the domain designer with some assistance in building correctlyencoded domains. One way of doing this is to provide domain-independent techniques forextracting, from a domain description, knowledge that is implicit in that description andthat can assist domain designers in debugging domain descriptions. This knowledge canalso be exploited to improve the performance of planners: several researchers have exploredthe potential of state invariants in speeding up the performance of domain-independentplanners. In this paper we describe a process by which state invariants can be extractedfrom the automatically inferred type structure of a domain. These techniques are beingdeveloped for exploitation by stan, a Graphplan based planner that employs state analysistechniques to enhance its performance.1. IntroductionStan (Long & Fox, in press) is a domain-independent planner based on the constraintsatisfaction technology of Graphplan (Blum & Furst, 1995). Its name is derived from thefact that it performs a variety of pre-processing analyses (STate ANalyses) on the domaindescription to which it is applied, that assist it in planning e ciently in that domain. Stantook part in the aips-98 planning competition, the rst international competition in whichdomain-independent planners were compared in terms of their performance on well-knownbenchmark domains. Of the four planners that competed in the strips track, three werebased on the Graphplan (Blum & Furst, 1995) architecture. The most important di er-ence between stan and the other Graphplan-based planners was its use of state analysistechniques. Although these techniques were not, at that stage, fully integrated with theplanning algorithm stan gave an impressive performance as can be determined by exami-nation of the competition results. There is a description of the competition, its objectivesand the results, at the aips-98 planning competition FTP site (see Appendix A).One of the most important of the analyses performed by stan is the automatic inferenceof state invariants. As will be described in this paper, state invariants are inferred from thetype structure of the domain that is itself automatically inferred, or enriched, by stan. Thetechniques used are completely independent of the planning architecture, so can be isolatedin a pre-processing module that we call tim (Type Inference Module). Tim can be usedby any planner, regardless of whether it is based on Graphplan or on any other underlyingc 1998 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.\nFox & Longarchitecture. Tim has been implemented in c++ and executables and examples of outputare available at our web site (see Appendix A) and in Online Appendix 1.Tim takes a domain description in which no type information need be supplied and infersa rich type structure from the functional relationships between objects in the domain. If typeinformation is supplied tim can exploit it as the foundation of the type structure and willoften infer an enriched type structure on this basis. State invariants can be extracted fromthe way in which the inferred types are partitioned. The consequence is that the domaindesigner is relieved of a considerable overhead in the description of the domain. Whilst it iseasy to hand-code both types and state invariants for simple domains containing few objectsand relations, it becomes progressively more di cult to ensure cross-consistency of hand-coded invariants as domains become increasingly complex. Similarly, the exploitable typestructure of a domain may be much richer than can easily be provided by hand. We haveobserved that tim often infers unexpected type partitions that increase the discrimination ofthe type structure and provide corresponding bene ts to stan's performance. We thereforesee tim as a domain engineering tool, helping to shift the burden of domain design fromthe human to the automatic system.The usefulness of both types and state invariants is well-documented. Types have beenprovided by hand since it was rst observed that they reduce the number of operator in-stantiations that have to be considered in the traversal of a planner's search space. Theelimination of meaningless instantiations is particularly helpful in a system such as Graph-plan, in which the structure to be traversed is explicitly constructed prior to search. Webelieve that the bene ts to be obtained from type inference in planning are similar to thoseobtained in programing language design: type inference is more powerful than type checkingand can assist in the identi cation of semantic errors in the speci cation of the relationalstructure of the domain. Indeed, we have found tim to be a useful domain debuggingtool, allowing us to identify aws in some published benchmark domains. We also usedtim to reveal the underlying structure of the Mystery domain, a disguised transportationproblem domain, used in the planning competition. The Mystery domain is described inAppendix C.2.The use of domain knowledge can signi cantly improve the performance of planners,as shown by a number of researchers. Gerevini and Schubert (1996a, 1996b) have consid-ered the automatic inference of some state constraints and demonstrated that a signi cantempirical advantage can be obtained from their use. Kautz and Selman (1998) have hand-coded invariants and provided them as part of the domain description used by Blackbox.They demonstrate the performance advantages obtained and acknowledge the importance ofinferring such invariants automatically. McCluskey and Porteous (1997) have also demon-strated the important role that hand-coded state invariants can play in domain compilationfor e cient planning. Earlier work by Kelleher and Cohn (1992) and Morris and Feldman(1989) explores the automatic generation of some restricted invariant forms. We discussthese, and other, related approaches in section 5.In this paper we will describe the type inference process employed by tim and explainhow four di erent forms of state invariant can be extracted from the inferred type structure.We will argue that tim is correct since it never infers sentences that are not state invariants.We will then provide experimental results demonstrating the performance advantages thatcan be obtained by the use of types. 368\nAutomatic Inference of State Invariants fuelled\n1\nunfuelled 1\nat 1\nat\nin\nload\nunload\ndrive\ndrive\n1\n1Figure 1: A simple transportation domain seen as a collection of FSMs.2. The Type Inference ModuleOne way of viewing strips (Fikes & Nilsson, 1971) domains is as a collection of nite-statemachines (FSMs) with domain constants traversing the states within them. For example, ina simple transportation domain there are rockets and packages, with rockets being capableof being at locations and of moving, by driving, from being at one location to being atanother, and of being fuelled or unfuelled, and of moving between these two states. at canbe seen as forming a one-node FSM, and fuelled and unfuelled as forming a two-node FSM.This view is depicted in Figure 1. 369\nFox & LongPackages can be at locations or in rockets, and can move between these states in theresulting two-node FSM. In this example, rockets can be in states that involve more thanone FSM, since they can be both at and fuelled, or at and unfuelled. STRIPS domainshave been seen in this way in earlier work (McCluskey & Porteous, 1997; Grant, 1996), asdiscussed in Section 5.2.1 Types in TIMWhen two objects participate in identical FSMs they are functionally equivalent and can beseen to be of the same type. The notion of type here is similar to that of sorts in the work ofMcCluskey and Porteous (1997). A primary objective of the tim module is to automaticallyidentify the equivalence classes that form the primitive types in a domain description andto infer the hierarchical type structure of a domain on the basis of the primitive types. Theway this is done is discussed in Section 2.3. The primitive types are functional equivalenceclasses, and the objects of the domain are partitioned into these classes. Having identi edthe types of the domain objects tim infers the types of the parameters of all of the operators.State invariants are inferred as a nal stage.The early parts of this process rely on three key abstract data types, the property space,the attribute space and the transition rule. Formal de nitions of these components areprovided in Section 2.3, but we provide informal descriptions here to support the followingde nitions. Transition rules represent the state transformations that comprise the FSMstraversed by the objects in the domain. Property spaces are FSMs, together with the objectsthat participate in them, the properties these objects can have and the transition rules bywhich they can acquire these properties. Attribute spaces contain collections of objects thathave, or can acquire, the associated attributes. Attributes di er from properties becausethey can be acquired, or lost, without the associated loss, or acquisition (respectively),of another attribute. Attribute spaces also contain the transition rules that enable theacquisition (or loss) of these attributes. Once the state and attribute spaces have beenconstructed we assign types to the domain objects according to their membership of theproperty and attribute spaces. Any two objects that belong in identical property andattribute spaces will be assigned the same type. It is therefore very important to ensurethat the property and attribute spaces are adequately discriminating, otherwise importanttype distinctions can be lost. Much of the subtlety of the algorithm described in Section 2.2is concerned with maintaining adequate discrimination in the construction of these spaces.We present the following de nitions here to support our informal characterisation of theroles of types in strips and in tim. The de nitions are used again in Sections 2.4 and 2.6,which discuss how types are assigned to objects and operator parameters.De nition 1 A type vector is a bit vector in which each bit corresponds to membership, orotherwise, of a unique state or attribute space. The number of bits in the vector is alwaysequal to the number of distinct state and attribute spaces.De nition 2 A type is a set of domain objects each associated with the same type vector.De nition 3 A type vector, V1, in which two distinct bits, si and sj, are set corresponds toa sub-type of the type associated with a vector, V2, in which only si is set (all other settings370\nAutomatic Inference of State Invariantsbeing equal). Then the type associated with V2 can be seen to be a super-type of the typeassociated with V1.De nition 4 A type structure is a hierarchy of types organised by sub-type relationshipsbetween the component types.De nition 5 A type structure is adequately discriminating if objects are only assigned tostate (and attribute) spaces that characterize their state transitions (and attributes).De nition 6 A type structure is under-discriminating if it fails to distinguish types thatare functionally distinct.De nition 7 A type structure is over-discriminating if functionally identical objects areassigned to di erent types.There are two distinct ways in which types play a role in the speci cation of a domain.They can restrict the set of possible operator instances to eliminate all those that aremeaningless in the domain and hence improve e ciency by reducing the size of the searchspace, and they can eliminate unsound plans that could be constructed if they were notprovided. The following examples clarify the di erence between these two roles. Theuntyped schema: drive(X,Y,Z)Pre: at(X,Y), fuelled(X), location(Z)Add: at(X,Z), unfuelled(X)Del: at(X,Y), fuelled(X)permits more instances than the typed schema:drive(X,Y,Z)params: X:rocket,Y:package,Z:locationPre: at(X,Y), fuelled(X), location(Z)Add: at(X,Z), unfuelled(X)Del: at(X,Y), fuelled(X)but all meaningless instances will be eliminated during search because their preconditionswill not be satis able. On the other hand, the typed schema: y(X,Y,Z)params: X:aircraft,Y,Z:locationPre: at(X,Y)Add: at(X,Z)Del: at(X,Y)ensures that only aircraft can be own, whilst the untyped schema:371\nFox & Long y(X,Y,Z)Pre: at(X,Y)Add: at(X,Z)Del: at(X,Y)allows ying as a means of travel for any object that can be at a location, including packages,and other objects, as well as aircraft. Tim is capable of automatically inferring all typesplaying the restrictive role indicated in the typed drive operator. However, tim cannot infertype information that is not implicit in the domain description. Thus, given the untyped flyschema, there are no grounds for tim to infer any type restrictions. Tim will draw attentionto unintended under-discrimination by making packages and aircraft indistinguishable atthe type level, unless there is distinguishing information provided in other schemas. Atthe very least tim will make explicit the fact that packages are amongst those objects thatcan y. This assists the domain designer in tracking errors and omissions in a domaindescription, but unstated intended distinctions cannot be enforced by tim.2.2 An Overview of the TIM AlgorithmFigure 2 gives a broad outline of the tim algorithm. A more detailed description is givenin Appendix B. The role of each component of the algorithm is described, together with acommentary on discussing related issues and justi cations, in Sections 2.3, 2.4 and 2.7.Broadly, tim begins with an analysis of the domain operators, extracting transition rulesthat form the foundations of the property and attribute spaces described previously. Theserules are used to separate properties into equivalence classes from which the property andattribute spaces are constructed. Tim then analyses the initial state in order to assign thedomain objects to their appropriate spaces. This analysis also identi es the initial propertiesof individual objects and uses them to form states of the objects in the property spaces. Theinitial states in a property space are then extended by the application of the transition rulesin that space to form complete sets of states accounting for all of the states that objects inthat property space can possibly inhabit. As described in Section 2.4, attribute spaces donot behave like FSMs, as property spaces do, and the extension of these is carried out by adi erent procedure: one that can add new objects to these spaces, rather than new states.Tim then assigns types to objects using the pattern of membership of the spaces it hasconstructed. Finally, tim uses the spaces to determine invariants that govern the behaviourof the domain and the objects in it.2.3 Constructing the Transition RulesWe begin by describing the process by which the transition rules are constructed. Thefollowing de nitions are required.De nition 8 A property is a predicate subscripted by a number between 1 and the arity ofthat predicate. Every predicate of arity n de nes n properties.De nition 9 A transition rule is an expression of the form:property ) property ! property 372\nAutomatic Inference of State InvariantsConstruct base PRSs (Section 2.3)Split PRSs (Section 2.3)Construct transition rules (Section 2.3)Seed property and attribute spaces (Section 2.3)Assign transition rules (Section 2.4)Analyse initial state (Section 2.4)Extend property spaces (Section 2.4)Extend attribute spaces (Section 2.4)Identify types (Section 2.6)Construct invariants (Section 2.7)Figure 2: Outline of the tim algorithm.in which the three components are bags of zero or more properties called enablers, start and nish, respectively.The double arrow, ), is read enables and the single arrow, !, is read the transitionfrom. So: E ) S ! Fis read: E enables the transition from S to F. The properties in S are given up as a result ofthe transition. The properties in F are acquired as a result of the transition. The propertiesin E are not given up.If enablers is empty we write: start ! finishIf start is empty we write:Transition rule 1 enablers) null! finishIf nish is empty we write:Transition rule 2 enablers) start ! nullThe bag null is the empty bag of properties. Its role is to emphasise that, in transitionrule 1, nothing is given up as a result of the transition and, in transition rule 2, nothing isacquired. Rules that have a null start and a null nish are discarded because they describenull transitions.When the property bags contain more than one element they are separated by commas.The collection: pk ; qm; ::: rn373\nFox & Longis interpreted to mean that each of the properties in the collection can be satis ed asmany times as they appear in the collection. The comma is therefore used to separate theelements of a bag. We use to denote bag union, to denote bag di erence, to denotebag intersection and v to denote bag inclusion.De nition 10 A Property Relating Structure (PRS) is a triple of bags of properties.The rst stage of the algorithm constructs a set of transition rules from a set of operatorschemas. Each operator schema is analysed with respect to each parameter in turn and, foreach parameter, a PRS is built. The rst bag of properties is formed from the preconditionsof the schema, and the number used to form the property is the argument position ofthe parameter being considered. For example, if the precondition is on(X; Y ), and theparameter being considered is X , the property formed is on1. This bag, called precs,contains the enablers that will be used in the formation of the transition rules. The secondbag, called deleted precs, of properties is formed from all of the preconditions that appearon the delete list of the schema (with respect to this same parameter). The third bag, calledadd elements, contains the properties that can be formed from the add list of the schema.The PRS contains no deleted elements component { it is assumed that every element onthe delete list of a strips operator appears in the precondition list. This is a reasonablerestriction given that strips operators do not allow the use of conditional e ects. It isfurther assumed that every pair of atoms on the delete list of a schema will be distinct forall legal instantiations of the schema. This does not constitute a signi cant restriction sinceoperator schemas can always be easily rephrased whenever this condition is violated.We now consider the process by which PRSs are constructed. Given the schema:drive(X,Y,Z)Pre: at(X,Y), fuelled(X), location(Z)Add: at(X,Z), unfuelled(X)Del: at(X,Y), fuelled(X)and considering the parameter X , the following PRS will be built:PRS 1 precs : at1; fuelled1deleted precs : at1; fuelled1add elements : at1; unfuelled1By considering the parameter Y we obtain:PRS 2 precs : at2deleted precs : at2add elements :and by considering the parameter Z we obtain:374\nAutomatic Inference of State InvariantsPRS 3 precs : location1deleted precs :add elements : at2In constructing these structures we are identifying the state transformations through whichthe objects, instantiating the operator parameters, progress. Note that objects that instan-tiateX go from being fuelled and at somewhere to being unfuelled and at somewhere; objectsthat instantiate Y lose the property of having anything at them and gain nothing as a re-sult of application of this operator, and objects that instantiate Z continue being locationsand gain the property of having something at them. We now convert these structures intotransition rules in order to correctly capture these state transformations.Our standard formula for the construction of rules from PRSs is:precs deleted precs) deleted precs! add elementsThus, using the PRS 1 above, we could build the rule:at1; fuelled1 ! at1; unfuelled1A potential problem with this rule is that it causes at1 and fuelled1 to be linked in statetransformations, so that at1 and fuelled1 become associated with the same property spaceand, as a consequence, objects that can be at places, but that cannot be fuelled, may beindistinguishable from objects that require fuelling before they can be moved. In fact, wewish the transition rules to express the fact that being fuelled enables things to go frombeing at one place to being at another place, whilst not excluding the possibility that theremay be other enablers of this transition.We therefore begin a second phase of PRS construction by identifying, for special treat-ment, PRSs in which a property appears in both the deleted precs and the add elements.This is a property that is exchanged on application of the operator. That is, the relationcontinues to hold between the identi ed argument and some other object or objects (notnecessarily the same object or objects as before the application of the operator). For ex-ample, in PRS 1, the vehicle is at a new location after application of the operator, and nolonger at the old location. We observe that the vehicle must be fuelled to make this tran-sition. To separate the transition from this condition we split the PRS. Splitting identi esthe exchanged properties in a PRS and creates one new PRS for each exchange and onefor the unexchanged properties. Therefore, splitting a PRS always results in at most k+ 1(and at least k) new PRSs, where k is the number of exchanges that the PRS represents.By splitting PRS 1 we construct two new PRSs: one characterizing the exchange of the atproperty, and one characterising the fuelled to unfuelled transition.The rst of the new PRSs is:PRS 4 precs : at1; fuelled1deleted precs : at1add elements : at1375\nFox & Longfrom which the rule fuelled1 ) at1 ! at1is constructed. It should be noted that the property of being fuelled is no longer seen aspart of the state transformation but only as an enabler, which is why it does not appear inthe deleted precs bag in the resulting PRS.The second new PRS captures the fact that at1 can be seen as an enabler for thetransition from fuelled1 to unfuelled1:PRS 5 precs : at1; fuelled1deleted precs : fuelled1add elements : unfuelled1In this PRS there are no further splits required since no other properties are exchanged init. A more general example is as follows:PRS 6 precs : p1; p2 pndeleted precs : p1 pi pi+k pmadd elements : p1 pi q1 qkfrom which i PRSs would be constructed to deal with each of the i exchanged pairs and a nal PRS, PRS 7, would be constructed to describe the remainder of the transition makingi+ 1 PRSs in total.PRS 7 precs : p1; p2 pndeleted precs : pi+k pmadd elements : q1 qkThere is no need to consider additional pairings of add and delete-list elements, since thesewould not correspond to exchanges of properties. The splitting process is justi ed in Sec-tion 3.1. The standard rule construction formula can be applied to PRS 5, yielding therule at1 ) fuelled1 ! unfuelled1It should be observed that, even if the add elements bag contains multiple properties, asingle rule will always be built when the standard construction formula is applied.On considering the remaining PRSs, 2 and 3, it can be observed that they each containan empty eld: in 2 the add elements eld is empty and in 3 the deleted precs eld is empty.When a PRS has an empty eld special treatment is required. From PRS 2 we build therule at2 ! nullto represent the fact that the object that instantiates Y gives up the property of havingsomething at it, and gains nothing in return. From 3 we build the rulelocation1 ) null! at2376\nAutomatic Inference of State Invariantsto represent the fact that the object that instantiates Z gains the property of having some-thing at it by virtue of being a location, and gives up nothing in return. These rules havea somewhat di erent status from the ones that characterize the exchange of properties. Inthese cases properties are being lost or gained, without exchange, so can be seen as resourcesthat can be accumulated or spent by domain objects rather than as states through whichthe domain objects pass. For example, a location can acquire the property of having some-thing at it, without relinquishing anything in return, whereas an object that requires fuelcan only become fuelled by relinquishing the property of being unfuelled, and vice versa.Increasing and decreasing resources are identi ed as attributes and are distinguished fromstates. This distinction will later prove to be very important, since the generation of truestate invariants depends upon it being made correctly. Properties that can increase anddecrease without exchange are not invariant, and false assertions would be proposed asinvariants if they were treated in the same way as state-valued properties.A rule of the form constructed from PRS 3 must be constructed separately for everyproperty in the add elements bag because these properties must be individually character-ized as increasing resources. Rules constructed using null are distinguished as attributetransition rules. If the null is on the left side of the ! the rule is an increasing attributetransition rule. If the null is on the right hand side then the rule is a decreasing attributetransition rule.A nal case to consider during rule construction is the case in which a PRS has an emptyprecs eld. This happens if the parameter, with respect to which the PRS was constructed,did not appear in any of the preconditions of the operator schema. In this case a set ofrules is constructed, one for each property, a, in the add elements bag, of the formnull! are ecting the fact that a is an increasing resource (the deleted precs eld will necessarilyalso be empty in this case).De nition 11 A state is a bag of properties.When it is necessary to distinguish a bag from a set, square brackets will be used to denotethe bag.De nition 12 A property space is a tuple of four components: a set of properties, a setof transition rules, a set of states and a set of domain constants.De nition 13 An attribute space is a tuple of three components: a set of properties, a setof transition rules and a set of domain constants.It is helpful to observe here that the state and attribute spaces represent disjoint col-lections of properties, and that these disjoint collections are formed from the transitionrules by putting the start and finish properties of each rule into the same collection. Forexample, given two rules: E1 ) [p1; p2; p3]! [q1; q2]and E2 ) [r1; r2]! [s1]377\nFox & Longthe collections [p1; p2; p3; q1; q2] and [r1; r2; s1] would be formed. If a property appears inthe start or finish of both rules then a single collection will be formed from the two rules.The last stage in the rule construction phase is to identify the basis for the constructionof property and attribute spaces. This is done by uniting the left and right hand sides of therules. Uniting forms collections of properties that each seed a unique property or attributespace. It is not yet possible to decide which of the seeds will form attribute spaces, sotreatment of both kinds of space is identical at this stage. The enablers of the rules areignored during this process. We do not wish to make enablers automatically fall into thesame property spaces as the states in the transformations they enable. This could resultin incorrect assignment of properties to property and attribute spaces since enablers onlyfacilitate, and do not participate in, state transformations. The output of this phase is thecollection of rules, with some properties marked as attributes, and the property space seedsformed from the uniting process. All properties that remain unassigned at this stage areused to seed separate attribute spaces, one for each such property.The role played by the second phase of PRS construction is to postpone commitmentto the uniting of collections of properties so that the possibility of objects, which can havethese properties, being associated with di erent property spaces is left open for as long aspossible. It may be that consideration of other schemas provides enough information forthis possibility to be eliminated, as in the following abstract example, but we support asmuch type discrimination as possible in the earlier phases of analysis. We consider thissimple example to illustrate the problem.2.3.1 Postponing Property Space AmalgamationGiven a domain description containing the following operator schema:op1(X,Y,Z)Pre: p(X,Y), q(X,Y)Add: p(X,Z), q(X,Z)Del: p(X,Y), q(X,Y)the PRS: precs : p1; q1deleted precs : p1; q1add elements : p1; q1will be constructed, during the rst phase, for X . The properties p1 and q1 are boundtogether in this PRS, and the resulting rule would be:p1; q1 ! p1; q1which forces objects that can have property p1 to occupy the same property space as objectsthat can have property q1. Since this PRS models the exchange of p1 we will split it, andreplace it with two new PRSs: precs : p1; q1deleted precs : p1add elements : p1378\nAutomatic Inference of State Invariantsprecs : p1; q1deleted precs : q1add elements : q1We do not consider other pairings of p1 and q1, since these will be found in the PRSsof other operator schemas if the domain allows them. The two PRSs generated lead to thegeneration of the rules: q1 ) p1 ! p1and p1 ) q1 ! q1The two rules indicate that p1 and q1 should be used to form di erent property spaces sincethey could, in principle, be independent of one another. Then objects assigned to these twospaces can turn out to be of distinct types. However, if we add the following two schemas:op2(X,Y)Pre: q(X,Y)Add: p(X,Y)Del: q(X,Y) op3(X,Y,Z)Pre: p(X,Y)Add: q(X,Y)Del: p(X,Y)we generate, for X , the PRSs: precs : q1deleted precs : q1add elements : p1and precs : p1deleted precs : p1add elements : q1and the rules: q1 ! p1and p1 ! q1indicating that p1 and q1 should be united in the same set and hence form a single propertyspace, and that objects that can have these properties are really of the same type. Theuniting overrides the potential for separate property spaces to be formed but, in the absenceof these two schemas, there would have been insu cient information available to determinethe nature of the relationship between the two properties.379\nFox & Long2.4 Constructing the Property Spaces and Synthesising the TypesThe objective of this stage is to construct the type structure of the domain by identifyingdomain objects with distinct property spaces. Objects can appear in more than one propertyspace, giving us a basis for deriving a hierarchical type structure.The rst part of the process involves completing the seeded property spaces. The rsttask is to associate transition rules with the appropriate property space seeds. This can beeasily done by picking an arbitrary property of the start or nish component of each ruleand identifying the property space seed to which that property belongs. There can neverbe ambiguity because every property belongs to only one seed and uniting ensures that allof the properties referred to in a rule belong to the same seed. At this point the distinctionbetween states and attributes becomes important. Any property space seed that has anattribute transition rule associated with it becomes an attribute space and is dealt withdi erently from property spaces in certain respects explained below.The next step is to identify the domain objects associated with each property space andattribute space.For each object referred to in the initial state we construct a type vector in which a bitis set if the corresponding space is inhabited by the object. An object can inhabit morethan one space. Habitation is checked for by identifying all of the properties that hold, inthe initial state, of the object being considered and allocating them as states, rather thanas properties, to the appropriate state and attribute spaces. When every domain object hasbeen considered a unique type identi er is associated with each of the di erent bit patterns.The next task is to populate the property spaces with states. The following de nitionsare required to support the explanation of this process.De nition 14 A world-state is a collection of propositions characterising the con gurationof the objects in a given planning domain description.De nition 15 Given a world-state, W , a property space, P = (Ps; TRs; Ss; Os), or anattribute space, P = (Ps; TRs;Os), and an object o 2 Os, the P -projection of St for o isthe bag of properties, possessed by o in W , each of which belongs to Ps.The collection of properties of an object, o, in the initial state can be divided into a set ofbags of properties, each bag corresponding to the P -projection of the initial state for o, forsome property or attribute space P . Each bag is added to the state set of the correspondingproperty space, or discarded if the corresponding space is an attribute space. We now needto extend the spaces by, for each property space, adding states that can be inferred asreachable by objects within that space along transitions within that space. This is done forevery state in the space, including states that are newly added during this process, until nofurther new states are reachable. The ordering of the properties within states is irrelevant, sotwo states are considered equal if they contain the same properties, regardless of ordering(they are considered order-equivalent). Since, when we come to use this information inparts of the process of invariant generation, we will not require knowledge of any inclusionrelations between pairs of states, it is convenient to mark these at this stage. The additionof reachable states is important for the inference of state invariants, and their use will bediscussed in Section 2.7. The attribute spaces receive di erent treatment at this point. The380\nAutomatic Inference of State Invariantsimportant di erence to observe is that, since property spaces characterize the exchangeof properties, objects in a property space must start o in the initial state as membersof that property space. However, since attributes can be acquired without exchange, itis possible for objects that do not have particular attributes in the initial state to acquirethose attributes later. This is only possible if the attribute space has an increasing attributetransition rule associated with it. We now, therefore, consider each attribute space to seewhether further objects can be added by application of any corresponding increasing rule.An object can be added to an attribute space if it potentiates all of the enablers of anincreasing rule in that attribute space. An object potentiates an enabling property if itis a member of the state or attribute space to which that property belongs. Membershipof all of these spaces indicates that the object could enter a state in which it satis es allof the enabling properties, which would justify an application of the increasing rule. Anyenabling property that is not associated with a state or attribute space is a static condition,so the initial state can be checked to con rm that the property is true of the object beingconsidered.A complication arises if any enabling property was itself used to seed an attribute space(in which case it is itself an attribute), because it is then necessary to identify all of theobjects in its attribute space and consider them for addition to the current attribute space.Of course this could, in principle, initiate a loop in the process but we avoid this by markingattribute spaces as they are considered and ensuring, by iterating until convergence, thatall of the attribute spaces in the loop are completely assigned. The correctness of this partof the procedure is discussed in Section 3.When this is done the state and attribute spaces are complete and the types of thedomain objects can be extracted. The completeness of this construction phase is discussedin Section 3.1.2.5 A Worked ExampleA fully worked example of all stages of the process will help to clarify what is involved.Consider a simpli ed version of the Rocket domain in which there are two operator schemas:drive(X,Y,Z)Pre: at(X,Y), fuelled(X), location(Z)Add: at(X,Z), unfuelled(X)Del: at(X,Y), fuelled(X)load(X,Y,Z)Pre: at(X,Y), at(Z,Y)Add: in(X,Z)Del: at(X,Y)and an initial state containing four constants: rocket, package, London and Paris, andthe relations: at(rocket,Paris), fuelled(rocket) and at(package,London). It can be observedthat this simpli ed Rocket domain has the rather odd feature that the load schema is notrestricted to loading packages into rockets. This oddity will be highlighted by the analysisthat is constructed, showing how the analysis performed by tim can help in understanding(and debugging) the behaviour of the domain. From the drive operator schema the followingPRSs are constructed for variables X , Y and Z respectively:381\nFox & Longprecs: at1, fuelled1deleted precs: at1, fuelled1add elements: at1, unfuelled1precs: at2deleted precs: at2add elements:precs: location1deleted precs:add elements: at2From the load operator schema the following PRSs are constructed for variables X , Yand Z respectively: precs: at1deleted precs: at1add elements: in1precs: at2, at2deleted precs: at2add elements:precs: at1deleted precs:add elements: in2and the following rules are built. The rst PRS generates the rst two rules and subsequentPRSs each generate one rule. fuelled1 ) at1 ! at1at1 ) fuelled1 ! unfuelled1at2 ! nulllocation1 ) null! at2at1 ! in1at2 ) at2 ! nullat1 ) null! in2We now construct the following united sets of properties:fat1; in1gffuelled1; unfuelled1gfat2gfin2g 382\nAutomatic Inference of State InvariantsThese are used to seed property spaces. We rst associate the rules with these propertyspace seeds, resulting in the following assignment:fat1; in1g at1 ! in1; fuelled1 ) at1 ! at1ffuelled1; unfuelled1g at1 ) fuelled1 ! unfuelled1fat2g location1 ) null! at2; at2 ) at2 ! null;at2 ! nullfin2g at1 ) null! in2The last two spaces have been converted into attribute spaces by their association withattribute transition rules. The resulting spaces can now be supplemented with domainconstants and their legal states. We rst identify the subset of the legal states of thedomain objects that are identi able from the initial state. We do not use the goal stateto provide further information about the properties of objects. The goal state might beunachievable because objects cannot obtain the required properties. This would invalidatetim's analysis of the domain. In the initial state the rocket has properties at1 and fuelled1,the package has property at1, London has property at2 and Paris has property at2. Usingthis information we associate domain constants with the developing state and attributespaces to obtain:fat1; in1g at1 ! in1; fuelled1 ) at1 ! at1 frocket; packagegffuelled1; unfuelled1g at1 ) fuelled1 ! unfuelled1 frocketgfat2g location1 ) null! at2; at2 ) at2 ! null; fLondon; Parisgat2 ! nullfin2g at1 ) null! in2The next step is to add the legal states of these objects, which are identi able so far, tothe property spaces. This results in the following structures, the rst two of which canbe extended by inference (as will be explained) into completed property spaces. The lasttwo will be extended into completed attribute spaces by the addition of objects that canpotentially acquire the associated attributes (also described below).fat1; in1g at1 ! in1; fuelled1 ) at1 ! at1 frocket; packageg[at1]ffuelled1; unfuelled1g at1 ) fuelled1 ! unfuelled1 frocketg[fuelled1]fat2g location1 ) null! at2; at2 ) at2 ! null; fLondon; Parisgat2 ! nullfin2g at1 ) null! in2The last stage in the construction of the two property spaces is to add any states thatcan be inferred as reachable, via transition rules, by objects in the property spaces. Forexample, packages can go from being at1 to being in1, by application of the rule at1 ! in1,and since that rule is available in the property space to which package belongs, and at1is one of the legal states in that property space, we add in1 as a further legal state. Ingeneral, we construct the extension by, for each state in the space, identifying applicablerules and, for each rule, creating a new state by removing the properties in the start of the383\nFox & Longrule and adding the properties in the nish of the rule. This is done until all further statesare order-equivalent to those already generated. The enablers of the rules are ignored, withthe consequence that some of the new states generated might be unreachable. When thisprocess is completed in the current example the nished property spaces are as follows:Property space 1fat1; in1g at1 ! in1; fuelled1 ) at1 ! at1 frocket; packageg[at1]; [in1]Property space 2ffuelled1; unfuelled1g at1 ) fuelled1 ! unfuelled1 frocketg[fuelled1]; [unfuelled1]We now consider each attribute space in turn and add domain objects (not alreadymembers) that potentiate their increasing rules. No new domain objects can be added tothe rst attribute space since only London and Paris can potentiate the increasing rule,and they are already present. However, when the second attribute space is considered it canbe observed that rocket and package both potentiate the increasing rule and are thereforeboth added as new members. The resulting attribute spaces are:fat2g location1 ) null! at2; at2 ) at2 ! null; fLondon; Parisgat2 ! nullfin2g at1 ) null! in2 frocket; packagegThe oddity of the load operator is revealed at this stage, since both package and rockethave been assigned as members of the in2 attribute space (meaning that they both can havethe attribute of having things in them).The number of distinct bit patterns that are constructed, indicating object membershipof the state and attribute spaces, determines the number of distinct types that exist in thedomain. Hence, in this simpli ed encoding of the Rocket domain, there are three distincttypes. The rocket has type [1101], the package has type [1001] and Paris and London bothhave type [0010]. These types are given abstract identi ers, T0; T1 and T2, but might bemore meaningfully interpreted as the types of: movable object requiring fuel, movable objectand location respectively. As expected, London and Paris are of type location, whilst thepackage is of type movable object and the rocket is of type movable object requiring fuel,which is a sub-type of movable object.The distinction we have made between state and attribute spaces is further exploited inthe process of inferring state invariants, discussed in Section 2.7.2.6 The Assignment of Types to Operator ParametersTypes are assigned to the parameters of the operators in the following way. Given anoperator schema and a collection of property spaces and attribute spaces we allocate a typevector to each of the variables in the schema. The membership in the state and attributespaces of each of the properties of a given variable is recorded by setting the appropriate bitsin the vector for that variable. Only the properties that appear in the preconditions of the384\nAutomatic Inference of State Invariantsschema are considered, because any object that can satisfy the preconditions of an operatorcan have the properties represented by the postconditions and is therefore of the right typefor instantiation of the operator. When a type is associated with the vector the union of allof its sub-types is taken. This union is then the type assigned to the variable. Any domainobject, the type of which is a sub-type of the type associated with the variable, can thenbe used to instantiate that variable. To see how this process works, consider the variable Xin the drive schema above. The precondition properties of X are: at1, fuelled1. These aremembers of the two property spaces 1 and 2. Therefore, the type vector associated with Xis [1100]. It can be observed that the type vector associated with the rocket is [1101], so thatthe type of rocket is a sub-type of the type of X . This is the only sub-type, so the union ofsub-types contains only T0, the type of rocket. This means that X can be instantiated byrocket, but not by any other domain constant, since no other domain constant has a type inthe appropriate sub-type relation. To type the operator parameters we introduce new typevariables, Tk::Tn for unused values between k and n, where k is the number of existing typesand n is k plus the number of variables in the schema being considered. The type vectorfor variable Y will be [0010] and Z will have no type vector because location is a staticrelation and Z does not appear as an argument to any other predicate in the preconditions.Z therefore acquires the same type as London and Paris, the only two objects for whichlocation is true in the initial state. T4 is a super-type of T2. After taking the unions of thesub-types we can now specify the drive schema in the following way:drive(X,Y,Z)Params: X:T0 Y:T2 Z:T2Pre: at(X,Y), fuelled(X), location(Z)Add: at(X,Z), unfuelled(X)Del: at(X,Y), fuelled(X)stan exploits the sub-typing relations that have been inferred when constructing in-stances of the drive operator. Any variable that appears in a schema but does not appearin its preconditions can be instantiated by objects of any type. This is because the domaindescription contains no basis for inferring type restrictions in this case. No variable canappear on the delete list without appearing on the precondition list, since we assume thatall delete list elements appear as preconditions. So such a variable would have to occur onthe add list. This would mean that, regardless of the properties holding of the object usedto instantiate that variable, in the initial state, it can acquire that add list property freely.Since this acquisition would occur irrespective of the type of the object, such variables areessentially polymorphic.2.7 The Inference of State InvariantsThe nal phase of the computation of tim is the inference of the state invariants fromthe property spaces. The attribute spaces are not used for the inference of invariants:incorrect invariants would be proposed by tim if attribute spaces were inadvertantly used.This explains the importance of identifying the attribute spaces in the earlier stages of thealgorithm.The current version of tim is capable of inferring four kinds of invariant, three of whichare inferred from the property spaces (identity invariants, state membership invariants and385\nFox & Longinvariants characterizing uniqueness of state membership) and one of which is inferred fromthe operator schemas and initial state directly ( xed resource invariants). In the simpli edRocket domain, considered above, an example of an identity invariant is:8x : Tk:8y:8z:(at(x; y)^ at(x; z)! x = z)A state membership invariant is:8x : Tk:(9y : Tn:at(x; y) _ 9y : Tm:in(x; y))A uniqueness invariant is:8x : Tk::(9y : Tn:at(x; y) ^ 9y : Tm:in(x; y))To infer the identity invariants each property space is considered in turn, with respectto their properties and states. If a property, for example Pk with P of arity n > 1, occursat most once in any state an invariant of the following form, in which y and z are vectorscontaining n 1 values, can be constructed:8x:8 y:8 z:(P (y1::k 1; x; yk::n 1) ^ P (z1::k 1; x; zk::n 1)! y = z)The form of this invariant can be generalised to deal with the case where there are at mostm > 1 occurrences of Pk in any state in the space. In this case we build the followingexpression, in which we have assumed that k = 1, for simplicity.8x:8 y1::: ym:(P (x; y1) ^ :::^ P (x; ym)! ( y1 = y2 _ y1 = y3 _ :::_ ym 1 = ym))The state membership invariants are of the form:8x:(Disjunct1 _ :: _Disjunctn)where each disjunct is constructed from a single state. Thus, if a property space contains kstates there will be at most k disjuncts in the invariant constructed for that property space.Only one state membership invariant is constructed for each property space.Given the collection of states in a property space we rst identify those that are supersetsof other states in the collection. All supersets are discarded, since the invariants that wouldbe built from them would be logically equivalent to those built from their subset states.Each remaining state is used to build a single disjunct. If the state being considered containsa single property, Pk with P of arity n, then the expression9 y:P (y1::k 1; x; yk::n 1)is constructed. Of course, if n = 1 then there is no existential quanti er and the disjunctis just P (x). If the state contains more than one property, say m of them denoted P 1::Pm,then we build (again, assuming that k = 1 for simplicity):9 y1::: ym:(P 1(x; y1) ^ P 2(x; y2) ^ :::^ Pm(x; ym))The uniqueness invariants are constructed in a similar way. For each property space webegin by analysing the superset states to identify non-exclusive pairs of subset states. For386\nAutomatic Inference of State Invariantsexample, given the subset states fat1g and fin1g and the superset state fat1; in1g, it canbe observed that the two subset states are not mutually exclusive since at1 and in1 can besimultaneously held. Having done this analysis and identi ed all mutually exclusive pairsof states we mark the subset states as unusable for generation of invariants. The remainingstates are considered in all possible pairings. For every pair of states, P;Q, we generatean invariant of the following form assuming, for simplicity, that x is in the rst position inP 1::Pn and Q1::Qm. The form of the invariant is easily generalised, as before.8x::(9 y1::: yn:(P 1(x; y1) ^ P 2(x; y2) ^ :::^ Pn(x; yn))^(9 y1::: ym:(Q1(x; y1) ^Q2(x; y2) ^ :::^Qm(x; ym))))The fourth kind of invariant can be inferred from the structure of the operator schemaswithout reference to the property spaces or domain type structure. We call these invariants xed resource invariants since they capture the physical limitations of the domain. Fixedresource invariants cannot be inferred from the state and attribute spaces because they de-scribe properties of the domain rather than of objects within it. The following schema fromthe Gripper domain provides an example of why xed resource invariants are distinguishedfrom the other three kinds:move(X,Y)Pre: at robot(X), room(Y)Add: at robot(Y)Del: at robot(X)The PRSs that would be built from this operator are:precs : at robot1deleted precs : at robot1add elements :precs : room1deleted precs :add elements : at robot1and the rules constructed from these are:at robot1 ! nulland room1 ) null! at robot1It can be observed that both of these rules are attribute transition rules and that at robot1is attribute rather than state-valued. This means that no invariants of the rst three kindsdiscussed would be constructed.The reason for the lack of invariants of the rst three forms is that the encoding of therobot is embedded in a predicate, so the robot cannot participate directly in state transitions.An obvious invariant of the robot, which would naturally be true of this domain, is that the387\nFox & Longrobot is always in exactly one room but this cannot be inferred using the techniques so fardescribed. In fact, this is an axiom about the world, or domain, rather than speci c objectswithin it, and has to be obtained from information other than the state transformations ofthe objects.It can be seen from the operator schemas for the Gripper domain that at robot1 is bal-anced. That is, it is always deleted whenever it is added and added whenever it is deleted.This means that the number of occurrences of at robot in the initial state determines thenumber of occurrences that are possible in any subsequent state. This leads to the con-struction, for this domain, of the invariantjfx : at robot(x)gj = 1since there is only one at robot relation in the initial state. The form of xed resourceinvariants is always equational. Such an invariant states that the size of the set of combina-tions of objects satisfying a certain predicate is equal (or, in some cases, less than or equal)to a certain positive integer. Because this integer can be very large it is more convenient towrite an equation than it would be to write a logical expression. The information encodedin the xed resource invariants is very useful for identifying unsolvable goal sets without at-tempting to plan for them. For example, in the ICPARC version of the three-blocks Blocksworld (Liatsos & Richards, 1997), in which there are only three table positions, there mustalways be exactly three clear surfaces. Any goal specifying more than three clear relation-ships can be identi ed as unachievable from the xed-resource invariants for that domain.The xed-resource and uniqueness invariants produced by tim can be seen as providing aform of multi-mutex relations, in contrast to the binary mutex relations inferred during theconstruction of the plan graph in Graphplan-based planners (Blum & Furst, 1995). Binarymutex relations indicate that two actions or facts are mutually incompatible, whilst multi-mutex relations indicate that larger groups of actions or facts are collectively incompatible.Binary mutex relations, preventing a fact that can be true of only one object from holdingof two di erent objects simultaneously, can be extracted from the identity invariants thattim infers. Multi-mutex relations are more powerful than binary ones. Stan can detectunsolvable goal-sets by using the xed-resource and uniqueness invariants even when thebinary mutex relations at the corresponding level do not indicate that any problem exists.To infer these invariants we examine the predicates in the language to see whetherthey are exchanged on the add and delete lists of the operator schemas. If a predicate isexchanged equally in all schemas (it always appears the same number of times on the addlist as on the delete list of a schema) then the predicate corresponds to a xed resource.If a single schema upsets this balance then the predicate is not treated as xed. Given a xed resource predicate, it can be inferred that there can never be more combinations ofobjects satisfying that predicate than there are in the initial state. Because of the slightlyodd encoding of the rocket world considered in this paper, only location is a xed resource.at is not xed because it is not equally exchanged in the load schema. Examples of xedresource invariants inferred from various standard domains are provided in Appendix C.There are certain circumstances under which it is necessary to infer the weaker invariantthat jfx : P (x)gj k388\nAutomatic Inference of State Invariantsfor some positive integer k. If P holds of multiple objects in the initial state then it ispossible for subsequent state transformations, or attribute acquisitions, to result in statesin which two or more instances of P collapse into one. If P holds multiply often in the initialstate (or in any other reachable state) then it is necessary to build the invariant using instead of =. If P is state-valued, and multiple instances never occur in any state in itsproperty space, then it is safe to assert equality in the construction of the invariant.Automatic inference of the rst three kinds of invariants relies on the constructionof the property spaces as discussed in Section 2.4. As has been discussed, the distinctionbetween state and attribute spaces is critical for the inference of correct invariants. However,using just the techniques described so far, tim would lose information from which it couldconstruct useful invariants. To give an example of how this could occur we now considerthe following simple encoding of the standard Blocks world:move(X,Y,Z)Pre: on(X,Y), clear(X), clear(Z)Add: on(X,Z), clear(Y), clear(table)Del: on(X,Y), clear(Z)In this operator, used by Bundy et al. (1980), the add list element clear(table) makesreference to a constant. If the operator schema were to be submitted to our analysis in itscurrent form no PRS would be built for the constant, so the rules that would be constructed,and hence the state and attribute spaces constructed, would fail to record the fact that everyapplication of move results in a state in which the table is clear. The resulting analysiswould result in incorrect invariants and types. Grant (1996) identi es this version of themove operator as awed, because of the need to maintain state correctness by the additionof the invariant clear(table) to the add list. However, we can analyse this schema correctlyif we rst abstract it to remove the constant, yielding the following new schema:move(X,Y,Z,T)Pre: on(X,Y), clear(X), clear(Z), table(T)Add: on(X,Z), clear(Y), clear(T)Del: on(X,Y), clear(Z)Now, given an initial state in which blockC is on blockA and blockB is on the table,we add the proposition table(table) (so that the new precondition can be satis ed) and theproperty and attribute spaces that are constructed are as follows:fon1g clear1 ) on1 ! on1 fblockA; blockB; blockCg[on1]fon2; clear1g on2 ! clear1; clear1 ! on2; fblockA; blockB; blockC; tablegtable1 ) null! clear1The second of these is an attribute space, so our invariant extraction algorithm is notapplied to it. Consequently, the only invariants we can infer are those that characterizethe positions of blocks (every block is on exactly one surface). This is a pity, as thereis information available in the attribute space that could yield useful extra invariants. Inparticular, we would like to infer the invariant that every block can be either clear or have389\nFox & Longsomething on it, but it cannot be both clear and have something on it. The reason wecannot infer this as an invariant is because it would be asserted to hold for every object inthe attribute space, including the table, even though it is not actually true of the table (thetable can have things on it and still be clear).2.7.1 Sub-space Analysis on Property and Attribute SpacesThe solution to the problem of loss of invariants is to decompose any property or attributespace that contains k > 1 object types into k sub-spaces. A property sub-space is struc-turally identical to a property space. Attribute sub-spaces are identi ed but not used, asno invariants can be obtained from them. Property sub-spaces can be obtained by analy-sis on attribute spaces, as the following example will show. The reason for distinguishingsub-spaces from property and attribute spaces is that the properties are not partitionedin sub-spaces as they are in the property and attribute spaces. The original property orattribute space is not discarded and the sub-spaces are not used for determining the typesof objects. The only role of the sub-space analysis is to enable the construction of additionalinvariants.We now consider the Blocks domain described in the previous section as an example ofthe bene ts of sub-space analysis. At the point of invariant construction the types of thedomain objects have been identi ed by their property and attribute space membership, sotable is already known to be of a di erent type to that of the blocks. This is because table isnot a member of the property space for on1. Therefore, two sub-spaces can be constructedfrom the attribute space, one for the type [11], of blocks, and one for the type [01], oftables. No sub-spaces can be constructed from the property space because it contains onlyone type of object. The rules associated with the sub-spaces will be all of the rules from theoriginal attribute space that are enabled by objects of the appropriate type. The secondof the two sub-spaces is an attribute sub-space because of the inclusion of the increasingattribute transition rule. At this stage the two sub-spaces are as follows:fon2; clear1g on2 ! clear1; clear1 ! on2 fblockA; blockB; blockCgfon2; clear1g table1 ) null! clear1; on2 ! clear1; ftablegclear1 ! on2The attribute sub-space will not be used for invariant construction because it contains anattribute transition rule and would result in incorrect invariants (as is the case for attributespaces), so there is nothing to be gained from developing it further. However, the statesub-space is now completed by the addition of the states associated with the objects in thespace, both in the initial state and by extension. The resulting sub-spaces are:fon2; clear1g on2 ! clear1; clear1 ! on2 fblockA; blockB; blockCg[on2]; [clear1]fon2; clear1g table1 ) null! clear1; on2 ! clear1; ftablegclear1 ! on2From the new state sub-space we can infer the following invariants, using the type nameBlock to stand for the type vector [11]. We infer the identity invariant:8x : Block (8y 8z (on(y; x) ^ on(z; x)! y = z))390\nAutomatic Inference of State Invariantsthe state membership invariant:8x : Block (9y : Block on(y; x) _ clear(x))and the unique state invariant:8x : Block :(9y : Block (on(y; x)^ clear(x)))Although there is an additional invariant, that the table is always clear, we cannot inferthis at present.2.8 The Problem of Mixed SpacesIt can happen that the encoding of a domain conceals the presence of attributes withinschemas until the point at which property space extension occurs. This can prevent theproperty space extension process from terminating. For example, a simple lightswitch do-main contains the following two schemas:switchon(X)Pre: o (X)Add: on(X), touched(X)Del: o (X)switcho (X)Pre: on(X)Add: o (X), touched(X)Del: on(X)and an initial state in which switchA is on. Two PRSs are constructed:precs : o 1deleted precs : o 1add elements : on1; touched1precs : on1deleted precs : on1add elements : o 1; touched1giving rise to two rules: o 1 ! on1; touched1and on1 ! o 1; touched1Uniting then seeds one property space containing all three properties. After addition of therules the property space is as follows:fon1; o 1; touched1g o 1 ! on1; touched1; fswitchAgon1 ! o 1; touched1 [on1]391\nFox & LongIt is at the point of extension of the space that the problem arises. The following statesare added: [o 1; touched1], [on1; touched1; touched1], [o 1; touched1; touched1; touched1] andso on. We cannot simply avoid adding properties that are already in the state being ex-tended because the two, apparently identical, properties might in general refer to di erentarguments.The problem here is due to the fact that touched1 is actually an increasing attributebut this does not become apparent in the PRSs. The consequence is that mixed spaces areconstructed. A mixed space is a property space containing hidden attributes. Tim detectshidden attributes by checking, on extension, that no new state contains a state alreadygenerated from the same initial state starting point. Thus, on extension of the mixed spaceabove, tim would detect the hidden attribute when the state [on1; touched1; touched1] isconstructed, because this state contains the state [on1] that initiated this extension.Having detected the hidden attribute there are two possibilities: either tim can convertthe mixed space into an attribute space, in which case no invariants will be constructed, orit can attempt to identify the attribute and split the mixed space into an attribute spaceand a property space containing the state-valued components of the mixed space. We takethis option and split the state. This allows us to infer invariants concerning the state-valuedproperties.tim takes the di erence between the including and included states and, for each distinctproperty in the di erence, processes the rules by cutting any rule containing that propertyinto two rules, at least one of which will be an attribute rule. The following method isused to cut the rules. In the following, attr+ indicates one or more occurrences of theattribute-valued property and the comma is overloaded to mean both bag conjunction andbag union. If the rule is of the form:enablers) start ! adds; attr+then the two new rules will be of the forms:enablers; start ) null! attr+and enablers) start ! addsIf the rule is of the form: enablers) attr+; precs! addsthen the two new rules are of the forms:enablers; precs) attr ! nulland enablers; attr) precs! addsThe rule cutting separates the attribute-valued properties from the state-valued properties.Now pure attribute and property spaces can be constructed. However we do not discardthe original mixed space because it has been used in determining the type structure of392\nAutomatic Inference of State Invariantsthe domain. Any additional type information that could be extracted from the state andattribute spaces built following this analysis is not currently exploited.When this analysis is applied to the lightswitch domain, the following new propertyspace and attribute space are built:fon1; o 1g o 1 ! on1; on1 ! o 1 fswitchAg[on1]; [o 1]ftouched1g o 1 ) null! touched1; on1 ) null! touched1 fswitchAgUsing Lightswitch to stand for the type [11], the following state membership invariantcan be constructed from the property space:8x : Lightswitch (on(x) _ o (x))tim also constructs the uniqueness invariant:8x : Lightswitch :(on(x) ^ o (x))3. Properties of TIMThe correctness of tim relies on it constructing only necessarily true invariants. The demon-stration that only true invariants are constructed guarantees the construction of an ade-quately discriminating type structure. We cannot guarantee against under-discriminationbut we argue that over-discrimination does not occur in the type structures generated bytim. These properties were de ned in Section 2.1.Over-discrimination would be the result of distinguishing functionally identical objectsat the type level. This would occur if tim placed objects that participate in identicalstate transitions in di erent property spaces but, because of the underlying partitioning ofproperties between property spaces, this cannot happen. Further, membership of di erentproperty spaces requires that there be distinguishing state transformations, which thereare not in functionally identical objects. Flawed assignment (assigning an object to aproperty space without its corresponding state transformations), should simply be seen aserroneous, rather than as over-discrimination. The possibility of this occurring can beexcluded because property and attribute space construction and extension are shown to becorrect in Section 3.1.A failure to detect type di erences (under-discrimination) in the domain will resultin weak invariants, and over-discrimination, if it could occur, would lead to over-targetedinvariants that would still be true, but only for a subset of the objects they ought tocover. Flawed assignment would clearly lead to the construction of false invariants. Under-discrimination, which can arise, therefore a ects the completeness of the state-invariantinference procedure. It can also lead to over-generalisation of the operators since the typesassigned to the operator parameters will be equally under-discriminating. This can en-able meaningless instances to be formed, needlessly increasing the size of the search spacethat must be explored by the planner. This clearly raises e ciency issues but it does notundermine the formal properties of the planner that exploits tim.As observed, the consequence of under-discrimination is the construction of weak (butvalid) invariants. The following example illustrates how under-discrimination can occur.Given a schema: 393\nFox & Longop(X,Y)Pre: p(X,Y)Add: q(X,Y)Del: p(X,Y)and an initial state in which p(a; c); p(b; c); q(b; d)hold, the following two property spaces are constructed:fp1; q1g p1 ! q1 fa; bg[p1]; [q1]; [p1; q1]; [q1; q1]fp2; q2g p2 ! q2 fc; dg[q2]; [p2; p2]; [q2; p2]; [q2; q2]Given these property spaces it is impossible to distinguish a from b or c from d, eventhough analysis of the operator schema and initial state reveal that a is functionally distinctfrom b and c from d. It can be seen that, although a must always exchange a p1 for a q1,b can have both p1 and q1 simultaneously. A similar observation can be made for c andd. However, the process by which invariants are constructed cannot gain access to thisinformation. An identity invariant constructed for the rst property space is:8x : T 8y 8z 8u (q(x; y)^ q(x; z) ^ q(x; u)! y = z _ y = u _ z = u)This invariant is weaker than is ideal, because a can participate in only one q relation (b canparticipate in two simultaneously). A state membership invariant for this property spaceis: 8x : T ((9y : T1 p(x; y))_ 9y : T1 q(x; y))which understates the case for b, which can have p1 and q1 simultaneously. No uniquestate invariant is constructed for this property space, because p1 and q1 are not mutuallyexclusive.3.1 Correctness and Completeness of the Transition Rule Construction PhaseThe correctness of the algorithm used in tim depends on two elements. Firstly, the propertyspaces identi ed by the algorithm must be correctly populated. That is, no objects shouldbe assigned to property spaces to which they do not belong and every achievable state mustbe included in the appropriate property space. Secondly, these property spaces must onlysupport the generation of correct invariants. This second element is examined in Section 3.2.An interesting relationship exists between the states in a property space and the invari-ants generated from the space. Incorrect invariants will be contructed if a property space ismissing achievable states. This is because the state membership invariants assert that eachobject in the property space must be in one of the states in the property space. If statesare missing then this invariant will be false. We now prove that all achievable states willbe in the appropriate property space.Theorem 1 Given an initial state, I, a collection of operator schemas, O, a property space,P = (Ps; TRs; Ss; Os), generated by tim when applied to I and O, and any state, St, which394\nAutomatic Inference of State Invariantsis reachable from I by application of a valid linearised plan formed from ground instancesof operator schemas in O, then for any o 2 Os, the P -projection of St for o, StoP , is in Ss.Proof:The proof is by induction on the length of the plan that yields the state St. In the basecase the plan contains no operator instances so St = I . The P -projection of I for o is inSs, by de nition of the rst phase of the property space construction process described inSection 2.4.Suppose St is generated by a plan of length k + 1, with last step a and penultimatestate pre-St. Let the P -projection of pre-St for o be pre-StoP . By the inductive hypothesis,this state is in Ss. If a does not a ect the state of o, then the P -projection of St for owill be pre-StoP , and therefore in Ss trivially. Otherwise, consider the operator schema,Op 2 O, from which a is formed. As described in Section 2.7, no constants appear in Opand all variables in the body of Op are parameters of Op. Let the initial collection of PRSsconstructed from Op, for those parameters instantiated with o in the creation of a, be theset PRS1:::PRSn where every PRSi has the form:precs : Pideleted precs : Diadd elements : Aiand the initial collection is the collection formed prior to splitting.For each value of i the ith PRS will lead to the construction of k + 1 transition rules,where k is the size of the bag intersection, Xi, of Di and Ai. The k rules will be of thefollowing form: 8c 2 Xi (Pi fcg ) c! c)and the remaining rule will be of the form:Pi (Di Xi)) (Di Xi)! (Ai Xi)We refer to the latter rule for PRSi as the ith complex rule. A subset of the n complexrules will contain a property in Ps in either the start or the nish and will, therefore, berelevant to the transition from pre-St to St. It can be observed that these m complexrules (PRS1:::PRSm without loss of generality) must be in P because of the uniting processdescribed in 2.3.We de ne pres(a)oP to be the P -projection of the preconditions of a for o. Similarly,adds(a)oP and dels(a)oP are de ned to be the P -projections of the add and delete listsrespectively. By construction of the PRSs, de ned in Section 3.1,pres(a)oP = mM1 Piadds(a)oP = mM1 Aidels(a)oP = mM1 Di395\nFox & LongBecause of the restriction that delete lists must be a subset of preconditions, and thefact that a is applicable to pre-St, it follows that dels(a)oP v pres(a)oP v pre-StoP . Sincev represents bag inclusion it can be seen that all of the separate bags Di are included inpre-StoP without overlap.The extension process involves the iterated application of the rules as explained inSection 2.4 and indicated in the pseudo-code algorithm presented in Appendix B.For a rule to be applicable to a state its start must be included in the state. Thereforethe m complex rules are all applicable, regardless of the sequence of application, to pre-StoP .It follows that the state (pre-StoP mM1 (Di Xi)) mM1 (Ai Xi)is generated in the extension process. By de nition of Xi, and the fact that Di v pre-StoP ,this state can be written as: (pre-StoP mM1 Di) MAiwhich, as observed above, is just:(pre-StoP dels(a)oP ) adds(a)oPwhich equals StoP by the standard semantics of operator application in strips. 2The proof demonstrates that splitting, discussed in 2.3, does not result in the generationof invalid invariants. However, splitting can compromise the completeness of the invariant-generation process. It can result in the inclusion of unreachable states in property spaces,with the consequence that the identity and state membership invariants that are generatedare weaker than would otherwise be the case. This is further discussed in Section 3.2.We now explain the role of splitting in the PRS construction phases. Each domainobject in a strips domain has an associated nite automaton in which the states consist ofthe properties (for example, at1) it can have, either initially or as a result of the applicationof an arbitrary length sequence of operators. Objects that can be observed to be of thesame type will have identical automata at the property level. The PRSs capture the waysin which operator applications modify the con gurations of individual objects and henceprovide an encoding of these automata.The PRSs are built in two phases. In the rst phase, all of the parameters in all of theschemas are considered, so all possible object state transitions are captured. However, someof these transitions conceal the functional distinctions inherent in the domain descriptionand would lead to premature amalgamation of property spaces, as was observed in thediscussion of the Rocket domain in Section 2.5. In that example it was observed that useof our standard formula for the construction of rules from these PRSs alone would result inthe failure to detect the type distinction between rockets and packages.The second phase assists the type inference processes in avoiding under-discriminationby distinguishing enablers of a state transformation from the properties that are exchanged396\nAutomatic Inference of State Invariantsduring the transformation. Each PRS characterizing the exchange of k properties is splitto form at most k + 1 new PRSs. The PRSs 4 and 5, given in Section 2.3, show how twoPRSs are constructed from a single PRS containing a single exchanged property. This is asimple example, as only one split is required to remove exchanges. In general it might benecessary to split repeatedly until all exchanges are removed, as shown in the example givenby PRS 6 in Section 2.3. No non-exchange combinations of the properties in deleted precsand add elements should be considered during splitting. The resulting PRSs lead to theconstruction of transition rules which allow generic state transformations, such as movementfrom one location to another, to be separated from the speci c nature of the objects thatcan make those transformations.It can be observed that the rules that result from the splitting process are more generalthan the rules that would have been obtained from the PRS prior to splitting. Theydistinguish more precisely between the properties that take part in state transitions andthe properties that simply enable those transitions, allowing ner type distinctions to beinferred on the basis of the functionalities of the objects in the domain. Finer distinctionsare made during the process of seeding property and attribute spaces by uniting. This isbecause uniting merges, into single equivalence classes, all of the properties that appear inboth the start and nish of a rule.We argue that all state transformations are accounted for by the end of this secondphase. The result of the second phase is that the automata formed during the rst phaseare separated into collections of simpler automata where possible, so that no transitionsare lost but there is a ner grained encoding of the possible transitions that can be madeby objects with appropriate properties. The PRSs constructed in this phase support theconstruction of rules that allow objects making these transitions to occupy di erent propertyspaces. Some of the second phase PRSs may be under-constraining, in the sense thatanalysis of subsequent schemas might eliminate the possibilities they are keeping open, asin example 2.3.1, but the set of PRSs obtained at the end of the second phase cannot beover-constraining because all of the rst phase PRSs are considered for splitting.A subtlety concerns the consequence, at the type level, of assigning two functionallydistinct objects to the same state or attribute space. For example, in example 2.5, rocketand package are both assigned to the property space for fin1; at1g and the attribute space forfin2g. However, because rocket can be fuelled or unfuelled, and the package cannot, there isa distinction between them that emerges in the property and attribute membership vectorsassociated with the rocket and package objects. Membership of the additional property spacefor ffuelled1; unfuelled1g means that rocket is assigned a type that is a sub-type of the typeof package and the functional distinctness of rocket and package is recognised. As discussed,there is an oddity in this encoding that results in the package being assigned membershipof the fin2g attribute space. Furthermore, at1 and in1 were united, with the e ect thatrockets can make the at1 ! in1 transition and can be used to instantiate variables of typemovable object, even when variables of this type are intended only to be instantiated withthe package. There is nothing in the domain description to prevent this interpretation. Amore conventional encoding of the load schema would prevent the rocket from being loadedinto any other object, and this would cause a re nement in the type structure that wouldidentify loadable objects, and would prohibit the use of the rocket in forming instances ofoperators that should be restricted to operating on those objects.397\nFox & LongThe construction of transition rules follows a simple rule whereby any undeleted precon-ditions are used to enable a transformation from a state in which the deleted preconditionsof a PRS hold to one in which the added elements of the PRS hold. Given the assumptionthat all deleted atoms in an operator schema must appear as preconditions in that schema,these rules correctly characterize strips-style state transformations. All possible transfor-mations are captured because of the second phase of PRS construction. A complete set ofcorrect transition rules is therefore constructed.Given the correctness and completeness of the transition rule construction phase, correctinitial allocation of objects to spaces depends simply on correctly checking membership ofthe initial properties of the object in the property sets, formed by uniting the rules, thatare used to seed the spaces. Extension of the property spaces is done by straightforwardapplication of the transition rules, so all con gurations of properties that can be occupiedby the objects in the property space will have been added by the end of the extension phase.Extension of the attribute spaces is unproblematic in the cases where no potential enableris itself an attribute. If one is, then the process by which the attribute space of that enableris completed could, it appears, initiate a loop in the attribute space extension process. Infact, this does not happen as tim is able to detect when a loop has occurred and avoidrepeatedly iterating over it.The following example illustrates the problem and the way it is solved in tim. Supposewe have three attribute spaces:Attribute space 1 fq1g p1 ) null! q1 fa; bgAttribute space 2 fr1g q1 ) null! r1 fcgAttribute space 3 fp1g r1 ) null! p1 fdgThese spaces are extended by the addition of objects that potentiate their increasing rules,as discussed in Section 2.4. No problem arises if the enablers of these rules are states, andnot attributes, but in the extension of attribute space 1 above the enabler, p1, is an attribute.The attribute space for p1 has not yet been extended, so it is necessary to complete thatspace before using it to complete 1. Extension of 3 requires the extension of 2, for the samereason, and that requires the extension of 1 which requires the extension of 3, and so on.The way tim avoids re-entering this loop is by marking each space, as it is considered, ashaving been seen on this iteration. When a marked space is encountered it is not extendedbut is used as if it is already complete. Then a second iteration is required to extendany spaces that still require completion. Subsequent iterations will be required until theprocess converges. Our experiments suggest that it is unusual for there to be more thantwo iterations required. A worst case upper bound is o As, where o is the number ofdomain constants and As is the number of attribute spaces (which is limited by the numberof properties), and hence quadratic in the size of the domain description.398\nAutomatic Inference of State InvariantsIf the extension process starts with attribute space 1, in the above example, attributespace 1 will be marked as having been seen on the rst iteration. Tim then goes on toextend space 3 because the extension of space 1 depends upon space 3 being complete.Space 3 is marked as having been seen on this iteration and space 2 is considered. Space 2is marked and space 1 is revisited. Because space 1 is marked tim infers that a loop hasbeen entered. Its objects are added to space 2 without extension and the objects of space 2are then added to space 3. Finally, the objects of space 3 can be added to space 1 and the rst iteration is complete. fq1g p1 ) null! q1 fa; bg [ fc; dgfr1g q1 ) null! r1 fcg [ fa; bgfp1g r1 ) null! p1 fdg [ fc; a; bgHowever, space 2 is not yet complete, so a second iteration is required. This iterationstarts in the same place as the rst and the process is repeated, except that no furtheriterations will be required in this example.3.2 Correctness of the State InvariantsWe now argue for the correctness of the invariant inference procedure by considering eachof the four kinds of invariant in turn. The following arguments rely upon correctly dis-tinguishing property spaces from attribute spaces, since the invariant analysis cannot beperformed on attribute spaces. The only scope for confusing this distinction is in the exten-sion of mixed spaces, but we extract attributes from mixed spaces by checking for inclusionof existing states in the new states generated during extension. This process was discussedin Section 2.8.De nition 16 Given a property space P = (Ps; TRs; Ss; Os), Ss can be partitioned intothree disjoint sets: Sssubs and Sssups that contain all of the states in Ss that are included(as bags) or that include (as bags), respectively, at least one other state in Ss and Ssindthat contains all of the independent states in Ss that are neither in Sssubs nor in Sssups.Theorem 2 Given a property space P = (Ps; TRs; Ss; Os), in which the set of states Ssis a union of the three disjoint sets of states Ssind, Sssubs and Sssups, for each object, o, inOs the following families of invariants will hold:1. identity invariants;2. state membership invariants;3. unique state invariants.as de ned in Section 3.2.Proof:We address each kind of invariant in turn. By Theorem 1 every object in Os must be ina state in Ss. Furthermore, all states of each object in Os, with respect to each property inPs, will be in Ss. This follows because the properties are partitioned between the spaces399\nFox & Longduring the seeding process. Therefore, the maximum number of occurrences of a propertyp in Ps, possessed by any object in Os in any state of the world, will be bounded by themaximum number of instances of that property in any state in Ss (these maximum valuesmight not be equal since Ss can contain inaccessible states). The identity invariants simplyexpress this bound on the properties of the objects in Os.Every object in Os must be in a state in Ssind[Sssubs . This follows by de nition ofthese sets in De nition 16 and by Theorem 1. The state membership invariants assert thatevery object in Os must be in at least one of these states, with each disjunct in the invariantcorresponding to the assertion of membership of one of these states.To argue for the correctness of the unique state invariants, we observe that the proposedinvariants would only be false if they paired states that were not mutually exclusive. Inthis case, either the state extension process would have put properties that could be simul-taneously held into the same bag, or such properties would be simultaneously held in theinitial state and hence would appear in the same bag on initial construction of the propertyspace. In either case, a state will exist in the property space that is a superset of both ofthe non-exclusive states. However, uniqueness invariants are generated for pairs of statesdrawn only from Ssind [ Sssups so these non-exclusive pairs of states will not lead to thegeneration of incorrect invariants. 2The xed resource invariants are always associated with a particular predicate. If atomsbuilt with that predicate are balanced on the add and delete lists of all of the operatorschemas then the number of occurrences of these atoms in the initial state is xed over allsubsequent states. This is what the invariant expresses. An invariant is constructed forevery predicate that forms balanced atoms.Since no new techniques are required to infer invariants from sub-spaces, no furtherargument is required to support correctness of the invariants formed following sub-spaceanalysis.Although Theorem 2 demonstrates the correctness of the invariants inferred by tim itis possible for weak invariants to be inferred from the presence of unreachable states in Ss.Weak identity invariants are inferred if an unreachable state is generated, during extension,containing more instances of a property than are contained in any reachable state. Whenthis happens an identity invariant will be generated that is weaker than would be ideal, butis still valid. Further, if a property space contains unreachable states they will cause theinclusion of additional false disjuncts in the state membership invariants, but since thesefalse disjuncts will not exclude satisfying assignments their presence will not invalidatethe invariants. Unreachable states cause additional tautologous uniqueness invariants to begenerated but do not a ect the strength of the invariants that refer only to reachable states.Clearly we cannot hope to identify all of the unreachable states, as such an analysis wouldbe as hard as planning itself.Because no invariants are generated for attribute spaces tim cannot be claimed to becomplete. Sub-space analysis recti es this to some extent by identifying property spacesthat exist within attribute spaces and allowing further invariants to be generated. Thisanalysis could be further re ned. 400\nAutomatic Inference of State Invariants3.3 E ects of TIM on the Properties of the PlannerTim is itself sound, so no planner that uses tim is in danger of losing soundness as a result.Tim is certainly not complete for all domain axioms because there are invariant properties ofother kinds that cannot be extracted by the current version. For example, Kautz and Selman(1998) identify optimality conditions and simplifying assumptions amongst the di erentkinds of axioms that might be inferred from a domain. An optimality condition in theLogistics domain might be: a package should not be returned to a location it has beenremoved from. A simplifying assumption in the same domain might be: once a truck isloaded it should immediately move (assuming all necessary loads can be done in parallel).These constraints require a deeper analysis of the domain than is currently performed bytim, but we intend to characterise them and infer them in our future work.We cannot guarantee that the type structure inferred by tim is always fully discrimi-nating, although we do guarantee that it is not over-discriminating. However, failure ontim's part to infer all of the structure that is there to be inferred does not impact on thecompleteness of a planner using tim because, in these cases, tim will return an unstructureddomain and the planner can therefore default to reasoning with the unstructured domainwhen necessary.4. Experimental ResultsAn examination of tim's performance can be carried out on several dimensions. We considerthree speci c dimensions here: the viability of the analysis on typical benchmark domains;the scalability of the analysis and the utility of performing the analysis prior to planning. Itsgeneral performance on standard benchmark problems provides an indication of the scale ofthe overhead involved in using tim as a preprocessing tool. All experiments were performedunder Linux on a 300MHz PC with 128 Mb of RAM. Figure 3 shows that, even on largeproblem instances, the overhead is entirely acceptable. All of the Mystery problems listedin this table are very large (involving initial states containing hundreds of facts) and couldnot be solved by stan, ipp (Koehler, Nebel, & Dimopoulos, 1997) or Blackbox (Kautz &Selman, 1998) in the aips-98 competition. The nature of the Mystery domain is describedin Appendix C. This emphasises the relative costs of the preprocessing and planning e orts.The selection of problems used to construct table 3 is justi ed as follows. In the Blocksworld we have used a representative example from each of three encodings supplied in thepddl release. These are: the simple encoding (prob12), the att encoding (prob18) and thesnlp encoding (prob23). The Hanoi set contains a collection of reasonably sized problems.A representative group of relatively large Mystery instances was chosen from the pddlrelease. The two Tyre world instances are the only two strips instances available in therelease. The three Logistics problems are the three largest for the simple strips encodingincluded in the pddl release.The second dimension is scalability of the analysis. An analytic examination of thealgorithm can determine an upper bound on performance that is polynomial in all of thekey domain and problem components, including number of operator schemas, number ofliterals in operators, numbers of objects and facts in the initial state and the number andarities of predicates in the language. Figure 4 shows that the performance of tim is roughlyquadratic in the size of the problem speci cation. In the graph, size is crudely equated with401\nFox & Long Domain and problem Parse time Analysis time Output time TotalBlocks prob12.pddl 2 0 2 5prob18.pddl 3 1 2 7prob23.pddl 2 1 1 5Hanoi 3-disc 2 1 4 74-disc 2 1 4 75-disc 3 1 4 86-disc 3 1 4 97-disc 4 2 4 11Mystery prob060.pddl 17 15 9 43prob061.pddl 48 82 29 160prob062.pddl 26 37 10 74prob063.pddl 11 7 8 27prob064.pddl 21 21 10 52Tyre-World prob01.pddl 5 2 28 36prob02.pddl 6 2 28 37Logistics prob04.pddl 4 2 5 12prob05.pddl 4 2 6 12prob06.pddl 4 2 6 13Figure 3: Table showing tim's performance in milliseconds on standard domains and prob-lems. All timings are elapsed times and minor discrepancies in totals arise fromrounding.\n402\nAutomatic Inference of State Invariants 02000400060008000 1000012000 0 10000 20000 30000 40000 50000 60000 70000 80000Millisecs Size of le Tim Analysis of Mystery Domain\nFigure 4: Graph showing tim's performance on Mystery problems, plotting time againstsize (in characters) of problem le. The solid line is a plot of a quadratic function.the number of characters in the speci cation le. This graph was constructed by runningtim on all of the strips Mystery domain problems in the pddl release. The increasingsizes of the problem speci cations re ect increases in any and all of the various categoriesof objects in the domain and corresponding facts to describe their initial states.Figure 5 shows the e ect on tim's performance as the number of operator schemasincreases. This graph was constructed using an arti cial domain in which each new operatorcauses two new state transitions described by two new literals. Thus, both number ofoperators and number of properties is increasing whilst the number of objects stays constant.The domain is described in detail in Appendix E. The graph indicates the linear growth ofcost of analysis.The nal dimension for evaluating tim is the e ect of exploitation of its output by aplanner. Gerevini and Schubert (1998) and Kautz and Selman (1998) provide convincingevidence supporting the powerful role of state invariants in enhancing the performance ofSAT-based planning. In Figure 6 we demonstrate the power of inferred types by showing theadvantage that stan with tim obtains over stan without tim on untyped Rocket domainproblems. Figure 6 shows the e ect on performance of increasing the number of packagesto be transported. The time taken by stan with tim grows linearly, whilst stan withouttim follows a cubic curve. If there are p packages in a problem instance then stan with timconstructs 4(p+1) operator instances while stan without tim constructs (p+3)2(p+5)+2pinstances. This demonstrates that type information is the most signi cant factor in theadvantage depicted in the graph. Figure 7 demonstrates that a similar improvement isobtained in the Logistics domain. In this graph a series of sub-problems were considered in403\nFox & Long 20253035404550 55606570 0 2 4 6 8 10 12 14 16Millisecs Number of operators Tim Performance with Increasing Number of Operators3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\nAutomatic Inference of State Invariants 02000400060008000 1000012000 1 1.5 2 2.5 3 3.5 4 4.5 5Millisecs Number of sub-problems\nThe E ect of Tim on the Performance of StanSTAN without TIMSTAN with TIM Figure 7: Graph showing comparison between stan with and stan without tim on Logisticsdomain problems.which each sub-problem involves the independent transportation of a single package betweentwo cities.In very simple domains, the overhead of carrying out this analysis can outweigh theadvantages o ered. For example, in the Movie domain used in the competition stan gainedno bene ts from using tim but paid the overhead to the detriment of its performance oninstances from that domain. However, in general we observe that the bene ts of this analysisincrease with the increasing complexity of domains.5. Related WorkAlthough the importance of state invariants for e cient planning has been observed therehas been relatively little work on automatic inference of invariants. The published work thatmost closely resembles the research described in this paper is the state constraint inferencesystem discoplan, of Gerevini and Schubert (1998). Discoplan enables the inferenceof sv-constraints that correspond to a subset of our identity invariants. The reason thatdiscoplan is restricted to a subset is that it generates sv-constraints only for pairs of literals(one on the addlist of a schema and the other on the delete list) in which the argumentsvary in only one place. Tim can infer identity invariants in which vectors of arguments vary,as shown in Section 2.7. Discoplan cannot currently infer all singly varying constraints(although the techniques described by Gerevini and Schubert (1996a) are not yet fullyimplemented in discoplan). For example, discoplan cannot infer that all blocks can only405\nFox & Longbe on one surface, in its analysis of the Blocks world domain cited in the paper. Tim caninfer these invariants from its sub-space analysis.Gerevini and Schubert (1996a, 1996b) have also examined the potential for inferringparameter domains that are similar to the operator parameter types inferred by tim. Theirdomains are inferred by an iterative process of accretion which is similar to the attributespace extension process of tim. However, the accretion process they describe is synthetic,in that the parameter domains are synthesised directly from the operator descriptions andinitial state. Tim is an analytic system that constructs its types from an analysis of the func-tional properties of the domain objects. This analytic approach provides a rich informationsource from which other structures, including the domain invariants, can be derived.Some of the implicative constraints inferred by discoplan correspond to an implicittype assignment and would arise in the type structure built by tim. A further implicativeconstraint generated by discoplan refers to the separation of functional roles of objects.In particular, the irre exivity of on, as in:8x 8y (on(x; y)! :(x = y))can be captured using this kind of constraint. Tim cannot currently infer these invariants.Because tim uses an analysis based on the state view of objects in the domain it is ableto generate a broader collection of invariants, including state membership and unique stateinvariants currently not produced by discoplan.Although discoplan can deal with negative preconditions and tim cannot yet managethem, the invariants they produce overall are currently less powerful than those inferred bytim.Apart from the work of Gerevini and Schubert, there is some older work on the inferenceof invariants which also relies on the generation of candidate invariants which are thencon rmed by an inductive process against the domain operators. Two examples are thework of Kelleher and Cohn (1992) and Morris and Feldman (1989). The former workconcentrates on identifying directed mutual persistence relations, which hold between pairsof facts in a domain when, once both are established, the second continues to hold whilethe rst does. The use of these relations leads to the inference of a collection of constraintswhich fall into the uniqueness invariants inferred by tim. In the work described in (Morris& Feldman, 1989) the authors build invariants by using truth counts which are counts of thenumber of propositions from particular identi ed sets which must be true in any state ofthe domain. Sets for which this count is 1 can then be used to build invariants which are asubset of the state membership and uniqueness invariants. The authors describe methods forattempting to identify the sets of facts from which to work. This work, in common with thatof Kelleher and Cohn and of Gerevini and Schubert, builds invariants by rst hypothesisinga possible seed for the invariants and then determining their validity by analysing the e ectsof the operators on these seeds. In contrast to this generate-and-test strategy, tim producesonly correct invariants which it infers from a deep, structural analysis of the domain. Theinference of invariants does not exhaust the possibilities of this analysis. For example,the type structure is inferred automatically during this analysis, which has been shown tohave dramatic potential for the e ciency of planning. The relationship between enablers,and the state transitions they enable, determines an ordering on the satisfaction of goals,which also has signi cance for e ciency. Further, the state-based view of the behaviour of406\nAutomatic Inference of State Invariantsdomain objects would allow the techniques described by McCluskey and Porteous (1997)to be automated.McCluskey and Porteous (1997) have proposed and explored an object-centred approachto planning. This approach is based on the provision, by a domain engineer, of a richcollection of state invariants for object sorts participating in functional relationships in thedomain. These invariants are then exploited in a domain compilation phase to facilitate ane cient planning application to that domain. Tim infers precisely the sorts and collectionsof state invariants that McCluskey and Porteous provide by hand.Grant (1996) generates state invariants from state descriptions, provided by hand, andthen uses these invariants to build operator schemas. His approach is clearly related eventhough the objectives of his analysis are di erent. Grant is concerned with the automaticsynthesis of domain descriptions from a rich requirements speci cation provided by anexpert user. Our concern is with reverse-engineering a domain description to obtain the in-formation that can help increase the e ciency of planners applied to that domain. Althoughthe primary objectives in the use of tim are to enhance the performance of planning withina domain, tim also provides a valuable tool in the construction of domain descriptions byrevealing the underlying behaviours that the domain engineer has implicitly imposed, andhelping with the debugging of domain descriptions.6. ConclusionTim is a planner-independent set of techniques for identifying the underlying structure of adomain, revealing its type structure and a collection of four di erent kinds of invariant con-ditions. One important application of these techniques is as a domain debugging aid duringthe construction of large and complex domains. Using tim has revealed many anomaliesin domains encoded by us and by others, and has greatly assisted us in understandingstan's performance on many domains and problems. Another important application is inincreasing the e ciency of planners by making explicit to the planner information aboutthe domain that it would otherwise have to infer, from the domain representation, duringplanning.Tim generates a rich collection of invariants containing many that are not inferrable byrelated systems, as discussed in the previous section. The results presented by Gereviniand Schubert (1998) suggest that a marked improvement can be obtained from the use ofinvariants in the performance of planners based on SAT-solving techniques. No analysishas yet been done to determine what advantages might be obtainable by using invariants inplanners based on other architectures. Stan does not yet exploit all of the invariants pro-duced by tim during planning. It uses the type structure and the xed resource invariantsand we are currently developing an extension of stan that will fully exploit the other kindsof invariant. We expect to be able to use the uniqueness and identity invariants to shortcutthe e ort involved in deducing a signi cant subset of the necessary mutex relations duringgraph construction.The analysis performed by tim is e cient, growing more slowly than a quadratic functionof the size of the initial state being analysed. Our empirical analysis does not considerthe e ect on tim's performance of increasing numbers of operator schemas. However, theargument presented in Section 4 shows that tim's analysis grows linearly with the number407\nFox & Longof operator schemas, linearly with the number of domain constants and linearly with thesize of the initial state. There are other factors to take into account, but this con rms apolynomial performance as the size (and related structure) of the domain increases.The type analysis performed by tim di ers, in some important respects, from the variousforms of type analysis performed during the compilation of programs written in stronglytyped languages. In the latter context the type-correctness of a program is judged withrespect to an imposed context of basic types. Tim infers the basic types from the domaindescription so it is impossible for a domain speci cation not to be well-typed. Consequentlywe do not attempt to type-check domain descriptions using tim. This is a direction in whichwe hope to move in the near future, because type-checking will enable some unsolvableproblems to be detected as unsolvable statically rather than at planning time. We currentlyfocus only on type inference and the exploitation of the inferred type structure in themanagement of the search space of the planner.7. AcknowledgementsWe would like to thank Alfonso Gerevini, Gerry Kelleher and the anonymous referees foruseful discussions and helpful comments on earlier drafts of this paper.Appendix A. FTP and Web SitesThe aips-98 Planning Competition FTP site is at:http://ftp.cs.yale.edu/pub/mcdermott/aipscomp-results.html.Our web site, on which stan and tim executables can be found, is at:http://www.dur.ac.uk/ dcs0www/research/stanstuff/planpage.htmlAppendix B. The TIM AlgorithmThe following is a pseudo-code description of the tim algorithm.fConstruct base PRSs (Section 2.3)gPs := fg;for each operator schema, O,for each variable in O, x,construct a PRS for x from O and add to Ps;fSplit PRSsgfor each PRS in Ps, P,if a property, p, appears in P in both the adds and deleted precs eldsthen split P over p, into P' and Q and replace P with P' and Q in Ps,where to split P over p:construct PRS Q with the same precs as P, deleted precs and adds both set to fpg;construct PRS P' from P by removing p from deleted precs and adds of P;fConstruct transition rules (Section 2.3)gTs := fg;for each PRS in Ps, P,construct a transition rule for P and add to Ts;fSeed property and attribute spaces (Section 2.3)glet each property be initially assigned to a separate equivalence class;for each rule, r, in Tsmerge together (unite) the equivalence classes for all the properties in the start and nish of r;408\nAutomatic Inference of State Invariantsconstruct a separate space for each equivalence class of properties;fAssign transition rules (Section 2.4)gfor each rule, r, in Tsplace r in the space associated with the equivalence class containing the propertiesin the start (and nish) of r, s;if r is an increasing or decreasing rulethen mark s as an attribute space;fAnalyse initial state (Section 2.4)gfor each object, o, in the domainidentify the bag of initial properties of o, I(o);for each space, s,construct the bag of properties from I(o) which belong to the equivalence classassociated with s, b;if b is non-emptythen add o to the space s;if s is not an attribute spacethen add b as a state in s;fExtend property spaces (Section 2.4)gfor each property space, p,while there is an unextended state in p, s,mark s as extended;newgen := fg;for each rule in p, r,if the start of r is included in sthen add the state snew = (s ominus start oplus end) to newgen;if snewis a superset of any state in newgenthen mark p is an attribute space and exit the analysis of p;add newgen to the states in p;fExtend attribute spaces (Section 2.4)gchanges := TRUE;while changes,changes := FALSE;for each unmarked attribute space, a,extend a where to extend a:mark a;for each rule in a, r,for each property in enablers of r, p,if p's equivalence class is associated with an unmarked attribute space, a',then extend a';add all objects that appear in every space associated with an enabling property for r to a;if objects are addedthen changes := TRUE;fIdentify types (Section 2.6)gfor each object in the domain, o,identify the pattern of membership of spaces for o, tt;associate the type pattern, tt, with o;for each operator schema, O,for each argument of O, x,identify the pattern of membership of spaces for x implied by the properties of x in thepreconditions of O, tt;associate type pattern, tt, with x in O;fConstruct invariants (Section 2.7)gfor each property space, P,for each property in P, p,construct an identity invariant for p;construct a state membership invariant for P;construct a uniqueness invariant for P; 409\nFox & LongAppendix C. Example OutputThe following output was produced by tim and can be found, along with other examples,on the stan webpage. These examples show the details of the analysis performed on eachof three domains: a Flat-tyre domain, a Mystery domain and a Logistics domain. Theanalysis is done with respect to an initial state and a set of operator schemas. The operatorschemas used in these three domains are those provided with the pddl strips releases forthese domains. The initial states were taken from the pddl release. The pddl release canbe found at http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/mcdermott.html.C.1 The Tyre WorldTIM: Type Inference Mechanism - support for STAN: State Analysis PlannerD. Long and M. Fox, University of DurhamReading domain file: domain01.pddlReading problem file: prob01.pddlTIM: Domain analysis complete for flat-tire-stripsTIM: TYPES:Type T0 = {wrench}Type T1 = {wheel2}Type T2 = {wheel1}Type T3 = {trunk}Type T4 = {the-hub}Type T5 = {pump}Type T6 = {nuts}Type T7 = {jack}It will be noticed that the two wheels are separated into di erent types. This is becauseone wheel is intact and the other is not intact, and there is no operator for repairing wheelsthat are not intact. The tools have each been given di erent types. This is because theyeach appear as constants in di erent operators and therefore are functionally distinct.TIM: STATE INVARIANTS:FORALL x:T4. (on-ground(x) OR lifted(x))FORALL x:T4. NOT (on-ground(x) AND lifted(x))FORALL x:T3. (closed(x) OR open(x))FORALL x:T3. NOT (closed(x) AND open(x))410\nAutomatic Inference of State InvariantsFORALL x:T1 U T2. (deflated(x) OR inflated(x))FORALL x:T1 U T2. NOT (deflated(x) AND inflated(x))The invariants for hubs (below) suggest that almost anything could be on a hub. Sincethis is not the case the type structure is under-discriminating. However, the additionalinvariants drawn from the sub-space analysis provide enough information, in principle, todiscriminate more fully between the types. This information is not yet being fully exploited.FORALL x:T4. FORALL y1. FORALL z1. on(y1,x) AND on(z1,x) => y1 = z1FORALL x:T4. (Exists y1:T0 U T1 U T2 U T5 U T6 U T7. on(y1,x)OR free(x))FORALL x:T4. NOT (Exists y1:T0 U T1 U T2 U T5 U T6 U T7. on(y1,x)AND free(x))FORALL x:T4. FORALL y1. FORALL z1. tight(y1,x) AND tight(z1,x) => y1 = z1FORALL x:T4. FORALL y1. FORALL z1. loose(y1,x) AND loose(z1,x) => y1 = z1FORALL x:T4. ((Exists y1:T0 U T1 U T2 U T5 U T6 U T7. tight(y1,x)AND fastened(x))OR (Exists y1:T0 U T1 U T2 U T5 U T6 U T7. loose(y1,x)AND fastened(x)) OR unfastened(x))FORALL x:T4. NOT ((Exists y1:T0 U T1 U T2 U T5 U T6 U T7. tight(y1,x)AND fastened(x))AND (Exists y1:T0 U T1 U T2 U T5 U T6 U T7. loose(y1,x)AND fastened(x)))FORALL x:T4. NOT ((Exists y1:T0 U T1 U T2 U T5 U T6 U T7. tight(y1,x)AND fastened(x)) AND unfastened(x))FORALL x:T4. NOT ((Exists y1:T0 U T1 U T2 U T5 U T6 U T7. loose(y1,x)AND fastened(x)) AND unfastened(x))TIM: DOMAIN INVARIANTS:|{x0: container(x0)}| = 1|{x0: hub(x0)}| = 1|{x0: intact(x0)}| = 1|{x0: jack(x0)}| = 1|{x0: nut(x0)}| = 1|{x0: pump(x0)}| = 1|{x0: unlocked(x0)}| = 1|{x0: wheel(x0)}| = 2|{x0: wrench(x0)}| = 1TIM: ATTRIBUTE SPACES: 411\nFox & LongThe attribute space for the properties in the rst of these groups is subjected to a muchmore rigorous analysis in the sub-space invariants below.Objects, x, in T0 U T1 U T2 U T5 U T6 U T7 can have property:Exists y1:T3. in(x,y1);Exists y1:T4. on(x,y1);Exists y1:T4. tight(x,y1);Exists y1:T4. loose(x,y1);have(x);Objects, x, in T3 can have property:Exists y1:T0 U T1 U T2 U T5 U T6 U T7. in(y1,x);Objects, x, in T3 all have property: container(x);Objects, x, in T4 all have property: hub(x);Objects, x, in T1 all have property: intact(x);Objects, x, in T7 all have property: jack(x);Objects, x, in T6 all have property: nut(x);Objects, x, in T5 all have property: pump(x);Objects, x, in T3 all have property: unlocked(x);Objects, x, in T1 U T2 all have property: wheel(x);Objects, x, in T0 all have property: wrench(x);TIM: OPERATOR PARAMETER RESTRICTIONS:inflate(x1:T1)put-on-wheel(x1:T1 U T2,x2:T4)remove-wheel(x1:T1 U T2,x2:T4)put-on-nuts(x1:T6,x2:T4)remove-nuts(x1:T6,x2:T4)jack-down(x1:T4)jack-up(x1:T4)tighten(x1:T6,x2:T4)loosen(x1:T6,x2:T4)put-away(x1:T0 U T1 U T2 U T5 U T6 U T7,x2:T3)fetch(x1:T0 U T1 U T2 U T5 U T6 U T7,x2:T3)close-container(x1:T3)open-container(x1:T3)cuss()TIM: ADDITIONAL STATE INVARIANTS, USING SUB-SPACE ANALYSIS:We report here only the additional state invariants that add information to the invariantsalready listed. TIM currently reports invariants that are subsumed by the earlier collection.It should be observed that the rst wheel is intact but the second is not, and this givesrise to the following new invariant for wheels of the second type.412\nAutomatic Inference of State InvariantsFORALL x:T2. (deflated(x))The rst attribute space, which contains all objects except the trunk and the hub, is nowsubjected to sub-space analysis yielding a rich new collection of invariants.FORALL x:T0. FORALL y1. FORALL z1. in(x,y1) AND in(x,z1) => y1 = z1FORALL x:T0. (Exists y1:T3. in(x,y1) OR have(x))FORALL x:T0. NOT (Exists y1:T3. in(x,y1) AND have(x))FORALL x:T1. FORALL y1. FORALL z1. in(x,y1) AND in(x,z1) => y1 = z1FORALL x:T1. FORALL y1. FORALL z1. on(x,y1) AND on(x,z1) => y1 = z1FORALL x:T1. (Exists y1:T3. in(x,y1) OR have(x)OR Exists y1:T4. on(x,y1))FORALL x:T1. NOT (Exists y1:T3. in(x,y1) AND have(x))FORALL x:T1. NOT (Exists y1:T3. in(x,y1) AND Exists y1:T4. on(x,y1))FORALL x:T1. NOT (have(x) AND Exists y1:T4. on(x,y1))FORALL x:T2. FORALL y1. FORALL z1. in(x,y1) AND in(x,z1) => y1 = z1FORALL x:T2. FORALL y1. FORALL z1. on(x,y1) AND on(x,z1) => y1 = z1FORALL x:T2. (Exists y1:T4. on(x,y1) OR have(x)OR Exists y1:T3. in(x,y1))FORALL x:T2. NOT (Exists y1:T4. on(x,y1) AND have(x))FORALL x:T2. NOT (Exists y1:T4. on(x,y1) AND Exists y1:T3. in(x,y1))FORALL x:T2. NOT (have(x) AND Exists y1:T3. in(x,y1))FORALL x:T5. FORALL y1. FORALL z1. in(x,y1) AND in(x,z1) => y1 = z1FORALL x:T5. (Exists y1:T3. in(x,y1) OR have(x))FORALL x:T5. NOT (Exists y1:T3. in(x,y1) AND have(x))FORALL x:T6. FORALL y1. FORALL z1. in(x,y1) AND in(x,z1) => y1 = z1FORALL x:T6. FORALL y1. FORALL z1. tight(x,y1)AND tight(x,z1) => y1 = z1FORALL x:T6. FORALL y1. FORALL z1. loose(x,y1)AND loose(x,z1) => y1 = z1FORALL x:T6. (Exists y1:T4. tight(x,y1)OR Exists y1:T4. loose(x,y1)OR have(x) OR Exists y1:T3. in(x,y1))FORALL x:T6. NOT (Exists y1:T4. tight(x,y1)AND Exists y1:T4. loose(x,y1))FORALL x:T6. NOT (Exists y1:T4. tight(x,y1) AND have(x))FORALL x:T6. NOT (Exists y1:T4. tight(x,y1)AND Exists y1:T3. in(x,y1))FORALL x:T6. NOT (Exists y1:T4. loose(x,y1) AND have(x))FORALL x:T6. NOT (Exists y1:T4. loose(x,y1)AND Exists y1:T3. in(x,y1))FORALL x:T6. NOT (have(x) AND Exists y1:T3. in(x,y1))413\nFox & LongC.2 The Mystery DomainThe Mystery domain was devised by DrewMcDermott for the aips-98 planning competition.His intention was to conceal the structure of the problem domain by employing an obscureencoding of a transportation domain. The code replaces locations with the names of foodsand the routes between them with eats relations. The transports are pleasures while cargosare pains. Cargos and transports can be at locations, with the at relation encoded as craves.A cargo is either at a location or in a transport encoded by the fears relation. Transportshave restricted capacity encoded by planets and consume fuel in travelling between locations.Fuel exists in limited quantities at locations measured by provinces. Using TIM we wereable to decode the domain and identify the roles played by each of the components of theencoding.TIM: Domain analysis complete for mystery-strips (prob048.pddl)TIM: TYPES:It should be noted that provinces (types T6, T7 and T8) are divided into three separatetypes because they form a sequence, de ned by the attacks relation, in which the rst andlast have a slightly di erent functional role to the others. The same is true of the planets(types T1, T2 and T3).Type T0 = {beef,cantelope,chocolate,flounder,guava,mutton,onion,pepper,rice,shrimp,sweetroll,tuna,yogurt}Type T1 = {saturn}Type T2 = {pluto}Type T3 = {neptune}Type T4 = {achievement,lubricity}Type T5 = {abrasion,anger,angina,boils,depression,grief,hangover,laceration}Type T6 = {alsace,bosnia,guanabara,kentucky}Type T7 = {goias}Type T8 = {arizona}TIM: STATE INVARIANTS:FORALL x:T4. FORALL y1. FORALL z1. harmony(x,y1)AND harmony(x,z1) => y1 = z1FORALL x:T4. (Exists y1:T1 U T2 U T3. harmony(x,y1))FORALL x:T0. FORALL y1. FORALL z1. locale(x,y1)AND locale(x,z1) => y1 = z1FORALL x:T0. (Exists y1:T6 U T7 U T8. locale(x,y1))FORALL x:T4 U T5. FORALL y1. FORALL z1. fears(x,y1)414\nAutomatic Inference of State InvariantsAND fears(x,z1) => y1 = z1FORALL x:T4 U T5. FORALL y1. FORALL z1. craves(x,y1)AND craves(x,z1) => y1 = z1FORALL x:T4 U T5. (Exists y1:T0. craves(x,y1)OR Exists y1:T4. fears(x,y1))FORALL x:T4 U T5. NOT (Exists y1:T0. craves(x,y1)AND Exists y1:T4. fears(x,y1))TIM: DOMAIN INVARIANTS:|{(x0,x1): attacks(x0,x1)}| = 5|{(x0,x1): eats(x0,x1)}| = 36|{x0: food(x0)}| = 13|{(x0,x1): harmony(x0,x1)}| = 2|{(x0,x1): locale(x0,x1)}| = 13|{(x0,x1): orbits(x0,x1)}| = 2|{x0: pain(x0)}| = 8|{x0: planet(x0)}| = 3|{x0: pleasure(x0)}| = 2|{x0: province(x0)}| = 6TIM: ATTRIBUTE SPACES:Objects, x, in T1 U T2 U T3 can have property:Exists y1:T4. harmony(y1,x);Objects, x, in T6 U T7 U T8 can have property:Exists y1:T0. locale(y1,x);Objects, x, in T4 can have property:Exists y1:T4. fears(y1,x);Objects, x, in T0 can have property:Exists y1:T4 U T5. craves(y1,x);Objects, x, in T6 U T7 all have property:Exists y1:T6 U T8. attacks(x,y1);Objects, x, in T6 U T8 all have property:Exists y1:T6 U T7. attacks(y1,x);Objects, x, in T0 all have property:Exists y1:T0. eats(x,y1);Objects, x, in T0 all have property:Exists y1:T0. eats(y1,x);Objects, x, in T0 all have property: food(x);Objects, x, in T2 U T3 all have property:Exists y1:T1 U T2. orbits(x,y1); 415\nFox & LongObjects, x, in T1 U T2 all have property:Exists y1:T2 U T3. orbits(y1,x);Objects, x, in T5 all have property: pain(x);Objects, x, in T1 U T2 U T3 all have property: planet(x);Objects, x, in T4 all have property: pleasure(x);Objects, x, in T6 U T7 U T8 all have property: province(x);TIM: OPERATOR PARAMETER RESTRICTIONS:succumb(x1:T5,x2:T4)feast(x1:T4,x2:T0,x3:T0)overcome(x1:T5,x2:T4)TIM: ADDITIONAL STATE INVARIANTS, USING SUB-STATE ANALYSIS:These additional invariants show that the transports are always at a location and neverloaded into other transports.FORALL x:T4. FORALL y1. FORALL z1. craves(x,y1)AND craves(x,z1) => y1 = z1FORALL x:T4. (Exists y1:T0. craves(x,y1))C.3 The Logistics DomainTIM: Domain analysis complete for logistics-strips (prob05.pddl)TIM: TYPES:Type T0 = {bos-truck,la-truck,pgh-truck}Type T1 = {bos-po,la-po,pgh-po}Type T2 = {bos-airport,la-airport,pgh-airport}Type T3 = {bos,la,pgh}Type T4 = {package1,package2,package3,package4,package5,package6,package7,package8}Type T5 = {airplane1,airplane2}TIM: STATE INVARIANTS:FORALL x:T0 U T4 U T5. FORALL y1. FORALL z1. at(x,y1)AND at(x,z1) => y1 = z1FORALL x:T0 U T4 U T5. FORALL y1. FORALL z1. in(x,y1)AND in(x,z1) => y1 = z1FORALL x:T0 U T4 U T5. (Exists y1:T1 U T2. at(x,y1)416\nAutomatic Inference of State InvariantsOR Exists y1:T0 U T5. in(x,y1))FORALL x:T0 U T4 U T5. NOT (Exists y1:T1 U T2. at(x,y1)AND Exists y1:T0 U T5. in(x,y1))TIM: DOMAIN INVARIANTS:|{x0: airplane(x0)}| = 2|{x0: airport(x0)}| = 3|{x0: city(x0)}| = 3|{(x0,x1): in-city(x0,x1)}| = 6|{x0: location(x0)}| = 6|{x0: obj(x0)}| = 8|{x0: truck(x0)}| = 3TIM: ATTRIBUTE SPACES:Objects, x, in T1 U T2 can have property:Exists y1:T0 U T4 U T5. at(y1,x);Objects, x, in T0 U T5 can have property:Exists y1:T0 U T4 U T5. in(y1,x);Objects, x, in T5 all have property: airplane(x);Objects, x, in T2 all have property: airport(x);Objects, x, in T3 all have property: city(x);Objects, x, in T1 U T2 all have property: Exists y1:T3. in-city(x,y1);Objects, x, in T3 all have property: Exists y1:T1 U T2. in-city(y1,x);Objects, x, in T1 U T2 all have property: location(x);Objects, x, in T4 all have property: obj(x);Objects, x, in T0 all have property: truck(x);TIM: OPERATOR PARAMETER RESTRICTIONS:drive(x1:T0,x2:T1 U T2,x3:T1 U T2,x4:T3)fly(x1:T5,x2:T2,x3:T2)unload(x1:T0 U T4 U T5,x2:T0 U T5,x3:T1 U T2)load-plane(x1:T4,x2:T5,x3:T1 U T2)load-truck(x1:T4,x2:T0,x3:T1 U T2)TIM: ADDITIONAL STATE INVARIANTS, USING SUB-STATE ANALYSIS:417\nFox & LongThe following invariants add the constraints that trucks and airplanes must always be at alocation and never loaded into one another.FORALL x:T0. FORALL y1. FORALL z1. at(x,y1) AND at(x,z1) => y1 = z1FORALL x:T0. (Exists y1:T1 U T2. at(x,y1))FORALL x:T5. FORALL y1. FORALL z1. at(x,y1) AND at(x,z1) => y1 = z1FORALL x:T5. (Exists y1:T1 U T2. at(x,y1))Appendix D. The Rocket DomainThe Rocket domain used in the construction of Figure 6 is as follows:(define (domain rocket)(:predicates (at ?x ?y)(in ?x ?y)(fuelled ?x)(unfuelled ?x)(loc ?x)(obj ?x)(container ?x))(:action fly:parameters (?x ?y ?z):precondition (and (at ?x ?y) (loc ?z) (fuelled ?x)):effect (and (not (at ?x ?y)) (at ?x ?z) (unfuelled ?x)(not (fuelled ?x))))(:action load:parameters (?x ?y ?z):precondition (and (obj ?x) (container ?y) (at ?x ?z)(at ?y ?z)):effect (and (in ?x ?y) (not (at ?x ?z))))(:action unload:parameters (?x ?y ?z):precondition (and (at ?y ?z) (in ?x ?y)):effect (and (at ?x ?z) (not (in ?x ?y)))))Appendix E. Operator Test DomainThis domain is an arti cial domain used to test the e ects of increasing operators and literalsin the domain encoding on the performance of TIM. This example is the third instance - thevariation was achieved by adding more operator schemas in the pattern of those includedhere. 418\nAutomatic Inference of State Invariants(define (domain od)(:predicates(p1 ?x ?y) (q1 ?x ?y)(p2 ?x ?y) (q2 ?x ?y)(p3 ?x ?y) (q3 ?x ?y)(p4 ?x ?y) (q4 ?x ?y)(p5 ?x ?y) (q5 ?x ?y)(p6 ?x ?y) (q6 ?x ?y)(p7 ?x ?y) (q7 ?x ?y)(p8 ?x ?y) (q8 ?x ?y)(p9 ?x ?y) (q9 ?x ?y)(p10 ?x ?y) (q10 ?x ?y)(p11 ?x ?y) (q11 ?x ?y)(p12 ?x ?y) (q12 ?x ?y)(p13 ?x ?y) (q13 ?x ?y)(p14 ?x ?y) (q14 ?x ?y)(p15 ?x ?y) (q15 ?x ?y)(p16 ?x ?y) (q16 ?x ?y)(p17 ?x ?y) (q17 ?x ?y)(p18 ?x ?y) (q18 ?x ?y)(p19 ?x ?y) (q19 ?x ?y)(p20 ?x ?y) (q20 ?x ?y))(:action o1:parameters (?x ?y ?z):precondition (and (p1 ?x ?y) (q1 ?x ?z)):effect (and (not (p1 ?x ?y)) (not (q1 ?x ?z))(p1 ?x ?z) (q1 ?x ?y)))(:action o2:parameters (?x ?y ?z):precondition (and (p2 ?x ?y) (q2 ?x ?z)):effect (and (not (p2 ?x ?y)) (not (q2 ?x ?z))(p2 ?x ?z) (q2 ?x ?y)))(:action o3:parameters (?x ?y ?z):precondition (and (p3 ?x ?y) (q3 ?x ?z)):effect (and (not (p3 ?x ?y)) (not (q3 ?x ?z))(p3 ?x ?z) (q3 ?x ?y))))The problem instance was xed as follows:(define (problem op)(:domain od)(:objects a b c) 419\nFox & Long(:init (p1 a b) (q1 a c)(p2 a b) (q2 a c)(p3 a b) (q3 a c)(p4 a b) (q4 a c)(p5 a b) (q5 a c)(p6 a b) (q6 a c)(p7 a b) (q7 a c)(p8 a b) (q8 a c)(p9 a b) (q9 a c)(p10 a b) (q10 a c)(p11 a b) (q11 a c)(p12 a b) (q12 a c)(p13 a b) (q13 a c)(p14 a b) (q14 a c)(p15 a b) (q15 a c)(p16 a b) (q16 a c)(p17 a b) (q17 a c)(p18 a b) (q18 a c)(p19 a b) (q19 a c)(p20 a b) (q20 a c))(:goal (and (p1 a c) (q1 a b))))ReferencesBlum, A., & Furst, M. (1995). Fast Planning through Plan-graph Analysis. In IJCAI.Bundy, A., Burstall, R., Weir, S., & Young, R. (1980). Arti cial Intelligence: An Introduc-tory Course. Edinburgh University Press.Fikes, R., & Nilsson, N. (1971). STRIPS: A New Approach to the Application of Theorem-Proving to Problem-Solving. Arti cial Intelligence, 2 (3).Gerevini, A., & Schubert, L. (1996a). Accelerating Partial Order Planners: Some Tech-niques for E ective Search Control and Pruning. JAIR, 5, 95{137.Gerevini, A., & Schubert, L. (1996b). Computing Parameter Domains as an Aid to Planning.In AIPS-96.Gerevini, A., & Schubert, L. (1998). Inferring State Constraints for Domain-IndependentPlanning. In AAAI.Grant, T. J. (1996). Inductive Learning of Knowledge-based Planning Operators. Ph.D.thesis, Rijksuniversiteit Limburg de Maastricht.Kautz, H., & Selman, B. (1998). The Role of Domain Speci c Knowledge in the Planningas Satis ability Framework. In The Fourth International Conference on Arti cialIntelligence Planning Systems. 420\nAutomatic Inference of State InvariantsKelleher, G., & Cohn, A. (1992). Automatically Synthesising Domain Constraints fromOperator Descriptions. In Proceedings ECAI92.Koehler, J., Nebel, B., & Dimopoulos, Y. (1997). Extending Planning Graphs to an ADLSubset. In Proceedings of 4th European Conference on Planning.Liatsos, V., & Richards, B. (1997). Least Commitment: An Optimal Planning Strategy. InProceedings of the 16th Workshop of the UK Planning and Scheduling Special InterestGroup.Long, D., & Fox, M. (in press). The E cient Implementation of the Plangraph in stan. InJAIR.McCluskey, T. L., & Porteous, J. (1997). Engineering and Compiling Planning DomainModels to Promote Validity and E ciency. Arti cial Intelligence, 95 (1).Morris, P., & Feldman, R. (1989). Automatically Derived Heuristics for Planning Search.In Proceedings of the 2nd Irish Conference on Arti cial Intelligence and CognitiveScience, School of Computer Applications, Dublin City University.\n421"
    } ],
    "references" : [ {
      "title" : "Fast Planning through Plan-graph Analysis",
      "author" : [ "A. Blum", "M. Furst" ],
      "venue" : "In IJCAI",
      "citeRegEx" : "Blum and Furst,? \\Q1995\\E",
      "shortCiteRegEx" : "Blum and Furst",
      "year" : 1995
    }, {
      "title" : "STRIPS: A New Approach to the Application of Theorem",
      "author" : [ "R. Fikes", "N. Nilsson" ],
      "venue" : null,
      "citeRegEx" : "Fikes and Nilsson,? \\Q1971\\E",
      "shortCiteRegEx" : "Fikes and Nilsson",
      "year" : 1971
    }, {
      "title" : "Accelerating Partial Order Planners",
      "author" : [ "A. Gerevini", "L. Schubert" ],
      "venue" : null,
      "citeRegEx" : "Gerevini and Schubert,? \\Q1996\\E",
      "shortCiteRegEx" : "Gerevini and Schubert",
      "year" : 1996
    }, {
      "title" : "Computing Parameter Domains as an Aid to Planning",
      "author" : [ "A. Gerevini", "L. Schubert" ],
      "venue" : null,
      "citeRegEx" : "Gerevini and Schubert,? \\Q1996\\E",
      "shortCiteRegEx" : "Gerevini and Schubert",
      "year" : 1996
    }, {
      "title" : "Inferring State Constraints for Domain-Independent",
      "author" : [ "A. Gerevini", "L. Schubert" ],
      "venue" : null,
      "citeRegEx" : "Gerevini and Schubert,? \\Q1998\\E",
      "shortCiteRegEx" : "Gerevini and Schubert",
      "year" : 1998
    }, {
      "title" : "Inductive Learning of Knowledge-based Planning Operators",
      "author" : [ "T.J. Grant" ],
      "venue" : null,
      "citeRegEx" : "Grant,? \\Q1996\\E",
      "shortCiteRegEx" : "Grant",
      "year" : 1996
    }, {
      "title" : "The Role of Domain Speci c Knowledge in the Planning",
      "author" : [ "H. Kautz", "B. Selman" ],
      "venue" : null,
      "citeRegEx" : "Kautz and Selman,? \\Q1998\\E",
      "shortCiteRegEx" : "Kautz and Selman",
      "year" : 1998
    }, {
      "title" : "Automatically Synthesising Domain Constraints",
      "author" : [ "G. Kelleher", "A. Cohn" ],
      "venue" : null,
      "citeRegEx" : "Kelleher and Cohn,? \\Q1992\\E",
      "shortCiteRegEx" : "Kelleher and Cohn",
      "year" : 1992
    }, {
      "title" : "Extending Planning Graphs to an ADL",
      "author" : [ "J. Koehler", "B. Nebel", "Y. Dimopoulos" ],
      "venue" : null,
      "citeRegEx" : "Koehler et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Koehler et al\\.",
      "year" : 1997
    }, {
      "title" : "Least Commitment: An Optimal Planning Strategy",
      "author" : [ "V. Liatsos", "B. Richards" ],
      "venue" : null,
      "citeRegEx" : "Liatsos and Richards,? \\Q1997\\E",
      "shortCiteRegEx" : "Liatsos and Richards",
      "year" : 1997
    }, {
      "title" : "Engineering and Compiling Planning Domain",
      "author" : [ "T.L. McCluskey", "J. Porteous" ],
      "venue" : null,
      "citeRegEx" : "McCluskey and Porteous,? \\Q1997\\E",
      "shortCiteRegEx" : "McCluskey and Porteous",
      "year" : 1997
    }, {
      "title" : "Automatically Derived Heuristics for Planning Search",
      "author" : [ "P. Morris", "R. Feldman" ],
      "venue" : null,
      "citeRegEx" : "Morris and Feldman,? \\Q1989\\E",
      "shortCiteRegEx" : "Morris and Feldman",
      "year" : 1989
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "Gerevini and Schubert (1996a, 1996b) have considered the automatic inference of some state constraints and demonstrated that a signi cant empirical advantage can be obtained from their use. Kautz and Selman (1998) have handcoded invariants and provided them as part of the domain description used by Blackbox.",
      "startOffset" : 0,
      "endOffset" : 214
    }, {
      "referenceID" : 2,
      "context" : "Gerevini and Schubert (1996a, 1996b) have considered the automatic inference of some state constraints and demonstrated that a signi cant empirical advantage can be obtained from their use. Kautz and Selman (1998) have handcoded invariants and provided them as part of the domain description used by Blackbox. They demonstrate the performance advantages obtained and acknowledge the importance of inferring such invariants automatically. McCluskey and Porteous (1997) have also demonstrated the important role that hand-coded state invariants can play in domain compilation for e cient planning.",
      "startOffset" : 0,
      "endOffset" : 468
    }, {
      "referenceID" : 2,
      "context" : "Gerevini and Schubert (1996a, 1996b) have considered the automatic inference of some state constraints and demonstrated that a signi cant empirical advantage can be obtained from their use. Kautz and Selman (1998) have handcoded invariants and provided them as part of the domain description used by Blackbox. They demonstrate the performance advantages obtained and acknowledge the importance of inferring such invariants automatically. McCluskey and Porteous (1997) have also demonstrated the important role that hand-coded state invariants can play in domain compilation for e cient planning. Earlier work by Kelleher and Cohn (1992) and Morris and Feldman (1989) explores the automatic generation of some restricted invariant forms.",
      "startOffset" : 0,
      "endOffset" : 637
    }, {
      "referenceID" : 2,
      "context" : "Gerevini and Schubert (1996a, 1996b) have considered the automatic inference of some state constraints and demonstrated that a signi cant empirical advantage can be obtained from their use. Kautz and Selman (1998) have handcoded invariants and provided them as part of the domain description used by Blackbox. They demonstrate the performance advantages obtained and acknowledge the importance of inferring such invariants automatically. McCluskey and Porteous (1997) have also demonstrated the important role that hand-coded state invariants can play in domain compilation for e cient planning. Earlier work by Kelleher and Cohn (1992) and Morris and Feldman (1989) explores the automatic generation of some restricted invariant forms.",
      "startOffset" : 0,
      "endOffset" : 667
    }, {
      "referenceID" : 5,
      "context" : "STRIPS domains have been seen in this way in earlier work (McCluskey & Porteous, 1997; Grant, 1996), as discussed in Section 5.",
      "startOffset" : 58,
      "endOffset" : 99
    }, {
      "referenceID" : 5,
      "context" : "STRIPS domains have been seen in this way in earlier work (McCluskey & Porteous, 1997; Grant, 1996), as discussed in Section 5. 2.1 Types in TIM When two objects participate in identical FSMs they are functionally equivalent and can be seen to be of the same type. The notion of type here is similar to that of sorts in the work of McCluskey and Porteous (1997). A primary objective of the tim module is to automatically identify the equivalence classes that form the primitive types in a domain description and to infer the hierarchical type structure of a domain on the basis of the primitive types.",
      "startOffset" : 87,
      "endOffset" : 362
    }, {
      "referenceID" : 5,
      "context" : "Grant (1996) identi es this version of the move operator as awed, because of the need to maintain state correctness by the addition of the invariant clear(table) to the add list.",
      "startOffset" : 0,
      "endOffset" : 13
    }, {
      "referenceID" : 6,
      "context" : "For example, Kautz and Selman (1998) identify optimality conditions and simplifying assumptions amongst the di erent kinds of axioms that might be inferred from a domain.",
      "startOffset" : 13,
      "endOffset" : 37
    }, {
      "referenceID" : 2,
      "context" : "Gerevini and Schubert (1998) and Kautz and Selman (1998) provide convincing evidence supporting the powerful role of state invariants in enhancing the performance of SAT-based planning.",
      "startOffset" : 0,
      "endOffset" : 29
    }, {
      "referenceID" : 2,
      "context" : "Gerevini and Schubert (1998) and Kautz and Selman (1998) provide convincing evidence supporting the powerful role of state invariants in enhancing the performance of SAT-based planning.",
      "startOffset" : 0,
      "endOffset" : 57
    }, {
      "referenceID" : 2,
      "context" : "The published work that most closely resembles the research described in this paper is the state constraint inference system discoplan, of Gerevini and Schubert (1998). Discoplan enables the inference of sv-constraints that correspond to a subset of our identity invariants.",
      "startOffset" : 139,
      "endOffset" : 168
    }, {
      "referenceID" : 2,
      "context" : "The published work that most closely resembles the research described in this paper is the state constraint inference system discoplan, of Gerevini and Schubert (1998). Discoplan enables the inference of sv-constraints that correspond to a subset of our identity invariants. The reason that discoplan is restricted to a subset is that it generates sv-constraints only for pairs of literals (one on the addlist of a schema and the other on the delete list) in which the arguments vary in only one place. Tim can infer identity invariants in which vectors of arguments vary, as shown in Section 2.7. Discoplan cannot currently infer all singly varying constraints (although the techniques described by Gerevini and Schubert (1996a) are not yet fully implemented in discoplan).",
      "startOffset" : 139,
      "endOffset" : 730
    }, {
      "referenceID" : 2,
      "context" : "Gerevini and Schubert (1996a, 1996b) have also examined the potential for inferring parameter domains that are similar to the operator parameter types inferred by tim. Their domains are inferred by an iterative process of accretion which is similar to the attribute space extension process of tim. However, the accretion process they describe is synthetic, in that the parameter domains are synthesised directly from the operator descriptions and initial state. Tim is an analytic system that constructs its types from an analysis of the functional properties of the domain objects. This analytic approach provides a rich information source from which other structures, including the domain invariants, can be derived. Some of the implicative constraints inferred by discoplan correspond to an implicit type assignment and would arise in the type structure built by tim. A further implicative constraint generated by discoplan refers to the separation of functional roles of objects. In particular, the irre exivity of on, as in: 8x 8y (on(x; y)! :(x = y)) can be captured using this kind of constraint. Tim cannot currently infer these invariants. Because tim uses an analysis based on the state view of objects in the domain it is able to generate a broader collection of invariants, including state membership and unique state invariants currently not produced by discoplan. Although discoplan can deal with negative preconditions and tim cannot yet manage them, the invariants they produce overall are currently less powerful than those inferred by tim. Apart from the work of Gerevini and Schubert, there is some older work on the inference of invariants which also relies on the generation of candidate invariants which are then con rmed by an inductive process against the domain operators. Two examples are the work of Kelleher and Cohn (1992) and Morris and Feldman (1989).",
      "startOffset" : 0,
      "endOffset" : 1852
    }, {
      "referenceID" : 2,
      "context" : "Gerevini and Schubert (1996a, 1996b) have also examined the potential for inferring parameter domains that are similar to the operator parameter types inferred by tim. Their domains are inferred by an iterative process of accretion which is similar to the attribute space extension process of tim. However, the accretion process they describe is synthetic, in that the parameter domains are synthesised directly from the operator descriptions and initial state. Tim is an analytic system that constructs its types from an analysis of the functional properties of the domain objects. This analytic approach provides a rich information source from which other structures, including the domain invariants, can be derived. Some of the implicative constraints inferred by discoplan correspond to an implicit type assignment and would arise in the type structure built by tim. A further implicative constraint generated by discoplan refers to the separation of functional roles of objects. In particular, the irre exivity of on, as in: 8x 8y (on(x; y)! :(x = y)) can be captured using this kind of constraint. Tim cannot currently infer these invariants. Because tim uses an analysis based on the state view of objects in the domain it is able to generate a broader collection of invariants, including state membership and unique state invariants currently not produced by discoplan. Although discoplan can deal with negative preconditions and tim cannot yet manage them, the invariants they produce overall are currently less powerful than those inferred by tim. Apart from the work of Gerevini and Schubert, there is some older work on the inference of invariants which also relies on the generation of candidate invariants which are then con rmed by an inductive process against the domain operators. Two examples are the work of Kelleher and Cohn (1992) and Morris and Feldman (1989). The former work concentrates on identifying directed mutual persistence relations, which hold between pairs of facts in a domain when, once both are established, the second continues to hold while the rst does.",
      "startOffset" : 0,
      "endOffset" : 1882
    }, {
      "referenceID" : 6,
      "context" : "Automatic Inference of State Invariants domain objects would allow the techniques described by McCluskey and Porteous (1997) to be automated.",
      "startOffset" : 95,
      "endOffset" : 125
    }, {
      "referenceID" : 6,
      "context" : "Automatic Inference of State Invariants domain objects would allow the techniques described by McCluskey and Porteous (1997) to be automated. McCluskey and Porteous (1997) have proposed and explored an object-centred approach to planning.",
      "startOffset" : 95,
      "endOffset" : 172
    }, {
      "referenceID" : 2,
      "context" : "Grant (1996) generates state invariants from state descriptions, provided by hand, and then uses these invariants to build operator schemas.",
      "startOffset" : 0,
      "endOffset" : 13
    }, {
      "referenceID" : 2,
      "context" : "The results presented by Gerevini and Schubert (1998) suggest that a marked improvement can be obtained from the use of invariants in the performance of planners based on SAT-solving techniques.",
      "startOffset" : 25,
      "endOffset" : 54
    } ],
    "year" : 2011,
    "abstractText" : null,
    "creator" : "dvips 5.58 Copyright 1986, 1994 Radical Eye Software"
  }
}