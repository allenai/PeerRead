{
  "name" : "1402.0558.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Parameterized Complexity Results for Exact Bayesian Network Structure Learning",
    "authors" : [ "Sebastian Ordyniak", "Stefan Szeider" ],
    "emails" : [ "ordyniak@fi.muni.cz", "stefan@szeider.net" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Results: We show that exact Bayesian network structure learning can be carried out in non-uniform polynomial time if the super-structure has bounded treewidth, and in linear time if in addition the super-structure has bounded maximum degree. Furthermore, we show that if the directed super-structure is acyclic, then exact Bayesian network structure learning can be carried out in quadratic time. We complement these positive results with a number of hardness results. We show that both restrictions (treewidth and degree) are essential and cannot be dropped without loosing uniform polynomial time tractability (subject to a complexity-theoretic assumption). Similarly, exact Bayesian network structure learning remains NP-hard for “almost acyclic” directed super-structures. Furthermore, we show that the restrictions remain essential if we do not search for a globally optimal network but aim to improve a given network by means of at most k arc additions, arc deletions, or arc reversals (k-neighborhood local search)."
    }, {
      "heading" : "1. Introduction",
      "text" : "Bayesian Network Structure Learning (BNSL) is the important task of discovering a Bayesian network that represents a given set of training data. Unfortunately, solving the problem optimally (Exact BNSL) is NP-complete (Chickering, 1996). A common and widely used approach to overcome this complexity barrier is to exploit the structure of the problem. This has also been a popular direction for BNSL and two main kinds of structural restrictions have been studied so far, i.e., (1) restrictions on the probability distribution generating the input and (2) restrictions on the resulting Bayesian network. With the help of these restrictions several tractable classes of BNSL have been identified. BNSL is solvable in non-uniform polynomial time if the distribution generating the input has bounded treewidth (Narasimhan & Bilmes, 2004) or bounded degree (Pieter, Daphne, & Andrew, 2006) and it is solvable in (non-uniform) polynomial time if the resulting BN is a branching (Chow & Liu, 1968) or close to being a branching (Gaspers, Koivisto, Liedloff, Ordyniak,\nc©2013 AI Access Foundation. All rights reserved.\n& Szeider, 2012). These positive results are contrasted by a series of negative results for the above mentioned restrictions, e.g., BNSL is known to be NP-hard if the resulting BN is a polytree (Dasgupta, 1999) or a directed path (Meek, 2001). Recently, a novel approach to restrict the structure of BNSL has been introduced (Tsamardinos, Brown, & Aliferis, 2006; Perrier, Imoto, & Miyano, 2008). Here a so-called super-structure, an undirected graph on the same nodes as the resulting BN, is used to restrict the search space of BNSL in advance. After the super-structure has been obtained, usually using an IT-based approach (Tsamardinos et al., 2006), one looks for solution networks whose skeletons are contained in the super-structure. It hence becomes important that the super-structure is sound, i.e., contains at least one optimal solution.\nThere are two main questions concerning the super-structure: First, how can a suitable and sound super-structure be obtained efficiently? And secondly, once such a superstructure is obtained, how can it be used to guide the search for an optimal solution? The goal of this paper is to provide a theoretical analysis of the latter question, considering super-structures that arise from a given local score function adapting the model of Parviainen and Koivisto (2010). We consider various combinations of restrictions in a systematic way that allows us draw a broader picture of the complexity landscape of BNSL. We hope that our analysis can help to understand the boundaries between tractable and intractable cases of this important problem. Furthermore, we think that our results provide new insights that can help the search for more efficient and accurate heuristics. For our analysis, we use the theoretical framework of parameterized complexity (Downey & Fellows, 1999) which seems to be well suited for investigating the complexity of BNSL as it allows to take structural properties (in terms of parameters) into account. To the best of our knowledge parameterized complexity theory has not been employed in this context before."
    }, {
      "heading" : "1.1 Results",
      "text" : "In this section we give a brief overview of our results."
    }, {
      "heading" : "1.1.1 Exact BNSL Using the Super-structure",
      "text" : "In the first part of our paper we study the worst-case complexity of Exact BNSL under graph-theoretic restrictions on the super-structure. One of the most prominent restrictions on the super-structure that we consider is treewidth. Treewidth is an important and widely used parameter that measures the similarity of a graph to a tree (Bodlaender, 1993, 1997, 2005; Greco & Scarcello, 2010). Similarly as for trees, many otherwise intractable problems become tractable on graphs of bounded treewidth. More importantly, treewidth has already been successfully applied in the context of Bayesian Reasoning (Darwiche, 2001; Dechter, 1999; Kwisthout, Bodlaender, & van der Gaag, 2010). It hence seems only natural to apply treewidth to (Exact) BNSL. Our results are as follows:\n(1) Exact BNSL is solvable in non-uniform polynomial time if the treewidth of the superstructure is bounded by an arbitrary constant.\n(2) Exact BNSL is solvable in linear time if both treewidth and maximum degree of the super-structure are bounded by arbitrary constants.\nBy “non-uniform” we mean that the order of the polynomial depends on the treewidth. We obtain results (1) and (2) by means of a dynamic programming algorithm along a decomposition tree of the super-structure. We show that—in a certain sense—both results are optimal:\n(3) Exact BNSL for instances with super-structures of maximum degree 4 (but unbounded treewidth) is not solvable in polynomial time unless P = NP. Thus, in (1) and (2) we cannot drop the bound on the treewidth.\n(4) Exact BNSL for instances with super-structures of bounded treewidth (but unbounded maximum degree) is not solvable in uniform polynomial time unless FPT = W[1]. Thus, in (2) we cannot drop the bound on the degree.\nFPT 6= W[1] is a widely accepted complexity theoretic assumption (Downey & Fellows, 1999) that is often considered as the parameterized analog to P 6= NP. We will provide necessary background on parameterized complexity and fpt-reductions in Section 2.2."
    }, {
      "heading" : "1.1.2 Local Search BNSL Using the Super-structure",
      "text" : "Since learning an optimal Bayesian network is computationally hard heuristic methods are used in practice. A popular heuristic for BNSL is the so-called hill climbing procedure, or local search. In particular, a highly competitive algorithm for learning large Bayesian networks (MMHC) uses local search to find an optimal solution inside a previously constructed super-structure (Tsamardinos et al., 2006). We study the worst case complexity of a wellknown generalization of local search, the k-Neighborhood Local Search (or k-Local Search for short). In this variant of local search one is allowed to modify not one but up to k arcs in every step of the search. Hence by adjusting k, one is able to balance speed and accuracy. However, because the k-local search space is of order nO(k), applying k-local search is especially desirable for problems where the running time does only increase modestly with respect to k. Similarly to result (2) we are able to show the following:\n(5) k-Local Search BNSL is solvable in linear time if both the treewidth and the maximum degree of the super-structure are bounded by arbitrary constants.\nClearly, this result is only of minor interest because we can already solve the Exact BNSL problem under the same restrictions on the super-structure (see result (2)). However, in contrast to the Exact BNSL problem one might be able to drop one of these restrictions without losing uniform polynomial-time tractability. We show that this is again unlikely.\n(6) k-Local Search BNSL for instances with super-structures that have either bounded treewidth or bounded maximum degree is not solvable in uniform polynomial time unless FPT = W[1]."
    }, {
      "heading" : "1.1.3 Exact BNSL Using the Directed Super-structure",
      "text" : "So far, one has only considered the super-structure as an undirected graph. We introduce the directed super-structure as a more expressive way to restrict the search space of solutions, i.e., once the directed super-structure has been fixed we restrict our search to solutions whose\nnetworks are contained in the directed super-structure. Again, we study the complexity of Exact BNSL with respect to certain restrictions on the directed super-structure and obtain the following result.\n(7) Exact BNSL is solvable in quadratic time if the directed super-structure is acyclic.\nThe question arises whether we can extend this result by using a more general form of acyclicity. We show, however, that this is not the case.\n(8) Exact BNSL is NP-hard for directed super-structures that can be made acyclic by deleting one node. Hardness even holds if the maximum in-degree and the maximum out-degree of the directed super-structure are both bounded by 3.\nA systematic overview of our results (1)–(8) is given in Figure 1."
    }, {
      "heading" : "1.2 Related Work",
      "text" : "In this section we present relevant related work on BNSL. Further related work can be found in the respective sections, i.e., we present related work on parameterized complexity in Section 2.2, related work on treewidth and tree decompositions in Sections 2.3 and 3.1, and in Section 7 we present related work on k-neighborhood local search."
    }, {
      "heading" : "1.2.1 Algorithms for Exact BNSL",
      "text" : "To this date only a handful of exact algorithms for BNSL have been proposed. These can be split into three groups: (A) exact algorithms that do not employ any restrictions (Parviainen & Koivisto, 2010; Koivisto, 2006; Yuan, Malone, & Wu, 2011; Ott, Imoto, & Miyano, 2004; Silander & Myllymäki, 2006; Yuan et al., 2011), (B) exact algorithms using restrictions on the generating or target distribution (Pieter et al., 2006; Chechetka & Guestrin, 2007; Friedman, Nachman, & Pe’er, 1999; Chow & Liu, 1968; Gaspers, Koivisto et al., 2012), and (C) exact algorithms that use restrictions on the undirected super-structure (Friedman et al., 1999; Kojima, Perrier, Imoto, & Miyano, 2010). Algorithms falling into group (A) are only suited for small to medium sized Bayesian networks because they do not restrict the search space in any way. On the other hand, the restrictions used by algorithms in group (B) are more general than restrictions coming from the undirected super-structure and up to now only non-uniform polynomial-time algorithms could be obtained using these restrictions. To the best of our knowledge this paper is the first to employ an in-depth theoretical analysis of the parameterized complexity of BNSL using restrictions on the undirected super-structure. We obtain the first algorithm for exact BNSL with a uniform polynomial running-time with respect to structural restriction on the undirected superstructure. A similar approach has been taken by Kojima et al. (2010), where the authors propose an algorithm for exact BNSL that uses a “cluster-decomposition” of the undirected super-structure. Even though their practical results are quite promising the authors provide no theoretical analysis of the worst-case complexity of their algorithm beyond the trivial bound that also applies to exact algorithms in group (A). Apart from exact algorithms there also exists a variety of approximation algorithms using tree decomposition or degree-based techniques (Pieter et al., 2006; Elidan & Gould, 2008; Karger & Srebro, 2001)."
    }, {
      "heading" : "1.2.2 Hardness Results for Exact BNSL",
      "text" : "There are also a number of hardness results for BNSL under restrictions of the resulting Bayesian network. In particular, BNSL remains NP-hard if the in-degree of the resulting Bayesian network is bounded by 2 (Chickering, 1996), and if the resulting Bayesian network is a poly tree (Dasgupta, 1999), or a directed path (Meek, 2001). However, to the best of our knowledge, no negative results for BNSL under restrictions of the (directed) super-structure have been obtained."
    }, {
      "heading" : "1.3 Organization and Prior Work",
      "text" : "This paper is organized as follows: In Section 2 we introduce the basic concepts and notions that we use throughout the paper. We introduce the main object of our study (BNSL) in Section 3. Section 4 shows how to use a dynamic programming algorithm on a tree decomposition in order to show results (1) and (2). We provide a refined complexity analysis of our algorithm in Section 5. In Section 6 we show the complexity boundaries for Exact BNSL using a super-structure, i.e., we obtain results (3) and (4). We introduce k-Local Search BNSL in Section 7 where we establish results (5) and (6). We introduce the directed super-structure in Section 8 and show results (7) and (8). We conclude in Section 9. An appendix contains the proofs of some technical claims.\nA preliminary and shortened version of this paper appeared in the proceedings of UAI 2010. Apart from providing a higher level of detail and readability by giving more examples and detailed proofs, the paper extends its previous version in four ways: by adding a section on related work (Section 1.2), by providing a refined complexity analysis of our main algorithmic result (Section 5), by providing a novel proof of Theorem 6 that allows us to decrease the upper bound on the maximum degree of the super-structure from 5 to 3, and by introducing the directed super-structure (Section 8)."
    }, {
      "heading" : "2. Preliminaries",
      "text" : "In this section we will introduce the basic concepts and notions that we will use throughout the paper."
    }, {
      "heading" : "2.1 Basic Graph Theory",
      "text" : "We will assume that the reader is familiar with basic graph theory (see, e.g., Diestel, 2000; Bang-Jensen & Gutin, 2009). We consider undirected graphs and directed graphs (digraphs). A dag is a directed acyclic graph. We write V (G) = V and E(G) = E for the sets of nodes and edges of a (directed or undirected) graph G = (V,E), respectively. We denote an undirected edge between nodes u and v as {u, v} and a directed edge (or arc), directed from u to v as (u, v). We write NG(v) for the set of neighbors of a node v ∈ V in G, i.e., NG(v) = {u : (v, u) ∈ E or (u, v) ∈ E } if G is directed and NG(v) = {u : {u, v} ∈ E } if G is undirected. For a subset V ′ ⊆ V we write G[V ′] to denote the induced subgraph G′ = (V ′, E′) where E′ = { e ⊆ V ′ : e ∈ E } if G is undirected and E′ = { e ∈ V ′ × V ′ : e ∈ E } if G is directed. If G is a digraph we define PG(v) = {u ∈ V (G) : (u, v) ∈ E(G) } as the set of parents of v in G. Furthermore, for two directed graphs D1 and D2 we define D1∪D2 as the\nunion of D1 and D2, i.e., V (D1∪D2) = V (D1)∪V (D2) and E(D1∪D2) = E(D1)∪E(D2). Let G be a (directed or undirected) graph and e ∈ E(G) a directed or undirected edge in G. We denote by G− e the (undirected or directed) graph, where G− e = (V (G), E(G) \\ {e}). Furthermore, for a subset X ⊆ V (G) we denote by G−X the graph induced by the nodes in V \\X. If X contains only one node v we also write G − v instead of G − {v}. We call an undirected graph G′ = (V ′, E′) the skeleton of a directed graph G if V ′ = V (G) and E′ = { {u, v} : (u, v) ∈ E(G) }."
    }, {
      "heading" : "2.2 Parameterized Complexity",
      "text" : "Parameterized complexity provides a theoretical framework to distinguish between uniform and non-uniform polynomial-time tractability with respect to a parameter. It has been introduced and pioneered by Downey and Fellows (1999) and is receiving growing interest as reflected by the recent publication of two further monographs (Flum & Grohe, 2006; Niedermeier, 2006) and hundreds of research papers (see references in the above mentioned monographs). In 2008 the Computer Journal has devoted two special issues on parameterized complexity in order to make the key methods and ideas known to a wide range of computer scientists (Downey, Fellows, & Langston, 2008).\nAn instance of a parameterized problem is a pair (I, k) where I is the main part and k is the parameter ; the latter is usually a non-negative integer. A parameterized problem is fixed-parameter tractable if there exist a computable function f and a constant c such that instances (I, k) of size n can be solved in time O(f(k)nc). FPT is the class of all fixed-parameter tractable decision problems. Fixed-parameter tractable problems are also called uniform polynomial-time tractable because if k is considered constant, then instances with parameter k can be solved in polynomial time where the order of the polynomial is independent of k (in contrast to non-uniform polynomial-time running times such as nk).\nParameterized complexity offers a completeness theory similar to the theory of NPcompleteness. One uses fpt-reductions which are many-one reductions where the parameter for one problem maps into the parameter for the other. More specifically, problem L reduces to problem L′ if there is a mapping R from instances of L to instances of L′ such that (i) (I, k) is a yes-instance of L if and only if (I ′, k′) = R(I, k) is a yes-instance of L′, (ii) k′ ≤ g(k) for a computable function g, and (iii) R can be computed in time O(f(k)nc) where f is a computable function, c is a constant, and n denotes the size of (I, k). The parameterized complexity class W[1] is considered as the parameterized analog to NP. In particular, FPT = W[1] implies the (unlikely) existence of a 2o(n) algorithm for n-variable 3SAT (Impagliazzo, Paturi, & Zane, 2001; Flum & Grohe, 2006). An example, for a parameterized problem that is W[1]-complete under fpt-reductions is the parameterized Maximum Clique problem (given a graph G and a parameter k ≥ 0, does G contain a complete subgraph on k nodes?). Note that there exists a trivial non-uniform polynomialtime nk algorithm for the Maximum Clique problems that checks all sets of k nodes."
    }, {
      "heading" : "2.3 Tree Decompositions",
      "text" : "Treewidth is an important graph parameter that indicates in a certain sense the “treelikeness” of an undirected graph (Bodlaender, 1993, 1997, 2005). On graphs of treewidth bounded by a constant many otherwise intractable problems become tractable. Bucket\nElimination (Dechter, 1999) and Recursive Conditioning (Darwiche, 2001) are two important algorithmic concepts that apply to instances of bounded treewidth.\nThe treewidth of a graph G = (V,E) is defined via the following notion of decomposition: a tree decomposition of G is a pair (T, χ) where T is a tree and χ is a labeling function with χ(t) ⊆ V for every tree node t such that the following conditions hold:\n1. Every node of G occurs in χ(t) for some tree node t.\n2. For every edge {u, v} of G there is a tree node t such that u, v ∈ χ(t).\n3. For every node v of G, let Tv be the subgraph of T induced by all nodes t such that v ∈ χ(t). Then Tv is a (connected) subtree of T (“Connectedness Condition”).\nThe width of a tree decomposition (T, χ) is the size of a largest set χ(t) minus 1 among all nodes t of T . A tree decomposition of smallest width is optimal. The treewidth of a graph G, denoted tw(G), is the width of an optimal tree decomposition of G. It is known that if (T, χ) is a tree decomposition of a graph G, then every clique of G is contained in χ(t) for some tree node t ∈ V (T ) (Kloks, 1994, Lemma 2.2.2).\nThe following proposition will be useful to retrieve an upper bound on the treewidth of a graph.\nProposition 1. Let G be an undirected graph and X ⊆ V (G). If the graph G−X contains no edge, i.e., all the nodes in G−X are isolated, then tw(G) ≤ |X|.\nProof. Let V (G) \\ X contain the nodes v1, . . . , vn and let T be the tree with node set {t, t1, . . . , tn} and edge set { {t, ti} : 1 ≤ i ≤ n }. Then T together with the function χ such that χ(t) = X and χ(ti) = X ∪ {vi} for every 1 ≤ i ≤ n is a tree decomposition for G of width |X|.\nThe main property of tree decompositions that allows for efficient bottom-up dynamic programming algorithms for a wide spectrum of otherwise intractable problems is its wellknown separation property which is made precise in the following proposition.\nProposition 2. Let G be a graph, (T, χ) a tree decomposition for G, {t′, t′′} be an edge in T , and let T ′ and T ′′ be the subtrees of T obtained from T after deleting the edge {t′, t′′} such that T ′ contains t′ and T ′′ contains t′′. Furthermore, define S = χ(t′) ∩ χ(t′′), A =⋃ t∈V (T ′) χ(t) and B = ⋃ t∈V (T ′′) χ(t). Then the following two statements hold:\n1. A ∩B = S;\n2. S separates the nodes in A from the nodes in B, i.e., there is no edge between a node in A \\ S and a node in B \\ S.\nProof. The first statement follows immediately from Property (3) of a tree decomposition, since the subtree containing a node v ∈ (A∩B) has to make use of the edge {t′, t′′} in order to be connected and hence v has to be contained in S.\nTo see the second statement, suppose for a contradiction that there is an edge between a node a ∈ A \\S and a node b ∈ B \\S. It follows from the first statement of this proposition that Ta and Tb are disjoint, i.e.,otherwise either a ∈ S or b ∈ S. But this contradicts property (2) of a tree decomposition since {a, b} is an edge of G.\nGiven a graph G with n nodes and a constant w, it is possible to decide whether G has treewidth at most w, and if so, to compute an optimal tree decomposition of G in time O(n) (Bodlaender, 1996). Furthermore there exist powerful heuristics to compute tree decompositions of small width in a practically feasible way (Koster, Bodlaender, & van Hoesel, 2001; Gogate & Dechter, 2004; Dow & Korf, 2007). Recently, new randomized heuristics have been studied in the context of Bayesian reasoning (Kask, Gelfand, Otten, & Dechter, 2011; Gelfand, Kask, & Dechter, 2011)."
    }, {
      "heading" : "3. Bayesian Network Structure Learning",
      "text" : "In this section we define the theoretical framework for BNSL that we shall use for our considerations. We closely follow the abstract framework used by Parviainen and Koivisto (2010) which encloses a wide range of score-based approaches to structure learning. We assume that the input data specifies a set N of nodes (representing random variables) and a local score function f that assigns to each v ∈ N and each subset P ⊆ N \\ {v} a nonnegative real number f(v, P ). Given the local score function f and a set N of nodes, the problem is to find a dag D on N such that the score of D under f\nf(D) := ∑ v∈N f(v,PD(v))\nis as large as possible (the dag D together with certain local probability distributions forms a Bayesian network). This setting accommodates several popular scores like BDe, BIC and AIC (Parviainen & Koivisto, 2010; Chickering, 1995).\nWe consider the following decision problem:\nExact Bayesian Network Structure Learning\nInput: A local score function f defined on a set N of nodes, a real number s > 0. Question: Is there a dag D on N such that f(D) ≥ s?\nFor the following complexity results we need to fix how the score function is represented in the problem input. We cannot list the values f(v, P ) for all nodes v ∈ N and all subsets P ⊆ N \\{v}, as this requires Ω(2|N |) space. Therefore, we assume that f(v, P ) is only given if it is different from 0; we call this the non-zero representation. This representation is also used in other fields, for instance in constraint satisfaction, where only allowed tuples of constraints are listed in the input (Tsang, 1993). An alternative representation of the score function would be to list in the input all values f(v, P ) where |P | ≤ c for some constant c. Let us call this the arity-c representation. This representation requires only polynomial space if every node has at most c parents, for a small constant c, which is a reasonable assumption. Given an arity-c representation of a score function, we can clearly compute in linear time the corresponding non-zero representation. Hence the non-zero representation is more general, and therefore we will base our complexity results on this encoding. All tractability results also carry over to the arity-c representation.\nThe size of f (given in the non-zero representation) is the number of bits needed to represent the tuples with f(v, P ) > 0 in a reasonable data structure, e.g., as a list of these\ntuples where each tuple stores the node, the set of parents, and the value of the score function. Clearly, the size of f exceeds the total number of all such tuples. We define Pf (v) := {P ⊆ N : f(v, P ) > 0} ∪ {∅} to be the set of all potential parent sets of v. We also define\nδf := max v∈N |Pf (v)|;\nwhich will be an important measurement for our worst-case analysis of running times. In particular, the above assumption on how f is represented implies the following:\n(*) Let I = (N, f, s) be an instance of Exact Bayesian Network Structure Learning. Then δf is bounded by the size of f .\nLet f be a local score function defined on a set N of nodes. The directed super-structure of f is the directed graph S→f = (N,Ef ) where Ef contains an arc (u, v) if and only if u is a potential parent of v, i.e., if u ∈ P for some P ∈ Pf (v). The (undirected) super-structure of f , denoted Sf = (N,Ef ), is the skeleton of the directed super-structure.\nExample 1. Figure 2 shows an example for a local-score function f defined on the set N = {a, b, c, d, e, f, g} of nodes. The function f is given as a table containing all tuples (v, P, f(v, P )) with v ∈ N and P ⊆ N \\ {v} such that f(v, P ) > 0. Note that since f is non-negative it holds that f(v, P ) = 0 for all the remaining pairs (v, P ), i.e., the pairs that are not contained in the table. The figure also shows the directed super-structure S→f and the unique super-structure Sf of f .\nWe say that a dag D on a set N of nodes is admissible for f if the skeleton of D is a subgraph of the super-structure Sf . Furthermore, we say that a dag D on N is strictly admissible for f if for every node v ∈ N we have PD(v) ∈ Pf (v). Note that every strictly admissible dag is also admissible. Furthermore, there always exists a (strictly) admissible dag with the highest score as shown by the following lemma.\nLemma 1. Let f be a local score function defined on a set N of nodes and let D be a dag on N . Then there is a strictly admissible dag D′ on N with the same score as D.\nProof. If D is not (strictly) admissible, i.e., if there is a v ∈ N such that f(v,PD(v)) = 0, we can delete all arcs (w, v) such that w ∈ PD(v). This does not decrease the score since f(v, ∅) ≥ f(v,PD(v)) = 0 for every such a v.\nExample 2. Figure 3 shows four examples of dags on the the nodes a, b, c, d, e, f, g. Using the local-score function f as defined in Example 1, we make the following observations:\na) Da is not admissible, because the super-structure Sf does not contain the edge {c, b}. The score for Da is f(Da) = 4.\nb) Db is admissible but not strictly admissible, because the node a has parents c and d but f(a, {c, d}) = 0. The score for Db is f(Db) = 5.\nc) Dc is the strictly admissible dag obtained from Db as described in the proof of Lemma 1. We have f(Dc) = f(Db) = 5.\nd) Dd is strictly admissible and is also an optimal dag for f . The score for Dd is f(Dd) = 7."
    }, {
      "heading" : "3.1 Tree Decompositions",
      "text" : "When presenting algorithms for graphs of bounded treewidth it is convenient to consider tree decompositions in the following normal form (Kloks, 1994): A triple (T, χ, r) is a nice tree decomposition of a graph G if (T, χ) is a tree decomposition of G, the tree T is rooted at node r, and each node of T is of one of the following four types:\n1. a leaf node: a node having no children;\n2. a join node: a node t having exactly two children t1, t2, and χ(t) = χ(t1) = χ(t2);\n3. an introduce node: a node t having exactly one child t′, and χ(t) = χ(t′) ∪ {v} for a node v of G;\n4. a forget node: a node t having exactly one child t′, and χ(t) = χ(t′) \\ {v} for a node v of G.\nFor convenience we will also assume that χ(r) = ∅ for the root r of T . This can always be achieved by adding forget nodes on top of the root (see Figure 4 for an example). For a nice tree decomposition (T, χ, r) we define χ∗(t) to be the union of all the sets χ(t′) where t′ is contained in the subtree of T rooted at t. Furthermore, we denote by Ft the set of nodes that have already been “forgotten” at node t, i.e.,\nFt = χ ∗(t) \\ χ(t).\nAs stated in Section 2.3 one of the main properties of tree decompositions that allows for efficient algorithms is the well-known separator property made precise in Proposition 2. The following propositions provide different versions of this separator property of tree decompositions for each of the node types of a nice tree decomposition. Because these propositions are well-known (Kloks, 1994) and are immediate consequences of the separator property of tree decompositions we state them without proofs. The propositions summarize the algorithmic properties of nice tree decompositions that we will use for the design of our algorithm in Section 4.\nProposition 3. Let t be a join node with children t1 and t2. Then Ft1 ∩ Ft2 = ∅ and there is no edge between a node u ∈ Ft1 and a node v ∈ Ft2 in G. Proposition 4. Let t be an introduce node with child t′ such that χ(t) = χ(t′)∪{v0}. Then there is no edge from v0 to a node v ∈ Ft in G. Furthermore, v0 /∈ Ft′.\nProposition 5. Let t be a forget node with child t′ such that χ(t) = χ(t′) \\ {v0}. Then there is no edge from v0 to a node v ∈ V (G) \\ χ∗(t) in G.\nGiven a tree decomposition of a graph G of width w, one can effectively obtain in time O(|V (G)|) a nice tree decomposition of G with O(|V (G)|) nodes and of width at most w (Kloks, 1994).\nExample 3. Figure 4 shows a tree decomposition and a corresponding nice tree decomposition of the super-structure of Example 1."
    }, {
      "heading" : "4. A Dynamic Programming Algorithm for Exact Bayesian Network",
      "text" : "Structure Learning\nIn this section we present the dynamic programming algorithm and establish our tractability results. For the remainder of this section w denotes an arbitrary but fixed constant. Recall from the previous section that δf is the maximum number of potential parent sets of a node.\nTheorem 1. Given a set N of nodes and a local score function f on N whose superstructure Sf = (N,Ef ) has treewidth bounded by an arbitrary constant w. Then we can find in time O(δ 2(w+1) f · |N |) a dag D on N with maximal score f(D).\nBefore we devise an algorithm to show Theorem 1 we state and prove a direct consequence of the theorem.\nCorollary 1. Exact Bayesian Network Structure Learning can be decided in polynomial time for instances where the super-structure has bounded treewidth. The problem can be decided in linear time if additionally the super-structure has bounded maximum degree.\nProof. The first statement follows immediately from the theorem since δf is bounded by the total input size of the instance and w is a constant. Recall from Section 3 that the local score function f is given as the list of all tuples for which f is non-zero and hence δf is bounded by the total input size of the instance. The second statement follows since δf is bounded whenever the maximum degree d of the super-structure is bounded as clearly δf ≤ 2d.\nIn the following we will assume that we are given a set of nodes N and a local score function f on N together with a nice tree decomposition (T, χ, r) for Sf of width at most w. We are going to establish Theorem 1 by means of a dynamic programming algorithm along a nice tree decomposition for Sf , computing local information at the nodes of the tree decomposition that can then be put together to form an optimal dag. Our algorithm closely follows the general approach used by algorithms on graphs (or structures) of bounded treewidth (Bodlaender & Koster, 2008).\nA partial solution for a tree node t ∈ V (T ) is a dag that can be obtained as the induced subdigraph D[χ∗(t)] of a strictly admissible dag D for f . For a tree node t let D(t) denote the set of all partial solutions for t. For a partial solution D ∈ D(t) we set\nft(D) = ∑ v∈Ft f(v,PD(v)),\ni.e., ft(D) is the sum of the scores of the nodes in Ft. Recall from the previous section that Ft is the set of forgotten nodes at t.\nThe main idea underlying our algorithm is to reduce the space required to store a partial solution with the help of a so-called record. This becomes possible because of the properties of a tree decomposition manifested by Propositions 3, 4 and 5.\nA record of a tree node t ∈ V (T ) is a triple R = (a, p, s) such that:\n1. a is a mapping χ(t)→ Pf (v), i.e., for every v ∈ χ(t) we have a(v) ∈ Pf (v);\n2. p is a transitive binary relation on χ(t);\n3. s is a non-negative real number.\nInformally, for a tree node t ∈ V (T ) and a record R = (a, p, s), the mapping a fixes the parent set of every node in χ(t), p is a compact representation of the reachability relation between the nodes in χ(t) (using directed paths between nodes in χ∗(t)), and s is the sum of the scores of the nodes that have been forgotten for t, i.e., the nodes in Ft.\nWe say that a record represents a partial solution D ∈ D(t) if it satisfies the following conditions:\n1. a(v) ∩ V (D) = PD(v) for every v ∈ χ(t).\n2. For every pair of nodes v1, v2 ∈ χ(t) it holds that (v1, v2) ∈ p if and only if D contains a directed path from v1 to v2.\nWe say that a record R = (a, p, s) of a tree node t ∈ V (T ) is valid if it represents some dag D ∈ D(t) and s is the maximum score ft(D) over all dags in D(t) represented by R. We say a partial solution D that is represented by R is maximal with respect to R if R is valid and ft(D) = s. With each tree node t ∈ V (T ) we associate the set R(t) of all valid records representing partial solutions in D(t).\nIn a certain sense, R(t) is a succinct representation of the optimal elements of D(t), using space that only depends on w and δf , but not on |N |.\nExample 4. Figure 5 shows two partial solutions Da and Db for the node t of the nice tree decomposition Example 3. Da and Db are represented by all records R = (a, p, s) with\na(b) = {a, f}, a(c) = {e}, a(d) = ∅ and p = {(b, c), (d, b), (d, c)}. We have ft(Da) = 3 > ft(Db) = 2 and it is easy to see that 3 is the maximum score over all partial solutions represented by R. Hence the record R = (a, p, 3) is a valid record for t and Da is maximal with respect to R, thus R ∈ R(t).\nOur dynamic programming algorithm computes the set of all valid records in a bottom up manner, i.e., starting from the leave nodes of the nice tree decomposition the algorithm proceeds to the root node. The next three lemmas show how to compute the set of all valid records for the introduce, forget and join nodes of the nice tree decomposition from the valid records of its children. Informally, if t is an introduce node with child t′ such that χ(t) = χ(t′) ∪ {v0} then we compute the set R(t) of all valid records for t by checking for each potential parent set P ∈ P(v0) for v0 and each valid record R ∈ R(t′) for t′ whether the combination of P and R constitutes a valid record for t.\nLemma 2 (introduce node). Let t be an introduce node with child t′. Then R(t) can be computed from R(t′) in time O(δw+1f ).\nProof. In the following we denote by v0 the node introduced by t, i.e., χ(t) = χ(t ′) ∪ {v0}. We are going to establish the lemma with the help of the following claim whose proof can be found in the appendix.\nClaim 1. R(t) is the set of all records R = (a, p, s) such that there is a set P ∈ Pf (v0) and a record R′ = (a′, p′, s′) ∈ R(t′) with:\n1. a(v0) = P .\n2. For every v ∈ χ(t′) it holds that a(v) = a′(v).\n3. s = s′.\n4. p is the transitive closure of the relation p′ ∪ { (u, v0) : u ∈ P } ∪ { (v0, u) : u ∈ χ(t′) such that v0 ∈ a′(u) }.\n5. p is irreflexive.\nIt follows that R(t) can be computed by checking for every pair (P,R′), with P ∈ Pf (v0) and R′ ∈ R(t′), whether it satisfies the conditions (1)–(5). Since there are at most δf possible sets P and at most O(δwf ) possible valid records for t\n′ (observe that |χ(t′)| ≤ w) the lemma follows from the fact that for every pair (P ,R′) the conditions can be checked in time that only depends on w.\nInformally, if t is a forget node with child t′ such that χ(t) = χ(t′)\\{v0} then we compute the set R(t) of all valid records for t by “projecting” the set R(t′) of valid records for t′ to χ(t).\nLemma 3 (forget node). Let t be a forget node with child t′. Then R(t) can be computed from R(t′) in time O(δw+1f ).\nProof. In the following we denote by v0 the forgotten node, i.e. χ(t) = χ(t ′) \\ {v0}. We will show that R(t) can be obtained as the “projection” of R(t′) to χ(t). Before doing so we need some additional notation. Let R′ = (a′, p′, s′) ∈ R(t′). We define the projection of R′ to t, denoted R′[t] as the record R = (a, p, s) such that:\n1. a is the restriction of a′ to χ(t).\n2. p = { (v, w) ∈ p′ : v, w ∈ χ(t) }.\n3. s = s′ + f(v0, a ′(v0)).\nFurthermore, we define the projection of R(t′) to t, denoted R(t′)[t], as the set of all records R′[t] for R′ ∈ R(t′). We say that a record R = (a, p, s) ∈ R(t′)[t] is maximal if there is no s′ with s′ > s such that (a, p, s′) ∈ R(t′)[t].\nAgain, we are going to establish the lemma with the help of the following claim whose proof can be found in the appendix.\nClaim 2. R(t) is the set of all maximal records in R(t′)[t].\nSince R(t′) contains at most O(δw+1f ) records it is easy to see that R(t) can be computed in time O(δw+1f ).\nInformally, if t is a join node with children t1 and t2 then we compute the set R(t) of all valid records for t by checking for each record R1 ∈ R(t1) and each record R2 ∈ R(t2) whether the combination of R1 and R2 constitutes a valid record for t.\nLemma 4 (join node). Let t1, t2 be the children of t in T . Then R(t) can be computed from R(t1) and R(t2) in time O(δ2(w+1)f ).\nProof. We are going to establish the lemma with the help of the following claim (the rather technical proof of this claim can be found in the appendix).\nClaim 3. R(t) is the set of all records R = (a, p, s) such that there are records R1 = (a1, p1, s1) ∈ R(t1) and R2 = (a2, p2, s2) ∈ R(t2) with:\n1. a = a1 = a2.\n2. s = s1 + s2.\n3. p is the transitive closure of p1 ∪ p2.\n4. p is irreflexive, i.e., there is no v ∈ χ(t) such that (v, v) ∈ p.\nIt follows that R(t) can be computed by considering all pairs of records R1 ∈ R(t1) and R2 ∈ R(t2) and checking conditions (1)–(4). Since there are at most O(δw+1f ) valid records for every t ∈ V (T ) and for every such pair of records the time required to check the conditions (1)–(4) does only depend on w, it follows that the running time of this procedure is at most O(δ 2(w+1) f ).\nWe are now ready to establish Theorem 1.\nProof of Theorem 1. Let N be a set of nodes, f a local score function on N where the super-structure Sf has treewidth w (a constant) and |N | = n. We compute a nice tree decomposition (T, χ, r) of Sf of width w and with O(n) nodes. This can be accomplished in time O(n) (see the discussion in Section 2.3).\nNext we compute the sets R(t) via a bottom-up traversal of T . For a leaf node t we can compute R(t) just by considering all strictly admissible dags on the at most w + 1 nodes in χ(t). This can clearly be done in time O(δw+1f ) and we can then use Lemmas 4, 2 and 3 to compute the sets R(t) for all other O(n) tree nodes in time O(δ2(w+1)f · n). Since χ(r) = ∅, the partial solutions for the root r of T are exactly the strictly admissible dags for f , and we have fr(D) = f(D) for each such dag D. After the computation of the sets R(t) for all tree nodes t, the set R(r) contains exactly one record R = (∅, ∅, s). By the above considerations, it follows that s is the largest score of all strictly admissible dags for f , and, as noted in Section 3, this is also the largest score of any dag whose nodes belong to N . It is now easy to compute a dag D with score f(D) = s via a top-down traversal of T starting from r and using the information previously stored at each node in T . This can also be accomplished in time O(δ 2(w+1) f · n).\nWe close this section with a remark concerning the relationship between the treewidth of a Bayesian network and the treewidth of its super-structure. For Bayesian reasoning one usually associates with the dag D of a Bayesian network its moral graph M(D) which is the skeleton of D plus edges joining nodes that have a common child in D. The treewidth of a Bayesian network is the treewidth of its moral graph (Darwiche, 2001; Dechter, 1999). We observe that for every Bayesian network of bounded treewidth there is a super-structure of bounded treewidth that contains the Bayesian network. Hence, such a Bayesian network can be learned considering only super-structures of bounded treewidth. On the other hand if a Bayesian network is contained in a super-structure of bounded treewidth then the Bayesian network has bounded treewidth under the reasonable assumption that each of its nodes has a bounded number of parents. Consequently, if a Bayesian network is learned from a super-structure of bounded treewidth it is reasonable to assume that the Bayesian network has bounded treewidth as well."
    }, {
      "heading" : "5. Refined Complexity Analysis",
      "text" : "When presenting our algorithm in Section 4 we focused on a broad evaluation of its complexity. In this Section we provide a more fine-grained analysis of its running time.\nIn the following we assume that N is a set of nodes, f is a local score function on N , and (T, χ, r) is a nice tree decomposition of Sf of width at most w. We can improve on the running time of our algorithm by using the following five ideas.\nI1 By keeping the records for each node in the tree decomposition in some fixed order we\ncan improve the time needed at a join node of the tree decomposition from O(δ 2(w+1) f ) to O(δw+1f ) without any additional cost for sorting. We achieve this by generating new records in an ordered manner and keeping track of that order when the records are stored.\nI2 Parent sets that are supersets of parent sets with a higher score can be disregarded (de Campos, Zeng, & Ji, 2009). This simple preprocessing rule usually allows us to consider fewer than the potentially 2d potential parent sets. In the sequel we will denote the preprocessed score function by f ′. Clearly, |Pf (v)| ≤ |Pf ′(v)| for every v ∈ N .\nI3 If the maximum in-degree of the resulting BN is bounded in advance one can use this fact to further preprocess the score function in the natural way. In the following we denote the resulting score function by f ′′. Clearly, |Pf ′′(v)| ≤ |Pf ′(v)| for every v ∈ N .\nI4 Every node of the network might have a different number of potential parent sets. Consequently, instead of using one upper bound for the number δf ′′ of potential parent sets it is more realistic to consider the actual number |Pf ′′(v)| of potential parent sets for each node v ∈ N .\nI5 Only valid records need to be stored by our algorithm, i.e., records that represent acyclic networks.\nConsidering the ideas I1–I4 the worst-case complexity of our algorithm can be refined as follows: ∑\nt∈V (T ) O(w2 · ∏ v∈χ(t) |Pf ′′(v)|)\nObserve that w2 · ∏ v∈χ(t) |Pf ′′(v)| is the number of potential records for the tree node t. Because of idea I5 in general not all of these records need to be stored by our algorithm. This refined analysis suggests that the running time of our algorithm is dominated by the maximum number of records that need to be stored for a tree node t ∈ V (T )."
    }, {
      "heading" : "6. Hardness Results for Exact Bayesian Network Structure Learning",
      "text" : "The following result follows by a reduction due to Chickering (1996).\nTheorem 2. Exact Bayesian Network Structure Learning is NP-hard for instances with super-structures of maximum degree 4.\nProof. Since we use a well-known reduction from Chickering, we will only sketch the argument. The reduction is from Feedback Arc Set (FAS). The problem asks whether a digraph D = (V,E) can be made acyclic by deleting at most k arcs (the deleted arcs form a feedback arc set of D). The problem is NP-hard for digraphs with skeletons of maximum degree 4 (Karp, 1972). Given an instance (D, k) of FAS, where the skeleton of D has maximum degree 4, we construct a set V ′ = V (D)∪E(D) of nodes and a local score function f on V ′ by setting f((u, v), {u}) = 1 for all (u, v) ∈ E(D), f(v, { (u, v) : u ∈ PD(v) }) = |PD(v)| for all v ∈ V (D), and f(v, P ) = 0 in all other cases. Clearly, the super-structure Sf (recall the definition of Sf in Section 3) is isomorphic to the undirected graph obtained from the skeleton of D after subdividing every edge once, hence the maximum degree of Sf is at most the maximum degree of D which is 4. It is easy to see that D has a feedback arc set of size ≤ k if and only if there exists a dag D′ whose skeleton is a spanning subgraph of Sf with f(D′) ≥ 2 · |E| − k.\nTheorem 3. Exact Bayesian Network Structure Learning parameterized by the treewidth of the super-structure is W[1]-hard.\nProof. We devise an fpt-reduction from the following problem, which is well-known to be W[1]-complete (Pietrzak, 2003).\nPartitioned Clique\nInput: A k-partite graph G = (V,E) with partition V1, . . . , Vk such that |Vi| = |Vj | = n for 1 ≤ i < j ≤ k. Parameter: The integer k. Question: Are there nodes v1, . . . , vk such that vi ∈ Vi for 1 ≤ i ≤ k\nand {vi, vj} ∈ E for 1 ≤ i < j ≤ k? (The graph K = ({v1, . . . , vk}, { {vi, vj} : 1 ≤ i < j ≤ k }) is a k-clique of G.)\nLet G = (V,E) be an instance of this problem with partition V1, . . . , Vk, |V1| = · · · = |Vk| = n and parameter k. Informally, we encode the given instance of Partitioned Clique as an instance (N, f, s) of Exact Bayesian Structure Learning such that G has a k-clique if and only if there is a Bayesian network D with f(D) ≥ s. To achieve this we introduce a node nv for every node v of G and one node aij for every 1 ≤ i 6= j ≤ k. Then a node that corresponds to a node in Vi achieves its maximum score for the parent set that contains all nodes aij for 1 ≤ j ≤ k. A node aij achieves its maximum score if its parent set corresponds to an edge of G between a node in Vi and a node in Vj . Hence, the edges of G are encoded in the local score function of the nodes aij for 1 ≤ i 6= j ≤ k. By choosing the proper scores for these nodes and the right threshold s we can assure that in any Bayesian network whose score is higher than s every node aij has to attain its maximum score, and all but at most k nodes that correspond to nodes of G do not achieve their maximum score. It follows that the parent sets chosen for the nodes aij correspond to the edges of a k-clique of G.\nIn order to make later calculations easier we will assume that k > 2 for the remainder of this proof. Let α = k2 − k − 1, ε = 2k and s = nkα+ 1. We construct a set N of nodes and a local score function f on N satisfying the following claims.\nClaim 4. tw(Sf ) ≤ k(k − 1)/2\nClaim 5. G has a k-clique if and only if there is a dag D such that f(D) ≥ s.\nWe will have shown the theorem after establishing the two claims. We set A = { aij : 1 ≤ i < j ≤ k }, N = V (G) ∪ A, and Ai = { alk ∈ A : l = i or k = i } for every 1 ≤ i ≤ k. We are now ready to define f . We set f(v,Ai) = α for every v ∈ Vi, and f(aij , {u,w}) = ε for every 1 ≤ i < j ≤ k, u ∈ Vi, w ∈ Vj , and {u,w} ∈ E(G). Furthermore, we set f(v, P ) = 0 for all the remaining combinations of v and P . See Figure 6 for an illustration. Now, Claim 4 follows from Proposition 1 with X = A. Hence, it remains to show Claim 5.\nBefore we go on to show Claim 5 we give some further notation and explanation. Let E′ ⊆ E(G). We denote by V (E′) the set of all nodes incident to edges in E′, i.e., the set ⋃ e∈E′ e. We say that E\n′ is representable if for every 1 ≤ i < j ≤ k it contains at most one edge between a node in Vi and a node in Vj . We define eij(E\n′) = {vi, vj} if E′ contains the edge between vi ∈ Vi and vj ∈ Vj and eij = ∅ otherwise. We define D(E′) to\nbe the directed graph with node set N and arc set { (v, aij) : v ∈ eij(E′) and 1 ≤ i < j ≤ k } ∪ { (aij , v) : v /∈ eij(E′) and 1 ≤ i < j ≤ k }. Figure 7 shows D(E′) for a representable edge set of the example graph G from Figure 6.\nThe main idea to show Claim 5 is that f(D) ≥ s if and only if D has the form D(E′) for a representable edge set E′ that corresponds to a k-clique in G. This is formally expressed by the following claim whose proof can be found in the appendix.\nClaim 6. The following statements are equivalent:\n1. G has a k-clique.\n2. There is a dag D with f(D) ≥ s.\n3. There is a representable edge set E′ ⊆ E(G) such that f(D(E′)) ≥ s.\nNote that in contrast to Theorem 2, it is essential for Theorem 3 that the super-structure has unbounded degree: if both degree and treewidth are bounded then the problem is fixed-parameter tractable by Corollary 1 and so unlikely to be W[1]-hard.\n7. k-Neighborhood Local Search\nImportant and widely used algorithms for BNSL are based on local search methods (Heckerman, Geiger, & Chickering, 1995). Usually the local search algorithm tries to improve the score of a given dag by transforming it into a new dag by adding, deleting, or reversing one arc at a time (in symbols: add, del, and rev, respectively). The main obstacle for local search methods is the danger of getting stuck at a poor local optimum. A possibility for decreasing this danger is to perform k > 1 elementary changes in one step, known as kNeighborhood Local Search or k-Local Search for short. For BNSL, when we try to improve the score of a dag on n nodes, the k-local search space is of order nO(k). Therefore, if carried out by brute-force, k-local search is too costly even for small values of k. It is therefore not surprising that most practical local search algorithms for BNSL consider 1-neighborhoods only.\nThe study of the parameterized complexity of k-local search was initiated by Fellows (2003). To date a collection of positive and negative results on the parameterized complexity of k-local search for various combinatorial optimization problems are known. For instance, k-local search has already been investigated for combinatorial problems on graphs (Khuller, Bhatia, & Pless, 2003; Marx, 2008; Fellows, Rosamond, Fomin, Lokshtanov, Saurabh, & Villanger, 2009; Gaspers, Kim, Ordyniak, Saurabh, & Szeider, 2012), for the problem of finding a minimum weight assignment for a Boolean constraint satisfaction instance (Krokhin & Marx, 2012), for the stable marriage problem with ties (Marx & Schlotter, 2011), and for the satisfiability problem (Szeider, 2011).\nIn this section we show that k-local search for BNSL can be solved in linear time if the super-structure has bounded treewidth and bounded maximum degree. This result is in good agreement with Theorem 1. However, in contrast to Exact BNSL it might still be possible to drop one of these restrictions without losing uniform polynomial-time tractability, but we show that this is not the case. We also investigate k-Local Search BNSL for different combinations of allowed operations such as reversal, addition and deletion of an arc. Our results are mostly negative. In fact, somewhat surprisingly, k-Local Search BNSL remains hard even if edge reversal is the only allowed operation.\nBefore we state and show our results we define k-Local Search BNSL more formally. Let k ≥ 0 and O ⊆ {add,del,rev}. Consider a dag D = (V,E). A directed graph D′ = (V ′, E′) is a k-O-neighbor of D if\n1. D′ is a dag,\n2. V = V ′,\n3. E′ can be obtained from E by performing at most k operations from the set O.\nFor O ⊆ {add, del, rev} we consider the following parameterized decision problem.\nk-O-Local Search Bayesian Network Structure Learning Input: A local score function f , a dag D that is admissible for f , and\nan integer k. Question: Is there a k-O-neighbor D′ of D with a higher score than D?\nNote that the problem does not change if we require D′ to be admissible, as we can always avoid the addition of an inadmissible arc.\nExample 5. Figure 8 shows two dags D and D′ such that D′ can be obtained from D by either reversing or by deleting and adding the reverse of the bold arcs in D. It follows that D′ is a 3-{rev}-neighbor and a 6-{add,del}-neighbor of D. The directed graph obtained from D after only reversing the arc (a, d) contains a cycle (on the nodes {a, b, f, d}) but D′ does not. The score of D′ is larger than the score of D, since f(D) = 3 and f(D′) = 7 (using the score function f as depicted in Figure 2).\nProposition 6. k-Local Search Bayesian Network Structure Learning can be decided in linear time for instances where the super-structure has bounded treewidth and bounded maximum degree.\nProof. As the proof uses the same arguments as the proof of Theorem 1 we only sketch the proof of this proposition.\nIn the following we will assume that we are given an instance I = (D, f, k) of k-OLocal Search Bayesian Network Structure Learning together with a nice tree decomposition (T, χ, r) for Sf of width at most w and let d be the maximum degree of Sf . As before we assume that w and d are constants. For a set S we denote by [S] the set of all subsets of S.\nThe main difference to the proof of Theorem 1 is that we are now only interested in solutions which are k-O-neighbors of D. To take this into account we need to slightly extend the concept of a record for a tree node t ∈ V (T ). We include an integer c to reflect the “cost” of a partial solution that is the smallest number of operations from O needed to obtain D. For technical reasons we also include a mapping b that assigns the set of forgotten children to every node contained in χ(t). This allows us to compute the value of c for a forget node.\nA record of a tree node t ∈ V (T ) is a quintuple R = (a, b, p, c, s) such that:\n1. a is a mapping χ(t)→ Pf (v);\n2. b is a mapping χ(t)→ [Ft];\n3. p is a transitive binary relation on χ(t);\n4. c is a non-negative integer;\n5. s is a non-negative real number.\nWe say that a record represents a partial solution Dp ∈ D(t) if it satisfies the following conditions:\n1. a(v) ∩ V (Dp) = PDp(v) for every v ∈ χ(t).\n2. b(v) = {u ∈ Ft : (v, u) ∈ E(Dp) } for every v ∈ χ(t).\n3. For every pair of nodes v1, v2 ∈ χ(t) it holds that (v1, v2) ∈ p if and only if Dp contains a directed path from v1 to v2.\n4. c ≤ k is the smallest integer such that Dp[Ft] is a c-O-neighbor of D[Ft].\nWe say that a record R = (a, b, p, c, s) of a tree node t ∈ V (T ) is valid if it represents some dag Dp ∈ D(t) and s is the maximum score ft(D) over all dags in D(t) represented by R. We say a partial solution D that is represented by R is maximal with respect to R if R is valid and ft(D) = s. With each tree node t ∈ V (T ) we associate the set R(t) of all valid records representing partial solutions in D(t).\nIt is now straightforward to adapt the dynamic programming algorithm of Section 4 to the new setting. Observe that there are at most k + 1 possible values for c. Furthermore, because every considered partial solution Dp is admissible, the number of possible values for b(v) for every v ∈ χ(t) is bounded by 2d. It follows that the space requirement to store such a record is at most (k+ 1) · 2d(w+1) times the space requirement needed to store a record as defined in Section 4. Using the same argumentation as in Section 4 this leads to an overall running time of O((δw+1f · (k+1) ·2\nd(w+1))2 · |V (D)|) ≤ O((dw+1 · (k+1) ·2d(w+1))2 · |V (D)|). Since w and d are constants, this constitutes a linear running time.\nTheorem 4. If O = {add} or O = {del}, then k-O-Local Search Bayesian Network Structure Learning is solvable in polynomial time.\nProof. We only consider O = {add} as the proof for O = {del} is analogous. Let I = (D, f, k) be the given instance of k-{add}-Local Search Bayesian Network Structure Learning. Since we are only allowed to add arcs to D every step must leave D acyclic. It follows that there is a k-{add}-neighbor D′ of D with f(D′) > f(D) if and only if there is a node v ∈ V (D) such that the addition of at most k incoming arcs increases the score of v and the resulting digraph remains acyclic. Now, for every P ⊆ V (D) \\ {v} one can easily check whether f(v, P ) > f(v,PD(v)) and whether P can be obtained from PD(v) via the addition of at most k incoming arcs and whether the resulting digraph is acyclic.\nIn view of Theorem 4 let us define a set O ⊆ {add, del, rev} to be non-trivial if O /∈ {∅, {add}, {del}}.\nTheorem 5. Let O ⊆ {add,del,rev} be non-trivial. Then k-O-Local Search Bayesian Network Structure Learning is W[1]-hard for parameter tw(Sf ) + k.\nProof. We slightly modify the reduction given in the proof of Theorem 3. Let I = (G, k) be the given instance of Partioned Clique and let N , f and s be defined in correspondence to I and the proof of Theorem 3. We will distinguish two cases depending on whether it is allowed to reverse an arc or not, i.e., depending on whether rev ∈ O.\nFor the case that rev ∈ O we claim that I ′ = (f,D, k′) where D = D(∅) and k′ = ( k 2 ) is an instance of k′-O-Local Search Bayesian Network Structure Learning such that G contains a k-clique if and only if there is a k′-O-neighbor D′ of D with f(D′) > f(D). To see this let K be a k-clique in G. It follows from Claim 6 that there is a representable edge set E′ with f(D(E′)) ≥ s > f(D) = s − 1 and since E′ is representable it is easy to see that D(E′) can be obtained from D by the reversal of at most k′ arcs in D. Hence D′ = D(E′) is a k′-O-neighbor of D with f(D′) > f(D). To see the reverse let D′ be a k′-O-neighbor of D with f(D′) > f(D) = s−1. Hence D′ is a dag and since f(D′) is integer it follows that f(D′) ≥ s. Again, using Claim 6, we have that there is a k-clique in G.\nNow, for the only remaining case, i.e., the case that O = {add,del} we claim that I ′′ = (f,D, k′′) where k′′ = 2k′ is an instance of k′-O-Local Search Bayesian Network Structure Learning such that G contains a k-clique if and only if there is a k′′-Oneighbor D′ of D with f(D′) > f(D). The proof uses the same arguments as in the case that rev ∈ O only that we now need twice as many operations. That is, we have to replace the reversal of an arc (u, v) with the deletion of the arc (u, v) followed by the addition of the arc (v, u).\nIn the preliminary version of this paper (Ordyniak & Szeider, 2010) we showed the following theorem by a parametrized reduction from Red/Blue Non-Blocker, which had been claimed to be W[1]-complete for graphs of bounded degree (Downey & Fellows, 1995). However, recently we found out that this problem is in fact fixed-parameter tractable and that the proof published in the work of Downey and Fellows (1995) contained a mistake (Fellows, 2012). We therefore use a reduction from Independent Set that does not require the original instance to have bounded degree. This even allows us to strengthen our result by decreasing the upper bound on the maximum degree of the super-structure from 5 to 3.\nTheorem 6. Let O ⊆ {add,del,rev} be non-trivial. Then k-O-Local Search Bayesian Network Structure Learning is W[1]-hard for parameter k. Hardness even holds if the super-structure Sf has maximum degree 3.\nProof. We devise an fpt-reduction from the following problem which is known to be W[1]complete (Downey & Fellows, 1999).\nIndependent Set\nInput: An undirected graph G = (V,E) and an integer k. Parameter: The integer k. Question: Does G have an independent set of size at least k, i.e., is there\na set S ⊆ V with |S| ≥ k such that {u, v} /∈ E for every pair of nodes u, v ∈ S.\nTo simplify the initial construction we first prove the theorem for the case that the maximum degree of the super-structure is at most 5. We later show how to refine the proof for superstructures with maximum degree at most 3.\nLet (G = (V,E), k) be an instance of this problem and k′ = 2k + 1 if rev ∈ O and k′ = 2(2k + 1) otherwise. We construct a dag D and a local score function f such that G has an independent set of size at least k if and only if D has a k′-O-neighbor D′ with a higher score than D.\nThe dag D is obtained from G by applying the following steps (see Figure 9 for an illustration):\n1. We replace every node v ∈ V with the two nodes v1 and v2 and an arc (v1, v2).\n2. For every node v ∈ V we add a binary tree Tv1 with exactly |NG(v)| leaves. The root of Tv1 is v 1 and all arcs of Tv1 are directed away from v 1. Furthermore, we define lv1\nto be a bijective mapping from NG(v) to the leaves of Tv1 .\n3. For every node v ∈ V we add a binary tree Tv2 with exactly |NG(v)| leaves. The root of Tv2 is v 2 and all arcs of Tv2 are directed towards v 2. Furthermore, we define lv2 to\nbe a bijective mapping from NG(v) to the leaves of Tv2 .\n4. For every edge {u, v} ∈ E, we add the arcs (lu1(v), lv2(u)) and (lv1(u), lu2(v)) to D.\n5. We add a binary tree T1 with root r1 with exactly |V | leaves, whose edges are directed away from r1. We define lT1 to be a bijective mapping from V to the leaves of T1.\n6. We add a binary tree T2 with root r2 with exactly |V | leaves, whose edges are directed towards r2. We define lT2 to be a bijective mapping from V to the leaves of T2.\n7. For every v ∈ V (G), we add the arcs (v1, lT1(v)) and (v1, lT2(v)) to D.\n8. We add the arc (r2, r1) to D.\nThis completes the construction of D. Next we define the local score function f on V (D). Let α = k − 1, β = |V (G)| and ε = 1.\n1. For every n ∈ V (D) \\ { v1 : v ∈ V (G) } ∪ {r1} we set f(n,PD(n)) = β.\n2. For every v ∈ V (G) we set f(v1, {v2, lT1(v)}) = ε, f(v2,PD(v2) \\ {v1}) = β, and f(lT1(v),PD(lT1(v)) \\ {v1}) = β.\n3. We set f(r1,PD(r1)) = α and f(r2,PD(r2) ∪ {r1}) = β.\n4. For all the remaining combinations of n ∈ V (D) and P ⊆ V (D) we set f(n, P ) = 0.\na b c7→\nEvidently D is acyclic and both D and f can be constructed from G in polynomial time. Observe that the super-structure Sf is exactly the skeleton of D. Hence, by construction, the nodes v1 for v ∈ V (D) have degree at most 5 while all other nodes of Sf have degree at most 3 showing that the maximum degree of Sf is at most 5. Consequently, we can establish the theorem with the help of the following claim whose proof can be found in the appendix.\nClaim 7. G has an independent set of size at least k if and only if D has a k′-O-neighbor D′ with a higher score than D where k′ = 2k + 1 if rev ∈ O and k′ = 2(2k + 1) otherwise.\nWe now show how to alter the above construction to obtain the result for maximum degree 3. The only nodes in Sf whose degree may exceed 3 are the nodes in { v1 : v ∈ V (G) }. The main idea to reduce the degree of these nodes is to further split their sets of neighbors using binary trees. For our new construction we define a DAG D′ and a local score function f ′ as follows. The DAG D′ is obtained from D by applying the following actions:\n1. For every v ∈ V (G), we delete all nodes of Tv1 and all arcs incident with these nodes.\n2. For every v ∈ V (G), we add the nodes v1a and v1b and the arcs (v1a, v1b) and (v1b, v2).\n3. For every v ∈ V (G) we add a binary tree Tv1a with exactly |NG(v)| + 1 leaves. The root of Tv1a is v 1a and all arcs of Tv1a are directed away from v 1a. Furthermore, we\ndefine lv1a to be a bijective mapping from NG(v) ∪ {lT2(v)} to the leaves of Tv1a .\n4. For every v ∈ V (G) we add the arcs (v1b, lT1(v)) and (lv1a(lT2(v)), lT2(v)).\nThis completes the construction of D′. Next we define the local score function f ′ as follows:\n1. For every n ∈ V (D′) \\ { v1a : v ∈ V (G) } ∪ {r1} we set f ′(n,PD′(n)) = β.\n2. For every v ∈ V (G) we set f ′(v1a, {v1b}) = ε, f ′(v1b, {v2, lT1(v)}) = β, f ′(v2,PD′(v2)\\ {v1b}) = β, and f ′(lT1(v),PD′(lT1(v)) \\ {v1b}) = β.\n3. We set f ′(r1,PD′(r1)) = α and f ′(r2,PD′(r2) ∪ {r1}) = β.\n4. For all the remaining combinations of n ∈ V (D′) and P ⊆ V (D′) we set f ′(n, P ) = 0.\nIt is easy to see that Sf ′ has maximum degree 3. Furthermore, using the same arguments as in the proof of Claim 7 one can show that the graph G has an independent set of size k if and only if the DAG D′ has a k′-O-neighbor D′′ with a higher score than D′ (with respect to f ′) where k′ = 3k + 1 if rev ∈ O and k′ = 2(3k + 1) otherwise.\nTheorem 6 provides a surprising contrast to a similar study of k-local search for MAX-SAT where the problem is fixed-parameter tractable for instances of bounded degree (Szeider, 2011). A possible explanation for the surprising hardness of k-O-Local Search Bayesian Structure Learning could be that, in contrast to MAX-SAT, a global property of the entire instance (acyclicity) must be checked."
    }, {
      "heading" : "8. The Directed Super-structure",
      "text" : "In the previous sections we considered the problem of Exact BNSL and k-Local Search BNSL under certain restrictions of the undirected super-structure. However, every strictly admissible solution to Exact BNSL is actually contained in the more restrictive directed super-structure. It is a natural question whether the additional information entailed in the directed super-structure can be used to find new structural restrictions under which Exact BNSL becomes tractable. It is well-known that Exact BNSL becomes significantly easier if an ordering of the variables is given in advance. For instance, given an ordering of the variables of a BN, Exact BNSL becomes solvable in polynomial time if the input is given in the arity-c representation (Teyssier & Koller, 2005). Fixing an ordering of the variables in a BN corresponds to restricting the search space to acyclic directed super-structures. Our first observation of this section is that Exact BNSL is solvable in polynomial time if the directed super-structure is a dag and the input to the problem is given in the more general non-zero representation. It is important to note that there is no corresponding restriction of the undirected super-structure, because restricting the directed super-structure to be acyclic does not impose any restrictions on the undirected super-structure. Considering this promising result it becomes natural to ask whether it is possible to gradually generalize the class of acyclic directed super-structures. A natural approach would be to consider only directed super-structures that can be made acyclic by deleting a small number k of nodes. Such an approach looks promising as it is known that for every fixed k the directed superstructures that can be made acyclic by deleting at most k nodes can be recognized efficiently (Chen, Liu, Lu, O’Sullivan, & Razgon, 2008). However, we show that this approach is unlikely to work for Exact BNSL. Furthermore, in correspondence to the results in the previous sections, NP-hardness even holds if we additionally bound the maximum in-degree and out-degree of S→f .\nTheorem 7. Let N be a set of nodes and f a local score function on N such that S→f is acyclic. Then we can find in time O(|N |δf ) a dag D with maximal score f(D).\nProof. Because S→f is acyclic, it follows that every strictly admissible directed graph D is also acyclic. Hence in order to compute a dag D with the highest score, it is sufficient to\ncompute for every n ∈ N a parent set with the highest score. This can clearly be done in time O(|N |δf ) and so the result follows.\nCorollary 2. Exact Bayesian Network Structure Learning is solvable in quadratic time for acyclic directed super-structures.\nProof. This follows immediately from Theorem 7 because both N and δf are bounded by the total input size of the problem. Recall from Section 3 that the local score function f is given as the list of all tuples for which f is non-zero and hence δf is bounded by the total input size of the instance.\nTheorem 8. Exact Bayesian Network Structure Learning is NP-hard for instances where S→f can be made acyclic by deleting one node. Hardness even holds if we additionally bound the maximum in-degree and the maximum out-degree of S→f by 3.\nProof. We devise a polynomial reduction from the restricted version of 3-SAT where every literal is contained in at most two clauses. This version of 3-SAT is still NP-complete (Garey & Johnson, 1979). Let φ be a 3-CNF formula with variables x1, . . . , xn and clauses C1, . . . , Cm where Cj = lj,1∨ lj,2∨ lj,3, for every 1 ≤ j ≤ m. We construct a set N of nodes, a local score function f and a real number s > 0.\nN contains the nodes d0, . . . , dn and t0, . . . , tn+m and additionally:\n• For every 1 ≤ i ≤ n the nodes xi, xi, ai, bi.\n• For every 1 ≤ j ≤ m the nodes lj,1, lj,2, lj,3, Cj .\nLet α = n+ 1 and ε = 1. We define f as follows:\n• We set f(d0, {t0}) = f(t0, t1) = α.\n• For every 1 ≤ i ≤ n we set:\n– f(di, {di−1}) = α. – f(ai, {di}) = α and f(xi, {ai}) = f(xi, {ai}) = ε. – f(bi, {xi}) = f(bi, {xi}) = α. – f(ti, {ti+1, bi}) = α.\n• For every 1 ≤ j ≤ m we set:\n– f(Cj , {lj,1}) = f(Cj , {lj,2}) = f(Cj , {lj,3}) = α. – f(tn+j , {tn+j+1, Cj}) = α if j < m and f(tn+j , {Cj}) = α if j = m.\n• For every 1 ≤ i ≤ n, 1 ≤ j ≤ m and 1 ≤ l ≤ 3 we set f(lj,l, {xi}) = α if lj,l = xi and f(lj,l, {xi}) = α if lj,l = xi.\nFor all other combinations of v ∈ N and P ⊆ N we set f(v, P ) = 0. Furthermore, we set s = (4n + 5m + 2)α + nε. An example of the directed super-structure constructed from a 3-CNF formula is shown in Figure 11. We establish the theorem by showing the following claims.\nClaim 8. S→f can be made acyclic by deleting at most one node. Claim 9. S→f has maximum in-degree and maximum out-degree 3.\nClaim 10. φ is satisfiable if and only if there is a dag D with score f(D) ≥ s.\nIt is easy to see that S→f − d0 is acyclic and hence Claim 8 holds. Since every literal occurs in at most two clauses it is also easy to verify Claim 9. The proof of Claim 10 is straightforward and can be found in the appendix."
    }, {
      "heading" : "9. Conclusion",
      "text" : "We have studied the computational complexity of Bayesian Structure Learning (BNSL) under various restrictions on the (directed) super-structure, considering both Exact BNSL and k-Local Search BNSL. We have obtained positive and negative results for the theoretical worst-case complexities of the problems. Our main positive result states that Exact BNSL is linear-time tractable if the super-structure has bounded treewidth and bounded maximum degree. We have contrasted out positive results with negative results, using techniques and concepts from Parameterized Complexity. This theoretical framework is particularly well-suited for such an investigation as it allows a fined-grained investigation that takes structural aspects of problem instances into account. Our results point out which combinations of structural restrictions make the problems tractable and which restrictions cannot be dropped without loosing tractability. Considering various combinations of restrictions in a systematic way allows us draw a broader picture of the complexity landscape (see the table in Section 1). We hope that our results provide a better understanding of the principles\nof BNSL and contribute to its foundations. We hope that this understanding will also be useful for the development of heuristic methods for practical BNSL systems."
    }, {
      "heading" : "Acknowledgments",
      "text" : "A shorter and preliminary version of this paper appeared in UAI 2010. Research supported by the European Research Council, grant reference 239962."
    }, {
      "heading" : "Appendix A",
      "text" : "Proof of Claim 1 (Lemma 2). Let us first assume that R = (a, p, s) is a valid record of t and let P = a(v0). Since R is valid it follows that it represents some partial solution D ∈ D(t) such that D is maximal with respect to R. Now, D′ = D[χ∗(t′)] is a partial solution for t′ and it follows from Proposition 4 that D′ = D − v0 and furthermore ft′(D′) = s. Hence, D′ can be represented by some record R′ = (a′, p′, s′) such that R, R′ and P satisfy the conditions of this claim. Furthermore, since R is valid and ft(D) = ft′(D\n′) the maximality of ft′(D\n′) with respect to R′ follows from the maximality of ft(D) with respect to R and hence R′ is a valid record of t′.\nTo see the converse let P ∈ Pf (v0) and a valid record R′ = (a′, p′, s′) ∈ R(t′) be given. Let R = (a, p, s) be the triple as defined via the conditions (1)-(4). Since R′ is a valid record it represents some partial solution D′ such that D′ is maximal with respect to R′. It is easy to see that the digraph D with node set V (D′) ∪ {v0} and arc set E(D′) ∪ { (u, v0) : u ∈ P } ∪ { (v0, u) : u ∈ χ(t′) such that v0 ∈ a′(u) } is acyclic if and only if p satisfies condition (5), i.e., p is irreflexive. It follows that R represents D if and only if p satisfies condition (5) and furthermore the maximality of D with respect to R follows from the maximality of D′ with respect to R′. Hence, R is a valid record for t if and only if it satisfies the conditions (1)–(5).\nProof of Claim 2 (Lemma 3). Let us first assume that R = (a, p, s) is a valid record of t. Since R is a valid record it represents some solution D ∈ D(t) such that D is maximal with respect to R. Now, let R′ = (a′, p′, s′) be such that a′(v0) = PD(v0), a\n′(v) = PD(v) for every v ∈ χ(t), p′ is the union of p and all tuples (v0, v) and (v, v0) where v ∈ χ(t) such that there is a directed path from v0 to v respectively from v to v0 in D and s\n′ = s − f(v0, PD(v0)). Note that because of Proposition 5 we can assume that PD(v0) ∈ Pf (v0) and hence D is also represented by R′. It follows from the maximality of D with respect to R that R′ is a maximal element in R(t′)[t].\nTo see the converse let R = (a, p, s) be a maximal element in R(t′)[t]. Since R ∈ R(t′)[t] it follows that there is a record R′ = (a′, p′, s′) ∈ R(t′) such that R = R′[t]. Hence, there is a partial solution D represented by R′ such that ft′(D) = s\n′ is maximal with respect to all partial solutions represented by R′. Clearly, D is also represented by R and the maximality of D with respect to R follows from the fact that R is a maximal element in R(t′)[t].\nProof of Claim 3 (Lemma 4). Let us first assume that R = (a, p, s) is a valid record for t. Since R is valid it follows that it represents a partial solution D ∈ D(t) such that D is maximal with respect to R. Let D1 = D[χ ∗(t1)] and D2 = D[χ ∗(t2)], i.e., D1 and D2 are the two subdigraphs of D induced by the nodes contained in the nodes of the subtrees\nrooted at t1 and t2, respectively. It follows from Proposition 3 that D = D1 ∪ D2 and V (D1) ∩ V (D2) = χ(t). Hence, D1 and D2 are partial solutions for t1 and t2, respectively. For i ∈ {1, 2}, let Ri = (ai, pi, si) be such that a = ai, (v, w) ∈ pi if and only if there is a directed path from v to w in Di and si = fti(Di). It follows directly from the definition that R1 and R2 represent D1 and D2, respectively, and since ft(D) = ft1(D1) + ft2(D2) the maximality of D with respect to R implies the maximality of D1 and D2 with respect to R1 and R2, respectively. Hence, R1 and R2 are valid records for t1 and t2, respectively, and it is easy to see that R, R1 and R2 satisfy the conditions of the claim.\nTo see the converse let us assume that we are given R1 = (a1, p1, s1) ∈ R(t1) and R2 = (a2, p2, s2) ∈ R(t2) and that the triple R = (a, p, s) as defined by the conditions (1)– (3) satisfies condition (4). Since R1 and R2 are valid it follows that both represent some partial solutions D1 and D2 such that D1 and D2 are maximal with respect to R1 and R2, respectively. Furthermore, using Proposition 3 it follows that V (D1) ∩ V (D2) = χ(t) and hence it follows from condition (4) that D = D1∪D2 is a partial solution represented by R. Now, ft(D) = ft1(D1) + ft2(D2) = s1 + s2 = s and the maximality of D with respect to R follows from the maximality of D1 and D2 with respect to R1 and R2, respectively. It follows that R is a valid record for t.\nProof of Claim 6 (Theorem 3). (1)⇒(2) SupposeG has a k-cliqueK. Then f(D(E(K))) = nkα− |V (K)|α+ |E(K)|ε = nkα+ k ≥ s and it remains to show that D(E(K)) is acyclic. To see this note that every cycle in D(E(K)) has to use at least one node from V , because D(E(K)) does not contain an arc between two nodes in A. But since K is a clique, every node v ∈ V is either a sink, i.e., v has only incoming arcs, or a source, i.e., v has only outgoing arcs and hence no cycle can use a node from V .\n(2)⇒(3) Suppose D is a dag with f(D) ≥ s. Let A′ be the set of nodes in A with f(a, PD(a)) = ε for every a ∈ A′. It follows from the definition of f that for every aij ∈ A′ there is a unique edge e between a node in Vi and a node in Vj in G with PD(aij) = e. Let E′ ⊆ E(G) be the set of all edges in G that correspond to a node in A′. It follows that E′ is representable and we claim that every node v ∈ N has at least the local score in D(E′) as it has in D. By construction of D(E′) the claim is trivially satisfied for every node a ∈ A. Similarly, for every v ∈ V \\ V (E′) it holds that f(v, PD(E′)(v)) = α and hence f(v, PD(E′)(v)) ≥ f(v, PD(v)). Furthermore, for every v ∈ V (E′) it holds that f(v, PD(v)) = 0 and hence again f(v, PD(E′)(v)) ≥ f(v, PD(v)). It follows that f(D(E′)) ≥ f(D) ≥ s.\n(3)⇒(1) Suppose that E′ ⊆ E(G) is a representable edge set of G with f(D(E′)) ≥ s. We will show that |V (E′)| = k and |E′| = ( k 2 ) which implies that E′ is the edge set of a k-clique in G.\nBecause E′ is an edge set, it holds that |E′| ≤ (|V (E′)|\n2\n) and hence:\nf(D(E′))− nkα = −|V (E′)|α+ |E′|ε ≤ −|V (E′)|α+ ( |V (E′)|\n2\n) ε\n= −|V (E′)|(k2 − k − 1) + ( |V (E′)|\n2\n) 2k\n= −|V (E′)|(k2 − k − 1) + (|V (E′)|2 − |V (E′)|)k = −|V (E′)|k2 + |V (E′)|2k + |V (E′)|k − |V (E′)|k + |V (E′)| = −|V (E′)|k2 + |V (E′)|2k + |V (E′)|\nBecause f(D(E′)) ≥ s, it follows that −|V (E′)|k2 + |V (E′)|2k + |V (E′)| ≥ 1 and hence:\n−|V (E′)|k2 + |V (E′)|2k + |V (E′)| ≥ 1\n−k2 + |V (E′)|k + 1 ≥ 1 |V (E′)|\n|V (E′)| ≥ 1 |V (E′)| + k 2 − 1\nk\n|V (E′)| ≥ k − 1 k + 1 |V (E′)|k\nSince |V (E′)| is an integer and k > 2, we have that |V (E′)| ≥ k. Furthermore, since E′ is representable it can contain at most ( k 2 ) edges and hence\nf(D(E′))−nkα ≤ −|V (E′)|α+ ( k 2 ) ε. Again, it follows from f(D(E′)) ≥ s that −|V (E′)|α+(\nk 2\n) ε ≥ 1 and:\n−|V (E′)|α+ ( k\n2\n) ε ≥ 1\n−|V (E′)|(k2 − k − 1) + k3 − k2 ≥ 1 −|V (E′)|(k2 − k − 1) ≥ −k3 + k2 + 1\n−|V (E′)| ≥ −k 3 + k2 + 1\nk2 − k − 1\n|V (E′)| ≤ k + k + 1 k2 − k − 1\nSince |V (E′)| is an integer and k > 2, it follows that |V (E′)| ≤ k and hence |V (E′)| = k. Using this in f(D(E′))− nkα ≥ 1 we get:\n−kα+ |E′|ε ≥ 1 −(k3 − k2 − k) + |E′|2k ≥ 1\n|E′| ≥ k 3 − k2 − k + 1\n2k\n|E′| ≥ k2 − k − 1 + 1k\n2 |E′| ≥ ( k\n2\n) −\n1− 1k 2\nBecause |E′| is an integer and k > 2, it follows that |E′| ≥ ( k 2 ) . Putting everything together\nwe have that f(D(E′)) ≥ s implies |V (E′)| = k and |E′| = ( k 2 ) . Hence E′ is the edge set of a k-clique in G.\nProof of Claim 7 (Theorem 6). We first show the claim for the case that rev ∈ O and k′ = 2k + 1.\nLet us first assume that G has an independent set S ⊆ V (G) of size at least k. We obtain D′ from D by reversing the k′ arcs in { (v1, v2), (v1, lT1(v)) : v ∈ S } ∪ {(r2, r1)}. This decreases the score for r1 by α and increases the score for the nodes in { v1 : v ∈ S } by ε while the score of all the other nodes of D remains unchanged. Hence, f(D′) = f(D) − α + |S|ε ≥ α + kε = f(D) + 1 > f(D) and it remains to show that D′ is acyclic. To see this assume that D′ contains a cycle C. Because D is acyclic C must contain at least one of the newly created arcs in D′, i.e., C must contain either an arc (v2, v1), an arc (lT1(v), v\n1) for some v ∈ S or the arc (r1, r2). Because r2 is a sink in D′, i.e., r2 has no outgoing arcs, the cycle C cannot contain the arc (r1, r2). Similarly, because D\n′ does not contain a directed path from v1 to lT1(v) the cycle C cannot contain an arc (lT1(v), v\n1) for any v ∈ S. Hence the cycle C must contain an arc (v2, v1) for some v ∈ S. So suppose that C contains the arc (v2, v1) for some v ∈ S. Because D′ contains no directed paths from a node of T2 to a node of T1 it follows that C cannot leave the node v\n1 using the arc (v1, lT2(v)). Consequently, the cycle C must leave the node v\n1 towards w2 for some neighbor w of v in G. Because S is an independent set in G it follows that w /∈ S and hence the node w2 is a sink in D′ contradicting the existence of the cycle C.\nTo see the reverse direction assume that D′ is a dag obtained from D by reversing at most k′ arcs. Note that the nodes in { v1 : v ∈ V (G) } are the only nodes of D whose scores are not yet maximum. Hence, in order for D′ to have a higher score than D the score for at least one of these nodes has to be increased. Now, the score for such a node v1 for some v ∈ V (G) can only be increased by reversing the arcs (v1, v2) and (v1, lT1(v)). It is easy to see that reversing the arc (v1, lT1(v)) introduces a cycle C in D that uses only nodes in V (T1) ∪ V (T2) ∪ {v1}. However, because every such cycle C contains the arc (r2, r1) we can destroy all of these cycles by additionally reversing the arc (r2, r1). Because reversing (r2, r1) does only decrease the score of r1 by α this is also the cheapest way to destroy these cycles. Now, α = (k − 1)ε and it follows that in order to increase the score of D the scores of at least k nodes in { v1 : v ∈ V (G) } have to be increased to ε. Let S be the set of nodes in V (G) such that the score of the nodes in { v1 : v ∈ S } has been increased in this manner. As mentioned above |S| ≥ k and it remains to show that S is an independent set in G. Suppose S is not an independent set and let u, v ∈ S be such that {u, v} ∈ E(G). Then the arcs (v2, v1) and (u2, u1) together with the directed path from v1 to u2 (using the arcs in Tv1 and Tu2) and the directed path from u\n1 to v2 (using the arcs in Tu1 and Tv2) form a cycle in D′ contradicting the acyclicity of D′. It follows that S is an independent set in G of size at least k.\nHence, we have shown the theorem for the case rev ∈ O. It remains to show the theorem for the only remaining non-trivial set with rev /∈ O, i.e., the set O = {add,del}. Now k′ = 2(2k + 1) and the idea is to replace every reversal of an arc (u, v) by a deletion (of (u, v)) and an addition (of (v, u)).\nProof of Claim 10 (Theorem 8). We will prove Claim 10 with the help of the following claim.\nClaim 11. f(D) ≥ s and D is acyclic if and only if D satisfies the following conditions:\n1 D contains at least the following arcs:\n– The arc (t0, d0).\n– For every 1 ≤ i ≤ n, the arcs (di−1, di), (di, ai), (bi, ti) and (ti, ti−1). – For every 1 ≤ i ≤ n, 1 ≤ j ≤ m and 1 ≤ l ≤ 3 the arc (xi, lj,l) if lj,l = xi and\nsimilarly the arc (xi, lj,l) if lj,l = xi.\n– For every 1 ≤ j ≤ m, the arcs (Cj , tn+j) and (tn+j , tn+j−1) and exactly one of the arcs (lj,1, Cj), (lj,2, Cj) and (lj,3, Cj).\n2 For every 1 ≤ i ≤ n the digraph D contains the arcs (ai, xi) and (xi, bi) but not the arcs (ai, xi) and (xi, bi) or D contains the arcs (ai, xi) and (xi, bi) but not the arcs (ai, xi) and (xi, bi).\n3 For 1 ≤ i ≤ n, 1 ≤ j ≤ m and 1 ≤ l ≤ 3, the following holds:\n– If lj,l = xi and D contains the arc (lj,l, Cj) then D does not contain the arc (ai, xi).\n– If lj,l = xi and D contains the arc (lj,l, Cj) then D does not contain the arc (ai, xi).\nWe will first show how the previous claim can be used to prove Claim 10. Suppose φ is satisfiable and let β be a satisfying assignment for φ. Let D be the digraph that satisfies condition 1 and additionally:\n• For every 1 ≤ i ≤ n if β(xi) = true then D contains the arcs (ai, xi) and (xi, bi), otherwise D contains the arcs (ai, xi) and (xi, bi).\n• For every 1 ≤ j ≤ m let lj,l any literal in the clause Cj that is satisfied by β; since β is a satisfying assignment every clause Cj contains such a literal. Then D contains the arc (lj,l, Cj).\nIt follows that D satisfies the conditions 2 and 3 and hence (using Claim 11) f(D) ≥ s and D is acyclic.\nTo see the reverse let D be a dag with f(D) ≥ s. It follows from Claim 11 that D satisfies the conditions 1 –3. We claim that the assignment β with β(xi) = true if and only if D does not contain the arc (ai, xi) is a satisfying assignment for φ. It follows from condition 1 that for every 1 ≤ j ≤ m the digraph D contains an arc (lj,l, Cj) for some 1 ≤ l ≤ 3. W.l.o.g., we can assume that lj,l = xi for some 1 ≤ i ≤ n (the case that lj,l = xi is analog). Again using condition 1 it follows that D contains the arc (xi, lj,l). Because of condition 3 the digraph D does not contain the arc (ai, xi) and hence β(lj,l) = true.\nHence it only remains to show Claim 11. Let us first show that every dag D with f(D) ≥ s satisfies conditions 1 –3. To see this observe that every node in V = {x1, x1, . . . , xn, xn}\nhas either score 0 or ε. Similarly, every node in V ′ = N \\ V has either score 0 or α. It follows that in every directed graph there are at most 4n + 5m + 2 nodes with score α and at most 2n nodes with score ε. Hence, the maximum score for every directed graph is (4n + 5m + 2)α + 2nε. Because α > nε and f(D) ≥ s it follows that in D every node from V ′ must have score α and similarly at least n of the 2n nodes in V must have score ε. Hence D satisfies condition 1.\nTo show condition 2 observe that because for every 1 ≤ i ≤ n the node bi must have score α in D it holds that exactly one of the arcs (xi, bi) and (xi, bi) is in D. Now, if D contains the arc (xi, bi) for some 1 ≤ i ≤ n then D cannot contain the arc (ai, xi) because otherwise D would contain the cycle (d, ai, xi, bi, t, d). Similarly, if D contains the arc (xi, bi) for some 1 ≤ i ≤ n then D cannot contain the arc (ai, xi). It follows that for every 1 ≤ i ≤ n at least one of the arcs (ai, xi) and (ai, xi) is missing in D. Since there are at most n nodes in V with score 0 it follows that for every 1 ≤ i ≤ n exactly one of the arcs (ai, xi) and (ai, xi) must be in D. It follows that D satisfies condition 2.\nTo see condition 3 suppose for some 1 ≤ i ≤ n, 1 ≤ j ≤ m and 1 ≤ l ≤ 3 with lj,l = xi the digraph D contains both arcs (lj,l, Cj) and (ai, xi). It follows that D would contain the cycle (d, ai, xi, lj,l, Cj , t, d), a contradiction. The case that lj,l = xi is analog and hence D satisfies condition 3.\nTo see the reverse implication of the claim suppose that D is a digraph that satisfies the conditions 1 –3. It is easy to see that f(D) = s and it hence only remains to show that D is acyclic. Because S→f − (t0, d0) is acyclic it follows that every cycle in D has to use the arc (t0, d0). Hence D contains a cycle if and only if there is a directed path P from d0 to t0 in D. It follows from condition 2 that there is no directed path from d0 to some bi in D, for 1 ≤ i ≤ 3, and hence P cannot contain a node bi. Since the only other nodes in D with arcs to {t0, . . . , tn+m} are the nodes C1, . . . , Cm it follows that P has to use a node Cj for some 1 ≤ j ≤ m. Because of condition 1 the node Cj has exactly one incoming neighbor (one of lj,1, lj,2, lj,3) say lj,l. Again using condition 1 the node lj,l has exactly one incoming neighbor xi or xi if lj,l = xi or lj,l = xi, respectively. W.l.o.g. let us assume that lj,l = xi. It follows from condition 3 that xi has no incoming neighbor and hence D contains no directed path P from d0 to t0."
    } ],
    "references" : [ {
      "title" : "Digraphs (Second edition)",
      "author" : [ "J. Bang-Jensen", "G. Gutin" ],
      "venue" : null,
      "citeRegEx" : "Bang.Jensen and Gutin,? \\Q2009\\E",
      "shortCiteRegEx" : "Bang.Jensen and Gutin",
      "year" : 2009
    }, {
      "title" : "A tourist guide through treewidth",
      "author" : [ "H.L. Bodlaender" ],
      "venue" : "Acta Cybernetica,",
      "citeRegEx" : "Bodlaender,? \\Q1993\\E",
      "shortCiteRegEx" : "Bodlaender",
      "year" : 1993
    }, {
      "title" : "Discovering treewidth",
      "author" : [ "H.L. Bodlaender" ],
      "venue" : "In Proceedings of the 31st Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM’05),",
      "citeRegEx" : "Bodlaender,? \\Q2005\\E",
      "shortCiteRegEx" : "Bodlaender",
      "year" : 2005
    }, {
      "title" : "A linear-time algorithm for finding tree-decompositions of small treewidth",
      "author" : [ "H.L. Bodlaender" ],
      "venue" : "SIAM J. Comput.,",
      "citeRegEx" : "Bodlaender,? \\Q1996\\E",
      "shortCiteRegEx" : "Bodlaender",
      "year" : 1996
    }, {
      "title" : "Treewidth: algorithmic techniques and results",
      "author" : [ "H.L. Bodlaender" ],
      "venue" : "In Mathematical foundations of computer science 1997 (Bratislava),",
      "citeRegEx" : "Bodlaender,? \\Q1997\\E",
      "shortCiteRegEx" : "Bodlaender",
      "year" : 1997
    }, {
      "title" : "Combinatorial optimization on graphs of bounded treewidth",
      "author" : [ "H.L. Bodlaender", "Koster", "A.M.C. A" ],
      "venue" : "Comput. J.,",
      "citeRegEx" : "Bodlaender et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Bodlaender et al\\.",
      "year" : 2008
    }, {
      "title" : "Efficient principled learning of thin junction trees",
      "author" : [ "A. Chechetka", "C. Guestrin" ],
      "venue" : "Advances in Neural Information Processing Systems 20, Proceedings of the Twenty-First Annual Conference on Neural Information Processing Systems,",
      "citeRegEx" : "Chechetka and Guestrin,? \\Q2007\\E",
      "shortCiteRegEx" : "Chechetka and Guestrin",
      "year" : 2007
    }, {
      "title" : "A fixed-parameter algorithm for the directed feedback vertex set problem",
      "author" : [ "J. Chen", "Y. Liu", "S. Lu", "B. O’Sullivan", "I. Razgon" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "Chen et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2008
    }, {
      "title" : "A transformational characterization of equivalent Bayesian network structures",
      "author" : [ "D.M. Chickering" ],
      "venue" : "In Uncertainty in artificial intelligence (Montreal, PQ,",
      "citeRegEx" : "Chickering,? \\Q1995\\E",
      "shortCiteRegEx" : "Chickering",
      "year" : 1995
    }, {
      "title" : "Learning Bayesian networks is NP-complete. In Learning from data (Fort",
      "author" : [ "D.M. Chickering" ],
      "venue" : "Vol. 112 of Lecture Notes in Statist.,",
      "citeRegEx" : "Chickering,? \\Q1996\\E",
      "shortCiteRegEx" : "Chickering",
      "year" : 1996
    }, {
      "title" : "Approximating discrete probability distributions with dependence trees",
      "author" : [ "C.I. Chow", "C.N. Liu" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "Chow and Liu,? \\Q1968\\E",
      "shortCiteRegEx" : "Chow and Liu",
      "year" : 1968
    }, {
      "title" : "Recursive conditioning",
      "author" : [ "A. Darwiche" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Darwiche,? \\Q2001\\E",
      "shortCiteRegEx" : "Darwiche",
      "year" : 2001
    }, {
      "title" : "Learning polytrees",
      "author" : [ "S. Dasgupta" ],
      "venue" : "UAI ’99: Proceedings of the Fifteenth Conference on Uncertainty in Artificial Intelligence, Stockholm, Sweden, July 30-August",
      "citeRegEx" : "Dasgupta,? \\Q1999\\E",
      "shortCiteRegEx" : "Dasgupta",
      "year" : 1999
    }, {
      "title" : "Structure learning of Bayesian networks using constraints",
      "author" : [ "C.P. de Campos", "Z. Zeng", "Q. Ji" ],
      "venue" : "Proceedings of the 26th Annual International Conference on Machine Learning,",
      "citeRegEx" : "Campos et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Campos et al\\.",
      "year" : 2009
    }, {
      "title" : "Bucket elimination: a unifying framework for reasoning",
      "author" : [ "R. Dechter" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Dechter,? \\Q1999\\E",
      "shortCiteRegEx" : "Dechter",
      "year" : 1999
    }, {
      "title" : "Graph Theory (2nd edition)., Vol. 173 of Graduate Texts in Mathematics",
      "author" : [ "R. Diestel" ],
      "venue" : null,
      "citeRegEx" : "Diestel,? \\Q2000\\E",
      "shortCiteRegEx" : "Diestel",
      "year" : 2000
    }, {
      "title" : "Best-first search for treewidth",
      "author" : [ "P.A. Dow", "R.E. Korf" ],
      "venue" : "In Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence, July 22-26,",
      "citeRegEx" : "Dow and Korf,? \\Q2007\\E",
      "shortCiteRegEx" : "Dow and Korf",
      "year" : 2007
    }, {
      "title" : "Parameterized Complexity. Monographs in Computer Science",
      "author" : [ "R.G. Downey", "M.R. Fellows" ],
      "venue" : null,
      "citeRegEx" : "Downey and Fellows,? \\Q1999\\E",
      "shortCiteRegEx" : "Downey and Fellows",
      "year" : 1999
    }, {
      "title" : "Fixed-parameter tractability and completeness",
      "author" : [ "R.G. Downey", "M.R. Fellows" ],
      "venue" : "II. On completeness for W [1]. Theoret. Comput. Sci.,",
      "citeRegEx" : "Downey and Fellows,? \\Q1995\\E",
      "shortCiteRegEx" : "Downey and Fellows",
      "year" : 1995
    }, {
      "title" : "The computer journal special issue on parameterized complexity: Foreword by the guest editors",
      "author" : [ "R.G. Downey", "M.R. Fellows", "M.A. Langston" ],
      "venue" : "The Computer Journal,",
      "citeRegEx" : "Downey et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Downey et al\\.",
      "year" : 2008
    }, {
      "title" : "Learning bounded treewidth Bayesian networks",
      "author" : [ "G. Elidan", "S. Gould" ],
      "venue" : "Advances in Neural Information Processing Systems 21, Proceedings of the Twenty-Second Annual Conference on Neural Information Processing Systems,",
      "citeRegEx" : "Elidan and Gould,? \\Q2008\\E",
      "shortCiteRegEx" : "Elidan and Gould",
      "year" : 2008
    }, {
      "title" : "Blow-ups, win/win’s, and crown rules: Some new directions in FPT",
      "author" : [ "M.R. Fellows" ],
      "venue" : "Graph-Theoretic Concepts in Computer Science (WG 2003),",
      "citeRegEx" : "Fellows,? \\Q2003\\E",
      "shortCiteRegEx" : "Fellows",
      "year" : 2003
    }, {
      "title" : "Local search: Is brute-force avoidable",
      "author" : [ "M.R. Fellows", "F.A. Rosamond", "F.V. Fomin", "D. Lokshtanov", "S. Saurabh", "Y. Villanger" ],
      "venue" : "Proceedings of the 21st International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Fellows et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Fellows et al\\.",
      "year" : 2009
    }, {
      "title" : "Parameterized Complexity Theory, Vol. XIV of Texts in Theoretical Computer Science. An EATCS Series",
      "author" : [ "J. Flum", "M. Grohe" ],
      "venue" : null,
      "citeRegEx" : "Flum and Grohe,? \\Q2006\\E",
      "shortCiteRegEx" : "Flum and Grohe",
      "year" : 2006
    }, {
      "title" : "Learning Bayesian network structure from massive datasets: The ”sparse candidate",
      "author" : [ "N. Friedman", "I. Nachman", "D. Pe’er" ],
      "venue" : "UAI ’99: Proceedings of the Fifteenth Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Friedman et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Friedman et al\\.",
      "year" : 1999
    }, {
      "title" : "Computers and Intractability",
      "author" : [ "M.R. Garey", "D.R. Johnson" ],
      "venue" : null,
      "citeRegEx" : "Garey and Johnson,? \\Q1979\\E",
      "shortCiteRegEx" : "Garey and Johnson",
      "year" : 1979
    }, {
      "title" : "Don’t be strict in local search",
      "author" : [ "S. Gaspers", "E.J. Kim", "S. Ordyniak", "S. Saurabh", "S. Szeider" ],
      "venue" : "In Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "Gaspers et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Gaspers et al\\.",
      "year" : 2012
    }, {
      "title" : "On finding optimal polytrees",
      "author" : [ "S. Gaspers", "M. Koivisto", "M. Liedloff", "S. Ordyniak", "S. Szeider" ],
      "venue" : null,
      "citeRegEx" : "Gaspers et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Gaspers et al\\.",
      "year" : 2012
    }, {
      "title" : "Stopping rules for randomized greedy triangulation schemes",
      "author" : [ "A. Gelfand", "K. Kask", "R. Dechter" ],
      "venue" : "Proceedings of the Twenty-Fifth AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "Gelfand et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Gelfand et al\\.",
      "year" : 2011
    }, {
      "title" : "A complete anytime algorithm for treewidth",
      "author" : [ "V. Gogate", "R. Dechter" ],
      "venue" : "In Proceedings of the Proceedings of the Twentieth Conference Annual Conference on Uncertainty in Artificial Intelligence",
      "citeRegEx" : "Gogate and Dechter,? \\Q2004\\E",
      "shortCiteRegEx" : "Gogate and Dechter",
      "year" : 2004
    }, {
      "title" : "On the power of structural decompositions of graph-based representations of constraint problems",
      "author" : [ "G. Greco", "F. Scarcello" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Greco and Scarcello,? \\Q2010\\E",
      "shortCiteRegEx" : "Greco and Scarcello",
      "year" : 2010
    }, {
      "title" : "Learning Bayesian networks: The combination of knowledge and statistical data",
      "author" : [ "D. Heckerman", "D. Geiger", "D.M. Chickering" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Heckerman et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Heckerman et al\\.",
      "year" : 1995
    }, {
      "title" : "Which problems have strongly exponential complexity",
      "author" : [ "R. Impagliazzo", "R. Paturi", "F. Zane" ],
      "venue" : "J. of Computer and System Sciences,",
      "citeRegEx" : "Impagliazzo et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Impagliazzo et al\\.",
      "year" : 2001
    }, {
      "title" : "Learning markov networks: maximum bounded treewidth graphs",
      "author" : [ "D.R. Karger", "N. Srebro" ],
      "venue" : "In SODA,",
      "citeRegEx" : "Karger and Srebro,? \\Q2001\\E",
      "shortCiteRegEx" : "Karger and Srebro",
      "year" : 2001
    }, {
      "title" : "Reducibility among combinatorial problems",
      "author" : [ "R.M. Karp" ],
      "venue" : "In Complexity of computer computations (Proc. Sympos., IBM Thomas J. Watson Res",
      "citeRegEx" : "Karp,? \\Q1972\\E",
      "shortCiteRegEx" : "Karp",
      "year" : 1972
    }, {
      "title" : "Pushing the power of stochastic greedy ordering schemes for inference in graphical models",
      "author" : [ "K. Kask", "A. Gelfand", "L. Otten", "R. Dechter" ],
      "venue" : "Proceedings of the Twenty-Fifth AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "Kask et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Kask et al\\.",
      "year" : 2011
    }, {
      "title" : "On local search and placement of meters in networks",
      "author" : [ "S. Khuller", "R. Bhatia", "R. Pless" ],
      "venue" : "SIAM J. Comput.,",
      "citeRegEx" : "Khuller et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Khuller et al\\.",
      "year" : 2003
    }, {
      "title" : "Treewidth: Computations and Approximations",
      "author" : [ "T. Kloks" ],
      "venue" : null,
      "citeRegEx" : "Kloks,? \\Q1994\\E",
      "shortCiteRegEx" : "Kloks",
      "year" : 1994
    }, {
      "title" : "Advances in exact Bayesian structure discovery in Bayesian networks",
      "author" : [ "M. Koivisto" ],
      "venue" : "Proceedings of the 22nd Conference in Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Koivisto,? \\Q2006\\E",
      "shortCiteRegEx" : "Koivisto",
      "year" : 2006
    }, {
      "title" : "Optimal search on clustered structural constraint for learning Bayesian network structure",
      "author" : [ "K. Kojima", "E. Perrier", "S. Imoto", "S. Miyano" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "Kojima et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kojima et al\\.",
      "year" : 2010
    }, {
      "title" : "Treewidth: Computational experiments",
      "author" : [ "Koster", "A.M.C. A", "H.L. Bodlaender", "S.P.M. van Hoesel" ],
      "venue" : "Electronic Notes in Discrete Mathematics,",
      "citeRegEx" : "Koster et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Koster et al\\.",
      "year" : 2001
    }, {
      "title" : "On the hardness of losing weight",
      "author" : [ "A.A. Krokhin", "D. Marx" ],
      "venue" : "ACM Transactions on Algorithms,",
      "citeRegEx" : "Krokhin and Marx,? \\Q2012\\E",
      "shortCiteRegEx" : "Krokhin and Marx",
      "year" : 2012
    }, {
      "title" : "The necessity of bounded treewidth for efficient inference in Bayesian networks",
      "author" : [ "J. Kwisthout", "H.L. Bodlaender", "L.C. van der Gaag" ],
      "venue" : "In ECAI,",
      "citeRegEx" : "Kwisthout et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kwisthout et al\\.",
      "year" : 2010
    }, {
      "title" : "Searching the k-change neighborhood for TSP is W[1]-hard",
      "author" : [ "D. Marx" ],
      "venue" : "Oper. Res. Lett.,",
      "citeRegEx" : "Marx,? \\Q2008\\E",
      "shortCiteRegEx" : "Marx",
      "year" : 2008
    }, {
      "title" : "Stable assignment with couples: Parameterized complexity and local search",
      "author" : [ "D. Marx", "I. Schlotter" ],
      "venue" : "Discrete Optimization,",
      "citeRegEx" : "Marx and Schlotter,? \\Q2011\\E",
      "shortCiteRegEx" : "Marx and Schlotter",
      "year" : 2011
    }, {
      "title" : "Finding a path is harder than finding a tree",
      "author" : [ "C. Meek" ],
      "venue" : "J. Artif. Intell. Res.,",
      "citeRegEx" : "Meek,? \\Q2001\\E",
      "shortCiteRegEx" : "Meek",
      "year" : 2001
    }, {
      "title" : "PAC-learning bounded tree-width graphical models",
      "author" : [ "M. Narasimhan", "J.A. Bilmes" ],
      "venue" : "UAI ’04, Proceedings of the 20th Conference in Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Narasimhan and Bilmes,? \\Q2004\\E",
      "shortCiteRegEx" : "Narasimhan and Bilmes",
      "year" : 2004
    }, {
      "title" : "Invitation to Fixed-Parameter Algorithms. Oxford Lecture Series in Mathematics and its Applications",
      "author" : [ "R. Niedermeier" ],
      "venue" : null,
      "citeRegEx" : "Niedermeier,? \\Q2006\\E",
      "shortCiteRegEx" : "Niedermeier",
      "year" : 2006
    }, {
      "title" : "Algorithms and complexity results for exact Bayesian structure learning",
      "author" : [ "S. Ordyniak", "S. Szeider" ],
      "venue" : "Proceedings of UAI 2010, The 26th Conference on Uncertainty in Artificial Intelligence, Catalina",
      "citeRegEx" : "Ordyniak and Szeider,? \\Q2010\\E",
      "shortCiteRegEx" : "Ordyniak and Szeider",
      "year" : 2010
    }, {
      "title" : "Finding optimal models for small gene",
      "author" : [ "S. Ott", "S. Imoto", "S. Miyano" ],
      "venue" : "Proceedings of the Pacific Symposium, Hawaii,",
      "citeRegEx" : "Ott et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Ott et al\\.",
      "year" : 2004
    }, {
      "title" : "Bayesian structure discovery in Bayesian networks with less space",
      "author" : [ "P. Parviainen", "M. Koivisto" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "Parviainen and Koivisto,? \\Q2010\\E",
      "shortCiteRegEx" : "Parviainen and Koivisto",
      "year" : 2010
    }, {
      "title" : "Finding optimal Bayesian network given a super-structure",
      "author" : [ "E. Perrier", "S. Imoto", "S. Miyano" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "Perrier et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Perrier et al\\.",
      "year" : 2008
    }, {
      "title" : "Learning factor graphs in polynomial time and sample complexity",
      "author" : [ "A. Pieter", "K. Daphne", "Y.N. Andrew" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "Pieter et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Pieter et al\\.",
      "year" : 2006
    }, {
      "title" : "On the parameterized complexity of the fixed alphabet shortest common supersequence and longest common subsequence problems",
      "author" : [ "K. Pietrzak" ],
      "venue" : "J. of Computer and System Sciences,",
      "citeRegEx" : "Pietrzak,? \\Q2003\\E",
      "shortCiteRegEx" : "Pietrzak",
      "year" : 2003
    }, {
      "title" : "A simple approach for finding the globally optimal Bayesian network structure",
      "author" : [ "T. Silander", "P. Myllymäki" ],
      "venue" : "Proceedings of the 22nd Conference in Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Silander and Myllymäki,? \\Q2006\\E",
      "shortCiteRegEx" : "Silander and Myllymäki",
      "year" : 2006
    }, {
      "title" : "The parameterized complexity of k-flip local search for SAT and MAX SAT",
      "author" : [ "S. Szeider" ],
      "venue" : "Discrete Optimization,",
      "citeRegEx" : "Szeider,? \\Q2011\\E",
      "shortCiteRegEx" : "Szeider",
      "year" : 2011
    }, {
      "title" : "Ordering-based search: A simple and effective algorithm for learning bayesian networks",
      "author" : [ "M. Teyssier", "D. Koller" ],
      "venue" : "Proceedings of the 21st Conference in Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Teyssier and Koller,? \\Q2005\\E",
      "shortCiteRegEx" : "Teyssier and Koller",
      "year" : 2005
    }, {
      "title" : "The max-min hill-climbing Bayesian network structure learning algorithm",
      "author" : [ "I. Tsamardinos", "L. Brown", "C. Aliferis" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Tsamardinos et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Tsamardinos et al\\.",
      "year" : 2006
    }, {
      "title" : "Foundations of Constraint Satisfaction",
      "author" : [ "E.P.K. Tsang" ],
      "venue" : null,
      "citeRegEx" : "Tsang,? \\Q1993\\E",
      "shortCiteRegEx" : "Tsang",
      "year" : 1993
    }, {
      "title" : "Learning optimal Bayesian networks using A* search",
      "author" : [ "C. Yuan", "B. Malone", "X. Wu" ],
      "venue" : "Proceedings of the 22nd International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Yuan et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Yuan et al\\.",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "Unfortunately, solving the problem optimally (Exact BNSL) is NP-complete (Chickering, 1996).",
      "startOffset" : 73,
      "endOffset" : 91
    }, {
      "referenceID" : 12,
      "context" : ", BNSL is known to be NP-hard if the resulting BN is a polytree (Dasgupta, 1999) or a directed path (Meek, 2001).",
      "startOffset" : 64,
      "endOffset" : 80
    }, {
      "referenceID" : 45,
      "context" : ", BNSL is known to be NP-hard if the resulting BN is a polytree (Dasgupta, 1999) or a directed path (Meek, 2001).",
      "startOffset" : 100,
      "endOffset" : 112
    }, {
      "referenceID" : 57,
      "context" : "After the super-structure has been obtained, usually using an IT-based approach (Tsamardinos et al., 2006), one looks for solution networks whose skeletons are contained in the super-structure.",
      "startOffset" : 80,
      "endOffset" : 106
    }, {
      "referenceID" : 12,
      "context" : ", BNSL is known to be NP-hard if the resulting BN is a polytree (Dasgupta, 1999) or a directed path (Meek, 2001). Recently, a novel approach to restrict the structure of BNSL has been introduced (Tsamardinos, Brown, & Aliferis, 2006; Perrier, Imoto, & Miyano, 2008). Here a so-called super-structure, an undirected graph on the same nodes as the resulting BN, is used to restrict the search space of BNSL in advance. After the super-structure has been obtained, usually using an IT-based approach (Tsamardinos et al., 2006), one looks for solution networks whose skeletons are contained in the super-structure. It hence becomes important that the super-structure is sound, i.e., contains at least one optimal solution. There are two main questions concerning the super-structure: First, how can a suitable and sound super-structure be obtained efficiently? And secondly, once such a superstructure is obtained, how can it be used to guide the search for an optimal solution? The goal of this paper is to provide a theoretical analysis of the latter question, considering super-structures that arise from a given local score function adapting the model of Parviainen and Koivisto (2010). We consider various combinations of restrictions in a systematic way that allows us draw a broader picture of the complexity landscape of BNSL.",
      "startOffset" : 65,
      "endOffset" : 1186
    }, {
      "referenceID" : 11,
      "context" : "More importantly, treewidth has already been successfully applied in the context of Bayesian Reasoning (Darwiche, 2001; Dechter, 1999; Kwisthout, Bodlaender, & van der Gaag, 2010).",
      "startOffset" : 103,
      "endOffset" : 179
    }, {
      "referenceID" : 14,
      "context" : "More importantly, treewidth has already been successfully applied in the context of Bayesian Reasoning (Darwiche, 2001; Dechter, 1999; Kwisthout, Bodlaender, & van der Gaag, 2010).",
      "startOffset" : 103,
      "endOffset" : 179
    }, {
      "referenceID" : 57,
      "context" : "In particular, a highly competitive algorithm for learning large Bayesian networks (MMHC) uses local search to find an optimal solution inside a previously constructed super-structure (Tsamardinos et al., 2006).",
      "startOffset" : 184,
      "endOffset" : 210
    }, {
      "referenceID" : 38,
      "context" : "These can be split into three groups: (A) exact algorithms that do not employ any restrictions (Parviainen & Koivisto, 2010; Koivisto, 2006; Yuan, Malone, & Wu, 2011; Ott, Imoto, & Miyano, 2004; Silander & Myllymäki, 2006; Yuan et al., 2011), (B) exact algorithms using restrictions on the generating or target distribution (Pieter et al.",
      "startOffset" : 95,
      "endOffset" : 241
    }, {
      "referenceID" : 59,
      "context" : "These can be split into three groups: (A) exact algorithms that do not employ any restrictions (Parviainen & Koivisto, 2010; Koivisto, 2006; Yuan, Malone, & Wu, 2011; Ott, Imoto, & Miyano, 2004; Silander & Myllymäki, 2006; Yuan et al., 2011), (B) exact algorithms using restrictions on the generating or target distribution (Pieter et al.",
      "startOffset" : 95,
      "endOffset" : 241
    }, {
      "referenceID" : 52,
      "context" : ", 2011), (B) exact algorithms using restrictions on the generating or target distribution (Pieter et al., 2006; Chechetka & Guestrin, 2007; Friedman, Nachman, & Pe’er, 1999; Chow & Liu, 1968; Gaspers, Koivisto et al., 2012), and (C) exact algorithms that use restrictions on the undirected super-structure (Friedman et al.",
      "startOffset" : 90,
      "endOffset" : 223
    }, {
      "referenceID" : 24,
      "context" : ", 2012), and (C) exact algorithms that use restrictions on the undirected super-structure (Friedman et al., 1999; Kojima, Perrier, Imoto, & Miyano, 2010).",
      "startOffset" : 90,
      "endOffset" : 153
    }, {
      "referenceID" : 52,
      "context" : "Apart from exact algorithms there also exists a variety of approximation algorithms using tree decomposition or degree-based techniques (Pieter et al., 2006; Elidan & Gould, 2008; Karger & Srebro, 2001).",
      "startOffset" : 136,
      "endOffset" : 202
    }, {
      "referenceID" : 24,
      "context" : ", 2012), and (C) exact algorithms that use restrictions on the undirected super-structure (Friedman et al., 1999; Kojima, Perrier, Imoto, & Miyano, 2010). Algorithms falling into group (A) are only suited for small to medium sized Bayesian networks because they do not restrict the search space in any way. On the other hand, the restrictions used by algorithms in group (B) are more general than restrictions coming from the undirected super-structure and up to now only non-uniform polynomial-time algorithms could be obtained using these restrictions. To the best of our knowledge this paper is the first to employ an in-depth theoretical analysis of the parameterized complexity of BNSL using restrictions on the undirected super-structure. We obtain the first algorithm for exact BNSL with a uniform polynomial running-time with respect to structural restriction on the undirected superstructure. A similar approach has been taken by Kojima et al. (2010), where the authors propose an algorithm for exact BNSL that uses a “cluster-decomposition” of the undirected super-structure.",
      "startOffset" : 91,
      "endOffset" : 960
    }, {
      "referenceID" : 9,
      "context" : "In particular, BNSL remains NP-hard if the in-degree of the resulting Bayesian network is bounded by 2 (Chickering, 1996), and if the resulting Bayesian network is a poly tree (Dasgupta, 1999), or a directed path (Meek, 2001).",
      "startOffset" : 103,
      "endOffset" : 121
    }, {
      "referenceID" : 12,
      "context" : "In particular, BNSL remains NP-hard if the in-degree of the resulting Bayesian network is bounded by 2 (Chickering, 1996), and if the resulting Bayesian network is a poly tree (Dasgupta, 1999), or a directed path (Meek, 2001).",
      "startOffset" : 176,
      "endOffset" : 192
    }, {
      "referenceID" : 45,
      "context" : "In particular, BNSL remains NP-hard if the in-degree of the resulting Bayesian network is bounded by 2 (Chickering, 1996), and if the resulting Bayesian network is a poly tree (Dasgupta, 1999), or a directed path (Meek, 2001).",
      "startOffset" : 213,
      "endOffset" : 225
    }, {
      "referenceID" : 47,
      "context" : "It has been introduced and pioneered by Downey and Fellows (1999) and is receiving growing interest as reflected by the recent publication of two further monographs (Flum & Grohe, 2006; Niedermeier, 2006) and hundreds of research papers (see references in the above mentioned monographs).",
      "startOffset" : 165,
      "endOffset" : 204
    }, {
      "referenceID" : 17,
      "context" : "It has been introduced and pioneered by Downey and Fellows (1999) and is receiving growing interest as reflected by the recent publication of two further monographs (Flum & Grohe, 2006; Niedermeier, 2006) and hundreds of research papers (see references in the above mentioned monographs).",
      "startOffset" : 40,
      "endOffset" : 66
    }, {
      "referenceID" : 14,
      "context" : "Elimination (Dechter, 1999) and Recursive Conditioning (Darwiche, 2001) are two important algorithmic concepts that apply to instances of bounded treewidth.",
      "startOffset" : 12,
      "endOffset" : 27
    }, {
      "referenceID" : 11,
      "context" : "Elimination (Dechter, 1999) and Recursive Conditioning (Darwiche, 2001) are two important algorithmic concepts that apply to instances of bounded treewidth.",
      "startOffset" : 55,
      "endOffset" : 71
    }, {
      "referenceID" : 3,
      "context" : "Given a graph G with n nodes and a constant w, it is possible to decide whether G has treewidth at most w, and if so, to compute an optimal tree decomposition of G in time O(n) (Bodlaender, 1996).",
      "startOffset" : 177,
      "endOffset" : 195
    }, {
      "referenceID" : 38,
      "context" : "We closely follow the abstract framework used by Parviainen and Koivisto (2010) which encloses a wide range of score-based approaches to structure learning.",
      "startOffset" : 64,
      "endOffset" : 80
    }, {
      "referenceID" : 8,
      "context" : "This setting accommodates several popular scores like BDe, BIC and AIC (Parviainen & Koivisto, 2010; Chickering, 1995).",
      "startOffset" : 71,
      "endOffset" : 118
    }, {
      "referenceID" : 58,
      "context" : "This representation is also used in other fields, for instance in constraint satisfaction, where only allowed tuples of constraints are listed in the input (Tsang, 1993).",
      "startOffset" : 156,
      "endOffset" : 169
    }, {
      "referenceID" : 37,
      "context" : "When presenting algorithms for graphs of bounded treewidth it is convenient to consider tree decompositions in the following normal form (Kloks, 1994): A triple (T, χ, r) is a nice tree decomposition of a graph G if (T, χ) is a tree decomposition of G, the tree T is rooted at node r, and each node of T is of one of the following four types:",
      "startOffset" : 137,
      "endOffset" : 150
    }, {
      "referenceID" : 37,
      "context" : "Because these propositions are well-known (Kloks, 1994) and are immediate consequences of the separator property of tree decompositions we state them without proofs.",
      "startOffset" : 42,
      "endOffset" : 55
    }, {
      "referenceID" : 37,
      "context" : "Given a tree decomposition of a graph G of width w, one can effectively obtain in time O(|V (G)|) a nice tree decomposition of G with O(|V (G)|) nodes and of width at most w (Kloks, 1994).",
      "startOffset" : 174,
      "endOffset" : 187
    }, {
      "referenceID" : 11,
      "context" : "The treewidth of a Bayesian network is the treewidth of its moral graph (Darwiche, 2001; Dechter, 1999).",
      "startOffset" : 72,
      "endOffset" : 103
    }, {
      "referenceID" : 14,
      "context" : "The treewidth of a Bayesian network is the treewidth of its moral graph (Darwiche, 2001; Dechter, 1999).",
      "startOffset" : 72,
      "endOffset" : 103
    }, {
      "referenceID" : 8,
      "context" : "The following result follows by a reduction due to Chickering (1996).",
      "startOffset" : 51,
      "endOffset" : 69
    }, {
      "referenceID" : 34,
      "context" : "The problem is NP-hard for digraphs with skeletons of maximum degree 4 (Karp, 1972).",
      "startOffset" : 71,
      "endOffset" : 83
    }, {
      "referenceID" : 53,
      "context" : "We devise an fpt-reduction from the following problem, which is well-known to be W[1]-complete (Pietrzak, 2003).",
      "startOffset" : 95,
      "endOffset" : 111
    }, {
      "referenceID" : 43,
      "context" : "For instance, k-local search has already been investigated for combinatorial problems on graphs (Khuller, Bhatia, & Pless, 2003; Marx, 2008; Fellows, Rosamond, Fomin, Lokshtanov, Saurabh, & Villanger, 2009; Gaspers, Kim, Ordyniak, Saurabh, & Szeider, 2012), for the problem of finding a minimum weight assignment for a Boolean constraint satisfaction instance (Krokhin & Marx, 2012), for the stable marriage problem with ties (Marx & Schlotter, 2011), and for the satisfiability problem (Szeider, 2011).",
      "startOffset" : 96,
      "endOffset" : 256
    }, {
      "referenceID" : 55,
      "context" : "For instance, k-local search has already been investigated for combinatorial problems on graphs (Khuller, Bhatia, & Pless, 2003; Marx, 2008; Fellows, Rosamond, Fomin, Lokshtanov, Saurabh, & Villanger, 2009; Gaspers, Kim, Ordyniak, Saurabh, & Szeider, 2012), for the problem of finding a minimum weight assignment for a Boolean constraint satisfaction instance (Krokhin & Marx, 2012), for the stable marriage problem with ties (Marx & Schlotter, 2011), and for the satisfiability problem (Szeider, 2011).",
      "startOffset" : 487,
      "endOffset" : 502
    }, {
      "referenceID" : 8,
      "context" : "Important and widely used algorithms for BNSL are based on local search methods (Heckerman, Geiger, & Chickering, 1995). Usually the local search algorithm tries to improve the score of a given dag by transforming it into a new dag by adding, deleting, or reversing one arc at a time (in symbols: add, del, and rev, respectively). The main obstacle for local search methods is the danger of getting stuck at a poor local optimum. A possibility for decreasing this danger is to perform k > 1 elementary changes in one step, known as kNeighborhood Local Search or k-Local Search for short. For BNSL, when we try to improve the score of a dag on n nodes, the k-local search space is of order nO(k). Therefore, if carried out by brute-force, k-local search is too costly even for small values of k. It is therefore not surprising that most practical local search algorithms for BNSL consider 1-neighborhoods only. The study of the parameterized complexity of k-local search was initiated by Fellows (2003). To date a collection of positive and negative results on the parameterized complexity of k-local search for various combinatorial optimization problems are known.",
      "startOffset" : 102,
      "endOffset" : 1002
    }, {
      "referenceID" : 17,
      "context" : "However, recently we found out that this problem is in fact fixed-parameter tractable and that the proof published in the work of Downey and Fellows (1995) contained a mistake (Fellows, 2012).",
      "startOffset" : 130,
      "endOffset" : 156
    }, {
      "referenceID" : 55,
      "context" : "Theorem 6 provides a surprising contrast to a similar study of k-local search for MAX-SAT where the problem is fixed-parameter tractable for instances of bounded degree (Szeider, 2011).",
      "startOffset" : 169,
      "endOffset" : 184
    } ],
    "year" : 2013,
    "abstractText" : "Bayesian network structure learning is the notoriously difficult problem of discovering a Bayesian network that optimally represents a given set of training data. In this paper we study the computational worst-case complexity of exact Bayesian network structure learning under graph theoretic restrictions on the (directed) super-structure. The super-structure is an undirected graph that contains as subgraphs the skeletons of solution networks. We introduce the directed super-structure as a natural generalization of its undirected counterpart. Our results apply to several variants of score-based Bayesian network structure learning where the score of a network decomposes into local scores of its nodes. Results: We show that exact Bayesian network structure learning can be carried out in non-uniform polynomial time if the super-structure has bounded treewidth, and in linear time if in addition the super-structure has bounded maximum degree. Furthermore, we show that if the directed super-structure is acyclic, then exact Bayesian network structure learning can be carried out in quadratic time. We complement these positive results with a number of hardness results. We show that both restrictions (treewidth and degree) are essential and cannot be dropped without loosing uniform polynomial time tractability (subject to a complexity-theoretic assumption). Similarly, exact Bayesian network structure learning remains NP-hard for “almost acyclic” directed super-structures. Furthermore, we show that the restrictions remain essential if we do not search for a globally optimal network but aim to improve a given network by means of at most k arc additions, arc deletions, or arc reversals (k-neighborhood local search).",
    "creator" : "TeX"
  }
}