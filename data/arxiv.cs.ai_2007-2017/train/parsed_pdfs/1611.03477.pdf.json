{
  "name" : "1611.03477.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "SONG FROM PI: A MUSICALLY PLAUSIBLE NETWORK FOR POP MUSIC GENERATION",
    "authors" : [ "Hang Chu", "Raquel Urtasun", "Sanja Fidler" ],
    "emails" : [ "chuhang1122@cs.toronto.edu", "urtasun@cs.toronto.edu", "fidler@cs.toronto.edu" ],
    "sections" : [ {
      "heading" : "1 INTRODUCTION",
      "text" : "Neural networks have revolutionized many fields. They have not only proven to be powerful in performing perception tasks such as image classification and language understanding, but have also shown to be surprisingly good “artists”. In Gatys et al. (2015), photos were turned into paintings by exploiting particular drawing styles such as Van Gogh’s, Kiros et al. (2015) produced stories about images biased by writing style (e.g., romance books), Karpathy et al. (2016) wrote Shakespeare inspired novels, and Simo-Serra et al. (2015) gave fashion advice.\nMusic composition is another artistic domain where neural based approaches have been proposed. Early approaches exploiting Recurrent Neural Networks (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)) date back to the 80’s. The main variations between the different models is the representation of the notes and the outputs they produced, which typically encode melody and chord. Most of these approaches were single track, in that they produced only one note per time step. The exception is Boulanger-lewandowski et al. (2012) which generated polyphonic music, i.e., simultaneous independent melodies.\nIn this paper, we aim to generate pop music, where the melody but also chords and other instruments make up what is typically called a song. We draw inspiration from the Song from π by Macdonald 1, a piano video on Youtube, where the pleasing music is created from a sequence of digits of π. This video shows both the randomness and the regularity of music. On one hand, since any possible digit sequence is a subset of the π digit sequence, this implies that pleasing music can be created even from a totally random base signal. On the other hand, the composer uses specific rules such as A Harmonic Minor scale and harmonies to convert the digit sequence into a music sheet. It is these rules that play the key role in converting randomness into music.\nFollowing the ideas of Songs from π, we aim to generate both the melody as well as accompanying effects such as chords and drums. Arguably, these turn even a not particularly pleasing melody into a well sounding song. We propose a hierarchical approach, where each level is a Recurrent Neural Network producing a key aspect of the song. The bottom layers generate the melody, while the higher levels produce drums and chords. This enables the drum and chord layers to compensate for the melody in order to produce appleasing music. Adopting the key idea from Songs from π, we condition our model on the scale type allowing the melody generator to learn the notes that are typically played in a particular scale.\n1https://youtu.be/OMq9he-5HUU\nar X\niv :1\n61 1.\n03 47\n7v 1\n[ cs\n.S D\n] 1\n0 N\nov 2\n01 6\nWe train our model on 100 hours of midi music containing user-composed pop songs and video game music. We conduct human studies with music generated with our approach and compare it against a recent approach by Google, showing that our songs are strongly preferred over the baseline. In our human study we also perform an ablation analysis of our model. We additionally show two new applications: neural dancing and karaoke as well as neural music singing. As part of the first application we generate a stickman dancing to our music and lyrics that can be sung with, while in the second application we condition on the output of Kiros et al. (2015) which writes a story about an image and convert it into a pop song. We refer the reader to http://www.cs.toronto.edu/songfrompi/ for our demos and results."
    }, {
      "heading" : "2 RELATED WORK",
      "text" : "Generating music has been an active research area for decades. It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)).\nEarly approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)). Mozer (1996) used a Recurrent Neural Network that produced pitch, duration and chord at each time step. Unlike most other neural network approaches, this work encodes music knowledge into the representation. Eck & Schmidhuber (2002) was first to use LSTMs to generate both melody and chord. Compared to Mozer (1996), the LSTM captured more global music structure across the song.\nLike us, Kang et al. (2012) built upon the randomness of melody by trying to accompany it with drums. However, in their model the scale type is enforced. No details about the model are presented, and thus it is virtually impossible to compare to. Boulanger-lewandowski et al. (2012) propose to learn complex polyphonic musical structure which has multiple notes playing in parallel through the song. The model is single-track in that it only produces melody, whereas in our work we aim to produce multi-track songs. Just recently, Huang & Wu (2016) proposed a 2-layer LSTM that, like Boulanger-lewandowski et al. (2012), produces music that is more complex than a single note sequence, and is able to produce chords. The main novelty of our work over existing approaches is a hierarchical model that incorporates knowledge from music theory to build the neural architecture, and produces multi-track pop music (melody, chord and drum). We also present two novel fun applications."
    }, {
      "heading" : "3 CONCEPTS FROM MUSIC THEORY",
      "text" : "We start by introducing the basic notation and definitions from music theory. A note defines the basic unit that music is composed of. Music follows the 12-tone system, i.e., 12 is the cycle length of all notes. The 12 tones are: C, C]/D[, D, D]/E[, E, F , F ]/G[, G, G]/A[, A, A]/B[, B. A bar is a short segment of time that corresponds to a specific number of beats (notes). The boundaries of the bar are indicated by vertical bar lines.\nScale is a subset of notes. There are four types of scales most commonly used: Major (Minor), Harmonic Minor, Melodic Minor and Blues. Each scale type specifies a sequence of relative intervals (or shifts) which act relative to the starting note. For example, the sequence for the scale type Major is 2→ 2→ 1→ 2→ 2→ 2→ 1. Thus, C Major specifies the starting note to be C, and applying the relative sequence of shifts yields: C 2−→ D 2−→ E 1−→ F 2−→ G 2−→ A 2−→ B 1−→ C. The subset of notes specified by C Major is thus C, D, E, F, G, A, and B (a subset of seven notes). All scales types have a subset of seven notes except for Blues which has six. In total we have 48 unique scales, i.e. 4 scale types and 12 possible starting notes. We treat Major and Minor as one type as for a Major scale there is always a Minor that has exactly the same set of notes. In music theory, this is referred to as Relative Minor.\nChord is a group of notes that sound good together. Similarly to scale, a chord has a start note and a type defining a set of intervals. There are mainly 6 types in triads chords: Major Chord, Minor Chord, Augmented Chord, Diminished Chord, Suspended 2nd Chord, and Suspended 4th Chord.\nThe Circle of Fifths is often used to produce a chord progression. It maps 12 chord starting notes to a circle. When changing from one chord to another chord, moving to a nearby chord on the circle is often preferred as this forms a strong chord progression that produces the sense of harmony."
    }, {
      "heading" : "4 HIERARCHICAL RECURRENT NETWORKS FOR POP MUSIC GENERATION",
      "text" : "We follow the high level idea behind the Song from π to define our model. In particular, we generate music with a hierarchical Recurrent Neural Network where the layers and the structure of the hierarchy encode our prior knowledge about how pop music is composed. We first outline the model and describe the details and justifications for our choices in the subsections that follow.\nWe condition our generation on the scale type, as this helps the model to pick up the regularities in pop songs. We encode melody with two random variables at each time step, representing which key is being played (the key layer) and the duration that the key will be pressed (the press layer). The melody is generated conditioned on the scale, which does not vary across the song as is typically the case in pop music. We assume the drums and the chords are independent given the melody. Thus conditioned on the melody, at each time step we generate the chord (the chord layer) as well as the drums (the drum layer). The output at all layers yields the final song. We refer the reader to Fig. 1 for an illustration of our hierarchical model."
    }, {
      "heading" : "4.1 THE ROLE OF SCALE",
      "text" : "It is known from music theory that while in principle each song has 12 tones to choose from, most of the notes are in fact only using the six (for Blues) or seven (for other scales) tone subsets specified by the scale rule. We found that by conditioning the music generator on scale it captures these regularities more easily. However, we do not enforce the notes to be generated from the subset and allow our model to generate notes outside the scale.\nWe confirm the above musical fact by analysing over 100 hours of pop song music from the midi man dataset. Since scale is defined relative to a starting note, we first try to factor out its influence and normalize all songs to have identical start note. To identify the scale of a song, we compute the histogram over the 12 tones and match it with the 48 tone subsets of 4 scale types with 12 different start notes. We then normalize all songs to have start note C by applying a constant shift\non all notes. This allows us to categorize any song into 4 scale types. Since this shift affects all notes at once, it does not affect how the song sounds (its harmony). Our analysis shows that for all notes in all Major scale songs, 94.66% are within the tone subset. For Harmonic Minor, Melodic Minor, and Blues the percentage of notes that belong to the main tone set is 87.16%, 85.11%, and 90.93%, respectively. We refer the reader to Fig. 2, where the x-axis denotes the percentage of within-scale notes of a song, and the y-axis indicates how many songs in the dataset have that percentage. Note that the majority of the notes follow the scale rule. Furthermore, different scale types have different inlier distribution. We thus represent scale with a single random variable s ∈ {1, · · · , 4} which is fixed for the whole song, and condition the model on it. 2"
    }, {
      "heading" : "4.2 TWO-LAYER RNN FOR MELODY GENERATION",
      "text" : "We represent the melody with two random variables per time step: which key is pressed, and the duration of the press. A Recurrent Neural Network (RNN) is used to generate the key condition on the scale. Then conditioned on the output of the key layer, a second RNN generates the duration of the press at each time step.\nIn this paper we take advantage of LSTMs, which in their most basic form (single layer) compute the hidden state ht given the input xt by\nf t = σ(Wf [x t, ht−1]) (1)\nit = σ(Wi[x t, ht−1])\not = σ(Wo[x t, ht−1])\nC̃t = tanh(WC [x t, ht−1])\nCt = f t Ct−1 + it C̃t\nht = ot tanh(Ct)\nwith Wf ,Wi,Wo,WC learnable parameters. Here f , i, o, C, C̃, and h denote the forget gate, input gate, output gate, cell state, input cell state and hidden state.\nIn particular, we model the key layer with a two-layer LSTM with 512-dimensional hidden state, which outputs a note (key) at each time step. Note that we condition on scale s, thus we have different parameters per scale. We only allow notes between C3 to C6 as notes outside this range are usually too low or too high to sound good. We remind the reader that given a scale, seven (or six for blues) out of the twelve notes (per octave) are statistically more plausible, however we allow the model to choose from all 12. This results in a 37-dimensional output, as there are 36 possible notes corresponding to 3 octaves with 12 notes per octave, plus silence. Let htkey be the hidden state of the second key decoder layer at time t. We compute the probability of each key using the softmax:\nP (ytkey) ∝ exp(vytkeyh t key) (2)\nwhere vytkey is the row of V (the output embedding matrix of notes), corresponding to note y t key .\nAs input to the LSTM we use a vector that concatenates multiple features: a one-hot encoding of the previous generated note yt−1key , Lookback features, and the melody profile. The Lookback features were proposed by Google Magenta (Waite et al.) to make it easier for the model to memorize recently produced notes and potentially repeat them. They include skip connections from two and one bar ago (a bar is 8 consecutively played notes), i.e., yt−16key and y t−8 key . They also contain two additional features, indicating whether the last generated key has been copied from one or two bars ago, i.e. 1(yt−1key ,y t−1−8 key ) and 1(y t−1 key ,y t−1−16 key ). They also add a 5-dimensional feature indicating a binary encoding of the current time t. This helps the model keep track where in a 4−bar range it is, and thus produce music accordingly.\nIn addition, we introduce a new feature which we refer to as the melody profile. Intuitively, the profile represents the high-level music flow. To get the profile for each song, we compute the local note histogram at each time step with width of two bars, and cluster all local histograms within the\n2For readers with musical background, the Twelve-Tone Serialism technique Schoenberg & Newlin (1951) prevents emphasis of any one tone. However, our data analysis indicates that pop music is not influenced by it.\nsong into 10 clusters via k-means. We order the 10 clusters with mean note ordered from low to high as cluster 1 to 10, and apply moving averages on the cluster id sequence to encourage local smoothness. This results in a 10-dimensional one-hot vector representation of the cluster id for each time step. This additional information allows the user to set the melody’s ups and downs of the song.\nThe keys alone are not sufficient to describe how the melody is performed. Additionally we also need to know the duration that each key needs to be pressed for. Towards this goal, conditioned on the melody, we generate the duration of each key with a two-layer LSTM with a 512-dimensional hidden state. We represent the duration of pressing as a forward counting sequence that is conditioned on the generated melody. The press outputs 1 when a new key is pressed, and sequentially outputs 2, 3, 4 and so on as the key is held on. When the current key is released, the press counter is reset to 1. Compared to the event on-off representation of Waite et al., our representation learns the melody flow and how to press separately. This is important, as Waite et al. has extremely unbalanced output distributions dominated by the repeat-of-holding event. We represent press ytprs as a 8-dimensional one-hot vector. The input to our LSTM is yt−1prs , concatenated with the 37-dimensional one-hot encoding of the melody key ytkey ."
    }, {
      "heading" : "4.3 CHORD AND DRUM RNN LAYERS",
      "text" : "We studied all existing chords in our 100 hours of pop music. Although in principle a chord can be any arbitrary combination of multiple notes, we observed that in the actual music data 99.19% of the chords belong to one of 72 chord classes (6 types × 12 start notes). Fig. 3 shows the correlation between the melody’s tone and the starting note of the chord playing at the same time. It can be seen that chord is strongly correlated with melody. These two findings inspire our design. We thus represent chord ytchd as a one-hot encoding with 72 classes, and predict it using a two-layer LSTM with a 512-dimensional hidden state. We generate one chord at each time step. The input is yt−4chd concatenated with yt−3:tkey .\nWe look at our music dataset and find all unique drum patterns with duration of a half bar. We then compute the histogram of all the patterns. This forms a long tail distribution, where 94.60% comes from the top 100 common patterns. We generate drum conditioned on the key layer using a twolayer LSTM with 512 dimensional hidden states. Drum ytdrm is represented as one-hot encoding\nwith of the 100 unique one-bar-long drum patterns. The input is yt−4drm concatenated with the notes from the previous three times steps yt−3:tkey ."
    }, {
      "heading" : "4.4 LEARNING",
      "text" : "We use cross-entropy as our loss function to train each layer. We follow the typical training strategy where we make predictions at each layer and time step but feed in ground-truth information to the next. This effectively decomposes training, and allows to train all layers in parallel. We use the Adam optimizer, a learning rate of 2e-3 and a learning rate decay of 0.99 after each epoch for 10 epochs."
    }, {
      "heading" : "4.5 MUSIC SYNTHESIS: PUTTING ALL THE OUTPUTS TOGETHER",
      "text" : "To synthesize music we first randomly choose a scale and a profile xprf . For generating xprf , we randomly choose one cluster id with a random duration, and repeat until we get the desired total length of the music sequence. We then perform inference in our model conditioned on the chosen scale, and use xprf as input to our key layer. At each time step, we sample a key according to P (ytkey). We encode it as a one-hot vector and pass to the press, chord and drum layers. We sample the press, chords and drums at each time step in a similar fashion.\nBefore putting the outputs across layers together, we further adjust the generated sequences at the bar level. For melody, we first check at each bar if the first step is a continuation of a previous note or silence. If it is the latter, we find the first newly pressed note within the bar and move it to the beginning of the bar. We do similarly for the windows of two half-bars as well as the four quarterbars. This makes the melody more likely to be on the beat, and generally sounds better. We verify this in our experiments.\nFor chord, we generate one chord at each half bar, which is the majority of all single step chord generations. Furthermore, we incorporate the rule of chord progression in the Circle of Fifths as between chords pairwise smooth terms, and compute the final chord using dynamic programming. For drum, we generate one pattern at each half bar.\nOur model generates with scale starting note C, and then applies a constant shift to generate music with other starting notes. Besides scale, which instrument to use is also customizable. However, we simply set all instruments as grand piano in all experiments, as the effect and musical meaning of different instrument combinations is beyond the scope of this paper."
    }, {
      "heading" : "5 EXPERIMENTS",
      "text" : "To train our model, we took 100 hours of pop music from midi man which consists of user-composed pop songs and video game music. In our generation, we always use 120 beats per minute with 4 time steps per beat. However, songs in the dataset can have arbitrary speed. To neutralize the effect of this, we detect the most frequent interval between two adjacent notes for each song, and iteratively divide or multiply this interval by 2 until it falls in the range between 0.25s and 0.5s. We use this as a measure of the song’s beat duration. We then adjust the song’s temporal axis so that all songs have the same beat duration of 0.5s.\nA MIDI file can be separated into different channels/tracks, where the 9th channel is specifically preserved for drums. We categorize the rest of non-drum tracks into melody, chord, and else, by simply setting thresholds on average number of unique notes within a bar and average number of note changing within a bar, as chords are by definition repetitive. Fig. 4 shows an example of our music generation.\nTo evaluate the quality of our music generation, we conduct a human survey with 27 participants. In the survey, participants are presented with several pairs of 30-second music clips, and are asked to vote which clip in the pair sounds better. We gave no other information about what they are listening to. They are also allow to submit a neutral vote in case they cannot decide between the two choices. In our study, we consider three cases: our full method versus Magenta Waite et al., our method with melody only versus Google Magenta (Waite et al.), and our method versus our method\nwithout the temporal alignment described in Sec.4.5. We randomly generated 10 songs per method and randomly shuffled each pair.\nAs shown in Table 1, most participants prefer songs produced by our method compared to Magenta. Participants also made comments such as music sounds better with percussion than piano alone, and multiple instruments with continuous play is much better. This confirms that our multi-layer generation improves music quality. Few participants also point out that drums sound too different and do not participate to the melody perfectly, which indicates that further improvements can be still made. In the second comparison, we study if the quality improvement of our method is only caused by adding chords and drums, or is also related to our two-layer melody generation with alignment. It can be seen that without chords and drums, the score drops as expected, but is still much higher than the Magenta baseline. This is because our method produces less recursion and silence, and faster and more accurate tempo as mentioned by the participants. In the last comparison, most participants prefer our full method than the no-alignment version, since beats are more subtle and better timed. This proves the usefulness of temporal alignment.\nFinally we study our model’s capabilities to generate new music. Towards this goal, we generated 100 sequences of 50 seconds of length using different random initializations. Then for each sequence, we search for the longest sub-sequence of keys that matches part of the training data, and record its length. We find out that with 1 hour of training data, the mean matching sub-sequence length is 3.46s. With 100 hours of training data, the mean length increases to 4.65s, since there are more possible matches. The sequences are very small and thus, our model is able to generate new music."
    }, {
      "heading" : "6 APPLICATIONS",
      "text" : "In this section we demonstrate two novel applications of our pop music generation framework. We refer the reader to http://www.cs.toronto.edu/songfrompi/ for the music videos."
    }, {
      "heading" : "6.1 NEURAL DANCING AND KARAOKE",
      "text" : "In our first application, we attempt to generate both music and a stickman dancing to it, as well as a sequence of karaoke-like text that people can sing along with. To learn the relationship between music and dance, we download 1 hour of video from the game Just Dance, as well as the MIDI files for songs included in the video from different sources. We use the method in Newell et al. (2016) to track single-frame 2D human pose in the videos. We process the single-frame tracking result to ensure left-right body consistency through time, and then use the method of Zhou et al. (2016) to convert the 2D pose sequence into 3D. Example results are shown in Fig. 5. We observe that our\npose processing pipeline is able to extract reasonable human poses most of the time. However, the quality is not perfect due to tracking failure or video effects. We define pose similarity as average euclidean distance of all joints, and cluster poses into 456 clusters. We used Frey & Dueck (2007) as the number of clusters is large.\nWe learn to generate a stickman dancing by adding another dancing layer on top of the key layer, just like for drum and chord. We generate one pose at each beat, which is equivalent to 4 time steps or 0.5 seconds in a 120 beat-per-minute music. In particular, we predict one of the 456 pose clusters using a linear projection layer followed by softmax. We use cross-entropy at each time step as our loss function. At inference time, we further apply moving average to temporally smooth the generated 3D pose sequence.\nTo learn the relationship between music and lyrics, we collect 51 hours of lyrics data from the internet. This data contains 50 hours of text without music, and the rest 1 hour are songs we collected from Just Dance. For the music part, we temporally align each sentence in the lyrics with the midi music by using the widely-existing lrc format, which records the time tag at the beginning of every sentence. We select words that appear at least 4 times, which yields a vocabulary size of 3390 including unknown and end-of-sentence. Just as for dance, we generate one word per beat using another lyrics layer on top of the key layer."
    }, {
      "heading" : "6.2 NEURAL STORY SINGING",
      "text" : "In this application our aim is to sing a song about a photo. We first generate a story about the photo with the neural storyteller Kiros et al. (2015) and try to accompany the generated text with music. We utilize the same 1 hour dataset of temporally aligned lyrics and music. We further include the phoneme list of our 3390 vocabulary as we also want to sing the story. Starting from the text produced by neural storyteller, we arrange it into a temporal sequence with 1 beat per word and a short pause for end-of-sentence, where the pause length is decided such that the next sentence starts from a new bar. As our dataset is relatively small, we generate the profile conditioned on the text, which has less dimensions compared to the key. This is done by a 2-layer LSTM that takes as input the generated profile at the last time step concatenated with a one-hot vector of the current word, and outputs the current profile. We then generate the song with our model given the generated profile. The generated melody key is then used to decide on the pitch frequency of a virtual singer, assuming the key-to-pitch correspondence of a grand piano. We further constrain that the singer’s final pitch is always in the range of E3 to G4, which we empirically found to be the natural pitch range. We then replace all words outside the vocabulary with the sound Ooh, and play the rendered singing with the generated music."
    }, {
      "heading" : "7 CONCLUSION AND FUTURE WORK",
      "text" : "We have presented a hierarchical approach to pop song generation which exploits music theory in the model design. In contrast to past work, our approach is able to generate multi-track music. Our human studies shows the strength of our framework compared to an existing strong baseline. We additionally proposed two new applications: neural dancing & karaoke, and neural story singing. We next discuss the limitations and avenues for future work. As most existing approaches our method’s objective is to learn to produce music at the note level. This can be unsuitable for music, as music is flexible and intentionally made to be unpredictable when it is composed. This calls for a deeper study of music theory, as in this paper we are only scratching the surface."
    } ],
    "references" : [ {
      "title" : "Modeling the perception of tonal structure with neural nets",
      "author" : [ "Jamshed J. Bharucha", "Peter M. Todd" ],
      "venue" : "Computer Music Journal,",
      "citeRegEx" : "Bharucha and Todd.,? \\Q1989\\E",
      "shortCiteRegEx" : "Bharucha and Todd.",
      "year" : 1989
    }, {
      "title" : "Modeling temporal dependencies in high-dimensional sequences: Application to polyphonic music generation and transcription",
      "author" : [ "Nicolas Boulanger-lewandowski", "Yoshua Bengio", "Pascal Vincent" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Boulanger.lewandowski et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Boulanger.lewandowski et al\\.",
      "year" : 2012
    }, {
      "title" : "Improving algorithmic music composition with machine learning",
      "author" : [ "Michael Chan", "John Potter", "Emery Schubert" ],
      "venue" : "In 9th International Conference on Music Perception and Cognition,",
      "citeRegEx" : "Chan et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Chan et al\\.",
      "year" : 2006
    }, {
      "title" : "Creating melodies with evolving recurrent neural networks",
      "author" : [ "Chun-Chi J. Chen", "Risto Miikkulainen" ],
      "venue" : "In International Joint Conference on Neural Networks,",
      "citeRegEx" : "Chen and Miikkulainen.,? \\Q2001\\E",
      "shortCiteRegEx" : "Chen and Miikkulainen.",
      "year" : 2001
    }, {
      "title" : "A first look at music composition using lstm recurrent neural networks",
      "author" : [ "Douglas Eck", "Juergen Schmidhuber" ],
      "venue" : null,
      "citeRegEx" : "Eck and Schmidhuber.,? \\Q2002\\E",
      "shortCiteRegEx" : "Eck and Schmidhuber.",
      "year" : 2002
    }, {
      "title" : "Automatic real-time music generation for games",
      "author" : [ "Steve Engels", "Fabian Chan", "Tiffany Tong" ],
      "venue" : "In AIIDE Workshop,",
      "citeRegEx" : "Engels et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Engels et al\\.",
      "year" : 2015
    }, {
      "title" : "Clustering by passing messages between data points",
      "author" : [ "Brendan J Frey", "Delbert Dueck" ],
      "venue" : null,
      "citeRegEx" : "Frey and Dueck.,? \\Q2007\\E",
      "shortCiteRegEx" : "Frey and Dueck.",
      "year" : 2007
    }, {
      "title" : "A neural algorithm of artistic style",
      "author" : [ "Leon A. Gatys", "Alexander S. Ecker", "Matthias Bethge" ],
      "venue" : "In arXiv:1508.06576,",
      "citeRegEx" : "Gatys et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Gatys et al\\.",
      "year" : 2015
    }, {
      "title" : "Deep learning for music",
      "author" : [ "Allen Huang", "Raymond Wu" ],
      "venue" : "arXiv preprint arXiv:1606.04930,",
      "citeRegEx" : "Huang and Wu.,? \\Q2016\\E",
      "shortCiteRegEx" : "Huang and Wu.",
      "year" : 2016
    }, {
      "title" : "Automatic Music Generation and Machine Learning Based Evaluation, pp. 436–443",
      "author" : [ "Semin Kang", "Soo-Yol Ok", "Young-Min Kang" ],
      "venue" : null,
      "citeRegEx" : "Kang et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Kang et al\\.",
      "year" : 2012
    }, {
      "title" : "Visualizing and understanding recurrent networks",
      "author" : [ "Andrej Karpathy", "Justin Johnson", "Li Fei-Fei" ],
      "venue" : "In ICLR 2016 Workshop,",
      "citeRegEx" : "Karpathy et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Karpathy et al\\.",
      "year" : 2016
    }, {
      "title" : "Skip-thought vectors",
      "author" : [ "Ryan Kiros", "Yukun Zhu", "Ruslan R Salakhutdinov", "Richard Zemel", "Raquel Urtasun", "Antonio Torralba", "Sanja Fidler" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Kiros et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Kiros et al\\.",
      "year" : 2015
    }, {
      "title" : "Neural network music composition by prediction: Exploring the benefits of psychoacoustic constraints and multi-scale processing",
      "author" : [ "Michael C. Mozer" ],
      "venue" : "Connection Science,",
      "citeRegEx" : "Mozer.,? \\Q1996\\E",
      "shortCiteRegEx" : "Mozer.",
      "year" : 1996
    }, {
      "title" : "Stacked hourglass networks for human pose estimation",
      "author" : [ "Alejandro Newell", "Kaiyu Yang", "Jia Deng" ],
      "venue" : "In ECCV,",
      "citeRegEx" : "Newell et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Newell et al\\.",
      "year" : 2016
    }, {
      "title" : "Style and idea",
      "author" : [ "Arnold Schoenberg", "Dika Newlin" ],
      "venue" : "Technical report, Williams and Norgate London,",
      "citeRegEx" : "Schoenberg and Newlin.,? \\Q1951\\E",
      "shortCiteRegEx" : "Schoenberg and Newlin.",
      "year" : 1951
    }, {
      "title" : "Neuroaesthetics in fashion: Modeling the perception of beauty",
      "author" : [ "Edgar Simo-Serra", "Sanja Fidler", "Francesc Moreno-Noguer", "Raquel Urtasun" ],
      "venue" : "In CVPR,",
      "citeRegEx" : "Simo.Serra et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Simo.Serra et al\\.",
      "year" : 2015
    }, {
      "title" : "Sparseness meets deepness: 3d human pose estimation from monocular video",
      "author" : [ "Xiaowei Zhou", "Menglong Zhu", "Spyridon Leonardos", "Kosta Derpanis", "Kostas Daniilidis" ],
      "venue" : null,
      "citeRegEx" : "Zhou et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Zhou et al\\.",
      "year" : 2016
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "In Gatys et al. (2015), photos were turned into paintings by exploiting particular drawing styles such as Van Gogh’s, Kiros et al.",
      "startOffset" : 3,
      "endOffset" : 23
    }, {
      "referenceID" : 6,
      "context" : "In Gatys et al. (2015), photos were turned into paintings by exploiting particular drawing styles such as Van Gogh’s, Kiros et al. (2015) produced stories about images biased by writing style (e.",
      "startOffset" : 3,
      "endOffset" : 138
    }, {
      "referenceID" : 6,
      "context" : "In Gatys et al. (2015), photos were turned into paintings by exploiting particular drawing styles such as Van Gogh’s, Kiros et al. (2015) produced stories about images biased by writing style (e.g., romance books), Karpathy et al. (2016) wrote Shakespeare inspired novels, and Simo-Serra et al.",
      "startOffset" : 3,
      "endOffset" : 238
    }, {
      "referenceID" : 6,
      "context" : "In Gatys et al. (2015), photos were turned into paintings by exploiting particular drawing styles such as Van Gogh’s, Kiros et al. (2015) produced stories about images biased by writing style (e.g., romance books), Karpathy et al. (2016) wrote Shakespeare inspired novels, and Simo-Serra et al. (2015) gave fashion advice.",
      "startOffset" : 3,
      "endOffset" : 302
    }, {
      "referenceID" : 6,
      "context" : "In Gatys et al. (2015), photos were turned into paintings by exploiting particular drawing styles such as Van Gogh’s, Kiros et al. (2015) produced stories about images biased by writing style (e.g., romance books), Karpathy et al. (2016) wrote Shakespeare inspired novels, and Simo-Serra et al. (2015) gave fashion advice. Music composition is another artistic domain where neural based approaches have been proposed. Early approaches exploiting Recurrent Neural Networks (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)) date back to the 80’s.",
      "startOffset" : 3,
      "endOffset" : 496
    }, {
      "referenceID" : 6,
      "context" : "In Gatys et al. (2015), photos were turned into paintings by exploiting particular drawing styles such as Van Gogh’s, Kiros et al. (2015) produced stories about images biased by writing style (e.g., romance books), Karpathy et al. (2016) wrote Shakespeare inspired novels, and Simo-Serra et al. (2015) gave fashion advice. Music composition is another artistic domain where neural based approaches have been proposed. Early approaches exploiting Recurrent Neural Networks (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)) date back to the 80’s.",
      "startOffset" : 3,
      "endOffset" : 510
    }, {
      "referenceID" : 6,
      "context" : "In Gatys et al. (2015), photos were turned into paintings by exploiting particular drawing styles such as Van Gogh’s, Kiros et al. (2015) produced stories about images biased by writing style (e.g., romance books), Karpathy et al. (2016) wrote Shakespeare inspired novels, and Simo-Serra et al. (2015) gave fashion advice. Music composition is another artistic domain where neural based approaches have been proposed. Early approaches exploiting Recurrent Neural Networks (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)) date back to the 80’s.",
      "startOffset" : 3,
      "endOffset" : 538
    }, {
      "referenceID" : 6,
      "context" : "In Gatys et al. (2015), photos were turned into paintings by exploiting particular drawing styles such as Van Gogh’s, Kiros et al. (2015) produced stories about images biased by writing style (e.g., romance books), Karpathy et al. (2016) wrote Shakespeare inspired novels, and Simo-Serra et al. (2015) gave fashion advice. Music composition is another artistic domain where neural based approaches have been proposed. Early approaches exploiting Recurrent Neural Networks (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)) date back to the 80’s.",
      "startOffset" : 3,
      "endOffset" : 564
    }, {
      "referenceID" : 1,
      "context" : "The exception is Boulanger-lewandowski et al. (2012) which generated polyphonic music, i.",
      "startOffset" : 17,
      "endOffset" : 53
    }, {
      "referenceID" : 11,
      "context" : "As part of the first application we generate a stickman dancing to our music and lyrics that can be sung with, while in the second application we condition on the output of Kiros et al. (2015) which writes a story about an image and convert it into a pop song.",
      "startOffset" : 173,
      "endOffset" : 193
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al.",
      "startOffset" : 127,
      "endOffset" : 163
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer.",
      "startOffset" : 127,
      "endOffset" : 216
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)).",
      "startOffset" : 127,
      "endOffset" : 392
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)).",
      "startOffset" : 127,
      "endOffset" : 580
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)).",
      "startOffset" : 127,
      "endOffset" : 691
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)).",
      "startOffset" : 127,
      "endOffset" : 705
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)).",
      "startOffset" : 127,
      "endOffset" : 733
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)).",
      "startOffset" : 127,
      "endOffset" : 759
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)). Mozer (1996) used a Recurrent Neural Network that produced pitch, duration and chord at each time step.",
      "startOffset" : 127,
      "endOffset" : 774
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)). Mozer (1996) used a Recurrent Neural Network that produced pitch, duration and chord at each time step. Unlike most other neural network approaches, this work encodes music knowledge into the representation. Eck & Schmidhuber (2002) was first to use LSTMs to generate both melody and chord.",
      "startOffset" : 127,
      "endOffset" : 994
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)). Mozer (1996) used a Recurrent Neural Network that produced pitch, duration and chord at each time step. Unlike most other neural network approaches, this work encodes music knowledge into the representation. Eck & Schmidhuber (2002) was first to use LSTMs to generate both melody and chord. Compared to Mozer (1996), the LSTM captured more global music structure across the song.",
      "startOffset" : 127,
      "endOffset" : 1077
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)). Mozer (1996) used a Recurrent Neural Network that produced pitch, duration and chord at each time step. Unlike most other neural network approaches, this work encodes music knowledge into the representation. Eck & Schmidhuber (2002) was first to use LSTMs to generate both melody and chord. Compared to Mozer (1996), the LSTM captured more global music structure across the song. Like us, Kang et al. (2012) built upon the randomness of melody by trying to accompany it with drums.",
      "startOffset" : 127,
      "endOffset" : 1169
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)). Mozer (1996) used a Recurrent Neural Network that produced pitch, duration and chord at each time step. Unlike most other neural network approaches, this work encodes music knowledge into the representation. Eck & Schmidhuber (2002) was first to use LSTMs to generate both melody and chord. Compared to Mozer (1996), the LSTM captured more global music structure across the song. Like us, Kang et al. (2012) built upon the randomness of melody by trying to accompany it with drums. However, in their model the scale type is enforced. No details about the model are presented, and thus it is virtually impossible to compare to. Boulanger-lewandowski et al. (2012) propose to learn complex polyphonic musical structure which has multiple notes playing in parallel through the song.",
      "startOffset" : 127,
      "endOffset" : 1424
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)). Mozer (1996) used a Recurrent Neural Network that produced pitch, duration and chord at each time step. Unlike most other neural network approaches, this work encodes music knowledge into the representation. Eck & Schmidhuber (2002) was first to use LSTMs to generate both melody and chord. Compared to Mozer (1996), the LSTM captured more global music structure across the song. Like us, Kang et al. (2012) built upon the randomness of melody by trying to accompany it with drums. However, in their model the scale type is enforced. No details about the model are presented, and thus it is virtually impossible to compare to. Boulanger-lewandowski et al. (2012) propose to learn complex polyphonic musical structure which has multiple notes playing in parallel through the song. The model is single-track in that it only produces melody, whereas in our work we aim to produce multi-track songs. Just recently, Huang & Wu (2016) proposed a 2-layer LSTM that, like Boulanger-lewandowski et al.",
      "startOffset" : 127,
      "endOffset" : 1690
    }, {
      "referenceID" : 1,
      "context" : "It brings together machines learning researchers that aim to capture the complex structure of music (Eck & Schmidhuber (2002); Boulanger-lewandowski et al. (2012)), as well as music professionals (Chan et al. (2006)) and enthusiasts (Johnson; Sun) that want to see how far a computer can get to be a real composer. Real-time music generation is also explored for gaming (Engels et al. (2015)). Early approaches mostly instilled knowledge from music theory into generation, by using rules of how music segments can be stitched together in a plausible way, e.g., Chan et al. (2006). On the other hand, neural networks have been used for music generation since the 80’s (Bharucha & Todd (1989); Mozer (1996); Chen & Miikkulainen (2001); Eck & Schmidhuber (2002)). Mozer (1996) used a Recurrent Neural Network that produced pitch, duration and chord at each time step. Unlike most other neural network approaches, this work encodes music knowledge into the representation. Eck & Schmidhuber (2002) was first to use LSTMs to generate both melody and chord. Compared to Mozer (1996), the LSTM captured more global music structure across the song. Like us, Kang et al. (2012) built upon the randomness of melody by trying to accompany it with drums. However, in their model the scale type is enforced. No details about the model are presented, and thus it is virtually impossible to compare to. Boulanger-lewandowski et al. (2012) propose to learn complex polyphonic musical structure which has multiple notes playing in parallel through the song. The model is single-track in that it only produces melody, whereas in our work we aim to produce multi-track songs. Just recently, Huang & Wu (2016) proposed a 2-layer LSTM that, like Boulanger-lewandowski et al. (2012), produces music that is more complex than a single note sequence, and is able to produce chords.",
      "startOffset" : 127,
      "endOffset" : 1761
    }, {
      "referenceID" : 13,
      "context" : "We use the method in Newell et al. (2016) to track single-frame 2D human pose in the videos.",
      "startOffset" : 21,
      "endOffset" : 42
    }, {
      "referenceID" : 13,
      "context" : "We use the method in Newell et al. (2016) to track single-frame 2D human pose in the videos. We process the single-frame tracking result to ensure left-right body consistency through time, and then use the method of Zhou et al. (2016) to convert the 2D pose sequence into 3D.",
      "startOffset" : 21,
      "endOffset" : 235
    }, {
      "referenceID" : 11,
      "context" : "We first generate a story about the photo with the neural storyteller Kiros et al. (2015) and try to accompany the generated text with music.",
      "startOffset" : 70,
      "endOffset" : 90
    } ],
    "year" : 2016,
    "abstractText" : "We present a novel framework for generating pop music. Our model is a hierarchical Recurrent Neural Network, where the layers and the structure of the hierarchy encode our prior knowledge about how pop music is composed. In particular, the bottom layers generate the melody, while the higher levels produce the drums and chords. We conduct several human studies that show strong preference of our generated music over that produced by the recent method by Google. We additionally show two applications of our framework: neural dancing and karaoke, as well as neural story singing.",
    "creator" : "LaTeX with hyperref package"
  }
}