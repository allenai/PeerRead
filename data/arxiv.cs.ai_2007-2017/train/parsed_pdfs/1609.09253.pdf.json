{
  "name" : "1609.09253.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Heuristic with elements of tabu search for Truck and Trailer Routing Problem",
    "authors" : [ "Ivan S. Grechikhin" ],
    "emails" : [ "igrechikhin@hse.ru" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 9.\n09 25\n3v 1\n[ cs\n.A I]\n2 9\nKey words: Truck and Trailer Routing Problem, Site-Dependent, Soft Time Windows, Split Deliveries, Tabu search"
    }, {
      "heading" : "1 Introduction",
      "text" : "Vehicle Routing Problem is a well-known problem in combinatorial optimisation and integer programming. The problem can be secribed as follows: there is a set of customers, where each customer has a demand, there is a set of vehicles, which may serve the demand of customers. Using the information on the distances and costs of travelling between each pair of customers, the goal is to find the solution with minimal total cost. This paper considers one version of the problem, which is called Truck and Trailer Routing Problem (TTRP). The problem in consideration is a real-life problem, and contains a big number of constraints.\n0 National Research University Higher School of Economics. Laboratory of Algorithms and Technologies for Network Analysis. Probationer; E-mail: igrechikhin@hse.ru\n3\nTruck and trailer routing problem has two sets of customers: truck-customers and trailer-customers. Every vehicle, then, consists of a truck and a trailer of some capacities (sometimes trailer capacity is zero, which means the vehicle does not have a trailer). Truck-customers can not be served by a vehicle with a trailer. It means that the vehicle should not have trailer from the start, or the trailer should be left at some other place before visiting a truck-customer. This requirement is explained by the fact that there may be small stores, that do not have place for vehicle with its trailer. A vehicle with a trailer has a possibility to leave the trailer at a transshipment location, which is basically a special place to leave trailers. Another opportunity is to leave trailer at a previous trailer-customer: in this case the trailer may be unloaded at the trailer-customer and, at the same time, the truck goes to a truck-customer and serves it in parallel with the trailer-customer. Such rules create a necessity to organize load transfer - the operation, where goods are transferred from truck to trailer or vice versa. This may happen, because, for example, the total weight of goods for truck-customers in one route is more than the capacity of the truck.\nIn the considered problem, the Heterogeneous Fleet of vehicles is present (HFTTRP). This problem differs from homogeneous fleet TTRP, where all vehicles are the same: they have the same fixed costs and capacities. HFTTRP has a set of vehicles with different capacities and fixed costs, which makes the problem even more difficult. Additionally, every customer may have its own preferences on types of vehicles to serve the customer. In this case the problem is called the Site Dependent TTRP (SDTTRP) and there are some developed heuristics for solving such problems sometimes with additional elaborations in constraints .\nAnother real-life constraints are hard and soft time windows and split-deliveries. Time windows are periods of time, when the delivery is acceptable (hard time windows) and the constraint should be satisfied in the majority of routes (soft time window). Split-deliveries are such deliveries, when there is a possibility to serve one customer with more than one vehicle. The problem in this form is considered in Batsyn & Ponomarenko (2014) and Batsyn & Ponomarenko (2015). These papers suggested greedy heuristic for the problem. In this article, this heuristic is developed in another way with an addition of new heuristic with elements of tabu-search. The greedy heuristic is altered so there are possible operations of both insertion and deletion from the route. After the greedy heuristic, the obtained solution is reconstructed with new heuristic with tabu-search elements.\nGreedy heuristic constructs the solution iteratively, until there are no unserved customers. For every route, the algorithm randomly chooses one of the farthest customers to be the first customer added to the route. Then, other customers are tried as candidates to the route. The solution has a constraint on the number of splitdeliveries and delays (violations of soft time window). For every route, the possibility of a split-delivery and the number of delays is chosen randomly. The route may have only one new split-delivery, and the probability is determined by the fraction of the current allowed split-deliveries to the estimated number of split-deliveries. The number of delays is defined by the fraction of the current allowed soft win-\ndow violations to the estimated number of soft window violations, however, every route may have different number of delays. The algorithm determines the allowed number of delays before constructing the route. After the solution is obtained, the heuristic with tabu-search elements tries to move customers between the routes to derive better solution. The algorithm uses set of changing parameters, which define “tabu neighbourhood” - the algorithm looks through the infeasible solutions. The degree of infeasibility is determined by the parameters - the number of allowed delays over limit, the number of routes with violated capacity and allowed cost change of the route."
    }, {
      "heading" : "2 Heuristic algorithm",
      "text" : "The following parameters are used in the pseudo-code of the algorithm: n - the number of customers V - the set of all customers K - the set of all vehicles Ki - the set of vehicles, which can serve customer i Qk - the current remaining capacity of vehicle k qi - the current remaining demand of the customer i vR - the number of soft time window violations in route R R - the current route S - the current solution S∗ - the best solution found so far v - the number of permitted soft window violations w - the current remaining number of permitted soft time window violations U - the set of all customers sorted the most expensive (farthest) customer first C - the cost of current insertion corridor - the allowed level of violations CurrentState - the current state of second heuristic closeness - the distance between customers to perform move CV set - the set of routes, where the capacity of vehicles is violated\nThe first important function of the whole algorithm is initial greedy heuristic, which constructs initial solution (Algorithms 1 and 2). The function works so that the solution will be necessarily constructed, but its cost may not be satisfactory. First, the algorithm sorts all customers by the distance from the depot (or, by the cost of direct travel from depot, which is the same) so the first customer in U is the farthest. Then, the process of solution construction begins. Routes of the solution are constructed in cycle, until there are unserved customers. For every route, the algorithm chooses one of the farthest customers, after that the vehicle is determined for the route. Also, function BASICROUTE(k) creates the route with one chosen customer.\nThe function FINDNUMBEROFVIOLATIONS(i, k, w) determines maximal possible number of soft window violations for the current route. The function uses the rela-\nAlgorithm 1 Initial Greedy heuristic Part 1\n1: function INITIALGREEDYHEURISTIC 2: ⊲ Creates one initial feasible solution 3: U ← V ⊲ sorting customers so that U1 has maximal ckl0i 4: S ← ∅ 5: while U 6= ∅ do 6: w = v 7: i ←RANDOM(U1, . . . , Uµ) ⊲ choose from the µ most expensive 8: k ←CHOOSEVEHICLE(i, [qj ] , [Qk]) 9: R ←BASICROUTE(k)\n10: violNumber ←FINDNUMBEROFVIOLATIONS(i, k, w) 11: Rviol ← ∅, Rclear ← ∅ 12: Cviol ← ∞ Cclear ← ∞ 13: IDviol ← 0, IDclear ← 0 14: for j ∈ U do 15: if k /∈ Kj then 16: continue 17: end if 18: mayV iolate ← true 19: C ′\nviol ←GETINSERTIONCOST(j,R,mayViolate,qj,Qk,violNumber) 20: mayV iolate ← false 21: C ′\nclear ←GETINSERTIONCOST(j,R,mayViolate,qj,Qk,violNumber) 22: ⊲ There are two possible insertions, with violation or without 23: if C ′\nviol < Cviol then 24: Cviol ← C ′\nviol\n25: Rviol ←INSERTCUSTOMER(j,R,true,qi,Qk) 26: IDviol ← j 27: end if 28: if C ′\nclear < Cclear then 29: Cclear ← C ′\nclear\n30: Rclear ←INSERTCUSTOMER(j,R,false,qi,Qk) 31: IDclear ← j 32: end if\ntion of current remaining soft window violations to the estimated number of remaining soft window violations and increases the number of allowed violations until the random generator returns numbers less than this relation. After that, the algorithm tries to insert all other customers in the route R, however, the algorithm does the insertion in two ways - allowing the violation of soft time window and forbidding the violation. If the number of soft window violations exceeds the allowed number, the route is forbidden. From obtained routes, there is chosen the best. Step by step the algorithm inserts customers until there are no possible insertions.\nAlgorithm 2 Initial Greedy heuristic Part 2\n33: if Rviol = null and Rclear = null then 34: S ← S ∪ {R}"
    }, {
      "heading" : "35: Qk ← 0",
      "text" : "36: w ← w − vR 37: break 38: else if Rclear = null then 39: R ← Rviol 40: U ← U/{IDviol} 41: else if Rviol = null then 42: R ← Rclear 43: U ← U/{IDclear} 44: else 45: if Cviol > Cclear then 46: R = Rviol 47: U ← U/{IDviol} 48: else 49: R = Rclear 50: U ← U/{IDclear} 51: end if 52: end if 53: end for 54: end while 55: end function\nThe whole idea of the greedy algorithm is based on Batsyn & Ponomarenko (2014) and Batsyn & Ponomarenko (2015)\nSecond important function is the second heuristic with elements of tabu search (Algorithm 3). Its goal is to take initial solution S and improve it by performing simple moves. The algorithm makes steps and at each step there is a possible move happens. The variety of possible moves depends on the corridor and closeness parameters. Also, there is CurrentState of the algorithm, which tracks successes, changes in the current best and some other parameters. From time to time, the algorithm tries to obtain feasible solution from current solution. The algorithm also may change corridor depending on CurrentState of the heuristic or even stop it in order to get new initial solution and start the procedure again.\nAt every step of the second heuristic (Algorithm 4), first, the customer is chosen randomly from one of the route of the current solution. After that, the customer is tried to be inserted in other routes in such way that the adjacent customer is close - the time of travel is less than closeness parameter. Variables places contains all such places of insertion in the route R. After finding the best move by the cost this move may be performed if it does not violate too many constraints.\nAlgorithm 3 Heuristic with Tabu Search\n1: function TABUSEARCHHEURISTIC(S,corridor,closeness,CurrentState) 2: S∗ ← S 3: repeat 4: success ←HEURISTICSTEP(S,corridor,closeness) 5: CHANGESTATEFORTABUSTEPSUCCESS(CurrentState,success) 6: if SHOULDOBTAINFEASIBLESOLUTION(CurrentState) then 7: ⊲ Recovery procedures work here 8: ROUTESOPTIMIZATION(S) 9: RECOVERCAPACITYVIOLATIONS(S)\n10: FINALZEROUTESTIMES(S) 11: RECOVERSOFTWINDOWVIOLATIONS(S) 12: if COST(S) < COST(S∗) then 13: S∗ ← S 14: CHANGESSTATEFORCHANGEINBEST(CurrentState) 15: end if 16: end if 17: CHANGECORRIDOR(corridor,CurrentState) 18: until STOPPINGCONDITION(CurrentState) 19: end function\nFinally, when the second heuristic tries to obtain the feasible solution from current infeasible, the recovery procedure takes place(Algorithm 3). Basically, the whole solution is likely to be in infeasible region because of moves. In that case, the algorithm needs to decrease the number of soft time window violations and recover over-capacitated routes to be under constraints. The recovery procedures start with route optimization - it creates some free space inside routes in order to recover solution more efficiently. After that, the algorithm recovers capacities of routes. Next step is finalization of times - the procedure goes through every route and compacts the time of the route. The last step is recovering soft time window violations.\nThe algorithm of capacity constraints recovery is described in Algorithm 5. There are two parts in this algorithm. First part of the algorithm repeatedly tries to take customers from over-capacitated routes and insert them in other routes without capacity violations. If there is no such move possible and there are over-capacitated routes left, the second part of the algorithm creates new routes with customers from over-capacitated routes. At the end of the procedure all routes have total demand less or equal to the capacity of the vehicle of the route."
    }, {
      "heading" : "3 Computational results",
      "text" : "Experiments were performed for seven experimental days, for which the good results of greedy heuristic are known. The column Greedy Heuristic Results, contains\nAlgorithm 4 Heuristic Step Algorithm\n1: function HEURISTICSTEP(S,corridor,closeness) 2: Ri, i, costOfDeletion ←CHOOSERANDOMCUSTOMER(S) 3: ⊲ i is deleted customer, the algorithm also needs the cost of deletion of this\ncustomer from its current route 4: bestCost ← ∞ 5: bestRoute ← ∅ 6: for all R ∈ S do 7: places ←FINDPLACESFORINSERTION(R,closeness) 8: for all place ∈ places do 9: R∗ ←ADDCUSTOMER(R,place)\n10: cost ←FINDMOVECOST(costOfDeletion,R,R∗,corridor,CurrentState) 11: if cost < bestCost then 12: bestCost = cost 13: bestRoute = R 14: end if 15: end for 16: end for 17: success ←ALLOWMOVE(bestCost,corridor) 18: if success then 19: Ri ← Ri/i 20: R ← R ∪ i 21: CHANGECURRENTVIOLATIONS(CurrentState,S) 22: end if 23: end function\nthe value of objective function obtained by the greedy heuristic for this day (Batsyn & Ponomarenko, 2015). The third column shows the results of heuristic with tabu search elements for the experimental days. The second heuristic worked for 3 hours for every experimental day. All experiments were conducted on Intel Xeon X5675 machine, with base processor frequency 3.06 GHz and 64 GB of memory.\nAlgorithm 5 Recovery Capacity Violations Procedure Part 1\n1: function RECOVERCAPACITYVIOLATIONS(S) 2: CV set ←FINDROUTESWITHCAPACITYVIOLATIONS(S) 3: for all R ∈ CV set do 4: bestCost ← ∞ 5: bestCustomer ← −1 6: bestRouteFrom ← ∅ 7: bestRouteTo ← ∅ 8: for all i ∈ R do 9: for all Rc /∈ CV set do\n10: cost, R∗, Rc∗ =FINDCOSTOFMOVE(R,i,Rc) 11: if cost < bestCost then 12: bestCost ← cost 13: bestCustomer ← i 14: bestRouteFrom ← R∗ 15: bestRouteTo← Rc∗ 16: end if 17: end for 18: end for 19: if bestCost 6= ∞ then 20: REPLACEROUTES(S,bestRouteFrom,bestRouteTo) 21: end if 22: end for 23: CV set =FINDROUTESWITHCAPACITYVIOLATIONS(S) 24: while CV set 6= ∅ do 25: Rcap ←CHOOSERANDOMROUTE(CV set) 26: i ←CHOOSECUSTOMERTORECOVERCAPACITY(Rcap) 27: CV set ← CV set/Rcap 28: success ← (CV set 6= ∅) 29: while R ∈ CV set do 30: bestCost ← ∞ 31: bestCustomer ← −1 32: bestRouteFrom ← ∅"
    }, {
      "heading" : "33: bestRouteTo← ∅",
      "text" : "34: for all i ∈ R do 35: for all Rc /∈ CV set do 36: cost, R∗, Rc∗ =FINDCOSTOFMOVE(R,i,Rc) 37: if cost < bestCost then 38: bestCost ← cost 39: bestCustomer ← i 40: bestRouteFrom ← R∗ 41: bestRouteTo ← Rc∗ 42: end if 43: end for 44: end for 45: end while 46: end while 47: end function"
    }, {
      "heading" : "4 Conclusion",
      "text" : "In this paper new heuristic was developed for the Site-Dependent Truck and Trailer Routing Problem with Time Windows and Split Deliveries. The heuristic uses a greedy approach for the initial solution construction and then employs elements of local search and tabu search to improve the initial solution. The obtained results are promising as they show improvement in most cases.\nThe following work should be directed to the improvement of the speed of the algorithm and to guarantee the best possible results as well. One of the way to improve the algorithm is to use new neighborhood - swap neighborhood, where two customers from different routes can be swapped. Also, there are more constraints that can be relaxed, such as time windows and split deliveries."
    }, {
      "heading" : "5 Acknowledgments",
      "text" : "The author is supported by LATNA Laboratory, NRU HSE, RF government grant, ag. 11.G34.31.0057."
    }, {
      "heading" : "6 References",
      "text" : "1. Batsyn, M., & Ponomarenko, A. (2014). Heuristic for a Real-life Truck and Trailer Routing Problem. Procedia Computer Science, 31, 778-792. doi:10.1016/j.procs.2014.05.328\n2. Batsyn, M., & Ponomarenko, A. (2015). Heuristic for Site-Dependent Truck and Trailer Routing Problem with Soft and Hard Time Windows and Split Deliveries. Lecture Notes in Computer Science Machine Learning, Optimization, and Big Data, 65-79. doi:10.1007/978-3-319-27926-8 7"
    } ],
    "references" : [ {
      "title" : "Heuristic for a Real-life Truck and Trailer Routing Problem",
      "author" : [ "M. Batsyn", "A. Ponomarenko" ],
      "venue" : "Procedia Computer Science,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2014
    }, {
      "title" : "Heuristic for Site-Dependent Truck and Trailer Routing Problem with Soft and Hard Time Windows and Split Deliveries. Lecture Notes in Computer Science Machine Learning, Optimization, and Big Data, 65-79",
      "author" : [ "M. Batsyn", "A. Ponomarenko" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2015
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "Vehicle Routing Problem is a well-known problem in logistics and transportation, and the variety of such problems is explained by the fact that it occurs in many real-life situations. It is an NP-hard combinatorial optimization problem and finding an exact optimal solution is practically impossible. In this work, SiteDependent Truck and Trailer Routing Problem with hard and soft Time Windows and Split Deliveries is considered (SDTTRPTWSD). In this article, we develop a heuristic with the elements of Tabu Search for solving SDTTRPTWSD. The heuristic uses the concept of neighborhoods and visits infeasible solutions during the search. A greedy heuristic is applied to construct an initial solution.",
    "creator" : "LaTeX with hyperref package"
  }
}