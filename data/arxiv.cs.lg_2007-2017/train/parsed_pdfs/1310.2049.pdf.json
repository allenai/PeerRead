{
  "name" : "1310.2049.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Fast Multi-Instance Multi-Label Learning",
    "authors" : [ "Sheng-Jun Huang", "Wei Gao", "Zhi-Hua Zhou" ],
    "emails" : [ "zhouzh@nju.edu.cn" ],
    "sections" : [ {
      "heading" : null,
      "text" : "In many real-world tasks, particularly those involving data objects with complicated semantics such as images and texts, one object can be represented by multiple instances and simultaneously be associated with multiple labels. Such tasks can be formulated as multi-instance multi-label learning (MIML) problems, and have been extensively studied during the past few years. Existing MIML approaches have been found useful in many applications; however, most of them can only handle moderate-sized data. To efficiently handle large data sets, in this paper we propose the MIMLfast approach, which first constructs a low-dimensional subspace shared by all labels, and then trains label specific linear models to optimize approximated ranking loss via stochastic gradient descent. Although the MIML problem is complicated, MIMLfast is able to achieve excellent performance by exploiting label relations with shared space and discovering sub-concepts for complicated labels. Experiments show that the performance of MIMLfast is highly competitive to state-of-the-art techniques, whereas its time cost is much less; particularly, on a data set with 20K bags and 180K instances, MIMLfast is more than 100 times faster than existing MIML approaches. On a larger data set where none of existing approaches can return results in 24 hours, MIMLfast takes only 12 minutes. Moreover, our approach is able to identify the most representative instance for each label, and thus providing a chance to understand the relation between input patterns and output label semantics. Key words: MIML, multi-instance multi-label learning, fast, key instance, sub-concepts\n∗Corresponding author. Email: zhouzh@nju.edu.cn\nPreprint submitted for review October 9, 2013\nar X\niv :1\n31 0.\n20 49\nv1 [\ncs .L\nG ]\n8 O\nct 2\n01 3"
    }, {
      "heading" : "1. Introduction",
      "text" : "In traditional supervised learning, one object is represented by a single instance and associated with only one label. However, in many real world applications, one object can be naturally decomposed into multiple instances, and has multiple class labels simultaneously. For example, in image classification problems, an image usually contains multiple objects, and can be divided into several segments, where each segment is represented with an instance, and corresponds to a semantic label [26]; in text categorization tasks, an article may belong to multiple categories, and can be represented by a bag of instances, one for a paragraph [22]; in gene function prediction tasks, a gene usually has multiple labels since it is related to multiple functions, and can be represented with a set of images with different views [12]. Multi-instance multi-label learning (MIML) is a recent proposed framework for such complicated objects [27].\nDuring the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27]. They achieved decent performances and validated the superiority of MIML framework in different applications. However, along with the enhancing of expressive power, the hypothesis space of MIML expands dramatically, resulting in the high complexity and low efficiency of existing approaches. These approaches are usually time-consuming, and cannot handle large scale data, thus strongly limit the application of multi-instance multi-label learning.\nIn this paper, we propose a novel approach MIMLfast to learn on multi-instance multi-label data fast. Though simple linear models are employed for efficiency, MIMLfast provides an effective approximation of the original MIML problem. Specifically, to utilize the relations among multiple labels, we first learn a shared space for all the labels from the original features, and then train label specific linear models from the shared space. To identify the key instance to represent a bag for a specific label, we train the classification model on the instance level, and then select the instance with maximum prediction. To make the learning efficient, we employ stochastic gradient descent (SGD) to optimize an approximated ranking loss. At each step of SGD, MIMLfast randomly samples a triplet which consists of a bag, a relevant label of the bag and an irrelevant label, and optimizes the model to rank the relevant label before the irrelevant one if such an order is violated.\nWhile most existing approaches focus on improving generalization, another important task of MIML learning is to understand the relation between input patterns and output label semantics\n[11]. Our approach can naturally identify the most representative instance for each label. In addition, we propose to discover sub-concepts for complicated labels, which frequently occur in MIML tasks.\nThe rest of the paper is organized as follows. We propose the MIMLfast approach in Section 2, and then present the experiments in Section 3. Section 4 reviews some related work, followed by the conclusion in Section 5."
    }, {
      "heading" : "2. The MIMLfast Approach",
      "text" : "We denote by {(X1, Y1), (X2, Y2), · · · , (Xn, Yn)} the training data that consists of n examples, where each bag Xi has zi instances {xi,1,xi,2, · · · ,xi,zi} and Yi contains the labels associated with Xi, which is a subset of all possible labels {y1, y2 · · · yL}.\nWe first discuss on how to build the classification model on the instance level, and then try to get the labels of bags from instance predictions. To handle a problem with multiple labels, the simplest way is to degenerate it into a series of single label problems by training one model for each label independently. However, such a degenerating approach may lose information since it treats the labels independently and ignores the relations among them. In our approach, we formulate the model as a combination of two components. The first component learns a linear mapping from the original feature space to a low dimensional space, which is shared by all the labels. Then the second component learns label specific models based on the shared space. The two components are optimized interactively to fit training examples from all labels. In such a way, examples from each label will contribute the optimization of the shared space, and labels with strong relations are expected to help each other. Formally, given an instance x, we define the classification model on label l as\nfl(x) = w > l W0x,\nwhere W0 is a m× d matrix which maps the original feature vectors to the shared space, and wl is the m-dimensional weight vector for label l. d and m are the dimensionalities of the feature space and the shared space, respectively.\nObjects in multi-instance multi-label learning tasks usually have complicated semantic; and thus examples with diverse contents may be assigned the same label. For example, the content of an image labeled apple can be a mobile phone, a laptop or just a real apple. It is difficult to train a single model to classify images with such diverse contents into the same category. Instead, we propose to learn multiple models for a complicated label, one for a sub-concept, and automatically decide which sub-concept one example belongs to. The model of each sub-concept is much simpler and may be more easily trained to fit the data. We assume that there are K sub-concepts for each label. For a given example with label l, the sub-concept it belongs to is automatically determined by first examining the prediction values of the K models, and then selecting the sub-concept with maximum prediction value. Now we can redefine the prediction of instance x on label l as:\nfl(x) = max k=1···K fl,k(x) = max k=1···K\nw>l,kW0x, (1)\nwhere wl,k corresponds to the k-th sub-concept of label l. Note that although we assume there are K sub-concepts for each label, empty sub-concepts are allowed, i.e., examples of a simple label may be distributed in only a few or even one sub-concept.\nWe then look at how to get the predictions of bags from the instance level models. It is usually assumed that a bag is positive if and only if it contains at least one positive instance [5, 4]. Under this assumption, the prediction of a bag X on label l can be defined as the maximum of predictions of all instances in this bag:\nfl(X) = max x∈X fl(x).\nWe call the instance with maximum prediction the key instance of X on label l.\nWith the above model, for an example X and one of its relevant labels l, we define R(X, l) as\nR(X, l) = ∑ j∈Ȳ I[fj(X) > fl(X)], (2)\nwhere Ȳ denotes the set of irrelevant labels of X, and I[·] is the indicator function which returns 1 if the argument is true and 0 otherwise. Essentially, R(X, l) counts how many irrelevant labels are ranked before label l on the bag X.\nBased on R(X, l), we further define the ranking error [19] with respect to an example X on label l as\n(X, l) = R(X,l)∑ i=1 1 i . (3)\nIt is obvious that the ranking error would be larger for lower l being ranked. Finally, we have the ranking error on the whole dataset as\nRank Error = n∑ i=1 ∑ l∈Yi (X, l).\nBased on Eq. 2, the ranking error (X, l) can be spread into all irrelevant labels in Ȳ as:\n(X, l) = ∑ j∈Ȳ (X, l) I[fj(X) > fl(X)] R(X, l) . (4)\nDue to non-convexity and discontinuousness, it is rather difficult to optimize the above equation directly because such optimization often leads to NP-hard problems. We instead explore the following hinge loss, which has been shown as an optimal choice among all convex surrogate losses [2],\nΨ(X, l) = ∑ j∈Ȳ (X, l) |1 + fj(X)− fl(X)|+ R(X, l) , (5)\nwhere |q|+ = q if q ≥ 0; otherwise, |q|+ = 0. The surrogate loss Ψ(X, l) can be viewed as an upper bound of (X, l) with the following lemma:\nLemma 1 (X, l) ≤ Ψ(X, l).\nProof: This lemma holds from I[q] ≤ |1− q|+.\nWe then employ stochastic gradient descent (SGD) [16] to minimize the ranking error. At each iteration of SGD, we randomly sample a bag X, one of its relevant labels y, and one of its irrelevant labels ȳ ∈ Ȳ to form a triplet (X, y, ȳ), which will induce a loss:\nL(X, y, ȳ) = (X, y)|1 + fȳ(X)− fy(X)|+. (6)\nWe then have the following lemma to disclose the relation between Ψ(X, y) and L(X, y, ȳ).\nLemma 2 Ψ(X, y) = Eȳ[L(X, y, ȳ)], where E[·] denotes the expectation on the uniform distribution over Ȳ .\nProof: This lemma follows from the fact that probability of randomly choosing ȳ in Ȳ is 1/R(X, y).\nTo minimize L(X, y, ȳ), it is required to calculate R(X, y) in advance, i.e., we have to compare fy(X) with fȳ(X) for each ȳ ∈ Ȳ , whereas this could be time consuming when the number of possible labels is large. Therefore, we use an approximation to estimate R(X, y) in our implementation, inspired by Weston et al. [20]. Specifically, at each SGD iteration, we randomly sample labels from the irrelevant label set Ȳ one by one, until a violated label ȳ occurs. Here we call ȳ a violated label if it was ranked before y, i.e., fȳ(X) > fy(X)− 1. Without loss of generality, we assume that the first violated label is found at the v-th sampling step, and then, R(X, y) can be approximated by b|Ȳ |/vc with the following lemma:\nLemma 3 We denote by ξ a random event with ξ = i representing the event that first violated label is at the i-th sampling step. We have\nR(X, y)\n|Ȳ | ≈ Eξ\n[ 1\nξ\n] .\nProof: For convenience, we set p = R(X, y)/|Ȳ | and assume 0 < p < 1 without loss of generality. It is easy to derive the probability\nPr[ξ = i] = (1− p)i−1p for i ≥ 1,\nand we further have\nEξ\n[ 1\nξ\n] = ∞∑ i=1 1 i p(1− p)i−1 = p 1− p ∞∑ i=1 1 i (1− p)i\n= −p\n1− p ln(1− (1− p)) ≈ p\nwhere we use ∑∞\ni=1 1 i (1− p) i = − ln(p) and ln(1 + q) ≈ q. This completes the proof.\nWe assume that the triplet sampled at the t-th SGD iteration is (X, y, ȳ), on label y, the key instance is x, and achieves the maximum prediction on the k-th sub-concept, while on label ȳ,\nthe instance x̄ achieves the maximum prediction on the k̄-th sub-concept. Then we have the approximated ranking loss for the triplet:\nL(X, y, ȳ) = (X, y)|1 + fȳ(X)− fy(X)|+\n≈  0 if ȳ is not violated;\nSȲ ,v(1 + [w t ȳ,k̄] >W t0x̄− [wty,k]>W t0x) otherwise.\nHere we introduce SȲ ,v = ∑b |Ȳ | v c i=1 1 i for the convenience of presentation. So, if a violated label ȳ is sampled, we perform the gradient descent on the three parameters according to:\nW t+10 = W t 0 − γtSȲ ,v(wtȳ,k̄x̄ > −wty,kx>) (7)\nwt+1y,k = w t y,k + γtSȲ ,vW t 0x (8) wt+1 ȳ,k̄ = wtȳ,k̄ − γtSȲ ,vW t 0x̄ (9)\nwhere γt is the step size of SGD at the t-th iteration. After the update of the parameters, wy,k, wȳ,k̄ and each column of W0 are normalized to have a L2 norm smaller than a constant C.\nThe pseudo code of MIMLfast is presented in Algorithm 1. First, each column of W0 and wkl for all labels l and all sub-concepts k are initialized at random with mean 0 and standard deviation 1/ √ d. Then at each iteration of SGD, a triplet (X, y, ȳ) is randomly sampled, and their corresponding key instance and sub-concepts are identified. After that, gradient descent is performed to update the three parameters: W0, wy,k and wȳ,k̄ according to Eqs. 7 to 9. At last, the updated parameters are normalized such that their norms will be upper bounded by C. This procedure is repeated until some stop criteria reached. In our experiments, we sample a small subset from the training data to form a validation set, and stop the training if the ranking loss does not decrease anymore on the validation set.\nWe then present some theoretical guarantees on the convergence rate of the optimization. Denoting by\nLt(W0,wy,k,wȳ,k̄) = SȲ ,v(1 + w>ȳ,k̄W0x̄t −w > y,kW0xt)+\nthe loss of t-th SGD iteration with model parameters W0, wy,k wȳ,k̄, and\n(W ∗0 ,w ∗ l,k) ∈ arg min ∑ t Lt(W0,wy,k,wȳ,k̄)\nthe optimal solution, we have:\nAlgorithm 1 The MIMLfast algorithm\n1: INPUT: training data, parameters m, C, K and γt 2: TRAIN: 3: initialize W0 and wl,k (l = 1 · · ·L, k = 1 · · ·K) 4: repeat: 5: randomly sample a bag X and one of its label y 6: (x, k) = arg maxx∈X,k∈{1···K} fy,k(x) 7: for i = 1 : |Ȳ | 8: sample an irrelevant label ȳ from Ȳ 9: (x̄, k̄) = arg maxx∈X,k̄∈{1···K} fȳ,k̄(x)\n10: if fȳ(X) > fy(X)− 1 11: v = i 12: update W0, wy,k and wȳ,k̄ as Eqs. 7 to 9 13: normalize W0, wy,k and wȳ,k̄ 14: break 15: end if 16: end for 17: until stop criterion reached 18: TEST: 19: Relevant labels set for the test bag Xtest is: {l|1 + fl(Xtest) > fŷ(Xtest)}\nTheorem 1 Suppose ‖xt‖ ≤ 1, ‖W t0‖ ≤ C √ d, ‖wty,k‖ ≤ C and ‖wtȳ,k̄‖ ≤ C. By choosing proper W 00 , w 0 y,k and γt, it holds that\nT∑ t Lt(W t0,wty,k,wtȳ,k̄)− T∑ t Lt(W ∗0 ,w∗y,k,w∗ȳ,k̄) ≤ B √ T\nwhere B = 4 + (d+ 2 √ d)C2 ∑L i=1 1/i.\nProof: We present the main steps due to space limitation. Since the function Lt(W t0,wty,k,wtȳ,k̄) is convex with respect to wty,k and w t ȳ,k̄ , we have\nLt(W t0,wty,k,wtȳ,k̄)− Lt(W t 0,w ∗ y,k,w ∗ ȳ,k̄)\n≤ [∂Lt(W t0,wty,k,wtȳ,k̄)/∂w t y,k] >(wty,k −w∗y,k)\n+[∂Lt(W t0,wty,k,wtȳ,k̄)/∂w t ȳ,k̄] >(wtȳ,k̄ −w ∗ ȳ,k̄).\nFrom Eqs. (8) and (9), we have\n‖wt+1y,k −w ∗ y,k‖ ≤ ‖wty,k −w∗y,k‖+ ∆t − 2γt[∂Lt(W t0,wty,k,wtȳ,k̄)/∂w t y,k] >(wty,k −w∗y,k)\nwhere\n∆t = γ 2 t ∥∥∥SȲ ,vW t0∥∥∥2 ≤ dC2γ2t ∑Li=1 1/i. This follows that\n‖wt+1y,k −w ∗ y,k‖ ≤ ‖wty,k −w∗y,k‖+ dC2γ2t ∑L i=1 1/i\n− 2γt[∂Lt(W t0,wty,k,wtȳ,k̄)/∂w t y,k] >(wty,k −w∗y,k).\nIn a similar manner, we have\n‖wt+1 ȳ,k̄ −w∗ȳ,k̄‖ ≤ ‖w t ȳ,k̄ −w ∗ ȳ,k̄‖+ dC 2γ2t ∑L i=1 1/i\n− 2γt[∂Lt(W t0,wty,k,wtȳ,k̄)/∂w t ȳ,k̄] >(wtȳ,k̄ −w ∗ ȳ,k̄).\nSumming over t = 0, ..., T − 1, and by setting γt = 1/ √ t and simple calculation, we have\nT−1∑ t=1 Lt(W t0,wty,k,wtȳ,k̄)− T−1∑ t=1 Lt(W t0,w∗y,k,w∗ȳ,k̄)\n≤ 2 γT +B T−1∑ t=1 γt 2 ≤ (2 + dC2 ∑L i=1 1/i) √ T .\nFurther, we have\nT−1∑ t=1 Lt(W t0,w∗y,k,w∗ȳ,k̄)− T−1∑ t=1 Lt(W ∗0 ,w∗y,k,w∗ȳ,k̄)\n= √ T−1∑ t=1 Lt(W t0,w∗y,k,w∗ȳ,k̄)− √ T−1∑ t=1 Lt(W ∗0 ,w∗y,k,w∗ȳ,k̄)\n+ T−1∑ t= √ T Lt(W t0,w∗y,k,w∗ȳ,k̄)− T−1∑ t= √ T Lt(W ∗0 ,w∗y,k,w∗ȳ,k̄)\n≤ 2(1 + √ dC2 L∑ i=1 1/i) √ T\nby selecting proper initial values and simple calculation. This theorem follows as desired.\nIn the test phase of the algorithm, for a bag Xtest, we can get the prediction value on each label, and consequently the rank of all labels. For single label classification problem, it is very easy to get the label of Xtest by selecting the one with largest prediction value. However, in multi-label learning, the bag Xtest may have more than one label; and thus one do not know how many labels should be selected as relevant ones from the ranked label list [8]. To solve this problem, we assign each bag a dummy label, denoted by ŷ, and train the model to rank the dummy label before all irrelevant labels while after the relevant ones. To implement this idea, we pay a special consideration on constructing the irrelevant labels set Ȳ . Specifically, when X and its label y are sampled (in Line 6 of Algorithm 1), the algorithm will first examine whether y is the dummy label. If y = ŷ, then Ȳ consists of all the irrelevant labels; otherwise, Ȳ contains both the dummy label and all the irrelevant labels. In such a way, the model will be trained to rank the dummy label between relevant labels and irrelevant ones. For a test bag, the labels with larger prediction value than that on the dummy label are selected as relevant labels."
    }, {
      "heading" : "3. Experiments",
      "text" : ""
    }, {
      "heading" : "3.1. Settings",
      "text" : "We compare MIMLfast with six state-of-the-art MIML methods: DBA [22], a generative model for MIML learning; KISAR [11], a MIML algorithm tries to discover instance-label relation;\nMIMLBoost [26], a boosting method decomposes MIML into multi-instance single label problems; MIMLkNN [24], a MIML nearest neighbor algorithm; MIMLSVM [26], a SVM style algorithm which decomposes MIML into single instance multi-label problems; and RankLossSIM [4], a MIML algorithm minimizes ranking loss for instance annotation.\nWe perform the experiments on 6 moderate-sized data sets and 2 large data sets. Among the moderate-sized data sets, Scene and Reuters are two benchmark data sets commonly used in existing MIML works. Scene [26] consists of 2000 images for scene classification, and is associated with 5 possible labels: desert, mountains, sea, sunset and trees. For each image, a bag of 9 instances is extracted via SBN [14]. Reuters is constructed based on the Reuters-21578 data set [18] with the sliding window technique in [1]. The other four moderate-sized data sets are collected by Fern et al. in their recent work [4]: Letter Carroll and Letter Frost are constructed using the UCI Letter Recognition dataset [7], where a bag is created for each word, and labels correspond to the letters. Bird Song consists of bird song recordings at the H. J. Andrews (HJA) Experimental Forest. Each bag is extracted from a 10-seconds audio recording while labels correspond to species of birds. MSRC v2 is a subset of the Microsoft Research Cambridge (MSRC) image dataset [21]. Based on the ground-truth segmentation, histograms of gradients and colors are extracted to form an instance for each segment. The two large data sets are Corel5K and MSRA. Corel5K [6] contains 5000 segmented images and 260 class labels, and each image is represented by 9 instances on average. MSRA [10] is a multimedia database collected by Microsoft Research Asia, the subset used in this work contains 30000 images with 99 possible labels, and each image is represented with a bag of 9 instances. The detailed characteristics of these data sets are summarized in Table 1.\nFor MSRA and Corel5K, since existing MIML approaches cannot handle large scale data, we examine the performances of compared approaches on a series of subsets with different number of training bags (which will be specified later). For each data set, 2/3 of the data are randomly sampled for training, and the remaining examples are taken as test set. We repeat the random data partition for thirty times, and report the average results over the thirty repetitions.\nFor MIMLfast, the step size is in the form γt = γ0/(1+ηγ0t) according to [3]. The parameters are selected by 3-fold cross validation on the training data with regard to ranking loss. The candidate values for the parameters are as below: m ∈ {50, 100, 200}, C ∈ {1, 5, 10}, K ∈ {1, 5, 10, 15},\nγ0 ∈ {0.0001, 0.0005, 0.001, 0.005} and η ∈ {10−5, 10−6}. In our experience, the algorithm is not very sensitive to m and C; and the influence of K will be studied in Section 3.5. For the compared\n0.2 0.4 0.6 0.8 1 1.2 1.4 1.6\nMIMLfast DBA KISAR MIMLkNN MIMLSVM RankLossSIM\n(a) Legend\n1000 2000 3000 4000 5000\n.015\n.020\n.025\nData Size\nH am\nm in\ng L\nos s\n(b) Hamming Loss ↓\n1000 2000 3000 4000 5000\n0.6\n0.7\n0.8\nData Size\nO ne\nE rr\nor\n(c) One Error ↓\n1000 2000 3000 4000 5000 0.2\n0.4\n0.6\n0.8\n1.0\nData Size\nC ov\ner ag\ne\n(d) Coverage ↓\n1000 2000 3000 4000 5000 0.0\n0.5\n1.0\nData Size\nR an\nki ng\nL os\ns\n(e) Ranking Loss ↓\n1000 2000 3000 4000 5000 0.0\n0.1\n0.2\n0.3\nData Size\nA ve\nra ge\nP re\nci si\non\n(f) Average Precision ↑\nFigure 1: Comparison results on Corel5K with varying data size; ↑(↓) indicates that the larger (smaller) the value, the better the performance.\n10k 15k 20k 25k 30k 12 mins\n18 hrs18 hrs\n22 hrs\nData Size\nMIMLfast KISAR MIMLkNN MIMLSVM\n(a) Legend\n5k 10k 15k 20k 25k 30k\n.028\n.030\n.032\n.034\n.036\nData Size\nH am\nm in\ng L\nos s\n(b) Hamming Loss ↓\n5k 10k 15k 20k 25k 30k .55\n.60\n.65\nData Size\nO ne\nE rr\nor\n(c) One Error ↓\n5k 10k 15k 20k 25k 30k .20\n.24\n.28\n.32\nData Size\nC ov\ner ag\ne\n(d) Coverage ↓\n5k 10k 15k 20k 25k 30k .10\n.12\n.14\n.16\n.18\nData Size\nR an\nki ng\nL os\ns\n(e) Ranking Loss ↓\n5k 10k 15k 20k 25k 30k .38\n.40\n.42\n.44\nData Size\nA ve\nra ge\nP re\nci si\non\n(f) Average Precision ↑\nFigure 2: Comparison results on MSRA with varying data size; ↑(↓) indicates that the larger (smaller) the value, the better the performance; only MIMLfast can work when data size reaches 25,000.\napproaches, parameters are determined in the same way if no value suggested in their literatures.\nThe performances of the compared approaches are evaluated with five commonly used MIML\ncriteria: hamming loss, one error, coverage, ranking loss and average precision. For average precision, a larger value implies a better performance, while for the other four criteria, the smaller, the better. Note that coverage is normalized by the number of labels such that all criteria are in the interval [0, 1]. The definition of these criteria can be found in [17, 27]."
    }, {
      "heading" : "3.2. Performance Comparison",
      "text" : "We first report the comparison results on the six moderate-sized data sets in Table 2. As shown in the table, our approach MIMLfast achieves the best performance in most cases. DBA tends to favor text data, and is outperformed by MIMLfast on all the data sets. KISAR achieves comparable results with MIMLfast on Scene while is less effective on the other data sets. MIMLBoost can handle only the two smallest data sets, and does not yield good performance. MIMLkNN and MIMLSVM work steady on all the data sets, but are not competitive when compared with MIMLfast. At last, RankLossSIM is comparable to MIMLfast on 4 of 6 data sets, and even achieves better coverage and ranking loss on the Bird Song data set. However, on the other two data sets with relative more bags, i.e., Reuters and Scene, it is significantly worse than our approach on all the five criteria.\nMSRA and Corel5K contain 30000 and 5000 bags respectively, which are too large for most existing MIML approaches. We thus perform the comparison on subsets of them with different data sizes. We vary the number of bags from 1000 to 5000 for Corel5K, and 5000 to 30000 for MSRA, and plot the performance curves in Figures 1 and 2, respectively. MIMLBoost did not return results in 24 hours even for the smallest data size, and thus it is not included in the comparison. RankLossSIM is not presented on MSRA for the same reason. We also exclude DBA on MSRA because its performance is too bad. As observable in Figures 1 and 2, MIMLfast is apparently better than the others on these two large data sets. Particularly, when data size reaches 25K, other methods cannot work, but MIMLfast still works well."
    }, {
      "heading" : "3.3. Efficiency Comparison",
      "text" : "It is crucial to study the efficiency of the compared MIML approaches, because our basic motivation is to develop a method that can work on large scale MIML data. All the experiments are\n0.2 0.4 0.6 0.8 1 1.2 1.4 1.6\nperformed on a machine with 16×2.60 GHz CPUs and 32GB main memory. Again, we first show the time cost of each algorithm on the six moderate-sized data sets in Figure 3. Since the results on the two smallest data sets Letter Carroll and Letter Frost are similar, we take one of them as representative to save space. Obviously, our approach is the most efficient one on all the data sets. MIMLBoost is the most time-consuming one, followed by RankLossSIM and MIMLkNN.\nThe superiority of our approach is more distinguished on larger data sets. As shown in Figure 4, on Corel5K, MIMLBoost failed to get result in 24 hours even with the smallest subset, while RankLossSIM can handle only 1000 examples. The time costs of existing methods increase dramatically as the data size increases. In contrast, MIMLfast takes only 1 minute even for the largest size in Figure 4(a). In Figure 4(b), on the largest MSRA data, the superiority of MIMLfast is even more apparent. None of existing approaches can deal with more than 20K examples. In contrast, on data of 20,000 bags and 180,000 instances, MIMLfast is more than 100 times faster than the most efficient existing approach; when the data size becomes larger, none of existing approaches can return result in 24 hours, and MIMLfast takes only 12 minutes."
    }, {
      "heading" : "3.4. Key Instance Detection",
      "text" : "In MIML, a set of labels are assigned to a group of instances, and thus it is interesting to understand the relation between input patterns and output label semantics. Inspired by [11], by assuming that each label is triggered by its most positive instance, our MIMLfast approach is able to identify the key instance for each label.\nWe first give an intuitive evaluation of the key instance detection of MIMLfast. On MSRA, following [11], we first partition each image into a set of patches with k-means clustering, and\nthen extract an instance from each cluster. In Figure 5, we show two example images, and highlight the regions corresponding to the key instance detected by our approach for each label. Note that since the image regions are obtained by clustering, an instance may correspond to multiple regions in the same cluster rather than a single region. The results clearly show that MIMLfast can detect reasonable key instances for the labels.\nWe also evaluate the key instance detection accuracy quantitatively. On 4 of the 8 MIML data sets, i.e., Letter Carroll, Letter Frost, MSRC v2 and Bird Song, the instance labels are available, and thus providing a test bed for key instance detection. Among the existing MIML methods, RankLossSIM and KISAR are able to detect key instance for each label, and will be compared with our approach. For MIMLfast and RankLossSIM, the key instance for a specific label is identified by selecting the instance with maximum prediction value on that label, while for KISAR, key instance is the one closest to the prototype of the label as in [11]. We examine the ground truth of the detected key instances and present the accuracies in Table 3. We can observe that KISAR is less accurate than the other two methods, probably because it does not build the model on the instance level, and detects key instance based on unsupervised prototypes. When compared with RankLossSIM, which is specially designed for instance annotation, our approach is more accurate on the two larger data sets, while comparable on Letter Carroll, and slightly worse on Letter Frost."
    }, {
      "heading" : "3.5. Sub-Concept Discovery",
      "text" : "To examine the effectiveness of sub-concept discovery, we run MIMLfast with varying number of sub-concepts on the two benchmark data sets: Scene for image classification and Reuters for\ntext categorization. Table 4 presents the results with K varying from 1 to 15 with step size of 5. For each value of K, we run 10-fold cross validation and report the average results as well as standard deviations. Note that K is selected by cross validation on the training data in Section 3.2. As shown in Table 4, compared with neglecting the sub-concepts (K = 1), the exploitation of sub-concepts is helpful (K = 5, 10 and 15 are all better than K = 1). When the K gets larger, the difference between results with different K values is not very significant. This may owe to that if we set a K value larger than what is really needed, some sub-concepts might capture no examples, and thus a overly-large K will not make the performance degenerate too much, although it might hamper the efficiency.\nWe further examine the sub-concepts discovered by MIMLfast. We take the Scene data set as an illustration and show some example images of the top-four sub-concepts discovered for the label sea in Figure 6. It is interesting to see that these four sub-concepts are with reasonable but different perceptions: the first sub-concept corresponds to sea with beach and blue sky, the second sub-concept corresponds to big wave in the sea, etc."
    }, {
      "heading" : "3.6. Comparison with Variants",
      "text" : "To further examine how MIMLfast works, we study two variants, V1 and V2. V1 gives up W0 in Eq. 1 and directly learns a linear model for each label. It is constructed to examine whether learning the shared space is helpful. V2 simply selects the top r labels as relevant ones, where r is the average number of relevant labels on the training data. It is constructed to examine whether the dummy label provides a good separation of relevant and irrelevant labels.\nTable 5 shows the results on the two benchmark data sets. V1 is significantly worse than MIMLfast on all criteria, implying that learning the shared space for all the labels is better than learning each label independently. On hamming loss, MIMLfast achieves significantly better performance than V2, while on the other four criteria, they achieve comparable performances, implying that the use of dummy label does not affect the rank of the labels but providing a reasonable separation of relevant and irrelevant labels."
    }, {
      "heading" : "4. Related Work",
      "text" : "Many MIML approaches were proposed during the past few years. For example, MIMLSVM [26] degenerated the MIML problem into single-instance multi-label tasks to solve. MIMLBoost [26] degenerated MIML to multi-instance single-label learning. A generative model for MIML was proposed by Yang et al. [22]. Nearest neighbor and neural network approaches for MIML were proposed in [24] and [25], respectively. Zha et al. [23] proposed a hidden conditional random field model for MIML image annotation. Briggs et al. [4] proposed to optimize ranking loss for MIML instance annotation. In [11], the authors tried to discover what patters trigger what labels in MIML learning by constructing a prototype for each label with clustering. Existing MIML approaches achieved success in many applications, most with moderate-sized data owing to the high computational load. To handle large-scale data, MIML approaches with high efficiency are demanded.\nIn [20], a similar technique was used to optimize WARP loss for image annotation; however, it dealt with single-instance single-label problem, which is quite different from our MIML problem. In [27], an approach of discovering sub-concepts for complicated concepts was proposed based\non clustering. However, it was focused on single label learning, quite different from our MIML task. Moreover, MIMLfast exploits label information and discovers sub-concepts using supervised model rather than heuristic clustering."
    }, {
      "heading" : "5. Conclusion",
      "text" : "MIML is a framework for learning with complicated objects, and has been proved to be effective in many applications. However, existing MIML approaches are usually too time-consuming to deal with large scale problems. In this paper, we propose the MIMLfast approach to learn with MIML examples fast. On one hand, efficiency is highly improved by optimizing the approximated ranking loss with SGD based on a two level linear model; on the other hand, effectiveness is achieved by exploiting label relations in a shared space and discovering sub-concepts for complicated labels. Moreover, our approach can naturally detect key instance for each label, and thus providing a chance to discover the relation between input patterns and output label semantics. In the future, we will try to optimize other loss functions rather than ranking loss. Also, larger scale problems will be studied."
    } ],
    "references" : [ {
      "title" : "Support vector machines for multipleinstance learning",
      "author" : [ "S. Andrews", "I. Tsochantaridis", "T. Hofmann" ],
      "venue" : "Advances in neural information processing systems 15, pages 561–568. MIT Press, Cambridge, MA,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Minimizing the misclassification error rate using a surrogate convex loss",
      "author" : [ "S. Ben-David", "D. Loker", "N. Srebro", "K. Sridharan" ],
      "venue" : "Proceedings of the 29th International Conference on Machine Learning, Edinburgh, Scotland,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Large-scale machine learning with stochastic gradient descent",
      "author" : [ "Léon Bottou" ],
      "venue" : "Compstat,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2010
    }, {
      "title" : "Rank-loss support instance machines for miml instance annotation",
      "author" : [ "F. Briggs", "X.Z. Fern", "R. Raich" ],
      "venue" : "Proceedings of the 18th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 534–542, Beijing, China,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Solving the multiple instance problem with axis-parallel rectangles",
      "author" : [ "T.G. Dietterich", "R.H. Lathrop", "T. Lozano-Pérez" ],
      "venue" : "Artificial Intelligence, 89(1):31–71,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Object recognition as machine translation: Learning a lexicon for a fixed image vocabulary",
      "author" : [ "P. Duygulu", "K. Barnard", "J.F.G. Freitas", "D.A. Forsyth" ],
      "venue" : "Proceedings of the 7th European Conference on Computer Vision, pages 97–112, Copenhagen, Denmark,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Letter recognition using holland-style adaptive classifiers",
      "author" : [ "P.W. Frey", "D.J. Slate" ],
      "venue" : "Machine Learning, 6(2):161–182,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Multilabel classification via calibrated label ranking",
      "author" : [ "J. Fürnkranz", "E. Hüllermeier", "E. Loza Menćıa", "K. Brinker" ],
      "venue" : "Machine Learning, 73(2):133–153,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Learning a distance metric from multi-instance multi-label data",
      "author" : [ "R. Jin", "S. Wang", "Z.H. Zhou" ],
      "venue" : "Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 896–902, Miami, FL,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Msra-mm 2.0: A large-scale web multimedia dataset",
      "author" : [ "H. Li", "M. Wang", "X.S. Hua" ],
      "venue" : "In Proceedings of the IEEE International Conference on Data Mining Workshops,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2009
    }, {
      "title" : "Towards discovering what patterns trigger what labels",
      "author" : [ "Yu-Feng Li", "Ju-Hua Hu", "Yuang Jiang", "Zhi-Hua Zhou" ],
      "venue" : "In Proceedings of the 26th AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2012
    }, {
      "title" : "Drosophila gene expression pattern annotation through multi-instance multi-label learning",
      "author" : [ "Y.X. Li", "S. Ji", "S. Kumar", "J. Ye", "Z.H. Zhou" ],
      "venue" : "Proceedings of the 21st International Joint Conference on Artificial Intelligence, pages 1445–1450, Pasadena, CA,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Learning from candidate labeling sets",
      "author" : [ "J. Luo", "F. Orabona" ],
      "venue" : "Advances in Neural Information Processing Systems 23. MIT Press, Cambridge, MA,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Multiple-instance learning for natural scene classification",
      "author" : [ "O. Maron", "A.L. Ratan" ],
      "venue" : "Proceedings of the 15th International Conference on Machine Learning, pages 341–349, Madison, WI,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "A new svm approach to multi-instance multi-label learning",
      "author" : [ "N. Nguyen" ],
      "venue" : "Proceedings of the 10th IEEE International Conference on Data Mining, pages 384–392, Sydney, Australia,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A stochastic approximation method",
      "author" : [ "H. Robbins", "S. Monro" ],
      "venue" : "The Annals of Mathematical Statistics, 22(3):400–407,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1951
    }, {
      "title" : "BoosTexter: A boosting-based system for text categorization",
      "author" : [ "R.E. Schapire", "Y. Singer" ],
      "venue" : "Machine Learning, 39(2-3):135–168,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Machine learning in automated text categorization",
      "author" : [ "F. Sebastiani" ],
      "venue" : "ACM Computing Surveys, 34(1):1–47,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Ranking with ordered weighted pairwise classification",
      "author" : [ "N. Usunier", "D. Buffoni", "P. Gallinari" ],
      "venue" : "Proceedings of the 26th International Conference on Machine Learning, pages 1057–1064, Montreal, Canada,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Wsabie: Scaling up to large vocabulary image annotation",
      "author" : [ "J. Weston", "S. Bengio", "N. Usunier" ],
      "venue" : "Proceedings of the 22nd International Joint Conference on Artificial Intelligence, pages 2764–2770, Barcelona, Spain,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Object categorization by learned universal visual dictionary",
      "author" : [ "J. Winn", "A. Criminisi", "T. Minka" ],
      "venue" : "10th IEEE International Conference on Computer Vision, pages 1800–1807, Beijing, China,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Dirichlet-bernoulli alignment: A generative model for multi-class multi-label multi-instance corpora",
      "author" : [ "S.H. Yang", "H. Zha", "B.G. Hu" ],
      "venue" : "Advances in Neural Information Processing Systems 22, pages 2143–2150. MIT Press, Cambridge, MA,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Joint multi-label multi-instance learning for image classification",
      "author" : [ "Z.J. Zha", "X.S. Hua", "T. Mei", "J. Wang", "G.J. Qi", "Z. Wang" ],
      "venue" : "Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 1–8, Anchorage, AK,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "A k-nearest neighbor based multi-instance multi-label learning algorithm",
      "author" : [ "M.-L. Zhang" ],
      "venue" : "Proceedings of the 22nd IEEE International Conference on Tools with Artificial Intelligence, pages 207–212, Arras, France,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Mimlrbf: Rbf neural networks for multi-instance multi-label learning",
      "author" : [ "M.-L. Zhang", "Z.-J. Wang" ],
      "venue" : "Neurocomputing, 72(16):3951–3956,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Multi-instance multi-label learning with application to scene classification",
      "author" : [ "Z.-H. Zhou", "M.-L. Zhang" ],
      "venue" : "Advances in Neural Information Processing Systems 19, pages 1609–1616. MIT Press, Cambridge, MA,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Multi-instance multi-label learning",
      "author" : [ "Z.-H. Zhou", "M.-L. Zhang", "S.-J. Huang", "Y.-F. Li" ],
      "venue" : "Artificial Intelligence, 176(1):2291–2320,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 25,
      "context" : "For example, in image classification problems, an image usually contains multiple objects, and can be divided into several segments, where each segment is represented with an instance, and corresponds to a semantic label [26]; in text categorization tasks, an article may belong to multiple categories, and can be represented by a bag of instances, one for a paragraph [22]; in gene function prediction tasks, a gene usually has multiple labels since it is related to multiple functions, and can be represented with a set of images with different views [12].",
      "startOffset" : 221,
      "endOffset" : 225
    }, {
      "referenceID" : 21,
      "context" : "For example, in image classification problems, an image usually contains multiple objects, and can be divided into several segments, where each segment is represented with an instance, and corresponds to a semantic label [26]; in text categorization tasks, an article may belong to multiple categories, and can be represented by a bag of instances, one for a paragraph [22]; in gene function prediction tasks, a gene usually has multiple labels since it is related to multiple functions, and can be represented with a set of images with different views [12].",
      "startOffset" : 369,
      "endOffset" : 373
    }, {
      "referenceID" : 11,
      "context" : "For example, in image classification problems, an image usually contains multiple objects, and can be divided into several segments, where each segment is represented with an instance, and corresponds to a semantic label [26]; in text categorization tasks, an article may belong to multiple categories, and can be represented by a bag of instances, one for a paragraph [22]; in gene function prediction tasks, a gene usually has multiple labels since it is related to multiple functions, and can be represented with a set of images with different views [12].",
      "startOffset" : 553,
      "endOffset" : 557
    }, {
      "referenceID" : 26,
      "context" : "Multi-instance multi-label learning (MIML) is a recent proposed framework for such complicated objects [27].",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 25,
      "context" : "During the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27].",
      "startOffset" : 58,
      "endOffset" : 96
    }, {
      "referenceID" : 22,
      "context" : "During the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27].",
      "startOffset" : 58,
      "endOffset" : 96
    }, {
      "referenceID" : 8,
      "context" : "During the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27].",
      "startOffset" : 58,
      "endOffset" : 96
    }, {
      "referenceID" : 21,
      "context" : "During the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27].",
      "startOffset" : 58,
      "endOffset" : 96
    }, {
      "referenceID" : 24,
      "context" : "During the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27].",
      "startOffset" : 58,
      "endOffset" : 96
    }, {
      "referenceID" : 12,
      "context" : "During the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27].",
      "startOffset" : 58,
      "endOffset" : 96
    }, {
      "referenceID" : 14,
      "context" : "During the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27].",
      "startOffset" : 58,
      "endOffset" : 96
    }, {
      "referenceID" : 23,
      "context" : "During the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27].",
      "startOffset" : 58,
      "endOffset" : 96
    }, {
      "referenceID" : 3,
      "context" : "During the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27].",
      "startOffset" : 58,
      "endOffset" : 96
    }, {
      "referenceID" : 26,
      "context" : "During the past years, many MIML algorithms were proposed [26, 23, 9, 22, 25, 13, 15, 24, 4, 27].",
      "startOffset" : 58,
      "endOffset" : 96
    }, {
      "referenceID" : 10,
      "context" : "[11].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "It is usually assumed that a bag is positive if and only if it contains at least one positive instance [5, 4].",
      "startOffset" : 103,
      "endOffset" : 109
    }, {
      "referenceID" : 3,
      "context" : "It is usually assumed that a bag is positive if and only if it contains at least one positive instance [5, 4].",
      "startOffset" : 103,
      "endOffset" : 109
    }, {
      "referenceID" : 18,
      "context" : "Based on R(X, l), we further define the ranking error [19] with respect to an example X on label l as",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 1,
      "context" : "We instead explore the following hinge loss, which has been shown as an optimal choice among all convex surrogate losses [2], Ψ(X, l) = ∑ j∈Ȳ (X, l) |1 + fj(X)− fl(X)|+ R(X, l) , (5)",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 15,
      "context" : "We then employ stochastic gradient descent (SGD) [16] to minimize the ranking error.",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 19,
      "context" : "[20].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "However, in multi-label learning, the bag Xtest may have more than one label; and thus one do not know how many labels should be selected as relevant ones from the ranked label list [8].",
      "startOffset" : 182,
      "endOffset" : 185
    }, {
      "referenceID" : 21,
      "context" : "We compare MIMLfast with six state-of-the-art MIML methods: DBA [22], a generative model for MIML learning; KISAR [11], a MIML algorithm tries to discover instance-label relation; 10",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 10,
      "context" : "We compare MIMLfast with six state-of-the-art MIML methods: DBA [22], a generative model for MIML learning; KISAR [11], a MIML algorithm tries to discover instance-label relation; 10",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 25,
      "context" : "MIMLBoost [26], a boosting method decomposes MIML into multi-instance single label problems; MIMLkNN [24], a MIML nearest neighbor algorithm; MIMLSVM [26], a SVM style algorithm which decomposes MIML into single instance multi-label problems; and RankLossSIM [4], a MIML algorithm minimizes ranking loss for instance annotation.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 23,
      "context" : "MIMLBoost [26], a boosting method decomposes MIML into multi-instance single label problems; MIMLkNN [24], a MIML nearest neighbor algorithm; MIMLSVM [26], a SVM style algorithm which decomposes MIML into single instance multi-label problems; and RankLossSIM [4], a MIML algorithm minimizes ranking loss for instance annotation.",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 25,
      "context" : "MIMLBoost [26], a boosting method decomposes MIML into multi-instance single label problems; MIMLkNN [24], a MIML nearest neighbor algorithm; MIMLSVM [26], a SVM style algorithm which decomposes MIML into single instance multi-label problems; and RankLossSIM [4], a MIML algorithm minimizes ranking loss for instance annotation.",
      "startOffset" : 150,
      "endOffset" : 154
    }, {
      "referenceID" : 3,
      "context" : "MIMLBoost [26], a boosting method decomposes MIML into multi-instance single label problems; MIMLkNN [24], a MIML nearest neighbor algorithm; MIMLSVM [26], a SVM style algorithm which decomposes MIML into single instance multi-label problems; and RankLossSIM [4], a MIML algorithm minimizes ranking loss for instance annotation.",
      "startOffset" : 259,
      "endOffset" : 262
    }, {
      "referenceID" : 25,
      "context" : "Scene [26] consists of 2000 images for scene classification, and is associated with 5 possible labels: desert, mountains, sea, sunset and trees.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 13,
      "context" : "For each image, a bag of 9 instances is extracted via SBN [14].",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 17,
      "context" : "Reuters is constructed based on the Reuters-21578 data set [18] with the sliding window technique in [1].",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 0,
      "context" : "Reuters is constructed based on the Reuters-21578 data set [18] with the sliding window technique in [1].",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 3,
      "context" : "in their recent work [4]: Letter Carroll and Letter Frost are constructed using the UCI Letter Recognition dataset [7], where a bag is created for each word, and labels correspond to the letters.",
      "startOffset" : 21,
      "endOffset" : 24
    }, {
      "referenceID" : 6,
      "context" : "in their recent work [4]: Letter Carroll and Letter Frost are constructed using the UCI Letter Recognition dataset [7], where a bag is created for each word, and labels correspond to the letters.",
      "startOffset" : 115,
      "endOffset" : 118
    }, {
      "referenceID" : 20,
      "context" : "MSRC v2 is a subset of the Microsoft Research Cambridge (MSRC) image dataset [21].",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 5,
      "context" : "Corel5K [6] contains 5000 segmented images and 260 class labels, and each image is represented by 9 instances on average.",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 9,
      "context" : "MSRA [10] is a multimedia database collected by Microsoft Research Asia, the subset used in this work contains 30000 images with 99 possible labels, and each image is represented with a bag of 9 instances.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 2,
      "context" : "For MIMLfast, the step size is in the form γt = γ0/(1+ηγ0t) according to [3].",
      "startOffset" : 73,
      "endOffset" : 76
    }, {
      "referenceID" : 0,
      "context" : "Note that coverage is normalized by the number of labels such that all criteria are in the interval [0, 1].",
      "startOffset" : 100,
      "endOffset" : 106
    }, {
      "referenceID" : 16,
      "context" : "The definition of these criteria can be found in [17, 27].",
      "startOffset" : 49,
      "endOffset" : 57
    }, {
      "referenceID" : 26,
      "context" : "The definition of these criteria can be found in [17, 27].",
      "startOffset" : 49,
      "endOffset" : 57
    }, {
      "referenceID" : 10,
      "context" : "Inspired by [11], by assuming that each label is triggered by its most positive instance, our MIMLfast approach is able to identify the key instance for each label.",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 10,
      "context" : "On MSRA, following [11], we first partition each image into a set of patches with k-means clustering, and",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 10,
      "context" : "For MIMLfast and RankLossSIM, the key instance for a specific label is identified by selecting the instance with maximum prediction value on that label, while for KISAR, key instance is the one closest to the prototype of the label as in [11].",
      "startOffset" : 238,
      "endOffset" : 242
    }, {
      "referenceID" : 25,
      "context" : "For example, MIMLSVM [26] degenerated the MIML problem into single-instance multi-label tasks to solve.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 25,
      "context" : "MIMLBoost [26] degenerated MIML to multi-instance single-label learning.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 21,
      "context" : "[22].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "Nearest neighbor and neural network approaches for MIML were proposed in [24] and [25], respectively.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 24,
      "context" : "Nearest neighbor and neural network approaches for MIML were proposed in [24] and [25], respectively.",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 22,
      "context" : "[23] proposed a hidden conditional random field model for MIML image annotation.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 3,
      "context" : "[4] proposed to optimize ranking loss for MIML instance annotation.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 10,
      "context" : "In [11], the authors tried to discover what patters trigger what labels in MIML learning by constructing a prototype for each label with clustering.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 19,
      "context" : "In [20], a similar technique was used to optimize WARP loss for image annotation; however, it dealt with single-instance single-label problem, which is quite different from our MIML problem.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 26,
      "context" : "In [27], an approach of discovering sub-concepts for complicated concepts was proposed based",
      "startOffset" : 3,
      "endOffset" : 7
    } ],
    "year" : 2013,
    "abstractText" : "In many real-world tasks, particularly those involving data objects with complicated semantics such as images and texts, one object can be represented by multiple instances and simultaneously be associated with multiple labels. Such tasks can be formulated as multi-instance multi-label learning (MIML) problems, and have been extensively studied during the past few years. Existing MIML approaches have been found useful in many applications; however, most of them can only handle moderate-sized data. To efficiently handle large data sets, in this paper we propose the MIMLfast approach, which first constructs a low-dimensional subspace shared by all labels, and then trains label specific linear models to optimize approximated ranking loss via stochastic gradient descent. Although the MIML problem is complicated, MIMLfast is able to achieve excellent performance by exploiting label relations with shared space and discovering sub-concepts for complicated labels. Experiments show that the performance of MIMLfast is highly competitive to state-of-the-art techniques, whereas its time cost is much less; particularly, on a data set with 20K bags and 180K instances, MIMLfast is more than 100 times faster than existing MIML approaches. On a larger data set where none of existing approaches can return results in 24 hours, MIMLfast takes only 12 minutes. Moreover, our approach is able to identify the most representative instance for each label, and thus providing a chance to understand the relation between input patterns and output label semantics.",
    "creator" : "LaTeX with hyperref package"
  }
}