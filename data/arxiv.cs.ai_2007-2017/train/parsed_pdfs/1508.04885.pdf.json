{
  "name" : "1508.04885.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Efficient Computation of Exact IRV Margins",
    "authors" : [ "Michelle Blom", "Peter J. Stuckey", "Vanessa J. Teague", "Ron Tidhar" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 8.\n04 88\n5v 1\n[ cs\n.A I]\n2 0\nA ug\n2 01"
    }, {
      "heading" : "1 Introduction",
      "text" : "Instant Runoff Voting (IRV) is system of preferential voting in which voters rank candidates in order of preference. IRV is used for all parliamentary lower house elections in Australia, parliamentary elections in Fiji and Papua New Guinea, presidential elections in Ireland and Bosnia/Herzogovinia, and local elections in numerous locations world-wide, including the UK and United States [Richie, 2004]. Given a field of candidates A, B, C, D, the ranking [A,B,C], in an IRV election, expresses a first preference for candidate A, a second preference for B, and a third for C. Ballots are distributed to their first ranked candidate, and redistributed to subsequent preferences during one or more rounds of candidate elimination. IRV has many advantages over first-past-the-post – in which ballots are cast for a single candidate, and the candidate with the most votes declared the winner. For example, it reduces the “spoiler” effect by allowing voters to express a first preference for a candidate unlikely to gather much support, followed by a later preference for a candidate more likely to win. Although there are still opportunities for strategic (i.e. dishonest) voting, these are less prevalent than they are for first-past-the-post.\nIt is difficult, however, to compute either the true runner-up of an IRV election, or the margin by which they lost. Consequently, it is difficult to establish whether a small problem in an election could have made a difference to the outcome. Disputing an election outcome, or proving that it is correct, generally requires some argument comparing the electoral margin to the precision of the process. For example, risk-limiting audits [Lindeman and Stark, 2012] require knowledge of the victory margin to determine how much auditing is required. A close election, in which the margin of victory is small, requires more auditing than one with a large margin.\nAutomatic recounting of ballots, for example, is triggered in many jurisdictions if the last round margin (the difference between the tallies of the last two remaining candidates, divided by two and rounded up) of an IRV election falls below a threshold. The 2013 Federal Election for the Australian seat of Fairfax, in Queensland, for example, had a last round margin of just 4 votes, triggering a recount [AP, 2013]. The actual margin of victory for an IRV election, however, may be much lower than its last round margin. The 2011 federal election for the Australian seat of Balmain, New South Wales, had a last round margin of 1239 votes, with 2477 votes separating the last two remaining candidates – a Liberal and a Green [NSWEC, 2011]. The actual margin of victory, however, was at most 388 votes, with 775 votes separating the Greens and\n1\nLabor in a prior round of elimination. Last round margins will therefore trigger recounts in only a portion of eligible IRV elections.\nThis paper contributes a practical algorithm for exact IRV margin computation that substantially improves on the current best-known approach by Magrino et al. [2011]. On 25 IRV elections held in the United States between 2007 and 2010, Magrino et al. [2011] compute margins in several hundred seconds in 24 of the 25 instances, and fail to compute a margin within 12 hours in the remainder. Although exponential in the worst case, our algorithm runs efficiently in practice on all real election instances for which we could obtain data. On all 25 IRV elections examined by Magrino et al. [2011], our algorithm computes exact margins in less than 2 seconds.\nAn obvious, but inefficient, algorithm for computing exact IRV margins is to consider every possible order in which candidates could have been eliminated, and use a linear program (LP) solver such as CPLEX to compute the exact number of manipulations (ballot modifications, additions, and deletions) necessary to achieve it. Magrino et al. [2011] improve upon this with clever ways to identify which elimination orders are not worth investigating. Our algorithm follows the same basic structure but introduces a new, easily computed, lower bound on the number of ballot manipulations required to realise any given elimination order, allowing us to eliminate whole classes of possible orders very quickly. This significantly improves upon the time required to compute exact margins of victory.\nMagrino et al. [2011] compute margins under the assumption that any manipulation applied to the set of ballots cast in an election must leave the number of ballots unchanged. We present several variations of our algorithm in which this assumption is not required. This allows us to answer a number of important questions, including the potential influence of lost ballots (could their inclusion have altered the election outcome?) and informal ballots (incorrectly filled out ballots excluded from the count). One question of interest is “how many ballots must be added to the election profile to realise a different outcome?”. If this number of ballots is less than the number of lost or spoiled ballots, we can say that these ballots have the potential to change the election outcome. In the 2013 Australian federal election (lower house), the number of informal votes totalled 5.91% of all ballots cast – the highest rate experienced since 1984 [SBS, 2014].\nA separate, but equally important, question is “how many ballots, of those cast, must we remove to change the election outcome?”. This question is of particular relevance in jurisdictions that suffer from multiple voting. In Australian state and federal elections, each polling station has a book containing the names and addresses of all electors in the region. As each elector casts their vote, their name is struck off by hand. This does not prevent an elector, however, from casting multiple votes in multiple polling booths. In the 2013 Australian federal election, the Australian Electoral Commission (AEC) ‘investigated almost 19,000 instances of multiple voting’ [ABC, 2014]. In this situation we know that there are a certain number of invalid ballots, but not which ballots are invalid. If this total exceeds the number of ballots that, if removed, change the result of the election, we know we have a problem.\nThe answer to the two questions described above can be obtained by calculating the electoral victory margin under the assumption that ballots can only be added to the election (addition only) or removed (deletion only), respectively. We consider both settings in this paper.\nThe remainder of this paper is structured as follows. We describe existing approaches designed to compute bounds on, and exact values for, the margin of victory in IRV elections in Section 2. The manner in which counting proceeds in IRV elections, and a formal definition of the margin of victory, is presented in Section 3. Sections 4 and 5 describe and evaluate our algorithm for the exact computation of IRV margins. Section 6 examines two variations of our algorithm in which ballots may be deleted from or added to an election profile, but not both. We conclude in Section 7 with a discussion of expected future work."
    }, {
      "heading" : "2 Related Work",
      "text" : "Exact computation of IRV electoral margins is NP-hard. Bartholdi III and Orlin [1991] have demonstrated that it is NP-hard to compute a preference ordering on a set of candidates C that, when combined with the preferences of a set of voters V , results in the election of a specific candidate c ∈ C. However, this result is defined in terms of the number of candidates, not the number of votes, so this may not imply that the\n2\nproblem is hard in practice when the number of candidates is small. Related NP-hardness results have been presented by Conitzer et al. [2003] and Conitzer et al. [2007].\nThese results refer to the worst case complexity of manipulating a voting scheme. Procaccia and Rosenchein [2007] demonstrate that given certain assumptions regarding the distribution of votes in an election, it is possible to find voting rules that are average-case hard to manipulate. Conitzer and Sandholm [2006] highlight that efficient algorithms can be designed to successfully compute such manipulations in many real instances, proving that it is impossible to design a voting rule for which computing a manipulation is “usually hard”. Friedgut et al. [2008] and Isaksson et al. [2012] have shown that for a very general class of voting schemes, a random manipulation by a random voter will succeed in altering the outcome of an election with a non-negligible probability. This result is a quantitative expression of the Gibbard-Satterthwaite theorem [Gibbard, 1973, Satterthwaite, 1975]. Gibbard [1973] demonstrates that any non-dictatorial voting scheme, involving at least three candidates, can be manipulated by an individual voter. Satterthwaite [1975] proves that any strategy-proof voting scheme (a scheme that cannot be manipulated by a voter misrepresenting their preferences to achieve a desired outcome) is dictatorial, meaning that a single entity holds absolute power in determining the outcome. While, in the worst case, the complexity of finding a strategic manipulation of an IRV election to achieve a desired outcome is NP-hard, it is possible, with some probability, to achieve such a manipulation via random selection.\nMany authors have developed algorithms for the computation of victory margins in IRV elections that can be efficiently applied in most real instances. Cary [2011] defines several upper and lower bounds on the true IRV margin of victory, including one called the “Winner Elimination Upper Bound” which simply finds the most efficient way to eliminate the apparent winner at each elimination round, and returns the least-cost (involving the smallest number of vote changes) of these. Sarwate et al. [2013] provide bounds on the margin of victory for IRV and various other complex voting schemes. Sarwate et al. [2013] compute lower bounds on the margin of victory in IRV elections by picking sets of candidates to eliminate in order to maximise the difference between the number of votes allocated to the candidates in these sets, and to the remaining candidate with the fewest votes. The bounds defined by Cary [2011] and Sarwate et al. [2013] can be computed in polynomial time, but are not necessarily tight (i.e. these bounds may differ significantly from the true margin).\nSarwate et al. [2013] compare their computed bounds to exact margins for a set of IRV elections conducted in the United States, and three Irish elections. In the 31 elections in which exact margins were known, computed lower bounds equalled exact margins in 18 elections, and fell below exact margins by a number of votes equaling 0.6 to 19% of the total votes cast in the remainder. Computed upper bounds were typically within a few votes of exact margins, with a number of exceptions. For the 2009 Aspen City Council election, which forms part of the data set considered in this paper, the lower and upper bound of Sarwate et al. [2013] differ from the exact margin by 2.5% (62 votes) and 9.9% (254 votes) of the total number of votes, respectively. The algorithm we present in this paper for the exact computation of IRV margins finds the exact margin of victory in this election within 1.5 seconds. In the 2008 race for Pierce County assessor, their lower and upper bound differ from the exact margin by 0.6% (1945 votes) and 1.6% (5079 votes) of the total number of votes, respectively. Our algorithm computes the exact margin in this race within 0.02 seconds.\nMagrino et al. [2011] present a branch-and-bound algorithm (MRSW) to compute the exact margin of victory in IRV elections. Applied to 25 IRV elections in the United States, their approach successfully computes exact margins in all but one instance. Magrino et al. [2011] consider the space of possible alternate elimination orders of a set of candidates C, in which the actual winner cw ∈ C is not the last remaining candidate. Given one such order, a linear program (LP) is presented which computes the smallest number of votes (of those cast in the election) that must be modified in order to realise this elimination order. When applied to a partial sequence of candidates, L, the LP computes the smallest number of ballot changes required to achieve this order of elimination in a reduced election profile, in which all candidates not in L have been eliminated (and their votes redistributed). It is clear that this bound is also a lower bound on the number of ballot changes required to achieve any elimination order (involving all candidates) ending in L.\nMagrino et al. [2011] first construct a priority queue, initially containing one node for each candidate in C \\ cw. The lower bound assigned to each of these nodes is (necessarily) 0. In the reduced election profiles\n3\ncomputed for each node, only one candidate remains, and thus no votes need be changed to ensure their election. Each node in the queue is expanded to add several new partial elimination orders to the search tree – the expansion of [ci], for example, adds a node [cj , ci] to the queue, for all cj ∈ C \\ ci. Each of these new nodes is assigned a lower bound, computed by the provided LP. Nodes with the smallest lower bounds are prioritised for expansion. The smallest LP evaluation obtained for each visited leaf node (orders containing all candidates) provides an upper bound on the smallest manipulation required to alter the election result. Nodes are pruned from the tree (none of their descendants are explored) if their lower bound is larger than this upper bound.\nThe main restricting cost of MRSW is the number of nodes that are explored and evaluated via the LP. The algorithm we present in this paper dramatically reduces the number of partial elimination orders explored in the computation of exact margins, relative to MRSW, through the use of a scoring rule assigning tighter lower bounds to nodes close to the root of the search tree. We are consequently able to prune larger portions of the search space."
    }, {
      "heading" : "3 Counting Votes in an IRV Election",
      "text" : "Consider the example election of Table 1, between four candidates A, B, C, and D, taken from Magrino et al. [2011]. Each ballot (vote) is a list of candidates, ranked in preference order. For example, ballot [A,B,C] denotes that the voter likes candidate A best, then B, and then C. The ranking [A,B,C] is alternately known as the signature of the ballot. Voters may express partial preferences, such as [A] which simply votes for candidate A, or [A,B] which prefers A to B and no more. Table 1a lists the candidate rankings present across the set of ballots cast in this election, alongside the number of ballots in which each of these rankings appear. For example, 40 voters cast ballots with the ranking [A, C, B, D], and 5 with [D, B, C, A].\nThe tallying of votes in an IRV election proceeds by a series of rounds in which the candidate with the lowest tally is eliminated — see Figure 1 — with the last remaining candidate declared the winner. For each candidate c, we first compute the number of ballots in which c is ranked first. Table 1b reports the total number of first preference ballots in each candidates’ tally (their Initial Tally). Candidate A has the most first preference votes at 40. Candidate D has the fewest at 5, and is eliminated in the first round. The 5 votes in D’s tally are redistributed to B, who has 26 ballots in their tally after the second round of counting. Continuing in this fashion, candidate C is next eliminated. All of the ballots in C’s tally have A as the next preferred candidate, and are thus redistributed to A. In the third round of counting, A has 60 votes while B has 26. The elimination of candidate B results in the election of A. In practice, the total number of votes reduces as the tallying algorithm progresses, as some voters express only a partial list of preferences. When the last ranked candidate in a ballot is eliminated, this ballot is deemed exhausted.\nIt is tempting to think that the difference in the tallies of the two last remaining candidates in an IRV election is the true number of votes by which the winner won. However, this is not necessarily the case. Consider for example the (very close) election for the seat of Balmain in the Australian state of New South Wales in 2011 [NSWEC, 2011]. This was a genuine three-way race between the Labor Party, the Liberal Party and the Greens. The last two rounds of elimination are shown in Table 2. In the final round, the Greens won comfortably over the Liberal Party. However, in a prior round they only very narrowly defeated\n4\nthe Labor Party, from which almost all votes then passed their next preferences to the Greens. The large margin in the last round does not reflect the true difference between winner and losers, which was actually determined by the (very small) difference between Labor and the Greens in a prior elimination round.\nWe define the margin of victory of an election as the smallest number of ballots that if modified, by some adversary, will result in the election of a different candidate [Magrino et al., 2011]. If several candidates receive the same number of votes, at any stage of the IRV count, we assume that the adversary can decide which of the candidates is eliminated. This assumption is made by Magrino et al. [2011]. If an adversary cannot determine which of these tied candidates is eliminated, the margin of victory of Definition 2 slightly underestimates (but never overestimates) the margin of victory of the election. We define the last round margin of an election in Definition 1.\nDefinition 1 Last Round Margin The last round margin of an election, B, in which two candidates ci, cj ∈ C remain with t{ci,cj}(ci) and t{ci,cj}(cj) ballots in their tally, is equal to half the difference between the tallies of the two remaining candidates rounded up.\nLRMB = ⌈ |t{ci,cj}(ci)− t{ci,cj}(cj)|\n2 ⌉ (1)\nDefinition 2 Margin of Victory The true margin of victory in an election between candidates c1, c2, . . . ,cn ∈ C, with winner cw ∈ C, is the smallest number of ballots whose ranking must be modified so that a different candidate cj ∈ C \\ cw becomes the winner of the election.\nIn the election of Table 1, the last round margin, by Definition 1, is 17 votes, while the true margin of victory, by Definition 2, is only 3 votes. Let us consider an alternative election profile to that shown in Table 1a, in which 3 of the 5 votes with ranking [D, B, C, A] are changed to [D, C]. After candidate D is eliminated, 2 votes are distributed to candidate B, and 3 to C. Candidates B and C have equal tallies of 23 votes. If our adversary decides to eliminate candidate B, the tallies of candidates A and C in the third round of counting are now 40 and 46, respectively. All of B’s 23 votes were distributed to candidate C."
    }, {
      "heading" : "4 Fast Margin Computation via Branch-and-Bound",
      "text" : "We present a branch-and-bound algorithm for the computation of victory margins in IRV elections. This algorithm has the same basic structure as that of Magrino et al. [2011], being a traversal of the tree of possible orders of candidate elimination. Our algorithm incorporates a substantially improved pruning rule, however, allowing us to dramatically reduce the portion of this tree we must traverse to determine the exact victory margin. In this section, we describe our algorithm in detail and contrast its performance against the current state-of-the-art approach of Magrino et al. [2011] on 29 IRV elections held in the United States between 2007 and 2014.\n5"
    }, {
      "heading" : "4.1 Preliminaries",
      "text" : "Let C be the set of candidates in an election B. We refer to sequences of candidates π in list notation, e.g. π = [A,C,D,B], and use such sequences to represent both ballots and elimination orders. We will often treat a sequence as the set of elements it contains. An election B is defined as a multiset1 of ballots, each ballot b ∈ B a sequence of candidates in C, with no duplicates, listed in order of preference (most preferred to least preferred). Let first(π) denote the first candidate appearing in sequence π. At any stage in the counting of an IRV election, there are a current set of eliminated candidates E and a current set of candidates still standing S = C \\ E . The winner cw of the election is the last standing candidate.\nDefinition 3 Projection pS(π) We define the projection of a sequence π onto a set S as the largest subsequence of π that contains only elements of S. (The elements keep their relative order in π). For example:\np{B,C}([A,B,D,C]) = [B,C] and p{B,C,D,E}([F,D,G,B,A]) = [D,B].\nThroughout the counting process, each candidate c ∈ C has a tally of ballots. Ballots can be added to this tally upon the elimination of a candidate c′ ∈ C \\ c, and are redistributed from this tally upon the elimination of c. We formally define a candidate’s tally as follows.\nDefinition 4 Tally tS(c) Given candidates S ⊆ C are still standing in an election B, the tally for a candidate c ∈ C is denoted tS(c), and is defined as the number of ballots b ∈ B for which c is the mostpreferred candidate of those remaining. Recall that each ballot b ∈ B is a sequence of candidates, and pS(b) the sequence of candidates mentioned in b that are also in S.\ntS(c) = |[b | b ∈ B, c = first(pS(b))]| (2)\nUsing the notation presented in this section, we can formalise the IRV counting algorithm of Figure 1 as shown in Figure 2."
    }, {
      "heading" : "4.2 The MRSW Branch-and-Bound Algorithm",
      "text" : "In order to obtain a new result (a new winner) in an election B we must modify the ballots of the election to give a new elimination order (i.e. where the winning candidate is not the last candidate standing). The MRSW algorithm [Magrino et al., 2011] investigates, without traversing all of, the tree of all possible elimination orders. The goal of the algorithm presented by Magrino et al. [2011] is to find the alternate elimination order requiring the smallest number of ballots in B to be modified. A modification of a ballot b ∈ B is defined as a replacing the sequence of candidates appearing in b with a new sequence (not necessarily involving the same set of candidates). The number of ballot changes required to realise this elimination order is, by Definition 2, the margin of victory. Several such orders may exist for an election, where each requires the least number of ballot changes. We call each such order a least change alternate elimination order.\n1A multiset allows for the inclusion of duplicate items.\n6\nEach node in the tree constructed by Magrino et al. [2011] represents a (partial) elimination order π, where π ⊆ C. Each node π has children constructed by adding a candidate in C \\ π to the front of the elimination order. The root of the tree, labelled with the empty sequence [], has children labelled [c] for each c ∈ C \\ {cw}, where cw is the winner of B. A node [cw] is not added to this tree, as we do not need to consider elimination orders which do not change the result of the election. We can think of each node in the tree as representing a reduced election Bπ = [pπ(b)|b ∈ B] of only the candidates in π. All candidates not in π have been removed from their positions in each ballot b ∈ B. The sequence π denotes an elimination order for the candidates in this reduced election. Each descendant of node [c] represents an elimination order in which c ∈ C is the winner in its associated reduced election. The leaves of this tree are each a sequence containing all candidates in C, and represent an alternate elimination order for B.\nFigure 3a shows the tree constructed for the election of Table 1, after a child [c] for each c ∈ C \\ {cw} has been added to the root []. This tree is traversed by adding children to the node which we expect will lead to a least change alternate elimination order. In the MRSW algorithm, each node π is assigned a score using a linear program (LP), denoted DistanceTo(π, C, B). This LP, presented in Appendix A, computes the smallest number of ballots in B that must be modified to realise the elimination order π in the reduced election Bπ. Magrino et al. [2011] show that this number is a lower bound on the number of ballots in the (non-reduced) election B that must be changed to realise an elimination order than ends in the sequence π. Magrino et al. [2011] add children to (expand) nodes which have the lowest assigned score. The score computed by DistanceTo(π, C, B) for a leaf node π represents exactly the number of ballots in B that must be modified to realise the elimination order π. The smallest score assigned to any leaf node visited while traversing the tree of elimination orders defines an upper bound (U) on the smallest number of ballot changes required to alter the result of the election. Any subsequently visited node with a score equal to or greater than U can be pruned from the tree, as it is clear it will not lead to an order requiring fewer than U ballot changes to realise.\nFigure 4 formally defines the branch-and-bound algorithm of Magrino et al. [2011], denoted MRSW. A fringe of nodes Q is maintained to represent the evolving search tree. Initially, Q is empty (Step 1) and the upper bound on the number of ballot changes required to change the election result is set to the last round margin of the election, as per Definition 1 (Step 2). A node for each candidate in C \\ {cw}, where cw is the winner of the election, is scored and added to the fringe in Steps 3–6. The elimination order π in Q with the lowest score is expanded and its children (each child is created by adding a candidate c ∈ C, c 6∈ π, to the front of π) are added to Q if their score is less than the current upper bound U (Step 11 and Steps 16–20). The children that are not added to Q have been pruned from the tree. If a child represents a complete elimination order (an order containing all candidates), this child is a leaf node. If the score l of this leaf is less than U , the upper bound is set to l (Step 14). The algorithm terminates when no nodes remain in Q – all possible nodes in the search tree have been visited and scored, or pruned – returning U (Step 12). At the conclusion of the algorithm, U is equal to the smallest score assigned to any visited leaf node. It thus represents the smallest number of ballot changes required to alter the result of election B.\nFigure 3b shows the tree constructed for the election of Table 1, after node [B] has been expanded (Step 11). In Step 2, U was set to the last round margin for this election, which is 17. Nodes [A,B] and [C,B], each with a score of 17, are pruned from the tree.\n7"
    }, {
      "heading" : "4.3 An Improved Scoring Function",
      "text" : "Let us consider a partial elimination order π ⊆ C. Each candidate e ∈ C \\ π must be eliminated before every candidate c ∈ π. We define ∆(c, e) as the number of ballots b ∈ B for which c is ranked higher than e, or c appears and e does not. This is equal to the number of ballots with rankings [c, e] or [c] when all candidates apart from c and e are removed. At any time e is eliminated before c, c has a tally of at most ∆(c, e) at the moment e is eliminated, with all other ballots assigned to e, or another candidate. Recall that pS(b) denotes the projection of b onto set S (ie. the ranking of ballot b with all candidates not in the set S removed).\n∆(c, e) = | [ b | b ∈ B, p{c,e}(b) ∈ {[c, e], [c]} ] | (3)\nWe define the primary vote of a candidate c ∈ C, denoted f(c), as the number of ballots b ∈ B for which c is the highest ranked candidate.\nf(c) = | [ b | b ∈ B, c = first(b) ] | (4)\nTo ensure that candidate e is eliminated before candidate c, we require that f(e) ≤ ∆(c, e). In other words, we require that the primary vote of e is less than or equal to the number of ballots in which c is ranked higher than e, or c appears and e does not. If it is the case that f(e) > ∆(c, e), we need to change the relative counts by the amount f(e)−∆(c, e) for this order of elimination to be feasible. Let l1(c, e) denote a lower bound on the number of ballots that must be modified to achieve the elimination of e before c.\nl1(c, e) = ⌈ f(e)−∆(c, e)\n2 ⌉ (5)\nSince each candidate e ∈ C\\π has been eliminated prior to every candidate c ∈ π, we can compute a lower bound on the number of ballots in B that must be modified in order to realise an elimination order ending in π, lb1(π), as shown in Equation 6. This lower bound does not consider the order in which candidates are eliminated in π, but calculates the number of ballots we must alter to get to a situation in which the candidates in π are the last candidates standing.\nlb1(π) = max{l1(c ′, e′) | c′ ∈ π, e′ ∈ C \\ π} (6)\nWe can improve this reasoning further. Consider the partial elimination order π, for which all candidates e ∈ C \\ π are eliminated before any c ∈ π. We know that e has at least f(e) ballots in its tally. Candidate c may not have, in their tally, all ballots which have been counted toward ∆(c, e) (those in which c appears before e, or c appears, but e does not). Some of these ballots may lie in the tallies of other candidates in π, who have not yet been eliminated. We define ∆S(c, e) as the maximum number of ballots that c can have\n8\nin their tally at the moment e is eliminated, where S = {e} ∪ π denotes the minimal set of candidates that must be ‘still standing’ at this time.\n∆S(c, e) = | [ b | b ∈ B, c = first(pS(b) ] | (7)\nTo realise a situation in which candidate e ∈ C \\ π is eliminated prior to candidate c ∈ π, we require that f(e) ≤ ∆S(c, e), and hence if f(e) > ∆S(c, e) then we must modify at least l2(c, e, π) ballots.\nl2(c, e, π) = ⌈ f(e)−∆S(c, e)\n2 ⌉ (8)\nA tighter lower bound on the number of ballots in B that must be changed to realise the situation where π ⊆ C are the last remaining candidates, lb2(π), is shown in Equation 9. Note that l2(c, e, π) ≤ l1(c, e), for all π ⊆ C, c ∈ π, and e ∈ C \\ π. Hence, lb2(π) ≥ lb1(π) for all π ⊆ C.\nlb2(π) = max{l2(c, e, π) | c ∈ π, e ∈ C \\ π} (9)\nThis lower bound is independent of the order of candidates in π."
    }, {
      "heading" : "4.4 An Improved Branch-and-Bound Algorithm",
      "text" : "We can modify the MRSW algorithm of Magrino et al. [2011] to use the new lower bound computed in Equation 9 as shown in Figure 5. The principal advantage of this modified algorithm is that lb2(π) takes into account the candidates that must have been eliminated prior to those in π, while DistanceTo(π, C, B)\n9\nconsiders only the candidates that are in π, and their order of elimination. Our algorithm computes lb2(π) for each visited node π, and prunes those that we know will not lead to a least change alternate order. We add a node π to the tree with a score equal to the maximum of lb2(π) and DistanceTo(π, C, B), but avoid solving the DistanceTo LP if lb2(π) is already too large for π to be of interest.\nConsider the example election of Table 1. Figure 6 highlights which elimination orders are considered by the algorithm of Magrino et al. [2011] in its computation of the exact margin. Each node denotes an elimination order that is traversed and evaluated by the MRSW algorithm, with its score recorded. For example, the MRSW algorithm first considers the partial elimination orders [B], [C], and [D], assigning each a score of 0. The upper bound on the degree of manipulation required to change the outcome of the election is initially set to 17 ballots. The algorithm expands node [D], adding its children to the tree – [A,D] with a score of 17, [B,D] with a score of 28, and [C,D] with a score of 38. All three of these nodes have a score that is equal to or greater than 17, and are not considered further. Node [C] is expanded, creating children [A,C], [B,C], and [D,C], each with a score of 0. In our implementation of MRSW, node [A,C] is expanded next, creating child nodes [B,A,C], with a score of 3, and [D,A,C] with a score of 0. The leaf node [B,D,A,C] is then visited and assigned a score of 8, setting the current upper bound to 8. Nodes [B,C] and [D,C] are considered in turn, visiting 5 additional nodes. At this point, node [B,A,C] has the lowest score at 3. The leaf [D,B,A,C] is visited and assigned a score of 3, setting the current upper bound to 3. No remaining node has a score lower than 3, and the algorithm terminates. In total, MRSW visits 23 nodes and solves 20 LPs.\nOn this example election, our algorithm visits and evaluates the subset of shaded nodes in Figure 6,\n10\nreporting beside each node the score we assign to it. Nodes [B], [C], and [D], are assigned scores of 7, 0, and 8, respectively. This allows us to concentrate on elimination orders ending in C. Nodes [A,C], [B,C], and [D,C], are assigned scores of 1, 10, and 18. Node [D,C] can be immediately pruned from the tree. Nodes [B,A,C] and [D,A,C] are then considered, with scores of 1 and 8, respectively. The leaf node [D,B,A,C] is considered, and given a score of 3. No nodes remain with scores lower than 3, and so our algorithm is able to prune the remainder of the search space, and return a margin of 3. Our algorithm assigns scores to 9 nodes, but solves only 5 LPs in the process. The MRSW algorithm, in contrast, solves 20 LPs (not requiring an LP solve for the immediate children of the root, nodes [B], [C], and [D])."
    }, {
      "heading" : "5 Computational Results",
      "text" : "We have evaluated the branch-and-bound algorithm we present in Figure 5 on 29 IRV elections held in the United States. Moreover, we contrast the performance of our approach on this data set with that of the MRSW algorithm of Magrino et al. [2011]. Execution was performed on a machine with four 2.10 GHz CPUs, 7.7 GB of memory, and with a 12 hour timeout. CPLEX 12.5.1 was used to solve all LPs. Table 3 reports, for each of the 29 IRV elections considered, the number of candidates and ballots cast in the election, the\n11\nnumber of calls to the DistanceTo LP made by MRSW and by our improved branch-and-bound algorithm (denoted margin), the computation time (in milliseconds) of the two algorithms, the margin of victory and the last-round margin.\nIt is clear that our algorithm substantially reduces both the number of calls to DistanceTo and the computation time. We are able to compute the margin of victory in the 2007 San Francisco Mayor instance, where MRSW timed out after 12 hours. The results in Table 3 replicate those of Magrino et al. [2011] in terms of margins calculated.2 In generating these results, our algorithm uses the tighter lb2 pruning rule of Equation 9. We compare these results with those obtained when pruning with lb1 (Equation 6), in Table 6, shown in Appendix B."
    }, {
      "heading" : "6 Variations",
      "text" : "While our margin of victory calculations concentrate on the least number of ballot modifications required to change the result of an election, sometimes we wish to ask a slightly different question."
    }, {
      "heading" : "6.1 Addition only",
      "text" : "Suppose some ballots are lost during an election. The question of whether the lost ballots could change the result of the election asks “what is the minimum number of ballots required to be added to change the result of the election.” The extension of our margin algorithm (shown in Figure 5) to answer this question is straightforward.\nWe first modify the last round margin calculation of Definition 1. In this setting, manipulations can only add ballots. Hence, we define the last round margin (addition only) to be the difference in tallies of the last two remaining candidates ci and cj (the margin is not divided by two):\nLRM+B = |t{ci,cj}(ci)− t{ci,cj}(cj)|\nSimilarly, we redefine l1 of Equation (5) to compute a lower bound on the number of ballots that must be added to ensure that candidate e is eliminated before c, l+1 (c, e), as follows:\nl+1 (c, e) = f(e)−∆(c, e)\nA lower bound on the number of ballots that must be added to the election to realise an elimination order ending in π is given by:\nlb+1 (π) = max{l + 1 (c ′, e′) | c′ ∈ π, e′ ∈ C \\ π}\nTighter lower bounds l+2 and lb + 2 are similarly defined, given the definitions of l2 and lb2 in Equations (8) and (9). We modify the DistanceTo LP of Magrino et al. [2011] to calculate the minimum number of ballot additions required to enforce a certain elimination order, creating DistanceTo+. Details are discussed in Appendix A.\nWe define margin+ as a variation of margin in which: LRM+B is used in place of LRMB; DistanceTo + in place of DistanceTo; and lb+2 in place of lb2. If an upper bound UL on the number of lost ballots is known we can initialise U with min{UL + 1, LRM + B }, as we are not interested in manipulations requiring the addition of more than UL ballots. If margin + returns UL + 1, the election result cannot be changed by adding at most UL ballots. Table 4 reports, for each of the IRV elections we consider in this paper, the number of calls to the DistanceTo + LP made by MRSW and margin+, the computation time (in milliseconds) of the two algorithms, the margin of victory and the last-round margin (LRM+B ).\n2Our reimplementation of the MRSW algorithm made slightly fewer LP calls than the original work, as reported by Magrino et al. [2011]. This is likely due to small arbitrary decisions regarding the prioritisation of nodes given the same score. Moreover, the total number of ballots cast, and the resulting margin, reported here for the Oakland 2014 Mayoral election are slightly lower than reported by ACGOV [2014]. This is likely due to differences in the inclusion of under and overvotes.\n12"
    }, {
      "heading" : "6.2 Deletion only",
      "text" : "A common problem arising in elections is the inclusion of false ballots. In Australian state and federal elections there is no mechanism to prevent duplicate voting by the same elector, except via an a posteriori check that their name has not been crossed off at multiple polling places. In the case of multiple votes v by the same elector (or multiple electors using the same identity) we can determine that the number of false ballots (by that elector) is v − 1, but not which ballots are false.\nSuppose some false ballots have been cast in an election. The question of whether these false extra ballots could have changed the result of the election asks “what is the minimum number of ballots required to be removed to change the result of the election.” The extension of our margin algorithm to answer this question is also straightforward.\nWe modify the DistanceTo LP of Magrino et al. [2011] to calculate the minimum number of deleted ballots required to enforce a certain elimination order, creating DistanceTo− (see Appendix A). We use the modified lower bounding function lb+2 (in place of lb2), as adding ballots to a loser or deleting ballots from the winner result in a manipulation of the same size.\nWe define margin− as a variation of margin+, in which all calls to DistanceTo+ are replaced by calls to DistanceTo−. If an upper bound on the number of false ballots UF is known we can initialise U with min{UF + 1, LRM + B }, as we are not interested in manipulations that require the deletion of more than UF ballots. If margin− returns UF + 1, the election result cannot be changed by deleting UF or fewer ballots. Table 5 reports, for each of the IRV elections we consider in this paper, the number of calls to the DistanceTo − LP made by MRSW and margin−, the computation time (in milliseconds) of the two algorithms, the margin of victory and the last-round margin (LRM−B = LRM + B )."
    }, {
      "heading" : "7 Concluding Remarks and Future Work",
      "text" : "We have shown that IRV margins are feasible to compute in practice. Although it is possible that IRV election instances will emerge that our algorithm cannot find margins for, we can efficiently compute the electoral margin on all instances for which we could obtain data. This includes a number of instances for which the current state-of-the-art approach could not compute the margin.\nIRV has several natural extensions, including various forms of the Single Transferable Vote (STV). The extension of our algorithm for computing margins in IRV elections to STV elections, where candidates are elected to multiple seats, is a topic of future research. STV is used to elect candidates to the Australian Senate, in all elections in Malta, and in most elections in the Republic of Ireland [Farrell and McAllister, 2005]. In the 2013 election of candidates to six seats in Western Australia’s Senate a discrepancy of 1,375 initially verified votes was discovered during a recount. The election result was overturned, and a repeat election held in 2014. If the margin of victory for the original election was known, the question of whether the loss of these ballots may have altered the resulting outcome could have been answered, potentially avoiding a costly repeat election. Indeed, our algorithm for computing IRV margins can be applied to find a smallest manipulation for the final IRV-only rounds of an STV count (for example, the election of a candidate to the last seat, where no candidate has a quota). This size of this manipulation provides an upper bound on the exact margin of victory."
    }, {
      "heading" : "A Appendix A: MRSW Lower Bounding LP (DistanceTo)",
      "text" : "Magrino et al. [2011] present a linear program (LP) to compute the smallest number of vote modifications required (to the set of ballots cast in an IRV election between candidates C) to realise a (potentially partial) elimination order π ⊆ C. Given an elimination order π, Magrino et al. [2011] define two rankings as equivalent if, at the point at which each candidate in π is eliminated, each ballot counts toward the tally of the same candidate. For example, consider an elimination order [A, B, C]. The ranking [B,A,C] is equivalent to [B,C] as they both count toward the tally of B in the first two rounds of counting (where A and B are eliminated), and toward the tally of C in the third round [Magrino et al., 2011] . A ballot signature (ranking) S has an associated equivalence class [[S]]π , minimal with respect to set inclusion, such that S is equivalent to [[S]]π with respect to the elimination order π = [c1, c2, ..., ck]. Let S = [c ′ 1, . . . , c ′ n], then:\n[[S]]π = [c ′ i | i ∈ 1..n, ∃j ∈ 1..k.c ′ i = cj ∧ {c ′ 1, . . . , c ′ i−1} ∩ {cj+1, . . . , ck} = ∅]\nFor simplicity of notation from now on we omit π from [[S]]π instead using [[S]]. Let S denote a set of equivalence classes which define (cover) the set of all possible rankings over C, n[[S]] the number of ballots in the (original) election profile with a ranking equivalent to [[S]] ∈ S, and n the total number of ballots in the election profile. Variables q[[S]], m[[S]], and y[[S]], respectively denote: the number of ballots in the original profile that will be changed to have signature [[S]] ∈ S (i.e. their original ranking was something other than [[S]]);3 the number of ballots in the original profile with signature [[S]] ∈ S that are to be modified to something other than [[S]]; and the number of ballots in the new (modified) profile with signature [[S]] ∈ S.\nMagrino et al. [2011] define the lower bounding linear program DistanceTo as follows.\nminimise ∑\n[[S]]∈S\nq[[S]] (10)\nsuch that\nn[[S]] + q[[S]] −m[[S]] = y[[S]] (11)\nn ≥ y[[S]] ≥ 0 (12)\nn[[S]] ≥ m[[S]] ≥ 0 (13)\nq[[S]] ≥ 0 (14)∑\n[[S]]∈S\nq[[S]] = ∑\n[[S]]∈S\nm[[S]] (15)\n∑\n[[S]]∈Si,i\ny[[S]] ≤ ∑\n[[S]]∈Sj,i\ny[[S]] for all ci, cj ∈ π such that i < j (16)\nConstraint (11) ensures that the total number of ballots with signature [[S]] ∈ S in the new election profile is equal to the sum of the number of ballots with this signature in the original profile and the number of ballots whose signature is changed to [[S]], minus the number of ballots whose signature has been modified from [[S]]. Constraint (15) ensures that the total number of ballots in the new election profile is equal to that of the original (no ballots are added or removed). Constraint (16) defines a set of special elimination constraints which force the candidates in π to eliminated in the stated order (c1 followed by c2, leaving ck as the last remaining candidate). The set Si,i denotes the set of signatures [[S]] ∈ S which will count toward candidate ci in elimination round i (the round in which ci is eliminated). Similarly, Sj,i denotes the set of signatures [[S]] ∈ S which will count toward cj in the ith round (in which ci is eliminated).\n3Magrino et al. [2011] use p[[S]] to denote the number of ballots in the original profile modified to have signature [[S]] ∈ S. We use notation q[[S]] to avoid confusion with the projection of a sequence π onto a set S ′, of pS′ (π).\n18\nA.1 Addition only\nIt is easy to modify the LP of Magrino et al. [2011] to consider the case in which the only manipulation that can take place is that new ballots can be added. Let us reinterpret variable q[[S]] as the number of ballots with signature [[S]] ∈ S added to the original profile. We set m[[S]] = 0 for [[S]] ∈ S, and remove Constraint (15) which forces the number of ballots in the modified profile to equal that of the original. We denote the resulting lower bounding LP as DistanceTo+.\nA.2 Deletion only\nWe can similarly modify the LP of Magrino et al. [2011] to consider the case in which the only manipulation that can take place is the deletion of existing ballots. Let us reinterpret variable m[[S]] as the number of ballots with signature [[S]] ∈ S in the original election profile that we will delete. We set q[[S]] = 0 for [[S]] ∈ S, and again remove Constraint (15) which forces the number of ballots in the modified election profile to equal that of the original. In this setting, we need only consider equivalence classes [[S]] for ballot signatures S that actually occur in the election S ∈ B, as we can only remove ballots that already exist. Finally, we replace the objective of the LP with ∑ [[S]]∈S,S∈Bm[[S]]. We denote the resulting lower bounding LP as DistanceTo −."
    }, {
      "heading" : "B Appendix B: Additional Results",
      "text" : "We show in Table 6 the difference in the performance of our branch-and-bound algorithm when using the looser pruning rule lb1, defined in Equation 6, relative to the tighter pruning rule lb2, defined in Equation 9. These results demonstrate that fewer LPs are solved when using lb2, but that this does not necessarily lead to faster margin computation. The lb2 score is more costly to compute than lb1. In the 2007 San Francisco Mayor election, for example, 1300 ms are used to compute the margin when pruning with lb2 (solving 94 LPs). In contrast, 1139 ms are used when pruning with lb1, even though 970 LPs are solved in the process. In the majority of instances considered, however, pruning with lb2 was either faster, or as fast, as pruning with lb1.\n19"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "The margin of victory is easy to compute for many election schemes but difficult for Instant Runoff Voting (IRV). This is important because arguments about the correctness of an election outcome usually rely on the size of the electoral margin. For example, risk-limiting audits require a knowledge of the margin of victory in order to determine how much auditing is necessary. This paper presents a practical branch-and-bound algorithm for exact IRV margin computation that substantially improves on the current best-known approach. Although exponential in the worst case, our algorithm runs efficiently in practice on all the real examples we could find. We can efficiently discover exact margins on election instances that cannot be solved by the current state-of-the-art.",
    "creator" : "LaTeX with hyperref package"
  }
}