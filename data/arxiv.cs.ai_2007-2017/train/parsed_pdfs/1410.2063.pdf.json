{
  "name" : "1410.2063.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Committment-Based Data-Aware Multi-Agent-Contexts Systems",
    "authors" : [ "Stefania Costantini" ],
    "emails" : [ "stefania.costantini@univaq.it" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n41 0.\n20 63\nv1 [\ncs .A\nI] 8\nO ct\n2 01"
    }, {
      "heading" : "1 Introduction",
      "text" : "Communication and interaction among agents in Multi-Agents Systems (MAS) have been the subject of extensive investigation since many years (cf. [1,2] for useful reviews and discussion). Commitments (cf. [3,4,5,6] and the references therein) have been proposed as a general paradigm for agent interaction, where a commitmentCx,y (ant , csq), relates a debtor agent x to a creditor agent y where x commits to bring about csq whenever ant , csq holds. Commitments can be created, discharged (i.e., fulfilled), canceled, released, delegated ad assigned, where this lifecycle is managed by a so-called “commitment machine” [7]. In agent societies, commitments can be divided into base-level commitments and meta-commitments, which represent the “norms” of the society [8]. An implicit meta-commitment is called (and considered to be) a “convention”, or a “custom”. Commitment-based communications appears particularly suitable in Artificial Social Systems and Organizational Multi-Agent Systems where two or more business partners interact, where each partner is represented as an autonomous, reactive and proactive agent. Such systems are in fact often based upon (business) protocols [4] that regulate interactions among agents by specifying the massages that agents are able to exchange, and constraints on these messages (involving message order, sequences,\ncontents, etc.). Literature about commitment-based protocols static and run-time verification is so wide as to make it impossible to mention all relevant work here. About run-time verification we mention [9,10,11], about static (a priori) verification we mention (among many) [12,13,14,15]. In [5], a semantics is proposed for the most common FIPA primitives [16] in terms of commitments. The objective of such a semantics is that of abstracting away from agents’ “mental states”, which are by definition private and non-observable, while in the author’s perspective communication is a social phenomenon consisting of exchanges that are made public. However, despite the open criticism to the “mentalistic” approach, in this work semantics of FIPA primitives still refer to BDI [17,18] concepts of Belief, Desire and Intention stating, e.g., that in an “Inform” primitive whatever is communicated is also believed. Alternative formal proposals that treat communicative acts in terms of commitments can be found in in [19] and in the references therein.\nIn [6,20] there is a strong claim toward an approach where a Multi-Agent System (MAS) is to be considered as a distributed system including heterogeneous components which operate autonomously and need to interoperate. No reference to “Intelligence” or knowledge representation and reasoning needs to be made, in the authors’ view, concerning communication: a strict software-engineering orientation is embraced, where agents are to any practical extents pieces of software managing interaction protocols. In [15], the quest for a decoupling of agent design and protocol design is advocated, to be obtained by means of refactoring design techniques, so as to allow designers to deploy a new protocol for a MAS with no need of substantial modifications to the agents’code.\nThough the commitment-based communication paradigm is very well-established and has proved effective in many practical applications, some more or less explicit discussion about the pervasiveness of such a paradigm has emerged (see e.g. [1,2]), i.e., whether or not are commitments really able to capture all forms of inter-agent communication, and whether or not intelligence and knowledge representation and reasoning abilities of agents, as well as the application context where they operate, can really be always and fully ignored or, however, considered to be a system parameter not to be taken into account as far as communication is concerned.\nIn interesting recent work [21], Calvanese De Giacomo and Montali study how to lift to lift the commitment-related approaches proposed in the literature from a propositional to a first-order setting. This with the aim of establishing how data maintained by the agents impact on the dynamics of MAS, and on the evolution of commitments. They are able to specify and verify (under some conditions) dynamic properties by means of a first-order variant of µ-calculus [22,23]. The approach, called DACMAS (Data-Aware Commitment-based MAS) is based upon the DRL-Lite Description Logic [24]. In this approach, a set of agents is augmented with an institutional agent which owns a “global TBox, that\nrepresents the key concepts, relations and constraints characterizing the domain in which the agents operate, so as to provide a common ground for the agent interaction.\nThe institutional agent keeps track of all agents participating in the system and of the evolution of their commitments, and is able to observe and record every interaction.\nAgents consist of a local ABox which is consistent with the global TBox (though mutual consistency of the ABoxes is not required) and of a set of reactive and proactive rules, where proactive rules model communications, and reactive rules model internal updates. Interestingly enough, in fact, agents communicate by interchanging events, which may then lead to commitment formation. For instance, a potential buyer send an event to a seller in order to register as customer. When (via an internal update) the seller does so, it sends to the buyer events representing offers. Only later, in case, e.g., the customer decides to buy, commitments are (conditionally) created by the institutional agent (which implements the commitment machine) about, e.g., payment and delivery. Notice that, since the institutional agent explicitly and implicitly participates in every interaction, and also implements the commitment machine, if all communications were to be based upon commitment one would need a meta-institutional agent, and so on in a potentially infinite regression. This even in a setting where participating agents are strongly coupled by the unique common ontology.\nThough the DACMAS approach is interesting, also for its potential for affordable verification, an important aspect is still missing, at least in the hypothesis of a really heterogeneous and autonomous set of agents. In fact, decisions about how to react to an event can be taken in DACMASs only based upon querying the local or the institutional ABox. In real-world applications, decisions such as, e.g., whether to accept a customer or whether to issue an order to a certain seller, whether to enroll a candidate student, whether to concede a loan and at which conditions, etc. are taken after consulting a number of information sources that can be not only internal, but also external to the agent system, and after following a decision procedure that goes beyond simple reaction. This irrespective to concepts such as “intelligence” an “mental states” that the agent communication community (at least as represented by [2]) chooses to ignore: for instance a University, in order to select among candidate students, requires some documentation and collects additional information from various sources. Then, it compares the candidates and makes decisions according to its internal criteria, and to decisionmaking algorithms relying upon knowledge representation and reasoning of some kind. Therefore, communication can be social, but the extent and purposes and (social) effects of communication may still widely depend upon the agent’s internal processes and upon its the interaction with other sources. This kind of interaction has little to do with sociality and commitments, like for instance when the University checks the candidates’ secondary school ranking in a local government’s file.\nIn the Artificial Intelligence and Knowledge Representation field, The MultiContext Systems (MCS) approach has been proposed to model such an information exchange [25,26]. In this proposal, there is a number of (information) contexts that are essentially kinds of heterogeneous reasoning entities, which interact via so-called bridge rules: such rules allow an entity to augment its knowledge base by inferring new consequence from what can (and/or cannot) be concluded in the other contexts. The MCS have evolved by the simplest form to Managed MCS (mMCS) [27], where conclusions resulting from bridge rules are locally re-elaborated so as to avoid inconsistency and to be able to suitably incorporate the new knowledge.\nIn this paper, we propose to combine the approach of [21] with mMCS into DACmMCMASs (DACmMCMASs), so as to obtain a commitment-based agent sys-\ntem which is however able to interact with heterogeneous external information sources. This by augmenting the set of participating agents by a set of contexts, and by equipping agents with special communicative rules that are a variant of bridge rules.\nThe paper is organized as follows: in Sections 2 we provide the necessary background notions about mMCSs and DACMASs. In Section 3 we present and illustrate, also by means of examples, the new approach of DACmMCMASs. We also discuss how nice properties of both mMCSs and DACMASs extend to the new formalization. Finally, in Section 4 we conclude."
    }, {
      "heading" : "2 Background on mMCS and DACMAS",
      "text" : ""
    }, {
      "heading" : "2.1 mMCS",
      "text" : "(Managed) Multi-Context systems [26,27] aim at making it possible to build systems that need to access multiple possibly heterogeneous data sources, despite the variety of formalisms and languages these data sources can be based upon. In particular, it is realistically assumed that data sources, called “contexts” cannot be standardized in any way, so the objective is that of modeling the necessary information flow among contexts. The device for doing so is constituted by “bridge rules”, which are similar to datalog rules with negation (cf., e.g., [28] for a survey about datalog and the references therein for more information) but allow for inter-context communication, as in each element their “body’of these rules the context from which information is to be obtained is explicitly indicated.\nIn this section we will briefly revise MCSs. We will adapt terminology and definitions to our setting. Reporting from [26], a logic L is a triple (KBL;CnL;ACCL), where KBL is the set of admissible knowledge bases of L, which are sets of KBelements (“formulas”); CnL is the set of acceptable sets of consequences (in [26] they are called “belief sets”, but we prefer to abstract away from “mentalistic” concepts), whose elements are data items or ”facts”; ACCL : KBL → 2CnL is a function which defines the semantics of L by assigning each knowledge-base an “acceptable” set of consequences. A multi-context system (MCS) M = (C1, . . . , Cn) is a heterogeneous collection of contexts Ci = (Li; kbi; bri) where Li is a logic, kbi ∈ KBLi is a knowledge base and bri is a set of bridge rules. Each such rule is of the following form, where the left-hand side s is called the head, also denoted as hd(ρ), the right-hand side is called the body, also denoted as body(ρ), and the comma stand for conjunction.\ns ← (c1 : p1), . . . , (cj : pj), not (cj+1 : pj+1), . . . , not (cm : pm).\nFor each bridge rule included in a context Ci, it is required that kbi ∪ s belongs to KBLi and, for every k ≤ m, ck is a context included in M , and each pk belongs to some set in KBLk .\nThe meaning is that s is added to the consequences of kbi whenever each pr, r ≤ j, belongs to the consequences of context cr, while instead each ps, j < s ≤ m, does not belong to the consequences of context cs. If M = (C1, . . . , Cn) is an MCS, a data state (“belief state” in the terminology of [26]) is a tuple S = (S1, . . . , Sn) such that each Si is an element of Cni. Desirable data states are those where each Si is\nacceptable according to ACCi. A bridge rule ρ is applicable in a data state iff for all 1 ≤ i ≤ j : pi ∈ Si and for all j + 1 ≤ k ≤ m : pk 6∈ Sk. Let app(S) be the set of bridge rules which are applicable in a data state S.\nWe will now introduce managed MCS (mMCS) though in a simplified form with respect to [26]: in fact, they substitute a logic with a “logic suite”, where one can select the desired semantics for the given knowledge base. We define mMCS over logics, as the extension over logic suites is not needed in our setting (thus, our formulation is in between those of [26] and [27]). While in standard MCSs the head s of a bridge rule is simply added to the “destination” context’s data state kb, in managed MCS kb is subjected to an elaboration w.r.t. s according to a specific operator op and to its intended semantics: rather than simple addition, op can determine, e.g. deletion of other formulas upon addition of s, or any kind of elaboration and revision of kb w.r.t. s. Formula s itself can be elaborated by op, for instance with the aim of making it compatible with kb’s format.\nFor a logic L, FL = {s ∈ kb | kb ∈ KBL} is the set of formulas occurring in its knowledge bases. A management base is a set of operation names (briefly, operations) OP , defining elaborations that can be performed on formulas, e.g., addition of, revision with, etc. For a logic L and a management base OP , the set of operational statements that can be built from OP and FL is FOPL = {o(s) | o ∈ OP, s ∈ FL}. The semantics of such statements is given by a management function, which maps a set of operational statements and a knowledge base into a modified knowledge base. In particular, a management function over a logic L and a management base OP is a function\nmng : 2F OP L ×KBL → 2KBL \\ ∅\nBridge rules for context Ci are as before, except that the head now belongs to FOPL , and is then of the form o(s).\nSemantics of (simplified) mMCS are in terms of equilibria. A data state S = (S1, . . . , Sn) is an equilibrium for an MCS M = (C1, . . . , Cn) iff, for 1 ≤ i ≤ n, there exists kb′i = mngi(app(S), kbi) such that Si ∈ ACCi(kb ′\ni). Thus, an equilibrium is a global data state composed of acceptable data sets, one for each context, considering however inter-context communication determined by bridge rules and the elaboration resulting from the operational statements and the management function.\nEquilibria may not exist, or may contain inconsistent data sets (local inconsistency, w.r.t. local consistency). A management function is called local consistency (lc-) preserving iff, for every given management base, kb′ is consistent. It can be proved that a mMCS where all management functions are lc-preserving is locally consistent. Global consistency would require the Si’s to be consistent with each other, but this property is not required in this context.\nIntuitively, a data state is an equilibrium whenever the application of a bridge rule according to the destination context’s strategy for incorporating new knowledge produces a result which is compatible with the context’s semantics for its data sets. E.g., in a data set consisting simply of positive and negative facts simple addition of the negation of a pre-existing fact cannot result in an equilibrium as it determines an inconsistency. Equilibrium can be guaranteed via an lc-preserving operator op which, e.g., gives priority to newly acquired data by removing the pre-existing conflicting item.\nNotice that bridge rules are intended to be applied whenever they are applicable, so inter-context communication automatically occurs via the predefined set of bridge rules, though mediated via the management function. In our proposal, as seen below bridge rules will be introduced in agents, which will be able to apply them proactively."
    }, {
      "heading" : "2.2 DACMAS",
      "text" : "We assume as known the basic concepts about Description Logic and ontologies [24] and in particular DLR-Lite, though no detail is needed here beyond being aware of the following aspects. (1) A TBox is a finite set of assertions specifying: concepts and relations; inclusion and disjunction among concepts/relations; key assertions for relations. (2) An ABox is a finite set of assertions concerning concept and relation membership. In essence, a TBox describes the structure of the data/knowledge, and the ABox specifies the actual data/knowledge instance. (3) In DLR-Lite, data can be queried via UCQs (Union of Conjunctive Queries) and ECQs (Existential Conjunctive Queries): the latter are FOL (First-Order Logic) queries involving negation, conjunction and the existential quantifier, whose atoms are UCQs.\nFormally, a DACMAS (Data-Aware Commitment-based Multi-Agent System) is (from [21]) a tuple 〈T , E ,X , I, C,B〉 where: (i) X is a finite set of agent specifications; (ii) T is a global DLR-Lite TBox, which is common to all agents participating in the system; (iii) I is a specification for the “institutional” agent; (iv) E is a set of predicates denoting events (where the predicate name is the event type, and the arity determines the content/payload of the event); (v) C is a contractual specification; (vi) and B is a Commitment Box (CBox). The global TBox lists the names of all participating agents in connection to their specifications. Each agent has a local ABox, consistent with the global TBox, where however the ABoxes of the various agents are not required to be mutually consistent. The institutional agent is a special agent who is aware of every message exchanged in the system, and can query all ABoxes. In addition, it is responsible of the management of commitments, whose concrete instances are maintained in the Commitment Box B, and it does so based on the Commitment Rules in C, which define the commitment machine. An execution semantics for DACMASs is provided in [21], in terms of a transition system constructed by means of a suitable algorithm.\nApart from the local ABox, each agent’s specification include a (possibly empty set of): communicative rules, which proactively determine events to be sent to other agents; update rules, which are internal reactive rules that update the local ABox upon sending/receiving an event to/from another agent. the other participants.\nA communicative rule has the form\nQ(r, x̂) enables EV (x̂) to r\nwhere: Q is an ECQ query, or precisely an ECQl with location argument @Ag to specify the agent to which the query is directed (if omitted, the the agent queries its own ABox); x̂ is a set of tuples representing the results of the query; EV (x̂) is an event supported by the system, i.e., predicate EV belongs to E ; r is a variable, denoting an agent’s name. Whenever the rule is proactively applied, if the query evaluates to true (i.e., if the query succeeds) then EV (x̂) and r are instantiated via one among the\nanswers returned by the query, according to the agent’s own choice. For instance, an agent can find the name r of the provider of a service (if several names are returned, only one is chosen) and sends to this provider a subscription request (instantiated with the necessary information x̂) in order to be able to access the service.\nUpdate rules are ECA-like rules1 of the following form, where α is an action, the other elements are as before, and each rule is to be applied whenever an event is either sent or received, as specified in the rule itself:\non EV (x̂) to r if Q(r, x̂) then α(r, x̂) (on-send/on-receive)\nUpdate rules may imply the insertion in the agent’s ABox of new data items not previously present in the system, taken from a countably infinite domain ∆. For instance, after subscription to a service an agent can receive offers and issue orders, the latter case determining the creation of a commitment (managed by the institutional agent).\nAn agent specification is a tuple 〈sn, Π〉, where sn is the agent specification name, and Π is the set of communicative and update rules characterizing the agent."
    }, {
      "heading" : "3 DACmMCMAS: Data-Aware Commitment-based managed Multi-Context MASDACmMCMASs",
      "text" : "The definition of a DACmMCMAS ( Data-Aware Commitment-based managed MultiContext MASDACmMCMASs), extend that of DACMASs as the set of participating agents is augmented with a set of contexts, which are to be understood as data sources which can be consulted by agents. The global TBox will now include a set of context names. However no specification of contexts is provided, since contexts are supposed to be external to the system. Contexts are supposed to be available for queries only. Each context’s name is however related, in the Tbox, to a context role, specifying the function that a context assumes in the system. E.g., a context’s name studoff may correspond to context role student office , and context name poldept to police department . More information about contexts can be held in each agent’s ABox, i.e., each agent may have its own private information about context roles. Bridge rules, similar to those of MCSs, can be now defined also in agents. Each agent is therefore equipped with local management functions, which can perform any elaboration on acquired data. The objective is to keep the agent’s ABox consistent, by means either of general simple techniques (e.g., rejecting incoming inconsistent knowledge) or via more involved belief revision techniques.\nIn the following, let a logic, a management base and management functions be as specified in Section 2.1. Formally, we have (where T , E ,X , I, C and B are the same as for DACMASs, their meaning is reported only for making the overall definition selfcontained):\nDefinition 1. A DACmMCMAS (Data-Aware Commitment-based managed Multi- Context MAS) is a tuple 〈T , E ,X ,Y, I, C,B〉 where: (i) T is a global DLR-Lite TBox, which\n1 As it is well-known, ’ECA’ rules stands for ’Event-Condition-Action’ rules, and specify reaction to events.\nis common to all agents participating in the system; (ii) E is a set of predicates denoting events (where the predicate name is the event type, and the arity determines the content/payload of the event); (iii) X is a finite set of agent specifications; (iv) Y is a finite set of context names; (vv) I is a specification for the institutional agent; (vi) C is a contractual specification; (vii) and B is a Commitment Box (CBox).\nThe global TBox lists, as in DACMASs, the names of all participating agents in connection to their specifications. The global TBox however also lists the description of all available external contexts, for which (differently from agents) no specification is available within the system. Each context has a name and, as mentioned, each context has a role, indicating to agents the kind of information that can be obtained from such context. For simplicity, we assume that roles are specified as constants: in future evolution of this work, more expressive descriptions may be adopted. We assume the each agent’s local ABox may include additional context descriptions, concerning contexts which are locally known to that specific agent. We also assume that context names include all the information needed for actually posing queries (e.g., context names might coincide with their URIs). Context names might also be linked to the information about the related query language; however, again for the sake of simplicity though without loss of generality we assume that all contexts accept datalog queries. In particular, we will consider datalog queries of the following form.\nDefinition 2. An agent-to-context datalog query is defined as follows:\nQ :-A1, . . . , An, notB1, notBm with n+m > 0\nwhere the left-hand-side Q can stand in place of the right-hand-side. The comma stand for conjunction, and each the Ais is either an atom or a binary expression involving connectives such as equality, inequality, comparison, applied to variables occurring in atoms and to constants. Each atom has a (possibly empty) tuple of arguments and can be either ground, i.e., all arguments are constants, or non-ground, i.e, arguments include both constants and variables, to be instantiated to constants in the query results. All variables which occur either in Q or in the Bis also occur in the Ais.\nIntuitively, the conjunction of the Ais selects a set of tuples and the Bis rule some of them out. Q is essentially a placeholder for the whole query, but also projects over the wished-for elements of the resulting tuples.\nEach context may include bridge rules, of the form specified in section 2.1, where however the body refers to contexts only, i.e., contexts cannot query agents. The novelty of our approach is that also agents may be equipped with bridge rules, for extracting data from contexts (not agents, as data exchange among agents occurs via explicit communication as defined in DACMASs). As in DACMASs, we assume that the new data items possibly added to the agent’s ABox belong to the same countably infinite domain ∆. Moreover, as seen below bridge rules in agents are not automatically applied as in mMCSs, rather they are proctively activated by agents upon need.\nDefinition 3. A bridge rule occurring in an agent’s specification has the following form.\nA(x̂) determinedby E1, . . . , Ek, notGk+1, . . . , notGr\nA(x̂), called the conclusion of the rule, is an atom over tuple of arguments x̂. The right-hand-side is called the body of the rule, and is a conjunction of queries on external contexts. Precisely, each of the Eis and each of the Gis (where k > 0 and r ≥ 0) can be either of the form DQi(x̂i) : ci or of the form DQi(x̂i) : qi where: DQi is a datalog query (defined according to Definition 2) over tuple of arguments x̂i; ci is a context listed in the local ABox with is role, and thus locally known to the agent; qi = Role@inst(rolei ) is a context name obtained by means of a standard query Role@inst to the institutional agent inst (notation ’@’ is borrowed from standard DACMASs), performed by providing the context role rolei . We assume that all variables occurring in A(x̂) and in each of the Gis also occur in the Eis. The comma stands for conjunction. Assuming (without loss of generality) that all the x̂is have the same arity, when the rule is triggered (see Definition 4 below) then the Eis may produce a set of tuples, some of which are discarded by the Gis. Finally, A(x̂) is obtained as a suitable projection. Within an agent, different bridge rules have distinct conclusions. The management operations and function are defined separately (see Definition 5 below).\nE.g., Role@inst(student office) would return the name of the context corresponding to the student office. There is, as mentioned, an important difference between bridge rules in contexts and bridge rules in agents. Each bridge rules in a context is meant to be automatically applied whenever the present data state entails the rule body. The new knowledge corresponding to the rule head is added (via the management function) to the context’s knowledge base. Instead, bridge rules in agents are meant to be proactvely activated by the agent itself. To this aim, we introduce suitable variants of DACMAS’s communicative and update rules.\nDefinition 4. A trigger rule has the form\nQ(x̂) enables A(ŷ)\nwhere: Q is an ECQl query, and x̂ a set of tuples representing the results of the query; A(ŷ) is the conclusion of exactly one of the agent’s bridge rules. If the query evaluates to true, then A(ŷ) is (partially) instantiated via one among the answers returned by the query, according to the agent’s own choice, and the corresponding bridge rule is triggered.\nSince agents’ bridge rules are executed neither automatically nor simultaneously, we have to revise the definition of management function with respect to the original definition of Section 2.1. First, notice that for each agent included in a DACmMCMAS the underlying logic (KBL;CnL;ACCL) is such that: KBL is composed of the global TBox plus the local ABoxes; ACCL is determined by the DRL-Lite semantics, according to which elements of CnL are computed. If an agent is equipped with n bridge rules, there will be n operators in the agent’s management base, one for each bridge rule, i.e., OP = {op1, . . . , opn}. Each of them which will at least make the acquired knowledge compatible with the global TBox (possibly by means of global ontologies and/or forms\nof meta-reasoning, cf., e.g., [29,30] for an overview). FOPL is defined as in Section 2.1, but instead of a single management function there will now be n management functions mng1, . . . ,mngn, again one per each bridge rule, each one with signature (for each i)\nmngi : F OP L ×KB L → 2KBL \\ ∅\nThey can however be factorized within a single agent’s management function with signature (as in MCSs)\nmngi : 2 FOP L ×KBL → 2KBL \\ ∅\nwhich specializes into the mngis according to the bridge-rule head. Whenever a bridge rule is triggered, its result is interpreted as an agent’s generated event and is reacted to via a special ECA rule: this functioning is similar to internal events in the DALI agent-oriented programming language [31,32].\nDefinition 5. A bridge-update rule has the form\non A(x̂) then β(x̂)\nwhere: A(x̂) is the conclusion of exactly one bridge rule, and x̂ a set of tuples representing the results of the application of the bridge rule; β(x̂) specifies the operator, management function and actions to be applied to x̂, which may imply querying the ABoxes of the agent and of the institutional agent, so as to re-elaborate the agent’s ABox.\nActually, trigger and bridge-update rules can be seen as a special case of communicative and update rules of DACMASs, where the omitted recipient is implicitly assumed to be self, i.e., the agent itself. The significant difference is that the involved event is not exactly an event as understood before, but is rather the result of a bridge rule. Also, β actions in bridge-update rules go beyond simple addition and deletion of facts performed by standard update rules. We now need for DACmMCMAS agents an agent specification which is augmented w.r.t. that of DACMAS ones:\nDefinition 6. An agent specification is a tuple 〈sn, Π〉, where sn is the agent specification name, and Π is the set of rules characterizing the agent. In particular, Π = Πcu∪Πbtu∪Πaux , where Πcu is the set of communicative and update rules, Πbtu is the set of bridge, trigger and bridge-update rules, and Πaux the set of the necessary auxiliary rules.\nNotice that, though not explicitly mentioned, auxiliary rules where implicitly present also in the definition of DACMASs, unless one considered all necessary auxiliary definitions as built-ins.\nThe definition of data state and of equilibria must be extended with respect to those provided in Section 2.1, and not only because a data state now includes both contexts’s and agents’ sets of consequences. As mentioned, in MCSs a bridge rule is applied whenever it is applicable. This however does not in general imply that it is applied only once, and that an equilibrium, once reached, lasts forever. In fact, contexts are in general able to incorporate new data items from the external environment (which may include, as\ndiscussed in [33], the input provided by sensors). Therefore, a bridge rule is in principle re-evaluated whenever a new result can be obtained, thus leading to evolving equilibria. In DACmMCMASs, there is the additional issue that for a bridge rule to be applied it is not sufficient that it is applicable in the MCS sense, but it must also be triggered by a corresponding trigger rule. Formally we have:\nDefinition 7. Let M be a DACmMCMAS where (C1, . . . , Cj) are the composing contexts and (Aj+1, . . . , An) the composing agents, j ≥ 0, n > 0. A data state of M is a tuple S = (S1, . . . , Sn) such that each Si is an element of Cni.\nDefinition 8. Lat S = (S1, . . . , Sn) be a data set for a DACmMCMAS M where (C1, . . . , Cj) are the composing contexts and (Aj+1, . . . , An) are the composing agents. A bridge rule ρ occurring in each composing context or agent is potentially applicable in S iff S entails its body. For contexts, entailment is the same as in MCSs. For agents, entailment implies that all queries in the rule body succeed w.r.t. S. A bridge rule is applicable in a context whenever it is potentially applicable. A bridge rule with head A(ŷ) is applicable in an agent Aj whenever it is potentially applicable and there exists a trigger rule of the form Q(x̂) enables A(ŷ) in the specification of Aj such that Cnj |= Q(x̂). Let app(S) be the set of bridge rules which are applicable in data state S.\nDesirable data states are those where each Si is acceptable according to ACCi.\nDefinition 9. A data state is an equilibrium iff, for 1 ≤ i ≤ n, there exists kb′i = mngi(app(S), kbi) such that Si ∈ ACCi(kb′i).\nWe will now re-elaborate an example taken from [21], where a potential buyer queries the institutional agent in order to obtain the name of the seller (of some goods) and then sends to the seller a registration request, supposing that registration is required in order to become a customer. The communication rule from [21] is in particular the following, where sel is the variable which is instantiated by the query to the seller’s name. The query in fact asks inst for the specification name Spec of seller .\nSpec@inst(sel, seller ) enables REQ REG to sel\nWe assume instead that before sending the registration request, the potential buyer intends to verify the reliability of the seller. To do so, the above rule is substituted by the following trigger rule, which looks almost identical unless for the fact that, instead of sending an event, a bridge rule is invoked by mentioning is head.\nSpec@inst(sel), seller ) enables verify(sel)\nThe bridge rule might involve consulting a list of trusted companies and reviewing other user’s opinion.\nverify(sel) determinedby trusted(sel) : trusted companies directory , not bad rating(sel) : user forum\nIf the verification is successful, which implies that verify(sel) becomes true as the body is implied by the current data state, then the seller can be added to the agent’s ABox as reliable, and the registration request can actually be sent. This is achieved via the following bridge-update rule\non verify(sel) then add(verified(sel))\ncombined with a corresponding communication rule, whose head corresponds to a query of the agent to its own ABox.\nverified(sel) enables REQ REG to sel\nBridge-update rules and communication rules are detached, as the former can subsist independently of the latter. If communication occured in the bridge-update rule, this would establish an unnecessary constraint about communication always occurring, and occurring immediately after information acquisition."
    }, {
      "heading" : "3.1 Properties of DACmMCMASs",
      "text" : "In the terminology of [26], we require all management functions (both those related to agents and those related to contexts) to be local consistency (lc-)preserving. We thus obtain the following, as a consequence of Proposition 2 in [26]:\nProposition 1. Let D be a DACmMCMAS such that all management functions associated to the composing agents and contexts are lc-preserving. Then D is locally consistent.\nThe execution semantics of a DACmMCMAS can be defined by extending the transition system defined for DACMAS in [21], Section 4. We omit the full extended definition for lack of space. It should suffice however to say that the transition system construction (Figure 1 in [21]) must be modified: (i) in steps 2-24, which manage rules, so as to encompass bridge rules; (ii) in steps 30-37, which manage actions, so as to encompass β actions in bridge-update rules.\nThis allows us to extend to DACmMCMASs the nice results provided in [21] for DACMASs about verification using µ-calculus (which is a powerful temporal logic used for model checking of finite-state transition systems, able to express both lineartime temporal logics such as LTL and branching-time temporal logics such as CTL and its variants). In particular, in [21] a variant of µ-calculus is adopted, that we denote as µECQl (for the formal definition of this variant, the reader may refer to [23] and to the references therein). In Section 5.1 of [21], decidability of verification of DACMASs is proved by assuming that they are state bounded, in the sense that for each agent in a DACMAS ther exists a bound on the number of data items simultaneously stored in its ABOX. In our context, we can assume state-boundedness for both agents’ ABoxes and contexts’ data instances: i.e, we assume that also the number of data items simultaneously stored in a context stays within the same bound as agents’ ABoxes. Thus, verifiability properties of DACMASs (Theorem 5.1 in [21]) still holds for DACmMCMASs. The proof of the theorem remains substantially the same: in [21] it is assumed to\nunify all the ABoxes of the composing agents into a single relational database where tuples have an additional argument denoting the name of the agent the tuple comes from. We can assume to include in this relational database also data belonging to contexts, with an additional argument denoting the context name."
    }, {
      "heading" : "4 Concluding Remarks",
      "text" : "In this paper we have extended DACMAS, which is a formalization of ontology-based and commitment-based multi-agent systems. Our extension allows a system to include not only agents but also external contexts. The objective is that of modeling realworld situations where agents not only interact among themselves, but also consult external heterogeneous data- and knowledge-based to extract useful information. In this way, both single agents and the overall system is able to evolve by incorporating new data/knowledge. To do so, we have merged DACMASs with managed multicontext systems (mMCS), which model data and knowledge exchange among heterogeneous sources in a controlled way. We thus obtain a more general formalization, called DACmMCMAS, which retains the desirable properties of both approaches. Similarly to what the authors argue for DACMAS, instances of DACmMCMAS are readily implementable via standard publicly available technologies.\nWe may notice however that a-priori formal verification may not always be practically possible, even for DACMASs. In fact, decidability of verification relies upon the assumption that agents’s ABoxes are publicly available and can be in principle merged together. This assumption may certainly apply to many practical cases. In general however, agents are supposed to be wishing to keep some of their information private and unknown to other agents and to a potential third-party. Even more so in the case of DACmMCMAS: sometimes contexts will be part of the same overall organization, which would make contexts’ contents available thus enabling verification. Sometimes however they can be fully external to the MAS. For these reason, we believe that a-priori verification techniques might be profitably complemented by run-time verification techniques, such as, e.g., those discussed in [34,35]."
    } ],
    "references" : [ {
      "title" : "Specifying open agent systems: A survey",
      "author" : [ "A. Artikis", "J.V. Pitt" ],
      "venue" : "In Artikis, A., Picard, G., Vercouter, L., eds.: Engineering Societies in the Agents World IX, 9th International Workshop, ESAW 2008, Revised Selected Papers.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Research directions in agent communication",
      "author" : [ "A.K. Chopra", "A. Artikis", "J. Bentahar", "M. Colombetti", "F. Dignum", "N. Fornara", "A.J.I. Jones", "M.P. Singh", "P. Yolum" ],
      "venue" : "ACM TIST 4(2)",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Towards a formal theory of communication for multi-agent systems",
      "author" : [ "M.P. Singh" ],
      "venue" : "In Mylopoulos, J., Reiter, R., eds.: Proceedings of the 12th International Joint Conference on Artificial Intelligence, Morgan Kaufmann",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Formalizing communication protocols for multiagent systems",
      "author" : [ "M.P. Singh" ],
      "venue" : "In Veloso, M.M., ed.: IJCAI 2007, Proceedings of the 20th International Joint Conference on Artificial Intelligence.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "A social semantics for agent communication languages",
      "author" : [ "M.P. Singh" ],
      "venue" : "In Dignum, F., Greaves, M., eds.: Issues in Agent Communication. Volume 1916 of Lecture Notes in Computer Science., Springer",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Commitments in multiagent systems: Some history, some confusions, some controversies, some prospects",
      "author" : [ "M.P. Singh" ],
      "venue" : "In Paglieri, F., Tummolini, L., Falcone, R., Miceli, M., eds.: The Goals of Cognition. Essays in Honor of Cristiano Castelfranchi, College Publications, London",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Commitment machines",
      "author" : [ "P. Yolum", "M.P. Singh" ],
      "venue" : "In Meyer, J.J.C., Tambe, M., eds.: Intelligent Agents VIII, 8th International Workshop, ATAL 2001, Revised Papers. Volume 2333 of Lecture Notes in Computer Science., Springer",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "An ontology for commitments in multiagent systems",
      "author" : [ "M.P. Singh" ],
      "venue" : "Artif. Intell. Law 7(1)",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "A retrospective on the reactive event calculus and commitment modeling language",
      "author" : [ "P. Torroni", "F. Chesani", "P. Mello", "M. Montali" ],
      "venue" : "In Sakama, C., Sardiña, S., Vasconcelos, W., Winikoff, M., eds.: Declarative Agent Languages and Technologies IX - 9th International Workshop, DALT 2011, Revised Selected and Invited Papers. Volume 7169 of Lecture Notes in Computer Science., Springer",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Reactive event calculus for monitoring global computing applications",
      "author" : [ "S. Bragaglia", "F. Chesani", "P. Mello", "M. Montali", "P. Torroni" ],
      "venue" : "In Artikis, A., Craven, R., Cicekli, N.K., Sadighi, B., Stathis, K., eds.: Logic Programs, Norms and Action - Essays in Honor of Marek J. Sergot on the Occasion of His 60th Birthday. Volume 7360 of Lecture Notes in Computer Science., Springer",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Representing and monitoring social commitments using the event calculus",
      "author" : [ "F. Chesani", "P. Mello", "M. Montali", "P. Torroni" ],
      "venue" : "Autonomous Agents and Multi-Agent Systems 27(1)",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Choice, interoperability, and conformance in interaction protocols and service choreographies",
      "author" : [ "M. Baldoni", "C. Baroglio", "A.K. Chopra", "N. Desai", "V. Patti", "M.P. Singh" ],
      "venue" : "In Sierra, C., Castelfranchi, C., Decker, K.S., Sichman, J.S., eds.: 8th International Joint Conference on Autonomous Agents and Multiagent Systems AAMAS 2009, IFAAMAS",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Commitments with regulations: reasoning about safety and control in regula",
      "author" : [ "E. Marengo", "M. Baldoni", "C. Baroglio", "A.K. Chopra", "V. Patti", "M.P. Singh" ],
      "venue" : "In Sonenberg, L., Stone, P., Tumer, K., Yolum, P., eds.: 10th International Conference on Autonomous Agents and Multiagent Systems AAMAS 2011, IFAAMAS",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Constitutive and regulative specifications of commitment protocols: A decoupled approach",
      "author" : [ "M. Baldoni", "C. Baroglio", "E. Marengo", "V. Patti" ],
      "venue" : "ACM TIST 4(2)",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Evolving protocols and agents in multiagent systems",
      "author" : [ "S.N. Gerard", "M.P. Singh" ],
      "venue" : "In Gini, M.L., Shehory, O., Ito, T., Jonker, C.M., eds.: International conference on Autonomous Agents and Multi-Agent Systems, AAMAS ’13.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Modeling agents within a BDI-architecture",
      "author" : [ "A.S. Rao", "M.P. Georgeff" ],
      "venue" : "In Fikes, R., Sandewall, E., eds.: Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR), Cambridge, Massachusetts, Morgan Kaufmann",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Modeling rational agents within a bdi-architecture",
      "author" : [ "A.S. Rao", "M. Georgeff" ],
      "venue" : "Proceedings of the Second Int. Conf. on Principles of Knowledge Representation and Reasoning (KR’91), Morgan Kaufmann",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Specifying artificial institutions in the event calculus",
      "author" : [ "M. Fornara", "N. Colombetti" ],
      "venue" : "In Dignum, V., ed.: Handbook of Research on Multi-Agent Systems: Semantics and Dynamics of Organizational Models. IGI Global",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Agent communication",
      "author" : [ "A.K. Chopra", "M.P. Singh" ],
      "venue" : "In Weiss, G., ed.: Multiagent Systems, 2nd edition. MIT Press",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Specification and verification of commitment-regulated data-aware multiagent systems",
      "author" : [ "M. Montali", "D. Calvanese", "G. De Giacomo" ],
      "venue" : "Proceedings of AAMAS 2014, also in Proceedings of the 29th Italian Conference on Computational Logic, http://ceur-ws.org/Vol-1195/long6.pdf.",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Modal and Temporal Properties of Processes",
      "author" : [ "C. Stirling" ],
      "venue" : "Texts in Computer Science. Springer",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Verification and synthesis in description logic based dynamic systems (abridged version)",
      "author" : [ "D. Calvanese", "G. De Giacomo", "M. Montali", "F. Patrizi" ],
      "venue" : "In Faber, W., Lembo, D., eds.: Web Reasoning and Rule Systems - 7th International Conference, RR 2013. Volume 7994 of Lecture Notes in Computer Science., Springer",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "The description logic handbook: Theory, implementation, and applications",
      "author" : [ "F. Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. Patel-Schneider" ],
      "venue" : "Cambridge University Press",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Equilibria in heterogeneous nonmonotonic multi-context systems",
      "author" : [ "G. Brewka", "T. Eiter" ],
      "venue" : "Proceedings of the 22nd AAAI Conference on Artificial Intelligence, AAAI Press",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Nonmonotonic multi-context systems: A flexible approach for integrating heterogeneous knowledge sources",
      "author" : [ "G. Brewka", "T. Eiter", "M. Fink" ],
      "venue" : "In Balduccini, M., Son, T.C., eds.: Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning - Essays Dedicated to Michael Gelfond on the Occasion of His 65th Birthday. Volume 6565 of Lecture Notes in Computer Science., Springer",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Managed multi-context systems",
      "author" : [ "G. Brewka", "T. Eiter", "M. Fink", "A. Weinzierl" ],
      "venue" : "In Walsh, T., ed.: IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence, IJCAI/AAAI",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Logic programming and negation: A survey",
      "author" : [ "K.R. Apt", "R. Bol" ],
      "venue" : "The Journal of Logic Programming 19-20",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Reflection principles in computational logic",
      "author" : [ "J. Barklund", "P. Dell’Acqua", "S. Costantini", "G.A. Lanzarone" ],
      "venue" : "J. of Logic and Computation 10(6)",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Meta-reasoning: A survey",
      "author" : [ "S. Costantini" ],
      "venue" : "Computational Logic: Logic Programming and Beyond, Essays in Honour of Robert A. Kowalski, Part II. Volume 2408 of Lecture Notes in Computer Science. Springer",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "A logic programming language for multi-agent systems",
      "author" : [ "S. Costantini", "A. Tocchio" ],
      "venue" : "Logics in Artificial Intelligence, Proceedings of the 8th Europ. Conf.,JELIA 2002. LNAI 2424, Springer-Verlag, Berlin",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "The DALI logic programming agent-oriented language",
      "author" : [ "S. Costantini", "A. Tocchio" ],
      "venue" : "Logics in Artificial Intelligence, Proceedings of the 9th European Conference, Jelia 2004. LNAI 3229, Springer-Verlag, Berlin",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Multi-context systems for reactive reasoning in dynamic environments",
      "author" : [ "G. Brewka", "S. Ellmauthaler", "J. Pührer" ],
      "venue" : "In Schaub, T., ed.: ECAI 2014, Proceedings of the 21st European Conference on Artificial Intelligence, IJCAI/AAAI",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Self-checking logical agents",
      "author" : [ "S. Costantini" ],
      "venue" : "In Osorio, M., Zepeda, C., Olmos, I., Carballido, J.L., Ramı́rez, R.C.M., eds.: Proceedings of the Eighth Latin American Workshop on Logic, Languages, Algorithms and New Methods of Reasoning LA-NMR 2012. Volume 911 of CEUR Workshop Proceedings., CEUR-WS.org",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Runtime self-checking via temporal (meta-)axioms for assurance of logical agent systems",
      "author" : [ "S. Costantini", "G.D. Gasperis" ],
      "venue" : "In Bulling, N., van der Hoek, W., eds.: Proceedings of LAMAS 2014, 7th Workshop on Logical Aspects of Multi-Agent Systems, held at AAMAS 2014, 14th Intern. Conf. on Autonomous Agents and Multi-Agent Systems.",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "[1,2] for useful reviews and discussion).",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 1,
      "context" : "[1,2] for useful reviews and discussion).",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 2,
      "context" : "[3,4,5,6] and the references therein) have been proposed as a general paradigm for agent interaction, where a commitmentCx,y (ant , csq), relates a debtor agent x to a creditor agent y where x commits to bring about csq whenever ant , csq holds.",
      "startOffset" : 0,
      "endOffset" : 9
    }, {
      "referenceID" : 3,
      "context" : "[3,4,5,6] and the references therein) have been proposed as a general paradigm for agent interaction, where a commitmentCx,y (ant , csq), relates a debtor agent x to a creditor agent y where x commits to bring about csq whenever ant , csq holds.",
      "startOffset" : 0,
      "endOffset" : 9
    }, {
      "referenceID" : 4,
      "context" : "[3,4,5,6] and the references therein) have been proposed as a general paradigm for agent interaction, where a commitmentCx,y (ant , csq), relates a debtor agent x to a creditor agent y where x commits to bring about csq whenever ant , csq holds.",
      "startOffset" : 0,
      "endOffset" : 9
    }, {
      "referenceID" : 5,
      "context" : "[3,4,5,6] and the references therein) have been proposed as a general paradigm for agent interaction, where a commitmentCx,y (ant , csq), relates a debtor agent x to a creditor agent y where x commits to bring about csq whenever ant , csq holds.",
      "startOffset" : 0,
      "endOffset" : 9
    }, {
      "referenceID" : 6,
      "context" : ", fulfilled), canceled, released, delegated ad assigned, where this lifecycle is managed by a so-called “commitment machine” [7].",
      "startOffset" : 125,
      "endOffset" : 128
    }, {
      "referenceID" : 7,
      "context" : "In agent societies, commitments can be divided into base-level commitments and meta-commitments, which represent the “norms” of the society [8].",
      "startOffset" : 140,
      "endOffset" : 143
    }, {
      "referenceID" : 3,
      "context" : "Such systems are in fact often based upon (business) protocols [4] that regulate interactions among agents by specifying the massages that agents are able to exchange, and constraints on these messages (involving message order, sequences,",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 8,
      "context" : "About run-time verification we mention [9,10,11], about static (a priori) verification we mention (among many) [12,13,14,15].",
      "startOffset" : 39,
      "endOffset" : 48
    }, {
      "referenceID" : 9,
      "context" : "About run-time verification we mention [9,10,11], about static (a priori) verification we mention (among many) [12,13,14,15].",
      "startOffset" : 39,
      "endOffset" : 48
    }, {
      "referenceID" : 10,
      "context" : "About run-time verification we mention [9,10,11], about static (a priori) verification we mention (among many) [12,13,14,15].",
      "startOffset" : 39,
      "endOffset" : 48
    }, {
      "referenceID" : 11,
      "context" : "About run-time verification we mention [9,10,11], about static (a priori) verification we mention (among many) [12,13,14,15].",
      "startOffset" : 111,
      "endOffset" : 124
    }, {
      "referenceID" : 12,
      "context" : "About run-time verification we mention [9,10,11], about static (a priori) verification we mention (among many) [12,13,14,15].",
      "startOffset" : 111,
      "endOffset" : 124
    }, {
      "referenceID" : 13,
      "context" : "About run-time verification we mention [9,10,11], about static (a priori) verification we mention (among many) [12,13,14,15].",
      "startOffset" : 111,
      "endOffset" : 124
    }, {
      "referenceID" : 14,
      "context" : "About run-time verification we mention [9,10,11], about static (a priori) verification we mention (among many) [12,13,14,15].",
      "startOffset" : 111,
      "endOffset" : 124
    }, {
      "referenceID" : 4,
      "context" : "In [5], a semantics is proposed for the most common FIPA primitives [16] in terms of commitments.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 15,
      "context" : "However, despite the open criticism to the “mentalistic” approach, in this work semantics of FIPA primitives still refer to BDI [17,18] concepts of Belief, Desire and Intention stating, e.",
      "startOffset" : 128,
      "endOffset" : 135
    }, {
      "referenceID" : 16,
      "context" : "However, despite the open criticism to the “mentalistic” approach, in this work semantics of FIPA primitives still refer to BDI [17,18] concepts of Belief, Desire and Intention stating, e.",
      "startOffset" : 128,
      "endOffset" : 135
    }, {
      "referenceID" : 17,
      "context" : "Alternative formal proposals that treat communicative acts in terms of commitments can be found in in [19] and in the references therein.",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 5,
      "context" : "In [6,20] there is a strong claim toward an approach where a Multi-Agent System (MAS) is to be considered as a distributed system including heterogeneous components which operate autonomously and need to interoperate.",
      "startOffset" : 3,
      "endOffset" : 9
    }, {
      "referenceID" : 18,
      "context" : "In [6,20] there is a strong claim toward an approach where a Multi-Agent System (MAS) is to be considered as a distributed system including heterogeneous components which operate autonomously and need to interoperate.",
      "startOffset" : 3,
      "endOffset" : 9
    }, {
      "referenceID" : 14,
      "context" : "In [15], the quest for a decoupling of agent design and protocol design is advocated, to be obtained by means of refactoring design techniques, so as to allow designers to deploy a new protocol for a MAS with no need of substantial modifications to the agents’code.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 0,
      "context" : "[1,2]), i.",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 1,
      "context" : "[1,2]), i.",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 19,
      "context" : "In interesting recent work [21], Calvanese De Giacomo and Montali study how to lift to lift the commitment-related approaches proposed in the literature from a propositional to a first-order setting.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 20,
      "context" : "They are able to specify and verify (under some conditions) dynamic properties by means of a first-order variant of μ-calculus [22,23].",
      "startOffset" : 127,
      "endOffset" : 134
    }, {
      "referenceID" : 21,
      "context" : "They are able to specify and verify (under some conditions) dynamic properties by means of a first-order variant of μ-calculus [22,23].",
      "startOffset" : 127,
      "endOffset" : 134
    }, {
      "referenceID" : 22,
      "context" : "The approach, called DACMAS (Data-Aware Commitment-based MAS) is based upon the DRL-Lite Description Logic [24].",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 1,
      "context" : "This irrespective to concepts such as “intelligence” an “mental states” that the agent communication community (at least as represented by [2]) chooses to ignore: for instance a University, in order to select among candidate students, requires some documentation and collects additional information from various sources.",
      "startOffset" : 139,
      "endOffset" : 142
    }, {
      "referenceID" : 23,
      "context" : "In the Artificial Intelligence and Knowledge Representation field, The MultiContext Systems (MCS) approach has been proposed to model such an information exchange [25,26].",
      "startOffset" : 163,
      "endOffset" : 170
    }, {
      "referenceID" : 24,
      "context" : "In the Artificial Intelligence and Knowledge Representation field, The MultiContext Systems (MCS) approach has been proposed to model such an information exchange [25,26].",
      "startOffset" : 163,
      "endOffset" : 170
    }, {
      "referenceID" : 25,
      "context" : "The MCS have evolved by the simplest form to Managed MCS (mMCS) [27], where conclusions resulting from bridge rules are locally re-elaborated so as to avoid inconsistency and to be able to suitably incorporate the new knowledge.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 19,
      "context" : "In this paper, we propose to combine the approach of [21] with mMCS into DACmMCMASs (DACmMCMASs), so as to obtain a commitment-based agent sys-",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 24,
      "context" : "(Managed) Multi-Context systems [26,27] aim at making it possible to build systems that need to access multiple possibly heterogeneous data sources, despite the variety of formalisms and languages these data sources can be based upon.",
      "startOffset" : 32,
      "endOffset" : 39
    }, {
      "referenceID" : 25,
      "context" : "(Managed) Multi-Context systems [26,27] aim at making it possible to build systems that need to access multiple possibly heterogeneous data sources, despite the variety of formalisms and languages these data sources can be based upon.",
      "startOffset" : 32,
      "endOffset" : 39
    }, {
      "referenceID" : 26,
      "context" : ", [28] for a survey about datalog and the references therein for more information) but allow for inter-context communication, as in each element their “body’of these rules the context from which information is to be obtained is explicitly indicated.",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 24,
      "context" : "Reporting from [26], a logic L is a triple (KBL;CnL;ACCL), where KBL is the set of admissible knowledge bases of L, which are sets of KBelements (“formulas”); CnL is the set of acceptable sets of consequences (in [26] they are called “belief sets”, but we prefer to abstract away from “mentalistic” concepts), whose elements are data items or ”facts”; ACCL : KBL → 2L is a function which defines the semantics of L by assigning each knowledge-base an “acceptable” set of consequences.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 24,
      "context" : "Reporting from [26], a logic L is a triple (KBL;CnL;ACCL), where KBL is the set of admissible knowledge bases of L, which are sets of KBelements (“formulas”); CnL is the set of acceptable sets of consequences (in [26] they are called “belief sets”, but we prefer to abstract away from “mentalistic” concepts), whose elements are data items or ”facts”; ACCL : KBL → 2L is a function which defines the semantics of L by assigning each knowledge-base an “acceptable” set of consequences.",
      "startOffset" : 213,
      "endOffset" : 217
    }, {
      "referenceID" : 24,
      "context" : ", Cn) is an MCS, a data state (“belief state” in the terminology of [26]) is a tuple S = (S1, .",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 24,
      "context" : "We will now introduce managed MCS (mMCS) though in a simplified form with respect to [26]: in fact, they substitute a logic with a “logic suite”, where one can select the desired semantics for the given knowledge base.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 24,
      "context" : "We define mMCS over logics, as the extension over logic suites is not needed in our setting (thus, our formulation is in between those of [26] and [27]).",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 25,
      "context" : "We define mMCS over logics, as the extension over logic suites is not needed in our setting (thus, our formulation is in between those of [26] and [27]).",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 22,
      "context" : "We assume as known the basic concepts about Description Logic and ontologies [24] and in particular DLR-Lite, though no detail is needed here beyond being aware of the following aspects.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 19,
      "context" : "Formally, a DACMAS (Data-Aware Commitment-based Multi-Agent System) is (from [21]) a tuple 〈T , E ,X , I, C,B〉 where: (i) X is a finite set of agent specifications; (ii) T is a global DLR-Lite TBox, which is common to all agents participating in the system; (iii) I is a specification for the “institutional” agent; (iv) E is a set of predicates denoting events (where the predicate name is the event type, and the arity determines the content/payload of the event); (v) C is a contractual specification; (vi) and B is a Commitment Box (CBox).",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 19,
      "context" : "An execution semantics for DACMASs is provided in [21], in terms of a transition system constructed by means of a suitable algorithm.",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 27,
      "context" : ", [29,30] for an overview).",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 28,
      "context" : ", [29,30] for an overview).",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 29,
      "context" : "Whenever a bridge rule is triggered, its result is interpreted as an agent’s generated event and is reacted to via a special ECA rule: this functioning is similar to internal events in the DALI agent-oriented programming language [31,32].",
      "startOffset" : 230,
      "endOffset" : 237
    }, {
      "referenceID" : 30,
      "context" : "Whenever a bridge rule is triggered, its result is interpreted as an agent’s generated event and is reacted to via a special ECA rule: this functioning is similar to internal events in the DALI agent-oriented programming language [31,32].",
      "startOffset" : 230,
      "endOffset" : 237
    }, {
      "referenceID" : 31,
      "context" : "discussed in [33], the input provided by sensors).",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 19,
      "context" : "We will now re-elaborate an example taken from [21], where a potential buyer queries the institutional agent in order to obtain the name of the seller (of some goods) and then sends to the seller a registration request, supposing that registration is required in order to become a customer.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 19,
      "context" : "The communication rule from [21] is in particular the following, where sel is the variable which is instantiated by the query to the seller’s name.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 24,
      "context" : "In the terminology of [26], we require all management functions (both those related to agents and those related to contexts) to be local consistency (lc-)preserving.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 24,
      "context" : "We thus obtain the following, as a consequence of Proposition 2 in [26]:",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 19,
      "context" : "The execution semantics of a DACmMCMAS can be defined by extending the transition system defined for DACMAS in [21], Section 4.",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 19,
      "context" : "It should suffice however to say that the transition system construction (Figure 1 in [21]) must be modified: (i) in steps 2-24, which manage rules, so as to encompass bridge rules; (ii) in steps 30-37, which manage actions, so as to encompass β actions in bridge-update rules.",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 19,
      "context" : "This allows us to extend to DACmMCMASs the nice results provided in [21] for DACMASs about verification using μ-calculus (which is a powerful temporal logic used for model checking of finite-state transition systems, able to express both lineartime temporal logics such as LTL and branching-time temporal logics such as CTL and its variants).",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 19,
      "context" : "In particular, in [21] a variant of μ-calculus is adopted, that we denote as μECQl (for the formal definition of this variant, the reader may refer to [23] and to the references therein).",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 21,
      "context" : "In particular, in [21] a variant of μ-calculus is adopted, that we denote as μECQl (for the formal definition of this variant, the reader may refer to [23] and to the references therein).",
      "startOffset" : 151,
      "endOffset" : 155
    }, {
      "referenceID" : 19,
      "context" : "1 of [21], decidability of verification of DACMASs is proved by assuming that they are state bounded, in the sense that for each agent in a DACMAS ther exists a bound on the number of data items simultaneously stored in its ABOX.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 19,
      "context" : "1 in [21]) still holds for DACmMCMASs.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 19,
      "context" : "The proof of the theorem remains substantially the same: in [21] it is assumed to",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 32,
      "context" : ", those discussed in [34,35].",
      "startOffset" : 21,
      "endOffset" : 28
    }, {
      "referenceID" : 33,
      "context" : ", those discussed in [34,35].",
      "startOffset" : 21,
      "endOffset" : 28
    } ],
    "year" : 2014,
    "abstractText" : "Communication and interaction among agents have been the subject of extensive investigation since many years. Commitment-based communication, where communicating agents are seen as a debtor agent who is committed to a creditor agent to bring about something (possibly under some conditions) is now very well-established. The approach of DACMAS (Data-Aware Commitmentbased MAS) lifts commitment-related approaches proposed in the literature from a propositional to a first-order setting via the adoption the DRL-Lite Description Logic. Notably, DACMASs provide, beyond commitments, simple forms of inter-agent event-based communication. Yet, the aspect is missing of making a MAS able to acquire knowledge from contexts which are not agents and which are external to the MAS. This topic is coped with in Managed MCSs (Managed Multi-Context Systems), where however exchanges are among knowledge bases and not agents. In this paper, we propose the new approach of DACmMCMASs (Data-Aware Commitment-based managed MultiContext MAS), so as to obtain a commitment-based first-order agent system which is able to interact with heterogeneous external information sources. We show that DACmMCMASs retain the nice formal properties of the original approaches.",
    "creator" : "LaTeX with hyperref package"
  }
}