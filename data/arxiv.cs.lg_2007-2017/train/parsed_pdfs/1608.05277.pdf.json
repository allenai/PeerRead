{
  "name" : "1608.05277.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Lambert Schomaker", "L. Schomaker" ],
    "emails" : [ "schomaker@ai.rug.nl" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Keywords: Hidden-Markov Models, Bayes, Markov assumption, nearest-neighbor search, error propagation, handwriting recognition"
    }, {
      "heading" : "1. Introduction",
      "text" : "The use of Bayes and hidden-Markov models (HMMs) is pervasive in machine learning. The Bayes’ Theorem (Bayes, 1763) describes the theoretically correct optimum for the posterior probability given observations. The theoretical soundness of the paradigm makes it seem inappropriate to pose critical questions. Similarly, in the application domains of speech and handwriting recognition, the hidden-Markov model -which is also Bayesian in its essential computations- is the predominant paradigm, without essential objections or reserve. However, both in handwriting and speech recognition, current word-classification performances are still not up to the expectations the were prevalent during the last quarter of the previous century. This is in stark contrast with the dissemination of other technologies. The invention of the motorized airplane in 1903 produced a large and flourishing industry within ten years. This is contrary to the situation in hidden-Markov modeling for handwriting and speech recognition. At the same time, neural networks can be applied easily today by master students in a wide range of pattern-recognition problems. New paradigms for clas-\n1. This paper has been on shelf for some time, since 2009 and is the result of the extensive discussions with at-the-time MSc student Jean-Paul van Oosten, colleagues in handwriting recognition and critical/supportive comments by Bob Duin.\nc©2016 Lambert Schomaker.\nar X\niv :1\n60 8.\n05 27\n7v 3\n[ cs\n.L G\n] 3\nJ an\n2 01\nsification of stochastic time series, such as the (bidirectional) long-term short-term memory neural networks (Hochreiter and Schmidhuber, 1997; Graves and Schmidhuber, 2005) are enjoying considerable interest and success. On the contrary, a PhD student starting to apply HMMs in handwriting recognition should still be prepared for a bumpy ride, more than 25 years after the introduction of the method. Essential portions of the know how in the application of HMMs are not spelled out in the scientific literature. As a consequence, the reported successes from literature cannot be replicated easily. Therefore, time is ripe for critical considerations. Elsewhere (Van Oosten and Schomaker, 2014; van Oosten et al., 2017), we have addressed problems in estimating hidden-Markov models, as evidenced from haphazard model-fit value trajectories during regular Baum-Welch training.\nIn a similar vein, although Bayes’ rule is optimal, the same cannot be said about naiveBayes classifiers or Bayesian models in many current application domains. Despite a strong advocacy and a steep increase in Bayesian studies, it is often difficult to replicate successes of others. What is more intriguing, however, is that non-Bayesian pattern classifiers and systems yield competitive or improved performances using neural networks or even nearestneighbor classifiers, with limited (human) development effort. It is time to take a step back.\nFirst, a number of fundamental problems with Bayes will be introduced. Then, problems with hidden Markov models will be laid out. In the final section a case will be made for geometric methods: distance or dissimilarity-based vectorial matching, which remain the most convenient approach for conditions with limited ground-truth reference data."
    }, {
      "heading" : "2. Problems with a Scotsman",
      "text" : "The Scottish reverend Thomas Bayes Bayes (1763) introduced the well-known equation for estimating the probability of a fact C given an observable X\nP (C|X) = P (X|C) ∗ P (C) P (X)\n(1)\nwhere P (C) is the prior probability of C occurring, at all, P (X) is the prior probability of X occurring, at all, while P (X|C) is the probability of observing X under the condition that C is known to be true. In pattern recognition, X will coincide with the observed feature value(s), while C will coincide with a particular class of which the presence must be estimated. The Bayes theorem describes the benefits of weighing the probability of X under condition of C with two factors:\n• Multiplication with P (C) represents realism (”how often does C occur, anyway?”);\n• Division by P (X) exploits informational value (”if the general probability of X occurring is low, observing X tells a lot”).\nApplication of the Bayes equation will yield a clarifying (contrast-enhancing) scaling operator on the a-posteriori probability P (C|X), such that in a multi-class problem the class Ci with the largest a-posteriori probability can be easily identified. The use of probabilities as the currency in reasoning or in ’belief propagation’ is definitely an advantage over methods\nwhich use more diversely scaled measures of similarity or rankings, e.g., for combining classifiers van Erp et al. (2002). However, combination of evidence from multiple sources is still not trivial. In order to combine pieces of information, and disregarding complex interactions due to stochastic interdependence of observables, a so-called naive Bayes scheme is used, usually. The effect of a conjoint observation of a set of observables X = x1, x2, ..., xN is then inserted as a product of probabilities:\nP (C|x1, x2, ..., xN ) = P (C) ∗ N∏ j=1 P (xj |C) P (xj)\n(2)\nIt may not be appropriate to combine evidence by assuming conjunction of stochastically independent observations. This shortcoming of the naive-Bayes assumption has been dealt with in depth elsewhere (Rennie et al., 2003). Note that the computation of a product of probabilities is essential for a classifier which is implemented as a Bayesian engine. This is made more explicit in the following formulation, demonstrating the presence of two such product chains:\nP (C|x1, x2, ..., xN ) = P (C) ∗ ∏N\nj=1 P (xj |C)∏N j=1 P (xj)\n(3)\nWe will get to this aspect in a later section. For now, a basic question is whether learning systems should be implemented as a Bayesian system, by using the above formalism. It should be realized that a classifier may operate close to the optimal Bayes performance, without being implemented as a Bayes engine, using estimations of probability, etc. A well-known example is the fact that a nearest-neighbor classifier with an infinite number of examples will yield an error which is guaranteed to be less than twice the optimum Bayes error Duda and Hart (1973). In fact, a Bayesian implementation of a classification system may be impractical in a realistic system, as will be illustrated in the following example.\nExample 1 Let us translate the problem to an ecologically realistic problem which is presented to, e.g., an ancestral primate. The subject, an autonomous intelligent system, is rather young, and aims at survival. It encounters a hissing and rattling snake and would like to estimate whether a bite is to be expected, i.e, in Bayesian terms:\nP (bite|snake) = P (snake|bite) ∗ P (bite) P (snake)\n(4)\nFor a learning system, implemented in the manner of many contemporary machinelearning models, this would imply the following instructions to the subject in order to compute the necessary terms on the right-hand side:\nP (snake) walk on the earth extensively, count the instances for all classes of objects you encounter and if you have seen enough, jot down the probability of encountering snakes;\nP (bite) interact with object classes as extensively as possible, and count the number of times you were bitten;\nP (snake|bite) each time you are bitten, keep count of the number of times the perpetrator was a snake.\nNote : Make sure you encounter sufficient numbers of snakes, bites, and biting snakes, as you want those probabilities to be reliable;\nP (bite|snake) can now be computed.\nWhile this is a colloquial, non-formal example it illustrates a number of underlying problems with the Bayesian formalism, even for single-observation problems. To obtain reliable priors, huge amounts of data need to be collected, that a newborn system is unlikely to possess. This makes a classification system which is implemented by means of the Bayes equation rather impractical. For instance, in natural cognitive systems, the phenomenon of single-shot (one-shot, or one-trial) learning (Guthrie, 1946; Underwood and Keppel, 1962; Herbst, 1982; Hinton et al., 1984; Yip and Sussman, 1997) will make extensive and painful sampling unnecessary, after the first bite. It is even likely that the original perpetrator of the first bite does not need to to be a snake to estimate that a bite is imminent when seeing an instance of the hitherto unseen species “snake”. For the problem at hand, we can largely deconstruct the Bayes equation:\nSince a concrete version of Example 1 is concerned with estimating the likelihood of a number of possible snake behaviors, one of which is biting, say, {bite, rattle,misc}, then the total problem will be described by an estimation of three a-posteriori probabilities:\nP (bite|snake) = P (snake|bite) ∗ P (bite) / P (snake) P (rattle|snake) = P (snake|rattle) ∗ P (rattle) / P (snake) P (misc|snake) = P (snake|misc) ∗ P (misc) / P (snake)\nIt can be seen quickly that the denominator P (snake) does not need to be known to find the most likely behavior in this set. As a result, the agent only has to compute three relative posterior estimates in the example, denoted as p̃:\np̃(bite|snake) = P (snake|bite) ∗ P (bite) p̃(rattle|snake) = P (snake|rattle) ∗ P (rattle) p̃(misc|snake) = P (snake|misc) ∗ P (misc)\nFurthermore, however, we need to take a step back and ask ourselves the question why we actually need to compute an exact P (bite|snake) at all. For an autonomous system, the more fundamental variable is the utility or cost involved, i.e., the estimated utility u′ = P (bite|snake) ∗ U(bite) where U(bite) is the utility of being bitten. Since the cost of dying can be considered infinite, any non-zero probability of suffering a bite would necessitate a swift avoidance of the snake, no matter the height of the probabilities P (rattle) and P (misc). This leaves the original Bayes equation completely deconstructed, with only the term P (snake|bite) remaining. The latter can be translated into a probabilistic question: ”is it possible that a proportion of the bites suffered comes from a snake?”. Note, however,\nthat we are dealing with an infinite-cost problem, such that it is sufficient to express the problem as a logical question: ”is it true that ∃x bites(x) ∧ x = snake?”, yielding a value of one or zero, exempt of probabilistic subtleties. The exact value of the probability is becoming less and less important for large costs. Under these conditions, the autonomous agent only needs to know whether the posterior probability equals zero or not and little is left from Eq. 1. Utility is a pervasive and real factor, not an outlandish concept for exclusive use within operations research or robotics. Most applications of pattern recognition have a cost factor attached to their decisions. Consider, as an example, the cost of a FalseMiss decision in automatic signature verification for a fraudulent bank transaction. The actual deployment of a particular algorithm in such a context does not only depend on its sensitivity and specificity (probabilities) but also on the risk the embedding system is able to take (utility).\nEven without an excursion into the cost domain, the importance of the exact value of the prior can be considered as relative. It provides a pragmatic weighing according to the probability of events. However, in many problems, such as data mining or knowledge discovery, the pattern classification effort is exactly taken in order to estimate the occurrence probability of patterns. In such a case, the prior can be replaced by a constant, for instance with a value of one divided by the number of classes, and the Bayes equation is deconstructed.\nIt could be argued that the snake example is extreme, since not all problems are concerned with infinite costs attached to the decision which is taken on the basis of the computed posterior probability. Therefore, four more examples will be given here, each leading to at least a partial deconstruction of the Bayes equation.\nExample 2 A forensic institute maintains a database of handwritten fraudulent, black-mail and extortion letters. For an incoming handwritten document of unknown origin, the posterior probability is needed for finding the most likely writer in the database. Unfortunately, the database is contaminated by a single recidivist occupying 90% of the records.\nIs it desirable to compute the full Bayes posterior? A judge may rightfully argue that it is more important to know the likelihood ratio P (X|C)/P (X) for the visual, patternrecognition evidence in isolation and disregard the (pragmatic) probability of encountering a writer in this particular database, i.e., P (C) in Eq. 1. In the legal discussion about the evidence, the value of (a) the decision by the pattern-recognition tool after using pure-shape evidence and (b) the knowledge about the presence of a recidivist in the database can and should be decoupled and treated as isolated pieces of evidence. In other words, the designer of the pattern-recognition tool does not want to suffer a legal suit because of an erroneous system decision which is not caused by the applied pattern-recognition algorithm proper, but by the Bayesian weighing with a prior, for this utilization context. A decoupling of the application and context specific prior P (C) from the actual machine-learning information P (X|C)/P (X) is desirable, from this perspective. Given that P (X) would be the same for all C, this leaves us, again, with the deconstructed Bayes term P (X|C), which is, according to the author the essential contribution of pattern recognition proper: Knowing under which conditions patterns do occur. The other two terms are context-dependent biasing factors.\nExample 3 A cultural-heritage institution provides access to a large manuscript collection of administrative texts. The collection is also interesting to genealogy enthusiasts tracking their family name. Given a word-image example of a handwritten family name, the system must retrieve the most similar images.\nAlso in this application, the user is not interested in the clean-Bayesian posteriors, but is focused to find a unique needle-in-a-haystack family name and does not want to be annoyed by the fact that P (Smith) and P (Johnson) are very large values, causing the “hit list” for targets Smyth or Jonson to be contaminated with irrelevant items with a larger prior.\nExample 4 When training a multi-layer perceptron to classify the digits one to nine, the system can be made to behave Bayesian if it is trained with the natural (Benford, 1938) frequencies of training instances of the digits: 1 (30.1%), 2 (17.6%), 3 (12.5%), 4 (9.7%), 5 (7.9%), 6 (6.7%), 7 (5.8%), 8 (5.1%), 9 (4.6%). Is this appropriate?\nOn the contrary, in machine learning, most system designers will ignore the Benford distribution of digits and use a balanced training set with an equal number of samples for each of the classes, such that also the low-frequency digit “9” will be recognized reliably and the classifier will provide an output likelihood based on shape evidence alone, rather than on a mixture of shape evidence and pragmatic knowledge on class priors. For the sake of argument, the digit zero, which is obviously needed in a real system, is left out of this example: Its prior is excluded from the Benford distribution.\nIn patterns of human origin, e.g., spoken (Benzeghiba et al., 2007) or written words (Wing, 2000; Tucha et al., 2004), there is an additional confounding factor. The low-frequency patterns will be produced in a less stable manner and with a lower signal quality than the high-frequency words which have enjoyed more human-motor training. For this reason it is better to increase the relative presence of instances from low-frequency classes in a training set, rather than to rely on Bayes to decide for sampling frequencies. Also in latent semantic indexing (Dumais et al., 1997; Mikolov et al., 2013), effort is spent in non-Bayesian sampling a corpus of text in such a way that the model is not determined by the prior probability of terms. High-frequency function words would dominate deep bag-of-words models to the extent of becoming unusable.\nExample 5 In a criminal case, the forensic expert has computed the probability that some features of handwriting (or speech, etc.) in a sample are produced by the suspect. In the denominator of the Bayes equation, the probability of these features in the general population are used. The suspect, however, claims to be right-handed, that this is an accepted fact and demands that the probability is recomputed for the proper conditional reference set of right-handed writers. In many countries, the judge is allowed to disregard such ’subtleties’. However, the example illustrates the arbitrariness of reference sets. Both the prior of the decision (class) and the probability of evidence (feature) are implicitly conditional to some world context Wc and Wx where the observables happen, respectively:\nP (C|X,Wc,Wx) = P (X,Wx|C,Wc) ∗ P (C,Wc)\nP (X,Wx) (5)\nIn words: the probability that decision C is true, given observation X is considered in conjunction with a particular context Wc generating the decisions and a particular context Wx generating that observation. The context determinants W are then factors that should be taken into account in computing the conditional probability of observing X given C, in the adjusted context-specific prior for C and the evidence-generating context for observing X. The fact that context W plays a role becomes evident in any machine learning task where there is a difference between training and testing due to Wtest 6= Wtrain such that P (X,Wtest,x) 6= P (X,Wtrain,x), P (C,Wtest,c) 6= P (C,Wtrain,C) and P (X,Wtest,x|C,Wtest,c) 6= P (X,Wtrain,x|C,Wtrain,c).\nBoth in legal cases and in a reasoning robot, considerable deliberation over the validity of the reference context is needed when using a Bayesian decision framework."
    }, {
      "heading" : "2.1 Five remarks on Bayes",
      "text" : "To summarize, it can be noted that -in addition to the known problems of using naive Bayes- there are five other essential caveats:\n“behave as” vs “compute as” Bayes? Whereas the Bayes equation is optimal, learning by estimating its right-hand side terms may be rather impractical from a ’tabula rasa’ condition or only a limited number of examples. It is very well possible that a working classifier performs exactly according to Bayes, without ever residing to the computation of Bayesian products of probabilities ’under the hood’ of its machinery;\nprobability or utility? Since for autonomous systems, the ultimate decision is based on utility, it is conceivable to estimate utility directly from observables, bypassing the cumbersome estimation of probabilities, as is done in reinforcement learning (Wiering and van Otterlo, 2014);\nprobability or possibility? There is a singularity at the probability of zero, such that an autonomous system cannot know whether a zero-probability estimate corresponds to a structural, physical impossibility, or, alternatively, may be the consequence of insufficient sampling. However, both in Bayesian and Markov modeling, such problems are circumvented by using default, ’back-off’ probability constants with a low value (euphemistically called ’smoothing’). Such a practical intervention appears to be in conflict with the clear-cut cleanliness of the Bayes equation and will be a problem for cases where the estimated zero probability indeed represents a structural impossibility.\ncost of learning? How to obtain reliable priors and class-conditional feature distributions? The bootstrap problem may be insurmountable. In robotics problems applying Bayesian learning it is not uncommon to find the batteries drained and mechanical defects appearing long before the necessary probability distributions have been estimated reliably. The challenge is usually not to implement an optimal system, given an infinite amount of correctly labeled data, but to provide an acceptable performance on the amount of training data that happens to be available.\nuniversality? Are the unconditional probabilities really universal? Is the notion of a population or ensemble valid enough to compute prior probabilities of classes and evidences? Especially in language problems, lack of universality becomes quickly evident: Contemporary corpora of text, even if they encompass hundreds of thousands of documents, are utterly unusable to help in deciphering a medieval text using statistical models. In order to enjoy the benefits from computational linguistics, large reference corpora of medieval documents in the same language and from a comparable content would be needed, but these evidently do not exist. The well-known large data set of contemporary handwritten digits MNIST with 50k samples (LeCun et al., 1998) is already inadequate for a reliable recognition of late 19th/early 20th century digits as we found out (Bulacu et al., 2009)."
    }, {
      "heading" : "3. Accuracy and quantization",
      "text" : "As a consequence of the problems noted here, textbook examples and successful articles usually deal with questions of limited dimensionality. In a bioinformatics application with feature vectors of 20k dimensions, however, the product of probabilities for the observed feature values would not often yield a meaningful value. This will be dealt with in the next section. As an example: 0.99920000 = 2 ∗ 10−9 but 0.99820000 = 0 (at ANSI C double or FORTRAN REAL*8 precision). Sampling a joint-probability distribution until reliable estimates are reached is very expensive, even in problems of medium dimensionality. Apart from belief networks, the new field of conditional random fields (CRFs) is now also focusing on Bayes as its computing element. In the next section we will show, that under conditions of unreliable probability estimates, the chances of success are strongly limited for long chains of probabilistic reasoning."
    }, {
      "heading" : "4. The product of probabilities",
      "text" : "An underestimated problem in Bayesian (and therefore Markovian) modeling is the fact that a product of probabilities suffers from a number of practical and fundamental limitations. Usually, for a chain of observables or conditionals, a product of probabilities is computed:\nptrue = n∏ i pi (6)\nwhere n is the number of probabilities in the chain. For example, for a number of class models Ω, a model is searched with the maximum probability product:\nΩtrue = argmaxΩ n∏ i pi(Ω) (7)\nWhat is usually forgotten is that each probability p is actually an estimate, most likely suffering from an error. In the Bayesian belief approach, (initial) subjective probabilities will be subject to such an estimation problem. However, also other approaches entail an ’error in the probability’, where that probability is estimated using, e.g., neural networks or\nother methods. Let us assume there exists an additive error on the estimated probabilities, such that a more realistic variation on Eq. 6 is:\npmeasured(t) = n∏ i (pi + (t)) (8)\nwhere is some stochastic variable characterized by a (usually unknown) statistical distribution. Then, the expected absolute-valued error is\nε = E|ptrue − pmeasured| (9)\nFor sake of simplicity, in order to obtain an impression of the order of magnitude of errors to be expected, assume that all pi ≈ P , where P is a given constant probability such that the product reduces to:\nptrue = P n (10)\nand\npmeasured = (P + ) n (11)\nThen, the expected absolute-valued error can be expressed as:\nε′ = E|Pn − (P + )n| (12)\nMore interesting, however, is the relative error, as it will immediately relate to the ranking of different models Ω in a classification problem.\nε′rel = ε ′/Pn (13)\nor\nε′rel ≈ |Pn − (P + )n|/Pn (14)\nFor non-zero P we can now estimate the magnitude of the relative error:\nε′rel ≈ |1− (P + )n/Pn| (15) = |1− ( (P + )\nP\n)n | (16)\n= |1− (1 + /P )n | (17)\nOnly in the case is exactly equal to zero, the expected relative error will equal zero. In all other cases, a power of the sum of one plus an error fraction will lead to a very large error for large n. For problems with a chain of probabilities for more than ten pieces of (Bayesian) information, there will be a serious error.\nAdditionally, but separately from the fundamental problem described here, the product of probabilities entails very small values which lead to quantization errors. In the programming language C, for instance, the use of float (4 bytes for a floating point number) must\nbe excluded. Regular double precision (8 bytes) will do better, but it is advisable to use long double. A common trick is to sum log(p) instead of computing a product. This may help somewhat in the computational problem, but that does not solve the problem of an error in the probability estimates biasing the final product of p or sum of log(p). In the next section an experiment is performed to check the predictions."
    }, {
      "heading" : "4.1 Monte-Carlo experiment",
      "text" : "Apart from the analytical discussion above, it may be informative to visualize the error propagation. A Monte-Carlo experiment is performed. For a range of chain lengths n, for each value of n a large number (100k) of probability vectors of dimensionality n is drawn (i.i.d.) with element values from a uniform distribution x ∈ [0, 1]. A range of additiveerror amplitudes a ∈ [0, 1] is scanned in steps of 0.01, contaminating each true probability value with a uniformly distributed ∈ [−a, a]. For each instance of a probability vector, the relative difference between the true probability product and the measured product -as contaminated by - is computed. Since these computations are highly influenced by quantization error, the simulation will be based on long doubles (16 bytes per floating-point value) to mitigate quantization error. Each experiment for a value of a is repeated twenty times to obtain an average error curve (Figures 1 to 3). With a chain of ten probabilities and an error amplitude a = 0.3 for , the resulting product of probabilities suffers from an error which is of the same order of magnitude as the true probability product, i.e., the relative error has a value of one (100%). For longer chains, the result is evidently more dramatic. With a chain of 20 probabilities and the same value of = 0.3, the relative error is about 200%!\nThese tests are rather primitive, in the sense that a uniform distribution is used and the probability estimates are biased in a purely additive fashion, without keeping the biased probabilities in the range [0, 1]. Both truncation and residing to a Gaussian error will mitigate the error-multiplication effect. However, for a truncated uniform error (Appendix,\nTable I), the case of ten probabilities in a chain will still lead to a relative error of about one (100%). With a chain of twenty probabilities, the relative error will be about 130%.\nFor non-truncated Gaussian errors on the individual probabilities, assuming a base standard deviation of σ = √ 1/12, which is the same value as the standard deviation of the uniform distribution, the effect is less extreme, but still highly worrying. Here, in case of a chain of ten probabilities, the relative error will be 50%. For a chain of twenty probabilities, the relative error will be 80% (Appendix, Table II).\nIn this section we have seen from Monte-Carlo experiments on products of probabilities that the presence of an estimation error in the chain will yields dramatic errors, even in problems of dimensionalities that would be considered low (e.g., Ndim=20) in current-day problems in scientific methods or applied systems."
    }, {
      "heading" : "5. How is the error of a product of probabilities distributed?",
      "text" : "The performance of Monte-Carlo experiments leaves one with the unsatisfying situation that a more compact analytical description of the problem does not exist. According to the central limit theorem, the sum of arbitrary distributions will converge to the Gaussian distribution. In case of the product of independent random variable, a log normal distribution may be expected. However, it can be observed that not only the mean but also the standard deviation of resulting distributions increases as chain lengths will be longer. In this case, as yet without proof, we will propose the continuous Poisson distribution.\nWhen running a Monte-Carlo experiment to draw n probabilities pi from a uniform distribution in order to multiply them, it will appear that with a large enough number of iterations:\nN∑ k=1 n∑ i=1 ln(pi) = −n (18)\nwhere N is the number of iterations indexed k. This -maybe counterintuitive- result is due to the following. The integral of ln(x), x ∈ R is given by:\nF(x) = ∫ ln(x)dx (19)\n= x ln(x)− x+ C (20)\nFor the interval x ∈ [0, 1] this yields the following value:\n∫ 1 0 ln(x)dx = F(1)−F(0) (21)\n= 1 ln(1)− 1 + C − (0 ln(0) + C) (22) = −1 (23)\nUsing the property that for computing a sum, the inner and outer loop may be swapped in the algorithm, and realizing that the sum of a large (infinite) number of uniform-random draws from the interval [0, 1] amounts to integrative sampling of that interval, we obtain the following estimation of the mean of the resulting distribution:\nn∑ i=1 ∫ 1 0 ln(pi)dp = n ∫ 1 0 ln(x)dx (24)\n= −n (25)\nThus, chain length directly determines the average estimate of ∑n\ni=1 ln(pi), in fact, as the mean µ = −n, the variance will be σ2 = n, again, provided that the original random distribution is uniform. This distributions looks like an exponential distribution at n = 1, with a maximum on the right and the tail on the left. For increasing values of n, the distribution will move left, gradually becoming less skewed.\nIf m = b− ∑n\ni=1 ln(pi)c, where m ∈ N≥0 is then m is distributed approximately according to Poisson:\nPoiss(m,n) = nme−m\nm! (26) However, for a sum of log probabilities x = − ∑n\ni=1 ln(pi), a continuous random variable x ∈ R≥0 is needed, unlike the discrete, countable stochastic variable underlying the regular Poisson distribution, such that we need to assume a variant of the Poisson distribution describing a continuous stochastic variable. To this end, the gamma function Γ() can be applied:\ncPoiss(x, n) = nxe−x\nΓ(x+ 1) (27)\nThe continuous-Poisson function cPoiss() will reliably model the distribution of a product of probabilities in the domain of a sum of log probabilities.\nApart from a more or less practical premise which led us to propose the continuous Poisson distribution, namely that a continuous variable requires a continuous Poisson model, a formal proof is not given here. However, this model fits the Monte-Carlo experiments very well. Figures 4 and 5 show examples of correspondence between data and continuousPoisson model. The model requires one scaling factor along the x-axis, to compensate for the simulation characteristics. The same value is used for all values of n = λ in a graph.\nThe next question is how to model the distribution of a sum of the logarithm of probabilities when the uniform distribution is in the domain p ∈ [0, pmax] rather than in the interval [0, 1]. For the case of an arbitrary maximal probability pmax, the position of the continuous-Poisson distribution can be translated simply along the abscissa, by denoting x′ = x+ ln(pnmax) and applying cPoiss(x\n′, n). Still further, a generalization can be obtained by constraining the probabilities in an interval [pmin, pmax]. Under these conditions, with proper scaling, the continuous-Poisson function will still be a good basis for modeling the effects of error transmission in probability-product chains. More specifically, for a bipolar interval [−e, e] and uniform noise, the standard deviation of the perturbations will be σe = √ (2e)2/12 = e/ √ 3 which will work out as a virtual elongation of the chain, such that the new mean of a distribution of sum-log probabilities will be shifted leftwards from the value n ln (pmean) to the value n ln (pmean + σe)."
    }, {
      "heading" : "6. Effects of ’error in the probability’ on classification",
      "text" : "In order to test the effects of the error in the probability estimate on a slightly more practical problem, consider the problem of finding the path with the maximum sum of log(probability) in a synthetic lexical search akin to word classification in a speech or handwriting recognition system. The simulation is set up as follows. A balanced tree of given depth d and breadth b - i.e., the fan-out per node - is generated. Each node corresponds with a letter of a word. Each edge is assigned a random transition probability designated as the true probability. In the resulting tree, there will be a path of maximum product of probability, or maximum sum of log(probability), which is the target for classification. The other paths of the tree can be considered as distractors. Given this probabilistic structure, a number of test instances is created for a model, where each of the transition probabilities is nudged with a small additive uniform random error with zero mean and bipolar range ± . In the simulation, the following parameters were varied: Depth d = 3, 5, 7, 9, breadth b = 2, 3, 4, 5, 6 and error = 0.01, 0.02, 0.04, 0.08, 0.16, 0.32. A wide range of models will thus be generated, randomly biased, and tested. For the performance of the classification, the F measure will be used, with a weight of 0.5 for precision and recall. Accuracy is not a good performance measure in this test, because this performance measure is biased by a large number of correct rejects for distractor paths in the -possibly large- tree.\nTable 1 shows the classification performance for trees varying in depth from 3 to 13, breadth (fan out) varying from 2 to 6, and errors varying from 0.01 to 0.32, determining the amplitude of bipolar pseudo-random uniform noise2, with a mean of zero. The number of error-biasing trials for a given random model tree is 400. The number of randomly drawn models is 100 per tree topology. As can be inferred from the table, the expectation that errors will somehow be canceled out cannot be confirmed. Note that lexicon size (8 to 279936 paths) and word length (3 to 7) were varied in order to compute average performances. For instance, one model test for a tree with depth 7 and breadth 6 yields 67 = 279936 different paths, i.e., one target and 279935 distractor paths. This particular single model test requires some 108 sum of log-probability path evaluations and is repeated 100 times. Already a probability error of only = 0.01 yields a drop of three percent in path classification performance, even on short paths. This deteriorates as paths become longer and the number of distractors increases (Table 1)."
    }, {
      "heading" : "7. Intermediate Conclusion: Error propagation in probability product",
      "text" : "chains\nIn current applications in pattern recognition, machine learning and data mining, feature vectors and problem dimensionality may well exceed an n of ten dimensions. Dimensionalities of hundreds, thousands, even tens of thousands (in bioinformatics and marketing) are common. Therefore, it is highly likely that many systems and applications reported in literature suffer from the problem described here. It is a riddle, how current text books keep advertising Bayesian and Markovian approaches, virtually without caveats. At the conceptual, descriptive level, the reverend Bayes is right, of course. Who would want to\n2. drand48() was used\nargue with the basic principle? For a realizable and powerful classification system one must hope that it behaves in a Bayesian manner, because this is the theoretical optimum.\nThe issue of one-trial (one-shot) learning has garnered attention in recent years, both in the Bayesian (Fei-Fei et al., 2006; Lake et al., 2015) and in the deep-learning (Rezende et al., 2016) schools of thought. Assuming that generally true, low-level patterns have been trained to a system in a reliable manner, this ’world’ information can be used in a generative fashion by making inferences on perceived instances of a new, previously unseen class. With the proper pretraining and dimension reduction, the existing Bayesian conditional probability landscape can be used to infer new categories and classes. In no way this paper is intended to question the importance of Bayesian modeling and the power of generative approaches based on Bayes. However, generative hypothesis generation can also be realized using deep learning, with a lesser stress on the Bayesian properties (’approximate Bayesian inference’ (Kingma et al., 2014)). It remains to be seen in how far the current results are still small and specific, with little hope for easy replication in other domains. If the product of probabilities chain can be kept short, the error propagation problem addressed in this paper may pose only a limited risk.\nHowever, as demonstrated before, it is unrealistic to expect veridical a posteriori probability estimates when computing in a Bayesian style over a practical problem where many pieces of evidence are combined in a product of probabilities. An important motivation for writing this memo is the regular stream of questions received from PhD students about HMMs for handwriting recognition because they encounter problems in replicating good recognition result from HMM literature. The reason may be that failures are not archived in the public arena and ’typical results’ may indeed be very typical. Van Oosten and Schomaker (2014) addresses a number of ’tricks of the trade’, well known to researchers in the domain of hidden-Markov modeling but not spelled out in enough detail in the literature."
    }, {
      "heading" : "8. Caveats on Markov modeling",
      "text" : "Although Hidden-Markov Models are well known, a brief introduction is necessary. The assumption is that in stochastic observation series, the next observation can predicted from the current state of a modeled system. For explicit (’surface’) Markov models, the current state for a discrete time and discrete state system can be the observation of a token from the alphabet of a stochastic language generator. For large alphabets, such as the list of phonemes uttered by a human speaker, it became quite clear, that in order to work for speech recognition, the model space needed to be reduced: The number of state transitions would consist of an L*L matrix, with L being the number of tokens emitted by the source. Such a matrix can become quite large, because a typical ’alphabet’ of quantized phonemes may have hundreds of tokens. A powerful solution for this problem is to replace the concrete observation token-as-a-state by a more abstract, ’hidden’, state, which induces a probability distribution of tokens that is valid when this state occurs. In this manner, a number of k << L state transitions can be used to characterize a state-dependent token-emission process. Also in the Markov paradigm, products of probabilities play an essential role, for instance in the computation of the likelihood that a particular sequence of states represents, e.g., a spoken word in speech recognition. Most commonly, sums of products of two probabilities\nare used of the form pij = ∑k\nr=1 pirprj . This means that the propagation of the random estimation error within each value of p is less dramatic than in a long belief-network reasoning chain but will still have an unavoidable problematic effect on the model estimation and its use for classification or prediction.\nA final caveat to be dealt with is the question whether the temporal structure of a particular classification problem is important, at all. Does one really need a state transition matrix for problems such as handwriting or speech recognition? Because these problems present themselves as temporal, with patterns of varying duration, Markov modeling seems to be unavoidable.\nWhat is the word classification rate in a lexicon, if the only information used is letter presence, regardless of sequential order of the letters? In order to test the uniqueness of words in lexica of a number of languages, an experiment was done, using nearest-neighbor classification. The feature vector for each word of a lexicon consists of the counts of its letters in the alphabet. The word ’a’ would be represented by a vector with an element of value one and 61 zeros (Upper and lower case letters are treated as different and international characters are transliterated to their nearest ASCII representative, keeping the dimensionality identical for all languages in the test). For nine languages, 20-thousand words were randomly selected each, from a larger lexicon. In order to prevent deterministic sort order effects, a small fraction of noise was added to the counts, making sure that the total variation remains within a step count of one (bipolar uniform noise amplitude a = 0.0001. In the worst case, a ∗ 62 << 1, the deviation from the letter count is much smaller than one, so no spurious attractors for nearest-neighbor matching are created. This was done twice per test per lexicon, such that a reference set and a test set was obtained which marginally differed in terms of the small noise perturbations3. In this manner, words with an identical letter count vector have an equal probability of obtaining a hit in the nearest-neighbor search. Tests were repeated six times, with random values. The random number generator was initialized by using the microseconds field value of the time of program start.\nTable 2 shows the results, which reveal a surprisingly high recognition rate on the basis of word-letter frequency, with a stable result over multiple random selections. On the basis of these findings, speech and handwriting recognizers, which usually have lower classification rates than this, should focus predominantly on letter-presence detection rather than spending modeling time on the sequential order. Discussion with colleagues from different teams in Markov modeling world-wide revealed that it was, paraphrasing, ’considered a well-known fact that the transition matrix was less important than the state-conditional probability distributions in Markov modeling’. According to these results, the efforts in sequence modeling will only cover one to five percent of the problems in lexical classification. It can be hypothesized that BLSTM (neural) methods may also have relied more on pattern presence detection rather than on elaborate sequence modeling, after training. In Van Oosten and Schomaker (2014) we have shown that the importance of temporal modeling can easily be checked when training a hidden Markov Model by flattening the transition matrix. If the performance collapses, temporal modeling was essential. As in the lexical example above, the collapse may be limited since the essential information for classification\n3. Lexical ’letvec’ data can be obtained here: monkweb.nl/monk/Projects/distro-UDI-Letvec.tgz\nresides in the state-conditional observation probability distributions of the HMM and not in the state transitions."
    }, {
      "heading" : "9. Non-probabilistic distance-based matching",
      "text" : "We have found that, using non-Markovian, non-Bayesian word classifiers for historical handwriting in a wide range of scripts, periods and languages, nearest-centroid feature matching schemes may attain word classification rates of 82%, for classes with 50 example instances each, and lexica of 1100 words on average. The largest lexicon used was for 22k Chinese characters. Such results were obtained without extensive training and efforts by human researchers. With more modeling effort, word recognition rates above 90% were obtained in Van der Zant et al. (2008). Figure 6 shows the distribution of nearest-neighbor (nearestmean) matching in our ongoing ’24/7’ learning search engine for handwritten words, the Monk project (Schomaker, 2016). Note that in these methods, the performance relies more on geometry (shape) than on probability (familiarity) of patterns. The theory on similarity spaces and multiple-instance learning (Duin et al., 2013) has made great strides forward in recent years and the focus is on geometry rather than on probability, here also."
    }, {
      "heading" : "10. Conclusions",
      "text" : "Notwithstanding current folklore, there are many problems associated with the application of Bayesian learning and classification and hidden-Markov modeling. The attractive, clear simplicity of Bayes will appear to have been misleading as soon as the modeling deviates from bowls with colored marbles, i.e., a world of closed sets and countable events, to the real world of sets with unclear boundaries, errors in probability estimates, limited data and missing observations. The use of probabilities should not be a goal in itself, if the final decision criteria are based on an other domain, e.g., utility. In computing products of probabilities or sums of log probabilities, beware of the propagating (relative) error. The error appears to be considerable, seemingly according to a continuous Poisson distribution.\nFor hidden-Markov modeling, it is advisable to test whether temporal modeling is essential, for a problem at hand. Flattening of the transition matrix can be used as a test to find out whether the Markov assumption is needed. If it is not, the problem may also be cast as a simultaneous feature-processing classification of the pattern as a whole. If the pattern-learning process is in a bootstrapping stage, with only limited numbers of examples such that the use of current ’deep learning’ is out of the question, purely geometric methods such as nearest-neighbor matching are still an attractive option, especially in sparsely labeled ’big data’."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We would like to acknowledge support for this project from the Dutch NWO (grants 612.066.514 and 640.002.402)"
    }, {
      "heading" : "11. Appendix: Table I. Relative error on product of probabilities, for",
      "text" : "truncated-Uniform error on the individual probabilities, for chain lengths n\ne = amplitude of error, to be multiplied with the value of each sample from the uniform distribution with µ = 0, σ = √ 1/12. Truncation means that after the error addition, negative probabilities or values above 1.0, are folded to zero or one, respectively.\nn = number of probabilities in the product chain\nThese values are computed experimentally and contain quantization errors, especially for high n. Example: for an absolute estimation error e = 0.06, the relative error on the product of probabilities will be 0.3 (30%) in a chain of 13 probabilities in the product.\ne \\ n 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39\n0.00 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.02 0.0 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.03 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.04 0.0 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.05 0.0 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.4 0.06 0.1 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.5 0.07 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.5 0.6 0.6 0.08 0.1 0.1 0.2 0.2 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.6 0.6 0.7 0.09 0.1 0.2 0.2 0.3 0.3 0.3 0.4 0.4 0.4 0.5 0.5 0.5 0.5 0.6 0.5 0.6 0.6 0.7 0.7 0.7 0.10 0.1 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.7 0.8 0.7 0.8 0.11 0.1 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.6 0.7 0.7 0.7 0.7 0.8 0.9 0.8 0.12 0.1 0.2 0.3 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.7 0.8 0.8 0.8 0.9 1.0 0.9 0.13 0.1 0.2 0.3 0.4 0.4 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.8 0.8 0.8 0.9 0.9 0.9 1.0 0.9 0.14 0.1 0.3 0.3 0.4 0.5 0.5 0.6 0.6 0.7 0.7 0.7 0.8 0.8 0.8 0.9 0.9 1.0 0.9 1.0 1.0 0.15 0.1 0.3 0.4 0.4 0.5 0.6 0.6 0.7 0.7 0.7 0.8 0.8 0.9 0.9 0.9 0.9 1.0 1.0 1.0 1.0 0.16 0.2 0.3 0.4 0.5 0.5 0.6 0.6 0.7 0.7 0.8 0.8 0.8 0.9 0.9 0.9 1.0 1.1 1.1 1.1 1.2 0.17 0.2 0.3 0.4 0.5 0.6 0.6 0.7 0.7 0.8 0.8 0.9 0.9 1.0 1.0 1.0 1.0 1.1 1.2 1.1 1.1 0.18 0.2 0.3 0.4 0.5 0.6 0.7 0.7 0.8 0.8 0.9 0.9 1.0 1.0 1.0 1.1 1.1 1.1 1.2 1.2 1.7 0.19 0.2 0.3 0.4 0.5 0.6 0.7 0.7 0.8 0.9 0.9 1.0 1.0 1.0 1.1 1.1 1.2 1.1 1.3 1.3 1.4 0.20 0.2 0.4 0.5 0.6 0.6 0.7 0.8 0.8 0.9 0.9 1.0 1.0 1.1 1.1 1.1 1.2 1.2 1.3 1.2 1.6 0.21 0.2 0.4 0.5 0.6 0.7 0.7 0.8 0.9 0.9 1.0 1.0 1.1 1.1 1.2 1.2 1.2 1.3 1.3 1.3 1.3 0.22 0.2 0.4 0.5 0.6 0.7 0.8 0.8 0.9 1.0 1.0 1.1 1.1 1.1 1.2 1.3 1.3 1.3 1.2 1.6 1.4 0.23 0.2 0.4 0.5 0.6 0.7 0.8 0.9 0.9 1.0 1.1 1.1 1.2 1.2 1.3 1.2 1.3 1.4 1.4 1.5 1.9 0.24 0.2 0.4 0.6 0.7 0.8 0.8 0.9 1.0 1.0 1.1 1.1 1.2 1.2 1.3 1.6 1.4 1.5 1.3 1.4 1.4 0.25 0.2 0.4 0.6 0.7 0.8 0.9 0.9 1.0 1.1 1.1 1.2 1.2 1.3 1.4 1.4 1.4 1.4 1.4 1.4 1.5 0.26 0.2 0.4 0.6 0.7 0.8 0.9 1.0 1.0 1.1 1.2 1.2 1.3 1.3 1.4 1.4 1.4 1.6 1.6 1.7 1.5 0.27 0.2 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.1 1.2 1.2 1.3 1.3 1.4 1.3 1.4 1.5 1.5 1.5 1.7 0.28 0.3 0.5 0.6 0.8 0.9 0.9 1.0 1.1 1.2 1.2 1.3 1.3 1.4 1.4 1.4 1.4 1.6 1.4 1.3 1.6 0.29 0.3 0.5 0.7 0.8 0.9 1.0 1.1 1.1 1.2 1.3 1.3 1.3 1.4 1.5 1.5 1.4 1.4 1.5 1.4 1.8 0.30 0.3 0.5 0.7 0.8 0.9 1.0 1.1 1.2 1.2 1.3 1.3 1.4 1.4 1.5 1.5 1.5 1.6 1.6 1.5 1.7"
    }, {
      "heading" : "12. Appendix: Table II. Relative error on product of probabilities, for",
      "text" : "non-truncated Gaussian error on the individual probabilities, for chain lengths n e = amplitude of error, to be multiplied with sample from a normal distribution with µ = 0, σ =√ 1/12 which are the same values as in the tests on the uniform distribution.\nn = number of probabilities in the product chain\nThese values are computed experimentally and contain quantization errors, especially for high n. Example: for an absolute estimation error e = 0.07, the relative error on the product of probabilities will be 0.2 (20%) in a chain of 13 Gauss-distributed probabilities in the product.\ne \\ n 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39\n0.00 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.03 0.0 0.0 0.0 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.04 0.0 0.0 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.05 0.0 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.06 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.2 0.3 0.07 0.0 0.1 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.08 0.0 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.09 0.0 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.10 0.0 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.5 0.5 0.4 0.11 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.5 0.5 0.4 0.5 0.12 0.1 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.5 0.4 0.5 0.5 0.5 0.6 0.13 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.5 0.6 0.6 0.14 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.7 0.6 0.15 0.1 0.1 0.2 0.2 0.3 0.3 0.3 0.4 0.4 0.4 0.5 0.5 0.5 0.5 0.5 0.5 0.6 0.7 0.6 0.7 0.16 0.1 0.1 0.2 0.2 0.3 0.3 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.8 0.7 0.17 0.1 0.2 0.2 0.3 0.3 0.3 0.4 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.7 0.7 0.7 0.8 0.7 0.8 0.18 0.1 0.2 0.2 0.3 0.3 0.4 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.6 0.7 0.7 0.7 0.8 0.9 0.19 0.1 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.7 0.6 0.8 0.8 0.8 1.0 1.1 0.20 0.1 0.2 0.2 0.3 0.4 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.7 0.7 0.8 0.8 0.9 0.9 1.0 0.7 0.21 0.1 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.7 0.7 0.8 0.7 0.9 0.9 0.9 1.0 0.9 0.22 0.1 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.8 0.8 0.8 0.9 0.9 1.2 1.1 0.23 0.1 0.2 0.3 0.3 0.4 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.8 0.8 0.8 1.0 0.8 0.9 0.9 1.1 0.24 0.1 0.2 0.3 0.4 0.4 0.5 0.5 0.6 0.6 0.7 0.7 0.7 0.8 0.9 0.9 0.9 1.1 1.0 0.9 1.1 0.25 0.1 0.2 0.3 0.4 0.4 0.5 0.5 0.6 0.6 0.7 0.7 0.8 0.8 0.9 1.0 1.2 1.0 1.0 1.1 1.2 0.26 0.1 0.2 0.3 0.4 0.5 0.5 0.6 0.6 0.7 0.7 0.8 0.8 0.8 0.9 1.2 1.1 1.1 1.2 1.2 1.2 0.27 0.1 0.2 0.3 0.4 0.5 0.5 0.6 0.6 0.7 0.7 0.8 0.9 0.9 1.0 1.1 1.0 1.1 1.1 1.3 1.2 0.28 0.1 0.3 0.3 0.4 0.5 0.6 0.6 0.7 0.7 0.8 0.8 0.9 0.9 1.0 1.1 1.0 1.1 1.1 1.4 1.4 0.29 0.1 0.3 0.4 0.4 0.5 0.6 0.6 0.7 0.7 0.8 0.9 1.0 0.9 0.9 1.2 1.2 1.1 1.1 1.1 1.3 0.30 0.1 0.3 0.4 0.5 0.5 0.6 0.7 0.7 0.8 0.8 0.9 0.9 1.0 1.0 1.2 1.3 1.3 1.3 1.5 1.5"
    }, {
      "heading" : "13. Appendix: Table III. Relative error on product of probabilities, for",
      "text" : "truncated-Gaussian error on the individual probabilities, for chain lengths n e = amplitude of error, to be multiplied with sample from a normal distribution with µ = 0, σ =√ 1/12 which are the same values as in the tests on the uniform distribution. Truncation means that negative probabilities or values above 1.0 are folded to either zero or one, respectively.\nn = number of probabilities in the product chain\nThese values are computed experimentally and contain quantization errors, especially for high n.\ne \\ n 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39\n0.00 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.03 0.0 0.0 0.0 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.04 0.0 0.0 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.05 0.0 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.06 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.2 0.2 0.2 0.07 0.0 0.1 0.1 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.3 0.08 0.0 0.1 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.09 0.0 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.4 0.3 0.4 0.4 0.4 0.10 0.0 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.5 0.5 0.11 0.0 0.1 0.1 0.2 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.12 0.1 0.1 0.1 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.5 0.4 0.5 0.5 0.13 0.1 0.1 0.2 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.5 0.5 0.6 0.14 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.5 0.6 0.5 0.15 0.1 0.1 0.2 0.2 0.3 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.5 0.6 0.6 0.6 0.7 0.16 0.1 0.1 0.2 0.2 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.7 0.6 0.7 0.17 0.1 0.1 0.2 0.2 0.3 0.3 0.3 0.4 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.6 0.7 0.8 0.7 0.18 0.1 0.2 0.2 0.3 0.3 0.3 0.4 0.4 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.6 0.6 0.7 0.7 0.19 0.1 0.2 0.2 0.3 0.3 0.4 0.4 0.4 0.5 0.5 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.7 0.7 0.8 0.20 0.1 0.2 0.2 0.3 0.3 0.4 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.8 0.8 0.8 0.8 0.21 0.1 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.6 0.7 0.7 0.7 0.8 0.7 0.9 0.22 0.1 0.2 0.3 0.3 0.4 0.4 0.4 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.7 0.9 0.8 0.8 0.9 1.0 0.23 0.1 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.7 0.6 0.7 0.8 0.8 0.8 0.8 0.9 0.9 0.24 0.1 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.8 0.8 0.8 0.9 0.8 0.9 1.0 0.25 0.1 0.2 0.3 0.4 0.4 0.5 0.5 0.5 0.6 0.6 0.6 0.6 0.7 0.8 0.8 0.8 0.8 0.9 1.0 1.1 0.26 0.1 0.2 0.3 0.4 0.4 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.7 0.9 0.8 0.9 0.9 0.9 1.1 1.1 0.27 0.1 0.2 0.3 0.4 0.4 0.5 0.5 0.6 0.6 0.7 0.7 0.7 0.8 0.8 0.9 0.9 1.0 1.0 1.0 0.9 0.28 0.1 0.2 0.3 0.4 0.4 0.5 0.6 0.6 0.7 0.7 0.7 0.7 0.8 0.9 0.9 1.1 0.9 1.0 1.1 1.1 0.29 0.1 0.2 0.3 0.4 0.5 0.5 0.6 0.6 0.6 0.7 0.7 0.8 0.8 0.9 0.9 0.9 0.9 1.0 1.0 1.0 0.30 0.1 0.3 0.3 0.4 0.5 0.5 0.6 0.6 0.7 0.7 0.8 0.8 0.8 0.9 0.9 1.1 1.0 1.0 1.0 1.1"
    }, {
      "heading" : "14. Appendix: C Source for generating random probability sequences",
      "text" : "with an error in each estimate\n/* mulprob - Lambert Schomaker - May 2009 */\n#include <stdio.h> #include <stdlib.h> #include <math.h> #define N 2000 #define Nerr 100\nint main(int argc, char *argv[]) {\nint i,j,k,n = N, niter=100000, seed, icurve, ncurves = 20; long double p[N], a, da = 0.01, e, d, sumd, sum, prod, target; double xax[Nerr], curve[Nerr];\nn = atoi(argv[1]); seed = atoi(argv[2]); srand48(seed);\n/* Clear arrays */\na = 0.0; for(k = 0; k < Nerr; ++k) {\nxax[k] = a; curve[k] = 0.0; a += da;\n}\nfor(icurve = 0; icurve < ncurves; ++icurve) {\n/* For a number of error levels a (i.e., error on the p[]) */\na = 0.0; for(k = 0; k < Nerr; ++k) {\n/* For a number of iterations to get a reliable estimate */\nsum = 0.0; sumd = 0.0; for(i = 0; i < niter; ++i) {\n/* Generate a sample of probabilities */\nfor(j = 0; j < n; ++j) {\np[j] = drand48();\n}\n/* Compute their veridical product */\nprod = 1.0; for(j = 0; j < n; ++j) {\nprod = prod * p[j];\n} target = prod;\n/* Compute their product, after adding bipolar noise */\nprod = 1.0;\nfor(j = 0; j < n; ++j) {\ne = 2. * a * (drand48()-0.5); prod = prod * (p[j] + e);\n} d = (target - prod); if(d < 0.) d = -d; sumd += d; sum += target;\n} curve[k] += (double) (sumd/sum); a += da;\n}\n} /* next curve */\nfor(k = 0; k < Nerr; ++k) {\ncurve[k] /= ncurves; printf(\"%f %f\\n\", xax[k], curve[k]);\n} return(0);\n}"
    } ],
    "references" : [ {
      "title" : "Pattern Classification and Scene Analysis",
      "author" : [ "R. 0. Duda", "P.E. Hart" ],
      "venue" : null,
      "citeRegEx" : "2009",
      "shortCiteRegEx" : "2009",
      "year" : 1973
    }, {
      "title" : "Psychological facts and psychological theory",
      "author" : [ ],
      "venue" : "Psychological Bulletin,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1997
    }, {
      "title" : "Semi-supervised learning with deep generative models",
      "author" : [ "D.P. Kingma", "D.J. Rezende", "S. Mohamed", "M. Welling" ],
      "venue" : "In Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Kingma et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kingma et al\\.",
      "year" : 2014
    }, {
      "title" : "Human-level concept learning through probabilistic program induction",
      "author" : [ "B.M. Lake", "R. Salakhutdinov", "J.B. Tenenbaum" ],
      "venue" : null,
      "citeRegEx" : "Lake et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lake et al\\.",
      "year" : 2015
    }, {
      "title" : "Mnist handwritten digit database",
      "author" : [ "Y. LeCun", "C. Cortes", "C. Burges" ],
      "venue" : "Technical report,",
      "citeRegEx" : "LeCun et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 1998
    }, {
      "title" : "Distributed representations of words and phrases and their compositionality",
      "author" : [ "T. Mikolov", "I. Sutskever", "K. Chen", "G.S. Corrado", "J. Dean" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Mikolov et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Mikolov et al\\.",
      "year" : 2013
    }, {
      "title" : "Tackling the poor assumptions of naive bayes text classifiers",
      "author" : [ "J.D.M. Rennie", "J. Teevan", "D.R. Karger" ],
      "venue" : "In Proceedings of the Twentieth International Conference on Machine Learning,",
      "citeRegEx" : "Rennie et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Rennie et al\\.",
      "year" : 2003
    }, {
      "title" : "One-shot generalization in deep generative models",
      "author" : [ "D.J. Rezende", "S. Mohamed", "I. Danihelka", "K. Gregor", "D. Wierstra" ],
      "venue" : "In Proceedings of the 33rd International Conference on Machine Learning,",
      "citeRegEx" : "Rezende et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Rezende et al\\.",
      "year" : 2016
    }, {
      "title" : "Limitations of the dual-process-theory regarding the writing of words and non-words to dictation",
      "author" : [ "O. Tucha", "C. Trumpp", "K.W.e Lange" ],
      "venue" : "Brain and Language,",
      "citeRegEx" : "Tucha et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Tucha et al\\.",
      "year" : 2004
    }, {
      "title" : "One-trial learning",
      "author" : [ "B.J. Underwood", "G. Keppel" ],
      "venue" : "Journal of Verbal Learning and Verbal Behavior,",
      "citeRegEx" : "Underwood and Keppel.,? \\Q1962\\E",
      "shortCiteRegEx" : "Underwood and Keppel.",
      "year" : 1962
    }, {
      "title" : "Handwritten-word spotting using biologically inspired features",
      "author" : [ "T. Van der Zant", "L.R.B. Schomaker", "K. Haak" ],
      "venue" : "IEEE Transactions on Pattern Analysis and Machine Intelligence,",
      "citeRegEx" : "Zant et al\\.,? \\Q1945\\E",
      "shortCiteRegEx" : "Zant et al\\.",
      "year" : 1945
    }, {
      "title" : "An overview and comparison of voting methods for pattern recognition",
      "author" : [ "M. van Erp", "L. Vuurpijl", "L.R.B. Schomaker" ],
      "venue" : "In IWFHR ’02: Proceedings of the Eighth International Workshop on Frontiers in Handwriting Recognition",
      "citeRegEx" : "Erp et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Erp et al\\.",
      "year" : 2002
    }, {
      "title" : "A reevaluation and benchmark of hidden markov models",
      "author" : [ "J.-P. Van Oosten", "L.R.B. Schomaker" ],
      "venue" : "In Frontiers in Handwriting Recognition (ICFHR),",
      "citeRegEx" : "Oosten and Schomaker.,? \\Q2014\\E",
      "shortCiteRegEx" : "Oosten and Schomaker.",
      "year" : 2014
    }, {
      "title" : "On the convergence of the baum-welch training algorithm for hidden markov models",
      "author" : [ "J-P. van Oosten", "V. Frinken", "S. Uchida", "L.R.B. Schomaker" ],
      "venue" : "xx(x):xxx–xxx,",
      "citeRegEx" : "Oosten et al\\.,? \\Q2017\\E",
      "shortCiteRegEx" : "Oosten et al\\.",
      "year" : 2017
    }, {
      "title" : "Reinforcement Learning: State-of-the-Art",
      "author" : [ "M. Wiering", "M. van Otterlo" ],
      "venue" : "ISBN 364244685X,",
      "citeRegEx" : "Wiering and Otterlo.,? \\Q2014\\E",
      "shortCiteRegEx" : "Wiering and Otterlo.",
      "year" : 2014
    }, {
      "title" : "Motor control: Mechanisms of motor equivalence in handwriting",
      "author" : [ "A.M. Wing" ],
      "venue" : "Current Biology,",
      "citeRegEx" : "Wing.,? \\Q2000\\E",
      "shortCiteRegEx" : "Wing.",
      "year" : 2000
    }, {
      "title" : "Sparse representations for fast, one-shot learning",
      "author" : [ "K. Yip", "G.J. Sussman" ],
      "venue" : "In Proc. of National Conference on Artificial Intelligence,",
      "citeRegEx" : "Yip and Sussman.,? \\Q1997\\E",
      "shortCiteRegEx" : "Yip and Sussman.",
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 11,
      "context" : ", for combining classifiers van Erp et al. (2002). However, combination of evidence from multiple sources is still not trivial.",
      "startOffset" : 32,
      "endOffset" : 50
    }, {
      "referenceID" : 6,
      "context" : "This shortcoming of the naive-Bayes assumption has been dealt with in depth elsewhere (Rennie et al., 2003).",
      "startOffset" : 86,
      "endOffset" : 107
    }, {
      "referenceID" : 9,
      "context" : "For instance, in natural cognitive systems, the phenomenon of single-shot (one-shot, or one-trial) learning (Guthrie, 1946; Underwood and Keppel, 1962; Herbst, 1982; Hinton et al., 1984; Yip and Sussman, 1997) will make extensive and painful sampling unnecessary, after the first bite.",
      "startOffset" : 108,
      "endOffset" : 209
    }, {
      "referenceID" : 16,
      "context" : "For instance, in natural cognitive systems, the phenomenon of single-shot (one-shot, or one-trial) learning (Guthrie, 1946; Underwood and Keppel, 1962; Herbst, 1982; Hinton et al., 1984; Yip and Sussman, 1997) will make extensive and painful sampling unnecessary, after the first bite.",
      "startOffset" : 108,
      "endOffset" : 209
    }, {
      "referenceID" : 15,
      "context" : ", 2007) or written words (Wing, 2000; Tucha et al., 2004), there is an additional confounding factor.",
      "startOffset" : 25,
      "endOffset" : 57
    }, {
      "referenceID" : 8,
      "context" : ", 2007) or written words (Wing, 2000; Tucha et al., 2004), there is an additional confounding factor.",
      "startOffset" : 25,
      "endOffset" : 57
    }, {
      "referenceID" : 5,
      "context" : "Also in latent semantic indexing (Dumais et al., 1997; Mikolov et al., 2013), effort is spent in non-Bayesian sampling a corpus of text in such a way that the model is not determined by the prior probability of terms.",
      "startOffset" : 33,
      "endOffset" : 76
    }, {
      "referenceID" : 4,
      "context" : "The well-known large data set of contemporary handwritten digits MNIST with 50k samples (LeCun et al., 1998) is already inadequate for a reliable recognition of late 19th/early 20th century digits as we found out (Bulacu et al.",
      "startOffset" : 88,
      "endOffset" : 108
    }, {
      "referenceID" : 3,
      "context" : "The issue of one-trial (one-shot) learning has garnered attention in recent years, both in the Bayesian (Fei-Fei et al., 2006; Lake et al., 2015) and in the deep-learning (Rezende et al.",
      "startOffset" : 104,
      "endOffset" : 145
    }, {
      "referenceID" : 7,
      "context" : ", 2015) and in the deep-learning (Rezende et al., 2016) schools of thought.",
      "startOffset" : 33,
      "endOffset" : 55
    }, {
      "referenceID" : 2,
      "context" : "However, generative hypothesis generation can also be realized using deep learning, with a lesser stress on the Bayesian properties (’approximate Bayesian inference’ (Kingma et al., 2014)).",
      "startOffset" : 166,
      "endOffset" : 187
    }, {
      "referenceID" : 12,
      "context" : "Van Oosten and Schomaker (2014) addresses a number of ’tricks of the trade’, well known to researchers in the domain of hidden-Markov modeling but not spelled out in enough detail in the literature.",
      "startOffset" : 4,
      "endOffset" : 32
    }, {
      "referenceID" : 12,
      "context" : "In Van Oosten and Schomaker (2014) we have shown that the importance of temporal modeling can easily be checked when training a hidden Markov Model by flattening the transition matrix.",
      "startOffset" : 7,
      "endOffset" : 35
    }, {
      "referenceID" : 1,
      "context" : "We have found that, using non-Markovian, non-Bayesian word classifiers for historical handwriting in a wide range of scripts, periods and languages, nearest-centroid feature matching schemes may attain word classification rates of 82%, for classes with 50 example instances each, and lexica of 1100 words on average. The largest lexicon used was for 22k Chinese characters. Such results were obtained without extensive training and efforts by human researchers. With more modeling effort, word recognition rates above 90% were obtained in Van der Zant et al. (2008). Figure 6 shows the distribution of nearest-neighbor (nearestmean) matching in our ongoing ’24/7’ learning search engine for handwritten words, the Monk project (Schomaker, 2016).",
      "startOffset" : 295,
      "endOffset" : 566
    } ],
    "year" : 2017,
    "abstractText" : "This paper describes a number of fundamental and practical problems in the application of hidden-Markov models and Bayes when applied to cursive-script recognition. Several problems, however, will have an effect in other application areas. The most fundamental problem is the propagation of error in the product of probabilities. This is a common and pervasive problem which deserves more attention. On the basis of Monte Carlo modeling, tables for the expected relative error are given. It seems that it is distributed according to a continuous Poisson distribution over log probabilities. A second essential problem is related to the appropriateness of the Markov assumption. Basic tests will reveal whether a problem requires modeling of the stochasticity of seriality, at all. Examples are given of lexical encodings which cover 95-99% classification accuracy of a lexicon, with removed sequence information, for several European languages. Finally, a summary of results on a non-Bayes, non-Markov method in handwriting recognition are presented, with very acceptable results and minimal modeling or training requirements using nearest-mean classification.",
    "creator" : "LaTeX with hyperref package"
  }
}