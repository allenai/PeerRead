{
  "name" : "1606.03401.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Memory-Efficient Backpropagation Through Time",
    "authors" : [ "Audrūnas Gruslys", "Remi Munos", "Ivo Danihelka" ],
    "emails" : [ "audrunas@google.com", "munos@google.com", "danihelka@google.com", "lanctot@google.com", "gravesa@google.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We propose a novel approach to reduce memory consumption of the backpropagation through time (BPTT) algorithm when training recurrent neural networks (RNNs). Our approach uses dynamic programming to balance a trade-off between caching of intermediate results and recomputation. The algorithm is capable of tightly fitting within almost any user-set memory budget while finding an optimal execution policy minimizing the computational cost. Computational devices have limited memory capacity and maximizing a computational performance given a fixed memory budget is a practical use-case. We provide asymptotic computational upper bounds for various regimes. The algorithm is particularly effective for long sequences. For sequences of length 1000, our algorithm saves 95% of memory usage while using only one third more time per iteration than the standard BPTT."
    }, {
      "heading" : "1 Introduction",
      "text" : "Recurrent neural networks (RNNs) are artificial neural networks where connections between units can form cycles. They are often used for sequence mapping problems, as they can propagate hidden state information from early parts of the sequence back to later points. LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al. [2013]) and reinforcement learning (Sorokin et al. [2015], Mnih et al. [2016]) settings. Other successful RNN architectures include Neural Turing Machines (NTM) (Graves et al. [2014]), DRAW network (Gregor et al. [2015]), Neural Transducers (Grefenstette et al. [2015]).\nBackpropagation Through Time algorithm (BPTT) (Rumelhart et al. [1985], Werbos [1990]) is typically used to obtain gradients during training. One important problem is the large memory consumption required by the BPTT. This is especially troublesome when using Graphics Processing Units (GPUs) due to the limitations of GPU memory.\nMemory budget is typically known in advance. Our algorithm balances the tradeoff between memorization and recomputation by finding an optimal memory usage policy which minimizes the total computational cost for any fixed memory budget. The algorithm exploits the fact that the same memory slots may be reused multiple times. The idea to use dynamic programming to find a provably optimal policy is the main contribution of this paper.\nOur approach is largely architecture agnostic and works with most recurrent neural networks. Being able to fit within limited memory devices such as GPUs will typically compensate for any increase in computational cost.\nar X\niv :1\n60 6.\n03 40\n1v 1\n[ cs\n.N E\n] 1\n0 Ju"
    }, {
      "heading" : "2 Background and related work",
      "text" : "In this section, we describe the key terms and relevant previous work for memory-saving in RNNs. Definition 1. An RNN core is a feed-forward neural network which is cloned (unfolded in time) repeatedly, where each clone represents a particular time point in the recurrence.\nFor example, if an RNN has a single hidden layer whose outputs feed back into the same hidden layer, then for a sequence length of t the unfolded network is feed-forward and contains t RNN cores. Definition 2. The hidden state of the recurrent network is the part of the output of the RNN core which is passed into the next RNN core as an input.\nIn addition to the initial hidden state, there exists a single hidden state per time step once the network is unfolded. Definition 3. The internal state of the RNN core for a given time-point is all the necessary information required to backpropagate gradients over that time step once an input vector, a gradient with respect to the output vector, and a gradient with respect to the output hidden state is supplied. We define it to also include an output hidden state.\nAn internal state can be (re)evaluated by executing a single forward operation taking the previous hidden state and the respective entry of an input sequence as an input. For most network architectures, the internal state of the RNN core will include a hidden input state, as this is normally required to evaluate gradients. This particular choice of the definition will be useful later in the paper. Definition 4. A memory slot is a unit of memory which is capable of storing a single hidden state or a single internal state (depending on the context)."
    }, {
      "heading" : "2.1 Backpropagation through Time",
      "text" : "Backpropagation through Time (BPTT) (Rumelhart et al. [1985], Werbos [1990]) is one of the commonly used techniques to train recurrent networks. BPTT “unfolds” the neural network in time by creating several copies of the recurrent units which can then be treated like a (deep) feed-forward network with tied weights. Once this is done, a standard forward-propagation technique can be used to evaluate network fitness over the whole sequence of inputs, while a standard backpropagation algorithm can be used to evaluate partial derivatives of the loss criteria with respect to all network parameters. This approach, while being computationally efficient is also fairly intensive in memory usage. This is because the standard version of the algorithm effectively requires storing internal states of the unfolded network core at every time-step in order to be able to evaluate correct partial derivatives."
    }, {
      "heading" : "2.2 Trading memory for computation time",
      "text" : "The general idea of trading computation time and memory consumption in general computation graphs has been investigated in the automatic differentiation community (Dauvergne and Hascoët [2006]). Recently, the rise of deep architectures and recurrent networks has increased interest in a less general case where the graph of forward computation is a chain and gradients have to be chained in a reverse order. This simplification leads to relatively simple memory-saving strategies and heuristics. In the context of BPTT, instead of storing hidden network states, some of the intermediate results can be recomputed on demand by executing an extra forward operation. Chen et. al. proposed subdividing the sequence of size t into √ t equal parts and memorizing only hidden states between the subsequences and all internal states within each segment (Chen et al. [2016]). This uses O( √ t) memory at the cost of making an additional forward pass on average, as once the errors are backpropagated through the right-side of the sequence, the second-last subsequence has to be restored by repeating a number of forward operations. We refer to this as Chen’s √ t algorithm.\nThe authors also suggest applying the same technique recursively several times by sub-dividing the sequence into k equal parts and terminating the recursion once the subsequence length becomes less than k. The authors have established that this would lead to memory consumption of O(k logk+1(t)) and computational complexity of O(t logk(t)). This algorithm has a minimum possible memory usage of log2(t) in the case when k = 1. We refer to this as Chen’s recursive algorithm."
    }, {
      "heading" : "3 Memory-efficient backpropagation through time",
      "text" : "We first discuss two simple examples: when memory is very scarce, and when it is somewhat limited.\nWhen memory is very scarce, it is straightforward to design a simple but computationally inefficient algorithm for backpropagation of errors on RNNs which only uses only a constant amount of memory. Every time when the state of the network at time t has to be restored, the algorithm would simply re-evaluate the state by forward-propagating inputs starting from the beginning until time t. As backpropagation happens in the reverse temporal order, results from the previous forward steps can not be reused (as there is no memory to store them). This would require repeating t forward steps before backpropagating gradients one step backwards (we only remember inputs and the initial state). This would produce an algorithm requiring t(t+ 1)/2 forward passes to backpropagate errors over t time steps. The algorithm would be O(1) in space and O(t2) in time.\nA simple way of reducing memory consumption is simply to store only hidden RNN states at all time points. When errors have to be backpropagated from time t to t− 1, an internal RNN core state can be re-evaluated by executing another forward operation taking the previous hidden state as an input. The backward operation can follow immediately. This approach can lead to fairly significant memory savings, as typically the recurrent network hidden state is much smaller than an internal state of the network core itself. On the other hand this leads to another forward operation being executed during the backpropagation stage."
    }, {
      "heading" : "3.1 Backpropagation though time with selective hidden state memorization (BPTT-HSM)",
      "text" : "The idea behind the proposed algorithm is to compromise between two previous extremes. Suppose that we want to forward and backpropagate a sequence of length t, but we are only able to store m hidden states in memory at any given time. We may reuse the same memory slots to store different hidden states during backpropagation. Also, suppose that we have a single RNN core available for the purposes of intermediate calculations which is able to store a single internal state. Define C(t,m) as a computational cost of backpropagation measured in terms of how many forward-operations one has to make in total during forward and backpropagation steps combined when following an optimal memory usage policy minimizing the computational cost. One can easily set the boundary conditions: C(t, 1) = 12 t(t + 1) is the cost of the minimal memory approach, while C(t,m) = 2t − 1 for all m ≥ t when memory is plentiful (as shown in Fig. 3 a). Our approach is illustrated in Figure 1. Once we start forward-propagating steps at time t = t0, at any given point y > t0 we can choose to put the current hidden state into memory (step 1). This step has the cost of y forward operations. States will be read in the reverse order in which they were written: this allows the algorithm to store states in a stack. Once the state is put into memory at time y = D(t,m), we can reduce the problem into two parts by using a divide-and-conquer approach: running the same algorithm on the t > y side of the sequence while using m− 1 of the remaining memory slots at the cost of C(t− y,m− 1) (step 2), and then reusing m memory slots when backpropagating on the t ≤ y side at the cost of C(y,m) (step 3). We use a full size m memory capacity when performing step 3 because we could release the hidden state y immediately after finishing step 2.\nThe base case for the recurrent algorithm is simply a sequence of length t = 1 when forward and backward propagation may be done trivially on a single available RNN network core. This step has the cost C(1,m) = 1.\nHaving established the protocol we may find an optimal policy D(t,m). Define the cost of choosing the first state to be pushed at position y and later following the optimal policy as:\nQ(t,m, y) = y + C(t− y,m− 1) + C(y,m) (1)\nC(t,m) = Q(t,m,D(t,m)) (2) D(t,m) = argmin1≤y<t Q(t,m, y) (3)\nEquations can be solved exactly by using dynamic programming subject to the boundary conditions established previously (e.g. as in Figure 2(a)). D(t,m) will determine the optimal policy to follow. Pseudocode is given in the supplementary material. Figure 3 illustrates an optimal policy found for two simple cases."
    }, {
      "heading" : "3.2 Backpropagation though time with selective internal state memorization (BPTT-ISM)",
      "text" : "Saving internal RNN core states instead of hidden RNN states would allow us to save a single forward operation during backpropagation in every divide-and-conquer step, but at a higher memory cost.\nSuppose we have a memory capacity capable of saving exactly m internal RNN states. First, we need to modify the boundary conditions: C(t, 1) = 12 t(t + 1) is a cost reflecting the minimal memory approach, while C(t,m) = t for all m ≥ t when memory is plentiful (equivalent to standard BPTT). As previously, C(t,m) is defined to be the computational cost for combined forward and backward propagations over a sequence of length t with memory allowance m while following an optimal memory usage policy. As before, the cost is measured in terms of the amount of total forward steps made, because the number of backwards steps is constant. Similarly to BPTT-HSM, the process can be divided into parts using divide-and-conquer approach (Fig 4). For any values of t and m position of the first memorization y = D(t,m) is evaluated. y forward operations are executed and an internal RNN core state is placed into memory. This step has the cost of y forward operations (Step 1 in Figure 4). As the internal state also contains an output hidden state, the same algorithm can be recurrently run on the high-time (right) side of the sequence while having on less memory slot available (Step 2 in Figure 4). This step has the cost of C(t− y,m− 1) forward operations. Once gradients are backpropagated through the right side of the sequence, backpropagation can be done over the stored RNN core (Step 3 in Figure 4). This step has no additional cost as it involves no more forward operations. The memory slot can now be released leaving m memory available. Finally, the same algorithm is run on the left-side of the sequence (Step 4 in Figure 4). This final step has the cost of C(y − 1,m) forward operations. Summing the costs gives us the following equation:\nQ(t,m, y) = y + C(y − 1,m) + C(t− y,m− 1) (4)\nRecursion has a single base case: backpropagation over an empty sequence is a nil operation which has no computational cost making C(0,m) = 0.\nCompared to the previous section (20) stays the same while (19) is minimized over 1 ≤ y ≤ t instead of 1 ≤ y < t. This is because it is meaningful to remember the last internal state while there was no reason to remember the last hidden state. A numerical solution of C(t,m) for several different memory capacities is shown in Figure 5(a).\nD(t,m) = argmin 1≤y≤t Q(t,m, y) (5)\nAs seen in Figure 5(a), our methodology saves 95% of memory for sequences of 1000 (excluding input vectors) while using only 33% more time per training-iteration than the standard BPTT (assuming a single backward step being twice as expensive as a forward step)."
    }, {
      "heading" : "3.3 Backpropagation though time with mixed state memorization (BPTT-MSM)",
      "text" : "It is possible to derive an even more general model by combining both approaches as described in Sections 3.1 and 3.2. Suppose we have a total memory capacity m measured in terms of how much a single hidden states can be remembered. Also suppose that storing an internal RNN core state takes α times more memory where α ≥ 2 is some integer number. We will choose between saving a single hidden state while using a single memory unit and storing an internal RNN core state by using α\ntimes more memory. The benefit of storing an internal RNN core state is that we will be able to save a single forward operation during backpropagation.\nDefine C(t,m) as a computational cost in terms of a total amount of forward operations when running an optimal strategy. We use the following boundary conditions: C(t, 1) = 12 t(t + 1) as a cost reflecting the minimal memory approach, while C(t,m) = t for all m ≥ αt when memory is plentiful and C(t− y,m) =∞ for all m ≤ 0 and C(0,m) = 0 for notational convenience. We use a similar divide-and-conquer approach to the one used in previous sections.\nDefine Q1(t,m, y) as the computational cost if we choose to firstly remember a hidden state at position y and thereafter follow an optimal policy (identical to ( 18)):\nQ1(t,m, y) = y + C(y,m) + C(t− y,m− 1) (6)\nSimilarly, define Q2(t,m, y) as the computational cost if we choose to firstly remember an internal state at position y and thereafter follow an optimal policy (similar to ( 4) except that now the internal state takes α memory units):\nQ2(t,m, y) = y + C(y − 1,m) + C(t− y,m− α) (7)\nDefine D1 as an optimal position of the next push assuming that the next state to be pushed is a hidden state and define D2 as an optimal position if the next push is an internal core state. Note that D2 has a different range over which it is minimized, for the same reasons as in equation 5:\nD1(t,m) = argmin 1≤y<t Q1(t,m, y) D2(t,m) = argmin 1≤y≤t Q2(t,m, y) (8)\nAlso define Ci(t,m) = Qi(t,m,D(t,m)) and finally:\nC(t,m) = min i Ci(t,m) H(t,m) = argmin i Ci(t,m) (9)\nWe can solve the above equations by using simple dynamic programming. H(t,m) will indicate whether the next state to be pushed into memory in a hidden state or an internal state, while the respective values if D1(t,m) and D2(t,m) will indicate the position of the next push."
    }, {
      "heading" : "3.4 Removing double hidden-state memorization",
      "text" : "Definition 3 of internal RNN core state would typically require for a hidden input state to be included for each memorization. This may lead to the duplication of information. For example, when an optimal strategy is to remember a few internal RNN core states in sequence, a memorized hidden output of one would be equal to a memorized hidden input for the other one (see Definition 3).\nEvery time we want to push an internal RNN core state onto the stack and a previous internal state is already there, we may omit pushing the input hidden state. Recall that an internal core RNN state when an input hidden state is otherwise not known is α times larger than a hidden state. Define β ≤ α as the space required to memorize the internal core state when an input hidden state is known. A relationship between α and β is application-specific, but in many circumstances α = β + 1. We only have to modify (7) to reflect this optimization:\nQ2(t,m, y) = y + C(y − 1,m) + C(t− y,m− 1y>1α− 1y=1β) (10)\n1 is an indicator function. Equations for H(t,m), Di(t,m) and C(t,m) are identical to (8) and (9)."
    }, {
      "heading" : "3.5 Analytical upper bound for BPTT-HSM",
      "text" : "We have established a theoretical upper bound for BPTT-HSM algorithm as C(t,m) ≤ mt1+ 1m . As the bound is not tight for short sequences, it was also numerically verified that C(t,m) < 4t1+ 1 m for t < 105 and m < 103, or less than 3t1+ 1 m if the initial forward pass is excluded. In addition to that, we have established a different bound in the regime where t < m m\nm! . For any integer value a and for all t < m a\na! the computational cost is bounded by C(t,m) ≤ (a+ 1)t. The proofs are given in the supplementary material. Please refer to supplementary material for discussion on the upper bounds for BPTT-MSM and BPTT-ISM."
    }, {
      "heading" : "3.6 Comparison of the three different strategies",
      "text" : "Computational costs for each previously described strategy and the results are shown in Figure 6. BPTT-MSM outperforms both BPTT-ISM and BPTT-HSM. This is unsurprising, because the search space in that case is a superset of both strategy spaces, while the algorothm finds an optimal strategy within that space. Also, for a fixed memory capacity, the strategy memorizing only hidden states outperforms a strategy memorizing internal RNN core states for long sequences, while the latter outperforms the former for relatively short sequences."
    }, {
      "heading" : "4 Discussion",
      "text" : "We used an LSTM mapping 256 inputs to 256 with a batch size of 64 and measured execution time for a single gradient descent step (forward and backward operation combined) as a function of sequence length (Figure 2(b)). Please note that measured computational time also includes the time taken by backward operations at each time-step which dynamic programming equations did not take into the account. A single backward operation is usually twice as expensive than a orward operation, because it involves evaluating gradients both with respect to input data and internal parameters. Still, as the number of backward operations is constant it has no impact on the optimal strategy."
    }, {
      "heading" : "4.1 Optimality",
      "text" : "The dynamic program finds the optimal computational strategy by construction, subject to memory constraints and a fairly general model that we impose. As both strategies proposed by Chen et al. [2016] are consistent with all the assumptions that we have made in section 3.4 when applied to RNNs, BPTT-MSM is guaranteed to perform at least as well under any memory budget and any sequence length. This is because strategies proposed by Chen et al. [2016] can be expressed by providing a (potentially suboptimal) policy Di(t,m), H(t,m) subject to the same equations for Qi(t,m).\n4.2 Numerical comparison with Chen’s √ t algorithm\nChen’s √ t algorithm requires to remember √ t hidden states and √ t internal RNN states (excluding input hidden states), while the recursive approach requires to remember at least log2 t hidden states. In other words, the model does not allow for a fine-grained control over memory usage and rather saves some memory. In the meantime our proposed BPTT-MSM can fit within almost arbitrary constant memory constraints, and this is the main advantage of our algorithm.\nThe non-recursive Chen’s √ t approach does not allow to match any particular memory budget making a like-for-like comparison difficult. Instead of fixing the memory budge, it is possible to fix computational cost at 2 forwards iterations on average to match the cost of the √ t algorithm and observe how much memory would our approach use. Memory usage by the √ t algorithm would be equivalent to saving √ t hidden states and √ t internal core states. Lets suppose that the internal RNN core state is α times larger than hidden states. In this case the size of the internal RNN core state excluding the input hidden state is β = α − 1. This would give a memory usage of Chen’s algorithm as √ t(1 + β) = √ t(α), as it needs to remember √ t hidden states and √ t internal states where input hidden states can be omitted to avoid duplication. Figure 7 illustrates memory usage by our algorithm divided by √ t(1 + β) for a fixed execution speed of 2 as a function of sequence length and for different values of parameter β. Values lower than 1 indicate memory savings. As it is seen, we can save a significant amount of memory for the same computational cost. Another experiment is to measure computational cost for a fixed memory consumption of √ t(1 + β). The results are shown in Figure 7. Computational cost of 2 corresponds to Chen’s √ t algorithm. This illustrates that our approach does not perform significantly faster (although it does not do any worse). This is because Chen’s √ t strategy is actually near optimal for this particular memory budget. Still, as seen from the previous paragraph, this memory budget is already in the regime of diminishing returns and further memory reductions are possible for almost the same computational cost."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In this paper, we proposed a novel approach for finding optimal backpropagation strategies for recurrent neural networks for a fixed user-defined memory budget. We have demonstrated that the most general of the algorithms is at least as good as many other used common heuristics. The main advantage of our approach is the ability to tightly fit to almost any user-specified memory constraints gaining maximal computational performance."
    }, {
      "heading" : "A Pseudocode for BPTT-HSM",
      "text" : "Below is a pseudocode of an algorithm which evaluates an optimal policy for BPTT-HSM. This algorithm has a complexity of O(t2 ·m) but it is possible to optimize to to O(t ·m) by exploiting convexity in t. In any case, this is a one-off computation which does not have to be repeated while training an RNN.\nAlgorithm 1: BPTT-HSM strategy evaluation. input : tmax – maximum sequence length; mmax – maximum memory capacity\n1 EVALUATESTRATEGY(tmax,mmax) 2 Let C and D each be a 2D array of size tmax ×mmax 3 for r ∈ {1, . . . , tmax} do 4 C[t][1]← t(t+1)2 5 for m ∈ {t, . . . ,mmax} do 6 C[t][m]← 2t− 1 7 D[t][m]← 1 8 for m ∈ {2, . . . ,mmax} do 9 for t ∈ {m+ 1, . . . , tmax} do\n10 Cmin ←∞ 11 for y ∈ {1, . . . , t− 1} do 12 c← y + C[y][m] + C[t− y][m− 1] 13 if c < Cmin then 14 Cmin ← c 15 D[t][m]← y 16 C[t][m]← Cmin 17 return (C,D)\nAlgorithm 2, shown below, contains pseudocode which executes the precomputed policy.\nAlgorithm 2: BPTT-HSM strategy execution. input :D – previously evaluated policy; rnnCore – mutable RNN core network; stack – a stack\ncontaining memorized hidden states; gradHidden – a gradient with respect to the last hidden state; m – memory capacity available in the stack; t – subsequence length; s – starting subsequence index;\n1 EXECUTESTRATEGY(D, rnnCore, stack, gradHidden, m, t, s) 2 hiddenState = PEEK(stack) 3 if t = 0 then 4 return gradHidden 5 else if t = 1 then 6 output← FORWARD(rnnCore, GETINPUT(s), hiddenState) 7 gradOutput← SETOUTPUTANDGETGRADOUTPUT(s+ t, output) 8 (gradInput, gradHiddenPrevious)← BACKWARD(rnnCore, GETINPUT(s), hiddenState, 9 gradOuput, gradHidden)\n10 SETGRADINPUT(s+ t, gradInput) 11 return gradHiddenPrevious 12 else 13 y ← D[t][m] 14 for i ∈ {0, . . . , t− 1} do 15 output, hiddenState← FORWARD(rnnCore, GETINPUT(s+ i), hiddenState) 16 PUSH(stack, hiddenState) 17 gradHiddenR← EXECUTESTRATEGY(D, rnnCore, stack, gradHidden, m− 1, t− y, s+ y) 18 POP(stack) 19 gradHiddenL← EXECUTESTRATEGY(D, rnnCore, stack, gradHiddenR, m, y, s) 20 return gradHiddenL"
    }, {
      "heading" : "B Upper bound of the computational costs for BPTT-SHM",
      "text" : "B.1 General upper bound\nConsider the following dynamic program C(t,m) = min\n1≤y<t (y + C(t− y,m− 1) + C(y,m)) (11)\nwith boundary conditions: C(t, 1) = 12 t(t+ 2) and C(t,m) = 2t− 1 for all m ≥ t Proposition 1. We have C(t,m) ≤ mt1+1/m for all t,m ≥ 1.\nProof. It is straightforward to check that the bound is satisfied at the boundaries. Now let us define the boolean functions A(t,m) := {C(t,m) ≤ mt1+1/m} and A(m) := {∀t ≥ 1, C(t,m) ≤ mt1+1/m}. Let us prove by induction on m that A(m) is true. Thus assume A(m) is true and let us prove that A(m+ 1) is also true. For that, we will prove by induction on t that A(t,m+ 1) is true. Thus for any t ≥ 2, assume A(y,m+ 1) is true for all y < t and let us prove that A(t,m+ 1) is also true. We have\nC(t,m+ 1) = min 1≤y<t\n[ y + C(t− y,m) + C(y,m+ 1) ] (12)\n= min 1≤y<t\n[ y +m(t− y)1+1/m + (m+ 1)y1+1/(m+1) ] (13)\nusing our inductive assumption that A(y,m+ 1) and A(t− y,m) are true.\nFor any real number y ∈ [1, t− 1], define g(y) = y +m(t− y)1+1/m + (m+ 1)y1+1/(m+1). g is convex (as the sum of 3 convex functions) and is smooth over [1, t− 1] with\ng′(y) = 1− (m+ 1)(t− y)1/m + (m+ 2)y1/(m+1), and\ng′′(y) = m+ 1 m (t− y)1/m−1 + m+ 2 m+ 1 y1/(m+1)−1.\nNotice that g′′ is positive and convex, thus\nmax 1≤s≤t−1 |g′′(s)| = max(g′′(1), g′′(t− 1)) ≤ m+ 1 m (1 + (t− 1)1/m−1) ≤ 4. (14)\nLet y∗ the (unique) optimum of g (i.e., such that g′(y∗) = 0). Then we have C(t,m+ 1) ≤ g(by∗c)\n≤ g(y∗) + (y∗ − by∗c)g′(y∗) + 1 2 (y∗ − by∗c)2 max 1≤s≤t−1 |g′′(s)| ≤ g(y∗) + 2 ≤ g(ỹ) + 2\nwhere ỹ defined as the unique solution to\nt− y = ym/(m+1). (15)\nNotice that for any t ≥ 2, ỹ ∈ [1, t). We deduce from (13) that C(t,m+ 1) ≤ ỹ +m(t− ỹ)1+1/m + (m+ 1)ỹ1+1/(m+1) + 2\n≤ ỹ +mỹ + (m+ 1)ỹ1+1/(m+1) + 2 (16)\nNow, using the convexity of x 7→ x1+1/(m+1) and since y < t, we have\nt1+1/(m+1) ≥ ỹ1+1/(m+1) + (t− ỹ)(1 + 1 m+ 1 )ỹ1/(m+1)\n= ỹ1+1/(m+1) + ỹm/(m+1)(1 + 1\nm+ 1 )ỹ\n= ỹ1+1/(m+1) + (1 + 1\nm+ 1 )ỹ (17)\n(where the last equality derives from the definition of ỹ in (15)). Now putting (17) into (16) we deduce:\nC(t,m+ 1) ≤ ỹ +mỹ + (m+ 1) [ t1+1/(m+1) − (1 + 1 m+ 1 )ỹ ] + 2\n= (m+ 1)t1+1/(m+1) − ỹ + 2 ≤ (m+ 1)t1+1/(m+1),\nas soon as ỹ ≥ 2, which happens when t ≥ 4. Now the cases t < 4 (which actually corresponds to the 2 cases: (t = 3,m = 2) and (t = 3,m = 3)) are verified numerically.\nB.2 Upper bound for short sequences\nThe algorithm described in the previous section finds an optimal solution using dynamic programming. It is trival to show that C(t,m) is an increasing function in t and we will make use of this property. It is possible to prove a computational upper bound by finding a potentially sub-optimal policy and evaluating its cost. Alternatively, one can find a policy for a given computational cost, and then use this as an upper bound for an optimal policy.\nIt was established that when memory equals to the sequence (t = m) length then C(t,m) = 2t−1 < 2t. Define T (a,m) as the maximum sequence length t for which an average computational cost C(t,m)/t ≤ a. Hence, we can clearly see that T (2,m) ≥ m.\nProposition 2. We have T (a,m) ≥ m a−1\n(a−1)!\nProof. This is clearly satisfied for the case a = 2. Assume that proposition is true for some value a. We prove by induction that this is also satisfied for all other values of a.\nConsider a sequence of length t =\n∑m\ni=1 T (a, i). We will make the first initial pass over the sequence at the cost t and will memorize hidden states spaced at intervals T (a,m), T (a,m − 1) .. T (a, 2) (Figure 8). Once the hidden states are memorized, we can run the same backpropagation algorithm on each sub-sequence each time paying the cost of ≤ a per time-step (Proposition 2). This will make the local cost of the algorithm C(t, a+ 1) ≤ t+ ta = (a+ 1)t. As this makes the cost per time-step ≤ a, T (a+ 1,m) ≥ t = ∑m i=1 T (a, i) ≥ ∑m i=1 ia−1 (a−1)! ≥ ma a! .\nThis implies that C(t,m) ≤ (a + 1)t when t ≤ m a\na! . Please note that this is a much better result comparing to a strategy when interval is sub-divided into equal-sub-intervals several times recursively,\nas the later strategy would only give C(t,m) ≤ (a+ 1)t for t ≤ m a\naa while (a! a a) for the same\ncomputational cost. It turns out that it is non-trivial to invert this function to state computation explicitly as a function of t,m.\nB.3 Analytical upper bounds for BPTT-ISM and BPTT-MSM\nWhen we are capable of memorizing internal core states instead of hidden states, we can apply almost exactly the same calculation of the upper bound as in Section 3.5 while still being conservative. The main difference though a removal of a single forward operation per time-step. This would give us the upper bound of the computational cost as C(t,m) ≤ at for t ≤ m a\na! . The same upper bound of C(t,m) ≤ mt1+ 1m can be assumed to be true for the case when t > m a\na! , because an internal state also includes a hidden state, and the derived optimal algorithm can not do any worse for the same number of m. Please note that in this case the same number of m constitutes for a larger actual memory usage, as the units of measurement are different. T (a,m) is the maximum sequence length for which a computational cost C(T (a,m),m) ≤ at. Any upper bounds derived for the case of BPTT-HSM will also hold for the case of BPTT-MSM, because the later is generalization of the former technique, and an optimal policy found will be at least as good as."
    }, {
      "heading" : "C Generalizing to deep feed-forward networks",
      "text" : "BPTT-MSM can also be generalized to deep network architectures rather than RNNs as long as the computational graph is a linear chain. The main difference is that different layers in deep architectures are non-homogeneous (i.e., have different computational costs and memory requirements) while cores within the same RNN are homogeneous. This difference can be addressed by modifying the dynamic program formulation.\nTo start with, lets derive a strategy when only hidden states are stored. We can recall that an optimal policy of BPTT-HSM algorithm could be found by solving given dynamic programming equations.\nCost if we choose to memorize next state at position y and thereafter we follow an optimal policy:\nQ(t,m, y) = y + C(t− y,m− 1) + C(y,m) (18)\nOptimal position of the next memorization:\nD(t,m) = argmin 1≤y<t Q(t,m, y) (19)\nComputational cost under the optimal policy:\nC(t,m) = Q(t,m,D(t,m)) (20)\nAs in the case of RNNs, we choose to remember only some of the intermediate output results (hidden states) and recompute all internal states (and other hidden states) on demand while fitting within some memory allowance. As sizes of internal representations of different layers are different, it is necessary to include a size of a \"working\" network layer into our current memory allowance. In the case of RNNs this constant factor could be comfortably ignored. In addition to that, hidden states produced by different layers will also have different sizes.\nSuppose that the cost of recomputing layer y is uy while the size of a hidden state computed after step y has the size of sy . We also assume that the initial input vector is always available.\nDefine U(x, y) = ∑x+y\ni=x+1 ui as a cumulative computational cost of forward propagation when x bottom layers are cut-off and we are forward propagating over y layers . Also, define pi to be the size of an internal state of some given network layer: this defined as the minimum memory requirement to execute forward and backward operations on a given layer. Neither forward not backward operation is impossible if we have less memory left that the operation requires. Define the maximum memory usage when executing forward operation on layers from x+ 1 to y inclusive as P (x, y) = maxx<i≤y pi. For the reasons discussed previously it is convenient to set computational\ncost to infinity when we have have less than required memory available: K(x, y,m) = 0 if P (x, y) ≤ m and K(x, y,m) =∞ if P (x, y) > m. Consider a part of the neural network with x bottom layers cut-off. Define C(t,m − 1, x) as a computation cost of a combined forward and back-propagation on such network over t bottom layers.\nThe cost of a combined forward and back-propagation of the cut-off section assuming that the next memorization happens at position y is:\nQ(t,m, y, x) = U(x, y) +K(x, y,m) + C(t− y,m− sx+y, x+ y) + C(y,m, x) (21)\nK(x, y,m) prevents us from making an impossible back-propagation commitment when memory is not enough.\nIt is now trivial to define position of the next memorization as:\nD(t,m, x) = argmin 1≤y<t Q(t,m, y, x) (22)\nAnd hence we can evaluate a cost under the optimal policy:\nC(t,m, x) = Q(t,m,D(t,m, x), x) (23)\nAs previously, we have to set boundary conditions:\nWhen no extra memory left:\nC(t, 0, x) = x+t∑ i=x (t− i+ 1)ui (24)\nWhen the memory is plentiful (m >= ∑x+t\ni=x si):\nC(t,m, x) = ut + x+t−1∑ i=x 2ui (25)\nAnother boundary condition applies when the network has zero depth: C(t,m, x) = 0 when x+ t > N and N is the number of layer in the network and also C(t,m, x) = 0 when t ≤ 0. It is convenient to set C(t,m, x) =∞ for m < 0 to emphasize that memory can never become negative. We can solve the equations using dynamic programming, but unlike in the recurrent case when dynamic programming required filling a 3D rather than a 2D array. This means that evaluation of the strategy may become impractical for sequences longer than a few hundred, but a good thing is that a strategy is a one-off computational.\nThe algorithm is executed as follows: if any any point we start a recursive call of the algorithm at layer x while having memory allowance m, we evaluate y = D(t,m, x), forward-propagate states until y, memorize the next state and call the algorithm recursively both parts of the sequence.\nSimilarly equations can be generalized for BPTT-ISM and BPTT-MSM algorithms,"
    } ],
    "references" : [ {
      "title" : "Training deep nets with sublinear memory cost",
      "author" : [ "Tianqi Chen", "Bing Xu", "Zhiyuan Zhang", "Carlos Guestrin" ],
      "venue" : "arXiv preprint arXiv:1604.06174,",
      "citeRegEx" : "Chen et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2016
    }, {
      "title" : "The data-flow equations of checkpointing in reverse automatic differentiation",
      "author" : [ "Benjamin Dauvergne", "Laurent Hascoët" ],
      "venue" : "In Computational Science–ICCS",
      "citeRegEx" : "Dauvergne and Hascoët.,? \\Q2006\\E",
      "shortCiteRegEx" : "Dauvergne and Hascoët.",
      "year" : 2006
    }, {
      "title" : "A first look at music composition using LSTM recurrent neural networks",
      "author" : [ "Douglas Eck", "Juergen Schmidhuber" ],
      "venue" : "Istituto Dalle Molle Di Studi Sull Intelligenza Artificiale,",
      "citeRegEx" : "Eck and Schmidhuber.,? \\Q2002\\E",
      "shortCiteRegEx" : "Eck and Schmidhuber.",
      "year" : 2002
    }, {
      "title" : "Speech recognition with deep recurrent neural networks",
      "author" : [ "Alan Graves", "Abdel-rahman Mohamed", "Geoffrey Hinton" ],
      "venue" : "In Acoustics, Speech and Signal Processing (ICASSP),",
      "citeRegEx" : "Graves et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Graves et al\\.",
      "year" : 2013
    }, {
      "title" : "Supervised Sequence Labelling with Recurrent Neural Networks",
      "author" : [ "Alex Graves" ],
      "venue" : "Studies in Computational Intelligence. Springer,",
      "citeRegEx" : "Graves.,? \\Q2012\\E",
      "shortCiteRegEx" : "Graves.",
      "year" : 2012
    }, {
      "title" : "Neural turing machines",
      "author" : [ "Alex Graves", "Greg Wayne", "Ivo Danihelka" ],
      "venue" : "arXiv preprint arXiv:1410.5401,",
      "citeRegEx" : "Graves et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Graves et al\\.",
      "year" : 2014
    }, {
      "title" : "Learning to transduce with unbounded memory",
      "author" : [ "Edward Grefenstette", "Karl Moritz Hermann", "Mustafa Suleyman", "Phil Blunsom" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Grefenstette et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Grefenstette et al\\.",
      "year" : 2015
    }, {
      "title" : "Draw: A recurrent neural network for image generation",
      "author" : [ "Karol Gregor", "Ivo Danihelka", "Alex Graves", "Daan Wierstra" ],
      "venue" : "arXiv preprint arXiv:1502.04623,",
      "citeRegEx" : "Gregor et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Gregor et al\\.",
      "year" : 2015
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Sepp Hochreiter", "Jürgen Schmidhuber" ],
      "venue" : "Neural computation,",
      "citeRegEx" : "Hochreiter and Schmidhuber.,? \\Q1997\\E",
      "shortCiteRegEx" : "Hochreiter and Schmidhuber.",
      "year" : 1997
    }, {
      "title" : "Asynchronous methods for deep reinforcement learning",
      "author" : [ "Volodymyr Mnih", "Adria Puigdomenech Badia", "Mehdi Mirza", "Alex Graves", "Timothy P Lillicrap", "Tim Harley", "David Silver", "Koray Kavukcuoglu" ],
      "venue" : "In Proceedings of the International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Mnih et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Mnih et al\\.",
      "year" : 2016
    }, {
      "title" : "Learning internal representations by error propagation",
      "author" : [ "David E Rumelhart", "Geoffrey E Hinton", "Ronald J Williams" ],
      "venue" : "Technical report, DTIC Document,",
      "citeRegEx" : "Rumelhart et al\\.,? \\Q1985\\E",
      "shortCiteRegEx" : "Rumelhart et al\\.",
      "year" : 1985
    }, {
      "title" : "Deep attention recurrent Q-network",
      "author" : [ "Ivan Sorokin", "Alexey Seleznev", "Mikhail Pavlov", "Aleksandr Fedorov", "Anastasiia Ignateva" ],
      "venue" : "arXiv preprint arXiv:1512.01693,",
      "citeRegEx" : "Sorokin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Sorokin et al\\.",
      "year" : 2015
    }, {
      "title" : "Generating text with recurrent neural networks",
      "author" : [ "Ilya Sutskever", "James Martens", "Geoffrey E Hinton" ],
      "venue" : "In Proceedings of the 28th International Conference on Machine Learning",
      "citeRegEx" : "Sutskever et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Sutskever et al\\.",
      "year" : 2011
    }, {
      "title" : "Backpropagation through time: what it does and how to do it",
      "author" : [ "Paul J Werbos" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "Werbos.,? \\Q1990\\E",
      "shortCiteRegEx" : "Werbos.",
      "year" : 1990
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al.",
      "startOffset" : 6,
      "endOffset" : 40
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al.",
      "startOffset" : 120,
      "endOffset" : 147
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al.",
      "startOffset" : 120,
      "endOffset" : 172
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al.",
      "startOffset" : 120,
      "endOffset" : 187
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al. [2013]) and reinforcement learning (Sorokin et al.",
      "startOffset" : 120,
      "endOffset" : 230
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al. [2013]) and reinforcement learning (Sorokin et al. [2015], Mnih et al.",
      "startOffset" : 120,
      "endOffset" : 281
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al. [2013]) and reinforcement learning (Sorokin et al. [2015], Mnih et al. [2016]) settings.",
      "startOffset" : 120,
      "endOffset" : 301
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al. [2013]) and reinforcement learning (Sorokin et al. [2015], Mnih et al. [2016]) settings. Other successful RNN architectures include Neural Turing Machines (NTM) (Graves et al. [2014]), DRAW network (Gregor et al.",
      "startOffset" : 120,
      "endOffset" : 406
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al. [2013]) and reinforcement learning (Sorokin et al. [2015], Mnih et al. [2016]) settings. Other successful RNN architectures include Neural Turing Machines (NTM) (Graves et al. [2014]), DRAW network (Gregor et al. [2015]), Neural Transducers (Grefenstette et al.",
      "startOffset" : 120,
      "endOffset" : 443
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al. [2013]) and reinforcement learning (Sorokin et al. [2015], Mnih et al. [2016]) settings. Other successful RNN architectures include Neural Turing Machines (NTM) (Graves et al. [2014]), DRAW network (Gregor et al. [2015]), Neural Transducers (Grefenstette et al. [2015]).",
      "startOffset" : 120,
      "endOffset" : 492
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al. [2013]) and reinforcement learning (Sorokin et al. [2015], Mnih et al. [2016]) settings. Other successful RNN architectures include Neural Turing Machines (NTM) (Graves et al. [2014]), DRAW network (Gregor et al. [2015]), Neural Transducers (Grefenstette et al. [2015]). Backpropagation Through Time algorithm (BPTT) (Rumelhart et al. [1985], Werbos [1990]) is typically used to obtain gradients during training.",
      "startOffset" : 120,
      "endOffset" : 565
    }, {
      "referenceID" : 2,
      "context" : "LSTM (Hochreiter and Schmidhuber [1997]) in particular is an RNN architecture that has excelled in sequence generation (Eck and Schmidhuber [2002], Sutskever et al. [2011], Graves [2012]), speech recognition (Graves et al. [2013]) and reinforcement learning (Sorokin et al. [2015], Mnih et al. [2016]) settings. Other successful RNN architectures include Neural Turing Machines (NTM) (Graves et al. [2014]), DRAW network (Gregor et al. [2015]), Neural Transducers (Grefenstette et al. [2015]). Backpropagation Through Time algorithm (BPTT) (Rumelhart et al. [1985], Werbos [1990]) is typically used to obtain gradients during training.",
      "startOffset" : 120,
      "endOffset" : 580
    }, {
      "referenceID" : 10,
      "context" : "Backpropagation through Time (BPTT) (Rumelhart et al. [1985], Werbos [1990]) is one of the commonly used techniques to train recurrent networks.",
      "startOffset" : 37,
      "endOffset" : 61
    }, {
      "referenceID" : 10,
      "context" : "Backpropagation through Time (BPTT) (Rumelhart et al. [1985], Werbos [1990]) is one of the commonly used techniques to train recurrent networks.",
      "startOffset" : 37,
      "endOffset" : 76
    }, {
      "referenceID" : 0,
      "context" : "The general idea of trading computation time and memory consumption in general computation graphs has been investigated in the automatic differentiation community (Dauvergne and Hascoët [2006]).",
      "startOffset" : 164,
      "endOffset" : 193
    }, {
      "referenceID" : 0,
      "context" : "proposed subdividing the sequence of size t into √ t equal parts and memorizing only hidden states between the subsequences and all internal states within each segment (Chen et al. [2016]).",
      "startOffset" : 169,
      "endOffset" : 188
    }, {
      "referenceID" : 0,
      "context" : "As both strategies proposed by Chen et al. [2016] are consistent with all the assumptions that we have made in section 3.",
      "startOffset" : 31,
      "endOffset" : 50
    }, {
      "referenceID" : 0,
      "context" : "As both strategies proposed by Chen et al. [2016] are consistent with all the assumptions that we have made in section 3.4 when applied to RNNs, BPTT-MSM is guaranteed to perform at least as well under any memory budget and any sequence length. This is because strategies proposed by Chen et al. [2016] can be expressed by providing a (potentially suboptimal) policy Di(t,m), H(t,m) subject to the same equations for Qi(t,m).",
      "startOffset" : 31,
      "endOffset" : 303
    } ],
    "year" : 2016,
    "abstractText" : "We propose a novel approach to reduce memory consumption of the backpropagation through time (BPTT) algorithm when training recurrent neural networks (RNNs). Our approach uses dynamic programming to balance a trade-off between caching of intermediate results and recomputation. The algorithm is capable of tightly fitting within almost any user-set memory budget while finding an optimal execution policy minimizing the computational cost. Computational devices have limited memory capacity and maximizing a computational performance given a fixed memory budget is a practical use-case. We provide asymptotic computational upper bounds for various regimes. The algorithm is particularly effective for long sequences. For sequences of length 1000, our algorithm saves 95% of memory usage while using only one third more time per iteration than the standard BPTT.",
    "creator" : "LaTeX with hyperref package"
  }
}