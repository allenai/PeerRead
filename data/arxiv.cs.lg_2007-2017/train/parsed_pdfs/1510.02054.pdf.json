{
  "name" : "1510.02054.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Stochastic Optimization for Deep CCA via Nonlinear Orthogonal Iterations",
    "authors" : [ "Weiran Wang" ],
    "emails" : [ "weiranwang@ttic.edu,", "klivescu@ttic.edu,", "nati@ttic.edu,", "arora@cs.jhu.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n51 0.\n02 05\n4v 1\n[ cs\n.L G\n] 7\nO ct\n2 01\nI. INTRODUCTION\nStochastic gradient descent (SGD) is a fundamental and popular optimization method for machine learning problems [1], [2], [3], [4], [5]. SGD is particularly well-suited for large-scale machine learning problems because it is extremely simple and easy to implement, it often achieves better generalization (test) performance (which is the focus of machine learning research) than sophisticated batch algorithms, and it usually achieves large error reduction very quickly in a small number of passes over the training set [6]. One intuitive explanation for the empirical success of stochastic gradient descent for large data is that it makes better use of data redundancy, with an extreme example given by [2]: If the training set consists of 10 copies of the same set of examples, then computing an estimate of the gradient over one single copy is 10 times more efficient than computing the full gradient over the entire training set, while achieving the same optimization progress in the following gradient descent step.\nAt the same time, “multi-view” data are becoming increasingly available, and methods based on canonical correlation analysis (CCA) [7] that use such data to learn representations (features) form an active research area. The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such\nThis research was supported by the NSF grants IIS-1546482 and IIS1321015. The opinions expressed in this work are those of the authors and do not necessarily reflect the views of the funding agency.\nas words + context [19] or document text + text of inbound hyperlinks [20]. The presence of multiple information sources presents an opportunity to learn better representations (features) by analyzing multiple views simultaneously. Among various multi-view learning approaches, the recently proposed deep canonical correlation analysis [21], which extends traditional CCA with deep neural networks (DNNs), has been shown to be advantageous over previous methods in several domains [22], [23], [24], and scales to large data better than its nonparametric counterpart kernel CCA [25], [26], [11].\nIn contrast with most DNN-based methods, the objective of deep CCA couples together all of the training examples due to its whitening constraint, making stochastic optimization challenging. Previous optimizers for this model are batch-based, e.g., limited-memory BFGS (L-BFGS) [27] as in [21], or stochastic optimization with large minibatches [22], because it is difficult to obtain an accurate estimate of the gradient with a small subset of the training examples (again due to the whitening constraint). As a result, these approaches have high memory complexity and may not be practical for large DNN models with hundreds of millions of weight parameters (common with web-scale data [28]), or if one would like to run the training procedure on GPUs which are equipped with faster but smaller (more expensive) memory than CPUs. In such cases there is not enough memory to save all intermediate hidden activations of the batch/large minibatch used in error backpropagation.\nIn this paper, we tackle this problem with two key ideas. First, we reformulate the CCA solution with orthogonal iterations, and embed the DNN parameter training in the orthogonal iterations with a nonlinear least squares regression objective, which naturally decouples over training examples. Second, we use adaptive estimates of the covariances used by the CCA whitening constraints and carry out whitening only for the minibatch used at each step to obtain training signals for the DNNs. This results in a stochastic optimization algorithm that can operate on small minibatches and thus consume little memory. Empirically, the new stochastic optimization algorithm performs as well as previous optimizers in terms of convergence speed, even when using small minibatches with which the previous stochastic approach makes no training progress.\nIn the following sections, we briefly introduce deep CCA\nand discuss the difficulties in training it (Section II); motivate and propose our new algorithm (Section III); describe related work (Section IV); and present experimental results comparing different optimizers (Section V)."
    }, {
      "heading" : "II. DEEP CCA",
      "text" : "Notation In the multi-view feature learning setting, we have access to paired observations from two views, denoted (x1,y1), . . . , (xN ,yN ), where N is the training set size, xi ∈ R\nDx and yi ∈ RDy for i = 1, . . . , N . We also denote the data matrices for View 1 and View 2 X = [x1, . . . ,xN ] and Y = [y1, . . . ,yN ], respectively. We use bold-face letters, e.g. f , to denote mappings implemented by DNNs, with a corresponding set of learnable parameters, denoted, e.g., Wf . The dimensionality of the learned features is denoted L.\nDeep CCA (DCCA) [21] extends (linear) CCA [7] by extracting dx- and dy-dimensional nonlinear features with two DNNs f and g for views 1 and 2 respectively, such that the canonical correlation (measured by CCA) between the DNN outputs is maximized, as illustrated in Fig. 1. The goal of the final CCA is to find L ≤ min(dx, dy) pairs of linear projection vectors U ∈ Rdx×L and V ∈ Rdy×L such that the projections of each view (a.k.a. canonical variables, [7]) are maximally correlated with their counterparts in the other view, constrained such that the dimensions in the representation are uncorrelated with each other. Formally, the DCCA objective can be written as1\nmax Wf ,Wg,U,V\ntr ( U⊤FG⊤V )\n(1)\ns.t. U⊤FF⊤U = V⊤GG⊤V = I,\nwhere F = f(X) = [f(x1), . . . , f(xN )] ∈ Rdx×N and G = g(Y) = [g(y1), . . . ,g(yN )] ∈ R\ndy×N . We assume that F and G are centered at the origin for notational simplicity; if they are not, we can center them as a preprocessing operation. Notice that if we use the original input data without further feature extraction, i.e. F = X and G = Y, then we recover the CCA objective. In DCCA, the final features (projections) are\nf̃(x) = U⊤f(x) and g̃(y) = V⊤g(y). (2)\n1In this paper, we use the scaled covariance matrices (scaled by N ) so that the dimensions of the projection are orthonormal and comply with the custom of orthogonal iterations.\nWe observe that the last CCA step with linear projection mappings U and V can be considered as adding a linear layer on top of the feature extraction networks f and g respectively. In the following, we sometimes refer to the concatenated networks f̃ and g̃ as defined in (2), with Wf̃ = {Wf ,U} and Wg̃ = {Wg,V}. 2\nLet Σfg = FG⊤, Σff = FF⊤ and Σgg = GG⊤ be the (scaled) cross- and auto-covariance matrices of the featuremapped data in the two views. It is well-known that, when f and g are fixed, the last CCA step in (1) has a closed form solution as follows. Define Σ̃fg = Σ − 1 2 ff ΣfgΣ − 1 2\ngg , and let Σ̃fg = ŨΛṼ\n⊤ be its rank-L singular value decomposition (SVD), where Λ contains the singular values σ1 ≥ · · · ≥ σL ≥ 0 on its diagonal. Then the optimum of (1) is achieved by (U,V) = (Σ − 1 2\nff Ũ,Σ − 1 2 gg Ṽ), and the optimal\nobjective value (the total canonical correlation) is ∑L\nj=1 σj . By switching max(·) with −min−(·), and adding 1/2 times the constraints, it is straightforward to show that (1) is equivalent to the following:\nmin Wf ,Wg,U,V\n1\n2\n∥ ∥U⊤F−V⊤G ∥ ∥ 2\nF (3)\ns.t. (U⊤F)(U⊤F)⊤ = (V⊤G)(V⊤G)⊤ = I.\nIn other words, CCA minimizes the squared difference between the projections of the two views, subject to the whitening constraints. This alternative formulation of CCA will also shed light on our proposed algorithm for DCCA.\nThe DCCA objective (1) differs from typical DNN regression or classification training objectives. Typically, the objectives are unconstrained and can be written as the expectation (or sum) of error functions (e.g., squared loss or cross entropy) incurred at each training example. This property naturally suggests stochastic gradient descent (SGD) for optimization, where one iteratively generates random unbiased estimates of the gradient based on one or a few training examples (a minibatch) and takes a small step in the opposite direction. However, the objective in (1) can not be written as an unconstrained sum of errors. The difficulty lies in the fact that the training examples are coupled through the auto-covariance matrices (in the constraints), which can not be reliably estimated with only a small amount of data.\nWhen introducing deep CCA, [21] used the L-BFGS algorithm for optimization. To compute the gradients of the objective with respect to (Wf ,Wg), one first computes the gradients3 with respect to (F,G) as\n∂ ∑L\nj=1 σj\n∂F = 2∆ffF+∆fgG, (4)\nwith ∆ff = − 1\n2 Σ\n−1/2 ff ŨΛŨ ⊤Σ−1/2ff\n∆fg = Σ −1/2 ff ŨṼ ⊤Σ−1/2gg\n2In principle there is no need for the final linear layer; we could define DCCA such that the correlation objective and constraints are imposed on the final nonlinear layer. However, the linearity of the final layer is crucial for algorithmic implementations such as ours.\n3Technically we are computing subgradients as the “sum of singular values” (trace norm) is not a differentiable function of the matrix.\nAlgorithm 1 CCA projections via alternating least squares. Input: Data matrices F ∈ Rdx×N , G ∈ Rdy×N . Initialization Ũ0 ∈ Rdx×L s.t. Ũ⊤0 Ũ0 = I.\nA0 ← Ũ ⊤ 0 Σ\n− 1 2 ff F\nfor t = 1, 2, . . . , T do Bt ← At−1G⊤ ( GG⊤ )−1 G\nBt ← ( BtB ⊤ t )− 1 2 Bt At ← BtF ⊤ (FF⊤ )−1 F At ← ( AtA ⊤ t )− 1 2 At\nend for Output: AT /BT are the CCA projections of view 1/2.\nwhere Σ̃fg = ŨΛṼ⊤ is the SVD of Σ̃fg as in the closedform solution to CCA, and ∂\n∑L j=1 σj/∂G has an analogous\nexpression. One can then compute the gradients with respect to Wf and Wg via the standard backpropagation procedure [29]. From the gradient formulas, it is clear that the key to optimizing DCCA is the SVD of Σ̃fg; various nonlinear optimization techniques can be used here once the gradient is computed. In practice, however, batch optimization is undesirable for applications with large training sets or large DNN architectures, as each gradient step computed on the entire training set can be expensive in both memory and time.\nLater, it was observed by [22] that stochastic optimization still works well even for the DCCA objective, as long as larger minibatches are used to estimate the covariances and Σ̃fg when computing the gradient with (4). More precisely, the authors find that learning plateaus at a poor objective value if the minibatch is too small, but fast convergence and better generalization than batch algorithms can be obtained once the minibatch size is larger than some threshold, presumably because a large minibatch contains enough information to estimate the covariances and therefore the gradient accurately enough (the threshold of minibatch size varies for different datasets because they have different levels of data redundancy). Theoretically, the necessity of using large minibatches in this approach can also be established. Let the empirical estimate of Σ̃fg using a minibatch of n samples be Σ̂ (n) fg . It can be shown that the expectation of Σ̂ (n)\nfg does not equal the true Σ̃fg computed using the entire dataset, mainly due to the nonlinearities in the matrix inversion and multiplication operations in computing Σ̃fg, and the nonlinearity in the “sum of singular values” (trace norm) of Σ̃fg; moreover, the spectral norm of the error ∥ ∥ ∥ Σ̂ (n) fg − Σ̃fg ∥ ∥ ∥ decays slowly as 1√ n\n. Consequently, the gradient estimated on a minibatch using (4) does not equal the true gradient of the objective in expectation, indicating that the stochastic approach of [22] does not qualify as a stochastic gradient descent method for the DCCA objective."
    }, {
      "heading" : "III. OUR ALGORITHM",
      "text" : ""
    }, {
      "heading" : "A. An iterative solution to linear CCA",
      "text" : "Our solution to (1) is inspired by the iterative solution for finding the linear CCA projections (U⊤F,V⊤G) for inputs\n(F,G), as shown in Algorithm 1. This algorithm computes the top-L singular vectors (Ũ, Ṽ) of Σ̃fg via orthogonal iterations [30]. An essentially identical algorithm (named alternating least squares for reasons that will soon become evident) appears in [31, Algorithm 5.2] and according to the authors the idea goes back to J. Von Neumann. A similar algorithm is also recently used by [32, Algorithm 1] for large scale linear CCA with high-dimensional sparse inputs, although their algorithm does not implement the whitening operations At ← ( AtA ⊤ t )− 1 2 At and Bt ← ( BtB ⊤ t )− 1 2 Bt or they use the QR decomposition instead. The convergence of Algorithm 1 is characterized by the following theorem, which parallels [32, Theorem 1].\nTheorem 1: Let the singular values of Σ̃fg be\nσ1 ≥ · · · ≥ σL > σL+1 ≥ · · · ≥ σmin(dx,dy)\nand suppose Ũ⊤0 Ũ is nonsingular. Then the output (AT ,BT ) of Algorithm 1 converges to the CCA projections as T → ∞.\nProof: We focus on showing that AT converges to the view 1 projection; the proof for BT is similar.\nFirst recall that Σ̃fg = ŨΛṼ⊤ is the rank-L SVD of\nΣ − 1 2 ff ΣfgΣ − 1 2 gg , and thus Ũ contains the top-L eigenvectors of Σ̃fgΣ̃ ⊤ fg = ŨΛ 2Ũ⊤.\nSince the operation ( AA⊤ )− 1\n2 A extracts an orthonormal basis of the row space of A, at iteration t we can write\nAt−1G ⊤ (GG⊤ )−1 G = PtBt\nBtF ⊤ (FF⊤ )−1 F = QtAt\nwhere Pt ∈ RL×L and Qt ∈ RL×L are nonsingular coefficient matrices (as the initialization Ũ0 is nonsingular) for representing the left-hand side matrices in their row space basis. Combining the above two equations gives the following recursion at iteration t:\nAt−1G ⊤ (GG⊤ )−1 GF⊤ ( FF⊤ )−1 F = PtQtAt.\nBy induction, it can be shown that by the end of iteration t we have\nA0\n(\nG⊤ ( GG⊤ )−1 GF⊤ ( FF⊤ )−1 F )t\n= OtAt.\nwhere Ot = P1Q1 . . .PtQt ∈ RL×L is nonsingular. Plugging in the definition of A0, this equation reduces to\nŨ⊤0\n( Σ̃fgΣ̃ ⊤ fg )t Σ − 1 2 ff F = OtAt. (5)\nIt is then clear that At can be written as\nAt = Ũ ⊤ t Σ\n− 1 2 ff F\nwith\nŨt = ( Σ̃fgΣ̃ ⊤ fg )t Ũ0O −1 t ∈ R dx×L.\nAnd since At has orthonormal rows, we have\nI = AtA ⊤ t = Ũ ⊤ t Σ\n− 1 2\nff (FF ⊤)Σ\n− 1 2\nff Ũt = Ũ ⊤ t Ũt,\nindicating that Ũt has orthonormal columns.\nAs a result, we consider the algorithm as working implicitly in the space of {Ũt ∈ Rdx×L, t = 0, . . . , T }, and have\n(Σ̃fgΣ̃ ⊤ fg) T Ũ0 = OT ŨT . (6)\nFollowing the argument of [30, Theorem 8.2.2]) for orthogonal iterations, under the assumptions of our theorem, the column space of ŨT converges to that of Ũ, the topL eigenvectors of Σ̃fgΣ̃ ⊤ fg, with a linear convergence rate depending on the ratio σL+1/σL. In view of the relationship between ŨT and At, we conclude that AT converges to the view 1 CCA projection as T → ∞.\nIt is interesting to note that, besides the whitening op-\nerations ( AtA ⊤ t )− 1 2 At, the other basic operations in each iteration of Algorithm 1 are of the form\nAt ← BtF ⊤ (FF⊤ )−1 F (7)\nwhich is solving a linear least squares (regression) problem with input F and target output Bt satisfying BtB⊤t = I, i.e.,\nmin Ut\n∥ ∥U⊤t F−Bt ∥ ∥ 2 F .\nBy setting the gradient of this unconstrained objective to zero, we obtain Ut = (FF⊤)−1FB⊤t and so the optimal projection U⊤t F coincides with the update (7).\nFor [32], the advantage of the alternating least squares formulation over the exact solution to CCA is that it does not need to form the high-dimensional (nonsparse) matrix Σ̃fg; instead it directly operates on the projections, which are much smaller in size, and one can solve the least squares problems using iterative algorithms that require only sparse matrix-vector multiplications."
    }, {
      "heading" : "B. Extension to DCCA",
      "text" : "Our intuition for adapting Algorithm 1 to DCCA is as follows. During DCCA optimization, the DNN weights (Wf ,Wg) are updated frequently and thus the outputs (f(X),g(Y)), which are also the inputs to the last CCA step, also change upon each weight update. Therefore, the last CCA step needs to adapt to the fast evolving input data distribution. On the other hand, if we are updating the CCA weights (U,V) based on a small minibatch of data (as happens in stochastic optimization), it is intuitively wasteful to solve (U,V) to optimality rather than to make a simple update based on the minibatch. Moreover, the objective of this “simple update” can be used to derive a gradient estimate for (Wf ,Wg).\nIn view of Algorithm 1, it is a natural choice to embed the optimization of (f ,g) into the iterative solution to linear CCA. Instead of solving the regression problem F → Bt exactly with At ← BtF⊤ ( FF⊤ )−1\nF, we try to solve the problem X → Bt on a minibatch with a gradient descent step on (Wf ,U) jointly (recall F = f(X) is a function of Wf ). Notice that this regression objective is unconstrained and decouples over training samples, so an unbiased gradient estimate for this problem can be easily derived through standard backpropagation using minibatches (however, this\ngradient estimate may not be unbiased for the original DCCA objective; see discussion in Section IV).\nThe less trivial part of Algorithm 1 to implement in\nDCCA is the whitening operation ( AtA ⊤ t )− 1 2 At, which needs At ∈ RL×N , the projections of all training samples. We would like to avoid the exact computation of At as it requires feeding forward the entire training set X with the updated Wf̃ , and the computational cost of this operation is as high as (half of) the cost of evaluating the batch gradient (the latter requires both the forward and backward passes). We bypass this difficulty by noting that the only portion of At needed is the updated projection of the minibatch used in the subsequent view 2 regression problem X → At (corresponding to the step Bt+1 ← AtG⊤ ( GG⊤ )−1 G in Algorithm 1). Therefore, if we have an estimate of the covariance Σt\nf̃ f̃ := AtA ⊤ t without feeding forward the entire\ntraining set, we can estimate the updated projection for this minibatch only. Specifically, we estimate this quantity by4\nΣt f̃ f̃ ← ρΣt−1 f̃ f̃ + (1− ρ) N |b| f̃ (Xb)f̃ (Xb) ⊤, (8)\nwhere ρ ∈ [0, 1], Xb denotes a minibatch of data with index set b, and |b| denotes the size (number of samples) of this minibatch. The time constant ρ controls how much the previous covariance estimate is kept in the update; a larger ρ indicates forgetting the “memory” more slowly. Assuming that the parameters do not change much from time t− 1 to t, then Σt−1\nf̃ f̃ will be close to Σt f̃ f̃ , and incorporating it helps\nto reduce the variance from the term f̃(Xb)f̃ (Xb)⊤ when |b| ≪ N . The update in (8) has a form similar to that of the widely used momentum technique in the optimization [33] and neural network literature [34], [35], and is also used by [36], [37], [38] for online subspace tracking and anomaly detection. We note that the memory cost of Σt\nf̃ f̃ ∈ RL×L\nis small as we look for low-dimensional projections (small L) in practice. These advantages validate our choice of whitening operations over the more commonly used QR decomposition used by [32].\nWe give the resulting nonlinear orthogonal iterations procedure (NOI) for DCCA in Algorithm 2. Now adaptive whitening is used to obtain suitable target outputs of the regression problems for computing derivatives (∂Wf̃ , ∂Wg̃), and we no longer maintain the whitened projections of the entire training set at each iteration. Therefore, by the end of the algorithm, (f̃ (X), g̃(Y)) may not satisfy the whitening constraints of (1). One may use an additional CCA step on (f̃ (X), g̃(Y)) to obtain a feasible solution of the original problem if desired, and this amounts to linear transforms in R\nL which do not change the canonical correlations between the projections for both the training and test sets. In practice, we adaptively estimate the mean of f̃(X) and g̃(Y) with an update formula similar to that of (8) and center the samples accordingly before estimating the covariances and computing the target outputs. We also use momentum in\n4We add a small value ǫ > 0 to the diagonal of the covariance estimates in our implementation for numerical stability.\nAlgorithm 2 Nonlinear orthogonal iterations (NOI) for DCCA. Input: Data matrix X ∈ RDx×N , Y ∈ RDy×N . Initializa-\ntion (Wf̃ ,Wg̃), time constant ρ, learning rate η. Randomly choose a minibatch (Xb0 ,Yb0) Σf̃ f̃ ← N b0 ∑ i∈b0 f̃ (xi)f̃ (xi) ⊤, Σg̃g̃ ← N b0 ∑ i∈b0 g̃(yi)g̃(yi) ⊤ for t = 1, 2, . . . , T do Randomly choose a minibatch (Xbt ,Ybt) Σf̃ f̃ ← ρΣf̃ f̃ + (1− ρ) N |bt| ∑ i∈bt f̃(xi)f̃ (xi) ⊤\nΣg̃g̃ ← ρΣg̃g̃ + (1 − ρ) N |bt|\n∑ i∈bt g̃(yi)g̃(yi) ⊤\nCompute the gradient ∂Wf̃ of the objective\nmin W\nf̃\n1\n|bt|\n∑\ni∈bt\n∥ ∥ ∥ f̃(xi)−Σ − 1 2 g̃g̃ g̃(yi) ∥ ∥ ∥\n2\nCompute the gradient ∂Wg̃ of the objective\nmin Wg̃\n1\n|bt|\n∑\ni∈bt\n∥ ∥ ∥ g̃(yi)−Σ − 1 2\nf̃ f̃ f̃(xi)\n∥ ∥ ∥\n2\nWf̃ ← Wf̃ − η∂Wf̃ , Wg̃ ← Wg̃ − η∂Wg̃. end for\nOutput: The updated (Wf̃ ,Wg̃).\nthe stochastic gradient steps for the nonlinear least squares problems as is commonly used in the deep learning community [34]. Overall, Algorithm 2 is intuitively quite simple: It alternates between adaptive covariance estimation/whitening and stochastic gradient steps over (a stochastic version of) the least squares objectives, without any involved gradient computation."
    }, {
      "heading" : "IV. RELATED WORK",
      "text" : "Stochastic (and online) optimization techniques for fundamental problems, such as principal component analysis and partial least squares, are of continuous research interest [39], [40], [41], [42], [43], [44], [45], [46]. However, as pointed out by [42], the CCA objective is more challenging due to the whitening constraints.\nRecently, [38] proposed an adaptive CCA algorithm with efficient online updates based on matrix manifolds defined by the whitening constraints. However, the goal of their algorithm is anomaly detection rather than optimizing the canonical correlation objective for a given dataset. Based on the alternating least squares formulation of CCA (Algorithm 1), [32] propose an iterative solution of CCA for very high-dimensional and sparse input features, and the key idea is to solve the high dimensional least squares problems with randomized PCA and (batch) gradient descent.\nUpon the submission of this paper, we have become aware of the very recent publication of [47], which extends [32] by solving the linear least squares problems with (stochastic) gradient descent. We notice that a specical case of our algorithm (ρ = 0) is equivalent to theirs for linear CCA. To see this, we give the linear CCA version of our algorithm\nAlgorithm 3 CCA via gradient descent over least squares. Input: Data matrix F ∈ Rdx×N , G ∈ Rdy×N . Initialization u0 ∈ R\ndx , v0 ∈ Rdy . Learning rate η. for t = 1, 2, . . . , T do ut ← ut−1 − ηF(F⊤ut−1 − 1\n‖v⊤t−1G‖ G⊤vt−1)\nvt ← vt−1 − ηG(G⊤vt−1 − 1 ‖u⊤t−1F‖ F⊤ut−1)\nend for u ← uT\n‖u⊤T F‖ , v ← vT\n‖v⊤T G‖ Output: u/v are the CCA directions of view 1/2.\n(for a one-dimensional projection, to be consistent with the notation of [47]) in Algorithm 3, where we take a batch gradient descent step over the least squares objectives in each iteration. This algorithm is equivalent to Algorithm 3 of [47].5 Though intuitively very simple, the analysis of this algorithm is challenging. In [47] it is shown that the solution to the CCA objective is a fixed point of this algorithm, but no global convergence property is given. We also notice that the gradients used in this algorithm are derived from the alternating least squares problems\nmin u\n∥ ∥ ∥ ∥ u⊤F− v⊤G\n‖v⊤G‖\n∥ ∥ ∥ ∥\n2\nF\nand min v\n∥ ∥ ∥ ∥ v⊤G− u⊤F\n‖u⊤F‖\n∥ ∥ ∥ ∥\n2\nF\n,\nwhile the true CCA objective can be written as\nmin u,v\n∥ ∥ ∥ ∥ u⊤F\n‖u⊤F‖ −\nv⊤G\n‖v⊤G‖\n∥ ∥ ∥ ∥\n2\nF\n.\nThis shows that Algorithm 3 is not implementing gradient descent over the CCA objective.\nWhen extending Algorithm 3 to stochastic optimization, we observe the key differences between their algorithm and ours as follows. Due to the evolving (Wf ,Wg), the last CCA step in the DCCA model is dealing with different (f(X),g(Y)) and covariance structures in different iterates, even though the original inputs (X,Y) are the same; this motivates the adaptive estimate of covariances in (8). In the whitening steps of [47], however, the covariances are estimated using only the current minibatch at each iterate, without consideration of the remaining training samples or previous estimates, which corresponds to ρ → 0 in our estimate. [47] also suggests using a minibatch size of the order O(L), the dimensionality of the covariance matrices to be estimated, in order to obtain a high-accuracy estimate for whitening. As we will show in the experiments, in both CCA and DCCA, it is important to incorporate the previous covariance estimates (ρ → 1) at each step to reduce the variance, especially when small minibatches are used. Based on the above analysis for batch gradient descent, solving the least squares problem with stochastic gradient descent is\n5Although Algorithm 3 of [47] maintains two copies—the normalized and the unnormalized versions—of the weight parameters, we observe that the sole purpose of the normalized version in the intermediate iterations is to provide whitened target output for the least squares problems; our version of the algorithm eliminates this copy and the normalized version can be retrieved by a whitening step at the end.\nnot implementing stochastic gradient descent over the CCA objective. Nonetheless, as shown in the experiments, this stochastic approach works remarkably well and can match the performance of batch optimization, for both linear and nonlinear CCA, and is thus worth careful analysis.\nFinally, we remark that other possible approaches for solving (1) exist. Since the difficulty lies in the whitening constraints, one can relax the constraints and solve the Lagrangian formulation repeatedly with updated Lagrangian multipliers, as done by [25]; or one can introduce auxiliary variables and apply the quadratic penalty method [48], as done by [49]. The advantage of such approaches is that there exists no coupling of all training samples when optimizing the primal variables (the DNN weight parameters) and thus one can easily apply SGD there, but one also needs to deal with the Lagrange multipliers or to set a schedule for the quadratic penalty parameter (which is non-trivial) and alternately optimize over two sets of variables repeatedly in order to obtain a solution of the original constrained problem."
    }, {
      "heading" : "V. EXPERIMENTS",
      "text" : ""
    }, {
      "heading" : "A. Experimental setup",
      "text" : "We now demonstrate the NOI algorithm on the two realworld datasets used by [21] when introducing DCCA. The first dataset is a subset of the University of Wisconsin XRay Microbeam corpus [50], which consists of simultaneously recorded acoustic and articulatory measurements during speech. Following [21], [22], the acoustic view inputs are 39D Mel-frequency cepstral coefficients and the articulatory view inputs are horizontal/vertical displacement of 8 pellets attached to different parts of the vocal tract, each then concatenated over a 7-frame context window, for speaker ‘JW11’. The second dataset consists of left/right halves of the images in the MNIST dataset [51], and so the input of each view consists of 28 × 14 grayscale images. We do not tune neural network architectures as it is out of the scope of this paper. Instead, we use DNN architectures similar to those used by [21] with ReLU activations [52], and we achieve better generalization performance with these architectures mainly due to better optimization. The statistics of each dataset and the chosen DNN architectures (widths of input layer-hidden layers-output layer) are given in Table I. The projection dimensionality L is set to 112/50 for JW11/MNIST respectively as in [21]; these are also the maximum possible total canonical correlations for the two datasets.\nWe compare three optimization approaches: full batch optimization by L-BFGS [21], using the implementation of [53] which includes a good line-search procedure; stochastic\noptimization with large minibatches [22], denoted STOL; and our algorithm, denoted NOI. We create training/tuning/test splits for each dataset and measure the total canonical correlations on the test sets (measured by linear CCA on the projections) for different optimization methods. Hyperparameters of each algorithm, including ρ for NOI, minibatch size n = |b1| = |b2| , . . . , learning rate η and momentum µ for both STOL and NOI, are chosen by grid search on the tuning set. All methods use the same random initialization for DNN weight parameters. We set the maximum number of iterations to 300 for L-BFGS and number of epochs (one pass over the training set) to 50 for STOL and NOI."
    }, {
      "heading" : "B. Effect of minibatch size n",
      "text" : "In the first set of experiments, we vary the minibatch size n of NOI over {10, 20, 50, 100}, while tuning ρ, η and µ. Learning curves (objective value vs. number of epochs) on the tuning set for each n with the corresponding optimal hyperparameters are shown in Fig. 2. For comparison, we also show the learning curves of STOL with n = 100 and n = 500, while η and µ are also tuned by grid search. We observe that STOL performs very well at n = 500 (with the performance on MNIST being somewhat better due to higher data redundancy), but it can not achieve much progress in the objective over the random initialization with n = 100, for the reasons described earlier. In contrast, NOI achieves very competitive performance with various small minibatch sizes, with fast improvement in objective during the first few iterations, although larger n tends to achieve slightly higher correlation on tuning/test sets eventually. Total canonical correlations on the test sets are given in Table II, showing that we achieve better results than [21] with similar DNN architectures."
    }, {
      "heading" : "C. Effect of time constant ρ",
      "text" : "In the second set of experiments, we demonstrate the importance of ρ in NOI for different minibatch sizes. The total canonical correlations achieved by NOI on the tuning set for ρ = {0, 0.2, 0.4, 0.6, 0.8, 0.9, 0.99, 0.999, 0.9999} are shown in Fig. 3, while other hyper-parameters are set to their optimal values. We confirm that for relatively large n, NOI works reasonably well with ρ = 0 (so we are using the same covariance estimate/whitening as [47]). But also as expected, when n is small, it is beneficial to incorporate the\nTABLE II TOTAL TEST SET CANONICAL CORRELATION OBTAINED BY DIFFERENT ALGORITHMS.\ndataset L-BFGS STOL NOI\nn = 100 n = 500 n = 10 n = 20 n = 50 n = 100\nJW11 78.7 33.0 86.7 83.6 86.9 87.9 89.1 MNIST 47.0 26.1 47.0 45.9 46.4 46.4 46.4\nprevious estimate of the covariance because the covariance information contained in each small minibatch is noisy. Also, as ρ becomes too close to 1, the covariance estimates are not adapted to the DNN outputs and the performance of NOI degrades. Moreover, we observe that the optimal ρ value seems different for each n."
    }, {
      "heading" : "D. Pure stochastic optimization for CCA",
      "text" : "Finally, we carry out pure stochastic optimization (n = 1) for linear CCA on the MNIST dataset. Notice that linear CCA is a special case of DCCA with (f̃ , g̃) both being single-layer linear networks (although we have used small weight-decay terms for the weights, leading to a slightly different objective than that of CCA). Total canonical correlations achieved by STOL with n = 500 and by NOI (50 training epochs) on the training set with different ρ values are shown in Fig. 4. The objective of the random initialization and the closed-form solution (by SVD) are also shown for comparison. NOI could not improve over the random initialization without memory (ρ = 0, corresponding to the\nalgorithm of [47]), but gets very close to the optimal solution and matches the objective obtained by the previous large minibatch approach when ρ → 1. This result demonstrates the importance of our adaptive estimate (8) also for CCA."
    }, {
      "heading" : "VI. CONCLUSIONS",
      "text" : "In this paper, we have proposed a stochastic optimization algorithm NOI for training DCCA which updates the DNN weights based on small minibatches and performs competitively to previous optimizers.\nOne direction for future work is to better understand the convergence properties of NOI, which presents several difficulties. First, we note that convergence of the alternating least squares formulation of CCA (Algorithm 1, or rather orthogonal iterations) is usually stated as the angle between the estimated subspace and the ground-truth subspace converging to zero. In the stochastic optimization setting, we need to relate this measure of progress (or some other measure) to the nonlinear least squares problems we are trying to solve in the NOI iterations. As discussed in Section IV, even the convergence of the linear CCA version of NOI with batch gradient descent is not well understood [47]. Second, the use of memory in estimating covariances (8) complicates the analysis and ideally we would like to come up with ways of determining the time constant ρ.\nWe have also tried using the same form of adaptive covariance estimates in both views for the STOL approach for computing the gradients (4), but its performance with small minibatches is much worse than that of NOI. Presumably this is because the gradient computation of STOL suffers from noise in both views which are further combined through various nonlinear operations, whereas the noise in the gradient computation of NOI only comes from the output target (due to inexact whitening), and as a result NOI is more tolerant to the noise resulting from using small minibatches. This deserves further analysis as well."
    } ],
    "references" : [ {
      "title" : "Stochastic gradient learning in neural networks",
      "author" : [ "L. Bottou" ],
      "venue" : "Proc. Neuronı̂mes, 1991.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Efficient backprop",
      "author" : [ "Y. LeCun", "L. Bottou", "G.B. Orr", "K.-R. Müller" ],
      "venue" : "Neural Networks: Tricks of the Trade, ser. Lecture Notes in Computer Science, vol. 1524, 1998, pp. 9–50.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Stochastic learning",
      "author" : [ "L. Bottou" ],
      "venue" : "Advanced Lectures on Machine Learning, ser. Lecture Notes in Artificial Intelligence 3176, 2004, pp. 146–168.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Solving large scale linear prediction problems using stochastic gradient descent algorithms",
      "author" : [ "T. Zhang" ],
      "venue" : "Proc. of the 21st Int. Conf. Machine Learning (ICML’04), 2004, pp. 919–926.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Incremental gradient, subgradient, and proximal methods for convex optimization: A survey",
      "author" : [ "D.P. Bertsekas" ],
      "venue" : "Optimization for Machine Learning, S. Sra, S. Nowozin, and S. J. Wright, Eds. MIT Press, 2011.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "The tradeoffs of large scale learning",
      "author" : [ "L. Bottou", "O. Bousquet" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS), vol. 20, 2008, pp. 161–168.",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Relations between two sets of variates",
      "author" : [ "H. Hotelling" ],
      "venue" : "Biometrika, vol. 28, no. 3/4, pp. 321–377, 1936.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1936
    }, {
      "title" : "Pixels that sound",
      "author" : [ "E. Kidron", "Y.Y. Schechner", "M. Elad" ],
      "venue" : "Proc. of the 2005 IEEE Computer Society Conf. Computer Vision and Pattern Recognition (CVPR’05), 2005, pp. 88–95.",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Multiview clustering via canonical correlation analysis",
      "author" : [ "K. Chaudhuri", "S.M. Kakade", "K. Livescu", "K. Sridharan" ],
      "venue" : "Proc. of the 26th Int. Conf. Machine Learning (ICML’09), 2009, pp. 129–136.",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Multi-view CCA-based acoustic features for phonetic recognition across speakers and domains",
      "author" : [ "R. Arora", "K. Livescu" ],
      "venue" : "Proc. of the IEEE Int. Conf. Acoustics, Speech and Sig. Proc. (ICASSP’13), 2013.",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Canonical correlation analysis: An overview with application to learning methods",
      "author" : [ "D.R. Hardoon", "S. Szedmak", "J. Shawe-Taylor" ],
      "venue" : "Neural Computation, vol. 16, no. 12, pp. 2639–2664, 2004.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Connecting modalities: Semi-supervised segmentation and annotation of images using unaligned text corpora",
      "author" : [ "R. Socher", "F.-F. Li" ],
      "venue" : "Proc. of the 2010 IEEE Computer Society Conf. Computer Vision and Pattern Recognition (CVPR’10), 2010, pp. 966–973.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Framing image description as a ranking task: Data, models and evaluation metrics",
      "author" : [ "M. Hodosh", "P. Young", "J. Hockenmaier" ],
      "venue" : "Journal of Artificial Intelligence Research, vol. 47, pp. 853–899, 2013.",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Inferring a semantic representation of text via cross-language correlation analysis",
      "author" : [ "A. Vinokourov", "N. Cristianini", "J. Shawe-Taylor" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS), vol. 15, 2003, pp. 1497–1504.",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Learning bilingual lexicons from monolingual corpora",
      "author" : [ "A. Haghighi", "P. Liang", "T. Berg-Kirkpatrick", "D. Klein" ],
      "venue" : "Proceedings of the Annual Meeting of the Association for Computational Linguistics (ACL 2008), 2008, pp. 771–779.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "An autoencoder approach to learning bilingual word representations",
      "author" : [ "S. Chandar", "S. Lauly", "H. Larochelle", "M.M. Khapra", "B. Ravindran", "V. Raykar", "A. Saha" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS), vol. 27, 2014, pp. 1853–1861.",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Improving vector space word representations using multilingual correlation",
      "author" : [ "M. Faruqui", "C. Dyer" ],
      "venue" : "Proceedings of EACL, 2014.",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Deep multilingual correlation for improved word embeddings",
      "author" : [ "A. Lu", "W. Wang", "M. Bansal", "K. Gimpel", "K. Livescu" ],
      "venue" : "The 2015 Conference of the North American Chapter of the Association for Computational Linguistics - Human Language Technologies (NAACL HLT 2015), 2015.",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "GloVe: Global vectors for word representation",
      "author" : [ "J. Pennington", "R. Socher", "C.D. Manning" ],
      "venue" : "Proc. 2014 Conference on Empirical Methods in Natural Language Processing, 2014.",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Multi-view clustering",
      "author" : [ "S. Bickel", "T. Scheffer" ],
      "venue" : "Proc. of the 4th IEEE Int. Conf. Data Mining (ICDM’04), 2004, pp. 19–26.",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Deep canonical correlation analysis",
      "author" : [ "G. Andrew", "R. Arora", "J. Bilmes", "K. Livescu" ],
      "venue" : "Proc. of the 30th Int. Conf. Machine Learning (ICML 2013), 2013, pp. 1247–1255.",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Unsupervised learning of acoustic features via deep canonical correlation analysis",
      "author" : [ "W. Wang", "R. Arora", "K. Livescu", "J. Bilmes" ],
      "venue" : "Proc. of the IEEE Int. Conf. Acoustics, Speech and Sig. Proc. (ICASSP’15), 2015.",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "On deep multi-view representation learning",
      "author" : [ "——" ],
      "venue" : "Proc. of the 32st Int. Conf. Machine Learning (ICML 2015), 2015, pp. 1083–1092.",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Deep correlation for matching images and text",
      "author" : [ "F. Yan", "K. Mikolajczyk" ],
      "venue" : "Proc. of the 2015 IEEE Computer Society Conf. Computer Vision and Pattern Recognition (CVPR’15), 2015, pp. 3441–3450.",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Kernel and nonlinear canonical correlation analysis",
      "author" : [ "P.L. Lai", "C. Fyfe" ],
      "venue" : "Int. J. Neural Syst., vol. 10, no. 5, pp. 365–377, 2000.",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Kernel independent component analysis",
      "author" : [ "F.R. Bach", "M.I. Jordan" ],
      "venue" : "Journal of Machine Learning Research, vol. 3, pp. 1–48, 2002.",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Updating quasi-Newton matrices with limited storage",
      "author" : [ "J. Nocedal" ],
      "venue" : "Math. Comp., vol. 35, no. 151, pp. 773–782, 1980.",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 1980
    }, {
      "title" : "Large scale distributed deep networks",
      "author" : [ "J. Dean", "G. Corrado", "R. Monga", "K. Chen", "M. Devin", "Q. Le", "M. Mao", "M. Ranzato", "A. Senior", "P. Tucker", "K. Yang", "A. Ng" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS), vol. 25, 2012, pp. 1232–1240.",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Learning representations by back-propagating errors",
      "author" : [ "D.E. Rumelhart", "G.E. Hinton", "R.J. Williams" ],
      "venue" : "Nature, vol. 323, pp. 533– 536, 1986.",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "Matrix Computations, 3rd ed",
      "author" : [ "G.H. Golub", "C.F. van Loan" ],
      "venue" : null,
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 1996
    }, {
      "title" : "Linear Algebra for Signal Processing, ser. The IMA Volumes in Mathematics and its Applications",
      "author" : [ "G.H. Golub", "H. Zha" ],
      "venue" : "ch. The Canonical Correlations of Matrix Pairs and their Numerical Computation,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 1995
    }, {
      "title" : "Large scale canonical correlation analysis with iterative least squares",
      "author" : [ "Y. Lu", "D.P. Foster" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS), vol. 27, 2014, pp. 91–99.",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Some methods of speeding up the convergence of iteration methods",
      "author" : [ "B.T. Polyak" ],
      "venue" : "USSR Computational Mathematics and Mathematical Physics, vol. 4, no. 5, pp. 1–17, 1964.",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 1964
    }, {
      "title" : "On the importance of initialization and momentum in deep learning",
      "author" : [ "I. Sutskever", "J. Martens", "G. Dahl", "G. Hinton" ],
      "venue" : "Proc. of the 30th Int. Conf. Machine Learning (ICML 2013), 2013, pp. 1139–1147.",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "No more pesky learning rate",
      "author" : [ "T. Schaul", "S. Zhang", "Y. LeCun" ],
      "venue" : "Proc. of the 30th Int. Conf. Machine Learning (ICML 2013), 2013, pp. 343–351.",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Fast low-rank modifications of the thin singular value decomposition",
      "author" : [ "M. Brand" ],
      "venue" : "Linear Algebra Appl., vol. 415, no. 1, pp. 20–30, 2006.",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Data stream anomaly detection through principal subspace tracking",
      "author" : [ "P.H. dos Santos Teixeira", "R.L. Milidiú" ],
      "venue" : "Proceedings of the 2010 ACM Symposium on Applied Computing (SAC’10), 2010, pp. 1609–1616.",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Adaptive canonical correlation analysis based on matrix manifolds",
      "author" : [ "F. Yger", "M. Berar", "G. Gasso", "A. Rakotomamonjy" ],
      "venue" : "Proc. of the 29th Int. Conf. Machine Learning (ICML 2012), 2012, pp. 1071– 1078.",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A method of stochastic approximation for the determination of the least eigenvalue of a symmetric matrix",
      "author" : [ "T.P. Krasulina" ],
      "venue" : "USSR Computational Mathematics and Mathematical Physics, vol. 9, no. 6, pp. 189–195, 1969.",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 1969
    }, {
      "title" : "On stochastic approximation of the eigenvectors and eigenvalues of the expectation of a random matrix",
      "author" : [ "E. Oja", "J. Karhunen" ],
      "venue" : "J. Math. Anal. Appl., vol. 106, no. 1, pp. 69–84, 1985.",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "Randomized online PCA algorithms with regret bounds that are logarithmic in the dimension",
      "author" : [ "M.K. Warmuth", "D. Kuzmin" ],
      "venue" : "Journal of Machine Learning Research, vol. 9, pp. 2287–2320, 2008.",
      "citeRegEx" : "41",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Stochastic optimization for PCA and PLS",
      "author" : [ "R. Arora", "A. Cotter", "K. Livescu", "N. Srebro" ],
      "venue" : "50th Annual Allerton Conference on Communication, Control, and Computing, Montcello, IL, Oct. 1–5 2012, pp. 861–868.",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Stochastic optimization of PCA with capped MSG",
      "author" : [ "R. Arora", "A. Cotter", "N. Srebro" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS), vol. 26, 2013, pp. 1815–1823.",
      "citeRegEx" : "43",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Memory limited, streaming PCA",
      "author" : [ "I. Mitliagkas", "C. Caramanis", "P. Jain" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS), vol. 26, 2013, pp. 2886–2894.",
      "citeRegEx" : "44",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "The fast convergence of incremental PCA",
      "author" : [ "A. Balsubramani", "S. Dasgupta", "Y. Freund" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS), vol. 26, 2013, pp. 3174–3182.",
      "citeRegEx" : "45",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "A stochastic PCA and SVD algorithm with an exponential convergence rate",
      "author" : [ "O. Shamir" ],
      "venue" : "Proc. of the 32st Int. Conf. Machine Learning (ICML 2015), 2015, pp. 144–152.",
      "citeRegEx" : "46",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Finding linear structure in large datasets with scalable canonical correlation analysis",
      "author" : [ "Z. Ma", "Y. Lu", "D. Foster" ],
      "venue" : "Proc. of the 32st Int. Conf. Machine Learning (ICML 2015), 2015, pp. 169–178.",
      "citeRegEx" : "47",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Distributed optimization of deeply nested systems",
      "author" : [ "M.Á. Carreira-Perpiñán", "W. Wang" ],
      "venue" : "Proc. of the 17th Int. Workshop on Artificial Intelligence and Statistics (AISTATS 2014), Reykjavik, Iceland, Apr. 22 – Apr. 25 2014, pp. 10–19.",
      "citeRegEx" : "49",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "X-Ray Microbeam Speech Production",
      "author" : [ "J.R. Westbury" ],
      "venue" : "Database User’s Handbook Version",
      "citeRegEx" : "50",
      "shortCiteRegEx" : "50",
      "year" : 1994
    }, {
      "title" : "Gradient-based learning applied to document recognition",
      "author" : [ "Y. LeCun", "L. Bottou", "Y. Bengio", "P. Haffner" ],
      "venue" : "Proc. IEEE, vol. 86, no. 11, pp. 2278–2324, 1998.",
      "citeRegEx" : "51",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Rectified linear units improve restricted Boltzmann machines",
      "author" : [ "V. Nair", "G.E. Hinton" ],
      "venue" : "Proc. of the 27th Int. Conf. Machine Learning (ICML 2010), 2010, pp. 807–814.",
      "citeRegEx" : "52",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "minFunc",
      "author" : [ "M. Schmidt" ],
      "venue" : "2012, code available at http://www.cs.ubc.ca/ ̃schmidtm/Software/minFunc.html.",
      "citeRegEx" : "53",
      "shortCiteRegEx" : null,
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Stochastic gradient descent (SGD) is a fundamental and popular optimization method for machine learning problems [1], [2], [3], [4], [5].",
      "startOffset" : 113,
      "endOffset" : 116
    }, {
      "referenceID" : 1,
      "context" : "Stochastic gradient descent (SGD) is a fundamental and popular optimization method for machine learning problems [1], [2], [3], [4], [5].",
      "startOffset" : 118,
      "endOffset" : 121
    }, {
      "referenceID" : 2,
      "context" : "Stochastic gradient descent (SGD) is a fundamental and popular optimization method for machine learning problems [1], [2], [3], [4], [5].",
      "startOffset" : 123,
      "endOffset" : 126
    }, {
      "referenceID" : 3,
      "context" : "Stochastic gradient descent (SGD) is a fundamental and popular optimization method for machine learning problems [1], [2], [3], [4], [5].",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 4,
      "context" : "Stochastic gradient descent (SGD) is a fundamental and popular optimization method for machine learning problems [1], [2], [3], [4], [5].",
      "startOffset" : 133,
      "endOffset" : 136
    }, {
      "referenceID" : 5,
      "context" : "SGD is particularly well-suited for large-scale machine learning problems because it is extremely simple and easy to implement, it often achieves better generalization (test) performance (which is the focus of machine learning research) than sophisticated batch algorithms, and it usually achieves large error reduction very quickly in a small number of passes over the training set [6].",
      "startOffset" : 383,
      "endOffset" : 386
    }, {
      "referenceID" : 1,
      "context" : "One intuitive explanation for the empirical success of stochastic gradient descent for large data is that it makes better use of data redundancy, with an extreme example given by [2]: If the training set consists of 10 copies of the same set of examples, then computing an estimate of the gradient over one single copy is 10 times more efficient than computing the full gradient over the entire training set, while achieving the same optimization progress in the following gradient descent step.",
      "startOffset" : 179,
      "endOffset" : 182
    }, {
      "referenceID" : 6,
      "context" : "At the same time, “multi-view” data are becoming increasingly available, and methods based on canonical correlation analysis (CCA) [7] that use such data to learn representations (features) form an active research area.",
      "startOffset" : 131,
      "endOffset" : 134
    }, {
      "referenceID" : 7,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 96,
      "endOffset" : 99
    }, {
      "referenceID" : 8,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 9,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 10,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 11,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 153,
      "endOffset" : 157
    }, {
      "referenceID" : 12,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 159,
      "endOffset" : 163
    }, {
      "referenceID" : 13,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 199,
      "endOffset" : 203
    }, {
      "referenceID" : 14,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 205,
      "endOffset" : 209
    }, {
      "referenceID" : 15,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 211,
      "endOffset" : 215
    }, {
      "referenceID" : 16,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 217,
      "endOffset" : 221
    }, {
      "referenceID" : 17,
      "context" : "The views can be multiple measurement modalities, such as simultaneously recorded audio + video [8], [9], audio + articulation [10], images + text [11], [12], [13], or parallel text in two languages [14], [15], [16], [17], [18], but may also be different information extracted from the same source, such",
      "startOffset" : 223,
      "endOffset" : 227
    }, {
      "referenceID" : 18,
      "context" : "as words + context [19] or document text + text of inbound hyperlinks [20].",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 19,
      "context" : "as words + context [19] or document text + text of inbound hyperlinks [20].",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 20,
      "context" : "Among various multi-view learning approaches, the recently proposed deep canonical correlation analysis [21], which extends traditional CCA with deep neural networks (DNNs), has been shown to be advantageous over previous methods in several domains [22], [23], [24], and scales to large data better than its nonparametric counterpart kernel CCA [25], [26], [11].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 21,
      "context" : "Among various multi-view learning approaches, the recently proposed deep canonical correlation analysis [21], which extends traditional CCA with deep neural networks (DNNs), has been shown to be advantageous over previous methods in several domains [22], [23], [24], and scales to large data better than its nonparametric counterpart kernel CCA [25], [26], [11].",
      "startOffset" : 249,
      "endOffset" : 253
    }, {
      "referenceID" : 22,
      "context" : "Among various multi-view learning approaches, the recently proposed deep canonical correlation analysis [21], which extends traditional CCA with deep neural networks (DNNs), has been shown to be advantageous over previous methods in several domains [22], [23], [24], and scales to large data better than its nonparametric counterpart kernel CCA [25], [26], [11].",
      "startOffset" : 255,
      "endOffset" : 259
    }, {
      "referenceID" : 23,
      "context" : "Among various multi-view learning approaches, the recently proposed deep canonical correlation analysis [21], which extends traditional CCA with deep neural networks (DNNs), has been shown to be advantageous over previous methods in several domains [22], [23], [24], and scales to large data better than its nonparametric counterpart kernel CCA [25], [26], [11].",
      "startOffset" : 261,
      "endOffset" : 265
    }, {
      "referenceID" : 24,
      "context" : "Among various multi-view learning approaches, the recently proposed deep canonical correlation analysis [21], which extends traditional CCA with deep neural networks (DNNs), has been shown to be advantageous over previous methods in several domains [22], [23], [24], and scales to large data better than its nonparametric counterpart kernel CCA [25], [26], [11].",
      "startOffset" : 345,
      "endOffset" : 349
    }, {
      "referenceID" : 25,
      "context" : "Among various multi-view learning approaches, the recently proposed deep canonical correlation analysis [21], which extends traditional CCA with deep neural networks (DNNs), has been shown to be advantageous over previous methods in several domains [22], [23], [24], and scales to large data better than its nonparametric counterpart kernel CCA [25], [26], [11].",
      "startOffset" : 351,
      "endOffset" : 355
    }, {
      "referenceID" : 10,
      "context" : "Among various multi-view learning approaches, the recently proposed deep canonical correlation analysis [21], which extends traditional CCA with deep neural networks (DNNs), has been shown to be advantageous over previous methods in several domains [22], [23], [24], and scales to large data better than its nonparametric counterpart kernel CCA [25], [26], [11].",
      "startOffset" : 357,
      "endOffset" : 361
    }, {
      "referenceID" : 26,
      "context" : ", limited-memory BFGS (L-BFGS) [27] as in [21], or stochastic optimization with large minibatches [22], because it is difficult to obtain an accurate estimate of the gradient with a small subset of the training examples (again due to the whitening constraint).",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 20,
      "context" : ", limited-memory BFGS (L-BFGS) [27] as in [21], or stochastic optimization with large minibatches [22], because it is difficult to obtain an accurate estimate of the gradient with a small subset of the training examples (again due to the whitening constraint).",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 21,
      "context" : ", limited-memory BFGS (L-BFGS) [27] as in [21], or stochastic optimization with large minibatches [22], because it is difficult to obtain an accurate estimate of the gradient with a small subset of the training examples (again due to the whitening constraint).",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 27,
      "context" : "As a result, these approaches have high memory complexity and may not be practical for large DNN models with hundreds of millions of weight parameters (common with web-scale data [28]), or if one would like to run the training procedure on GPUs which are equipped with faster but smaller (more expensive) memory than CPUs.",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 20,
      "context" : "Deep CCA (DCCA) [21] extends (linear) CCA [7] by extracting dx- and dy-dimensional nonlinear features with two DNNs f and g for views 1 and 2 respectively, such that the canonical correlation (measured by CCA) between the DNN outputs is maximized, as illustrated in Fig.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 6,
      "context" : "Deep CCA (DCCA) [21] extends (linear) CCA [7] by extracting dx- and dy-dimensional nonlinear features with two DNNs f and g for views 1 and 2 respectively, such that the canonical correlation (measured by CCA) between the DNN outputs is maximized, as illustrated in Fig.",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 6,
      "context" : "canonical variables, [7]) are maximally correlated with their counterparts in the other view, constrained such that the dimensions in the representation are uncorrelated with each other.",
      "startOffset" : 21,
      "endOffset" : 24
    }, {
      "referenceID" : 20,
      "context" : "When introducing deep CCA, [21] used the L-BFGS algorithm for optimization.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 28,
      "context" : "One can then compute the gradients with respect to Wf and Wg via the standard backpropagation procedure [29].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 21,
      "context" : "Later, it was observed by [22] that stochastic optimization still works well even for the DCCA objective, as long as larger minibatches are used to estimate the covariances and Σ̃fg when computing the gradient with (4).",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 21,
      "context" : "on a minibatch using (4) does not equal the true gradient of the objective in expectation, indicating that the stochastic approach of [22] does not qualify as a stochastic gradient descent method for the DCCA objective.",
      "startOffset" : 134,
      "endOffset" : 138
    }, {
      "referenceID" : 29,
      "context" : "This algorithm computes the top-L singular vectors (Ũ, Ṽ) of Σ̃fg via orthogonal iterations [30].",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 31,
      "context" : "For [32], the advantage of the alternating least squares formulation over the exact solution to CCA is that it does not need to form the high-dimensional (nonsparse) matrix Σ̃fg; instead it directly operates on the projections, which are much smaller in size, and one can solve the least squares problems using iterative algorithms that require only sparse matrix-vector multiplications.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 0,
      "context" : "where ρ ∈ [0, 1], Xb denotes a minibatch of data with index set b, and |b| denotes the size (number of samples) of this minibatch.",
      "startOffset" : 10,
      "endOffset" : 16
    }, {
      "referenceID" : 32,
      "context" : "The update in (8) has a form similar to that of the widely used momentum technique in the optimization [33] and neural network literature [34], [35], and is also used by [36], [37], [38] for online subspace tracking and anomaly detection.",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 33,
      "context" : "The update in (8) has a form similar to that of the widely used momentum technique in the optimization [33] and neural network literature [34], [35], and is also used by [36], [37], [38] for online subspace tracking and anomaly detection.",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 34,
      "context" : "The update in (8) has a form similar to that of the widely used momentum technique in the optimization [33] and neural network literature [34], [35], and is also used by [36], [37], [38] for online subspace tracking and anomaly detection.",
      "startOffset" : 144,
      "endOffset" : 148
    }, {
      "referenceID" : 35,
      "context" : "The update in (8) has a form similar to that of the widely used momentum technique in the optimization [33] and neural network literature [34], [35], and is also used by [36], [37], [38] for online subspace tracking and anomaly detection.",
      "startOffset" : 170,
      "endOffset" : 174
    }, {
      "referenceID" : 36,
      "context" : "The update in (8) has a form similar to that of the widely used momentum technique in the optimization [33] and neural network literature [34], [35], and is also used by [36], [37], [38] for online subspace tracking and anomaly detection.",
      "startOffset" : 176,
      "endOffset" : 180
    }, {
      "referenceID" : 37,
      "context" : "The update in (8) has a form similar to that of the widely used momentum technique in the optimization [33] and neural network literature [34], [35], and is also used by [36], [37], [38] for online subspace tracking and anomaly detection.",
      "startOffset" : 182,
      "endOffset" : 186
    }, {
      "referenceID" : 31,
      "context" : "These advantages validate our choice of whitening operations over the more commonly used QR decomposition used by [32].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 33,
      "context" : "the stochastic gradient steps for the nonlinear least squares problems as is commonly used in the deep learning community [34].",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 38,
      "context" : "Stochastic (and online) optimization techniques for fundamental problems, such as principal component analysis and partial least squares, are of continuous research interest [39], [40], [41], [42], [43], [44], [45], [46].",
      "startOffset" : 174,
      "endOffset" : 178
    }, {
      "referenceID" : 39,
      "context" : "Stochastic (and online) optimization techniques for fundamental problems, such as principal component analysis and partial least squares, are of continuous research interest [39], [40], [41], [42], [43], [44], [45], [46].",
      "startOffset" : 180,
      "endOffset" : 184
    }, {
      "referenceID" : 40,
      "context" : "Stochastic (and online) optimization techniques for fundamental problems, such as principal component analysis and partial least squares, are of continuous research interest [39], [40], [41], [42], [43], [44], [45], [46].",
      "startOffset" : 186,
      "endOffset" : 190
    }, {
      "referenceID" : 41,
      "context" : "Stochastic (and online) optimization techniques for fundamental problems, such as principal component analysis and partial least squares, are of continuous research interest [39], [40], [41], [42], [43], [44], [45], [46].",
      "startOffset" : 192,
      "endOffset" : 196
    }, {
      "referenceID" : 42,
      "context" : "Stochastic (and online) optimization techniques for fundamental problems, such as principal component analysis and partial least squares, are of continuous research interest [39], [40], [41], [42], [43], [44], [45], [46].",
      "startOffset" : 198,
      "endOffset" : 202
    }, {
      "referenceID" : 43,
      "context" : "Stochastic (and online) optimization techniques for fundamental problems, such as principal component analysis and partial least squares, are of continuous research interest [39], [40], [41], [42], [43], [44], [45], [46].",
      "startOffset" : 204,
      "endOffset" : 208
    }, {
      "referenceID" : 44,
      "context" : "Stochastic (and online) optimization techniques for fundamental problems, such as principal component analysis and partial least squares, are of continuous research interest [39], [40], [41], [42], [43], [44], [45], [46].",
      "startOffset" : 210,
      "endOffset" : 214
    }, {
      "referenceID" : 45,
      "context" : "Stochastic (and online) optimization techniques for fundamental problems, such as principal component analysis and partial least squares, are of continuous research interest [39], [40], [41], [42], [43], [44], [45], [46].",
      "startOffset" : 216,
      "endOffset" : 220
    }, {
      "referenceID" : 41,
      "context" : "However, as pointed out by [42], the CCA objective is more challenging due to the whitening constraints.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 37,
      "context" : "Recently, [38] proposed an adaptive CCA algorithm with efficient online updates based on matrix manifolds defined by the whitening constraints.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 31,
      "context" : "Based on the alternating least squares formulation of CCA (Algorithm 1), [32] propose an iterative solution of CCA for very high-dimensional and sparse input features, and the key idea is to solve the high dimensional least squares problems with randomized PCA and (batch) gradient descent.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 46,
      "context" : "Upon the submission of this paper, we have become aware of the very recent publication of [47], which extends [32] by solving the linear least squares problems with (stochastic) gradient descent.",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 31,
      "context" : "Upon the submission of this paper, we have become aware of the very recent publication of [47], which extends [32] by solving the linear least squares problems with (stochastic) gradient descent.",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 46,
      "context" : "(for a one-dimensional projection, to be consistent with the notation of [47]) in Algorithm 3, where we take a batch gradient descent step over the least squares objectives in each iteration.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 46,
      "context" : "This algorithm is equivalent to Algorithm 3 of [47].",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 46,
      "context" : "In [47] it is shown that the solution to the CCA objective is a fixed point of this algorithm, but no global convergence property is given.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 46,
      "context" : "In the whitening steps of [47], however, the covariances are estimated using only the current minibatch at each iterate, without consideration of the remaining training samples or previous estimates, which corresponds to ρ → 0 in our estimate.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 46,
      "context" : "[47] also suggests using a minibatch size of the order O(L), the dimensionality of the covariance matrices to be estimated, in order to obtain a high-accuracy estimate for whitening.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 46,
      "context" : "5Although Algorithm 3 of [47] maintains two copies—the normalized and the unnormalized versions—of the weight parameters, we observe that the sole purpose of the normalized version in the intermediate iterations is to provide whitened target output for the least squares problems; our version of the algorithm eliminates this copy and the normalized version can be retrieved by a whitening step at the end.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 24,
      "context" : "Since the difficulty lies in the whitening constraints, one can relax the constraints and solve the Lagrangian formulation repeatedly with updated Lagrangian multipliers, as done by [25]; or one can introduce auxiliary variables and apply the quadratic penalty method [48], as done by [49].",
      "startOffset" : 182,
      "endOffset" : 186
    }, {
      "referenceID" : 47,
      "context" : "Since the difficulty lies in the whitening constraints, one can relax the constraints and solve the Lagrangian formulation repeatedly with updated Lagrangian multipliers, as done by [25]; or one can introduce auxiliary variables and apply the quadratic penalty method [48], as done by [49].",
      "startOffset" : 285,
      "endOffset" : 289
    }, {
      "referenceID" : 20,
      "context" : "We now demonstrate the NOI algorithm on the two realworld datasets used by [21] when introducing DCCA.",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 48,
      "context" : "The first dataset is a subset of the University of Wisconsin XRay Microbeam corpus [50], which consists of simultaneously recorded acoustic and articulatory measurements during speech.",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 20,
      "context" : "Following [21], [22], the acoustic view inputs are 39D Mel-frequency cepstral coefficients and the articulatory view inputs are horizontal/vertical displacement of 8 pellets attached to different parts of the vocal tract, each then concatenated over a 7-frame context window, for speaker ‘JW11’.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 21,
      "context" : "Following [21], [22], the acoustic view inputs are 39D Mel-frequency cepstral coefficients and the articulatory view inputs are horizontal/vertical displacement of 8 pellets attached to different parts of the vocal tract, each then concatenated over a 7-frame context window, for speaker ‘JW11’.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 49,
      "context" : "The second dataset consists of left/right halves of the images in the MNIST dataset [51], and so the input of each view consists of 28 × 14 grayscale images.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 20,
      "context" : "Instead, we use DNN architectures similar to those used by [21] with ReLU activations [52], and we achieve better generalization performance with these architectures mainly due to better optimization.",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 50,
      "context" : "Instead, we use DNN architectures similar to those used by [21] with ReLU activations [52], and we achieve better generalization performance with these architectures mainly due to better optimization.",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 20,
      "context" : "The projection dimensionality L is set to 112/50 for JW11/MNIST respectively as in [21]; these are also the maximum possible total canonical correlations for the two datasets.",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 20,
      "context" : "We compare three optimization approaches: full batch optimization by L-BFGS [21], using the implementation of [53] which includes a good line-search procedure; stochastic JW11 MNIST",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 51,
      "context" : "We compare three optimization approaches: full batch optimization by L-BFGS [21], using the implementation of [53] which includes a good line-search procedure; stochastic JW11 MNIST",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 21,
      "context" : "optimization with large minibatches [22], denoted STOL; and our algorithm, denoted NOI.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 20,
      "context" : "Total canonical correlations on the test sets are given in Table II, showing that we achieve better results than [21] with similar DNN architectures.",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 46,
      "context" : "We confirm that for relatively large n, NOI works reasonably well with ρ = 0 (so we are using the same covariance estimate/whitening as [47]).",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 46,
      "context" : "NOI could not improve over the random initialization without memory (ρ = 0, corresponding to the algorithm of [47]), but gets very close to the optimal solution and matches the objective obtained by the previous large minibatch approach when ρ → 1.",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 46,
      "context" : "As discussed in Section IV, even the convergence of the linear CCA version of NOI with batch gradient descent is not well understood [47].",
      "startOffset" : 133,
      "endOffset" : 137
    } ],
    "year" : 2015,
    "abstractText" : "Deep CCA is a recently proposed deep neural network extension to the traditional canonical correlation analysis (CCA), and has been successful for multi-view representation learning in several domains. However, stochastic optimization of the deep CCA objective is not straightforward, because it does not decouple over training examples. Previous optimizers for deep CCA are either batch-based algorithms or stochastic optimization using large minibatches, which can have high memory consumption. In this paper, we tackle the problem of stochastic optimization for deep CCA with small minibatches, based on an iterative solution to the CCA objective, and show that we can achieve as good performance as previous optimizers and thus alleviate the memory requirement.",
    "creator" : "LaTeX with hyperref package"
  }
}