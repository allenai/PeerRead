{
  "name" : "1608.08262.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Vicious Circle Principle and Formation of Sets in ASP Based Languages",
    "authors" : [ "Michael Gelfond", "Yuanlin Zhang" ],
    "emails" : [ "y.zhang}@ttu.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 8.\n08 26\n2v 1\n[ cs\n.A I]\n2 9\nA ug"
    }, {
      "heading" : "1 Introduction",
      "text" : "This paper is the continuation of work started in [15] with introduction of Alog – a version of Answer Set Prolog (ASP) with aggregates. The semantics of Alog combines the Rationality Principle of ASP [12] with the adaptation of the Vicious Circle Principle (VCP) introduced by Poincare and Russel [29,31] in their attempt to resolve paradoxes of set theory. In Alog, the latter is used to deal with formation of sets and their legitimate use in program rules. To understand the difficulty addressed by Alog consider the following programs:\nExample 1. P0 consisting of a rule:\np(1) :- card{X: p(X)} != 1.\nP1 consisting of rules:\np(1) :- p(0). p(0) :- p(1). p(1) :- card{X: p(X)} != 1.\nP2 consisting of rules:\np(1) :- card{X: p(X)} >= 0.\nEven for these seemingly simple programs, there are different opinions about their meaning. To the best of our knowledge all ASP based semantics, including that of [6,34,15]) view P0 as a bad specification. It is inconsistent, i.e., has no answer sets. Opinions differ, however, about the meaning of the other two programs. [6] views P1 as a reasonable specification having one answer set – {p(0), p(1)}. According to [34,15] P1 is inconsistent. According to most semantics P2 has one answer set, {p(1)}. Alog, however, views it as inconsistent.\nAs in the naive set theory, the difficulty in interpretations seems to be caused by self-reference. In both P1 and P2, the definition of p(1) references the set described in terms of p. It is, of course, not entirely clear how this type of differences can be resolved. Sometimes, further analysis can find convincing arguments in favor of one of the proposals. Sometimes, the analysis discovers that different approaches really model different language or world phenomena and are, hence, all useful in different contexts. We believe that the difficulty can be greatly alleviated if the designers of the language provide its users with as clear intuitive meaning of the new constructs as possible. Accordingly, the set name construct {X : p(X)} of Alog denotes the set of all objects believed by the rational agent associated with the program to satisfy property p. (This reading is in line with the epistemic view of ASP connectives shared by the authors.) The difficulties with self-reference in Alog are resolved by putting the following intuitive restriction on the formation of sets1:\nAn expression {X : p(X)} denotes a set S only if for every t rational belief in p(t) can be established without a reference to S , or equivalently, the reasoner’s belief in p(t) can not depend on existence of a set denoted by {X : p(X)}.\nWe view this restriction as a possible interpretation of VCP and refer to it as Strong VCP. Let us illustrate the intuition behind Alog set constructs.\nExample 2. Let us consider programs from Example 1. P0 clearly has no answer set since ∅ does not satisfy its rule and there is no justification for believing in p(1). P1 is also inconsistent. To see that notice that the first two rules of the program limit our possibilities to A1 = ∅ and A2 = {p(0), p(1)}. In the first case {X : p(X)} denotes ∅. But this contradicts the last rule of the program. A1 cannot be an answer set of P1. In A2, {X : p(X)} denotes S = {0, 1}. But this violates our form of VCP since the reasoner’s beliefs in both, p(0) and p(1), cannot be established without reference to S. A2 is not an answer set either. Now consider program P2. There are two candidate answer sets 2: A1 = ∅ and\n1 It is again similar to set theory where the difficulty is normally avoided by restricting comprehension axioms guaranteeing existence of sets denoted by expressions of the form {X : p(X)}. In ASP such restrictions are encoded in the definition of answer sets. 2 By a candidate answer set we mean a consistent set of ground regular literals satisfying the rules of the program.\nA2 = {p(1)}. In A1, S = ∅ which contradicts the rule. In A2, S = {1} but this would contradict the Alog’s VCP. The program is inconsistent3.\nWe hope that the examples are sufficient to show how the informal semantics of Alog can give a programmer some guidelines in avoiding formation of sets problematic from the standpoint of VCP. In what follows we\n– Expand Alog by allowing infinite sets and several additional set related constructs useful for knowledge representation and teaching. – Propose an alternative formalization of the original VCP and incorporate it into the semantics of new language, Slog+, which allows more liberal construction of sets and their use in programming rules. (The name of the new language is explained by its close relationship with language Slog [34] – see Theorem 2). – Show that, for programs without disjunction and infinite sets, the formal semantics of aggregates in Slog+ coincides with that of several other known languages. Their intuitive and formal semantics, however, are based on quite different ideas and seem to be more involved than that of Slog+. – Prove some basic properties of programs in (extended) Alog and Slog+.\n2 Syntax and Semantics of Alog\nIn what follows we retain the name Alog for the new language and refer to the earlier version as “original Alog”."
    }, {
      "heading" : "2.1 Syntax",
      "text" : "Let Σ be a (possibly sorted) signature with a finite collection of predicate and function symbols and (possibly infinite) collection of object constants, and let A be a finite collection of symbols used to denote functions from sets of terms of Σ into integers. Terms and literals over signature Σ are defined as usual and referred to as regular. Regular terms are called ground if they contain no variables and no occurrences of symbols for arithmetic functions. Similarly for literals. We refer to an expression\n{X̄ : cond} (1)\nwhere cond is a finite collection of regular literals and X̄ is the list of variables occurring in cond, as a set name. It is read as the set of all objects of the program believed to satisfy cond. Variables from X̄ are often referred to as set variables. An occurrence of a set variable in (1) is called bound within (1). Since treatment of variables in extended Alog is the same as in the original language we limit our\n3 There is a common argument for the semantics in which {p(1)} would be the answer set of P2: “Since card{X : p(X)} ≥ 0 is always true it can be dropped from the rule without changing the rule’s meaning”. But the argument assumes existence of the set denoted by {X : p(X)} which is not always the case in Alog.\nattention to programs in which every occurrence of a variable is bound. Rules containing non-bound occurrences of variables are considered as shorthands for their ground instantiations (for details see [15]). A set atom of Alog is an expression of the form\nf1(S1)⊙ f2(S2) (2)\nor\nf(S)⊙ k (3)\nwhere f , f1, f2 are functions from A, S, S1, S2 are set names, k is a number, and ⊙ is an arithmetic relation >,≥, <,≤,= or !=, or of the form\nS1 ⊗ S2 (4)\nwhere ⊗ is ⊂,⊆, or =. We often write f({X̄ : p(X̄)}) as f{X̄ : p(X̄)} and {X̄ : p(X̄)} ⊗ S and S ⊗ {X̄ : p(X̄)} as p ⊗ S and S ⊗ p respectively. Regular and set atoms are referred to as atoms. A rule of Alog is an expression of the form\nhead ← body (5)\nwhere head is a disjunction of regular literals or a set atom of the form p ⊆ S, S ⊆ q, or p = S, and body is a collection of regular literals (possibly preceded by not) and set atoms. A rule with set atom in the head is called set introduction rule. Note that both head and body of a rule can be infinite. All parts of Alog rules, including head, can be empty. A program of Alog is a collection of Alog’s rules."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "To define the semantics of Alog programs we first notice that the standard definition of answer set from [13] is applicable to programs with infinite rules. Hence we already have the definition of answer set for Alog programs not containing occurrences of set atoms. We also need the satisfiability relation for set atoms. Let A be a set of ground regular literals. If f({t̄ : cond(t̄) ⊆ A}) is defined then f({X̄ : cond}) ≥ k is satisfied by A (is true in A) iff f({t̄ : cond(t̄) ⊆ A}) ≥ k. Otherwise, f({X̄ : cond}) ≥ k is falsified (is false in A). If f({t̄ : cond(t̄) ⊆ A}) is not defined then f({X̄ : cond}) ≥ k is undefined in A. (For instance, atom card{X : p(X)} ≥ 0 is undefined in A if A contains an infinite collection of atoms formed by p.) Similarly for other set atoms. Finally a rule is satisfied by S if its head is true in S or its body is false or undefined in S.\nAnswer Sets for Programs without Set Introduction Rules. To simplify the presentation we first give the definition of answer sets for programs whose rules contain no set atoms in their heads. First we need the following definition:\nDefinition 1 (Set Reduct of Alog). Let Π be a ground program of Alog. The set reduct of Π with respect to a set of ground regular literals A is obtained from Π by\n1. removing rules containing set atoms which are false or undefined in A. 2. replacing every remaining set atom SA by the union of cond(t̄) such that\n{X̄ : cond(X̄)} occurs in SA and cond(t̄) ⊆ A.\nThe first clause of the definition removes rules useless because of the truth values of their aggregates in A. The next clause reflects the principle of avoiding vicious circles. Clearly, set reducts do not contain set atoms.\nDefinition 2 (Answer Set). A set A of ground regular literals over the signature of a ground Alog program Π is an answer set of Π if A is an answer set of the set reduct of Π with respect to A.\nIt is easy to see that for programs of the original Alog our definition coincides with the old one. Next several examples demonstrate the behavior of our semantics for programs not covered by the original syntax.\nInfinite Universe\nExample 3 (Aggregates on infinite sets). Consider a program E1 consisting of the following rules:\neven(0). even(I+2) :- even(I). q :- min{X : even(X)} = 0.\nIt is easy to see that the program has one answer set, SE1 = {q, even(0), even(2), . . .}. Indeed, the reduct of E1 with respect to SE1 is the infinite collection of rules\neven(0). even(2) :- even(0). ... q :- even(0),even(2),even(4)...\nThe last rule has the infinite body constructed in the last step of definition 1. Clearly, SE1 is a subset minimal collection of ground literals satisfying the rules of the reduct (i.e. its answer set). Hence SE1 is an answer set of E1.\nExample 4 (Programs with undefined aggregates). Now consider a program E2 consisting of the rules:\neven(0). even(I+2) :- even(I). q :- card{X : even(X)} > 0.\nThis program has one answer set, SE2 = {even(0), even(2), . . .}. Since our aggregates range over natural numbers, the aggregate card is not defined on the set card{t : even(t) ∈ SE2}. This means that the body of the last rule is undefined. According to clause one of definition 1 this rule is removed. The reduct of E2 with respect to SE2 is\neven(0). even(2) :- even(0). even(4) :- even(2). ...\nHence SE2 is the answer set of E2. 4 It is easy to check that, since every set A satisfying the rules of E2 must contain all even numbers, SE1 is the only answer set.\nPrograms with Set Atoms in the Bodies of Rules\nExample 5 (Set atoms in the rule body). Consider a knowledge base containing two complete lists of atoms:\ntaken(mike,cs1). taken(mike,cs2). taken(john,cs2). required(cs1). required(cs2).\nSet atoms allow for a natural definition of the new relation, ready to graduate(S), which holds if student S has taken all the required classes from the second list:\nready to graduate(S) :- {C: required(C)} ⊆ {C:taken(S,C)}.\nThe intuitive meaning of the rule is reasonably clear. The program consisting of this rule and the closed world assumption:\n-ready_to_graduate(S) :- not ready_to_graduate(S)\nimplies that Mike is ready to graduate while John is not. If the list of classes taken by a student is incomplete the closed world assumption should be removed but the first rule still can be useful to determine people who are definitely ready to graduate. Even though the story can be represented in ASP without the set atoms, such representations are substantially less intuitive and less elaboration tolerant. Here is a simplified example of alternative representation suggested to the authors by a third party:\nready to graduate :- not -ready to graduate.\n-ready to graduate :- not taken(c).\n(Here student is eliminated from the parameters and we are limited to only one required class, c.) Even though in this case the answers are correct, unprincipled use of default negation leads to some potential difficulties. Suppose, for instance, that a student may graduate if given a special permission. This can be naturally added as a rule\nready to graduate :- permitted.\nIf the program is expanded by permitted it becomes inconsistent. This, of course, is unintended and contradicts our intuition. No such problem exists for the original representation.\n4 Of course this is true only because of our (somewhat arbitrary) decision to limit aggregates of Alog to those ranging over natural numbers. We could, of course, allow aggregates mapping sets into ordinals. In this case the body of the last rule of E2 will be defined and the only answer set of E2 will be SE1 .\nThe next example shows how the semantics deals with vicious circles.\nExample 6 (Set atoms in the rule body). Consider a program P4\np(a) :- p ⊆ {X : q(X)}. q(a).\nin which definition of p(a) depends on the existence of the set denoted by {X : p(X)}. In accordance with the vicious circle principle no answer set of this program can contain p(a). There are only two candidates for answer sets of P4: S1 = {q(a)} and S2 = {q(a), p(a)}. The set atom reduct of P4 with respect to S1 is\np(a) :- q(a). q(a).\nwhile set atom reduct of P4 with respect to S2 is\np(a) :- p(a),q(a). q(a).\nClearly, neither S1 nor S2 is an answer set of P4. As expected, the program is inconsistent.\nPrograms with Set Introduction Rules. A set introduction rule with head p ⊆ S (where p is a predicate symbol and S is a set name) defines set p as an arbitrary subset of S; rule with head p = S simply gives S a different name; S ⊆ p defines p as an arbitrary superset of S.\nExample 7 (Set introduction rule). According to this intuitive reading the program P9:\nq(a). p ⊆ {X:q(X)}.\nhas answer sets A1 = {q(a)} where the set p is empty and A2 = {q(a), p(a)} where p = {a}.\nThe formal definition of answer sets of programs with set introduction rules is given via a notion of set introduction reduct. (The definition is similar to that presented in [10]).\nDefinition 3 (Set Introduction Reduct). The set introduction reduct of a ground Alog program Π with respect to a set of ground regular literals A is obtained from Π by\n1. replacing every set introduction rule of Π whose head is not true in A by\n← body.\n2. replacing every set introduction rule of Π whose head p ⊆ {X̄ : q(X̄)} (or p = {X̄ : q(X̄)} or {X̄ : q(X̄)} ⊆ p) is true in A by\np(t̄) ← body\nfor each p(t̄) ∈ A.\nSet A is an answer set of Π if it is an answer set of the set introduction reduct of Π with respect to A.\nExample 8 (Set introduction rule). Consider a program P9 from Example 7. The reduct of this program with respect to A1 = {q(a)} is {q(a).} and hence A1 is an answer set of P9. The reduct of P9 with respect to A2 = {q(a), p(a)} is {q(a). p(a).} and hence A2 is also an answer set of P9. There are no other answer sets.\nThe use of a set introduction rule p ⊆ S ← body is very similar to that of choice rule {p(X̄) : q(X̄)} ← body of [24] implemented in Clingo and other similar systems. In fact, if p from the set introduction rule does not occur in the head of any other rule of the program, the two rules have the same meaning. However if this condition does not hold the meaning is different. An Alog program consisting of rules p ⊆ {X : q1(X)} and p ⊆ {X : q2(X)} defines an arbitrary set p from the intersection of q1 and q2. With choice rules it is not the case. We prefer the set introduction rule because of its more intuitive reading (after all everyone is familiar with the statement “p is an arbitrary subset of q”) and relative simplicity of the definition of its formal semantics as compared with that of the choice rule.\nOur last example shows how subset introduction rule with equality can be used to represent synonyms:\nExample 9 (Synonyms). Suppose we have a set of cars represented by atoms formed by a predicate symbol car, e.g., {car(a). car(b).} The following rule\ncarro = {X:car(X)} :- spanish.\nallows to introduce a new name of this set for Spanish speaking people. Clearly, car and carro are synonyms. Hence, program P9 ∪ {spanish.} has one answer set: {spanish, car(a), car(b), carro(a), carro(b)}.\n3 Alternative Formalization of VCP – Language Slog+\nIn this section we introduce alternative interpretation of VCP (referred to as weak VCP) and incorporate it in the semantics of a new logic programming language with set, called Slog+. The syntax of Slog+ coincides with that ofAlog. Its informal semantics is based on weak VCP. By C(T ) we denote a set atom containing an occurrence of set term T . The instantiation of C({X : p(X)}) in a set A of regular literals obtained from C({X : p(X)}) by replacing {X : p(X)} by {t : p(t) ∈ A}. The weak VCP is: belief in p(t) (i.e. inclusion of p(t) in an answer set A) must be established without reference to the instantiation of a set atom C in A unless the truth of this instantiation can be demonstrated without reference to p(t).\nExample 10. To better understand the weak VCP, let us consider program\np(0) :- C. :- not p(0).\nFirst we assume C be card{X : p(X)} > 0. There is only one candidate answer set A = {p(0)} for this program. Belief in p(0) (i.e. its membership in answer set A) can only be established by checking if instantiation card{t : p(t) ∈ A} > 0 of C in A holds. This is prohibited by weak VCP unless the truth of this instantiation can be demonstrated without reference to p(0). But this cannot be so demonstrated because card{t : p(t) ∈ A} > 0 holds only when p(0) is in A. Hence, A is not an answer set. Now let C be card{X : p(X)} ≥ 0. This time the truth of instantiation card{t : p(t) ∈ A} ≥ 0 of C can be demonstrated without reference to p(0) – the instantiation would be true even if A were empty. Hence p(0) must be believed and thus the program has one answer set, {p(0)}.\nTo make weak VCP based semantics precise we need the following notation and definitions: By W̄n, V̄ n we denote n-ary vectors of sets of ground regular literals and by Wi, Vi their i-th coordinates. W̄\nn ≤ V̄ n if for every i, Wi ⊆ Vi. W̄n < V̄ n if W̄n ≤ V̄ n and W̄n 6= V̄ n. A set atom C({X : p1(X)}, . . . , {X : p1(X)}) is satisfied by W̄n if C({t : p1(t) ∈ W1}, . . . , {t : pn(t) ∈ Wn}) is true.\nDefinition 4 (Minimal Support). Let A be a set of ground regular literals of Π, and C be a set atom with n parameters. W̄n is a minimal support for C in A if\n– For ever 1 ≤ i ≤ n, Wi ⊆ A. – Every V̄ n such that for every 1 ≤ i ≤ n, Wi ⊆ Vi ⊆ A satisfies C. – No Ūn < W̄n satisfies the first two conditions.\nIntuitively, the weak VCP says that set atom C can be safely used to support the reasoner’s beliefs iff the existence of a minimal support of C can be established without reference to those beliefs. Precise definition of answer sets of Slog+ is obtained by replacing definition 1 of set reduct of Alog by definition 5 below and combining it with definition 3.\nDefinition 5 (Set-reduct of Slog+). A set reduct of Slog+ program Π with respect to a set A of ground regular literals is obtained from Π by\n1. Removing rules containing set atoms which are false or undefined in A. 2. Replacing every remaining set atom C in the body of the rule by the union\nof coordinates of one of its minimal supports.\nClearly such a reduct is a regular ASP program without sets. A is an answer set of a Slog+ program Π if A is an answer set of a weak set reduct of Π with respect to A.\nExample 11. Consider now an Slog+ program P3\np(3) :- card{X : p(X)} >= 2. p(2) :- card{X : p(X)} >= 2. p(1).\nIt has two candidate answer sets: A1 = {p(1)} and A2 = {p(1), p(2), p(3)}. In A1 the corresponding condition is not satisfied and, hence, the weak set reduct of the programwith respect to A1 is p(1). Consequently, A1 is an answer set of P3. In A2 the condition has three minimal supports: M1 = {p(1), p(2)}, M2 = {p(1), p(3)}, and M3 = {p(2), p(3)}. Hence, the program has nine weak set reducts of P3 with respect to A2. Each reduct is of the form\np(3) :- Mi. p(2) :- Mj. p(1).\nwhere Mi and Mj are minimal supports of the condition. Clearly, the first two rules of such a reduct are useless and hence A2 is not an answer set of this reduct. Consequently A2 is not an answer set of P3.\nThe following two results help to better understand the semantics of Slog+.\nTheorem 1. If a set A is an Alog answer set of Π then A is an Slog+ answer set of Π.\nAs an Slog+ program, P2 has an answer set of {p(1)}, but it has no answer set as an Alog program. The following result shows that there are many such programs and justifies our name for the new language.\nTheorem 2. Let Π be a program which, syntactically, belongs to both Slog and Slog+. A set A is an Slog answer set of Π iff it is an Slog+ answer set of Π.\nAs shown in [35] Slog has sufficient expressive power to formalize complex forms of recursion, including that used in the Company Control Problem [6]. Theorem 2 guarantees that the same representations will work in Slog+. Of course, in many respects Slog+ substantially increases the expressive power of Slog. Most importantly it expands the Slog semantics to programs with epistemic disjunction – something which does not seem to be easy to do using the original definition of Slog answer sets. Of course, new set constructs and rules with infinite number of literals are available in Slog+ but not in Slog. On another hand, Slog allows multisets – a feature we were not trying to include in our language. The usefulness of multisets and the analysis of its cost in terms of growing complexity of the language due to its introduction is still under investigation.\nUnfortunately, the additional power of Slog+ as compared with Alog comes at a price. Part of it is a comparative complexity of the definition of Slog+ set reduct. But, more importantly, the formalization of the weak VCP does not eliminate all the known paradoxes of reasoning with sets. Consider, for instance the following example:\nExample 12. Recall program P2:\np(1) :- card{X:p(X)} >= 0.\nfrom Example 1 and assume, for simplicity, that parameters of p are restricted to {0, 1}. Viewed as a program of Alog, P2 is inconsistent. In Slog+ (and hence in Slog and F log (the language defined in [6])) it has an answer set {p(1)}. The latter languages therefore admit existence of set {X : p(X)}. Now let us look at program P5:\np(1) :- card{X : p(X)} = Y, Y >=0.\nand its grounding P6:\np(1) :- card{X:p(X)} = 1, 1>=0. p(1) :- card{X:p(X)} = 0, 0>=0.\nThey seem to express the same thought as P2, and it is natural to expect all these programs to be equivalent. It is indeed true in Alog – none of the programs is consistent. According to the semantics of Slog+ (and Slog and F log), however, P5 and P6 are inconsistent. To see that notice that there are two candidate answer sets for P6: A1 = ∅ and A2 = {p(1)}. The minimal support of card{X : p(X)} = 0 in A1 is ∅ and hence the only weak set reduct of P6 with respect to A1 is {p(1) :- 0>=0}. A1 is not an answer set of P6. The minimal support of card{X : p(X)} = 1 in A2 is {p(1)}. The only weak set reduct is { p(1) :- p(1),1>=0 }. A2 is not an answer set of P6 either. It could be that this paradoxical behavior will be in the future explained from some basic principles but currently authors are not aware of such an explanation."
    }, {
      "heading" : "4 Properties of VCP Based Extensions of ASP",
      "text" : "In this section we give some basic properties ofAlog and Slog+ programs. Propositions 1 and 2 ensure that, as in regular ASP, answer sets of Alog program are formed using the program rules together with the rationality principle. Proposition 3 is the Alog/Slog+ version of the Splitting Set Theorem – basic technical tool used in theoretical investigations of ASP and its extensions [14,19,38].\nProposition 1 (Rule Satisfaction and Supportedness). Let A be an Alog or Slog+ answer set of a ground program Π. Then\n– A satisfies every rule r of Π. – If p(t̄) ∈ A then there is a rule r from Π such that the body of r is satisfied\nby A and • p(t̄) is the only atom in the head of r which is true in A or • the head of r is of the form p ⊙ {X̄ : q(X̄)} and q(t̄) ∈ A. (It is often said that rule r supports atom p.)\nBy the intuitive and formal meaning of set introduction rules, the anti-chain property no longer holds. However, the anti-chain property still holds for programs without set atoms in the heads of their rules.\nProposition 2 (Anti-chain Property). If Π is a program without set atoms in the heads of its rules then there are no Alog answer sets A1, A2 of Π such that A1 ⊂ A2. Similarly for its Slog + answer sets.\nBefore formulating the next result we need some terminology.\nDefinition 6 (Occurrences of Regular Literals in Aggregate Atoms). We say that a ground literal l occurs in a set atom C if there is a set name {X : cond(X)} occurring in C and l is a ground instance of some literal in cond. If B is a set of ground literals possibly preceded by default negation not then l occurs in B if l ∈ B, or not l ∈ B, or l occurs in some set atom from B.\nDefinition 7 (Splitting Set). Let Π be a program with signature Σ. A set S of ground regular literals of Σ is called a splitting set of Π if, for every rule r of Π, if l occurs in the head of r then every literal occurring in the body of r belongs to S. The set of rules of Π constructed from literals of S is called the bottom of Π relative to S; the remaining rules are referred to as the top of Π relative to S.\nNote that the definition implies that no literal occurring in the bottom of Π relative to S can occur in the heads of rules from the top of Π relative to S.\nProposition 3 (Splitting Set Theorem). Let Π be a ground program, S be its splitting set, and Π1 and Π2 be the bottom and the top of Π relative to S respectively. Then a set A is an answer set of Π iff A ∩ S is an answer set of Π1 and A is an answer set of (A ∩ S) ∪Π2.\nNote that this formulation differs from the original one in two respects. First, rules of the program can be infinite. Second, the definition of occurrence of a regular literal in a rule changes to accommodate the presence of set atoms."
    }, {
      "heading" : "5 Related Work",
      "text" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2]. In addition to this work our paper was significantly influenced by the original work on VCP in set theory and principles of language design advocated by Dijkstra, Hoare, Wirth and others. Harrison et al’s work [16] explaining the semantics of some constructs of gringo in terms of infinitary formulas of Truszczynski [37] led to their inclusion in Alog and Slog+. The notion of set reduct of Alog was influenced by the reduct introduced for defining the semantics of Epistemic Specification in [11]. Recent work by Alviano and Faber [1] helped us to realize the close relationship between Alog and Slog and Argumentation theory [5,3,36] which certainly deserves further investigation, as well as provided us with additional knowledge about Alog. More information about Slog and Slog+ can be found in Section 3. Shen et al. [33] and Liu et al. [20] propose equivalent semantics for disjunctive constraint programs (i.e., programs with rules whose bodies\nare built from constraint atoms and whose heads are epistemic disjunctions of such atoms). This generalizes the standard ASP semantics for disjunctive programs. We conjecture that when we adapt our definition of Slog+ semantics to disjunctive constraint programs, it will coincide with that of [33,20]. However, our definition seems to be simpler and is based on clear, VCP related intuition."
    }, {
      "heading" : "6 Conclusion",
      "text" : "The paper belongs to the series of works aimed at the development of an answer set based knowledge representation language. Even though we want to have a language suitable for serious applications our main emphasis is on teaching. This puts additional premium on clarity and simplicity of the language design. In particular we believe that the constructs of the language should have a simple syntax and a clear intuitive semantics based on understandable informal principles. In our earlier paper [15] we concentrated on a language Alog expanding standard Answer Set Prolog by aggregates. We argued that the syntax of the language is simpler than that of the most popular aggregate language F log implemented in Clingo and other similar systems. In particular, Alog’s notion of grounding allows to define the intuitive (and formal) meaning of a set name independently from its occurrence in a rule. As the result, set name {X : p(X)} can be always equivalently replaced by {Y : p(Y )}. In F log, it is not the case. A semantics of aggregates in Alog was based on a particularly simple and restrictive formalization of VCP. In this paper we:\n– Expanded syntax and semantics of the original Alog by allowing • rules with an infinite number of literals – a feature of theoretical interest also useful for defining aggregates on infinite sets;\n• subset relation between sets in the bodies of rules concisely expressing a specific form of universal quantification; • set introduction – a feature with functionality somewhat similar to that of the choice rule of clingo but with different intuitive semantics. Our additional set constructs are aimed at showing that our original languages can be expanded in a natural and technically simple ways. Other constructs such as set operations and rules with variables ranging over sets (in the style of [4]), etc. are not discussed. Partly this is due to space limitations – we do not want to introduce any new constructs without convincing examples of their use. The future will show if such extensions are justified. – Introduced a new KR language, Slog+, with the same syntax as Alog but different semantics for the set related constructs. The new language is less restrictive and allows formation of substantially larger collection of sets. Its semantics is based on the alternative, weaker formalization of VCP. – Proved that (with the exception of multisets) Slog+ is an extension of a well known aggregate language Slog. The semantics of the new language is based on the intuitive idea quite different from that of Slog and the definition of its semantics is simpler. We point out some paradoxes of Slog+ (and F log) which prevent us from advocating them as standard ASP language with aggregates.\n– Proved a number of basic properties of programs of Alog and Slog+."
    } ],
    "references" : [ {
      "title" : "Stable model semantics of abstract dialectical frameworks revisited: A logic programming perspective",
      "author" : [ "M. Alviano", "W. Faber" ],
      "venue" : "Proceedings of the 21st International Joint Conference on Artificial Intelligence. IJCAI Organization, Buenos Aires, Argentina. pp. 2684–2690",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Complexity and compilation of gz-aggregates in answer set programming",
      "author" : [ "M. Alviano", "N. Leone" ],
      "venue" : "Theory and Practice of Logic Programming 15(4-5), 574–587",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Abstract dialectical frameworks revisited",
      "author" : [ "G. Brewka", "S. Ellmauthaler", "H. Strass", "J.P. Wallner", "S. Woltran" ],
      "venue" : "Proceedings of the Twenty-Third international joint conference on Artificial Intelligence. pp. 803–809. AAAI Press",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Intensional sets in CLP",
      "author" : [ "A. Dovier", "E. Pontelli", "G. Rossi" ],
      "venue" : "Logic Programming, 19th International Conference, ICLP 2003, Mumbai, India, December 9-13, 2003, Proceedings. pp. 284–299",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games",
      "author" : [ "P.M. Dung" ],
      "venue" : "Artificial intelligence 77(2), 321–357",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Semantics and complexity of recursive aggregates in answer set programming",
      "author" : [ "W. Faber", "G. Pfeifer", "N. Leone" ],
      "venue" : "Artificial Intelligence 175(1), 278–298",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Answer sets for propositional theories",
      "author" : [ "P. Ferraris" ],
      "venue" : "LPNMR. pp. 119–131",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Weight constraints as nested expressions",
      "author" : [ "P. Ferraris", "V. Lifschitz" ],
      "venue" : "TPLP 5(1-2), 45–74",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Abstract gringo",
      "author" : [ "M. Gebser", "A. Harrison", "R. Kaminski", "V. Lifschitz", "T. Schaub" ],
      "venue" : "Theory and Practice of Logic Programming 15(4-5), 449–463",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Representing Knowledge in A-Prolog",
      "author" : [ "M. Gelfond" ],
      "venue" : "Kakas, A.C., Sadri, F. (eds.) Computational Logic: Logic Programming and Beyond, Essays in Honour of Robert A. Kowalski, Part II. vol. 2408, pp. 413–451. Springer Verlag, Berlin",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "New semantics for epistemic specifications",
      "author" : [ "M. Gelfond" ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning, pp. 260–265. Springer",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Knowledge Representation, Reasoning, and the Design of Intelligent Agents",
      "author" : [ "M. Gelfond", "Y. Kahl" ],
      "venue" : "Cambridge University Press",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9(3/4), 365–386",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "On consistency and completeness of autoepistemic theories",
      "author" : [ "M. Gelfond", "H. Przymusinska" ],
      "venue" : "Fundam. Inf. 16(1)",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "Vicious circle principle and logic programs with aggregates",
      "author" : [ "M. Gelfond", "Y. Zhang" ],
      "venue" : "TPLP 14(4-5),",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2014
    }, {
      "title" : "The semantics of gringo and infinitary propositional formulas",
      "author" : [ "A.J. Harrison", "V. Lifschitz", "F. Yang" ],
      "venue" : "KR",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Semantics of logic programs with aggregates",
      "author" : [ "D.B. Kemp", "P.J. Stuckey" ],
      "venue" : "ISLP. vol. 91, pp. 387–401. Citeseer",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "A reductive semantics for counting and choice in answer set programming",
      "author" : [ "J. Lee", "V. Lifschitz", "R. Palla" ],
      "venue" : "Proceedings of the Twenty-Third AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2008
    }, {
      "title" : "Splitting a logic program",
      "author" : [ "V. Lifschitz", "H. Turner" ],
      "venue" : "Proceedings of the 11th International Conference on Logic Programming (ICLP94). pp. 23–38",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Strong equivalence of logic programs with abstract constraint atoms",
      "author" : [ "G. Liu", "R. Goebel", "T. Janhunen", "I. Niemelä", "J.H. You" ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning, pp. 161–173. Springer",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Logic programs with abstract constraint atoms: The role of computations",
      "author" : [ "L. Liu", "E. Pontelli", "T.C. Son", "M. Truszczynski" ],
      "venue" : "Artif. Intell. 174(3-4), 295–315",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Set constraints in logic programming",
      "author" : [ "V.W. Marek", "J.B. Remmel" ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning, pp. 167–179. Springer",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Logic programs with abstract constraint atoms",
      "author" : [ "V.W. Marek", "M. Truszczynski" ],
      "venue" : "AAAI. vol. 4, pp. 86–91",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "I. Niemela", "P. Simons", "T. Soininen" ],
      "venue" : "Artificial Intelligence 138(1–2), 181–234",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Well-fouded and stable semantics of logic programs with aggregates",
      "author" : [ "N. Pelov", "M. Denecker", "M. Bruynooghe" ],
      "venue" : "Theory and Practice of Logic Programming 7, 355–375",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Semantics of logic programs with aggregates",
      "author" : [ "N. Pelov" ],
      "venue" : "Ph.D. thesis, Katholieke Universiteit Leuven, Leuven, Belgium",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Partial stable models for logic programs with aggregates",
      "author" : [ "N. Pelov", "M. Denecker", "M. Bruynooghe" ],
      "venue" : "LPNMR. pp. 207–219",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Semantics of disjunctive programs with monotone aggregates - an operator-based approach",
      "author" : [ "N. Pelov", "M. Truszczynski" ],
      "venue" : "NMR. pp. 327–334",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Les mathematiques et la logique",
      "author" : [ "H. Poincare" ],
      "venue" : "Review de metaphysique et de morale 14, 294–317",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1906
    }, {
      "title" : "Answer sets for logic programs with arbitrary abstract constraint atoms",
      "author" : [ "E. Pontelli", "T.C. Son", "P.H. Tu" ],
      "venue" : "CoRR abs/1110.2205",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Mathematical logic as based on the theory of types",
      "author" : [ "B. Russell" ],
      "venue" : "American Journal of Mathematics 30(3), 222–262",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 1908
    }, {
      "title" : "Flp answer set semantics without circular justifications for general logic programs",
      "author" : [ "Y.D. Shen", "K. Wang", "T. Eiter", "M. Fink", "C. Redl", "T. Krennwallner", "J. Deng" ],
      "venue" : "Artificial Intelligence 213, 1–41",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Characterizations of stable model semantics for logic programs with arbitrary constraint atoms",
      "author" : [ "Y. Shen", "J. You", "L. Yuan" ],
      "venue" : "TPLP 9(4), 529–564",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "A constructive semantic characterization of aggregates in answer set programming",
      "author" : [ "T.C. Son", "E. Pontelli" ],
      "venue" : "TPLP 7(3), 355–375",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Answer sets for logic programs with arbitrary abstract constraint atoms",
      "author" : [ "T.C. Son", "E. Pontelli", "P.H. Tu" ],
      "venue" : "J. Artif. Intell. Res. (JAIR) 29, 353–389",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Approximating operators and semantics for abstract dialectical frameworks",
      "author" : [ "H. Strass" ],
      "venue" : "Artificial Intelligence 205, 39–70",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Connecting first-order asp and the logic fo (id) through reducts",
      "author" : [ "M. Truszczynski" ],
      "venue" : "Correct Reasoning, pp. 543–559. Springer",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Splitting a default theory",
      "author" : [ "H. Turner" ],
      "venue" : "Proceedings of the Thirteenth National Conference on Artificial Intelligence and Eighth Innovative Applications of Artificial Intelligence Conference, AAAI 96, IAAI 96, Portland, Oregon, August 4-8, 1996, Volume 1. pp. 645–651",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "A well-founded semantics for basic logic programs with arbitrary abstract constraint atoms",
      "author" : [ "Y. Wang", "F. Lin", "M. Zhang", "J.H. You" ],
      "venue" : "AAAI",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 14,
      "context" : "This paper is the continuation of work started in [15] with introduction of Alog – a version of Answer Set Prolog (ASP) with aggregates.",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 11,
      "context" : "The semantics of Alog combines the Rationality Principle of ASP [12] with the adaptation of the Vicious Circle Principle (VCP) introduced by Poincare and Russel [29,31] in their attempt to resolve paradoxes of set theory.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 28,
      "context" : "The semantics of Alog combines the Rationality Principle of ASP [12] with the adaptation of the Vicious Circle Principle (VCP) introduced by Poincare and Russel [29,31] in their attempt to resolve paradoxes of set theory.",
      "startOffset" : 161,
      "endOffset" : 168
    }, {
      "referenceID" : 30,
      "context" : "The semantics of Alog combines the Rationality Principle of ASP [12] with the adaptation of the Vicious Circle Principle (VCP) introduced by Poincare and Russel [29,31] in their attempt to resolve paradoxes of set theory.",
      "startOffset" : 161,
      "endOffset" : 168
    }, {
      "referenceID" : 5,
      "context" : "To the best of our knowledge all ASP based semantics, including that of [6,34,15]) view P0 as a bad specification.",
      "startOffset" : 72,
      "endOffset" : 81
    }, {
      "referenceID" : 33,
      "context" : "To the best of our knowledge all ASP based semantics, including that of [6,34,15]) view P0 as a bad specification.",
      "startOffset" : 72,
      "endOffset" : 81
    }, {
      "referenceID" : 14,
      "context" : "To the best of our knowledge all ASP based semantics, including that of [6,34,15]) view P0 as a bad specification.",
      "startOffset" : 72,
      "endOffset" : 81
    }, {
      "referenceID" : 5,
      "context" : "[6] views P1 as a reasonable specification having one answer set – {p(0), p(1)}.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 33,
      "context" : "According to [34,15] P1 is inconsistent.",
      "startOffset" : 13,
      "endOffset" : 20
    }, {
      "referenceID" : 14,
      "context" : "According to [34,15] P1 is inconsistent.",
      "startOffset" : 13,
      "endOffset" : 20
    }, {
      "referenceID" : 33,
      "context" : "(The name of the new language is explained by its close relationship with language Slog [34] – see Theorem 2).",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 14,
      "context" : "Rules containing non-bound occurrences of variables are considered as shorthands for their ground instantiations (for details see [15]).",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 12,
      "context" : "To define the semantics of Alog programs we first notice that the standard definition of answer set from [13] is applicable to programs with infinite rules.",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 9,
      "context" : "(The definition is similar to that presented in [10]).",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 23,
      "context" : "The use of a set introduction rule p ⊆ S ← body is very similar to that of choice rule {p(X̄) : q(X̄)} ← body of [24] implemented in Clingo and other similar systems.",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 34,
      "context" : "As shown in [35] Slog has sufficient expressive power to formalize complex forms of recursion, including that used in the Company Control Problem [6].",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 5,
      "context" : "As shown in [35] Slog has sufficient expressive power to formalize complex forms of recursion, including that used in the Company Control Problem [6].",
      "startOffset" : 146,
      "endOffset" : 149
    }, {
      "referenceID" : 5,
      "context" : "In Slog (and hence in Slog and F log (the language defined in [6])) it has an answer set {p(1)}.",
      "startOffset" : 62,
      "endOffset" : 65
    }, {
      "referenceID" : 13,
      "context" : "Proposition 3 is the Alog/Slog version of the Splitting Set Theorem – basic technical tool used in theoretical investigations of ASP and its extensions [14,19,38].",
      "startOffset" : 152,
      "endOffset" : 162
    }, {
      "referenceID" : 18,
      "context" : "Proposition 3 is the Alog/Slog version of the Splitting Set Theorem – basic technical tool used in theoretical investigations of ASP and its extensions [14,19,38].",
      "startOffset" : 152,
      "endOffset" : 162
    }, {
      "referenceID" : 37,
      "context" : "Proposition 3 is the Alog/Slog version of the Splitting Set Theorem – basic technical tool used in theoretical investigations of ASP and its extensions [14,19,38].",
      "startOffset" : 152,
      "endOffset" : 162
    }, {
      "referenceID" : 16,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 9,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 23,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 22,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 21,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 25,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 26,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 27,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 6,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 7,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 24,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 33,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 17,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 32,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 20,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 5,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 29,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 19,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 38,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 15,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 31,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 14,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 8,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 1,
      "context" : "There are multiple approaches to introducing aggregates in logic programming languages under the answer sets semantics [17,10,24,23,22,26,27,28,7,8,25,34,18,33,21,6,30,20,39,16,32,15,9,2].",
      "startOffset" : 119,
      "endOffset" : 187
    }, {
      "referenceID" : 15,
      "context" : "Harrison et al’s work [16] explaining the semantics of some constructs of gringo in terms of infinitary formulas of Truszczynski [37] led to their inclusion in Alog and Slog.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 36,
      "context" : "Harrison et al’s work [16] explaining the semantics of some constructs of gringo in terms of infinitary formulas of Truszczynski [37] led to their inclusion in Alog and Slog.",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 10,
      "context" : "The notion of set reduct of Alog was influenced by the reduct introduced for defining the semantics of Epistemic Specification in [11].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 0,
      "context" : "Recent work by Alviano and Faber [1] helped us to realize the close relationship between Alog and Slog and Argumentation theory [5,3,36] which certainly deserves further investigation, as well as provided us with additional knowledge about Alog.",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 4,
      "context" : "Recent work by Alviano and Faber [1] helped us to realize the close relationship between Alog and Slog and Argumentation theory [5,3,36] which certainly deserves further investigation, as well as provided us with additional knowledge about Alog.",
      "startOffset" : 128,
      "endOffset" : 136
    }, {
      "referenceID" : 2,
      "context" : "Recent work by Alviano and Faber [1] helped us to realize the close relationship between Alog and Slog and Argumentation theory [5,3,36] which certainly deserves further investigation, as well as provided us with additional knowledge about Alog.",
      "startOffset" : 128,
      "endOffset" : 136
    }, {
      "referenceID" : 35,
      "context" : "Recent work by Alviano and Faber [1] helped us to realize the close relationship between Alog and Slog and Argumentation theory [5,3,36] which certainly deserves further investigation, as well as provided us with additional knowledge about Alog.",
      "startOffset" : 128,
      "endOffset" : 136
    }, {
      "referenceID" : 32,
      "context" : "[33] and Liu et al.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[20] propose equivalent semantics for disjunctive constraint programs (i.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 32,
      "context" : "We conjecture that when we adapt our definition of Slog semantics to disjunctive constraint programs, it will coincide with that of [33,20].",
      "startOffset" : 132,
      "endOffset" : 139
    }, {
      "referenceID" : 19,
      "context" : "We conjecture that when we adapt our definition of Slog semantics to disjunctive constraint programs, it will coincide with that of [33,20].",
      "startOffset" : 132,
      "endOffset" : 139
    }, {
      "referenceID" : 14,
      "context" : "In our earlier paper [15] we concentrated on a language Alog expanding standard Answer Set Prolog by aggregates.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 3,
      "context" : "Other constructs such as set operations and rules with variables ranging over sets (in the style of [4]), etc.",
      "startOffset" : 100,
      "endOffset" : 103
    } ],
    "year" : 2016,
    "abstractText" : "The paper continues the investigation of Poincare and Russel’s Vicious Circle Principle (VCP) in the context of the design of logic programming languages with sets. We expand previously introduced language Alog with aggregates by allowing infinite sets and several additional set related constructs useful for knowledge representation and teaching. In addition, we propose an alternative formalization of the original VCP and incorporate it into the semantics of new language, Slog, which allows more liberal construction of sets and their use in programming rules. We show that, for programs without disjunction and infinite sets, the formal semantics of aggregates in Slog coincides with that of several other known languages. Their intuitive and formal semantics, however, are based on quite different ideas and seem to be more involved than that of Slog.",
    "creator" : "LaTeX with hyperref package"
  }
}