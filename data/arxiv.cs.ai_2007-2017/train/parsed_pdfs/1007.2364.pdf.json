{
  "name" : "1007.2364.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n00 7.\n23 64\nv1 [\ncs .A\nI] 1\n4 Ju"
    }, {
      "heading" : "1 Introduction",
      "text" : "The idea of the Semantic Web is to annotate Web content and services with computer interpretable descriptions in order to automatize many tasks currently performed by human users. In the context of the Web services, this has led to the definition of semantic Web services, that is a semantic description of the capabilities and the structure of services in the languages of the semantic Web. The current proposals for the representation of semantic Web services, as OWL-S [10], view services as processes with pre- and post- conditions and effects. The representation by pre- and post- conditions describe the requirements and output of a service that is useful to retrieve the service; the representation of the process associated with a service describe the interaction with other given services. One of the main problems in the context of Web services is their composition. The problem can be stated as follows: given a composition goal, represented as a service with pre- and post- conditions, compose the available services so to satisfy the goal. Obviously in this context the challenge is to provide tools to support the definition of the composite service or, at best, to automatize the entire composition process. Using the well known relation between semantic Web languages and description logics, here we discuss the problem of service composition in the context of constructive description logics. This allows us to draw from the long tradition of use of constructive mathematics in the context of program synthesis. Indeed, the composition calculus we discuss in this paper is inspired by [13].\n⋆ Part of this work will appear as a position paper in Proceedings of the 4th International Conference on Web Reasoning and Rule Systems (RR 2010).\nIn this paper we formalize the composition problem in the framework of the constructive description logic BCDL0. This paper represents an initial presentation for our approach: its main contribution is to lay down the definitions for a composition language in a way that it can then be possible to define an automatic procedure for composition by software synthesis principles. Moreover, our approach also exhibits an interesting application of constructive semantics for description logics and demonstrates how to take advantage of their computational properties.\nThe logic BCDL0 that forms the base of our proposal is a subsystem of BCDL [9], a logic based on an information terms semantics. The main advantage of this semantics is to provide a natural notion of state which is at the base of our formalization of Web services and Web service composition. Moreover, how discussed in [9] this logic supports the proofs-as-programs paradigm. This allows to characterize in this setting also the problem of automatic Web services composition. For our purposes, in this paper we present a natural deduction calculus for BCDL0: however, this logic can be related to KALC [4], a constructive description logic based on a Kripke-style semantics for which we provided a decidable tableaux calculus.\nIn the following sections we introduce our formalism for the specification of services and we present our calculus SC for the definition of composite services. In order to do this, we begin by introducing the syntax and information terms semantics of BCDL0.\n2 BCDL0: Syntax and Semantics\nBCDL0 is a subsystem of BCDL [9] which is the correspondent in the information terms semantics context of the basic description logic ALC [1]. The language L for BCDL0 is based on the following denumerable sets: the set NR of role names, the set NC of concept names, the set NI of individual names and the set Var of individual variables. The concepts C,D and the formulas K of L are defined according to the following grammar:\nC,D ::= A | ¬C | C ⊓D | C ⊔D | ∃R.C | ∀R.C\nK ::= ⊥ | (s, t) : R | t : C | A⊑C\nwhere s, t ∈ NI ∪ Var, R ∈ NR, A ∈ NC. A closed formula is a formula not containing individual variables. A simple formula is either a formula of the kind ⊥, (s, t) : R or a formula of the kind t : C with C a concept name or a negated concept. We remark that we do not allow general inclusions of concepts, but we only admit atomic concepts in the antecedent of a subsumption.\nIn the following we will be interested in the formulas generated by a finite subset N of NI; we denote with LN such a language. A model M for LN is a pair (DM, .M), where DM is a non-empty set (the domain of M) and .M is a valuation map such that: (i) for every c ∈ N , cM ∈ DM; (ii) for every A ∈ NC, AM ⊆ DM; (iii) for every R ∈ NR, RM ⊆ DM ×DM.\nA non atomic concept C is interpreted by a subset CM of DM as usual:\n(¬C)M = DM \\ CM\n(C ⊓D)M = CM ∩DM\n(C ⊔D)M = CM ∪DM\n(∃R.C)M = { c ∈ DM | there is d ∈ DM s.t. (c, d) ∈ RM and d ∈ CM}\n(∀R.C)M = { c ∈ DM | for all d ∈ DM, (c, d) ∈ RM implies d ∈ CM}\nA closed formula K is valid in M, and we write M |= K, if K 6= ⊥ and:\nM |= (s, t) : R iff (sM, tM) ∈ RM\nM |= t : C iff tM ∈ CM\nM |= A ⊑ C iff AM ⊆ CM\nA theory T consists of a TBox and an ABox. A TBox is a finite set of formulas of the form A ⊑ C. An ABox is a finite set of concept and role assertions: a concept assertion is a formula of the kind c : A, with c ∈ NI and A ∈ NC; a role assertion is a formula of the kind (c, d) : R, with c, d ∈ NI and R ∈ NR.\nThe constructive interpretation of BCDL0 is based on the notion of information term [9]. Intuitively, an information term α for a closed formula K is a structured object that provides a justification for the validity of K in a classical model, in the spirit of the BHK interpretation of logical connectives [18]. Information terms are inductively defined on the structure of the closed formulas, starting from the constant symbol tt associated to atomic formulas. The meaning and the correct reading of an information term is provided by the related formula. For instance, the truthness of an existential formula c : ∃R.C in a classical model M can be explained by its information term (d, α), that explicitly provides the witness d such that (cM, dM) ∈ RM and dM ∈ CM; moreover, the information term α recursively explains why dM ∈ CM.\nFormally, given N ⊆ NI and a closed formula K of LN , we define the set of information terms itN (K) by induction on K as follows.\nitN (K) = {tt}, if K is a simple formula\nitN (c : C1 ⊓ C2) = { (α, β) | α ∈ itN (c : C1) and β ∈ itN (c : C2) }\nitN (c : C1 ⊔ C2) = { (k, α) | k ∈ {1, 2} and α ∈ itN (c : Ck) }\nitN (c : ∃R.C) = { (d, α) | d ∈ N and α ∈ itN (d : C) } itN (c : ∀R.C) = {φ : N → ⋃ d∈N itN (d : C) | φ(d) ∈ itN (d : C) } itN (A⊑C) = {φ : N → ⋃ d∈N itN (d : C) | φ(d) ∈ itN (d : C) }\nWe remark that information terms for K = c : ∀R.C and K = A⊑C formulas are defined as a set of functions mapping every element d of the finite set N to an information term for d : C. In other words, any information term for these formulas justifies that every element of N belongs to the concept defined by C in a given classical model.\nLet M be a model for LN , K a closed formula of LN and η ∈ itN (K). We define the realizability relation M✄ 〈η〉K by induction on the structure of K.\n– M✄ 〈tt〉K iff M |= K. – M✄ 〈(α, β)〉 c : C1 ⊓ C2 iff M ✄ 〈α〉 c : C1 and M✄ 〈β〉 c : C2. – M✄ 〈(k, α)〉 c : C1 ⊔ C2 iff M✄ 〈α〉 c : Ck. – M✄ 〈(d, α)〉 c : ∃R.C iff M |= (c, d) : R and M✄ 〈α〉 d : C. – M ✄ 〈φ〉 c : ∀R.C iff M |= c : ∀R.C and, for every d ∈ N , M |= (c, d) : R\nimplies M✄ 〈φ(d)〉 d : C – M ✄ 〈φ〉A⊑C iff, M |= A⊑C and, for every d ∈ N , if M ✄ 〈tt〉 d : A then\nM✄ 〈φ(d)〉 d : C\nIf Γ is a finite set of closed formulas {K1, . . . ,Kn} of LN (for any ordering of the formulas of Γ ), itN (Γ ) denotes the set of n-tuples η = (η1, . . . , ηn) such that, for every 1 ≤ j ≤ n, ηj ∈ itN (Kj); M ✄ 〈η〉Γ iff, for every 1 ≤ j ≤ n, M✄ 〈ηj〉Kj.\nNow, we introduce the example we refer to throughout this paper.\nExample 1 (Theory definition). Our example represents a reinterpretation and a formalization in our context of the “purchase and delivery service” example of [17]. The example presents a system composed by three agents: a User, a Shipper and a Producer agent. The Shipper and the Producer provide the User with services to request and obtain offers for the delivery and the purchase of a product: the goal of the example is to combine the services of the two agents in order to provide the User with a single service to request the production and shipping of a product. We begin by defining the theory TPS that models our system.\nAcceptedRequest ⊑ Request RefusedRequest ⊑ Request ⊓ ¬AcceptedRequest\nProduceRequest ⊑ Request AcceptedProduceRequest ⊑ ProduceRequest ⊓ AcceptedRequest\nShippingRequest ⊑ Request AcceptedShippingRequest ⊑ ShippingRequest ⊓ AcceptedRequest\nProduceOffer ⊑ Offer ShippingOffer ⊑ Offer\nThe theory states that a request can be classified as accepted or refused by one of the two agents: we further characterize offers, requests and accepted requests by the agent to which they refer. To relate requests to offers and to the information that they convey, we include in TPS the following axioms:\nOffer ⊑ ∀hasCost.Price Request ⊑ ∀hasOffer.Offer\nShippingRequest ⊑ ∀hasDestination.Location ProduceRequest ⊑ ∀hasProduct.Product\nIn other words, every offer in Offer specifies its Price by the role hasCost; requests relate to their offers by the role hasOffer; finally, a ShippingRequest\ncontains information about the Location to where to ship by the role hasDestination and a ProduceRequest describes the Product to buy by the role hasProduct.\nGiven a finite set of individual names N , we assume to have a suitable η ∈ itN (TPS) justifying the validity of TPS with respect to elements of N . Note that TPS only represents a TBox, thus information terms of its subsumptions are functions mapping information terms of the included concept in those of the including concept. If we assume to store assertions of an ABox over N in some kind of database (e.g., a relational database or the data part of a logic program), the functions for each of these information terms can be implemented as query prototypes (to be instantiated with individuals of N ) over the database. ✸\nGiven a finite subset N of NI, an N -substitution σ is a map σ : Var → N . We extend σ to LN as usual: if c ∈ N , σc = c; for a formula K of LN , σK denotes the closed formula of LN obtained by replacing every variable x occurring in K with σ(x); given a set of formulas Γ , σΓ is the set of σK such that K ∈ Γ . If c ∈ N , σ[c/p] is the N -substitution σ′ such that σ′(p) = c and σ′(x) = σ(x) for x 6= p. A N -substitution σ is a closing substitution for a set of formulas Γ if σΓ is a set of closed formulas.\nNow, let us consider the natural deduction calculus ND for BCDL0 whose rules are given in Figure 1. We denote with π :: Γ ⊢ K the fact that π is a proof of Γ ⊢ K and with Γ |\nBCDL0 K the fact that there exists a proof π :: Γ ⊢ K in\nND . For a detailed presentation of the calculus and its properties we refer the reader to [9]. Here we only note that ND is sound with respect to the information term semantics, namely:\nTheorem 1 (Soundness). Let Γ ∪ {K} ⊆ LN , let π :: Γ ⊢ K be a proof of ND and let Σ be the set of all the closing N -substitutions for Γ ∪ {K}. Then there exists an operator\nΦπN : ⋃\nσ∈Σ\nitN (σΓ ) → ⋃\nσ∈Σ\nitN (σK)\nsuch that, for every γ ∈ it(σΓ ) and for every model M for LN , M ✄ 〈γ〉σΓ implies M✄ 〈ΦπN (γ)〉σK. ⊓⊔\nWe remark that the proof of the above theorem is constructive. As shown in [9] we can effectively extract from the proof π the operator ΦπN . This plays an important role in the definition of our service composition calculus in Section 4."
    }, {
      "heading" : "3 Service Specifications",
      "text" : "In this section we introduce the basic definitions for the description of systems and for the specification of services operating on them. A service specification (over LN ) is an expression of the form s(x) :: P ⇒ Q where: s is a label that identifies the service; x is the input parameter of the service (to be instantiated with an individual name from N ); P and Q are concepts over LN . P is called the service pre-condition, denoted with Pre(s), and Q the service post-condition,\ndenoted with Post(s). Given a service specification s(x) :: P ⇒ Q over LN we call service implementation a function\nΦs : ⋃\nt∈N\nitN (t : P ) → ⋃\nt∈N\nitN (t : Q)\nWe denote with the pair (s(x) :: P ⇒ Q,Φs) (or simply with (s, Φs)) a service definition over LN .\nEssentially, a service definition corresponds to an effective Web service. The service specification provides the formal description of the behavior of the service in terms of pre- and post- conditions. The function Φs represents a formal description of service implementation (i.e., of the input/output function).\nThe notion of correctness is modeled as follows. Given a language LN , a service definition (s(x) :: P ⇒ Q,Φs) over LN and a model M for LN , Φs uniformly solves s(x) :: P ⇒ Q in M iff, for every individual name t ∈ N and every α ∈ itN (t : P ) such that M✄ 〈α〉 t : P , M✄ 〈Φs(α)〉 t : Q.\nExample 2 (Service specification). We can now model the services provided by the Producer and Shipper agents.\nDoProduceRequest(req) :: ProduceRequest ⊓ ∃hasProduct.Product ⇒ RefusedRequest ⊔ ( AcceptedProduceRequest ⊓ ∃hasOffer.( ProduceOffer ⊓ ∃hasCost.Price ) )\nDoShippingRequest(req) :: ShippingRequest ⊓ ∃hasDestination.Location\n⇒ RefusedRequest ⊔ ( AcceptedShippingRequest ⊓ ∃hasOffer.( ShippingOffer ⊓ ∃hasCost.Price ) )\nThe service described by DoProduceRequest takes as input a request req specifying the required product and must classify it according to the service postcondition: namely, the service can answer with a refusal to the request (by classifying req in RefusedRequest) or it can accept the request and produce an offer with a price specified by the hasCost role. The DoShippingRequest service works in a similar way: it takes as input the destination where to ship the product and either refuses the request or it accepts the request providing an offer with the associated price.\nIn our setting, service implementations correspond to functions mapping information terms for the pre-condition into information terms for the postcondition. These functions formalize the behavior of the effective implementation of the web services. In particular let us consider the implementation ΦDPR of the DoProduceRequest service. Let req 1 be the individual name representing a request. The input of ΦDPR is any information term for α ∈ itN (req 1 : Pre(DoProduceRequest)). req 1 can be seen as a reference to a database record providing the information required by the service precondition and α can be seen as a structured representation of such information. Let us suppose that α = (tt, (book 1, tt)); this information term means that req 1 is a product request with associated product book 1. Now, let β = ΦDPR(α) ∈ it(req 1 : Post(DoProduceRequest)). If β = (1, tt), this classify req 1 as refused. Otherwise β could be (2, (tt, (off 1, (tt, (price 1, tt))))) which classifies req 1 as accepted and specifies that there is an offer off 1 with associated price price 1 for the requested product. The implementation ΦDSR of DoShippingRequest acts in a similar way.\nTo conclude, we remark that the intended model M we use to evaluate the correctness of the system is implicitly defined by the knowledge base of the system. Indeed, M ✄ 〈α〉 req 1 : Pre(DoProduceRequest) if and only if in our system req 1 effectively codify a request and book 1 is classified as a product. In this case, since ΦDPR uniformly solves the service specification, we know that M ✄ 〈β〉 req 1 : Post(DoProduceRequest): this trivially corresponds to the fact that, looking at its knowledge base, the Producer can generate its offer. ✸\nThe problem of service composition amounts to build a new service from a family of implemented services. We formalize this problem in the context of an environment, that is a structure E = 〈LN ,T, η, (s1, Φ1), . . . , (sn, Φn)〉 where:\n– T is a theory over the language LN ; – η ∈ itN (T); – for every i ∈ {1, . . . , n}, (si, Φi) is a service definition in LN .\nGiven a model M for LN we say that M is a model for E iff M✄ 〈η〉T and for every i ∈ {1, . . . , n}, Φi uniformly solves si in M.\nA service specification s′ is solvable in E if there exists an implementation Φ′ of s′ such that, for every model M of LN , if M is a model for E then Φ′ uniformly solves s′ in M.\nExample 3 (Composition problem definition). Given the previous specifications, we are now ready to state the composition problem. We want to combine the services DoProduceRequest and DoShippingRequest to provide the User with a single service to request both the production and the delivery of an object. To do this, we define a third service that composes the offers from the two agents:\nProcessOffers(req) :: AcceptedProduceRequest ⊓ ∃hasOffer.( ProduceOffer ⊓ ∃hasCost.Price ) ⊓ AcceptedShippingRequest ⊓ ∃hasOffer.( ShippingOffer ⊓ ∃hasCost.Price ) ⇒ AcceptedRequest ⊓ ∃hasOffer.( Offer ⊓ ∃hasCost.Price )\nLet ΦPO be the implementation of ProcessOffers. We define the environment EPS = 〈LN ,TPS , η, S1, S2, S3〉 where S1 = (DoProduceRequest, ΦDPR), S2 = (DoShippingRequest, ΦDSR) and S3 = (ProcessOffers, ΦPO). The problem can be now reduced to the definition of a suitable service specification that is solvable in such environment. ✸\nNow, the main point of service composition is to effectively build the implementation of the service specification starting from the environment. This problem can be solved in two ways: the first solution consists in the definition of a composition language which allows the user to build up a new service starting from the environment. The second is given by providing a method to automatically build up the new service implementation.\nThe formalization of the composition problem in the framework of a (constructive) logic allows to use the proof-theoretical properties of the logical system to support the composition problem. In this paper we concentrate on the definition of a composition language. As for the problem of automatic service composition, it can be seen as a reformulation of the program-synthesis problem, a problem which has a long tradition in the constructive logics context and which has already been studied in the framework of BCDL, see [3, 9]."
    }, {
      "heading" : "4 Composition Calculus SC",
      "text" : "The composition calculus we describe in this section is inspired by PAP [13], a calculus which support program synthesis from proofs of a constructive logical system. Our calculus allows to manually compose services guaranteeing the correctness of the composed service. The main advantage of our formalization is that service composition can be supported by an appropriate proof-system. This tool can be used to check the correctness of rule applications and to automatically build the proofs of the applicability conditions.\nA composition over an environment E = 〈LN ,T, η, (s1, Φ1), . . . , (sn, Φn)〉 is defined as:\ns(x) :: P ⇒ Q\nΠ1 : s1(x) :: P1 ⇒ Q1 · · · Πn : sn(x) :: Pn ⇒ Qn\nr\nwhere:\n– s(x) :: P ⇒ Q is a service specification over E; – r is one of the rules of the composition calculus SC; – For every i ∈ {1, . . . , n}, Πi : si(x) :: Pi ⇒ Qi is a service composition over E\nthat meets the applicability conditions of r.\nThe rules of the composition calculus SC and their computational interpretation Φs are given in Figure 2. In the rules, the service specification s(x) :: P ⇒ Q is called the main sequent of the rule and represents the specification of the service to be composed. The service specifications si(x) :: Pi ⇒ Qi are called subsequents of the rule and represent the services involved in the composition. The sequents must satisfy the applicability conditions (AC) of the rule. These conditions describe the role of the subsequents in the composition of the main sequent: in order to verify the correctness of compositions, the proof checker must verify the truth of such conditions. The composition rules have both a logical and a computational reading. Given a service composition Π with main sequent s(x) :: P ⇒ Q, we define the function\nΦs : ⋃ t∈N itN (t : P ) → ⋃\nt∈N itN (t : Q) associated with s. The function is inductively defined on the last rule r applied in Π . Here we assume the following conventions: given a subsequent s′ of the rule r, we denote with Φs′ its computed function; given the applicability condition (a) Γ |\nBCDL0 x : A of the rule r we\ndenote with Φa the operator corresponding to the proof π :: Γ ⊢ x : A defined according to Section 2.\nInspecting the rules of Figure 2 we see that:\n– The AND rule represents a ⊓ introduction on the right hand side of the specification sequents: the services composed by this rule are seen as a parallel execution of the sub services. – The CASE rule represents a ⊔ elimination on the left hand side of the specification sequent: the services composed by this rule are seen as in a case construct, in which the applicability condition determines the executed sub-service. – The SEQ rule represents a composition given as a sequential execution of the sub-services and a composition of proofs under the logical reading. – The AX rule states that the system can infer specifications provable under a suitable calculus for BCDL0. – The ENV rule allows to use the specifications given in the environment E.\nLet us complete our example with a sample service composition.\nExample 4 (Service Composition). Given the environment EPS defined in Example 3 and the rules of SC, we can define a new service ProduceAndShip as the composition Π of the stated specifications as follows:\nProduceAndShip(req) :: ProduceRequest ⊓ ShippingRequest⊓ ∃hasProduct.Product ⊓ ∃hasDestination.Location ⇒\nRefusedRequest ⊔ ( AcceptedRequest ⊓ ∃hasOffer.( Offer ⊓ ∃hasCost.Price ) ) SEQ Π1 : DoRequest(req) :: ProduceRequest ⊓ ShippingRequest⊓ ∃hasProduct.Product ⊓ ∃hasDestination.Location ⇒\nRefusedRequest ⊔ ( ( AcceptedProduceRequest ⊓ ∃hasOffer.( ProduceOffer ⊓ ∃hasCost.Price ) ) ⊓ ( AcceptedShippingRequest ⊓ ∃hasOffer.( ShippingOffer ⊓ ∃hasCost.Price ) ) ) AND DoProduceRequest(req) :: ENV\nProduceRequest ⊓ ∃hasProduct.Product ⇒\nRefusedRequest ⊔ ( AcceptedProduceRequest ⊓ ∃hasOffer.( ProduceOffer ⊓ ∃hasCost.Price ) )\nDoShippingRequest(req) :: ENV ShippingRequest ⊓ ∃hasDestination.Location ⇒\nRefusedRequest ⊔ ( AcceptedShippingRequest ⊓ ∃hasOffer.( ShippingOffer ⊓ ∃hasCost.Price ) )\nΠ2 : PresentOffer(req) ::\nRefusedRequest ⊔ ( ( AcceptedProduceRequest ⊓ ∃hasOffer.( ProduceOffer ⊓ ∃hasCost.Price ) ) ⊓ ( AcceptedShippingRequest ⊓ ∃hasOffer.( ShippingOffer ⊓ ∃hasCost.Price ) ) ) ⇒\nRefusedRequest ⊔ ( AcceptedRequest ⊓ ∃hasOffer.( Offer ⊓ ∃hasCost.Price ) ) CASE RefuseRequest(req) :: AX\nRefusedRequest ⇒ RefusedRequest\nProcessOffers(req) :: ENV AcceptedProduceRequest ⊓ ∃hasOffer.( ProduceOffer ⊓ ∃hasCost.Price ) ⊓ AcceptedShippingRequest ⊓ ∃hasOffer.( ShippingOffer ⊓ ∃hasCost.Price ) ⇒\nAcceptedRequest ⊓ ∃hasOffer.( Offer ⊓ ∃hasCost.Price )\nThe behavior of this service is defined as follows: using the DoRequest service (service composition Π1), it first invokes the DoProduceRequest and the DoShippingRequest services to query the Producer and the Shipper over the combined request req. The answer of the two is then combined by PresentOffer (service composition Π2): by a case construct, this sub-service either responds that the request req has been classified as refused, or it accepts the request and generate the combined price using the ProcessOffers service.\nLet us discuss how the composite service computes information terms by explaining a sample execution. Let req 2 be both a ProduceRequest and a ShippingRequestwith associated product book 1 and shipping destination my home. Then, a call of ProduceAndShip over req 2 has as input information term α1 = (tt, (tt, ((book 1, tt), (my home, tt)))). Following the composition, The execution of ProduceAndShip starts with the sequence construct and the first invoked service is DoRequest which process the information term α1. DoRequest consists of a parallel call to the services of the Producer and the Shipper. The request to the Producer is executed as a call to DoProduceRequest. According to the conditions of the AND rule, we have a proof:\nπ1 :: TPS , x : Pre(DoRequest) | BCDL0 x : Pre(DoProduceRequest)\nThe corresponding operator Φπ1N allows us to extract from α1 the information term (tt, (book 1, tt)) ∈ itN (req 2 : Pre(DoProduceRequest)). Let us suppose that the Producer accepts the request and produces an offer p off with an associated price. The offer is codified in the information term α2 = ΦDPR((tt, (book 1, tt)). Let us assume that α2 has the following form:\nα2 = (2, (tt, (p off, (tt, (p off price, tt)))))\nThe request to the Shipper consists in a call to DoShippingRequest with input information term (tt, (my home, tt)). Also in this case this information term is generated from the operator associated with an applicability rule. As above, if\nthe Shipper accepts the request with an offer s off and its price, then the output information term is:\nα3 = (2, (tt, (s off, (tt, (s off price, tt)))))\nNow the applicability conditions of the AND composition rule, in particular the proof:\nπ2 :: TPS , x : Post(DoProduceRequest) ⊓ Post(DoShippingRequest)\n| BCDL0 x : Post(DoRequest)\nallows us to combine α2 and α3 to get an α4 ∈ itN (req 2 : Post(DoRequest)) as follows:\nα4 = (2, ((tt, (p off, (tt, (p off price, tt)))), (tt, (s off, (tt, (s off price, tt))))))\nProceeding in the sequence, the previous responses are combined by a call of PresentOffer with input information term α4. By the AC of the CASE construct, as the request has been accepted by both agents, we enter in the second of the cases and we call ProcessOffers with input information term:\nα5 = ( (tt, (p off, (tt, (p off price, tt)))), (tt, (s off, (tt, (s off price, tt)))) )\nThe service combines the offers producing a composite offer ps off with its associated price ps off price modeled by the information term:\n(tt, (ps off, (tt, (ps off price, tt))))\nFinally the output of PresentOffer and ProduceAndShip is:\n(2, (tt, (ps off, (tt, (ps off price, tt)))))\nThis object states that the request has been accepted and it contains both the object representing the composite offer (ps off) and its composite price (ps off price). ✸\nTo conclude this section we state the result asserting the soundness of the rules with respect to uniform solvability. Its proof easily follows by induction on the structure of the composition Π .\nTheorem 2. Let E = 〈LN ,T, η, (s1, Φ1), . . . , (sn, Φn)〉 be an environment and let s(x) :: P ⇒ Q be the main sequent of a composition Π over E. For every model M for L, if M is a model for E then the function Φs extracted from Π uniformly solves s in M. ⊓⊔"
    }, {
      "heading" : "5 Related Works and Conclusions",
      "text" : "In this section we review some of the current approaches for the composition of semantic Web services and we discuss the relations with our proposal.\nOne of the most relevant proposals for the semantic description of Web services is OWL-S [10]. An OWL-S service is described by three representations conforming to three distinct ontologies: a service profile, describing its use in terms of inputs, outputs, pre- and post- conditions, a process model, stating the flow of interactions that composes the service, and a grounding model, describing the details about its interface. Among these, the profile and the process model define an abstract representation of the service. In particular, the service profile gives a declarative description of the service. The process model describes the possible interactions with a service, that is its composition with other given services. The model mainly distinguish services into atomic and composite processes : atomic processes do not have a representation of their internal structure and thus they are entirely defined by their profiles; on the other hand, composite processes are representations of compositions of processes linked by some control structure.\nMany tasks can be supported by a pure atomic view of the services: one of these tasks is planning, which can be seen as a way to synthesize service compositions. In [10] it is stated that the execution behavior of control constructs of the composite processes can not be suitably represented in OWL-DL: this brought to several translations of OWL-S compositions into different formalisms. The idea is that by a formalization of control structures one can reason over the definition of composite processes. One of these formalizations has been presented in [15]: the authors define a translation from DAML-S descriptions to Petri Nets and give procedures to compute composition, verification and simulation of services. However, as noted in [17], this approach only allows sequential composition of atomic services. A similar approach is presented in [17] in which OWL-S process models are encoded into state transition systems: synthesis of compositions is performed by planning techniques. This approach features the representation of non deterministic outcomes of services, complex specifications of goals and the translation of the resulting plans to executable processes. We must note that the above approaches are mostly based on the process representation of services.\nAn approach that highlights the relationships between composition and software synthesis is proposed in [11]. This approach composes services on the base of their service profiles. The idea is that Web services can be treated as software components, thus service composition can be carried out as a problem of software composition. The approach uses the Structural Synthesis Program (SSP) method [12] to extract compositions. We notice that SSP is based on the implicative part of the intuitionistic propositional calculus and it can only define sequential or conditional compositions in general.\nA different representation of semantic Web services is given by the WSMO ontology [7] and its Web service modeling language WSML. As OWL-S, these languages define services by their profiles, but WSMO does not explicitly represent the structure of composition of Web services in terms of control flow. Interactions of services are controlled by specific agents called mediators which refer to the standard execution environment WSMX.\nAs can be noted, many of the latter proposals do not base their compositions on a logic representation of pre- and post- conditions or on the function mapping inputs to outputs. Moreover, whenever a composition of sub services is defined, this does not explicitly depend on the condition stated in declarative description of the composite service. A kind of composition that depends on the formulas of service profiles can be found in the related approaches for action formalisms and planning over description logics as in [2, 6, 8, 14]. However, classical planning techniques mostly generate sequences of services achieving a goal: as noted in [17], this can be limiting in practical cases when one needs to distinguish between different condition cases and represent sequence constraints between goals.\nTo compare our approach with the ones cited above, we remark that SC assures that the composite service specification (the service profile) directly follows from composition proof. The correctness of compositions can be checked directly by verifying the applicability conditions of the rules used in the composition: moreover, our rules directly represent common control structures, thus allowing to represent complex compositions.\nEven if in this paper we detailed manual composition of services, by implementing SC we would obtain a method for automatic composition. For an actual implementation of our calculus we need both an implementation of BCDL0 and a method to convert in our formalism the service descriptions from specification languages as OWL-S that preserves their intended semantics. The main limitation of our approach stands in the restricted expressivity of the description logic at its base, that represents a small fragment of the actual expressivity of current ontology languages. In order to define a calculus for automatic composition, in our future work we plan to study the properties of SC and of its underlying constructive description logic BCDL0. In particular, we remark that BCDL0 is related to the logic KALC [4] for which we already presented a decidable tableaux calculus: moreover, it can be shown that the derived tableaux procedure is Pspace-complete, as in the case of satisfiability procedures for classical ALC [16]. The relations between BCDL0, BCDL and KALC will be subject of our future investigations. On the other hand, in order to evaluate the properties of the composition calculus, we also intend to examine its relations with software synthesis and action formalisms."
    } ],
    "references" : [ {
      "title" : "editors",
      "author" : [ "F. Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. Patel-Schneider" ],
      "venue" : "The Description Logic Handbook: Theory, Implementation, and Applications. Cambridge University Press,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "A description logic based approach to reasoning about web services",
      "author" : [ "F. Baader", "C. Lutz", "M. Milicic", "U. Sattler", "F. Wolter" ],
      "venue" : "In WSS2005, Chiba City, Japan,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "A decidable constructive description logic",
      "author" : [ "L. Bozzato", "M. Ferrari", "C. Fiorentini", "G. Fiorino" ],
      "venue" : "In JELIA 2010, Lecture Notes in Computer Science. SpringerVerlag,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "editors",
      "author" : [ "D. Calvanese", "E. Franconi", "V. Haarslev", "D. Lembo", "B. Motik", "S. Tessaris", "A. Turhan" ],
      "venue" : "Proceedings of the 20th International Workshop on Description Logics, volume 250 of CEUR Workshop Proceedings. CEUR-WS.org,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "The Web Service Modeling Language WSML: An Overview",
      "author" : [ "J. de Bruijn", "H. Lausen", "A. Polleres", "D. Fensel" ],
      "venue" : "In ESWC 2006,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2006
    }, {
      "title" : "Integrating action calculi and description logics",
      "author" : [ "C. Drescher", "M. Thielscher" ],
      "venue" : "In KI 2007, volume 4667 of Lecture Notes in Computer Science, pages 68–83. Springer-Verlag,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "BCDL: Basic Constructive Description Logic",
      "author" : [ "M. Ferrari", "C. Fiorentini", "G. Fiorino" ],
      "venue" : "Journal of Automated Reasoning, 44(4):371–399,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Bringing Semantics to Web Services with OWL-S",
      "author" : [ "D. Martin", "M. Burstein", "D. McDermott", "S. McIlraith", "M. Paolucci", "K. Sycara", "D.L. McGuinness", "E. Sirin", "N. Srinivasan" ],
      "venue" : "World Wide Web, 10(3):243–277,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Value-added web services composition using automatic program synthesis",
      "author" : [ "M. Matskin", "J. Rao" ],
      "venue" : "In C. Bussler, R. Hull, S. A. McIlraith, M. E. Orlowska, B. Pernici, and J. Yang, editors, WES 2002, volume 2512 of Lecture Notes in Computer Science, pages 213–224. Springer,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Strategies of structural synthesis of programs and its extensions",
      "author" : [ "M. Matskin", "E. Tyugu" ],
      "venue" : "Computers and Artificial Intelligence, 20(1),",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Program specification and synthesis in constructive formal systems",
      "author" : [ "P. Miglioli", "U. Moscato", "M. Ornaghi" ],
      "venue" : "In LOPSTR 1991, pages 13–26. Springer-Verlag,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Simulation, verification and automated composition of web services",
      "author" : [ "S. Narayanan", "S.A. McIlraith" ],
      "venue" : "In WWW 2002, pages 77–88,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Attributive concept descriptions with complements",
      "author" : [ "M. Schmidt-Schauß", "G. Smolka" ],
      "venue" : "Artificial Intelligence, 48(1):1–26,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Automated composition of semantic web services into executable processes",
      "author" : [ "P. Traverso", "M. Pistore" ],
      "venue" : "In ISWC 2004, volume 3298 of Lecture Notes in Computer Science, pages 380–394. Springer,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "From constructivism to computer science",
      "author" : [ "A.S. Troelstra" ],
      "venue" : "Theoretical Computer Science, 211(1-2):233–252,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1999
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "The current proposals for the representation of semantic Web services, as OWL-S [10], view services as processes with pre- and post- conditions and effects.",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 10,
      "context" : "Indeed, the composition calculus we discuss in this paper is inspired by [13].",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 6,
      "context" : "The logic BCDL0 that forms the base of our proposal is a subsystem of BCDL [9], a logic based on an information terms semantics.",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 6,
      "context" : "Moreover, how discussed in [9] this logic supports the proofs-as-programs paradigm.",
      "startOffset" : 27,
      "endOffset" : 30
    }, {
      "referenceID" : 2,
      "context" : "For our purposes, in this paper we present a natural deduction calculus for BCDL0: however, this logic can be related to KALC [4], a constructive description logic based on a Kripke-style semantics for which we provided a decidable tableaux calculus.",
      "startOffset" : 126,
      "endOffset" : 129
    }, {
      "referenceID" : 6,
      "context" : "BCDL0 is a subsystem of BCDL [9] which is the correspondent in the information terms semantics context of the basic description logic ALC [1].",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 0,
      "context" : "BCDL0 is a subsystem of BCDL [9] which is the correspondent in the information terms semantics context of the basic description logic ALC [1].",
      "startOffset" : 138,
      "endOffset" : 141
    }, {
      "referenceID" : 6,
      "context" : "The constructive interpretation of BCDL0 is based on the notion of information term [9].",
      "startOffset" : 84,
      "endOffset" : 87
    }, {
      "referenceID" : 14,
      "context" : "Intuitively, an information term α for a closed formula K is a structured object that provides a justification for the validity of K in a classical model, in the spirit of the BHK interpretation of logical connectives [18].",
      "startOffset" : 218,
      "endOffset" : 222
    }, {
      "referenceID" : 13,
      "context" : "Our example represents a reinterpretation and a formalization in our context of the “purchase and delivery service” example of [17].",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 6,
      "context" : "For a detailed presentation of the calculus and its properties we refer the reader to [9].",
      "startOffset" : 86,
      "endOffset" : 89
    }, {
      "referenceID" : 6,
      "context" : "As shown in [9] we can effectively extract from the proof π the operator ΦπN .",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 6,
      "context" : "As for the problem of automatic service composition, it can be seen as a reformulation of the program-synthesis problem, a problem which has a long tradition in the constructive logics context and which has already been studied in the framework of BCDL, see [3, 9].",
      "startOffset" : 258,
      "endOffset" : 264
    }, {
      "referenceID" : 10,
      "context" : "The composition calculus we describe in this section is inspired by PAP [13], a calculus which support program synthesis from proofs of a constructive logical system.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 7,
      "context" : "One of the most relevant proposals for the semantic description of Web services is OWL-S [10].",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 7,
      "context" : "In [10] it is stated that the execution behavior of control constructs of the composite processes can not be suitably represented in OWL-DL: this brought to several translations of OWL-S compositions into different formalisms.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 11,
      "context" : "One of these formalizations has been presented in [15]: the authors define a translation from DAML-S descriptions to Petri Nets and give procedures to compute composition, verification and simulation of services.",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 13,
      "context" : "However, as noted in [17], this approach only allows sequential composition of atomic services.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 13,
      "context" : "A similar approach is presented in [17] in which OWL-S process models are encoded into state transition systems: synthesis of compositions is performed by planning techniques.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 8,
      "context" : "An approach that highlights the relationships between composition and software synthesis is proposed in [11].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 9,
      "context" : "The approach uses the Structural Synthesis Program (SSP) method [12] to extract compositions.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 4,
      "context" : "A different representation of semantic Web services is given by the WSMO ontology [7] and its Web service modeling language WSML.",
      "startOffset" : 82,
      "endOffset" : 85
    }, {
      "referenceID" : 1,
      "context" : "A kind of composition that depends on the formulas of service profiles can be found in the related approaches for action formalisms and planning over description logics as in [2, 6, 8, 14].",
      "startOffset" : 175,
      "endOffset" : 188
    }, {
      "referenceID" : 5,
      "context" : "A kind of composition that depends on the formulas of service profiles can be found in the related approaches for action formalisms and planning over description logics as in [2, 6, 8, 14].",
      "startOffset" : 175,
      "endOffset" : 188
    }, {
      "referenceID" : 13,
      "context" : "However, classical planning techniques mostly generate sequences of services achieving a goal: as noted in [17], this can be limiting in practical cases when one needs to distinguish between different condition cases and represent sequence constraints between goals.",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 2,
      "context" : "In particular, we remark that BCDL0 is related to the logic KALC [4] for which we already presented a decidable tableaux calculus: moreover, it can be shown that the derived tableaux procedure is Pspace-complete, as in the case of satisfiability procedures for classical ALC [16].",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 12,
      "context" : "In particular, we remark that BCDL0 is related to the logic KALC [4] for which we already presented a decidable tableaux calculus: moreover, it can be shown that the derived tableaux procedure is Pspace-complete, as in the case of satisfiability procedures for classical ALC [16].",
      "startOffset" : 275,
      "endOffset" : 279
    } ],
    "year" : 2014,
    "abstractText" : "The idea of the Semantic Web is to annotate Web content and services with computer interpretable descriptions with the aim to automatize many tasks currently performed by human users. In the context of Web services, one of the most interesting tasks is their composition. In this paper we formalize this problem in the framework of a constructive description logic. In particular we propose a declarative service specification language and a calculus for service composition. We show by means of an example how this calculus can be used to define composed Web services and we discuss the problem of automatic service synthesis.",
    "creator" : "dvips(k) 5.98 Copyright 2009 Radical Eye Software"
  }
}