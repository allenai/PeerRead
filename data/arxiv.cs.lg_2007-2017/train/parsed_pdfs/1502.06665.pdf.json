{
  "name" : "1502.06665.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Reified Context Models",
    "authors" : [ "Jacob Steinhardt", "Percy Liang" ],
    "emails" : [ "JSTEINHARDT@CS.STANFORD.EDU", "PLIANG@CS.STANFORD.EDU" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Many structured prediction tasks across natural language processing, computer vision, and computational biology can be formulated as that of learning a distribution over outputs y1:L = (y1, . . . , yL) ∈ Y1:L given an input x:\npθ(y1:L | x) ∝ exp ( L∑ i=1 θ>φi(y1:i−1, yi, x) ) . (1)\nThe thirst for expressive models (e.g., where yi depends heavily on its context y1:i−1) often leads one down the route of approximate inference, for example, to Markov chain Monte Carlo (Brooks et al., 2011), sequential Monte Carlo (Cappé et al., 2007; Doucet & Johansen, 2011), or beam search (Koehn et al., 2003). While these methods in principle can operate on models with arbitrary amounts of context, they only touch a small portion of the output space Y1:L. Without such coverage, we miss out on two important but oft-neglected properties:\n• precision: In user-facing applications, it is important to only predict on inputs where the system is confident, leaving hard decisions to the user (Zhang et al., 2014). Lack of coverage means failing to consider all alterna-\ntive outputs, which leads to overconfidence and poor estimates of uncertainty. • indirect supervision: When only part of the output y1:L\nis observed, lack of coverage is even more problematic than it is in the fully-supervised setting. An approximate inference algorithm might not even consider the true y (whereas one always has the true y in a fully-supervised setting), which leads to invalid parameter updates (Yu et al., 2013).\nOf course, lower-order models admit exact inference and ensure coverage, but these models have unacceptably low expressive power. Ideally, we would like a model that varies the amount of context in a judicious way, allocating modeling power to parts of the input that demand it. Therein lies the principal challenge: How can we adaptively choose the amount of context for each position i in a data-dependent way while maintaining tractability?\nIn this paper, we introduce a new approach, which we call reified context models. The key idea is based on reification, a general idea in logic and programming languages, which refers to making something previously unaccessible (e.g., functions or metadata of functions) a “first-class citizen” and therefore available (e.g., via lambda abstraction or reflection) to formal manipulation. In the probabilistic modeling setting, we propose reifying the contexts as random variables in the model so that we can reason over them.\nar X\niv :1\n50 2.\n06 66\n5v 1\n[ cs\n.L G\n] 2\n4 Fe\nb 20\n15\nSpecifically, for each i ∈ {1, . . . , L − 1}, we maintain a collection Ci of contexts, each of which is a subset of Y1:i representing what we remember about the past (see Figure 1 for an example). We define a joint model over (y, c), suppressing x for brevity:\npθ(y1:L, c1:L−1) ∝ exp ( L∑ i=1 θ>φi(ci−1, yi) ) × κ(y, c),\n(2) where κ is a consistency potential, to be explained later. The features φi now depend on the current context ci−1, rather than the full history y1:i−1. The distribution over (y, c) factorizes according to the graphical model below:\nY1 Y2 Y3 Y4 Y5\nC1 C2 C3 C4\n(3)\nThe factorization (3) implies that the family in (2) admits efficient exact inference via the forward-backward algorithm as long as each collection Ci has small cardinality.\nAdaptive selection of context. Given limited computational resources, we only want to track contexts that are reasonably likely to contain the answer. We do this by selecting the context sets Ci during a forward pass using a heuristic similar to beam search, but unlike beam search, we achieve coverage because we are selecting contexts rather than individual variable values. We detail our selection method, called RCMS, in Section 4. We can think of selecting the Ci’s as selecting a model to perform inference in, with the guarantee that all such models will be tractable. Our method is simple to implement; see the appendix for implementation details.\nThe goal of this paper is to flesh out the framework described above, providing intuitions about its use and exploring its properties empirically. To this end, we start in Section 2 by defining some tasks that motivate this work. In Sections 3 and 4 we introduce reified context models formally, together with an algorithm, RCMS, for selecting contexts adaptively at run-time. Sections 5-7 explore the empirical properties of the RCMS method. Finally, we discuss future research directions in Section 9."
    }, {
      "heading" : "2. Description of Tasks",
      "text" : "To better understand the motivation for our work, we present three tasks of interest, which are also the tasks used in our empirical evaluation later. These tasks are word recognition (a fully supervised task), speech recognition (a weakly supervised task), and decipherment (an unsupervised task). The first of these tasks is relatively easy while\nthe latter two are harder. We use word recognition to study the precision of our method, the other two tasks to explore learning under indirect supervision, and all three to understand how our algorithm selects contexts during training.\nWord recognition The first task is the word recognition task from Kassel (1995); we use the “clean” version of the dataset as in Weiss et al. (2012). This contains 6, 876 examples, split into 10 folds (numbered 0 to 9); we used fold 1 for testing and the rest for training. Each input is a sequence of 16× 8 binary images of characters; the output is the word that those characters spell. The first character is omitted due to capitalization issues. Since this task ended up being too easy as given, we downsampled each image to be 8× 4 (by taking all pixels whose coordinates were both odd). An example input and output is given below:\ninput x output y r o j e c t i o n s\nEach individual image is too noisy to interpret in isolation, and so leveraging the context of the surrounding characters is crucial to achieving high accuracy.\nSpeech recognition Our second task is from the Switchboard speech transcription project (Greenberg et al., 1996). The dataset consists of 999 utterances, split into two chunks of sizes 746 and 253; we used the latter chunk as a test set. Each utterance is a phonetic input and textual output:\ninput x h# y ae ax s w ih r dcl d h# latent z (alignment) output y yeah it’s weird\nThe alignment between the input and output is unobserved.\nThe average input length is 26 phonemes, or 2.5 seconds of speech. We removed most punctuation from the output, except for spaces, apostrophes, dashes, and dots.\nDecipherment Our final task is a decipherment task similar to that described in Nuhn & Ney (2014). In decipherment, one is given a large amount of plain text and a smaller amount of cipher text; the latter is drawn from the same distribution as the former but is then passed through a 1-to-1 substitution cipher. For instance, the plain text sentence “I am what I am” might be enciphered as “13 5 54 13 5”:\nlatent z I am what I am output y 13 5 54 13 5\nThe task is to reverse the substitution cipher, e.g. determine that 13 7→ I , 5 7→ am, etc.\nWe extracted a dataset from the English Gigaword corpus (Graff & Cieri, 2003) by finding the 500 most common\nwords and filtering for sentences that only contained those words. This left us with 24, 666 utterances, of which 2, 000 were enciphered and the rest were left as plain text.\nNote that this task is unsupervised, but we can hope to gain information about the cipher by looking at various statistics of the plaintext and ciphertext. For instance, a very basic idea would be to match words based on their frequency. This alone doesn’t work very well, but by considering bigram and trigram statistics we can do much better."
    }, {
      "heading" : "3. Reified Context Models",
      "text" : "We now formally introduce reified context models. Our setup is structured prediction, where we predict an output (y1, . . . , yL) ∈ Y1 × · · · × YL; we abbreviate these as y1:L and Y1:L. While this setup assumes a generative model, we can easily handle discriminative models as well as a variable length L; we ignore these extensions for simplicity.\nOur framework reifies the idea of context as a tool for efficient inference. Informally, a context for Yi is information that we remember about Y1:i−1. In our case, a context ci−1 is a subset of Y1:i−1, which should contain y1:i−1: in other words, ci−1 is “remembering” that y1:i−1 ∈ ci−1. A context set Ci−1 is a collection of possible values for ci−1.\nFormally, we define a canonical context set Ci to be a collection of subsets of Y1:i satisfying two properties:1\n• coverage: Y1:i ∈ Ci • closure: for c, c′ ∈ Ci, c ∩ c′ ∈ Ci ∪ {∅}\nAn example of such a collection is given in Figure 2; as in Section 1, notation such as ??a denotes the subset of Y1:3 where y3 = a.\nWe refer to each element of Ci as a “context”. Given a sequence y1:L, we need to define contexts c1:L−1 such that y1:i ∈ ci for all i. The coverage property ensures that some such context always exists: we can take ci = Y1:i.\nIn reality, we would like to use the smallest (most precise) context ci possible; the closure property ensures that this is canonically defined: given a context ci−1 ∈ Ci−1 and a value yi ∈ Yi, we inductively define ci = fi(ci−1, yi) to be the intersection of all c ∈ Ci that contain ci−1×{yi}, or equivalently the smallest such c. Example evaluations of f are provided in Figure 2. Note that y1:i ∈ ci always.\nWe now define a joint model over the variables y1:L and\n1 This is similar to the definition of a hierarchical decomposition from Steinhardt & Liang (2014). Our closure condition replaces the more restrictive condition that c ∩ c′ ∈ {c, c′, ∅}.\ncontexts c1:L−1:\npθ(y1:L, c1:L−1) ∝ exp ( L∑ i=1 θ>φi(ci−1, yi) ) × κ(y, c),\nwhere κ(y, c) def= ∏L−1 i=2 I[ci = fi(ci−1, yi)] enforces consistency of contexts. The distribution pθ factors according to (3). One consequence of this is that the variables y1:L are jointly independent given c1:L−1: the contexts contain all information about interrelationships between the yi.\nMathematically, the model above is similar to a hidden Markov model where ci is the hidden state. However, we choose the context sets adaptively, giving us much greater expressive power than an HMM, since we essentially have exponentially many choices of hidden states (canonical context sets) to select from at runtime.\nExample: 2nd-order Markov chain. To provide more intuition, we construct a 2nd-order Markov chain using our framework (we can construct nth-order Markov chains in the same way). We would like Ci to “remember” the previous 2 values, i.e. (yi−1, yi). To do this, we let Ci consist of all sets of the form Y1:i−2 × {(yi−1, yi)}; these sets fix the value of (yi−1, yi) while allowing y1:i−2 to vary freely. Then fi+1(ci, yi+1) = Y1:i−1×{(yi, yi+1)}, which is well-defined since yi can be determined from ci.\nIf |Yi| = V , then |Ci| = V 2 (or V n for nth-order chains), reflecting the cost of inference in such models.\nAs a technical note, we also need to include Y1:i in Ci to satisfy the coverage condition. However, Y1:i will never actually appear as a context, as can be seen by the preceding definition of f .\nTo finish the construction, suppose we have a family of 2nd-order Markov chains parameterized as\npθ(y1:n) ∝ exp ( L∑ i=1 θ>φi((yi−2, yi−1), yi) ) . (4)\nSince φi depends only on (yi−2, yi−1), which can be determined from ci−1, we can define an equivalent function\nφ̃i(ci−1, yi). Doing so, we recover a model family equivalent to (4) after marginalizing out c1:L−1 (since c1:L−1 is a deterministic function of y1:L, this last step is trivial)."
    }, {
      "heading" : "4. Adaptive Context Sets",
      "text" : "The previous section shows how to define a tractable model for any collection of canonical context sets Ci. We now show how to choose such sets adaptively, at run-time. We use a heuristic motivated by beam search, which greedily chooses the highest-scoring configurations of y1:i based on an estimate of their mass. We work one level of abstraction higher, choosing contexts instead of configurations; this allows us to maintain coverage while still being adaptive.\nOur idea has already been illustrated to an extent in Figures 1 and 2: if some of our contexts are very coarse (such as ??? in Figure 2) and others are much finer (such as abc in Figure 2), then we can achieve coverage of the space while still modeling complex dependencies. We will do this by allowing each context c ∈ Ci to track a suffix of y1:i of arbitrary length; this contrasts with the Markov chain example where we always track suffixes of length 2.\nPrecise contexts expose more information about y1:i and so allow more accurate modeling; however, they are small and Ci is necessarily limited in size, so only a small part of the space can be precisely modeled in this way. We thus want to choose contexts that focus on high probability regions.\nOur procedure. To do this, we define the partial model\nqiθ(y1:i, c1:i−1) ∝ exp  i∑ j=1 θ>φj(cj−1, yj) × κ(y, c). We then define the context sets inductively via the following procedure, which takes as input a context size B:\n• Let C̃i = {ci−1 × {yi} | ci−1 ∈ Ci−1, yi ∈ Yi}. • Compute the mass of each element of C̃i under qiθ. • Let Ci be the B elements of C̃i with highest mass, to-\ngether with the set Y1:i.\nThe remaining elements of C̃i will effectively be merged into their least ancestor in Ci. Note that each c ∈ Ci fixes the value of some suffix yj:i of y1:i, and allows y1:j−1 to vary freely across Y1:j−1. Any such collection will automatically satisfy the closure property.\nThe above procedure can be performed during the forward pass of inference, and so is cheap computationally. Implementation details can be found in the appendix. We call this procedure RCMS (short for “Reified Context Model Selection”).\nCaveat. There is no direct notion of an inference error in the above procedure, since exact inference is possible by design. An indirect notion of inference error is poor choice of contexts, which can lead to less accurate predictions."
    }, {
      "heading" : "4.1. Relationship to beam search",
      "text" : "The idea of greedily selecting contexts based on qiθ is similar in spirit to beam search, an approximate inference algorithm that greedily selects individual values of y1:i based on qiθ. More formally, beam search maintains a beam Bi ⊆ Y1:i of size B, constructed as follows:\n• Let B̃i = Bi−1 × Yi. • Compute the mass of each element of B̃i under qiθ. • Let Bi be the B elements of B̃i with highest mass.\nThe similarity can be made precise: beam search is a degenerate instance of our procedure. Given Bi, let Ci = {{b} | b ∈ Bi} ∪ {Y1:i}. Then Ci consists of singleton sets for each element of Bi, together with Y1:i in order to ensure coverage. To get back to beam search (which doesn’t have coverage), we add an additional feature to our model: I[ci = Y1:i]. We set the weight of this feature to −∞, assigning zero mass to everything outside of Bi.\nGiven any algorithm based on beam search, we can improve it simply by allowing the weight on this additional feature to be learned from data. This can help with the precision ceiling issue by allowing us to reason about when beam search is likely to have made a search error."
    }, {
      "heading" : "4.2. Featurizations",
      "text" : "We end this section with a recipe for choosing features φi(ci−1, yi). We focus on n-gram and alignment features, which are what we use in our experiments.\nn-gram features. We consider nth-order Markov chains over text, typically featurized by (n+ 1)-grams:\nφi(y1:i−1, yi) = ( I[yi−n:i = ŷ] ) ŷ∈Yi−n:i . (5)\nTo extend this to our setting, define Yi = Yi ∪ {?} and Y1:i = ∏i j=1 Yi. We can identify each pair (ci−1, yi) with a sequence s = σ(ci−1, yi) ∈ Yi in the same way as before: in each position j ≤ i where yj is determined by (ci−1, yi), sj = yj ; otherwise, sj = ?. We then define our n-gram model on the extended space Yi−n:i:\nφi(ci−1, yi) = ( I[σ(ci−1, yi) = ŷ] ) ŷ∈Yi−n:i . (6)\nAlignments. In the speech task from Section 2, we have an input x1:L′ and output y1:L, where x and y have different lengths and need to be aligned. To capture this, we add an alignment z to the model, such as the one below:\naligned input h# y ae ax s w ih r dcl d h# aligned output y eah it ’ s w ei r d\nWe represent z as a bipartite graph between {1, . . . , L} and {1, . . . , L′} with no crossing edges, and where every node has degree at least one. The non-crossing condition allows one phoneme to align to multiple characters, or one character to align to multiple phonemes, but not both. Our goal is to model pθ(y, z | x).\nTo featurize alignment models, we place n-gram features on the output yi, as well as on every group of n consecutive edges. In addition, we augment the context ci to keep track of what yi most recently aligned to (so that we can ensure the alignment is monotonic). We also maintain the B best contexts at position i separately for each of the L′ possible values of zi; this modification to the RCMS heuristic encourages even coverage of the space of alignments."
    }, {
      "heading" : "5. Generating High Precision Predictions",
      "text" : "Recall that one symptom stemming from a lack of coverage is poor estimates of uncertainty and the inability to generate high precision predictions. In this section, we show that the coverage offered by RCMS mitigates this issue compared to beam search.\nSpecifically, we are interested in whether an algorithm can find a large subset of test examples that it can classify with high (≈ 99%) accuracy. Formally, assume a method outputs a prediction y with confidence p ∈ [0, 1] for each example. We sort the examples by confidence, and see what fraction R of examples we can answer before our accuracy drops below a given threshold P . In this case, P is the precision and R is the recall.\nHaving good recall at high levels of precision (e.g., P = 0.99) is useful in applications where we need to pass on predictions below the precision threshold for a human to verify, but where we would still like to classify as many examples as possible automatically.\nWe ran an experiment on the word recognition dataset described in Section 2. We used a 4-gram model, training both beam search (with a beam size of 10) and RCMS (with 10 contexts per position, not counting Y1:i). In addition, we used beam search with a beam size of 200 to simulate almost-exact inference. To train the models, we maximized the approximate log-likelihood using AdaGrad (Duchi et al., 2010) with a step size η of 0.2 and δ = 10−4.\nThe precision-recall curve for each method is plotted in Figure 3; confidence is the probability the model assigns to the predicted output. Note that while beam search and RCMS achieve similar accuracies (precision at R = 1) on the full test set (87.1% and 88.5%, respectively), RCMS is much better at separating out examples that are likely to\nbe correct. The flat region in the precision-recall curve for beam search means that the model confidence and actual error probability are unrelated across that region.\nAs a result, there is a precision ceiling, where it is simply impossible to obtain high precision at any reasonable level of recall. To quantify this effect, note that the recall at 99% precision for beam search is only 16%, while for RCMS it is 82%. For comparison, the recall for exact inference is only 4% higher (86%). Therefore, RCMS is nearly as effective as exact inference on this metric while requiring substantially fewer computational resources."
    }, {
      "heading" : "6. Learning with Indirect Supervision",
      "text" : "The second symptom of lack of coverage is the inability to learn from indirect supervision. In this setting, we have an exponential family model pθ(y, z | x) ∝ exp(θ>φ(x, y, z)), where x and y are observed during training but z is unobserved. The gradient of the (marginal) log-likelihood is:\n∇ log pθ(y | x) = Eẑ∼pθ(z|x,y) [φ(x, y, ẑ)] (7) − Eŷ,ẑ∼pθ(y,z|x) [φ(x, ŷ, ẑ)] ,\nwhich is the difference between the expected features with respect to the target distribution pθ(z | x, y) and the model distribution pθ(y, z | x). In the fully supervised case, where we observe z, the target term is simply φ(x, y, z), which provides a clear training signal without any inference. With indirect supervision, even obtaining a training signal requires inference with respect to pθ(z | x, y), which is generally intractable.\nIn the context of beam search, there are several strategies\nto inferring z for computing gradients:\n• Select-by-model: select beams based on qiθ(z |x), then re-weight at the end by pθ(y | z, x). This only works if the weights are high for at least some “easy” examples, from which learning can then bootstrap. • Select-by-target: select beams based on qiθ(z | x, y).\nSince y is not available at test time, parameters θ learned conditioned on y do not generalize well. • Hybrid: take the union of beams based on both the\nmodel and target distributions. • Forced decoding (Gorman et al., 2011): first train a\nsimple model for which exact inference is tractable to infer the most likely z, conditioned on x and y. Then simply fix z; this becomes a fully-supervised problem.\nTo understand the behavior of these methods, we used them all to train a model on the speech recognition dataset from Section 2. The model places 5-gram indicator features on the output as well as on the alignments. We trained using AdaGrad with step size η = 0.2 and δ = 10−4. For each method, we set the beam size to 20. For forced decoding, we used a bigram model with exact inference to impute z at the beginning.\nThe results are shown in Figure 4(a). Select-by-model doesn’t learn at all: it only finds valid alignments for 2 out of the 746 training examples; for the rest, pθ(y | z, x) is zero for all alignments considered, thus providing no signal for learning. Select-by-target quickly reaches high training accuracy, but generalizes extremely poorly because it doesn’t learn to keep the right answer on the beam. The hybrid approach does better but still not very well. The only method that learns effectively is forced decoding.\nWhile forced decoding works well, it relies on the idea that a simple model can effectively determine z given access to x and y. This will not always be the case, so we would like methods that work well even without such a model. Reified context models provide a natural way of doing this: we simply compute pθ(z | x, y) under the contexts selected by RCMS, and perform learning updates in the natural way.\nTo test RCMS, we trained it in the same way using 20 contexts per position. Without any need for an initialization scheme, we obtain a model whose test accuracy is better than that of forced decoding (see Figures 4(b),4(c)).\nDecipherment: Unsupervised Learning. We now turn our attention to an unsupervised problem: the decipherment task from Section 2. We model decipherment as a hidden Markov model (HMM): the hidden plain text evolves according to an n-th order Markov chain, and the cipher text is emitted based on a deterministic but unknown 1:1 substitution cipher (Ravi & Knight, 2009).\nAll the methods we described for speech recognition break down in the absence of any supervision except select-bymodel. We therefore compare only three methods: selectby-model (beam search), RCMS, and exact inference. We trained a 1st-order (bigram) HMM using all 3 methods, and a 2nd-order (trigram) HMM using only beam search and RCMS, as exact inference was too slow (the vocabulary size is 500). We used the given plain text to learn the transition probabilities, using absolute discounting (Ney et al., 1994) for smoothing. Then, we used EM to learn the transition probabilities; we used Laplace smoothing for these updates.\nThe results are shown in Figure 5. We measured performance by mapping accuracy: the fraction of unique symbols that are correctly mapped (Nuhn et al., 2013). First, we compared the overall accuracy of all methods, setting the beam size and context size both to 60. We see that all 2nd-order models outperform all 1st-order models, and that beam search barely learns at all for the 1st-order model.\nRestricting attention to 2nd-order models, we measure the effect of beam size and context size on accuracy, plotting learning curves for sizes of 10, 20, 30, and 60. In all cases, RCMS learns more quickly and converges to a more accurate solution than beam search. The shapes of the learning curves are also different: RCMS learns quickly after a few initial iterations, while beam search slowly accrues information at a roughly constant rate over time."
    }, {
      "heading" : "7. Refinement of Contexts During Training",
      "text" : "When learning with indirect supervision and approximate inference, one intuition is that we can “bootstrap” by first learning from easy examples, and then using the information gained from these examples to make better inferences about the remaining ones (Liang et al., 2011). However, this can fail if there are insufficiently many easy examples (as in the speech task), if the examples are hard to identify, or if they differ statistically from the remaining examples.\nWe think of the above as “vertical bootstrapping”: using the full model on an increasing number of examples. RCMS instead performs “horizontal bootstrapping”: for each example, it selects a model (via the context sets) based on the information available. As training progresses, we expect these contexts to become increasingly fine as our parameters improve.\nTo measure this quantitatively, we define the length of a context ci−1 to be the number of positions of y1:i−1 that can be determined from ci−1 (number of non-?’s). We plot the average length (weighted by mass under qiθ) as training progresses. The averages are updated every 50 and 100 training examples respectively for word and speech recognition. For decipherment, they are computed once for each\nfull pass over the training data (since EM only updates the parameters once per pass).\nFigure 6 shows that the broad trend is an increase in the context length over time. For both the word and speech tasks, there is an initial overshoot at the beginning that is not present in the decipherment task; this is because the word and speech tasks are trained with stochastic gradient methods, which often overshoot and then correct in parameter space, while for decipherment we use the more stable EM algorithm.\nSince we start by using coarse contexts and move to finer contexts by the end of training, RCMS can be thought of as a coarse-to-fine training procedure (Petrov & Charniak, 2011). However, instead of using a pre-defined, discrete set of models for initialization, we organically adapt the amount of context on a per-example basis."
    }, {
      "heading" : "8. Related work",
      "text" : "Kulesza & Pereira (2007) first study the interaction be-\ntween approximate inference and learning, showing that even in the fully supervised case approximate inference can be seriously detrimental; Finley & Joachims (2008) show that approximate inference algorithms which overgenerate possible outputs interact best with learning; this further supports the need for coverage when learning.\nFour major approaches have been taken to address the problem of learning with inexact inference. The first modifies the learning updates to account for the inference procedure, as in the max-violation perceptron and related algorithms (Huang et al., 2012; Zhang et al., 2013; Yu et al., 2013); reinforcement learning approaches to inference (Daumé III et al., 2009; Shi et al., 2015) also fit into this category. Another approach modifies the inference algorithm to obtain better coverage, as in coarse-to-fine inference (Petrov et al., 2006; Weiss et al., 2010), where simple models are used to direct the focus of more complex models. Pal et al. (2006) encourage coverage for beam search by adaptively increasing the beam size. A third approach is to use inference procedures with certificates of optimality, based on either\nduality gaps from convex programs (Sontag, 2010) or variational bounds (Xing et al., 2002; Wainwright et al., 2005).\nFinally, another way of sidestepping the problems of approximate inference is to learn a model that is already tractable. While classical tractable model families based on low treewidth are often insufficiently expressive, more modern families have shown promise; for instance, sumproduct networks (Poon & Domingos, 2011) can express models with high treewidth while still being tractable, and have achieved state-of-the-art results for some tasks. Other work includes exchangeable variable models (Niepert & Domingos, 2014) and mean-field networks (Li & Zemel, 2014).\nOur method RCMS also attempts to define tractable model families, in our case, via a parsimonious choice of latent context variables, even though the actual distribution over y1:L may have arbitrarily high treewidth. We adaptively choose the model structure for each example at “runtime”, which distinguishes our approach from the aforementioned methods, though sum-product networks have some capacity for expressing adaptivity implicitly. We believe that such per-example adaptivity is important for obtaining good performance on challenging structured prediction tasks.\nCertain smoothing techniques in natural language processing also interpolate between contexts of different order, such as absolute discounting (Ney et al., 1994) and KneserNey smoothing (Kneser & Ney, 1995). However, in such cases all observed contexts are used in the model; to get the same tractability gains as we do, it would be necessary to adaptively sparsify the model for each example at run-time. Some Bayesian nonparametric approaches such as infinite contingent Bayesian networks (Milch et al., 2005) and hierarchical Pitman-Yor processes (Teh, 2006; Wood et al., 2009) also reason about contexts; again, such models do not lead to tractable inference."
    }, {
      "heading" : "9. Discussion",
      "text" : "We have presented a new framework, reified context models, that reifies context as a random variable, thereby defining a family of expressive but tractable probability distributions. By adaptively choosing context sets at run-time, our RCMS method uses short contexts in regions of high uncertainty and long contexts in regions of low uncertainty, thereby reproducing the behavior of coarse-to-fine training methods in a more organic and fine-grained manner. In addition, because RCMS maintains full coverage of the space, it is able to break through the precision ceiling faced by beam search. Coverage also helps with training under indirect supervision, since we can better identify settings of latent variables that assign high likelihood to the data.\nAt a high level, our method provides a framework for structuring inference in terms of the contexts it considers; because the contexts are reified in the model, we can also support queries about how much probability mass lies in each context. These two properties together open up intriguing possibilities. For instance, one could imagine a multi-pass approach to inference where the first pass uses small context sets for each location, and later passes add additional contexts at locations where there is high uncertainty. By adaptively adding context only when it is needed, we could speed up inference by a potentially large amount.\nAnother direction of research is to extend our construction beyond a single left-to-right ordering. In principle, we can consider any collection of contexts that induce a graphical model with low treewidth, rather than only considering the factorization in (3). For problems such as image segmentation where the natural structure is a grid rather than a chain, such extensions may be necessary.\nFinally, while we currently learn how much weight to assign to each context, we could go one step further and learn which contexts to propose and include in the context sets Ci (rather than relying on a fixed procedure as in the RCMS algorithm). Ideally, one could specify a large number of possible strategies for building context sets, and the best strategy to use for a given example would be learned from\ndata. This would move us one step closer to being able to employ arbitrarily expressive models with the assurance of an automatic inference procedure that can take advantage of the expressivity in a reliable manner."
    }, {
      "heading" : "B. Further Details of Experimental Setup",
      "text" : "We include here a few experimental details that did not fit into the main text. When training with AdaGrad, we performed several stochastic gradient updates in parallel, similar to the approach described in Recht et al. (2011) (although we parallelized even more aggressively at the expense of theoretical guarantees). We also used a randomized truncation scheme to round most small coordinates of the gradients to zero, which substantially reduces memory usage as well as concurrency overhead.\nFor decipherment, we used absolute discounting with discount 0.25 and smoothing 0.01, and Laplace smoothing with parameter 0.01. For the 1st-order model, beam search performs better if we use Laplace smoothing instead of absolute discounting (though still worse than RCMS). In order to maintain a uniform experimental setup, we excluded this result from the main text.\nFor the hybrid selection algorithm in the speech experiments, we take the union of the beams at every step (as opposed to computing two sets of beams separately and then taking a single union at the end)."
    }, {
      "heading" : "C. Additional Files",
      "text" : "In the supplementary material, we also include the source code and datasets for the decipherment task. A README is included to explain how to run these experiments."
    } ],
    "references" : [ {
      "title" : "An overview of existing methods and recent advances in sequential Monte Carlo",
      "author" : [ "Cappé", "Olivier", "Godsill", "Simon J", "Moulines", "Eric" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "Cappé et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Cappé et al\\.",
      "year" : 2007
    }, {
      "title" : "Search-based structured prediction",
      "author" : [ "Daumé III", "Hal", "Langford", "John", "Marcu", "Daniel" ],
      "venue" : "Machine learning,",
      "citeRegEx" : "III et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "III et al\\.",
      "year" : 2009
    }, {
      "title" : "A tutorial on particle filtering and smoothing: Fifteen years later",
      "author" : [ "Doucet", "Arnaud", "Johansen", "Adam M" ],
      "venue" : "In Oxford Handbook of Nonlinear Filtering. Citeseer,",
      "citeRegEx" : "Doucet et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Doucet et al\\.",
      "year" : 2011
    }, {
      "title" : "Adaptive subgradient methods for online learning and stochastic optimization",
      "author" : [ "J. Duchi", "E. Hazan", "Y. Singer" ],
      "venue" : "In Conference on Learning Theory (COLT),",
      "citeRegEx" : "Duchi et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Duchi et al\\.",
      "year" : 2010
    }, {
      "title" : "Training structural svms when exact inference is intractable",
      "author" : [ "Finley", "Thomas", "Joachims", "Thorsten" ],
      "venue" : "In Proceedings of the 25th international conference on Machine learning,",
      "citeRegEx" : "Finley et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Finley et al\\.",
      "year" : 2008
    }, {
      "title" : "Prosodylab-aligner: A tool for forced alignment of laboratory speech",
      "author" : [ "Gorman", "Kyle", "Howell", "Jonathan", "Wagner", "Michael" ],
      "venue" : "Canadian Acoustics,",
      "citeRegEx" : "Gorman et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Gorman et al\\.",
      "year" : 2011
    }, {
      "title" : "Insights into spoken language gleaned from phonetic transcription of the switchboard corpus",
      "author" : [ "Greenberg", "Steven", "Hollenback", "Joy", "Ellis", "Dan" ],
      "venue" : "In Proceedings of the International Conference on Spoken Language Processing,",
      "citeRegEx" : "Greenberg et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Greenberg et al\\.",
      "year" : 1996
    }, {
      "title" : "Structured perceptron with inexact search",
      "author" : [ "Huang", "Liang", "Fayong", "Suphan", "Guo", "Yang" ],
      "venue" : "In Proceedings of the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,",
      "citeRegEx" : "Huang et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Huang et al\\.",
      "year" : 2012
    }, {
      "title" : "A comparison of approaches to on-line handwritten character recognition",
      "author" : [ "Kassel", "Robert H" ],
      "venue" : "PhD thesis, Massachusetts Institute of Technology,",
      "citeRegEx" : "Kassel and H.,? \\Q1995\\E",
      "shortCiteRegEx" : "Kassel and H.",
      "year" : 1995
    }, {
      "title" : "Improved backingoff for m-gram language modeling",
      "author" : [ "Kneser", "Reinhard", "Ney", "Hermann" ],
      "venue" : "In Acoustics, Speech, and Signal Processing,",
      "citeRegEx" : "Kneser et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Kneser et al\\.",
      "year" : 1995
    }, {
      "title" : "Statistical phrase-based translation",
      "author" : [ "Koehn", "Philipp", "Och", "Franz Josef", "Marcu", "Daniel" ],
      "venue" : "In Proceedings of the 2003 Conference of the North American Chapter of the Association for Computational Linguistics on Human Language Technology-Volume",
      "citeRegEx" : "Koehn et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Koehn et al\\.",
      "year" : 2003
    }, {
      "title" : "Structured learning with approximate inference",
      "author" : [ "Kulesza", "Alex", "Pereira", "Fernando" ],
      "venue" : "In Advances in neural information processing systems,",
      "citeRegEx" : "Kulesza et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Kulesza et al\\.",
      "year" : 2007
    }, {
      "title" : "Learning dependency-based compositional semantics",
      "author" : [ "P. Liang", "M.I. Jordan", "D. Klein" ],
      "venue" : "In Association for Computational Linguistics (ACL), pp",
      "citeRegEx" : "Liang et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Liang et al\\.",
      "year" : 2011
    }, {
      "title" : "Approximate inference for infinite contingent bayesian networks",
      "author" : [ "Milch", "Brian", "Marthi", "Bhaskara", "Sontag", "David", "Russell", "Stuart", "Ong", "Daniel L", "Kolobov", "Andrey" ],
      "venue" : "In Proc. 10th AISTATS,",
      "citeRegEx" : "Milch et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Milch et al\\.",
      "year" : 2005
    }, {
      "title" : "On structuring probabilistic dependences in stochastic language modelling",
      "author" : [ "Ney", "Hermann", "Essen", "Ute", "Kneser", "Reinhard" ],
      "venue" : "Computer Speech & Language,",
      "citeRegEx" : "Ney et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Ney et al\\.",
      "year" : 1994
    }, {
      "title" : "Exchangeable variable models",
      "author" : [ "Niepert", "Mathias", "Domingos", "Pedro" ],
      "venue" : "arXiv preprint arXiv:1405.0501,",
      "citeRegEx" : "Niepert et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Niepert et al\\.",
      "year" : 2014
    }, {
      "title" : "Improved decipherment of homophonic ciphers",
      "author" : [ "Nuhn", "Malte", "Ney", "Hermann" ],
      "venue" : "In Conference on Empirical Methods in Natural Language Processing,",
      "citeRegEx" : "Nuhn et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Nuhn et al\\.",
      "year" : 2014
    }, {
      "title" : "Beam search for solving substitution ciphers",
      "author" : [ "Nuhn", "Malte", "Schamper", "Julian", "Ney", "Hermann" ],
      "venue" : "In Annual Meeting of the Assoc. for Computational Linguistics,",
      "citeRegEx" : "Nuhn et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Nuhn et al\\.",
      "year" : 2013
    }, {
      "title" : "Sparse forward-backward using minimum divergence beams for fast training of conditional random fields",
      "author" : [ "Pal", "Chris", "Sutton", "Charles", "McCallum", "Andrew" ],
      "venue" : "In IEEE International Conference on Acoustics, Speech and Signal Processing,",
      "citeRegEx" : "Pal et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Pal et al\\.",
      "year" : 2006
    }, {
      "title" : "Coarse-to-fine natural language processing",
      "author" : [ "Petrov", "Slav", "Charniak", "Eugene" ],
      "venue" : "Springer Science & Business Media,",
      "citeRegEx" : "Petrov et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Petrov et al\\.",
      "year" : 2011
    }, {
      "title" : "Sum-product networks: A new deep architecture",
      "author" : [ "Poon", "Hoifung", "Domingos", "Pedro" ],
      "venue" : "In Computer Vision Workshops (ICCV Workshops),",
      "citeRegEx" : "Poon et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Poon et al\\.",
      "year" : 2011
    }, {
      "title" : "Attacking letter substitution ciphers with integer programming. Cryptologia",
      "author" : [ "Ravi", "Sujith", "Knight", "Kevin" ],
      "venue" : null,
      "citeRegEx" : "Ravi et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Ravi et al\\.",
      "year" : 2009
    }, {
      "title" : "Hogwild: A lock-free approach to parallelizing stochastic gradient descent",
      "author" : [ "Recht", "Benjamin", "Re", "Christopher", "Wright", "Stephen", "Niu", "Feng" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Recht et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Recht et al\\.",
      "year" : 2011
    }, {
      "title" : "Learning where to sample in structured prediction",
      "author" : [ "Shi", "Tianlin", "Steinhardt", "Jacob", "Liang", "Percy" ],
      "venue" : null,
      "citeRegEx" : "Shi et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Shi et al\\.",
      "year" : 2015
    }, {
      "title" : "Approximate inference in graphical models using LP relaxations",
      "author" : [ "Sontag", "David Alexander" ],
      "venue" : "PhD thesis, Massachusetts Institute of Technology,",
      "citeRegEx" : "Sontag and Alexander.,? \\Q2010\\E",
      "shortCiteRegEx" : "Sontag and Alexander.",
      "year" : 2010
    }, {
      "title" : "Filtering with abstract particles",
      "author" : [ "Steinhardt", "Jacob", "Liang", "Percy" ],
      "venue" : "In Proceedings of the 31st International Conference on Machine Learning",
      "citeRegEx" : "Steinhardt et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Steinhardt et al\\.",
      "year" : 2014
    }, {
      "title" : "A new class of upper bounds on the log partition function",
      "author" : [ "Wainwright", "Martin J", "Jaakkola", "Tommi S", "Willsky", "Alan S" ],
      "venue" : "Information Theory, IEEE Transactions on,",
      "citeRegEx" : "Wainwright et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Wainwright et al\\.",
      "year" : 2005
    }, {
      "title" : "Sidestepping intractable inference with structured ensemble cascades",
      "author" : [ "Weiss", "David", "Sapp", "Benjamin", "Taskar", "Ben" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Weiss et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Weiss et al\\.",
      "year" : 2010
    }, {
      "title" : "Structured prediction cascades",
      "author" : [ "Weiss", "David", "Sapp", "Benjamin", "Taskar", "Ben" ],
      "venue" : "arXiv preprint arXiv:1208.3279,",
      "citeRegEx" : "Weiss et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Weiss et al\\.",
      "year" : 2012
    }, {
      "title" : "A stochastic memoizer for sequence data",
      "author" : [ "Wood", "Frank", "Archambeau", "Cédric", "Gasthaus", "Jan", "James", "Lancelot", "Teh", "Yee Whye" ],
      "venue" : "In Proceedings of the 26th Annual International Conference on Machine Learning,",
      "citeRegEx" : "Wood et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Wood et al\\.",
      "year" : 2009
    }, {
      "title" : "A generalized mean field algorithm for variational inference in exponential families",
      "author" : [ "Xing", "Eric P", "Jordan", "Michael I", "Russell", "Stuart" ],
      "venue" : "In Proceedings of the Nineteenth conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Xing et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Xing et al\\.",
      "year" : 2002
    }, {
      "title" : "Maxviolation perceptron and forced decoding for scalable mt training",
      "author" : [ "Yu", "Heng", "Huang", "Liang", "Mi", "Haitao", "Zhao", "Kai" ],
      "venue" : "In EMNLP,",
      "citeRegEx" : "Yu et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Yu et al\\.",
      "year" : 2013
    }, {
      "title" : "Online learning for inexact hypergraph search",
      "author" : [ "Zhang", "Hao", "Huang", "Liang", "Zhao", "Kai", "McDonald", "Ryan" ],
      "venue" : "In Proceedings of EMNLP,",
      "citeRegEx" : "Zhang et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2013
    }, {
      "title" : "Context-assisted face clustering framework with human-in-the-loop",
      "author" : [ "Zhang", "Liyan", "Kalashnikov", "Dmitri V", "Mehrotra", "Sharad" ],
      "venue" : "International Journal of Multimedia Information Retrieval,",
      "citeRegEx" : "Zhang et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2014
    }, {
      "title" : "although we parallelized even more aggressively at the expense of theoretical guarantees). We also used a randomized truncation scheme to round most small coordinates of the gradients",
      "author" : [ "Recht" ],
      "venue" : null,
      "citeRegEx" : "Recht,? \\Q2011\\E",
      "shortCiteRegEx" : "Recht",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : ", 2011), sequential Monte Carlo (Cappé et al., 2007; Doucet & Johansen, 2011), or beam search (Koehn et al.",
      "startOffset" : 32,
      "endOffset" : 77
    }, {
      "referenceID" : 10,
      "context" : ", 2007; Doucet & Johansen, 2011), or beam search (Koehn et al., 2003).",
      "startOffset" : 49,
      "endOffset" : 69
    }, {
      "referenceID" : 33,
      "context" : "• precision: In user-facing applications, it is important to only predict on inputs where the system is confident, leaving hard decisions to the user (Zhang et al., 2014).",
      "startOffset" : 150,
      "endOffset" : 170
    }, {
      "referenceID" : 31,
      "context" : "An approximate inference algorithm might not even consider the true y (whereas one always has the true y in a fully-supervised setting), which leads to invalid parameter updates (Yu et al., 2013).",
      "startOffset" : 178,
      "endOffset" : 195
    }, {
      "referenceID" : 27,
      "context" : "Word recognition The first task is the word recognition task from Kassel (1995); we use the “clean” version of the dataset as in Weiss et al. (2012). This contains 6, 876 examples, split into 10 folds (numbered 0 to 9); we used fold 1 for testing and the rest for training.",
      "startOffset" : 129,
      "endOffset" : 149
    }, {
      "referenceID" : 6,
      "context" : "Speech recognition Our second task is from the Switchboard speech transcription project (Greenberg et al., 1996).",
      "startOffset" : 88,
      "endOffset" : 112
    }, {
      "referenceID" : 3,
      "context" : "To train the models, we maximized the approximate log-likelihood using AdaGrad (Duchi et al., 2010) with a step size η of 0.",
      "startOffset" : 79,
      "endOffset" : 99
    }, {
      "referenceID" : 5,
      "context" : "• Forced decoding (Gorman et al., 2011): first train a simple model for which exact inference is tractable to infer the most likely z, conditioned on x and y.",
      "startOffset" : 18,
      "endOffset" : 39
    }, {
      "referenceID" : 14,
      "context" : "We used the given plain text to learn the transition probabilities, using absolute discounting (Ney et al., 1994) for smoothing.",
      "startOffset" : 95,
      "endOffset" : 113
    }, {
      "referenceID" : 17,
      "context" : "We measured performance by mapping accuracy: the fraction of unique symbols that are correctly mapped (Nuhn et al., 2013).",
      "startOffset" : 102,
      "endOffset" : 121
    }, {
      "referenceID" : 12,
      "context" : "When learning with indirect supervision and approximate inference, one intuition is that we can “bootstrap” by first learning from easy examples, and then using the information gained from these examples to make better inferences about the remaining ones (Liang et al., 2011).",
      "startOffset" : 255,
      "endOffset" : 275
    }, {
      "referenceID" : 7,
      "context" : "The first modifies the learning updates to account for the inference procedure, as in the max-violation perceptron and related algorithms (Huang et al., 2012; Zhang et al., 2013; Yu et al., 2013); reinforcement learning approaches to inference (Daumé III et al.",
      "startOffset" : 138,
      "endOffset" : 195
    }, {
      "referenceID" : 32,
      "context" : "The first modifies the learning updates to account for the inference procedure, as in the max-violation perceptron and related algorithms (Huang et al., 2012; Zhang et al., 2013; Yu et al., 2013); reinforcement learning approaches to inference (Daumé III et al.",
      "startOffset" : 138,
      "endOffset" : 195
    }, {
      "referenceID" : 31,
      "context" : "The first modifies the learning updates to account for the inference procedure, as in the max-violation perceptron and related algorithms (Huang et al., 2012; Zhang et al., 2013; Yu et al., 2013); reinforcement learning approaches to inference (Daumé III et al.",
      "startOffset" : 138,
      "endOffset" : 195
    }, {
      "referenceID" : 23,
      "context" : ", 2013); reinforcement learning approaches to inference (Daumé III et al., 2009; Shi et al., 2015) also fit into this category.",
      "startOffset" : 56,
      "endOffset" : 98
    }, {
      "referenceID" : 27,
      "context" : "Another approach modifies the inference algorithm to obtain better coverage, as in coarse-to-fine inference (Petrov et al., 2006; Weiss et al., 2010), where simple models are used to direct the focus of more complex models.",
      "startOffset" : 108,
      "endOffset" : 149
    }, {
      "referenceID" : 1,
      "context" : ", 2013); reinforcement learning approaches to inference (Daumé III et al., 2009; Shi et al., 2015) also fit into this category. Another approach modifies the inference algorithm to obtain better coverage, as in coarse-to-fine inference (Petrov et al., 2006; Weiss et al., 2010), where simple models are used to direct the focus of more complex models. Pal et al. (2006) encourage coverage for beam search by adaptively increasing the beam size.",
      "startOffset" : 63,
      "endOffset" : 370
    }, {
      "referenceID" : 30,
      "context" : "duality gaps from convex programs (Sontag, 2010) or variational bounds (Xing et al., 2002; Wainwright et al., 2005).",
      "startOffset" : 71,
      "endOffset" : 115
    }, {
      "referenceID" : 26,
      "context" : "duality gaps from convex programs (Sontag, 2010) or variational bounds (Xing et al., 2002; Wainwright et al., 2005).",
      "startOffset" : 71,
      "endOffset" : 115
    }, {
      "referenceID" : 14,
      "context" : "Certain smoothing techniques in natural language processing also interpolate between contexts of different order, such as absolute discounting (Ney et al., 1994) and KneserNey smoothing (Kneser & Ney, 1995).",
      "startOffset" : 143,
      "endOffset" : 161
    }, {
      "referenceID" : 13,
      "context" : "Some Bayesian nonparametric approaches such as infinite contingent Bayesian networks (Milch et al., 2005) and hierarchical Pitman-Yor processes (Teh, 2006; Wood et al.",
      "startOffset" : 85,
      "endOffset" : 105
    }, {
      "referenceID" : 29,
      "context" : ", 2005) and hierarchical Pitman-Yor processes (Teh, 2006; Wood et al., 2009) also reason about contexts; again, such models do not lead to tractable inference.",
      "startOffset" : 46,
      "endOffset" : 76
    } ],
    "year" : 2015,
    "abstractText" : "A classic tension exists between exact inference in a simple model and approximate inference in a complex model. The latter offers expressivity and thus accuracy, but the former provides coverage of the space, an important property for confidence estimation and learning with indirect supervision. In this work, we introduce a new approach, reified context models, to reconcile this tension. Specifically, we let the amount of context (the arity of the factors in a graphical model) be chosen “at run-time” by reifying it—that is, letting this choice itself be a random variable inside the model. Empirically, we show that our approach obtains expressivity and coverage on three natural language tasks.",
    "creator" : "LaTeX with hyperref package"
  }
}