{
  "name" : "1505.05364.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Reactive Reasoning with the Event Calculus",
    "authors" : [ "Alexander Artikis", "Georgios Paliouras" ],
    "emails" : [ "a.artikis@unipi.gr", "m.sergot@imperial.ac.uk", "paliourg@iit.demokritos.gr" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Systems for symbolic event recognition (‘event pattern matching’) accept as input a stream of time-stamped simple, derived events (SDE)s. A SDE (‘low-level event’) is the result of applying a computational derivation process to some other event, such as an event coming from a sensor [21]. Using SDEs as input, event recognition systems identify composite events (CE)s of interest—collections of events that satisfy some pattern. The ‘definition’ of a CE (‘high-level event’) imposes temporal and, possibly, atemporal constraints on its subevents, i.e. SDEs or other CEs. Consider e.g. the recognition of attacks on computer network nodes given the TCP/IP messages.\nNumerous recognition systems have been proposed in the literature [10]. Recognition systems with a logic-based representation of CE definitions, in particular, have recently been attracting attention [4]. They exhibit a formal, declarative semantics, in contrast to other types of recognition system that usually rely on an informal and/or procedural semantics. However, non-logic-based CE recognition systems have proven to be, overall, more efficient than logic-based ones. To address this issue, we present an efficient dialect of the Event Calculus [18], called ‘Event Calculus for Run-Time reasoning’ (RTEC). The Event Calculus is a logic programming formalism for representing and reasoning about events and their effects. RTEC includes novel implementation techniques for efficient CE recognition, scalable to large SDE and CE volumes. A set of interval manipulation constructs simplify CE definitions and improve reasoning efficiency. A simple indexing mechanism makes RTEC robust to SDEs that are irrelevant to the CEs we want to recognise and so RTEC can operate without SDE filtering modules. Finally, a ‘windowing’ mechanism supports real-time CE recognition. One main motivation for RTEC\n1 University of Piraeus, Greece & NCSR Demokritos, Greece, email: a.artikis@unipi.gr 2 Imperial College London, UK, email: m.sergot@imperial.ac.uk 3 NCSR Demokritos, Greece, email: paliourg@iit.demokritos.gr 4 A form of this paper has been submitted to IEEE TKDE.\nis that it should remain efficient and scalable in applications where SDEs arrive with a (variable) delay from, or are revised by, the underlying SDE detection system: RTEC can update the already recognised CEs, and recognise new CEs, when SDEs arrive with a delay or following revision. The code of RTEC is available at <http: //users.iit.demokritos.gr/˜a.artikis/EC.html>.\nWe evaluate RTEC on public space surveillance from video content. In this application, the SDEs are the ‘short-term activities’ detected on video frames—e.g. a person walking, running or being inactive. The aim then is to recognise ‘long-term activities’, i.e. shortterm activity combinations, such as when a person leaves an object unattended, when two people are moving together, when they are having a meeting or fighting. The CE definitions are quite complex, allowing for a realistic evaluation of the efficiency of RTEC. This is in contrast to the majority of related approaches where rather simple CE definitions are used for empirical analysis. Our evaluation shows that RTEC supports real-time CE recognition and is capable of meeting the performance requirements of most of today’s applications as estimated by a recent survey of event processing use cases [5].\nThe remainder of the paper is structured as follows. Sections 2 and 3 present the expressivity of RTEC and the way it performs reasoning. The experimental evaluation is given in Section 4. Section 5 summarises the presented work, puts the work in context, and outlines directions for further research."
    }, {
      "heading" : "2 Event Calculus",
      "text" : "Our system for CE recognition is based on an Event Calculus dialect. The Event Calculus [18] is a logic programming formalism for representing and reasoning about events and their effects. For the dialect introduced here, called RTEC, the time model is linear and includes integer time-points. Variables start with an upper-case letter, while predicates and constants start with a lower-case letter. Where F is a fluent—a property that is allowed to have different values at different points in time—the term F =V denotes that fluent F has value V . Boolean fluents are a special case in which the possible values are true and false. holdsAt(F =V, T ) represents that fluent F has value V at a particular time-point T . holdsFor(F =V, I) represents that I is the list of the maximal intervals for which F =V holds continuously. holdsAt and holdsFor are defined in such a way that, for any fluent F , holdsAt(F =V, T ) if and only if T belongs to one of the maximal intervals of I for which holdsFor(F =V, I).\nAn event description in RTEC includes rules that define the event instances with the use of the happensAt predicate, the effects of events with the use of the initiatedAt and terminatedAt predicates, and the values of the fluents with the use of the holdsAt and holdsFor predicates, as well as other, possibly atemporal, constraints. Table 1 summarises the RTEC predicates available to the event description developer. The last three items in the table are interval manipulation\nar X\niv :1\n50 5.\n05 36\n4v 1\n[ cs\n.A I]\n2 0\nM ay\n2 01\n5\npredicates specific to RTEC.\nWe represent instantaneous SDEs and CEs by means of happensAt, while durative SDEs and CEs are represented as fluents. The majority of CEs are durative and, therefore, in CE recognition the task generally is to compute the maximal intervals for which a fluent representing a CE has a particular value continuously."
    }, {
      "heading" : "2.1 Simple Fluents",
      "text" : "Fluents in RTEC are simple or statically determined. We assume, without loss of generality, that these types are disjoint. For a simple fluent F , F =V holds at a particular time-point T if F =V has been initiated by an event that has occurred at some time-point earlier than T , and has not been terminated at some other time-point in the meantime. This is an implementation of the law of inertia. To compute the intervals I for which F =V , i.e. holdsFor(F =V, I), we find all time-points Ts at which F =V is initiated, and then, for each Ts, we compute the first time-point Tf after Ts at which F =V is ‘broken’. The time-points at which F =V is initiated are computed by means of domain-specific initiatedAt rules. The time-points at which F =V is ‘broken’ are computed as follows:\nbroken(F =V, Ts, T )← terminatedAt(F =V, Tf ), Ts < Tf ≤ T\n(1)\nbroken(F =V1, Ts, T )← initiatedAt(F =V2, Tf ), Ts < Tf ≤ T, V1 6= V2\n(2)\nbroken(F =V, Ts, T ) represents that a maximal interval starting at Ts for which F =V holds continuously is terminated at some time Tf such that Ts<Tf≤T . Similar to initiatedAt, terminatedAt rules are domain-specific (examples are presented below). According to rule (2), if F =V2 is initiated at Tf then effectively F =V1 is terminated at time Tf , for all other possible values V1 of F . Rule (2) ensures therefore that a fluent cannot have more than one value at any time. We do not insist that a fluent must have a value at every time-point. There is a difference between initiating a Boolean fluent F = false and terminating F = true: the former implies, but is not implied by, the latter.\nRTEC stores and indexes holdsFor intervals as they are computed for any given fluent-value F =V : thereafter intervals for F =V are retrieved from the computer memory without the need for recomputation. Similarly, a holdsAt query for F =V looks up F ’s value in the holdsFor cache.\nIn public space surveillance, it is often required to detect when a person leaves an object unattended. Typically, an object carried by a person is not tracked by the computer vision algorithms—only the person that carries it is tracked. The object will be tracked, i.e. it will ‘appear’, if and only if the person leaves it somewhere. Moreover, objects (as opposed to persons) can exhibit only inactive activity. Accordingly, we define a durative ‘leaving an object’ CE as follows:\ninitiatedAt(leaving object(P ,Obj )= true, T )← happensAt(appear(Obj ), T ), holdsAt(inactive(Obj )= true, T ), holdsAt(close(P ,Obj )= true, T ), holdsAt(person(P)= true, T )\n(3)\ninitiatedAt(leaving object(P ,Obj )= false, T )← happensAt(disappear(Obj ), T )\n(4)\nIn rule (3) leaving object(P ,Obj )= true is initiated at time T if Obj ‘appears’ at T , it is inactive at T , and there is a person P ‘close’ to Obj at T . appear and inactive are instantaneous SDE and durative SDE respectively. SDE are detected on video frames in this application. close(A,B) is true when the distance between A and B does not exceed some threshold of pixel positions.\nThere is no explicit information about whether a tracked entity is a person or an inanimate object. We define the simple fluent person(P) to have value true if P has been active, walking, running or moving abruptly since P first ‘appeared’. The value of person(P) has to be time-dependent because the identifier P of a tracked entity that ‘disappears’ (is no longer tracked) at some point may be used later to refer to another entity that ‘appears’ (becomes tracked), and that other entity may not necessarily be a person. This is a feature of the application and not something that is imposed by RTEC.\nUnlike the specification of person , it is not clear from the data whether a tracked entity is an object. person(P)= false does not necessarily mean that P is an object; it may be that P is not tracked, or that P is a person that has never walked, run, been active or moved abruptly. Note finally that rule (3) incorporates a reasonable simplifying assumption, that a person entity will never exhibit ‘inactive’ activity at the moment it first ‘appears’ (is tracked). If an entity is ‘inactive’ at the moment it ‘appears’ it can be assumed to be an object, as in the first two conditions of rule (3).\nRule (4) expresses the conditions in which leaving object ceases to be recognised. leaving object(P ,Obj ) becomes false when the object in question is picked up. An object that is picked up by someone is no longer tracked—it ‘disappears’—terminating leaving object . (disappear is an instantaneous SDE.) The maximal intervals during which leaving object(P ,Obj )= true holds continuously are computed using the built-in RTEC predicate holdsFor from rules (3) and (4).\nConsider another example from public space surveillance:\ninitiatedAt(moving(P1 ,P2 )= true, T ) ← happensAt(start(walking(P1 )= true), T ), holdsAt(walking(P2 )= true, T ), holdsAt(close(P1 ,P2 )= true, T )\n(5)\ninitiatedAt(moving(P1 ,P2 )= true, T ) ← happensAt(start(walking(P2 )= true), T ), holdsAt(walking(P1 )= true, T ), holdsAt(close(P1 ,P2 )= true, T )\n(6)\ninitiatedAt(moving(P1 ,P2 )= true, T ) ← happensAt(start(close(P1 ,P2 )= true), T ), holdsAt(walking(P1 )= true, T ), holdsAt(walking(P2 )= true, T )\n(7)\nterminatedAt(moving(P1 ,P2 )= true, T ) ← happensAt(end(walking(P1 )= true), T )\n(8)\nterminatedAt(moving(P1 ,P2 )= true, T ) ← happensAt(end(walking(P2 )= true), T )\n(9)\nterminatedAt(moving(P1 ,P2 )= true, T ) ← happensAt(end(close(P1 ,P2 )= true), T )\n(10)\nwalking is a durative SDE detected on video frames. start(F =V ) (resp. end(F =V )) is a built-in RTEC event taking place at each starting (ending) point of each maximal interval for which F =V holds continuously. The above formalisation states that P1 is moving with P2 when they are walking close to each other.\nOne of the main attractions of RTEC is that it makes available the power of logic programming to express complex temporal and atemporal constraints, as conditions in initiatedAt and terminatedAt rules for durative CEs, and happensAt rules for instantaneous CEs. E.g. standard event algebra operators, such as sequence, disjunction, parallelism, etc, may be expressed in a RTEC event description."
    }, {
      "heading" : "2.2 Statically Determined Fluents",
      "text" : "In addition to the domain-independent definition of holdsFor, an event description may include domain-specific holdsFor rules, used to define the values of a fluent F in terms of the values of other fluents. We call such a fluent F statically determined. holdsFor rules of this kind make use of interval manipulation constructs—see the last three items of Table 1. Consider, e.g. moving as in rules (5)–(10) but defined instead as a statically determined fluent:\nholdsFor(moving(P1 ,P2 )= true, I )← holdsFor(walking(P1 )= true, I1 ), holdsFor(walking(P2 )= true, I2 ), holdsFor(close(P1 ,P2 )= true, I3 ), intersect all([I1 , I2 , I3 ], I )\n(11)\nThe list I of maximal intervals during which P1 is moving with P2 is computed by determining the list I1 of maximal intervals during which P1 is walking, the list I2 of maximal intervals during which P2 is walking, the list I3 of maximal intervals during which P1 is close to P2, and then calculating the list I representing the intersections of the maximal intervals in I1, I2 and I3.\nRTEC provides three interval manipulation constructs: union all, intersect all and relative complement all. union all(L, I) computes the list I of maximal intervals representing the union of maximal intervals of the lists of list L. For instance:\nunion all([[(5, 20), (26, 30)], [(28, 35)]], [(5, 20), (26, 35)])\nA term of the form (Ts ,Te) in RTEC represents the closed-open interval [Ts ,Te). I in union all(L, I) is a list of maximal intervals that includes each time-point that is part of at least one list of L.\nintersect all(L, I) computes the list I of maximal intervals such that I represents the intersection of maximal intervals of the lists of\nlist L, as, e.g.:\nintersect all([[(26, 31)], [(21, 26), (30, 40)]], [(30, 31)])\nI in intersect all(L, I) is a list of maximal intervals that includes each time-point that is part of all lists of L.\nrelative complement all(I ′, L, I) computes the list I of maximal intervals such that I represents the relative complements of the list of maximal intervals I ′ with respect to the maximal intervals of the lists of list L. Below is an example of relative complement all:\nrelative complement all([(5, 20), (26, 50)], [[(1, 4), (18, 22)], [(28, 35)]], [(5, 18), (26, 28), (35, 50)])\nI in relative complement all(I ′, L, I) is a list of maximal intervals that includes each time-point of I ′ that is not part of any list of L.\nWhen defining a statically determined fluent F we will often want to say that, for all time-points T , F =V holds at T if and only if W holds at T where W is some Boolean combination of fluent-value pairs. RTEC provides optional shorthands for writing such definitions concisely. For example, the definition\nG=V iff (A=V1 or B=V2), (A=V ′1 or B=V ′ 2 ),\nnot C =V3\n(12)\nis expanded into the following holdsFor rule:\nholdsFor(G=V, I) ← holdsFor(A=V1, I1), holdsFor(B=V2, I2), union all([I1, I2], I3), holdsFor(A=V ′1 , I4), holdsFor(B=V ′ 2 , I5),\nunion all([I4, I5], I6), intersect all([I3, I6], I7), holdsFor(C =V3, I8), relative complement all(I7, [I8], I)\n(13)\nThe required transformation takes place automatically when event descriptions are loaded into RTEC.\nFor a wide range of fluents, the use of interval manipulation constructs leads to a much more concise definition than the traditional style of Event Calculus representation, i.e. identifying the various conditions under which the fluent is initiated and terminated so that maximal intervals can then be computed using the domainindependent holdsFor. Compare, e.g. the statically determined and simple fluent representations of moving in rules (11) and (5)–(10) respectively.\nThe interval manipulation constructs of RTEC can also lead to much more efficient computation. The complexity analysis may be found in [3]."
    }, {
      "heading" : "2.3 Semantics",
      "text" : "CE definitions are (locally) stratified logic programs [25]. We restrict attention to hierarchical definitions, those where it is possible to define a function level that maps all fluent-values F =V and all events to the non-negative integers as follows. Events and statically determined fluent-values F =V of level 0 are those whose happensAt and holdsFor definitions do not depend on any other events or fluents. In CE recognition, they represent the input SDEs. There are no fluent-values F =V of simple fluents F in level 0. Events and simple fluent-values of level n are defined in terms of at least one\nevent or fluent-value of level n−1 and a possibly empty set of events and fluent-values from levels lower than n−1. Statically determined fluent-values of level n are defined in terms of at least one fluentvalue of level n−1 and a possibly empty set of fluent-values from levels lower than n−1. Note that fluent-values F =Vi and F =Vj for Vi 6=Vj could be mapped to different levels. For simplicity however, and without loss of generality, a fluent F itself is either simple or statically determined but not both. The CE definitions of public space surveillance, i.e. the holdsFor definitions of statically determined fluents, initiatedAt and terminatedAt definitions of simple fluents and happensAt definitions of events, are available with the RTEC code."
    }, {
      "heading" : "3 Run-Time Recognition",
      "text" : "CE recognition has to be efficient enough to support real-time decision-making, and scale to very large numbers of SDEs and CEs. SDEs may not necessarily arrive at the CE recognition system in a timely manner, i.e. there may be a (variable) delay between the time at which SDEs take place and the time at which they arrive at the CE recognition system. Moreover, SDEs may be revised, or even completely discarded in the future, as in the case where the parameters of a SDE were originally computed erroneously and are subsequently revised, or in the case of retraction of a SDE that was reported by mistake, and the mistake was realised later [1]. Note that SDE revision is not performed by the CE recognition system, but by the underlying SDE detection system.\nRTEC performs CE recognition by computing and storing the maximal intervals of fluents and the time-points in which events occur. CE recognition takes place at specified query times Q1, Q2, . . . . At each Qi the SDEs that fall within a specified interval—the ‘working memory’ (WM) or ‘window’—are taken into consideration. All SDEs that took place before or at Qi−WM are discarded. This is to make the cost of CE recognition dependent only on the WM size and not on the complete SDE history. The WM size, and the temporal distance between two consecutive query times — the ‘step’ (Qi−Qi−1) — are set by the user.\nAt Qi, the maximal intervals computed by RTEC are those that can be derived from SDEs that occurred in the interval (Qi−WM, Qi], as recorded at time Qi. When WM is longer than the inter-query step, i.e., when Qi−WM<Qi−1<Qi, it is possible that an SDE occurs in the interval (Qi−WM, Qi−1] but arrives at RTEC only after Qi−1; its effects are taken into account at query time Qi. And similarly for SDEs that took place in (Qi−WM, Qi−1] and were subsequently revised after Qi−1. In the common case that SDEs arrive at RTEC with delays, or there is SDE revision, it is preferable therefore to make WM longer than the inter-query step. Note that information may still be lost. Any SDEs arriving or revised between Qi−1 and Qi are discarded at Qi if they took place before or at Qi−WM. To reduce the possibility of losing information, one may increase the WM size. Doing so, however, decreases recognition efficiency.\nFigure 1 illustrates windowing in RTEC. In this example we have WM>Qi−Qi−1. To avoid clutter, Figure 1 shows streams of only five SDEs. These are displayed below WM, with dots for instantaneous SDEs and lines for durative ones. For the sake of the example, we are interested in recognising just two CEs:\n• CEs , represented as a simple fluent (see Section 2.1). The starting and ending points, and the maximal intervals of CEs are displayed above WM in Figure 1. • CEstd , represented as a statically determined fluent (see Section 2.2). For the example, the maximal intervals of CEstd are defined\nto be the union of the maximal intervals of the two durative SDEs in Figure 1. The maximal intervals of CEstd are displayed above the CEs intervals.\nFor simplicity, we assume that both CEs and CEstd are defined only in terms of SDE, i.e. they are not defined in terms of other CEs.\nFigure 1 shows the steps that are followed in order to recognise CEs at an arbitrary query time, say Q138. Figure 1(a) shows the state of RTEC as computation begins at Q138. All SDEs that took place before or at Q137−WM were retracted at Q137. The thick lines and dots represent the SDEs that arrived at RTEC between Q137 and Q138; some of them took place before Q137. Figure 1(a) also shows the maximal intervals for the CE fluents CEs and CEstd that were computed and stored at Q137.\nThe CE recognition process at Q138 considers the SDEs that took place in (Q138−WM, Q138]. All SDEs that took place before or at Q138−WM are discarded, as shown in Figure 1(b). For durative SDEs that started before Q138−WM and ended after that time, RTEC retracts the sub-interval up to and including Q138−WM. Figure 1(b) shows the interval of a SDE that is partially retracted in this way.\nNow consider CE intervals. At Qi some of the maximal intervals computed at Qi−1 might have become invalid. This is because some SDEs occurring in (Qi−WM, Qi−1] might have arrived or been revised after Qi−1: their existence could not have been known at Qi−1. Determining which CE intervals should be (partly) retracted in these circumstances can be computationally very expensive. See Section 5 for a discussion. We find it simpler, and more efficient, to discard all CE intervals in (Qi−WM, Qi] and compute all intervals from scratch in that period. CE intervals that have ended before or at Qi−WM are discarded. Depending on the user requirements, these intervals may be stored in a database for retrospective inspection of the activities of a system.\nIn Figure 1(b), the earlier of the two maximal intervals computed for CEstd at Q137 is discarded at Q138 since its endpoint is before\nQ138−WM. The later of the two intervals overlaps Q138−WM (an interval ‘overlaps’ a time-point t if the interval starts before or at t and ends after or at that time) and is partly retracted at Q138. Its starting point could not have been affected by SDEs arriving between Q138−WM and Q138 but its endpoint has to be recalculated. Accordingly, the sub-interval from Q138−WM is retracted at Q138.\nIn this example, the maximal intervals of CEstd are determined by computing the union of the maximal intervals of the two durative SDEs shown in Figure 1. At Q138, only the SDE intervals in (Q138−WM, Q138] are considered. In the example, there are two maximal intervals for CEstd in this period as can be seen in Figure 1(c). The earlier of them has its startpoint at Q138−WM. Since that abuts the existing, partially retracted sub-interval for CEstd whose endpoint is Q138−WM, those two intervals are amalgamated into one continuous maximal interval as shown in Figure 1(c). In this way, the endpoint of the CEstd interval that overlapped Q138−WM at Q137 is recomputed to take account of SDEs available at Q138. (In this particular example, it happens that the endpoint of this interval is the same as that computed at Q137. That is merely a feature of this particular example. Had CEstd been defined e.g. as the intersection of the maximal intervals of the two durative SDE, then the intervals of CEstd would have changed in (Q138−WM, Q137].)\nFigure 1 also shows how the intervals of the simple fluent CEs are computed at Q138. Arrows facing upwards (downwards) denote the starting (ending) points of CEs intervals. First, in analogy with the treatment of statically determined fluents, the earlier of the two CEs intervals in Figure 1(a), and its start and endpoints, are retracted. They occur before Q138−WM. The later of the two intervals overlaps Q138−WM. The interval is retracted, and only its starting point is kept; its new endpoint, if any, will be recomputed at Q138. See Figure 1(b). For simple fluents, it is simpler, and more efficient, to retract such intervals completely and reconstruct them later from their start and endpoints by means of the domain-independent holdsFor rules, rather than keeping the sub-interval that takes place before Q138−WM, and possibly amalgamating it later with another interval, as we do for statically determined fluents.\nThe second step for CEs at Q138 is to calculate its starting and ending points by evaluating the relevant initiatedAt and terminatedAt rules. For this, we only consider SDEs that took place in (Q138−WM, Q138]. Figure 1(c) shows the starting and ending points of CEs in (Q138−WM, Q138]. The last ending point of CEs that was computed at Q137 was invalidated in the light of the new SDEs that became available at Q138 (compare Figures 1(c)–(a)). Moreover, another ending point was computed at an earlier time.\nFinally, in order to recognise CEs at Q138 we use the domainindependent holdsFor to calculate the maximal intervals of CEs given its starting and ending points. The later of the two CEs intervals computed at Q137 became shorter when re-computed at Q138. The second interval of CEs at Q138 is open: given the SDEs available at Q138, we say that CEs holds since time t, where t is the last starting point of CEs .\nThe discussion above showed that, when SDEs arrive with a variable delay, CE intervals computed at an earlier query time may be (partly) retracted at the current or a future query time. (And similarly if SDEs are revised.) Depending on the application requirements, RTEC may be set to report:\n• CEs as soon as they are recognised, even if their intervals may be (partly) retracted in the future. • CEs whose intervals may be partly, but not completely, retracted in the future, i.e. CEs whose intervals overlap Qi+1−WM.\n• CEs whose intervals will not be even partly retracted in the future, i.e. CEs whose intervals end before or at Qi+1−WM.\nThe example used for illustration shows how RTEC performs CE recognition. To support real-time reasoning, at each query time Qi all SDEs that took place before or at Qi−WM are discarded. To handle efficiently delayed SDEs and SDE revision, CE intervals within WM are computed from scratch. At Qi, the computed maximal CE intervals are those that can be derived from SDEs that occurred in the interval (Qi−WM, Qi], as recorded at time Qi. For completeness, RTEC amalgamates the computed intervals to any intervals ending at Qi−WM. More details about CE recognition in RTEC may be found at [3]."
    }, {
      "heading" : "4 Experimental Results",
      "text" : "We present experimental results on the public space surveillance application. The experiments were performed on a computer with eight Intel i7 950@3.07GHz processors and 12GiB RAM, running Ubuntu Linux 12.04 and YAP Prolog 6.2.2. Each CE recognition time displayed in this section is the average of 30 runs. We use the CAVIAR benchmark dataset consisting of 28 surveillance videos of a public space <http://groups.inf.ed.ac.uk/vision/ CAVIAR/CAVIARDATA1>. The videos are staged—actors walk around, sit down, meet one another, leave objects behind, etc. Each video has been manually annotated by the CAVIAR team in order to provide the ground truth for ‘short-term activities’, i.e. activities taking place in a short period of time detected on individual video frames. (The frame rate in CAVIAR is 40 ms.) The short-term activities of CAVIAR concern an entity (person or object) entering or exiting the surveillance area, walking, running, moving abruptly, being active or inactive. The CAVIAR team has also annotated the 28 videos with ‘long-term activities’: a person leaving an object unattended, two people meeting, moving together and fighting. Shortterm activities can be viewed as SDEs while long-term activities can be viewed as CEs. Consequently, the input to RTEC in this case study includes the set of annotated short-term activities, and the output is a set of recognised long-term activities. The CE definitions and the datasets on which the experiments were performed are available with the RTEC code.\nCE recognition for multiple pairs of entities. Figure 2(a) shows the results of experiments concerning all 45 pairs of the 10 entities tracked in the CAVIAR dataset. (In CAVIAR each CE concerns a pair of entities.) On average, 179 SDEs are detected per sec. We used a single processor for CE recognition concerning all 45 tracked pairs. That requires computing and storing the intervals of 645 CEs. We varied WM from 10 sec (≈2,000 SDEs) to 110 sec (≈19,000 SDEs). The inter-query step is set to 5 sec (≈1,000 SDEs). In all settings shown in Figure 2(a), RTEC performs real-time CE recognition.\nLarger datasets. We constructed a larger dataset by taking ten copies of the original CAVIAR dataset with new identifiers for the tracked entities in each copy. The resulting dataset has 100 tracked entities, i.e. 4,950 entity pairs, while on average 1,800 SDEs take place per sec. According to the use case survey of the Event Processing Technical Society [5], in the resulting dataset there are more SDEs per sec than in most applications. First, we used a single processor for CE recognition. In this case, the intervals of approximately 64,000 CEs were computed and stored. Second, we used all eight processors of the computer in parallel. Consequently, each instance of RTEC running on a processor computed and stored the intervals of approximately 8,000 CEs. We emphasize that the input data was\nthe same in all sets of experiments: each processor receives SDEs coming from all tracked entities—i.e. there was no SDE filtering to restrict the input relevant for each processor. We rely only on the indexing mechanism of RTEC to pick out relevant SDEs from the stream. RTEC employs a very simple indexing mechanism: it merely exploits YAP Prolog’s standard indexing on the functor of the first argument of the head of a clause.\nAs in the previous set of experiments, the inter-query step is set to 5 sec, while the size of the WM varies from 10 to 110 sec. In this case, however, step includes approximately 9,000 SDEs, and WM varies from 18,000 to 192,000 SDEs. Figure 2(b) shows the average CE recognition times. In all cases RTEC performs real-time CE recognition. Figure 2(b) also shows that we can achieve significant performance gain by running RTEC in parallel on different processors. Such a gain is achieved without requiring SDE filtering."
    }, {
      "heading" : "5 Discussion",
      "text" : "We presented RTEC, an Event Calculus dialect with novel implementation techniques that allow for efficient CE recognition, scalable to large numbers of SDEs and CEs. RTEC remains efficient and scalable in applications where SDEs arrive with a (variable) delay from, or are revised by, the SDE detection systems: it can update the already recognised CEs, and recognise new CEs, when SDEs are arrive with a delay or following revision.\nRTEC has a formal, declarative semantics as opposed to most complex event processing languages, several data stream processing and event query languages, and most commercial production rule systems. Furthermore, RTEC has available the power of logic programming and thus supports atemporal reasoning and reasoning over background knowledge (as opposed to e.g. [2, 13, 19, 9]), has builtin axioms for complex temporal phenomena (as opposed to [26, 1]), explicitly represents CE intervals and thus avoids the related logical problems (as opposed to e.g. [22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]). Concerning the Event Calculus literature, a key feature of RTEC is that it includes a windowing technique. In contrast, no Event Calculus system (including e.g. [8, 7, 23, 24, 6]) ‘forgets’ or represents concisely the SDE history.\nThe ‘Cached Event Calculus’ [8] performs update-time reasoning: it computes and stores the consequences of a SDE as soon as it arrives. Query processing, therefore, amounts to retrieving the appropriate CE intervals from the computer memory. When a maximal\ninterval of a fluent is asserted or retracted due to a delayed SDE, the assertion/retraction is propagated to the fluents whose validity may rely on such an interval. E.g. propagateAssert([T1 ,T2 ],U ) in the Cached Event Calculus checks whether there are new initiations as a result of asserting the interval (T1, T2] of fluent U . In particular, propagateAssert checks whether: (1) the asserted fluent U is a condition for the initiation of a fluent F at the occurrence of event E, (2) the occurrence time T of E belongs to (T1, T2], and (3) there is not already a maximal interval for F with T as its starting point. If the above conditions are satisfied, propagateAssert recursively calls updateInit(E ,T ,F ) in order to determine if F is now initiated at T , and if it is, to update the fluent interval database accordingly.\npropagateAssert also checks whether there are new terminations as a result of a fluent interval assertion, while propagateRetract checks whether there are new initiations and terminations as a result of a fluent interval retraction. The cost of propagateAssert and propagateRetract is very high, especially in applications where the CE definitions include many rules with several fluents that depend on several other fluents. Furthermore, this type of reasoning is performed very frequently. RTEC avoids the costly checks every time a fluent interval is asserted/retracted due to delayed SDE arrival/revision. We found that in RTEC it is more efficient, and simpler, to discard at each query time Qi, all intervals of fluents representing CEs in (Qi−WM ,Qi ] and compute from scratch all such intervals given the SDEs available at Qi and detected in (Qi−WM ,Qi ].\nFor further work, we are developing techniques, based on abductive-inductive logic programming, for automated generation and refinement of CE definitions from very large datasets, with the aim of minimising the time-consuming and error-prone process of manual CE definition construction [16]. We are also porting RTEC into probabilistic logic programming frameworks, in order to deal with various types of uncertainty, such as imperfect CE definitions, incomplete and erroneous SDE streams [17]."
    }, {
      "heading" : "ACKNOWLEDGEMENTS",
      "text" : "We would like to thank the anonymous reviewers for their very helpful comments. This work has been partly funded by the EU FP7 project SPEEDD (619435)."
    } ],
    "references" : [ {
      "title" : "Real-time complex event recognition and reasoning",
      "author" : [ "D. Anicic", "S. Rudolph", "P. Fodor", "N. Stojanovic" ],
      "venue" : "Applied Artificial Intelligence, 26(1– 2), 6–57, ",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "The CQL continuous query language: semantic foundations and query execution",
      "author" : [ "A. Arasu", "S. Babu", "J. Widom" ],
      "venue" : "The VLDB Journal, 15(2), 121–142, ",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Run-time composite event recognition",
      "author" : [ "A. Artikis", "M. Sergot", "G. Paliouras" ],
      "venue" : "DEBS, pp. 69–80. ACM, ",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Logic-based event recognition",
      "author" : [ "A. Artikis", "A. Skarlatidis", "F. Portet", "G. Paliouras" ],
      "venue" : "Knowledge Engineering Review, 27(4), 469–506, ",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Results of the survey on event processing use cases",
      "author" : [ "P. Bizzaro" ],
      "venue" : "Event Processing Technical Society,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "A calculus of macro-events: Progress report",
      "author" : [ "I. Cervesato", "A. Montanari" ],
      "venue" : "TIME, pp. 47–58, ",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "A logic-based",
      "author" : [ "F. Chesani", "P. Mello", "M. Montali", "P. Torroni" ],
      "venue" : "reactive calculus of events’, Fundamenta Informaticae, 105(1-2), 135–161, ",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Efficient temporal reasoning in the cached event calculus",
      "author" : [ "L. Chittaro", "A. Montanari" ],
      "venue" : "Computational Intelligence, 12(3), 359–382, ",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "TESLA: a formally defined event specification language",
      "author" : [ "G. Cugola", "A. Margara" ],
      "venue" : "DEBS, pp. 50–61, ",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Processing flows of information: From data stream to complex event processing",
      "author" : [ "G. Cugola", "A. Margara" ],
      "venue" : "ACM Computing Surveys, 44(3), 15, ",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Efficiently correlating complex events over live and archived data streams",
      "author" : [ "N. Dindar", "P.M. Fischer", "M. Soner", "N. Tatbul" ],
      "venue" : "DEBS, pp. 243–254, ",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Runtime semantic query optimization for event stream processing",
      "author" : [ "L. Ding", "S. Chen", "E.A. Rundensteiner", "J. Tatemura", "W.-P. Hsiung", "K. Candan" ],
      "venue" : "ICDE, pp. 676–685, ",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Chronicle recognition improvement using temporal focusing and hierarchisation",
      "author" : [ "C. Dousson", "P. Le Maigat" ],
      "venue" : "IJCAI, pp. 324–329, ",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "SASE: Complex event processing over streams",
      "author" : [ "D. Gyllstrom", "E. Wu", "H.-J. Chae", "Y. Diao", "P. Stahlberg", "G. Anderson" ],
      "venue" : "CIDR, ",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Modular-E : An elaboration tolerant approach to the ramification and qualification problems",
      "author" : [ "A. Kakas", "L. Michael", "R. Miller" ],
      "venue" : "LP- NMR, pp. 211–226, ",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Incremental learning of event definitions with inductive logic programming",
      "author" : [ "Nikos Katzouris", "Alexander Artikis", "George Paliouras" ],
      "venue" : "CoRR, abs/1402.5988,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2014
    }, {
      "title" : "On the implementation of the probabilistic logic programming language ProbLog",
      "author" : [ "A. Kimmig", "B. Demoen", "L. De Raedt", "V. Santos Costa", "R. Rocha" ],
      "venue" : "Theory and Practice of Logic Programming, 11, 235– 262, ",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A logic-based calculus of events",
      "author" : [ "R. Kowalski", "M. Sergot" ],
      "venue" : "New Generation Computing, 4(1), 67–96, ",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "Semantics and implementation of continuous sliding window queries over data streams",
      "author" : [ "J. Krämer", "B. Seeger" ],
      "venue" : "ACM Transactions on Database Systems, 34(1), 1–49, ",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Complex event pattern detection over streams with interval-based temporal semantics",
      "author" : [ "M. Li", "M. Mani", "E.A. Rundensteiner", "T. Lin" ],
      "venue" : "DEBS, pp. 291–302, ",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Event processing glossary — version 1.1",
      "author" : [ "D. Luckham", "R. Schulte" ],
      "venue" : "Event Processing Technical Society,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2008
    }, {
      "title" : "A monitoring approach for runtime service discovery",
      "author" : [ "K. Mahbub", "G. Spanoudakis", "A. Zisman" ],
      "venue" : "Automated Software Engineering, 18(2), 117–161, ",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "and W",
      "author" : [ "M. Montali", "F.M. Maggi", "F. Chesani", "P. Mello" ],
      "venue" : "M. P. van der Aalst, ‘Monitoring business constraints with the Event Calculus’, ACM TIST, 5(1), ",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Knowledge representation concepts for automated SLA management",
      "author" : [ "A. Paschke", "M. Bichler" ],
      "venue" : "Decision Support Systems, 46(1), 187– 205, ",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "On the declarate semantics of stratified deductive databases and logic programs",
      "author" : [ "T. Przymusinski" ],
      "venue" : "Foundations of Deductive Databases and Logic Programming, Morgan, ",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Bilattice-based logical reasoning for human detection",
      "author" : [ "V. Shet", "J. Neumann", "V. Ramesh", "L. Davis" ],
      "venue" : "CVPR, ",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 20,
      "context" : "A SDE (‘low-level event’) is the result of applying a computational derivation process to some other event, such as an event coming from a sensor [21].",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 9,
      "context" : "Numerous recognition systems have been proposed in the literature [10].",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 3,
      "context" : "Recognition systems with a logic-based representation of CE definitions, in particular, have recently been attracting attention [4].",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 17,
      "context" : "To address this issue, we present an efficient dialect of the Event Calculus [18], called ‘Event Calculus for Run-Time reasoning’ (RTEC).",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 4,
      "context" : "Our evaluation shows that RTEC supports real-time CE recognition and is capable of meeting the performance requirements of most of today’s applications as estimated by a recent survey of event processing use cases [5].",
      "startOffset" : 214,
      "endOffset" : 217
    }, {
      "referenceID" : 17,
      "context" : "The Event Calculus [18] is a logic programming formalism for representing and reasoning about events and their effects.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 2,
      "context" : "The complexity analysis may be found in [3].",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 24,
      "context" : "CE definitions are (locally) stratified logic programs [25].",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 0,
      "context" : "Moreover, SDEs may be revised, or even completely discarded in the future, as in the case where the parameters of a SDE were originally computed erroneously and are subsequently revised, or in the case of retraction of a SDE that was reported by mistake, and the mistake was realised later [1].",
      "startOffset" : 290,
      "endOffset" : 293
    }, {
      "referenceID" : 2,
      "context" : "More details about CE recognition in RTEC may be found at [3].",
      "startOffset" : 58,
      "endOffset" : 61
    }, {
      "referenceID" : 4,
      "context" : "According to the use case survey of the Event Processing Technical Society [5], in the resulting dataset there are more SDEs per sec than in most applications.",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 1,
      "context" : "[2, 13, 19, 9]), has builtin axioms for complex temporal phenomena (as opposed to [26, 1]), explicitly represents CE intervals and thus avoids the related logical problems (as opposed to e.",
      "startOffset" : 0,
      "endOffset" : 14
    }, {
      "referenceID" : 12,
      "context" : "[2, 13, 19, 9]), has builtin axioms for complex temporal phenomena (as opposed to [26, 1]), explicitly represents CE intervals and thus avoids the related logical problems (as opposed to e.",
      "startOffset" : 0,
      "endOffset" : 14
    }, {
      "referenceID" : 18,
      "context" : "[2, 13, 19, 9]), has builtin axioms for complex temporal phenomena (as opposed to [26, 1]), explicitly represents CE intervals and thus avoids the related logical problems (as opposed to e.",
      "startOffset" : 0,
      "endOffset" : 14
    }, {
      "referenceID" : 8,
      "context" : "[2, 13, 19, 9]), has builtin axioms for complex temporal phenomena (as opposed to [26, 1]), explicitly represents CE intervals and thus avoids the related logical problems (as opposed to e.",
      "startOffset" : 0,
      "endOffset" : 14
    }, {
      "referenceID" : 25,
      "context" : "[2, 13, 19, 9]), has builtin axioms for complex temporal phenomena (as opposed to [26, 1]), explicitly represents CE intervals and thus avoids the related logical problems (as opposed to e.",
      "startOffset" : 82,
      "endOffset" : 89
    }, {
      "referenceID" : 0,
      "context" : "[2, 13, 19, 9]), has builtin axioms for complex temporal phenomena (as opposed to [26, 1]), explicitly represents CE intervals and thus avoids the related logical problems (as opposed to e.",
      "startOffset" : 82,
      "endOffset" : 89
    }, {
      "referenceID" : 21,
      "context" : "[22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 12,
      "context" : "[22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 8,
      "context" : "[22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 14,
      "context" : "[22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 13,
      "context" : "[22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]).",
      "startOffset" : 70,
      "endOffset" : 93
    }, {
      "referenceID" : 11,
      "context" : "[22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]).",
      "startOffset" : 70,
      "endOffset" : 93
    }, {
      "referenceID" : 8,
      "context" : "[22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]).",
      "startOffset" : 70,
      "endOffset" : 93
    }, {
      "referenceID" : 10,
      "context" : "[22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]).",
      "startOffset" : 70,
      "endOffset" : 93
    }, {
      "referenceID" : 19,
      "context" : "[22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]).",
      "startOffset" : 70,
      "endOffset" : 93
    }, {
      "referenceID" : 23,
      "context" : "[22, 13, 9, 15]), and supports out-oforder SDE streams (as opposed to [14, 12, 9, 11, 20, 24]).",
      "startOffset" : 70,
      "endOffset" : 93
    }, {
      "referenceID" : 7,
      "context" : "[8, 7, 23, 24, 6]) ‘forgets’ or represents concisely the SDE history.",
      "startOffset" : 0,
      "endOffset" : 17
    }, {
      "referenceID" : 6,
      "context" : "[8, 7, 23, 24, 6]) ‘forgets’ or represents concisely the SDE history.",
      "startOffset" : 0,
      "endOffset" : 17
    }, {
      "referenceID" : 22,
      "context" : "[8, 7, 23, 24, 6]) ‘forgets’ or represents concisely the SDE history.",
      "startOffset" : 0,
      "endOffset" : 17
    }, {
      "referenceID" : 23,
      "context" : "[8, 7, 23, 24, 6]) ‘forgets’ or represents concisely the SDE history.",
      "startOffset" : 0,
      "endOffset" : 17
    }, {
      "referenceID" : 5,
      "context" : "[8, 7, 23, 24, 6]) ‘forgets’ or represents concisely the SDE history.",
      "startOffset" : 0,
      "endOffset" : 17
    }, {
      "referenceID" : 7,
      "context" : "The ‘Cached Event Calculus’ [8] performs update-time reasoning: it computes and stores the consequences of a SDE as soon as it arrives.",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 15,
      "context" : "For further work, we are developing techniques, based on abductive-inductive logic programming, for automated generation and refinement of CE definitions from very large datasets, with the aim of minimising the time-consuming and error-prone process of manual CE definition construction [16].",
      "startOffset" : 287,
      "endOffset" : 291
    }, {
      "referenceID" : 16,
      "context" : "We are also porting RTEC into probabilistic logic programming frameworks, in order to deal with various types of uncertainty, such as imperfect CE definitions, incomplete and erroneous SDE streams [17].",
      "startOffset" : 197,
      "endOffset" : 201
    } ],
    "year" : 2015,
    "abstractText" : "Systems for symbolic event recognition accept as input a stream of time-stamped events from sensors and other computational devices, and seek to identify high-level composite events, collections of events that satisfy some pattern. RTEC is an Event Calculus dialect with novel implementation and ‘windowing’ techniques that allow for efficient event recognition, scalable to large data streams. RTEC can deal with applications where event data arrive with a (variable) delay from, and are revised by, the underlying sources. RTEC can update already recognised events and recognise new events when data arrive with a delay or following data revision. Our evaluation shows that RTEC can support real-time event recognition and is capable of meeting the performance requirements identified in a recent survey of event processing use cases. 4",
    "creator" : "TeX"
  }
}