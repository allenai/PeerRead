{
  "name" : "1708.04726.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Privacy-Enabled Biometric Search",
    "authors" : [ "Scott Streit" ],
    "emails" : [ "scott@scottstreit.com", "bqstreit@gmail.com", "ssuffian@villanova.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Privacy-Enabled Biometric Search Scott Streit\nComputer Science Innovations, LLC 16487 Frederick Road Woodbine, MD 21797\n+1-301-596-2550 scott@scottstreit.com\nBrian Streit DRN\n4150 International Plaza, Suite 800 Fort Worth, TX 76109\n+1-301-706-0908 bqstreit@gmail.com\nStephen Suffian Department of Electrical and\nComputer Engineering Villanova University\n800 East Lancaster Avenue, Villanova, PA 19085\nssuffian@villanova.edu Abstract— Biometrics have a long-held hope of replacing\npasswords by establishing a non-repudiated identity and providing authentication with convenience. Convenience drives consumers toward biometrics-based access management solutions. Unlike passwords, biometrics cannot be script-injected; however, biometric data is considered highly sensitive due to its personal nature and unique association with users. Biometrics differ from passwords in that compromised passwords may be reset. Compromised biometrics offer no such relief. A compromised biometric offers unlimited risk in privacy (anyone can view the biometric) and authentication (anyone may use the biometric). Standards such as the Biometric Open Protocol Standard (BOPS) (IEEE 2410-2016) provide a detailed mechanism to authenticate biometrics based on pre-enrolled devices and a previous identity by storing the biometric in encrypted form. This paper describes a biometric-agnostic approach that addresses the privacy concerns of biometrics through the implementation of BOPS. Specifically, two novel concepts are introduced. First, a biometric is applied to a neural network to create a feature vector. This neural network alone can be used for one-to-one matching (authentication), but would require a search in linear time for the one-to-many case (identity lookup). The classifying algorithm described in this paper addresses this concern by producing normalized floating-point values for each feature vector. This allows authentication lookup to occur in up to polynomial time, allowing for search in encrypted biometric databases with speed, accuracy and privacy.\nKeywords—component; formatting; style; styling; insert (key words)\nI. INTRODUCTION\nConvenience drives consumers toward the biometrics-based access management solutions. Studies show that 52% of smartphone users [5] want to use their fingerprints instead of a password, a further 61% want to use fingerprints to unlock their phones, and 48% want to use eye recognition. Biometrics have a long-held hope of replacing passwords by establishing a non-repudiated identity and providing authentication with convenience. While biometrics are increasingly becoming a preferred and convenient method for identity and authentication [4,6], there are currently serious concerns regarding the protection of biometric data. Biometrics include a wide range of information taken from a person, e.g., fingerprints, face, voice, iris pattern, etc. and his/her behavioral properties, e.g., gait, date, time, and location. Recent increases in the processing power and sensor technologies allow digital signal processing (DSP) algorithms to run in the time needed for a real-time authentication (1-5 seconds, similar to username and password login processing).\nUnlike passwords, biometrics cannot be script-injected; however, biometric data is considered highly sensitive due to its personal nature and unique association with users. Biometrics differ from passwords in that compromised passwords may be reset. Compromised biometrics offer no such relief. A compromised biometric offers unlimited risk in privacy (anyone can view the biometric) and authentication (anyone may use the biometric). Since resetting the biometric is impossible, the privacy of biometrics is of utmost concern.\nConsumer privacy concerns have been exacerbated by recent security breaches, such as those at Ashley Madison and Home Depot. For biometrics to penetrate the field of authentication and identification, users must remove themselves as impediments.\nCurrent transport-level encryption technology provides strong protection of the transmission of all types of data, including biometric data, that satisfies confidentiality, assurance, and non-repudiation requirements. These methods protect from an adversary listening in on communication. However, current biometric techniques require the use of plaintext search for matching, which means the biometric is visible. This paper describes techniques for matching and searching that address this problem by conducting matching in the encrypted space, thus allowing for biometric data to be immediately encrypted upon collection.\nII. EASE OF USE\nEncryption has been widely used for several millennia to protect information during transport [8]. The nature of the information dictated the levels and type of encryption required to protect it in transit in case of compromise [9].\nThe most popular form of modern encryption during data transit is the use of transport layer security (TLS) which is commonly called by its predecessor technology, secure socket layers (SSL). We generalize and abbreviate as (TLS/SSL). Additionally, 2-way SSL sits on top of TLS /SSL and is an identity protocol that uses a certificate exchange to identify an individual.\nIn the case of stored data, it has not been possible to encrypt all stored [15] data at the application level because of requirements for searching the data. Personally Identifiable Information (PII) requires encryption mechanisms and additional policies and processes [10,11,15] for data protection because any operation on the data demands decryption of that data for viewing and editing. For example,\n1 | P a g e\nHIPAA [15] requires the encryption of data in transport and offers policies for the release and dissemination of that data. The policy for cryptographic strength in this case is meant to protect against compromise of PII databases in cases of their theft. If operations could be performed, such as search, without decryption, data need not be exposed to potential compromise.\nBiometric data requires further protections by processes and policy that introduce the need for additional mechanisms including more sophisticated encryption [19]. One-to-one record match given a reference biometric and a new input record has been solved [19] but encrypted match and encrypted search remain an open problem.\nThe current state of biometrics is as follows:\n1. An enrollment takes place for a new device. This links a biometric to an identity. A key exchange takes place that links the enrolling device to an identity and a server. The biometric is stored either on the server or on the client.\n2. Each instance of a biometric differs. The key exchange from step 1 offers an initial layer of security. A likeliness value is then calculated between the initial biometric and the new biometric.\n3. A match result is then derived from step 2.\nCurrently, biometric searches require that the biometric be stored in a persistent and plaintext form. Existing stores are not general purpose and require the participants to agree to store their biometrics. It has thus far been infeasible, from a performance perspective, to search biometric data, even when it is stored as ciphertext, because the match is not direct. Two biometric instances of the same person vary, when in encrypted form, processing time becomes unacceptable as identification requires decryption of the biometric, and still an exhaustive search. Lastly and in some ways more importantly, the biometric is not one-way encrypted, meaning that ownership of the decryption key can allow for access to the plaintext biometric data."
    }, {
      "heading" : "A. Biometric Open Protocol Standard (BOPS)",
      "text" : "In 2013, no standard existed for the interoperability of biometrics or a set of best practices for biometrics. In July of 2013, a set of researchers formed IEEE Working Group 2410, the Biometric Open Protocol. The initial standard described a set of web service interfaces and a set of inter-operable processing rules. Products were built using IEEE 2410-2015.\nIn late 2014, it became clear that there were impediments prohibiting the large scale dissemination of biometrics. Vulnerabilities that were discovered in the initial BOPS specification, such as client-side malware attacks, led to the revision of BOPS in 2016 (BOPS II). BOPS II considers privacy and the threat of malware taking over a client device while simultaneously considering the risks associated with plaintext storage on the server. It provides a detailed mechanism to authenticate based on pre-enrolled devices and a previous identity by storing the biometric in encrypted form.\nBOPS II allows the match to take place in plaintext or as homomorphic encryption. The base practice is homomorphic encryption.\nBOPS I and BOPS II are based on the tested computerbased implementation of the Trusted Computer System Evaluation Criteria (TCSEC). BOPS conforms to the TCSEC, which is the United States Department of Defense standard that sets basic requirements for assessing the effectiveness of computer security controls built into a computer system. TCSEC was created by the National Computer Security Center, an arm of the National Security Agency (NSA) and is also frequently referred as “Orange Book, Section B1.” BOPS also conforms to the Director of the Central Intelligence Directive 6/3 protection level 3, level 4, and level 5 (PL3, PL4, and PL5), and to the standards of the Multiple Independent Levels of Security/Safety (MILS) architecture.\nThere are two primary use cases in which BOPS II could be implemented. The first is the one-to-one case: sending and receiving encrypted biometric data and comparing to an existing encrypted biometric sample. We consider this the authentication use case because given a biometric vector and an identity as input, we can authenticate (or deny) a given biometric vector if it matches an existing biometric vector corresponding to that identity.\nBOPS II also specifies functions for the one-to-many case: searching encrypted biometric records given a new biometric record. The only solution to this case is an \uD835\uDC42\uD835\uDC42(\uD835\uDC5B\uD835\uDC5B) exhaustive search in which each record is decrypted and compared. We consider this the identity use case because given a biometric vector as input, we can search and determine whether or not the given biometric is in a database. When storing profiles of users, we wish to use a biometric to find a user. However, even if we abate the concern for privacy, two biometrics from the same person will not match exactly. The inexact nature of this match leads a non-polynomial search, which is untenable and not implementable.\nBiometric identification in BOPS II may occur by storing the biometric in plaintext or the substantially more difficult method of storing the biometric data using homomorphic encryption, allowing for matching to be conducted in the encrypted space using Euclidean measurement algorithms. The risk to privacy is inversely proportional to the amount of time and operations that occur in the plaintext space. If biometrics are kept in plaintext one hundred percent of the time, this leaves a large window for any sort of privacy attack. Alternatively, if a biometric is gathered as ciphertext and all manipulations are done as ciphertext, there is no place where the biometric is plaintext and vulnerable. Matching in the encrypted space using a one-way encryption offers the highest level of privacy.\nBOPS II provides for data privacy in biometric store, biometric match and biometric search. Clearly, data privacy requires the encryption of the biometrics. The question is whether a solution exists that allows us to work entirely in the encrypted space. BOPS II as a specification offers a general\n2 | P a g e\nframework for biometric operations, but it does not offer a specific means of implementation. This paper provides a solution compliant with BOPS II for privacy-based match and search in a biometric-agnostic way, allowing for biometric matching in the encrypted space.\nThe rest of the paper is organized as follows. In Section 3, we formulate the problem with conducting biometric matching and search in encrypted space. In Section 4, we discuss our Methodology, which includes designing a Neural Network to acquire a feature vector that is then sent through a novel classification algorithm, allowing for biometric search between log(n) and n time.\nIII. PROBLEM FORMULATION The issue with current biometric schemes is they require a mechanism for: (1) acquiring the biometric, (2) plaintext biometric match, (3) encrypting the biometric, (4) performing a Euclidean-measurable match, and (5) searching using a one-to-many indexing scheme.\nTo do steps 1 through 5 for every biometric is time consuming, error-prone and frequently nearly impossible to do before the biometric becomes deprecated. Our goal is to develop a scheme, techniques and technologies that allow us to work with biometrics in a privacy-protected and polynomial-time based way that is also biometric-agnostic. We will use machine learning to solve problems (2) - (5). We focus much of our effort on (5) and allow points (1) - (4) to provide supplemental information.\nFinally, complete content and organizational editing before formatting. Please take note of the following items when proofreading spelling and grammar:"
    }, {
      "heading" : "A. Encryption",
      "text" : "Since we have little control over devices such as cameras or sensors, the biometric template arrives as plaintext. If we encrypt it immediately and only process it as ciphertext, we have the maximum practical level of privacy. An important part of offering this highest level of privacy is a one-way encryption algorithm, meaning that given ciphertext, there is no mechanism to get to the original plaintext. Many one-way encryption algorithms exist, such as MD5 and SHA-512. However, these algorithms are not homomorphic. This means we cannot do a closeness match between two ciphertext vectors using Euclidean measurements.\nThis paper explores and produces a general purpose solution that produces biometric ciphertext that is Euclideanmeasurable. We do this using a Neural Network. We then apply a classification algorithm to allow for one-to-many identification. This solution maximizes privacy and runs between \uD835\uDC42\uD835\uDC42(1) and \uD835\uDC42\uD835\uDC42(log(\uD835\uDC5B\uD835\uDC5B)) time.\nIV. METHODOLOGY In this Section, we first design a Neural Network for the encryption of a biometric, and then use a classification algorithm on the encrypted output to perform both one-to-one authentication and one-to-many identification. Matrix multiplications and several other operations are used in the\nneural network to translate an Initial Biometric Vector (IBV) into a Euclidean Measurable Feature Vector (EMFV), which is then stored. When a new biometric is submitted for matching/identification, this Current Biometric Vector (CBV) is sent through the neural network so it can be translated into an EMFV. These EMFVs are then used in a separate classification algorithm to perform one-to-many search between \uD835\uDC42\uD835\uDC42(1) and \uD835\uDC42\uD835\uDC42(log(\uD835\uDC5B\uD835\uDC5B)) time.\nThis paper uses the biometric of facial recognition to test the approach. However, the method was designed specifically to be implementable regardless of the type of biometric. We believe similar techniques will work for voice, fingerprints and a host of other biometrics. This is due to the use of feature vectors for encryption, which are the output of a neural network. The proposed classification algorithm acts on these feature vectors. This allows this general approach to be used despite varying biometrics, neural networks, and data."
    }, {
      "heading" : "A. Our Defined Neural Network",
      "text" : "We use a convolutional neural network for processing images and determining the correct cost function. The spatial size of the output volume can be computed as a function of the input volume size \uD835\uDC4A\uD835\uDC4A, the kernel field size of the convolutional layer neurons \uD835\uDC3E\uD835\uDC3E, the stride with which they are applied \uD835\uDC46\uD835\uDC46, and the amount of zero padding \uD835\uDC43\uD835\uDC43 used on the border. The formula for calculating how many neurons \"fit\" in a given volume is given by 1 + (\uD835\uDC4A\uD835\uDC4A −\uD835\uDC3E\uD835\uDC3E + 2\uD835\uDC43\uD835\uDC43)/\uD835\uDC46\uD835\uDC46. One of the objectives of this research is to find the ideal number of neurons and layers in the neural network. Fig. 1 below shows an activation function as a summation of a matrix of weights times the \uD835\uDC4B\uD835\uDC4B values. This yields a \uD835\uDC4C\uD835\uDC4C value.\nThe neural network is initially trained as a classifier using labeled biometric data. However, the traditional use of a neural network in this regard is neither novel nor scalable as it assumes the person is already stored and the images, from the training, are present. One cannot assume, or even fathom that we can train on every person available to our set.\nInstead, when an IBV is introduced into the neural network, the vector used in the n-1 layer can be used as a unique feature vector to identify that IBV but in the homomorphic encrypted space. This feature vector is Euclidean-measurable and encrypted.\n3 | P a g e\nThe feature vector replaces the biometric vector. The feature vector is a list of 256 floating-point numbers. It is impossible to reconstruct the biometric from a list of 256 floating-point numbers. The feature vector is therefore a oneway encryption. Feature vectors have the property of being Euclidean-measurable.\nAppendix 1 shows an example of our neural network. The initial image is applied to the neural network. We see the resulting softmax, which shows which of the defined “buckets” the image belongs. In this bucket, we have the images for the given individual. Next it shows us the matrix computations to create the softmax. Two convolutional steps prior to the softmax is fc7-conv which has the output from convolutional layer 7. This output is the feature vector.\nFor example, if the feature vector for person \uD835\uDC4B\uD835\uDC4B , as 256 values, when applied to the classifying function results in a floating-point number of \uD835\uDC4C\uD835\uDC4C . For all values near \uD835\uDC4C\uD835\uDC4C , we can identify the individual. We can only do this if our feature vector is Euclidean-measurable and classifying function is stable.\nAppendix 2, shows us the entire network. We have a variety of convolutional layers together with a rectifier (ReLU) and pooling nodes. The rectifier is, as of the publication of this paper, the most popular activation function for deep neural networks. The rectifier is an activation function defined as \uD835\uDC53\uD835\uDC53(\uD835\uDC65\uD835\uDC65) = max(0, \uD835\uDC65\uD835\uDC65).\nBeyond ReLU, our convolutional network uses pooling which is a form of non-linear down-sampling. We use a type of pooling algorithm called maxpooling, which partitions input images into a set of non-overlapping rectangles and, for each such sub-region, outputs the maximum. Once a feature has been found, its exact location is not as important as its relation to other features. The function of the pooling layer is to progressively reduce the spatial size of the representation to reduce the amount of parameters and computation in the network. Through the use of convolutions, ReLU and maxpooling, we get a reasonable size vector of 256 to use for matching, classifying and comparison.\nThe resultant encrypted, Euclidean-measurable feature vectors (EMFVs) from the neural network can later be used in the classification algorithm to receive a scalar value that can be compared to the feature vectors from other biometrics."
    }, {
      "heading" : "B. Our Classification Algorithm",
      "text" : "To use the feature vector for storage, we need to index it. For indexing we use a classification algorithm that, given an input feature vector, returns a floating-point number. This floating-point number is an index for storage. The classification algorithm has a dependence on a high-quality mean vector, which aids in creating distances between persons. The classification algorithm allows us to search and find the enrolled person in polynomial time.\nThe aforementioned floating-point number allows us to index search for a previously stored biometric. An appropriate classification algorithm gives us the intended person based on the input feature vector. Given a feature vector of 256 nonnegative integers, the procedure given below classifies this\nvector into the appropriate pool. Each pool is for one and only one distinct person. If the person is not found, it is assumed the algorithm will look for neighboring persons to complete the search.\nThe idea is to use distances to classify unknown vectors of the form \uD835\uDC65\uD835\uDC65 = (\uD835\uDC65\uD835\uDC650, \uD835\uDC65\uD835\uDC651,⋯ , \uD835\uDC65\uD835\uDC65255). Unless otherwise noted, \uD835\uDC65\uD835\uDC65\uD835\uDC56\uD835\uDC56 is a nonnegative integer for all \uD835\uDC56\uD835\uDC56 ∈ {0,1,⋯ ,255}. We define the distance between two vectors as \uD835\uDC51\uD835\uDC51(\uD835\uDC65\uD835\uDC65,\uD835\uDC66\uD835\uDC66) = ∑ |\uD835\uDC65\uD835\uDC65\uD835\uDC56\uD835\uDC56 − \uD835\uDC66\uD835\uDC66\uD835\uDC56\uD835\uDC56|255\uD835\uDC56\uD835\uDC56=0 . Let \uD835\uDC48\uD835\uDC48 be the set of known vectors and |\uD835\uDC48\uD835\uDC48| the number of vectors in \uD835\uDC48\uD835\uDC48. We will assume |\uD835\uDC48\uD835\uDC48| < ∞.\nThe mean of all vectors in \uD835\uDC48\uD835\uDC48 is given by \uD835\uDC5A\uD835\uDC5A\uD835\uDC48\uD835\uDC48 = 1 |\uD835\uDC48\uD835\uDC48|⁄ ∑ \uD835\uDC65\uD835\uDC65\uD835\uDC65\uD835\uDC65∈\uD835\uDC48\uD835\uDC48 and can be calculated explicitly if |\uD835\uDC48\uD835\uDC48| is sufficiently small. If |\uD835\uDC48\uD835\uDC48| is not sufficiently small, then \uD835\uDC5A\uD835\uDC5A\uD835\uDC48\uD835\uDC48 can be approximated. Note that the coordinates of \uD835\uDC5A\uD835\uDC5A\uD835\uDC48\uD835\uDC48 are not necessarily nonnegative integers.\nConsider a partition of \uD835\uDC48\uD835\uDC48 as \uD835\uDC48\uD835\uDC48 = ∐ \uD835\uDC43\uD835\uDC43\uD835\uDC57\uD835\uDC57\uD835\uDC57\uD835\uDC57 . We have observed experimentally that for each \uD835\uDC43\uD835\uDC43\uD835\uDC57\uD835\uDC57, there exist \uD835\uDC4E\uD835\uDC4E\uD835\uDC57\uD835\uDC57 , \uD835\uDC4F\uD835\uDC4F\uD835\uDC57\uD835\uDC57 ∈ (0,∞) such that \uD835\uDC51\uD835\uDC51(\uD835\uDC5A\uD835\uDC5A\uD835\uDC48\uD835\uDC48 ,\uD835\uDC66\uD835\uDC66) ∈ [\uD835\uDC4E\uD835\uDC4E\uD835\uDC57\uD835\uDC57 , \uD835\uDC4F\uD835\uDC4F\uD835\uDC57\uD835\uDC57] for all \uD835\uDC66\uD835\uDC66 ∈ \uD835\uDC43\uD835\uDC43\uD835\uDC57\uD835\uDC57 . Moreover, [\uD835\uDC4E\uD835\uDC4E\uD835\uDC57\uD835\uDC57 , \uD835\uDC4F\uD835\uDC4F\uD835\uDC57\uD835\uDC57] is disjoint from [\uD835\uDC4E\uD835\uDC4E\uD835\uDC58\uD835\uDC58, \uD835\uDC4F\uD835\uDC4F\uD835\uDC58\uD835\uDC58] for \uD835\uDC57\uD835\uDC57 ≠ \uD835\uDC58\uD835\uDC58 . In other words, bands of distances from the mean vector can be used to classify unknown vectors.\nGiven a vector \uD835\uDC66\uD835\uDC66 ∉ \uD835\uDC48\uD835\uDC48, we calculate \uD835\uDC51\uD835\uDC51(\uD835\uDC5A\uD835\uDC5A\uD835\uDC48\uD835\uDC48 ,\uD835\uDC66\uD835\uDC66) to determine how to uniquely extend partitions of U to partitions of \uD835\uDC49\uD835\uDC49 = \uD835\uDC48\uD835\uDC48 ∪ {\uD835\uDC66\uD835\uDC66} . If \uD835\uDC51\uD835\uDC51(\uD835\uDC5A\uD835\uDC5A\uD835\uDC48\uD835\uDC48 ,\uD835\uDC66\uD835\uDC66) ∉ [\uD835\uDC4E\uD835\uDC4E\uD835\uDC57\uD835\uDC57 ,\uD835\uDC4F\uD835\uDC4F\uD835\uDC57\uD835\uDC57] for all j, then the interval [\uD835\uDC4E\uD835\uDC4E\uD835\uDC57\uD835\uDC57 , \uD835\uDC4F\uD835\uDC4F\uD835\uDC57\uD835\uDC57] closest to y is chosen and the subset \uD835\uDC43\uD835\uDC43\uD835\uDC57\uD835\uDC57 associated with this interval is chosen to include y in the extension of the original partition to a partition of \uD835\uDC49\uD835\uDC49 . If it happens that y is equidistant to two different intervals, then the subset in which to include y in the partition of \uD835\uDC49\uD835\uDC49 is not well-defined. In this case, the numerical results should be re-examined and a better choice for at least one of the two intervals equidistant to \uD835\uDC66\uD835\uDC66 should be made.\nV. RESULTS We used 257 images for training. The Neural Network is a 32 node, 8 convolution layer network. The training allocates the appropriate weights to the network. With this trained network, we apply a new face for either storage or lookup. In either case, we put the face through the neural network and at convolutional layer 7 we have a feature vector.\nUsing a set of images, and applying our neural network we receive the following EMFV at convolutional layer 7. An example of part of one such output is below:\n0.83215457, 0, 0.97926098, 2.34792662, 6.1617651, 6.31998634 2.36983943, 3.691468, 3.82195878, 0.94054723, 1.48430574, 3.68506813, 3.71155834, 0.73430908, 1.13436747, 2.62325954, 2.40342426, 1.69623852, 1.55817235, 1.41169822, 0.89341599\nFor a set of 15 persons and 257 images the results are desirable. The feature vector classifies to a specific person within runtime \uD835\uDC42\uD835\uDC42(1) . Using the algorithm, as specified in Section 4.1, we have ranges of three individuals. Using normalized vectors, the resulting ranges of images are as follows. For Person 1, our normalized distances range from .85\n4 | P a g e\nto 1.12. For Person 2 our range is from 1.18 to 1.32. For Person 3, our normalized distances range from .39 to .68.\nAs a practical example, subsequent IBVs of person one, when given to the neural network and classification algorithm, will produce results between .85 and 1.12. Similarly, subsequent IBVs for person 3 will yield results between .39 and .68. These acceptable ranges offer us banding for each person. Therefore, the idea is we see banding and no collisions for the bands between persons. For small sets of data, our results are exact.\nVI. DISCUSSION Our hypothesis is as follows:\n1. We can use deep learning to do more than categorize.\n2. The feature vectors from machine learning are Euclidean-measurable and stable.\n3. We use feature vectors for one to one match guaranteeing us homomorphic encryption. We have the highest level of privacy.\n4. Our classification algorithm allows us to search, given a feature vector as input.\nConclusions 1 through 3 appear exact. Conclusion 4 requires more data and testing.\nThe numeric ranges after the application of our classification algorithm offer us buckets for search. Each bucket results in the selection of an individual.\nVII. FUTURE WORK We anticipate continued work in the area of indexing based on feature vectors. The results hold for smaller sets, we wish to see if the indexing and classification algorithm holds over set of hundreds of thousands of individuals.\nWe will also experiment with the mean vectors looking for wider banding between the categorization values on a person by person basis.\nWe also will do a combinatorial analysis to determine the order of the classification algorithm. We will find if the runtime of the classifier is \uD835\uDC42\uD835\uDC42(1) or \uD835\uDC42\uD835\uDC42(log(\uD835\uDC5B\uD835\uDC5B)).\nVIII. CONCLUSION In conclusion, we see that deep learning solves the homomorphic encryption problem for one to one match. Adding our classification algorithm, to the results of the neural network offers us a solution for search.\nWe match based upon the IBV as input, the application of the neural network the resulting feature vector. We then use the feature vector, with our classification algorithm to provide indexed search."
    } ],
    "references" : [ {
      "title" : "The quest to replace passwords: A framework for comparative evaluation of Web authentication schemes",
      "author" : [ "J. Bonneau", "C. Herley", "P.C. van Oorschot", "F. Stajano" ],
      "venue" : "Proceedings 2012 IEEE Symposium on Security and Privacy, S&P 2012, San Francisco, CA, pp. 553–567, May 2012.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Mordani, JavaTM Servlet Specification, Version 3.1",
      "author" : [ "S.W. Chan" ],
      "venue" : "Redwood Shores, CA: Oracle America, Inc.,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2013
    }, {
      "title" : "JAX-RS: JavaTM API for RESTful Web Services, Version 1.0",
      "author" : [ "M. Handley" ],
      "venue" : "Santa Clara: CA: Sun Microsystems, Inc.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2008
    }, {
      "title" : "IBM Research",
      "author" : [ "D. Nahamoo" ],
      "venue" : "IBM 5 in 5: Biometric data will be the key to personal security, 2011.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "PayPal and the National Cyber Security Alliance Unveil Results of New Mobile Security Survey",
      "author" : [ "PayPal Stories" ],
      "venue" : "2015.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "The 10 Hot Consumer Trends of 2014 Report",
      "author" : [ "Slideshare.net" ],
      "venue" : "2013.",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Department of Defense Trusted Computer System Evaluation Criteria",
      "author" : [ "U.S. Department of Defense", "DoD 5200.28-STD" ],
      "venue" : "December 1985.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "The Quest to Replace Passwords: A Framework for Comparative Evaluation of Web Authentication Schemes",
      "author" : [ "Joseph Bonneau", "Joseph", "Herley", "Cormac", "Van Oorschot", "Paul", "Stajano", "Frank" ],
      "venue" : "IEEE Symp. Security and Privacy,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "smartphone users [5] want to use their fingerprints instead of a password, a further 61% want to use fingerprints to unlock their phones, and 48% want to use eye recognition.",
      "startOffset" : 17,
      "endOffset" : 20
    }, {
      "referenceID" : 3,
      "context" : "While biometrics are increasingly becoming a preferred and convenient method for identity and authentication [4,6], there are currently serious concerns regarding the protection of biometric data.",
      "startOffset" : 109,
      "endOffset" : 114
    }, {
      "referenceID" : 5,
      "context" : "While biometrics are increasingly becoming a preferred and convenient method for identity and authentication [4,6], there are currently serious concerns regarding the protection of biometric data.",
      "startOffset" : 109,
      "endOffset" : 114
    } ],
    "year" : 2017,
    "abstractText" : "Biometrics have a long-held hope of replacing passwords by establishing a non-repudiated identity and providing authentication with convenience. Convenience drives consumers toward biometrics-based access management solutions. Unlike passwords, biometrics cannot be script-injected; however, biometric data is considered highly sensitive due to its personal nature and unique association with users. Biometrics differ from passwords in that compromised passwords may be reset. Compromised biometrics offer no such relief. A compromised biometric offers unlimited risk in privacy (anyone can view the biometric) and authentication (anyone may use the biometric). Standards such as the Biometric Open Protocol Standard (BOPS) (IEEE 2410-2016) provide a detailed mechanism to authenticate biometrics based on pre-enrolled devices and a previous identity by storing the biometric in encrypted form. This paper describes a biometric-agnostic approach that addresses the privacy concerns of biometrics through the implementation of BOPS. Specifically, two novel concepts are introduced. First, a biometric is applied to a neural network to create a feature vector. This neural network alone can be used for one-to-one matching (authentication), but would require a search in linear time for the one-to-many case (identity lookup). The classifying algorithm described in this paper addresses this concern by producing normalized floating-point values for each feature vector. This allows authentication lookup to occur in up to polynomial time, allowing for search in encrypted biometric databases with speed, accuracy and privacy. Keywords—component; formatting; style; styling; insert (key words)",
    "creator" : "Acrobat PDFMaker 11 for Word"
  }
}