{
  "name" : "1305.0187.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Community Based Algorithm for Large Scale Web Service Composition",
    "authors" : [ "Chantal Cherifi", "Yvan Rivierre", "Jean-François Santucci" ],
    "emails" : [ "chantalbonner@gmail.com", "Yvan.Rivierre@imag.fr", "santucci@univ-corse.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "available Web services in order to satisfy a client request that cannot be treated by any available Web services. The Web services space is a dynamic environment characterized by a huge number of elements. Furthermore, many Web services are offering similar functionalities. In this paper we propose a model for Web service composition designed to address the scale effect and the redundancy issue. The Web services space is represented by a two-layered network architecture. A concrete similarity network layer organizes the Web services operations into communities of functionally similar operations. An abstract interaction network layer represents the composition relationships between the sets of communities. Composition synthesis is performed by a two-phased graph search algorithm. First, the interaction network is mined in order to discover abstract solutions to the request goal. Then, the abstract compositions are instantiated with concrete operations selected from the similarity network. This strategy allows an efficient exploration of the Web services space. Furthermore, operations grouped in a community can be easily substituted if necessary during the composition's synthesis's process.\nKeywords: Web services, composition, substitution, interaction, similarity, community, network, graph search algorithm"
    }, {
      "heading" : "1. Introduction",
      "text" : "The paradigm of Web service is gaining more and more popularity with companies and organizations that are interested in lowering the cost of the development and maintaining of their applications. Indeed, Web services are software systems designed to support interoperable machine-to-machine interaction over a network. They allow enterprises to implement their core business as services over the Internet. Once published in a registry by providers, they can be discovered and invoked by business partners or clients. In order to achieve new and more useful functionalities, they can be programmatically loosely coupled through the Web . Resulting value-added composite Web services can satisfy a user request when no atomic Web service is able to do it. Automatic and dynamic composition process nevertheless raises interesting challenges. Among them is the scale effect; Web services are numerous on the Web and their number is increasing with time. Besides, they are created, changed, relocated, or even removed on the fly; this volatile aspect is another source of complexity. Another particularity is that lot of them provide overlapping or identical functionalities with eventually different quality of service. This results in a huge, intricate and dynamic space to be explored. The topic always stirs researcher interest and various propositions have been made to meet the challenges.\nMany proposals address Web service composition as a planning problem [1], [2]. With the increasing number of available Web services, such solutions suffer from their high complexity and a prohibitive computational cost. Other approaches treat the composition as a graph search problem. Indeed, in the composition context, the Web services space can naturally be represented by a network of interacting atomic Web services. In [3], compositions are discovered within a semantic Web service network by a forward chaining algorithm. In [4], search of compositions in a syntactic Web service network is performed using graph matching techniques. In [5], a semantic Web service network is stored in a relational database. Composition search is done by SQL statements. In [6], a breadth first search algorithm is used\nto search for compositions in a semantic network of parameters. In [7], the information on link analysis of a semantic Web service interaction network is used to guide the A* shortest path search algorithm that probe the Web service space. The authors in [8], use the A* search algorithm to find a minimal composition within a subset of semantic Web services represented as a graph. The approach in [9] proposed the use of a semantic interaction network enriched with an organization of the Web services in communities. This is an ontological organization where communities are sets of Web services providing services in the same domain. The network is used to search for compositions through a forward chaining algorithm. In [10], the authors propose a dynamic Web service composition algorithm based on the combination of ant colony algorithm and genetic algorithm, to address the efficiency issue in a large solution space. In [11], genetic algorithms allow quality of service-aware Web service composition. The authors in [12] propose a framework to deal with data distribution and quality of service issues by solving problems of unavailability of updated information and inaccessibility of Web services. Note that there is a great deal of work addressing the composition issue not only according to the Web services functional requirements, but also to their transactional properties their QoS characteristics or the security problems [13], [14].\nIn current solutions, discovery and composition processes take place within a predefined space which is a repository of individual and atomic Web services. Even, if they can solve some key issues in Web service composition, none of them gives an effective solution to address the scaling and redundancy effect. In this paper, we present a graph search based approach to overcome these shortcomings. We propose to use a two-layered network architecture to store interaction and similarity functional relationships that occur between the operations of Web services. Note that we consider operations rather than Web services as atomic element because it is at this level that Web services are used. In order to reach a request goal, a composition search algorithm explores the two network layers in two pass. First, an “abstract interaction network” is mined in order to retrieve a set of meta-operations that satisfies a given goal. Then, the meta-operations are instantiated with real operations extracted from a similarity network. The similarity network gives opportunities to substitute operations that offer similar functionalities. This need is susceptible to happen either when a user is not satisfied with non functional aspects of a Web service, i.e. quality of service, or when a Web service is out of service for different reasons. The interaction layer is built above the similarity layer. Similar operations are grouped into a single meta-operation in order to reduce the search space during the first phase of the algorithm. The main features of our proposal are that it allows: 1) Reducing the search space by using similarity between Web services functionalities. 2) Taking advantage of this similarity to give opportunities to substitute Web services and to efficiently deal with redundancy.\nThe rest of this paper is organized as follows. In section 2, we present the two-layered network architecture and we describe the abstract layer and the instance layer. Section 3 is devoted to our composition algorithm with details on the two phases. Finally, we end the article in section 4 by discussing some conclusions and directions for future work."
    }, {
      "heading" : "2. The two-layered architecture",
      "text" : "Our approach for Web service composition is based on a structure of two networks. An abstract interaction network is used to discover a set of meta-operations that can potentially satisfy a goal. A concrete similarity network allows to instantiate them with actual and available Web service operations. Groups of similar operations are pre-existing structures stored in a network of similar concrete operations. Composition of meta-operations is a pre-existing structure stored in a network of interacting meta-operations. They can be upgraded easily when new Web services appear."
    }, {
      "heading" : "2.1. Instance layer",
      "text" : "The instance layer represents all concrete operations of published Web services. They can be\npotentially invoked to fulfill a request. They are organized in a similarity network.\nA similarity network of operations is a graph whose nodes correspond to Web service operations and links indicate that two operations offer similar functionalities. As our main concern is to deal with Web services substitution, we consider that two operations are similar if they allow reaching more or less the same goal. Hence, to determine the similarity, we consider input and output parameters. We consider four similarity levels called Full Similarity, Partial Similarity, Excess Similarity and Relation Similarity [15]. They are defined in terms of set relations between the input and the output parameter sets of the compared operations. Suppose we want to compare two operations o1 and o2. Let Ii be the set of input parameters, and Oi the set of output parameters for operation oi. A FullSim network is obtained using a symmetrical function such that two operations are fully similar if and only if 1) they provide exactly the same outputs (O1 = O2) and 2) they need overlapping inputs (I1 ⋂ I2 ≠ ∅). PartialSim and ExcessSim networks are associated to asymmetrical functions. In the former, o2 is partially similar to o1 if and only if 1) some o1 outputs are missing in o2 (O1 ⊃ O2) and 2) they need overlapping inputs (I1 ⋂ I2 ≠ ∅). In the latter, o2 is similar to o1 with excess if and only if 1) o2 provides all o1 outputs plus additional ones (O1 ⊂ O2) and 2) o2 needs only some of o1 inputs (I1 ⊇ I2). A RelationSim network uses a symmetrical function. Two operations have a relational similarity if and only if 1) they have exactly the same outputs (O1 = O2) and 2) they do not share common input (I1 ⋂ I2 = ∅). In the following, the instance layer is realized by a FullSim network of operations. For short, we will refer to it as “similarity network of operations”. It is the most satisfying level of similarity from a substitution point of view. Nevertheless, even if they offer a less effective solution, the other networks can be also considered. All the similarity networks exhibit a component structure [15]. A component is a maximal connected sub-graph i.e. a set of interconnected nodes, all disconnected from the rest of the network. Each component materializes a community, i.e. a group of similar operations. The lower part of Figure 1 represents the communities extracted from a set of 8 operations. There are four communities represented by different colors. The operations with the same color belong to the same community. Note that communities are non-overlapping and include all the network nodes.\nA remarkable structure within the components is the clique. A clique is a fully connected sub-network. In a similarity network of operations, a clique contains operations that share at least a common input parameter. In the lower part of Figure 1, operations (o2, o3, o4) form the largest clique of the network, with b as common parameter. Operations in a same clique are the most likely to be substituted."
    }, {
      "heading" : "2.2. Meta-layer",
      "text" : "The meta-layer enables to search for compositions in a reduced space of an interaction network of meta-operations. A meta-operation is the representative of a community in the instance layer. We define a set of input parameters and a set of output parameters for each meta-operation. The set of input parameters of a meta-operation is defined as the union of the inputs of all the operations of the corresponding community. Similarly, the output parameter set of a meta-operation is the union of the output parameter set of the operations of the underlying community. Meta-operations are linked together to form an interaction network of meta-operations.\nAn interaction network of meta-operations is a directed graph N (V, E), where V is the set of nodes representing the meta-operations and E is the set of links representing their interactions. Let two meta-operations mi and mj ∊ V, there is a directed link (mi, mj) ∊ E, if and only if mi can interact with mj. Meta-operations interact according to the partial invocation mode. In other words, a meta-operation mi can interact with a meta-operation mj, if and only if mi has at least one output parameter which is similar to one of the input parameters of mj.\nFigure 1, illustrates this two-layered architecture. Meta-operations are represented with roundedcorner boxes, above the underlying connected components (communities) of the similarity network. By convention, all notations related to the meta-layer are written in cursive script, in order to distinguish it from the rest of the model.\nThe upper part of Figure 1 represents an interaction network with four meta-operations, m1, m2, m3 and m4, extracted from the four components of the similarity network illustrated in the lower part of the\nfigure. Operations o1, o2, o3 and o4 are represented by the meta-operation m1, operations o5 and o6 are represented by the meta-operation m2, and operations o7 and o8 are represented by meta-operations m3 and m4 respectively. Links are labeled with the set of parameters that enable the invoking metaoperation to interact with the invoked meta-operation. m1 interacts with m2 trough parameter e, m3 interacts with m2 trough parameter e and m4 interacts with m3 trough parameter f."
    }, {
      "heading" : "3. Composition algorithm",
      "text" : "The composition process consists of two steps. In the first step, the meta-operation network is explored to search for a meta-composition that fits a user request. It is performed using a graph-based approach, starting from the goal of a service’s request and composing backwards in the direction of the input of the service request. This meta-composition wraps all possible compositions. If no metacomposition is found, it implies that no composition could have been found anyway. In the second step, the meta-composition is instantiated into compositions of operations. By instantiating we mean replacing the abstract meta-operations by concrete operations of the similarity network of the instance layer. A composition of operations is a sequence of operations sorted by invocation order. It does not contain the functional relations between these operations, but they can be easily inferred. Note that the sequence is only used for simplifying the formalism. Even if formally expressed as a sequence of operations, composition can be either sequential, parallel dependent or parallel independent.\nThe algorithm can find all the compositions that fit a user request. Depending on its needs and as long as he is not satisfied by the returned composition, a user can call the second step several times, in order to obtain other possible compositions. It is a valuable behavior, because retrieving all possible compositions can be very expensive. We assume that the user is interested in getting a suitable composition without missing an opportunity of composition, rather than getting all possible ones."
    }, {
      "heading" : "3.1. Environment",
      "text" : "This environment is defined for formalizing both steps of the general composition algorithm. K is the set of parameters known by the user, i.e. the input part of the request. G is the set of desired parameters, i.e. the goal part of the request. N = (V, E) is the operation similarity network. N = (V, E) is the meta-operation interaction network built on top of N. The following primitives are used to explore a network. Label(m, m’) returns the label of edge (m, m’) in N. Input(m) returns the input parameters of m. Output(m) returns the output parameters of m. Pred(m, network) returns the predecessors of m in network. Since a meta-composition is a sub-network of N, it can be considered as a network as well. Finally, the two kinds of the results provided by the general composition\nalgorithm are stored into variables declared as follows. C is the meta-composition to be built at first step, and instantiated at second step. This is a network of meta-operations. C is the composition to be built at second step, by instantiating the meta-composition C. This is a sequence of operations. The two steps of the algorithm are detailed in the following sub-sections."
    }, {
      "heading" : "3.2. Find Meta-composition",
      "text" : "Find meta-composition is the first step of the general composition algorithm. It consists of finding a meta-composition C which fits the request. The goal G must be supplied by meta-operations of C. Only K, that contains the parameters known by the user, can be used. This step is called exactly one time per user request. If there is no meta-composition which can fulfill the whole goal, false is returned.\nThe first step of the general composition algorithm is formalized in Procedure 1. First, metaoperations which supply at least a part of the goal G are listed as candidate. They serve as entry points to begin the N network exploration (line 4: build initial candidate paths). Then, a backward search is performed from each of these starting points as follows. When visiting a meta-operation m from a specific path, there are two possibilities for adding path meta-operations to C. Either at least one input parameter of m is known by the user (line 9) or m has at least a predecessor of m that is already in C (line 12: path head is already in meta-composition). To pursue the exploration from m, incident links are followed if and only if they provide at least an unknown parameter (line 15) and they don’t lead to an already visited meta-operation (line 1: at least a parameter can be obtained from m and no cycle is created). The latest condition ensures that the exploration does not follow cyclic paths and eventually terminates. Finally it verifies (line 21: effectively supplied parts of the goal) that each part of the goal G can be provided by at least a meta-operation of the resulting meta-composition C. If it is effectively the case, it successfully returns C. Otherwise it returns false as an indication that no composition can fulfill the request.\nThe first step of the general composition algorithm depends on the declarations below. The following variables are locally declared for this step. Path is the currently visited path of metaoperations in N. Next is the set of candidate paths for further iterations. The primitives hereafter are used in this step only. Add(path, meta-composition) adds meta-operations of path to metacomposition. Head(path) returns the head element of path. Pop(set of paths) returns and removes a candidate path from set of paths. Suppliers(parameters, network) returns meta-operations in network which supply at least one of parameters. This primitive is used to search for the goal.\nAfter this step, the meta-operations interaction network N is no more considered in its integrity. Only its sub-network defined by the meta-composition C stands in scope of the second step of the general composition algorithm."
    }, {
      "heading" : "3.3. Instantiate Meta-composition",
      "text" : "The second step of the general composition algorithm consists in instantiating the meta-composition C found at the first step. This step can be called several times. At each call of the instantiation step, another composition is built from the same meta-composition until no more composition can be found.\nThe second step of the general composition algorithm is formalized in Procedure 2. The sets of meta-operations that cover the goal are processed one after the other. Those meta-operations are the starting points for the similarity network exploration. After this initialization (line 1 and 2: at first use, (re)initialize the set of meta-operations used to reach the goal) the network is explored for a next instantiation setup (line 4), either by instantiating a meta-operation m to a different operation, or by using another set of input-covering meta-operations for m. If there are no more possible instantiation for this set of goal-covering meta-operations, then (line 11) the next set of goal-covering metaoperations is selected. If there are no goal-covering sets left, it means that all instances have been already returned by previous call to this instantiation procedure. Finally, the network is explored (line 19), without modification, for extracting and returning the selected instance of the meta-composition.\nThe last step of the general composition algorithm depends on the declarations below. At each call of this step, the following local variables are declared. HasNext returns true if a meta-operation has another instance or covering set to be used next, false else. Visited is the set of meta-operations that have been visited before. It is used in order to avoid infinite recursion.\nThe meta-composition C is persistently backed with additional variables, in order to select the appropriate nodes and links of the meta-composition. One of these variables is used to iterate over meta-operations sets that cover the goal. There are two additional variables per meta-operation. The first one is iterating over invocable instances of a meta-operation. The second variable iterates over meta-operations sets that cover input of its instance. All of these variables can exclusively be used through the following primitives. GetGoalCover() returns the selected set of meta-operations to cover the goal. If none is selected, false is returned. Initially, no set is selected. NextGoalCover() selects and returns the next set of meta-operations to cover the goal. If there is none, it deselects the currently selected set and returns false. GetInstance(m) returns the selected instance for meta-operation m. If none is selected, false is returned. Initially no instance is selected. NextInstance(m) selects and returns the next invocable instance for meta-operation m. If there is none, it deselects the currently selected instance and returns false. It also deselects the currently selected cover. GetInCover(m) returns the selected set of meta-operations that covers input of the selected instance for meta-operation m. If there is none, false is returned. Initially no set is selected. NextInCover(m) selects and returns the next set of meta-operations that covers input of the selected instance for meta-operation m. If there is none, it deselects the currently selected set and returns false.\nAt the end, two subroutines are defined in Procedure 3 and Procedure 4, in order to handle recursive search through the meta-composition network C. GetOpSeq(m) returns a sequence of operations which instantiates the sub-network of C which ends to m. It is recursively defined and uses the Visited set of meta-operations in order to avoid infinite recursion. NextOpSeq(m) returns true if there is a next possible instantiation of the sub-network of C which ends to m. It is recursively defined and uses the Visited set of meta-operations in order to avoid infinite recursion.\nProcedure 1. Find meta-composition 1: C ← ∅ 2: Next ← ∅ 3: for all m ∈ Suppliers(G, N) do 4: Next ← Next ∪ {{m}} 5: end for 6: while Next ≠ ∅ do 7: Path ← Pop(Next) 8: if Input(Head(Path)) ⋂ K ≠ ∅ then 9: Add(Path, C) 10: end if 11: if Head(Path) ∈ C then 12: Add(Path, C) 13:else 14:for all m ∈ Pred(Head(Path),N) do 15:if(Label(m,Head(Path))\\K ≠ ∅) ∧ (m∉Path) then 16: Next ← Next ∪ {{m}.Path} 17: end if 18: end for 19: end if 20:end while 21:Supplied ← ∅ 22:for all m ∈ Suppliers(G, N) do 23: Supplied ← Supplied ∪ Output(m) 24: end for 25: if G ⊆ Supplied then 26: return C 27:else 28: return ⊥ 29:end if\nProcedure 2. Instantiate meta-composition 1: if GetCoverGoal( ) = ⊥ then 2: NextCoverGoal( ) 3: end if 4: HasNext ← Next ⊥ 5: Visited ← Next ∅ 6: for all m ∈ GetCoverGoal( ) do 7: if HasNext = ⊥ then 8: NasNext ← NextOpSeq(m) 9: end if 10: end for 11: if HasNext = ⊥ then 12: NextCoverGoal( ) 13: if GetCoverGoal( ) = ⊥ then 14: return ⊥ 15: else 16: HasNext ← ⊤ 17: end if 18: end if 19: C ← ∅ 20: Visited ← ∅ 21: for all m ∈ GetCoverGoal( ) do 22: if GetInstance(m) ≠ C then 23: C ← NextOpSeq(m).C 24: end if 25: end for 26: return C\nProcedure 3. Instanciation Subroutine 1: procedure GetOpSeq(m) /returns operations sequence for subnetwork of C ending with m/ 2: Visited ← Visited ∪ {m} 3: if GetInstance(m) = ⊥ then /switch to first instanciation setup of m/ 4: NextInstance(m) 5: NextInCover(m) 6: end if 7: OpSeq ← {GetInstance(m)} /initialize operations sequence with m/ 8: for all m’ ∉ Visited ∧ m’ ∈ GetInCover(m ) do 9: OpSeq ← GetOpSeq(m’).OpSeq /prefix operations sequence with the one of m’/ 10: end for 11: return OpSeq 12: end procedure Procedure 4. Iteration Over Instances 1: procedure NextOpSeq(m) /return ⊤ if there is a next operations sequence for m or one of its predecessors, ⊥ else/ 2: Visited ← Visited ∪ {m} 3: if GetInstance(m ) = ⊥ then 4: return ⊤ /m has to be (re)initialized/ 5: end if 6: for all m’ ∉ Visited ^ m’ ∧ ∈ GetInCover(m ) do 7: if NextOpSeq(m’) then 8: return ⊤ /there is a next instanciation of m’/ 9: end if 10: end for 11: if NextInCover(m) ≠ ⊥ then 12: return ⊤ /there is a next input cover of the currently\nselected instance for m/ 13: end if 14: if NextInstance(m) ≠ ⊥ then 15: NextInCover(m) 16: return ⊤ /there is a next instance for m/ 17: end if 18: return ⊥ /there is no next instance of m/ 19: end procedure"
    }, {
      "heading" : "3.4 Example",
      "text" : ""
    }, {
      "heading" : "3.4.1 Find a meta-composition",
      "text" : "Given a user request with knowledge K = {a}, goal G = {x, y, z}, and N the interaction network of\nmeta-operations in Figure 2, Procedure 1 is used to find a meta-composition C within N.\nFirst, m1, m2 and m3 are the only meta-operations to supply at least a part of the goal. They provide initial nodes to explore N. The zero-length path {m1} is considered at first. Since a is known and one of its input parameter, m1 is selected for meta-composition. Path {m4, m1} is hold for further exploration. {m7, m1} is ignored because a is already known and m1 does not need b. When considered, {m4, m1} is finally discarded because no input parameters of m4 is known.\nThen, zero-length path {m2} is considered before paths {m5, m2}, {m6, m5, m2} and {m7, m6, m5, m2}. Among those, only {m6, m5, m2} has a first meta-operation with a known input parameter, thus its nodes are selected as a meta-composition. Although m5 is a predecessor of m7, path {m5, m7, m6, m5, m2} is not hold for exploration, because it would be cycling at m5.\nAt the end, the zero-length path {m3} is considered and discarded because no one of its input parameter is known. Then {m5, m3} is considered. Its first meta-operation is already in the metacomposition as it is a suffix of an invocable path; thus m3 is also added to the meta-composition. The resulting meta-composition is a sub-network of N restricted to vertices {m1, m2, m3, m5, m6, m7}."
    }, {
      "heading" : "3.4.2 Refined the meta-composition",
      "text" : "Given the meta-composition C, in Figure 3(left), resulting from the previous step, Procedure 5 is used to refine C. It guarantees that the refined meta-composition C is only composed of instantiable meta-operations. The refined meta-composition is no more a sub-network of N. It is still an interaction network, but with slightly modified meta-operations. Compared to the meta-composition as found at the previous step, while m7 is removed from meta-operations, o1’’ and o6’ are removed from the underlying operations of their respective meta-operations m1 and m6. m1 is replaced by m1’. The resulting meta-composition is {m1’, m2, m3, m5, m6}.\nGiven the refined meta-composition resulting from the previous step, Procedure 2 is used to instantiate this refined meta-composition. As shown in Figure 3(right), there are two alternatives that cover the goal, one with {m1’, m3}, the other with {m2, m3}. There are also two possible instances for m1’, the operations o1 and o1’. Even if they are functionally equivalent, they might have different implementations, or belong to different Web services. Hence they are prone to have different nonfunctional properties. At the end, instantiated compositions are: {o6, o5, o3, o1}, {o6, o5, o3, o1’} and {o6, o5, o3, o2}. Note that if no solutions are found in the FullSim network, the others similarity networks can be considered, depending on user’s preferences.\nProcedure 5. Refine meta-composition 1: Grays ← C 2: WasMod ← ⊤ 3: while Grays ≠ ∅ ∧ WasMod do 4: WasMod ← ⊥ 5: for all m ∈ Grays do 6: K’ ← ∅ 7: K’’ ← ∅ 8: for all m’ ∈ Pred(m , C) do 9: if m’ ∈ Grays then /gray meta-operations are in Grays/ 10: K” ←K” ∪ Label(m’, m) 11: else if m’ C ∈ then \\instanciable meta-operations are in C \\ Grays\\ 12: K’ ← K’ ∪ Label(m’, m) 13: end if 14: end for 15: for all o ∈ m do 16: if Input(o) ⊆ K ∪ K’ then 17: Grays←Grays \\ {m } \\assert that m is instanciable\\ 18: WasMod ← ⊥ 19: else if Input(o) ⊈ K ∪ K’ ∪ K’’ then 20: m←m \\ {o} \\assert that o is not invokable\\ 21: end if 22: end for 23: end for 24: end while 25: C←C \\ Grays \\remove gray meta-operations from meta-composition C\\"
    }, {
      "heading" : "4. Conclusion",
      "text" : "In this paper we proposed a two-layered architecture to tackle the large scale and redundancy issue occurring in Web service composition synthesis. This architecture is based on network representations of the Web services space. A concrete layer is made of communities of similar Web services operations. It is realized by a similarity network of operations. An abstract layer is made of interacting meta-operations, each meta-operation being the representative of a community. It is realized by an interaction network of meta-operations. A graph-based search algorithm acts in two phases to explore the network architecture. In the first phase, it starts from the desired goal of a request for exploring the interaction network and retrieve a meta-composition. In the second phase, it starts from the metacomposition found during the first phase and explores the similarity network to replace the metaoperations by corresponding operations.\nThe main contribution of the proposed approach is to reduce drastically the search space as compared to previous graph based approaches. Indeed structuring the Web services operation space into communities allows dealing efficiently with the redundancy issue. Furthermore, similar operations can be easily substituted. This aspect is of great value because Web services are highly volatile.\nHowever, our algorithm presents some limitations. It is unable to select the most valuable composition according to user criteria, without requiring an exhaustive instantiation of the metacomposition. Furthermore it does not consider subsumption relationships of ontological concepts in order to define operations similarity and it does not take advantage of the topological structure of the networks. Our future work will address these issues."
    }, {
      "heading" : "5. References",
      "text" : "[1] G. Vadivelou, E. IIavarasan, S. Prasanna, “Algorithm for Web Service Composition\nusing Multi-Agents,” International Journal of Computer Applications, Foundation of Computer Science, Vol. 13, No. 8, pp. 40-45, 2011.\n[2] W. Liu, Y. Y. Du, B. Q. Guo, Yan. C, Q. Xu, “A Fast Algorithm for Web Service Composition\nBased on Dynamic Description Logic,” Information Technology Journal, Asian Network for Scientific Information, Vol. 9, No. 6, pp. 1150-1157, 2010.\n[3] H. Talantikite, D. Aissani, N. Boudjlida, “Semantic annotations for web services discovery and\ncomposition,” Computer Standards Interfaces, Elsevier B.V., Vol. 31, No. 6, pp. 1108-1117, 2009.\n[4] J. Liu, L. Chao, “Web Services as a Graph and Its Application for Service Discovery,” In\nproceedings of International Conference on Grid and Cooperative Computing, IEEE, pp. 293- 300, 2006.\n[5] J. Kwon, K. Park, D. Lee, S. Lee, “PSR : Pre-computing Solutions in RDBMS for Fast Web\nServices Composition Search,” In proceedings of International Conference on Web Services, IEEE, pp. 808-815, 2007.\n[6] S. V. Hashemian, F. Mavaddat, “A Graph-Based Approach to Web Services Composition,” In\nproceedings of Symposium on Applications and the Internet, IEEE, pp. 183-189, 2005.\n[7] J. Gekas, M. Fasli, “Employing Graph Network Analysis for Web Service Composition,”\nInternational Journal of Information Technology and Web Engineering, IGI Global, Vol. 2, No. 4, 2008.\n[8] P. Rodriguez-Mier, M. Mucientes, M. Lama, “Automatic Web Service Composition with a\nHeuristic-Based Search Algorithm,” In proceedings of International Conference on Web Services, IEEE, pp. 81-88, 2011.\n[9] I. Arpinar, B. Aleman-Meza, R. Zhang, A. Maduko, “Ontology-driven web services\ncomposition platform,” Inf. Syst. E-Business Management, Vol. 3, No. 2, pp. 175-199, 2005.\n[10] Z. Yang, C. Chang, Q. Liu, C. Zhao, “A Dynamic Web Services Composition Algorithm Based\non the Combination of Ant Colony Algorithm and Genetic Algorithm,” Journal of Computational Information Systems, Springer, Vol. 6, No. 8, pp. 2617-2622, 2010.\n[11] L. Ai, “QoS-Aware Web service composition using genetic algorithms,” Queensland\nUniversity of Technology, pp. 250, 2011.\n[12] F. H. Khan, F. Y. Javed, S. Bashir, A. Khan, M. S. Khiyal, “QoS Based Dynamic Web\nServices Composition & Execution,” International Journal of Computer Science and Information Security, IJCSIS Publication, Vol. 7, No. 2, 2010.\n[13] M. Q. Saleem, J. B. Jaafar, M. F. Hassan, \"A Framework for the Model Driven Development\nof Secure Web Services Composition,\" International Journal of Advances in Information Sciences and Service Sciences, AICIT, Vol.4, No 9, pp. 67-78, 2012\n[14] X. Wu, C. Chen, H. Huang, “A Survey on Web Service Composition: from service description,\nautomatic process generation to process evaluation,” International Journal of Digital Content Technology and its Applications, AICIT, Vol. 6, No. 17, pp. 483-495, 2012.\n[15] C. Cherifi, V. Labatut, J. F. Santucci, “Topological Properties of Web Services Similarity\nNetworks,” Strategic Advantage of Computing Information Systems in Enterprise Management, ATINER, pp. 105-117, 2010."
    } ],
    "references" : [ {
      "title" : "Algorithm for Web Service Composition using Multi-Agents",
      "author" : [ "G. Vadivelou", "E. IIavarasan", "S. Prasanna" ],
      "venue" : "International Journal of Computer Applications, Foundation of Computer Science, Vol. 13, No. 8, pp. 40-45, 2011.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A Fast Algorithm for Web Service Composition Based on Dynamic Description Logic",
      "author" : [ "W. Liu", "Y.Y. Du", "B.Q. Guo", "Yan. C", "Q. Xu" ],
      "venue" : "Information Technology Journal, Asian Network for Scientific Information, Vol. 9, No. 6, pp. 1150-1157, 2010.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Semantic annotations for web services discovery and composition",
      "author" : [ "H. Talantikite", "D. Aissani", "N. Boudjlida" ],
      "venue" : "Computer Standards Interfaces, Elsevier B.V., Vol. 31, No. 6, pp. 1108-1117, 2009.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Web Services as a Graph and Its Application for Service Discovery",
      "author" : [ "J. Liu", "L. Chao" ],
      "venue" : "proceedings of International Conference on Grid and Cooperative Computing, IEEE, pp. 293- 300, 2006.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "PSR : Pre-computing Solutions in RDBMS for Fast Web Services Composition Search",
      "author" : [ "J. Kwon", "K. Park", "D. Lee", "S. Lee" ],
      "venue" : "proceedings of International Conference on Web Services, IEEE, pp. 808-815, 2007.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "A Graph-Based Approach to Web Services Composition",
      "author" : [ "S.V. Hashemian", "F. Mavaddat" ],
      "venue" : "proceedings of Symposium on Applications and the Internet, IEEE, pp. 183-189, 2005.",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Employing Graph Network Analysis for Web Service Composition",
      "author" : [ "J. Gekas", "M. Fasli" ],
      "venue" : "International Journal of Information Technology and Web Engineering, IGI Global, Vol. 2, No. 4, 2008.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Automatic Web Service Composition with a Heuristic-Based Search Algorithm",
      "author" : [ "P. Rodriguez-Mier", "M. Mucientes", "M. Lama" ],
      "venue" : "proceedings of International Conference on Web Services, IEEE, pp. 81-88, 2011.",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Ontology-driven web services composition platform",
      "author" : [ "I. Arpinar", "B. Aleman-Meza", "R. Zhang", "A. Maduko" ],
      "venue" : "Inf. Syst. E-Business Management, Vol. 3, No. 2, pp. 175-199, 2005.",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "A Dynamic Web Services Composition Algorithm Based on the Combination of Ant Colony Algorithm and Genetic Algorithm",
      "author" : [ "Z. Yang", "C. Chang", "Q. Liu", "C. Zhao" ],
      "venue" : "Journal of Computational Information Systems, Springer, Vol. 6, No. 8, pp. 2617-2622, 2010.",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "QoS-Aware Web service composition using genetic algorithms",
      "author" : [ "L. Ai" ],
      "venue" : "Queensland University of Technology, pp. 250, 2011.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "QoS Based Dynamic Web Services Composition & Execution",
      "author" : [ "F.H. Khan", "F.Y. Javed", "S. Bashir", "A. Khan", "M.S. Khiyal" ],
      "venue" : "International Journal of Computer Science and Information Security, IJCSIS Publication, Vol. 7, No. 2, 2010.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A Framework for the Model Driven Development of Secure Web Services Composition",
      "author" : [ "M.Q. Saleem", "J.B. Jaafar", "M.F. Hassan" ],
      "venue" : "International Journal of Advances in Information Sciences and Service Sciences, AICIT, Vol.4, No 9, pp. 67-78, 2012",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A Survey on Web Service Composition: from service description, automatic process generation to process evaluation",
      "author" : [ "X. Wu", "C. Chen", "H. Huang" ],
      "venue" : "International Journal of Digital Content Technology and its Applications, AICIT, Vol. 6, No. 17, pp. 483-495, 2012.",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Topological Properties of Web Services Similarity Networks",
      "author" : [ "C. Cherifi", "V. Labatut", "J.F. Santucci" ],
      "venue" : "Strategic Advantage of Computing Information Systems in Enterprise Management, ATINER, pp. 105-117, 2010.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Many proposals address Web service composition as a planning problem [1], [2].",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 1,
      "context" : "Many proposals address Web service composition as a planning problem [1], [2].",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 2,
      "context" : "In [3], compositions are discovered within a semantic Web service network by a forward chaining algorithm.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 3,
      "context" : "In [4],",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 4,
      "context" : "In [5], a semantic Web service network is stored in a relational database.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 5,
      "context" : "In [6], a breadth first search algorithm is used",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 6,
      "context" : "In [7], the information on link",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 7,
      "context" : "The authors in [8], use the A* search algorithm to find a minimal composition within a subset of semantic Web services represented as a graph.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 8,
      "context" : "The approach in [9] proposed the use of a semantic interaction network enriched with an organization of the Web services in communities.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 9,
      "context" : "In [10], the authors propose a dynamic Web service composition algorithm based on the combination of ant colony algorithm and genetic algorithm, to address the efficiency issue in a large solution space.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 10,
      "context" : "In [11], genetic algorithms allow quality of service-aware Web service composition.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 11,
      "context" : "The authors in [12] propose a framework to deal with data distribution and quality of service issues by solving problems of unavailability of updated information and inaccessibility of Web services.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 12,
      "context" : "Note that there is a great deal of work addressing the composition issue not only according to the Web services functional requirements, but also to their transactional properties their QoS characteristics or the security problems [13], [14].",
      "startOffset" : 231,
      "endOffset" : 235
    }, {
      "referenceID" : 13,
      "context" : "Note that there is a great deal of work addressing the composition issue not only according to the Web services functional requirements, but also to their transactional properties their QoS characteristics or the security problems [13], [14].",
      "startOffset" : 237,
      "endOffset" : 241
    }, {
      "referenceID" : 14,
      "context" : "We consider four similarity levels called Full Similarity, Partial Similarity, Excess Similarity and Relation Similarity [15].",
      "startOffset" : 121,
      "endOffset" : 125
    }, {
      "referenceID" : 14,
      "context" : "All the similarity networks exhibit a component structure [15].",
      "startOffset" : 58,
      "endOffset" : 62
    } ],
    "year" : 2013,
    "abstractText" : "Web service composition is the process of synthesizing a new composite service using a set of available Web services in order to satisfy a client request that cannot be treated by any available Web services. The Web services space is a dynamic environment characterized by a huge number of elements. Furthermore, many Web services are offering similar functionalities. In this paper we propose a model for Web service composition designed to address the scale effect and the redundancy issue. The Web services space is represented by a two-layered network architecture. A concrete similarity network layer organizes the Web services operations into communities of functionally similar operations. An abstract interaction network layer represents the composition relationships between the sets of communities. Composition synthesis is performed by a two-phased graph search algorithm. First, the interaction network is mined in order to discover abstract solutions to the request goal. Then, the abstract compositions are instantiated with concrete operations selected from the similarity network. This strategy allows an efficient exploration of the Web services space. Furthermore, operations grouped in a community can be easily substituted if necessary during the composition's synthesis's process.",
    "creator" : "Microsoft® Office Word 2007"
  }
}