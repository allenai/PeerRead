{
  "name" : "1605.02038.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Markov Chain methods for the bipartite Boolean quadratic programming problem",
    "authors" : [ "Daniel Karapetyana", "Abraham P. Punnen", "Andrew J. Parkes" ],
    "emails" : [ "daniel.karapetyan@gmail.com", "apunnen@sfu.ca", "andrew.parkes@nottingham.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We study the Bipartite Boolean Quadratic Programming Problem (BBQP) which is an extension of the well known Boolean Quadratic Programming Problem (BQP). Applications of the BBQP include mining discrete patterns from binary data, approximating matrices by rank-one binary matrices, computing the cut-norm of a matrix, and solving optimisation problems such as maximum weight biclique, bipartite maximum weight cut, maximum weight induced subgraph of a bipartite graph, etc. For the BBQP, we first present several algorithmic components, specifically, hill climbers and mutations, and then show how to combine them in a high-performance metaheuristic. Instead of hand-tuning a standard metaheuristic to test the efficiency of the hybrid of the components, we chose to use an automated generation of a multi-component metaheuristic to save human time, and also improve objectivity in the analysis and comparisons of components. For this we designed a new metaheuristic schema which we call Conditional Markov Chain Search (CMCS). We show that CMCS is flexible enough to model several standard metaheuristics; this flexibility is controlled by multiple numeric parameters, and so is convenient for automated generation. We study the configurations revealed by our approach and show that the best of them outperforms the previous state-of-the-art BBQP algorithm by several orders of magnitude. In our experiments we use benchmark instances introduced in the preliminary version of this paper and described here, which have already become the de facto standard in the BBQP literature.\nKeywords: artificial intelligence, bipartite Boolean quadratic programming, automated heuristic configuration, benchmark"
    }, {
      "heading" : "1. Introduction",
      "text" : "The (Unconstrained) Boolean Quadratic Programming Problem (BQP) is to\nmaximise f(x) = xTQ′x+ c′x+ c′0\nsubject to x ∈ {0, 1}n,\nwhere Q′ is an n× n real matrix, c′ is a row vector in Rn, and c′0 is a constant. The BQP is a well-studied problem in the operational research literature [6]. The focus of this paper is on a problem closely related to BQP, called the Bipartite (Unconstrained) Boolean Quadratic Programming Problem (BBQP) [23]. BBQP can be defined as follows:\nmaximise f(x, y) = xTQy + cx+ dy + c0\nsubject to x ∈ {0, 1}m, y ∈ {0, 1}n,\nwhereQ = (qij) is anm×n real matrix, c = (c1, c2, . . . , cm) is a row vector in Rm, d = (d1, d2, . . . , dn) is a row vector\n∗Corresponding author. Tel: +44 1206 872861 Email addresses: daniel.karapetyan@gmail.com (Daniel\nKarapetyan), apunnen@sfu.ca (Abraham P. Punnen), andrew.parkes@nottingham.ac.uk (Andrew J. Parkes)\nin Rn, and c0 is a constant. Without loss of generality, we assume that c0 = 0, and m ≤ n (which can be achieved by simply interchanging the rows and columns if needed). In what follows, we denote a BBQP instance built on matrix Q, row vectors c and d and c0 = 0 as BBQP(Q, c, d), and (x, y) is a feasible solution of the BBQP if x ∈ {0, 1}m and y ∈ {0, 1}n. Also xi stands for the ith component of the vector x and yj stands for the jth component of the vector y.\nA graph theoretic interpretation of the BBQP can be given as follows [23]. Let I = {1, 2, . . . ,m} and J = {1, 2, . . . , n}. Consider a bipartite graph G = (I, J, E). For each node i ∈ I and j ∈ J , respective costs ci and dj are prescribed. Furthermore, for each (i, j) ∈ E, a cost qij is given. Then the Maximum Weight Induced Subgraph Problem on G is to find a subgraph G′ = (I ′, J ′, E′) such that∑\ni∈I′ ci + ∑ j∈J′ dj + ∑ (i,j)∈E′ qij is maximised, where I ′ ⊆ I, J ′ ⊆ J and G′ is induced by I ′ ∪ J ′. The Maximum Weight Induced Subgraph Problem on G is precisely the BBQP, where qij = 0 if (i, j) /∈ E.\nThere are some other well known combinatorial optimisation problems that can be modelled as a BBQP. Consider the bipartite graph G = (I, J, E) with wij being the weight of the edge (i, j) ∈ E. Then the Maximum Weight\nPreprint submitted to Elsevier\nar X\niv :1\n60 5.\n02 03\n8v 2\n[ cs\n.D S]\n2 4\nO ct\n2 01\n6\nBiclique Problem (MWBP) [4, 26] is to find a biclique in G of maximum total edge-weight. Define\nqij = { wij if (i, j) ∈ E, −M otherwise,\nwhere M is a large positive constant. Set c and d as zero vectors. Then BBQP(Q, c, d) solves the MWBP [23]. This immediately shows that the BBQP is NP-hard and one can also establish some approximation hardness results with appropriate assumptions [4, 26]. Note that the MWBP has applications in data mining, clustering and bioinformatics [7, 27] which in turn become applications of BBQP.\nAnother application of BBQP arises in approximating a matrix by a rank-one binary matrix [10, 16, 17, 19, 25]. For example, let H = (hij) be a given m×n matrix and we want to find an m× n matrix A = (aij), where aij = uivj and ui, vj ∈ {0, 1}, such that ∑m i=1 ∑n j=1(hij − uivj)2 is minimised. The matrix A is called a rank one approximation of H and can be identified by solving the BBQP with qij = 1 − 2hij , ci = 0 and dj = 0 for all i ∈ I and j ∈ J . Binary matrix factorisation is an important topic in mining discrete patterns in binary data [19, 25]. If ui and vj are required to be in {−1, 1} then also the resulting factorisation problem can be formulated as a BBQP.\nThe Maximum Cut Problem on a bipartite graph (MaxCut) can be formulated as BBQP [23] and this gives yet another application of the model. BBQP can also be used to find approximations to the cut-norm of a matrix [3].\nFor theoretical analysis of approximation algorithms for BBQP, we refer to [22].\nA preliminary version of this paper was made available to the research community in 2012 [15]. Subsequently Glover et al. [11] and Duarte et al. [9] studied heuristic algorithms for the problem. The testbed presented in our preliminary report [15] continues to be the source of benchmark instances for the BBQP. In this paper, in addition to providing a detailed description of the benchmark instances, we refine the algorithms reported in [15], introduce a new class of algorithms and give a methodology for automated generation of a multi-component metaheuristic. By (algorithmic) component we mean a black box algorithm that modifies the given solution. All the algorithmic components can be roughly split into two categories: hill climbers, i.e. components that guarantee that the solution not be worsened, and mutations, i.e. components that usually worsen the solution. Our main goals are to verify that the proposed components are sufficient to build a high-performance heuristic for BBQP and also investigate the most promising combinations. By this computational study, we also further support the ideas in the areas of automated parameter tuning and algorithm configuration (e.g. see [1, 5, 13, 14]). Thus we rely entirely on automated configuration. During configuration, we use smaller instances compared to those in our benchmark. This way we ensure that we do not over-train our metaheuristics to the benchmark instances – an issue that is often quite hard\nto avoid with manual design and configuration. We apply the resulting multi-component metaheuristic to our benchmark instances demonstrating that a combination of several simple components can yield powerful metaheuristics clearly outperforming the state-of-the-art BBQP methods.\nThe main contributions of the paper include:\n• In Section 2, we describe several BBQP algorithmic components, one of which is completely new.\n• In Section 3 we take the Markov Chain idea, such as in the Markov Chain Hyper-heuristic [20], but restrict it to use static weights (hence having no online learning, and so, arguably, not best labelled as a “hyper-heuristic”), but instead adding a powerful extension to it, giving what we call “Conditional Markov Chain Search (CMCS)”.\n• In Section 4 we describe five classes of instances corresponding to various applications of BBQP. Based on these classes, a set of benchmark instances is developed. These test instances were first introduced in the preliminary version of this paper [15] and since then used in a number of papers [9, 11] becoming de facto standard testbed for the BBQP.\n• In Section 5 we use automated configuration of CMCS to demonstrate the performance of individual components and their combinations, and give details sufficient to reproduce all of the generated metaheuristics. We also show that a special case of CMCS that we proposed significantly outperforms several standard metaheuristics, on this problem.\n• In Section 6 we show that our best machine-generated metaheuristic is, by several orders of magnitude, faster than the previous state-of-the-art BBQP method."
    }, {
      "heading" : "2. Algorithmic Components",
      "text" : "In this section we introduce several algorithmic components for BBQP. Except for ‘Repair’ and ‘MutationX/Y’, these components were introduced in [15]. A summary of the components discussed below is provided in Table 1. The components are selected to cover a reasonable mix of fast and slow hill climbing operators for intensification, along with mutation operators that can be expected to increase diversification, and with Repair that does a bit of both. Note that a hill climbing component can potentially implement either a simple improvement move or a repetitive local search procedure with iterated operators that terminates only when a local maximum is reached. However in this project we opted for single moves leaving the control to the metaheuristic framework.\nName Description\n— Hill climbing operators: that is, components guaranteeing that the solution will not be worsened OptX Optimise-X, Section 2.1. Fixes vector y while optimising x. OptY As OptX, but reversing roles of x and y. FlpX Flip-X, Section 2.2. Checks if flipping xi for some i ∈ I and subsequently optimising y improves the solution. FlpY As FlpX, but reversing roles of x and y.\n— Mutations: that is, components that may worsen the solution Repair Repair, Section 2.3. Finds a single term of the objective function that can be improved and “repairs” it. MutX4 Mutation-X(4), Section 2.4. Flips xi for four randomly picked i ∈ I. MutY4 As MutX4, but reversing roles of x and y. MutX16 As MutX4, but for 16 randomly picked xi. MutY16 As MutY4, but for 16 randomly picked yi.\nTable 1: List of the algorithmic components used in this paper, and described in Section 2\n2.1. Components: Optimise-X / Optimise-Y\nObserve that, given a fixed vector x, we can efficiently compute an optimal y = yopt(x):\nyopt(x)j = 1 if ∑ i∈I qijxi + dj > 0,\n0 otherwise. (1)\nThis suggests a hill climber operator Optimise-Y (OptY) that fixes x and replaces y with yopt(x). Equation (1) was first introduced in [23] and then used as a neighbourhood search operator in [15], [9] and [11].\nOptY implements a hill climber operator in the neighbourhood NOptY(x, y) = {(x, y′) : y′ ∈ {0, 1}n}, where (x, y) is the original solution. Observe that the running time of OptY is polynomial and the size of the neighbourhood |NOptY(x, y)| = 2n is exponential; hence OptY corresponds to an operator that could be used in a very large-scale neighbourhood search (VLNS), a method that is often considered as a powerful approach to hard combinatorial optimisation problems [2].\nObserve that OptY finds a local maximum after the first application because N(x, y) = N(x, yopt(y)) (that is, it is an “idempotent operator”); hence, there is no gain from applying OptY again immediately after it was applied. Though, for example, iterating and alternating between between OptX and OptY would give a VLNS.\nNote that yopt(x)j can take any value if ∑\ni∈I qijxi + dj = 0, without affecting the objective value of the solution. Thus, one can implement various “tie breaking” strategies including randomised decision whether to assign 0 or 1 to yopt(x)j , however in that case OptY would become non-deterministic. In our implementation of OptY we preserve the previous value by setting yopt(x)j = yj for every j such that ∑ i∈I qijxi+dj = 0. As will be explained in Section 5.1, changing a value yj is a relatively expensive operation and thus, whenever not necessary, we prefer to avoid such a change.\nBy interchanging the roles of rows and columns, we\nalso define\nxopt(y)i = 1 if ∑ j∈J qijyj + ci > 0,\n0 otherwise,\n(2)\nand a hill climber operator Optimise-X (OptX) with properties similar to those of OptY.\n2.2. Components: Flip-X / Flip-Y\nThis class of components is a generalisation of the previous one. In Flip-X (FlpX), we try to flip xi for every i ∈ I, each time re-optimising y. More formally, for i = 1, 2, . . . ,m, we compute x′ = (x1, . . . , xi−1, 1 − xi, xi+1, . . . , xm) and then verify if solution (x ′, yopt(x ′)) is an improvement over (x, y). Each improvement is immediately accepted, but the search carries on for the remaining values of i. In fact, one could consider a generalisation of Flip-X that flips xi for several i at a time. However, exploration of such a neighbourhood would be significantly slower, and so we have not studied such a generalisation in this paper.\nBy row/column interchange, we also introduce the FlipY (FlpY) hill climbing operator. Clearly, FlpX and FlpY are also VLNS operators, though unlike OptX and OptY they are not idempotent and so could be used consecutively.\nFlpX and FlpY were first proposed in [23] and then used in [11].\n2.3. Components: Repair\nWhile all the above methods were handling entire rows or columns, Repair is designed to work on the level of a single element of matrix Q. Repair is a new component inspired by the WalkSAT heuristic for SAT problem [21, 24] in that it is a version of ‘iterative repair’ [28] that tries to repair some significant ‘flaw’ (deficiency of the solution) even if this results in creation of other flaws, in a hope that the newly created flaws could be repaired later. This behaviour, of forcing the repair of randomly selected flaws,\ngives some stochasticity to the search that is also intended to help in escaping from local optima.\nRecall that the objective value of BBQP includes terms qijxiyj . For a pair (i, j), there are two possible kinds of flaws: either qij is negative but is included in the objective value (i.e. xiyj = 1), or it is positive and not included in the objective value (i.e. xiyj = 0). The Repair method looks for such flaws, especially for those with large |qij |. For this, it uses the tournament principle; it randomly samples pairs (i, j) and picks the one that maximises (1 − 2xiyj)qij . Once an appropriate pair (i, j) is selected, it ‘repairs’ the flaw; if qij is positive then it sets xi = yj = 1; if qij is negative then it sets either xi = 0 or yj = 0 (among these two options it picks the one that maximises the overall objective value). Our implementation of Repair terminates after the earliest of two: (i) finding 10 flaws and repairing the biggest of them, or (ii) sampling 100 pairs (i, j).\nNote that one could separate the two kinds of flaws, and so have two different methods: Repair-Positive, that looks for and repairs only positive ‘missing’ terms of the objective function, and Repair-Negative, that looks for and repairs only negative included terms of the objective function. However, we leave these options to future research.\n2.4. Components: Mutation-X / Mutation-Y\nIn our empirical study, we will use some pure mutation operators of various strengths to escape local maxima. For this, we use the NOptX(x, y) neighbourhood. Our Mutation-X(k) operator picks k distinct x variables at random and then flips their values, keeping y unchanged. Similarly we introduce Mutation-Y(k). In this paper we use k ∈ {4, 16}, and so have components which we call MutX4, MutX16, MutY4 and MutY16.\nAn operator similar to Mutation-X/Y was used in [9]."
    }, {
      "heading" : "3. The Markov Chain Methods",
      "text" : "The algorithmic components described in Section 2 are designed to work within a metaheuristic; analysis of each component on its own would not be sufficient to conclude on its usefulness within the context of a multi-component system. To avoid bias due to picking one or another metaheuristic, and to save human time on hand-tuning it, we chose to use a generic schema coupled with automated configuration of it."
    }, {
      "heading" : "3.1. Conditional Markov Chain Search (CMCS)",
      "text" : "The existing framework that was closest to our needs was the Markov Chain Hyper-Heuristic (MCHH) [20]. MCHH is a relatively simple algorithm that applies components in a sequence. This sequence is a Markov chain; the ‘state’ in the Markov chain is just the operator that is to be applied, and so the Markov nature means that the transition to a new state (component/operator) only depends on the\ncurrently-applied component and transition probabilities. Transition probabilities, organised in a transition matrix, are obtained in MCHH dynamically, by learning most successful sequences.\nWhile MCHH is a successful approach capable of effectively utilising several algorithmic components, it does not necessarily provide the required convenience of interpretation of performance of individual components and their combinations because the transition probabilities in MCHH change dynamically. To address this issue, we chose to fix the transition matrix and learn it offline. We can then perform the analysis by studying the learnt transition probabilities.\nThe drawback of learning the probabilities offline is that MCHH with static transition matrix receives no feedback from the search process and, thus, has no ability to respond to the instance and solution properties. To enable such a feedback, we propose to extend the state of the Markov chain with the information about the outcome of the last component execution; this extension is simple but will prove to be effective. In particular, we suggest to distinguish executions that improved the solution quality, and executions that worsened, or did not change, the solution quality.\nWe call our new approach Conditional Markov Chain Search (CMCS). It is parameterised with two transition matrices: M succ for transitions if the last component execution was successful (improved the solution), and M fail for transitions if the last component execution failed (has not improved the solution).1\nCMCS does not in itself employ any learning during the search process, but is configured by means of offline learning, and so the behaviour of any specific instance of CMCS is defined by two matrices M succ and M fail of size |H|×|H| each. Thus, we refer to the general idea of CMCS as schema, and to a concrete instance of CMCS, i.e. specific values of matrices M succ and M fail, as configuration.\nFor the termination criterion, we use a predefined time after which CMCS terminates. This is most appropriate, as well as convenient, when we need to compare metaheuristics and in which different components run at different speeds so that simple counting of steps would not be a meaningful termination criterion.\nCMCS requires an initial solution; this could have been supplied from one of the several construction heuristics\n1 Note that executions that do not change the solution quality at all are also considered as a failure. This allows us to model a hill climber that is applied repeatedly until it becomes trapped in a local maximum.\nLet H be the pool of algorithmic components. CMCS is a singlepoint metaheuristic that applies one component h ∈ H at a time, accepting both improving and worsening moves. The next component h′ ∈ H to be executed is determined by a function next : H → H. In particular, h′ is chosen using roulette wheel with probabilities phh′ of transition from h to h′ defined by matrix Msucc if the last execution of h was successful and M fail otherwise. All the moves are always accepted in CMCS. Pseudo-code of the CMCS schema is given in Algorithm 1.\nAlgorithm 1: Conditional Monte-Carlo Search\ninput : Ordered set of components H; input : Matrices M succ and M fail of size |H| × |H|; input : Objective function f(S) to be maximised; input : Initial solution S; input : Termination time terminate-at ;\n1 S∗ ← S; 2 h← 1; 3 while now < terminate-at do 4 fold ← f(S); 5 S ← Hh(S); 6 fnew ← f(S); 7 if fnew > fold then 8 h←\nRouletteWheel(M succh,1 ,M succ h,2 , . . . ,M succ h,|H|);\n9 if f(S) > f(S∗) then 10 S∗ ← S;"
    }, {
      "heading" : "11 else",
      "text" : "12 h← RouletteWheel(M failh,1 ,M failh,2 , . . . ,M failh,|H|);"
    }, {
      "heading" : "13 return S∗;",
      "text" : "developed for BBQP [15, 9], however, to reduce potential bias, we initialise the search with a randomly generated solution with probability of each of xi = 1 and yj = 1 being 50%."
    }, {
      "heading" : "3.2. CMCS properties",
      "text" : "Below we list some of the properties of CMCS that make it a good choice in our study. We also believe that it will be useful in future studies in a similar way.\n• CMCS is able to combine several algorithmic components in one search process, and with each component taken as a black box.\n• CMCS has parameters for inclusion or exclusion of individual components as we do not know in advance if any of our components have poor performance. This is particularly true when considering that performance of a component might well depend on which others are available – some synergistic combinations might be much more powerful than the individuals would suggest.\n• CMCS has parameters that permit some components to be used more often than others as some of our hill climbing operators are significantly faster than others; this also eliminates the necessity to decide in advance on the frequency of usage of each of the components. Appropriate choices of the parameters should allow the imbalance of component runtimes to be exploited.\n• CMCS is capable of exploiting some (recent) history of the choices made by the metaheuristic, as there\nmight be efficient sequences of components which should be exploitable.\n• As we will show later, CMCS is powerful enough to model some standard metaheuristics and, thus, allows easy comparison with standard approaches.\n• The performance of CMCS does not depend on the absolute values of the objective function; it is rankbased in that it only uses the objective function to find out if a new solution is better than the previous solution. This property helps CMCS perform well across different families of instances. In contrast, methods such as Simulated Annealing, depend on the absolute values of the objective function and thus often need to be tuned for each family of instances, or else need some mechanism to account for changes to the scale of the objective function.\n• The transition matrices of a tuned CMCS configuration allow us conveniently interpret the results of automated generation."
    }, {
      "heading" : "3.3. Special cases of CMCS",
      "text" : "Several standard metaheuristics are special cases of CMCS. If H = {HC,Mut} includes a hill climbing operator “HC” and a mutation “Mut” then\nM succ =  HC MutHC 1 0 Mut 1 0  and M fail =\n HC MutHC 0 1 Mut 1 0  implements Iterated Local Search [18]; the algorithm repeatedly applies HC until it fails, then applies Mut, and then returns to HC disregarding the success or failure of Mut.\nIf M succh,h′ = M fail h,h′ = 1/|H| for all h, h′ ∈ H then CMCS implements a simple uniform random choice of component [8].\nA generalisation of the uniform random choice is to allow non-uniform probabilities of component selection. We call this special case Operator Probabilities (Op. Prob.) and model it by setting M succh,h′ = M fail h,h′ = ph′ for some vector p of probabilities. Note that Operator Probabilities is a static version of a Selection Hyper-heuristic [8].\nObviously, if M succ = M fail then CMCS implements a static version of MCHH.\nBy allowing M succ 6= M fail, it is possible to implement a Variable Neighbourhood Search (VNS) using the CMCS schema. For example, if\nM succ =  HC1 HC2 HC3 Mut\nHC1 1 0 0 0 HC2 1 0 0 0 HC3 1 0 0 0 Mut 1 0 0 0\n\nand\nM fail =  HC1 HC2 HC3 Mut\nHC1 0 1 0 0 HC2 0 0 1 0 HC3 0 0 0 1 Mut 1 0 0 0  then CMCS implements a VNS that applies HC1 until it fails, then applies HC2. If HC2 improves the solution then the search gets back to HC1; otherwise HC3 is executed. Similarly, if HC3 improves the solution then the search gets back to HC1; otherwise current solution is a local maximum with respect to the neighbourhoods explored by HC1, HC2 and HC3 (assuming they are deterministic) and mutation Mut is applied to diversify the search.\nHowever, even though the previous examples are wellknown metaheuristics, they are rather special cases from the perspective of CMCS, which allows much more sophisticated strategies. For example, we can implement a twoloop heuristic, which alternates hill climbing operator HC1 and mutation Mut1 until HC1 fails to improve the solution. Then the control is passed to the second loop, alternating HC2 and Mut2. Again, if HC2 fails, the control is passed to the first loop.\nTo describe such more sophisticated strategies, it is convenient to represent CMCS configurations with automata as in Figure 1. Blue and red lines correspond to transitions in case of successful and unsuccessful execution of the components, respectively. Probabilities of each transition are shown with line widths (in Figure 1 all the shown probabilities are 100%). The advantage of automata representation is that it visualises the probabilities of transition and sequences in which components are executed (and so complements, not supplants, the formal description via the pseudo-code and the explicit transition matrices), as common when describing transition systems.\nThe transitions in the above example are deterministic, however, this is not an inherent limitation; for example, one could implement a two phase search with the transition being probabilistic, see Figure 2. We also note here\nthat CMCS can be significantly enriched by having several copies of each component in H and/or employing dummy components for describing more sophisticated behaviours; but we leave these possibilities to future work.\nThese are just some of the options available with CMCS, showing that it is potentially a powerful tool. However, this flexibility does come with the associated challenge – of configuring the matrices to generate effective metaheuristics. For example, if |H| = 10 then CMCS has 2|H|2 = 200 continuous parameters.\nBy simple reasoning we can fix the values of a few of these parameters:\n• If component h is a deterministic hill climbing operator then M failh,h = 0, as when it fails then the solution remains unchanged and so immediate repetition is pointless.\n• If component h is an idempotent operator (e.g. OptX or OptY) then M succh,h = M fail h,h = 0; again there is no\nuse in applying h several times in a row.\nNevertheless, the significant number of remaining parameters of CMCS makes it hard to configure. For this reason we propose, and exploit a special case of the CMCS schema, with much fewer parameters but that still provides much of the power of the framework of the full CMCS. Specifically, we allow at most k non-zero elements in each row of M succ and M fail, calling the resulting metaheuristic “CMCS[k-row]”. Clearly, CMCS[|H|-row] is identical to the full version of CMCS. In practice, however, we expect one to use only smaller values of k; either k = 1 or k = 2.\nWhen k = 1, the corresponding automata has at most one outgoing “success” arc, and one outgoing “failure” arc for each component. Hence CMCS turns into a deterministic control mechanism. Note that iterated local search and VNS are in fact special cases of CMCS[1-row].\nWhen k = 2, the corresponding automata has at most two outgoing “success” arcs from each component, and their total probability of transition is 100%. Hence, the\n“success” transition is defined by a pair of components and the split of probabilities between them. “Failure” transition is defined in the same way.\nIn Section 5, we show that CMCS[2-row] is sufficiently powerful to implement complex component combinations but is much easier to configure and analyse than full CMCS."
    }, {
      "heading" : "4. Benchmark Instances",
      "text" : "The testbed which is currently de facto standard for BBQP was first introduced in our unpublished work [15]. Our testbed consists of five instance types that correspond to some of the real life applications of BBQP. Here we provide the description of it, and also make it available for download.2 We keep record of the best known solutions for each of the test instances which will also be placed on the download page.\nIn order to generate some of the instances, we need random bipartite graphs. To generate a random bipartite graph G = (V,U,E), we define seven parameters, namely m = |V |, n = |U |, d1, d̄1, d2, d̄2 and µ such that 0 ≤ d1 ≤ d̄1 ≤ n, 0 ≤ d2 ≤ d̄2 ≤ m, md1 ≤ nd̄2 and md̄1 ≥ nd2.\nThe bipartite graph generator proceeds as follows.\n1. For each node v ∈ V , select dv uniformly at random from the range [d1, d̄1].\n2. For each node u ∈ U , select du uniformly at random from the range [d2, d̄2].\n3. While ∑ v∈V dv 6= ∑\nu∈U du, alternatively select a node in V or U and re-generate its degree as described above.3\n4. Create a bipartite graphG = (V,U,E), where E = ∅.\n5. Randomly select a node v ∈ V such that dv > deg v (if no such node exists, go to the next step). Let U ′ = {u ∈ U : deg u < du and (v, u) /∈ E}. If U ′ 6= ∅, select a node u ∈ U ′ randomly. Otherwise randomly select a node u ∈ U such that (v, u) /∈ E and du > 0; randomly select a node v\n′ ∈ V adjacent to u and delete the edge (v′, u). Add an edge (v, u). Repeat this step.\n6. For each edge (v, u) ∈ E select the weight wvu as a normally distributed integer with standard deviation σ = 100 and given mean µ.\nThe following are the instance types used in our computational experiments.\n2http://csee.essex.ac.uk/staff/dkarap/?page=\npublications&key=CMCS-BBQP 3In practice, if m(d1 + d̄1) ≈ n(d2 + d̄2), this algorithm converges very quickly. However, in theory it may not terminate in finite time and, formally speaking, there needs to be a mechanism to guarantee convergence. Such a mechanism could be turned on after a certain (finite) number of unsuccessful attempts, and then it would force the changes of degrees dv that reduce | ∑ v∈V dv − ∑ u∈U du|.\n1. The Random instances are as follows: qij , ci and dj are integers selected at random with normal distribution (mean µ = 0 and standard deviation σ = 100).\n2. The Max Biclique instances model the problem of finding a biclique of maximum weight in a bipartite graph. Let G = (I, J, E) be a random bipartite graph with d1 = n/5, d̄1 = n, d2 = m/5, d̄2 = m and µ = 100. (Note that setting µ to 0 would make the weight of any large biclique likely to be around 0, which would make the problem much easier.) If wij is the weight of an edge (i, j) ∈ E, set qij = wij for every i ∈ I and j ∈ J if (i, j) ∈ E and qij = −M otherwise, where M is large number. Set c and d as zero vectors.\n3. The Max Induced Subgraph instances model the problem of finding a subset of nodes in a bipartite graph that maximises the total weight of the induced subgraph. The Max Induced Subgraph instances are similar to the Max Biclique instances except that qij = 0 if (i, j) /∈ E and µ = 0. (Note that if µ > 0 then the optimal solution would likely include all or almost all the nodes and, thus, the problem would be relatively easy).\n4. The MaxCut instances model the MaxCut problem as follows. First, we generate a random bipartite graph as for the Max Induced Subgraph instances. Then, we set qij = −2wij if (i, j) ∈ E and qij = 0 if (i, j) /∈ E. Finally, we set ci = 12 ∑ j∈J qij and\ndj = 1 2 ∑ i∈I qij . For an explanation, see [23].\n5. The Matrix Factorisation instances model the problem of producing a rank one approximation of a binary matrix. The original matrix H = (hij) (see Section 1) is generated randomly with probability 0.5 of hij = 1. The values of qij are then calculated as qij = 1− 2hij , and c and d are zero vectors.\nOur benchmark consists of two sets of instances: Medium and Large. Each of the sets includes one instance of each type (Random, Max Biclique, Max Induced Subgraph, MaxCut and Matrix Factorisation) of each of the following sizes: Medium: 200× 1000, 400× 1000, 600× 1000, 800× 1000, 1000× 1000; Large: 1000×5000, 2000×5000, 3000×5000, 4000×5000, 5000× 5000. Thus, in total, the benchmark includes 25 medium and 25 large instances."
    }, {
      "heading" : "5. Metaheuristic Design",
      "text" : "In this section we describe configuration of metaheuristics as discussed in Section 3 and using the BBQP components given in Section 2. In Sections 5.1 and 5.2 we give some details about our experiments, then in Section 5.3\ndescribe the employed automated configuration technique, in Section 5.4 we provide details of the configured metaheuristics, and in Section 5.5 analyse the results.\nOur test machine is based on two Intel Xeon CPU E52630 v2 (2.6 GHz) and has 32 GB RAM installed. Hyperthreading is enabled, but we never run more than one experiment per physical CPU core concurrently, and concurrency is not exploited in any of the tested solution methods."
    }, {
      "heading" : "5.1. Solution Representation",
      "text" : "We use the most natural solution representation for BBQP, i.e. simply storing vectors x and y. However, additionally storing some auxiliary information with the solution can dramatically improve the performance of algorithms. We use a strategy similar to the one employed in [11]. In particular, along with vectors x and y, we always maintain values ci + ∑ j yjqij for each i, and dj + ∑ i xiqij for each j. Maintenance of this auxiliary information slows down any updates of the solution but significantly speeds up the evaluation of potential moves, which is what usually takes most of time during the search."
    }, {
      "heading" : "5.2. Solution Polishing",
      "text" : "As in many single-point metaheuristics, the changes between diversifying and intensifying steps of CMCS mean that the best found solution needs to be stored, and also that it is not necessarily a local maximum with respect to all the available hill climbing operators. Hence, we apply a polishing procedure to every CMCS configuration produced in this study, including special cases of VNS, Op. Prob. and MCHH. Our polishing procedure is executed after the CMCS finishes its work, and it is aimed at improving the best solution found during the run of CMCS. It sequentially executes OptX, OptY, FlpX and FlpY components, restarting this sequence every time an improvement is found. When none of these algorithms can improve the solution, that is, the solution is a local maximum with respect to all of our hillclimbing operators, the procedure terminates.\nWhile taking very little time, this polishing procedure has notably improved our results. We note that this polishing stage is a Variable Neighbourhood Descent, and thus a special case of CMCS; hence, the final polishing could be represented as a second phase of CMCS. We also note that the Tabu Search algorithm, against which we compare our best CMCS configuration in Section 6.1, uses an equivalent polishing procedure applied to each solution and thus the comparison is fair."
    }, {
      "heading" : "5.3. Approach to Configuration of the Metaheuristics",
      "text" : "Our ultimate goal in this experiment is to apply automated configuration (e.g. in the case of CMCS, to configure M succ and M fail matrices), which would compete with the state-of-the-art methods on the benchmark instances (which have sizes 200 × 1000 to 5000 × 5000) and with\nrunning times in the order of several seconds to several minutes. As explained in Section 3, instead of hand designing a metaheuristic we chose to use automated generation based on the CMCS schema. Automated generation required a set of training instances. Although straightforward, directly training on benchmark instances would result in over-training (a practice generally considered unfair because an over-trained heuristic might perform well only on a very small set of instances on which it is tuned and then tested) and also would take considerable computational effort. Thus, for training we use instances of size 200× 500. We also reduced the running times to 100 milliseconds per run of each candidate configuration, that is, matrices when configuring CMCS or MCHH, probability vector for Op. Prob., and component sequence for VNS.\nLet T be the set of instances used for training. Then our objective function for configuration is\nf(h, T ) = 1 |T | ∑ t∈T fbest(t)− h(t) fbest(t) · 100% , (3)\nwhere h is the evaluated heuristic, h(t) is the objective value of solution obtained by h for instance t, and fbest(t) is the best known solution for instance t. For the training set, we used instances of all of the types. In particular, we use one instance of each of the five types (see Section 4), all of size 200 × 500, and each of these training instances is included in T 10 times, thus |T | = 50 (we observed that without including each instance several times the noise level significantly obfuscated results). Further, when testing the top ten candidates, we include each of the five instances 100 times in T , thus having |T | = 500.\nWe consider four types of metaheuristics: VNS, Op. Prob., MCHH and CMCS[2-row], all of which are also special cases of CMCS. All the components discussed in Section 2, and also briefly described in Table 1, are considered for inclusion in all the metaheuristics. Additionally, since Repair is a totally new component, we want to confirm its usefulness. For this we also study a special case of CMCS[2-row] which we call “CMCS[2-row reduced]”. In CMCS[2-row reduced], the pool of potential components includes all the components in Table 1 except Repair.\nTo configure VNS and Op. Prob., we use brute force search as we can reasonably restrict the search to a relatively small number of options. In particular, when configuring Op. Prob., the number of components |H| (recall that H is the set of components employed by the metaheuristic) is restricted to at most four, and weights of individual components are selected from {0.1, 0.2, 0.5, 0.8, 1} (these weights are then rescaled to obtain probabilities). We also require that there has to be at least one hill climbing operator in H as otherwise there would be no pressure to improve the solution, and one mutation operator as otherwise the search would quickly become trapped in a local maximum. Note that we count Repair as a mutation as, although designed to explicitly fix flaws, it is quite likely to worsen the solution (even if in the long run this will\nbe beneficial). When configuring VNS, H includes one or several hill climbing operators and one mutation and the configuration process has to also select the order in which they are applied.\nTo configure CMCS and static MCHH, we use a simple evolutionary algorithm, with the solution describing matrices M succ and M fail (accordingly restricted), and fitness function (3). Implementation of a specialised tuning algorithm has an advantage over the general-purpose automated algorithm configuration packages, as a specialised system can exploit the knowledge of the parameter space (such as entanglement of certain parameters). In this project, our evolutionary algorithm employs specific neighbourhood operators that intuitively make sense for this particular application. For example, when tuning 2-row, we employ, among others, a mutation operator that swaps the two non-zero weights in a row of a weight matrix. Such a move is likely to be useful for “exploitation”; however it is unlikely to be discovered by a general purpose parameter tuning algorithm.\nWe compared the tuning results of our CMCS-specific algorithm to ParamILS [13], one of the leading general purpose automated parameter tuning/algorithm configuration software. We found out that, while ParamILS performs well, our specialised algorithm clearly outperforms it, producing much better configurations. It should be noted that there can be multiple approaches to encode matrices M succ and M fail for ParamILS. We tried two most natural approaches and both attempts were relatively unsuccessful; however it is possible that future research will reveal more efficient ways to represent the key parameters of CMCS. We also point out that CMCS can be a new interesting benchmark for algorithm configuration or parameter tuning software."
    }, {
      "heading" : "5.4. Configured Metaheuristics",
      "text" : "In this section we describe the configurations of each type (VNS, Op. Prob., MCHH, CMCS[2-row reduced] and CMCS[2-row]) generated as described in Section 5.3. From now on we refer to the obtained configurations by the name of their types. Note that the structures described in this section are all machine-generated, and thus when we say that “a metaheuristic chose to do something”, we mean that such a decision emerged from the generation process; the decision was not a human choice.\nVNS chose three hill climbing operators, OptY, FlpY and OptX, and a mutation MutX16, and using the order as written. It is interesting to observe that this choice and sequence can be easily explained. Effectively, the search optimises y given a fixed x (OptY), then tries small changes to x with some lookahead (FlpY), and if this fails then optimises x globally but without lookahead (OptX). If the search is in a local maximum with respect to all three neighbourhoods then the solution is perturbed by a strong mutation MutX16. Observe that the sequence\nof hill climbing operators does not obey the generally accepted rule of thumb to place smaller neighbourhoods first; the third hill climbing operator OptX has clearly smaller neighbourhood than FlpY. However, this sequence has an interesting internal logic. Whenever FlpY succeeds in improving the solution, the resultant solution is a local minimum with respect to OptX. Accordingly, VNS jumps back to OptY when FlpY succeeds. However, if FlpY fails then the solution might not be a local minimum with respect to OptX, and then OptX is executed. This shows that the automated configuration is capable of generating meaningful configurations which are relatively easy to explain but might not be so easy to come up with.\nThe Op. Prob. chose four components: OptX (probability of picking is 40%), FlpX (20%), Repair (20%) and MutX16 (20%). Note that the actual runtime frequency of OptX is only about 30% because the framework will never execute OptX twice in a row.\nOut of 9 components, MCHH chose five: OptX, OptY, FlpX, MutY4 and MutX16. The generated transition matrix (showing the probabilities of transitions) is given in Figure 3.\nCMCS[2-row reduced] chose to use only OptX, OptY, FlpX, MutX4, MutY4 and MutY16 from the pool of 8 components it was initially permitted (recall that CMCS[2row reduced] was not allowed to use Repair), and transition matrices as given in Figure 4 and visually illustrated in Figure 7a. The line width in Figure 7a indicates the frequency of the transition when we tested the configuration on the tuning instance set. Although these frequencies may slightly vary depending on the particular instance, showing frequencies preserves all the advantages of showing probabilities but additionally allows one to see: (i) how often a component is executed (defined by the total width of all incoming/outgoing arrows), (ii) the probability of success of a component (defined by the the total width of\nblue outgoing arrows compared to the total width of the red outgoing arrows), and (iii) most common sequences of component executions (defined by thickest arrows).\nCMCS[2-row] decided to use only OptX, OptY, FlpX, Repair, MutY4 and MutY16 from the set of 9 moves it was initially permitted, and transition matrices as shown in Figure 5."
    }, {
      "heading" : "5.5. Analysis of Components and Metaheuristics",
      "text" : "Table 2 gives the tuning objective function (3) and the average number of component executions per run (i.e. in 100 milliseconds when solving a 200×500 instance) for each metaheuristic. CMCS, even if restricted to CMCS[2-row] and even if the pool of components is reduced, outperforms all standard metaheuristics (VNS, Op. Prob. and MCHH), even though Op. Prob. and VNS benefit from higher quality configuration (recall that VNS and Op. Prob. are configured using complete brute-force search). An interesting observation is that the best performing metaheuristics mostly employ fast components thus being able to run many more iterations than, say, VNS or Op. Prob.\nFigure 6 gives the relative frequency of usage of each component by each metaheuristic. Most of the components appear to be useful within at least one of the considered metaheuristic schemas; only MutX4 is almost unused. It is however not surprising to observe some imbalance between the Mutation-X and Mutation-Y components because the number of rows is about half of the number of columns in the training instances. The selection of components is hard to predict as it significantly depends on the metaheuristic schema; indeed, different types of metaheuristics may be able to efficiently exploit different features of the components. Thus components should not be permanently discarded or selected based only on expert intuition and/or a limited number of experiments. We believe that the approach to component usage analysis proposed and used in this paper (and also in works such as [13, 5, and others]) is in many circumstances more comprehensive than manual analysis.\nWhile frequencies of usage of the components vary between all the metaheuristics, Op. Prob. is clearly an outlier in this respect. We believe that this reflects the fact that Op. Prob. is the only metaheuristic among the considered\nones that does not have any form of memory and thus does not control the order of components. Thus it prefers strong (possibly slow) components whereas other metaheuristics have some tendency to form composite components from fast ones, with the latter (history-based) approach apparently being superior.\nMore information about the performance of CMCS[2row reduced] and CMCS[2-row] configurations can be collected from Figure 7 detailing the runtime frequencies of transitions in each of them. Edge width here is proportional to square root of the runtime frequency of the corresponding transition occurring in several test runs; thus it allows to see not only the probabilities of transitions from any individual component, but also how frequently that component was executed and how often it was successful, compared to other components.\nFirstly, we observe that the two metaheuristics employ similar sets of components; the only difference is that CMCS[2-row] does not use MutX4 but adds Repair (recall that Repair was purposely removed from the pool of components of CMCS[2-row reduced]). Furthermore, the core components (OptX, OptY, MutY4 and MutY16) are exactly the same, and most of interconnections between them are similar. However, the direction of transitions to and from MutY16 is different. One may also notice that both metaheuristics have “mutation” blocks; that is, mutations that are often executed in sequences. It is then not surprising that CMCS[2-row] connects Repair to the other mutation components.\nBoth metaheuristics include some natural patterns such as alternation of OptX and OptY, or iterated local search OptX–MutY4, which we could also expect in a handdesigned metaheuristic. It is also easy to suggest an explanation for the loop at MutY16 as it allows the component to be repeated a couple of times intensifying the mutation. However, the overall structure of the metaheuristics is complex and hard to explain. Our point here is that, although the observed chains of components make sense, it is unlikely that a human expert would come up with a heuristic of such a level of detail."
    }, {
      "heading" : "6. Evaluation of Metaheuristics",
      "text" : "So far we have only been testing the performance of the metaheuristics on the training instance set. In Tables 3 and 4 we report their performance on benchmark instances, giving 10 seconds per Medium instance and 100 seconds per Large instance. For each instance and metaheuristic, we report the percentage gap, between the solution obtained by that metaheuristic and the best known objective value for that instance. The best known objective values are obtained by recording the best solutions produced in all our experiments, not necessarily only the experiments reported in this paper. The best known solutions will be available for download, and their objective values are reported in Tables 5 and 6.\nThe results of the experiments on benchmark instances generally positively correlate with the configuration objective function (3) reported in Table 2, except that Op. Prob. shows performance better than MCHH, and is competing with CMCS[2-row reduced] on Large instances. This shows a common problem that the evaluation by short runs on small instances, as used for training, may not always perfectly correlate with the performance of the heuristic on real (or benchmark) instances [14]. However, in our case, the main conclusions are unaffected by this. In particular, we still observe that CMCS[2-row] outperforms other metaheuristics, including CMCS[2-row reduced], hence proving usefulness of the Repair component. Also CMCS[2row] clearly outperforms MCHH demonstrating that even a restricted version of the CMCS schema is more robust than the MCHH schema; recall that CMCS is an extension of MCHH with conditional transitions.\nWe made the source code of CMCS[2-row] publicly available4. The code is in C# and was tested on Windows and Linux machines. We note here that CMCS is relevant to the Programming by Optimisation (PbO) concept [12]. We made sure that our code complies with the “PbO Level 3” standard, i.e. “the software-development process is structured and carried out in a way that seeks to provide design choices and alternatives in many performancerelevant components of a project.” [12]. Our code is not\n4http://csee.essex.ac.uk/staff/dkarap/?page=\npublications&key=CMCS-BBQP\ncompliant with “PbO Level 4” because some of the choices made (specifically, the internal parameters of individual components) were not designed to be tuned along with the CMCS matrices; for details of PbO see [12]."
    }, {
      "heading" : "6.1. Comparison to the State-of-the-art",
      "text" : "There have been two published high-performance metaheuristics for BBQP: Iterated Local Search by Duarte et al. [9] and Tabu Search by Glover et al. [11]. Both papers agree that their approaches perform similarly; in fact, following a sign test, Duarte et al. conclude that “there are not significant differences between both procedures”. At first, we compare CMCS[2-row] to Tabu Search for which we have detailed experimental results [11]. Then we also compare CMCS[2-row] to ILS using approach adopted in [9].\nTabu Search has two phases: (i) a classic tabu search based on a relatively small neighbourhood, which runs until it fails to improve the solution, and (ii) a polishing procedure, similar to ours, which repeats a sequence of hill climbing operators OptY, FlpX, OptX and FlpY until a local maximum is reached.5 The whole procedure is repeated as many times as the time allows.\nThe experiments in [11] were conducted on the same benchmark instances, first introduced in [15] and now described in Section 4 of this paper. Each run of Tabu Search\n5In [11], a composite of OptY and FlpX is called Flip-x-Float-y, and a composite of OptX and FlpY is called Flip-y-Float-x.\nwas given 1000 seconds for Medium instances (n = 1000) and 10000 seconds for Large instances (n = 5000). In Table 5 we report the performance results of CMCS[2-row], our best performing metaheuristic, on Medium instances with 1, 10, 100 and 1000 second time limits, and in Table 6 on Large instances with 10, 100, 1000 and 10000 second time limits, and explicitly compare those results to the performance of Tabu Search and so implicitly compare to the results of Duarte et al. [9] that were not significantly different from Tabu.\nGiven the same time, CMCS[2-row] produces same (for 10 instances) or better (for 20 instances) solutions. The worst gap between best known and obtained solution (reported in the Max row at the bottom of each table) is also much larger for Tabu Search than for CMCS[2-row]. CMCS[2-row] clearly outperforms Tabu Search even if given a factor of 100 less time, and competes with it even if given a factor of 1000 less time. Thus we conclude that CMCS[2row] is faster than Tabu Search by two to three orders of magnitude. Further, we observe that CMCS[2-row] does not converge prematurely, that is, it continues to improve the solution when given more time.\nAs pointed out above, it is known from the literature that ILS [9] performs similarly to Tabu Search, and hence the conclusions of the comparison between CMCS[2-row] and Tabu Search can be extended to ILS as well. However, to verify this, we reproduced the experiment from [9]. In that experiment, Duarte et al. solved each of the medium and large instances, giving ILS 1000 seconds per run, and then reported the average objective value. We tested CMCS[2-row] is exactly the same way, except that we allowed only 10 seconds per run. Despite a much lower time budget, our result of 14,523,968.32 is superior to the result of 14,455,832.30 reported in [9, Table 8]. This direct experiment confirms that CMCS[2-row] significantly\noutperforms ILS. We note here that this result is achieved in spite of CMCS[2-row] consisting of simple components combined in an entirely automated way; without any human intelligence put into the detailed metaheuristic design. Instead, only a modest computational power (a few hours of CPU time) was required to obtain it. (Note that this computational power should not be compared to the running time of the algorithm itself; it is a replacement of expensive time of a human expert working on manual design of a high-performance solution method.) We believe that these results strongly support the idea of automated metaheuristic in general and CMCS schema in particular."
    }, {
      "heading" : "7. Conclusions",
      "text" : "In this work, we considered an important combinatorial optimisation problem called Bipartite Boolean Quadratic Programming Problem (BBQP). We defined several algorithmic components for BBQP, primarily aiming at components for metaheuristics. To test and analyse the performance of the components, and to combine them in a powerful metaheuristic, we designed a flexible metaheuristic schema, which we call Conditional Markov Chain Search (CMCS), the behaviour of which is entirely defined by an explicit set of parameters and thus which is convenient for automated configuration. CMCS is a powerful schema with special cases covering several standard metaheuristics. Hence, to evaluate the performance of a metaheuristic on a specific problem class, we can configure the CMCS restricted to that metaheuristic, obtaining a nearly best possible metaheuristic of that particular type for that specific problem class. The key advantages of this approach include avoidance of human/expert bias in analysis of the components and metaheuristics, and complete automation\nof the typically time-consuming process of metaheuristic design.\nOf the methods we consider, the CMCS schema is potentially the most powerful as it includes the others as special cases, however, it has a lot of parameters, and this complicates the selection of the matrices. To combat this, we proposed a special case of CMCS, CMCS[k-row], which is significantly easier to configure, but that still preserves much of the flexibility of the approach.\nBy configuring several special cases of CMCS on a set of small instances and then testing them on benchmark instances, we learnt several lessons. In particular, we found out that CMCS schema, even if restricted to the CMCS[2-row] schema, is significantly more powerful than VNS, Op. Prob. and even MCHH (with a static transition matrix). We also verified that the new BBQP component, Repair, is useful, as its inclusion in the pool of components improved the performance of CMCS[2-row]. Finally, we showed that the best found strategies are often much more sophisticated than the strategies implemented in standard approaches.\nOur best performing metaheuristic, CMCS[2-row], clearly outperforms the previous state-of-the-art BBQP methods. Following a series of computational experiments, we estimated that CMCS[2-row] is faster than those methods by roughly two to three orders of magnitude."
    }, {
      "heading" : "7.1. Future Work",
      "text" : "A few other BBQP algorithmic components could be studied and exploited using the CMCS schema. Variations of the Repair heuristic, as discussed in Section 2.3, should be considered more thoroughly. Another possibility for creating a new class of powerful components is to reduce the entire problem by adding constraints of the form xi = xi′ , xi 6= xi′ or xi = 1, or even more sophisticated such as xi = xi′ ∨ xi′′ . Note that such constraints effectively reduce the original problem to a smaller BBQP; then this smaller BBQP can be solved exactly or heuristically. Also note that if such constraints are generated to be consistent with the current solution then this approach can be used as a hill climbing operator.\nIt is interesting to note that the reduced size subproblem could itself be solved using a version of CMCS configured to be effective for brief intense runs. This gives the intriguing possibility of an upper-level CMCS in which one of the components uses a different CMCS – though we expect that tuning such a system could be a significant, but interesting, challenge.\nThe CMCS schema should be developed in several directions. First of all, it should be tested on other domains. Then a few extensions can be studied, e.g. one could add a “termination” component that would stop the search – to allow variable running times. It is possible to add\nsome form of memory and/or backtracking functionality, for example to implement a tabu-like mechanism. Another direction of research is population-based extensions of CMCS. Of interest are efficient configuration procedures that would allow to include more components. Finally, of course, one can study methods for online learning, that is adaptation of the transition probabilities during the search process itself; in which case it would be most natural to call the method “Conditional Markov Chain Hyper-heuristic.”"
    }, {
      "heading" : "Acknowledgement",
      "text" : "This research work was partially supported by an NSERC Discovery accelerator supplement awarded to Abraham P. Punnen, EPSRC grants EP/H000968/1 and EP/F033214/1 (“The LANCS Initiative”), and also LANCS Initiative International Scientific Outreach Fund which supported the visit of Daniel Karapetyan to the Simon Fraser University."
    } ],
    "references" : [ {
      "title" : "Fine-tuning of algorithms using fractional experimental designs and local search",
      "author" : [ "B. Adenso-Dı́az", "M. Laguna" ],
      "venue" : "Operations Research",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2006
    }, {
      "title" : "A survey of very large-scale neighborhood search techniques",
      "author" : [ "R.K. Ahuja", "Ö. Ergun", "J.B. Orlin", "A.P. Punnen" ],
      "venue" : "Discrete Applied Mathematics",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2002
    }, {
      "title" : "Approximating the Cut-Norm via Grothendieck’s Inequality",
      "author" : [ "N. Alon", "A. Naor" ],
      "venue" : "SIAM Journal on Computing",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2006
    }, {
      "title" : "Inapproximability results for maximum edge biclique, minimum linear arrangement, and sparsest cut",
      "author" : [ "C. Ambühl", "M. Mastrolilli", "O. Svensson" ],
      "venue" : "SIAM Journal on Computing",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2011
    }, {
      "title" : "Evolutionary Multi-Criterion Optimization: 8th International Conference, EMO",
      "author" : [ "L.C.T. Bezerra", "M. López-Ibáñez", "T. Stützle" ],
      "venue" : "–April",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2015
    }, {
      "title" : "Quadratic 0-1 bibliography URL: http: //cedric.cnam.fr/fichiers/RC611.pdf",
      "author" : [ "A. Billionnet" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2004
    }, {
      "title" : "Exploring biological interaction networks with tailored weighted quasi-bicliques",
      "author" : [ "W.C. Chang", "S. Vakati", "R. Krause", "O. Eulenstein" ],
      "venue" : "BMC bioinformatics 13 Suppl",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2012
    }, {
      "title" : "A hyperheuristic approach to scheduling a sales summit",
      "author" : [ "P. Cowling", "G. Kendall", "E. Soubeiga" ],
      "venue" : "Selected papers from the 3rd International Conference on the Practice and Theory of Automated Timetabling (PATAT",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2001
    }, {
      "title" : "Optimization procedures for the bipartite unconstrained 0-1 quadratic programming problem",
      "author" : [ "A. Duarte", "M. Laguna", "R. Mart́ı", "J. Sánchez-Oro" ],
      "venue" : "Computers & Operations Research",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2014
    }, {
      "title" : "Low-rank matrix approximation with weights or missing data is NP-hard",
      "author" : [ "N. Gillis", "F. Glineur" ],
      "venue" : "SIAM Journal on Matrix Analysis and Applications",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2011
    }, {
      "title" : "Integrating tabu search and VLSN search to develop enhanced algorithms: A case study using bipartite boolean quadratic programs",
      "author" : [ "F. Glover", "T. Ye", "A. Punnen", "G. Kochenberger" ],
      "venue" : "European Journal of Operational Research",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2015
    }, {
      "title" : "Programming by optimization",
      "author" : [ "H.H. Hoos" ],
      "venue" : "Communications of the ACM",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2012
    }, {
      "title" : "ParamILS: An automatic algorithm configuration framework",
      "author" : [ "F. Hutter", "H.H. Hoos", "K. Leyton-Brown", "T. Stützle" ],
      "venue" : "Journal of Artificial Research",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2009
    }, {
      "title" : "Automatic algorithm configuration based on local search",
      "author" : [ "F. Hutter", "H.H. Hoos", "T. Stützle" ],
      "venue" : "in: Proceedings of the 22nd National Conference on Artificial Intelligence - Volume",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2007
    }, {
      "title" : "Heuristic algorithms for the bipartite unconstrained 0-1 quadratic programming problem URL: http://arxiv.org/abs/1210.3684",
      "author" : [ "D. Karapetyan", "A.P. Punnen" ],
      "venue" : null,
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "Compression, clustering, and pattern discovery in very high-dimensional discrete-attribute data sets",
      "author" : [ "M. Koyutürk", "A. Grama", "N. Ramakrishnan" ],
      "venue" : "IEEE Transactions on Knowledge and Data Engineering",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2005
    }, {
      "title" : "Nonorthogonal decomposition of binary matrices for bounded-error data compression and analysis",
      "author" : [ "M. Koyutürk", "A. Grama", "N. Ramakrishnan" ],
      "venue" : "ACM Transactions on Mathematical Software",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2006
    }, {
      "title" : "Iterated local search: Framework and applications handbook of metaheuristics, Springer US, Boston, MA. volume 146 of International Series in Operations",
      "author" : [ "H.R. Lourenço", "O.C. Martin", "T. Stützle" ],
      "venue" : "Research & Management Science",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2010
    }, {
      "title" : "Weighted rank-one binary matrix factorization",
      "author" : [ "H. Lu", "J. Vaidya", "V. Atluri", "H. Shin", "L. Jiang" ],
      "venue" : "in: Proceedings of the Eleventh SIAM International Conference on Data Mining,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2011
    }, {
      "title" : "On selecting a satisfying truth assignment",
      "author" : [ "C.H. Papadimitriou" ],
      "venue" : "in: Foundations of Computer Science,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1991
    }, {
      "title" : "2015a. Average value of solutions for the bipartite boolean quadratic programs and rounding algorithms",
      "author" : [ "A.P. Punnen", "P. Sripratak", "D. Karapetyan" ],
      "venue" : "Theoretical Computer Science",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2015
    }, {
      "title" : "The bipartite unconstrained 0-1 quadratic programming problem: polynomially solvable cases",
      "author" : [ "A.P. Punnen", "P. Sripratak", "D. Karapetyan" ],
      "venue" : "Discrete Applied Mathematics 193,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2015
    }, {
      "title" : "Local search strategies for satisfiability testing, in: DIMACS series in discrete mathematics and theoretical computer",
      "author" : [ "B. Selman", "H. Kautz", "B. Cohen" ],
      "venue" : null,
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1995
    }, {
      "title" : "Mining discrete patterns via  binary matrix factorization, in: Proceedings of the 15th ACM SIGKDD international conference on Knowledge discovery and data",
      "author" : [ "Shen", "B.h", "S. Ji", "J. Ye" ],
      "venue" : null,
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2009
    }, {
      "title" : "Inapproximability of Maximum Weighted Edge Biclique and Its Applications",
      "author" : [ "J. Tan" ],
      "venue" : "in: Proceedings of the 5th international conference on Theory and applications of models of computation,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2008
    }, {
      "title" : "Discovering statistically significant biclusters in gene expression data",
      "author" : [ "A. Tanay", "R. Sharan", "R. Shamir" ],
      "venue" : "Bioinformatics 18,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2002
    }, {
      "title" : "Scheduling and rescheduling with iterative repair",
      "author" : [ "M. Zweben", "E. Davis", "B. Daun", "M.J. Deale" ],
      "venue" : "IEEE Transactions on Systems, Man, and Cybernetics",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 1993
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "The BQP is a well-studied problem in the operational research literature [6].",
      "startOffset" : 73,
      "endOffset" : 76
    }, {
      "referenceID" : 21,
      "context" : "The focus of this paper is on a problem closely related to BQP, called the Bipartite (Unconstrained) Boolean Quadratic Programming Problem (BBQP) [23].",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 21,
      "context" : "A graph theoretic interpretation of the BBQP can be given as follows [23].",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 3,
      "context" : "Biclique Problem (MWBP) [4, 26] is to find a biclique in G of maximum total edge-weight.",
      "startOffset" : 24,
      "endOffset" : 31
    }, {
      "referenceID" : 24,
      "context" : "Biclique Problem (MWBP) [4, 26] is to find a biclique in G of maximum total edge-weight.",
      "startOffset" : 24,
      "endOffset" : 31
    }, {
      "referenceID" : 21,
      "context" : "Then BBQP(Q, c, d) solves the MWBP [23].",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 3,
      "context" : "This immediately shows that the BBQP is NP-hard and one can also establish some approximation hardness results with appropriate assumptions [4, 26].",
      "startOffset" : 140,
      "endOffset" : 147
    }, {
      "referenceID" : 24,
      "context" : "This immediately shows that the BBQP is NP-hard and one can also establish some approximation hardness results with appropriate assumptions [4, 26].",
      "startOffset" : 140,
      "endOffset" : 147
    }, {
      "referenceID" : 6,
      "context" : "has applications in data mining, clustering and bioinformatics [7, 27] which in turn become applications of BBQP.",
      "startOffset" : 63,
      "endOffset" : 70
    }, {
      "referenceID" : 25,
      "context" : "has applications in data mining, clustering and bioinformatics [7, 27] which in turn become applications of BBQP.",
      "startOffset" : 63,
      "endOffset" : 70
    }, {
      "referenceID" : 9,
      "context" : "Another application of BBQP arises in approximating a matrix by a rank-one binary matrix [10, 16, 17, 19, 25].",
      "startOffset" : 89,
      "endOffset" : 109
    }, {
      "referenceID" : 15,
      "context" : "Another application of BBQP arises in approximating a matrix by a rank-one binary matrix [10, 16, 17, 19, 25].",
      "startOffset" : 89,
      "endOffset" : 109
    }, {
      "referenceID" : 16,
      "context" : "Another application of BBQP arises in approximating a matrix by a rank-one binary matrix [10, 16, 17, 19, 25].",
      "startOffset" : 89,
      "endOffset" : 109
    }, {
      "referenceID" : 18,
      "context" : "Another application of BBQP arises in approximating a matrix by a rank-one binary matrix [10, 16, 17, 19, 25].",
      "startOffset" : 89,
      "endOffset" : 109
    }, {
      "referenceID" : 23,
      "context" : "Another application of BBQP arises in approximating a matrix by a rank-one binary matrix [10, 16, 17, 19, 25].",
      "startOffset" : 89,
      "endOffset" : 109
    }, {
      "referenceID" : 18,
      "context" : "Binary matrix factorisation is an important topic in mining discrete patterns in binary data [19, 25].",
      "startOffset" : 93,
      "endOffset" : 101
    }, {
      "referenceID" : 23,
      "context" : "Binary matrix factorisation is an important topic in mining discrete patterns in binary data [19, 25].",
      "startOffset" : 93,
      "endOffset" : 101
    }, {
      "referenceID" : 21,
      "context" : "The Maximum Cut Problem on a bipartite graph (MaxCut) can be formulated as BBQP [23] and this gives yet another application of the model.",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 2,
      "context" : "to find approximations to the cut-norm of a matrix [3].",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 20,
      "context" : "For theoretical analysis of approximation algorithms for BBQP, we refer to [22].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 14,
      "context" : "A preliminary version of this paper was made available to the research community in 2012 [15].",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 10,
      "context" : "[11] and Duarte et al.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 8,
      "context" : "[9] studied heuristic algorithms for the problem.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 14,
      "context" : "The testbed presented in our preliminary report [15] continues to be the source of benchmark instances for the BBQP.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 14,
      "context" : "In this paper, in addition to providing a detailed description of the benchmark instances, we refine the algorithms reported in [15], introduce a new class of algorithms and give a methodology for automated generation of a multi-component metaheuristic.",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 0,
      "context" : "see [1, 5, 13, 14]).",
      "startOffset" : 4,
      "endOffset" : 18
    }, {
      "referenceID" : 4,
      "context" : "see [1, 5, 13, 14]).",
      "startOffset" : 4,
      "endOffset" : 18
    }, {
      "referenceID" : 12,
      "context" : "see [1, 5, 13, 14]).",
      "startOffset" : 4,
      "endOffset" : 18
    }, {
      "referenceID" : 13,
      "context" : "see [1, 5, 13, 14]).",
      "startOffset" : 4,
      "endOffset" : 18
    }, {
      "referenceID" : 14,
      "context" : "These test instances were first introduced in the preliminary version of this paper [15] and since then used in a number of papers [9, 11] becoming de facto standard testbed for the BBQP.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 8,
      "context" : "These test instances were first introduced in the preliminary version of this paper [15] and since then used in a number of papers [9, 11] becoming de facto standard testbed for the BBQP.",
      "startOffset" : 131,
      "endOffset" : 138
    }, {
      "referenceID" : 10,
      "context" : "These test instances were first introduced in the preliminary version of this paper [15] and since then used in a number of papers [9, 11] becoming de facto standard testbed for the BBQP.",
      "startOffset" : 131,
      "endOffset" : 138
    }, {
      "referenceID" : 14,
      "context" : "Except for ‘Repair’ and ‘MutationX/Y’, these components were introduced in [15].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 21,
      "context" : "Equation (1) was first introduced in [23] and then used as a neighbourhood search operator in [15], [9] and [11].",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 14,
      "context" : "Equation (1) was first introduced in [23] and then used as a neighbourhood search operator in [15], [9] and [11].",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 8,
      "context" : "Equation (1) was first introduced in [23] and then used as a neighbourhood search operator in [15], [9] and [11].",
      "startOffset" : 100,
      "endOffset" : 103
    }, {
      "referenceID" : 10,
      "context" : "Equation (1) was first introduced in [23] and then used as a neighbourhood search operator in [15], [9] and [11].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 1,
      "context" : "time of OptY is polynomial and the size of the neighbourhood |NOptY(x, y)| = 2 is exponential; hence OptY corresponds to an operator that could be used in a very large-scale neighbourhood search (VLNS), a method that is often considered as a powerful approach to hard combinatorial optimisation problems [2].",
      "startOffset" : 304,
      "endOffset" : 307
    }, {
      "referenceID" : 21,
      "context" : "FlpX and FlpY were first proposed in [23] and then used in [11].",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 10,
      "context" : "FlpX and FlpY were first proposed in [23] and then used in [11].",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 19,
      "context" : "Repair is a new component inspired by the WalkSAT heuristic for SAT problem [21, 24] in that it is a version of ‘iterative repair’ [28] that tries to repair some significant ‘flaw’ (deficiency of the solution) even if this results in creation of other flaws, in a hope that the newly created flaws could be repaired later.",
      "startOffset" : 76,
      "endOffset" : 84
    }, {
      "referenceID" : 22,
      "context" : "Repair is a new component inspired by the WalkSAT heuristic for SAT problem [21, 24] in that it is a version of ‘iterative repair’ [28] that tries to repair some significant ‘flaw’ (deficiency of the solution) even if this results in creation of other flaws, in a hope that the newly created flaws could be repaired later.",
      "startOffset" : 76,
      "endOffset" : 84
    }, {
      "referenceID" : 26,
      "context" : "Repair is a new component inspired by the WalkSAT heuristic for SAT problem [21, 24] in that it is a version of ‘iterative repair’ [28] that tries to repair some significant ‘flaw’ (deficiency of the solution) even if this results in creation of other flaws, in a hope that the newly created flaws could be repaired later.",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 8,
      "context" : "An operator similar to Mutation-X/Y was used in [9].",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 14,
      "context" : "developed for BBQP [15, 9], however, to reduce potential",
      "startOffset" : 19,
      "endOffset" : 26
    }, {
      "referenceID" : 8,
      "context" : "developed for BBQP [15, 9], however, to reduce potential",
      "startOffset" : 19,
      "endOffset" : 26
    }, {
      "referenceID" : 17,
      "context" : "implements Iterated Local Search [18]; the algorithm repeatedly applies HC until it fails, then applies Mut, and then returns to HC disregarding the success or failure of Mut.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 7,
      "context" : "If M succ h,h′ = M fail h,h′ = 1/|H| for all h, h′ ∈ H then CMCS implements a simple uniform random choice of component [8].",
      "startOffset" : 120,
      "endOffset" : 123
    }, {
      "referenceID" : 7,
      "context" : "Note that Operator Probabilities is a static version of a Selection Hyper-heuristic [8].",
      "startOffset" : 84,
      "endOffset" : 87
    }, {
      "referenceID" : 14,
      "context" : "BBQP was first introduced in our unpublished work [15].",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 21,
      "context" : "For an explanation, see [23].",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 10,
      "context" : "We use a strategy similar to the one employed in [11].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 12,
      "context" : "We compared the tuning results of our CMCS-specific algorithm to ParamILS [13], one of the leading general",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 13,
      "context" : "real (or benchmark) instances [14].",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 11,
      "context" : "We note here that CMCS is relevant to the Programming by Optimisation (PbO) concept [12].",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 11,
      "context" : "” [12].",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 11,
      "context" : "the CMCS matrices; for details of PbO see [12].",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 8,
      "context" : "[9] and Tabu Search by Glover et al.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 10,
      "context" : "[11].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "At first, we compare CMCS[2-row] to Tabu Search for which we have detailed experimental results [11].",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 8,
      "context" : "Then we also compare CMCS[2-row] to ILS using approach adopted in [9].",
      "startOffset" : 66,
      "endOffset" : 69
    }, {
      "referenceID" : 10,
      "context" : "The experiments in [11] were conducted on the same benchmark instances, first introduced in [15] and now described in Section 4 of this paper.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 14,
      "context" : "The experiments in [11] were conducted on the same benchmark instances, first introduced in [15] and now described in Section 4 of this paper.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 10,
      "context" : "5In [11], a composite of OptY and FlpX is called Flip-x-Float-y, and a composite of OptX and FlpY is called Flip-y-Float-x.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 8,
      "context" : "[9] that were not significantly different from Tabu.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "As pointed out above, it is known from the literature that ILS [9] performs similarly to Tabu Search, and hence the conclusions of the comparison between CMCS[2-row] and Tabu Search can be extended to ILS as well.",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 8,
      "context" : "However, to verify this, we reproduced the experiment from [9].",
      "startOffset" : 59,
      "endOffset" : 62
    } ],
    "year" : 2016,
    "abstractText" : "We study the Bipartite Boolean Quadratic Programming Problem (BBQP) which is an extension of the well known Boolean Quadratic Programming Problem (BQP). Applications of the BBQP include mining discrete patterns from binary data, approximating matrices by rank-one binary matrices, computing the cut-norm of a matrix, and solving optimisation problems such as maximum weight biclique, bipartite maximum weight cut, maximum weight induced subgraph of a bipartite graph, etc. For the BBQP, we first present several algorithmic components, specifically, hill climbers and mutations, and then show how to combine them in a high-performance metaheuristic. Instead of hand-tuning a standard metaheuristic to test the efficiency of the hybrid of the components, we chose to use an automated generation of a multi-component metaheuristic to save human time, and also improve objectivity in the analysis and comparisons of components. For this we designed a new metaheuristic schema which we call Conditional Markov Chain Search (CMCS). We show that CMCS is flexible enough to model several standard metaheuristics; this flexibility is controlled by multiple numeric parameters, and so is convenient for automated generation. We study the configurations revealed by our approach and show that the best of them outperforms the previous state-of-the-art BBQP algorithm by several orders of magnitude. In our experiments we use benchmark instances introduced in the preliminary version of this paper and described here, which have already become the de facto standard in the BBQP literature.",
    "creator" : "LaTeX with hyperref package"
  }
}