{
  "name" : "1312.6138.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Query Answering in Object Oriented Knowledge Bases in Logic Programming: Description and Challenge for ASP",
    "authors" : [ "Vinay K. Chaudhri", "Stijn Heymans", "Michael Wessel", "Tran Cao Son" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The KB Bio 101 represents knowledge from a textbook used for advanced high school and introductory college biology courses [19]. The KB was developed by SRI as part of their work for Project Halo3 and contains a concept taxonomy for the whole textbook and detailed rules for 20 chapters of the textbook. SRI has tested the educational usefulness of this KB in the context of an intelligent textbook called Inquire4. The KB Bio 101 was originally developed using a knowledge representation and reasoning system called Knowledge Machine (KM) [9]. To express KB Bio 101 in answer set programming (ASP) required us to define a conceptual modeling layer called Object Oriented Knowledge Base or OOKB [6]. The goal of this paper is not to introduce OOKB as a more complete specification and analysis of formal properties of OOKBs are available elsewhere [6]. OOKB is of more general interest as it supports conceptual modeling primitives that are commonly found in description logic (DL) family of languages such as a facility to define classes and organize them into a hierarchy, define partitions, ability to define relations (also known as slots) and organize them into a relation hierarchy, support for domain, range and qualified number constraints, support for defining sufficient conditions of a class, and support for descriptive rules. The features in OOKB also overlap with the features of logic programming (LP) languages such as\n3 http://www.projecthalo.com/ 4 http://www.aaaivideos.org/2012/inquire_intelligent_textbook/\nar X\niv :1\n31 2.\n61 38\nv1 [\ncs .A\nI] 2\n0 D\nec 2\nFDNC [11], Datalog± [5], and ASPfs [1] in its support for function symbols. It differs from these previous LP languages as well as from the DL systems in that the functions can be used to specify graph-structured objects which cannot be done in these other languages. The reasoning with OOKBs has been proven to be undecidable [6]. The approach taken in this paper fosters work on multi-paradigm problem solving in the following ways. First, it aims to give a declarative formalization of reasoning tasks that were originally implemented in KM which is a very different paradigm for reasoning as compared to ASP. Second, the conceptual modeling primitives considered here directly overlap with many description logics, thus, providing another example of integration between ASP with DLs. The primary objective of this paper is to introduceKB Bio 101as a valuable and data set and four queries of practical interest on this KB. These queries have been found extremely useful in the context of Inquire. This dataset presents an excellent opportunity for further development of ASP solvers for the following reasons. • Recent developments in ASP suggest that it could potentially provide an ideal\ntool for large scale KBs. Yet, most of the KBs described in the literature are fairly small. KB Bio 101 provides a real-world ASP program that fits this bill. • We note that KB Bio 101 contains rules with function symbols for which the\ngrounding is infinite. A simple example is a KB consisting of a single class person, and a single relation has-parent, and a statement of the form “for each person there exists an instance of the has-parent relation between this person with another individual who is also a person”. The skolemized versions of these statements require function symbols. An obvious first challenge that must be addressed is to develop suitable grounding techniques. • Even though rules in KB Bio 101 follow a small number of axiom templates,\nthe size of this KB indicates that this could be a non-trivial task for ASP solvers. • The KB Bio 101 cannot be expressed in commonly available decidable DLs\nbecause it contains graph structured descriptions. Efficient reasoning with graph structures is an area of active recent research [15, 16], and since there exists an export of KB Bio 101 for DL systems also [7], it provides an ideal usecase to explore the relative effectiveness of DL reasoners vs ASP solvers on a common problem. • The reasoning tasks of computing differences between two concepts and finding\nrelationships between two individuals are computationally intensive tasks. The implementations of these tasks in Inquire rely on graph algorithms and trade completeness for efficiency. These tasks will present a tough challenges to ASP solvers. • Last but not the least, we believe that the KB could entice the development\nand/or experimentation with new solvers for extended classes of logic programs (e.g., language with existential quantifiers or function symbols).\nIn addition to the challenges listed above, it will be possible to define multiple new challenges of increasing difficulty that can be used to motivate further research and development of ASP solvers."
    }, {
      "heading" : "2 Background: Logic Programming and OOKB",
      "text" : ""
    }, {
      "heading" : "2.1 Logic Programming",
      "text" : "A logic program Π is a set of rules of the form\nc← a1, . . . , am, not am+1, . . . , not an (1)\nwhere 0≤m≤n, each ai is a literal of a first order language and not aj , m<j≤n, is called a negation as failure literal (or naf-literal). c can be a literal or omitted. A rule (program) is non-ground if it contains some variable; otherwise, it is a ground rule (program). When n = 0, the rule is called a fact. When c is omitted, the rule is a constraint. Well-known notions such as substitution, the Herbrand universe UΠ , and Herbrand base BΠ of a program Π are defined as usual. The semantics of a program is defined over ground programs. For a ground rule r of the form (1), let pos(r)={a1, . . . , am} and neg(r)={am+1, . . . , an}. A set of ground literals X is consistent if there exists no atom a s.t. {a,¬a}⊆X. A ground rule r is satisfied by X if (i) neg(r)∩X 6=∅; (ii) pos(r)\\X 6=∅; or (iii) c ∈ X. Let Π be a ground program. For a consistent set of ground literals S, the reduct of Π w.r.t. S, denoted by ΠS , is the program obtained from the set of all rules of Π by deleting (i) each rule that has a naf-literal not a in its body with a ∈ S, and (ii) all naf-literals in the bodies of the remaining rules. S is an answer set of Π [13] if it satisfies the following conditions: (i) If Π does not contain any naf-literal then S is the minimal set of ground literals satisfying all rules in Π; and (ii) If Π contains some naf-literal then S is an answer set of Π if S is the answer set of ΠS . For a non-ground program Π, a set of literals in BΠ is an answer set of Π if it is an answer set of ground(Π) that is the set of all possible ground rules obtained from instantiating variables with terms in UΠ . Π is consistent if it has an answer set. Π entails a ground literal a, Π |= a, if a belongs to every answer set of Π. For convenience in notation, we will make use of choice atoms as defined in [20] that can occur in a rule wherever a literal can. Answer sets of logic programs can be computed using answer set solvers (e.g., Clasp [12], dlv [8])."
    }, {
      "heading" : "2.2 Object-Oriented Knowledge Bases",
      "text" : "We will now review the notion of an OOKB [6]. We note that an OOKB could be viewed as a logic program with function symbols and the language of OOKBs contains features that cannot be represented in previous investigated classes of function symbols such as FDNC [11], Datalog± [5], or ASPfs [1]. In essense, an OOKBs is a logic program consisting of the following components:\n• Taxonomic Knowledge: This group of facts encodes the class hierarchy, the relation hierarchy, individual constants and their class membership. It contains ASP-atoms of the following form:\nclass(c) (2)\nindividual(i) (3)\nsubclass of(c1, c2) (4)\ndisjoint(c1, c2) (5)\ninstance of(i, c) (6)\nrelation(r) (7)\nrange(r, c) (8)\ndomain(r, c) (9)\nsubrelation of(r1, r2) (10)\ncompose(r1, r2, r3) (11)\ninverse(r1, r2) (12)\nThe predicate names are self-explanatory. • Descriptive statements: Relationships between individuals are encoded in\nOOKB by descriptive statements of the form:\nvalue(r, f(X), g(X)) ← instance of(X, c) (13) value(r,X, g(X)) ← instance of(X, c) (14)\nwhere f and g are unary functions, called Skolem functions, such that f 6= g and c is a class. Axiom 13 (or 14) describes a relation value of individuals belonging to class c, encoded by the atom value(r, f(X), g(X)) (or value(r,X, f(X)). It states that for each individual X in c, f(X) (or X) is related to g(X) via the relation r. An example use of axiom 14 is: Every Eukaryotic Cell has part a Nucleus, where Eukaryotic Cell and Nucleus are individuals from these two classes, and has part is a relationship between those individuals. It is required that if f (or g) appears in (13) or (14), then the OOKB also contains the following rule\ninstance of(f(X), cf ) ← instance of(X, c) or (15) instance of(g(X), cg) ← instance of(X, c) (16)\nwhich specify the class of which f(X) (resp. g(X)) is a member. For example, if f(X) represents a nucleus individual, then cf will be the class Nucleus. • Cardinality constraints on relations: OOKB allows cardinality constraints on relations to be specified by statements of the following form:\nconstraint(t, f(X), r, d, n)← instance of(X, c) (17)\nwhere r is a relation, n is a non-negative integer, d and c are classes, and t can either be min, max, or exact. This constraint states that for each instance X of the class c, the set of values of relation r restricted on f(X)—which must occur in a relation value literal value(r, f(X), g(X)) of c—has minimal (resp. maximal, exactly) n values belonging to the class d. The head of (17) is called a constraint literal of c. • Sufficient conditions: A sufficient condition of a class c defines sufficient conditions for membership of that class based on the relation values and\nconstraints applicable to an instance:\ninstance of(X, c)← Body(X) (18)\nwhereBody(X) is a conjunction of relation value literals, instance-of literals, constraint-literals of c, and X is a variable occurring in the body of the rule. • (In)Equality between individual terms: The rules in this group specify in/equality\nbetween terms, which are constructable from Skolem functions and the variable X (t1 and t2), and have the followimg form:\neq(t1, t2)← instance of(X, c) (19) neq(t1, t2)← instance of(X, c) (20)\n• Domain-independent axioms: An OOKB also contains a set of domain-independent axioms ΠR for inheritance reasoning, reasoning about the relation values of individuals (rules (25)—(27)), in/equality between terms (rules (28)—(40)), and enforcing constraints (rules (42)—(47)).\nsubclass of(C,B) ← subclass of(C,A), subclass of(A,B). (21) instance of(X,C) ← instance of(X,D), subclass of(D,C). (22)\ndisjoint(C,D) ← disjoint(D,C). (23) ¬instance of(X,C) ← instance of(X,D), disjoint(D,C). (24)\nvalue(U,X,Z) ← compose(S, T, U), value(S,X, Y ), value(T, Y, Z). (25) value(T,X, Y ) ← subrelation of(S, T ), value(S,X, Y ). (26) value(T, Y,X) ← inverse(S, T ), value(S,X, Y ). (27)\neq(X,Y ) ← eq(Y,X) (28) eq(X,Z) ← eq(X,Y ), eq(Y,Z), X 6= Z (29)\n← eq(X,Y ), neq(X,Y ) (30) {substitute(X,Y )} ← eq(X,Y ). (31)\n← eq(X,Y ), {substitute(X,Z) : eq(X,Z)}0, (32) {substitute(Y,Z) : eq(Y,Z)}0.\n← substitute(X,Y ), substitute(X,Z), (33) X 6= Y,X 6= Z, Y 6= Z. (34)\n← substitute(X,Y ), X 6= Y, neq(X,Y ). (35) substitute(Y,Z) ← substitute(X,Z), X 6= Z, eq(X,Y ). (36)\nis substituted(X) ← substitute(X,Y ), X 6= Y. (37) substitute(X,X) ← term(X), not is substituted(X). (38)\nterm(X) ← value(S,X, Y ). (39) term(Y ) ← value(S,X, Y ). (40)\nvaluee(S, P,Q) ← value(S,X, Y ), substitute(X,P ), substitute(Y,Q). (41) ← value(S,X, Y ), domain(S,C), not instance of(X,C).(42) ← value(S,X, Y ), range(S,C), not instance of(Y,C). (43) ← constraint(min, Y, S,D,M), (44)\n{valuee(S, Y, Z) : instance of(Z,D)}M − 1. ← constraint(max, Y, S,D,M), (45)\nM + 1{valuee(S, Y, Z) : instance of(Z,D)}. ← constraint(exact, Y, S,D,M), (46) {valuee(S, Y, Z) : instance of(Z,D)}M − 1. ← constraint(exact, Y, S,D,M), (47) M + 1{valuee(S, Y, Z) : instance of(Z,D)}.\nFor a detailed explanation of the above rules, please refer to [6]. An OO-domain is a collection of rules of the form (2)—(20). ¿From now on, whenever we refer to an OOKB, we mean the prorgram D ∪ΠR, denoted by KB(D), where D is the OO-domain of the OOKB5.\n2.3 KB Bio 101: An OOKB Usage and Some Key Characteristics\nThe KB Bio 101 is an instance of OOKB and is available in ASP format6. The KB is based on an upper ontology called the Component Library [3]. The biologists used a knowledge authoring system called AURA to represent knowledge from a biology textbook. As an example, in Figure 1, we show an example AURA graph. The white node labeled as Eukaryotic-Cell is the root node and represents the universally quantified variable X, whereas the other nodes shown in gray represent existentials, or the Skolem functions fn(X). The nodes labeled as has part and is inside represent the relation names. The authoring process in\nAURA can be abstractly characterized as involving three steps: inherit, specialize and extend. For example, the biologist creates the class Eukaryotic-Cell as a subclass of Cell. While doing so, the system would first inherit the relation values defined for Cell which in this case is a Chromosome, and show it in the graphical editor. The biologist then uses a gesture in the editor to specialize the inherited Chromosome to a Eukaryotic-Chromosome, and then introduces a new Nucleus and relates it to the Eukaryotic-Chromosome, via an is-inside relationship. The\n5 In [6], general OOKBs, that can contain arbitrary logic programming rules, were defined. The discussion in this paper is applicable to general OOKBs as well. 6 See http://www.ai.sri.com/~halo/public/exported-kb/biokb.html\ninherited Chromosome value for the has-part relationship, is thus, specialized to Eukaryotic-Chromosome and extended by connecting it to the Nucleus by using an is-inside relationship. The statistics about the size of the exported OOKB are summarized in Table 1. In total KB Bio 101 has more than 300,000 non-ground rules. It contains 746 individuals which are members of classes which represent constants of measurements, colors, shapes, quantity, priority, etc. The KB does not contain individuals of biology classes such as cell, ribosome, etc. For computing properties of an individual or comparing individuals, the input needs to introduce the individuals."
    }, {
      "heading" : "3 Queries in OOKBs",
      "text" : "We will now describe the queries given an OOKB, say KB(D). These queries play a central role in the educational application Inquire [17] which employs the knowledge encoded in KB Bio 101. These queries were developed by extensive analysis of the questions from an exam, the questions at the back of the book, and the questions that are educationally useful [4, 18]. We divide these queries into four groups. The first type of queries which includes the first two queries asks about facts and relatiolnships. The second type of queries asks about the taxonomic information. These first two question types are usually referred to as the wh-questions. The third type is about the differences and similarities between individuals from different classes. This type of query has been traditionally studied as an example of analogical reasoning [10]. The fourth type of queries that includes the last two questions query for relationships between concepts and are unique to our work.\n• what is a eukaryotic cell? • what process provides raw materials for the citric acic cycle during cellu-\nlar respiration? • is oocyte a subclass of a eukaryotic cell? • describe the differences and similarities between mitochondrions and chloroplasts • What is the relationship between a mitochondrion and a chloroplast\n• in the absence of oxygen, yeast cells can obtain energy bywhich process? Let Z be a set of literals of KB(D), r be a relation, and i be an individual from a class c. T (i) denotes the set of terms constructable from Skolem functions and the individual i. We characterize the set of pairs in the relation r w.r.t. Z in KB(D) by the set V (r, i, c, Z) = {(r, x, y) | value(r, x, y) ∈ Z, x, y ∈ T (i)} if instance of(i, c) ∈ Z; otherwise, V (r, i, c, Z)=∅.\nDefinition 1 (Value set of an individual). Let KB(D) be an OOKB. For an answer set M of KB(D), the value set of an individual i at a class c w.r.t. M , Σ(i, c,M), is defined by Σ(i, c,M) = ⋃ relation(r)∈M V (i, c, r,M).\nObserve that the rules (29)—(41) indicate that KB(D) can have multiple answer sets. Nevertheless, the structure of KB(D) allows us to prove the following important property of answer sets of KB(D).\nProposition 1. Let KB(D) be an OOKB. For every two answer sets M1 and M2 of KB(D), every literal in M1 \\ M2 has one of the following forms: (i) substitute(x, y); (ii) is substituted(x, y); or (iii) valuee(r, x, y).\nThe above proposition indicates that Σ(i, c,M1) = Σ(i, c,M2) for arbitrary individual i and class c and answer sets M1 and M2 of KB(D). The relationship between atoms of the form value(r, x, y) and valuee(r, x, y) is as follows.\nProposition 2. Let KB(D) be an OOKB, i an individual, and c a class. For every answer sets M of KB(D), we have that valuee(r, x, y) ∈ M iff there exists x′, y′ such that (i) M contains the following atoms eq(x′, x), eq(y′, y), substitute(x′, x), and substitute(y′, y); and (ii) (r, x′, y′) ∈ Σ(i, c,M).\nThe significance of these two propositions is that cautious reasoning about values of individuals at classes can be accomplished by computing one answer set of KB(D). As we will see, the majority of queries is related to this type of reasoning. We next describe, for each query Q, an input program I(Q) and a set R(Q) of rules for computing the answer of Q. Throughout the section, KB denotes an arbitrary but fixed OOKB KB(D) and KB(Q) = KB(D) ∪ I(Q) ∪R(Q).\n3.1 Subsumption Between Classes (Q1)\nSubsumption requires us to compute whether a class c1 is subsumed by a class c2, i.e., whether for each answer setM ofKB(Q1), we have for each instance of(x, c1) ∈ M also instance of(x, c2) ∈ M . We can answer this question by introducing a fresh constant i in the OOKB and set I(Q1) = {instance of(i, c1)}. R(Q1) consists of a rule:\nsubclass of(c1, c2)← instance of(i, c2) (48)\nIndeed, we then have that a class c1 is subsumbed by c2 iff for each answer set M of KB(Q1), subclass of(c1, c2) ∈ M . Proposition 1 can be extended to KB(Q1) and thus we only need to compute one answer set of KB(Q1). Note that this shows how, as in description logics, subsumption can be reduced to entailment in the OOKB framework. We can show that\nProposition 3. If KB(Q1) has an answer set M and subclass of(c1, c2) ∈M then c1 is subsumed by c2.\nWe note that computing answer sets of KB(Q1) is not a simple task (see [6]). In particular, the problem for KB Bio 101 is quite challenging due to its size and the potential infiniteness of the grounding program of KB(Q1). One can define many more taxonomic queries than what we have considered here. Some examples of such queries are as follows. Given a class C, compute all its super classes or subclasses? Given a class, return only most specific superclass? Given two classes, return there nearest common superclass? Some of the taxonomic queries can require a higher order representation. For example, given two classes, compute a class description that is their union or intersection. Such queries are straightforward in a DL system, and are examples of capabilities that are challenging for the current ASP systems.\n3.2 Description of an Individual (Q2)\nQueries about the description of an individual ask for a description of an individual of a class c, represented by a fresh constant i in the language of KB(D). This query can be represented by the program I(Q2) = {get value(i, c).instance of(i, c).} where get value(i, c) encodes the query of “inquiring about values of i at the class c.” We will now discuss the answer to this query. Intuitively, a complete description of i should contain the following information: • C(c)={d | KB(D)|=subclass of(c, d)}, the classes from which i inherits its\nrelation values; and • its relation values, i.e., the triples in Σ(i, c,M) where M is a given answer\nset of R(Q2). Computing a complete description of i could be achieved by the following rules:\nout member of(Y ) ← get value(I, C), instance of(I, C), instance of(I, Y ). (49) out value(R,X, Y ) ← get value(I, C), value(R,X, Y ), relation(R), (50)\nterm of(X, I), term of(Y, I).\nwhere term of(X, I) defines a term (X) that is constructable from Skolem functions and an individual (I), out member of(d) indicates that i is an instance of the class d (i.e., d ∈ C(c)), and out value(r, x, y) says that KB(D) |= value(r, x, y). This answer is correct but may contain too much information for users of an OOKB who have knowledge about the class hierarchy. This is because the above description could also include values that i can inherit from the superclasses of c. This can be seen in the next example.\nExample 1. Let us consider the class Eukaryotic cell. The description of this class contains 88 statements of the form (13)—(14) that involve 167 classes and 150 equality specifications. A first-level answer7 computed using (49)–(50)\n7 Current solvers can only approximate the answer due to the infiniteness of the grounding program. We computed the answer by limiting the maximum nesting level for complex terms of the term to be 1 (e.g., the option maxnesting in dlv).\ncontains 9 atoms of the form out member of(x) which indicate that a eukaryotic cell is also a cell, a living entity, a physical object, etc. In addition, there are 643 atoms of the form out value(r, x, y) which contains inverse, composition, sub-relation, and the relation value defined in statements of the form (13)—(14) and those that are obtained by the rules (25)–(27).\nThe example highlights two challenges in computing the description of an individual. First, since the grounding of the KB is infinite, it raises the question of what counts as an adequate grounding that returns a sufficient description of an individuals? Second, for practical query answering applications that use KB Bio 101, one must post-process the results to deciding which subset of the answers should be preesnted to the user. It should be noted that because of the infiniteness of the grounded KB, current ASP solvers can be used to approximate the answers, by setting depth bounds. Whether this will result in acceptable performance, both in terms of the quality of the answers and the efficiency, is a topic open for future research.\n3.3 Comparing between Classes (Q3)\nA comparison query takes the general form of “What are the differences/similarities between c1 and c2?” (e.g., “what are the differences between chromosome and ribosome?”). More specific versions of the query may ask for specific kinds of differences, e.g., structural differences. The query can be represented and answered by (i) introducing two new constants i1 and i2 which are instances of c1 and c2, respectively; and (ii) identifying the differences and similarities presented in the descriptions of i1 and i2. We therefore encode I(Q3) using the following program:\ninstance of(i1, c1). instance of(i2, c2). comparison(i1, c1, i2, c2). (51)\nLet us first discuss the features that can be used in comparing individuals of two classes. Individuals from two classes can be distinguished from each other using different dimensions, either by their superclass relationship or by the relations defined for each class. More specifically, they can be differentiated from each other by the generalitation and/or specialitation between classes; or the properties of instances belonging to them. We will refer to these two dimensions as class-dimension and instance-dimension, respectively. We therefore define the following notions, given an answer set M of KB(Q3): • The set of similar classes between c1 and c2: is the intersection between the\nset of superclasses of c1 and of c2 U(c1, c2) = C(c1) ∩ C(c2). • The set of different classes between c1 and c2: is the set difference between the\nset of superclasses of c1 and of c2 D(c1, c2) = (C(c1)\\C(c2))∪(C(c2)\\C(c1)). where C(c) denotes the set of superclasses of c. We next discuss the question of what should be considered as a similar and/or different property between individuals of two different classes. Our formalization is motivated from the typical answers to this type of question such as an answer “a chromosome has a part as protein but a ribosome does not” to the query\n“what is the different between a chromosome and a ribosome?” This answer indicates that for each chromosome x there exists a part of x, say f(x), which is a protein, i.e., value(has part, x, f(x)) and instance of(f(x), protein) hold; furthermore, no part of a ribosome, say y, is a protein, i.e., there exists no g such that value(has part, y, g(y)) and instance of(g(y), protein) hold. For a set of literals M of KB(Q3) and a class c with instance of(i, c) ∈M , let T (i, c) be the set of triples (r, p, q) such that (r, x, y) ∈ Σ(i, c,M), instance of(x, p) ∈ M , and instance of(y, q) ∈ M . p (q) is called the domain (range) of r if (r, p, q) ∈ T (i, c). We define • The set of similar relations between c1 and c2: is the set Rs(c1, c2) of relations s such that (i) c1 and c2 are domain of s; (ii) c1 and c2 are range of s; or (iii) there exist (p, q) such that (s, p, q) ∈ T (i1, c1) ∩ T (i2, c2).\n• The set of different relations between c1 and c2: is the set Rd(c1, c2) of relations s such that (i) c1 is and c2 is not a domain of s or vice versa; (ii) c1 is and c2 is not a range of s vice versa; or (iii) there exist (p, q) such that (s, p, q) ∈ (T (i1, c1) \\ T (i2, c2)) ∪ (T (i2, c2) \\ T (i1, c1)). An answer to Q3 must contain information from U(c1, c2), D(c1, c2), R s(c1, c2), and Rd(c1, c2). Computing U(c1, c2) and D(c1, c2) rely on the rules for determining the most specific classes among a group of classes which can easily be implemented using the naf-operator. We now describe the set of rules R(Q3), dividing it into different groups. First, the set of rules for computing U(c1, c2) is as follows:\nshared(C,P,Q)← comparison(X,P, Y,Q), subclass of(P,C), subclass of(Q,C). (52)\nThe rule identifies the classes that are superclass of both c1 and c2. We can show that KB(Q3) |= shared(c, c1, c2) iff c ∈ U(c1, c2). The next set of rules is for computing D(c1, c2).\ndist(C,P,Q) ← comparison(X,P, Y,Q), subclass of(P,C), not subclass of(Q,C). (53) dist(C,P,Q) ← comparison(X,P, Y,Q), not subclass of(P,C), subclass of(Q,C). (54)\nThe two rules identify the classes that are superclass of c1 but not c2 and vice versa. Again, we can show that KB(Q3) |= dist(c, c1, c2) iff c ∈ D(c1, c2). For computing Rs(c1, c2) and R\nd(c1, c2), we need to compute the sets T (i1, c1) and T (i2, c2). For this purpose, we define two predicates t1 and t2 such that for every answer set M of KB(Q3), tk(s, p, q) ∈ M iff (s, p, q) ∈ T (ik, ck) for k = 1, 2. Before we present the rules, let us denote a predicate msc of , called the most specific class of an individual, by the following rules.\nnot msc of(X,P ) ← subclass of(Q,P ), instance of(X,P ), instance of(X,Q). (55) msc of(X,P ) ← instance of(X,P ), not not msc of(X,P ). (56)\nThese rules state that the class p is the most specific class of an individual x if x is a member of p and x is not an instance of any subclass q of p. This will allow us to define the set T (i1, c1) and T (i2, c2) as follows.\n3{t1(R,P,Q), ← comparison(X1, C1, Y1, C2), value(R,X, Y ), (57)\nq d(R,P ), term of(Y,X1), term of(X,X1),\nq r(R,Q)} msc of(X,P ),msc of(Y,Q). 3{t2(R,P,Q), ← comparison(X1, C1, Y1, C2), value(R,X, Y ), (58)\nq d(R,P ), term of(X,Y1), term of(Y, Y1), (59) q r(R,Q)} msc of(X,P ),msc of(Y,Q).\nThe following rules identify relations that are similar between c1 and c2:\nshared property(R) ← comparison(X1, C1, Y1, C2), t1(R,C1, Q1), t2(R,C2, Q2).(60) shared property(S) ← comparison(X1, C1, Y1, C2), t1(R,P1, C1), t2(R,P2, C2). (61) shared property(S) ← comparison(X1, C1, Y1, C2), t1(R,P,Q), t2(R,P,Q). (62)\nThe rules say that individuals i1 and i2 from class c1 and c2 respectively share a relation r. The first rule says that ik (k = 1, 2) is a source in the relation r (i.e., there exists some tk such that (r, ik, tk) ∈ Σ(ik, ck,M)); The second rule says that ik is a destination in the relation r (i.e., the first rule: there exists some tk such that (r, tk, ik) ∈ Σ(ik, ck,M)). The third rule says that there exist some pair t1k, t 2 k such that t 1 k and t 2 k are instances of the same class and (r, t1k, t 2 k) ∈ Σ(ik, ck,M). The set of rules for computing Rd(c1, c2) is similar to the above set of rules. It is omitted here for space reason. The key challenge in computing the differences/similarities between classes in KB Bio 101 are the same as for Q2. First, since the grounded program is infinite, one has to determine what is an adequate description that should be used for the purposes of comparsion. Second, even though the computation will return all differences and similarties, the users are frequently interested in knowing about salient differences. The current AURA system uses a complex set of heuristics to post process the results to group and rank the results to draw out the salience. The description of such heuristics is outside the scope of the present paper.\n3.4 Relationship between Individuals (Q4)\nA relationship query takes the general form of “What is the relationship between individual i1 and individual i2?”, e.g., “what is the relationship between a biomembrane and a carbohydrate”? Since this type of query refers to a path between two individuals, it can involve significant search in the KB making it especially suitable for solution by ASP solvers. In more specific forms of this query, the choice of relationships can be limited to a specific subset of relationships in the KB. For example, “What is the structural or functional relationship between individual i1 and individual i2?” We can formulate this query as follows. Given a set of literals M of an OOKB and a set of relations S, a sequence of classes alternated with relation ω = (c1, s1, c2, s2, . . . , sn−1, cn) is called a path between q1 and qn with restrictive relations S inM if there exists instance of(t, c1) ∈ M and Skolem functions f1 = id, f2, . . . , fn−1 such that value(si, fi(t), fi+1(t)) ∈ M for i = 1, . . . , n − 1 and instance of(fi(t), ci) ∈ M for i ≥ 2 and si ∈ S for\n1 ≤ i < n. A query of type Q4 asks for a path between c1 and c2 with restrictive relations in S and is encoded by the program I(Q4):\ninstance of(i1, c1). instance of(i2, c2). p relation(c1, c2). include(r). (r ∈ S)\nThe answer to the query should indicate paths between c1 and c2 with restrictive relations in S. Observe that an answer can be generated by (i) selecting some atoms of the form value(s, x, y) such that s ∈ S; and (ii) checking whether these atoms create a path from c1 to c2. We next present the set of rules R(Q4), dividing them into two groups that implement the steps (i) and (ii) as follows.\np segment(R,E,C, F,D) ← include(R), value(R,E, F ), instance of(E,C), (63) instance of(F,D).\n{seg(S,E,C, F,D)} ← p segment(S,E,C, F,D). (64) ← p relation(C1, C2), {seg( , , C1, , )}0. (65) ← p relation(C1, C2), 2{seg( , , C1, , )}. (66) ← p relation(C1, C2), {seg( , , , , C2)}0. (67) ← p relation(C1, C2), 2{seg( , , , , C2)}. (68)\nThe first rule defines possible segments of the path. The second rule, a choice rule, picks some arbitrary segments to create the path. A segment is represented by the atom seg(s, e, c, e′, c′) that encodes a relation s between e (an instance of class c) and e′ (an instance of class c′). The rest of the rules eliminate combinations that do not create a path from c1 to c2. For example, the first two constraints make sure that there must be exactly one segment starting from c1; the next two ensure that there must be exactly one segment that ends at c2. The next four constraints make sure that the segments create a path.\n← p relation(C1, C2), seg(S,E,C,E1, D), D 6= C2, {seg( , E1, D, , )}0. (69) ← p relation(C1, C2), seg(S,E,C,E1, D), D 6= C2, 2{seg( , E1, D, , )}. (70) ← p relation(C1, C2), seg(S,E,C,E1, D), D 6= C2, C 6= C1, {seg( , , , E, C)}0. (71) ← p relation(C1, C2), seg(S,E,C,E1, D), D 6= C2, C 6= C1, 2{seg( , , , E, C)}. (72)\nEven if one could define a suitable finite grounding of KB Bio 101, computing KB(Q4) can be exponential in the worst case. The implementation of this query in AURA relies on a set of heuristics and depth-bound incomplete reasoning. E.g., one heuristic involves first performing the search on the subclass relationships. The existing implementation is unsatisfactory as it misses out important relationships. In an ideal implementation, one would first compute all candidate paths, and then rank them based on user provided critieria. Computing all such paths especially at the runtime has been infeasible in AURA so far. We hope that ASP could provide a solution for an efficient path computation."
    }, {
      "heading" : "4 Discussion",
      "text" : "We observe that there was no use of default negation in the axioms (2)-(20) that specify OOKB. The default negation is used in the domain independent axioms,\nfor example, in axiom (38) and in axioms (53)-(54). In principle, default negation could be used in axioms (13) or axiom (14), but in our practical experience in developing KB Bio 101 such usage has not been necessary. That is primarily because while formalizing the textbook knowledge, one typically requires classical negation. It is only for query answering that the usage of negation becomes critical. If one generalizes OOKB to other domains, it may well be necessary to use default negation in the domain specification axioms (2)-(20), but we have not considered such usage in our work so far. Since default negation is necessary to specify query answering for OOKB, ASP provides a compelling paradigm for declarative specification of such reasoning. Let us also consider comparison between using ASP vs DLs for OOKB queries presented here. There are two key features of OOKBs that are not directly expressible in description logics: graph-structured objects and (in)equality statements. Using axioms (13) and (14), it is possible to define a graph structure. It is well known that graph structured descriptions usually lead to undecidability in reasoning [16]. In(equality) statements as in axiom (19) and (20), allow us to relate skolem functions that have been introduced as part of two different class descriptions. Such modeling paradigm is not supported by DLs. Of course, the reasoning with OOKBs in full generality is undecidable, and it is an open question whether there exist decidable fragments of OOKB for which the reasoning is decidable [6]. Another important difference between a DL and ASP is in handling of constraints. To illustrate this difference, consider a KB that has a statement: every person has exactly two parents, and further individuals p1, p2, p3 and p4, such that p2, p3 and p4 are the parents of p1. With axioms (43)-(47), such a KB will be inconsistent. In contrast, most DL system will infer that either p2 must be equal to p3, or p3 must be equal to p4, or p4 must be equal to p2. The semantics of constraints in AURA conform to the semantics captured in axioms (43)-(47). Our work on formalizing the OOKB queries in ASP has been only theoretical, and an experimental evaluation is open for future work. Some example answers of the queries considered in Section 3 which are produced by the Inquire system can be seen at [17]."
    }, {
      "heading" : "5 Conclusions",
      "text" : "We described the contents of an OOKB knowledge base, and formulated ASP programs for answering four classes of practically interesting queries. We also presented a practical OOKB, KB Bio 101, whose size and necessary features make the computation of the answers to these queries almost impossible using contemporary ASP solvers. The specific challenges include developing suitable grounding strategies and dealing with potential undecidability in reasoning with an OOKB. Given the large overlap in features supported by OOKB and DLs, the KB Bio 101 also presents a unique dataset which could be used to explore relative tradeoffs in reasoning efficiency across these two different paradigms. Being a concrete OOKB, KB Bio 101 presents a real challenge for the development\nof ASP-solvers. This also calls for the development of novel query answering methods with huge programs in ASP. We welcome engaging with both the ASP and DL research communities so that KB Bio 101 could be used as a driver for advancing the state of the art in efficient and scalable reasoning."
    }, {
      "heading" : "Acknowledgment",
      "text" : "This work was funded by Vulcan Inc. and SRI International."
    } ],
    "references" : [ {
      "title" : "Disjunctive ASP with functions: Decidable queries and effective computation",
      "author" : [ "M. Alviano", "W. Faber", "N. Leone" ],
      "venue" : "TPLP, 10(4-6):497–512,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A library of generic concepts for composing knowledge bases",
      "author" : [ "K. Barker", "B. Porter", "P. Clark" ],
      "venue" : "In Proc. 1st Int Conf on Knowledge Capture,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "and V",
      "author" : [ "P. Clark" ],
      "venue" : "Chaudhri and S. Mishra and J. Thomere and K. Barker and B. Porter. Enabling Domain Experts to Convey Questions to Machine: A Modified, Template-Based Approach In Proc. 2nd Int Conf on Knowledge Capture,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Datalog±: a unified approach to ontologies and integrity constraints",
      "author" : [ "A. Cal̀ı", "G. Gottlob", "T. Lukasiewicz" ],
      "venue" : "In Database Theory - ICDT 2009. ACM",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2009
    }, {
      "title" : "Object Oriented Knowledge Bases in Logic Programming",
      "author" : [ "V. Chaudhri", "S. Heymans", "M. Wessel", "T.C. Son" ],
      "venue" : "In Technical Communications of International Conference on Logic Programming,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "KB Bio 101: A Challenge for OWL Reasoners",
      "author" : [ "V. Chaudhri", "S. Heymans", "M. Wessel" ],
      "venue" : "In Proceedings of the Workshop on OWL Reasoner Evaluation,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "The KR System dlv: Progress Report, Comparisons, and Benchmarks",
      "author" : [ "T. Eiter", "N. Leone", "C. Mateis", "G. Pfeifer", "F. Scarcello" ],
      "venue" : "KRR, 406–417,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "and B",
      "author" : [ "P. Clar" ],
      "venue" : "Porter. KM (v2.0 and later): Users Manual,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "and K",
      "author" : [ "S. Nicholso" ],
      "venue" : "Forbus Answering Comparison Questions in SHAKEN: A Progress Report AAAI Spring Symposium on Mining Answers From Text and Knowledge Bases,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "FDNC: Decidable nonmonotonic disjunctive logic programs with function symbols",
      "author" : [ "T. Eiter", "M. Simkus" ],
      "venue" : "ACM TOCL, 11(2),",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "clasp: A conflict-driven answer set solver",
      "author" : [ "M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub" ],
      "venue" : "LPNMR’07, LNAI 4483, 260–265. Springer-Verlag,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Logic programs with classical negation",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "ICLP, 579– 597,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Project Halo Update—Progress Toward Digital Aristotle",
      "author" : [ "D. Gunning", "V.K. Chaudhri", "P. Clark", "K. Barker", "S-Y. Chaw", "M. Greaves", "B. Grosof", "A. Leung", "D. McDonald", "S. Mishra", "J. Pacheco", "B. Porter", "A. Spaulding", "D. Tecuci", "J. Tien" ],
      "venue" : "AI Magazine, pages 33–58,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "B",
      "author" : [ "D. Magka" ],
      "venue" : "Motik, B., and I. Horrocks. Modeling Structured Domains using Description Graphs and Logic Programming. In DL",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Representing ontologies using description logics, description graphs, and rules",
      "author" : [ "B. Motik", "B.C. Grau", "I. Horrocks", "U. Sattler" ],
      "venue" : "AIJ, 173:1275-1309,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Inquire: An Intelligent Textbook",
      "author" : [ "A. Overholtzer", "A. Spaulding", "V.K. Chaudhri", "D. Gunning" ],
      "venue" : "In Proceedings of AAAI Video Competition Track,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Inquire Biology: A Textbook that Answers Questions",
      "author" : [ "V. Chaudhri", "B. Cheng", "A. Overholtzer", "J. Roschelle", "A. Spaulding", "P. Clark", "M. Greaves", "D. Gunning" ],
      "venue" : "In AI Magazine, Vol 34, No 3, September",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Campbell Biology, 9/E",
      "author" : [ "J.B. Reece", "L.A. Urry", "M.L. Cain", "S.A. Wasserman", "P.V. Minorsky", "R.B. Jackson" ],
      "venue" : "Benjamin Cummings,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "P. Simons", "N. Niemelä", "T. Soininen" ],
      "venue" : "Artificial Intelligence, 138(1–2):181–234,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Automatic Strengthening of GraphStructured Knowledge Bases",
      "author" : [ "M. Wessel", "V. Chaudhri", "S. Heymans" ],
      "venue" : "In 3rd International Workshop on Graph Structures for Knowledge Representation and Reasoning,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 17,
      "context" : "The KB Bio 101 represents knowledge from a textbook used for advanced high school and introductory college biology courses [19].",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 7,
      "context" : "The KB Bio 101 was originally developed using a knowledge representation and reasoning system called Knowledge Machine (KM) [9].",
      "startOffset" : 124,
      "endOffset" : 127
    }, {
      "referenceID" : 4,
      "context" : "To express KB Bio 101 in answer set programming (ASP) required us to define a conceptual modeling layer called Object Oriented Knowledge Base or OOKB [6].",
      "startOffset" : 150,
      "endOffset" : 153
    }, {
      "referenceID" : 4,
      "context" : "The goal of this paper is not to introduce OOKB as a more complete specification and analysis of formal properties of OOKBs are available elsewhere [6].",
      "startOffset" : 148,
      "endOffset" : 151
    }, {
      "referenceID" : 9,
      "context" : "FDNC [11], Datalog± [5], and ASP [1] in its support for function symbols.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 3,
      "context" : "FDNC [11], Datalog± [5], and ASP [1] in its support for function symbols.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 0,
      "context" : "FDNC [11], Datalog± [5], and ASP [1] in its support for function symbols.",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 4,
      "context" : "The reasoning with OOKBs has been proven to be undecidable [6].",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 13,
      "context" : "Efficient reasoning with graph structures is an area of active recent research [15, 16], and since there exists an export of KB Bio 101 for DL systems also [7], it provides an ideal usecase to explore the relative effectiveness of DL reasoners vs ASP solvers on a common problem.",
      "startOffset" : 79,
      "endOffset" : 87
    }, {
      "referenceID" : 14,
      "context" : "Efficient reasoning with graph structures is an area of active recent research [15, 16], and since there exists an export of KB Bio 101 for DL systems also [7], it provides an ideal usecase to explore the relative effectiveness of DL reasoners vs ASP solvers on a common problem.",
      "startOffset" : 79,
      "endOffset" : 87
    }, {
      "referenceID" : 5,
      "context" : "Efficient reasoning with graph structures is an area of active recent research [15, 16], and since there exists an export of KB Bio 101 for DL systems also [7], it provides an ideal usecase to explore the relative effectiveness of DL reasoners vs ASP solvers on a common problem.",
      "startOffset" : 156,
      "endOffset" : 159
    }, {
      "referenceID" : 11,
      "context" : "S is an answer set of Π [13] if it satisfies the following conditions: (i) If Π does not contain any naf-literal then S is the minimal set of ground literals satisfying all rules in Π; and (ii) If Π contains some naf-literal then S is an answer set of Π if S is the answer set of Π .",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 18,
      "context" : "For convenience in notation, we will make use of choice atoms as defined in [20] that can occur in a rule wherever a literal can.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 10,
      "context" : ", Clasp [12], dlv [8]).",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 6,
      "context" : ", Clasp [12], dlv [8]).",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 4,
      "context" : "We will now review the notion of an OOKB [6].",
      "startOffset" : 41,
      "endOffset" : 44
    }, {
      "referenceID" : 9,
      "context" : "We note that an OOKB could be viewed as a logic program with function symbols and the language of OOKBs contains features that cannot be represented in previous investigated classes of function symbols such as FDNC [11], Datalog± [5], or ASP [1].",
      "startOffset" : 215,
      "endOffset" : 219
    }, {
      "referenceID" : 3,
      "context" : "We note that an OOKB could be viewed as a logic program with function symbols and the language of OOKBs contains features that cannot be represented in previous investigated classes of function symbols such as FDNC [11], Datalog± [5], or ASP [1].",
      "startOffset" : 230,
      "endOffset" : 233
    }, {
      "referenceID" : 0,
      "context" : "We note that an OOKB could be viewed as a logic program with function symbols and the language of OOKBs contains features that cannot be represented in previous investigated classes of function symbols such as FDNC [11], Datalog± [5], or ASP [1].",
      "startOffset" : 242,
      "endOffset" : 245
    }, {
      "referenceID" : 4,
      "context" : "For a detailed explanation of the above rules, please refer to [6].",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 1,
      "context" : "The KB is based on an upper ontology called the Component Library [3].",
      "startOffset" : 66,
      "endOffset" : 69
    }, {
      "referenceID" : 4,
      "context" : "5 In [6], general OOKBs, that can contain arbitrary logic programming rules, were defined.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 15,
      "context" : "These queries play a central role in the educational application Inquire [17] which employs the knowledge encoded in KB Bio 101.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 2,
      "context" : "These queries were developed by extensive analysis of the questions from an exam, the questions at the back of the book, and the questions that are educationally useful [4, 18].",
      "startOffset" : 169,
      "endOffset" : 176
    }, {
      "referenceID" : 16,
      "context" : "These queries were developed by extensive analysis of the questions from an exam, the questions at the back of the book, and the questions that are educationally useful [4, 18].",
      "startOffset" : 169,
      "endOffset" : 176
    }, {
      "referenceID" : 8,
      "context" : "This type of query has been traditionally studied as an example of analogical reasoning [10].",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 4,
      "context" : "We note that computing answer sets of KB(Q1) is not a simple task (see [6]).",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 14,
      "context" : "It is well known that graph structured descriptions usually lead to undecidability in reasoning [16].",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 4,
      "context" : "Of course, the reasoning with OOKBs in full generality is undecidable, and it is an open question whether there exist decidable fragments of OOKB for which the reasoning is decidable [6].",
      "startOffset" : 183,
      "endOffset" : 186
    }, {
      "referenceID" : 15,
      "context" : "Some example answers of the queries considered in Section 3 which are produced by the Inquire system can be seen at [17].",
      "startOffset" : 116,
      "endOffset" : 120
    } ],
    "year" : 2013,
    "abstractText" : "Research on developing efficient and scalable ASP solvers can substantially benefit by the availability of data sets to experiment with. KB Bio 101 contains knowledge from a biology textbook, has been developed as part of Project Halo, and has recently become available for research use. KB Bio 101 is one of the largest KBs available in ASP and the reasoning with it is undecidable in general. We give a description of this KB and ASP programs for a suite of queries that have been of practical interest. We explain why these queries pose significant practical challenges for the current ASP solvers.",
    "creator" : "TeX"
  }
}