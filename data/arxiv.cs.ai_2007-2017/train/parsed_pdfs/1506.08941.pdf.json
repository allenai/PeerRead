{
  "name" : "1506.08941.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Language Understanding for Text-based Games Using Deep Reinforcement Learning",
    "authors" : [ "Karthik Narasimhan", "Tejas Kulkarni", "Regina Barzilay" ],
    "emails" : [ "karthikn@csail.mit.edu", "tejask@mit.edu", "regina@csail.mit.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "In this paper, we address the task of learning control policies for text-based strategy games. These games, predecessors to modern graphical ones, still enjoy a large following worldwide.1 They often involve complex worlds with rich interactions and elaborate textual descriptions of the underlying states (see Figure 1). Players read descriptions of the current world state and respond with natural language commands to take actions. Since the underlying state is not directly observable, the player has to understand the text in order to act, making it challenging for existing AI programs to play these games.\nIn designing an autonomous game player, we have considerable latitude when selecting an ad-\n∗These authors contributed equally to this work. 1http://mudstats.com/\nequate state representation to use. The simplest method is to use a bag-of-words representation derived from the text description. However, this scheme disregards the ordering of words and the finer nuances of meaning that evolve from composing words into sentences and paragraphs. For instance, in State 2 in Figure 1, the agent has to understand that going east will lead it to the castle whereas moving south will take it to the standing archway. An alternative approach is to convert text descriptions to pre-specified representations using annotated training data, commonly used in language grounding tasks (Matuszek et al., 2013; Kushman et al., 2014).\nIn contrast, our goal is to learn useful representations in conjunction with control policies. We adopt a reinforcement learning framework and for-\nar X\niv :1\n50 6.\n08 94\n1v 1\n[ cs\n.C L\n] 3\n0 Ju\nn 20\n15\nmulate game sequences as Markov Decision Processes. An agent playing the game aims to maximize rewards that it obtains from the game engine upon the occurrence of certain events. The agent learns a policy in the form of an action-value function Q(s, a) which denotes the long-term merit of an action a in state s.\nThe action-value function is parametrized using a deep recurrent neural network, trained using the game feedback. The network contains two modules. The first one converts textual descriptions into vector representations that act as proxies for states. This component is implemented using Long Short-Term Memory (LSTM) networks (Hochreiter and Schmidhuber, 1997). The second module of the network scores the actions given the vector representation computed by the first.\nWe evaluate our model using two Multi-User Dungeon (MUD) games (Curtis, 1992). We compare our algorithm against baselines of a random player and a model that uses a bag-of-words representation for a state. We demonstrate that our model LSTM-DQN significantly outperforms the baselines in terms of number of completed quests and reward values. For instance, on a fantasy MUD game, our model learns to complete 96% of the quests, while the bag-of-words model and a random baseline solve only 82% and 5% of the quests, respectively. Moreover, we show that the acquired representation can be reused across games, speeding up learning and leading to faster convergence of Q-values."
    }, {
      "heading" : "2 Related Work",
      "text" : "Learning control policies from text is gaining increasing interest in the NLP community. Example applications include interpreting help documentation for software (Branavan et al., 2010), navigating with directions (Vogel and Jurafsky, 2010; Kollar et al., 2010; Artzi and Zettlemoyer, 2013; Matuszek et al., 2013) and playing computer games (Eisenstein et al., 2009; Branavan et al., 2011a).\nGames provide a rich domain for grounded language analysis. Prior work has assumed perfect knowledge of the underlying state of the game to learn policies. Gorniak and Roy (2005) developed a game character that can be controlled by spoken instructions adaptable to the game situation. The grounding of commands to actions is learned from a transcript manually annotated with actions and\nstate attributes. Eisenstein et al. (2009) learn game rules by analyzing a collection of game-related documents and precompiled traces of the game. In contrast to the above work, our model combines text interpretation and strategy learning in a single framework. As a result, textual analysis is guided by the received control feedback, and the learned strategy directly builds on the text interpretation.\nOur work closely relates to an automatic game player that utilizes text manuals to learn strategies for Civilization (Branavan et al., 2011a). Similar to our approach, text analysis and control strategies are learned jointly using feedback provided by the game simulation. In their setup, states are fully observable, and the model learns a strategy by combining state/action features and features extracted from text. However, in our application, the state representation is not provided, but has to be inferred from a textual description. Therefore, it is not sufficient to extract features from text to supplement a simulation-based player.\nAnother related line of work consists of an automatic Atari games player that infers state representations directly from raw pixels (Mnih et al., 2015). This model learns control strategies using convolutional neural networks, trained with a variant of Q-learning (Watkins and Dayan, 1992). While both approaches use deep reinforcement learning for training, our work has important differences. In order to handle the sequential nature of text, we use Long Short-Term Memory networks to automatically learn useful representations. Additionally, we show that decomposing the network into a representation layer and an action selector is useful for transferring the learnt representations to new game scenarios."
    }, {
      "heading" : "3 Background",
      "text" : "Game Representation We represent a game by the tuple 〈H,A, T,R,Ψ〉, where H is the set of all possible game states, A = {(a, o)} is the set of all commands (action-object pairs), T (h′ | h, a, o) is the stochastic transition function between states and R(h, a, o) is the reward function. The game state H is hidden from the player, who only receives a varying textual description, produced by a stochastic function Ψ : H → S. Specifically, the underlying state h in the game engine keeps track of attributes such as the player’s location, her health points, time of day, etc. The function Ψ (also part of the game framework) then converts\nthis state into a textual description of the location the player is at or a message indicating low health. We do not assume access to either H or Ψ for our agent during both training and testing phases of our experiments. We denote the space of all possible text descriptions s to be S. Rewards are generated using R and are only given to the player upon completion of in-game quests.\nQ-Learning Reinforcement Learning is a commonly used framework for learning control policies in game environments (Silver et al., 2007; Amato and Shani, 2010; Branavan et al., 2011b; Szita, 2012). The game environment can be formulated as a sequence of state transitions (s, a, r, s′) of a Markov Decision Process (MDP). The agent takes an action a in state s by consulting a state-action value function Q(s, a), which is a measure of the action’s expected long-term reward. Q-Learning (Watkins and Dayan, 1992) is a model-free technique which is used to learn an optimal Q(s, a) for the agent. Starting from a random Q-function, the agent continuously updates its Q-values by playing the game and obtaining rewards. The iterative updates are derived from the Bellman equation (Sutton and Barto, 1998):\n(1)Qi+1(s, a) = E[r + γmax a′\nQi(s ′, a′) | s, a]\nwhere γ is a discount factor for future rewards and the expectation is over all game transitions that involved the agent taking action a in state s.\nUsing these evolving Q-values, the agent chooses the action with the highest Q(s, a) to maximize its expected future rewards. In practice, the trade-off between exploration and exploitation can be achieved following an -greedy policy (Sutton and Barto, 1998), where the agent performs a random action with probability .\nDeep Q-Network In large games, it is often impractical to maintain the Q-value for all possible state-action pairs. One solution to this problem is to approximate Q(s, a) using a parametrized function Q(s, a; θ), which can generalize over states and actions by considering higher-level attributes (Sutton and Barto, 1998; Branavan et al., 2011a). However, creating a good parametrization requires knowledge of the state and action spaces. One way to bypass this feature engineering is to use a Deep Q-Network (DQN) (Mnih et al., 2015). The DQN approximates the Q-value function with a deep neural network to predict Q(s, a) for all\npossible actions a simultaneously given the current state s. The non-linear function layers of the DQN also enable it to learn better value functions than linear approximators."
    }, {
      "heading" : "4 Learning Representations and Control Policies",
      "text" : "In this section, we describe our DQN model and describe its use in learning good Q-value approximations for games with stochastic textual descriptions. We divide the DQN model into two parts. The first module is a representation generator that converts the textual description of the current state into a vector. This vector is then input into the second module which is an action scorer. Figure 2 shows the overall architecture of our model. We learn the parameters of both the representation generator and the action scorer jointly, using the in-game reward feedback.\nRepresentation Generator (φR) The representation generator reads raw text s displayed to the agent and converts it to a vector representation vs. A bag-of-words (BOW) representation is not sufficient to capture higher-order structures of sentences and paragraphs. The need for a better semantic representation of the text is evident from the average performance of this representation in playing MUD-games (as we show in Section 6).\nIn order to assimilate better representations, we utilize a Long Short-Term Memory network (LSTM) (Hochreiter and Schmidhuber, 1997) as\na representation generator. LSTMs are recurrent neural networks with the ability to connect and recognize long-range patterns between words in text. They are more robust than BOW to small variations in word usage and are able to capture underlying semantics of sentences to some extent. In recent work, LSTMs have been used successfully in NLP tasks such as machine translation (Sutskever et al., 2014) and sentiment analysis (Tai et al., 2015) to compose vector representations of sentences from word-level embeddings (Mikolov et al., 2013; Pennington et al., 2014). In our setup, the LSTM network takes in word embeddings wk from the words in a description s and produces output vectors xk at each step.\nTo get the final state representation vs, we add a mean pooling layer which computes the elementwise mean over the output vectors xk.2\n(2)vs = 1\nn n∑ k=1 xk\nAction Scorer (φA) The action scorer module produces scores for the set of possible actions given the current state representation. We use a multi-layered neural network for this purpose (see Figure 2). The input to this module is the vector from the representation generator, vs = φR(s) and the outputs are scores for actions a ∈ A. Scores for all actions are predicted simultaneously, which is computationally more efficient than scoring each state-action pair separately. Thus, by combining the representation generator and action scorer, we can obtain the approximation for the Qfunction as Q(s, a) ≈ φA(φR(s))[a].\nAn additional complexity in playing MUDgames is that the actions taken by the player are multi-word natural language commands such as eat apple or go east. Due to computational constraints, in this work we limit ourselves to consider commands to consist of one action (e.g. eat) and one argument object (e.g. apple). This assumption holds for the majority of the commands in our worlds, with the exception of one class of commands that require two arguments (e.g. move red-root right, move blue-root up). We consider all possible actions and objects available in the game and predict both for each state using the same network (Figure 2). We consider the Q-value of the\n2We also experimented with considering just the output vector of the LSTM after processing the last word. Empirically, we find that mean pooling leads to faster learning, so we use it in all our experiments.\nentire command (a, o) to be the average of the Qvalues of the action a and the object o. For the rest of this section, we only show equations forQ(s, a) but similar ones hold for Q(s, o).\nParameter Learning We learn the parameters θR of the representation generator and θA of the action scorer using stochastic gradient descent with RMSprop (Tieleman and Hinton, 2012). The complete training procedure is shown in Algorithm 1. In each iteration i, we update the parameters to reduce the discrepancy between the predicted value of the current state Q(st, at; θi) (where θi = [θR; θA]i) and the expected Q-value given the reward rt and the value of the next state maxa Q(st+1, a; θi−1).\nWe keep track of the agent’s previous experiences in a memory D.3 Instead of performing updates to the Q-value using transitions from the current episode, we sample a random transition (ŝ, â, s′, r) from D. Updating the parameters in this way avoids issues due to strong correlation when using transitions of the same episode (Mnih et al., 2015). Using the sampled transition and (1), we obtain the following loss function to minimize:\n(3)Li(θi) = Eŝ,â[(yi −Q(ŝ, â; θi))2]\nwhere yi = Eŝ,â[r + γmaxa′ Q(s′, a′; θi−1) | ŝ, â] is the target Q-value with parameters θi−1 fixed from the previous iteration.\nThe updates on the parameters θ can be performed using the following gradient of Li(θi):\n∇θiLi(θi) = Eŝ,â[2(yi −Q(ŝ, â; θi))∇θiQ(ŝ, â; θi)]\nFor each epoch of training, the agent plays several episodes of the game, which is restarted after every terminal state.\nMini-batch Sampling In practice, online updates to the parameters θ are performed over a mini batch of state transitions, instead of a single transition. This increases the number of experiences used per step and is also more efficient due to optimized matrix operations.\nThe simplest method to create these minibatches from the experience memory D is to sample uniformly at random. However, certain experiences are more valuable than others for the agent to learn from. For instance, rare transitions\n3The memory is limited and rewritten in a first-in-first-out (FIFO) fashion.\nAlgorithm 1 Training Procedure for DQN with prioritized sampling 1: Initialize experience memory D 2: Initialize parameters of representation generator (φR) and action scorer (φA) randomly 3: for episode = 1,M do 4: Initialize game and get start state description s1 5: for t = 1, T do 6: Convert st (text) to representation vst using φR 7: if random() < then 8: Select a random action at 9: else 10: Compute Q(st, a) for all actions using φA(vst) 11: Select at = argmax Q(st, a) 12: Execute action a and observe reward rt and new state st+1 13: Set priority pt = 1 if rt > 0, else pt = 0 14: Store transition (st, at, rt, st+1, pt) in D 15: Sample random mini batch of transitions (sj , aj , rj , sj+1, pj) from D,\nwith fraction ρ having pj = 1 16: Set yj = { rj if sj+1 is terminal rj + γ maxa′ Q(sj+1, a′; θ) if sj+1 is non-terminal 17: Perform gradient descent step on the loss L(θ) = (yj −Q(sj , aj ; θ))2\nthat provide positive rewards can be used more often to learn optimal Q-values faster. In our experiments, we consider such positive-reward transitions to have higher priority and keep track of them in D. We use prioritized sampling (inspired by Moore and Atkeson (1993)) to sample a fraction ρ of transitions from the higher priority pool and a fraction 1− ρ from the rest."
    }, {
      "heading" : "5 Experimental Setup",
      "text" : "Game Environment For our game environment, we modify Evennia,4 an open-source library for building online textual MUD games. Evennia is a Python-based framework that allows one to easily create new games by writing a batch file describing the environment with details of rooms, objects and actions. The game engine keeps track of the game state internally, presenting textual descriptions to the player and receiving text commands from the player. We conduct experiments on two worlds - a smaller Home world we created ourselves, and a larger, more complex Fantasy world created by Evennia’s developers. The motivation behind Home world is to abstract away high-level planning and focus on the language understanding requirements of the game. Table 1 provides statistics of the game worlds.\n4http://www.evennia.com/\nIn both worlds, the agent gets a randomly sampled description of a room each time. The agent receives a positive reward on completing a quest, and negative rewards for getting into bad situations like falling off a bridge, or losing a battle. We also add small deterministic negative rewards for each non-terminating step. This incentivizes the agent to learn policies that solve quests in fewer steps. Supplementary material has reward details.\nHome World We created Home world to mimic the environment of a typical house.5 The world consists of four rooms - a living room, a bedroom, a kitchen and a garden with connecting pathways. Every room is reachable from every other room. Each room contains a representative object that the agent can interact with. For instance, the kitchen has an apple that the player can eat. Transitions between the rooms are deterministic. At the start\n5An illustration is provided in the supplementary material.\nof each game episode, the player is placed in a random room and provided with a randomly selected quest. The text provided to the player contains both the description of her current state and that of the quest. Thus, the player can begin in one of 16 different states (4 rooms × 4 quests), which adds to the world’s complexity.\nAn example of a quest given to the player in text is You are not sleepy but are hungry. To complete this quest and obtain a reward, the player has to navigate through the house to reach the kitchen and eat the apple (i.e type in the command eat apple). More importantly, the player should interpret that the quest does not require him to take a nap in the bedroom. We created such misguiding quests to make it hard for agents to succeed without having an adequate level of language understanding.\nFantasy World The Fantasy world is considerably more complex and involves quests such as navigating through a broken bridge or finding the secret tomb of an ancient hero. This game also has stochastic transitions in addition to varying state descriptions provided to the player. For instance, there is a possibility of the player falling from the bridge if he lingers too long on it.\nDue to the large command space in this game,6 we make use of cues provided by the game itself to narrow down the set of possible objects to consider in each state. For instance, in the MUD example in Figure 1, the game provides a list of possible exits. If the game does not provide such clues for the current state, we consider all objects in the game.\nEvaluation We use two metrics for measuring an agent’s performance: (1) the cumulative reward obtained per episode averaged over the episodes and (2) the fraction of quests completed by the agent. The evaluation procedure is as follows. In each epoch, we first train the agent on M episodes of T steps each. At the end of this training, we have a testing phase of running M episodes of the game for T steps. We useM = 50, T = 20 for the Home world and M = 20, T = 250 for the Fantasy world. For all evaluation episodes, we run the agent following an -greedy policy with = 0.05, which makes the agent choose the best action according to its Q-values 95% of the time. We report the agent’s performance at each epoch.\n6We consider 222 possible command combinations of 6 actions and 37 object arguments.\nBaselines We compare our LSTM-DQN model to two baselines. The first is a Random agent that chooses both actions and objects uniformly at random from all available choices.7 The second is BOW-DQN, which uses a bag-of-words representation of the text as input to the DQN action scorer. This baseline serves to illustrate the importance of having a good representation layer for the task.\nSettings For our DQN models, we used D = 100000, γ = 0.5. We use a learning rate of 0.0005 for RMSprop. We anneal the for -greedy from 1 to 0.2 over 100000 transitions. We perform a minibatch gradient update every 4 steps of the gameplay. We roll out the LSTM (over words) for a maximum of 30 steps on the Home world and for 100 steps on the Fantasy world. For the prioritized sampling, we used ρ = 0.25 for both worlds. We used a mini-batch size of 64 and embedding size d = 20 in all experiments."
    }, {
      "heading" : "6 Results",
      "text" : "Home World Figure 3 illustrates the performance of LSTM-DQN compared to the baselines. We can observe that the Random baseline performs quite poorly, completing only around 10% of quests on average8 obtaining a low reward of around −1.58. The BOW-DQN model performs significantly better and is able to complete around 46% of the quests, with an average reward of 0.20. The improvement in reward is due to both greater quest success rate and a lower rate of issuing invalid commands (e.g. eat apple would be invalid in the bedroom since there is no apple). We notice that both the reward and quest completion graphs of this model are volatile. This is because the model fails to pick out differences between quests like You are not hungry but are sleepy and You are not sleepy but are hungry. In contrast, the LSTMDQN model does not suffer from this issue and is able to complete 100% of the quests after around 50 epochs of training, achieving close to the optimal reward possible.9\nFantasy World We evaluate all the models on the Fantasy world in the same manner as before and report reward, quest completion rates and Qvalues. The quest we evaluate on involves crossing\n7In the case of the Fantasy world, the object choices are narrowed down using game clues as described earlier.\n8Averaged over the last 10 epochs. 9Note that since each step incurs a penalty of −0.01, the\nbest reward (on average) a player can get is around 0.98.\nthe broken bridge (which takes a minimum of five steps), with the possibility of falling off at random (a 5% chance) when the player is on the bridge. The game has an additional quest of reaching a secret tomb. However, this quest is complex since it requires the player to memorize game events and perform high-level planning that are beyond the scope of this current work. Therefore, we focus only on the first quest.\nFrom Figure 3 (bottom), we can see that the Random baseline does poorly in terms of both average per-episode reward10 and quest completion rates. BOW-DQN converges to a much higher average reward of −12.68 and achieves around 82% quest completion. Again, the BOW-DQN is often confused by varying (10 different) descriptions of the portions of the bridge, which reflects in its erratic performance on the quest. The LSTM-DQN model again outperforms both baselines, achieving an average reward of −11.33 and completing 96% of quests. Though this world does not contain descriptions adversarial to BOW-LSTM, the LSTM-DQN obtains higher average reward by completing the quest in fewer steps by being more\n10Note that the rewards graph is in log scale.\nresilient to variations in the state descriptions.\nTransfer Learning We would like the representations learnt by φR to be generic enough and transferable to new game worlds. To test this, we created a second Home world with the same rooms, but a completely different map, changing the locations of the rooms and the pathways between them. The main differentiating factor of this world from the original home world lies in the high-level planning required to complete quests.\nWe initialized the LSTM part of an LSTMDQN agent with parameters θR learnt from the original home world and trained it on the new world.11 Figure 3 (top right) demonstrates that the agent with transferred parameters is able to learn quicker than an agent starting from scratch initialized with random parameters (No Transfer), reaching the optimal policy almost 20 epochs earlier. This indicates that these simulated worlds can be used to learn good representations for language that transfer across worlds.\nPrioritized sampling We also investigate the effects of different minibatch sampling procedures\n11The parameters for the Action Scorer (θA) are initialized randomly.\non the parameter learning. From Figure 3 (bottom right), we observe that using prioritized sampling significantly speeds up learning, with the agent achieving the optimal policy around 50 epochs faster than using uniform sampling. This shows promise for further research into different schemes of assigning priority to transitions.\nRepresentation Analysis We analyzed the representations learnt by the LSTM-DQN model on the Home world. Figure 4 shows a visualization of learnt word embeddings, reduced to two dimensions using t-SNE (Van der Maaten and Hinton, 2008). All the vectors were initialized randomly before training. We can see that semantically similar words appear close together to form coherent subspaces. In fact, we observe four different subspaces, each for one type of room along with its corresponding object(s) and quest words. For instance, food items like pizza and rooms like kitchen are very close to the word hungry which appears in a quest description. This shows that the agent learns to form meaningful associations between the semantics of the quest and the environment. Table 2 shows some examples of descriptions from Fantasy world and their nearest neighbors using cosine similarity between their corresponding vector representations produced by LSTM-DQN. The model is able to correlate descriptions of the same (or similar) underlying states and project them onto nearby points in the representation subspace."
    }, {
      "heading" : "7 Conclusions",
      "text" : "We address the task of learning control policies for text-based games. In these games, all interactions in the virtual world are through text and the underlying state is not observed. The resulting language barrier makes such environments chal-\nlenging for automatic game players. We employ a deep reinforcement learning framework to jointly learn state representations and action policies using game rewards as feedback. This framework enables us to map text descriptions into vector representations that capture the semantics of the game states. We evaluate our approach on two game worlds, comparing against a baseline with a bagof-words state representation. Our algorithm outperforms the baseline on quest completion by 54% on a newly created world and by 14% on a preexisting fantasy game. Future directions include tackling high-level planning and strategy learning to improve the performance of intelligent agents."
    } ],
    "references" : [ {
      "title" : "High-level reinforcement learning in strategy games",
      "author" : [ "Amato", "Shani2010] Christopher Amato", "Guy Shani" ],
      "venue" : "In Proceedings of the 9th International Conference on Autonomous Agents and Multi-",
      "citeRegEx" : "Amato et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Amato et al\\.",
      "year" : 2010
    }, {
      "title" : "Weakly supervised learning of semantic parsers for mapping instructions to actions. Transactions of the Association for Computational Linguistics, 1(1):49–62",
      "author" : [ "Artzi", "Zettlemoyer2013] Yoav Artzi", "Luke Zettlemoyer" ],
      "venue" : null,
      "citeRegEx" : "Artzi et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Artzi et al\\.",
      "year" : 2013
    }, {
      "title" : "Reading between the lines: Learning to map high-level instructions to commands",
      "author" : [ "Luke S Zettlemoyer", "Regina Barzilay" ],
      "venue" : "In Proceedings of the 48th Annual Meeting of the Association",
      "citeRegEx" : "Branavan et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Branavan et al\\.",
      "year" : 2010
    }, {
      "title" : "Learning to win by reading manuals in a monte-carlo framework",
      "author" : [ "David Silver", "Regina Barzilay" ],
      "venue" : "In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Lan-",
      "citeRegEx" : "Branavan et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Branavan et al\\.",
      "year" : 2011
    }, {
      "title" : "Non-linear monte-carlo search in civilization",
      "author" : [ "David Silver", "Regina Barzilay" ],
      "venue" : "ii. AAAI Press/International Joint Conferences on Artificial Intelligence",
      "citeRegEx" : "Branavan et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Branavan et al\\.",
      "year" : 2011
    }, {
      "title" : "Mudding: Social phenomena in text-based virtual realities",
      "author" : [ "Pavel Curtis" ],
      "venue" : "High noon on the electronic frontier: Conceptual issues in cyberspace,",
      "citeRegEx" : "Curtis.,? \\Q1992\\E",
      "shortCiteRegEx" : "Curtis.",
      "year" : 1992
    }, {
      "title" : "Reading to learn: Constructing features from semantic abstracts",
      "author" : [ "James Clarke", "Dan Goldwasser", "Dan Roth" ],
      "venue" : "In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Process-",
      "citeRegEx" : "Eisenstein et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Eisenstein et al\\.",
      "year" : 2009
    }, {
      "title" : "Speaking with your sidekick: Understanding situated speech in computer role playing games",
      "author" : [ "Gorniak", "Roy2005] Peter Gorniak", "Deb Roy" ],
      "venue" : "Proceedings of the First Artificial Intelligence and Inter-",
      "citeRegEx" : "Gorniak et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Gorniak et al\\.",
      "year" : 2005
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Hochreiter", "Schmidhuber1997] Sepp Hochreiter", "Jürgen Schmidhuber" ],
      "venue" : "Neural computation,",
      "citeRegEx" : "Hochreiter et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Hochreiter et al\\.",
      "year" : 1997
    }, {
      "title" : "Toward understanding natural language directions",
      "author" : [ "Kollar et al.2010] Thomas Kollar", "Stefanie Tellex", "Deb Roy", "Nicholas Roy" ],
      "venue" : "In HumanRobot Interaction (HRI),",
      "citeRegEx" : "Kollar et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kollar et al\\.",
      "year" : 2010
    }, {
      "title" : "Learning to automatically solve algebra word problems",
      "author" : [ "Kushman et al.2014] Nate Kushman", "Yoav Artzi", "Luke Zettlemoyer", "Regina Barzilay" ],
      "venue" : "ACL",
      "citeRegEx" : "Kushman et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kushman et al\\.",
      "year" : 2014
    }, {
      "title" : "Learning to parse natural language commands to a robot control system",
      "author" : [ "Evan Herbst", "Luke Zettlemoyer", "Dieter Fox" ],
      "venue" : "In Experimental Robotics,",
      "citeRegEx" : "Matuszek et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Matuszek et al\\.",
      "year" : 2013
    }, {
      "title" : "Efficient estimation of word representations in vector space. arXiv preprint arXiv:1301.3781",
      "author" : [ "Kai Chen", "Greg Corrado", "Jeffrey Dean" ],
      "venue" : null,
      "citeRegEx" : "Mikolov et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Mikolov et al\\.",
      "year" : 2013
    }, {
      "title" : "Human-level control through deep reinforcement learning",
      "author" : [ "Antonoglou", "Helen King", "Dharshan Kumaran", "Daan Wierstra", "Shane Legg", "Demis Hassabis." ],
      "venue" : "Nature, 518(7540):529–533, 02.",
      "citeRegEx" : "Antonoglou et al\\.,? 2015",
      "shortCiteRegEx" : "Antonoglou et al\\.",
      "year" : 2015
    }, {
      "title" : "Prioritized sweeping: Reinforcement learning with less data and less time",
      "author" : [ "Moore", "Atkeson1993] Andrew W Moore", "Christopher G Atkeson" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Moore et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Moore et al\\.",
      "year" : 1993
    }, {
      "title" : "Glove: Global vectors for word representation",
      "author" : [ "Richard Socher", "Christopher D Manning" ],
      "venue" : "Proceedings of the Empiricial Methods in Natural Language Processing",
      "citeRegEx" : "Pennington et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Pennington et al\\.",
      "year" : 2014
    }, {
      "title" : "Reinforcement learning of local shape in the game of go",
      "author" : [ "Silver et al.2007] David Silver", "Richard S Sutton", "Martin Müller" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "Silver et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Silver et al\\.",
      "year" : 2007
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "Oriol Vinyals", "Quoc VV Le" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Sutskever et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Sutskever et al\\.",
      "year" : 2014
    }, {
      "title" : "Introduction to reinforcement learning",
      "author" : [ "Sutton", "Barto1998] Richard S Sutton", "Andrew G Barto" ],
      "venue" : null,
      "citeRegEx" : "Sutton et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Sutton et al\\.",
      "year" : 1998
    }, {
      "title" : "Reinforcement learning in games",
      "author" : [ "István Szita" ],
      "venue" : "In Reinforcement Learning,",
      "citeRegEx" : "Szita.,? \\Q2012\\E",
      "shortCiteRegEx" : "Szita.",
      "year" : 2012
    }, {
      "title" : "Improved semantic representations from tree-structured long short-term memory networks. arXiv preprint arXiv:1503.00075",
      "author" : [ "Tai et al.2015] Kai Sheng Tai", "Richard Socher", "Christopher D Manning" ],
      "venue" : null,
      "citeRegEx" : "Tai et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Tai et al\\.",
      "year" : 2015
    }, {
      "title" : "Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude",
      "author" : [ "Tieleman", "Hinton2012] Tijmen Tieleman", "Geoffrey Hinton" ],
      "venue" : "COURSERA: Neural Networks for Machine Learning,",
      "citeRegEx" : "Tieleman et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Tieleman et al\\.",
      "year" : 2012
    }, {
      "title" : "Visualizing data using t-sne",
      "author" : [ "Van der Maaten", "Geoffrey Hinton" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Maaten et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Maaten et al\\.",
      "year" : 2008
    }, {
      "title" : "Learning to follow navigational directions",
      "author" : [ "Vogel", "Jurafsky2010] Adam Vogel", "Dan Jurafsky" ],
      "venue" : "In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics,",
      "citeRegEx" : "Vogel et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Vogel et al\\.",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 11,
      "context" : "An alternative approach is to convert text descriptions to pre-specified representations using annotated training data, commonly used in language grounding tasks (Matuszek et al., 2013; Kushman et al., 2014).",
      "startOffset" : 162,
      "endOffset" : 207
    }, {
      "referenceID" : 10,
      "context" : "An alternative approach is to convert text descriptions to pre-specified representations using annotated training data, commonly used in language grounding tasks (Matuszek et al., 2013; Kushman et al., 2014).",
      "startOffset" : 162,
      "endOffset" : 207
    }, {
      "referenceID" : 5,
      "context" : "We evaluate our model using two Multi-User Dungeon (MUD) games (Curtis, 1992).",
      "startOffset" : 63,
      "endOffset" : 77
    }, {
      "referenceID" : 2,
      "context" : "Example applications include interpreting help documentation for software (Branavan et al., 2010), navigating with directions (Vogel and Jurafsky, 2010; Kollar et al.",
      "startOffset" : 74,
      "endOffset" : 97
    }, {
      "referenceID" : 9,
      "context" : ", 2010), navigating with directions (Vogel and Jurafsky, 2010; Kollar et al., 2010; Artzi and Zettlemoyer, 2013; Matuszek et al., 2013) and playing computer games (Eisenstein et al.",
      "startOffset" : 36,
      "endOffset" : 135
    }, {
      "referenceID" : 11,
      "context" : ", 2010), navigating with directions (Vogel and Jurafsky, 2010; Kollar et al., 2010; Artzi and Zettlemoyer, 2013; Matuszek et al., 2013) and playing computer games (Eisenstein et al.",
      "startOffset" : 36,
      "endOffset" : 135
    }, {
      "referenceID" : 6,
      "context" : ", 2013) and playing computer games (Eisenstein et al., 2009; Branavan et al., 2011a).",
      "startOffset" : 35,
      "endOffset" : 84
    }, {
      "referenceID" : 6,
      "context" : "Eisenstein et al. (2009) learn game rules by analyzing a collection of game-related documents and precompiled traces of the game.",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 16,
      "context" : "Q-Learning Reinforcement Learning is a commonly used framework for learning control policies in game environments (Silver et al., 2007; Amato and Shani, 2010; Branavan et al., 2011b; Szita, 2012).",
      "startOffset" : 114,
      "endOffset" : 195
    }, {
      "referenceID" : 19,
      "context" : "Q-Learning Reinforcement Learning is a commonly used framework for learning control policies in game environments (Silver et al., 2007; Amato and Shani, 2010; Branavan et al., 2011b; Szita, 2012).",
      "startOffset" : 114,
      "endOffset" : 195
    }, {
      "referenceID" : 17,
      "context" : "In recent work, LSTMs have been used successfully in NLP tasks such as machine translation (Sutskever et al., 2014) and sentiment analysis (Tai et al.",
      "startOffset" : 91,
      "endOffset" : 115
    }, {
      "referenceID" : 20,
      "context" : ", 2014) and sentiment analysis (Tai et al., 2015) to compose vector representations of sentences from word-level embeddings (Mikolov et al.",
      "startOffset" : 31,
      "endOffset" : 49
    }, {
      "referenceID" : 12,
      "context" : ", 2015) to compose vector representations of sentences from word-level embeddings (Mikolov et al., 2013; Pennington et al., 2014).",
      "startOffset" : 82,
      "endOffset" : 129
    }, {
      "referenceID" : 15,
      "context" : ", 2015) to compose vector representations of sentences from word-level embeddings (Mikolov et al., 2013; Pennington et al., 2014).",
      "startOffset" : 82,
      "endOffset" : 129
    } ],
    "year" : 2015,
    "abstractText" : "In this paper, we consider the task of learning control policies for text-based games. In these games, all interactions in the virtual world are through text and the underlying state is not observed. The resulting language barrier makes such environments challenging for automatic game players. We employ a deep reinforcement learning framework to jointly learn state representations and action policies using game rewards as feedback. This framework enables us to map text descriptions into vector representations that capture the semantics of the game states. We evaluate our approach on two game worlds, comparing against a baseline with a bag-of-words state representation. Our algorithm outperforms the baseline on quest completion by 54% on a newly created world and by 14% on a pre-existing fantasy game.",
    "creator" : "LaTeX with hyperref package"
  }
}