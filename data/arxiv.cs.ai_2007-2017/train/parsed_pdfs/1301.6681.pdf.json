{
  "name" : "1301.6681.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Reasoning With Conditional Ceteris Paribus Preference Statements",
    "authors" : [ "Craig Boutilier", "Ronen I. Brafman" ],
    "emails" : [ "cebly@cs.ubc.ca", "brajman@cs.bgu.ac.il", "}@cs.ubc.ca" ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 Introduction\nPreference elicitation is an important aspect of automated decision making. In many application domains, the space of possible actions or decisions available to someone is fixed, with well-understood dynamics; the only variable compo nent in the decision making process are the preferences of the user on whose behalf a decision is being made. This is often the case in domains such as product configuration or medical diagnosis (to name but two). Extracting preference information from users is generally arduous, and human decision analysts have developed so phisticated techniques to help elicit this information from decision makers [ 1 1]. A key goal in the study of computer based decision support is the construction of tools that allow the preference elicitation process to be automated, either partially or fully. In particular, methods for extracting, rep resenting and reasoning about the preferences of naive users is especially important in AI applications, where users can not be expected to have the patience (or sometimes the abil ity) to provide detailed preference relations or utility func tions. In applications ranging from collaborative filtering [ 1 4] and recommender systems [ 1 5] to product configura tion [6] to medical decision making [4], typical users may\nnot be able to provide much more than qualitative rankings of fairly circumscribed outcomes.\nIdeally, a preference representation for such applications would capture statements that are natural for users to as sess are reasonably compact, and support effective infer enc� (particularly when deciding whether one outcome is preferred to, or dominates, another). In this paper, we ex plore a network representation of conditional preference statements under a ceteris paribus (all else equal) assump tion. The semantics of our local preference statements cap ture the classical notion of (conditional) preferential inde pendence [ 1 3], while our CP-network (conditional prefer ence network) representation allows these statements to be organized in a precise way. We also describe several infer ence algorithms for dominance queries, and show that these are very efficient for certain classes of networks, and seem to work well on general network structures. Our conditional ceteris paribus semantics requires that the user specify, for any specific feature F of interest, which other features can impact her preferences for values of F. For each instantiation of the relevant features (parents of F), the user must specify her preference ordering over val ues ofF conditional on the parents assuming the instanti ated values; for instance, /1 may be preferred to h when 91 and h2 hold. Such a preference is given a ceteris paribus interpretation: /! is preferred to h given 91 and h2 all else being equal. In other words, for any fixed instantiation of the remaining features, an outcome where /! holds is pre ferred to one where h holds (assuming 91 and h2). Such statements are arguably quite natural and appear in several places (e.g., in e-comrnerce applications). For instance, the product selection service offered by Active Buyer's Guide asks for (unconditional) ceteris paribus statements in as sessing a user's preference for various products.1 Condi tional expressions offer even greater flexibility. Generally, tools for representing and reasoning about ceteris paribus preferences are important because they should aid in the elicitation process for naive users.\n1 See www . acti vebuyersguide. com. The tools there also ask for some semi-quantitative information about prefer ences.\n72 Boutilier, Brafman, Hoos, and Poole\nPreference elicitation is a complex task and is a key focus in work on decision analysis [ 13, 1 1 , 9], especially elicita tion involving expert users. Automating the process of pref erence extraction can be very difficult. Straightforward ap proaches involving the direct comparison of all pairs of out comes are generally infeasible for a number of reasons, in cluding the exponential number of outcomes (in the num ber of relevant features for which preferences are indicated) and the complexity of the questions that are asked (the com parison of complete outcomes). There has been consider able work on exploiting the structure of preferences and utility functions in a way that allows them to be appropri ately decomposed [ 1 3, 1]. For instance, if certain attributes are preferentially independent of others [ 13], one can assign degrees of preference to these attribute values without wor rying about other attribute values. Furthermore, if one as sumes more stringent conditions, often one can construct an additive value function in which each attribute contributes to overall preference to a certain \"degree\" (the weight of that attribute) [13]. For instance, it is common in engineer ing design problems to make such assumptions and simply require users to assess the weights [6]. This allows the di rect tradeoffs between values of different attributes to be as sessed concisely. Case-based approaches have also recently been considered [I 0].\nModels such as these make the preference elicitation pro cess easier by imposing specific requirements on the form of the utility or preference function. We consider our CP network representation to offer an appropriate tradeoff be tween allowing flexible preference expression and impos ing a particular preference structure. Specifically, unlike much of the work cited above, conditional preference state ments will be permitted.\nThe remainder of the paper is organized as follows. In Sec tion 2, we describe the necessary background on preference functions. We define our graphical preference model, CP networks, in Section 3 and describe its semantics in terms of ceteris paribus (conditional preferential independence) statements. Though the CP-semantics of the local prefer ence statements could be considered somewhat weak, some surprisingly strong conclusions regarding dominance can often be drawn based on the network structure. In Sec tion 4, we consider the task of answering dominance queries as a search for a sequence of more preferred (or less pre ferred) alternatives leading the to potentially dominating (or dominated) outcome. We formally define the search space and describe several completeness-preserving prun ing techniques. In Section 5, we describe several search strategies, heuristics designed to work effectively for cer tain types of problems. We show that these heuristics are backtrack-free for certain types of networks and where backtrack points arise for other types. We also describe how to view this problem as a planning problem. To conclude, in Section 6 we briefly describe the use of CP-nets in two abstract applications. The first is the sorting of a product database using the preferences over product features, allow-\ning the most preferred products to be identified for a con sumer. The second is the use ofCP-nets in constraint-based optimization. Finally, we offer some thoughts on future re search.\n2 Preference Relations\nWe focus our attention on single-stage decision problems with complete information, ignoring in this paper any is sues that arise in multi-stage, sequential decision analysis and any considerations of risk that arise in the context of un certainty. 2 We begin with an outline of the relevant notions from decision theory. We assume that the world can be in one of a number of states S and at each state s there are a number of actions A, that can be performed. Each action, when performed at a state, has a specific outcome (we do not concern ourselves with uncertainty in action effects or knowledge of the state). The set of all outcomes is denoted CJ. A preference ranking is a total preorder � over the set of outcomes: Ot � 02 means that outcome o1 is equally or more preferred to the decision maker than o2• The aim of decision making under certainty is, given knowledge of a specific state, to choose the action that has the most pre ferred outcome. We note that the ordering � will be differ ent for different decision makers. For instance, two differ ent customers might have radically different preferences for different types of computer systems that a sales program is helping them configure.\nOften, for a state s, certain outcomes in (') cannot result from any action a E A, : those outcomes that can obtain are called feasible outcomes (givens). In many instances, the mapping from states and actions to outcomes can be quite complex. In other decision scenarios, actions and outcomes may be equated: a user is allowed to directly select a feasi ble outcome (e.g., select a product with a desirable combi nation of features). Often states may play no role (i.e., there is a single state).\nWhat makes the decision problem difficult is the fact that outcomes of actions and preferences are not usually rep resented so directly. We focus here on preferences. We assume a set of features (or variables or attributes) F = { F1, · · · Fn} over which the decision maker has prefer ences. Each feature F; is associated with a domain of fea ture values :F; = {fj, · · · f�.} it can take. The product space :F = :Ft x · · · x :Fn is the set of outcomes. Thus direct assessment of a preference function is usually infea sible due to the exponential size of :F. We denote a partic ular assignment of values to a set X <;; F as i, and the concatenation of two such partial assignments to X and Y (X n Y = 0) by iiJ. If XU Y = F, iiJ is a (complete) outcome.\nFortunately, a preference function can be specified (or par tially specified) concisely if it exhibits sufficient structure.\n2Such issues include assigning preferences to sequences of outcome states, assessing uncertainty in beliefs and system dy namics, and assessing the user's attitude towards risk.\nWe describe certain types of structure here, referring to [ 1 3] for a detailed description of these (and other) struc tural forms and a discussion of their implications. These no tions are standard in multi-attribute utility theory. A set of features X is preferentially independent of its complement Y = F- X iff, for all x1, x2, Yl, Y2· we have\nIn other words, the structure of the preference relation over assignments to X, when all other features are held fixed, is the same no matter what values these other features take. If the relation above holds, we say x1 is preferred to x2 ceteris paribus. Thus, one can assess the relative prefer ences over assignments to X once, knowing these prefer ences do not change as other attributes vary. We can define conditional preferential independence analogously. Let X, Y and Z partition F (each set is nonempty). X and Y are conditionally preferentially independent given z iff, for all i1, i2, Y1, Y2. we have\nIn other words, the preferential independence of X and Y only holds when Z is assigned z. If this relation holds for all assignments z, we say X and Y are conditionally pref erentially independent given Z.\nThis decomposability of a preference functions often allows one to identify the most preferred outcomes rather readily. Unfortunately, the ceteris paribus component of these defi nitions ensures that the statements one makes are relatively weak. In particular, they do not imply a stance on specific value tradeoffs. For instance, suppose two features A and B are preferentially independent so that the preferences for values of A and B can be assessed separately; e.g., sup pose a1 )>- a2 and b1 )>- b2. Clearly, a1 h is the most pre ferred outcome and a2b2 is the least; but if feasibility con straints make a1 b1 impossible, we must be satisfied with one of a1b2 or a2b1. We cannot tell which is most preferred using these separate assessments. However, under stronger conditions (e.g., mutual preferential independence) one can construct an additive value function in which weights are assigned to different attributes (or attribute groups). This is especially appropriate when attributes take on numerical values. We refer to [ 1 3] for a discussion of this problem.\nGiven such a specification of preferences, a number of dif ferent techniques can be used to search the space of feasible outcomes for a most preferred outcome.\n3 CP-Networks\nIn this section we describe a network representation that al lows the compact (but generally incomplete) representation of a preference relation. We first describe the basic model and its semantics and then describe inference procedures for dominance testing.\nReasoning With Conditional Preferences 73\nOur representation for preferences is graphical in nature, and exploits conditional preferential independence in struc turing a user's preferences. The model is similar to a Bayes net on the surface; however, the nature of the relation be tween nodes within a network is generally quite weak (e.g., compared with the probabilistic relations in Bayes nets). Others have defined graphical representations of preference relations; for instance Bacchus and Grove [1] have shown some strong results pertaining to undirected graphical rep resentations of additive independence. Our representation and semantics is rather distinct, and our main aim in using the graph is to capture statements of conditional preferential independence. We note that reasoning about ceteris paribus statements has been explored in AI, though not in the con text of network representations [7].\nFor each feature F, we ask the user to identify a set of par ent features P(F) that can affect her preference over vari ous F values. That is, given a particular value assignment to P(F), the user should be able to determine a preference order for the values ofF, all other things being equal. For mally, denoting all other features aside from F and P(F) by F, we have that F and F are conditionally preferentially independent given P( F). Given this information, we ask the user to explicitly specify her preferences over F values for all possible P(F) values. We use the above information to create an annotated graph in which each feature F has P (F) as its set of parents. The node F is annotated with a condition preference table (CPT) describing the user's pref erences over F's values given every combination of par ent values.3 We call these structures conditional preference networks (or CP-networks ). We note that nothing in the semantics forces the graph to be acyclic, though we argue below that most natural networks will indeed be acyclic. Moreover, even cyclic CP-networks cannot express all pos sible total preference orderings, as can be shown by a simple counting argument.\nWe illustrate the network semantics and some of its conse quences with a series of examples. In the following exam ples all features are boolean, though our semantics is de fined for features with arbitrary finite domains.\nExample 1 Asking the user to describe her preference over feature B, we are told that this preference depends on the value for A and on that value alone (ceteris paribus). We then make A a parent of B and ask about her preference on B for each value of A. She may say that, when a holds, she prefers b over li, and when a holds she prefers b over b, ceteris paribus. This is written here as:\n3That is, we assume that a preorder is provided over the do main of F, such that for any two values f; and f,, either f; >- f,, !, >- f;, or f; and fi are equally preferred. For ease of presen tation, we ignore indifference in our algorithms (though its treat ment is straightforward). We assume this relation is fully specified (though see Section 6).\n74 Boutilier, Brafman, Hoos, and Poole\nExample 2 Suppose we have two features A and B, where A is a parent of B and A has no parents. Assume the fol lowing conditional preferences:\na :-- a; a : b :-- b; a : b :-- b\nSomewhat surprisingly, this information is sufficient to to tally order the outcomes:\nab :-- ali :-- ali :-- ab.\nNotice that we can judge each outcome in terms of the con ditional preferences it violates. The ab outcome violates none of the preference constraints. Outcome ali violates the conditional preference for B. Outcome ali violates the pref erence for A. Outcome ab violates both. What is surprising is that the ceteris paribus semantics implies that violating the A constraint is worse than violating the B constraint (we have ali :-- ali). That is, the parent preferences have higher priority than the child preferences.\nExample3 Suppose we have three features A, B, and C, and suppose that the preference dependency graph is dis connected. Let's assume that a :-- a, b :-- b, and c :-- c. Given this information we can conclude that abc is the most preferred outcome, then comes abc, abc, and abc. These three cannot be ordered based on the information provided. Less preferred than the last two is abc, and so on. The least preferred outcome is abc.\nExample4 Suppose we have three features A, B, and C, and the conditional preference graph forms a chain with A having no parents, A the parent of B, and B the parent of C. Suppose we have the following dependence information:\na :-- a; a : b :-- b; a : /i :-- b; b : c :-- c; b : c :-- c\nThese preference constraints imply the following ordering:\nabc )-- abc )-- abc )-- abc )-- abc )-- abc )-- abc,\nwhich totally orders all but one of the outcomes. Notice how we get from one outcome to the next in the chain: we flip (or exchange) the value of exactly one feature according to the preference dependency information. The element not in this chain is abc, and we can derive the ordering abc :- abc :-- abc. Thus, the only two outcomes not totally ordered are abc and abc. From Example 2, we saw that violations of preference constraints for parent features are worse than vi olations of constraints over child preferences. In one of the two unordered outcomes we violate the preference of the most important feature (A), while in the other outcome we violate preference over two less important features (B and C). The semantics of CP-networks does not specify which of these tuples is preferred.\nThere are two important things to notice about these exam ples. First, a chain of \"flipping feature values\" can be used\nto show that one outcome is better than another. In Exam ple 4, the conditional preferences for C allow the value of\nC to be ''flipped\" in outcome abc to obtain abc. B's value can then be flipped (given a) to obtain abc, and so on. Sec ond, violations are worse (i.e., have a larger negative im pact on preference) the higher up they are in the network, although we cannot compare two (or more) lower level vi olations to violation of a single ancestor constraint. These observations underly the inference algorithms below.\nAs mentioned, the semantics of CP-nets do not preclude cyclic networks. For instance, a two-variable network where A depends on B and B depends on could be consis tently quantified as follows:\na : b :-- b; a : b :-- b b : a :-- a; b : a :-- a\nUnder these preferences, the user simply prefers A and B to have the same value, with both ab and ali maximally preferred. Acyclic graphs always have a unique most preferred outcome. We note that cyclic preference graphs can be inconsistent (e.g., in the example above, simply re verse the conditional preferences for B under each value of A). Indeed, acyclic graphs are always consistent (i.e., cor respond to at least one well-defined preference ordering). It seems there is rarely a need for cyclic structures unless one wants to express indifference between certain assignments to subsets of variables. In this case, one can often cluster the variables to maintain acyclicity. In what follows, we as sume that our CP-nets are acyclic.\n4 Searching for Flipping Sequences\nWe assume we are given an acyclic CP-network over fea tures Ft, · · · Fn. By convention, we assume the ordering of these features respects the topology of the network (that is, the parents of any F; have indices j < i). We use x;, xi, y;, etc. to denote values of feature F;. The basic inference problem we address is the following: given a CP-network N, and two outcomes x = XtX2 · · · Xn, y = YtY2 · · · Yn. is x :-- y a consequence of preferences of the CP-network? In other words, is the outcome x preferred toy? We treat the inference problem as a search for a flipping sequence from the (purported) less preferred outcome y, through a series of more preferred outcomes, to the (purported) more pre ferred outcome x, where each value flip in the sequence is sanctioned by the network N. Conversely, we can view the problem as a search in the opposite direction, from the more preferred outcome to the less preferred outcome.\n4.1 Improving Search\nGiven any CP-network, and a query x :-- y, we define the improving search tree as follows. The search tree is rooted aty = YtY2 · · · Yn; the children of any nodez = z1z2 · · · Zn in the search tree are those outcomes that can be reached by changing one feature value z; to zi such that zi :-- z; given the values Zj, j < i. Note that possible improving values zi of F; can be readily determined by inspecting the CPT\nFigure 1 : An Example Conditional Preference Graph\nfor F;. Since the only preference statements explicitly rep resented in the network are those captured by the CPTs, it is clear that x >- y is implied by N iff there exists a path from y to x in the improving search tree. Thus, any com plete search procedure--any procedure guaranteed to ex amine every branch of the search tree-will be a sound and complete query answering procedure. All procedures dis cussed in this paper are, in this sense, sound and complete.\nExample 5 Consider the preference graph of Figure I . Suppose that the conditional preferences are:\na>- a; b >- b; (ai\\b) v (a A b) : c >- c; (ai\\ b) v (a A b) : c>- c\nc : d >- d; c : d.>- d; d : e >- e; d. : e >- e;\nd : f >- 7; d : 7 >- f; f : g >- g; 7 : g >- g g : h >- h; g : h >- h\nSuppose we want to compare outcome abcdef9h (which violates the G preference) and outcome abcde7gh (which violates the A preference). In order to show that the first is preferred, we generate the sequence: abcdefgh -< abcdefgh -< abcdefgh -< abcae7gh -< abcdefgh -< abcdef9h. Intuitively, we constructed a sequence of in creasingly preferred outcomes, using only valid conditional independence relations represented in the CP-network, by flipping values of features. We are allowed to change the value of a \"higher priority\" feature (higher in the network) to its preferred value, even if this introduces a new prefer ence violation for some lower priority feature (a descendent in the network). For instance, the first flip of A's value in this sequence to its preferred state repairs the violation of A's preference constraint, while introducing a preference violation with respect to C (the value cis dispreferred when ab holds). This process is repeated (e.g., making C take its conditionally most preferred value at the expense of violat ing the preference for D) until the single preference viola tion ofF (in the \"target\" outcome) is shown to be preferred to the single preference violation of A (in the initial out come). This demonstrates how the violation of conditional preference for a feature is dispreferred to the violation of one of its descendent's preferences.\nReasoning With Conditional Preferences 75\nSuppose we compare abcde Jgh (which violates the G pref erence and the H preference) and abcde fgh (which violates the A preference). These turn out not to be comparable (nei ther is preferred to the other). The sequence of flips above cannot be extended to change the values of both G and H so that their preference constraints are violated. The sole vio lation of the A constraint cannot be dominated by the vio lation of two (or more) descendents in a chain.\nIf we want to compare abcdef9h (which violates the E preference and the G preference) and abcde fgh (which vio lates the A preference), we can use the following sequence: abcdefgh -< abcdefgh -< abcde7gh -< abcae7gh -< abcdef9h. The violation of E and G is preferred to the vi olation of A: intuitively, the A violation can be absorbed by violation in each path starting at D.\nNow consider the comparison of abcdef9h (which violates the G and H preferences) and abcde f gh (which violates the A and B preferences). We can use the following sequence of flips to show preference: abcdefgh -< abcdefgh -< abcdefgh -< abcdefgh -< abcde7gh -< abcde7gh -< abcde7gh -< abcde7gh -< abcdefgh -< abcdef9h. This shows how two violations in· ancestor features covers two violations in their descendents.\nThese examples illustrate how certain preference violations have priority over others in determining the relative order ing of two outcomes. Intuitively, dominance is shown by constructing a sequence of legal flips from the initial out come to the target.\n4.2 Worsening Search\nA query x >- y can also be answered using search through the worsening search tree, defined as follows. The search tree is rooted at x = z1 z2 · · · Zn; the children of any node z = z1 z2 · · · Zn in the search tree are those outcomes that can be reached by changing one feature value z; to zi such that zi -< z; given the values Zj, j < i. Note that possi ble worsening values zi ofF; can be readily determined by inspecting the CPT for F;. Again, it is clear that x >- y is implied by N iff there exists a path from x to y in the wors ening search tree.\nWhile clearly any path from x toy that exists in the wors ening search tree corresponds to a path from y to x in the improving search tree, and vice versa, the search space may be such that searching in the improving search tree is most effective for some queries, while searching in the worsen ing search tree is most appropriate for others.\nExample 6 Consider the CP-network described in Exam ple 4. Suppose we wish to test whether abc >- abc. Taking abc as the root of the worsening tree, the only path one can generate is abc >- abc >- abc >- abc. In other words, the worsening tree does not branch and leads directly to a pos itive answer to the query. In contrast, the improving search tree rooted at abc consists of six branches (with a maximum length of seven nodes), and only one path leads to a solution (see Figure 2).\nExample 7 With the same network, consider the query abc >- abc. Taking abc as the root of the improving search tree, the only path in the tree is abc -<( abc -<( abc -<( abc. In contrast, the worsening search tree rooted at abc consists of six branches (with a maximum length of seven nodes), and only one path leads to a solution.\nFor this reason, we believe that a parallel search in both the improving and worsening search trees is generally most ap propriate. Though we have illustrated positive queries only, the same considerations apply to negative queries, where, in fact, exploiting small search trees is especially important in order to quickly fail.\n4.3 Suffix Fixing and Extension\nThough we haven't yet detailed specific search procedures, in the remainder of this section we suppose that we have some complete (and necessarily sound) search procedure. Regardless of whether one uses improving or worsening search, there are two simple rules that allow one to make deterministic moves in search space (i.e., choose flips that need not be backtracked over, or reconsidered) without im pacting completeness of the search procedure. The first rule is suffix fixing. We define a suffix of an al ternative z = ZJ z2 ·. · · Zn to be some subset of the values z;z;+l · · · Zn, i 2: 1. A suffix can be defined for any le gal ordering of the features. Suppose an improving search for the query x >- y takes us from the root node y to node z = z1 z2 • · · Zn. Suppose further that some suffix of z matches the suffix of target x; that is, Zj = Xj for all j 2: i.4 The suffix fixing rule requires that those features making up the suffix never be flipped. The following proposition en sures that we never need reconsider a decision not to flip features in a matching suffix.\nProposition 1 Let there be a path in the improving search\n4The matching suffix can be \"created\" by a reordering of the features that is consistent with the partial ordering of the (acyclic) CP-network.\ntree from root y to node z, such that some suffix of z matches that of the target x. If there is a path from y to x that passes through z, then there is a path from z to x such that every node along that path has the same values as z for the fea tures that make up the suffix.\nThis effectively restricts the search tree under z to have only paths that retain the suffix values. Though one may have to backtrack over choices that lead to z, one will not have to consider the full search tree under z. The suffix fixing rule also applies to worsening search."
    }, {
      "heading" : "A second completeness-preserving rule is the suffix exten",
      "text" : "sion rule. Suppose that a path to intermediate node z has been found that matches some suffix of the target x . . Fur thermore, suppose that the values of z allow this suffix to be extended; that is, suffix z;z;+l · · · Zn matches the target and feature pi-! can be improved from Zi-! to zl_1 = X;-J.5 Then the flip to zi _1 can be chosen and not reconsidered. Proposition 2 Let there exist a path in the improving search tree from root y to node z, such that some suffix of z matches that of the target x, and that the suffix can be ex tended by a legal move from z to z'. If there exists a path from y to x that passes through z, then there exists a path from z' to x such that every node along that path has the same values as·z' for the features that make up the extended suffix.\nExample 8 Consider the CP-network of Figure I with the conditional preferences as in Example 5. Suppose we were to consider the query\nabcae79h >- abcdeJgh\nusing an improving search. Suffix fixing means that we never have to consider flipping g, h ore (there is a reorder ing of the features that has these three as the rightmost fea tures). The suffix extension rule means that we can flip f to 7 (asd: 7 >- f), without backtracking over this choice. We cannot immediately flip d to d in the context of c, so suffix extension is not applicable (once f is flipped).\n4.4 Forward Pruning\nIn this section we describe a general pruning mechanism that can be carried out given a query x >- y. It\n• often quickly shows that no flipping sequence is pos sible; • prunes the domains of the features to reduce the flip ping search space; • doesn't compromise soundness or completeness; and • is relatively cheap (time is O(nrd2) where n is the\nnumber of features, r is the maximum number of con ditional preference rules for each feature, and d is the size of the biggest domain).\nThe general idea is to sweep forward through the network, pruning any values of a feature that cannot appear in any\ns Again, the suffix can be found using feature reordering.\n(improving or worsening) flipping sequence to validate a query. Intuitively, we consider the set of flips possible, ig noring interdependence of the parents and the number· of times the parents can change their values. We consider each feature in an order consistent with the net work topology (so that parents of a node are considered be fore the node). For each feature F, we build a graph with nodes corresponding to the possible values for F, and for each conditional preference relation\nC : Vt >- V2 >- · · · >- Vd\nsuch that c is consistent with the pruned values of the par ents ofF, we include an arc between the successive values (i.e., between the values v; and v;+t). We can prune any value that isn't on a directed path from x's value for feature F toy's value for feature F. This can be implemented by running Dijkstra's algorithm [5] twice: once to find the nodes reachable from x's value for feature F and again to find the nodes that can reach y's value for feature F. These sets of nodes can be intersected to find the possible values for F. If there are no nodes remaining, the domination query fails: there is no legal flipping sequence. This often results in quick failure for straightforward cases, so that we only carry out the search for non-obvious cases.\nExample 9 Consider the CP-network of Figure I with the conditional preferences as in Example 5. Consider a query of the form\nab ... >- ab ...\nFirst we consider A. We can draw an arc a --+ a, and find that both a and a are on a path, so no values of A are pruned.6 We then consider B and draw an arc b --+ b; but there are no paths from b to b, so the query fails quickly without looking at the other features.\nOne could imagine extending this pruning phase to include more information, such as the sequences of values through which the parents can pass. From this one can determine the possible sequences of values through which the child feature could pass. Generally, the combinatorics of main taining such sequences is prohibitive; but in the binary case, any path through the set of values is completely determined by the starting value and a count of the number of times the value flips. Pruning still ignores the possible interde pendencies of the values for the parents, but for singly connected networks (where we can guarantee the sequences of values the parents can pass through are independent), pruning is complete in the sense that if it stops without fail ing there is a flipping sequence. This was the basis of the counting algorithm in [3] for singly-connected binary CP networks.\n6If the example were changed slightly so that A had a third value a', where a >- a >- a', then this third value could be pruned from A, thus simplifying the tables for all the children of A.\nReasoning With Conditional Preferences 77\n5 Search Strategies and Heuristics\nIn the previous section, the search space was formally de fined, and several completeness preserving rules for prun ing the search space were defined. This leaves open the is sue of effective procedures for searching. In this section we describe several heuristics for exploring the search tree. We first describe some simple heuristics that seem to be effec tive for many networks, and are, in fact, backtrack-free for certain classes of networks. We then show how this search problem can be recast as a planning problem and briefly de scribe the potential benefits of such a view.\n5.1 Rightmost and Least-Improving Heuristics\nThe rightmost heuristic requires that the variable whose value one flips when deciding which child to move to is the rightmost variable that can legally be flipped. For instance, consider the improving search tree in Example 6 (as illus trated in Figure 2). Given a target outcome abc, we see that the rightmost heuristic leads us directly to the target in two steps. If the target outcome were different, say abc, then the rightmost heuristic has the potential to lead us astray. However, when we incorporate the suffix-fixing rule into the search, we see that the rightmost heuristic (defined now as flipping the rightmost value that doesn't destroy a suf fix match) will lead directly to any target outcome in the search tree. For example, given target outcome abc, the rightmost heuristic discovers the shortest path to the target: notice also that suffix-fixing prevents us from exploring the longest (length six) path to the target.\nThis example suggests that for chains, the rightmost heuris tic will lead to a proof, if one exists, without backtracking. This may not be the the case, however, if variables are not all binary.\nExample 10 Consider the CP-network where variable A, with domain { a1, a2, a3}, is a parent of boolean variable B. Conditional preferences are given by\na1 >- a2 >- aa a1 : b >- b; a2 : b >- b; a3 : b >- b\nGiven query a1 b >- a3b, the rightmost heuristic in an im proving search could first construct the sequence a3b -< a1 b, reaching a dead end (thus requiring backtracking). The direct sequence aab -< a2b -< a2b -< a1 b is also consistent with the rightmost heuristic.\nIn the example above, the rightmost heuristic permitted a 'jump\" from a3 to the most preferred value at without mov ing through the intermediate value a2. This prevented it from discovering the correct flipping sequence. In multi valued domains, another useful heuristic is the least improving heuristic (or in worsening searches, the least worsening heuristic): when the rightmost value can be flipped to several improving values given its parents, the improving value that is least preferred is adopted. This al lows greater flexibility in the movement of \"downstream\"\n78 Boutilier, Brafman, Hoos, and Poole\nvariables. While one can always further improve the value of the variable in question from its least improving value to a more preferred value (provided that parent values are maintained), \"skipping\" values may prevent us from setting its descendents to their desired values. Both the rightmost and least improving heuristics can be viewed as embodying a form of least commitment. Flipping the values of the rightmost possible variable (i.e., a variable with the smallest number of descendents in the network) can be seen as leaving maximum flexibility in flipping the values of other variables. An upstream variable limits the possible flipping sequences more drastically than a down stream variable-specifically, altering a specific variable does not limit the ability to flip the values of its nondescen dents. For the reasons described above, the least improving heuristic can be cast in a similar light. Unfortunately, while the least-commitment approach works well in practice, it does not allow backtrack-free search in general, as the following example shows.\nExample 11 Consider the CP-network with three variables A, B and C such that A is the only parent of B and B is the only parent of C. Suppose A has domain {a, a}, B has domain {61, b2, ba} and C has domain {c, c}, with the fol lowing conditional preferences:\na>-a; a : ba >- b2 >- b1; a : ba >-b1 >-b2; b2 : c >-c; 61 V ba : c >-c\nConsider the query ab3c >- ab1 c with an improving search. c cannot be improved in the context of 61. However b1 can be improved to ba in the context of a, but this leads to a dead end. The right thing to do is to flip a first, then change b1 to b2 which will let you flip c and then change b2 to b3.\nWhile queries over chain-structured networks with mul tivalued variables cannot reliably be searched backtrack free using the rightmost and least-improving heuristics, this search approach is backtrack-free for chains when all vari ables are binary. Intuitively, this is the case because chang ing the value of the rightmost allowable variable does not impact the ability to flip its parent's value; furthermore, changing this variable cannot prevent its child from being flipped, since if the child needed a different value (and could have been flipped), it would have been flipped earlier. For similar reasons, binary tree-structured networks (where ev ery variable has at most one parent, but perhaps multiple children) can also be searched backtrack-free.\nExample 12 Consider the binary tree-structured prefer ence graph of Figure 3 with the conditional preferences:\na>-a a : b >- b; a : b >- b a : c >-c; a : c >-c\nConsider the queryabcde >- abcde. Suppose we are search ing for an improving flipping sequence from abc de. By suf fix fixing, we leave e untouched. The first value we flip is c. Since this is the only way we could ever get to flip d, and be cause cis binary, there is only ever one other value it could have. We can now flip d forming abcde (d and e then re main untouched). We can flip b, and fix it by suffix fixing (as there is an ordering where it is part of the fixed suffix). The only value we can flip at this point is a; this gives us abcde. We can now flip c and we are done.\nProposition 3 The rightmost search heuristic, in conjunc tion with suffix-fixing and suffix-extension, is complete and backtrack-free for chain- and tree-structured CP-nets with binary variables.\nPolytrees (singly-connected networks containing no undi rected cycles) cannot be searched without backtracking in general, even when variables are binary. This is due to the fact that several parents of a given node may each be allowed to have their values flipped, but only one of the choices may lead to the target outcome, while the others lead to deadends. For instance, suppose we consider Exam ple 5, restricted to the variables A, B, C, and are given the query abc >-abc. Using an improving search rooted at abc, we have a choice of flipping A or B. If B is chosen, we start down the path abc -< abc; but this clearly cannot lead to the target, since there is no way to flip B back to b. A deadend will be reached and we must backtrack to flip A before B, leading to the solution path abc -< abc -< abc. Essentially, this means we have to may have to consider dif ferent variable orderings over the ancestors of a given node. It turns out that these are the only backtrack points in binary polytrees. Finally, for general (multiply-connected) CP-nets, complex interdependencies can exist among the parents of variables because the parents themselves may share ancestors. This can lead to complex search paths in the successful search for a flipping sequence. Though we don't provide examples, one can construct networks and specific queries such that no fixed ordering of variables allows the rightmost heuristic to work backtrack-free. We also note that the shortest flipping sequence for certain queries can be exponential in length given a maximally-connected acyclic network (e.g., we can\nrequire sequences of length 0(2nf2) in ann-variable binary network). We do not believe such sequences are required in singly-connected networks.\nIt should be noted that while one can generate example net works and queries that require complicated search, involv ing considerable backtracking using most simple heuristics, such examples tend to be rather intricate and obscure. They invariably require a tight interaction between the network structure, the conditional preference statements quantifying the network, and the specific query itself. None of the nat ural examples we have seen require much search.\n5.2 Flipping Sequences as Plans\nIn this paper we have considered searching directly for flip ping sequences. This can be seen as a case of state-space search. It is also possible to think about answering domi nance queries as a type of planning problem. A conditional preference statement of the form\ncan be converted into a set of STRIPS actions for improv ing the value for a variable. In particular, this conditional preference statement can be converted into a set of d - 1 STRIPS operators of the form (for 1 < i ::; d):\nPreconditions: c II v;\nAdd List: v; -1\nDelete list: v;\nThis corresponds to the action of improving v; to v; -1 in the context of c. (A different set of actions would be created for worsening).\nGiven a query x >- y, we treat y as the start state and x as the goal state. It is readily apparent that that the query is a consequence of the CP-network if and only if there is a plan for the associated planning problem. A plan corresponds to a flipping argument.\nThe previous algorithms can be viewed as state-based for ward planners. It is often the case that domain-specific heuristics can be easily added to a forward search [2], and we expect the same here. We could also use other planning techniques such as regression, partial-order planning, plan ning as satisfiability and stochastic local search methods for this problem. The application of regression and partial order planners (more generally, backchaining planners) can provide support for reasoning about the changes in ancestor values required for a specific descendent to flip its value to its target. We note that the planning problems generated by CP-queries will generally look quite different in form from standard AI planning problems, as there are many more ac tions, and each action is directed toward achieving a partic ular proposition and requires very specific preconditions.\nReasoning With Conditional Preferences 79\n6 Concluding Remarks\nIn this paper we introduced CP-networks, a new graphi cal model for representing qualitative preference orderings which reflects conditional dependence and independence of preference statements under a ceteris paribus semantics. This formal framework often allows compact and arguably natural representations of preference information. We ar gued that given a CP-network, the basic inference problem of determining whether one of two given vectors of feature values is preferred to the other is equivalent to the task of finding a connecting sequence of flipping individual feature values. We characterized the corresponding search space and described several strategies and heuristics which often significantly reduce the search effort and allow one to solve many problem instances efficiently.\nWe see various applications of CP-networks and our domi nance testing strategies and heuristics. One of these is sort ing a product database according to user-specified prefer ences. This problem is highly relevant in the context of electronic commerce. Several rather conceptually simplis tic implementations are available on the World Wide Web (e.g., Active Buyers Guide). The general idea is to assist a user in selecting a specific product from a database ac cording to her preferences. Here, it is very important to use compact and natural representations for preference infor mation. CP-networJcs extend current models (which typi cally don't allow conditional preference statements). An other important aspect of this problem is that the given database precisely defines the items (represented as vec tors of feature values) available, and preference information is only required to such an extent that the choice is suffi ciently narrowed down to a small selection of products from this database. Dominance testing strategies are important in this context to find a set of Pareto-optimal choices given the (conditional) preference information extracted from the user. Here, an interactive and dynamic approach appears to be most promising, where the user is prompted for addi tional preference statements until the ordering of the items in the database is sufficiently constrained by the preference information to offer a reasonably small selection of prod ucts. W hile the dominance algorithms are an important part of the database sorting task, the problem does not generally require that all pairwise comparisons be run to completion. Certain preprocessing steps can be taken, that exploit the network structure, to partition tuples in the database accord ing to values of high priority attributes.\nAnother application area is constraint-based configuration, where the task is to assemble a number of components ac cording to user preferences such that given compatibility constraints are satisfied [3, 6]. A simple example of this is the assembly of components for computer systems where, for instance, the type of system bus constrains the choice of video and sound cards. CP-networks can be used to repre sent the user preferences which are used together with com patibility constraints to search for most preferred, feasible\n30 Boutilier, Brafman, Hoos, and Poole\nconfigurations. In contrast to the database sorting applica tion above, here the set of possible vectors of feature values (i.e., configurations) is not explicitly given, but implicitly specified by the compatibility constraints. Dominance test ing is again required for finding most preferred solutions, but now it has to be combined with mechanisms which limit the search to feasible configurations [3].\nWe are currently extending this work in two directions. First, the search strategies and heuristics for dominance testing presented in this paper have to be implemented in order to empirically assess their performance on various types of problem instances, including real-world problems, as well as handcrafted examples exhibiting uniform, reg ular structures of theoretical interest. Secondly, we are working on various extensions of the framework presented here. These include cases where the conditional preference statements contain a small amount of quantitative informa tion. In particular, existing applications (such as online in teractive consumer guides) suggest that a limited amount of such quantitative preference information might be rela tively easy to extract from the user in a natural way, and is very useful for inducing stronger preference orderings.\nAnother interesting issue is the extension of the represen tation and reasoning system such that incompletely spec ified conditional preference information (i.e., incomplete CP-tables) can be taken into account. This is motivated by the fact that often the full preference information given by the CP-tables is not required for deciding a particular dom inance query. Therefore, it seems to be useful to consider mechanisms which allow incompletely specified CP\"tables and dynamically prompt the user for additional preference information when it is needed.\nFinally, we intend to investigate the tradeoffs between the amount of user-interaction required for extracting the pref erence information and the amount of computation needed for determining most preferred feature vectors. By asking very specific questions about particular, potentially com plex preferences, finding most preferred feature vectors can become much easier. On the other hand, asking too many questions, especially those not really necessary for establishing relevant preferences, will annoy the user and make the system less usable. Thus, finding good trade offs between the amount of user-interaction and computa tion time for answering queries-such as finding most pre ferred items from a database or optimal configurations seems to be a promising direction for future research. This is related to the motivation underlying goal programming [8, 12). The representations and search techniques pre sented in this paper form a starting point for such investi gations.\nAcknowledgements: This research was supported by IRIS III Project \"Interactive Optimization and Preference Elicitation\" (BOU).\nReferences\n[ I ] Fahiem Bacchus and Adam Grove. Graphical models for preference and utility. In Proceedings of the Eleventh Con ference on Uncertainty in Artificial Intelligence, pages 3-10, Montreal, 1995.\n[2] Fabiem Bacchus and Froduald Kabanza. Using temporal logic to control search in a forward chaining planner. In Proceedings of the 3rd European Work shop on Planning, 1995. Available via the URL ftp://logos.uwaterloo.ca:/pub/tlplan/tlplan.ps.Z.\n[3] Craig Boutilier, Ronen Brafman, Chris Geib, and David Poole. A constraint-based approach to preference elicitation and decision making. In AAAI Spring Symposium on Quali tative Decision Theory, Stanford, 1997.\n[4] U. Chajewska, L. Getoor, J. Norman, and Y. Shabar. Util ity elicitation as a classification problem. In Proceedings of the Fourteenth Conference on Uncertainty in Artificial Intel ligence, pages 79-88, Madison, WI, 1998.\n[5] Thomas H. Cormen, Charles E. Lierson, and Ronald L. Rivest. Introduction to Algorithms. MIT Press, Cambridge, MA, 1990.\n[6] Joseph G. D'Ambrosio and William P. Birmingham. Preference-directed design. Journal for Artificial Intelli gence in Engineering Design, Analysis and Manufacturing, 9:219-230, 1995.\n[7] Jon Doyle and Michael P. Wellman. Preferential semantics for goals. In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 698-703, Anaheim, 1991 .\n[8] J . S . Dyer. Interactive goal programming. Management Sci ence, 19:62-70, 1972.\n[9] Simon French. Decision Theory. Halsted Press, New York, 1986.\n[1 0] Vu Ha and Peter Haddawy. Toward case-based preference elicitation: Similarity measures on preference structures. In Proceedings of the Fourteenth Conference on Uncertainty in Artificial Intelligence, pages 193-201 , Madison, WI, 1998.\n[ 1 1 ] Ronald A. Howard and James E. Matheson, editors. Read ings on the Principles and Applications of Decision Analysis. Strategic Decision Group, Menlo Park, CA, 1984.\n[12] James P. Ignizio. Linear Programming in Single and Mul tiple Objective Systems. Prentice-Hall, Englewood Cliffs, 1982.\n[ 13] R. L. Keeney and H. Raiffa. Decisions with Multiple Objec tives: Preferences and Value Trade-offs. Wiley, New York, 1976.\n[14] Yezdi Lashkari, Max Metra!, and Pattie Maes. Collabora tive interface agents. In Proceedings of the Twelfth National Conference on Artificial Intelligence, pages 444-449, Seat tle, 1994.\n[15] Hien Nguyen and Peter Haddawy. The decision-theoretic video advisor. In AAA/-98 Workshop on Recommender Sys tems, pages 77-80, Madison, WI, 1998."
    } ],
    "references" : [ {
      "title" : "Graphical models for preference and utility",
      "author" : [ "I ] Fahiem Bacchus", "Adam Grove" ],
      "venue" : "In Proceedings of the Eleventh Con­ ference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Bacchus and Grove.,? \\Q1995\\E",
      "shortCiteRegEx" : "Bacchus and Grove.",
      "year" : 1995
    }, {
      "title" : "Using temporal logic to control search in a forward chaining planner",
      "author" : [ "Fabiem Bacchus", "Froduald Kabanza" ],
      "venue" : "In Proceedings of the 3rd European Work­ shop on Planning,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1995
    }, {
      "title" : "A constraint-based approach to preference elicitation and decision making",
      "author" : [ "Craig Boutilier", "Ronen Brafman", "Chris Geib", "David Poole" ],
      "venue" : "In AAAI Spring Symposium on Quali­ tative Decision Theory, Stanford,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1997
    }, {
      "title" : "Util­ ity elicitation as a classification problem",
      "author" : [ "U. Chajewska", "L. Getoor", "J. Norman", "Y. Shabar" ],
      "venue" : "In Proceedings of the Fourteenth Conference on Uncertainty in Artificial Intel­ ligence,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1998
    }, {
      "title" : "Introduction to Algorithms",
      "author" : [ "Thomas H. Cormen", "Charles E. Lierson", "Ronald L. Rivest" ],
      "venue" : null,
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1990
    }, {
      "title" : "Preference-directed design",
      "author" : [ "Joseph G. D'Ambrosio", "William P. Birmingham" ],
      "venue" : "Journal for Artificial Intelli­ gence in Engineering Design, Analysis and Manufacturing,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1995
    }, {
      "title" : "Preferential semantics for goals",
      "author" : [ "Jon Doyle", "Michael P. Wellman" ],
      "venue" : "In Proceedings of the Ninth National Conference on Artificial Intelligence,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1991
    }, {
      "title" : "Interactive goal programming",
      "author" : [ "J . S . Dyer" ],
      "venue" : "Management Sci­ ence,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1972
    }, {
      "title" : "Decision Theory",
      "author" : [ "Simon French" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1986
    }, {
      "title" : "Linear Programming in Single and Mul­ tiple Objective Systems",
      "author" : [ "James P. Ignizio" ],
      "venue" : "Prentice-Hall, Englewood Cliffs,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1982
    }, {
      "title" : "Raiffa. Decisions with Multiple Objec­ tives: Preferences and Value Trade-offs",
      "author" : [ "H.R.L. Keeney" ],
      "venue" : null,
      "citeRegEx" : "Keeney,? \\Q1976\\E",
      "shortCiteRegEx" : "Keeney",
      "year" : 1976
    }, {
      "title" : "The decision-theoretic video advisor",
      "author" : [ "Hien Nguyen", "Peter Haddawy" ],
      "venue" : "Workshop on Recommender Sys­ tems,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1998
    } ],
    "referenceMentions" : [ ],
    "year" : 2011,
    "abstractText" : "In many domains it is desirable to assess the pref­ erences of users in a qualitative rather than quan­ titative way. Such representations of qualitative preference orderings form an important compo­ nent of automated decision tools. We propose a graphical representation of preferences that re­ flects conditional dependence and independence of preference statements under a ceteris paribus (all else being equal) interpretation. Such a rep­ resentation is often compact and arguably natural. We describe several search algorithms for domi­ nance testing based on this representation; these algorithms are quite effective, especially in spe­ cific network topologies, such as chainand tree­ structured networks, as well as polytrees.",
    "creator" : "pdftk 1.41 - www.pdftk.com"
  }
}