{
  "name" : "1702.08653.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Scaffolding Networks for Teaching and Learning to Comprehend",
    "authors" : [ "Asli Celikyilmaz", "Li Deng", "Lihong Li", "Chong Wang" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "I. INTRODUCTION Instructional scaffolding teaching [1],[2] is a process through which a teacher adds support for students to enhance learning. A common method in scaffolding teaching is to repeatedly question students to check for understanding, which systematically builds on students’ experiences and knowledge. In this paper, we present a modular neural network architecture that imitates scaffolding teaching and teaches machines to read and comprehend text by iteratively asking questions. The Scaffolding Network (as sketched in Figure 1) combines several desirable features into a single, effective network: it can iteratively learn to track the information in text one sentence at a time; it can generate questions from the text via a question simulator; it learns to answer these questions based on the reward signal it receives from an agent that repeatedly interacts with the text and the simulator. By scaffolding questions about the previous memory, it improves comprehension.\nIn the literature, the machine reading and comprehension is mostly taken as a cloze-style question answering (QA) task. Especially the neural-network-based approaches learn to selectively attend to different parts of the input text relevant to a target question. They squash the input text into a vector representation, e.g., [3],[4],[5], and use the answer as the output signal in a supervised learning setting. The key challenge is to understand the relation(s) between different parts of the text and do reasoning about the related facts. Similar to [6],[7],[8], our model receives the input text in sequences of smaller segments\n(e.g., sentences). Unlike previous work, our network does not just focus on answering a target question, but rather sequentially encode the text while repeatedly refreshing its memory and generating questions about the recent past. This way, it learns to keep track of the new information in each sentence, building up on previous memory, thus improve comprehension. This is similar to the scaffolding teaching, in which teachers typically break up learning a skill into discrete parts and check to see if students have understood the concepts in previous parts.\nOur main contribution is a novel reading comprehension architecture and an associated algorithm that iteratively learns to map hidden facts in sentences into state representation. It uses an attention network while keeping the representation of the previous sentences of the text in memory. The second module, the question simulator, generates question-answer pairs related to the text processed so far along with their answers based on the error signal it receives from the network. Contrary to earlier work, we do not provide the final question and its answer (true labels) until after all the sentences are encoded through scaffold questioning. To reduce the dependency on the training data labels, we evaluate our model on data by reducing the training data labels and instead use the generated question-answer pairs as the labels. In a sense, scaffolding network can be self-trained with these auxiliary questions. Nevertheless, labels from training data improve learning to answer different types of questions, possibly more complex than the generated question-answers. The third module, the agent, produces scores for the set of possible answers to the posed question given the current state representation. The agent receives a limited (partial) information about the state of the world (no prior information as entities, slots or relations between them are provided) and learns to encode them given previous memory. Therefore, we adopt a reinforcement learning (RL) framework, and use agent’s reward as the learning signal. The scaffolding agent aims to maximize its rewards that it obtains upon answering generated questions. Using Deep QLearning [9], [10] (DQN), the agent learns a policy in the form of an action-value function to evaluate the merit of the predicted answer to generated question. Action-value function is parameterized with the scaffolding network using the answers to questions as a feedback.\nWe evaluate the Scaffolding Network (SN) on story-based reasoning and question/answering datasets including a travellog data, bAbI QA [11], bAbI dialog set and DSTC2 dialog datasets [12] in the supervised learning setting. In most of the experiments, when all labels are used, our SN competes well with the state-of-the-art. We also demonstrate that it shows promising results on reasonings tasks that require learning\nar X\niv :1\n70 2.\n08 65\n3v 1\n[ cs\n.C L\n] 2\n8 Fe\nb 20\n17\n2 relations between multiple facts compared to other methods especially when less supervision is used."
    }, {
      "heading" : "II. THE SCAFFOLDING NETWORK",
      "text" : "Similar to approaches that use dialog modeling for comprehension tasks [6], the SN agent interactively learns to parse the input text and register the information into the memory by interacting with a question simulator. Unlike these systems, where a simulator and agent take turns and the agent asks clarifying questions to get more information, the information that the our agent needs is readily available in the text, but is mostly hidden. Our agent’s interaction with the simulator is implicit and agent’s goal is to learn to track information in text while continuously trying to answer a generated question.\nConsider that the network shown in Figure 1 is encoding the shown input text. Each sentence is processed through this network one at a time. For instance, the figure shows that at time t=3 the network is reading the sentence \"the bathroom is south of the kitchen\". First, the question simulator samples a sentence from the first t− 1 sentences and generates a question along with an answer (e.g., if sentence 2 is sampled, the generated question can be \"the garden is west of the ?\" with kitchen being the answer) (path 1-6). Then, the network encodes the current sentence together with the generated question and the dynamic memory into a concatenated hidden state representation (path 7). The attention network identifies new information in the current sentence relative to the dynamic memory (flow 8) and updates the memory (flow 9). The network concatenates all this information (flow 10) into a vector representation and sends to the policy network (flow 11), which produces a reward for answering the question (flow 12). Thus, the goal in scaffold questioning is to reinforce the registering of key hidden facts (e.g., kitchen’s location relative to the garden and bathroom) with as little external supervision as possible. If the corpus is equipped with question-answer pairs about the text, they are also encoded when the end of text is reached. The reward is positive when the agent answers correctly, and negative when a wrong answer is predicted. By trial-and-error exploration, the network learns to keep track of the hidden states within the text. We provide the details of SN modules below and the pseudo-code for training the network end-to-end in Algorithms 1 and 2 in Appendix-A.\nA. Input Encoder Module\nThe training data Dtrain is a collection of passages. Each passage, denoted X , consists of a sequence of sentences: X = (x1, . . . , xT ). The network is trained using one sentence at a time, xt = (wt,1, . . . , wt,n), represented as a sequence of n words, used as the input units. Each word wt,i is represented with embedding et,i, yielding a sequence of embedding vectors et = (et,1, . . . , et,n). The embedding vector at time t is used as input to an long short-term memory (LSTM) [13] model to obtain H ∈ Rd×n, which is a matrix of hidden states of each word Ht = (ht,1, . . . , ht,n), and d indicates the size of the hidden layers. We also inject the previous context into the LSTM. This is crucial for our network, as the network may be asked questions about previous context. To do this,\nthe information accumulated from the previous sentence after processing the last state, h̃t−1, is used as the initial state of the LSTM that processes the current sentence. The last hidden state ht=ht,n of the current sentence is used to update the dynamic memory."
    }, {
      "heading" : "B. Question-Sentence Encoder",
      "text" : "Similar to the input encoder, each word ai in a question xq = (a1 · · · an), be it generated by the question simulator or provided in the corpus, is encoded by first mapping onto embedding vectors eqt = (e q t,1, . . . , e q t,n), and then using LSTM to get the hidden vectors. The final rolled hidden state hqt = hqt,n is a fixed length vector representing each question at time t. The similarity of a question xqt at time t to the current sentence xt as well as the previous memory is computed by a linear combination of the output of the last hidden state of the question LSTM hqt , hidden-state representation of the previous memory h̃t−1, and the current sentence word embeddings et as follows:\nẽt ← et + hqt ⊗ Iq (1) ẽt,0 ← h̃t−1 hqt (2) ot ← LSTM(ẽt,0, ẽt) , (3)\nwhere Iq∈Rn is a vector of 1s that we use to merge the encoded question vector with the embedding vector of each word in the sentence, et. Element-wise product ( ) of the question and the previous memory is used as the initial state ẽt,0 of the question-sentence encoder. The non-linear combination of the question and sentence, ot, ensures encoding of the information in sentence t, in relation to the question and the previous memory, as part of the state representation."
    }, {
      "heading" : "C. Attention Network",
      "text" : "The goal of the attention network is two-folds: (i) learn to detect new information in the current sentence in relation to the information extracted in previous sentences using soft attention, (ii) learn to build a dynamic memory to store the previous memory and current information using a gating function. To achieve these goals, the attention network receives two inputs: the hidden states of each word of the current sentence t, Ht= (ht,1, · · · , ht,n) and the last hidden state from the previous time step, h̃t−1. Soft Attention. [14] learns an entailment relation between two sentences (a premise and a hypothesis text) by word-by-word soft attention to encourage reasoning over entailment of pairs of words or phrases. We implement a similar soft attention mechanism. Rather than learning entailment relations, we aim to learn dissimilarities between the previous sentences (premises) and the current sentence (the hypothesis) to track and encode the new information in the current sentence into states. Weaker attention indicates that the information in the current sentence compared to the memory (e.g., a new entity present in the current sentence) is different and should be tracked in state representation. The attentive network produces intermediate attention representation mt as a non-linear combination of the\n3 ⋯ ⋯ ⋯ LSTM question-sentence encoder ⋯ ⋯ ⋯ soft attention No reward=-1 2-layer NN ⋯ ⋯ Input encoder read the next sentence sample a new sentence Yes reward = 1 state representation LSTM question generator\ns1:the bedroom is north of the hallway. s2:the garden is west of the kitchen. s3:the bathroom is south of the kitchen. s4:the office is north of the bedroom. s5:the hallway is east of the kitchen. 3:t t r i t f t it . i ll i i\ninput text dynamic memory\nbedroom\nkitchen\nwest north\nhallway south\nbathroom\ngarden [west, south]\n1\n2\nread current sentence (s3)"
    }, {
      "heading" : "Q-Network",
      "text" : "memory update\ngate\nis answer correct ?\npredict an answer\n1\n7\n6\n11\n⋯\n⋯\n⋯\nLSTM\nsample an answer\nthe garden is west of the kitchen sample a sentence 8\nusing sampled answer,\ngenerate question\nthe garden is west of the ?\n3\n4\n5\n12\n7\nargmax ,\n10\n78 9\n1010\n9\nFig. 1: Illustration of scaffolding forward step at time (sentence) t=3. The process starts at flow 1 with the question simulator sampling a sentence (e.g., t=2), and generating a scaffolding question and an answer. The question, sentence and attention modules are encoded into concatenated hidden states and are sent to the policy producing rewards for answering the question. Gating function gt updates the dynamic memory by combining the previous and current memory. Hidden facts (e.g., kitchen’s location relative to the garden and bathroom) are instilled into the dynamic memory. The process ends after flow 12 with a decision to read the (t+1)th sentence or generate a new sentence. The scaffolding forward step is repeated until the end of document and experiences are saved to learn the policy offline.\nprevious sentence’s last hidden state h̃t−1 and hidden states of each word in the current sentence ht,i ∈ Ht:\nmt ← φ(W xHt +Whh̃t−1 ⊗ In) , (4)\nwhere W x and Wh are weight matrices to be learned, and the output product (Whh̃t−1 ⊗ In) repeats the previous sentence hidden state h̃t−1 n times. φ is the activation function; in our experiments, we used the hyperbolic tangent (tanh) activation function. Each column mt,i of the output attention matrix mt (as in Figure 1) is the un-normalized attention of the ith word of sentence xt. Dynamic Memory. After encoding the sentence with attention, the network determines how much information to carry over to the next sentence using a gating function:\ngt ← φ(WCht +WP h̃t−1) (5) h̃t ← ht + gt h̃t−1 . (6)\nIn the above, WC and WP are weight matrices to be learned. They represent the weights associated with the current sentence and the previous memory at time t−1. ht is the last hidden state of the current sentence LSTM model. We choose hyperbolic tangent for the activation φ. In the experiments, we compare the effectiveness of our gating function to simpler memory update functions, i.e., summation: h̃t = h̃t−1 +ht and moving average: h̃t = (h̃t−1 + ht)/2."
    }, {
      "heading" : "D. Question Simulator",
      "text" : "Instead of a human proving question-answers as a teacher, our question simulator is designed to ask scaffolding questions to the agent. Its goal is to reinforce tracking of the information as states and learning the relations between the information extracted from sentences. To generate questions, we use two types of methods: Rule-Based Simulator: The rule-based question simulator randomly selects a sentence among the sentences that have been processed so far. Similar to [15], it randomly samples one word (we omit stop words) as the answer (ai), and replaces it with an unknown word ‘unk’ (“the documents are released to the press” → “the documents are released to unk?”). Such questions represent what is known as wh-questions, such as “who are the documents released to?”. The generated question is processed through an LSTM to obtain the last hidden state vector hqt and is sent to the question-sentence encoder. Reward-Driven Simulator: Our RL agent encodes the internal state of sentences by iteratively learning to correctly answer questions. With no signal from the agent, the rule-based agent may unnecessarily generate questions that the model has already learnt to correctly answer. We propose rather an intelligent simulator that learns to generate questions based on the reward it receives from the agent. To achieve this, we first select a candidate sentence from those already processed so far.\n4 The candidate sentence words are converted into embedding vectors, then processed through an LSTM layer to obtain unrolled hidden states of its words Hq = (hq,1, . . . , hq,n). We learn a mapping (parameterized by β) from hidden states to a probability distribution pt over words in the selected sentence, so that\npt(ai) ∝ exp(βThqt,i) , (7)\nThe pt(ai) is the probability that the word ai is chosen from the candidate words {a1, ..., an} normalized over all candidate words, and we define pt=[pt(a1) . . . pt(an)] as the probability vector. Among all words, a candidate answer a∗i is sampled from this distribution. The generated question is then formed by replacing the candidate answer with an unknown word ‘unk’. The generated question is processed through the same LSTM to obtain the last hidden state vector and is sent to the question-sentence encoder (as shown in Figure1). The question word probabilities pt are concatenated to the input state representation so the scaffolding is trained with the simulator end-to-end. Under this model, the simulator will learn to sample among answer candidates, for which the model has yielded negative reward in the past. When the question-answer pairs are provided in corpus (i.e, at the end of the text), the provided question follows through the question-generation path (1-6) in Figure1 to obtain the word probabilities pt skipping the answer sampling step. Then the provided answer is used as the target answer."
    }, {
      "heading" : "E. Scaffolding Deep Q-Network Agent",
      "text" : "We pose the task of learning to reason through questioning into a problem well suited for an RL problem. State. At each time step t, the agent observes the current st ∈ S, which, for the rule-based simulator, consists of the output of the question-sentence encoder (ot) and the attention vector (mt): st = [ot;mt]. For the reward-driven simulator, the state also includes the question word probabilities (pt); that is, st = [ot;mt;pt]. This is similar to [16], in which our agent attempts to understand the text not only from encoding the question and sentence together with the dynamic memory, but also from encoding the generated question, which includes some hidden information about the candidate answer. Action. At each time step, the agent selects an action at from a finite set of actions A = {1, . . . ,K}. In our task, an action corresponds to an answer, which is an entity from a taskspecific entity set. The agent selects an answer, then collects the corresponding reward. The agent’s action affects the next operations of the whole network, including whether the next sentence from the input text is to be read, and how the question generator samples question-answer pairs; this in turn affects the next state, st+1, observed by the RL agent. Reward. A negative reward is provided when the agent answers the question wrong, and positive when correct. For a wrong answer at time t, the question simulator generates a new question, the tth sentence is encoded with the new question and are sent to the agent, Then the agent samples an answer and collects reward. This process continues until the agent gets a correct answer or a maximum of Γ trials are exhausted.\nThe reward at terminal is a larger positive number which is proportional to the number of correctly answered questions given the sentences in the input text. Policy. We learn the optimal policy through a Deep Q-Network, or DQN. As the forward activation, the agent first interacts with each sentence over a sequence of discrete steps until the end of text is reached. At each time step, it observes the current state st, and chooses an action/answer at to the generated question according to a policy π : S 7→ A. The agent receives a reward rt and observes a new state st+1, continuing to read sentences until the end of text. The Qfunction for the policy π measures, for each state-action pair (s, a), the expected cumulative discounted reward if the agent chooses a in state s and then follows π thereafter: Qπ(s, a) = Eπ [∑T i=0 γ irt+i|st = s, at = a ] , where γ is the discount factor. An optimal policy π∗ has a Q-function, denoted Q∗, that uniformly dominates every other policy’s Q-function. During learning, -greedy exploration is used with = 0.1 which decays over time. Learning Double DQN: Back Propagation. In standard Deep Q-learning [10], given an optimal policy Q∗, at any time-step t, the agent’s optimal move is to choose action a∗ = arg maxaQ(s, a). For reasoning tasks, the action space is large and state space is continuous, so we approximate the Qfunction by a 2-layered deep-learning model Q(s, a; θ), where θ are parameters to be learned. As commonly done, we represent experiences as tuples of transitions, ((st, at, rt, st+1) ∈ De). Using a greedy policy, we aim to improve the value function by minimizing the squared error between the current prediction and one-step look ahead prediction. With stochastic approximation, we train the q-function. We use experience reply [10] by maintaining a buffer of experiences and training on randomly selected mini-batches of experiences. As proposed in [10], we also use the target network to compute the training targets yt. We implement double deep q-learning (D-DQN) [17] for the scaffolding agent policy learning to eliminate over-optimism during learning. In D-DQN, two value functions, θ and θ′ are learnt by alternating their use. One of the value functions is used to determine the greedy policy, and the other value function is used to determine its value. (see Appendix-A for implementation details)"
    }, {
      "heading" : "III. RELATED WORK",
      "text" : "One of the challenges in reading comprehension is to learn to represent document structure to do a proper reasoning. Neural Readers have recently seen considerable success, specifically in cloZE form question answering tasks. Most early work applied single turn-reasoning utilizing an attention mechanism to emphasize some sections of a document which are relevant to a query and proposed different network structures [18], [19], [3], [4], [20]. While they do reasonably well in representing the similarity relations between a passage and a question, they fall short on the reasoning capabilities because it is harder to keep track of relations between encoded knowledge with such architecture. For reasoning tasks, we must design a network that can extract information from different parts of the text and track in memory, as shown in Section II-C.\n5 The second and arguably the most important challenge is to evaluate the efficacy of the model on doing a fair reasoning. Several recent work has simulated this by combining the facts in a query with the new information from previous iterations to do multi-turn reasoning [15], [21], [22], [5], [23] for more complex stories which require deeper reasoning. Most work are based on memory networks [11] or RNNs with attention components, e.g, Gated Attention Reader [24], Iterative Alternative Reader [5], Fine-Grained Gating [25], Chunk Extraction [26], Dynamic Co-Attention Networks [27] etc.\nSimilar to our work, others receive the text in sequences of sentences and encode them separately. [6] considers dialog modeling approach, in which an agent iteratively asks additional questions about relevant missing facts, so it learns to correctly answer the target question. Unlike their approach, our agent does not ask questions, but rather a question simulator module, implicitly acting as a teacher, repeatedly questions the agent about the hidden facts to strength its memory network. [28]’s dialog-based language learning approach gets feedback from a teacher and various correction types and imitates such signals in order to learn to answer questions. [8] encodes the labeled question together with each sentence separately to identify question related facts. The goal of these earlier studies is to highlight relevant facts about the questions by using the question-answer pairs in the corpus as the supervised signal. Unlike them, our goal is not to search for clues about a given question, but, to learn to encode the given text to do reasoning later. The closest to our work is the Recurrent Entity Networks [7], in which the authors try to learn the internal state representation of each sentence and store in memory by parallel recurrent units with tied weights using gating functions. Similar to ours, their goal is to learn to represent a story into states to later do reasoning. Unlike their work, we use scaffolding to imitate the student teaching experience using RL. In the experiments we use some these models to compare against the scaffolding networks."
    }, {
      "heading" : "IV. EXPERIMENTAL SETUP",
      "text" : "We evaluated our SNs on a set of reasoning tasks with synthetic and real datasets. Our goal is to show that a rewardbased question simulator as a teacher in a self-training setting is fundamental to reasoning about facts that may be partially observable. Even with reduced labeled data, the scaffolding can learn to do reasoning well on complex tasks, reducing the dependence on humans as teachers."
    }, {
      "heading" : "A. Training the Scaffolding Network",
      "text" : "If no validation data is provided, we withhold 10% of the data for hyper-parameter tuning. We use hidden size of 100 for small datasets (∼1K training data) and 128 for the rest of the datasets. The weights in the input and output units were initialized with zero mean and standard deviation of 1/ √ d. L2 weight decay of 0.001 is used for all weights. All models are trained with ADAM [29] with initial learning rates set by a grid search over {0.1, 0.01}. We varied the epochs at training by 100-500 epochs. For each experiment, we assign a reward of -1 for answering a question wrong, +1 when correct. At the\nlast sentence, we provide +5 for correct answer plus a reward proportional to the number of correct answers, e.g,. if there are 10 sentences in text, and 3 of the questions are correctly answered (including the last labeled question) the reward at terminal is rT = 5 + 3. As large variance in performance can be observed on some tasks [30], we repeat each training 5-10 times with different random initializations and choose the best model based on validation performance and report test results of the best model.\nOur benchmark models use multi-hop/multi-layer memory networks and show promising improvements compared to single hop/layer counterparts. For a fair comparison, we also used 2-layer LSTMs for the question simulator and the questionsentence encoder. We obtain two last hidden states from the two layer question simulator, hq,1t , h q,2 t . The first one is used as an input to the first LSTM of the question-sentence encoder same as in Equation 1 and 2. The second one is linearly combined with the unrolled output of the first LSTM, ot1, and sent to the second LSTM as follows:\nõ2t ← o1t + h q,2 t ⊗ Iq (8)\no2t ← LSTM(õ2t ) (9) The state is then represented as: s = [ o2t ,mt ] and s =[\no2t ;mt;pt ]\nwith the reward driven simulator. We get slight improvements with 2-layered SN and use in all experiments."
    }, {
      "heading" : "B. Datasets",
      "text" : "Travel Log datasets. Travel log dataset is a collection of text documents about travel narratives. Our goal in creating these datasets is to measure the ability of our scaffolding network in reasoning tasks which require learning relations between multiple facts. Each text is constructed by placing a traveler agent in a town defined by a 9×9 grid, which is full of attractions. The agent starts randomly in one location and wanders around the town by randomly choosing a direction to the next move (i.e., north, west, south, east) and logs each move. As agent moves to a new direction, logs any attraction nearby with respect to the current location (e.g. there is a museum on my left.) End of each log, a question is asked about the location of a randomly chosen attraction, (e.g.,what is north of the museum?). The task is to find the correct answer, which can only be inferred from the text by tracing the traveler’s steps. The complexity of the task increases as the number of attractions in town is increased. Five different cities of log datasets are generated by varying the number of attractions, i.e., complexity of the reasoning task. Each dataset contains 1000 training and test logs. (Samples from log data can be found in Appendix-B.) bAbI story-based QA datasets. bAbI dataset is a collection of 20 question answering datasets [11] of different tasks. A task consists of a text in the form of sequence of sentences followed by a question whose answer is a word or set of words from the text. The task is to answer the question correctly, both of which are available at training time, but the answer is to be predicted at test time. Two sets of the QA datasets are used: one of them has 10,000 training problems per task and the other has 1,000 per task.\n6\nbAbI Dialog datasets. Goal oriented dialog datasets [12] with 5 different tasks of completing a restaurant reservation conversational dialog system between a user and a system. The datasets (T1,..,T5) are synthetically generated based on knowledge based consisting of 7 facts which define restaurants (e.g., such as location and price range). These tasks test the capacity of end-to-end dialog systems with various goals (e.g., request phone-number, address, etc.) A different set of test sets, named out-of-vocabulary (OOV), are also used to test the capability of a system to deal with entities not appearing in training data. DSTC-2 Dialog datasets. This dataset[12] is provided with real human-bot conversations, in restaurant domain, and derived from second Dialog State Tracking Challenge [31]. Sample conversations are provided in Appendix-C.\nFor the QA datasets, the scaffolding RL agent uses all the vocabulary (after stop words are removed) as its action space. Some tasks include \"yes/no\" questions, so we added \"yes\" and \"no\" to our action space. For the dialog tasks, the input text is defined by taking the utterances cu1 , c s 1, c u 2 , c s 2, .., c u t−1, c s t−1 (alternating between the user cui and the system response c s i , while the cut is the question and the goal is to predict the response cst . The answers are comprised of multiple words. Similar to [12], we define an action ai as the ith response in the candidate set C such that ai ∈ C. The set of candidate responses includes all possible bot utterances and API calls."
    }, {
      "heading" : "V. EXPERIMENTAL RESULTS",
      "text" : ""
    }, {
      "heading" : "A. Results on Supervised Setting",
      "text" : "I. Travel-Log Datasets. We start with studying our model’s comprehension capability on learning the relations between multiple facts in text logs. To make the tasks harder, we gradually increase the number of attractions. We compare the performance of LSTM, End-to-End Memory Networks (MemN2N)1 [30] and Scaffolding Networks with Reward Driven Simulator (SN-RD).\nTable II shows results. For each model we repeated the experiment 5 times and report the best performance. The scaffolding models outperform almost all the benchmark models, except for the simplest task with 5 attractions. The LSTMs performed poorly. MemN2N performed similarly to the scaffolding models for simpler tasks (#attractions ≤10). Although, the performance of all models drop as the complexity\n1https://github.com/facebook/MemNN\nincrease, our scaffolding agent is both more accurate and more robust on complex tasks. As shown Appendix-B, Table 3, the question simulator learns to ask the questions that would challenge the agent. This teaches the agent to learn to encode the correct facts and relations. II. QA and Dialog Datasets. We compare our approach to recently published work mentioned in the related work: Endto-End Memory Networks (MemN2N) [30], Query Reduction Networks (QRN) [8], Dynamic memory Networks (DMN) [21], Recurrent Entity Networks (EntNet) [7], End-to-End Goal Oriented Dialog (N2N) [12] (This approach is same as the MemN2N models except dialog features are used). For fair comparison with benchmark models, we show the 2-layer results of QRN (their best model on bAbI and dialog data). We list the results of our SNs with rule based question simulator (SN-RB), and with reward driven question simulator (SN-RD).\nPerformance results are summarized in Table I. For story based QA datasets (top table), both of our SN models are ranked in top tier among the best reported models based on the mean error over 20 tasks. SNs are trained with a goal of interactively learning to encode the sentences in input text first, then to answer labeled questions. In that sense, the scaffolding model results are promising and comparable to state-of-theart. In addition, some of these tasks are more challenging requiring multiple steps of reasoning and incremental knowledge contemplation. Although our models do not outperform baselines in the overall, the scaffolding agent shows promising improvements over the baselines especially for complex tasks requiring deeper reasoning, e.g., positional and size reasoning, and the tasks including lists, as detailed in Appendix-D. The model with the reward driven question simulator SN-RD shows slight improvement over the rule based SN-RB suggesting that reward-driven simulator can learn to tackle with the reasoning tasks better.\nFollowing previous work, we expand the state representation with 7 additional features, each focusing on one of the 7\n7 10 25 50 75 100 20 40 60 80\n%labeled data\nTe st\nE rr\nor (%\n) Task 9 - Simple Negation (1K) SN-RD MemN2N\n10 25 50 75 100\n0\n20\n40\n60\n%labeled data\nTe st\nE rr\nor (%\n)\nTask 14 - Time Reasoning (1K)\nSN-RD MemN2N\n10 25 50 75 100\n40\n60\n80\n%labeled data\nTe st\nE rr\nor (%\n)\nTask 17 - Positional Reasoning (1K)\nSN-RD MemN2N\n10 25 50 75 100\n40\n50\n60\n70\n%labeled data\nTe st\nE rr\nor (%\n)\nDSTC-2 Dialog\nSN-RD MemN2N\nFig. 2: Error rates of Semi-Supervised training, showcasing the efficacy of the models when the number of labeled training data is reduced. Experiments are on 1K training data.\nproperties associated with restaurants. These features, referred to as match features, indicate whether there are any exact match between words occurring in the candidate and those in the question or memory. For the bAbI dialog tasks with match features, the scaffolding agent performs same or better than the best performing model. The OOV experiments in Table I demonstrate how the models handle actions with \"unseen\" entities in conversational dialogs. All models have slightly higher error rates with OOV words, and, SNs immediately follow the best model when no match features (plain) are used, yielding best results with match features compared to the best performing model. In the DSTC-2 challenge, the real dialog conversational data, the efficacy of the reward driven model’s improvement is more pronounced even without the match features. This shows that SNs can generalize well to not only the \"unseen\" entities but also the real story scenarios as in DSTC-2."
    }, {
      "heading" : "B. Results on Semi-Supervised Setting",
      "text" : "The question simulator generates question-answer pairs to scaffold the agent during learning to encode the information into dynamic memory, in a sense, it self-supervises! Such questions are used as labeled data at a specific turn. These questions can be simpler than the provided labeled questions, however, as in reward driven approach, they focus on the agent’s faults while generating questions. To investigate how the generated scaffolding questions contribute to the overall performance, we gradually reduced the amount of labeled data. We compare the reward driven scaffolding agent SN-RD against MemN2N. For the SN models, removing m% of training instances means that we replace their question-answer labels with the generated question-answer pairs during training. For MemN2N models, we used self-training by first removing m% of the training data, and training with the rest (100-m)% labeled data. Then we predict the labels for the removed m% data, add them back to the training data, re-train and repeat the process.\nIn Figure 2, we demonstrate the self-training results on bAbI QA Task 9,14,17 and DSTC-2 dialog tasks. We repeated the experiments 10 times and report the best results. Our models show promising results. Even when scaffolding models’ error rate is same or higher than the memory networks when 100% labeled data is used (Task 9 and 14), removing the labels does not affect the scaffolding models’ performance as much as the memory networks due to the self-training property of the reward-driven scaffold questioning."
    }, {
      "heading" : "C. Analysis on the Gating Function",
      "text" : "The gating functions in Equation 5 and 6 enable the amount of information flow as each sentence is processed, hence the scaffolding network learns to control the dynamic memory. With enough training and scaffolding through questioning, our hope is that it learns to keep track of the new but hidden facts as well as register and strengthen/weaken their relations. To visualize this, using our scaffolding agent we compare our gating function to other much simpler memory transferring methods between sentences, i.e., (i) summing the current and past memory, (ii) moving average of current and past memory (as explained in Section II-C).\nFigure 3 demonstrates the training success rate in accuracy over the number of episodes for Task-2 of bAbI QA data. In each episode we report average success rates of 100 randomly sampled train instances, i.e., 100 different [story,question,answer] pairs. Our gating function can learn to keep more rich information for the reasoning tasks."
    }, {
      "heading" : "VI. CONCLUSIONS",
      "text" : "Summary. We take a step towards teaching machines to comprehend by introducing an RL framework that simulates instructional scaffolding teaching. We found that by integrating the strengths of neural attention models and deep Q-networks we can repeatably check and update the agent about the information it encodes in sequential order. We additionally found after using a reward based question simulator that enables self-supervision, the network can continue to comprehend text even with reduced labeled data.\nLimitations and Future Work. Our results reveal the promise of scaffolding teaching of text based learning functions.\n8 Our model is far from perfect, and more work is needed to explore the processes humans use to learn to comprehend. Future work could use an adversarial training agent for generating questions about a story using the reward signal from another encoder agent. We hope to show results on larger datasets.\n9"
    }, {
      "heading" : "APPENDIX",
      "text" : ""
    }, {
      "heading" : "Appendix-A : Training Scaffolding Agent with Double DQN -",
      "text" : ""
    }, {
      "heading" : "Implementation Details",
      "text" : "The scaffolding network can use a rule-based or a reward driven question simulator. In Algorithm 1 below, we provide the details of the forward activation of the scaffolding network training using the reward-driven question simulator. Algorithm 1 focuses on the forward activation step where the experiences are stored and used by the q-network for training a policy. We use Double DQN (D-DQN) framework to train the scaffolding agent policy as presented in Algorithm 2. So, in Algorithm 1 we refer to Algorithm 2 that shows the pseudo code for policy learning.\nAs the network encodes each sentence from the input text of 1, . . . , T sentences, the question simulator sub-module of the scaffolding network generates one question. The corpora we use in this work include training and test datasets where the instances include list of tuples, i.e., (input text;question;answer). When the network is at the end of the text, and encoding the last sentence, the network does not consult the question simulator, but rather uses the question-answer pair as provided in the corpus. Thus, at time t = T , the network encodes the T th sentence along with the provided question and goes through one forward pass in Algorithm 1. Since the provided answer is used as the target answer, no answer sampling is required at the last step. But the provided question still needs to go through the question simulator LSTM in order (i) to obtain the probabilities of each of its words pT so they can be used to construct the state representation of time T , also (ii) to obtain the last hidden state vector hqt to send to the question-sentence encoder.\nAlgorithm 1 Forward Activation in Scaffolding Network Training with Reward Driven Question Simulator\nInput: Input text X={x1, ..., xT } of T sentences Output: State representation st ∈ S to be used by the D-DQN Parameters: 3-different LSTM weights; attention sub-module weights:{W x,Wh}; gating function weights:{WC ,WP }; q-network parameters:{θQ, θ′Q}; reward-driven simulator weights over fixed length question vector:β (Once at the beginning of the training) Initialize replay memory De and empty the initial dynamic memory vector h̃0 Initialize all weights randomly. Set r0 = 1, Γ max trials for t = 1 to T do\n- process LSTM(et) on sentence t’s word embeddings et to obtain hidden states ht,i for each word ( attention encoding ) - execute attention mt,i=φ(h̃t−1, ht,i) on each word using the dynamic memory from (t-1) to obtain attention vector of the sentence t, mt - γ=0 (trial constant for the agent) while rt<0 or γ < Γ do\n( question simulator ) - sample a candidate sentence xq∼ {x1, ..., xt−1} - process question LSTM(eq) on candidate sentence words to obtain hidden states hqt,i∈ h q t of each word - compute answer probabilities pt∝σ(βThqt ) - sample a∗i∼ P (a|h q t ) as the target variable - generate question based on the selected answer, obtain embedding vectors, eq , and process the question LSTM to obtain the last hidden state hqt ( question-sentence encoding ) - process Equation 1 and 2 to obtain joint query and sentence encodings - process LSTM(ẽt,0, ẽt) to obtain question-sentence encoding ot,i ∈ ot for each word ( q-network ) - concatenate the question-sentence, attention and candidate answer probabilities into current state representation: st = [mt;ot;pt] - run policy πθ,θ′ on {st = [mt;ot;pt], a∗t } and observe reward rt using Algorithm 2 - γ = γ+1 end while - calculate gate value gt using Equation 5 and update dynamic memory h̃t using Equation 6\nend for\n11\nAlgorithm 2 Training Scaffolding Agent with D-DQN 0: function: train Q(., .; .) network\nInput: Q (D-DQN), the T number of input sentences in text, input text X={x1, ..., xT } of T sentences, experience replay memory De Output: Learnt parameters θQ, θ′Q. for greedy exploration\nfor t = 1 to T do - Select randomly among parameters θQ←{θQ, θ′Q} - process input xt using Algorithm 1 to obtain st - With probability select random answer at ; otherwise, select answer at=maxa′ Q(st, a′; θQ) - Using the answer at, observe reward rt and successor state st+1 based on the answer being correct (read next sentence or stay on encoding the current one with a different generated question from the question simulator) - Store transition (st, at, rt, st+1) in De - Sample random mini-batch (sµ, aµ, rµ, sµ+1) transitions from De - Set yµ ← { rµ for terminal sµ+1\nrµ+1 + Θ for non-terminal sµ+1 where Θ=γmaxa′ Q(sµ+1,argmaxaQ(sµ+1, a; θQ); θ′Q) - Perform a gradient descent step (SGD): θQ ← θQ + α(yµ −Q(sµ, aµ; θ +Q)) OQ(Q(sµ, aµ; θQ))\nend for\n12"
    }, {
      "heading" : "Appendix-B : Details of the Travel Log Experiments",
      "text" : "The traveler is placed on a 9×9 grid town of 81 distinct locations with a list of attractions in randomly chosen locations. At each time step, the traveler’s next direction is chosen at random among 4 possible actions, e.g., north, south, east, west. If the selection puts the traveler off the grid, a new legal direction is chosen at random. Below we provide a sample travel log where the attractions are highlighted.\n1 moving to south 2 moving to west 3 there is a tower on my south 4 moving to south 5 i am at the tower 6 the museum is on my west 7 moving to west 8 i am at the museum 9 there is a tower on my east 10 moving to north 11 there is a tower on my south 12 continuing on north 13 there is a palace on my west 14 moving to west 15 i am at the palace 16 moving to north 17 on my west is a park 18 moving to west 19 i am at the park 20 moving to north 21 Question:What is west of the museum? Answer:palace\nWe use the following rules to generate the log data. The traveler visits each attraction only once. If the randomly chosen next direction takes the traveler to an attraction previously visited, a new random direction is chosen. If all the 4 directions contain attractions that are visited before, the log terminates. Once the traveler is in a new location, she looks at 4 immediate directions to log attractions. If there is no attraction, she continues on the next direction. Otherwise randomly chooses one attraction to log. We randomly generate different town layouts by varying the number of attractions, e.g., {5,10,15,20,25} and evaluate the performance of the models in the experiments.\nWe use all the words in the vocabulary except a list of stop words. The list of attractions and 4 different directions are used as the output space. If the attraction is a multi-word expression, we combine all the words. The question simulator of the scaffolding agent only uses the sentences that contain the location of the attractions to generate questions. During training, it samples a candidate sentence, then samples a possible answer from the words of this sentence that are either attractions or one of the four possible directions. For instance, the simulator selects sentence 17 above as candidate sentence to generate the question. Then it either picks west or park as candidate answer to generate on my ’unk’ is a park ? with west as target answer.\nIn Table III we demonstrate the output of the scaffolding network over a single log data selected from the travel log test dataset. The questions and answers generated by the\nquestion simulator and the rewards observed based on agent’s response are shown in each column. At any given time, as the network reads a sentence, the question generator samples a candidate sentence from the previously observed sentences. Then, using the reward-driven question generation, it samples a candidate answer from the words of the sampled sentence (see Section 2.4 for details.) This candidate answer is used as the target output for the current turn. Then, the current sentence, generated question and dynamic memory are encoded into state representation and sent to the agent. The agent runs through the policy and selects an answer, observes a reward as shown in the table. The agent’s decision determines if a next sentence should be read or the same sentence is encoded with a new question generated by the question simulator. If the reward is negative, the agent reads the same sentence, the question simulator samples a new sentence to generate a new question. This is to ensure that the agent learns to encode the information in the so far processed text by learning to correctly answer questions posed to it. At each trial, the agent’s decision changes the dynamic memory as well as the encoding of the next states. This step continues until a positive reward is observed, or a maximum of Γ trials are exhausted. In this example, we use Γ = 3. If the reward is positive it continues to read the next sentence. With the reward-driven approach the simulator asks questions that the agent didn’t get right in the past, helping it to learn to better encode the objects and relations through iteration."
    }, {
      "heading" : "Appendix-C : Example Dialog from the DSTC-2 Dataset",
      "text" : "Turn User Utterance (U) / System Response (S)\n1 (U) <SILENCE> (S) Hello , welcome to ... How may I help you ? 2 (U) i want a moderately priced restaurant that serves (S) What kind of food would you like? 3 (U) canapes food (S) What part of town do you have in mind? 4 (U) it doesnt matter (S) api-call canapes R-location moderate\n5 api-call no result 6 (U) <SILENCE>\n(S) yippee_noodle_bar is a nice restaurant in the centre of town in the moderate price range\n7 (U) gastropub food (S) Sorry there is no canapes restaurant in the moderate price range 8 (U) i want a gastropub restaurant (S) the cow pizza kitchen and bar is a nice restaurant in the centre of town serving gastropub food 9 (U) what is the address (S) Sure , the cow pizza kitchen and bar is on the-cowpizza-kitchen-and-bar-address\n10 (U) what is the phone number (S) The phone number of the cow pizza kitchen and bar is the-cow-pizza-kitchen-and-bar-phone 11 (U) what is the area (S) the cow pizza kitchen and bar is a nice place in the centre of town 12 (U) thank you goodbye (S) you are welcome\n13\n14"
    }, {
      "heading" : "Appendix-D : Additional Results on bAbI Tasks",
      "text" : "We provide some additional experiment results on the bAbI tasks to better understand the influence of (i) reward based answer selection for question generation versus rule-based answer selection, (iii) the degree of self-supervision, and (ii) the amount of training data. The results are presented in Table 4, 5, 6 and 7.\nIn most of these tasks, the scaffolding networks, SNs, either follow the best reported result or perform better. Based on the overall mean error measure for the 1K and 10K babi tasks, the reward driven SN model, SN-RD, competes well against the best performing EntNet and QRN models.\n15\n16"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "In scaffolding teaching, students are gradually asked<lb>questions to build background knowledge, clear up confusions,<lb>learn to be attentive, and improve comprehension. Inspired by<lb>this approach, we explore methods for teaching machines to learn<lb>to reason over text documents through asking questions about the<lb>past information. We address three key challenges in teaching and<lb>learning to reason: 1) the need for an effective architecture that<lb>learns from the information in text and keeps it in memory; 2) the<lb>difficulty of self-assessing what is learned at any given point and<lb>what is left to be learned; 3) the difficulty of teaching reasoning<lb>in a scalable way. To address the first challenge, we present the<lb>Scaffolding Network, an attention-based neural network agent<lb>that can reason over a dynamic memory. It learns a policy using<lb>reinforcement learning to incrementally register new information<lb>about concepts and their relations. For the second challenge,<lb>we describe a question simulator as part of the scaffolding<lb>network that learns to continuously question the agent about<lb>the information processed so far. Through questioning, the agent<lb>learns to correctly answer as many questions as possible. For<lb>the last challenge, we explore training with reduced annotated<lb>data. We evaluate on synthetic and real datasets, demonstrating<lb>that our model competes well with the state-of-the-art methods,<lb>especially when less supervision is used.",
    "creator" : "LaTeX with hyperref package"
  }
}