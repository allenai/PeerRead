{
  "name" : "1411.4023.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Automatic Generation of Alternative Starting Positions for Simple Traditional Board Games",
    "authors" : [ "Umair Z. Ahmed", "Krishnendu Chatterjee", "Sumit Gulwani" ],
    "emails" : [ "umair@iitk.ac.in", "krishnendu.chatterjee@ist.ac.at", "sumitg@microsoft.com" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Board games involve placing pieces on a pre-marked surface or board according to a set of rules by taking turns. Some of these grid-based two-player games like Tic-Tac-Toe and CONNECT-4 have a relatively simple set of rules, yet, they are decently challenging for certain age groups. Such games have been immensely popular across centuries.\nStudies show that board games can significantly improve a child’s mathematical ability (Ramani and Siegler 2008). Such early differences in mathematical ability persist into secondary education (Duncan et al. 2007). Board games also assist with emotional and social development of a child. They instill a competitive desire to master new skills in order to win. Winning gives a boost to their self confidence. Playing a game within a set of rules helps them to adhere to discipline in life. They learn social etiquette; taking turns, and being patient. Strategy is another huge component of board games. Children learn cause and effect by observing that decisions they make in the beginning of the game have consequences later on.\nBoard games help elderly people stay mentally sharp and less likely to develop Alzheimer (Gottlieb 2003). They also hold a great importance in today’s digital society by strengthening family ties. They bridge the gap between\nyoung and old. They bolster the self-esteem of children who take great pride and pleasure when an elder spends playing time with them.\nSignificance of Generating Fresh Starting States Board games are typically played with a default start state (e.g., empty board in case of Tic-Tac-Toe and CONNECT4). However, there are following drawbacks in starting from the default starting state, which we use to motivate our goals. Customizing hardness level of a start state. The default starting state for a certain game, while being unbiased, might not be conducive for a novice player to enjoy and master the game. Traditional board games in particular are easy to learn but difficult to master because these games have intertwined mechanics and force the player to consider far too many possibilities from the standard starting configurations. Players can achieve mastery most effectively if complex mechanics can be simplified and learned in isolation. Csikszentmihalyi’s theory of flow (Csikszentmihalyi 1991) suggests that we can keep the learner in a state of maximal engagement by continually increasing difficulty to match the learner’s increasing skill. Hence, we need an approach that allows generating start states of a specified hardness level. This capability can be used to generate a progression of starting states of increasing hardness. This is similar to how students are taught educational concepts like addition through a progression of increasingly hard problems (Andersen, Gulwani, and Popovic 2013). Leveling the playing field. The starting state for commonly played games is mostly unbiased, and hence does not offer a fair experience for players of different skills. The flexibility to start from some other starting state that is more biased towards the weaker player can allow for leveling the playing field and hence a more enjoyable game. Hence, we need an approach that takes as input the expertise levels of players and uses that information to associate a hardness level with a state. Generating multiple fresh start states. A fixed starting state might have a well-known conclusion. For example, both players can enforce a draw in Tic-Tac-Toe while the first player can enforce a win in CONNECT-4 (Allis 1988), starting from the default empty starting state. Players can memorize certain moves from a fixed starting state ar X iv :1 41 1. 40 23 v1 [ cs .A I] 1 4 N\nov 2\n01 4\nand gain undue advantage. Hence, we need an approach that generates multiple start states (of a specified hardness level). This observation has also inspired the design of Chess960 (Wikipedia 2014) (or Fischer Random Chess), which is a variant of chess that employs the same board and pieces as standard chess; however, the starting position of the pieces on the players’ home ranks is randomized. The random setup renders the prospect of obtaining an advantage through memorization of opening lines impracticable, compelling players to rely on their talent and creativity. Customizing length of play. People sometimes might be disinterested in playing a game if it takes too much time to finish. However, selecting non-default starting positions allow the potential of a shorter game play. Certain interesting situations might manifest only in states that are typically not easily reachable from the start state, or require too many steps. The flexibility to start from such states might lead to more opportunities for practice of specific targeted strategies. Thus, we need an approach that can take as input a parameter for the number of steps that can lead to a win for a given player. Experimenting with game variants. While people might be hesitant to learn a game with completely different new rules, it is quite convenient to change the rules slightly. For example, instead of allowing for straight-line matches in each of row, column, or diagonal (RCD) in Tic-Tac-Toe or CONNECT-4, one may restrict the matches to say only row or diagonal (RD). However, the default starting state of a new game may be heavily biased towards a player; as a result that specific game might not have been popular. For example, consider the game of Tic-Tac-Toe (3,4,4), where the goal is to make a straight line of 3 pieces, but on a 4× 4 board. In this game, the person who plays first invariably almost always wins even with a naive strategy. Hence, such a game has never been popular. However, there can be non-default unbiased states for such games and starting from those states can make playing such games interesting. Hence, we need an approach that is parameterized by the rules of a game. This also has the advantage of experimenting with new games or variants of existing games.\nProblem Definition and Search Strategy We address the problem of automatically generating interesting starting states (i.e., states of desired hardness levels) for a given two-player board game. Our approach takes as input the rules of a board game (for game variants) and the desired number of steps required for player 1 to win (for controlling the length of play). It then generates multiple starting states of varying hardness levels (in particular, easy, medium, or hard) for player 1 for various expertise level combinations of the two players. We formalize the exploration of a game as a strategy tree and the expertise level of a player as depth of the strategy tree. The hardness of a state is defined w.r.t. the fraction of times player 1 will win, while playing a strategy of depth k1 against an opponent who plays a strategy of depth k2.\nOur solution employs a novel combination of symbolic methods and iterative simulation to efficiently search for\ndesired states. Symbolic methods are used to compute the winning set for player 1. These methods work particularly well for navigating a state space where the transition relation forms a sparse directed acyclic graph (DAG). Such is the case for those board games in which a piece once placed on the board doesn’t move, as in Tic-Tac-Toe and CONNECT4. Minimax simulation is used to identify the hardness of a given winning state. Instead of randomly sampling the winning set to identify a state of a certain hardness level, we identify states of varying hardness levels in order of increasing values of k1 and k2. The key observation is that hard states are much fewer than easy states, and for a given k2, interesting states for higher values of k1 are a subset of hard states for smaller values of k1.\nContributions • We introduce and study a novel aspect of graph games,\nnamely generation of starting states. In particular, we address the problem of generating starting states of varying hardness levels parameterized by look-ahead depth of the strategies of the two players, the graph game description, and the number of steps required for winning (§2). • We present a novel search methodology for generating desired initial states. It involves combination of symbolic methods and iterative simulation to efficiently search a huge state space (§3). • We present experimental results that illustrate the effectiveness of our search methodology (§5). We produce a collection of initial states of varying hardness levels for standard games as well as their variants (thereby discovering some interesting variants of the standard games in the first place). While our search methodology applies to any graph game; in our experiments we focus on generating starting states in simple board games and their variants as opposed to games with complicated rules. Games with complicated rules are hard to learn, whereas simple variants of traditional games are easier to adopt. The problem of automated generation of starting states should also be experimented for complex games as future work; however, given that this problem has not even been studied for simple games in the past, and our approach makes valuable discovery for simple games, is a key contribution of this paper."
    }, {
      "heading" : "2 Problem Definition",
      "text" : ""
    }, {
      "heading" : "2.1 Background on Graph Games",
      "text" : "Graph games. An alternating graph game (for short, graph game) G = ((V,E), (V1, V2)) consists of a finite graph G with vertex set V , a partition of the vertex set into player1 vertices V1 and player-2 vertices V2, and edge set E ⊆ ((V1×V2)∪(V2×V1)). The game is alternating in the sense that the edges of player-1 vertices go to player-2 vertices and vice-versa. The game is played as follows: the game starts at a starting vertex v0; if the current vertex is a player-1 vertex, then player 1 chooses an outgoing edge to move to a new vertex; if the current vertex is a player-2 vertex, then player 2 does likewise. The winning condition is given by a target set T1 ⊆ V for player 1; and similarly a target set T2 ⊆ V for\nplayer 2. If the target set T1 is reached, then player 1 wins; if T2 is reached, then player 2 wins; else we have a draw. Examples. The class of graph games provides the mathematical framework to study many board games like Chess or Tic-Tac-Toe. For example, in Tic-Tac-Toe the vertices of the graph represent the board configurations and whether it is player 1 (×) or player 2 (◦) to play next. The set T1 (resp. T2) is the set of board configurations with three consecutive × (resp. ◦) in a row, column, or diagonal. Classical game theory result. A classic result in the theory of graph games (Gale and Stewart 1953) shows that for every graph game with respective target sets for both players, from every starting vertex one of the following three conditions hold: (1) player 1 can enforce a win no matter how player 2 plays (i.e., there is a strategy for player 1 to play to ensure winning against all possible strategies of the opponent); (2) player 2 can enforce a win no matter how player 1 plays; or (3) both players can enforce a draw (player 1 can enforce a draw no matter how player 2 plays, and player 2 can enforce a draw no matter how player 1 plays). The classic result (aka determinacy) rules out the following possibility: against every player-1 strategy, player 2 can win; and against every player-2 strategy, player 1 can win. In the mathematical study of game theory, the theoretical question (which ignores the notion of hardness) is as follows: given a designated starting vertex v0 determine whether case (1), case (2), or case (3) holds. In other words, the mathematical game theoretic question concerns the best possible way for a player to play to ensure the best possible result. The set Wj is defined as the set of vertices such that player 1 can ensure to win within j-moves; and the winning set W 1 of vertices of player 1 is the set ⋃ j≥0Wj where player 1 can win in any number of moves. Analogously, we define W 2; and the classical game theory question is formally stated as follows: given a designated starting vertex v0 decide whether v0 belongs to W 1 (player-1 winning set) or to W 2 (player-2 winning set) or to V \\ (W 1 ∪W 2) (both players draw ensuring set)."
    }, {
      "heading" : "2.2 Formalization of Problem Definition",
      "text" : "Notion of hardness. The mathematical game theoretic question ignores two aspects. (1) The notion of hardness: It is concerned with optimal strategies irrespective of hardness; and (2) the problem of generating different starting vertices. We are interested in generating starting vertices of different hardness. The hardness notion we consider is the depth of the tree a player can explore, which is standard in artificial intelligence. Tree exploration in graph games. Consider a player-1 vertex u0. The search tree of depth 1 is as follows: we consider a tree rooted at u0 such that children of u0 are the vertices u1 of player 2 such that (u0, u1) ∈ E (there is an edge from u0 to u1); and for every vertex u1 (that is a children of u0) the children of u1 are the vertices u2 such that (u1, u2) ∈ E, and they are the leaves of the tree. This gives us the search tree of depth 1, which intuitively corresponds to exploring one round of the play. The search tree of depth k + 1 is defined inductively from the search tree of depth k, where we\nfirst consider the search tree of depth 1 and replace every leaf by a search tree of depth k. The depth of the search tree denotes the depth of reasoning (analysis depth) of a player. The search tree for player 2 is defined analogously.\nStrategy from tree exploration. A depth-k strategy of a player that does a tree exploration of depth k is obtained by the classical min-max reasoning (or backward induction) on the search tree. First, for every vertex v of the game we associate a number (or reward) r(v) that denotes how favorable is the vertex for a player to win. Given the current vertex u, a depth-k strategy is defined as follows: first construct the search tree of depth k and evaluate the tree bottom-up with min-max reasoning. In other words, a leaf vertex v is assigned reward r(v), where the reward function r is game specific, and intuitively, r(v) denotes how “close” the vertex v is to a winning vertex (see the following paragraph for an example). For a vertex in the tree if it is a player-1 (resp. player-2) vertex we consider its reward as the maximum (resp. minimum) of its children, and finally, for vertex u (the root) the strategy chooses uniformly at random among its children with the highest reward. Note that the rewards are assigned to vertices only based on the vertex itself without any look-ahead, and the exploration is captured by the classical min-max tree exploration.\nExample description of tree exploration. Consider the example of the Tic-Tac-Toe game. We first describe how to assign reward r to board positions. Recall that in the game of Tic-Tac-Toe the goal is to form a line of three consecutive positions in a row, column, or diagonal. Given a board position, (i) if it is winning for player 1, then it is assigned reward +∞; (ii) else if it is winning for player 2, then it is assigned reward−∞; (iii) otherwise it is assigned the score as follows: let n1 (resp. n2) be the number of two consecutive positions of marks for player 1 (resp. player 2) that can be extended to satisfy the winning condition. Then the reward is the difference n1 − n2. Intuitively, the number n1 represents the number of possibilities for player 1 to win, and n2 represents the number of possibilities for player 2, and their difference represents how favorable the board position is for player 1. If we consider the depth-1 strategy, then the strategy chooses all board positions uniformly at random; a depth-2 strategy chooses the center and considers all other positions to be equal; a depth-3 strategy chooses the center and also recognizes that the next best choice is one of the four corners. An illustration is given in the appendix. This example illustrates that as the depth increases, the strategies become more intelligent for the game.\nOutcomes and probabilities given strategies. Given a starting vertex v, a depth-k1 strategy σ1 for player 1, and depth-k2 strategy σ2 for player 2, let O be the set of possible outcomes, i.e., the set of possible plays given σ1 and σ2 from v, where a play is a sequence of vertices. The strategies and the starting vertex define a probability distribution over the set of outcomes which we denote as Prσ1,σ2v , i.e., for a play ρ in the set of outcomes O we have Prσ1,σ2v (ρ) is the probability of ρ given the strategies. Note that strategies are randomized (because strategies choose distributions over the children in the search tree exploration), and hence define a\nprobability distribution over the set of outcomes. This probability distribution is used to formally define the notion of hardness we consider. Problem definition. We consider several board games (such as Tic-Tac-Toe, CONNECT-4, and variants), and our goal is to obtain starting positions that are of different hardness levels, where our hardness is characterized by strategies of different depths. Precisely, consider a depth-k1 strategy for player 1, and depth-k2 strategy for player 2, and a starting vertex v ∈ Wj that is winning for player 1 within j-moves and a winning move (i.e., j + 1 moves for player 1 and j moves of player 2). We classify the starting vertex as follows: if player 1 wins (i) at least 23 times, then we call it easy (E); (ii) at most 13 times, then we call it hard (H); (iii) otherwise medium (M). Definition 1 ((j, k1, k2)-Hardness). Consider a vertex v ∈ Wj that is winning for player 1 within j-moves. Let σ1 and σ2 be a depth-k1 strategy for player 1 and depth-k2 strategy for player 2, respectively. LetO1 ⊆ O be the set of plays that belong to the set of outcomes and is winning for player 1. Let Prσ1,σ2v (O1) = ∑ ρ∈O1 Pr σ1,σ2 v (ρ) be the probability of the winning plays. The (k1, k2)-classification of v is: (i) if Prσ1,σ2v (O1) ≥ 23 , then v is easy (E); (ii) if Pr σ1,σ2 v (O1) ≤ 1 3 , then v is hard (H); (iii) otherwise it is medium (M). Remark 1. In the definition above we chose the probabilities 1 3 and 2 3 , however, the probabilities in the definition could be easily changed and experimented. We chose 13 and 2 3 to divide the interval [0, 1] symmetrically in regions of E, M, and H. In this work, we present result based on the above definition.\nOur goal is to consider various games and identify vertices of different categories (hard for depth-k1 vs. depth-k2, but easy for depth-(k1+1) vs. depth-k2, for small k1 and k2). Remark 2. In this work we consider classical min-max reasoning for tree exploration. A related notion is Monte Carlo Tree Search (MCTS) which in general converges to minmax exploration, but can take a long time. However, this convergence is much faster in our setting, since we consider simple games that have great symmetry, and explore only small-depth strategies."
    }, {
      "heading" : "3 Search Strategy",
      "text" : ""
    }, {
      "heading" : "3.1 Overall methodology",
      "text" : "Generation of j-steps win set. Given a game graph G = ((V,E), (V1, V2)) along with target sets T1 and T2 for player 1 and player 2, respectively, our first goal is to compute the set of vertices Wj such that player 1 can win within j-moves. For this we define two kinds of predecessor operators: one predecessor operator for player 1, which uses existential quantification over successors, and one for player 2, which uses universal quantification over successors. Given a set of vertices X , let EPre(X) (called existential predecessor) denote the set of player-1 vertices that has an edge to X; i.e., EPre(X) = {u ∈ V1 | there exists v ∈ X such that (u, v) ∈ E} (i.e., player 1 can ensure to reach X from EPre(X) in one step); and APre(X) (called universal predecessor) denote the set of player-2 vertices that has\nall its outgoing edges to X; i.e., APre(X) = {u ∈ V2 | for all (u, v) ∈ E we have v ∈ X} (i.e., irrespective of the choice of player 2 the set X is reached from APre(X) in one step). The computation of the set Wj is defined inductively: W0 = EPre(T1) (i.e., player 1 wins with the next move to reach T1); and Wi+1 = EPre(APre(Wi)). In other words, from Wi player 1 can win within i-moves, and from APre(Wi) irrespective of the choice of player 2 the next vertex is in Wi; and hence EPre(APre(Wi)) is the set of vertices such that player 1 can win within (i+ 1)-moves. Exploring vertices from Wj . The second step is to explore vertices from Wj , for increasing values of j starting with small values of j. Formally, we consider a vertex v from Wj , consider a depth-k1 strategy for player 1 and a depth-k2 strategy for player 2, and play the game multiple times with starting vertex v to find out the hardness level with respect to (k1, k2)-strategies, i.e., the (k1, k2)-classification of v. Note that from Wj player 1 can win within j-moves. Thus the approach has the benefit that player 1 has a winning strategy with a small number of moves and the game need not be played for long. Two key issues. There are two main computational issues associated with the above approach in practice. The first issue is related to the size of the state space (number of vertices) of the game which makes enumerative approach to analyze the game graph explicitly computationally infeasible. For example, the size of the state space of Tic-TacToe 4 × 4 game is 6,036,001; and a CONNECT-4 5 × 5 game is 69,763,700 (above 69 million). Thus any enumerative method would not work for such large game graphs. The second issue is related to exploring the vertices from Wj . If Wj has a lot of witness vertices, then playing the game multiple times from all of them will be computationally expensive. So we need an initial metric to guide the search of vertices from Wj such that the metric computation is inexpensive. We solve the first issue with symbolic methods, and the second one by iterative simulation."
    }, {
      "heading" : "3.2 Symbolic methods",
      "text" : "We discuss the symbolic methods to analyze games with large state spaces. The key idea is to represent the games symbolically (not with explicit state space) using variables, and operate on the symbolic representation. The key object used in symbolic representation are called BDDs (boolean decision diagrams) (Bryant 1986) that can efficiently represent a set of vertices using a DAG representation of a boolean formula representing the set of vertices. The tool CUDD supports many symbolic representation of state space using BDDs and supports many operations on symbolic representation on graphs using BDDs (Somenzi 1998). Symbolic representation of vertices. In symbolic methods, a game graph is represented by a set of variables x1, x2, . . . , xn such that each of them takes values from a finite set (e.g., ×, ◦, and blank symbol); and each vertex of the game represents a valuation assigned to the variables. For example, the symbolic representation of the game of Tic-Tac-Toe of board size 3 × 3 consists of ten variables x1,1, x1,2, x1,3, x2,1 . . . , x3,3, x10, where the first nine vari-\nables xi,` denote the symbols in the board position (i, `) and the symbol is either ×, ◦, or blank; and the last variable x10 denotes whether it is player 1 or player 2’s turn to play. Note that the vertices of the game graph not only contains the information about the board configuration, but also additional information such as the turn of the players. To illustrate how a symbolic representation is efficient, consider the set of all valuations to boolean variables y1, y2, . . . , yn where the first variable is true, and the second variable is false: an explicit enumeration requires to list 2n−2 valuations, where as a boolean formula representation is very succinct. Symbolic representation with BDDs exploit such succinct representation for sets of vertices, and are used in many applications, e.g. hardware verification (Bryant 1986).\nSymbolic encoding of transition function. The transition function (or the edges) are also encoded in a symbolic fashion: instead of specifying every edge, the symbolic encoding allows to write a program over the variables to specify the transitions. The tool CUDD takes such a symbolic description written as a program over the variables and constructs a BDD representation of the transition function. For example, for Tic-Tac-Toe, a program to describe the symbolic transition is: the program maintains a set U of positions of the board that are already marked; and at every point receives an input (i, `) from the set {(a, b) | 1 ≤ a, b ≤ 3} \\ U of remaining board positions from the player of the current turn; then adds (i, `) to the set U and sets the variable xi,` as × or ◦ (depending on whether it was player 1 or player 2’s turn). This gives the symbolic description of the transition function. Symbolic encoding of target vertices. The set of target vertices is encoded as a boolean formula that represents a set of vertices. For example, in Tic-Tac-Toe the set of target vertices for player 1 is given by the following boolean formula:\n∃i, `. 1 ≤ i, ` ≤ 3. (xi,` = × ∧ xi+1,` = × ∧ xi+2,` = ×) ∨(xi,` = × ∧ xi,`+1 = × ∧ xi,`+2 = ×) ∨(x2,2 = ×∧ ((x1,1 = × ∧ x3,3 = ×) ∨(x3,1 = × ∧ x1,3 = ×))) ∧ Negation of above with ◦ to specify player 2 not winning\nThe above formula states that either there is some column (xi,`, xi+1,` and xi+2,`) that is winning for player 1; or a row (xi,`, xi,`+1 and xi,`+2) that is winning for player 1; or there is a diagonal (x1,1, x2,2 and x3,3; or x3,1, x2,2 and x1,3) that is winning for player 1; and player 2 has not won already. To be precise, we also need to consider the BDD that represents all valid board configurations (reachable vertices from the empty board) and intersect the BDD of the above formula with valid board configurations to obtain the target set T1.\nSymbolic computation of Wj . The symbolic computation of Wj is as follows: given the boolean formula for the target set T1 we obtain the BDD for T1; and the CUDD tool supports both EPre and APre as basic operations using symbolic functions; i.e., the tool takes as input a BDD representing a set X and supports the operation to return the BDD for EPre(X) and APre(X). Thus we obtain the symbolic computation of Wj ."
    }, {
      "heading" : "3.3 Iterative simulation",
      "text" : "We now describe a computationally inexpensive way to aid sampling of vertices as candidates for starting positions of a given hardness level. Given a starting vertex v, a depth-k1 strategy for player 1, and a depth-k2 strategy for player 2, we need to consider the tree exploration of depth max{k1, k2} to obtain the hardness of v. Hence if either of the strategy is of high depth, then it is computationally expensive. Thus we need a preliminary metric that can be computed relatively easily for small values of k1 and k2 as a guide for vertices to be explored in depth. We use a very simple metric for this purpose. The hard vertices are rarer than the easy vertices, and thus we rule out easy ones quickly using the following approach: If k1 is large: Given a strategy of depth k2, the set of hard vertices for higher values of k1 are a subset of the hard vertices for smaller values of k1. Thus we iteratively start with smaller values and proceed to higher values of k1 only for vertices that are already hard for smaller values of k1. If k2 is large: Here we exploit the following intuition. Given a strategy of depth k1, a vertex which is hard for high value of k2 is likely to show indication of hardness already in small values of k2. Hence we consider the following approach. For the vertices inWj , we fix a depth-k1 strategy, and fix a small depth strategy for the opponent and assign the vertex a number (called score) based on the performance of the depth-k1 strategy and the small depth strategy of the opponent. The score indicates the fraction of games won by the depth-k1 strategy against the opponent strategy of small depth. The vertices that have low score are then iteratively simulated against depth-k2 strategies of the opponent to obtain vertices of different hardness level. This heuristic serves as a simple metric to explore vertices for large value of k2 starting with small values of k2."
    }, {
      "heading" : "4 Framework for Board Games",
      "text" : "We now consider the specific problem of board games. We describe a framework to specify several variants of two-player grid-based board games such as Tic-Tac-Toe, CONNECT-4. Different parameters. Our framework allows three different parameters to generate variants of board games. (1) The first parameter is the board size; e.g., the board size could be 3×3; or 4×4; or 4×5 and so on. (2) The second parameter is the way to specify the winning condition, where a player wins if a sequence of the player’s moves are in a line, which could be along a row (R), a column (C), or the diagonal (D). The user can specify any combination: (i) RCD (denoting the player wins if the moves are in a line along a row, column or diagonal); (ii) RC (line must be along a row or column, but diagonal lines are not winning); (iii) RD (row or diagonal, not column); or (iv) CD (column or diagonal, not row). (3) The third parameter is related to the allowed moves of the player. At any point the players can choose any available column (i.e., column with at least one empty position) but can be restricted according to the following parameters: (i) Full gravity (once a player chooses a column, the move is fixed to be the lowest available position in that column);\n(ii) partial gravity-` (once a player chooses a column, the move can be one of the bottom-` available positions in the column); or (iii) no gravity (the player can choose any of the available positions in the column). Observe that Tic-Tac-Toe is given as (i) board size 3× 3; (ii) winning condition RCD; and (iii) no-gravity; whereas in CONNECT-4 the winning condition is still RCD but moves are with full gravity. But in our framework there are many new variants of the previous classical games, e.g., Tic-Tac-Toe in a board of size 4×4 but diagonal lines are not winning (RC); and Bottom-2 (partial gravity-2) which is between Tic-Tac-Toe and CONNECT games in terms of moves allowed.\nFeatures of our implementation. We have implemented our approach and the main features that our implementation supports are: (1) Generation of starting vertices of different hardness level if they exist. (2) Playing against opponents of different levels. We have implemented the depth-k2 strategy of the opponent for k2 = 1, 2 and 3 (typically in all the above games depth-3 strategies are quite intelligent, and hence we do not explore larger values of k2). Thus, a learner (beginner) can consider starting with board positions of various hardness levels and play with opponents of different skill level and thus hone her ability to play the game and be exposed to new combinatorial challenges of the game."
    }, {
      "heading" : "5 Experimental Results",
      "text" : "Our experiments reveal useful discoveries. The main aim is to investigate the existence of interesting starting ver-\ntices and their abundance in CONNECT, Tic-Tac-Toe, and Bottom-2 games, for various combinations of expertise levels and winning rules (RCD, RC, RD, and CD), for small lengths of plays. Moreover, the computation time should be reasonable. Description of tables. The caption of Table 1 describes the column headings used in Tables 1-3, which describe the experimental results. In our experiments, we explore vertices fromW2 andW3 only as the setW4 is almost always empty. The third column j = 2, 3 denotes whether we explore from W2 or W3. For the classification of a board position, we run the game between the depth-k1 vs the depth-k2 strategy for 30 times. If player 1 wins (i) more than 23 times (20 times), then it is identified as easy (E); (ii) less than 13 times (10 times), then it is identified as hard (H); (iii) else as medium (M). Experimental results for CONNECT games. Table 1 presents results for CONNECT-3 and CONNECT-4 games, against depth-3 strategies of the opponent. An interesting finding is that in CONNECT-4 games with board size 5×5, for all winning conditions (RCD, RD, CD, RC), there are easy, medium, and hard vertices, for k1=1,2, and 3, when j=3. In other words, even in much smaller board size (5×5 as compared to the traditional 7×7) we discover interesting starting positions for CONNECT-4 games and its simple variants. Experimental results for Bottom-2 games. Table 2 shows the results for Bottom-2 (partial gravity-2) against depth-3 strategies of the opponent. In contrast to CONNECT games, medium or hard vertices do not exist for depth-3 strategies. Experimental results for Tic-Tac-Toe games. The results for Tic-Tac-Toe games are shown in Table 3. For Tic-TacToe games the strategy exploration is expensive (a tree of depth-3 for 4× 4 requires exploration of 106 nodes). Hence using the iterative simulation techniques we first assign a score to all vertices and use exploration for bottom hundred vertices (B100), i.e., hundred vertices with the least score according to our iterative simulation metric. In contrast to CONNECT games, interesting vertices exist only for depth1 strategies.\nRunning times. The generation of Wj for j=2,3 took between 2-4 hours per game (this is a one-time computation for each game). The time to classify a vertex as E, M, or H for depth-3 strategies of both players, playing 30 times from a board position on average varies between 12 sec. (for CONNECT-4 games) to 25 min. for Tic-Tac-Toe games. Details for depth-2 strategy of the opponent are given in the appendix.\nImportant findings. Our first key finding is the existence of vertices of different hardness levels in various games. We observe that in Tic-Tac-Toe games only board positions that are hard for k1 = 1 exist; in particular, and very interestingly, they also exist in board of size 4×4. Since the default start (the blank) vertex in 4× 4 Tic-Tac-Toe games is heavily biased towards the player who starts first, they have been believed to be uninteresting for ages, whereas our experiments discover interesting starting vertices for them. With the slight variation of allowable moves (Bottom-2), we obtain board positions that are hard for k1 = 2. In Connect-4 we obtain vertices that are hard for k1 = 3 even with small board size of 5×5. The default starting vertex in Tic-Tac-Toe 3 × 3 and Connect-4 5 × 5 does not belong to the winning set Wj ; in Tic-Tac-Toe 4 × 4 it belongs to the winning set Wj and is Easy for all depth strategies.\nThe second key finding of our results is that the number of interesting vertices is a negligible fraction of the huge state space. For example, in Bottom-2 RCD games with board size 4 × 4 the size of the state space is over 1.8 million, but has only two positions that are hard for k1 = 2; and in\nCONNECT-4 RCD games with board size 5 × 5 the state space size is around sixty nine million, but has around two hundred hard vertices for k1 = 3 and k2 = 3, when j = 3, among the five thousand vertices sampled from Wj . Since the size of Wj in this case is around 2.8 × 105, the total number of hard vertices is around twelve thousand (among sixty nine million state space size). Since the interesting positions are quite rare, a naive approach of randomly generating positions and measuring its hardness will be searching for a needle in a haystack and be ineffective to generate interesting positions. Thus there is need for a non-trivial search strategy (§3), which our tool implements. Example board positions. In Figure 1(a)-Figure 1(f) we present examples of several board positions that are of different hardness level for strategies of certain depth. Also see appendix for an illustration. In all the figures, player-X is the current player against opponent of depth-3 strategy. All these board positions were discovered through our experiments."
    }, {
      "heading" : "6 Related Work",
      "text" : "Tic-Tac-Toe and Connect-4. Tic-Tac-Toe has been generalized to different board sizes, match length (Ma 2014), and even polyomino matches (Harary 1977) to find variants that are interesting from the default start state. Existing research has focussed on establishing which of these games have a winning strategy (Gardner 1979; Gardner 1983; Weisstein 2014). In contrast, we show that even simpler variants can be interesting if we start from certain specific states. Connect-4 research has also focussed on establishing a winning strategy from the default starting state (Allis 1988). In contrast, we study how easy or difficult is to win from winning states given expertise levels.\nBDDs have been used to represent board games before (Kissmann and Edelkamp 2011) to perform MCTS run with Upper Confidence Bounds applied to Trees (UCT). However, the goal was instantiation of the BDDs and finding the number of states explored by a single agent. In our setting we have two players, and use BDDs to compute the winning set. Level generation. Goldspinner (Williams-King et al. 2012) is a level generation system for KGoldrunner, a puzzle game with dynamic elements. It uses a genetic algorithm to generate candidate levels and simulation to evaluate dynamic aspects of the game. We also use simulation to evaluate the dy-\nnamic aspect, but use symbolic methods to generate candidate states; also, our system is parameterized by game rules.\nMost other work has been restricted to games without opponent and dynamic content such as Sudoku (Hunt, Pong, and Tucker 2007; XUE et al. 2009). Smith et al. used answer-set programming to generate levels for Refraction that adhered to pre-specified constraints written in first-order logic (Smith et al. 2012). Similar approaches have also been used to generate levels for platform games (Smith et al. 2009). In these approaches, designers must explicitly specify constraints on the generated content, e.g., the tree needs to be near the rock and the river needs to be near the tree. In contrast, our system takes as input rules of the game and does not require any further help from the designer. (Andersen, Gulwani, and Popovic 2013) also uses a similar model and applies symbolic methods (namely, test input generation techniques) to generate various levels for DragonBox, which became the most purchased game in Norway on the Apple App Store (Liu 2012). In contrast, we use symbolic methods for generating start states, and use simulation for estimating their hardness level. Problem generation. Automatic generation of fresh problems can be a key capability in intelligent tutoring systems (Gulwani 2014). The technique for generation of algebraic proof problems (Singh, Gulwani, and Rajamani 2012) uses probabilistic testing to guarantee the validity of a generated problem candidate (from abstraction of the original problem) on random inputs, but there is no guarantee of the hardness level. Our simulation can be linked to this probabilistic testing approach, but it is used to guarantee hardness level; whereas validity is guaranteed by symbolic methods. The technique for generation of natural deduction problems (Ahmed, Gulwani, and Karkare 2013) and (Alvin et al. 2014) involves a backward existential search over the state space of all possible proofs for all possible facts to dish out problems with a specific hardness level. In contrast, we employ a two-phased strategy of backward and forward search; backward search is necessary to identify winning states, while forward search ensures hardness levels. Furthermore, our state transitions alternate between different players, thereby necessitating alternate universal vs. existential search over transitions.\nInteresting starting states that require few steps to play and win are often published in newspapers for sophisticated games like Chess and Bridge. These are usually obtained from database of past games. In contrast, we show how to automatically generate such states, albeit for simpler games. Acknowledgments. The research was partly supported by Austrian Science Fund (FWF) Grant No P23499- N23, FWF NFN Grant No S11407-N23 (RiSE), ERC Start grant (279307: Graph Games), and Microsoft faculty fellows award."
    }, {
      "heading" : "A Appendix",
      "text" : "Strategies. A strategy for a player is a rule that specifies how to extend plays. Formally, a strategy σ1 for player 1 is a function σ1: V ∗ ·V1 → D(V ), whereD(V ) denote the set of probability distributions over V , that given a finite sequence of vertices (representing the history of the play so far) which ends in a player 1 vertex, chooses a probability distribution for the next vertex. The strategy must choose only available successors, i.e., for all w ∈ V ∗ and v ∈ V1 we have that if σ1(w · v)(u) > 0, then (v, u) ∈ E. The strategies σ2 for player 2 are defined analogously.\nSummary and details of running time. We summarize our results in Table 7. We call a state category-i state if it is not easy for depth-(i−1) strategy, but it is easy for depth-i strategy. In Table 7 we summarize the different games and the existence of category i states in such games. The generation of Wj for j = 2 and j = 3 took between two to four hours per game (note that this is a one-time computation for each game). The evaluation time to classify a state as E, M, or H is as follows: for depth-3 strategies of both players, playing 30 times from a board position on average takes (i) 12 seconds for CONNECT-4 games with board size 5 × 5; (ii) 47 seconds for Bottom-2 games with board size 4× 4; and (iii) 25 minutes for Tic-Tac-Toe games with board size 4 × 4. Note that the size of the state space is around 108 for CONNECT4 games with board size 5×5, and testing the winning nature of a state takes at least few seconds. Hence an explicit enumeration of the state space cannot be used to obtain Wj in reasonable time; in contrast, our symbolic methods succeed to compute Wj efficiently."
    } ],
    "references" : [ {
      "title" : "A",
      "author" : [ "U.Z. Ahmed", "S. Gulwani", "Karkare" ],
      "venue" : "2013. Automatically generating problems and solutions for natural deduction. In Proceedings of the Twenty-Third international joint conference on Artificial Intelligence, 1968–",
      "citeRegEx" : "Ahmed. Gulwani. and Karkare 2013",
      "shortCiteRegEx" : null,
      "year" : 1975
    }, {
      "title" : "Synthesis of geometry proof problems",
      "author" : [ "Alvin" ],
      "venue" : null,
      "citeRegEx" : "Alvin,? \\Q2014\\E",
      "shortCiteRegEx" : "Alvin",
      "year" : 2014
    }, {
      "title" : "A trace-based framework for analyzing and synthesizing educational progressions",
      "author" : [ "Gulwani Andersen", "E. Popovic 2013] Andersen", "S. Gulwani", "Z. Popovic" ],
      "venue" : "In Proceedings of the SIGCHI Conference on Human Factors in Computing Systems,",
      "citeRegEx" : "Andersen et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Andersen et al\\.",
      "year" : 2013
    }, {
      "title" : "School readiness and later achievement. Developmental psychology 43(6):1428",
      "author" : [ "Duncan" ],
      "venue" : null,
      "citeRegEx" : "Duncan,? \\Q2007\\E",
      "shortCiteRegEx" : "Duncan",
      "year" : 2007
    }, {
      "title" : "F",
      "author" : [ "D. Gale", "Stewart" ],
      "venue" : "M.",
      "citeRegEx" : "Gale and Stewart 1953",
      "shortCiteRegEx" : null,
      "year" : 1953
    }, {
      "title" : "Difficulty-driven sudoku puzzle generation",
      "author" : [ "Pong Hunt", "M. Tucker 2007] Hunt", "C. Pong", "G. Tucker" ],
      "venue" : "UMAPJournal",
      "citeRegEx" : "Hunt et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Hunt et al\\.",
      "year" : 2007
    }, {
      "title" : "and Edelkamp",
      "author" : [ "P. Kissmann" ],
      "venue" : "S.",
      "citeRegEx" : "Kissmann and Edelkamp 2011",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "W",
      "author" : [ "Ma" ],
      "venue" : "J.",
      "citeRegEx" : "Ma 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "and Siegler",
      "author" : [ "G. Ramani" ],
      "venue" : "R.",
      "citeRegEx" : "Ramani and Siegler 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Automatically generating algebra problems",
      "author" : [ "Gulwani Singh", "R. Rajamani 2012] Singh", "S. Gulwani", "S. Rajamani" ],
      "venue" : null,
      "citeRegEx" : "Singh et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Singh et al\\.",
      "year" : 2012
    }, {
      "title" : "Rhythm-based level generation for 2D platformers",
      "author" : [ "Smith" ],
      "venue" : "In FDG",
      "citeRegEx" : "Smith,? \\Q2009\\E",
      "shortCiteRegEx" : "Smith",
      "year" : 2009
    }, {
      "title" : "A",
      "author" : [ "Smith" ],
      "venue" : "M.; Andersen, E.; Mateas, M.; and Popović, Z.",
      "citeRegEx" : "Smith et al. 2012",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "E",
      "author" : [ "Weisstein" ],
      "venue" : "W.",
      "citeRegEx" : "Weisstein 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "The gold standard: Automatically generating puzzle game levels",
      "author" : [ "J. cock", "B. Stephenson" ],
      "venue" : "AIIDE",
      "citeRegEx" : "cock and Stephenson,? \\Q2012\\E",
      "shortCiteRegEx" : "cock and Stephenson",
      "year" : 2012
    }, {
      "title" : "Sudoku puzzles generating: From easy to evil. Mathematics in Practice and Theory 21:000",
      "author" : [ "XUE" ],
      "venue" : null,
      "citeRegEx" : "XUE,? \\Q2009\\E",
      "shortCiteRegEx" : "XUE",
      "year" : 2009
    } ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "Simple board games, like Tic-Tac-Toe and CONNECT-4, play an important role not only in the development of mathematical and logical skills, but also in the emotional and social development. In this paper, we address the problem of generating targeted starting positions for such games. This can facilitate new approaches for bringing novice players to mastery, and also leads to discovery of interesting game variants. We present an approach that generates starting states of varying hardness levels for player 1 in a two-player board game, given rules of the board game, the desired number of steps required for player 1 to win, and the expertise levels of the two players. Our approach leverages symbolic methods and iterative simulation to efficiently search the extremely large state space. We present experimental results that include discovery of states of varying hardness levels for several simple gridbased board games. The presence of such states for standard game variants like 4 × 4 Tic-Tac-Toe opens up new games to be played that have never been played as the default start state is heavily biased.",
    "creator" : "LaTeX with hyperref package"
  }
}