{
  "name" : "1306.6302.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Solving Relational MDPs with Exogenous Events and Additive Rewards",
    "authors" : [ "Saket Joshi", "Roni Khardon", "Prasad Tadepalli", "Aswin Raghavan", "Alan Fern" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Relational Markov Decision Processes (RMDPs) offer an attractive formalism to study both reinforcement learning and probabilistic planning in relational domains. However, most work on RMDPs has focused on planning and learning when the only transitions in the world are a result of the agent’s actions. We are interested in a class of problems modeled as service domains, where the world is affected by exogenous service requests in addition to the agent’s actions. In this paper we use the inventory control (IC) domain as a motivating running example and for experimental validation. The domain models a retail company faced with the task of maintaining the inventory in its shops to meet consumer demand. Exogenous events (service requests) correspond to arrival of customers at shops and, at any point in time, any number of service requests can occur independently of each other and independently of the agent’s action. Although we focus on IC, independent exogenous service requests are common in many other problems, for example, in fire and emergency response, air traffic control, and service centers such as taxicab companies, hospitals, and restaurants. Exogenous events present a challenge for planning and reinforcement learning algorithms because the number of possible next states, the “stochastic branching factor”, grows exponentially in the number of possible simultaneous service requests.\nIn this paper we consider symbolic dynamic programming (SDP) to solve RMDPs, as it allows to reason more abstractly than what is typical in forward planning and reinforcement learning. The SDP solutions for propositional MDPs can be adapted to\nar X\niv :1\n30 6.\n63 02\nv2 [\ncs .A\nI] 2\n7 Ju\nn 20\n13\nRMDPs by grounding the RMDP for each size to get a propositional encoding, and then using a “factored approach” to solve the resulting planning problem, e.g., using algebraic decision diagrams (ADDs) [5] or linear function approximation [4]. This approach can easily model exogenous events [2] but it plans for a fixed domain size and requires increased time and space due to the grounding. The relational (first order logic) SDP approach [3] provides a solution which is independent of the domain size, i.e., it holds for any problem instance. On the other hand, exogenous events make the first order formulation much more complex. To our knowledge, the only work to have approached this is [17,15]. While Sanner’s work is very ambitious in that it attempted to solve a very general class of problems, the solution used linear function approximation, approximate policy iteration, and some heuristic logical simplification steps to demonstrate that some problems can be solved and it is not clear when the combination of ideas in that work is applicable, both in terms of the algorithmic approximations and in terms of the symbolic simplification algorithms.\nIn this paper we make a different compromise by constraining the class of problems and aiming for a complete symbolic solution. In particular, we introduce the class of service domains, that have a simple form of independent object-focused exogenous events, so that the transition in each step can be modeled as first taking the agent’s action, and then following a sequence of “exogenous actions” in any order. We then investigate a relational SDP approach to solve such problems. The main contribution of this paper is a new symbolic algorithm that is proved to provide a lower bound approximation on the true value function for service domains under certain technical assumptions. While the assumptions are somewhat strong, they allow us to provide the first complete analysis of relational SDP with exogenous events which is important for understanding such problems. In addition, while the assumptions are needed for the analysis, they are not needed for the algorithm that can be applied in more general settings. Our second main contribution provides algorithmic support to implement this algorithm using the GFODD representation of [8]. GFODDs provide a scheme for capturing and manipulating functions over relational structures. Previous work has analyzed some theoretical properties of this representation but did not provide practical algorithms. In this paper we develop a model evaluation algorithm for GFODDs inspired by variable elimination (VE), and a model checking reduction for GFODDs. These are crucial for efficient realization of the new approximate SDP algorithm. We illustrate the new algorithm in two variants of the IC domain, where one satisfies our assumptions and the other does not. Our results demonstrate that the new algorithm can be implemented efficiently, that its size-independent solution scales much better than propositional approaches [5,19], and that it produces high quality policies."
    }, {
      "heading" : "2 Preliminaries: Relational Symbolic Dynamic Programming",
      "text" : "We assume familiarity with basic notions of Markov Decision Processes (MDPs) and First Order Logic [14,13]. Briefly, a MDP is given by a set of states S, actions A, transition function Pr(s′|s, a), immediate reward function R(s) and discount factor γ < 1. The solution of a MDP is a policy that maximizes the expected discounted total reward obtained by following that policy starting from any state. The Value Iteration algorithm\n(VI), calculates the optimal value function V ∗ by iteratively performing Bellman backups Vi+1 = T [Vi] defined for each state s as,\nVi+1(s)← max a {R(s) + γ ∑ s′ Pr(s′|s, a)Vi(s′)}. (1)\nRelational MDPs: Relational MDPs are simply MDPs where the states and actions are described in a function-free first order logical language. In particular, the language allows a set of logical constants, a set of logical variables, a set of predicates (each with its associated arity), but no functions of arity greater than 0. A state corresponds to an interpretation in first order logic (we focus on finite interpretations) which specifies (1) a finite set of n domain elements also known as objects, (2) a mapping of constants to domain elements, and (3) the truth values of all the predicates over tuples of domain elements of appropriate size (to match the arity of the predicate). Atoms are predicates applied to appropriate tuples of arguments. An atom is said to be ground when all its arguments are constants or domain elements. For example, using this notation empty(x1) is an atom and empty(shop23) is a ground atom involving the predicate empty and object shop23 (expressing that the shop shop23 is empty in the IC domain). Our notation does not distinguish constants and variables as this will be clear from the context. One of the advantages of relational SDP algorithms, including the one in this paper, is that the number of objects n is not known or used at planning time and the resulting policies generalize across domain sizes.\nThe state transitions induced by agent actions are modeled exactly as in previous SDP work [3]. The agent has a set of action types {A} each parametrized with a tuple of objects to yield an action template A(x) and a concrete ground action A(o) (e.g. template unload(t, s) and concrete action unload(truck1, shop2)). To simplify notation, we use x to refer to a single variable or a tuple of variables of the appropriate arity. Each agent action has a finite number of action variants Aj(x) (e.g., action success vs. action failure), and when the user performs A(x) in state s one of the variants is chosen randomly using the state-dependent action choice distribution Pr(Aj(x)|A(x)).\nSimilar to previous work we model the reward as some additive function over the domain. To avoid some technical complications, we use average instead of sum in the reward function; this yields the same result up to a multiplicative factor. Relational Expressions and GFODDs: To implement planning algorithms for relational MDPs we require a symbolic representation of functions to compactly describe the rewards, transitions, and eventually value functions. In this paper we use the GFODD representation of [8] but the same ideas work for any representation that can express open-expressions and closed expressions over interpretations (states). An expression represents a function mapping interpretations to real values. An open expression f(x), similar to an open formula in first order logic, can be evaluated in interpretation I once we substitute the variables x with concrete objects in I . A closed expression (aggregatexf(x)), much like a closed first order logic formula, aggregates the value of f(x) over all possible substitutions of x to objects in I . First order logic limits f(x) to have values in {0, 1} (i.e., evaluate to false or true) and provides the aggregation max (corresponding to existential quantification) and min (corresponding to universal quantification) that can be used individually on each variable in x. Expressions are more general allowing for additional aggregation functions (for example,\naverage) so that aggregation generalizes quantification in logic, and allowing f(x) to take numerical values. On the other hand, our expressions require aggregation operators to be at the front of the formulas and thus correspond to logical expressions in prenex normal form. This enables us to treat the aggregation portion and formula portion separately in our algorithms. In this paper we focus on average and max aggregation. For example, in the IC domain we might use the expression: “maxt, avgs, (if ¬empty(s) then 1, else if tin(t, s) then 0.1, else 0)”. Intuitively, this awards a 1 for any non-empty shop and at most one shop is awarded a 0.1 if there is a truck at that shop. The value of this expression is given by picking one t which maximizes the average over s.\nGFODDs provide a graphical representation and associated algorithms to represent open and closed expressions. A GFODD is given by an aggregation function, exactly as in the expressions, and a labeled directed acyclic graph that represents the open formula portion of the expression. Each leaf in the GFODD is labeled with a non-negative numerical value, and each internal node is labeled with a first-order atom (allowing for equality atoms) where we allow atoms to use constants or variables as arguments. As in propositional diagrams [1], for efficiency reasons, the order over nodes in the diagram must conform to a fixed ordering over node labels, which are first order atoms in our case. Figure 1(a) shows an example GFODD capturing the expression given in the previous paragraph.\nGiven a diagram B = (aggregatexf(x)), an interpretation I , and a substitution of variables in x to objects in I , one can traverse a path to a leaf which gives the value for that substitution. The values of all substitutions are aggregated exactly as in expressions. In particular, let the variables as ordered in the aggregation function be x1, . . . , xn. To calculate the final value, mapB(I), the semantics prescribes that we enumerate all substitutions of variables {xi} to objects in I and then perform the aggregation over the variables, going from xn to x1. We can therefore think of the aggregation as if it organizes the substitutions into blocks (with fixed value to the first k − 1 variables and all values for the k’th variable), and then aggregates the value of each block separately, repeating this from xn to x1. We call the algorithm that follows this definition directly brute force evaluation. A detailed example is shown in Figure 3(a). To evaluate the diagram in Figure 3(a) on the interpretation shown there we enumerate all 33 = 27 substitutions of 3 objects to 3 variables, obtain a value for each, and then aggregate the values. In the block where x1 = a, x2 = b, and x3 varies over a, b, c we get the values 3, 2, 2 and an aggregated value of 7/3. This can be done for every block, and then we can aggregate over substitutions of x2 and x1. The final value in this case is 7/3.\nAny binary operation op over real values can be generalized to open and closed expressions in a natural way. If f1 and f2 are two closed expressions, f1 op f2 represents the function which maps each interpretation w to f1(w) op f2(w). We follow the general convention of using⊕ and⊗ to denote + and× respectively when they are applied to expressions. This provides a definition but not an implementation of binary operations over expressions. The work in [8] showed that if the binary operation is safe, i.e., it distributes with respect to all aggregation operators, then there is a simple algorithm (the Apply procedure) implementing the binary operation over expressions. For example ⊕ is safe w.r.t. max aggregation, and it is easy to see that (maxx f(x))⊕ (maxx g(x)) = maxxmaxy f(x) + g(y), and the open formula portion (diagram portion) of the result\ncan be calculated directly from the open expressions f(x) and g(y). The Apply procedure [20,8] calculates a diagram representing f(x) + g(y) using operations over the graphs representing f(x) and g(y). Note that we need to standardize apart, as in the renaming of g(x) to g(y) for such operations. SDP for Relational MDPs: SDP provides a symbolic implementation of the value iteration update of Eq (1) that avoids state enumeration implicit in that equation. The SDP algorithm of [8] generalizing [3] calculates one iteration of value iteration as follows. As input we get (as GFODDs) closed expressions Vn, R (we use Figure 1(a) as the reward in the example below), and open expressions for the probabilistic choice of actions Pr(Aj(x)|A(x)) and for the dynamics of deterministic action variants.\nThe action dynamics are specified by providing a diagram (called truth value diagram or TVD) for each variant Aj(x) and predicate template p(y). The corresponding TVD, T (Aj(x), p(y)), is an open expression that specifies the truth value of p(y) in the next state when Aj(x) has been executed in the current state. Figure 1(b) shows the TVD of unload(t∗, s∗) for predicates empty(s). Note that in contrast to other representations of planning operators (but similar to the successor state axioms of [3]) TVDs specify the truth value after the action and not the change in truth value. Since unload is deterministic we have only one variant and Pr(Aj(x)|A(x)) = 1. We illustrate probabilistic actions in the next section. Following [20,8] we require that Pr(Aj(x)|A(x)) and T (Aj(x), p(y)) have no aggregations and cannot introduce new variables, that is, the first refers to x only and the second to x and y but no other variables. This implies that the regression and product terms in the algorithm below do not change the aggregation function and therefore enables the analysis of the algorithm.\nThe SDP algorithm of [8] implements Eq (1) using the following 4 steps. We denote this as Vi+1 = SDP 1(Vi).\n1. Regression: The n step-to-go value function Vn is regressed over every deterministic variant Aj(x) of every action A(x) to produce Regr(Vn, Aj(x)). Regression is conceptually similar to goal regression in deterministic planning but it needs to be done for all (potentially exponential number of) paths in the diagram, each of which can be thought of as a goal in the planning context. This can be done efficiently by replacing every atom in the open formula portion of Vn (a node in the GFODD representation) by its corresponding TVD without changing the aggregation function. Figure 1(c) illustrates the process of block replacement for the diagram of part (a). Note that tin() is not affected by the action. Therefore its TVDs simply repeats the predicate value, and the corresponding node is unchanged by block replacement. Therefore, in this example, we are effectively replacing only one node with its TVD. The TVD leaf valued 1 is connected to the left child (true branch) of the node and the 0 leaf is connected to the right child (false branch). To maintain the diagrams sorted we must in fact use a different implementation than block replacement; the implementation does not affect the constructions or proofs in the paper and we therefore refer the reader to [20] for the details. 2. Add Action Variants: The Q-function QA(x)Vn = R ⊕ [γ ⊗ ⊕j(Pr(Aj(x)) ⊗ Regr(Vn, Aj(x)))] for each action A(x) is generated by combining regressed diagrams using the binary operations ⊕ and ⊗ over expressions. Recall that probability diagrams do not refer to additional variables. The multiplication can therefore be done directly on the open formulas without changing the aggregation function. As argued by [20], to guarantee correctness, both summation steps (⊕j and R⊕ steps) must standardize apart the functions before adding them. 3. Object Maximization: Maximize over the action parameters QA(x)Vn to produce QAVn for each action A(x), thus obtaining the value achievable by the best ground instantiation of A(x) in each state. This step is implemented by converting action parameters x in QA(x)Vn to variables, each associated with the max aggregation operator, and appending these operators to the head of the aggregation function. For example, if object maximization were applied to the diagram of Figure 1(c) (we skipped some intermediate steps) then t∗, s∗ would be replaced with variables and given max aggregation so that the aggregation is as shown in part (d) of the figure. Therefore, in step 2, t∗, s∗ are constants (temporarily added to the logical language) referring to concrete objects in the world, and in step 3 we turn them into variables and specify the aggregation function for them. 4. Maximize over Actions: The n+1 step-to-go value function Vn+1 =maxAQAVn , is generated by combining the diagrams using the binary operation max over expressions.\nThe main advantage of this approach is that the regression operation, and the binary operations over expressions⊕,⊗, max can be performed symbolically and therefore the final value function output by the algorithm is a closed expression in the same language. We therefore get a completely symbolic form of value iteration. Several instantiations of this idea have been implemented [11,6,18,20]. Except for the work of [8,18] previous work has handled only max aggregation. Previous work [8] relies on the fact that the binary operations ⊕, ⊗, and max are safe with respect to max,min aggregation to\nprovide a GFODD based SDP algorithm for problems where the reward function has max and min aggregations . In this paper we use reward functions with max and avg aggregation. The binary operations ⊕ and ⊗ are safe with respect to avg but the binary operation max is not. For example 2 + avg{1, 2, 3} = avg{2 + 1, 2 + 2, 2 + 3} but max{2, avg{1, 2, 3}} 6= avg{max{2, 1},max{2, 2},max{2, 3}}. To address this issue we introduce a new implementation for this case in the next section."
    }, {
      "heading" : "3 Model and Algorithms for Service Domains",
      "text" : "We now proceed to describe our extensions to SDP to handle exogenous events. Exogenous events refer to spontaneous changes to the state without agent action. Our main modeling assumption, denoted A1, is that we have object-centered exogenous actions that are automatically taken in every time step. In particular, for every object i in the domain we have action E(i) that acts on object i and the conditions and effects of {E(i)} are such that they are mutually non-interfering: given any state s, all the actions {E(i)} are applied simultaneously, and this is equivalent to their sequential application in any order. We use the same GFODD action representation described in the previous section to capture the dynamics of E(i). Example: IC Domain. We use a simple version of the inventory control domain (IC) as a running example, and for some of the experimental results. In IC the objects are a depot, a truck and a number of shops. A shop can be empty or full, i.e., the inventory has only two levels and the truck can either be at the depot or at a shop. The reward is the fraction (average) of non-empty shops. Agent actions are deterministic and they capture stock replacement. In particular, a shop can be filled by unloading inventory from the truck in one step. The truck can be loaded in a depot and driven from any location (shop or depot) to any location in one step. The exogenous action E(i) has two variants; the success variant Esucc(i) (customer arrives at shop i, and if non-empty the inventory becomes empty) occurs with probability 0.4 and the fail variant Efail(i) (no customer, no changes to state) occurs with probability 0.6. Figure 2 parts (a)-(d) illustrate the model for IC and its GFODD representation. In order to facilitate the presentation of algorithmic steps, Figure 2(e) shows a slightly different reward function (continuing previous examples) that is used as the reward in our running example.\nFor our analysis we make two further modeling assumptions. A2: we assume that exogenous action E(i) can only affect unary properties of the object i. To simplify the presentation we consider a single such predicate sp(i) that may be affected, but any number of such predicates can be handled. In IC, the special predicate sp(i) is empty(i) specifying whether the shop is empty. A3: we assume that sp() does not appear in the precondition of any agent action. It follows that E(i) only affects sp(i) and that sp(i) can appear in the precondition of E(i) but cannot appear in the precondition of any other action."
    }, {
      "heading" : "3.1 The Template Method",
      "text" : "Extending SDP to handle exogenous events is complicated because the events depend on the objects in the domain and on their number and exact solutions can result in\ncomplex expressions that require counting formulas over the domain [17,15]. A possible simple approach would explicitly calculate the composition of the agent’s actions with all the exogenous events. But this assumes that we know the number of objects n (and thus does not generalize) and results in an exponential number of action variants, which makes it infeasible. A second simple approach would be to directly modify the SDP algorithm so that it sequentially regresses the value function over each of the ground exogenous actions before performing the regression over the agent actions, which is correct by our assumptions. However, this approach, too, requires us to know n and because it effectively grounds the solution it suffers in terms of generality.\nWe next describe the template method, one of our main contributions, which provides a completely abstract approximate SDP solution for the exogenous event model. We make our final assumption, A4, that the reward function (and inductively Vi) is a closed expression of the form maxx avgyV (x, y) where x is a (potentially empty) set of variables and y is a single variable, and in V (x, y) the predicate sp() appears instantiated only as sp(y). The IC domain as described above satisfies all our assumptions.\nThe template method first runs the following 4 steps, denoted SDP 2(Vi), and then follows with the 4 steps of SDP as given above for user actions. The final output of our approximate Bellman backup, T ′, is Vi+1 = T ′(Vi) = SDP 1(SDP 2(Vi)).\n1. Grounding: Let a be a Skolem constant not in Vi. Partially ground V to get V = maxx V (x, a) 2. Regression: The function V is regressed over every deterministic variant Ej(a) of the exogenous action centered at a to produce Regr(V,Ej(a)). 3. Add Action Variants: The value function V = ⊕j(Pr(Ej(a)) ⊗ Regr(V,Ej(a))) is updated. As in SDP 1, multiplication is done directly on the open formulas without changing the aggregation function. Importantly, in contrast with SDP 1, here we do not standardize apart the functions when performing ⊕j . This leads to an approximation. 4. Lifting: Let the output of the previous step be V = maxxW (x, a). Return V = maxx avgyW (x, y).\nThus, the algorithm grounds V using a generic object for exogenous actions, it then performs regression for a single generic exogenous action, and then reintroduces the aggregation. Figure 2 parts (e)-(j) illustrate this process.\nWe now show that our algorithm provides a monotonic lower bound on the value function. The crucial step is the analysis of SDP 2(Vi). We have:\nLemma 1. Under assumptions A1, A2, A4 the value function calculated by SDP 2(Vi) is a lower bound on the value of regression of Vi through all exogenous actions.\nDue to space constraints the complete proof is omitted and we only provide a sketch. This proof and other omitted details can be found in the full version of this paper [10].\nProof. (sketch) The main idea in the proof is to show that, under our assumptions, the result of our algorithm is equivalent to sequential regression of all exogenous actions, where in each step the action variants are not standardized apart.\nRecall that the input value function Vi has the form V = maxx avgyV (x, y) = maxx 1 n [V (x, 1)+V (x, 2)+ . . .+V (x, n)]. To establish this relationship we show that after the sequential algorithm regressesE(1), . . . , E(k) the intermediate value function has the form maxx 1n [W (x, 1)+W (x, 2)+. . .+W (x, k)+V (x, k+1)+. . .+V (x, n)]. That is, the first k portions change in the same structural manner into a diagram W and the remaining portions retain their original form V . In addition, W (x, `) is the result of regressing V (x, `) through E(`) which is the same form as calculated by step 3 of the template method. Therefore, when all E(`) have been regressed, the result is V = maxx avgyW (x, y) which is the same as the result of the template method.\nThe sequential algorithm is correct by definition when standardizing apart but yields a lower bound when not standardizing apart. This is true because for any functions f1 and f2 we have [maxx1 avgy1f 1(x1, y1)] + [maxx2 avgy2f\n2(x2, y2)] ≥ maxx[avgy1 f1(x, y1)+avgy2f 2(x, y2)] = maxx avgy[(f 1(x, y)+f2(x, y))] where the last equality holds because y1 and y2 range over the same set of objects. Therefore, if f1 and f2 are the results of regression for different variants from step 2, adding them without standardizing apart as in the last equation yields a lower bound. ut\nThe lemma requires that Vi used as input satisfies A4. If this holds for the reward function, and if SDP 1 maintains this property then A4 holds inductively for all Vi. Put together this implies that the template method provides a lower bound on the true Bellman backup. It therefore remains to show how SDP 1 can be implemented for maxx avgy aggregation and that it maintains the form A4.\nFirst consider regression. If assumption A3 holds, then our algorithm using regression through TVDs does not introduce new occurrences of sp() into V . Regression also does not change the aggregation function. Similarly, the probability diagrams do not introduce sp() and do not change the aggregation function. Therefore A4 is maintained by these steps. For the other steps we need to discuss the binary operations ⊕ and max.\nFor ⊕, using the same argument as above, we see that [maxx1 avgy1f 1(x1, y1)] +\n[maxx2 avgy2f 2(x2, y2)] = maxx1 maxx2 [avgy f 1(x1, y)+ f 2(x2, y)] and therefore it suffices to standardize apart the x portion but y can be left intact and A4 is maintained. Finally, recall that we need a new implementation for the binary operation max with avg aggregation. This can be done as follows: to perform max{[maxx1 avgy1 f1(x1, y1)], [maxx2 avgy2f\n2(x2, y2)]} we can introduce two new variables z1, z2 and write the expression: “maxz1,z2 maxx1 maxx2 avgy1avgy2 (if z1 = z2 then f 1(x1, y1) else f2(x2, y2))”. This is clearly correct whenever the interpretation has at least two objects because z1, z2 are unconstrained. Now, because the branches of the if statement are mutually exclusive, this expression can be further simplified to “maxz1,z2 maxx avgy (if z1 = z2 then f1(x, y) else f2(x, y))”. The implementation uses an equality node at the root with label z1 = z2, and hangs f1 and f2 at the true and false branches. Crucially it does not need to standardize apart the representation of f1 and f2 and thus A4 is maintained. This establishes that the approximation returned by our algorithm, T ′[Vi], is a lower bound of the true Bellman backup T [Vi].\nAn additional argument (details available in [10]) shows that this is a monotonic lower bound, that is, for all i we have T [Vi] ≥ Vi where T [V ] is the true Bellman backup. It is well known (e.g., [12]) that if this holds then the value of the greedy policy w.r.t. Vi is at least Vi (this follows from the monotonicity of the policy update operator Tπ). The significance is, therefore, that Vi provides an immediate certificate on the quality of the resulting greedy policy. Recall that T ′[V ] is our approximate backup, V0 = R and Vi+1 = T ′[Vi]. We have:\nTheorem 1. When assumptions A1, A2, A3, A4 hold and the reward function is nonnegative we have for all i: Vi ≤ Vi+1 = T ′[Vi] ≤ T [Vi] ≤ V ∗.\nAs mentioned above, although the assumptions are required for our analysis, the algorithm can be applied more widely. Assumptions A1 and A4 provide our basic modeling assumption per object centered exogenous events and additive rewards. It is easy to generalize the algorithm to have events and rewards based on object tuples instead of single objects. Similarly, while the proof fails when A2 (exogenous events only affect special unary predicates) is violated the algorithm can be applied directly without modification. When A3 does not hold, sp() can appear with multiple arguments and the algorithm needs to be modified. Our implementation introduces an additional approximation and at iteration boundary we unify all the arguments of sp() with the average variable y. In this way the algorithm can be applied inductively for all i. These extensions of the algorithm are demonstrated in our experiments. Relation to Straight Line Plans: The template method provides symbolic way to calculate a lower bound on the value function. It is interesting to consider what kind of lower bound this provides. Recall that the straight line plan approximation (see e.g., discussion in [2]) does not calculate a policy and instead at any state it seeks the best\nlinear plan with highest expected reward. As the next observation argues (proof available in [10]) the template method provides a related approximation. We note, however, that unlike previous work on straight line plans our computation is done symbolically and calculates the approximation for all start states simultaneously.\nObservation 1. The template method provides an approximation that is related to the value of the best straight line plan. When there is only one deterministic agent action template we get exactly the value of the straight line plan. Otherwise, the approximation is bounded between the value of the straight line plan and the optimal value."
    }, {
      "heading" : "4 Evaluation and Reduction of GFODDs",
      "text" : "The symbolic operations in the SDP algorithm yield diagrams that are redundant in the sense that portions of them can be removed without changing the values they compute. Recently, [8,7] introduced the idea of model checking reductions to compress such diagrams. The basic idea is simple. Given a set of “focus states” S, we evaluate the diagram on every interpretation in S. Any portion of the diagram that does not “contribute” to the final value in any of the interpretations is removed. The result is a diagram which is exact on the focus states, but may be approximate on other states. We refer the reader to [8,7] for further motivation and justification. In that work, several variants of this idea have been analyzed formally (for max and min aggregation), have been shown to perform well empirically (for max aggregation), and methods for generating S via random walks have been developed. In this section we develop the second contribution of the paper, providing an efficient realization of this idea for maxx avgy aggregation.\nThe basic reduction algorithm, which we refer to below as brute force model checking for GFODDs, is: (1) Evaluate the diagram on each example in our focus set S marking all edges that actively participate in generating the final value returned for that example. Because we have maxx avgy this value is given by the “winner” of max aggregation. This is a block of substitutions that includes one assignment to x and all possible assignments to y. For each such block collect the set of edges traversed by any of the substitutions in the block. When picking the max block, also collect the edges traversed by that block, breaking ties by lexicographic ordering over edge sets. (2) Take the union of marked edges over all examples, connecting any edge not in this set to 0.\nConsider again the example of evaluation in Figure 3(a), where we assigned node identifiers 1,2,3. We identify edges by their parent node and its branch so that the leftgoing edge from the root is edge 1t. In this case the final value 7/3 is achieved by multiple blocks of substitutions, and two distinct sets of edges 1t2f3t3f and 1f3t3f . Assuming 1<2<3 and f<t, 1f3t3f is lexicographically smaller and is chosen as the marked set. This process is illustrated in the tables of Figure 3(a). Referring to the reduction procedure, if our focus set S includes only this interpretation, then the edges 1t, 2t, 2f will be redirected to the value 0. Efficient Model Evaluation and Reduction: We now show that the same process of evaluation and reduction can be implemented more efficiently. The idea, taking inspiration from variable elimination, is that we can aggregate some values early while calculating the tables. However, our problem is more complex than standard variable elimination and we require a recursive computation over the diagram.\nFor every node n let n.lit = p(x) be the literal at the node and let n↓f and n↓t be its false and true branches respectively. Define above(n) to be the set of variables appearing above n and self(n) to be the variables in x. Let maxabove(n) and maxself(n) be the variables of largest index in above(n) and self(n) respectively. Finally let maxvar(n) be the maximum between maxabove(n) and maxself(n). Figure 3(b) shows maxvar(n) and maxabove(n) for our example diagram. Given interpretation I , let bln↓t(I) be the set of bindings a of objects from I to variables in x such that p(a) ∈ I . Similarly bln↓f (I) is the set of bindings a such that ¬p(a) ∈ I . The two sets are obviously disjoint and together cover all bindings for x. For example, for the root node in the diagram of Figure 3(b), bln↓t(I) is a table mapping x2 to a, b and bln↓f (I) is a table mapping x2 to c. The evaluation procedure, Eval(n), is as follows:\n1. If n is a leaf: (1) Build a “table” with all variables implicit, and with the value of n. (2) Aggregate over all variables from the last variable down to maxabove(n) + 1. (3) Return the resulting table.\n2. Otherwise n is an internal node: (1) Let M↓t(I) = bln↓t(I) × Eval(n↓t), where × is the join of the tables. (2) Aggregate over all the variables in M↓t(I) from the last variable not yet aggregated down to maxvar(n) + 1. (3) Let M↓f (I) = bln↓f (I) × Eval(n↓f )\n(4) Aggregate over all the variables in M↓f (I) from the last variable not yet aggregated down to maxvar(n) + 1. (5) Let M =M↓t(I) ∪M↓f (I). (6) Aggregate over all the variables in M from the last variable not yet aggregated down to maxabove(n) + 1. (7) Return node table M .\nWe note several improvements for this algorithm and its application for reductions, all of which are applicable and used in our experiments. (I1) We implement the above recursive code using dynamic programming to avoid redundant calls. (I2) When an aggregation operator is idempotent, i.e., op{a, . . . , a} = a, aggregation over implicit variables does not change the table, and the implementation is simplified. This holds for max and avg aggregation. (I3) In the case of maxx avgy aggregation the procedure is made more efficient (and closer to variable elimination where variable order is flexible) by noting that, within the set of variables x, aggregation can be done in any order. Therefore, once y has been aggregated, any variable that does not appear above node n can be aggregated at n. (I4) The recursive algorithm can be extended to collect edge sets for winning blocks by associating them with table entries. Leaf nodes have empty edge sets. The join step at each node adds the corresponding edge (for true or false child) for each entry. Finally, when aggregating an average variable we take the union of edges, and when aggregating a max variable we take the edges corresponding to the winning value, breaking ties in favor of the lexicographically smaller set of edges.\nA detailed example of the algorithm is given in Figure 3(b) where the evaluation is on the same interpretation as in part (a). We see that node 3 first collects a table over x2, x3 and that, because x3 is not used above, it already aggregates x3. The join step for node 2 uses entries (b, a) and (c, a) for (x1, x2) from the left child and other entries from the right child. Node 2 collects the entries and (using I3) aggregates x1 even though x2 appears above. Node 1 then similarly collects and combines the tables and aggregates x2. The next theorem is proved by induction over the structure of the GFODD (details available in [10]).\nTheorem 2. The value and max block returned by the modified Eval procedure are identical to the ones returned by the brute force method."
    }, {
      "heading" : "5 Experimental Validation",
      "text" : "In this section we present an empirical demonstration of our algorithms. To that end we implemented our algorithms in Prolog as an extension of the FODD-PLANNER [9], and compared it to SPUDD [5] and MADCAP [19] that take advantage of propositionally factored state spaces, and implement VI using propositional algebraic decision diagrams (ADD) and affine ADDs respectively. For SPUDD and MADCAP, the domains were specified in the Relational Domain Description Language (RDDL) and translated into propositional descriptions using software provided for the IPPC 2011 planning competition [16]. All experiments were run on an Intel Core 2 Quad CPU @ 2.83GHz. Our system was given 3.5Gb of memory and SPUDD and MADCAP were given 4Gb.\nWe tested all three systems on the IC domain as described above where shops and trucks have binary inventory levels (empty or full). We present results for the IC domain, because it satisfies all our assumptions and because the propositional systems fare better in this case. We also present results for a more complex IC domain (advanced IC or AIC below) where the inventory can be in one of 3 levels 0,1 and 2 and a shop can have one of 2 consumption rates 0.3 and 0.4. AIC does not satisfy assumption A3. As the experiments show, even with this small extension, the combinatorics render the propositional approach infeasible. In both cases, we constructed the set of focus states to include all possible states over 2 shops. This provides exact reduction for states with 2 shops but the reduction is approximate for larger states as in our experiments.\nFigure 4 summarizes our results, which we discuss from left to right and top to bottom. The top left plot shows runtime as a function of iterations for AIC and illustrates that the variable elimination method is significantly faster than brute force evaluation and that it enables us to run many more iterations. The top right plot shows the total time (translation from RDDL to a propositional description and off-line planning for 10 iterations of VI) for the 3 systems for one problem instance per size for AIC. SPUDD runs out of memory and fails on more than 4 shops and MADCAP can handle at most 5\nshops. Our planning time (being domain size agnostic) is constant. Runtime plots for IC are omitted but they show a similar qualitative picture, where the propositional systems fail with more than 8 shops for SPUDD and 9 shops for MADCAP.\nThe middle two plots show the cost of using the policies, that is, the on-line execution time as a function of increasing domain size in test instances. To control run time for our policies we show the time for the GFODD policy produced after 4 iterations, which is sufficient to solve any problem in IC and AIC.4 On-line time for propositional systems is fast for the domain sizes they solve, but our system can solve problems of much larger size (recall that the state space grows exponentially with the number of shops). The bottom two plots show the total discounted reward accumulated by each system (as well as a random policy) on 15 randomly generated problem instances averaged over 30 runs. In both cases all algorithms are significantly better than the random policy. In IC our approximate policy is not distinguishable from the optimal (SPUDD). In AIC the propositional policies are slightly better (differences are statistically significant). In summary, our system provides a non-trivial approximate policy but is sub-optimal in some cases, especially in AIC where A3 is violated. On the other hand its offline planning time is independent of domain size, and it can solve instances that cannot be solved by the propositional systems."
    }, {
      "heading" : "6 Conclusions",
      "text" : "The paper presents service domains as an abstraction of planning problems with additive rewards and with multiple simultaneous but independent exogenous events. We provide a new relational SDP algorithm and the first complete analysis of such an algorithm with provable guarantees. In particular our algorithm, the template method, is guaranteed to provide a monotonic lower bound on the true value function under some technical conditions. We have also shown that this lower bound lies between the value of straight line plans and the true value function. As a second contribution we introduce new evaluation and reduction algorithms for the GFODD representation, that in turn facilitate efficient implementation of the SDP algorithm. Preliminary experiments demonstrate the viability of our approach and that our algorithm can be applied even in situations that violate some of the assumptions used in the analysis. The paper provides a first step toward analysis and solutions of general problems with exogenous events by focusing on a well defined subset of such models. Identifying more general conditions for existence of compact solutions, representations for such solutions, and associated algorithms is an important challenge for future work. In addition, the problems involved in evaluation and application of diagrams are computationally demanding. Techniques to speed up these computations are an important challenge for future work.\nAcknowledgements This work was partly supported by NSF under grants IIS-0964457 and IIS-0964705 and the CI fellows award for Saket Joshi. Most of this work was done when Saket Joshi was at Oregon State University.\n4 Our system does not achieve structural convergence because the reductions are not comprehensive. We give results at 4 iterations as this is sufficient for solving all problems in this domain. With more iterations, our policies are larger and their execution is slower."
    }, {
      "heading" : "8 Proof of Theorem 1 (Monotonic Lower Bound)",
      "text" : "The proof of Lemma 1 and the text that follows it imply that for all V satisfying A1-A4 we have T ′[V ] ≤ T [V ]. Now, when R is non-negative, V0 = R and Vi+1 = T ′[Vi] this implies that for all i, we have T ′[Vi] ≤ T [Vi] ≤ V ∗. We next show that under the same conditions on V0 and R we have that for all i\nVi ≤ T ′[Vi] = Vi+1. (3)\nCombining the two we get Vi ≤ Vi+1 = T ′[Vi] ≤ T [Vi] ≤ V ∗ as needed. We prove Eq (3) by induction on i. For the base case it is obvious that V0 ≤ V1 because V0 = R and V1 = R + W where W is the regressed and discounted value function which is guaranteed to be non-negative.\nFor the inductive step, note that all the individual operations we use with GFODDs (regress, ⊕, ⊗, max) are monotonic. That is, consider any functions (GFODDs) such that f1 ≥ f2 and f3 ≥ f4 then regress(f1) ≥ regress(f2) and op(f1, f3) ≥ op(f2, f4). As a result, the same is true for any sequence of such operations and in particular for the sequence of operations that defines T ′[V ]. Therefore, Vi−1 ≤ Vi implies Vi = T ′[Vi−1] ≤ T ′[Vi] = Vi+1."
    }, {
      "heading" : "9 Proof of Observation 1 (Relation to Straight Line Plans)",
      "text" : "The template method provides symbolic way to calculate a lower bound on the value function. It is interesting to consider what kind of lower bound this provides. Consider regression overE(k) and the source of approximation in the sequential argument where we do not standardize apart. Treating Vn as the next step value function, captures the ability to take the best action in the next state which is reached after the current exogenous action. Now by calculating maxx avgy[(f\n1(x, y) + f2(x, y))] the choice of the next action (determined by x) is done without knowledge of which action variant Ej(k) has occurred. Effectively, we have pushed the expectation over action variants Ej(k) into the max over actions for the next step. Now, because this is done for all k, and at every iteration of the value iteration algorithm, the result is similar to having replaced the true m step to go value function\nmax α1 Expβ1 max α2 Expβ2 . . .max αm Expβmf(R, {αi}, {βi})\n(where αi is the user action in the i’th step and βi is the compound exogenous action in the i’th step) with maxα1maxα2 . . . maxαm Expβ1Expβ2 . . .Expβmf(R, {αi}, {βi}). The last expression is the value of the best linear plan, known as the straight line plan approximation. The analogy given here does not go through completely due to two facts. First, the max and expectation are over arguments and not actions. In particular, when there is more than one agent action template (e.g., load unload, drive), we explicitly maximize over agent actions in Step 4 of SDP 1. These max steps are therefore done correctly and are not swapped with expectations. Second, we do still standardize apart agent actions so that their outcomes are taken into consideration. In other words the expectations due to randomization in the outcome of agent actions are performed\ncorrectly and are not swapped with max steps. On the other hand, when there is only one agent action template and the action is deterministic we get exactly straight line plan approximation."
    }, {
      "heading" : "10 Preparation for Proof of Theorem 2 (Correctness of Model Evaluation Algorithm)",
      "text" : "We start by proving the correctness of the evaluation step on its own without the specialization for maxx avgy aggregation and the additional steps for reductions.\nThe pseudocode for the Eval procedure was given above. Note that the two children of node n may have aggregated different sets of variables (due to having additional parents). Therefore in the code we aggregate the table from each side separately (down to maxvar(n) + 1) before taking the union. Once the two sides are combined we still need to aggregate the variables between maxvar(n)+ 1 and maxabove(n)+ 1 before returning the table.\nWe have the following:\nProposition 1. The value returned by the Eval procedure is exactly mapB(I).\nProof. Given a node n, the value of maxabove(n), and a concrete substitution ζ (for variables z1 to zmaxabove(n)) reaching n in I we consider the corresponding block in the brute force evaluation procedure and in our procedure. For the brute force evaluation we fix the values of z1 to zmaxabove(n) to agree with ζ and consider the aggregated value when all variables down to zmaxabove(n) + 1 have been aggregated. For Eval(n) we consider the entry in the table returned by the procedure which is consistent with ζ. Since the table may include some variables (that are smaller than maxabove(n) but do not appear below n) implicitly we simply expand the table entry with the values from ζ.\nWe next prove by induction over the structure of the diagram that the corresponding entries are identical. First, note that if this holds at the root where above(n) is the empty set, then the proposition holds because all variables are aggregated and the value is mapB(I).\nFor the base case, it is easy to see that the claim holds at a leaf, because all substitutions reaching the leaf have the same value, and the block is explicitly aggregated at the leaf.\nGiven any node n, we have two cases. In the first case,maxself(n)≤maxabove(n), that is, all variables in n.lit are already substituted in ζ. In this case, for any ζ, the entire block traverses n↓c (where c is either t or f as appropriate). Clearly, the join with bln↓c(I) identifies the correct child c with respect to the entry of ζ. Consider the table entries in M↓c(I) that are extensions of the substitution ζ possibly specifying more variables. More precisely, if the the child node is n′ the entries include the variables up to ` = maxabove(n′). By the inductive hypothesis the value in each entry is a correct aggregation of all the variables down to ` + 1. Now since the remaining variables are explicitly aggregated at n, the value calculated at n is correct.\nIn the second case, maxself(n) > maxabove(n) which means that some extensions of ζ traverse n↓t and some traverse n↓f . However, as in the previous case, by\nthe inductive hypothesis we know that the extended entries at the children are correct aggregations of their values. Now it is clear that the union operation correctly collects these entries together into one block, and as before because the remaining variables are explicitly aggregated at n, the result is correct. ut"
    }, {
      "heading" : "11 Proof of Theorem 2 (Correctness of Edge Marking in Model Evaluation Algorithm)",
      "text" : "We start by giving a more detailed version of the algorithmic extension of the algorithm to collect edge sets. In addition to the the substitution and value, every table entry is associated with a set of edges. (1) When calculating the join we add the edge n↓f to the corresponding table returned by the call to Eval(n↓f ) and similarly for n↓t and Eval(n↓t). (2) When a node aggregates an average variable the set of edges for the new entry is the union of edges in all the entries aggregated. (3) When a node aggregates a max variable the set of edges for the new entry is the set of edges from the winning value. In case of a tie we pick the set of edges which is smallest lexicographically. (4) A leaf node returns the empty set as its edge set.\nThe proof of Theorem 2 is similar to the proof above, in that we define a property of nodes and prove it inductively, but in this case it is simpler to argue by way of contradiction.\nProof. The correctness of the value returned was already shown in Proposition 1. We therefore focus on showing that the set of edges returned is identical to the one returned by the brute force method.\nFor a node n and a concrete substitution ζ (for variables z1 to zmaxabove(n)) reaching n in I , define Bζ to be the sub-diagram of B rooted at n where z1 to zmaxabove(n) are substituted by ζ, and with the aggregation function of zmaxabove(n)+1, . . . , zN as in B where zN is the last variable in the aggregation function.\nWe claim that for each node n, and ζ that reaches n, the entry in the table returned by n which is consistent with ζ has the value v = mapBζ (I) and set of edges E, where E is the lexicographically smallest set of edges of a block achieving the value v. Note that if the claim holds at the root n then the theorem holds because above(n) is empty. In the rest of the proof we argue that the set of edges returned is lexicographically smallest.\nNow consider any I and any B and assume by way of contradiction that the claim does not hold for I and B. Let n be the lowest node in B for which this happens. That is the claim does hold for all descendants of n.\nIt is easy to see that such a node n cannot be a leaf, because for any leaf the set E is the empty set and this is what the procedure returns.\nFor an internal node n, again we have two cases. If maxself(n) ≤ maxabove(n), then the entire block corresponding to ζ traverses n↓c (where as above c is t or f ). In this case, if the last variable (the only one with average aggregation) has not yet been aggregated then the tables are full and the claim clearly holds because aggregation\nis done directly at node n. Otherwise, n’s child aggregated the variables beyond zk for some k ≥ m = maxabove(n). Let η be a substitution for zm+1, . . . , zk. Then by the assumption we know that each entry in the table returned by the child, which is consistent with ζ, η has value mapBζ,η (I) and the lexicographically smallest set of edges corresponding to a block achieving this value.\nNow, at node n we aggregate zm+1, . . . , zk using this table. Consider the relevant sub-table with entries ζ, ηi, vi, Êi where Êi is Ei with the edge n↓c added to it by the join operation. Because zm+1, . . . , zk use max aggregation, the aggregation at n picks a vi with the largest value and the corresponding Êi where in case of tie in vi we pick the entry with smallest Êi.\nBy our assumption this set Êi is not the lexicographically smallest set corresponding to a block of substitutions realizing the value mapBζ (I). Therefore, there must be a block of valuations ζη′ where η′ is the substitution for zm+1, . . . , zk realizing the same value vi and whose edge set E′ is lexicographically smaller than Êi. But in this case η′ = ηj for some j, and E′ \\ n↓c is lexicographically smaller than Ei which (by construction, because the algorithm chose Ei) is lexicographically smaller than Ej . Thus the entry for Ej is incorrect. This contradicts our assumption that n is the lowest node violating the claim.\nThe second case, wheremaxself(n) > maxabove(n) ζ is argued similarly. In this case the substitutions extending ζ may traverse either n↓t or n↓f . We first aggregate some of the variables in each child’s table. We then take the union of the tables to form the block of ζ (as well as other blocks) and aggregate the remaining zm+1, . . . , zk. As in the previous case, both of these direct aggregation steps preserve the minimality of the corresponding sets Ei ut"
    } ],
    "references" : [ {
      "title" : "Algebraic decision diagrams and their applications",
      "author" : [ "R. Bahar", "E. Frohm", "C. Gaona", "G. Hachtel", "E. Macii", "A. Pardo", "F. Somenzi" ],
      "venue" : "Proceedings of the IEEE/ACM International Conference on Computer-Aided Design. pp. 188–191",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Decision-theoretic planning: Structural assumptions and computational leverage",
      "author" : [ "C. Boutilier", "T. Dean", "S. Hanks" ],
      "venue" : "Journal of Artificial Intelligence Research 11, 1–94",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Symbolic dynamic programming for first-order MDPs",
      "author" : [ "C. Boutilier", "R. Reiter", "B. Price" ],
      "venue" : "Proceedings of the International Joint Conference of Artificial Intelligence. pp. 690–700",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Efficient solution algorithms for factored MDPs",
      "author" : [ "C. Guestrin", "D. Koller", "R. Parr", "S. Venkataraman" ],
      "venue" : "Journal of Artificial Intelligence Research 19, 399–468",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "SPUDD: Stochastic planning using decision diagrams",
      "author" : [ "J. Hoey", "R. St-Aubin", "A. Hu", "C. Boutilier" ],
      "venue" : "Proceedings of Uncertainty in Artificial Intelligence. pp. 279–288",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "FluCaP: a heuristic search planner for firstorder MDPs",
      "author" : [ "S. Hölldobler", "E. Karabaev", "O. Skvortsova" ],
      "venue" : "Journal of Artificial Intelligence Research 27, 419–439",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Self-Taught decision theoretic planning with first-order decision diagrams",
      "author" : [ "S. Joshi", "K. Kersting", "R. Khardon" ],
      "venue" : "Proceedings of the International Conference on Automated Planning and Scheduling. pp. 89–96",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Decision theoretic planning with generalized first order decision diagrams",
      "author" : [ "S. Joshi", "K. Kersting", "R. Khardon" ],
      "venue" : "Artificial Intelligence 175, 2198–2222",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Probabilistic relational planning with first-order decision diagrams",
      "author" : [ "S. Joshi", "R. Khardon" ],
      "venue" : "Journal of Artificial Intelligence Research 41, 231–266",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Solving relational MDPs with exogenous events and additive rewards",
      "author" : [ "S. Joshi", "R. Khardon", "P. Tadepalli", "A. Raghavan", "A. Fern" ],
      "venue" : "CoRR abs/1306.6302",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2013
    }, {
      "title" : "Bellman goes relational",
      "author" : [ "K. Kersting", "M. van Otterlo", "L. De Raedt" ],
      "venue" : "Proceedings of the International Conference on Machine Learning. pp. 465–472",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Bounded real-time dynamic programming: RTDP with monotone upper bounds and performance guarantees",
      "author" : [ "H.B. McMahan", "M. Likhachev", "G.J. Gordon" ],
      "venue" : "Proceedings of the International Conference on Machine Learning. pp. 569–576",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Markov Decision Processes: Discrete Stochastic Dynamic Programming",
      "author" : [ "M.L. Puterman" ],
      "venue" : "Wiley",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Artificial Intelligence: A Modern Approach",
      "author" : [ "S. Russell", "P. Norvig" ],
      "venue" : "Prentice Hall Series in Artificial Intelligence",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "First-order decision-theoretic planning in structured relational environments",
      "author" : [ "S. Sanner" ],
      "venue" : "Ph.D. thesis, University of Toronto",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Relational dynamic influence diagram language (RDDL): Language description http://users.cecs.anu.edu.au/∼sanner/IPPC 2011/RDDL.pdf",
      "author" : [ "S. Sanner" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2010
    }, {
      "title" : "Approximate solution techniques for factored first-order MDPs",
      "author" : [ "S. Sanner", "C. Boutilier" ],
      "venue" : "Proceedings of the International Conference on Automated Planning and Scheduling. pp. 288–295",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Practical solution techniques for first-order MDPs",
      "author" : [ "S. Sanner", "C. Boutilier" ],
      "venue" : "Artificial Intelligence 173, 748–788",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Approximate dynamic programming with affine ADDs",
      "author" : [ "S. Sanner", "W. Uther", "K. Delgado" ],
      "venue" : "Proceeding of the International Conference on Autonomous Agents and Multiagent Systems. pp. 1349–1356",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "First-Order decision diagrams for relational MDPs",
      "author" : [ "C. Wang", "S. Joshi", "R. Khardon" ],
      "venue" : "Journal of Artificial Intelligence Research 31, 431–472",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : ", using algebraic decision diagrams (ADDs) [5] or linear function approximation [4].",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 3,
      "context" : ", using algebraic decision diagrams (ADDs) [5] or linear function approximation [4].",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 1,
      "context" : "This approach can easily model exogenous events [2] but it plans for a fixed domain size and requires increased time and space due to the grounding.",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 2,
      "context" : "The relational (first order logic) SDP approach [3] provides a solution which is independent of the domain size, i.",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 16,
      "context" : "To our knowledge, the only work to have approached this is [17,15].",
      "startOffset" : 59,
      "endOffset" : 66
    }, {
      "referenceID" : 14,
      "context" : "To our knowledge, the only work to have approached this is [17,15].",
      "startOffset" : 59,
      "endOffset" : 66
    }, {
      "referenceID" : 7,
      "context" : "Our second main contribution provides algorithmic support to implement this algorithm using the GFODD representation of [8].",
      "startOffset" : 120,
      "endOffset" : 123
    }, {
      "referenceID" : 4,
      "context" : "Our results demonstrate that the new algorithm can be implemented efficiently, that its size-independent solution scales much better than propositional approaches [5,19], and that it produces high quality policies.",
      "startOffset" : 163,
      "endOffset" : 169
    }, {
      "referenceID" : 18,
      "context" : "Our results demonstrate that the new algorithm can be implemented efficiently, that its size-independent solution scales much better than propositional approaches [5,19], and that it produces high quality policies.",
      "startOffset" : 163,
      "endOffset" : 169
    }, {
      "referenceID" : 13,
      "context" : "We assume familiarity with basic notions of Markov Decision Processes (MDPs) and First Order Logic [14,13].",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 12,
      "context" : "We assume familiarity with basic notions of Markov Decision Processes (MDPs) and First Order Logic [14,13].",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 2,
      "context" : "The state transitions induced by agent actions are modeled exactly as in previous SDP work [3].",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 7,
      "context" : "In this paper we use the GFODD representation of [8] but the same ideas work for any representation that can express open-expressions and closed expressions over interpretations (states).",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "As in propositional diagrams [1], for efficiency reasons, the order over nodes in the diagram must conform to a fixed ordering over node labels, which are first order atoms in our case.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 7,
      "context" : "The work in [8] showed that if the binary operation is safe, i.",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 19,
      "context" : "The Apply procedure [20,8] calculates a diagram representing f(x) + g(y) using operations over the graphs representing f(x) and g(y).",
      "startOffset" : 20,
      "endOffset" : 26
    }, {
      "referenceID" : 7,
      "context" : "The Apply procedure [20,8] calculates a diagram representing f(x) + g(y) using operations over the graphs representing f(x) and g(y).",
      "startOffset" : 20,
      "endOffset" : 26
    }, {
      "referenceID" : 7,
      "context" : "The SDP algorithm of [8] generalizing [3] calculates one iteration of value iteration as follows.",
      "startOffset" : 21,
      "endOffset" : 24
    }, {
      "referenceID" : 2,
      "context" : "The SDP algorithm of [8] generalizing [3] calculates one iteration of value iteration as follows.",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 2,
      "context" : "Note that in contrast to other representations of planning operators (but similar to the successor state axioms of [3]) TVDs specify the truth value after the action and not the change in truth value.",
      "startOffset" : 115,
      "endOffset" : 118
    }, {
      "referenceID" : 19,
      "context" : "Following [20,8] we require that Pr(Aj(x)|A(x)) and T (Aj(x), p(y)) have no aggregations and cannot introduce new variables, that is, the first refers to x only and the second to x and y but no other variables.",
      "startOffset" : 10,
      "endOffset" : 16
    }, {
      "referenceID" : 7,
      "context" : "Following [20,8] we require that Pr(Aj(x)|A(x)) and T (Aj(x), p(y)) have no aggregations and cannot introduce new variables, that is, the first refers to x only and the second to x and y but no other variables.",
      "startOffset" : 10,
      "endOffset" : 16
    }, {
      "referenceID" : 7,
      "context" : "The SDP algorithm of [8] implements Eq (1) using the following 4 steps.",
      "startOffset" : 21,
      "endOffset" : 24
    }, {
      "referenceID" : 19,
      "context" : "To maintain the diagrams sorted we must in fact use a different implementation than block replacement; the implementation does not affect the constructions or proofs in the paper and we therefore refer the reader to [20] for the details.",
      "startOffset" : 216,
      "endOffset" : 220
    }, {
      "referenceID" : 19,
      "context" : "As argued by [20], to guarantee correctness, both summation steps (⊕j and R⊕ steps) must standardize apart the functions before adding them.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 10,
      "context" : "Several instantiations of this idea have been implemented [11,6,18,20].",
      "startOffset" : 58,
      "endOffset" : 70
    }, {
      "referenceID" : 5,
      "context" : "Several instantiations of this idea have been implemented [11,6,18,20].",
      "startOffset" : 58,
      "endOffset" : 70
    }, {
      "referenceID" : 17,
      "context" : "Several instantiations of this idea have been implemented [11,6,18,20].",
      "startOffset" : 58,
      "endOffset" : 70
    }, {
      "referenceID" : 19,
      "context" : "Several instantiations of this idea have been implemented [11,6,18,20].",
      "startOffset" : 58,
      "endOffset" : 70
    }, {
      "referenceID" : 7,
      "context" : "Except for the work of [8,18] previous work has handled only max aggregation.",
      "startOffset" : 23,
      "endOffset" : 29
    }, {
      "referenceID" : 17,
      "context" : "Except for the work of [8,18] previous work has handled only max aggregation.",
      "startOffset" : 23,
      "endOffset" : 29
    }, {
      "referenceID" : 7,
      "context" : "Previous work [8] relies on the fact that the binary operations ⊕, ⊗, and max are safe with respect to max,min aggregation to",
      "startOffset" : 14,
      "endOffset" : 17
    }, {
      "referenceID" : 16,
      "context" : "complex expressions that require counting formulas over the domain [17,15].",
      "startOffset" : 67,
      "endOffset" : 74
    }, {
      "referenceID" : 14,
      "context" : "complex expressions that require counting formulas over the domain [17,15].",
      "startOffset" : 67,
      "endOffset" : 74
    }, {
      "referenceID" : 9,
      "context" : "This proof and other omitted details can be found in the full version of this paper [10].",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 9,
      "context" : "An additional argument (details available in [10]) shows that this is a monotonic lower bound, that is, for all i we have T [Vi] ≥ Vi where T [V ] is the true Bellman backup.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 11,
      "context" : ", [12]) that if this holds then the value of the greedy policy w.",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : ", discussion in [2]) does not calculate a policy and instead at any state it seeks the best",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 9,
      "context" : "As the next observation argues (proof available in [10]) the template method provides a related approximation.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 7,
      "context" : "Recently, [8,7] introduced the idea of model checking reductions to compress such diagrams.",
      "startOffset" : 10,
      "endOffset" : 15
    }, {
      "referenceID" : 6,
      "context" : "Recently, [8,7] introduced the idea of model checking reductions to compress such diagrams.",
      "startOffset" : 10,
      "endOffset" : 15
    }, {
      "referenceID" : 7,
      "context" : "We refer the reader to [8,7] for further motivation and justification.",
      "startOffset" : 23,
      "endOffset" : 28
    }, {
      "referenceID" : 6,
      "context" : "We refer the reader to [8,7] for further motivation and justification.",
      "startOffset" : 23,
      "endOffset" : 28
    }, {
      "referenceID" : 9,
      "context" : "The next theorem is proved by induction over the structure of the GFODD (details available in [10]).",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 8,
      "context" : "To that end we implemented our algorithms in Prolog as an extension of the FODD-PLANNER [9], and compared it to SPUDD [5] and MADCAP [19] that take advantage of propositionally factored state spaces, and implement VI using propositional algebraic decision diagrams (ADD) and affine ADDs respectively.",
      "startOffset" : 88,
      "endOffset" : 91
    }, {
      "referenceID" : 4,
      "context" : "To that end we implemented our algorithms in Prolog as an extension of the FODD-PLANNER [9], and compared it to SPUDD [5] and MADCAP [19] that take advantage of propositionally factored state spaces, and implement VI using propositional algebraic decision diagrams (ADD) and affine ADDs respectively.",
      "startOffset" : 118,
      "endOffset" : 121
    }, {
      "referenceID" : 18,
      "context" : "To that end we implemented our algorithms in Prolog as an extension of the FODD-PLANNER [9], and compared it to SPUDD [5] and MADCAP [19] that take advantage of propositionally factored state spaces, and implement VI using propositional algebraic decision diagrams (ADD) and affine ADDs respectively.",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 15,
      "context" : "translated into propositional descriptions using software provided for the IPPC 2011 planning competition [16].",
      "startOffset" : 106,
      "endOffset" : 110
    } ],
    "year" : 2013,
    "abstractText" : "We formalize a simple but natural subclass of service domains for relational planning problems with object-centered, independent exogenous events and additive rewards capturing, for example, problems in inventory control. Focusing on this subclass, we present a new symbolic planning algorithm which is the first algorithm that has explicit performance guarantees for relational MDPs with exogenous events. In particular, under some technical conditions, our planning algorithm provides a monotonic lower bound on the optimal value function. To support this algorithm we present novel evaluation and reduction techniques for generalized first order decision diagrams, a knowledge representation for realvalued functions over relational world states. Our planning algorithm uses a set of focus states, which serves as a training set, to simplify and approximate the symbolic solution, and can thus be seen to perform learning for planning. A preliminary experimental evaluation demonstrates the validity of our approach.",
    "creator" : "LaTeX with hyperref package"
  }
}