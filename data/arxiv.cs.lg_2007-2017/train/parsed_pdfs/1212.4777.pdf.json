{
  "name" : "1212.4777.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Practical Algorithm for Topic Modeling with Provable Guarantees",
    "authors" : [ "Sanjeev Arora", "Rong Ge", "Yoni Halpern", "David Mimno", "Ankur Moitra", "David Sontag", "Yichen Wu", "Michael Zhu" ],
    "emails" : [ "arora@cs.princeton.edu.", "rongge@cs.princeton.edu.", "halpern@cs.nyu.edu.", "mimno@cs.princeton.edu.", "moitra@ias.edu.", "dsontag@cs.nyu.edu.", "yichenwu@princeton.edu.", "mhzhu@princeton.edu." ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Topic modeling is a popular method that learns thematic structure from large document collections without human supervision. The model is simple: documents are mixtures of topics, which are modeled as distributions over a vocabulary [Blei, 2012]. Each word token is generated by selecting a topic from a document-specific distribution, and then selecting a specific word from that topic-specific distribution. Posterior inference over document-topic and topic-word distributions is intractable — in the worst case it is NP-hard even for just two topics [Arora et al., 2012b]. As a result, researchers have used approximate inference techniques such as singular value decomposition [Deerwester et al., 1990], variational inference [Blei et al., 2003], and MCMC [Griffiths & Steyvers, 2004].\nRecent work in theoretical computer science focuses on designing provably efficient algorithms for topic modeling. These treat the topic modeling problem as one of statistical recovery: assuming the data was generated perfectly from the hypothesized model using an unknown set of parameter\n∗Princeton University, Computer Science Department and Center for Computational Intractability. Email: arora@cs.princeton.edu. This work is supported by the NSF grants CCF-0832797 and CCF-1117309. †Princeton University, Computer Science Department and Center for Computational Intractability. Email: rongge@cs.princeton.edu. This work is supported by the NSF grants CCF-0832797 and CCF-1117309. ‡New York University, Computer Science Department. Email: halpern@cs.nyu.edu. Research supported in part by an NSERC Postgraduate Scholarship. §Princeton University, Computer Science Department. Email: mimno@cs.princeton.edu. This work is supported by an NSF Computing and Innovation Fellowship. ¶Institute for Advanced Study, School of Mathematics. Email: moitra@ias.edu. Research supported in part by NSF grant No. DMS-0835373 and by an NSF Computing and Innovation Fellowship. ‖New York University, Computer Science Department. Email: dsontag@cs.nyu.edu. Research supported by a Google Faculty Research Award, CIMIT award 12-1262, and grant UL1 TR000038 from NCATS, NIH. ∗∗Princeton University, Computer Science Department. Email: yichenwu@princeton.edu. ††Princeton University, Computer Science Department. Email: mhzhu@princeton.edu.\nar X\niv :1\n21 2.\n47 77\nv1 [\ncs .L\nG ]\n1 9\nD ec\n2 01\nvalues, the goal is to recover the model parameters in polynomial time given a reasonable number of samples.\nArora et al. [2012b] present an algorithm that provably recovers the parameters of topic models provided that the topics meet a certain separability assumption [Donoho & Stodden, 2003]. Separability requires that every topic contains at least one anchor word that has non-zero probability only in that topic. If a document contains this anchor word, then it is guaranteed that the corresponding topic is among the set of topics used to generate the document. The algorithm proceeds in two steps: first it selects anchor words for each topic; and second, in the recovery step, it reconstructs topic distributions given those anchor words. The input for the algorithm is the second-order moment matrix of word-word co-occurrences.\nAnandkumar et al. [2012] present a provable algorithm based on third-order moments that does not require separability, but, unlike the algorithm of Arora et al., assumes that topics are not correlated. Although standard topic models like LDA [Blei et al., 2003] assume that the choice of topics used to generate the document are uncorrelated, there is strong evidence that topics are dependent [Blei & Lafferty, 2007, Li & McCallum, 2007]: economics and politics are more likely to co-occur than economics and cooking.\nBoth algorithms run in polynomial time, but the bounds that have been proven on their sample complexity are weak and their empirical runtime performance is slow. The algorithm presented by Arora et al. [2012b] solves numerous linear programs to find anchor words. Bittorf et al. [2012] and Gillis [2012] reduce the number of linear programs needed. All of these algorithms infer topics given anchor words using matrix inversion, which is notoriously unstable and noisy: matrix inversion frequently generates negative values for topic-word probabilities.\nIn this paper we present three contributions. First, we replace linear programming with a combinatorial anchor selection algorithm. So long as the separability assumption holds, we prove that this algorithm is stable in the presence of noise and thus has polynomial sample complexity for learning topic models. Second, we present a simple probabilistic interpretation of topic recovery given anchor words that replaces matrix inversion with a new gradient-based inference method. Third, we present an empirical comparison between recovery-based algorithms and existing likelihood-based topic inference. We study both the empirical sample complexity of the algorithms on synthetic distributions and the performance of the algorithms on real-world document corpora. We find that our algorithm performs as well as collapsed Gibbs sampling on a variety of metrics, and runs at least an order of magnitude faster.\nOur algorithm both inherits the provable guarantees from Arora et al. [2012a,b] and also results in simple, practical implementations. We view our work as a step toward bridging the gap between statistical recovery approaches to machine learning and maximum likelihood estimation, allowing us to circumvent the computational intractability of maximum likelihood estimation yet still be robust to model error."
    }, {
      "heading" : "2 Background",
      "text" : "We consider the learning problem for a class of admixture distributions that are frequently used for probabilistic topic models. Examples of such distributions include latent Dirichlet allocation [Blei et al., 2003], correlated topic models [Blei & Lafferty, 2007], and Pachinko allocation [Li & McCallum, 2007]. We denote the number of words in the vocabulary by V and the number of topics by K. Associated with each topic k is a multinomial distribution over the words in the vocabulary, which we will denote as the column vector Ak of length V . Each of these topic models postulates a particular prior distribution τ over the topic distribution of a document. For example,\nin latent Dirichlet allocation (LDA) τ is a Dirichlet distribution, and for the correlated topic model τ is a logistic Normal distribution. The generative process for a document d begins by drawing the document’s topic distribution Wd ∼ τ . Then, for each position i we sample a topic assignment zi ∼Wd, and finally a word wi ∼ Azi .\nWe can combine the column vectors Ak for each of the K topics to obtain the word-topic matrix A of dimension V ×K. We can similarly combine the column vectors Wd for M documents to obtain the topic-document matrix W of dimension K ×M . We emphasize that W is unknown and stochastically generated: we can never expect to be able to recover it. The learning task that we consider is to find the word-topic matrix A. For the case when τ is Dirichlet (LDA), we also show how to learn hyperparameters of τ .\nMaximum likelihood estimation of the word-topic distributions is NP-hard even for two topics [Arora et al., 2012b], and as a result researchers typically use approximate inference. The most popular approaches are variational inference [Blei et al., 2003], which optimizes an approximate objective, and Markov chain Monte Carlo [McCallum, 2002], which asymptotically samples from the posterior distribution but has no guarantees of convergence.\nArora et al. [2012b] present an algorithm that provably learns the parameters of a topic model given samples from the model, provided that the word-topic distributions satisfy a condition called separability:\nDefinition 2.1. The word-topic matrix A is p-separable for p > 0 if for each topic k, there is some word i such that Ai,k ≥ p and Ai,k′ = 0 for k′ 6= k.\nSuch a word is called an anchor word because when it occurs in a document, it is a perfect indicator that the document is at least partially about the corresponding topic, since there is no other topic that could have generated the word. Suppose that each document is of lengthD ≥ 2, and let R = Eτ [WW T ] be the K×K topic-topic covariance matrix. Let αk be the expected proportion of topic k in a document generated according to τ . The main result of Arora et al. [2012b] is:\nTheorem 2.2. There is a polynomial time algorithm that learns the parameters of a topic model if the number of documents is at least\nM = max { O ( log V · a4K6\n2p6γ2D\n) , O ( logK · a2K4\nγ2\n)} ,\nwhere p is defined above, γ is the condition number of R, and a = maxk,k′ αk/αk′. The algorithm learns the word-topic matrix A and the topic-topic covariance matrix R up to additive error .\nUnfortunately, this algorithm is not practical. Its running time is prohibitively large because it solves V linear programs, and its use of matrix inversion makes it unstable and sensitive to noise. In this paper, we will give various reformulations and modifications of this algorithm that alleviate these problems altogether."
    }, {
      "heading" : "3 A Probabilistic Approach to Exploiting Separability",
      "text" : "The Arora et al. [2012b] algorithm has two steps: anchor selection, which identifies anchor words, and recovery, which recovers the parameters of A and of τ . Both anchor selection and recovery take as input the matrix Q (of size V × V ) of word-word co-occurrence counts, whose construction is described in the supplementary material. Q is normalized so that the sum of all entries is 1. The high-level flow of our complete learning algorithm is described in Algorithm 1, and follows the same two steps. In this section we will introduce a new recovery method based on a probabilistic\nAlgorithm 1. High Level Algorithm\nInput: Textual corpus D, Number of anchors K, Tolerance parameters a, b > 0. Output: Word-topic matrix A, topic-topic matrix R Q←Word Co-occurences(D) Form {Q̄1, Q̄2, ...Q̄V }, the normalized rows of Q. S ← FastAnchorWords({Q̄1, Q̄2, ...Q̄V }, K, a) (Algorithm 4) A,R← RecoverKL(Q,S, b) (Algorithm 3) return A,R\nAlgorithm 2. Original Recover [Arora et al., 2012b]\nInput: Matrix Q, Set of anchor words S Output: Matrices A,R\nPermute rows and columns of Q Compute ~pS = QS~1 (equals DR~1) Solve for ~z: QS,S~z = ~pS (Diag(~z) equals D\n−1) Solve for AT = (QS,SDiag(~z))\n−1QTS Solve for R = Diag(~z)QS,SDiag(~z) return A,R\nframework. We defer the discussion of anchor selection to the next section, where we provide a purely combinatorial algorithm for finding the anchor words.\nThe original recovery procedure (which we call “Recover”) from Arora et al. [2012b] is as follows. First, it permutes the Q matrix so that the first K rows and columns correspond to the anchor words. We will use the notationQS to refer to the firstK rows, andQS,S for the firstK rows and just the first K columns. If constructed from infinitely many documents, Q would be the second-order moment matrix Q = E[AWW TAT ] = AE[WW T ]AT = ARAT , with the following block structure:\nQ = ARAT = ( D U ) R ( D UT ) = ( DRD DRUT URD URUT ) where D is a diagonal matrix of size K × K. Next, it solves for A and R using the algebraic manipulations outlined in Algorithm 2.\nThe use of matrix inversion in Algorithm 2 results in substantial imprecision in the estimates when we have small sample sizes. The returned A and R matrices can even contain small negative values, requiring a subsequent projection onto the simplex. As we will show in Section 5, the original recovery method performs poorly relative to a likelihood-based algorithm. Part of the problem is that the original recover algorithm uses only K rows of the matrix Q (the rows for the anchor words), whereas Q is of dimension V ×V . Besides ignoring most of the data, this has the additional complication that it relies completely on co-occurrences between a word and the anchors, and this estimate may be inaccurate if both words occur infrequently.\nHere we adopt a new probabilistic approach, which we describe below after introducing some notation. Consider any two words in a document and call them w1 and w2, and let z1 and z2 refer to their topic assignments. We will use Ai,k to index the matrix of word-topic distributions, i.e. Ai,k = p(w1 = i|z1 = k) = p(w2 = i|z2 = k). Given infinite data, the elements of the Q matrix can be interpreted as Qi,j = p(w1 = i, w2 = j). The row-normalized Q matrix, denoted Q̄, which plays a role in both finding the anchor words and the recovery step, can be interpreted as a conditional probability Q̄i,j = p(w2 = j|w1 = i).\nDenoting the indices of the anchor words as S = {s1, s2, ..., sK}, the rows indexed by elements\nAlgorithm 3. RecoverKL\nInput: Matrix Q, Set of anchor words S, tolerance parameter . Output: Matrices A,R\nNormalize the rows of Q to form Q̄. Store the normalization constants ~pw = Q~1. Q̄sk is the row of Q̄ for the k\nth anchor word. for i = 1, ..., V do\nSolve Ci· = argmin ~Ci DKL(Q̄i|| ∑\nk∈SCi,kQ̄sk) Subject to: ∑ k Ci,k = 1 and Ci,k ≥ 0\nWith tolerance: end for A′ = diag(~pw)C Normalize the columns of A′ to form A. R = A†QA† T return A,R\nof S are special in that every other row of Q̄ lies in the convex hull of the rows indexed by the anchor words. To see this, first note that for an anchor word sk,\nQ̄sk,j = ∑ k′ p(z1 = k ′|w1 = sk)p(w2 = j|z1 = k′) (1)\n=p(w2 = j|z1 = k), (2)\nwhere (1) uses the fact that in an admixture model w2⊥w1 | z1, and (2) is because p(z1 = k|w1 = sk) = 1. For any other word i, we have\nQ̄i,j = ∑ k p(z1 = k|w1 = i)p(w2 = j|z1 = k).\nDenoting the probability p(z1 = k|w1 = i) as Ci,k, we have Q̄i,j = ∑\nk Ci,kQ̄sk,j . Since C is non-negative and ∑ k Ci,k = 1, we have that any row of Q̄ lies in the convex hull of the rows corresponding to the anchor words. The mixing weights give us p(z1|w1 = i)! Using this together with p(w1 = i), we can recover the A matrix simply by using Bayes’ rule:\np(w1 = i|z1 = k) = p(z1 = k|w1 = i)p(w1 = i)∑ i′ p(z1 = k|w1 = i′)p(w1 = i′) .\nFinally, we observe that p(w1 = i) is easy to solve for since ∑ j Qi,j = ∑\nj p(w1 = i, w2 = j) = p(w1 = i).\nOur new algorithm finds, for each row of the empirical row normalized co-occurrence matrix, Q̂i, the coefficients p(z1|w1 = i) that best reconstruct it as a convex combination of the rows that correspond to anchor words. This step can be solved quickly and in parallel (independently) for each word using the exponentiated gradient algorithm. Once we have p(z1|w1), we recover the A matrix using Bayes’ rule. The full algorithm using KL divergence as an objective is found in Algorithm 3. Further details of the exponentiated gradient algorithm are given in the supplementary material.\nOne reason to use KL divergence as the measure of reconstruction error is that the recovery procedure can then be understood as maximum likelihood estimation. In particular, we seek the parameters p(w1), p(z1|w1), p(w2|z1) that maximize the likelihood of observing the word co-occurence\ncounts, Q̂. However, the optimization problem does not explicitly constrain the parameters to correspond an admixture model.\nWe can also define a similar algorithm using quadratic loss, which we call RecoverL2. This formulation has the extremely useful property that both the objective and gradient can be kernelized so that the optimization problem is independent of the vocabulary size. To see this, notice that the objective can be re-written as\n||Qi − CTi QS||2 = ||Qi||2 − 2Ci(QSQ T i ) + C T i (QSQ T S)Ci,\nwhere QSQ T S is K ×K and can be computed once and used for all words, and QSQ T i is K × 1 and can be computed once prior to running the exponentiated gradient algorithm for word i. To recover the R matrix for an admixture model, recall that Q = ARAT . This may be an overconstrained system of equations with no solution for R, but we can find a least-squares approximation to R by pre- and post-multiplying Q by the pseudo-inverse A†. For the special case of LDA we can learn the Dirichlet hyperparameters. Recall that in applying Bayes’ rule we calculated p(z1) =∑\ni′ p(z1|w1 = i′)p(w1 = i′). These values for p(z) specify the Dirichlet hyperparameters up to a constant scaling. This constant could be recovered from the R matrix [Arora et al., 2012b], but in practice we find it is better to choose it using a grid search to maximize the likelihood of the training data.\nWe will see in Section 5 that our nonnegative recovery algorithm performs much better on a wide range of performance metrics than the recovery algorithm in Arora et al. [2012b]. In the supplementary material we show that it also inherits the theoretical guarantees of Arora et al. [2012b]: given polynomially many documents, our algorithm returns an estimate Â at most from the true word-topic matrix A."
    }, {
      "heading" : "4 A Combinatorial Algorithm for Finding Anchor Words",
      "text" : "Here we consider the anchor selection step of the algorithm where our goal is to find the anchor words. In the infinite data case where we have infinitely many documents, the convex hull of the rows in Q will be a simplex where the vertices of this simplex correspond to the anchor words. Since we only have a finite number of documents, the rows of Q are only an approximation to their expectation. We are therefore given a set of V points d1, d2, ...dV that are each a perturbation of a1, a2, ...aV whose convex hull P defines a simplex. We would like to find an approximation to the vertices of P . See Arora et al. [2012a] and Arora et al. [2012b] for more details about this problem.\nArora et al. [2012a] give a polynomial time algorithm that finds the anchor words. However, their algorithm is based on solving V linear programs, one for each word, to test whether or not a point is a vertex of the convex hull. In this section we describe a purely combinatorial algorithm for this task that avoids linear programming altogether. The new “FastAnchorWords” algorithm is given in Algorithm 4. To find all of the anchor words, our algorithm iteratively finds the furthest point from the subspace spanned by the anchor words found so far.\nSince the points we are given are perturbations of the true points, we cannot hope to find the anchor words exactly. Nevertheless, the intuition is that even if one has only found r points S that are close to r (distinct) anchor words, the point that is furthest from span(S) will itself be close to a (new) anchor word. The additional advantage of this procedure is that when faced with many choices for a next anchor word to find, our algorithm tends to find the one that is most different than the ones we have found so far.\nThe main contribution of this section is a proof that the FastAnchorWords algorithm succeeds in finding K points that are close to anchor words. To precisely state the guarantees, we recall the following definition from [Arora et al., 2012a]:\nAlgorithm 4. FastAnchorWords Input: V points {d1, d2, ...dV } in V dimensions, almost in a simplex with K vertices and > 0 Output: K points that are close to the vertices of the simplex.\nProject the points di to a randomly chosen 4 log V/ 2 dimensional subspace S ← {di} s.t. di is the farthest point from the origin. for i = 1 TO K − 1 do\nLet dj be the point in {d1, . . . , dV } that has the largest distance to span(S). S ← S ∪ {dj}.\nend for S = {v′1, v′2, ...v′K}. for i = 1 TO K do\nLet dj be the point that has the largest distance to span({v′1, v′2, ..., v′K}\\{v′i}) Update v′i to dj\nend for Return {v′1, v′2, ..., v′K}.\nNotation: span(S) denotes the subspace spanned by the points in the set S. We compute the distance from a point x to the subspace span(S) by computing the norm of the projection of x onto the orthogonal complement of span(S).\nDefinition 4.1. A simplex P is γ-robust if for every vertex v of P , the `2 distance between v and the convex hull of the rest of the vertices is at least γ.\nIn most reasonable settings the parameters of the topic model define lower bounds on the robustness of the polytope P . For example, in LDA, this lower bound is based on the largest ratio of any pair of hyper-parameters in the model [Arora et al., 2012b]. Our goal is to find a set of points that are close to the vertices of the simplex, and to make this precise we introduce the following definition:\nDefinition 4.2. Let a1, a2, ...aV be a set of points whose convex hull P is a simplex with vertices v1, v2, ...vK . Then we say ai -covers vj if when aj is written as a convex combination of the vertices as ai = ∑ j cjvj , then cj ≥ 1− . Furthermore we will say that a set of K points -covers the vertices if each vertex is covered by some point in the set.\nWe will prove the following theorem: suppose there is a set of points A = a1, a2, ...aV whose convex hull P is γ-robust and has vertices v1, v2, ...vK (which appear in A) and that we are given a perturbation d1, d2, ...dV of the points so that for each i, ‖ai − di‖ ≤ , then:\nTheorem 4.3. There is a combinatorial algorithm that runs in time Õ(V 2+V K/ 2) 1 and outputs a subset of {d1, . . . , dV } of size K that O( /γ)-covers the vertices provided that 20K /γ2 < γ.\nThis new algorithm not only helps us avoid linear programming altogether in inferring the parameters of a topic model, but also can be used to solve the nonnegative matrix factorization problem under the separability assumption, again without resorting to linear programming. Our analysis rests on the following lemmas, whose proof we defer to the supplementary material. Suppose the algorithm has found a set S of k points that are each δ-close to distinct vertices in {v1, v2, ..., vK} and that δ < γ/20K.\nLemma 4.4. There is a vertex vi whose distance from span(S) is at least γ/2.\n1In practice we find setting dimension to 1000 works well. The running time is then O(V 2 + 1000V K).\nThe proof of this lemma is based on a volume argument, and the connection between the volume of a simplex and the determinant of the matrix of distances between its vertices.\nLemma 4.5. The point dj found by the algorithm must be δ = O( /γ 2) close to some vertex vi.\nThis lemma is used to show that the error does not accumulate too badly in our algorithm, since δ only depends on , γ (not on the δ used in the previous step of the algorithm). This prevents the error from accumulating exponentially in the dimension of the problem, which would be catastrophic for our proof.\nAfter running the first phase of our algorithm, we run a cleanup phase (the second loop in Alg. 4) that can reduce the error in our algorithm. When we have K−1 points close to K−1 vertices, only one of the vertices can be far from their span. The farthest point must be close to this missing vertex. The following lemma shows that this cleanup phase can improve the guarantees of Lemma A.2:\nLemma 4.6. Suppose |S| = K−1 and each point in S is δ = O( /γ2) < γ/20K close to some vertex vi, then the farthest point v ′ j found by the algorithm is 1−O( /γ) close to the remaining vertex.\nThis algorithm is a greedy approach to maximizing the volume of the simplex. The larger the volume is, the more words per document the resulting model can explain. Better anchor word selection is an open question for future work. We have experimented with a variety of other heuristics for maximizing simplex volume, with varying degrees of success.\nRelated work. The separability assumption has also been studied under the name “pure pixel assumption” in the context of hyperspectral unmixing. A number of algorithms have been proposed that overlap with ours – such as the VCA [Nascimento & Dias, 2004] algorithm (which differs in that there is no clean-up phase) and the N-FINDR [Gomez et al., 2007] algorithm which attempts to greedily maximize the volume of a simplex whose vertices are data points. However these algorithms have only been proven to work in the infinite data case, and for our algorithm we are able to give provable guarantees even when the data points are perturbed (e.g., as the result of sampling noise). Recent work of Thurau et al. [2010] and Kumar et al. [2012] follow the same pattern as our paper, but use non-negative matrix factorization under the separability assumption. While both give applications to topic modeling, in realistic applications the term-by-document matrix is too sparse to be considered a good approximation to its expectation (because documents are short). In contrast, our algorithm works with the Gram matrix Q so that we can give provable guarantees even when each document is short."
    }, {
      "heading" : "5 Experimental Results",
      "text" : "We compare three parameter recovery methods, Recover [Arora et al., 2012b], RecoverKL and RecoverL2 to a fast implementation of Gibbs sampling [McCallum, 2002].2 Linear programmingbased anchor word finding is too slow to be comparable, so we use FastAnchorWords for all three recovery algorithms. Using Gibbs sampling we obtain the word-topic distributions by averaging over 10 saved states, each separated by 100 iterations, after 1000 burn-in iterations."
    }, {
      "heading" : "5.1 Methodology",
      "text" : "We train models on two synthetic data sets to evaluate performance when model assumptions are correct, and real documents to evaluate real-world performance. To ensure that synthetic\n2We were not able to obtain Anandkumar et al. [2012]’s implementation of their algorithm, and our own implementation is too slow to be practical.\ndocuments resemble the dimensionality and sparsity characteristics of real data, we generate semisynthetic corpora. For each real corpus, we train a model using MCMC and then generate new documents using the parameters of that model (these parameters are not guaranteed to be separable).\nWe use two real-world data sets, a large corpus of New York Times articles (295k documents, vocabulary size 15k, mean document length 298) and a small corpus of NIPS abstracts (1100 documents, vocabulary size 2500, mean length 68). Vocabularies were pruned with document frequency cutoffs. We generate semi-synthetic corpora of various sizes from models trained with K = 100 from NY Times and NIPS, with document lengths set to 300 and 70, respectively, and with document-topic distributions drawn from a Dirichlet with symmetric hyperparameters 0.03.\nWe use a variety of metrics to evaluate models: For the semi-synthetic corpora, we can compute reconstruction error between the true word-topic matrix A and learned topic distributions. Given a learned matrix Â and the true matrix A, we use an LP to find the best matching between topics. Once topics are aligned, we evaluate `1 distance between each pair of topics. When true parameters are not available, a standard evaluation for topic models is to compute held-out probability, the probability of previously unseen documents under the learned model. This computation is intractable but there are reliable approximation methods [Buntine, 2009, Wallach et al., 2009]. Topic models are useful because they provide interpretable latent dimensions. We can evaluate the semantic quality of individual topics using a metric called Coherence. Coherence is based on two functions, D(w) and D(w1, w2), which are number of documents with at least one instance of w, and of w1 and w2, respectively [Mimno et al., 2011]. Given a set of words W, coherence is\nCoherence(W) = ∑\nw1,w2∈W log\nD(w1, w2) +\nD(w2) . (3)\nThe parameter = 0.01 is used to avoid taking the log of zero for words that never co-occur [Stevens et al., 2012]. This metric has been shown to correlate well with human judgments of topic quality. If we perfectly reconstruct topics, all the high-probability words in a topic should co-occur frequently, otherwise, the model may be mixing unrelated concepts. Coherence measures the quality of individual topics, but does not measure redundancy, so we measure inter-topic similarity. For each topic, we gather the set of the N most probable words. We then count how many of those words do not appear in any other topic’s set of N most probable words. Some overlap is expected due to semantic ambiguity, but lower numbers of unique words indicate less useful models."
    }, {
      "heading" : "5.2 Efficiency",
      "text" : "The Recover algorithms, in Python, are faster than a heavily optimized Java Gibbs sampling implementation [Yao et al., 2009]. Fig. 1 shows the time to train models on synthetic corpora on a single machine. Gibbs sampling is linear in the corpus size. RecoverL2 is also linear (ρ = 0.79), but\nonly varies from 33 to 50 seconds. Estimating Q is linear, but takes only 7 seconds for the largest corpus. FastAnchorWords takes less than 6 seconds for all corpora."
    }, {
      "heading" : "5.3 Semi-synthetic documents",
      "text" : "The new algorithms have good `1 reconstruction error on semi-synthetic documents, especially for larger corpora. Results for semi-synthetic corpora drawn from topics trained on NY Times articles are shown in Fig. 2 for corpus sizes ranging from 50k to 2M synthetic documents. In addition, we report results for the three Recover algorithms on “infinite data,” that is, the true Q matrix from the model used to generate the documents. Error bars show variation between topics. Recover performs poorly in all but the noiseless, infinite data setting. Gibbs sampling has lower `1 with smaller corpora, while the new algorithms get better recovery and lower variance with more data (although more sampling might reduce MCMC error further).\nResults for semi-synthetic corpora drawn from NIPS topics are shown in Fig. 3. Recover does poorly for the smallest corpora (topic matching fails for D = 2000, so `1 is not meaningful), but achieves moderate error for D comparable to the NY Times corpus. RecoverKL and RecoverL2 also do poorly for the smallest corpora, but are comparable to or better than Gibbs sampling, with much lower variance, after 40,000 documents."
    }, {
      "heading" : "5.4 Effect of separability",
      "text" : "The non-negative algorithms are more robust to violations of the separability assumption than the original Recover algorithm. In Fig. 3, Recover does not achieve zero `1 error even with noiseless “infinite” data. Here we show that this is due to lack of separability. In our semi-synthetic corpora, documents are generated from the LDA model, but the topic-word distributions are learned from data and may not satisfy the anchor words assumption. We test the sensitivity of algorithms to violations of the separability condition by adding a synthetic anchor word to each topic that is by construction unique to the topic. We assign the synthetic anchor word a probability equal to the\nmost probable word in the original topic. This causes the distribution to sum to greater than 1.0, so we renormalize. Results are shown in Fig. 4. The `1 error goes to zero for Recover, and close to zero for RecoverKL and RecoverL2. The reason RecoverKL and RecoverL2 do not reach exactly zero is because we do not solve the optimization problems to perfect optimality."
    }, {
      "heading" : "5.5 Effect of correlation",
      "text" : "The theoretical guarantees of the new algorithms apply even if topics are correlated. To test how algorithms respond to correlation, we generated new synthetic corpora from the same K = 100 model trained on NY Times articles. Instead of a symmetric Dirichlet distribution, we use a logistic normal distribution with a block-structured covariance matrix. We partition topics into 10 groups. For each pair of topics in a group, we add a non-zero off-diagonal element to the covariance matrix. This block structure is not necessarily realistic, but shows the effect of correlation. Results for two levels of covariance (ρ = 0.05, ρ = 0.1) are shown in Fig. 5. Results for Recover are much worse in both cases than the Dirichlet-generated corpora in Fig. 2. The other three algorithms, especially Gibbs sampling, are more robust to correlation, but performance consistently degrades as correlation increases, and improves with larger corpora. With infinite data `1 error is equal to `1 error in the uncorrelated synthetic corpus (non-zero because of violations of the separability assumption)."
    }, {
      "heading" : "5.6 Real documents",
      "text" : "The new algorithms produce comparable quantitative and qualitative results on real data. Fig. 6 shows three metrics for both corpora. Error bars show the distribution of log probabilities across held-out documents (top panel) and coherence and unique words across topics (center and bottom panels). Held-out sets are 230 documents for NIPS and 59k for NY Times. For the small NIPS corpus we average over 5 non-overlapping train/test splits. The matrix-inversion in Recover failed for the smaller corpus (NIPS). In the larger corpus (NY Times), Recover produces noticeably worse held-out log probability per token than the other algorithms. Gibbs sampling produces the best\naverage held-out probability (p < 0.0001 under a paired t-test), but the difference is within the range of variability between documents. We tried several methods for estimating hyperparameters, but the observed differences did not change the relative performance of algorithms. Gibbs sampling has worse coherence than the Recover algorithms, but produces more unique words per topic. These patterns are consistent with semi-synthetic results for similarly sized corpora (details are in supplementary material).\nFor each NY Times topic learned by RecoverL2 we find the closest Gibbs topic by `1 distance. The closest, median, and farthest topic pairs are shown in Table 1.3 We observe that when there is a difference, recover-based topics tend to have more specific words (Anaheim Angels vs. pitch)."
    }, {
      "heading" : "6 Conclusions",
      "text" : "We present new algorithms for topic modeling, inspired by Arora et al. [2012b], which are efficient and simple to implement yet maintain provable guarantees. The running time of these algorithms is effectively independent of the size of the corpus. Empirical results suggest that the sample complexity of these algorithms is somewhat greater than MCMC, but, particularly for the `2 variant, they provide comparable results in a fraction of the time. We have tried to use the output of our algorithms as initialization for further optimization (e.g. using MCMC) but have not yet found a hybrid that out-performs either method by itself. Finally, although we defer parallel implementations to future work, these algorithms are parallelizable, potentially supporting web-scale topic inference.\n3The UCI NY Times corpus includes named-entity annotations, indicated by the zzz prefix."
    }, {
      "heading" : "A Proof for Anchor-Words Finding Algorithm",
      "text" : "Recall that the correctness of the algorithm depends on the following Lemmas:\nLemma A.1. There is a vertex vi whose distance from span(S) is at least γ/2.\nLemma A.2. The point ∆j found by the algorithm must be δ = O( /γ 2) close to some vertex vi.\nIn order to prove Lemma A.1, we use a volume argument. First we show that the volume of a robust simplex cannot change by too much when the vertices are perturbed.\nLemma A.3. Suppose {v1, v2, ..., vK} are the vertices of a γ-robust simplex S. Let S′ be a simplex with vertices {v′1, v′2, ..., v′K}, each of the vertices v′i is a perturbation of vi and ‖v′i − vi‖2 ≤ δ. When 10 √ Kδ < γ the volume of the two simplices satisfy\nvol(S)(1− 2δ/γ)K−1 ≤ vol(S′) ≤ vol(S)(1 + 4δ/γ)K−1.\nProof: As the volume of a simplex is proportional to the determinant of a matrix whose columns are the edges of the simplex, we first show the following perturbation bound for determinant.\nClaim A.4. Let A, E be K ×K matrices, the smallest eigenvalue of A is at least γ, the Frobenius norm ‖E‖F ≤ √ Kδ, when γ > 5 √ Kδ we have\ndet(A+ E)/det(A) ≥ (1− δ/γ)K .\nProof: Since det(AB) = det(A) det(B), we can multiply both A and A + E by A−1. Hence det(A+ E)/ det(A) = det(I +A−1E).\nThe Frobenius norm of A−1E is bounded by∥∥A−1E∥∥ F ≤ ∥∥A−1∥∥ 2 ‖E‖F ≤ √ Kδ/γ.\nLet the eigenvalues of A−1E be λ1, λ2, ..., λK , then by definition of Frobenius Norm ∑K\ni=1 λ 2 i ≤∥∥A−1E∥∥2\nF ≤ Kδ2/γ2. The eigenvalues of I + A−1E are just 1 + λ1, 1 + λ2, ..., 1 + λK , and the determinant det(I +A−1E) = ∏K i=1(1 + λi). Hence it suffices to show\nmin K∏ i=1 (1 + λi) ≥ (1− δ/γ)K when K∑ i=1 λ2i ≤ Kδ2/γ2.\nTo do this we apply Lagrangian method and show the minimum is only obtained when all λi’s are equal. The optimal value must be obtained at a local optimum of\nK∏ i=1 (1 + λi) + C K∑ i=1 λ2i .\nTaking partial derivatives with respect to λi’s, we get the equations −λi(1 + λi) = − ∏K i=1(1 +\nλi)/2C (here using √ Kδ/γ is small so 1+λi > 1/2 > 0). The right hand side is a constant, so each λi must be one of the two solutions of this equation. However, only one of the solution is larger than 1/2, therefore all the λi’s are equal.\nFor the lower bound, we can project the perturbed subspace to the K − 1 dimensional space. Such a projection cannot increase the volume and the perturbation distances only get smaller.\nTherefore we can apply the claim directly, the columns of A are just vi+1−v1 for i = 1, 2, ...,K−1; columns of E are just v′i+1 − vi+1 − (v′1 − v1). The smallest eigenvalue of A is at least γ because the polytope is γ robust, which is equivalent to saying after orthogonalization each column still has length at least γ. The Frobenius norm of E is at most 2 √ K − 1δ. We get the lower bound directly by applying the claim. For the upper bound, swap the two sets S and S′ and use the argument for the lower bound. The only thing we need to show is that the smallest eigenvalue of the matrix generated by points in S′ is still at least γ/2. This follows from Wedin’s Theorem [Wedin, 1972] and the fact that ‖E‖ ≤ ‖E‖F ≤ √ Kδ ≤ γ/2.\nNow we are ready to prove Lemma A.1. Proof: The first case is for the first step of the algorithm, when we try to find the farthest point to the origin. Here essentially S = {~0}. For any two vertices v1, v2, since the simplex is γ robust, the distance between v1 and v2 is at least γ. Which means dis(~0, v1) + dis(~0, v2) ≥ γ, one of them must be at least γ/2.\nFor the later steps, recall that S contains vertices of a perturbed simplex. Let S′ be the set of original vertices corresponding to the perturbed vertices in S. Let v be any vertex in {v1, v2, ..., vK} which is not in S. Now we know the distance between v and S is equal to vol(S∪{v})/(|S|−1)vol(S). On the other hand, we know vol(S′ ∪ {v})/(|S′| − 1)vol(S′) ≥ γ. Using Lemma A.3 to bound the ratio between the two pairs vol(S)/vol(S′) and vol(S ∪ {v})/vol(S′ ∪ {v}), we get:\ndis(v, S) ≥ (1− 4 ′/γ)2|S|−2γ > γ/2\nwhen γ > 20K ′.\nLemma A.2 is based on the following observation: in a simplex the point with largest `2 is always a vertex. Even if two vertices have the same norm if they are not close to each other the vertices on the edge connecting them will have significantly lower norm. Proof: (Lemma A.2)\nSince dj is the point found by the algorithm, let us consider the point aj before perturbation. The point aj is inside the simplex, therefore we can write aj as a convex combination of the vertices:\naj = K∑ t=1 ctvt\nLet vt be the vertex with largest coefficient ct. Let ∆ be the largest distance from some vertex to the space spanned by points in S (∆ = maxl dis(vl, span(S)). By Lemma A.1 we know ∆ > γ/2. Also notice that we are not assuming dis(vt, span(S)) = ∆.\nNow we rewrite aj as ctvt + (1− ct)w, where w is a vector in the convex hull of vertices other than vt. Observe that aj must be far from span(S), because dj is the farthest point found by the algorithm. Indeed:\ndis(aj , span(S)) ≥ dis(dj , span(S))− ≥ dis(vl, span(S))− 2 ≥ ∆− 2\nThe second inequality is because there must be some point dl that correspond to the farthest vertex vl and have dis(dl, span(S)) ≥ ∆ − . Thus as dj is the farthest point dis(dj , span(S)) ≥ dis(dl, span(S)) ≥ ∆− .\nThe point aj is on the segment connecting vt and w, the distance between aj and span(S) is not much smaller than that of vt and w. Following the intuition in `2 norm when vt and w are far we would expect aj to be very close to either vt or w. Since ct ≥ 1/K it cannot be really close to w, so it must be really close to vt. We formalize this intuition by the following calculation (see Figure 8):\nProject everything to the orthogonal subspace of span(S) (points in span(S) are now at the origin). After projection distance to span(S) is just the `2 norm of a vector. Without loss of generality we assume ‖vt‖2 = ‖w‖2 = ∆ because these two have length at most ∆, and extending these two vectors to have length ∆ can only increase the length of dj .\nThe point vt must be far from w by applying Lemma A.1: consider the set of vertices V ′ = {vi : vi does not correspond to any point in S and i 6= t}. The set V ′ ∪ S satisfy the assumptions in Lemma A.1 so there must be one vertex that is far from span(V ′ ∪ S), and it can only be vt. Therefore even after projecting to orthogonal subspace of span(S), vt is still far from any convex combination of V ′. The vertices that are not in V ′ all have very small norm after projecting to orthogonal subspace (at most δ0) so we know the distance of vt and w is at least γ/2− δ0 > γ/4.\nNow the problem becomes a two dimensional calculation. When ct is fixed the length of aj is strictly increasing when the distance of vt and w decrease, so we assume the distance is γ/4. Simple calculation (using essentially just pythagorean theorem) shows\nct(1− ct) ≤ ∆− √ ∆2 − γ2/16 .\nThe right hand side is largest when ∆ = 2 (since the vectors are in unit ball) and the maximum value is O( /γ2). When this value is smaller than 1/K, we must have 1 − ct ≤ O( /γ2). Thus ct ≥ 1−O( /γ2) and δ ≤ (1− ct) + ≤ O( /γ2).\nThe cleanup phase tries to find the farthest point to a subset of K − 1 vertices, and use that point as the K-th vertex. This will improve the result because when we have K − 1 points close to K − 1 vertices, only one of the vertices can be far from their span. Therefore the farthest point must be close to the only remaining vertex. Another way of viewing this is that the algorithm is trying to greedily maximize the volume of the simplex, which makes sense because the larger the volume is, the more words/documents the final LDA model can explain.\nThe following lemma makes the intuitions rigorous and shows how cleanup improves the guarantee of Lemma A.2.\nLemma A.5. Suppose |S| = K−1 and each point in S is δ = O( /γ2) < γ/20K close to some vertex vi, then the farthest point v ′ j found by the algorithm is 1−O( /γ) close to the remaining vertex.\nProof: We still look at the original point aj and express it as ∑K\nt=1 ctvt. Without loss of generality let v1 be the vertex that does not correspond to anything in S. By Lemma A.1 v1 is γ/2 far from span(S). On the other hand all other vertices are at least γ/20r close to span(S). We know the distance dis(aj , span(S)) ≥ dis(v1, span(S))− 2 , this cannot be true unless ct ≥ 1−O( /γ).\nThese lemmas directly lead to the following theorem:\nTheorem A.6. FastAnchorWords algorithm runs in time Õ(V 2 +V K/ 2) and outputs a subset of {d1, ..., dV } of size K that O( /γ)-covers the vertices provided that 20K /γ2 < γ.\nProof: In the first phase of the algorithm, do induction using Lemma A.2. When 20K /γ2 < γ Lemma A.2 shows that we find a set of points that O( /γ2)-covers the vertices. Now Lemma A.5 shows after cleanup phase the points are refined to O( /γ)-cover the vertices."
    }, {
      "heading" : "B Proof for Nonnegative Recover Procedure",
      "text" : "In order to show RecoverL2 learns the parameters even when the rows of Q̄ are perturbed, we need the following lemma that shows when columns of Q̄ are close to the expectation, the posteriors c computed by the algorithm is also close to the true value.\nLemma B.1. For a γ robust simplex S with vertices {v1, v2, ..., vK}, let v be a point in the simplex that can be represented as a convex combination v = ∑K i=1 civi. If the vertices of S are perturbed to S′ = {..., v′i, ...} where ‖v′i − vi‖ ≤ δ1 and v is perturbed to v′ where ‖v − v′‖ ≤ δ2. Let v∗ be the point in S′ that is closest to v′, and v∗ = ∑K i=1 c ′ ivi, when 10 √ Kδ1 ≤ γ for all i ∈ [K] |ci − c′i| ≤ 4(δ1 + δ2)/γ.\nProof: Consider the point u = ∑K\ni=1 civ ′ i, by triangle inequality: ‖u− v‖ ≤ ∑K i=1 ci ‖vi − v′i‖ ≤ δ1.\nHence ‖u− v′‖ ≤ ‖u− v‖+ ‖v − v′‖ ≤ δ1 + δ2, and u is in S′. The point v∗ is the point in S′ that is closest to v′, so ‖v∗ − v′‖ ≤ δ1 + δ2 and ‖v∗ − u‖ ≤ 2(δ1 + δ2).\nThen we need to show when a point (u) moves a small distance, its representation also changes by a small amount. Intuitively this is true because S is γ robust. By Lemma A.1 when 10 √ Kδ1 < γ,\nthe simplex S′ is also γ/2 robust. For any i, let Proji(v ∗) and Proji(u) be the projections of v ∗ and u in the orthogonal subspace of span(S′\\v′i), then\n|ci − c′i| = ‖Proji(v∗)− Proji(u)‖ /dis(vi, span(S′\\v′i)) ≤ 4(δ1 + δ2)/γ\nand this completes the proof.\nWith this lemma it is not hard to show that RecoverL2 has polynomial sample complexity.\nTheorem B.2. When the number of documents M is at least\nmax{O(aK3 log V/D(γp)6 ), O((aK)3 log V/D 3(γp)4)}\nour algorithm using the conjunction of FastAnchorWords and RecoverL2 learns the A matrix with entry-wise error at most .\nProof: (sketch) We can assume without loss of generality that each word occurs with probability at least /4aK and furthermore that if M is at least 50 log V/D 2Q then the empirical matrix Q̃ is entry-wise within an additive Q to the true Q = 1 M ∑M d=1AWdW T d A\nT see [Arora et al., 2012b] for the details. Also, the K anchor rows of Q̄ form a simplex that is γp robust.\nThe error in each column of Q̄ can be at most δ2 = Q √\n4aK/ . By Theorem A.6 when 20Kδ2/(γp)\n2 < γp (which is satisfied when M = O(aK3 log V/D(γp)6 )) , the anchor words found are δ1 = O(δ2/(γp)) close to the true anchor words. Hence by Lemma B.1 every entry of C has error at most O(δ2/(γp)\n2). With such number of documents, all the word probabilities p(w = i) are estimated more accurately than the entries of Ci,j , so we omit their perturbations here for simplicity. When we apply the Bayes rule, we know Ai,k = Ci,kp(w = i)/p(z = k), where p(z = k) is αk which is lower bounded by 1/aK. The numerator and denominator are all related to entries of C with positive coefficients sum up to at most 1. Therefore the errors δnum and δdenom are at most the error of a single entry of C, which is bounded by O(δ2/(γp)\n2). Applying Taylor’s Expansion to (p(z = k,w = i) + δnum)/(αk + δdenom), the error on entries of A is at most O(aKδ2/(γp)\n2). When Q ≤ O((γp)2 1.5/(aK)1.5), we have O(aKδ2/(γp)2) ≤ , and get the desired accuracy of A. The number of document required is M = O((aK)3 log V/D 3(γp)4).\nThe sample complexity for R can then be bounded using matrix perturbation theory."
    }, {
      "heading" : "C Empirical Results",
      "text" : "This section contains plots for `1, held-out probability, coherence, and uniqueness for all semisynthetic data sets. Up is better for all metrics except `1 error.\nC.1 Sample Topics\nTables 2, 3, and 4 show 100 topics trained on real NY Times articles using the RecoverL2 algorithm. Each topic is followed by the most similar topic (measured by `1 distance) from a model trained on the same documents with Gibbs sampling. When the anchor word is among the top six words by probability it is highlighted in bold. Note that the anchor word is frequently not the most prominent word."
    }, {
      "heading" : "D Algorithmic Details",
      "text" : "D.1 Generating Q matrix\nFor each document, let Hd be the vector in RV such that the i-th entry is the number of times word i appears in document d, nd be the length of the document and Wd be the topic vector chosen according to Dirichlet distribution when the documents are generated. Conditioned on Wd’s, our algorithms require the expectation of Q to be 1M ∑M d=1AWdW T d A\nT . In order to achieve this, similar to [Anandkumar et al., 2012], let the normalized vector\nH̃d = Hd√\nnd(nd−1) and diagonal matrix Ĥd = Diag(Hd) nd(nd−1) . Compute the matrix\nH̃dH̃ T d − Ĥd =\n1 nd(nd − 1) ∑\ni 6=j,i,j∈[nd]\nezd,ie T zd,j .\nHere zd,i is the i-th word of document d, and ei ∈ RV is the basis vector. From the generative model, the expectation of all terms ezd,ie T zd,j are equal to AWdW T d A T , hence by linearity of expectation we know E[H̃dH̃ T d − Ĥd] = AWdW Td AT .\nIf we collect all the column vectors H̃d to form a large sparse matrix H̃, and compute the sum of all Ĥd to get the diagonal matrix Ĥ, we know Q = H̃H̃\nT −Ĥ has the desired expectation. The running time of this step is O(MD2) where D2 is the expectation of the length of the document squared.\nD.2 Exponentiated gradient algorithm\nThe optimization problem that arises in RecoverKL and RecoverL2 has the following form,\nminimize d(b, Tx)\nsubject to: x ≥ 0 and xT1 = 1\nwhere d(·, ·) is a Bregman divergence, x is a vector of length K, and T is a matrix of size V ×K. We solve this optimization problem using the Exponentiated Gradient algorithm [Kivinen & Warmuth, 1995], described in Algorithm 5. In our experiments we show results using both squared Euclidean distance and KL divergence for the divergence measure. Stepsizes are chosen with a line search to find an η that satisfies the Wolfe and Armijo conditions (For details, see Nocedal & Wright\n[2006]). We test for convergence using the KKT conditions. Writing the KKT conditions for our constrained minimization problem:\n1. Stationarity: ∇xd(b, Tx∗)− ~λ+ µ1 = 0\n2. Primal Feasibility: x∗ ≥ 0, |x∗|1 = 1\n3. Dual Feasibility: λ ≥ 0\n4. Complementary Slackness: λix ∗ i = 0\nFor every iterate of x generated by Exponentiated Gradient, we set λ, µ to satisfy conditions 1-3. This gives the following equations:\nλ = ∇xd(b, Tx∗) + µ1 µ = −(∇xd(b, Tx∗))min\nBy construction conditions 1-3 are satisfied (note that the multiplicative update and the projection step ensure that x is always primal feasible). Convergence is tested by checking whether the final KKT condition holds within some tolerance. Since λ and x are nonnegative, we check complimentary slackness by testing whether λTx < . This convergence test can also be thought of as testing the value of the primal-dual gap, since the Lagrangian function has the form: L(x, λ, µ) = d(b, Tx)− λTx+ µ(xT1− 1), and (xT1− 1) is zero at every iteration.\nThe running time of RecoverL2 is the time of solving V small (K × K) quadratic programs. Especially when using Exponentiated Gradient to solve the quadratic program, each word requires O(KV ) time for preprocessing and O(K2) per iteration. The total running time is O(KV 2+K2V T ) where T is the average number of iterations. The value of T is about 100−1000 depending on data sets.\nAlgorithm 5. Exponentiated Gradient Input: Matrix T , vector b, divergence measure d(·, ·), tolerance parameter Output: non-negative normalized vector x close to x∗, the minimizer of d(b, Tx)\nInitialize x← 1K1 Initialize Converged ← False while not Converged do\np = ∇d(b, Tx) Choose a step size ηt x← xe−ηtp (Gradient step) x← x|x|1 (Projection onto the simplex) µ← ∇d(b, Tx)min λ← ∇d(b, Tx)− µ Converged ← λTx <\nend while"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2012,
    "abstractText" : "Topic models provide a useful method for dimensionality reduction and exploratory data<lb>analysis in large text corpora. Most approaches to topic model inference have been based on<lb>a maximum likelihood objective. Efficient algorithms exist that approximate this objective,<lb>but they have no provable guarantees. Recently, algorithms have been introduced that provide<lb>provable bounds, but these algorithms are not practical because they are inefficient and not ro-<lb>bust to violations of model assumptions. In this paper we present an algorithm for topic model<lb>inference that is both provable and practical. The algorithm produces results comparable to the<lb>best MCMC implementations while running orders of magnitude faster.",
    "creator" : "LaTeX with hyperref package"
  }
}