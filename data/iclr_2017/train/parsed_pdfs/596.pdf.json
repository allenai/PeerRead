{
  "name" : "596.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "IMPLICIT REASONET: MODELING LARGE-SCALE STRUCTURED RELATIONSHIPS WITH SHARED MEM- ORY",
    "authors" : [ "Yelong Shen", "Po-Sen Huang", "Ming-Wei Chang", "Jianfeng Gao" ],
    "emails" : [ "yeshen@microsoft.com", "pshuang@microsoft.com", "minchang@microsoft.com", "jfgao@microsoft.com" ],
    "sections" : [ {
      "heading" : "1 INTRODUCTION",
      "text" : "Knowledge bases such as WordNet (Fellbaum, 1998), Freebase (Bollacker et al., 2008), or Yago (Suchanek et al., 2007) contain many real-world facts expressed as triples, e.g., (Bill Gates, FounderOf, Microsoft). These knowledge bases are useful for many downstream applications such as question answering (Berant et al., 2013; Yih et al., 2015) and information extraction (Mintz et al., 2009). However, despite the formidable size of knowledge bases, many important facts are still missing. For example, West et al. (2014) showed that 21% of the 100K most frequent PERSON entities have no recorded nationality in a recent version of Freebase. We seek to infer unknown relations based on the observed triples. Thus, the knowledge base completion (KBC) task has emerged an important open research problem (Nickel et al., 2011).\nNeural-network based methods have been very popular for solving the KBC task. Following Bordes et al. (2013), one of the most popular approaches for KBC is to learn vector-space representations of entities and relations during training, and then apply linear or bi-linear operations to infer the missing relations at test time. However, several recent papers demonstrate limitations of prior approaches relying upon vector-space models alone. By themselves, there is no straightforward way to capture the structured relationships between multiple triples adequately (Guu et al., 2015; Toutanova et al., 2016; Lin et al., 2015a). For example, assume that we want to fill in the missing relation for the triple (Obama, NATIONALITY, ?), a multi-step search procedure might be needed to discover the evidence in the observed triples such as (Obama, BORNIN, Hawaii) and (Hawaii, PARTOF, U.S.A). To address this issue, Guu et al. (2015); Toutanova et al. (2016); Lin et al. (2015a) propose different approaches of injecting structured information by directly operating on the observed triplets. Unfortunately, due to the size of knowledge bases, these newly proposed approaches suffer from some limitations, as most paths are not informative for inferring missing relations, and it is prohibitive to consider all possible paths during the training time with expressive models.\nIn this paper, we take a different approach from prior work on KBC by addressing the challenges of performing large-scale inference through the design of search controller and shared memory. Our inference procedure centers around the search controller, which only operates on the shared memory instead of directly manipulating the observed triples in knowledge base. IRNs use training data to\n∗Equal contribution.\nlearn to perform multi-step inference through the shared memory. First, input module generates a representation of the query. Then, the search controller repeatedly interacts with the shared memory and checks the termination gate. After each iteration, if the termination condition is met, the model stops the search process and calls the output module to generate a prediction. The shared memory is designed to store key information about the overall structures it learned during training, and hence the search controller only needs to access the shared memory instead of operating on the observed triples.\nThere are several advantages of using IRNs. First, the cost of inference can be controlled because the search controller only needs to access the shared memory. Second, all the modules, including the search controller and memory, are jointly trained, and hence alleviate the needs to inject structured relationships between instances manually. Finally, we can easily extend IRNs to other tasks that require modeling structured relationships between instances by switching the input and output modules.\nThe main contributions of our paper are as follows:\n• We propose Implicit ReasoNets (IRNs), which use a shared memory guided by a search controller to model large-scale structured relationships implicitly.\n• We evaluate IRNs and demonstrate that our proposed model achieves the state-of-the-art results on the popular FB15k benchmark, surpassing prior approaches by more than 5.7%.\n• We analyze the behavior of IRNs for shortest path synthesis. We show that IRNs outperform a standard sequence-to-sequence model and execute meaningful multi-step inference."
    }, {
      "heading" : "2 REASONET FOR IMPLICIT INFERENCE",
      "text" : "In this section, we describe the general architecture of IRNs in a way that is agnostic to KBC. IRNs are composed of four main components: an input component, an output component, a shared memory, and a search controller, as shown in Figure 1. In this section, we briefly describe each component.\nInput/Output Modules: These two modules are task-dependent. The input module takes a query and converts the query into a vector representation q. The output module is a function fo, which converts the hidden state received from the search controller (s) into an output O. We optimize the whole\nmodel using the output prediction O with respect to a ground-truth target using a task-specified loss function.\nShared Memory: The shared memory is denoted as M . It consists of a list of memory vectors, M = {mi}i=1...I , where mi is a fixed dimensional vector. The memory vectors are randomly initialized and automatically updated through back-propagation. The shared memory component is shared across all instances.\nSearch Controller: The search controller is a recurrent neural network and controls the search process by keeping internal state sequences to track the current search process and history. The search controller uses an attention mechanism to fetch information from relevant memory vectors in M , and decides if the model should output the prediction or continue to generate the next possible output.\n• Internal State: The internal state of the search controller is denoted as S, which is a vector representation of the search process. The initial state s1 is usually the vector representation of the input vector q. The internal state at t-th time step is represented by st. The sequence of internal states is modeled by an RNN: st+1 = RNN(st, xt; θs).\n• Attention to memory: The attention vector xt at t-th time step is generated based on the current internal state st and the shared memory M : xt = fatt(st,M ; θx). Specifically, the attention score at,i on a memory vector mi given a state st is computed as at,i = softmaxi=1,...,|M |λ cos(W1mi,W2st), where λ is set to 10 in our experiments and the weight matrices W1 and W2 are learned during training. The attention vector xt can be written as xt = fatt(st,M ; θx) = ∑|M | i at,imi.\n• Termination Control: The terminate gate produces a stochastic random variable according to the current internal state, tt ∼ p(·|ftc(st; θtc))). tt is a binary random variable. If tt is true, the IRN will finish the search process, and the output module will execute at time step t; otherwise the IRN will generate the next attention vector xt+1 and feed into the state network to update the next internal state st+1. In our experiments, the termination variable is modeled by a logistical regression: ftc(st; θtc) = sigmoid(Wtcst + btc), where the weight matrix Wtc and bias vector btc are learned during training.\nCompared IRNs to Memory Networks (MemNN) (Weston et al., 2014; Sukhbaatar et al., 2015; ?) and Neural Turing Machines (NTM) (Graves et al., 2014; 2016), the biggest difference between our model and the existing frameworks is the search controller and the use of the shared memory. We build upon our previous work (Shen et al., 2016) for using a search controller module to dynamically perform a multi-step inference depending on the complexity of the instance. MemNN and NTM explicitly store inputs (such as graph definition, supporting facts) in the memory. In contrast, in IRNs, we do not explicitly store all the observed inputs in the shared memory. Instead, we directly operate on the shared memory, which modeling the structured relationships implicitly. We randomly initialize the memory and update the memory with respect to task-specific objectives. The idea of exploiting shared memory is proposed by Munkhdalai & Yu (2016) independently. Despite of using the same term, the goal and the operations used by IRNs are different from the one used in Munkhdalai & Yu (2016), as IRNs allow the model to perform multi-step for each instance dynamically."
    }, {
      "heading" : "2.1 STOCHASTIC INFERENCE PROCESS",
      "text" : "The inference process of an IRN is as follows. First, the model converts a task-dependent input to a vector representation through the input module. Then, the model uses the input representation to initialize the search controller. In every time step, the search controller determines whether the process is finished by sampling from the distribution according to the terminate gate. If the outcome is termination, the output module will generate a task-dependent prediction given the search controller states. If the outcome is continuation, the search controller will move on to the next time step, and create an attention vector based on the current search controller state and the shared memory. Intuitively, we design whole process by mimicking a search procedure that iteratively finds its target through a structure and output its prediction when a satisfying answer is found. The detailed inference process is described in Algorithm 1.\nThe inference process of an IRN is considered as a Partially Observable Markov Decision Process (POMDP) (Kaelbling et al., 1998) in the reinforcement learning (RL) literature. The IRN produces\nAlgorithm 1: Stochastic Inference Process in an IRN Input :Randomly initialized shared memory M ; Input vector q; Maximum step Tmax Output :Output vector o\n1 Define s1 = q; t = 1; 2 Sample tt from the distribution p(·|ftc(st; θtc)); 3 if tt is false, go to Step 4; otherwise Step 7; 4 Generate an attention vector xt = fatt(st,M ; θx); 5 Update the internal state st+1 = RNN(st, xt; θs); 6 Set t = t+ 1; if t < Tmax go to Step 2; otherwise Step 7; 7 Generate output ot = fo(st; θo); 8 Return o = ot;\nthe output vector oT at the T -th step, which implies termination gate variables t1:T = (t1 = 0, t2 = 0, ..., tT−1 = 0, tT = 1), and then takes prediction action pT according to the probability distribution given oT . Therefore, the IRN learns a stochastic policy π((t1:T , pT )|q; θ) with parameters θ to get a distribution over termination actions, and over prediction actions. The termination step T varies from instance to instance. The parameters of the IRN θ are given by the parameters of the embedding matrices W for the input/output module, the shared memory M , the attention network θx, the search controller RNN network θs, the output generation network θo, and the termination gate network θtc. The parameters θ = {W,M, θx, θs, θo, θtc} are trained to maximize the total expected reward that the IRN when interacting with the environment. The expected reward for an instance is defined as:\nJ(θ) = Eπ(t1:T ,pT ;θ) [ T∑ t=1 rt ]\nThe reward can only be received at the final termination step when a prediction action pT is performed. The rewards on intermediate steps are zeros, {rt = 0}t=1...T−1. We employ the approach from our previous work (Shen et al., 2016), REINFORCE (Williams, 1992) based Contrastive Reward method, to maximize the expected reward. The gradient of J can be written as:\n∇θJ(θ) = ∑\n(t1:T ,pT )∈A† π(t1:T , pT ; θ)\n[ ∇θlogπ(t1:T , pT ; θ)(\nrT bi − 1)\n]\nwhere A† is all the possible episodes, the baseline bi = ∑\n(t1:T ,pT )∈A† π(t1:T , pT ; θ)rT is the expected reward on the |A†| episodes for the i-th training instance.\n3 APPLYING IRNS TO KNOWLEDGE BASE COMPLETION\nThe goal of KBC tasks (Bordes et al., 2013) is to predict a head or a tail entity given the relation type and the other entity, i.e. predicting h given (?, r, t) or predicting t given (h, r, ?), where ? denotes the missing entity. For a KBC task, the input to our model is a subject entity (a head or tail entity) and a relation. The task-dependent input module first extracts the embedding vectors for the entity and relation from an embedding matrix. We then represent the query vector q for an IRN as the concatenation of the two vectors. We randomly initialize the shared memory component. At each step, a training triplet is processed through the model by Algorithm 1, where no explicit path information is given. The IRN updates the shared memory implicitly with respect to the objective function. For the task dependent output module, we use a nonlinear projection to project the search controller state into an output vector o: fo(st; θo) = tanh(Wost + bo), where the Wo and bo are the weight matrix and bias vector, respectively. We define the ground truth target (object) entity embedding as y, and use the L1 distance measure between the output o and target entity y, namely d(o, y) = |o− y|1. We sample a set of incorrect entity embeddings N = {y−i } |N | i=1 as negative examples. The probability of\nselecting a prediction ŷ ∈ D can be approximated as\np(ŷ|o) = exp(−γd(o, ŷ))∑ yk∈D exp(−γd(o, yk))\nwhere D = N ∪ {y}. We set |N | and γ to 20 and 5, respectively, for the experiments on FB15k and WN18 datasets. The IRN performs a prediction action pT on selecting ŷ with probability p(ŷ|o) . We define the reward of the prediction action as one if the ground truth entity is selected, and zero otherwise."
    }, {
      "heading" : "4 EXPERIMENTAL RESULTS",
      "text" : "In this section, we evaluate the performance of our model on the benchmark FB15k and WN18 datasets for KBC tasks (Bordes et al., 2013). These datasets contain multi-relations between head and tail entities. Given a head entity and a relation, the model produces a ranked list of the entities according to the score of the entity being the tail entity of this triple. To evaluate the ranking, we report mean rank (MR), the mean of rank of the correct entity across the test examples, and hits@10, the proportion of correct entities ranked in the top-10 predictions. Lower MR or higher hits@10 indicates a better prediction performance. We follow the evaluation protocol in Bordes et al. (2013) to report filtered results, where negative examples N are removed from the dataset. In this case, we can avoid some negative examples being valid and ranked above the target triplet.\nWe use the same hyper-parameters of our model for both FB15k and WN18 datasets. Entity embeddings (which are not shared between input and output modules) and relation embedding are both 100-dimensions. We use the input module and output module to encode subject and object entities, respectively. There are 64 memory vectors with 200 dimensions each, initialized by random vectors with unit L2-norm. We use single-layer GRU with 200 cells as the search controller. We set the maximum inference step of the IRN to 5. We randomly initialize all model parameters, and use SGD as the training algorithm with mini-batch size of 64. We set the learning rate to a constant number, 0.01. To prevent the model from learning a trivial solution by increasing entity embeddings norms, we follow Bordes et al. (2013) to enforce the L2-norm of the entity embeddings as 1. We use hits@10 as the validation metric for the IRN. Following the work (Lin et al., 2015a), we add reverse relations into the training triplet set to increase the training data.\nFollowing Nguyen et al. (2016), we divide the results of previous work into two groups. The first group contains the models that directly optimize a scoring function for the triples in a knowledge base without using extra information. The second group of models make uses of additional information from multi-step relations. For example, RTransE (García-Durán et al., 2015) and PTransE (Lin et al., 2015a) models are extensions of the TransE (Bordes et al., 2013) model by explicitly exploring multi-step relations in the knowledge base to regularize the trained embeddings. The NLFeat model (Toutanova et al., 2015) is a log-linear model that makes use of simple node and link features.\nTable 1 presents the experimental results. According to the table, our model significantly outperforms previous baselines, regardless of whether previous approaches use additional information or not. Specifically, on FB15k, the MR of our model surpasses all previous results by 12, and our hit@10 outperforms others by 5.7%. On WN18, the IRN obtains the highest hit@10 while maintaining similar MR results compared to previous work.1\nTo better understand the behavior of IRNs, we report the results of IRNs with different memory sizes and different Tmax on FB15K in Table 2. We find the performance of IRNs increases significantly if the number of inference step increases. Note that an IRN with Tmax = 1 is the case that an IRN without the shared memory. Interestingly, given Tmax = 5, IRNs are not sensitive to memory sizes. In particular, larger memory always improves the MR score, but the best hit@10 is obtained by |M | = 64 memory vectors. A possible reason is that the best memory size is determined by the complexity of the tasks.\nWe analyze hits@10 results on FB15k with respect to the relation categories. Following the evaluation in Bordes et al. (2013), we evaluate the performance in four types of relation: 1-1 if a head entity\n1Nguyen et al. (2016) reported two results on WN18, where the first one is obtained by choosing to optimize hits@10 on the validation set, and second one is obtained by choosing to optimize MR on the validation set. We list both of them in Table 1.\ncan appear with at most one tail entity, 1-Many if a head entity can appear with many tail entities, Many-1 if multiple heads can appear with the same tail entity, and Many-Many if multiple head entities can appear with multiple tail entities. The detailed results are shown in Table 3. The IRN significantly improves the hits@10 results in the Many-1 category on predicting the head entity (18.8%), the 1-Many category on predicting the tail entity (16.5%), and the Many-Many category (over 8% in average).\nTo analyze the behavior of IRNs, we pick some examples for the tail entity prediction in Table 4. Interestingly, we observed that the model can gradually increase the ranking score of the correct tail entity during the inference process.\n5 ANALYSIS: APPLYING IRNS TO A SHORTEST PATH SYNTHESIS TASK\nWe construct a synthetic task, shortest path synthesis, to evaluate the inference capability over a shared memory. The motivations of applying our model to this task are as follows. First, we want to evaluate IRNs on another task requiring multi-step inference. Second, we select the sequence generation task so that we are able to analyze the inference capability of IRNs in details.\nIn the shortest path synthesis task, as illustrated in Figure 2, a training instance consists of a start node and an end node (e.g., 215 493) of an underlying weighted directed graph that is unknown to models. The output of each instance is the shortest path between the given start and end nodes of the underlying graph (e.g., 215→ 101→ 493). Specifically, models can only observe the start-end node\npairs as input and their shortest path as output. The whole graph is unknown to the models and the edge weights are not revealed in the training data. At test time, a path sequence is considered correct if it connects the start node and the end node of the underlying graph, and the cost of the predicted path is the same as the optimal path.\nNote that the task is very difficult and cannot be solved by dynamic programming algorithms since the weights on the edges are not revealed to the algorithms or the models. To recover some of the shortest paths at the test time, the model needs to infer the correct path from the observed instances. For example, assume that we observe two instances in the training data, “A D: A→ B → G→ D” and “B E: B → C → E”. In order to answer the shortest path between A and E, the model needs to infer that “A→ B → C → E” is a possible path between A and E. If there are multiple possible paths, the model has to decide which one is the shortest one using statistical information.\nIn the experiments, we construct a graph with 500 nodes and we randomly assign two nodes to form an edge. We split 20,000 instances for training, 10,000 instances for validation, and 10,000 instances for testing. We create the training and testing instances carefully so that the model needs to perform inference to recover the correct path. We describe the details of the graph and data construction parts in the appendix section. A sub-graph of the data is shown in Figure 2.\nFor the settings of the IRN, we switch the output module to a GRU decoder for a sequence generation task. We assign reward rT = 1 if all the prediction symbols are correct and 0 otherwise. We use a 64-dimensional embedding vector for input symbols, a GRU controller with 128 cells, and a GRU decoder with 128 cells. We set the maximum inference step Tmax to 5.\nWe compare the IRN with two baseline approaches: dynamic programming without edge-weight information and a standard sequence-to-sequence model (Sutskever et al., 2014) using a similar parameter size to our model. Without knowing the edge weights, dynamic programming only recovers 589 correct paths at test time. The sequence-to-sequence model recovers 904 correct paths. The IRN outperforms both baselines, recovering 1,319 paths. Furthermore, 76.9% of the predicted paths from IRN are valid paths, where a path is valid if the path connects the start and end node nodes of the underlying graph. In contrast, only 69.1% of the predicted paths from the sequence-to-sequence model are valid.\nTo further understand the inference process of the IRN, Figure 2 shows the inference process of a test instance. Interestingly, to make the correct prediction on this instance, the model has to perform a fairly complicated inference.2 We observe that the model cannot find a connected path in the first three steps. Finally, the model finds a valid path at the forth step and predict the correct shortest path sequence at the fifth step."
    }, {
      "heading" : "6 RELATED WORK",
      "text" : "Link Prediction and Knowledge Base Completion Given that r is a relation, h is the head entity, and t is the tail entity, most of the embedding models for link prediction focus on finding the scoring function fr(h, t) that represents the implausibility of a triple. (Bordes et al., 2011; 2014; 2013; Wang et al., 2014; Ji et al., 2015; Nguyen et al., 2016). In many studies, the scoring function fr(h, t) is linear or bi-linear. For example, in TransE (Bordes et al., 2013), the function is implemented as fr(h, t) = ‖h+ r− t‖, where h, r and t are the corresponding vector representations. Recently, different studies (Guu et al., 2015; Lin et al., 2015a; Toutanova et al., 2016) demonstrate the importance for models to also learn from multi-step relations. Learning from multi-step relations injects the structured relationships between triples into the model. However, this also poses a technical challenge of considering exponential numbers of multi-step relationships. Prior approaches address this issue by designing path-mining algorithms (Lin et al., 2015a) or considering all possible paths using a dynamic programming algorithm with the restriction of using linear or bi-linear models only (Toutanova et al., 2016). Toutanova & Chen (2015) shows the effectiveness of using simple node and link features that encode structured information on FB15k and WN18. In our work, the IRN outperforms prior results and shows that similar information can be captured by the model without explicitly designing features.\n2 In the example, to find the right path, the model needs to search over observed instances “215 448: 215→ 101→ 448” and “76 493: 76→ 308→ 101→ 493”, and to figure out the distance of “140→ 493” is longer than “101→ 493” (there are four shortest paths between 101→ 493 and three shortest paths between 140→ 493 in the training set).\nStudies such as (Riedel et al., 2013) show that incorporating textual information can further improve the knowledge base completion tasks. It would be interesting to incorporate the information outside the knowledge bases in our model in the future.\nNeural Frameworks Sequence-to-sequence models (Sutskever et al., 2014; Cho et al., 2014) have shown to be successful in many applications such as machine translation and conversation modeling (Sordoni et al., 2015). While sequence-to-sequence models are powerful, recent work has shown that the necessity of incorporating an external memory to perform inference in simple algorithmic tasks (Graves et al., 2014; 2016)."
    }, {
      "heading" : "7 CONCLUSION",
      "text" : "In this paper, we propose Implicit ReasoNets (IRNs), which perform inference over a shared memory that models large-scale structured relationships implicitly. The inference process is guided by a search controller to access the memory that is shared across instances. We demonstrate and analyze the multi-step inference capability of IRNs in the knowledge base completion tasks and a shortest path synthesis task. Our model, without using any explicit knowledge base information in the inference procedure, outperforms all prior approaches on the popular FB15k benchmark by more than 5.7%.\nFor future work, we aim to further extend IRNs in two ways. First, inspired from Ribeiro et al. (2016), we would like to develop techniques to exploit ways to generate human understandable reasoning interpretation from the shared memory. Second, we plan to apply IRNs to infer the relationships in unstructured data such as natural language. For example, given a natural language query such as “are rabbits animals?”, the model can infer a natural language answer implicitly in the shared memory without performing inference directly on top of huge amount of observed sentences such as “all mammals are animals” and “rabbits are animals”. We believe the ability to perform inference implicitly is crucial for modeling large-scale structured relationships."
    }, {
      "heading" : "ACKNOWLEDGMENTS",
      "text" : "We thank Scott Wen-Tau Yih, Kristina Toutanova, Jian Tang and Zachary Lipton for their thoughtful feedback and discussions."
    }, {
      "heading" : "A DETAILS OF THE GRAPH CONSTRUCTION FOR THE SHORTEST PATH SYNTHESIS TASK",
      "text" : "We construct the underlying graph as follows: on a three-dimensional unit-sphere, we randomly generate a set of nodes. For each node, we connect its K-nearest neighbors and use the euclidean distance between two nodes to construct a graph. We randomly sample two nodes and compute its shortest path if it is connected between these two nodes. Given the fact that all the sub-paths within a shortest path are shortest paths, we incrementally create the dataset and remove the instances which are a sub-path of previously selected paths or are super-set of previous selected paths. In this case, all the shortest paths can not be answered through directly copying from another instance. In addition, all the weights in the graph are hidden and not shown in the training data, which increases the difficulty of the tasks. We set k = 50 as a default value."
    } ],
    "references" : [ {
      "title" : "Semantic parsing on Freebase from questionanswer pairs",
      "author" : [ "Jonathan Berant", "Andrew Chou", "Roy Frostig", "Percy Liang" ],
      "venue" : "In Proceedings of EMNLP,",
      "citeRegEx" : "Berant et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Berant et al\\.",
      "year" : 2013
    }, {
      "title" : "Freebase: A collaboratively created graph database for structuring human knowledge",
      "author" : [ "Kurt Bollacker", "Colin Evans", "Praveen Paritosh", "Tim Sturge", "Jamie Taylor" ],
      "venue" : "In Proceedings of SIGMOD-08,",
      "citeRegEx" : "Bollacker et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Bollacker et al\\.",
      "year" : 2008
    }, {
      "title" : "Learning structured embeddings of knowledge bases",
      "author" : [ "Antoine Bordes", "Jason Weston", "Ronan Collobert", "Yoshua Bengio" ],
      "venue" : "In Proceedings of the Twenty-Fifth AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "Bordes et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Bordes et al\\.",
      "year" : 2011
    }, {
      "title" : "Translating embeddings for modeling multi-relational data",
      "author" : [ "Antoine Bordes", "Nicolas Usunier", "Alberto Garcia-Duran", "Jason Weston", "Oksana Yakhnenko" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Bordes et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Bordes et al\\.",
      "year" : 2013
    }, {
      "title" : "A semantic matching energy function for learning with multi-relational data",
      "author" : [ "Antoine Bordes", "Xavier Glorot", "Jason Weston", "Yoshua Bengio" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Bordes et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Bordes et al\\.",
      "year" : 2014
    }, {
      "title" : "Learning phrase representations using rnn encoder-decoder for statistical machine translation",
      "author" : [ "Kyunghyun Cho", "Bart Van Merriënboer", "Caglar Gulcehre", "Dzmitry Bahdanau", "Fethi Bougares", "Holger Schwenk", "Yoshua Bengio" ],
      "venue" : "arXiv preprint arXiv:1406.1078,",
      "citeRegEx" : "Cho et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Cho et al\\.",
      "year" : 2014
    }, {
      "title" : "WordNet: An Electronic Lexical Database",
      "author" : [ "C. Fellbaum" ],
      "venue" : null,
      "citeRegEx" : "Fellbaum.,? \\Q1998\\E",
      "shortCiteRegEx" : "Fellbaum.",
      "year" : 1998
    }, {
      "title" : "Composing relationships with translations",
      "author" : [ "Alberto García-Durán", "Antoine Bordes", "Nicolas Usunier" ],
      "venue" : "In EMNLP, pp",
      "citeRegEx" : "García.Durán et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "García.Durán et al\\.",
      "year" : 2015
    }, {
      "title" : "Combining two and three-way embeddings models for link prediction in knowledge",
      "author" : [ "Alberto García-Durán", "Antoine Bordes", "Nicolas Usunier", "Yves Grandvalet" ],
      "venue" : "bases. CoRR,",
      "citeRegEx" : "García.Durán et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "García.Durán et al\\.",
      "year" : 2015
    }, {
      "title" : "Neural turing machines",
      "author" : [ "Alex Graves", "Greg Wayne", "Ivo Danihelka" ],
      "venue" : "arXiv preprint arXiv:1410.5401,",
      "citeRegEx" : "Graves et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Graves et al\\.",
      "year" : 2014
    }, {
      "title" : "Hybrid computing using a neural network with dynamic external memory",
      "author" : [ "Alex Graves", "Greg Wayne", "Malcolm Reynolds", "Tim Harley", "Ivo Danihelka", "Agnieszka Grabska-Barwińska", "Sergio Gómez Colmenarejo", "Edward Grefenstette", "Tiago Ramalho", "John Agapiou" ],
      "venue" : null,
      "citeRegEx" : "Graves et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Graves et al\\.",
      "year" : 2016
    }, {
      "title" : "Traversing knowledge graphs in vector space",
      "author" : [ "Kelvin Guu", "John Miller", "Percy Liang" ],
      "venue" : "arXiv preprint arXiv:1506.01094,",
      "citeRegEx" : "Guu et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Guu et al\\.",
      "year" : 2015
    }, {
      "title" : "Learning to represent knowledge graphs with gaussian embedding",
      "author" : [ "Shizhu He", "Kang Liu", "Guoliang Ji", "Jun Zhao" ],
      "venue" : "In Proceedings of the 24th ACM International on Conference on Information and Knowledge Management,",
      "citeRegEx" : "He et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "He et al\\.",
      "year" : 2015
    }, {
      "title" : "Knowledge graph embedding via dynamic mapping matrix",
      "author" : [ "Guoliang Ji", "Shizhu He", "Liheng Xu", "Kang Liu", "Jun Zhao" ],
      "venue" : "In ACL,",
      "citeRegEx" : "Ji et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Ji et al\\.",
      "year" : 2015
    }, {
      "title" : "Planning and acting in partially observable stochastic domains",
      "author" : [ "Leslie Pack Kaelbling", "Michael L. Littman", "Anthony R. Cassandra" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Kaelbling et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Kaelbling et al\\.",
      "year" : 1998
    }, {
      "title" : "Modeling relation paths for representation learning of knowledge bases",
      "author" : [ "Yankai Lin", "Zhiyuan Liu", "Huanbo Luan", "Maosong Sun", "Siwei Rao", "Song Liu" ],
      "venue" : "In Proceedings of the Conference on Empirical Methods for Natural Language Processing (EMNLP),",
      "citeRegEx" : "Lin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lin et al\\.",
      "year" : 2015
    }, {
      "title" : "Learning entity and relation embeddings for knowledge graph completion",
      "author" : [ "Yankai Lin", "Zhiyuan Liu", "Maosong Sun", "Yang Liu", "Xuan Zhu" ],
      "venue" : "In Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "Lin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lin et al\\.",
      "year" : 2015
    }, {
      "title" : "Distant supervision for relation extraction without labeled data",
      "author" : [ "Mike Mintz", "Steven Bills", "Rion Snow", "Daniel Jurafsky" ],
      "venue" : "In Proceedings of ACL-IJCNLP-09,",
      "citeRegEx" : "Mintz et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Mintz et al\\.",
      "year" : 2009
    }, {
      "title" : "STransE: a novel embedding model of entities and relationships in knowledge bases",
      "author" : [ "Dat Quoc Nguyen", "Kairit Sirts", "Lizhen Qu", "Mark Johnson" ],
      "venue" : "In NAACL,",
      "citeRegEx" : "Nguyen et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Nguyen et al\\.",
      "year" : 2016
    }, {
      "title" : "A three-way model for collective learning on multi-relational data",
      "author" : [ "Maximilian Nickel", "Volker Tresp", "Hans-Peter Kriegel" ],
      "venue" : "In Proceedings of the 28th international conference on machine learning",
      "citeRegEx" : "Nickel et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Nickel et al\\.",
      "year" : 2011
    }, {
      "title" : "why should i trust you?\": Explaining the predictions of any classifier",
      "author" : [ "Marco Tulio Ribeiro", "Sameer Singh", "Carlos Guestrin" ],
      "venue" : null,
      "citeRegEx" : "Ribeiro et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Ribeiro et al\\.",
      "year" : 2016
    }, {
      "title" : "Relation extraction with matrix factorization and universal schemas",
      "author" : [ "Sebastian Riedel", "Limin Yao", "Andrew McCallum", "Benjamin M. Marlin" ],
      "venue" : "In HLT-NAACL,",
      "citeRegEx" : "Riedel et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Riedel et al\\.",
      "year" : 2013
    }, {
      "title" : "Reasonet: Learning to stop reading in machine comprehension",
      "author" : [ "Yelong Shen", "Po-Sen Huang", "Jianfeng Gao", "Weizhu Chen" ],
      "venue" : null,
      "citeRegEx" : "Shen et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Shen et al\\.",
      "year" : 2016
    }, {
      "title" : "Reasoning With Neural Tensor Networks For Knowledge Base Completion",
      "author" : [ "Richard Socher", "Danqi Chen", "Christopher D. Manning", "Andrew Y. Ng" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Socher et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Socher et al\\.",
      "year" : 2013
    }, {
      "title" : "A neural network approach to context-sensitive generation of conversational responses",
      "author" : [ "Alessandro Sordoni", "Michel Galley", "Michael Auli", "Chris Brockett", "Yangfeng Ji", "Margaret Mitchell", "Jian-Yun Nie", "Jianfeng Gao", "Bill Dolan" ],
      "venue" : "arXiv preprint arXiv:1506.06714,",
      "citeRegEx" : "Sordoni et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Sordoni et al\\.",
      "year" : 2015
    }, {
      "title" : "Yago: A Core of Semantic Knowledge",
      "author" : [ "F.M. Suchanek", "G. Kasneci", "G. Weikum" ],
      "venue" : "In WWW,",
      "citeRegEx" : "Suchanek et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Suchanek et al\\.",
      "year" : 2007
    }, {
      "title" : "End-to-end memory networks",
      "author" : [ "Sainbayar Sukhbaatar", "Jason Weston", "Rob Fergus" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Sukhbaatar et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Sukhbaatar et al\\.",
      "year" : 2015
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "Ilya Sutskever", "Oriol Vinyals", "Quoc V Le" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Sutskever et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Sutskever et al\\.",
      "year" : 2014
    }, {
      "title" : "Observed versus latent features for knowledge base and text inference",
      "author" : [ "Kristina Toutanova", "Danqi Chen" ],
      "venue" : "In Proceedings of the 3rd Workshop on Continuous Vector Space Models and their Compositionality,",
      "citeRegEx" : "Toutanova and Chen.,? \\Q2015\\E",
      "shortCiteRegEx" : "Toutanova and Chen.",
      "year" : 2015
    }, {
      "title" : "Representing text for joint embedding of text and knowledge bases",
      "author" : [ "Kristina Toutanova", "Danqi Chen", "Patrick Pantel", "Hoifung Poon", "Pallavi Choudhury", "Michael Gamon" ],
      "venue" : "In EMNLP,",
      "citeRegEx" : "Toutanova et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Toutanova et al\\.",
      "year" : 2015
    }, {
      "title" : "Compositional learning of embeddings for relation paths in knowledge bases and text",
      "author" : [ "Kristina Toutanova", "Xi Victoria Lin", "Scott Wen tau Yih", "Hoifung Poon", "Chris Quirk" ],
      "venue" : null,
      "citeRegEx" : "Toutanova et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Toutanova et al\\.",
      "year" : 2016
    }, {
      "title" : "Knowledge graph embedding by translating on hyperplanes",
      "author" : [ "Zhen Wang", "Jianwen Zhang", "Jianlin Feng", "Zheng Chen" ],
      "venue" : "In Proceedings of the Twenty-Eighth AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "Wang et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2014
    }, {
      "title" : "Mining inference formulas by goal-directed random walks",
      "author" : [ "Zhuoyu Wei", "Jun Zhao", "Kang Liu" ],
      "venue" : "In EMNLP,",
      "citeRegEx" : "Wei et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Wei et al\\.",
      "year" : 2016
    }, {
      "title" : "Knowledge base completion via search-based question answering",
      "author" : [ "Robert West", "Evgeniy Gabrilovich", "Kevin Murphy", "Shaohua Sun", "Rahul Gupta", "Dekang Lin" ],
      "venue" : "In Proceedings of the 23rd international conference on World Wide Web,",
      "citeRegEx" : "West et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "West et al\\.",
      "year" : 2014
    }, {
      "title" : "Simple statistical gradient-following algorithms for connectionist reinforcement learning",
      "author" : [ "Ronald J. Williams" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Williams.,? \\Q1992\\E",
      "shortCiteRegEx" : "Williams.",
      "year" : 1992
    }, {
      "title" : "Embedding entities and relations for learning and inference in knowledge",
      "author" : [ "Bishan Yang", "Wen-tau Yih", "Xiaodong He", "Jianfeng Gao", "Li Deng" ],
      "venue" : "bases. CoRR,",
      "citeRegEx" : "Yang et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Yang et al\\.",
      "year" : 2014
    }, {
      "title" : "Semantic parsing via staged query graph generation: Question answering with knowledge base",
      "author" : [ "Wen-tau Yih", "Ming-Wei Chang", "Xiaodong He", "Jianfeng Gao" ],
      "venue" : "In Proc. of ACL,",
      "citeRegEx" : "Yih et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Yih et al\\.",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "Knowledge bases such as WordNet (Fellbaum, 1998), Freebase (Bollacker et al.",
      "startOffset" : 32,
      "endOffset" : 48
    }, {
      "referenceID" : 1,
      "context" : "Knowledge bases such as WordNet (Fellbaum, 1998), Freebase (Bollacker et al., 2008), or Yago (Suchanek et al.",
      "startOffset" : 59,
      "endOffset" : 83
    }, {
      "referenceID" : 25,
      "context" : ", 2008), or Yago (Suchanek et al., 2007) contain many real-world facts expressed as triples, e.",
      "startOffset" : 17,
      "endOffset" : 40
    }, {
      "referenceID" : 0,
      "context" : "These knowledge bases are useful for many downstream applications such as question answering (Berant et al., 2013; Yih et al., 2015) and information extraction (Mintz et al.",
      "startOffset" : 93,
      "endOffset" : 132
    }, {
      "referenceID" : 36,
      "context" : "These knowledge bases are useful for many downstream applications such as question answering (Berant et al., 2013; Yih et al., 2015) and information extraction (Mintz et al.",
      "startOffset" : 93,
      "endOffset" : 132
    }, {
      "referenceID" : 17,
      "context" : ", 2015) and information extraction (Mintz et al., 2009).",
      "startOffset" : 35,
      "endOffset" : 55
    }, {
      "referenceID" : 19,
      "context" : "Thus, the knowledge base completion (KBC) task has emerged an important open research problem (Nickel et al., 2011).",
      "startOffset" : 94,
      "endOffset" : 115
    }, {
      "referenceID" : 11,
      "context" : "By themselves, there is no straightforward way to capture the structured relationships between multiple triples adequately (Guu et al., 2015; Toutanova et al., 2016; Lin et al., 2015a).",
      "startOffset" : 123,
      "endOffset" : 184
    }, {
      "referenceID" : 30,
      "context" : "By themselves, there is no straightforward way to capture the structured relationships between multiple triples adequately (Guu et al., 2015; Toutanova et al., 2016; Lin et al., 2015a).",
      "startOffset" : 123,
      "endOffset" : 184
    }, {
      "referenceID" : 0,
      "context" : "These knowledge bases are useful for many downstream applications such as question answering (Berant et al., 2013; Yih et al., 2015) and information extraction (Mintz et al., 2009). However, despite the formidable size of knowledge bases, many important facts are still missing. For example, West et al. (2014) showed that 21% of the 100K most frequent PERSON entities have no recorded nationality in a recent version of Freebase.",
      "startOffset" : 94,
      "endOffset" : 311
    }, {
      "referenceID" : 0,
      "context" : "These knowledge bases are useful for many downstream applications such as question answering (Berant et al., 2013; Yih et al., 2015) and information extraction (Mintz et al., 2009). However, despite the formidable size of knowledge bases, many important facts are still missing. For example, West et al. (2014) showed that 21% of the 100K most frequent PERSON entities have no recorded nationality in a recent version of Freebase. We seek to infer unknown relations based on the observed triples. Thus, the knowledge base completion (KBC) task has emerged an important open research problem (Nickel et al., 2011). Neural-network based methods have been very popular for solving the KBC task. Following Bordes et al. (2013), one of the most popular approaches for KBC is to learn vector-space representations of entities and relations during training, and then apply linear or bi-linear operations to infer the missing relations at test time.",
      "startOffset" : 94,
      "endOffset" : 723
    }, {
      "referenceID" : 0,
      "context" : "These knowledge bases are useful for many downstream applications such as question answering (Berant et al., 2013; Yih et al., 2015) and information extraction (Mintz et al., 2009). However, despite the formidable size of knowledge bases, many important facts are still missing. For example, West et al. (2014) showed that 21% of the 100K most frequent PERSON entities have no recorded nationality in a recent version of Freebase. We seek to infer unknown relations based on the observed triples. Thus, the knowledge base completion (KBC) task has emerged an important open research problem (Nickel et al., 2011). Neural-network based methods have been very popular for solving the KBC task. Following Bordes et al. (2013), one of the most popular approaches for KBC is to learn vector-space representations of entities and relations during training, and then apply linear or bi-linear operations to infer the missing relations at test time. However, several recent papers demonstrate limitations of prior approaches relying upon vector-space models alone. By themselves, there is no straightforward way to capture the structured relationships between multiple triples adequately (Guu et al., 2015; Toutanova et al., 2016; Lin et al., 2015a). For example, assume that we want to fill in the missing relation for the triple (Obama, NATIONALITY, ?), a multi-step search procedure might be needed to discover the evidence in the observed triples such as (Obama, BORNIN, Hawaii) and (Hawaii, PARTOF, U.S.A). To address this issue, Guu et al. (2015); Toutanova et al.",
      "startOffset" : 94,
      "endOffset" : 1545
    }, {
      "referenceID" : 0,
      "context" : "These knowledge bases are useful for many downstream applications such as question answering (Berant et al., 2013; Yih et al., 2015) and information extraction (Mintz et al., 2009). However, despite the formidable size of knowledge bases, many important facts are still missing. For example, West et al. (2014) showed that 21% of the 100K most frequent PERSON entities have no recorded nationality in a recent version of Freebase. We seek to infer unknown relations based on the observed triples. Thus, the knowledge base completion (KBC) task has emerged an important open research problem (Nickel et al., 2011). Neural-network based methods have been very popular for solving the KBC task. Following Bordes et al. (2013), one of the most popular approaches for KBC is to learn vector-space representations of entities and relations during training, and then apply linear or bi-linear operations to infer the missing relations at test time. However, several recent papers demonstrate limitations of prior approaches relying upon vector-space models alone. By themselves, there is no straightforward way to capture the structured relationships between multiple triples adequately (Guu et al., 2015; Toutanova et al., 2016; Lin et al., 2015a). For example, assume that we want to fill in the missing relation for the triple (Obama, NATIONALITY, ?), a multi-step search procedure might be needed to discover the evidence in the observed triples such as (Obama, BORNIN, Hawaii) and (Hawaii, PARTOF, U.S.A). To address this issue, Guu et al. (2015); Toutanova et al. (2016); Lin et al.",
      "startOffset" : 94,
      "endOffset" : 1570
    }, {
      "referenceID" : 0,
      "context" : "These knowledge bases are useful for many downstream applications such as question answering (Berant et al., 2013; Yih et al., 2015) and information extraction (Mintz et al., 2009). However, despite the formidable size of knowledge bases, many important facts are still missing. For example, West et al. (2014) showed that 21% of the 100K most frequent PERSON entities have no recorded nationality in a recent version of Freebase. We seek to infer unknown relations based on the observed triples. Thus, the knowledge base completion (KBC) task has emerged an important open research problem (Nickel et al., 2011). Neural-network based methods have been very popular for solving the KBC task. Following Bordes et al. (2013), one of the most popular approaches for KBC is to learn vector-space representations of entities and relations during training, and then apply linear or bi-linear operations to infer the missing relations at test time. However, several recent papers demonstrate limitations of prior approaches relying upon vector-space models alone. By themselves, there is no straightforward way to capture the structured relationships between multiple triples adequately (Guu et al., 2015; Toutanova et al., 2016; Lin et al., 2015a). For example, assume that we want to fill in the missing relation for the triple (Obama, NATIONALITY, ?), a multi-step search procedure might be needed to discover the evidence in the observed triples such as (Obama, BORNIN, Hawaii) and (Hawaii, PARTOF, U.S.A). To address this issue, Guu et al. (2015); Toutanova et al. (2016); Lin et al. (2015a) propose different approaches of injecting structured information by directly operating on the observed triplets.",
      "startOffset" : 94,
      "endOffset" : 1590
    }, {
      "referenceID" : 9,
      "context" : ", 2015; ?) and Neural Turing Machines (NTM) (Graves et al., 2014; 2016), the biggest difference between our model and the existing frameworks is the search controller and the use of the shared memory.",
      "startOffset" : 44,
      "endOffset" : 71
    }, {
      "referenceID" : 22,
      "context" : "We build upon our previous work (Shen et al., 2016) for using a search controller module to dynamically perform a multi-step inference depending on the complexity of the instance.",
      "startOffset" : 32,
      "endOffset" : 51
    }, {
      "referenceID" : 9,
      "context" : ", 2015; ?) and Neural Turing Machines (NTM) (Graves et al., 2014; 2016), the biggest difference between our model and the existing frameworks is the search controller and the use of the shared memory. We build upon our previous work (Shen et al., 2016) for using a search controller module to dynamically perform a multi-step inference depending on the complexity of the instance. MemNN and NTM explicitly store inputs (such as graph definition, supporting facts) in the memory. In contrast, in IRNs, we do not explicitly store all the observed inputs in the shared memory. Instead, we directly operate on the shared memory, which modeling the structured relationships implicitly. We randomly initialize the memory and update the memory with respect to task-specific objectives. The idea of exploiting shared memory is proposed by Munkhdalai & Yu (2016) independently.",
      "startOffset" : 45,
      "endOffset" : 854
    }, {
      "referenceID" : 9,
      "context" : ", 2015; ?) and Neural Turing Machines (NTM) (Graves et al., 2014; 2016), the biggest difference between our model and the existing frameworks is the search controller and the use of the shared memory. We build upon our previous work (Shen et al., 2016) for using a search controller module to dynamically perform a multi-step inference depending on the complexity of the instance. MemNN and NTM explicitly store inputs (such as graph definition, supporting facts) in the memory. In contrast, in IRNs, we do not explicitly store all the observed inputs in the shared memory. Instead, we directly operate on the shared memory, which modeling the structured relationships implicitly. We randomly initialize the memory and update the memory with respect to task-specific objectives. The idea of exploiting shared memory is proposed by Munkhdalai & Yu (2016) independently. Despite of using the same term, the goal and the operations used by IRNs are different from the one used in Munkhdalai & Yu (2016), as IRNs allow the model to perform multi-step for each instance dynamically.",
      "startOffset" : 45,
      "endOffset" : 1000
    }, {
      "referenceID" : 14,
      "context" : "The inference process of an IRN is considered as a Partially Observable Markov Decision Process (POMDP) (Kaelbling et al., 1998) in the reinforcement learning (RL) literature.",
      "startOffset" : 104,
      "endOffset" : 128
    }, {
      "referenceID" : 22,
      "context" : "We employ the approach from our previous work (Shen et al., 2016), REINFORCE (Williams, 1992) based Contrastive Reward method, to maximize the expected reward.",
      "startOffset" : 46,
      "endOffset" : 65
    }, {
      "referenceID" : 34,
      "context" : ", 2016), REINFORCE (Williams, 1992) based Contrastive Reward method, to maximize the expected reward.",
      "startOffset" : 19,
      "endOffset" : 35
    }, {
      "referenceID" : 3,
      "context" : "The goal of KBC tasks (Bordes et al., 2013) is to predict a head or a tail entity given the relation type and the other entity, i.",
      "startOffset" : 22,
      "endOffset" : 43
    }, {
      "referenceID" : 3,
      "context" : "In this section, we evaluate the performance of our model on the benchmark FB15k and WN18 datasets for KBC tasks (Bordes et al., 2013).",
      "startOffset" : 113,
      "endOffset" : 134
    }, {
      "referenceID" : 7,
      "context" : "For example, RTransE (García-Durán et al., 2015) and PTransE (Lin et al.",
      "startOffset" : 21,
      "endOffset" : 48
    }, {
      "referenceID" : 3,
      "context" : ", 2015a) models are extensions of the TransE (Bordes et al., 2013) model by explicitly exploring multi-step relations in the knowledge base to regularize the trained embeddings.",
      "startOffset" : 45,
      "endOffset" : 66
    }, {
      "referenceID" : 29,
      "context" : "The NLFeat model (Toutanova et al., 2015) is a log-linear model that makes use of simple node and link features.",
      "startOffset" : 17,
      "endOffset" : 41
    }, {
      "referenceID" : 2,
      "context" : "In this section, we evaluate the performance of our model on the benchmark FB15k and WN18 datasets for KBC tasks (Bordes et al., 2013). These datasets contain multi-relations between head and tail entities. Given a head entity and a relation, the model produces a ranked list of the entities according to the score of the entity being the tail entity of this triple. To evaluate the ranking, we report mean rank (MR), the mean of rank of the correct entity across the test examples, and hits@10, the proportion of correct entities ranked in the top-10 predictions. Lower MR or higher hits@10 indicates a better prediction performance. We follow the evaluation protocol in Bordes et al. (2013) to report filtered results, where negative examples N are removed from the dataset.",
      "startOffset" : 114,
      "endOffset" : 693
    }, {
      "referenceID" : 2,
      "context" : "In this section, we evaluate the performance of our model on the benchmark FB15k and WN18 datasets for KBC tasks (Bordes et al., 2013). These datasets contain multi-relations between head and tail entities. Given a head entity and a relation, the model produces a ranked list of the entities according to the score of the entity being the tail entity of this triple. To evaluate the ranking, we report mean rank (MR), the mean of rank of the correct entity across the test examples, and hits@10, the proportion of correct entities ranked in the top-10 predictions. Lower MR or higher hits@10 indicates a better prediction performance. We follow the evaluation protocol in Bordes et al. (2013) to report filtered results, where negative examples N are removed from the dataset. In this case, we can avoid some negative examples being valid and ranked above the target triplet. We use the same hyper-parameters of our model for both FB15k and WN18 datasets. Entity embeddings (which are not shared between input and output modules) and relation embedding are both 100-dimensions. We use the input module and output module to encode subject and object entities, respectively. There are 64 memory vectors with 200 dimensions each, initialized by random vectors with unit L2-norm. We use single-layer GRU with 200 cells as the search controller. We set the maximum inference step of the IRN to 5. We randomly initialize all model parameters, and use SGD as the training algorithm with mini-batch size of 64. We set the learning rate to a constant number, 0.01. To prevent the model from learning a trivial solution by increasing entity embeddings norms, we follow Bordes et al. (2013) to enforce the L2-norm of the entity embeddings as 1.",
      "startOffset" : 114,
      "endOffset" : 1680
    }, {
      "referenceID" : 2,
      "context" : "In this section, we evaluate the performance of our model on the benchmark FB15k and WN18 datasets for KBC tasks (Bordes et al., 2013). These datasets contain multi-relations between head and tail entities. Given a head entity and a relation, the model produces a ranked list of the entities according to the score of the entity being the tail entity of this triple. To evaluate the ranking, we report mean rank (MR), the mean of rank of the correct entity across the test examples, and hits@10, the proportion of correct entities ranked in the top-10 predictions. Lower MR or higher hits@10 indicates a better prediction performance. We follow the evaluation protocol in Bordes et al. (2013) to report filtered results, where negative examples N are removed from the dataset. In this case, we can avoid some negative examples being valid and ranked above the target triplet. We use the same hyper-parameters of our model for both FB15k and WN18 datasets. Entity embeddings (which are not shared between input and output modules) and relation embedding are both 100-dimensions. We use the input module and output module to encode subject and object entities, respectively. There are 64 memory vectors with 200 dimensions each, initialized by random vectors with unit L2-norm. We use single-layer GRU with 200 cells as the search controller. We set the maximum inference step of the IRN to 5. We randomly initialize all model parameters, and use SGD as the training algorithm with mini-batch size of 64. We set the learning rate to a constant number, 0.01. To prevent the model from learning a trivial solution by increasing entity embeddings norms, we follow Bordes et al. (2013) to enforce the L2-norm of the entity embeddings as 1. We use hits@10 as the validation metric for the IRN. Following the work (Lin et al., 2015a), we add reverse relations into the training triplet set to increase the training data. Following Nguyen et al. (2016), we divide the results of previous work into two groups.",
      "startOffset" : 114,
      "endOffset" : 1944
    }, {
      "referenceID" : 2,
      "context" : "In this section, we evaluate the performance of our model on the benchmark FB15k and WN18 datasets for KBC tasks (Bordes et al., 2013). These datasets contain multi-relations between head and tail entities. Given a head entity and a relation, the model produces a ranked list of the entities according to the score of the entity being the tail entity of this triple. To evaluate the ranking, we report mean rank (MR), the mean of rank of the correct entity across the test examples, and hits@10, the proportion of correct entities ranked in the top-10 predictions. Lower MR or higher hits@10 indicates a better prediction performance. We follow the evaluation protocol in Bordes et al. (2013) to report filtered results, where negative examples N are removed from the dataset. In this case, we can avoid some negative examples being valid and ranked above the target triplet. We use the same hyper-parameters of our model for both FB15k and WN18 datasets. Entity embeddings (which are not shared between input and output modules) and relation embedding are both 100-dimensions. We use the input module and output module to encode subject and object entities, respectively. There are 64 memory vectors with 200 dimensions each, initialized by random vectors with unit L2-norm. We use single-layer GRU with 200 cells as the search controller. We set the maximum inference step of the IRN to 5. We randomly initialize all model parameters, and use SGD as the training algorithm with mini-batch size of 64. We set the learning rate to a constant number, 0.01. To prevent the model from learning a trivial solution by increasing entity embeddings norms, we follow Bordes et al. (2013) to enforce the L2-norm of the entity embeddings as 1. We use hits@10 as the validation metric for the IRN. Following the work (Lin et al., 2015a), we add reverse relations into the training triplet set to increase the training data. Following Nguyen et al. (2016), we divide the results of previous work into two groups. The first group contains the models that directly optimize a scoring function for the triples in a knowledge base without using extra information. The second group of models make uses of additional information from multi-step relations. For example, RTransE (García-Durán et al., 2015) and PTransE (Lin et al., 2015a) models are extensions of the TransE (Bordes et al., 2013) model by explicitly exploring multi-step relations in the knowledge base to regularize the trained embeddings. The NLFeat model (Toutanova et al., 2015) is a log-linear model that makes use of simple node and link features. Table 1 presents the experimental results. According to the table, our model significantly outperforms previous baselines, regardless of whether previous approaches use additional information or not. Specifically, on FB15k, the MR of our model surpasses all previous results by 12, and our hit@10 outperforms others by 5.7%. On WN18, the IRN obtains the highest hit@10 while maintaining similar MR results compared to previous work.1 To better understand the behavior of IRNs, we report the results of IRNs with different memory sizes and different Tmax on FB15K in Table 2. We find the performance of IRNs increases significantly if the number of inference step increases. Note that an IRN with Tmax = 1 is the case that an IRN without the shared memory. Interestingly, given Tmax = 5, IRNs are not sensitive to memory sizes. In particular, larger memory always improves the MR score, but the best hit@10 is obtained by |M | = 64 memory vectors. A possible reason is that the best memory size is determined by the complexity of the tasks. We analyze hits@10 results on FB15k with respect to the relation categories. Following the evaluation in Bordes et al. (2013), we evaluate the performance in four types of relation: 1-1 if a head entity Nguyen et al.",
      "startOffset" : 114,
      "endOffset" : 3767
    }, {
      "referenceID" : 2,
      "context" : "In this section, we evaluate the performance of our model on the benchmark FB15k and WN18 datasets for KBC tasks (Bordes et al., 2013). These datasets contain multi-relations between head and tail entities. Given a head entity and a relation, the model produces a ranked list of the entities according to the score of the entity being the tail entity of this triple. To evaluate the ranking, we report mean rank (MR), the mean of rank of the correct entity across the test examples, and hits@10, the proportion of correct entities ranked in the top-10 predictions. Lower MR or higher hits@10 indicates a better prediction performance. We follow the evaluation protocol in Bordes et al. (2013) to report filtered results, where negative examples N are removed from the dataset. In this case, we can avoid some negative examples being valid and ranked above the target triplet. We use the same hyper-parameters of our model for both FB15k and WN18 datasets. Entity embeddings (which are not shared between input and output modules) and relation embedding are both 100-dimensions. We use the input module and output module to encode subject and object entities, respectively. There are 64 memory vectors with 200 dimensions each, initialized by random vectors with unit L2-norm. We use single-layer GRU with 200 cells as the search controller. We set the maximum inference step of the IRN to 5. We randomly initialize all model parameters, and use SGD as the training algorithm with mini-batch size of 64. We set the learning rate to a constant number, 0.01. To prevent the model from learning a trivial solution by increasing entity embeddings norms, we follow Bordes et al. (2013) to enforce the L2-norm of the entity embeddings as 1. We use hits@10 as the validation metric for the IRN. Following the work (Lin et al., 2015a), we add reverse relations into the training triplet set to increase the training data. Following Nguyen et al. (2016), we divide the results of previous work into two groups. The first group contains the models that directly optimize a scoring function for the triples in a knowledge base without using extra information. The second group of models make uses of additional information from multi-step relations. For example, RTransE (García-Durán et al., 2015) and PTransE (Lin et al., 2015a) models are extensions of the TransE (Bordes et al., 2013) model by explicitly exploring multi-step relations in the knowledge base to regularize the trained embeddings. The NLFeat model (Toutanova et al., 2015) is a log-linear model that makes use of simple node and link features. Table 1 presents the experimental results. According to the table, our model significantly outperforms previous baselines, regardless of whether previous approaches use additional information or not. Specifically, on FB15k, the MR of our model surpasses all previous results by 12, and our hit@10 outperforms others by 5.7%. On WN18, the IRN obtains the highest hit@10 while maintaining similar MR results compared to previous work.1 To better understand the behavior of IRNs, we report the results of IRNs with different memory sizes and different Tmax on FB15K in Table 2. We find the performance of IRNs increases significantly if the number of inference step increases. Note that an IRN with Tmax = 1 is the case that an IRN without the shared memory. Interestingly, given Tmax = 5, IRNs are not sensitive to memory sizes. In particular, larger memory always improves the MR score, but the best hit@10 is obtained by |M | = 64 memory vectors. A possible reason is that the best memory size is determined by the complexity of the tasks. We analyze hits@10 results on FB15k with respect to the relation categories. Following the evaluation in Bordes et al. (2013), we evaluate the performance in four types of relation: 1-1 if a head entity Nguyen et al. (2016) reported two results on WN18, where the first one is obtained by choosing to optimize hits@10 on the validation set, and second one is obtained by choosing to optimize MR on the validation set.",
      "startOffset" : 114,
      "endOffset" : 3865
    }, {
      "referenceID" : 2,
      "context" : "Model Additional Information WN18 FB15k Hits@10 (%) MR Hits@10 (%) MR SE (Bordes et al., 2011) NO 80.",
      "startOffset" : 73,
      "endOffset" : 94
    }, {
      "referenceID" : 4,
      "context" : "8 162 Unstructured (Bordes et al., 2014) NO 38.",
      "startOffset" : 19,
      "endOffset" : 40
    }, {
      "referenceID" : 3,
      "context" : "3 979 TransE (Bordes et al., 2013) NO 89.",
      "startOffset" : 13,
      "endOffset" : 34
    }, {
      "referenceID" : 31,
      "context" : "1 125 TransH (Wang et al., 2014) NO 86.",
      "startOffset" : 13,
      "endOffset" : 32
    }, {
      "referenceID" : 12,
      "context" : "2 75 KG2E (He et al., 2015) NO 93.",
      "startOffset" : 10,
      "endOffset" : 27
    }, {
      "referenceID" : 13,
      "context" : "0 59 TransD (Ji et al., 2015) NO 92.",
      "startOffset" : 12,
      "endOffset" : 29
    }, {
      "referenceID" : 7,
      "context" : "3 91 TATEC (García-Durán et al., 2015) NO 76.",
      "startOffset" : 11,
      "endOffset" : 38
    }, {
      "referenceID" : 23,
      "context" : "7 58 NTN (Socher et al., 2013) NO 66.",
      "startOffset" : 9,
      "endOffset" : 30
    }, {
      "referenceID" : 35,
      "context" : "4 DISTMULT (Yang et al., 2014) NO 94.",
      "startOffset" : 11,
      "endOffset" : 30
    }, {
      "referenceID" : 18,
      "context" : "7 STransE (Nguyen et al., 2016) NO 94.",
      "startOffset" : 10,
      "endOffset" : 31
    }, {
      "referenceID" : 7,
      "context" : "7 69 RTransE (García-Durán et al., 2015) Path 76.",
      "startOffset" : 13,
      "endOffset" : 40
    }, {
      "referenceID" : 29,
      "context" : "6 58 NLFeat (Toutanova et al., 2015) Node + Link Features 94.",
      "startOffset" : 12,
      "endOffset" : 36
    }, {
      "referenceID" : 32,
      "context" : "0 Random Walk (Wei et al., 2016) Path 94.",
      "startOffset" : 14,
      "endOffset" : 32
    }, {
      "referenceID" : 2,
      "context" : "Model Predicting head h Predicting tail t 1-1 1-M M-1 M-M 1-1 1-M M-1 M-M SE (Bordes et al., 2011) 35.",
      "startOffset" : 77,
      "endOffset" : 98
    }, {
      "referenceID" : 4,
      "context" : "3 Unstructured (Bordes et al., 2014) 34.",
      "startOffset" : 15,
      "endOffset" : 36
    }, {
      "referenceID" : 3,
      "context" : "6 TransE (Bordes et al., 2013) 43.",
      "startOffset" : 9,
      "endOffset" : 30
    }, {
      "referenceID" : 31,
      "context" : "0 TransH (Wang et al., 2014) 66.",
      "startOffset" : 9,
      "endOffset" : 28
    }, {
      "referenceID" : 12,
      "context" : "8 KG2E (He et al., 2015) 92.",
      "startOffset" : 7,
      "endOffset" : 24
    }, {
      "referenceID" : 13,
      "context" : "4 TransD (Ji et al., 2015) 86.",
      "startOffset" : 9,
      "endOffset" : 26
    }, {
      "referenceID" : 7,
      "context" : "2 TATEC (García-Durán et al., 2015) 79.",
      "startOffset" : 8,
      "endOffset" : 35
    }, {
      "referenceID" : 18,
      "context" : "7 STransE (Nguyen et al., 2016) 82.",
      "startOffset" : 10,
      "endOffset" : 31
    }, {
      "referenceID" : 27,
      "context" : "We compare the IRN with two baseline approaches: dynamic programming without edge-weight information and a standard sequence-to-sequence model (Sutskever et al., 2014) using a similar parameter size to our model.",
      "startOffset" : 143,
      "endOffset" : 167
    }, {
      "referenceID" : 2,
      "context" : "(Bordes et al., 2011; 2014; 2013; Wang et al., 2014; Ji et al., 2015; Nguyen et al., 2016).",
      "startOffset" : 0,
      "endOffset" : 90
    }, {
      "referenceID" : 31,
      "context" : "(Bordes et al., 2011; 2014; 2013; Wang et al., 2014; Ji et al., 2015; Nguyen et al., 2016).",
      "startOffset" : 0,
      "endOffset" : 90
    }, {
      "referenceID" : 13,
      "context" : "(Bordes et al., 2011; 2014; 2013; Wang et al., 2014; Ji et al., 2015; Nguyen et al., 2016).",
      "startOffset" : 0,
      "endOffset" : 90
    }, {
      "referenceID" : 18,
      "context" : "(Bordes et al., 2011; 2014; 2013; Wang et al., 2014; Ji et al., 2015; Nguyen et al., 2016).",
      "startOffset" : 0,
      "endOffset" : 90
    }, {
      "referenceID" : 3,
      "context" : "For example, in TransE (Bordes et al., 2013), the function is implemented as fr(h, t) = ‖h+ r− t‖, where h, r and t are the corresponding vector representations.",
      "startOffset" : 23,
      "endOffset" : 44
    }, {
      "referenceID" : 11,
      "context" : "Recently, different studies (Guu et al., 2015; Lin et al., 2015a; Toutanova et al., 2016) demonstrate the importance for models to also learn from multi-step relations.",
      "startOffset" : 28,
      "endOffset" : 89
    }, {
      "referenceID" : 30,
      "context" : "Recently, different studies (Guu et al., 2015; Lin et al., 2015a; Toutanova et al., 2016) demonstrate the importance for models to also learn from multi-step relations.",
      "startOffset" : 28,
      "endOffset" : 89
    }, {
      "referenceID" : 30,
      "context" : ", 2015a) or considering all possible paths using a dynamic programming algorithm with the restriction of using linear or bi-linear models only (Toutanova et al., 2016).",
      "startOffset" : 143,
      "endOffset" : 167
    }, {
      "referenceID" : 2,
      "context" : "(Bordes et al., 2011; 2014; 2013; Wang et al., 2014; Ji et al., 2015; Nguyen et al., 2016). In many studies, the scoring function fr(h, t) is linear or bi-linear. For example, in TransE (Bordes et al., 2013), the function is implemented as fr(h, t) = ‖h+ r− t‖, where h, r and t are the corresponding vector representations. Recently, different studies (Guu et al., 2015; Lin et al., 2015a; Toutanova et al., 2016) demonstrate the importance for models to also learn from multi-step relations. Learning from multi-step relations injects the structured relationships between triples into the model. However, this also poses a technical challenge of considering exponential numbers of multi-step relationships. Prior approaches address this issue by designing path-mining algorithms (Lin et al., 2015a) or considering all possible paths using a dynamic programming algorithm with the restriction of using linear or bi-linear models only (Toutanova et al., 2016). Toutanova & Chen (2015) shows the effectiveness of using simple node and link features that encode structured information on FB15k and WN18.",
      "startOffset" : 1,
      "endOffset" : 985
    }, {
      "referenceID" : 21,
      "context" : "Studies such as (Riedel et al., 2013) show that incorporating textual information can further improve the knowledge base completion tasks.",
      "startOffset" : 16,
      "endOffset" : 37
    }, {
      "referenceID" : 27,
      "context" : "Neural Frameworks Sequence-to-sequence models (Sutskever et al., 2014; Cho et al., 2014) have shown to be successful in many applications such as machine translation and conversation modeling (Sordoni et al.",
      "startOffset" : 46,
      "endOffset" : 88
    }, {
      "referenceID" : 5,
      "context" : "Neural Frameworks Sequence-to-sequence models (Sutskever et al., 2014; Cho et al., 2014) have shown to be successful in many applications such as machine translation and conversation modeling (Sordoni et al.",
      "startOffset" : 46,
      "endOffset" : 88
    }, {
      "referenceID" : 24,
      "context" : ", 2014) have shown to be successful in many applications such as machine translation and conversation modeling (Sordoni et al., 2015).",
      "startOffset" : 111,
      "endOffset" : 133
    }, {
      "referenceID" : 9,
      "context" : "While sequence-to-sequence models are powerful, recent work has shown that the necessity of incorporating an external memory to perform inference in simple algorithmic tasks (Graves et al., 2014; 2016).",
      "startOffset" : 174,
      "endOffset" : 201
    }, {
      "referenceID" : 20,
      "context" : "First, inspired from Ribeiro et al. (2016), we would like to develop techniques to exploit ways to generate human understandable reasoning interpretation from the shared memory.",
      "startOffset" : 21,
      "endOffset" : 43
    } ],
    "year" : 2016,
    "abstractText" : "Recent studies on knowledge base completion, the task of recovering missing relationships based on recorded relations, demonstrate the importance of learning embeddings from multi-step relations. However, due to the size of knowledge bases, learning multi-step relations directly on top of observed instances could be costly. In this paper, we propose Implicit ReasoNets (IRNs), which is designed to perform large-scale inference implicitly through a search controller and shared memory. Unlike previous work, IRNs use training data to learn to perform multi-step inference through the shared memory, which is also jointly updated during training. While the inference procedure is not operating on top of observed instances for IRNs, our proposed model outperforms all previous approaches on the popular FB15k benchmark by more than 5.7%.",
    "creator" : "LaTeX with hyperref package"
  }
}