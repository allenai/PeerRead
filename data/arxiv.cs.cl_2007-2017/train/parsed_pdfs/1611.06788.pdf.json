{
  "name" : "1611.06788.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Bidirectional Tree-Structured LSTM with Head Lexicalization",
    "authors" : [ "Zhiyang Teng", "Yue Zhang" ],
    "emails" : [ "teng@mymail.sutd.edu.sg", "zhang@sutd.edu.sg" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Both sequence structured and tree structured neural models have been applied to NLP problems. Seminal work employs convolutional neural network (Collobert and Weston, 2008), recurrent neural network (Elman, 1990; Mikolov et al., 2010) and recursive neural network (Socher et al., 2011) for sequence and tree modeling. Recently, Long ShortTerm Memories (LSTM) have received increasing research attention, giving significantly improved accuracies in a variety of sequence tasks (Sutskever et al., 2014; Bahdanau et al., 2014) compared to vanilla\nrecurrent neural networks. Addressing diminishing gradients effectively, they have been extended to tree structures, achieving promising results for tasks such as syntactic language modeling (Zhang et al., 2015), sentiment analysis (Li et al., 2015; Zhu et al., 2015b; Le and Zuidema, 2015; Tai et al., 2015) and relation extraction (Miwa and Bansal, 2016).\nAccording to the node type, typical tree structures in NLP can be categorized to constituent trees and dependency trees. A salient difference between the two types of tree structures is in the node. While dependency tree nodes are input words themselves, constituent tree nodes represent syntactic constituents. Only leaf nodes in constituent trees correspond to words. Though LSTM structures have been developed for both types of trees above, we investigate constituent trees in this paper. There are three existing methods for constituent tree LSTM (Zhu et al., 2015b; Tai et al., 2015; Le and Zuidema, 2015), which make essentially the same extension from sequence structure LSTMs. We take the method of Zhu et al. (2015b) as our baseline.\nA contrast between the sequence structured LSTM of Hochreiter and Schmidhuber (1997) and the tree-structured LSTM of Zhu et al. (2015b) is shown in Figure 1, which illustrates the input (x), cell (c) and hidden (h) nodes at a certain time step t. The most important difference between Figure 1(a) and Figure 1(b) is the branching factor. While a cell in the sequence structure LSTM depends on the single previous hidden node, a cell in the treestructured LSTM depends on a left hidden node and a right hidden node. Such tree-structured extension of the sequence structure LSTM assumes that the\nar X\niv :1\n61 1.\n06 78\n8v 1\n[ cs\n.C L\n] 2\n1 N\nov 2\nconstituent tree is binarized, building hidden nodes from the input words in the bottom-up direction. The leaf node structure in shown in Figure 1(c).\nA second salient difference between the two types of LSTMs is the modeling of input words. While each cell in the sequence structure LSTM directly depends on its corresponding input word, only leaf cells in the tree structure LSTM directly depend on corresponding input words. This corresponds well to the constituent tree structure, where there is no direct association between non-leaf constituent nodes and input words. However, it leaves the tree structure a degraded version of a perfect binary-branching variation of the sequence-structure LSTM, with one important source of information (i.e. words) missing in forming a cell.\nWe fill this gap by proposing an extension to the tree LSTM model, injecting lexical information into every node in the tree. Our method takes inspiration from work on head-lexicalization, which shows that each node in a constituent tree structure is governed by a head word. As shown in Figure 2, the head word for the verb phrase “visited Mary” is “visited”, and the head word of the adverb phrase “this afternoon” is “afternoon”. Research has shown that head word information can significantly improve the performance of syntactic parsing (Collins, 2003; Clark and Curran, 2004). Correspondingly, we use head lexical information of each constituent word as the input node x for calculating the corresponding cell c in Figure 1(b).\nTraditional head-lexicalization relies on specific rules (Collins, 2003), typically extracting heads\nfrom constituent treebanks according to certain grammar formalisms. For better generalization, we use a neural attention mechanism to derive head lexical information automatically, rather than relying on linguistic head rules to find the head lexicon of each constituent, which is language- and formalismdependent.\nBased on such head lexicalization, we make a bidirectional extension of the tree structured LSTM, propagating information in the top-down direction as well as the bottom-up direction. This is analogous to the bidirectional extension of sequence structure LSTMs, which are commonly used for NLP tasks such as speech recognition (Graves et al., 2013), sentiment analysis (Tai et al., 2015; Li et al., 2015) and machine translation (Sutskever et al., 2014; Bahdanau et al., 2014) tasks.\nResults on a standard sentiment classification benchmark and a question type classification benchmark show that our tree LSTM structure gives significantly better accuracies compared with the method of Zhu et al. (2015b). We achieve the best reported results for sentiment classification. Interestingly, the head lexical information that is learned automatically from the sentiment treebank consists of both syntactic head information and key sentiment word information. This shows the advantage of automatic head-finding as compared with rule-based head lexicalization. We make our code available under GPL at https://github.com/XXX/XXX."
    }, {
      "heading" : "2 Related Work",
      "text" : "LSTM (Hochreiter and Schmidhuber, 1997) is a variation of RNN (Elman, 1990) to solve vanishing gradients in training. It has been widely adopted for NLP tasks, such as parsing (Dyer et al., 2015) and machine translation (Bahdanau et al., 2014). We take the standard LSTM with peephole connec-\ntions (Gers and Schmidhuber, 2000) as our baseline, which models sequences.\nThere has been extensions of sequence-structured LSTMs for modeling trees (Tai et al., 2015; Le and Zuidema, 2015; Zhu et al., 2015b). The idea is similar to extending recursive neural network to recurrent neural network, where gates are used in recursive structures for alleviating diminishing gradients. While Tai et al. (2015) investigated tree-structured LSTMs for both dependency structures and constituent structures, and both for unrestricted trees and M-nary trees, Zhu et al. (2015b) and Le and Zuidema (2015) focused on binary constituent trees. As discussed earlier, none of these existing methods make direct use of lexical input for composing constituent vectors. We take Zhu et al. (2015b) as our baseline.\nBidirectional information has been leveraged to extend sequence LSTM (Graves et al., 2013). On the other hand, the aforementioned tree-LSTM models work bottom-up, without information flew from parents to children. Zhang et al. (2015) built a topdown tree-LSTM for dependency trees, but without a bottom-up component. Paulus et al. (2014) made use of bidirectional information on binary trees, but for recursive neural networks only. The closest in spirit to our method, Miwa and Bansal (2016) adopted a bidirectional Tree LSTM model to jointly extract named entities and relations under dependency tree structure. For constituent tree structures, however, their model does not work due to lack of word inputs on non-leaf constituent nodes, and in particular the root node. Our head lexicalization allows us to investigate the top-down constituent Tree LSTM. To our knowledge, we are the first to report a bidirectional constituent Tree LSTM."
    }, {
      "heading" : "3 Baselines",
      "text" : "A sequence-structure LSTM estimates a sequence of hidden state vectors given a sequence of input vectors, through the calculation of a sequence of hidden cell vectors using a gate mechanism. For NLP, the input vectors are typically word embeddings (Mikolov et al., 2013), but can also include PoS embeddings, character embeddings or other types of information. For notational convenience, we refer to the input vectors as lexical vectors.\nFormally, given an input vector sequence x1, x2, . . . , xn, each state vector ht is estimated from the Hadamard product of a cell vector ct and a corresponding output gate vector ot\nht = ot ⊗ tanh(ct) (1)\nHere the cell vector depends on both the previous cell vector ct, and a combination of the previous state vector ht−1, the current input vector xt:\nct = ft ⊗ ct−1 + it ⊗ gt (2) gt = tanh(Wxgxt +Whght−1 + bg) (3)\nThe combination of ct−1 and gt are controlled by the Hadamard product between a forget gate vector ft and a input gate vector it, respectively. The gates ot, ft and it are defined as follows\nit = σ(Wxixt +Whiht−1 +Wcict−1 + bi)\nft = σ(Wxfxt +Whfht−1 +Wcfct−1 + bf )\not = σ(Wxoxt +Whoht−1 +Wcoct + bo),\n(4)\nwhere σ is the sigmoid function. Wxg, Whg, bg, Wxi, Whi, Wci, bi, Wxf , Whf , Wcf , bf , Wxo, Who, Wco and bo are model parameters.\nThe bottom-up Tree LSTM of Zhu et al. (2015b) extends the left-to-right sequence LSTM by splitting the previous state vector ht−1 into a left child state vector hLt−1 and a right child state vector h R t−1, and the previous cell vector ct−1 into a left child cell vector cLt−1 and a right child cell vector c R t−1, calculating ct as\nct = f L t ⊗ cLt−1 + fRt ⊗ cRt−1 + it ⊗ gt, (5)\nand the input/output gates it/ot as it = σ ( ∑\nN∈{L,R}\n(WNhih N t−1 +W N ci c N t−1) + bi ) ot = σ\n( ∑ N∈{L,R} WNhoh N t−1 +Wcoct + bo ) (6)\nThe forget gate ft is split into fLt and f R t for regulating cLt−1 and c R t−1, respectively:\nfLt = σ ( ∑\nN∈{L,R}\n(WNhflh N t−1 +W N cfl cNt−1) + bfl ) fRt = σ\n( ∑ N∈{L,R} (WNhfrh N t−1 +W N cfrc N t−1) + bfr ) (7)\ngt depends on both hLt−1 and h R t−1, but as shown in Figure 1 (b), it does not depend on xt\ngt = tanh ( ∑\nN∈{L,R}\nWNhgh N t−1 + bg\n) (8)\nFinally, the hidden state vector ht is calculated in the same way as in the sequential LSTM model shown in Equation 1. WLhi, W R hi, W L ci , W R ci , bi, W L ho, WRho, Wco, bo, W L hfl , WRhfl , W L cfl , WRcfl , bfl , W L hfr\n, WRhfr , W L cfr , WRcfr , bfr , W L hg, W R hg and bg are model parameters."
    }, {
      "heading" : "4 Our Model",
      "text" : ""
    }, {
      "heading" : "4.1 Head Lexicalization",
      "text" : "We introduce an input lexical vector xt to the calculation of each cell vector ct via a bottom-up head propagation mechanism. As shown in the shaded nodes in Figure 3 (b), the head propagation mechanism stands relatively in parallel to the cell propagation mechanism. In contrast, the method of Zhu et al. (2015b) in Figure 3 (a) does not have the input vector xt for non-leaf constituents.\nThere are multiple ways to choose a head lexicon for a given binary-branching constituent. One simple baseline is to choose the head lexicon of the left child as the head (left-headedness). Correspondingly, an alternative is to use the right child for head lexicon. However, these simple baselines can bring less benefits compared to linguistically motivated head finding, due to relatively less consistency in the governing head lexicons across variations of the same type of constituents with slightly different typologies.\nRather than selecting head lexicons using manually-defined head-finding rules, which are language- and formalism-dependent (Collins, 2003), we cast head finding as a part of the neural network model, learning the head lexicon of each constituent by a gated combination of head lexicons of its two children1. Formally,\nxt = zt ⊗ xLt−1 + (1− zt)⊗ xRt−1, (9)\nwhere xt represents the head lexicon vector of the current constituent, xLt−1 represents the head lexicon of its left child constituent, and xRt−1 represents the head lexicon of its right child constituent. The gate zt is calculated based on xLt−1 and x R t−1,\nzt = σ(W L zxx L t−1 +W R zxx R t−1 + bz) (10)\nHere WLzx, W R zx and bz are model parameters."
    }, {
      "heading" : "4.2 Lexicalized Tree LSTM",
      "text" : "Given head lexicon vectors for nodes, the Tree LSTM of Zhu et al. (2015b) can be extended by leveraging xt in calculating the corresponding ct. In particular, xt is used to estimate the input (it), output (ot) and forget (fRt and f L t ) gates:\nit = σ ( Wxixt+∑\nN∈{L,R}\n(WNhih N t−1 +W N ci c N t−1) + bi ) fLt = σ\n( Wxfxt+∑\nN∈{L,R}\n(WNhflh N t−1 +W N cfl cNt−1) + bfl ) fRt = σ\n( Wxfxt+∑\nN∈{L,R}\n(WNhfrh N t−1 +W N cfrc N t−1) + bfr ) ot = σ\n( Wxoxt+∑\nN∈{L,R}\nWNhoh N t−1 +Wcoct + bo\n)\n(11)\n1In this paper, we work on binary trees only, which is a common form for CKY and shift-reduce parsing. Typicial binarization methods, such as head binarization (Klein and Manning, 2003) , also rely on specific head-finding rules.\nIn addition, xt is also used in computing gt, gt = tanh ( Wxgxt + ∑ N∈{L,R} WNhgh N t−1 + bg ) (12) With the new definition of it, fRt , f L t and gt, the computing of ct remains the same as the baseline Tree LSTM model as shown in Equation 5. Similarly, ht remains the Hadamard product of ct and the new ot as shown in Equation 1.\nIn this model, Wxi, Wxf , Wxg and Wxo are newly-introduced model parameters. The use of xt in computing the gate and cell values are consistent with those in the baseline sequential LSTM."
    }, {
      "heading" : "4.3 Bidirectional Extensions",
      "text" : "Given a sequence of input vectors [x1, x2, . . . , xn], a bidirectional sequential LSTM (Graves et al., 2013) computes two sets of hidden state vectors, [h̃1, h̃2, . . . , h̃n] and [h̃′n, h̃ ′ n−1, . . . , h̃ ′ 1] in the left-to-right and the right-to-left directions, respectively. The final hidden state hi of the input xi is the concatenation of the corresponding state vectors in the two LSTMs, hi = h̃i ⊕ h̃′n−i+1 (13) The two LSTMs can share the same model parameters or use different parameters. We choose the latter in our baseline experiments.\nWe make a bidirectional extension to the Lexicalized tree LSTM in Section 4.2 by following the sequential baseline above, adding an additional set of hidden state vectors in the top-down direction. Different from the bottom-up direction, each hidden state in the top-down LSTM has exactly one predecessor. In fact, the path from the root of a tree down to any node forms a sequential LSTM.\nNote, however, that two different sets of model parameters are used when the current node is the left\nand the right child of its predecessor, respectively. Denoting the two sets of parameters as UL and UR, respectively, the hidden state vector h7 in Figure 4 is calculated from the hidden state vector h1 using the parameter set sequence [UL,UL,UR]. Similarly, h8 is calculated from h1 using [UL,UR,UL]. At each step t, the computing of ht follows the sequential LSTM model:\nht = ot ⊗ tanh(ct−1) ct = ft ⊗ ct−1 + it ⊗ gt gt = tanh(W N xg↓xt−1 +W N hg↓ht−1 + b N g↓) (14)\nWith the gate values being defined as:\nit = σ(W N xi↓xt +W N hi↓ht−1 +W N ci↓ct−1 + b N i↓) ft = σ(W N xf↓xt +W N hf↓ht−1 +W N cf↓ct−1 + b N f↓) ot = σ(W N xo↓xt +W N ho↓ht−1 +W N co↓ct + b N o↓)\n(15)\nHere N ∈ {L,R} and UN = {WNxg↓,WNhg↓, bNg↓,W N xi↓,W N hi↓,W N ci↓, b N i↓ ,W N xf↓,W N hf↓,W N cf↓, b N f↓, WNxo↓,W N ho↓,W N co↓, b N o↓}. UL and UR are model parameters in the top-down Tree LSTM. One final note is that the top-down Tree LSTM is enabled by the head propagation mechanism, which allows a head lexicon node to be made available for the root constituent node. Without such information, it would be difficult to build top-down LSTM for constituent trees."
    }, {
      "heading" : "5 Classification",
      "text" : "We apply the bidirectional Tree LSTM to classification tasks, where the input is a sentence with its binarized constituent tree, and the output is a discrete label. Denoting the bottom-up hidden state vector of the root as h̃ROOT↑, the top-down hidden state vector of the root as h̃ROOT↓ and the top-down hidden state vectors of the input words x1, x2, . . . , xn as h̃′1, h̃′2, . . . , h̃ ′ n, respectively, we take the concatenation of h̃ROOT↑, h̃ROOT↓ and the average of h̃′1, h̃ ′ 2, . . . , h̃′n as the final representation h of the sentence:\nh = h̃ROOT↑ ⊕ h̃ROOT↓ ⊕ 1\nn n∑ i=1 h̃′i (16)\nA softmax classifier is used to predict the probability pj of sentiment label j from h by\nhl = ReLU(Whlh+ bhl)\nP = softmax(Wlphl + blp)\npj = P [j],\n(17)\nwhere Whl, bhl, Wlp and blp are model parameters, and ReLU is the rectifier function f(x) = max(0, x). During prediction, the largest probability component of P will be taken as the answer."
    }, {
      "heading" : "6 Training",
      "text" : "We train our classifier to maximize the conditional log-likelihood of gold labels of training samples. Formally, given a training set of size |D|, the training objective is defined by\nL(θ) = − |D|∑ i=1 log pyi + λ 2 ||θ||2, (18)\nwhere θ is the set of model parameters, λ is a regularization parameter, yi is the gold label of the ith training sample and pyi is obtained according to Equation 17. For sequential LSTM models, we collect errors over each sequence. For Tree LSTMs, we sum up errors at every node.\nThe model parameters are optimized using ADAM (Kingma and Ba, 2014) without gradient clipping, with the default hyper-parameters of the AdamTrainer in the Dynet toolkits.2 We also use dropout (Srivastava et al., 2014) at lexical input embeddings with a fixed probability pdrop to avoid overfitting. pdrop is set to 0.5 for all tasks.\nFollowing Tai et al. (2015), Li et al. (2015), Zhu et al. (2015b) and Le and Zuidema (2015), we use Glove-300d word embeddings3 to train our model. The pretrained word embeddings are fine-tuned for all tasks. Unknown words are handled in two steps. First, if a word is not contained in the pretrained word embeddings, but its lowercased form exists in the embedding table, we use the lowercase as a replacement. Second, if both the original word and its lowercased form cannot be found, we treat the word as unk. The embedding vector of the UNK token is initialized as the average of all embedding vectors.\n2https://github.com/clab/dynet 3http://nlp.stanford.edu/data/glove.840B.300d.zip\nWe use one hidden layer and same dimensionality settings for both sequential and Tree LSTMs. LSTM hidden states are of size 150. The output hidden size is 128 and 64 for the sentiment classification task and the question type classification task, respectively. Each model is trained for 30 iterations. The same training procedure is repeated for 5 times using different random seeds, with parameters being evaluated at the end of every iteration on the development set. We use the label accuracy to select the best model over the 5 development runs and across the 30 iterations, which is taken for the final test."
    }, {
      "heading" : "7 Experiments",
      "text" : ""
    }, {
      "heading" : "7.1 Data",
      "text" : "The effectiveness of our model is tested on a sentiment classification task and a question type classification task."
    }, {
      "heading" : "7.1.1 Sentiment Classification",
      "text" : "For sentiment classification, we use the same data settings as Zhu et al. (2015b). Specifically, the Stanford Sentiment Treebank (Socher et al., 2013b) is used to train our classification model, which contains sentiments for movie reviews. Each sentence is annotated with a constituent tree.Every internal node corresponds to a phrase. Each node is manually assigned an integer sentiment label from 0 to 4, which respectively correspond to five sentiment classes: very negative, negative, neutral, positive and very positive. The root label represents the sentiment label of the whole sentence.\nWe perform both binary classification and finegrained classification. Following previous work, we use labels of all phrases for training. Gold-standard tree structures are used for training and testing (Le and Zuidema, 2015; Li et al., 2015; Zhu et al., 2015b; Tai et al., 2015). Accuracies are evaluated for both the sentence root labels and phrase labels."
    }, {
      "heading" : "7.1.2 Question Type Classification",
      "text" : "For the question type classification task, we use the TREC data (Li and Roth, 2002). Each training sample in this dataset contains a question sentence and its corresponding question type. We work on the six-way coarse classification task, where the six question types are ENTY, HUM, LOC, DESC, NUM\nand ABBR, corresponding to ENTITY, HUMAN, LOCATION, DESCRIPTION, NUMERIC VALUE and ABBREVIATION, respectively. For example, the correct type for the sentence “What year did the Titanic sink?” is of the NUM type. The training set consists of 5,452 examples and the test set contains 500 examples. Since there is no development set, we follow Zhou et al. (2015), randomly extracting 500 examples from the training set as a development set. Different from the sentiment treebank, there is no annotated tree for each sentence. Instead, we obtain an automatically parsed tree for each sentence using an open-sourced parser off-the-shelf (ZPar)4. Another difference between the TREC data and the sentiment treebank is that there is only one label, at the root node, rather than a label for each phrase."
    }, {
      "heading" : "7.2 Baselines",
      "text" : "We consider two models for our baselines. The first is a bidirectional LSTM (BiLSTM) (Hochreiter and Schmidhuber, 1997; Graves et al., 2013). Our bidirectional constituency Tree LSTM (BiConTree) are compared with the bidirectional sequential LSTM to investigate the effectiveness of the tree structure. For the sentiment task, following Tai et al. (2015) and Li et al. (2015), we convert the treebank into sequences to allow the bidirectional LSTM model to make use of every phrase span as a training example. The second baseline model is the bottom-up Tree LSTM model of Zhu et al. (2015b). We make a contrast between this model and our lexicalized bidirectional models to show the effects of adding head lexicalization and top-down information flow."
    }, {
      "heading" : "7.3 Main Results",
      "text" : "Table 1 shows the main results for the sentiment classification task, where RNTN is the recursive neural tensor model of Socher et al. (2013b), ConTree and DepTree denote constituency Tree LSTMs and dependency Tree LSTMs, respectively. Our reimplementation of sequential bidirectional LSTM and constituent Tree LSTM (Zhu et al., 2015b) gives comparable results to Zhu et al. (2015b)’s original implementation.\nAfter incorporating head lexicalization into our constituent Tree LSTM, the fine-grained sentiment\n4https://github.com/SUTDNLP/ZPar, version 7.5\nclassification accuracy increases from 51.2 to 52.8, and the binary sentiment classification accuracy increases from 88.5 to 89.2, which demonstrates the effectiveness of the head lexicalization mechanism.\nTable 1 also shows that a vanilla top-down ConTree LSTM enabled by head-lexicalization (i.e. the top-down half of the final bidirectional model) alone obtains comparable accuracies to the bottom-up ConTree LSTM model. The BiConTree model can further improve the classification accuracies by 0.7 points (fine-grained) and 1.3 points (binary) compared to the unidirectional bottom-up lexicalized ConTree LSTM model, respectively.\nTable 1 includes 5 class accuracies for all nodes. There is no significant difference between different models, as consistent with the observation of Li et al. (2015). To our knowledge, these are the best reported results for this sentiment classification task until now.\nTable 2 shows the question type classification results. Our final model gives better results compared to the BiLSTM model and the bottom-up ConTree model, achieving comparable results to the state-ofthe-art, which is a SVM classifier with carefully designed features."
    }, {
      "heading" : "7.4 Training Time and Model Size",
      "text" : "Introducing head lexicalization and bidirectional extension to the model increases the model complexity. In this section, we analyze our model in terms of training time and model size on the fine-grained sentiment classification task.\nWe run all the models using an i7-4790 3.60GHz CPU with a single thread. Table 4 shows the average running time for different models over 30 iterations. The baseline ConTree model takes about 1.3 hours to finish the training procedure. ConTree+Lex takes about 1.5 times longer than ConTree. BiConTree takes about 3.2 hours, which is about 2.5 times longer than that of ConTree.\nTable 5 compares the model sizes. We did not count the number of parameters in the lookup table since these parameters are the same for all models. Since the size of LSTM models mainly depends on the dimensionality of the state vector h, we change the size of h for comparing the effect of model size. When |h| = 150, the model size of the baseline model ConTree is the smallest, which consists of about 538K parameters. The model size of ConTree+Lex is about 1.4 times as large as that of the baseline model. The bidirectional model BiConTree is the largest, which is about 1.7 times as large as that of the ConTree+Lex model. However,\nthis parameter set is not very large compared to the modern memory capacity, even for a computer with 16GB RAM. In conclusion, in terms of both time, model size and accuracy, head lexicalization method is a good choice.\nTable 5 also helps to clarify whether the gain of the BiConTree model over the ConTree+Lex model is from the top-down information flow or more parameters. For the same model, increasing the model size can improve the performance to some extent. For example, doubling the size of |h| (75 → 150) increases the performance from 51.5 to 52.8 for the ConTree+Lex model. Similarly, we boost the performance of the BiConTree model when doubling the size of |h| from 75 to 150. However, continuing doubling the size of |h| from 150 to 300 empirically decreases the performance of the ConTree+Lex model. The BiConTree model with |h| = 75 is much smaller than the ConTree+Lex model with |h| = 150 in terms of model size. However the performance of these two models is quite close, which indicates that top-down information is useful even for a small model. We also run a ConTree+Lex model with |h| = 215, the model size of which is similar to that of the BiConTree model with |h| = 150. The performance of the ConTree+Lex model is still worse than the BiConTree model (52.5 v.s. 53.5), which shows the effectiveness of top-down information."
    }, {
      "heading" : "7.5 Head Lexicalization Methods",
      "text" : "In this experiment, we investigate the effect of our head lexicalization method over heuristic baselines. We consider three baseline methods, namely L, R and A. For L, a parent node accepts lexical information of its left child while ignoring the right child. Correspondingly, for R, a parent node accepts lexical information of its right child while ignoring the left child. For A, a parent node averages the lexical vectors of the left and right child.\nTable 3 shows the accuracies on the test set, where G denotes our method described in Section 4.1. R gives better results compared to L due to relatively more right-branching structures in this treebank.A simple average yields similar results compared with right branching. In contrast, G outperforms A method by considering the relative weights of each branch according to tree-level contexts.\nWe then investigate what lexical heads can be learned by G. Interestingly, the lexical heads contain both syntactic and sentiment information: while some heads correspond well to Collins syntactic rules (Collins, 2003), others are driven by subjective words. Compared to Collins’ rules, our method found 30.68% and 25.72% overlapping heads on the dev set and test set, respectively.\nFigure 5 shows some visualization based on the cosine similarity between the head lexical vector and its children. We decide the head of a node by choosing the head of the child that gives the largest similarity value. Some examples are shown below, where<> is used to indicate head words. Sentiment labels (e.g. 2, 3) are also included. In Figure 5a, “Emerges” is the syntactic head word of the whole phrase, which is consistent with Collins-style head finding. However, “rare” is the head word of the\nphrase “something rare”, which is different from the syntactic head, but rather sentiment-related. Similar observations are found in Figure 5b, where “good” is the head word of the whole phrase, rather than the syntactic head “place”. The sentiment label of “good” and the sentiment label of the whole phrase are both 3. Figure 5c shows more complex interactions between syntax and sentiment for deciding the head word."
    }, {
      "heading" : "7.6 Error Analysis",
      "text" : "Table 6 shows some example sentences incorrectly predicted by the baseline bottom-up tree model, but correctly labeled by our final model. The head word of sentence #1 by our model is “Gloriously”, which is consistent with the sentiment of the whole sentence. This shows how head lexicalization can affect sentiment classification results. Sentences #2 and #3 show the usefulness of top-down information for complex semantic structures, where compositionality exhibits subtle effects. With top-down LSTM, the models can predict the sentiment labels correctly. Our final model improves the results for the ‘very negative’ and ‘very positive’ classes by 10% and 11%, respectively. It also boosts the accuracies for sentences with negation (e.g. “not”, “no”, and “none”) by 4.4%.\nFigure 6 shows the accuracy distribution according to the sentence length. We find that our model can improve the classification accuracy for longer sentences (>30 words) by 3.5 points compared to the baseline ConTree LSTM of Zhu et al. (2015b), which demonstrates the strength of our model for handling long range information. By considering bidirectional information over tree structures, our model is aware of more complicate contexts for making better predictions."
    }, {
      "heading" : "7.7 Parser Reranking",
      "text" : "Our main results are obtained on semantic-driven tasks, where the automatically-learned head words contain mixed syntactic and semantic information. To further investigate the effectiveness of automatically learned head information on a pure syntactic task, we additionally conduct a simple parser reranking experiment. The standard PTB (Marcus et al., 1993) split (Collins, 2003) are used, and the same off-the-shelf ZPar model is adopted for our baseline. A standard interpolated reranker (Zhu et al., 2015a; Zhou et al., 2016) is adopted for scoring 8-best trees. For each tree y of sentence x, we follow Socher et al. (2013a) to define f(x, y; Θ) as the sum of scores of each constituent node,\nf(x, y; Θ) = ∑\nr∈node(x,y)\nScore(r; Θ) (19)\nWithout loss of generality, we take a binary node as an example. Given a node A, suppose that its two children are B and C. Let the learned composition state vectors of A, B and C by our proposed TreeLSTM model beNA, NB andNC , respectively. The head word vector of node A is HA. Score(A; Θ) is\ndefined as:\nO(A→BC) = ReLU(W L s NB +W R s NC +W H s HA + b s) Score(A→BC) = log(softmax(O(A→B C)))[A], (20)\nwhereWLs ,W R s and b s are model parameters, which are trained using a margin loss.\nTable 7 shows the reranking results on WSJ test set. The baseline F1 score is 90.40. Our ConTree improves the baseline model from 90.40 to 90.70. Using ConTree+Lex model can further improve the performance (90.70 → 90.83). This serves as an evidence that automatic heads can also be useful to some extent for a syntactic task, despite that our main motivation is more semantic-driven. Among neural rerankers, out model outperforms Socher et al. (2013a), but is not as good as current state-of-theart models, including sequence-to-sequence based LSTM language models (Vinyals et al., 2015; Charniak, 2016) and recurrent neural network grammars (Dyer et al., 2016), due to a low baseline oracle and simple reranking models5. Nevertheless, it serves our goal of contrasting the tree LSTM models."
    }, {
      "heading" : "8 Conclusion",
      "text" : "We showed that existing LSTM models for constituent tree structures are limited by not considering direct lexical input in the computing of cell values for non-leaf constituents, and proposed a headlexicalization method to address this issue. Learning the heads of constituent automatically using a neural model, our lexicalized tree LSTM is applicable to arbitrary binary branching trees in form of CFG, and is formalism-independent. In addition, lexical information on the root further allows a top-down extension to the model, resulting in a bi-directional constituent Tree LSTM. Experiments on two well-known datasets show that head-lexicalization improves the unidirectional Tree LSTM model, and bidirectional Tree LSTM gives superior labeling results compared with both unidirectional Tree LSTMs and bidirectional sequential LSTMs. We release our code under GPL at XXX.\n5Dyer et al. (2016) employs 2-layerd LSTMs with input and hidden dimensions of size 256 and 128, respectively, and Charniak (2016) use 3-layered LSTMs with both the input and hidden dimensions of size 1500."
    } ],
    "references" : [ {
      "title" : "Neural machine translation by jointly learning to align and translate",
      "author" : [ "Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio." ],
      "venue" : "arXiv preprint arXiv:1409.0473.",
      "citeRegEx" : "Bahdanau et al\\.,? 2014",
      "shortCiteRegEx" : "Bahdanau et al\\.",
      "year" : 2014
    }, {
      "title" : "Parsing as language modeling",
      "author" : [ "Eugene Charniak" ],
      "venue" : null,
      "citeRegEx" : "Charniak.,? \\Q2016\\E",
      "shortCiteRegEx" : "Charniak.",
      "year" : 2016
    }, {
      "title" : "Parsing the wsj using ccg and log-linear models",
      "author" : [ "Stephen Clark", "James R. Curran." ],
      "venue" : "Proceedings of the 42nd Meeting of the Association for Computational Linguistics (ACL’04), Main Volume, pages 103– 110, Barcelona, Spain, July.",
      "citeRegEx" : "Clark and Curran.,? 2004",
      "shortCiteRegEx" : "Clark and Curran.",
      "year" : 2004
    }, {
      "title" : "Head-driven statistical models for natural language parsing",
      "author" : [ "Michael Collins." ],
      "venue" : "Computational linguistics, 29(4):589–637.",
      "citeRegEx" : "Collins.,? 2003",
      "shortCiteRegEx" : "Collins.",
      "year" : 2003
    }, {
      "title" : "A unified architecture for natural language processing: Deep neural networks with multitask learning",
      "author" : [ "Ronan Collobert", "Jason Weston." ],
      "venue" : "Proceedings of the 25th international conference on Machine learning, pages 160–167. ACM.",
      "citeRegEx" : "Collobert and Weston.,? 2008",
      "shortCiteRegEx" : "Collobert and Weston.",
      "year" : 2008
    }, {
      "title" : "Transitionbased dependency parsing with stack long short-term memory",
      "author" : [ "Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A. Smith." ],
      "venue" : "ACL.",
      "citeRegEx" : "Dyer et al\\.,? 2015",
      "shortCiteRegEx" : "Dyer et al\\.",
      "year" : 2015
    }, {
      "title" : "Recurrent neural network grammars",
      "author" : [ "Chris Dyer", "Adhiguna Kuncoro", "Miguel Ballesteros", "Noah A Smith." ],
      "venue" : "arXiv preprint arXiv:1602.07776.",
      "citeRegEx" : "Dyer et al\\.,? 2016",
      "shortCiteRegEx" : "Dyer et al\\.",
      "year" : 2016
    }, {
      "title" : "Finding structure in time",
      "author" : [ "Jeffrey L Elman." ],
      "venue" : "Cognitive science, 14(2):179–211.",
      "citeRegEx" : "Elman.,? 1990",
      "shortCiteRegEx" : "Elman.",
      "year" : 1990
    }, {
      "title" : "Recurrent nets that time and count",
      "author" : [ "Felix A Gers", "Jürgen Schmidhuber." ],
      "venue" : "Neural Networks, 2000. IJCNN 2000, Proceedings of the IEEE-INNSENNS International Joint Conference on, volume 3, pages 189–194. IEEE.",
      "citeRegEx" : "Gers and Schmidhuber.,? 2000",
      "shortCiteRegEx" : "Gers and Schmidhuber.",
      "year" : 2000
    }, {
      "title" : "Hybrid speech recognition with deep bidirectional lstm",
      "author" : [ "Alan Graves", "Navdeep Jaitly", "Abdel-rahman Mohamed." ],
      "venue" : "Automatic Speech Recognition and Understanding (ASRU), 2013 IEEE Workshop on, pages 273–278. IEEE.",
      "citeRegEx" : "Graves et al\\.,? 2013",
      "shortCiteRegEx" : "Graves et al\\.",
      "year" : 2013
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Sepp Hochreiter", "Jürgen Schmidhuber." ],
      "venue" : "Neural computation, 9(8):1735– 1780.",
      "citeRegEx" : "Hochreiter and Schmidhuber.,? 1997",
      "shortCiteRegEx" : "Hochreiter and Schmidhuber.",
      "year" : 1997
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Diederik P. Kingma", "Jimmy Ba." ],
      "venue" : "CoRR, abs/1412.6980.",
      "citeRegEx" : "Kingma and Ba.,? 2014",
      "shortCiteRegEx" : "Kingma and Ba.",
      "year" : 2014
    }, {
      "title" : "Accurate unlexicalized parsing",
      "author" : [ "Dan Klein", "Christopher D Manning." ],
      "venue" : "Proceedings of the 41st Annual Meeting on Association for Computational Linguistics-Volume 1, pages 423–430. Association for Computational Linguistics.",
      "citeRegEx" : "Klein and Manning.,? 2003",
      "shortCiteRegEx" : "Klein and Manning.",
      "year" : 2003
    }, {
      "title" : "Compositional distributional semantics with long short term memory",
      "author" : [ "Phong Le", "Willem Zuidema" ],
      "venue" : null,
      "citeRegEx" : "Le and Zuidema.,? \\Q2015\\E",
      "shortCiteRegEx" : "Le and Zuidema.",
      "year" : 2015
    }, {
      "title" : "Learning question classifiers",
      "author" : [ "Xin Li", "Dan Roth." ],
      "venue" : "Proceedings of the 19th international conference on Computational linguistics-Volume 1, pages 1–7. Association for Computational Linguistics.",
      "citeRegEx" : "Li and Roth.,? 2002",
      "shortCiteRegEx" : "Li and Roth.",
      "year" : 2002
    }, {
      "title" : "When are tree structures necessary for deep learning of representations? In Empirical Methods in Natural Language Processing (EMNLP)",
      "author" : [ "Jiwei Li", "Minh-Thang Luong", "Dan Jurafsky", "Eudard Hovy" ],
      "venue" : null,
      "citeRegEx" : "Li et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Li et al\\.",
      "year" : 2015
    }, {
      "title" : "Building a large annotated corpus of english: The penn treebank",
      "author" : [ "Mitchell P Marcus", "Mary Ann Marcinkiewicz", "Beatrice Santorini." ],
      "venue" : "Computational linguistics, 19(2):313–330.",
      "citeRegEx" : "Marcus et al\\.,? 1993",
      "shortCiteRegEx" : "Marcus et al\\.",
      "year" : 1993
    }, {
      "title" : "Recurrent neural network based language model",
      "author" : [ "Tomas Mikolov", "Martin Karafiát", "Lukas Burget", "Jan Cernockỳ", "Sanjeev Khudanpur." ],
      "venue" : "INTERSPEECH, 2:3.",
      "citeRegEx" : "Mikolov et al\\.,? 2010",
      "shortCiteRegEx" : "Mikolov et al\\.",
      "year" : 2010
    }, {
      "title" : "Efficient estimation of word representations in vector space",
      "author" : [ "Tomas Mikolov", "Kai Chen", "Greg Corrado", "Jeffrey Dean." ],
      "venue" : "arXiv preprint arXiv:1301.3781.",
      "citeRegEx" : "Mikolov et al\\.,? 2013",
      "shortCiteRegEx" : "Mikolov et al\\.",
      "year" : 2013
    }, {
      "title" : "End-to-end Relation Extraction using LSTMs on Sequences and Tree Structures",
      "author" : [ "Makoto Miwa", "Mohit Bansal." ],
      "venue" : "ArXiv e-prints, abs/1601.00770, January.",
      "citeRegEx" : "Miwa and Bansal.,? 2016",
      "shortCiteRegEx" : "Miwa and Bansal.",
      "year" : 2016
    }, {
      "title" : "Global belief recursive neural networks",
      "author" : [ "Romain Paulus", "Richard Socher", "Christopher D Manning." ],
      "venue" : "Advances in Neural Information Processing Systems, pages 2888–2896.",
      "citeRegEx" : "Paulus et al\\.,? 2014",
      "shortCiteRegEx" : "Paulus et al\\.",
      "year" : 2014
    }, {
      "title" : "From symbolic to sub-symbolic information in question classification",
      "author" : [ "Joao Silva", "Luı́sa Coheur", "Ana Cristina Mendes", "Andreas Wichert" ],
      "venue" : "Artificial Intelligence Review,",
      "citeRegEx" : "Silva et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Silva et al\\.",
      "year" : 2011
    }, {
      "title" : "Parsing Natural Scenes and Natural Language with Recursive Neural Networks",
      "author" : [ "Richard Socher", "Cliff C. Lin", "Andrew Y. Ng", "Christopher D. Manning." ],
      "venue" : "Proceedings of the 26th International Conference on Machine Learning (ICML).",
      "citeRegEx" : "Socher et al\\.,? 2011",
      "shortCiteRegEx" : "Socher et al\\.",
      "year" : 2011
    }, {
      "title" : "Parsing with compositional vector grammars",
      "author" : [ "Richard Socher", "John Bauer", "Christopher D. Manning", "Ng Andrew Y." ],
      "venue" : "Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 455–465, Sofia,",
      "citeRegEx" : "Socher et al\\.,? 2013a",
      "shortCiteRegEx" : "Socher et al\\.",
      "year" : 2013
    }, {
      "title" : "Recursive deep models for semantic compositionality over a sentiment treebank",
      "author" : [ "Richard Socher", "Alex Perelygin", "Jean Wu", "Jason Chuang", "Christopher Manning", "Andrew Ng", "Christopher Potts." ],
      "venue" : "EMNLP.",
      "citeRegEx" : "Socher et al\\.,? 2013b",
      "shortCiteRegEx" : "Socher et al\\.",
      "year" : 2013
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "Ilya Sutskever", "Oriol Vinyals", "Quoc V Le." ],
      "venue" : "Advances in neural information processing systems, pages 3104–3112.",
      "citeRegEx" : "Sutskever et al\\.,? 2014",
      "shortCiteRegEx" : "Sutskever et al\\.",
      "year" : 2014
    }, {
      "title" : "Improved semantic representations from tree-structured long short-term memory networks",
      "author" : [ "Kai Sheng Tai", "Richard Socher", "Christopher D. Manning." ],
      "venue" : "Association for Computational Linguistics (ACL).",
      "citeRegEx" : "Tai et al\\.,? 2015",
      "shortCiteRegEx" : "Tai et al\\.",
      "year" : 2015
    }, {
      "title" : "Grammar as a foreign language",
      "author" : [ "Oriol Vinyals", "Łukasz Kaiser", "Terry Koo", "Slav Petrov", "Ilya Sutskever", "Geoffrey Hinton." ],
      "venue" : "Advances in Neural Information Processing Systems, pages 2755–2763.",
      "citeRegEx" : "Vinyals et al\\.,? 2015",
      "shortCiteRegEx" : "Vinyals et al\\.",
      "year" : 2015
    }, {
      "title" : "Tree recurrent neural networks with application to language modeling",
      "author" : [ "Xingxing Zhang", "Liang Lu", "Mirella Lapata." ],
      "venue" : "CoRR, abs/1511.00060.",
      "citeRegEx" : "Zhang et al\\.,? 2015",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2015
    }, {
      "title" : "A C-LSTM neural network for text classification",
      "author" : [ "Chunting Zhou", "Chonglin Sun", "Zhiyuan Liu", "Francis C.M. Lau." ],
      "venue" : "CoRR, abs/1511.08630.",
      "citeRegEx" : "Zhou et al\\.,? 2015",
      "shortCiteRegEx" : "Zhou et al\\.",
      "year" : 2015
    }, {
      "title" : "A search-based dynamic reranking model for dependency parsing",
      "author" : [ "Hao Zhou", "Yue Zhang", "Shujian Huang", "Junsheng Zhou", "Xin-Yu Dai", "Jiajun Chen." ],
      "venue" : "Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long",
      "citeRegEx" : "Zhou et al\\.,? 2016",
      "shortCiteRegEx" : "Zhou et al\\.",
      "year" : 2016
    }, {
      "title" : "Fast and accurate shift-reduce constituent parsing",
      "author" : [ "Muhua Zhu", "Yue Zhang", "Wenliang Chen", "Min Zhang", "Jingbo Zhu" ],
      "venue" : null,
      "citeRegEx" : "Zhu et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Zhu et al\\.",
      "year" : 2013
    }, {
      "title" : "A re-ranking model for dependency parser with recursive convolutional neural network",
      "author" : [ "Chenxi Zhu", "Xipeng Qiu", "Xinchi Chen", "Xuanjing Huang." ],
      "venue" : "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th Inter-",
      "citeRegEx" : "Zhu et al\\.,? 2015a",
      "shortCiteRegEx" : "Zhu et al\\.",
      "year" : 2015
    }, {
      "title" : "Long short-term memory over tree structures",
      "author" : [ "Xiaodan Zhu", "Parinaz Sobhani", "Hongyu Guo." ],
      "venue" : "CoRR, abs/1503.04881.",
      "citeRegEx" : "Zhu et al\\.,? 2015b",
      "shortCiteRegEx" : "Zhu et al\\.",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "Seminal work employs convolutional neural network (Collobert and Weston, 2008), recurrent neural network (Elman, 1990; Mikolov et al.",
      "startOffset" : 50,
      "endOffset" : 78
    }, {
      "referenceID" : 7,
      "context" : "Seminal work employs convolutional neural network (Collobert and Weston, 2008), recurrent neural network (Elman, 1990; Mikolov et al., 2010) and recursive neural network (Socher et al.",
      "startOffset" : 105,
      "endOffset" : 140
    }, {
      "referenceID" : 17,
      "context" : "Seminal work employs convolutional neural network (Collobert and Weston, 2008), recurrent neural network (Elman, 1990; Mikolov et al., 2010) and recursive neural network (Socher et al.",
      "startOffset" : 105,
      "endOffset" : 140
    }, {
      "referenceID" : 22,
      "context" : ", 2010) and recursive neural network (Socher et al., 2011) for sequence and tree modeling.",
      "startOffset" : 37,
      "endOffset" : 58
    }, {
      "referenceID" : 25,
      "context" : "Recently, Long ShortTerm Memories (LSTM) have received increasing research attention, giving significantly improved accuracies in a variety of sequence tasks (Sutskever et al., 2014; Bahdanau et al., 2014) compared to vanilla recurrent neural networks.",
      "startOffset" : 158,
      "endOffset" : 205
    }, {
      "referenceID" : 0,
      "context" : "Recently, Long ShortTerm Memories (LSTM) have received increasing research attention, giving significantly improved accuracies in a variety of sequence tasks (Sutskever et al., 2014; Bahdanau et al., 2014) compared to vanilla recurrent neural networks.",
      "startOffset" : 158,
      "endOffset" : 205
    }, {
      "referenceID" : 28,
      "context" : "Addressing diminishing gradients effectively, they have been extended to tree structures, achieving promising results for tasks such as syntactic language modeling (Zhang et al., 2015), sentiment analysis (Li et al.",
      "startOffset" : 164,
      "endOffset" : 184
    }, {
      "referenceID" : 15,
      "context" : ", 2015), sentiment analysis (Li et al., 2015; Zhu et al., 2015b; Le and Zuidema, 2015; Tai et al., 2015) and relation extraction (Miwa and Bansal, 2016).",
      "startOffset" : 28,
      "endOffset" : 104
    }, {
      "referenceID" : 33,
      "context" : ", 2015), sentiment analysis (Li et al., 2015; Zhu et al., 2015b; Le and Zuidema, 2015; Tai et al., 2015) and relation extraction (Miwa and Bansal, 2016).",
      "startOffset" : 28,
      "endOffset" : 104
    }, {
      "referenceID" : 13,
      "context" : ", 2015), sentiment analysis (Li et al., 2015; Zhu et al., 2015b; Le and Zuidema, 2015; Tai et al., 2015) and relation extraction (Miwa and Bansal, 2016).",
      "startOffset" : 28,
      "endOffset" : 104
    }, {
      "referenceID" : 26,
      "context" : ", 2015), sentiment analysis (Li et al., 2015; Zhu et al., 2015b; Le and Zuidema, 2015; Tai et al., 2015) and relation extraction (Miwa and Bansal, 2016).",
      "startOffset" : 28,
      "endOffset" : 104
    }, {
      "referenceID" : 19,
      "context" : ", 2015) and relation extraction (Miwa and Bansal, 2016).",
      "startOffset" : 32,
      "endOffset" : 55
    }, {
      "referenceID" : 33,
      "context" : "There are three existing methods for constituent tree LSTM (Zhu et al., 2015b; Tai et al., 2015; Le and Zuidema, 2015), which make essentially the same extension from sequence structure LSTMs.",
      "startOffset" : 59,
      "endOffset" : 118
    }, {
      "referenceID" : 26,
      "context" : "There are three existing methods for constituent tree LSTM (Zhu et al., 2015b; Tai et al., 2015; Le and Zuidema, 2015), which make essentially the same extension from sequence structure LSTMs.",
      "startOffset" : 59,
      "endOffset" : 118
    }, {
      "referenceID" : 13,
      "context" : "There are three existing methods for constituent tree LSTM (Zhu et al., 2015b; Tai et al., 2015; Le and Zuidema, 2015), which make essentially the same extension from sequence structure LSTMs.",
      "startOffset" : 59,
      "endOffset" : 118
    }, {
      "referenceID" : 13,
      "context" : ", 2015; Le and Zuidema, 2015), which make essentially the same extension from sequence structure LSTMs. We take the method of Zhu et al. (2015b) as our baseline.",
      "startOffset" : 8,
      "endOffset" : 145
    }, {
      "referenceID" : 10,
      "context" : "A contrast between the sequence structured LSTM of Hochreiter and Schmidhuber (1997) and the tree-structured LSTM of Zhu et al.",
      "startOffset" : 51,
      "endOffset" : 85
    }, {
      "referenceID" : 10,
      "context" : "A contrast between the sequence structured LSTM of Hochreiter and Schmidhuber (1997) and the tree-structured LSTM of Zhu et al. (2015b) is shown in Figure 1, which illustrates the input (x), cell (c) and hidden (h) nodes at a certain time step t.",
      "startOffset" : 51,
      "endOffset" : 136
    }, {
      "referenceID" : 3,
      "context" : "Research has shown that head word information can significantly improve the performance of syntactic parsing (Collins, 2003; Clark and Curran, 2004).",
      "startOffset" : 109,
      "endOffset" : 148
    }, {
      "referenceID" : 2,
      "context" : "Research has shown that head word information can significantly improve the performance of syntactic parsing (Collins, 2003; Clark and Curran, 2004).",
      "startOffset" : 109,
      "endOffset" : 148
    }, {
      "referenceID" : 3,
      "context" : "Traditional head-lexicalization relies on specific rules (Collins, 2003), typically extracting heads Figure 2: Head-Lexicalized Constituent Tree.",
      "startOffset" : 57,
      "endOffset" : 72
    }, {
      "referenceID" : 9,
      "context" : "This is analogous to the bidirectional extension of sequence structure LSTMs, which are commonly used for NLP tasks such as speech recognition (Graves et al., 2013), sentiment analysis (Tai et al.",
      "startOffset" : 143,
      "endOffset" : 164
    }, {
      "referenceID" : 26,
      "context" : ", 2013), sentiment analysis (Tai et al., 2015; Li et al., 2015) and machine translation (Sutskever et al.",
      "startOffset" : 28,
      "endOffset" : 63
    }, {
      "referenceID" : 15,
      "context" : ", 2013), sentiment analysis (Tai et al., 2015; Li et al., 2015) and machine translation (Sutskever et al.",
      "startOffset" : 28,
      "endOffset" : 63
    }, {
      "referenceID" : 25,
      "context" : ", 2015) and machine translation (Sutskever et al., 2014; Bahdanau et al., 2014) tasks.",
      "startOffset" : 32,
      "endOffset" : 79
    }, {
      "referenceID" : 0,
      "context" : ", 2015) and machine translation (Sutskever et al., 2014; Bahdanau et al., 2014) tasks.",
      "startOffset" : 32,
      "endOffset" : 79
    }, {
      "referenceID" : 31,
      "context" : "Results on a standard sentiment classification benchmark and a question type classification benchmark show that our tree LSTM structure gives significantly better accuracies compared with the method of Zhu et al. (2015b). We achieve the best reported results for sentiment classification.",
      "startOffset" : 202,
      "endOffset" : 221
    }, {
      "referenceID" : 10,
      "context" : "LSTM (Hochreiter and Schmidhuber, 1997) is a variation of RNN (Elman, 1990) to solve vanishing gradients in training.",
      "startOffset" : 5,
      "endOffset" : 39
    }, {
      "referenceID" : 7,
      "context" : "LSTM (Hochreiter and Schmidhuber, 1997) is a variation of RNN (Elman, 1990) to solve vanishing gradients in training.",
      "startOffset" : 62,
      "endOffset" : 75
    }, {
      "referenceID" : 5,
      "context" : "It has been widely adopted for NLP tasks, such as parsing (Dyer et al., 2015) and machine translation (Bahdanau et al.",
      "startOffset" : 58,
      "endOffset" : 77
    }, {
      "referenceID" : 0,
      "context" : ", 2015) and machine translation (Bahdanau et al., 2014).",
      "startOffset" : 32,
      "endOffset" : 55
    }, {
      "referenceID" : 8,
      "context" : "tions (Gers and Schmidhuber, 2000) as our baseline, which models sequences.",
      "startOffset" : 6,
      "endOffset" : 34
    }, {
      "referenceID" : 26,
      "context" : "There has been extensions of sequence-structured LSTMs for modeling trees (Tai et al., 2015; Le and Zuidema, 2015; Zhu et al., 2015b).",
      "startOffset" : 74,
      "endOffset" : 133
    }, {
      "referenceID" : 13,
      "context" : "There has been extensions of sequence-structured LSTMs for modeling trees (Tai et al., 2015; Le and Zuidema, 2015; Zhu et al., 2015b).",
      "startOffset" : 74,
      "endOffset" : 133
    }, {
      "referenceID" : 33,
      "context" : "There has been extensions of sequence-structured LSTMs for modeling trees (Tai et al., 2015; Le and Zuidema, 2015; Zhu et al., 2015b).",
      "startOffset" : 74,
      "endOffset" : 133
    }, {
      "referenceID" : 13,
      "context" : ", 2015; Le and Zuidema, 2015; Zhu et al., 2015b). The idea is similar to extending recursive neural network to recurrent neural network, where gates are used in recursive structures for alleviating diminishing gradients. While Tai et al. (2015) investigated tree-structured LSTMs for both dependency structures and constituent structures, and both for unrestricted trees and M-nary trees, Zhu et al.",
      "startOffset" : 8,
      "endOffset" : 245
    }, {
      "referenceID" : 13,
      "context" : ", 2015; Le and Zuidema, 2015; Zhu et al., 2015b). The idea is similar to extending recursive neural network to recurrent neural network, where gates are used in recursive structures for alleviating diminishing gradients. While Tai et al. (2015) investigated tree-structured LSTMs for both dependency structures and constituent structures, and both for unrestricted trees and M-nary trees, Zhu et al. (2015b) and Le and Zuidema (2015) focused on binary constituent trees.",
      "startOffset" : 8,
      "endOffset" : 408
    }, {
      "referenceID" : 13,
      "context" : ", 2015; Le and Zuidema, 2015; Zhu et al., 2015b). The idea is similar to extending recursive neural network to recurrent neural network, where gates are used in recursive structures for alleviating diminishing gradients. While Tai et al. (2015) investigated tree-structured LSTMs for both dependency structures and constituent structures, and both for unrestricted trees and M-nary trees, Zhu et al. (2015b) and Le and Zuidema (2015) focused on binary constituent trees.",
      "startOffset" : 8,
      "endOffset" : 434
    }, {
      "referenceID" : 13,
      "context" : ", 2015; Le and Zuidema, 2015; Zhu et al., 2015b). The idea is similar to extending recursive neural network to recurrent neural network, where gates are used in recursive structures for alleviating diminishing gradients. While Tai et al. (2015) investigated tree-structured LSTMs for both dependency structures and constituent structures, and both for unrestricted trees and M-nary trees, Zhu et al. (2015b) and Le and Zuidema (2015) focused on binary constituent trees. As discussed earlier, none of these existing methods make direct use of lexical input for composing constituent vectors. We take Zhu et al. (2015b) as our baseline.",
      "startOffset" : 8,
      "endOffset" : 619
    }, {
      "referenceID" : 9,
      "context" : "Bidirectional information has been leveraged to extend sequence LSTM (Graves et al., 2013).",
      "startOffset" : 69,
      "endOffset" : 90
    }, {
      "referenceID" : 9,
      "context" : "Bidirectional information has been leveraged to extend sequence LSTM (Graves et al., 2013). On the other hand, the aforementioned tree-LSTM models work bottom-up, without information flew from parents to children. Zhang et al. (2015) built a topdown tree-LSTM for dependency trees, but without a bottom-up component.",
      "startOffset" : 70,
      "endOffset" : 234
    }, {
      "referenceID" : 9,
      "context" : "Bidirectional information has been leveraged to extend sequence LSTM (Graves et al., 2013). On the other hand, the aforementioned tree-LSTM models work bottom-up, without information flew from parents to children. Zhang et al. (2015) built a topdown tree-LSTM for dependency trees, but without a bottom-up component. Paulus et al. (2014) made use of bidirectional information on binary trees, but for recursive neural networks only.",
      "startOffset" : 70,
      "endOffset" : 338
    }, {
      "referenceID" : 9,
      "context" : "Bidirectional information has been leveraged to extend sequence LSTM (Graves et al., 2013). On the other hand, the aforementioned tree-LSTM models work bottom-up, without information flew from parents to children. Zhang et al. (2015) built a topdown tree-LSTM for dependency trees, but without a bottom-up component. Paulus et al. (2014) made use of bidirectional information on binary trees, but for recursive neural networks only. The closest in spirit to our method, Miwa and Bansal (2016) adopted a bidirectional Tree LSTM model to jointly extract named entities and relations under dependency tree structure.",
      "startOffset" : 70,
      "endOffset" : 493
    }, {
      "referenceID" : 18,
      "context" : "For NLP, the input vectors are typically word embeddings (Mikolov et al., 2013), but can also include PoS embeddings, character embeddings or other types of information.",
      "startOffset" : 57,
      "endOffset" : 79
    }, {
      "referenceID" : 31,
      "context" : "The bottom-up Tree LSTM of Zhu et al. (2015b) extends the left-to-right sequence LSTM by splitting the previous state vector ht−1 into a left child state vector ht−1 and a right child state vector h R t−1, and the previous cell vector ct−1 into a left child cell vector ct−1 and a right child cell vector c R t−1, calculating ct as",
      "startOffset" : 27,
      "endOffset" : 46
    }, {
      "referenceID" : 31,
      "context" : "Figure 3: Contrast between Zhu et al. (2015b) (a) and this paper (b).",
      "startOffset" : 27,
      "endOffset" : 46
    }, {
      "referenceID" : 3,
      "context" : "Rather than selecting head lexicons using manually-defined head-finding rules, which are language- and formalism-dependent (Collins, 2003), we cast head finding as a part of the neural network model, learning the head lexicon of each constituent by a gated combination of head lexicons of its two children1.",
      "startOffset" : 123,
      "endOffset" : 138
    }, {
      "referenceID" : 30,
      "context" : "In contrast, the method of Zhu et al. (2015b) in Figure 3 (a) does not have the input vector xt for non-leaf constituents.",
      "startOffset" : 27,
      "endOffset" : 46
    }, {
      "referenceID" : 31,
      "context" : "Given head lexicon vectors for nodes, the Tree LSTM of Zhu et al. (2015b) can be extended by leveraging xt in calculating the corresponding ct.",
      "startOffset" : 55,
      "endOffset" : 74
    }, {
      "referenceID" : 12,
      "context" : "Typicial binarization methods, such as head binarization (Klein and Manning, 2003) , also rely on specific head-finding rules.",
      "startOffset" : 57,
      "endOffset" : 82
    }, {
      "referenceID" : 9,
      "context" : ", xn], a bidirectional sequential LSTM (Graves et al., 2013) computes two sets of hidden state vectors, [h̃1, h̃2, .",
      "startOffset" : 39,
      "endOffset" : 60
    }, {
      "referenceID" : 11,
      "context" : "The model parameters are optimized using ADAM (Kingma and Ba, 2014) without gradient clipping, with the default hyper-parameters of the AdamTrainer in the Dynet toolkits.",
      "startOffset" : 46,
      "endOffset" : 67
    }, {
      "referenceID" : 11,
      "context" : "The model parameters are optimized using ADAM (Kingma and Ba, 2014) without gradient clipping, with the default hyper-parameters of the AdamTrainer in the Dynet toolkits.2 We also use dropout (Srivastava et al., 2014) at lexical input embeddings with a fixed probability pdrop to avoid overfitting. pdrop is set to 0.5 for all tasks. Following Tai et al. (2015), Li et al.",
      "startOffset" : 47,
      "endOffset" : 362
    }, {
      "referenceID" : 11,
      "context" : "The model parameters are optimized using ADAM (Kingma and Ba, 2014) without gradient clipping, with the default hyper-parameters of the AdamTrainer in the Dynet toolkits.2 We also use dropout (Srivastava et al., 2014) at lexical input embeddings with a fixed probability pdrop to avoid overfitting. pdrop is set to 0.5 for all tasks. Following Tai et al. (2015), Li et al. (2015), Zhu et al.",
      "startOffset" : 47,
      "endOffset" : 380
    }, {
      "referenceID" : 11,
      "context" : "The model parameters are optimized using ADAM (Kingma and Ba, 2014) without gradient clipping, with the default hyper-parameters of the AdamTrainer in the Dynet toolkits.2 We also use dropout (Srivastava et al., 2014) at lexical input embeddings with a fixed probability pdrop to avoid overfitting. pdrop is set to 0.5 for all tasks. Following Tai et al. (2015), Li et al. (2015), Zhu et al. (2015b) and Le and Zuidema (2015), we use Glove-300d word embeddings3 to train our model.",
      "startOffset" : 47,
      "endOffset" : 400
    }, {
      "referenceID" : 11,
      "context" : "The model parameters are optimized using ADAM (Kingma and Ba, 2014) without gradient clipping, with the default hyper-parameters of the AdamTrainer in the Dynet toolkits.2 We also use dropout (Srivastava et al., 2014) at lexical input embeddings with a fixed probability pdrop to avoid overfitting. pdrop is set to 0.5 for all tasks. Following Tai et al. (2015), Li et al. (2015), Zhu et al. (2015b) and Le and Zuidema (2015), we use Glove-300d word embeddings3 to train our model.",
      "startOffset" : 47,
      "endOffset" : 426
    }, {
      "referenceID" : 24,
      "context" : "Specifically, the Stanford Sentiment Treebank (Socher et al., 2013b) is used to train our classification model, which contains sentiments for movie reviews.",
      "startOffset" : 46,
      "endOffset" : 68
    }, {
      "referenceID" : 28,
      "context" : "For sentiment classification, we use the same data settings as Zhu et al. (2015b). Specifically, the Stanford Sentiment Treebank (Socher et al.",
      "startOffset" : 63,
      "endOffset" : 82
    }, {
      "referenceID" : 13,
      "context" : "Gold-standard tree structures are used for training and testing (Le and Zuidema, 2015; Li et al., 2015; Zhu et al., 2015b; Tai et al., 2015).",
      "startOffset" : 64,
      "endOffset" : 140
    }, {
      "referenceID" : 15,
      "context" : "Gold-standard tree structures are used for training and testing (Le and Zuidema, 2015; Li et al., 2015; Zhu et al., 2015b; Tai et al., 2015).",
      "startOffset" : 64,
      "endOffset" : 140
    }, {
      "referenceID" : 33,
      "context" : "Gold-standard tree structures are used for training and testing (Le and Zuidema, 2015; Li et al., 2015; Zhu et al., 2015b; Tai et al., 2015).",
      "startOffset" : 64,
      "endOffset" : 140
    }, {
      "referenceID" : 26,
      "context" : "Gold-standard tree structures are used for training and testing (Le and Zuidema, 2015; Li et al., 2015; Zhu et al., 2015b; Tai et al., 2015).",
      "startOffset" : 64,
      "endOffset" : 140
    }, {
      "referenceID" : 14,
      "context" : "For the question type classification task, we use the TREC data (Li and Roth, 2002).",
      "startOffset" : 64,
      "endOffset" : 83
    }, {
      "referenceID" : 29,
      "context" : "Since there is no development set, we follow Zhou et al. (2015), randomly extracting 500 examples from the training set as a development set.",
      "startOffset" : 45,
      "endOffset" : 64
    }, {
      "referenceID" : 10,
      "context" : "The first is a bidirectional LSTM (BiLSTM) (Hochreiter and Schmidhuber, 1997; Graves et al., 2013).",
      "startOffset" : 43,
      "endOffset" : 98
    }, {
      "referenceID" : 9,
      "context" : "The first is a bidirectional LSTM (BiLSTM) (Hochreiter and Schmidhuber, 1997; Graves et al., 2013).",
      "startOffset" : 43,
      "endOffset" : 98
    }, {
      "referenceID" : 9,
      "context" : "The first is a bidirectional LSTM (BiLSTM) (Hochreiter and Schmidhuber, 1997; Graves et al., 2013). Our bidirectional constituency Tree LSTM (BiConTree) are compared with the bidirectional sequential LSTM to investigate the effectiveness of the tree structure. For the sentiment task, following Tai et al. (2015) and Li et al.",
      "startOffset" : 78,
      "endOffset" : 313
    }, {
      "referenceID" : 9,
      "context" : "The first is a bidirectional LSTM (BiLSTM) (Hochreiter and Schmidhuber, 1997; Graves et al., 2013). Our bidirectional constituency Tree LSTM (BiConTree) are compared with the bidirectional sequential LSTM to investigate the effectiveness of the tree structure. For the sentiment task, following Tai et al. (2015) and Li et al. (2015), we convert the treebank into sequences to allow the bidirectional LSTM model to make use of every phrase span as a training example.",
      "startOffset" : 78,
      "endOffset" : 334
    }, {
      "referenceID" : 9,
      "context" : "The first is a bidirectional LSTM (BiLSTM) (Hochreiter and Schmidhuber, 1997; Graves et al., 2013). Our bidirectional constituency Tree LSTM (BiConTree) are compared with the bidirectional sequential LSTM to investigate the effectiveness of the tree structure. For the sentiment task, following Tai et al. (2015) and Li et al. (2015), we convert the treebank into sequences to allow the bidirectional LSTM model to make use of every phrase span as a training example. The second baseline model is the bottom-up Tree LSTM model of Zhu et al. (2015b). We make a contrast between this model and our lexicalized bidirectional models to show the effects of adding head lexicalization and top-down information flow.",
      "startOffset" : 78,
      "endOffset" : 549
    }, {
      "referenceID" : 33,
      "context" : "Our reimplementation of sequential bidirectional LSTM and constituent Tree LSTM (Zhu et al., 2015b) gives comparable results to Zhu et al.",
      "startOffset" : 80,
      "endOffset" : 99
    }, {
      "referenceID" : 22,
      "context" : "Table 1 shows the main results for the sentiment classification task, where RNTN is the recursive neural tensor model of Socher et al. (2013b), ConTree and DepTree denote constituency Tree LSTMs and dependency Tree LSTMs, respectively.",
      "startOffset" : 121,
      "endOffset" : 143
    }, {
      "referenceID" : 22,
      "context" : "Table 1 shows the main results for the sentiment classification task, where RNTN is the recursive neural tensor model of Socher et al. (2013b), ConTree and DepTree denote constituency Tree LSTMs and dependency Tree LSTMs, respectively. Our reimplementation of sequential bidirectional LSTM and constituent Tree LSTM (Zhu et al., 2015b) gives comparable results to Zhu et al. (2015b)’s original implementation.",
      "startOffset" : 121,
      "endOffset" : 383
    }, {
      "referenceID" : 24,
      "context" : "5 Model 5-class binary Root Phrase Root Phrase RNTN(Socher et al., 2013b) 45.",
      "startOffset" : 51,
      "endOffset" : 73
    }, {
      "referenceID" : 15,
      "context" : "6 BiLSTM(Li et al., 2015) 49.",
      "startOffset" : 8,
      "endOffset" : 25
    }, {
      "referenceID" : 26,
      "context" : "7 DepTree(Tai et al., 2015) 48.",
      "startOffset" : 9,
      "endOffset" : 27
    }, {
      "referenceID" : 13,
      "context" : "7 ConTree(Le and Zuidema, 2015) 49.",
      "startOffset" : 9,
      "endOffset" : 31
    }, {
      "referenceID" : 33,
      "context" : "0 ConTree(Zhu et al., 2015b) 50.",
      "startOffset" : 9,
      "endOffset" : 28
    }, {
      "referenceID" : 15,
      "context" : "ConTree(Li et al., 2015) 50.",
      "startOffset" : 7,
      "endOffset" : 24
    }, {
      "referenceID" : 26,
      "context" : "7 ConTree(Tai et al., 2015) 51.",
      "startOffset" : 9,
      "endOffset" : 27
    }, {
      "referenceID" : 15,
      "context" : "There is no significant difference between different models, as consistent with the observation of Li et al. (2015). To our knowledge, these are the best reported results for this sentiment classification task until now.",
      "startOffset" : 99,
      "endOffset" : 116
    }, {
      "referenceID" : 21,
      "context" : "4 SVM (Silva et al., 2011) 95.",
      "startOffset" : 6,
      "endOffset" : 26
    }, {
      "referenceID" : 3,
      "context" : "Interestingly, the lexical heads contain both syntactic and sentiment information: while some heads correspond well to Collins syntactic rules (Collins, 2003), others are driven by subjective words.",
      "startOffset" : 143,
      "endOffset" : 158
    }, {
      "referenceID" : 31,
      "context" : "5 points compared to the baseline ConTree LSTM of Zhu et al. (2015b), which demonstrates the strength of our model for handling long range information.",
      "startOffset" : 50,
      "endOffset" : 69
    }, {
      "referenceID" : 31,
      "context" : "Model F1 Baseline (Zhu et al. (2013)) 90.",
      "startOffset" : 19,
      "endOffset" : 37
    }, {
      "referenceID" : 16,
      "context" : "The standard PTB (Marcus et al., 1993) split (Collins, 2003) are used, and the same off-the-shelf ZPar model is adopted for our baseline.",
      "startOffset" : 17,
      "endOffset" : 38
    }, {
      "referenceID" : 3,
      "context" : ", 1993) split (Collins, 2003) are used, and the same off-the-shelf ZPar model is adopted for our baseline.",
      "startOffset" : 14,
      "endOffset" : 29
    }, {
      "referenceID" : 32,
      "context" : "A standard interpolated reranker (Zhu et al., 2015a; Zhou et al., 2016) is adopted for scoring 8-best trees.",
      "startOffset" : 33,
      "endOffset" : 71
    }, {
      "referenceID" : 30,
      "context" : "A standard interpolated reranker (Zhu et al., 2015a; Zhou et al., 2016) is adopted for scoring 8-best trees.",
      "startOffset" : 33,
      "endOffset" : 71
    }, {
      "referenceID" : 3,
      "context" : ", 1993) split (Collins, 2003) are used, and the same off-the-shelf ZPar model is adopted for our baseline. A standard interpolated reranker (Zhu et al., 2015a; Zhou et al., 2016) is adopted for scoring 8-best trees. For each tree y of sentence x, we follow Socher et al. (2013a) to define f(x, y; Θ) as the sum of scores of each constituent node,",
      "startOffset" : 15,
      "endOffset" : 279
    }, {
      "referenceID" : 27,
      "context" : "(2013a), but is not as good as current state-of-theart models, including sequence-to-sequence based LSTM language models (Vinyals et al., 2015; Charniak, 2016) and recurrent neural network grammars (Dyer et al.",
      "startOffset" : 121,
      "endOffset" : 159
    }, {
      "referenceID" : 1,
      "context" : "(2013a), but is not as good as current state-of-theart models, including sequence-to-sequence based LSTM language models (Vinyals et al., 2015; Charniak, 2016) and recurrent neural network grammars (Dyer et al.",
      "startOffset" : 121,
      "endOffset" : 159
    }, {
      "referenceID" : 6,
      "context" : ", 2015; Charniak, 2016) and recurrent neural network grammars (Dyer et al., 2016), due to a low baseline oracle and simple reranking models5.",
      "startOffset" : 62,
      "endOffset" : 81
    }, {
      "referenceID" : 19,
      "context" : "Among neural rerankers, out model outperforms Socher et al. (2013a), but is not as good as current state-of-theart models, including sequence-to-sequence based LSTM language models (Vinyals et al.",
      "startOffset" : 46,
      "endOffset" : 68
    }, {
      "referenceID" : 1,
      "context" : "(2016) employs 2-layerd LSTMs with input and hidden dimensions of size 256 and 128, respectively, and Charniak (2016) use 3-layered LSTMs with both the input and hidden dimensions of size 1500.",
      "startOffset" : 102,
      "endOffset" : 118
    } ],
    "year" : 2016,
    "abstractText" : "Sequential LSTM has been extended to model tree structures, giving competitive results for a number of tasks. Existing methods model constituent trees by bottom-up combinations of constituent nodes, making direct use of input word information only for leaf nodes. This is different from sequential LSTMs, which contain reference to input words for each node. In this paper, we propose a method for automatic head-lexicalization for tree-structure LSTMs, propagating head words from leaf nodes to every constituent node. In addition, enabled by head lexicalization, we build a tree LSTM in the top-down direction, which corresponds to bidirectional sequential LSTM structurally. Experiments show that both extensions give better representations of tree structures. Our final model gives the best results on the Standford Sentiment Treebank and highly competitive results on the TREC question type classification task.",
    "creator" : "TeX"
  }
}