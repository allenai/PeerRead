{
  "name" : "1601.06569.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Towards Resolving Unidentifiability in Inverse Reinforcement Learning",
    "authors" : [ "Kareem Amin", "Satinder Singh" ],
    "emails" : [ "amkareem@umich.edu", "baveja@umich.edu" ],
    "sections" : [ {
      "heading" : "1. INTRODUCTION",
      "text" : "Inverse reinforcement learning (IRL), first introduced by Ng and Russell ([10]), is concerned with the problem of inferring the (unknown) reward function of an agent behaving optimally in a Markov decision process. The most basic formulation of the problem asks: given a known environment1 E, and an optimal agent policy π, can we deduce the reward function R which makes π optimal for the MDP (E,R)?\nIRL has seen a number of applications in the development of autonomous systems, such as autonomous vehicle operation, where even a cooperative (human) agent might have great difficultly describing her incentives [17, 2, 1, 5]. However, the problem is fundamental to almost any study which involves behavioral modeling. Consider an experimental psychologist attempting to understand the internal motivations of a subject, say a mouse, or consider a marketer observing user behavior on a website, hoping to understand the potential consumer’s value for various offers.\nAs noted by Ng and Russell, a fundamental complication to the goals of IRL is the impossibility of identifying the exact reward function of the agent from its behavior. In general, there may be infinitely many reward functions consistent with any observed policy π in some fixed environment.\n1We will use the terminology environment to refer to an MDP without a reward function.\nSince the true reward function is fundamentally unidentifiable, much of the previous work in IRL has been concerned with the development of heuristics which prefer certain rewards as better explanations for behavior than others [10, 20, 11]. In contrast, we make several major contributions towards directly resolving the issue of unidentifiability in IRL in this paper.\nAs a first contribution, we separate the causes of this unidentifiability into three classes. 1) A trivial reward function, assigning constant reward to all state-action pairs, makes all behaviors optimal; the agent with constant reward can execute any policy, including the observed π. 2) Any reward function is behaviorally invariant under certain arithmetic operations, such as re-scaling. Finally, 3) the behavior expressed by some observed policy π may not be sufficient to distinguish between two possible reward functions both of which rationalize the observed behavior, i.e., the observed behavior could be optimal under both reward functions. We will refer to the first two cases of unidentifiability as representational unidentifiability, and the third as experimental unidentifiability.\nAs a second contribution, we will demonstrate that, while representational unidentifiability is unavoidable, experimental unidentifiability is not. In contrast to previous methods, we will demonstrate how the latter can be eliminated completely in some cases. Moreover, in a manner which we will make more precise in Section 3, we will argue that in some ways representational unidentifiability is superficial; by eliminating experimental unidentifiability, one arrives at the fullest possible characterization of an agent’s reward function that one can hope for.\nAs a third contribution, we develop a slightly richer model for IRL. We will suppose that the learner can observe the agent behaving optimally in a number of environments of the learner’s choosing. Notice that in many of our motivating examples it is reasonable to assume that the learner does indeed have this power. One can ask the operator of a vehicle to drive through multiple terrains, while the experimental psychologist might observe a mouse across a number of environments. It is up to the experimenter to organize the dynamics of the maze. One of our key results will be that, with the right choice of environments, the learner can eliminate experimental unidentifiability. We will study our repeated experimentation for IRL in two settings, one in which the learner is omnipotent in that there are no restrictions on what environments can be presented to the agent, and another in which there are restrictions on the type of environments the learner can present. We show ar X\niv :1\n60 1.\n06 56\n9v 1\n[ cs\n.A I]\n2 5\nJa n\n20 16\nthat in the former case, experimental unidentifiability can be eliminated with just a small number of environments. In the latter case, we cast the problem as budgeted exploration, and show that for some number of environments B, a simple greedy algorithm approximately maximizes the information revealed about R in B environments.\nMost Closely Related Work. Prior work in IRL has mostly focused on inferring an agent’s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14]. We consider a setting in which the learner can actively select multiple environments to explore, before using the observations obtained from these environments to infer an agent’s reward. Studying a model where the agent can make active selections of environments in an IRL setting is novel to the best of our knowledge. Previous applications of active learning to IRL have considered settings where, in a single environment, the learner can query the agent for its action in some state [8], or for information about its reward [13].\nThere is prior work on using data collected from multiple — but exogenously fixed — environments to predict agent behavior [12]. There are also applications where methods for single-environment MDPs have been adapted to multiple environments [20]. Nevertheless, both these works do not attempt to resolve the ambiguity inherent in recovering the true reward in IRL, and describe IRL as being an “illposed” problem. As a result these works ultimately consider the objective of mimicking or predicting an agent’s optimal behavior. While this is a perfectly reasonable objective, we will more be interested in settings where the identification of R is the goal in itself. Among many other reasons, this may be because the learner explicitly desires an interpretable model of the agent’s behavior, or because the learner desires to transfer the learned reward function to new settings.\nIn the economics literature, the problem of inferring an agent’s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15]. When these models analyze Markovian environments, they will assume a fixed environment where the learner can ask certain types of queries, such as bound queries eliciting whether some state-action reward r(s, a) ≥ b. We will instead be interested in cases where the learner can only make inferences from agent behavior (with no external source of information), but can manipulate the environments on which the agent acts."
    }, {
      "heading" : "2. SETTING AND PRELIMINARIES",
      "text" : "We denote an environment by a tuple E = (S,A, P, γ), where S = {1, ..., d} is a finite set of states in which the agent can find itself, A is a finite set of actions available to the agent, and P is a collection of transition dynamics for each a ∈ A, so that P = {Pa}a∈A. We represent each Pa as a row-stochastic matrix, with Pa ∈ Rd×d, and Pa(s, s′) denoting the agent’s probability of transitioning to state s′ from state s when selecting action a. The agent’s discount factor is γ ∈ (0, 1).\nWe represent an agent’s reward function as a vector R ∈ Rd with R(s) indicating the (undiscounted) payout for arriving at state s. Note that a joint choice of Markovian environment E with reward function R fixes an MDP M = (E,R). A policy is a mapping π : S → A. With slight abuse of notation, we can represent π as a matrix Pπ where\nPπ(s, ·) = Pπ(s)(s, ·) (we take the s-row of Pπ to be the s-row of Pa, where a is the action chosen in state s).\nLet OPT(E,R) denote the set of policies that are optimal, maximizing the agent’s expected time-discounted rewards, for the MDP (E,R). We consider a repeated experimentation setting, where we suppose that the learner is able to select a sequence of environments2 E1, E2, ..., sequentially observing π1, π2, ... satisfying πi ∈ OPT(Ei, R), for some unknown agent reward function R. We call each (Ei, πi) an experiment. The goal of the experimenter is to output a reward estimate R̂, approximating the true reward function. In many settings, the assumption that the learner can directly observe the agent’s full policy πi is too strong, and a more realistic assumption is the learner observes only trajectories T i, where T i denotes a sequence of state-action, pairs drawn according to the distribution induced by the agent playing policy πi in environment Ei. We will refer to the former feedback model as the policy observation setting, and the latter as the trajectory observation setting.\nA fundamental theorem for IRL follows from rewriting the Bellman equations associated with the optimal policy in a single MDP, noting that the components of the vector Pa(I − γPπ)−1R correspond to the Q-value for action a, under policy π and reward R, for each of d states.\nTheorem 1 (Ng, Russell [10]). Let E = (S,A, P, γ) be an arbitrary environment, and R ∈ Rd. π ∈ OPT(E,R) if and only if ∀a ∈ A, (Pπ − Pa)(I − γPπ)−1R ≥ 0.3\nThe key take-away from this theorem is that in a policy observation setting, the set of reward functions R consistent with some observed optimal policy π are precisely those satisfying some set of linear constraints. Furthermore, those constraints can be computed from the environment E and policy π. Thus, an object that we will make recurring reference to is the set of reward functions consistent with experiment (E, π), denoted K(E, π):\nK(E, π) = {R ∈ Rd |∀a ∈ A, (Pπ − Pa)(I − γPπ)−1R ≥ 0 ∀s ∈ S, Rmin ≤ R(s) ≤ Rmax}.\nSince K(E, π) is an intersection of linear constraints, it defines a convex polytope, a fact which will be of later algorithmic importance. An immediate corollary of Theorem 1, is that given a sequence of experiments E = ((E1, π1), ..., (En, πn)), the set of rewards consistent with E are precisely those in\nK(E) , ∩(E,π)∈EK(E, π)\nWe can also think of a trajectory T as inducing a partial policy πT on the states visited by the trajectory. In particular, let D(T ) denote the domain of T , D(T ) = {s | ∃(s, a) ∈ T}. We say two policies π, π′ are consistent on D(T ) ⊂ S, denoted π ≡D(T ) π′, iff π(s) = π′(s) for all s ∈ D(T ). Thus, given (E, T ), the set of rewards consistent with the observation are precisely K(E, T ) = {R ∈ Rd | ∃π ≡D(T ) πT , ∀a ∈ A, (Pπ − Pa)(I − γPπ)−1R ≥ 0, Rmin ≤ Ri ≤ Rmax}, and given a sequence E = {(E1, T 1), ..., (En, Tn)}, we can define K(E) in the trajectory setting. 2Defined on the same state and action spaces. 3The inequality is read component-wise. That is, the relation holds if standard ≥ holds for each component."
    }, {
      "heading" : "3. ON IDENTIFICATION",
      "text" : "In this section we will give a more nuanced characterization of what it means to identify a reward function. We will argue that there are multiple types of uncertainty involved in identifying R, which we categorize as representational unidentifiability and experimental unidentifiability. Furthermore, we argue that first type is in some ways superficial, and ought to be ignored, while the second type can be eliminated.\nWe begin with a definition. Let R and R′ be reward functions defined on the same state space S. We say that R and R′ are behaviorally equivalent if for any environment (also defined on S), the agent whose reward function is R behaves identically to the agent whose reward function is R′.\nDefinition 1. Two reward vectors R,R′ ∈ Rd defined on S are behaviorally equivalent, denoted R ≡ R′ if for any set of actions, transition dynamics, and discount, (A,P, γ), defining an environment E = (S,A,P, γ) we have that OPT(E,R) = OPT(E,R′).\nBehavioral equivalence defines an equivalence relation over vectors in Rd, and we let [R] = {R′ ∈ Rd | R′ ≡ R} denote the equivalence classes defined in this manner. Intuitively, if R and R′ are behaviorally equivalent, they induce identical optimal policies in every single environment, and therefore are not really “different” reward functions. They are simply different representations of the same incentives.\nWe now observe that behavioral equivalence classes are invariant under multiplicative scaling by positive scalars, and component-wise translation by a constant. Intuitively, this is easy to see. Adding c reward to every state in some reward function R does not affect an agent’s decision-making. This is simply “background” reward that the agent gets for free. Similarly, scaling R by a positive constant simply changes the “units” used to represent rewards. The agent does not, and should not, care whether its reward is represented in dollars or cents. We prove this formally in the following Theorem.\nTheorem 2. For any c ∈ Rd, let ~c ∈ Rd denote the vector with all components equal to c. For any α > 0, and R ∈ Rd, R ≡ αR+ ~c.\nProof. First consider ~c as defined in the statement of the Theorem. Fix any environment E = (S,A,P, γ), action a ∈ A and arbitrary policy π. We begin by claiming that (Pπ − Pa)(I − γPπ)−1~c = ~0.\nThe Woodbury formula for matrix inversion tells us that (I − γPπ)−1 = I + (I − γPπ)−1γPπ. Furthermore, for any row-stochastic matrix P , P~c = ~c. Therefore:\nv = (Pπ − Pa)(I − γPπ)−1~c = (Pπ − Pa)(I + (I − γPπ)−1γPπ)~c = (Pπ − Pa)~c+ (Pπ − Pa)(I − γPπ)−1γPπ~c\n= ~0 + (Pπ − Pa)(I − γPπ)−1γ~c = γv\nSince γ ∈ (0, 1), it must be that v = ~0. Now fix a reward function R ∈ Rd, and arbitrary environment E, and consider OPT(E,R). By Theorem 1, we know that π ∈ OPT(E,R) iff for any a ∈ A, (Pπ − Pa)(I − γPπ) −1R ≥ 0, which occurs iff (Pπ−Pa)(I−γPπ)−1(αR) ≥\n0, since α is a positive scalar. Finally, we can conclude that π ∈ OPT(E,R) iff for all a ∈ A, (Pπ−Pa)(I−γPπ)−1(αR+ ~c) ≥ 0, this last condition implying that π ∈ OPT(E,αR + ~c), again by Theorem 1.\nSince our choice of E was arbitrary, by Definition 1, R ≡ αR+ ~c, concluding the proof.\nThus, we argue that one reason why reward functions cannot be identified is a trivial one: the classic IRL problem does not fix a consistent representation for reward functions. For any R ∈ Rd there are an uncountable number of other functions in [R], namely αR+~c for any α and ~c, all of which are behaviorally identical to R. However, distinguishing between these functions is irrelevant; whether an agent’s “true” reward function is (1, 2, 3, 4) or (0, 1/3, 2/3, 1)4 is simply a matter of what units are used to represent rewards.\nIn light of this observation, it is convenient to fix a canonical element of each equivalence class [R]. For any constant reward function R, we will take its canonicalized representation to be ~0. Otherwise we note, by way of Theorem 2, that any R can be translated and re-scaled so that maxsR(s) = 1 and minsR(s) = 0. More carefully, for any non-constant R, we take its canonicalized representation to be (R − minsR(s))/(maxsR(s) − minsR(s)) ∈ [R]. This canonicalization is consistent with behavioral equivalence, and we state the following Theorem whose proof can be found in the appendix. As a consequence of this Theorem, we can use the notation [R] interchangeably to refer to the equivalence class of R, or the the unique canonical element of [R].\nTheorem 3. For any R,R′ ∈ Rd, R ≡ R′ if and only if they have the same canonicalized representation.\nWe next consider the issue of trivial/constant rewards [~0]. Since the IRL problem was first formulated, it has been observed that no single experiment can ever determine that the agent’s reward function is not a constant reward function. The algebraic reason for this is the fact that ~0 is always a solution to the linear system K(E, π), for any E and π. The intuitive reason for this is the fact that any π on some E is as optimal as any other policy for an agent whose reward is ~0. Therefore, if we consider an agent whose true reward is some R ∈ Rd, R 6= ~0, then even in the policy observation setting, both R,~0 ∈ K(E, π). Furthermore, this will not disappear with multiple experimentation. After any sequence of experiments E , it also remains that both R,~0 ∈ K(E).\nConsider an agent whose true reward function is ~0. A crucial consequence of the above is that if an IRL algorithm guarantees that it will identify ~0, then it necessarily misidentifies non-trivial reward functions. This is because an agent with a trivial reward function is allowed to behave arbitrarily, and therefore may choose to behave consistently with some non-trivial reward R. An IRL algorithm that guarantees identification of trivial rewards will therefore misidentify the agent whose true reward is R.\nThis leads us to the following revised definition of identification, which accounts for what we call representational unidentifiability:\nDefinition 2. We say that an IRL algorithm succeeds at identification if for any R ∈ Rd, after observing behavior 4We get (0, 1/3, 2/3, 1) from (1, 2, 3, 4) by subtracting 1 from every state and dividing by 3"
    }, {
      "heading" : "No amount of experimentation can remove the representational unidentifiability from the setting, depicted here by the darker shaded region. (c) Nevertheless, adding the constraints K(E′, π′)",
      "text" : "induced by a second experiment disproves the original selection., removing some experimental unidentifiability.\nfrom an agent with true reward R, the algorithm outputs a R̂ such that R̂ ≡ R whenever R 6∈ [~0].\nNotice that this definition accomplishes two things. First, it excuses an algorithm for decisions about how R is represented. In other words, it asserts that the salient task in IRL is computing a member of [R], not the literal R. Secondly, if the true reward function R is not constant (i.e. R 6∈ [~0]), it demands the that algorithm identify R (up to representational decisions). However, if the agent really does have a reward function of ~0, the algorithm is allowed to output anything. In other words, the Algorithm is only allowed to behave arbitrarily if the agent behaves arbitrarily.5\nWe also note that Definition 2 can be relaxed to give a notion of approximate identification, which we state here:\nDefinition 3. We say that an IRL algorithm -identifies a reward function if for any R ∈ Rd, after observing behavior from an agent with true reward R, the algorithm outputs a R̂ such that ||[R]− [R̂]||∞ ≤ whenever R 6∈ [~0].\nEven Definition 2 may not be attainable from a single experiment, as K(E, π) may contain multiple behavioral classes [R]. We call this phenonmenon experimental unidentifiability, due to the fact that the experiment (E, π) may simply be insufficient to distinguish between some [R] and [R′]. In the next section, we will observe that this source of uncertainty in the reward function can be decreased with multiple experimentation, as depicted in Figure 1 (see Caption for details). In other words, by distinguishing representational unidentifiability from experimental unidentifiability, we can formally resolve the latter.\nA more concrete example is given in Figure 2, which depicts a grid-world with each square representing a state. In each of the figures, thick lines represent impenetrable walls, and an agent’s policy is depicted by arrows, with a circle indicating the agent deciding to stay at a grid location. The goal of the learner is to infer the reward of each state. Figures 2(a) and 2(b), depict the same agent policy, which takes the shortest path to the location labeled x from any starting location. One explanation for such behavior, depicted in\n5We comment that, as a practical matter, one is usually interested in rationalizing the behavior of an agent believed to be non-trivial.\nFigure 2(a), is that the agent has large reward for state x, and zero reward for every other state. However, an equally possible explanation is that the state y also gives positive reward (but smaller than that of x) such that if there exists a shortest path to x that also passes through y, the agent will take it (depicted in Figure 2(b)). Without additional information, these two explanations cannot be distinguished.\nThis is an example of experimental unidentifiability that can nevertheless be resolved with additional experimentation. By observing the same agent in the environment depicted in Figure 2(c), the learner infers that y is indeed a rewarding state. Finally, observing the agent’s behavior in the environment of Figure 2(d) reveals that the agent will prefer traveling to state y if getting to x requires 11 steps or more, while getting to y requires 4 steps of fewer. These subsequent observations allow the learner to relate the agent’s reward at state x with the agent’s reward at state y."
    }, {
      "heading" : "4. OMNIPOTENT EXPERIMENTER SETTING",
      "text" : "We now consider a repeated experimentation setting in which the environments available for selection by the experimenter are completely unrestricted. Formally, each environment E selected by the experimenter belongs to a class U∗ containing an environment (S,A, P, γ) for every feasible set of transition dynamics P on S. We call this the omnipotent experimenter setting.\nWe will describe an algorithm for the omnipotent experimenter setting that -identifies R, using just O(log(d/ )) experiments. While the omnipotent experimenter is extremely powerful, the result demonstrates that the guarantee obtained in a repeated IRL setting can be far stronger than available in a standard single-environment IRL setting. Furthermore, it clarifies the distinction between experimental unidentifiability and representational unidentifiability."
    }, {
      "heading" : "4.1 Omnipotent Identification Algorithm",
      "text" : "The algorithm proceeds in two stages, both of which involve simple binary searches. The first stage will identify states smin, smax such that R(smin) = Rmin and R(smax) = Rmax. The second stage identifies for each s ∈ S an αs such that R(s) = αsRmin + (1 − αs)Rmax. Throughout, the algorithm only makes use of two agent actions which we will denote a1, a2. Therefore, in describing the algorithm, we will assume that |A| = 2, and the environment selected by the algorithm is fully determined by its choices for Pa1 and Pa2 . If in fact |A| > 2, in the omnipotent experimenter setting, one can reduce to the two-action setting by making the remaining actions in A equivalent to either a1 or a2. 6\nWe first address the task of identifying smax. Suppose we have two candidates s and s′ for smax. The key idea in this first stage of the algorithm is to give the agent an absolute choice between the two states by setting Pa1(s, s) = 1, Pa1(s ′, s′) = 1, while setting Pa2(s, s ′) = 1 and Pa2(s\n′, s) = 1. An agent selecting π(s) = a1 reveals (for any γ) that R(s) ≥ R(s′), while an agent selecting π(s) = a2 reveals that R(s) ≤ R(s′). This test can be conducted for up to d/2 distinct pairs of states in a single experiment. Thus given k candidates for smax, in a single experiment, we can narrow the set of candidates to k/2, and are guaranteed that one of the remaining states s satisfies R(s) = Rmax. After log(d) such experiments we can identify a single state smax which satisfies R(smax) ≥ R(s) for all s. Conducting an analogous procedure identifies a state smin.\nOnce smin and smax are identified, take s1, ..., sd−2 to be the remaining states, and consider an environment with transition dynamics parameterized by α = (αs1 , ..., αsd−2). A typical environment in this phase is depicted in Figure 3. The environment sets smin, smax to be sinks with Pa1(smin, smin) = Pa1(smax, smax) = Pa2(smin, smin) = Pa2(smax, smax) = 1. For each remaining si, Pa1(si, smin) = αsi and Pa1(si, smax) = (1− αsi), so that taking action a1 in state si represents an αi probability gamble between the best and worst state. Finally, Pα also sets Pa2(s, s) = 1, and so taking action a2 in state si represents receiving R(si) for sure. By selecting π(s) = a1, the agent reveals αsRmin + (1 − αs)Rmax ≥ R(s), while a choice π(s) = a2 reveals that αsRmin + (1 − αs)Rmax ≤ R(s). Thus, a binary search can be conducted on each αs ∈ [0, 1] independently in order to determine an approximation of the α∗s such that R(s) = α ∗ sRmin + (1− α∗s)Rmax. The algorithm succeeds at -identification, summarized in the following theorem. The proof of the theorem is a straightforward analysis of binary search.\n6Doing so is possible in this setting because transition dynamics can be set arbitrarily.\nTheorem 4. Let R̂ be defined by letting R̂(smin) = 0, R̂(smax) = 1, and R̂(s) = 1 − αs for all other s (where smin, smax, and αs are identified as described above). For any true reward function R 6∈ [~0] with canonical form [R], ||[R]− R̂||∞ ≤ .\nThe takeaway of this setting is that the problems regarding identification in IRL can be circumvented with repeated experimentation. It is thought that even with policy observations, the IRL question is fundamentally ill-posed. However, here we see that with repeated experimentation it is in fact possible to identify R to arbitrary precision in a welldefined sense. While these results are informative, we believe that it is unrealistic to imagine that the learner can arbitrarily influence the environment of the agent. In the next section, we develop a theory for repeated experimentation when the learner is restricted to select environments from some restricted subset of all possible transition dynamics."
    }, {
      "heading" : "5. RESTRICTED EXPERIMENTER SETTING",
      "text" : "We now consider a setting in which the experimenter has a restricted universe U of environments to choose from. U need not contain every possible transition dynamic, an assumption required to execute the binary search algorithm of the previous section. The best the experimenter could ever hope for is to try every environment in U . This gives the experimenter all the available information about the agent’s reward function R. Thus, we will be more interested in maximizing the information gained by the experimenter while minimizing the number of experiments conducted. In practice, observing an agent may be expensive, or hard to come by, and so for even a small budget of experiments B, the learner would like select the environments from U which maximally reduce experimental unidentifiability.\nOnce a sequence of experiments E has been observed, we know that R is consistent with the observed sequence if and only if R ∈ K(E). Thus, the value of repeated experimentation is allowing the learner to select environments so that K(E) is as informative as possible. In contrast, we note that previous work on IRL has largely been focused on designing heuristics for the selection problem of picking some R from a fixed set (of equally possible reward functions). Thus, we will be interested in making K(E) “small,” while IRL has traditionally been focused on selecting R from exogenously fixed K(E). Before defining what we mean by “small”, we will review preexisting methods for selecting R ∈ K(E)."
    }, {
      "heading" : "5.1 Generalized Selection Heuristics",
      "text" : "In the standard (single-environment) setting, given an environment E and observed policy π, the learner must make a selection among one of the rewards in K(E, π). The heuristic suggested by [10] is motivated by the idea that for a given state s, the reward function that maximizes the difference in Q-value between the observed action in state s, π(s), and any other action a 6= π(s), gives the strongest explanation of the behavior observed from the agent. Thus, a reasonable linear selection criterion is to maximize the sum of these differences across states. Adding a regularization term, encourages the selection of reward functions that are also sparse. Putting these together, the standard selection heuristic for single-environment IRL is to select the R which maximizes:\n∑ s∈S ( min a6=π(s) (Pπ(s)− Pa(s))(I − γPπ)−1R ) − λ|R(s)| (1)\nThere are two natural candidates for generalizing this selection rule to the repeated experimentation setting, where now instead of a single experiment, the experimenter has encountered a sequence of observations E . The first is to sum over all (environment, state), pairs, the minimum difference in Q-value between the action selected by the agent and any other action. The second is to sum over states, taking the minimum over all (environment, action), pairs. While one could make arguments motivating each of these, ultimately any such objective is heuristic. However, we do argue that there is a strong algorithmic reason for preferring the latter objective. In particular, the former objective grows in dimensionality as environments are added, quickly resulting in an intractable LP. The dimension of the objective in the latter (Equation 2), however, remains constant.7\nmaximize R∈K(E) ∑ s∈S  min (Ei,πi)∈E a 6=πi(s) (P iπ(s)− P ia(s))(I − γP iπ)−1R −λ|R(s)| (2)\nThere are other selection rules for the single-environment setting, which are generalizable to the repeated experimentation setting, including heuristics for the infinite state setting, trajectory heuristics, as well as approaches already adapted to multiple environments [12]. Due to space constraints, we discuss only the foundational approach of [10]. Our goal here is simply to emphasize the dichotomy between adapting pre-existing IRL methods to data gathered from multiple environments (however that data was generated), and the problem of how to best select those environments to begin with, this latter problem being the focus of the next section."
    }, {
      "heading" : "5.2 Adaptive Experimentation",
      "text" : "Given a universe U of candidate environments, we now ask how to select a small number of environments from U so that the environments are maximally informative. We must first decide what we mean by “informative.” We propose that for a set of experiments E (either in the policy or trajectory setting), a natural objective is to minimize the mass of the resulting space of possible rewards K(E) with respect to some measure (or distribution) µ. Under the Lebesgue measure (or uniform distribution), this corresponds to the natural goal of reducing the volume of the K(E) as much as possible. Thus we define:\nVolµ(K(E)) = ∫ Rd 1[R ∈ K(E)]dµ(R)\n= PR∼µ [R ∈ K(E)]\nWe will find it convenient to cast this as a maximization problem, and therefore also define f(E) = V − Volµ(K(E)), 7Writing Equation 2 as an LP in standard form requires translating the min into constraints, and thus the number of constraints grows with the number of experiments, but as we demonstrate in our experimental results, this is tractable for most LP solvers.\nwhere V is an upper bound on the volume of [−Rmax, Rmax]d, and our goal to maximize f(E).\nThis objective has several desirable properties. First and foremost, by reducing the volume of K(E) we eliminate the space of possible reward functions (i.e. experimental unidentifiability). Secondly, the repeated experimentation setting is fundamentally an active learning setting. We can think of the true, unknown, R as a function that labels environments E with either a corresponding policy π or trajectory T . Thus, the volume operator corresponds to reducing the version space of possible rewards. Furthermore, as we will see later in this section, the objective is a monotone submodular function, an assumption well-studied in the active learning literature [7, 6], allowing us to prove guarantees for a greedy algorithm.\nFinally, we will normally think of µ as being the Lebesgue measure, and Vol(·) as volume in d-dimensional Euclidean space (or the uniform distribution on [−Rmax, Rmin]d). However, the choice of µ makes the objective quite general. For example, by making µ uniform on an -net on Rd, Vol corresponds to counting the number of rewards that are -apart with respect to some metric. In many settings, R naturally comes from some discrete space, such as the corners of the hypercube {0, 1}d. Again, this is readily modeled by the correct choice of µ. In fact, µ can be thought of simply as any prior on [−Rmax, Rmax]d.\nWe are now ready to describe a simple algorithm that adaptively selects environments E ∈ U , attempting to greedily maximize f(·), depicted as Algorithm 1.\nAlgorithm 1 Greedy Environment Selection\n1: Input B 2: i := 1 3: E := ∅ 4: while i ≤ B do 5: Ei := arg max\nE min R∈K(E) min π∈OPT(E,R) f(E ∪ (E, π))− f(E)\n6: Observe policy πi for Ei. 7: E := (E, (Ei, πi)) 8: i := i+ 1 9: end while\n10: return E\nIn order to state a performance guarantee about Algorithm 1, we will use the fact that f(·) is a submodular, nondecreasing, function on subsets of environment, observation pairs, 2U×O, where O is the set of possible observations.\nLemma 1. f is a submodular, non-decreasing function.\nProof. Given a set S and component s, we use S + s to denote the union of the singleton set {s} with S. Let O be the set of possible observations, so that o is a trajectory in the trajectory setting, and a policy in the policy setting. Let U be the space of possible environments.\nFix any Ê ⊂ E ⊂ 2U×O, and (E, o) 6∈ E . By definition of K(·), we have that K(E + (E, o)) = K(E) ∩K(E, o) and K(E) ⊂ K(Ê), and so: f((E , (E, o)))− f(E) = Vol(K(E))− Vol(K(E , (E, o))) = ∫ Rd 1[R ∈ K(E), R 6∈ K(E, o)]dµ(R)\n≤ ∫ Rd 1[R ∈ K(Ê), R 6∈ K(E, o)]dµ(R) = f((Ê , (E, o))) − f(Ê) This establishes submodularity of f . Since E is arbitrary and the right-hand-side of the second equality is nonzero, f is also monotone.\nThe performance of any algorithm is a function of how many experiments are attempted, and thus our analysis must\ntake this into account. Let An be a deterministic algorithm that deploys at most n experiments. An has a worst-case performance, which depends on the true reward R and what policies were observed. We say a sequence of experiments E = ((E1, o1), ..., (En, on)) is consistent with An and R, if An chooses environment Ej+1 after observing the subsequence of experiments ((E1, o1), ..., (Ej , oj)), and oj is either a trajectory or policy consistent with (E,R). Denoting the set of consistent experiments C(An, R), the best performance that any algorithm can guarantee with n experiments is: OPTn = maxAn minR minE∈C(An,R) f(E)\nThe submodularity of f , allows us to prove that for any n, the Greedy Environment Selection Algorithm8 needs slightly more than n experiments (by a logarithmic factor) to attain f(E) ≈ OPTn.\nTheorem 5. E returned by the Greedy Environment Selection algorithm satisfies f(E) ≥ OPTn − when B = n ln(OPTn/ ) ≤ n ln(V/ ).\nThe proof of Theorem 5 uses many of the same techniques used by Guillory et. al ([7]), in their work on interactive set cover. For technical reasons, we cannot state our theorem directly as a corollary of these results, which assume a finite hypothesis class, whereas we have an infinite space of possible rewards. Nevertheless, these proofs are easily adapted to our setting, and the full proofs are given in the appendix.\nFinally we note that Line (5) is not computable exactly without parametric assumptions on the class of environments or space of rewards. In practice, and as we will describe in the next section, we approximate the exact maximization by sampling environments and rewards from K(E), and optimizing on the sampled sets."
    }, {
      "heading" : "6. EXPERIMENTAL ANALYSIS",
      "text" : "We now deploy the techniques discussed in a setting, demonstrating that maximizing f(·) is indeed effective for identifying R. We imagine that we have an agent that will be\n8n.b. in the trajectory setting, one would replace the minimization over π ∈ OPT(E,R) in line 5 of the algorithm, with a minimization over T consistent with π, π ∈ OPT(E,R).\ndropped into a grid world. The experimenter would like to infer the agent’s reward for each space in the grid. We imagine that the experimenter has the power to construct walls in the agent’s environment, and so we will alternatively refer to an environment as a maze. To motivate the value of repeated experimentation, recall Figure 2.\nThis is a restricted environment for the learner. The learner cannot, for example, make it so that an action causes the agent to travel from a bottom corner of the maze to a top corner. However, the learner can modify the dynamics of the environment in so far as it can construct maze walls.\nWe evaluate Algorithm 1 on grids of size 10 × 10. An agent’s reward is given by a vector R ∈ R100, with ||R||∞ ≤ Rmax, where Rmax is taken to be 10 in all that follows. In each simulation we randomly assign some state in R to have reward Rmax, and assign 5 states to have reward 1.\n9 The remaining states give reward 0. The agent’s discount rate is taken to be 0.8. The goal of the learner is not just to determine which states are rewarding, but to further determine that the latter states yield 1/10 the reward of the former.\nIn Figure 4a, we display our main experimental results for four different algorithms in the policy observation setting, and in Figure 4b for the trajectory setting. Error represents ||R− R̂||∞, where R̂ is an algorithm’s prediction, with error bars representing standard error over 20 simulations.\nIn Figure 4a, the horizontal line displays the best results we achieved without repeated experimentation. If the learner only selects a single environment E, observing policy π, it is stuck with whatever experimental unidentifiability exists in K(E, π). In such a scenario, we can select a K(E, π) according to a classic IRL heuristic, given by LP (1) in Section 5.1, for some choice of λ in LP (1). Since the performance of this method depends both on which environment is used, and the choice of λ, we randomly generated 100 different environments, and for each of those environments selected λ ∈ {0.05, .1, .5, 1, 5, 6, 7, 8, 9, 10}. We then evaluated each of these single-environment approaches with\n9For motivation, one might think of the agent as being a mouse, with these rewards corresponding to food pellets or various shiny objects in a mouse’s cage.\n20 simulations, the best error among these 1300 different single-environment algorithms is displayed by the horizontal line. Immediately we see that the experimental unidentifiability from using a single environment makes it difficult to distinguish the actual reward function, with err for the best choice of E and λ greater than 5.\nThe remaining algorithms — which we will describe in greater detail below — conduct repeated experimentation. Each of these algorithms uses a different rule to select a new environment on each round. Given the sequence of (environment, policy) pairs E generated by each of these algorithms, we solve the LP (2) on K(E) at the end of each round. This is done with the same choice of λ(= 0.5) for each of the algorithms.\nBesides the Greedy algorithm of the previous section, we implement two other algorithms, which conduct repeated experiments, but do so non-adaptively. RandUniform, in each round, selects a maze uniformly at random from the space of possible mazes (each wall is present with probability 0.5). Note that RandUniform will tend to select mazes where roughly half of the walls are present. Thus, we also consider RandVaried which, in each round, selects a maze from a different distribution D. Mazes drawn from D are generated by a two-step process. First, for each row r and column c, we select numbers dr, dc i.i.d. from the uniform distribution on [0, 1]. Then each wall along row r (column c respectively) is created with probability dr (dc respectively). Although the probability any particular wall is present is still 0.5, the correlations in D creates more variable mazes (e.g. allowing an entire row to be sparsely populated with walls).\nWe implement Algorithm 1, Greedy, of the previous section, by approximating the maximization in Line 5 in Algorithm 1. This approximation is done by sampling 10 environments fromD, the same distribution used by RandVaried. In the policy observation setting, 1000 samples are first drawn from the consistent set K(E) using a hit-and-run sampler [9], which is an MCMC method for uniformly sampling highdimensional convex sets in polynomial time. These same samples are also used to estimate the volume f(·). In the trajectory setting, we first sample trajectories T on an environment E, then we use K(E, π̂) for an arbitrary π̂, π̂ ≡D(T ) πT , as a proxy for K(E, T ).\nExamining the results, we see that Greedy converges significantly quicker than either of the non-adaptive approaches. After 25 rounds of experimentation in the policy observation setting, Greedy attains error 0.2687(±0.0302), while the best non-adaptive approach attains 0.9691(±0.24310). Greedy only requires 16 rounds to reach a similar error of 0.9678(±0.0701). We note further that the performance of Greedy seems to continue to improve, while the nonadaptive approaches appear to stagnate. This could be due to the fact that after a certain number of rounds, the nonadaptive approaches have received all the information available from the environments typically sampled from their distributions. In order to make progress they must receive new information, in contrast to Greedy, which is designed to actively select the environments that will do just that.\nFinally, Greedy runs by selecting a sequence of environments, resulting in observations E . It then selects R from K(E) using LP (2). Thus, the regularization parameter λ in LP (2) is a free parameter for Greedy that we took to be equal to 0.5 for results (Figure 4a). We conclude by experimentally analyzing the sensitivity of Greedy to the choice of\nthis parameter, as well as of RandUniform, and RandVaried, which also select R according to LP (2). As λ is increased, eventually the LP over-regularizes, and is optimized taking R = ~0. In our setting, once λ ≈ 1 this begins to occur, and we begin to see pathological behavior (Figure 5a). This problem occurs in standard IRL, and one approach ([10]) is to select a large lambda before this transition, hence our choice of λ = 0.5. However, even for significantly smaller λ, the results are qualitatively similar (Figure 5b) to those in Figure 4a. We find that as long as λ is not too large, the results are not sensitive to the choice of λ."
    }, {
      "heading" : "7. CONCLUSIONS",
      "text" : "We provide a number of contributions in this work. First, we separate the causes of unidentifiability in IRL problems into two classes: representational, and experimental. We argue that representational unidentifiability is superficial, leading us to redefine the problem of identification in IRL according to Definition 2. While previous work does not distinguish between these two classes, we demonstrate that, by doing so, algorithms can be designed to eliminate experimental unidentifiability while providing formal guarantees.\nAlong the way, we derive a new model for IRL where the learner can observe behavior in multiple environments, a model which we believe is interesting in its own right, but also is key to eliminating experimental unidentifiability. We give an algorithm for a very powerful learner who can observe agent behavior in any environment, and show that the algorithm -identifies an agent reward defined on d states, while observing behavior on only O(log(d/ )) environments. We then weaken this learner to model more realistic settings where the learner might be restricted in the types of environments it may choose, and where it may only be able to elicit a small number of demonstrations from the agent. We derive a simple adaptive greedy algorithm which will select a nearly optimal (with respect to reducing the volume of possible reward function) set of environments. The value of the solution found by this greedy algorithm will be a comparable to the optimal algorithm which uses a logarithmic factor fewer number of experiments.\nFinally, we implement the algorithm in a simple maze environment that nevertheless demonstrates the value of eliminating experimental unidentifiability, significantly outperforming methods that attempt to perform IRL from a single environment."
    }, {
      "heading" : "A. PROOF OF THEOREM 3",
      "text" : "Theorem 6. For any R,R′ ∈ Rd, R ≡ R′ if and only if they have the same canonicalized representation.\nProof. By definition, the canonicalized representation of any reward function is attained by scaling and translation. Therefore, by Theorem 2, if R and R′ are both canonicalized as Rc, we have that R ≡ Rc and R′ ≡ Rc, and therefore R ≡ R′.\nIn the other direction, suppose R and R′ are canonicalized to Rc and R ′ c respectively, where Rc 6= R′c. Again, by Theorem 2, we have that R ≡ Rc and R′ ≡ R′c. Thus, to prove the theorem, it is sufficient to argue that Rc and R ′ c are not behaviorally equivalent. If one of Rc, R ′ c is ~0 and the other is not, then it is straightforward to show that they are not behaviorally equivalent. Thus, we focus on the case where both Rc and R ′ c are not ~0. We consider three cases. First, suppose that Rc 6= R′c because they have different minimally-rewarding states. Without loss of generality suppose that there is some s0 with Rc(s0) = 0 but R ′ c(s0) > 0. Furthermore, let s′0 be any state such that R ′ c(s ′ 0) = 0. Consider an environment E with two actions a and a′. Action a deterministically transitions to state s0 from any other state, while action a′ determininstically transitions to state s′0 from any other state. Let πa be the policy that always takes action a. OPT(E,R′c) = {πa}. However, if πa ∈ OPT(E,Rc), this means that Rc(s ′ 0) = 0, and therefore all policies are in OPT(E,Rc). Thus, OPT(E,Rc) 6= OPT(E,R′c), and Rc, R ′ c are not behaviorally equivalent.\nNext, suppose that Rc 6= R′c because they have different maximally-rewarding states. Analagously to the previous case, suppose without loss of generality there is some s0 with Rc(s0) = 1 by R ′ c(s0) < 0, and let s ′ 0 be any state such that R′c(s ′ 0) = 1 (which exists since R ′ c 6= ~0). Define the environment E in the same way as the previous case. This time, OPT(E,R′c) = {πa′}, while OPT(E,Rc) 6= {πa′}.\nFinally, suppose that Rc and R ′ c share the same maximally and minimally rewarding states, but there exists some s such that Rc(s) 6= R′c(s). Let s0 be any state such that Rc(s0) = R′c(s0) = 0 and let s1 be any state such that Rc(s1) = R′c(s1) = 1. Without loss of generality suppose that Rc(s) < R′c(s). Let E be the environment with two actions a and ap. Let p be any real number 0 ≤ Rc(s) < p < R′c(s) ≤ 1. From every state, action ap transitions to state s1 with probabiity p and to state s0 with the remaining probability. From every state action a transtions to state s deterministically. The reward for taking action ap in any state under either reward function is p, while action a gives a reward of Rc(s) < p\nunder Rc and R ′ c(s) > p under R ′ c. Thus, OPT(E,Rc) = {πap} 6= {πa} = OPT(E,R′c), concluding the proof."
    }, {
      "heading" : "B. PROOF OF GREEDY’S PERFORMANCE",
      "text" : "Given a set S and component s, we use S + s to denote the union of the singleton set {s} with S. We begin by redefining:\nVolµ(K(E)) = ∫ Rd 1[R ∈ K(E)]dµ(R)\nf(E) = V −Volµ(K(E))\nwhere V is an upper bound Volµ([−Rmax, Rmax]d). Let O be the set of possible observations, so that o is a trajectory in the trajectory setting, and a policy in the policy setting. Let U be the space of possible environments. WWe first establish that f is indeed submodular.\nLemma 2. f is a submodular, non-decreasing function on 2U×O.\nProof. Fix any Ê ⊂ E ⊂ 2U×O, and (E, o) 6∈ E . By definition of K(·), we have that K(E + (E, o)) = K(E) ∩ K(E, o) and K(E) ⊂ K(Ê), and so:\nf((E , (E, o)))− f(E) = Vol(K(E))−Vol(K(E , (E, o)))\n= ∫ Rd 1[R ∈ K(E), R 6∈ K(E, o)]dµ(R)\n≤ ∫ Rd 1[R ∈ K(Ê), R 6∈ K(E, o)]dµ(R) = f((Ê , (E, o)))− f(Ê)\nThis establishes submodularity of f . Since E is arbitrary and the right-hand-side of the second equality is non-zero, f is also monotone.\nLet T = {T : U → O} denote the set of functions mapping environments to observations. For any T ∈ T and S ⊂ U , overload T , so that T (S) = ∪E∈S(E, T (E)).\nNow suppose that environments where labeled according to some T ∈ T , and consider an algorithm which knowing T , selects the fewest number of environments S, so that f(T (S)) ≥ α. Given such an algorithm, we can now define the General Identification Cost, which identifies the worstpossible labelling strategy in T . In particular:\nGICα = max T∈T min S⊂U:f(T (S))≥α\n|S|\nRecall the definition from the main body:\nOPTn = max An min R min E∈C(An,R)\nf(E)\nThis is the largest that an algorithm can guarantee to make f(·) with n environments, when environments are consistently labeled by some R. Let A∗ be the algorithm satisfying the max.\nLemma 3. GICOPTn ≤ n\nProof. Fix any T ∈ T . Consider two cases. First suppose that there exists some S ⊂ U such that |S| ≤ n, but T (S) is inconsistent with the labeling of any R. By defintion\nof f , f(T (S)) = V ≥ OPTn, and since |S| ≤ n, the Lemma is proven.\nOtherwise, it must be that all S ⊂ U , |S| ≤ n, T (S) is consistent with the labeling of some R. By definition of OPTn, running A∗ against the labels provided by T is guaranteed to result in a sequence of environments S∗, |S∗| ≤ n, satisfying f(T (S∗)) ≥ OPTn. S∗ is a witness that minS⊂U:f(T (S))≥OPTn |S| is at most n.\nGiven an environment E and true reward R, let O(E,R) denote the set of possible observations (in either the policy or trajectory setting).\nLemma 4. For any E, such that f(E) ≤ OPTn, there exists an environment E such that:\nmin R∈K(E) min o∈O(E,R)\nf(E+(E, o))−f(E) ≥ (OPTn−f(E))/GICOPTn\nProof. Suppose not. Then for every environment E, there exists some R ∈ K(E) and o ∈ O(E,R) such that:\nf(E + (E, o))− f(E) < (OPTn − f(E))/GICOPTn Now let T ′ ∈ T be defined so that:\nT ′(E) , arg min R,o∈O(E,R) f(E + (E, o))− f(E) (3)\n< (OPTn − f(E))/GICOPTn (4)\nBy definition of GIC, we have that:\nmin S⊂U:f(T ′(S))≥OPTn\n|S| ≤ GICOPTn\nSo there exists a set of environments S, with |S| ≤ GICOPTn , such that f(T ′(S)) ≥ OPTn, and by monotonicity of f , we know that f(T ′(S) ∪ E) ≥ OPTn. Let γ = |S|/GICOPTn .\nHowever, despite f(T ′(S) ∪ E) ≥ OPTn, repeatedly applying the submodularity of f , then applying equation (4) implies:\nf(T ′(S) ∪ E) ≤ f(E) + ∑ E∈S (f(E + (E, T ′(E)))− f(E)\n< f(E) + |S|(OPTn − f(E))/GICOPTn = f(E) + γ(OPTn − f(E)) = (1− γ)f(E) + γOPTn ≤ OPTn\nThis establishes a contradiction.\nWe can now prove the main theorem:\nTheorem 7. E returned by the Greedy Environment Selection algorithm satisfies f(E) ≥ OPTn − when B = n ln(OPTn/ ).\nProof. Let Ei denote the subsequence consisting of the first i environment, observation pairs. If for some i ≤ B, f(Ei) ≥ OPTn, then there is nothing to prove. Otherwise, by applying Lemma 3, and the definition of the algorithm, we know that:\nf(Ei)− f(Ei−1) ≥ (OPTn − f(Ei−1))/GICOPTn which implies:\nOPTn − f(Ei) ≤ (OPTn − f(Ei−1))(1− 1/GICOPTn)\nUsing the fact 1− x ≤ e−x, we can conclude:\nOPTn − f(E) ≤ OPTn exp(−B/GICOPTn))\nApplying Lemma 4 and substitutingB completes the proof."
    } ],
    "references" : [ {
      "title" : "An application of reinforcement learning to aerobatic helicopter flight",
      "author" : [ "P. Abbeel", "A. Coates", "M. Quigley", "A.Y. Ng" ],
      "venue" : "Advances in neural information processing systems,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2007
    }, {
      "title" : "Apprenticeship learning via inverse reinforcement learning",
      "author" : [ "P. Abbeel", "A.Y. Ng" ],
      "venue" : "In Proceedings of the twenty-first international conference on Machine learning,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2004
    }, {
      "title" : "Making rational decisions using adaptive utility elicitation",
      "author" : [ "U. Chajewska", "D. Koller", "R. Parr" ],
      "venue" : "In AAAI/IAAI,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2000
    }, {
      "title" : "Learning for control from multiple demonstrations",
      "author" : [ "A. Coates", "P. Abbeel", "A.Y. Ng" ],
      "venue" : "In Proceedings of the 25th international conference on Machine learning,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2008
    }, {
      "title" : "Apprenticeship learning for helicopter control",
      "author" : [ "A. Coates", "P. Abbeel", "A.Y. Ng" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2009
    }, {
      "title" : "Adaptive submodularity: A new approach to active learning and stochastic optimization",
      "author" : [ "D. Golovin", "A. Krause" ],
      "venue" : "In COLT, pages 333–345,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2010
    }, {
      "title" : "Interactive submodular set cover",
      "author" : [ "A. Guillory", "J. Bilmes" ],
      "venue" : "In Proceedings of the International Conference on Machine Learning,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2010
    }, {
      "title" : "Active learning for reward estimation in inverse reinforcement learning",
      "author" : [ "M. Lopes", "F. Melo", "L. Montesano" ],
      "venue" : "In Machine Learning and Knowledge Discovery in Databases,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "Hit-and-run mixes fast",
      "author" : [ "L. Lovász" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1999
    }, {
      "title" : "Algorithms for inverse reinforcement learning",
      "author" : [ "A.Y. Ng", "S.J. Russell" ],
      "venue" : "In Icml,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2000
    }, {
      "title" : "Bayesian inverse reinforcement learning",
      "author" : [ "D. Ramachandran", "E. Amir" ],
      "venue" : "Urbana, 51:61801,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2007
    }, {
      "title" : "Maximum margin planning",
      "author" : [ "N.D. Ratliff", "J.A. Bagnell", "M.A. Zinkevich" ],
      "venue" : "In Proceedings of the 23rd International Conference on Machine Learning,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2006
    }, {
      "title" : "Regret-based reward elicitation for markov decision processes",
      "author" : [ "K. Regan", "C. Boutilier" ],
      "venue" : "In Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2009
    }, {
      "title" : "Robust policy computation in reward-uncertain mdps using nondominated policies",
      "author" : [ "K. Regan", "C. Boutilier" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2010
    }, {
      "title" : "Eliciting additive reward functions for markov decision processes",
      "author" : [ "K. Regan", "C. Boutilier" ],
      "venue" : "In IJCAI Proceedings-International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2011
    }, {
      "title" : "Preference elicitation and inverse reinforcement learning",
      "author" : [ "C.A. Rothkopf", "C. Dimitrakakis" ],
      "venue" : "In Machine Learning and Knowledge Discovery in Databases,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2011
    }, {
      "title" : "Effective reinforcement learning for mobile robots",
      "author" : [ "W.D. Smart", "L.P. Kaelbling" ],
      "venue" : "In Robotics and Automation,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2002
    }, {
      "title" : "A game-theoretic  approach to apprenticeship learning",
      "author" : [ "U. Syed", "R.E. Schapire" ],
      "venue" : "In Advances in neural information processing systems,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2007
    }, {
      "title" : "Theory of games and economic behavior (60th Anniversary Commemorative Edition)",
      "author" : [ "J. Von Neumann", "O. Morgenstern" ],
      "venue" : "Princeton university press,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2007
    }, {
      "title" : "Maximum entropy inverse reinforcement learning",
      "author" : [ "B.D. Ziebart", "A.L. Maas", "J.A. Bagnell", "A.K. Dey" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "Inverse reinforcement learning (IRL), first introduced by Ng and Russell ([10]), is concerned with the problem of inferring the (unknown) reward function of an agent behaving optimally in a Markov decision process.",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 16,
      "context" : "The most basic formulation of the problem asks: given a known environment E, and an optimal agent policy π, can we deduce the reward function R which makes π optimal for the MDP (E,R)? IRL has seen a number of applications in the development of autonomous systems, such as autonomous vehicle operation, where even a cooperative (human) agent might have great difficultly describing her incentives [17, 2, 1, 5].",
      "startOffset" : 397,
      "endOffset" : 410
    }, {
      "referenceID" : 1,
      "context" : "The most basic formulation of the problem asks: given a known environment E, and an optimal agent policy π, can we deduce the reward function R which makes π optimal for the MDP (E,R)? IRL has seen a number of applications in the development of autonomous systems, such as autonomous vehicle operation, where even a cooperative (human) agent might have great difficultly describing her incentives [17, 2, 1, 5].",
      "startOffset" : 397,
      "endOffset" : 410
    }, {
      "referenceID" : 0,
      "context" : "The most basic formulation of the problem asks: given a known environment E, and an optimal agent policy π, can we deduce the reward function R which makes π optimal for the MDP (E,R)? IRL has seen a number of applications in the development of autonomous systems, such as autonomous vehicle operation, where even a cooperative (human) agent might have great difficultly describing her incentives [17, 2, 1, 5].",
      "startOffset" : 397,
      "endOffset" : 410
    }, {
      "referenceID" : 4,
      "context" : "The most basic formulation of the problem asks: given a known environment E, and an optimal agent policy π, can we deduce the reward function R which makes π optimal for the MDP (E,R)? IRL has seen a number of applications in the development of autonomous systems, such as autonomous vehicle operation, where even a cooperative (human) agent might have great difficultly describing her incentives [17, 2, 1, 5].",
      "startOffset" : 397,
      "endOffset" : 410
    }, {
      "referenceID" : 9,
      "context" : "Since the true reward function is fundamentally unidentifiable, much of the previous work in IRL has been concerned with the development of heuristics which prefer certain rewards as better explanations for behavior than others [10, 20, 11].",
      "startOffset" : 228,
      "endOffset" : 240
    }, {
      "referenceID" : 19,
      "context" : "Since the true reward function is fundamentally unidentifiable, much of the previous work in IRL has been concerned with the development of heuristics which prefer certain rewards as better explanations for behavior than others [10, 20, 11].",
      "startOffset" : 228,
      "endOffset" : 240
    }, {
      "referenceID" : 10,
      "context" : "Since the true reward function is fundamentally unidentifiable, much of the previous work in IRL has been concerned with the development of heuristics which prefer certain rewards as better explanations for behavior than others [10, 20, 11].",
      "startOffset" : 228,
      "endOffset" : 240
    }, {
      "referenceID" : 9,
      "context" : "Prior work in IRL has mostly focused on inferring an agent’s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].",
      "startOffset" : 121,
      "endOffset" : 147
    }, {
      "referenceID" : 1,
      "context" : "Prior work in IRL has mostly focused on inferring an agent’s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].",
      "startOffset" : 121,
      "endOffset" : 147
    }, {
      "referenceID" : 3,
      "context" : "Prior work in IRL has mostly focused on inferring an agent’s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].",
      "startOffset" : 121,
      "endOffset" : 147
    }, {
      "referenceID" : 19,
      "context" : "Prior work in IRL has mostly focused on inferring an agent’s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].",
      "startOffset" : 121,
      "endOffset" : 147
    }, {
      "referenceID" : 10,
      "context" : "Prior work in IRL has mostly focused on inferring an agent’s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].",
      "startOffset" : 121,
      "endOffset" : 147
    }, {
      "referenceID" : 17,
      "context" : "Prior work in IRL has mostly focused on inferring an agent’s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].",
      "startOffset" : 121,
      "endOffset" : 147
    }, {
      "referenceID" : 13,
      "context" : "Prior work in IRL has mostly focused on inferring an agent’s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].",
      "startOffset" : 121,
      "endOffset" : 147
    }, {
      "referenceID" : 7,
      "context" : "Previous applications of active learning to IRL have considered settings where, in a single environment, the learner can query the agent for its action in some state [8], or for information about its reward [13].",
      "startOffset" : 166,
      "endOffset" : 169
    }, {
      "referenceID" : 12,
      "context" : "Previous applications of active learning to IRL have considered settings where, in a single environment, the learner can query the agent for its action in some state [8], or for information about its reward [13].",
      "startOffset" : 207,
      "endOffset" : 211
    }, {
      "referenceID" : 11,
      "context" : "There is prior work on using data collected from multiple — but exogenously fixed — environments to predict agent behavior [12].",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 19,
      "context" : "There are also applications where methods for single-environment MDPs have been adapted to multiple environments [20].",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 2,
      "context" : "In the economics literature, the problem of inferring an agent’s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].",
      "startOffset" : 164,
      "endOffset" : 187
    }, {
      "referenceID" : 18,
      "context" : "In the economics literature, the problem of inferring an agent’s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].",
      "startOffset" : 164,
      "endOffset" : 187
    }, {
      "referenceID" : 14,
      "context" : "In the economics literature, the problem of inferring an agent’s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].",
      "startOffset" : 164,
      "endOffset" : 187
    }, {
      "referenceID" : 15,
      "context" : "In the economics literature, the problem of inferring an agent’s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].",
      "startOffset" : 164,
      "endOffset" : 187
    }, {
      "referenceID" : 12,
      "context" : "In the economics literature, the problem of inferring an agent’s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].",
      "startOffset" : 164,
      "endOffset" : 187
    }, {
      "referenceID" : 14,
      "context" : "In the economics literature, the problem of inferring an agent’s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].",
      "startOffset" : 164,
      "endOffset" : 187
    }, {
      "referenceID" : 9,
      "context" : "Theorem 1 (Ng, Russell [10]).",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 0,
      "context" : "Thus, a binary search can be conducted on each αs ∈ [0, 1] independently in order to determine an approximation of the α∗ s such that R(s) = α ∗ sRmin + (1− α∗ s)Rmax.",
      "startOffset" : 52,
      "endOffset" : 58
    }, {
      "referenceID" : 9,
      "context" : "The heuristic suggested by [10] is motivated by the idea that for a given state s, the reward function that maximizes the difference in Q-value between the observed action in state s, π(s), and any other action a 6= π(s), gives the strongest explanation of the behavior observed from the agent.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 11,
      "context" : "There are other selection rules for the single-environment setting, which are generalizable to the repeated experimentation setting, including heuristics for the infinite state setting, trajectory heuristics, as well as approaches already adapted to multiple environments [12].",
      "startOffset" : 272,
      "endOffset" : 276
    }, {
      "referenceID" : 9,
      "context" : "Due to space constraints, we discuss only the foundational approach of [10].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 6,
      "context" : "Furthermore, as we will see later in this section, the objective is a monotone submodular function, an assumption well-studied in the active learning literature [7, 6], allowing us to prove guarantees for a greedy algorithm.",
      "startOffset" : 161,
      "endOffset" : 167
    }, {
      "referenceID" : 5,
      "context" : "Furthermore, as we will see later in this section, the objective is a monotone submodular function, an assumption well-studied in the active learning literature [7, 6], allowing us to prove guarantees for a greedy algorithm.",
      "startOffset" : 161,
      "endOffset" : 167
    }, {
      "referenceID" : 6,
      "context" : "al ([7]), in their work on interactive set cover.",
      "startOffset" : 4,
      "endOffset" : 7
    }, {
      "referenceID" : 0,
      "context" : "from the uniform distribution on [0, 1].",
      "startOffset" : 33,
      "endOffset" : 39
    }, {
      "referenceID" : 8,
      "context" : "In the policy observation setting, 1000 samples are first drawn from the consistent set K(E) using a hit-and-run sampler [9], which is an MCMC method for uniformly sampling highdimensional convex sets in polynomial time.",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 9,
      "context" : "This problem occurs in standard IRL, and one approach ([10]) is to select a large lambda before this transition, hence our choice of λ = 0.",
      "startOffset" : 55,
      "endOffset" : 59
    } ],
    "year" : 2016,
    "abstractText" : "We consider a setting for Inverse Reinforcement Learning (IRL) where the learner is extended with the ability to actively select multiple environments, observing an agent’s behavior on each environment. We first demonstrate that if the learner can experiment with any transition dynamic on some fixed set of states and actions, then there exists an algorithm that reconstructs the agent’s reward function to the fullest extent theoretically possible, and that requires only a small (logarithmic) number of experiments. We contrast this result to what is known about IRL in single fixed environments, namely that the true reward function is fundamentally unidentifiable. We then extend this setting to the more realistic case where the learner may not select any transition dynamic, but rather is restricted to some fixed set of environments that it may try. We connect the problem of maximizing the information derived from experiments to active submodular function maximization, and demonstrate that a greedy algorithm is near optimal (up to logarithmic factors). Finally, we empirically validate our algorithm on an environment inspired by behavioral psychology.",
    "creator" : "LaTeX with hyperref package"
  }
}