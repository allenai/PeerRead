{
  "name" : "1704.03574.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "CASP Solutions for Planning in Hybrid Domains",
    "authors" : [ "MARCELLO BALDUCCINI", "DANIELE MAGAZZENI", "EMILY C. LEBLANC" ],
    "emails" : [ "marcello.balduccini@gmail.com)", "daniele.magazzeni@kcl.ac.uk)", "marco@dibris.unige.it)", "ecl38@drexel.edu)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "In this paper, we present CASP solutions for dealing with PDDL+ problems, i.e., encoding from PDDL+ to CASP, and extensions to the algorithm of the ezcsp CASP solver in order to solve CASP programs arising from PDDL+ domains. An experimental analysis, performed on well-known linear and non-linear variants of PDDL+ domains, involving various configurations of the ezcsp solver, other CASP solvers, and PDDL+ planners, shows the viability of our solution. Under consideration in Theory and Practice of Logic Programming (TPLP)."
    }, {
      "heading" : "1 Introduction",
      "text" : "Constraint Answer Set Programming (CASP) (Baselice et al. 2005) is an extension of ASP (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991; Niemelä 1999; Baral 2003; Marek and Truszczynski 1999) that makes it possible to add numerical constraints to the rules of ASP programs, thus allowing to represent and reason on infinite state systems. In the automated planning community, the PDDL standard language for domain representation has been extended with constructs for modeling mixed discrete-continuous dynamics, thus with a similar objective of CASP development. The improved language of the planning community is called PDDL+ (Fox and Long 2006). Current CASP algorithms and solvers are either based on an eager approach to CASP solving (Mellarkod et al. 2008; Ostrowski and Schaub 2012), where the numerical constraints are processed within the ASP search, or are based on a lazy approach (Balduccini 2009), where first an ASP solution is found, and then the numerical constraints involved in the ASP solution are checked for consistency by a Constraint Satisfaction Problem (CSP) solver. Independently from the approach used, in order to be able to solve PDDL+ problems with CASP technology, there is the need to both define a suitable encoding from PDDL+ to CASP, and to extend the architecture of current CASP solvers.\nIn this paper, we present an approach for using CASP solving techniques to find plans for PDDL+ problems. In particular, first we design an encoding from PDDL+ to CASP, where we show how the various\nar X\niv :1\n70 4.\n03 57\n4v 1\nconstructs and the overall planning problems can be expressed in CASP by building on work on reasoning about action and change, and previous work on ASP encoding of planning problems. Given that there is still no standard language for CASP, we will mainly rely on the language constructs of the ezcsp solver. This is not a severe limitation: variants of our encoding for other CASP languages, e.g., clingon, can be obtained by syntactic modifications. Second, we present an architecture suitable for finding PDDL+ plans for a PDDL+ problem via its translation to CASP and the use of a CASP solver.\nThe proposed encoding and solving techniques follow a discretize-and-validate approach (Della Penna et al. 2009) in which a discretization is applied during the generation of the CASP encoding. In order to select only those CASP solutions that correspond to valid plans, the basic CASP solving algorithm is extended with a further check that uses the plan validator VAL (Howey et al. 2004) to verify the validity of the solution found. If the test fails, another CASP solution is found, until a valid plan has been found. Although the architecture is given for the ezcsp solver, it can be extended to other CASP solvers.\nThe paper contains an extensive experimental analysis on well-known PDDL+ domains. The analysis includes (i) various configurations of the ezcsp solver, (ii) variants of the proposed encoding, exploiting both domain-specific and domain-independent heuristics, (iii) variants of the encoding for use with the clingon CASP solver, studying the ramifications of the added language expressivity of the solver, (iv) stateof-the-art PDDL+ planners dReal and UPMurphi, and (v) two planning tasks, i.e., finding a plan at fixed (optimal) time step, and by progressively increasing the maximum time step. The experimental evaluation provides interesting results regarding the performance of CASP-based solutions vs. other PDDL+ planning approaches. It also demonstrates that PDDL+ planning is an excellent source of CASP benchmarks, with results that are sometimes surprising. Overall, the results show that our solution employing ezcsp performs well across all domains and reasoning tasks, at the same time being the only solution able to deal with all cases presented.\nThe paper is structured as follows. Section 2 introduces needed preliminaries about PDDL+, ASP, and CASP. Section 3 presents the proposed architecture for planning in hybrid domains and discusses our encoding from PDDL+ to CASP, which is exemplified in Section 4 by means of a concrete PDDL+ problem. The experimental analysis is provided in Section 5. Section 6 presents a more sophisticated extension of the solving architecture. The paper ends by discussing related work in Section 7, and by drawing conclusions in Section 8."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "In this section, we provide background knowledge on the main topics covered by the paper. We first introduce the domain of hybrid systems, followed by a brief introduction on AI planning and its application to hybrid domains. Finally, we briefly describe ASP, CSP, and CASP.\nHybrid systems can be described as hybrid automata (Henzinger 1996), which are finite state automata\nextended with continuous variables that evolve over time.\nDefinition 1 (Hybrid Automaton) A hybrid automaton is a tuple H = (Loc,Var , Init ,Flow ,Trans, I ), where\n• Loc is a finite set of locations, Var = {x1, . . . , xn} is a finite set of real-valued variables, Init(`) ⊆ Rn is the set of initial values for x1, . . . , xn for all locations `. • For each location `, Flow(`) is a relation over the variables in Var and their derivatives of the form\nẋ(t) = Ax(t) + u(t), u(t) ∈ U ,\nwhere x(t) ∈ Rn, A is a real-valued n x n matrix, and U ⊆ Rn is a closed and bounded convex set. • Trans is a set of discrete transitions, a discrete transition tr ∈ Trans being a tuple (`, g, ξ, `′) where ` and `′ are the source and the target locations, respectively, g is the guard of tr (given as a linear\nconstraint), and ξ is the update of tr (given by an affine mapping).\n• I (`) ⊆ Rn is an invariant for all locations `.\nAn illustrative example is given by the hybrid automaton for a thermostat depicted in Figure 1. Here, the temperature is represented by the continuous variable x. In the discrete location corresponding to the heater being off, the temperature falls according to the flow condition ẋ = −0.1x, while when the heater is on, the temperature increases according to the flow condition ẋ = 5 − 0.1x. The discrete transitions state that the heater may be switched on when the temperature falls below 19 degrees, and switched off when the temperature is greater than 21 degrees. Finally, the invariants state that the heater can be on (off) only if the temperature is not greater than 22 degrees (not less than 18 degrees)."
    }, {
      "heading" : "2.1 PDDL+ Planning",
      "text" : "Planning is an AI technology that aims at selecting and organizing activities in order to achieve specific goals (Nau et al. 2004). A planner uses a domain model, describing the actions through their pre- and postconditions, and an initial state together with a goal condition. It then searches for a trajectory through the induced state space, starting at the initial state and ending in a state satisfying the goal condition. In richer models, such as hybrid systems, the induced state space can be given a formal semantics as a timed hybrid automaton, which means that a plan can synchronise activities between controlled devices and external events. PDDL+ is the planning formalism used to model hybrid system planning domains.\nIn the rest of this subsection, we introduce the concepts of planning instance and plan in the context of PDDL+ planning.\nDefinition 2 (Planning Instance) A planning instance is a pair I = (Dom,Prob), where Dom = (Fs,Rs,As, Es,Ps, arity) is a tuple consisting of a finite set of function symbols Fs, a finite set of relation symbols Rs, a finite set of (durative) actions As, a finite set of events Es, a finite set of processes Ps, and a function arity mapping all symbols in Fs ∪ Rs to their respective arities. The triple Prob = (Os, Init , G) consists of a finite set of domain objects Os, the initial state Init , and the goal specification G.\nFollowing (Bogomolov et al. 2014), given a planning instance I, a state of I consists of a discrete component, described as a set of propositions P (the Boolean fluents), and a numerical component, described as a set of real variables v (the numerical fluents). Instantaneous actions are described through preconditions (which are conjunctions of propositions in P and/or numerical constraints over v, and define when an action can be applied) and effects (which specify how the action modifies the current state). The term “instantaneous” refers to the fact that instantaneous actions begin and end at the same timepoint. Events have preconditions as for actions, but they are used to model exogenous change in the world; therefore they are triggered as soon as the preconditions are true. A process is responsible for the continuous change of variables, and is active as long as its preconditions are true. Durative actions have three sets of preconditions, representing, respectively, the conditions that must hold when an action starts, the invariants that must hold throughout its execution, and the conditions that must hold at the end of the action. Similarly, a durative action has three sets of effects: effects that are applied when the action starts, effects that are applied when the action ends, and a set of continuous numeric effects which are applied continuously while the action is executing.\nFormally, the semantics of a PDDL+ planning instance (Definition 2) is given by hybrid automata (Defi-\nnition 1).\nThe full syntax and semantics of PDDL+ can be found in the seminal paper (Fox and Long 2006). However, in the following we provide a concrete example for the thermostat automaton in Figure 1, that also shows the main constructs of PDDL+.\nFigure 2 shows the PDDL+ process representing the continuous change of the temperature when the thermostat is off (that corresponds to the Off mode in the hybrid automaton in Figure 1. Here, the parameters are the thermostat (variable ?t) and the room (variable ?r). The condition field specifies when the process is active, that is while the thermostat is off and the temperature of the room (x ?r) is greater than or equal to 18. The effect field specifies the continuous change that takes place while the process is active, and actually models the differential equation described in the hybrid automaton of Figure 1. A similar process can be defined for when the thermostat is on. Note that PDDL+ processes follow a must semantics, meaning that they are triggered as soon as the preconditions are true, and then become inactive as soon as they become false.\nThe other key element of a planning domain is the set of actions. Figure 3 shows an example of action for\nswitching the thermostat off.\nHere, the preconditions specify that the thermostat can be switched off only if it is currently on and if the temperature of the room is greater than 21. The action has two discrete effects that specify that the thermostat is now off and is no longer on. A similar action can be defined for switching the thermostat on. Note that, as opposed to processes, actions follow a may semantics, meaning that the planner may (or may not) decide to apply that action. Clearly, each action can only be applied if the precondition is satisfied.\nFor completeness, we also provide an example of durative action in Figure 4, from the mars rover, a typical\ndomain in the AI planning comunity.\nThis durative action refers to the rover moving between two waypoints. The duration field specifies how long the action takes to complete, and in this case is function of the length of the path to be traversed. The condition field can specify conditions that must hold at start (i.e., before the action can actually start), at end (i.e., when the action terminates) and overall (i.e., throughout the duration of the action). In this example, it is required that at start the rover is in the initial waypoint, and for the whole action the two waypoints are visible and there is enough battery charge. Similarly, the effects of the action can be applied when the action starts, when it terminates, or they can be continuous while the action is being applied. In this example, when the action starts the rover is no longer at waypoint wp1, it will be at waypoint wp2 when the action terminates, and while the action is being executed the battery level decreases continuously.\nOnce the planning instance has been defined, a planner can be used to find a plan, whose formal definition\nis given in the following.\nDefinition 3 (Plan) A plan for a planning instance I = ((Fs,Rs,As,Es,Ps, arity), (Os, Init , G)) is a finite set of triples (t, a, d) ∈ R × As × R, where t is a timepoint, a is an action, and d is the action duration.\nNote that processes and events do not appear in a plan, as they are not under the direct control of the planner."
    }, {
      "heading" : "2.2 Answer Set Programming",
      "text" : "Let Σ be a signature containing constant, function and relation symbols. Terms and atoms are formed as in first-order logic. A literal is an atom a or its classical negation ¬a. A rule is a statement of the form:\nh← l1, . . . , lm,not lm+1, . . . ,not ln (1)\nwhere h and li’s are literals and not is the so-called default negation. The intuitive meaning of the rule is that a reasoner who believes {l1, . . . , lm} and has no reason to believe {lm+1, . . . , ln}, has to believe h. We call h the head of the rule, and {l1, . . . , lm,not lm+1, . . . ,not ln} the body of the rule. Given a rule r, we denote its head and body by head(r) and body(r), respectively. A rule with an empty body is called a fact, and indicates that the head is always true. In that case, the connective ← is often dropped. A program is a pair 〈Σ,Π〉, where Σ is a signature and Π is a set of rules over Σ. Often we denote programs by just the second element of the pair, and let the signature be defined implicitly.\nA set A of literals is consistent if no two complementary literals, a and ¬a, belong to A. A literal l is satisfied by a consistent set of literals A (denoted by A |= l) if l ∈ A. If l is not satisfied by A, we write A 6|= l. A set {l1, . . . , lk} of literals is satisfied by a set of literals A (A |= {l1, . . . , lk}) if each li is satisfied by A.\nPrograms not containing default negation are called definite. A consistent set of literals A is closed under a definite program Π if, for every rule of the form (1) such that the body of the rule is satisfied by A, the head is satisfied by A. This allows us to state the semantics of definite programs.\nDefinition 4 A consistent set of literals A is an answer set of definite program Π if A is closed under all the rules of Π and A is set-theoretically minimal among the sets closed under all the rules of Π.\nTo define answer sets of arbitrary programs, we introduce the reduct of a program Π with respect to a set of literals A, denoted by ΠA. The reduct is obtained from Π by: (1) deleting every rule r such that l ∈ A for some expression of the form not l from the body of r, and (2) removing all expressions of the form not l from the bodies of the remaining rules. The semantics of arbitrary ASP programs can thus be defined as follows.\nDefinition 5 A consistent set of literals A is an answer set of program Π if it is an answer set of ΠA.\nTo simplify the programming task, variables (identifiers with an uppercase initial) are allowed in ASP programs. A rule containing variables (a non-ground rule) is viewed as a shorthand for the set of its ground instances, obtained by replacing the variables by all possible ground terms. Similarly, a non-ground program is viewed as a shorthand for the program consisting of the ground instances of its rules.\nThere is also a set of useful constructs, introduced informally in the following. A rule whose head is empty\nis called denial, and states that its body must not be satisfied. A choice rule has a head of the form\ncl {m( ~X) : Γ( ~X)} cu\nwhere m is a relation symbol, ~X is a list of variables, Γ( ~X) is a set of literals that include variables from ~X, and cl, cu are non-negative integers. A choice rule intuitively states that, whenever the body is satisfied, the number of literals of the form m( ~X) where Γ( ~X) is satisfied must be between cl and cu. If not specified, the values of cl and cu are 0 and ∞, respectively. For example, given a relation q defined by {q(a), q(b)}, the rule:\n1{p(X) : q(X)}2.\nintuitively identifies three possible sets of conclusions: {p(a)}, {p(b)}, and {p(a), p(b)}."
    }, {
      "heading" : "2.3 Constraint Satisfaction Problems",
      "text" : "A Constraint Satisfaction Problem (CSP) (Smith 2006) is a triple 〈X,D,C〉, where X = {x1, . . . , xn} is a set of variables, D = {D1, . . . , Dn} is a set of domains such that Di is the domain of variable xi (i.e., the set of possible values that the variable can be assigned), and C is a set of constraints.1 Each constraint c ∈ C is a pair c = 〈σ, ρ〉, where σ is a vector of variables and ρ is a subset of the Cartesian product of the domains of such variables.\nAn assignment is a pair 〈xi, a〉, where a ∈ Di, whose intuitive meaning is that variable xi is assigned value a. A compound assignment is a set of assignments to distinct variables from X. A complete assignment is a compound assignment to all the variables in X. A constraint 〈σ, ρ〉 specifies the acceptable assignments for the variables from σ. We say that such assignments satisfy the constraint.\nDefinition 6 A solution to a CSP 〈X,D,C〉 is a complete assignment satisfying every constraint from C.\nConstraints can be represented either extensionally, by specifying the pair 〈σ, ρ〉, or intensionally, by specifying an expression involving variables, such as x < y. In this paper, we focus on constraints represented intensionally. A global constraint is a constraint that captures a relation between a non-fixed number of variables (Katriel and van Hoeve 2006), such as sum(x, y, z) < w and all different(x1, . . . , xk).\nOne should notice that the mapping of an intensional constraint specification into a pair 〈σ, ρ〉 depends on the constraint domain. For example, the expression 1 ≤ x < 2 corresponds to the constraint 〈〈x〉, {〈1〉}〉 if the finite domain is considered, while it corresponds to 〈〈x〉, {〈v〉 | v ∈ [1, 2)}〉 in a continuous domain. For this reason, and in line with the CLP Schema (Jaffar and Lassez 1987; Marriott et al. 2006), in this paper we assume that a CSP includes the specification of the intended constraint domain.\n1 Strictly speaking, the use of the same index i across sets X and D in the above definition of the set of domains would require X and D to be ordered. However, as the definition of CSP is insensitive to the particular ordering chosen, we follow the approach, common in the literature on constraint satisfaction, of simply considering X and D as sets and abusing notation slightly in the definition of CSP."
    }, {
      "heading" : "2.4 Constraint ASP",
      "text" : "CASP integrates ASP and CSP in order to deal with continuous dynamics. There is currently no standardized definition of CASP, and no stardard language. Multiple definitions have been given in the literature (Ostrowski and Schaub 2012; Mellarkod et al. 2008; Baselice et al. 2005; Balduccini 2009). Although largely overlapping, these definitions and syntax differ from each other in some details.\nTo ensure generality of our results, in this paper we introduce a simplified definition of CASP, which captures the common traits of the above approaches. The main results will be given using this simplified definition. Later (Section 4), we will introduce a specific CASP language and use it to describe a practical example.\nSyntax. In order to accommodate CSP constructs, the language of CASP extends ASP by allowing numerical constraints of the form x ./ y, where ./∈ {<,≤,=, 6=,≥, >}, and x and y are numerical variables2 or standard arithmetic terms possibly containing numerical variables, numerical constants, and ASP variables. Numerical constraints are only allowed in the head of rules.\nSemantics. Given a numerical constraint c, let τ(c) be a function that maps c to a syntactically legal ASP atom and τ−1 be its inverse. We say that an ASP atom a denotes a constraint c if a = τ(c). Function τ is extended in a natural way to CASP rules and programs. Note that, for every CASP program Π, τ(Π) is an ASP program.\nFinally, given a set A of ASP literals, let γ(A) be the set of ASP atoms from A that denote numerical constraints. The semantics of a CASP program can thus be given by defining the notion of CASP solution, as follows.\nDefinition 7 A pair 〈A,α〉 is a CASP solution of a CASP program Π if-and-only-if A is an answer set of τ(Π) and α is a solution to τ−1(γ(A)).\nezcsp language. In ezcsp, a program is a set of ASP rules written in such a way that their answer sets encode the desired CSPs. This is accomplished by using three types of special atoms:\n1. a constraint domain declaration, i.e., a statement of the form cspdomain(D), where D is a constraint domain such as fd, q, or r; informally, the statement says that the CSP is over the specified constraint\ndomain (finite domains, rational numbers, real numbers), thereby fixing an interpretation for the intensionally specified constraints of the CSP. A program can contain only one cspdomain declaration; 2. a constraint variable declaration, i.e., a statement of the form cspvar(x), where x is a ground term\ndenoting a variable of the CSP;\n3. a constraint statement, i.e. a statement of the form required(γ), where γ is an expression that intension-\nally represents a constraint on (some of) the variables specified by the cspvar statements; intuitively, the statement says that the constraint represented by γ is required to be satisfied by any solution to the CSP.\nFor example, suppose that we are given integer variables v(1), v(2), v(3) and we need to find values for them so that (i) each variable has a distinct value, and (ii) v(1) + v(2) + v(3) ≤ 6 unless the constraint is blocked (atom blocked), in which case the constraint has no effect. A possible ezcsp encoding is:\nd(1). d(2). d(3). cspdomain(fd). cspvar(v(X))← d(X). required(v(X) 6= v(Y ))← d(X), d(Y ), X 6= Y. required(v(1) + v(2) + v(3) ≤ 6)← not blocked.\n2 Numerical variables are distinct from ASP variables.\nwhere X and Y are ASP variables used to describe compactly the uniqueness of values of v(1), v(2), v(3).3 The grounding of the program is:\nd(1). d(2). d(3). cspdomain(fd). cspvar(v(1))← d(1). cspvar(v(2))← d(2). cspvar(v(3))← d(3). required(v(1) 6= v(2))← d(1), d(2), 1 6= 2. required(v(1) 6= v(3))← d(1), d(3), 1 6= 3. . . . required(v(1) + v(2) + v(3) ≤ 6)← not blocked.\nThe answer set of the program is {d(1), d(2), cspdomain(fd), cspvar(v(1)), cspvar(v(2)), cspvar(v(3)), required(v(1) 6= v(2)), required(v(1) 6= v(3), . . ., required(v(1) + v(2) + v(3) ≤ 6)}, which intuitively describes the numerical constraints given earlier. Note that constraint v(1) + v(2) + v(3) ≤ 6 is included in the answer set due to the fact that blocked does not hold."
    }, {
      "heading" : "3 A CASP-based Solution for Planning in Hydrid Domains",
      "text" : "In this section we first present a CASP-based architecture for solving PDDL+ problems. Then, we focus on the CASP encoding of PDDL+ problems."
    }, {
      "heading" : "3.1 Architecture",
      "text" : "Our approach is centered around the architecture outlined in Figure 5. A PDDL+ model is first translated\nto a CASP program Π. Then, the CASP solutions of Π are computed by a CASP solver. The architecture is independent of the CASP solver used, but, for presentation purposes, we focus on CASP solver ezcsp. In ezcsp, the Grounding Tool maps Π to its syntactically legal ASP counterpart, τ(Π), and grounds it, obtaining program Πg. Next, the Integration Module carries out an iterative process in which:\n3 For the interested reader, we note that such a constraint can be even more efficiently represented by a global constraint all different, which is supported by ezcsp.\n1. an ASP solver is used to find an answer set A of Πg; 2. a CSP C is obtained from A by finding all numerical constraints that are denoted by some atom of A,\ni.e., C = {τ−1(a) | a ∈ γ(A)}; 3. a CSP solver is used to find a solution, α, of C;\n4. if C has no solution, the ASP solver is used to find a new answer set of Πg and the process is iterated;\notherwise, the CASP solution 〈A,α〉 is returned.\nMore details on the ezcsp algorithm can be found in (Balduccini 2009). Details on other CASP solvers can be found in Section 7; Section 5 includes experiments that we conducted using CASP solver clingcon.\nAt this point, the Validation Module is executed. The module ensures that the CASP solution found represents a valid PDDL+ plan. As we will see later, in our encoding invariants are enforced at the beginning and at the end of every state in which durative actions and processes are in execution. In this sense, the continuous timeline is discretized. This may cause some plans found by the planner to be invalid: in fact, it is possible for an invariant to be satisfied at the boundaries of each state, and yet be violated within that interval. An example of this behavior is discussed in Section 6. To handle these situations, we follow the discretize-and-validate approach first proposed in (Della Penna et al. 2009). In that approach, a plan found in the discretized setting is validated using the plan validator VAL (Howey et al. 2004), which is capable of carrying out the calculations needed to check the satisfaction of invariants within state boundaries. The Validation Module consists of two components, the Plan Extractor and VAL. The Plan Extractor component applies syntactic transformations to translate the CASP solution to a PDDL+ plan in the input language of VAL. The plan is then passed to VAL. If VAL finds it to be valid, the plan is returned and the process terminates. Otherwise, ezcsp is invoked again. Suitable constraints are added to the ezcsp program to rule out previously-found CASP solutions and the process is iterated."
    }, {
      "heading" : "3.2 Encoding",
      "text" : "This section is dedicated to discussing our encoding of PDDL+ problems in CASP. Our approach is based on research on reasoning about actions and change, and action languages (Gelfond and Lifschitz 1993; Reiter 2001; Chintabathina et al. 2005). It builds upon the existing SAT-based (Kautz and Selman 1992) and ASP-based planning approaches and extends them to hybrid domains.\nIn reasoning about actions and change, the evolution of a domain over time is often represented by a transition diagram (or, transition system) that represents states and transitions between states through actions. Traditionally, in transition diagrams, actions are instantaneous, and states have no duration and are described by sets of Boolean fluents. Sequences of states characterizing the evolutions of the domain are represented as a sequence of discrete time steps, identified by integer numbers, so that step 0 corresponds to the initial state in the sequence. We extend this view to hybrid domains according to the following principles:\n• Similarly to PDDL+, a state is characterized by Boolean fluents and numerical fluents. • The flow of actual time is captured by the notion of global time (Chintabathina et al. 2005). States\nhave a duration, given by the global time at which a state begins and ends. Intuitively, this conveys the intuition that time flows “within” the state. • The truth value of Boolean fluents only changes upon state transitions, that is, it is unaffected by the flow of time “within” a state. On the other hand, the value of a numerical fluent may change within a\nstate.\n• The global time at which an action occurs is identified with the end time of the state in which the action occurs.\nNext, we describe the CASP formalization of PDDL+ models. We begin by discussing the correspondence\nbetween global time and states; then, we present domain, problems and planning task encodings."
    }, {
      "heading" : "3.2.1 Time, States, Fluents",
      "text" : "The global time at which the state at step i begins is represented by the numerical variable tstart(i). Similarly, the end time is represented by tend(i). A fluent literal is a fluent f or its negation ¬f . By l we denote Boolean complement over fluent literals, i.e., f = ¬f and ¬f = f . If f holds at discrete time step i, in the encoding we write holds(f, i); if ¬f holds, i.e., f is false, we write ¬holds(f, i). We also often use χ(l, i) as an abbreviation, corresponding to holds(f, i) if l = f and to ¬holds(f, i) if l = ¬f . For every numerical fluent n, we introduce two numerical variables representing its value at the beginning and at the end of time step i. The variables are v initial(n, i) and v final(n, i), respectively. The occurrence of an action a at time step i is represented by an atom occurs(a, i).\nAdditive fluents, whose value is affected by increase and decrease statements of PDDL+, are represented by introducing numerical variables of the form v(contrib(n, s), i), where n is a numerical fluent, s is a constant denoting a source (e.g., the action that causes the increase or decrease), and i is a time step. The expression denotes the amount of the contribution to fluent n from source s at step i. Intuitively, the value of n at the end of step i (encoded by numerical variable v final(n, i)) is calculated from the values of the individual contributions. Next, we discuss the encoding of the domain portion of a PDDL+ problem."
    }, {
      "heading" : "3.2.2 Domain Encoding",
      "text" : "In the following discussion, ASP variables I, I1, I2 denote time steps.\nIstantaneous Actions. As we have seen, instantaneous actions are characterized by a set of preconditions and a set of effects. A Boolean precondition is a fluent literal l, representing a condition on the truth value of l. A numerical precondition is an inequality between mathematical expressions involving combinations of numerical fluents and numerical constants. The encoding of a precondition depends on its type. Thus, every Boolean precondition l of an action a is encoded by a denial:\n← χ(l, I), occurs(a, I). (2)\nNotice that a separate denial is used for every precondition. To illustrate the encoding, consider an example in which an action refuel with(tk1), representing the refueling of some machine using refuel tank tk1, has a precondition that tank tk1 must be available, represented by avail(tk1). The precondition is thus represented by:\n← ¬holds(avail(tk1), I), occurs(refuel with(tk1), I). A numerical precondition γ is encoded by means of a numerical constraint γf obtained from γ by replacing every occurrence of a numerical fluent n by an expression v final(n, I). The latter represents the value of n at the end of time step I. Thus, for every precondition γ of an action a, the encoding includes a rule:\nγf ← occurs(a, I). (3)\nContinuing on the previous example, if action refuel with(tk1) has a precondition level(tk1) > 0, intuitively meaning that the tank must not be empty, the precondition is encoded by a rule:\nv final(level(tk1), I) > 0← occurs(refuel with(tk1), I).\nSimilarly to Boolean preconditions, Boolean effects are represented in PDDL+ by fluent literals. For every Boolean effect l of an action a, the encoding includes a rule:\nχ(l, I + 1)← occurs(a, I). (4)\nThe rule states that l is true at the next time step I + 1 if the action occurs at (the end of) step I. For the effects of actions on numerical fluents, we focus our presentation on the assignment of a value to a numerical fluent4, corresponding to PDDL+ expression (assign n e) where n is a numerical fluent and e\n4 The handling of additive fluents is discussed in the context of durative actions.\nis a mathematical expression possibly including numerical fluents. An effect of this form for an action a is represented by a rule: v initial(n, I + 1) = e′ ← occurs(a, I). (5) where e′ is obtained from e by replacing every occurrence of a numerical fluent n′ by v initial(n′, I + 1).\nDurative actions. Recall that a durative action is characterized by two sets of conditions: the start conditions, which are analogous to the preconditions of instantaneous actions, and the invariants, i.e. conditions that must be true throughout the execution of the action. Syntactically, start conditions and invariants are represented like the preconditions of instantaneous actions, i.e. with fluent literals and numerical inequalities. The effects of a durative action are divided in at-start effects, at-end effects, and continuous effects. The at-start and at-end effects take place at the beginning and at the end of the action and are treated analogously to the effects of instantaneous actions. The continuous effects only apply to numerical fluents and describe a change of value that is a function of the time elapsed since the start of the action. That is, the continuous effects of durative action d can be viewed as a partial function associating to every numerical fluent n affected by d a mathematical expression en(t) that is a function of time (and, possibly, of the value of other numerical fluents). This representation makes it possible to capture the behavior of additive fluents. Additionally, the duration of the action is specified by an inequality δ ./ e where δ represents the duration and e is an mathematical expression possibly including numerical fluents.\nIn our formalization, a durative action d is encoded by means of two instantaneous actions, start(d) and end(d). The start conditions of d are mapped to preconditions of start(d) and encoded using (2) and (3). Note that a durative action typically affects multiple consecutive states. Our encoding introduces a special Boolean fluent inprogr(d) to denote the states during which a durative action d is in progress. How this fluent is made true/false is discussed later. A Boolean invariant, l, of a durative action d is encoded by a denial:\n← χ(l, I), holds(inprogr(d), I). (6) It is worth noticing the similarity with (2). A numerical invariant γ is encoded by means of two rules:\nγi ← holds(inprogr(d), I). (7) γf ← holds(inprogr(d), I). (8)\nwhere γf is defined as for (3) and γi is obtained from γ by replacing every occurrence of a numerical fluent n by an expression v initial(n, I). Note that these rules enforce the invariants only at the beginning and at the end of every state affected by the action. The task of checking whether the conditions hold at other timepoints is discussed later.\nThe start and end effects of a durative action d can be easily viewed as the effects of the start(d) and end(d) actions and encoded using (4) and (5). To account for the special Boolean fluent inprogr(d), in our encoding the start and end effects of d are expanded to include, respectively, inprogr(d) and ¬inprogr(d). To account for the effects of concurrent actions on additive fluents, our encoding considers separately the contributions from each action by introducing a special numerical variable v(contrib(n, d), i) for every durative action d, numerical fluent n affected by d, and time step i. Recall that the continuous effect of d on n is described by a mathematical expression en(t). This is encoded in CASP by means of a rule:\nv(contrib(n, d), I) = ein ← holds(inprogr(d), I). (9)\nwhere ein is obtained from en(t) by replacing every occurrence of a numerical fluent n ′ by v initial(n′, I) and every occurrence of t by the expression tend(I)− tstart(I). For example, if a refuel action causes the level of fuel in a tank to increase linearly with time, its effect is encoded by:\nv(contrib(fuel level, refuel), I) = 1 · (tend(I)− tstart(I))← holds(inprogr(d), I).\nThe cumulative effects of durative actions are calculated by means of the following rule of the encoding: v final(N, I) = v initial(N, I) + ∑ d∈D v(contrib(N, d), I). (10)\nwhere N ranges over additive fluents and D over durative actions. Intuitively, for every numerical fluent n, the rule accumulates the effects of all durative actions on it and updates the value of n by the net result of such effects. For instance, in a domain in which fuel level is affected, possibly concurrently, by actions refuel and consume, their cumulative effects are modeled by:\nv final(fuel level, I) = v initial(fuel level, I) + ∑ d∈{consume,refuel} v(contrib(fuel level, d), I).\nNote that implementing the summation from (10) in an actual CASP language may require the introduction of additional numerical variables and rules because of syntax restrictions of the implemented languages. In the next section, we show how (10) is implemented in the case of ezcsp.\nThe encoding also includes a rule:\nv final(N, I) = v initial(N, I)← not ab(N, I). (11)\ni.e., a default stating that every additive fluent maintains its value unless explicitly changed. Intuitively, atom ab(n, i) states that fluent n is an exception to the default at time step i. Default (11) must be blocked in every state in which actions affect the fluent. This is accomplished by including in the encoding, for every action d affecting a fluent n, a rule:\nab(n, I)← holds(inprogr(d), I). (12)\nFollowing the semantics of PDDL+, action end(d) is automatically triggered after start(d). For every durative action d, the task of finding a time step at which the end action occurs is accomplished by a choice rule:\n1{occurs(end(d), I2) : I2 > I1}1← occurs(start(d), I1). (13)\nIf time step i is selected for the occurrence of end(d), the timepoint at which the action occurs is given by the value of tend(i). Notice that, unlike the selection of a time step for end(d), there is no need to state explicitly that a value must be selected for tend(d). The semantics of CASP ensures that a value is selected for every numerical variable in the constraint problem.\nFinally, the inequality δ ./ e on the duration of a durative action d is encoded by a rule:\n(tend(I2)− tend(I1)) ./ ef ← occurs(end(d), I2), occurs(start(d), I1). (14)\nwhere ef is obtained from e by replacing every occurrence of a numerical fluent n by v final(n, I1).\nIt is worth noting that the encoding extends to supporting multiple occurrences of the same durative action in a natural way. This is accomplished by adding an argument to the name of the action, i.e., instead of writing d we write d(i). The argument represents the time step at which the action starts. For example, (14) becomes:\n(tend(I2)− tend(I1)) ./ ef ← occurs(end(d(I)), I2), occurs(start(d(I)), I1).\nIntuitively, this approach yields multiple, and completely independent, “copies” of the durative action, whose effects and termination can be handled accordingly by the encoding presented. For simplicity of presentation, throughout the paper we make the assumption that durative actions occur only once and thus adopt the simpler writing d.\nProcesses and Events. The encoding of processes and events builds upon the approach outlined above, respectively, for durative and instantaneous actions. That is, an event is encoded using (2–5), while a process is encoded using (6–14). However, recall that their triggering is defined by PDDL+’s must semantics (see Section 2). In our encoding, this is captured by a choice rule combined with numerical constraints. Let l1, . . . , lk be the Boolean preconditions of an event v and γ1, . . . , γm be its numerical preconditions. The encoding includes a choice rule5:\n1{occurs(v, I), is false(γ1, I), . . . , is false(γm, I)}1← χ(l1, I), . . . , χ(lk, I). (15)\n5 Due to the syntactic restrictions of CASP solvers, in practice γ1, . . . γm are replaced by syntactically correct symbols that are in one-to-one correspondence with them.\nIntuitively, when the Boolean conditions of the event are satisfied, the choice rule states that the event will be triggered unless it is inhibited by unsatisfied numerical conditions. Given a numerical condition γi, let γi denote its complement, e.g., > is replaced by ≤ and = by 6=. This part of the encoding is completed by introducing, for every γi, a rule:\nγi f ← is false(γi, I). (16)\nwhere operator f is defined as for (3). The rule intuitively states that, if a numerical condition is hypothesized to be unsatisfied, then the corresponding numerical fluents must have values that falsify the condition. It is worth observing how the must semantics is obtained: as soon as all numerical conditions are satisfied by the current state i, then (16) ensures that is false(γi, i) must be false for each of them. If all Boolean conditions are also satisfied, then (15) is forced to make occurs(v, i) true, thus triggering the occurrence of the event. The triggering of a process p is handled in an analogous way, except that start(p) is the event triggered by (15) rather than v. Also note that, while one may be tempted to add a rule complementary to (16) such as:\nγfi ← not is false(γi, I), occurs(v, I).\nthis is made unnecessary by the presence of (3). To illustrate our approach, consider an example in which a process generate has start preconditions enabled and fuel level > 0. The corresponding encoding is:\n1{occurs(start(generate), I), is false(fuel level > 0, I)}1← holds(enabled, I). v final(fuel level, I) ≤ 0← is false(fuel level > 0, I). (17)\nThe encoding is completed by the domain-independent rules:\ntstart(I + 1) = tend(I).\nv initial(N, I + 1) = v final(N, I).\nholds(F, I + 1)← holds(F, I),not ¬holds(F, I + 1). ¬holds(F, I + 1)← ¬holds(F, I),not holds(F, I + 1).\n(18)\nThe first rule ensures that there are no gaps between the time intervals associated with consecutive states. The other rules handle propagation of fluent values from one state to the next."
    }, {
      "heading" : "3.2.3 Problem Encoding",
      "text" : "The problem portion of the PDDL+ problem is encoded as follows.\nInitial state. The encoding of the initial state consists of a set of rules specifying the values of fluents in P ∪ v at step 0, where P and v are the sets of Boolean and numerical fluents, respectively. Goals. The encoding of a goal consists of a set of denials on Boolean fluents and of constraints on numerical fluents, obtained similarly to the encoding of preconditions of actions, discussed earlier.\nGiven a PDDL+ planning instance I, by Π(I) we denote the CASP encoding of I. Next, we turn our attention to the planning task."
    }, {
      "heading" : "3.2.4 Planning Task",
      "text" : "Our approach to planning leverages techniques from ASP-based planning (Lifschitz 2002; Balduccini et al. 2006). The planning task is specified by the planning module, M , which includes a choice rule of the form:\nλ{occurs(a1, I), occurs(a2, I), . . . , occurs(ak, I)}µ.\nwhere a1 . . . ak are actions as defined by the PDDL+ specification and bounds λ, µ allow for control on concurrency of the actions. In practice, planning modules often also include heuristics for the purpose of increasing performance, also in terms of plan quality.\nIt can be shown that the plans for a given maximum time step for a PDDL+ planning instance I are in one-to-one correspondence with the CASP solutions of Π(I)∪M that pass the validation test by VAL. The plan encoded by a CASP solution A can be obtained from the atoms of the form occurs(a, i) and from the value assignments to numerical variables tstart(i) and tend(i).\nIt is also worth noting the level of modularity of our approach. In particular, it is straightforward to perform other reasoning tasks besides planning (e.g, a hybrid of planning and diagnostics is often useful for applications) by replacing the planning module by a different one, as demonstrated for example in (Balduccini and Gelfond 2003)."
    }, {
      "heading" : "4 An Example of our Encoding",
      "text" : "In this section, we provide an encoding of a PDDL+ instance (a domain and one problem instance that will be used also in the experimental analysis) into a CASP program.\nThe specific domain is described in the first subsection, then its PDDL model is given, while the third\nsubsection is devoted to the encoding into CASP.\n4.1 The generator domain\nThe generator domain is well-known across the planning community and has been a testbed for many planners. The problem revolves around refuelling a diesel powered generator which has to run for a given duration without overflowing or running dry. This problem is interesting because the time at which the refuel action must be applied within the generate action is critical: the fuel level in the tank must not exceed the capacity of the tank so the planner must realize that the refuel action must be delayed at least X time units after the start of the generate action, but must also occur at least Y time units before the end of the generate action to prevent the fuel level falling below zero, where X and Y depend on the instance."
    }, {
      "heading" : "4.2 PDDL+ model",
      "text" : "The PDDL+ domain of the generator is shown, in slightly simplified form, in Figure 6. The generate process models the generator running. Its invariant, specified by the overall condition, requires the fuel level in the generator to be no less than 0 at all times during the execution of the process. The process has two continuous effects: it decreases the fuel level (the expression (* #t 1) states that the change is continuous and linear with respect to time) and increases the value of variable generator time, which keeps track of how long the generator ran.\nDurative action refuel formalizes the use of a tank for refueling the generator. The action has an invariant stating that the fuel level in the generator must not exceed the capacity of the tank, and is required to have a duration of 10 time units. The action has the effect of continuously increasing the fuel level of the generator’s tank. Note that the rate at which the generator’s tank is refilled is twice as high as the rate at which fuel is consumed. When both actions are being executed, their effects are combined. Given that the duration of the refuel action is fixed, the total contribution of a refuel tank is 20 units of fuel.\nThe PDDL+ problem models the instance, as shown in Figure 7. In this example, we have one tank, the initial fuel level in the generator is 990, and the capacity of the generator is 1000 units. The goal for generator is to run for 1000 time units.\n4.3 The ezcsp encoding\nThe encoding assumes the existence of a relation step(·) defining the (finite) range of integers that represent the discrete steps in the evolution of the domain. Constant last step is set to the largest such integer, and determines the maximum number of steps in the plan, provided as an external parameter to the planner.\nDomain-independent component. We begin the description of the encoding from its domain-independent portion. Note that ezcsp requires the explicit declaration of all numerical variables. Thus, the first rules we show capture the declarations of the variables that encode the start and end times of states, accompanied by constraints specifying their domain, i.e. they must be non-negative and have values such that the corresponding states have non-negative duration.\ncspvar(tstart(I))← step(I). required(tstart(I) ≥ 0)← step(I). cspvar(tend(I))← step(I). required(tend(I) ≥ 0)← step(I). required(tend(I) ≥ tstart(I))← step(I).\nThe next axioms encode the first and last set of rules from (18), namely stating that every state ends at the same time in which the next state begins, and that a Boolean fluent maintains its value unless forced to change. For convenience of representation, the remaining rule from (18) is written in a domain-dependent way, and thus introduced in the next paragraph.\nrequired(tstart(I2) = tend(I1))← step(I1), step(I2), I2 = I1 + 1.\nholds(F, I2)← fluent(F ), step(I1), step(I2), I2 = I1 + 1, holds(F, I1), not ¬holds(F, I2). ¬holds(F, I2)← fluent(F ), step(I1), step(I2), I2 = I1 + 1,¬holds(F, I1), not holds(F, I2).\nDomain-dependent component. At the core of the domain encoding is the formalization of process generate, durative action refuel, and of how they affect the fuel level in the generator’s tank. Let us start with generate.\nThe generator’s fuel level is modeled by additive numerical fluent fuel level. The next set of rules declares the numerical variables representing the value of the fluent at the beginning and at the end of each state, and sets limits on their values (tankcap(·) is part of CASP encoding of the problem instance, and indicates the capacity of the tank):\ncspvar(v initial(fuel level, I))← step(I). required(v initial(fuel level, I) ≥ 0)← step(I). required(v initial(fuel level, I) ≤ TC)← step(I), tankcap(TC).\ncspvar(v final(fuel level, I))← step(I). required(v final(fuel level, I) ≥ 0)← step(I). required(v final(fuel level, I) ≤ TC)← step(I), tankcap(TC).\nThe next axiom is an instantiation, to numerical fluent fuel level, of the second rule from (18) and states that the value of fuel level at the end of a state coincides with its value at the beginning of the next.\nrequired(v initial(fuel level, I2) = v final(fuel level, I1))← step(I1), step(I2), I2 = I1 + 1.\nNext, we turn our attention modeling how the fluent changes over time, beginning with (10). As mentioned earlier, contributions to additive fluents are represented by means of numerical variables of the form v(contrib(·), ·). Because the sum operator from (10) is not supported directly by the syntax of ezcsp, the ezcsp encoding includes auxiliary rules and variables, which calculate, separately, the total positive and negative contributions from the sum of the relevant contributions. The positive and negative contributions are distinguished by an extra argument (incr or decr) in the name of variable v(contrib(·), ·).\ncspvar(v(contrib(fuel level, decr), I))← step(I). required(v(contrib(fuel level, decr), I) ≤ 0)← step(I).\ndecr(I, v(contrib(fuel level, decr,D), I))← step(I), cspvar(v(contrib(fuel level, decr,D), I)). required(sum([decr(I)/2],=, v(contrib(fuel level, decr), I)))← step(I).\ncspvar(v(contrib(fuel level, incr), I))← step(I). required(v(contrib(fuel level, incr), I) ≥ 0)← step(I).\nincr(I, v(contrib(fuel level, incr,D), I))← step(I), cspvar(v(contrib(fuel level, incr,D), I)). required(sum([incr(I)/2],=, v(contrib(fuel level, incr), I)))← step(I).\nAbove, ASP variable D ranges over all possible durative actions that may cause a contribution. Numerical variables v(contrib(fuel level, decr), I) and v(contrib(fuel level, incr), I) capture the negative and positive contributions at a given step. Relations decr(·, ·) and incr(·, ·) are used to link group the contributions at each time step. For example, a fact decr(1, v(contrib(fuel level, decr, generate), 1)) states that v(contrib(fuel level, decr, generate), 1)) is one of the (negative) contributions to the fuel level at step 1. The constraint required(sum([decr(I)/2],=, v(contrib(fuel level, decr), I))) sums all of the negative contributions for time step I and assigns the total to numerical variable v(contrib(fuel level, decr), I). The summation of the positive contributions works in a similar way. The ezcsp counterpart of (10) is a rule stating that the value of fuel level is the sum of the total positive and negative contributions:\nrequired(v final(fuel level, I) = v initial(fuel level, I) + v(contrib(fuel level, incr), I) − v(contrib(fuel level, decr), I))← step(I).\nNext, we focus on the generate process. The next rule defines Boolean fluent inprogr(generate), which\nindicates whether the process is in progress:\nfluent(inprogr(generate)).\nNext, we define a numerical variable formalizing generate’s contribution to the fuel level of the generator’s tank:\ncspvar(v(contrib(fuel level, decr, generate), I))← step(I). required(v(contrib(fuel level, decr, generate), I) ≥ 0)← step(I).\nThe contribution provided by generate while the process is in progress is calculated as per (9):\nrequired(v(contrib(fuel level, decr, generate), I) = 1 ∗ (tend(I)− tstart(I)))← step(I),\nholds(inprogr(generate), I).\nThe next set of rules follows (11) and (12), expressing the fact that, by default, the contribution by generate is 0. This is elegantly represented by means of default negation:\nab(contrib(fuel level, decr, generate), I)← step(I), holds(inprogr(generate), I).\nrequired(v(contrib(fuel level, decr, generate), I) = 0)← step(I),\nnot ab(contrib(fuel level, decr, generate), I).\nNext, we model the two (instantaneous) actions that trigger the start and the end of the process. The actions are defined by:\naction(start(generate)). action(end(generate)).\nThe following rule is the counterpart of (13) and ensures that action end(generate) is triggered at some time step following start(generate):\n1{occurs(end(generate), I2) : step(I2) : I2 > I1 : I2 < last step}1← step(I), occurs(start(generate), I1).\nThe next set of rules formalizes the effect of starting and stopping the process.\nholds(inprogr(generate), I2)← step(I1), step(I2), I2 = I1 + 1, occurs(start(generate), I1).\n¬holds(inprogr(generate), I2)← step(I1), step(I2), I2 = I1 + 1, occurs(end(generate), I1).\nThe preconditions and the triggering of action start(generate), which follows the must semantics, are encoded according to (3), (15), and (16):\nrequired(v final(fuel level, I) ≥ 0)← step(I), occurs(start(generate), I).\n1{occurs(start(generate), I), is false(fuel level ≥ 0, I) }1← step(I), I < last step, ¬holds(inprogr(generate), I). required(v final(fuel level, I) < 0)← step(I), is false(fuel level ≥ 0, I).\nDurative action refuel (instantiated for each refuel tank) is modeled along the same lines. First of all, fluents and numerical variables are defined to represent whether the action is in progress and the action’s contribution to the generator’s fuel level (variable TK ranges over the refuel tanks from the problem).\nfluent(inprogr(refuel(TK)))← refuel tank(TK).\ncspvar(v(contrib(fuel level, incr, refuel(TK)), I))← step(I), refuel tank(TK). required(v(contrib(fuel level, incr, refuel(TK)), I) ≥ 0)← step(I), refuel tank(TK).\nThe contribution to fuel level while refuel is in progress is defined similarly to that of generate:\nrequired(v(contrib(fuel level, incr, refuel(TK)), I) = 2 ∗ (tend(I)− tstart(I)))← step(I), refuel tank(TK),\nholds(inprogr(refuel(TK)), I).\nab(contrib(fuel level, incr, refuel(TK)), I)← step(I), refuel tank(TK), holds(inprogr(refuel(TK)), I).\nrequired(v(contrib(fuel level, incr, refuel(TK)), I) = 0)← step(I), refuel tank(TK),\nnot ab(contrib(fuel level, incr, refuel(TK)), I).\nNext, the instantaneous actions that correspond to the start and to the end of the durative action are introduced, and their effects defined:\naction(start(refuel(TK)))← refuel tank(TK). action(end(refuel(TK)))← refuel tank(TK).\n1{occurs(end(refuel(TK)), I2) : step(I2) : I2 > I1 : I2 < last step}1← step(I), refuel tank(TK),\noccurs(start(refuel(TK)), I1).\nholds(inprogr(refuel(TK)), I2)← step(I1), step(I2), I2 = I1 + 1, refuel tank(TK), occurs(start(refuel(TK)), I1).\n¬holds(inprogr(refuel(TK)), I2)← step(I1), step(I2), I2 = I1 + 1, refuel tank(TK), occurs(end(refuel(TK)), I1).\nFinally, the requirement on the duration of refuel from the PDDL+ specification is captured according to (14), i.e. a rule stating that, whenever refuel ends, the time elapsed between its start and its end must equal the duration specified (variable RT represents the duration of the refuel action; for convenience of representation, the duration is parametrized by relation duration(·, ·) rather than being expressed directly by a constant):\nrequired(tend(I2)− tend(I1)) = RT )← step(I1), step(I2), refuel tank(TK), duration(refuel(TK), RT ),\noccurs(end(refuel(TK)), I2), occurs(start(refuel(TK)), I1).\nPlanning module. Action selection is achieved by a choice rule stating that refuel actions are allowed\nto occur at any time:\n0{occurs(start(refuel(TK)), I) : step(I)}1← refuel tank(TK).\nIn order to improve performance, the planning module includes a heuristic saying that at least an action must be executed at every time step:\nsome action(I)← occurs(A, I). ← step(I), I < last step, not some action(I).\nProblem encoding. Relation step(·) is thus defined by:\nstep(0..last step).\nThe capacity of the generator’s tank is given by:\ntankcap(1000).\nThe set of available fuel tanks and the duration of the refuel action are specified by:\nrefuel tank(tank1). duration(refuel(TK), 10)← refuel tank(TK).\nThe initial state is specified in the following, with a set of rules that specifies the initial fuel level, states that no process or durative action is initially in progress, and sets the clock to 0:\nrequired(v initial(fuel level, 0) = 990). ¬holds(inprogr(generate), 0). ¬holds(inprogr(refuel(TK)), 0)← refuel tank(TK). required(tstart(0) = 0).\nFinally, the PDDL+ goal (= generator time 1000) is formalized by:\nduration(generate, 1000).\nrequired(tend(I2)− tend(I1) = D)← step(I1), step(I2), duration(generate,D), occurs(end(generate), I2), occurs(start(generate), I1).\nezcsp solution. A CASP solution produced by ezcsp for the above encoding of domain and problem is shown next. For clarity, we focus on the restriction of the solution to relation occurs and to numerical variable tend(·): occurs(start(generate), 0)\noccurs(start(refuel(tank1)), 0) tend(0) = 0.000\noccurs(end(refuel(tank1)), 1) tend(1) = 10.000\noccurs(end(generate), 2) tend(2) = 1000.000\nThis solution corresponds to the PDDL+ plan in which generate begins immediately (time 0.000) and lasts for 1000.000 time units, and refuel begins immediately and lasts for 10.0 time units:\n0.000 : generate [1000.000] 0.000 : refuel(tank1) [10.000]"
    }, {
      "heading" : "5 Experiments on PDDL+ planning domains",
      "text" : "We performed an empirical evaluation of the run-time performance of our approach. The comparison was with the state-of-the-art PDDL+ planners dReal (Bryce et al. 2015) and UPMurphi. Although SpaceEx (Bogomolov et al. 2014) is indeed a related approach, it was not included in the comparison because it is focused on proving only plan non-existence.\nThe experimental setup used a virtual machine running in VMWare Workstation 12 on a computer with an i7-4790K CPU at 4.00GHz. The virtual machine was assigned a single core and 4GB RAM. The operating system was Fedora 22 64 bit. The version of ezcsp used was 1.7.46, with gringo 3.0.57 and clasp 3.1.38 as grounding tool and ASP solver, and B-Prolog 7.59 and GAMS 24.5.710 as constraint solvers. The former\n6 http://mbal.tk/ezcsp/ 7 http://sourceforge.net/projects/potassco/files/gringo/ 8 https://sourceforge.net/projects/potassco/files/clasp/ 9 http://www.picat-lang.org/bprolog/\n10 http://www.gams.com/\nwas used for all linear problems and the latter for the non-linear ones. It should be noted that GAMS acts as a front-end to a large set of constraint solvers. The underlying constraint solver to be used by GAMS is selected at run-time. We performed a thorough evaluation of the underlying solvers on the domains they support.\nIn an attempt to evaluate the role of the encoding and of the solver in the resulting performance, we also created variants of our encodings, discussed later, suitable for clingcon, and studied their performance. For this part of the experiments, we used clingcon 2.0.311. Note that clingcon supports only integer variables\n11 https://sourceforge.net/projects/potassco/files/clingcon/\nand linear constraints, and was thus applied only to the linear variants of the domains considered. The other systems used were dReal 2.15.11.12, configured as suggested by its authors, and UPMurphi 3.0.213.\nThe experiments were conducted on the linear and non-linear versions of the generator and car domains. The CASP encodings were created manually as described earlier. Because of the different ways in which dReal and UPMurphi operate, the comparison with dReal was based on finding a single plan with a given maximum time step (called here fixed-time step experiments), as discussed in (Bryce et al. 2015). The results are summarized in Tables 1-3. On the other hand, the comparison with UPMurphi was based on the cumulative times for finding a single plan by progressively increasing the maximum time step (referred to as cumulative-time experiments). The results are reported in Tables 4-6.\nIn the tables, entries marked “-” indicate a timeout (threshold 600 sec). Entries marked “*” indicate missing entries due to licensing limitations (see below). Remarkably, we found that, in all instances, VAL determined that the CASP solutions returned represented valid PDDL+ plans. More information on the topic of validation, as well as an example in which validation fails, can be found in Section 6. Next, we discuss the experimental results obtained for each domain.\nCar. The version of the car domain we used is the same that was adopted in (Bryce et al. 2015). In this domain, a vehicle needs to travel a certain goal distance from its start position. The vehicle is initially at rest. Two actions allow the vehicle to accelerate and to decelerate. The goal is achieved when the vehicle reaches the desired distance and its speed is 0. In the linear variant, accelerating increases the velocity by 1 and decelerating decreases it by 1. In the non-linear variant, accelerating increases the acceleration by 1, and similarly for decelerating. The velocity is influenced by the acceleration according to the usual laws of physics. The calculation also takes into account a drag factor equal to 0.1 · v2. The instances were obtained by progressively increasing the range of allowed accelerations (velocities in the linear version) from [−1, 1] to [−8, 8].\nezcsp was run on the encoding described earlier. The clingcon encoding was obtained by a straightforward syntactic transformation. As illustrated by Tables 1 and 4, both CASP encodings solved all instances in approximately constant time – even in the non-linear case – demonstrating excellent scalability. The experimental evaluation yielded a number of other interesting results, discussed next. We begin from the outcomes of the fixed-time step experiments (Table 1), and later address the cumulative-time experiments.\nezcsp vs clingcon. clingcon outperformed ezcsp in all experiments on the linear variant of car, although the small magnitude of both sets of run-times (negligible time for clingcon and about 0.30 sec for ezcsp) prevents general claims.\nGAMS solvers. Given the GAMS limitations in terms of sizes of the formulas that can be analyzed with the free license, only two GAMS solvers can be employed in this domain. Of those, knitro, which implements state-of-the-art interior-point and active-set methods for dealing with non-linear problems, is the best performer.\nezcsp vs dReal. ezcsp substantially outperformed dReal: ezcsp solved all non-linear instances in less than one second, while dReal only solved the two smallest instances, with times that peaked at 3 orders of magnitude larger than the ezcsp times.\nCumulative times (Table 4). As one might expect, given previous results, clingcon outperformed ezcsp on the cumulative-time experiments as well. The absolute times were still rather small – negligible for clingcon and between 0.83 sec and 1.04 sec for ezcsp. Once again, GAMS’s knitro solver had the best performance among the GAMS solvers. Finally, the comparison with UPMurphi shows some interesting results. In the\n12 http://dreal.github.io/ 13 https://github.com/gdellapenna/UPMurphi/\nlinear case, ezcsp is, in fact, about 2-3 times slower than UPMurphi, although the absolute times are small in both cases. On the other hand, ezcsp outperformed UPMurphi by a much larger margin in the non-linear case, with all instances solved in times between 1.78 sec and 3.96 sec, while UPMurphi only solved the first instance, and with a time of 184.88 sec, i.e., nearly 2 orders of magnitude slower than ezcsp. Reasons for the performance of UPMurphi seem to be (i) the unoptimized implementation of the discretize-and-validate approach, and (ii) the fact that it performs blind search.\nGenerator. Our encoding models the transfer of liquid according to Torricelli’s law: v = √ 2gh.\nIt should be noted that this is different from the approach used in (Bryce et al. 2015), where a simpler, but less physically accurate model was used. For a fair comparison with (Bryce et al. 2015), the simpler model was used in reproducing the results for dReal. The instances were generated by increasing the number of refuel tanks from 1 to 8.\nThe complexity of this domain makes it amenable to studying various optimizations of the CASP encodings, mostly aimed at improving performance of the encoding with respect to the treatment of the must semantics.14\nIn the following, the CASP encoding presented throughout this paper is referred to as “Basic.” The encoding referred to as “Heuristic” leverages the observation, based on straightforward considerations on this domain, that the generate process must start at timepoint 0. Thus, “Heuristic” extends “Basic” by a single heuristic stating that action start(generate) must occur immediately. The expectation is that “Heuristic” will outperform “Basic” in most cases. We are also interested in contrasting the effects of this domain-specific, encoding-level heuristic with those of the sophisticated, algorithm-level, and yet domain-independent, heuristics used in dReal.\nThe encoding labeled “Estimator” takes the observation about the generate process one step further, replacing the domain-specific heuristic with rules that, in some conditions, can be used to estimate the value of numerical fluents without calling the constraint solver. This is expected to enable earlier pruning of candidate plans directly within the ASP solver, and result in performance potentially comparable with that of “Heuristic.” The encoding is based on the following idea. As we have seen, the conditions that trigger a process can be divided in Boolean and numerical. In the CASP encoding, the former are directly listed in the body of choice rule (15), while the latter are captured by numerical constraints, such as (16). Because these constraints are checked by the constraint solver, from an algorithmic perspective, a candidate plan that violates (16) is detected only after it has been fully computed by the ASP solver and passed to the constraint solver. This may obviously lead to unnecessary computations. A more economical approach seems to be that of checking as many numerical conditions as possible during the ASP computation. To accomplish that, we maintain extra Boolean fluents that capture the value of numerical fluents, i.e., has val(f, v) states that numerical fluent f has value v. Keeping track of all changes to numerical fluents is obviously unfeasible on the ASP side, but it is indeed possible to keep track of direct assignments of values to them. For example, for every rule of the form\nv initial(f, I) = v ← Γ. where I is as above and v is an integer constant15, we introduce a rule:\nholds(has val(f, v), I)← Γ.\nThe value of such fluents is propagated by a rule:\nholds(has val(F, V ), I + 1)← holds(has val(F, V ), I),not ab(F, I + 1).\n14 It is not difficult to see, from our presentation of the CASP encoding, that the must semantics may significantly affect performance. 15 The approach can be extended to non-integer constants.\nThe last element in the body of the rule enables blocking the propagation when needed. Specifically, for every rule h(I) ← Γ of the original encoding whose head is a numerical constraint over the value of f (at step I) that is not in the form of the assignment considered above, we add to the encoding a rule:\nab(f, I)← Γ.\nIt is worth noting that, compared to dReal and to “Heuristic,” the “Estimator” encoding is both encodinglevel and domain-independent. Furthermore, while dReal’s heuristics are specific to the PDDL+ planning task, this approach is task-independent.\nWe also studied the performance of clingcon. To do so, we created translations of all of the three encodings, “Basic,” “Heuristic,” and “Estimator.” These translations are labeled “clingcon” in the tables. Note that, due to clingcon’s limitations, the “clingcon/Opt” translations are applicable only to linear instances. Another clingcon variant that we considered, labeled “clingcon/Opt,” is specifically aimed at leveraging additional features of clingcon. Differently from ezcsp, the language of clingcon allows for numerical constraints in both the head and body of rules. We attempted to take advantage of this and achieve a more compact encoding of the must semantics. We replaced rules (15) and (16) by a single rule, in which numerical constraints occur in the body and can directly trigger the process, as long as the Boolean conditions are satisfied. For example, (17) becomes:\noccurs(generate, I)← holds(enabled, I), v final(fuel level, I) > 0. (19)\nIn order to understand our interest in “clingcon/Opt”, note that (19) is a regular rule, rather than a choice rule. With (15) and (16), the ASP solver will tend to generate multiple CSPs in an uninformed way, so that each can be checked by the constraint solver. With the adoption of (19), it is conceivable that the triggering of the process may be achieved earlier in the computation and improve performance, thanks to the tighter integration of the ASP and constraint solver in clingcon, whose algorithm is capable of interleaving the processes of solving the qualitative part of the problem and the numerical one.\nNext, we discuss the experimental results. As for the car domain, we begin by addressing the outcomes of\nthe fixed-time step experiments (Tables 2 and 3), and later analyze the cumulative-time experiments.\nezcsp vs clingcon. ezcsp outperformed clingcon in all experiments on the linear variant of generator, except for a single outlier (instance 8 of the “Basic” encoding). This is a remarkable result, given that in all previous analyses that the authors are aware of, the tighter coupling between ASP solver and constraint solver featured by clingcon led to better performance, see, e.g., (Balduccini and Lierler 2013). The result is surprising in particular because the seemingly strong interdependency between the qualitative and numerical components of generator would have been expected to advantage tight coupled solvers.\n“clingcon” vs “clingcon/Opt.” Another surprising result comes from the comparison of the “clingcon”\nand “clingcon/Opt” translations. Recall that the latter is designed specifically to take advantage of clingcon’s language features and solving algorithm. Yet, “clingcon/Opt” did not yield the performance improvements one might have expected. In the case of “Heuristic”, “clingcon/Opt” and “clingcon” had similar performance; for the “Basic” encoding, “clingcon/Opt” was able to find a solution for an instance (instance 3) in which “clingcon” timed out, but at the same time the former failed to yield a solution for instance 8, which the latter was able to solve; finally, in the case of the “Estimator” encoding, “clingcon/Opt” timed out on every instance, yielding substantially worse performance than “clingcon.”\nGAMS solvers. GAMS’s conopt solver, which implements a fast method for finding a first feasible solution, and thus can be efficient also on constraint problems without an objective function like ours, exhibited better scalability than all other GAMS solvers.\nAdvanced encodings. Focusing on ezcsp, and on the GAMS conopt solver for the non-linear cases, there was no absolute winner among the “Basic”, “Heuristic” and “Estimator” encodings. As one might expect,\n“Heuristic” yielded the best performance in many cases. On the other hand, “Estimator” was able to tie or beat “Heuristic” in a number of situations – most notably, non-linear instance 6. In the linear instances, “Basic” had worse performance than “Estimator” in most cases, but scaled better, solving instance 7 while the latter encoding timed out, suggesting a possible negative impact on scalability due to a somewhat larger encoding for “Estimator”. It is also worth noting that “Estimator” surprisingly exhibited worse scalability in the linear case, where 6 instances were solved, than in the non-linear case, where 7 instances were solved, with the 8th giving a GAMS’s license error rather than a timeout.\nezcsp vs dReal. Overall, ezcsp substantially outperformed dReal. Particularly interesting is the comparison between “Estimator” and dReal, since the former uses declarative, task-independent heuristics, while the latter employs algorithm-level, task-dependent ones. The execution times for ezcsp for this case (Tables 2 and 3) ranged between 0.27 sec and 303.75 sec for the linear variant, with 6 instances solved, and between 0.72 sec and 256.59 sec for the non-linear one (with GAMS’s conopt solver), with 7 instances solved. On the other hand, dReal was only able to solve the first instance in both cases (3.73 sec for the linear one and 8.18 sec for the non-linear one).\nCumulative times (Tables 5 and 6). If we contrast the results based on solvers used, clingcon beat ezcsp in absolute performance on the largest instance (110.70 sec vs 279.81 sec in instance 8), but lost when overall scalability is considered: the ezcsp versions of “Basic” and “Estimator” solve all instances while the clingcon translations solve 3 instances at best. “clingcon/Opt” yielded mixed performance results: while the “clingcon” and “clingcon/Opt” translations solved the same number of instances overall, the latter often had worse performance – up to one order of magnitude for instance 2 when using the “Estimator” encoding, but typically 20%-30% worse. On the other hand, the “clingcon/Opt” translation of the “Estimator” encoding was able to solve instance 8. Interestingly, both clingcon translations of the “Heuristic” encoding timed out, while the clingcon translations of the “Basic” encoding found solutions. This is surprising given that “Heuristic”, when compared to “Basic”, introduces heuristic knowledge that simplifies the problem.\nLooking at the non-linear variant of the domain, we see that, once again, GAMS’s conopt solver was the one with best performance among the GAMS solvers. Focusing on ezcsp (and GAMS’s conopt), “Basic” was slightly better than “Heuristic” and “Estimator” in some cases (e.g., linear instance 8), but overall lost to both – especially in the non-linear instances, where “Basic” solves 3 and 2 fewer instances respectively. Remarkably, “Estimator” featured marginally better performance than “Heuristic” on most easy instances (instances 1-3), but did not scale equally well. Finally, UPMurphi had substantially worse performance than ezcsp in all cases: it solved only 3 linear instances (vs 8 for ezcsp) and no non-linear instances (vs 7 for ezcsp16). The speedup yielded by ezcsp reached about one order of magnitude before UPMurphi began to time out.\nSummary. Considering the entire set of experiments, we can draw a number of important conclusions. First of all, the experiments demonstrate that our CASP-based solution substantially outperforms both dReal and UPMurphi, showing better scalability. ezcsp is also more scalable than clingcon on challenging problems from the generator domain. This is a remarkable result, which goes against previous comparisons (see, e.g., (Balduccini and Lierler 2013)) of the performance of tightly coupled hybrid solving algorithms vs their loosely coupled counterparts. Note that such comparisons were conducted on sets of benchmarks different from the ones considered here. This indicates that PDDL+ planning problems may be a new and useful class of valuable benchmarks for the CASP community.\nLooking specifically at encoding variants and the corresponding techniques, the “Heuristic” variant of the encoding was overall the best, while ”Estimator” worked well in a number of cases, but did not equal\n16 It should be noted that the experiments on cumulative times do not result in GAMS licensing errors, because the corresponding instances time out before reaching the point where the error would be generated.\nits performance. These results corroborate the considerations that led to creation of these variants. Also, “clingcon/Opt” failed to yield consistent performance improvements in spite of its leveraging the more advanced features of the clingcon language and solver, which are not available in ezcsp.\nOverall, we believe the empirical results demonstrate the promise of our approach."
    }, {
      "heading" : "6 Extended Architecture",
      "text" : "As we mentioned, validation through VAL always succeeds in the previous experiments. In this section, we discuss how the architecture from Section 3 can be extended to handle more efficiently cases in which the validation does not succeed. Specifically, we present a variant of the architecture from Figure 5 aimed at making better use of the information provided by VAL in case of a failed validation.\nThe extended architecture is shown in Figure 8. While the figure refers to ezcsp, the approach is not\ndifficult to extend to clingcon and other CASP solvers.\nOur approach leverages the fact that, when VAL finds a plan not to be valid, it returns information about which invariants were violated and in which timepoint intervals. Consider a variant of instance 1 of the non-linear generator from Section 5, modified so that the capacity and initial level of the generator’s tank are 100 units. A possible plan for this instance is:\n0.000 : generate [100.000] 12.500 : refuel(tank1) [12.500]\nWhen validating this plan, VAL detects that the invariant\n(< (fuelLevel ?g) (capacity ?g))\nis violated during the execution of refuel(tank1) – specifically, starting at 6.25 time units into the execution of the action, corresponding to timepoint range [18.75, 25]. See Figure 9 for an illustration. Such feedback is leveraged by the Expander Tool from Figure 8. The intuition behind the process is to select suitable timepoints in the offending interval, and introduce in the encoding (i) new numerical variables that capture the value of\nthe relevant numerical fluents at those timepoints, and (ii) corresponding numerical constraints that enforce the invariants on those variables. The idea is made precise by Algorithm 1 and Algorithm 2. Function expand (Algorithm 1) takes in input the CASP encoding and a set of pairs 〈inv, range〉, where inv is a violated invariant and range is the timepoint range in which it is violated. For each such pair, the algorithm selects a set of timepoints within the range (step 4) via user-supplied function Select Timepoints and stores them in ∆. These are the timepoints on which the invariant will be enforced by means of additional constraints. In simple cases, Select Timepoints may select the timepoints so that they are uniformly distributed within the range, but more complex options are possible. Next (step 5), the algorithm identifies the time step, s, at which the violation of the invariant occurred. For simplicity of presentation, we assume that a single time step corresponds to each range. (If the range extends over multiple time steps, one can always pre-process the output of VAL, splitting each violation into violations whose range corresponds to a single step.) The loop that begins at step 6 iterates over every timepoint δ from ∆ and (step 7) considers each numerical fluent, n, that occurs in the invariant. For each of them, Expand Fluent (Algorithm 2) is called. The function, which will be described in more detail next, expands the encoding with constraints that calculate the value of n at timepoint δ. Next, steps 10-13 insert in the encoding a final constraint that instantiates the offending invariant for timepoint δ. At the core of the process is the instantiation of the constraint from the head of the rule of the form (8) for inv, which occurs at step 12. In the first part of the process, every occurrence of ASP variable I is replaced by the time step, s, identified earlier, at which the invariant was violated. Next, for every numerical fluent n, the occurrences of v final(n, s) are replaced by v finalδ(n, s). This ensures that the constraint considers the values of the fluents at timepoint δ, as calculated by the constraints added by Expand Fluent, as opposed to the end of the time step.\nFunction Expand Fluent is given in input the program Π, a numerical fluent n, a timepoint δ and time step s. First of all, the function expands the encoding by creating a rule of the form (10) in which v final(·, ·) and v(contrib(·), ·) are replaced by new variables v finalδ(·, ·) and vδ(contrib(·), ·). These variables capture the value of n at timepoint δ and the contributions to such value. Next, (steps 3-7) variants of the rules of the form (9) are introduced. The new rules calculate the contributions to the value of n at timepoint δ for each durative action and process, d. Note that, in rule (9), such calculation depends on the duration of the action. However, in calculating the contribution of d from its start and up to timepoint δ, the time components of the calculation must be scaled accordingly. This is accomplished by Offset (Algorithm 2), which normalizes, w.r.t. [0, 1], the position of δ within the interval of execution of d, and by step 6 of Expand Fluent, which\nAlgorithm 1 Expansion step\n1: function Expand(Π, V )\ninput: Π: CASP encoding; V : set of pairs 〈inv, range〉 2: Π′ := ∅ 3: for 〈inv, range〉 ∈ V do 4: ∆ := Select Timepoints(range) 5: s := time step at which inv is violated 6: for δ ∈ ∆ do 7: for n ∈ inv do 8: Π′ := Π′ ∪Expand Fluent(Π, n, s, δ) 9: end for\n10: d := durative action or process for which inv is specified 11: γf := constraint from the head of the rule of form (8) for inv\n12: γf (s, δ) := replace in γf :\n{ 1. I by s\n2. v final(n, s) by v finalδ(n, s) for every numerical fluent n\n13: Π′ := Π′ ∪ {γf (s, δ)← holds(inprogr(d), s).} 14: end for 15: end for 16: return Π′ 17: end function\nscales the time component accordingly. Recall that ein from (9) represents the value of the contribution to n from a particular source. Thus, at the core of step 6 is the construction of a new expression, e′, which represents the contribution up to timepoint δ. Such expression is obtained by instantiating I to the time step at which the invariant was violated and by scaling down, by a factor δd, the duration of the interval under consideration.\nAlgorithm 2 Expansion of a numerical fluent\n1: function Expand Fluent(Π, n, s, δ)\ninput: Π: CASP encoding; n: numerical fluent; s: time step; δ: timepoint 2: Π′ := {v finalδ(n, s) = v initial(n, s) + ∑ d∈D vδ(contrib(n, d), s).} 3: for durative action or process d do 4: for every rule of Π of the form v(contrib(n, d), I) = ein ← holds(inprogr(d), I) do 5: δd := Offset(δ, d)\n6: e′ := replace in ein:\n{ 1. I by s\n2. tend(s)− tstart(s) by δd · (tend(s)− tstart(s)) 7: Π′ := Π′ ∪ {vδ(contrib(n, d), I) = e′ ← holds(inprogr(d), s).} 8: end for 9: end for\n10: return Π′ 11: end function\n12: function Offset(δ, d)\ninput: δ: timepoint; d: durative action or process 13: 〈s, e〉 := start, end timepoints of d in the plan 14: if δ > e then return 1 15: if δ < s then return 0 16: return δ−se−s 17: end function\nNext, we illustrate the algorithms with an example, which we carry out using the language of ezcsp. Continuing with the output of VAL described earlier, Expand begins by selecting timepoints at which the invariant should be further checked. For sake of illustration, let us select 3 uniformly distributed timepoints, 18.75, 21.875, and 25. The expansion of the encoding for the negative contribution and timepoint 18.75 is (below, ι(t) is the formula that calculates fuel transferred for a duration of time t; the actual calculation is omitted for space considerations):\nrequired(v18.75(contrib(fuel level, incr, refuel(TK)), 2) = ι( 18.75−12.5 25−12.5 ∗ (tend(2)− tstart(2))))← holds(inprog(refuel(TK)), 2).\nrequired(v final18.75(fuel level, 2) = v initial(fuel level, 2)\n+v18.75(contrib(fuel level, incr), 2) −v18.75(contrib(fuel level, decr), 2))← step(I).\nrequired(v final18.75(fuel level, 2) ≤ TC)← tankcap(TC), holds(inprog(refuel(TK)), 2).\nThe expansion for the positive contributions to the fuel level and for timepoints 21.875 and 25 is similar. Once the encoding has been expanded, ezcsp is executed again. The added constraints ensure that any solution that is returned does not violate the invariants at those timepoints. The process is iterated as needed until the validation succeeds. In our example, for the expanded encoding described above, the planner returns the plan:\n0.000 : generate [100.000] 14.063 : refuel(tank1) [12.500]\nThis plan is successfully validated by VAL, and the search terminates.\nThe approach has been implemented in prototypical form. When applied to the problem above, the prototype correctly detects that the original plan is not validated by VAL. Then, using VAL’s output, the expanded encoding is generated as above, and ezcsp is used to find a new solution. Using the “Heuristic” encoding, ezcsp, and GAMS’s conopt solver, the computation of the first plan takes 0.37 sec and that of the second plan takes 0.40 sec, for a total of 0.77 sec. The time taken for the validation by VAL is negligible. For “Basic” and “Estimator,” the total times are 1.08 sec and 0.84 sec, respectively."
    }, {
      "heading" : "7 Related Work",
      "text" : "In this section, we analyze related approaches and solvers. We start with PDDL+, then we move to CASP. Last, we relate our approach to research on planning in hybrid domains based on action languages.\nPDDL+ algorithms and solvers. Various techniques and tools have been proposed to deal with hybrid domains (Penberthy and Weld 1994; McDermott 2003; Li and Williams 2008; Coles et al. 2012; Shin and Davis 2005). Nevertheless, none of these approaches are able to handle the full set of PDDL+ features, namely, non-linear domains with processes and events.\nMore recent works include (Bryce et al. 2015), which presents an approach based on SMT for handling\nhybrid domains. However, dReach does not use PDDL+, and cannot handle exogenous events.\nFrom the model checking and control communities, a number of works based on timed and hybrid automata have been proposed to handle hybrid systems. Some examples include (Cimatti et al. 2015; Cavada et al. 2014; Tabuada et al. 2002; Maly et al. 2013; Bae et al. 2016; Liu and Ozay 2014; Henzinger and Otop 2014), sampling-based planners (Karaman et al. 2011; Lahijanian et al. 2014). Similarly, falsification of hybrid systems tries to guide the search towards the error states, that can be easily cast as a planning problem, (Plaku et al. 2013; Cimatti et al. 1997). However, while all these works aim to address hybrid systems, they cannot be used to handle PDDL+ models. Some recent works (Bogomolov et al. 2014; Bogomolov et al. 2015) are trying to define a formal translation between PDDL+ and standard hybrid automata, but so far only an over-approximation has been defined, that allows the use of those tools only for proving plan non-existence.\nUPMurphi (Della Penna et al. 2009; Della Penna et al. 2012) is the only tool able to handle the full set of\nPDDL+ features, although it is very limited in scalability as it performs blind search.\nPDDL+ has been used to model a number of planning applications (Vallati et al. 2016; Della Penna et al. 2010; Fox et al. 2011) but then specific domain dependent heuristics or tools have been used to find plans (Piacentini et al. ; Fox et al. 2012).\nThe approach proposed in this paper is similar to the encoding used in TM-LPSAT (Shin and Davis 2005). However, TM-LPSAT assumes linear continuous change, given it uses a linear solver to manage the continuous constraints, while we are solving problems with non-linear dynamics. TM-LPSAT exploits the linearity by checking conditions only at the end-points of intervals of continuous change. Moreover, as reported by Shin and Davies, the experiments showed that TM-LPSAT was not performant and finally the code is not available, hence TM-LPSAT remains a largely theoretical (though valuable) contribution.\nFinally, some very recent works on PDDL+ planning have been proposed (Cashmore et al. 2016; Piotrowski\net al. 2016), but a proper comparison with them will be addressed in future work.17\nCASP algorithms and solvers. For what concerns CASP solvers, although other CASP solvers exist, ezcsp is, to the best of our knowledge, the only one supporting both real numbers and non-linear constraints, required for modeling non-linear continuous change.\nACsolver (Mellarkod et al. 2008) implements an eager approach to CASP solving, where (in contrast to the lazy approach of ezcsp) ASP and CSP solving are tightly coupled and interleaved. It does not support non-linear or global constraints, but allows for real numbers.\nclingon (Ostrowski and Schaub 2012) is another tightly coupled CASP solver. The available implementation, however, is not broadly applicable to the kinds of problems considered in this paper. In fact, clingon does not support non-linear constraints and real numbers. On the other hand, unlike ezcsp, it allows for numerical constraints both in the head of rules and in their bodies, and is characterized by a tighter coupling of ASP and CSP solvers.\nA high level view of the languages and solving techniques employed by these solvers can be found in (Lierler 2014). There, by relying on the framework of abstract solvers, i.e., a graph-based representation of solving algorithms, similarities and differences among these solvers are formally stated by means of comparison of the related graphs.\nHybrid domains and action languages. Action language H was introduced in (Chintabathina et al. 2005) as an extension to previous well-known action languages for modeling hybrid domains. Then, in (Chintabathina 2013), H has been used specifically to model planning and scheduling tasks in hybrid domains, and reasoning is done via CASP language and solver ezcsp as in our paper. However, that approach suffers from some shortcomings, which our work overcomes, e.g., it (i) does not take into account PDDL+ as target language, despite it being the standard language for planning in hybrid domains, (ii) does not consider additive fluents, non-linear numerical constraints, and the triggering of processes and events via the must semantics, and (iii) does not include an experimental evaluation of the approach. Another action language ADP (Baral et al. 2002) was introduced earlier to allow for the specification of, e.g., actions with duration and continuous effects.\nOther lines of research that have dealt with extensions involving primitives for dealing with continuous change, processes, and (macro-)events include the Event Calculus in, e.g., (Evans 1990; Shanahan 1990; Miller and Shanahan 1996; Cervesato and Montanari 2000).\n17 At the time of submission, these papers were not published yet, and the corresponding planners not released."
    }, {
      "heading" : "8 Conclusions",
      "text" : "PDDL+ and CASP languages extend PDDL and ASP to reason with mixed discrete-continuous dynamics. PDDL+ is the standard language for the automated planning community, with a number of interesting domains being represented as PDDL+ models. In this paper, we have presented a new approach for solving PDDL+ problems by means of an encoding into CASP problems, and extension to the ezcsp solving architecture for planning in hybrid domains. Our solution can deal with both linear and non-linear variants of the domains. An experimental analysis, performed on well-known PDDL+ domains, involving some variants of our approach, other CASP solvers and PDDL+ planners on two reasoning tasks, showed the viability of our approach."
    } ],
    "references" : [ {
      "title" : "SMT-based analysis of virtually synchronous distributed hybrid systems",
      "author" : [ "K. Bae", "P.C. Ölveczky", "S. Kong", "S. Gao", "E.M. Clarke" ],
      "venue" : "Proceedings of the 19th International Conference on Hybrid Systems: Computation and Control (HSCC 2016), A. Abate and G. E. Fainekos, Eds. ACM, 145–154.",
      "citeRegEx" : "Bae et al\\.,? 2016",
      "shortCiteRegEx" : "Bae et al\\.",
      "year" : 2016
    }, {
      "title" : "Representing constraint satisfaction problems in answer set programming",
      "author" : [ "M. Balduccini" ],
      "venue" : "ICLP09 Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2009).",
      "citeRegEx" : "Balduccini,? 2009",
      "shortCiteRegEx" : "Balduccini",
      "year" : 2009
    }, {
      "title" : "Logic programs with consistency-restoring rules",
      "author" : [ "M. Balduccini", "M. Gelfond" ],
      "venue" : "Proccedings of the International Symposium on Logical Formalization of Commonsense Reasoning, P. Doherty, J. McCarthy, and M.-A. Williams, Eds. AAAI 2003 Spring Symposium Series. 9–18.",
      "citeRegEx" : "Balduccini and Gelfond,? 2003",
      "shortCiteRegEx" : "Balduccini and Gelfond",
      "year" : 2003
    }, {
      "title" : "Answer set based design of knowledge systems",
      "author" : [ "M. Balduccini", "M. Gelfond", "M. Nogueira" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 47, 1–2, 183–219.",
      "citeRegEx" : "Balduccini et al\\.,? 2006",
      "shortCiteRegEx" : "Balduccini et al\\.",
      "year" : 2006
    }, {
      "title" : "Integration schemas for constraint answer set programming: A case study",
      "author" : [ "M. Balduccini", "Y. Lierler" ],
      "venue" : "Theory and Practice of Logic Programming 13, 4-5-Online-Supplement.",
      "citeRegEx" : "Balduccini and Lierler,? 2013",
      "shortCiteRegEx" : "Balduccini and Lierler",
      "year" : 2013
    }, {
      "title" : "Knowledge Representation, Reasoning, and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "Baral,? 2003",
      "shortCiteRegEx" : "Baral",
      "year" : 2003
    }, {
      "title" : "A transition function based characterization of actions with delayed and continuous effects",
      "author" : [ "C. Baral", "T.C. Son", "L. Tuan" ],
      "venue" : "Proceedings of the Eights International Conference on Principles and Knowledge Representation and Reasoning (KR 2002), D. Fensel, F. Giunchiglia, D. L. McGuinness, and M. Williams, Eds. Morgan Kaufmann, 291–302.",
      "citeRegEx" : "Baral et al\\.,? 2002",
      "shortCiteRegEx" : "Baral et al\\.",
      "year" : 2002
    }, {
      "title" : "Towards an integration of answer set and constraint solving",
      "author" : [ "S. Baselice", "P.A. Bonatti", "M. Gelfond" ],
      "venue" : "Proceedings of the 21st International Conference on Logic Programming (ICLP 2005), M. Gabbrielli and G. Gupta, Eds. Lecture Notes in Computer Science, vol. 3668. 52–66.",
      "citeRegEx" : "Baselice et al\\.,? 2005",
      "shortCiteRegEx" : "Baselice et al\\.",
      "year" : 2005
    }, {
      "title" : "PDDL+ planning with hybrid automata: Foundations of translating must behavior",
      "author" : [ "S. Bogomolov", "D. Magazzeni", "S. Minopoli", "M. Wehrle" ],
      "venue" : "Proceedings of the 25th International Conference on Automated Planning and Scheduling (ICAPS 2015), R. I. Brafman, C. Domshlak, P. Haslum, and S. Zilberstein, Eds. AAAI Press, 42–46.",
      "citeRegEx" : "Bogomolov et al\\.,? 2015",
      "shortCiteRegEx" : "Bogomolov et al\\.",
      "year" : 2015
    }, {
      "title" : "Planning as model checking in hybrid domains",
      "author" : [ "S. Bogomolov", "D. Magazzeni", "A. Podelski", "M. Wehrle" ],
      "venue" : "Proceedings of the 28th AAAI Conference on Artificial Intelligence (AAAI 2014), C. E. Brodley and P. Stone, Eds. AAAI Press, 2228–2234.",
      "citeRegEx" : "Bogomolov et al\\.,? 2014",
      "shortCiteRegEx" : "Bogomolov et al\\.",
      "year" : 2014
    }, {
      "title" : "SMT-based nonlinear PDDL+ planning",
      "author" : [ "D. Bryce", "S. Gao", "D.J. Musliner", "R.P. Goldman" ],
      "venue" : "Proceedings of the 29h AAAI Conference on Artificial Intelligence (ICAPS 2015), B. Bonet and S. Koenig, Eds. AAAI Press, 3247–3253.",
      "citeRegEx" : "Bryce et al\\.,? 2015",
      "shortCiteRegEx" : "Bryce et al\\.",
      "year" : 2015
    }, {
      "title" : "A compilation of the full PDDL+ language into SMT",
      "author" : [ "M. Cashmore", "M. Fox", "D. Long", "D. Magazzeni" ],
      "venue" : "Proceedings of the 26th International Conference on Automated Planning and Scheduling (ICAPS 2016), A. J. Coles, A. Coles, S. Edelkamp, D. Magazzeni, and S. Sanner, Eds. AAAI Press, 79–87.",
      "citeRegEx" : "Cashmore et al\\.,? 2016",
      "shortCiteRegEx" : "Cashmore et al\\.",
      "year" : 2016
    }, {
      "title" : "The nuXmv symbolic model checker",
      "author" : [ "R. Cavada", "A. Cimatti", "M. Dorigatti", "A. Griggio", "A. Mariotti", "A. Micheli", "S. Mover", "M. Roveri", "S. Tonetta" ],
      "venue" : "Proceedings of the 26th International Conference on Computer Aided Verification (CAV 2104), A. Biere and R. Bloem, Eds. Lecture Notes in Computer Science, vol. 8559. Springer, 334–342.",
      "citeRegEx" : "Cavada et al\\.,? 2014",
      "shortCiteRegEx" : "Cavada et al\\.",
      "year" : 2014
    }, {
      "title" : "A calculus of macro-events: Progress report",
      "author" : [ "I. Cervesato", "A. Montanari" ],
      "venue" : "7th International Workshop on Temporal Representation and Reasoning (TIME 2000). IEEE Computer Society, 47–58.",
      "citeRegEx" : "Cervesato and Montanari,? 2000",
      "shortCiteRegEx" : "Cervesato and Montanari",
      "year" : 2000
    }, {
      "title" : "Planning and scheduling in hybrid domains using answer set programming",
      "author" : [ "S. Chintabathina" ],
      "venue" : "Available at http://arxiv.org/pdf/1301.1389v1.",
      "citeRegEx" : "Chintabathina,? 2013",
      "shortCiteRegEx" : "Chintabathina",
      "year" : 2013
    }, {
      "title" : "Modeling hybrid domains using process description language",
      "author" : [ "S. Chintabathina", "M. Gelfond", "R. Watson" ],
      "venue" : "Proceedings of ASP ’05: Answer Set Programming: Advances in Theory and Implementation. 303– 317.",
      "citeRegEx" : "Chintabathina et al\\.,? 2005",
      "shortCiteRegEx" : "Chintabathina et al\\.",
      "year" : 2005
    }, {
      "title" : "Planning via model checking: A decision procedure for AR",
      "author" : [ "A. Cimatti", "E. Giunchiglia", "F. Giunchiglia", "P. Traverso" ],
      "venue" : "Recent Advances in AI planning. Springer, 130–142.",
      "citeRegEx" : "Cimatti et al\\.,? 1997",
      "shortCiteRegEx" : "Cimatti et al\\.",
      "year" : 1997
    }, {
      "title" : "HyComp: An SMT-based model checker for hybrid systems",
      "author" : [ "A. Cimatti", "A. Griggio", "S. Mover", "S. Tonetta" ],
      "venue" : "Proceedings of Tools and Algorithms for the Construction and Analysis of Systems, ETAPS. 52–67.",
      "citeRegEx" : "Cimatti et al\\.,? 2015",
      "shortCiteRegEx" : "Cimatti et al\\.",
      "year" : 2015
    }, {
      "title" : "COLIN: Planning with continuous linear numeric change",
      "author" : [ "A.J. Coles", "A. Coles", "M. Fox", "D. Long" ],
      "venue" : "Journal of Artificial Intelligence Research 44, 1–96.",
      "citeRegEx" : "Coles et al\\.,? 2012",
      "shortCiteRegEx" : "Coles et al\\.",
      "year" : 2012
    }, {
      "title" : "A PDDL+ benchmark problem: The batch chemical plant",
      "author" : [ "G. Della Penna", "B. Intrigila", "D. Magazzeni", "F. Mercorio" ],
      "venue" : "Proceedings of the 20th International Conference on Automated Planning and Scheduling, (ICAPS 2010), R. I. Brafman, H. Geffner, J. Hoffmann, and H. A. Kautz, Eds. AAAI, 222–225.",
      "citeRegEx" : "Penna et al\\.,? 2010",
      "shortCiteRegEx" : "Penna et al\\.",
      "year" : 2010
    }, {
      "title" : "A universal planning system for hybrid domains",
      "author" : [ "G. Della Penna", "D. Magazzeni", "F. Mercorio" ],
      "venue" : "Applied Intelligence 36, 4, 932–959.",
      "citeRegEx" : "Penna et al\\.,? 2012",
      "shortCiteRegEx" : "Penna et al\\.",
      "year" : 2012
    }, {
      "title" : "UPMurphi: A tool for universal planning on PDDL+ problems",
      "author" : [ "G. Della Penna", "D. Magazzeni", "F. Mercorio", "B. Intrigila" ],
      "venue" : "Proceedings of the 19th International Conference on Automated Planning and Scheduling (ICAPS 2009), A. Gerevini, A. E. Howe, A. Cesta, and I. Refanidis, Eds. AAAI.",
      "citeRegEx" : "Penna et al\\.,? 2009",
      "shortCiteRegEx" : "Penna et al\\.",
      "year" : 2009
    }, {
      "title" : "The macro event calculus: Representing temporal granularity",
      "author" : [ "C. Evans" ],
      "venue" : "Proceedings of the Pacific Rim International Conference on Artificial Intelligence (PRICAI 1990). IOS Press.",
      "citeRegEx" : "Evans,? 1990",
      "shortCiteRegEx" : "Evans",
      "year" : 1990
    }, {
      "title" : "Modelling mixed discrete-continuous domains for planning",
      "author" : [ "M. Fox", "D. Long" ],
      "venue" : "Journal of Artificial Intelligence Research 27, 235–297.",
      "citeRegEx" : "Fox and Long,? 2006",
      "shortCiteRegEx" : "Fox and Long",
      "year" : 2006
    }, {
      "title" : "Automatic construction of efficient multiple battery usage policies",
      "author" : [ "M. Fox", "D. Long", "D. Magazzeni" ],
      "venue" : "Proceedings of the 21st International Conference on Automated Planning and Scheduling (ICAPS 2011), F. Bacchus, C. Domshlak, S. Edelkamp, and M. Helmert, Eds. AAAI.",
      "citeRegEx" : "Fox et al\\.,? 2011",
      "shortCiteRegEx" : "Fox et al\\.",
      "year" : 2011
    }, {
      "title" : "Plan-based policies for efficient multiple battery load management",
      "author" : [ "M. Fox", "D. Long", "D. Magazzeni" ],
      "venue" : "Journal of Artificial Intelligence Research 44, 335–382.",
      "citeRegEx" : "Fox et al\\.,? 2012",
      "shortCiteRegEx" : "Fox et al\\.",
      "year" : 2012
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proceedings of the 5th International Conference and and Symposium on Logic Programming (ICLP/SLP 1988), R. A. Kowalski and K. A. Bowen, Eds. 1070–1080.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1988",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9, 365–385.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1991",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1991
    }, {
      "title" : "Representing action and change by logic programs",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Journal of Logic Programming 17, 2–4, 301–321.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1993",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1993
    }, {
      "title" : "The theory of hybrid automata",
      "author" : [ "T.A. Henzinger" ],
      "venue" : "Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science (LICS 1996). 278–292.",
      "citeRegEx" : "Henzinger,? 1996",
      "shortCiteRegEx" : "Henzinger",
      "year" : 1996
    }, {
      "title" : "Model measuring for hybrid systems",
      "author" : [ "T.A. Henzinger", "J. Otop" ],
      "venue" : "Proceedings of the 17th International Conference on Hybrid Systems: Computation and Control (part of CPS Week) (HSCC 2014), M. Fränzle and J. Lygeros, Eds. ACM, 213–222.",
      "citeRegEx" : "Henzinger and Otop,? 2014",
      "shortCiteRegEx" : "Henzinger and Otop",
      "year" : 2014
    }, {
      "title" : "Val: Automatic plan validation, continuous effects and mixed initiative planning using PDDL",
      "author" : [ "R. Howey", "D. Long", "M. Fox" ],
      "venue" : "16th IEEE International Conference on Tools with Artificial Intelligence (ICTAI 2004). IEEE Computer Society, 294–301.",
      "citeRegEx" : "Howey et al\\.,? 2004",
      "shortCiteRegEx" : "Howey et al\\.",
      "year" : 2004
    }, {
      "title" : "Constraint logic programming",
      "author" : [ "J. Jaffar", "Lassez", "J.-L." ],
      "venue" : "Proceedings of the 14th ACM Symposium on Principles of Programming Languages (POPL 1987). ACM Press, 111–119.",
      "citeRegEx" : "Jaffar et al\\.,? 1987",
      "shortCiteRegEx" : "Jaffar et al\\.",
      "year" : 1987
    }, {
      "title" : "Anytime motion planning using the RRT",
      "author" : [ "S. Karaman", "M.R. Walter", "A. Perez", "E. Frazzoli", "S.J. Teller" ],
      "venue" : "IEEE International Conference on Robotics and Automation (ICRA 2011). IEEE, 1478–1483.",
      "citeRegEx" : "Karaman et al\\.,? 2011",
      "shortCiteRegEx" : "Karaman et al\\.",
      "year" : 2011
    }, {
      "title" : "Handbook of Constraint Programming",
      "author" : [ "I. Katriel", "van Hoeve", "W.-J." ],
      "venue" : "Foundations of Artificial Intelligence. Elsevier, Chapter 6. Global Constraints, 169–208.",
      "citeRegEx" : "Katriel et al\\.,? 2006",
      "shortCiteRegEx" : "Katriel et al\\.",
      "year" : 2006
    }, {
      "title" : "Planning as satisfiability",
      "author" : [ "H.A. Kautz", "B. Selman" ],
      "venue" : "Proceedings of the 10th European Conference on Artificial Intelligence (ECAI 1992), B. Neumann, Ed. 359–363.",
      "citeRegEx" : "Kautz and Selman,? 1992",
      "shortCiteRegEx" : "Kautz and Selman",
      "year" : 1992
    }, {
      "title" : "A sampling-based strategy planner for nondeterministic hybrid systems",
      "author" : [ "M. Lahijanian", "L.E. Kavraki", "M.Y. Vardi" ],
      "venue" : "2014 IEEE International Conference on Robotics and Automation (ICRA 2014). IEEE, 3005– 3012.",
      "citeRegEx" : "Lahijanian et al\\.,? 2014",
      "shortCiteRegEx" : "Lahijanian et al\\.",
      "year" : 2014
    }, {
      "title" : "Generative planning for hybrid systems based on flow tubes",
      "author" : [ "H.X. Li", "B.C. Williams" ],
      "venue" : "Proceedings",
      "citeRegEx" : "Li and Williams,? 2008",
      "shortCiteRegEx" : "Li and Williams",
      "year" : 2008
    }, {
      "title" : "Relating constraint answer set programming languages and algorithms",
      "author" : [ "Y. Lierler" ],
      "venue" : "Artificial Intelligence 207, 1–22.",
      "citeRegEx" : "Lierler,? 2014",
      "shortCiteRegEx" : "Lierler",
      "year" : 2014
    }, {
      "title" : "Answer set programming and plan generation",
      "author" : [ "V. Lifschitz" ],
      "venue" : "Artificial Intelligence 138, 39–54.",
      "citeRegEx" : "Lifschitz,? 2002",
      "shortCiteRegEx" : "Lifschitz",
      "year" : 2002
    }, {
      "title" : "Abstraction, discretization, and robustness in temporal logic control of dynamical systems",
      "author" : [ "J. Liu", "N. Ozay" ],
      "venue" : "Proceedings of the 17th International Conference on Hybrid Systems: Computation and Control (part of CPS Week) (HSCC 2014), M. Fränzle and J. Lygeros, Eds. ACM, 293–302.",
      "citeRegEx" : "Liu and Ozay,? 2014",
      "shortCiteRegEx" : "Liu and Ozay",
      "year" : 2014
    }, {
      "title" : "Iterative temporal motion planning for hybrid systems in partially unknown environments",
      "author" : [ "M.R. Maly", "M. Lahijanian", "L.E. Kavraki", "H. Kress-Gazit", "M.Y. Vardi" ],
      "venue" : "Proceedings of the 16th international conference on Hybrid systems: computation and control (HSCC 2013), C. Belta and F. Ivancic, Eds. ACM, 353–362.",
      "citeRegEx" : "Maly et al\\.,? 2013",
      "shortCiteRegEx" : "Maly et al\\.",
      "year" : 2013
    }, {
      "title" : "The Logic Programming Paradigm: a 25-Year Perspective",
      "author" : [ "V.W. Marek", "M. Truszczynski" ],
      "venue" : "Springer Verlag, Berlin, Chapter Stable Models and an Alternative Logic Programming Paradigm, 375–398.",
      "citeRegEx" : "Marek and Truszczynski,? 1999",
      "shortCiteRegEx" : "Marek and Truszczynski",
      "year" : 1999
    }, {
      "title" : "Handbook of Constraint Programming",
      "author" : [ "K. Marriott", "P.J. Stuckey", "M. Wallace" ],
      "venue" : "Foundations of Artificial Intelligence. Elsevier, Chapter 12. Constraint Logic Programming, 409–452.",
      "citeRegEx" : "Marriott et al\\.,? 2006",
      "shortCiteRegEx" : "Marriott et al\\.",
      "year" : 2006
    }, {
      "title" : "Reasoning about autonomous processes in an estimated-regression planner",
      "author" : [ "D.V. McDermott" ],
      "venue" : "Proceedings of the 13th International Conference on Automated Planning and Scheduling (ICAPS 2003), E. Giunchiglia, N. Muscettola, and D. S. Nau, Eds. AAAI, 143–152.",
      "citeRegEx" : "McDermott,? 2003",
      "shortCiteRegEx" : "McDermott",
      "year" : 2003
    }, {
      "title" : "Integrating answer set programming and constraint logic programming",
      "author" : [ "V.S. Mellarkod", "M. Gelfond", "Y. Zhang" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 53, 1-4, 251–287.",
      "citeRegEx" : "Mellarkod et al\\.,? 2008",
      "shortCiteRegEx" : "Mellarkod et al\\.",
      "year" : 2008
    }, {
      "title" : "Reasoning about discontinuities in the event calculus",
      "author" : [ "R. Miller", "M. Shanahan" ],
      "venue" : "Proceedings of the 5th International Conference on Principles of Knowledge Representation and Reasoning (KR 1996), L. C. Aiello, J. Doyle, and S. C. Shapiro, Eds. Morgan Kaufmann, 63–74.",
      "citeRegEx" : "Miller and Shanahan,? 1996",
      "shortCiteRegEx" : "Miller and Shanahan",
      "year" : 1996
    }, {
      "title" : "Automated Planning: Theory & Practice",
      "author" : [ "D. Nau", "M. Ghallab", "P. Traverso" ],
      "venue" : "Morgan Kaufmann Publishers Inc.",
      "citeRegEx" : "Nau et al\\.,? 2004",
      "shortCiteRegEx" : "Nau et al\\.",
      "year" : 2004
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. Niemelä" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 3–4, 241–27.",
      "citeRegEx" : "Niemelä,? 1999",
      "shortCiteRegEx" : "Niemelä",
      "year" : 1999
    }, {
      "title" : "ASP modulo CSP: The clingcon system",
      "author" : [ "M. Ostrowski", "T. Schaub" ],
      "venue" : "Theory and Practice of Logic Programming 12, 4–5, 485–503.",
      "citeRegEx" : "Ostrowski and Schaub,? 2012",
      "shortCiteRegEx" : "Ostrowski and Schaub",
      "year" : 2012
    }, {
      "title" : "Temporal planning with continuous change",
      "author" : [ "J.S. Penberthy", "D.S. Weld" ],
      "venue" : "Proceedings of the 12th National Conference on Artificial Intelligence (AAAI 1994), B. Hayes-Roth and R. E. Korf, Eds. AAAI Press / The MIT Press, 1010–1015.",
      "citeRegEx" : "Penberthy and Weld,? 1994",
      "shortCiteRegEx" : "Penberthy and Weld",
      "year" : 1994
    }, {
      "title" : "Solving realistic unit commitment problems using temporal planning: Challenges and solutions",
      "author" : [ "C. Piacentini", "D. Magazzeni", "D. Long", "M. Fox", "C. Dent" ],
      "venue" : "In Proceedings of the 26th International Conference on Automated Planning and Scheduling (ICAPS 2016),",
      "citeRegEx" : "Piacentini et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Piacentini et al\\.",
      "year" : 2016
    }, {
      "title" : "Heuristic planning for PDDL+ domains",
      "author" : [ "W. Piotrowski", "M. Fox", "D. Long", "D. Magazzeni", "F. Mercorio" ],
      "venue" : "Proceedings of the 25th International Joint Conference on Artificial Intelligence (IJCAI 2016), S. Kambhampati, Ed. IJCAI/AAAI Press, 3213–3219.",
      "citeRegEx" : "Piotrowski et al\\.,? 2016",
      "shortCiteRegEx" : "Piotrowski et al\\.",
      "year" : 2016
    }, {
      "title" : "Falsification of LTL safety properties in hybrid systems",
      "author" : [ "E. Plaku", "L.E. Kavraki", "M.Y. Vardi" ],
      "venue" : "Software and Tools for Technology Transfer 15, 4, 305–320.",
      "citeRegEx" : "Plaku et al\\.,? 2013",
      "shortCiteRegEx" : "Plaku et al\\.",
      "year" : 2013
    }, {
      "title" : "Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems",
      "author" : [ "R. Reiter" ],
      "venue" : "MIT Press.",
      "citeRegEx" : "Reiter,? 2001",
      "shortCiteRegEx" : "Reiter",
      "year" : 2001
    }, {
      "title" : "Representing continuous change in the event calculus",
      "author" : [ "M. Shanahan" ],
      "venue" : "Proceedings of the 9th European Conference on Artificial Intelligence (ECAI 1990). 598–603.",
      "citeRegEx" : "Shanahan,? 1990",
      "shortCiteRegEx" : "Shanahan",
      "year" : 1990
    }, {
      "title" : "Processes and continuous change in a SAT-based planner",
      "author" : [ "Shin", "J.-A.", "E. Davis" ],
      "venue" : "Artificial Intelligence 166, 1-2, 194–253.",
      "citeRegEx" : "Shin et al\\.,? 2005",
      "shortCiteRegEx" : "Shin et al\\.",
      "year" : 2005
    }, {
      "title" : "Handbook of Constraint Programming",
      "author" : [ "B.M. Smith" ],
      "venue" : "Foundations of Artificial Intelligence. Elsevier, Chapter",
      "citeRegEx" : "Smith,? 2006",
      "shortCiteRegEx" : "Smith",
      "year" : 2006
    }, {
      "title" : "Composing abstractions of hybrid systems",
      "author" : [ "P. Tabuada", "G.J. Pappas", "P.U. Lima" ],
      "venue" : "Proceedings of 5th International Conference on Hybrid Systems: Computation and Control, (HSCC 2002), C. Tomlin and M. R. Greenstreet, Eds. Lecture Notes in Computer Science, vol. 2289. Springer, 436–450.",
      "citeRegEx" : "Tabuada et al\\.,? 2002",
      "shortCiteRegEx" : "Tabuada et al\\.",
      "year" : 2002
    }, {
      "title" : "Efficient macroscopic urban traffic models for reducing congestion: A PDDL+ planning approach",
      "author" : [ "M. Vallati", "D. Magazzeni", "B.D. Schutter", "L. Chrpa", "T.L. McCluskey" ],
      "venue" : "Proceedings of the 30th AAAI",
      "citeRegEx" : "Vallati et al\\.,? 2016",
      "shortCiteRegEx" : "Vallati et al\\.",
      "year" : 2016
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "Constraint Answer Set Programming (CASP) (Baselice et al. 2005) is an extension of ASP (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991; Niemelä 1999; Baral 2003; Marek and Truszczynski 1999) that makes it possible to add numerical constraints to the rules of ASP programs, thus allowing to represent and reason on infinite state systems.",
      "startOffset" : 41,
      "endOffset" : 63
    }, {
      "referenceID" : 26,
      "context" : "2005) is an extension of ASP (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991; Niemelä 1999; Baral 2003; Marek and Truszczynski 1999) that makes it possible to add numerical constraints to the rules of ASP programs, thus allowing to represent and reason on infinite state systems.",
      "startOffset" : 29,
      "endOffset" : 140
    }, {
      "referenceID" : 27,
      "context" : "2005) is an extension of ASP (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991; Niemelä 1999; Baral 2003; Marek and Truszczynski 1999) that makes it possible to add numerical constraints to the rules of ASP programs, thus allowing to represent and reason on infinite state systems.",
      "startOffset" : 29,
      "endOffset" : 140
    }, {
      "referenceID" : 48,
      "context" : "2005) is an extension of ASP (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991; Niemelä 1999; Baral 2003; Marek and Truszczynski 1999) that makes it possible to add numerical constraints to the rules of ASP programs, thus allowing to represent and reason on infinite state systems.",
      "startOffset" : 29,
      "endOffset" : 140
    }, {
      "referenceID" : 5,
      "context" : "2005) is an extension of ASP (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991; Niemelä 1999; Baral 2003; Marek and Truszczynski 1999) that makes it possible to add numerical constraints to the rules of ASP programs, thus allowing to represent and reason on infinite state systems.",
      "startOffset" : 29,
      "endOffset" : 140
    }, {
      "referenceID" : 42,
      "context" : "2005) is an extension of ASP (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991; Niemelä 1999; Baral 2003; Marek and Truszczynski 1999) that makes it possible to add numerical constraints to the rules of ASP programs, thus allowing to represent and reason on infinite state systems.",
      "startOffset" : 29,
      "endOffset" : 140
    }, {
      "referenceID" : 23,
      "context" : "The improved language of the planning community is called PDDL+ (Fox and Long 2006).",
      "startOffset" : 64,
      "endOffset" : 83
    }, {
      "referenceID" : 45,
      "context" : "Current CASP algorithms and solvers are either based on an eager approach to CASP solving (Mellarkod et al. 2008; Ostrowski and Schaub 2012), where the numerical constraints are processed within the ASP search, or are based on a lazy approach (Balduccini 2009), where first an ASP solution is found, and then the numerical constraints involved in the ASP solution are checked for consistency by a Constraint Satisfaction Problem (CSP) solver.",
      "startOffset" : 90,
      "endOffset" : 140
    }, {
      "referenceID" : 49,
      "context" : "Current CASP algorithms and solvers are either based on an eager approach to CASP solving (Mellarkod et al. 2008; Ostrowski and Schaub 2012), where the numerical constraints are processed within the ASP search, or are based on a lazy approach (Balduccini 2009), where first an ASP solution is found, and then the numerical constraints involved in the ASP solution are checked for consistency by a Constraint Satisfaction Problem (CSP) solver.",
      "startOffset" : 90,
      "endOffset" : 140
    }, {
      "referenceID" : 1,
      "context" : "2008; Ostrowski and Schaub 2012), where the numerical constraints are processed within the ASP search, or are based on a lazy approach (Balduccini 2009), where first an ASP solution is found, and then the numerical constraints involved in the ASP solution are checked for consistency by a Constraint Satisfaction Problem (CSP) solver.",
      "startOffset" : 135,
      "endOffset" : 152
    }, {
      "referenceID" : 31,
      "context" : "In order to select only those CASP solutions that correspond to valid plans, the basic CASP solving algorithm is extended with a further check that uses the plan validator VAL (Howey et al. 2004) to verify the validity of the solution found.",
      "startOffset" : 176,
      "endOffset" : 195
    }, {
      "referenceID" : 29,
      "context" : "Hybrid systems can be described as hybrid automata (Henzinger 1996), which are finite state automata extended with continuous variables that evolve over time.",
      "startOffset" : 51,
      "endOffset" : 67
    }, {
      "referenceID" : 47,
      "context" : "Planning is an AI technology that aims at selecting and organizing activities in order to achieve specific goals (Nau et al. 2004).",
      "startOffset" : 113,
      "endOffset" : 130
    }, {
      "referenceID" : 9,
      "context" : "Following (Bogomolov et al. 2014), given a planning instance I, a state of I consists of a discrete component, described as a set of propositions P (the Boolean fluents), and a numerical component, described as a set of real variables v (the numerical fluents).",
      "startOffset" : 10,
      "endOffset" : 33
    }, {
      "referenceID" : 23,
      "context" : "The full syntax and semantics of PDDL+ can be found in the seminal paper (Fox and Long 2006).",
      "startOffset" : 73,
      "endOffset" : 92
    }, {
      "referenceID" : 57,
      "context" : "3 Constraint Satisfaction Problems A Constraint Satisfaction Problem (CSP) (Smith 2006) is a triple 〈X,D,C〉, where X = {x1, .",
      "startOffset" : 75,
      "endOffset" : 87
    }, {
      "referenceID" : 43,
      "context" : "For this reason, and in line with the CLP Schema (Jaffar and Lassez 1987; Marriott et al. 2006), in this paper we assume that a CSP includes the specification of the intended constraint domain.",
      "startOffset" : 49,
      "endOffset" : 95
    }, {
      "referenceID" : 49,
      "context" : "Multiple definitions have been given in the literature (Ostrowski and Schaub 2012; Mellarkod et al. 2008; Baselice et al. 2005; Balduccini 2009).",
      "startOffset" : 55,
      "endOffset" : 144
    }, {
      "referenceID" : 45,
      "context" : "Multiple definitions have been given in the literature (Ostrowski and Schaub 2012; Mellarkod et al. 2008; Baselice et al. 2005; Balduccini 2009).",
      "startOffset" : 55,
      "endOffset" : 144
    }, {
      "referenceID" : 7,
      "context" : "Multiple definitions have been given in the literature (Ostrowski and Schaub 2012; Mellarkod et al. 2008; Baselice et al. 2005; Balduccini 2009).",
      "startOffset" : 55,
      "endOffset" : 144
    }, {
      "referenceID" : 1,
      "context" : "Multiple definitions have been given in the literature (Ostrowski and Schaub 2012; Mellarkod et al. 2008; Baselice et al. 2005; Balduccini 2009).",
      "startOffset" : 55,
      "endOffset" : 144
    }, {
      "referenceID" : 1,
      "context" : "More details on the ezcsp algorithm can be found in (Balduccini 2009).",
      "startOffset" : 52,
      "endOffset" : 69
    }, {
      "referenceID" : 31,
      "context" : "In that approach, a plan found in the discretized setting is validated using the plan validator VAL (Howey et al. 2004), which is capable of carrying out the calculations needed to check the satisfaction of invariants within state boundaries.",
      "startOffset" : 100,
      "endOffset" : 119
    }, {
      "referenceID" : 28,
      "context" : "Our approach is based on research on reasoning about actions and change, and action languages (Gelfond and Lifschitz 1993; Reiter 2001; Chintabathina et al. 2005).",
      "startOffset" : 94,
      "endOffset" : 162
    }, {
      "referenceID" : 54,
      "context" : "Our approach is based on research on reasoning about actions and change, and action languages (Gelfond and Lifschitz 1993; Reiter 2001; Chintabathina et al. 2005).",
      "startOffset" : 94,
      "endOffset" : 162
    }, {
      "referenceID" : 15,
      "context" : "Our approach is based on research on reasoning about actions and change, and action languages (Gelfond and Lifschitz 1993; Reiter 2001; Chintabathina et al. 2005).",
      "startOffset" : 94,
      "endOffset" : 162
    }, {
      "referenceID" : 35,
      "context" : "It builds upon the existing SAT-based (Kautz and Selman 1992) and ASP-based planning approaches and extends them to hybrid domains.",
      "startOffset" : 38,
      "endOffset" : 61
    }, {
      "referenceID" : 15,
      "context" : "• The flow of actual time is captured by the notion of global time (Chintabathina et al. 2005).",
      "startOffset" : 67,
      "endOffset" : 94
    }, {
      "referenceID" : 39,
      "context" : "Our approach to planning leverages techniques from ASP-based planning (Lifschitz 2002; Balduccini et al. 2006).",
      "startOffset" : 70,
      "endOffset" : 110
    }, {
      "referenceID" : 3,
      "context" : "Our approach to planning leverages techniques from ASP-based planning (Lifschitz 2002; Balduccini et al. 2006).",
      "startOffset" : 70,
      "endOffset" : 110
    }, {
      "referenceID" : 2,
      "context" : "g, a hybrid of planning and diagnostics is often useful for applications) by replacing the planning module by a different one, as demonstrated for example in (Balduccini and Gelfond 2003).",
      "startOffset" : 158,
      "endOffset" : 187
    }, {
      "referenceID" : 10,
      "context" : "The comparison was with the state-of-the-art PDDL+ planners dReal (Bryce et al. 2015) and UPMurphi.",
      "startOffset" : 66,
      "endOffset" : 85
    }, {
      "referenceID" : 9,
      "context" : "Although SpaceEx (Bogomolov et al. 2014) is indeed a related approach, it was not included in the comparison because it is focused on proving only plan non-existence.",
      "startOffset" : 17,
      "endOffset" : 40
    }, {
      "referenceID" : 10,
      "context" : "Because of the different ways in which dReal and UPMurphi operate, the comparison with dReal was based on finding a single plan with a given maximum time step (called here fixed-time step experiments), as discussed in (Bryce et al. 2015).",
      "startOffset" : 218,
      "endOffset" : 237
    }, {
      "referenceID" : 10,
      "context" : "The version of the car domain we used is the same that was adopted in (Bryce et al. 2015).",
      "startOffset" : 70,
      "endOffset" : 89
    }, {
      "referenceID" : 10,
      "context" : "It should be noted that this is different from the approach used in (Bryce et al. 2015), where a simpler, but less physically accurate model was used.",
      "startOffset" : 68,
      "endOffset" : 87
    }, {
      "referenceID" : 10,
      "context" : "For a fair comparison with (Bryce et al. 2015), the simpler model was used in reproducing the results for dReal.",
      "startOffset" : 27,
      "endOffset" : 46
    }, {
      "referenceID" : 4,
      "context" : ", (Balduccini and Lierler 2013).",
      "startOffset" : 2,
      "endOffset" : 31
    }, {
      "referenceID" : 4,
      "context" : ", (Balduccini and Lierler 2013)) of the performance of tightly coupled hybrid solving algorithms vs their loosely coupled counterparts.",
      "startOffset" : 2,
      "endOffset" : 31
    }, {
      "referenceID" : 50,
      "context" : "Various techniques and tools have been proposed to deal with hybrid domains (Penberthy and Weld 1994; McDermott 2003; Li and Williams 2008; Coles et al. 2012; Shin and Davis 2005).",
      "startOffset" : 76,
      "endOffset" : 179
    }, {
      "referenceID" : 44,
      "context" : "Various techniques and tools have been proposed to deal with hybrid domains (Penberthy and Weld 1994; McDermott 2003; Li and Williams 2008; Coles et al. 2012; Shin and Davis 2005).",
      "startOffset" : 76,
      "endOffset" : 179
    }, {
      "referenceID" : 37,
      "context" : "Various techniques and tools have been proposed to deal with hybrid domains (Penberthy and Weld 1994; McDermott 2003; Li and Williams 2008; Coles et al. 2012; Shin and Davis 2005).",
      "startOffset" : 76,
      "endOffset" : 179
    }, {
      "referenceID" : 18,
      "context" : "Various techniques and tools have been proposed to deal with hybrid domains (Penberthy and Weld 1994; McDermott 2003; Li and Williams 2008; Coles et al. 2012; Shin and Davis 2005).",
      "startOffset" : 76,
      "endOffset" : 179
    }, {
      "referenceID" : 10,
      "context" : "More recent works include (Bryce et al. 2015), which presents an approach based on SMT for handling hybrid domains.",
      "startOffset" : 26,
      "endOffset" : 45
    }, {
      "referenceID" : 17,
      "context" : "Some examples include (Cimatti et al. 2015; Cavada et al. 2014; Tabuada et al. 2002; Maly et al. 2013; Bae et al. 2016; Liu and Ozay 2014; Henzinger and Otop 2014), sampling-based planners (Karaman et al.",
      "startOffset" : 22,
      "endOffset" : 163
    }, {
      "referenceID" : 12,
      "context" : "Some examples include (Cimatti et al. 2015; Cavada et al. 2014; Tabuada et al. 2002; Maly et al. 2013; Bae et al. 2016; Liu and Ozay 2014; Henzinger and Otop 2014), sampling-based planners (Karaman et al.",
      "startOffset" : 22,
      "endOffset" : 163
    }, {
      "referenceID" : 58,
      "context" : "Some examples include (Cimatti et al. 2015; Cavada et al. 2014; Tabuada et al. 2002; Maly et al. 2013; Bae et al. 2016; Liu and Ozay 2014; Henzinger and Otop 2014), sampling-based planners (Karaman et al.",
      "startOffset" : 22,
      "endOffset" : 163
    }, {
      "referenceID" : 41,
      "context" : "Some examples include (Cimatti et al. 2015; Cavada et al. 2014; Tabuada et al. 2002; Maly et al. 2013; Bae et al. 2016; Liu and Ozay 2014; Henzinger and Otop 2014), sampling-based planners (Karaman et al.",
      "startOffset" : 22,
      "endOffset" : 163
    }, {
      "referenceID" : 0,
      "context" : "Some examples include (Cimatti et al. 2015; Cavada et al. 2014; Tabuada et al. 2002; Maly et al. 2013; Bae et al. 2016; Liu and Ozay 2014; Henzinger and Otop 2014), sampling-based planners (Karaman et al.",
      "startOffset" : 22,
      "endOffset" : 163
    }, {
      "referenceID" : 40,
      "context" : "Some examples include (Cimatti et al. 2015; Cavada et al. 2014; Tabuada et al. 2002; Maly et al. 2013; Bae et al. 2016; Liu and Ozay 2014; Henzinger and Otop 2014), sampling-based planners (Karaman et al.",
      "startOffset" : 22,
      "endOffset" : 163
    }, {
      "referenceID" : 30,
      "context" : "Some examples include (Cimatti et al. 2015; Cavada et al. 2014; Tabuada et al. 2002; Maly et al. 2013; Bae et al. 2016; Liu and Ozay 2014; Henzinger and Otop 2014), sampling-based planners (Karaman et al.",
      "startOffset" : 22,
      "endOffset" : 163
    }, {
      "referenceID" : 33,
      "context" : "2016; Liu and Ozay 2014; Henzinger and Otop 2014), sampling-based planners (Karaman et al. 2011; Lahijanian et al. 2014).",
      "startOffset" : 75,
      "endOffset" : 120
    }, {
      "referenceID" : 36,
      "context" : "2016; Liu and Ozay 2014; Henzinger and Otop 2014), sampling-based planners (Karaman et al. 2011; Lahijanian et al. 2014).",
      "startOffset" : 75,
      "endOffset" : 120
    }, {
      "referenceID" : 53,
      "context" : "Similarly, falsification of hybrid systems tries to guide the search towards the error states, that can be easily cast as a planning problem, (Plaku et al. 2013; Cimatti et al. 1997).",
      "startOffset" : 142,
      "endOffset" : 182
    }, {
      "referenceID" : 16,
      "context" : "Similarly, falsification of hybrid systems tries to guide the search towards the error states, that can be easily cast as a planning problem, (Plaku et al. 2013; Cimatti et al. 1997).",
      "startOffset" : 142,
      "endOffset" : 182
    }, {
      "referenceID" : 9,
      "context" : "Some recent works (Bogomolov et al. 2014; Bogomolov et al. 2015) are trying to define a formal translation between PDDL+ and standard hybrid automata, but so far only an over-approximation has been defined, that allows the use of those tools only for proving plan non-existence.",
      "startOffset" : 18,
      "endOffset" : 64
    }, {
      "referenceID" : 8,
      "context" : "Some recent works (Bogomolov et al. 2014; Bogomolov et al. 2015) are trying to define a formal translation between PDDL+ and standard hybrid automata, but so far only an over-approximation has been defined, that allows the use of those tools only for proving plan non-existence.",
      "startOffset" : 18,
      "endOffset" : 64
    }, {
      "referenceID" : 59,
      "context" : "PDDL+ has been used to model a number of planning applications (Vallati et al. 2016; Della Penna et al. 2010; Fox et al. 2011) but then specific domain dependent heuristics or tools have been used to find plans (Piacentini et al.",
      "startOffset" : 63,
      "endOffset" : 126
    }, {
      "referenceID" : 24,
      "context" : "PDDL+ has been used to model a number of planning applications (Vallati et al. 2016; Della Penna et al. 2010; Fox et al. 2011) but then specific domain dependent heuristics or tools have been used to find plans (Piacentini et al.",
      "startOffset" : 63,
      "endOffset" : 126
    }, {
      "referenceID" : 25,
      "context" : "2011) but then specific domain dependent heuristics or tools have been used to find plans (Piacentini et al. ; Fox et al. 2012).",
      "startOffset" : 90,
      "endOffset" : 127
    }, {
      "referenceID" : 11,
      "context" : "Finally, some very recent works on PDDL+ planning have been proposed (Cashmore et al. 2016; Piotrowski et al. 2016), but a proper comparison with them will be addressed in future work.",
      "startOffset" : 69,
      "endOffset" : 115
    }, {
      "referenceID" : 52,
      "context" : "Finally, some very recent works on PDDL+ planning have been proposed (Cashmore et al. 2016; Piotrowski et al. 2016), but a proper comparison with them will be addressed in future work.",
      "startOffset" : 69,
      "endOffset" : 115
    }, {
      "referenceID" : 45,
      "context" : "ACsolver (Mellarkod et al. 2008) implements an eager approach to CASP solving, where (in contrast to the lazy approach of ezcsp) ASP and CSP solving are tightly coupled and interleaved.",
      "startOffset" : 9,
      "endOffset" : 32
    }, {
      "referenceID" : 49,
      "context" : "clingon (Ostrowski and Schaub 2012) is another tightly coupled CASP solver.",
      "startOffset" : 8,
      "endOffset" : 35
    }, {
      "referenceID" : 38,
      "context" : "A high level view of the languages and solving techniques employed by these solvers can be found in (Lierler 2014).",
      "startOffset" : 100,
      "endOffset" : 114
    }, {
      "referenceID" : 15,
      "context" : "Action language H was introduced in (Chintabathina et al. 2005) as an extension to previous well-known action languages for modeling hybrid domains.",
      "startOffset" : 36,
      "endOffset" : 63
    }, {
      "referenceID" : 14,
      "context" : "Then, in (Chintabathina 2013), H has been used specifically to model planning and scheduling tasks in hybrid domains, and reasoning is done via CASP language and solver ezcsp as in our paper.",
      "startOffset" : 9,
      "endOffset" : 29
    }, {
      "referenceID" : 6,
      "context" : "Another action language ADP (Baral et al. 2002) was introduced earlier to allow for the specification of, e.",
      "startOffset" : 28,
      "endOffset" : 47
    }, {
      "referenceID" : 22,
      "context" : ", (Evans 1990; Shanahan 1990; Miller and Shanahan 1996; Cervesato and Montanari 2000).",
      "startOffset" : 2,
      "endOffset" : 85
    }, {
      "referenceID" : 55,
      "context" : ", (Evans 1990; Shanahan 1990; Miller and Shanahan 1996; Cervesato and Montanari 2000).",
      "startOffset" : 2,
      "endOffset" : 85
    }, {
      "referenceID" : 46,
      "context" : ", (Evans 1990; Shanahan 1990; Miller and Shanahan 1996; Cervesato and Montanari 2000).",
      "startOffset" : 2,
      "endOffset" : 85
    }, {
      "referenceID" : 13,
      "context" : ", (Evans 1990; Shanahan 1990; Miller and Shanahan 1996; Cervesato and Montanari 2000).",
      "startOffset" : 2,
      "endOffset" : 85
    } ],
    "year" : 2017,
    "abstractText" : "CASP is an extension of ASP that allows for numerical constraints to be added in the rules. PDDL+ is an extension of the PDDL standard language of automated planning for modeling mixed discrete-continuous dynamics. In this paper, we present CASP solutions for dealing with PDDL+ problems, i.e., encoding from PDDL+ to CASP, and extensions to the algorithm of the ezcsp CASP solver in order to solve CASP programs arising from PDDL+ domains. An experimental analysis, performed on well-known linear and non-linear variants of PDDL+ domains, involving various configurations of the ezcsp solver, other CASP solvers, and PDDL+ planners, shows the viability of our solution. Under consideration in Theory and Practice of Logic Programming (TPLP).",
    "creator" : "LaTeX with hyperref package"
  }
}