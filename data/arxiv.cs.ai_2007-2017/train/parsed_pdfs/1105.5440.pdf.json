{
  "name" : "1105.5440.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Emmanuel Mazer", "Juan Manuel Ahuactzin" ],
    "emails" : [ "Emmanuel.Mazer@imag.fr", "jmal@mail.udlap.mx", "Pierre.Bessiere@imag.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Journal of Arti cial Intelligence Research 9 (1998) 295-316 Submitted 9/97; published 11/98 The Ariadne's Clew AlgorithmEmmanuel Mazer Emmanuel.Mazer@imag.frLaboratoire GRAVIR,INRIA 665 Avenue de L'Europe38330 Montbonnot, FranceJuan Manuel Ahuactzin jmal@mail.udlap.mxDepto. de Ing. en Sistemas ComputationalesUnversidad de las AmericasPuebla, Cholula, Puebla 72820, MexicoPierre Bessi ere Pierre.Bessiere@imag.frLaboratoire LEIBNIZ,46 Avenue Felix Viallet38000 Grenoble, France AbstractWe present a new approach to path planning, called the \\Ariadne's clew algorithm\".It is designed to nd paths in high-dimensional continuous spaces and applies to robotswith many degrees of freedom in static, as well as dynamic environments | ones whereobstacles may move. The Ariadne's clew algorithm comprises two sub-algorithms, calledsearch and explore, applied in an interleaved manner. explore builds a representationof the accessible space while search looks for the target. Both are posed as optimizationproblems. We describe a real implementation of the algorithm to plan paths for a sixdegrees of freedom arm in a dynamic environment where another six degrees of freedomarm is used as a moving obstacle. Experimental results show that a path is found in aboutone second without any pre-processing.1. IntroductionThe path planning problem is of major interest for industrial robotics. A basic version ofthis problem consists of nding a sequence of motions for a robot from a start con gurationto a given goal con guration while avoiding collisions with any obstacles in the environment.A simple version of the problem, that of planning the motion of a point robot among3-dimensional polyhedral obstacles, has been proved to be np-complete (Canny, 1988).Generally speaking, the complexity of the problem is exponential in the number of degrees offreedom (dof) of the robot, and polynomial in the number of obstacles in the environment.Consequently, nding a path for a robot with many dof (more than ve) in an environmentwith several obstacles is, indeed, a very di cult problem. Unfortunately, many realisticindustrial problems deal with robots of at least six dof and hundreds of obstacles. Evenworse, often the environment is dynamic in the sense that some of the obstacles may move,thereby further requiring that new paths be found in very short computing times.c 1998 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.\nMazer, Ahuactzin, & Bessi ereIn this paper, we present a new approach to path planning, called the \\Ariadne's clewalgorithm 1\". The approach is completely general and applies to a broad range of pathplanning problems. However, it is particularly designed to nd paths for robots with manydof in dynamic environments.The ultimate goal of a planner is to nd a path from the initial position to the target.However, while searching for this path, the algorithm may consider collecting informationabout the free space and about the set of possible paths that lie in that free space. TheAriadne's clew algorithm tries to do both at the same time: a sub-algorithm called explorecollects information about the free space with increasingly ne resolution, while, in parallel,an algorithm called search opportunistically checks whether the target can be reached.The explore algorithm works by placing landmarks in the searched space in such away that a path from the initial position to any landmark is known. In order to learn asmuch as possible about the free space, the explore algorithm tries to spread the landmarksuniformly all over the space. To do this, it places the landmarks as far as possible from oneanother. For each new landmark produced by the explore algorithm, the search algo-rithm checks (with a local method) whether the target can be reached from that landmark.Both the explore and search algorithms are posed as optimization problems.The Ariadne's clew algorithm is e cient and general:1. The algorithm is e cient in two senses:(a) Experiments show that the algorithm is able to solve path planning problems fastenough to move a six dof arm in a realistic and dynamic environment whereanother six dof robot is used as a moving obstacle.(b) It is well suited for parallel implementation and shows signi cant speed-up whenthe number of processors increases.2. The algorithm is general in two senses:(a) It may be used for a wide range of applications in robotics with little additionale ort to adapt it.(b) Finally, the algorithm is general in that it may be adapted for a large range ofsearch problems in continuous spaces that arise in elds that are not related torobotics.The paper is organized as follows. Section 2 presents the path planning problem anddiscusses related work. Section 3 presents the principle of the Ariadne's clew algorithm.Section 4 describes the application of the algorithm to a six dof arm in a dynamic envi-ronment. Finally, Section 5 concludes the paper with a discussion of the contributions ofour approach, the main di culties involved, and possible improvements of our method.1. According to Greek legend, Ariadne, the daughter of Minos, King of Crete, helped Theseus kill theMinotaur, a monster living in the Labyrinth, a huge maze built by Daedalus. The main di culty facedby Theseus was to nd his way through the Labyrinth. Ariadne brilliantly solved the problem by givinghim a thread (or a clew) that he could unwind in order to nd his path back.296\nThe Ariadne's clew algorithm2. The Path Planning ProblemMany versions of the path planning problem exist. An exhaustive classi cation of theseproblems and of the methods developed to solve them can be found in a survey by Hwangand Ahuja (1992). We choose to illustrate our discussion with a particular case. A robotarm is placed among a set of obstacles. Given an initial and a nal position of the robotarm, the problem is to nd a set of motions that will lead the robot to move between thetwo positions without colliding with the obstacles.To drive the robot amidst the obstacles, early methods (Brooks, 1983) directly used the3d cad models of the robot and of the obstacles to nd a solution, i.e., they considered the\\operational 3d space\". In this space, the path planning problem consists of nding themovements of a complex 3d structure (the robot) in a cluttered 3d space.A major advance was to express the problem in another space known as the con gurationspace, denoted by C (Lozano-P erez, 1987). In this space, the position (or con guration)of a robot is completely determined by a single point having n independent parametersas coordinates. The positions that are not physically legal (because of a collision) arerepresented by particular regions of C, and are called C-obstacles. In the con gurationspace, the path planning problem consists of nding a continuous curve (representing apath for a single geometrical point) that (i) connects the points representing the initial andthe nal con guration of the robot, and (ii) does not intersect any C-obstacles. This methodtrades a simpli cation of the path planning problem (it searches a path for a single point)against a higher-dimensional search space (the dimension of C is the number dof of therobot) and against more complex shapes of obstacles (very simple physical obstacles mayresult in very complex C-obstacles).For example, let us consider the planar arm of Figure 1. Its position among the obstaclesis totally known once the values of the angles between its links (q0; q1) are known. Thus, foreach pair (q0; q1), it is possible to decide whether the robot collides with the surroundingobstacles. This is what we did in Figure 2 to represent the mapping between the physicalobstacles in the operational space and the C-obstacles. Now, by moving a point along thecurve joining q̂a and q̂f one will also de ne a collision-free motion for the planar arm betweenthe corresponding positions P (q̂a) and P (q̂f ) in the operational space. This curve is onesolution to this particular path planning problem.A recent trend in the eld is to consider the \\trajectory space\" (Ferbach, 1996) wherea whole path is represented by a single point. The coordinates of this point are the valuesof the parameters de ning the successive movements of the robot. For instance, the list ofsuccessive commands sent to the robot controller indeed encode an entire path of the robot.In this space, the path planning problem is reduced to the search for a single point. Onceagain, we trade a simpli cation of the path planning problem (searching for a point) againsta higher dimension of the search space (the dimension of the trajectory space is the numberof parameters needed to specify completely a whole path). For example, in Figure 2, thepath between q̂b and q̂d can be represented by a point in a seven-dimensional space simplyby considering the length of its seven segments.297\nMazer, Ahuactzin, & Bessi ere PSfrag replacements B0\nB1B2 B3\nP (q̂a) P (q̂b) P (q̂f )q0\nq1\nFigure 1: A two dof arm placed among obstacles in the operational space2.1 Global ApproachesGlobal approaches are classically divided into two main classes: (i) retraction methods, and(ii) decomposition methods. In the retraction methods, one tries to reduce the dimension ofthe initial problem by recursively considering sub-manifolds of the con guration space. Inthe decomposition methods, one tries to characterize the regions of the con guration spacethat are free of obstacles. Both methods end up with a classical graph search over a discretespace. In principle, these methods are complete because they will nd a path if one existsand will still terminate in a nite time if a path does not exist. Unfortunately, computingthe retraction or the decomposition graph is an np-complete problem: the complexity ofthis task grows exponentially as the number of dof increases (Canny, 1988). Consequently,these planners are used only for robots having a limited number (three or four) of dof. Inaddition, they are slow and can only be used o -line: the planner is invoked with a modelof the environment, it produces a plan that is passed to the robot controller which, in turn,executes it. In general, the time necessary to achieve this is not short enough to allow therobot to move in a dynamic environment.2.2 Path Planning with Local PlannersOne way to combat the complexity of the problem is to trade completeness against perfor-mance. To do this, the local planners are guided by the gradient of a cost function (usuallythe Euclidean distance to the goal) and take into account the constraints introduced by theobstacles to avoid them (Faverjon & Tournassoud, 1987). Since the path planning problemis np-complete, knowing the cost function, it is always possible to design a deceptive envi-ronment where the method will get trapped in a local minimum. However, these methodsare useful in many industrial applications because they can deal with complex robots and298\nThe Ariadne's clew algorithm PSfrag replacements\nCfreeq̂a Cfreeq̂bq̂a\nq̂b q̂f q̂d\nCB0 CB2 CB3\nq0\nq1\n2\n2\no\nFigure 2: The con guration space corresponding to Figure 1. Note: (1) C is a torus, (2)it is divided into two regions Cfreeq̂a and Cfreeq̂b that cannot be connected bya continuous path, and (3) there is not a C-obstacle for B1 because it does notinterfere with the arm.environment models having thousands of faces, that are often too time-consuming for globalmethods.2.3 Path Planning with Randomized Techniques and LandmarksThe stochastic or random approach was rst introduced by Barraquand and Latombe (1990),and later used by Overmars (1992), and more recently by Kavraki (1996). The main ideabehind these algorithms is to build a graph in the con guration space. The graph is ob-tained incrementally as follows: a local planner is used to try to reach the goal. Shouldthe motion stop at a local minimum, a new node (or landmark) is created by generatinga random motion starting from that local minimum. The method iterates these two stepsuntil the goal con guration has been reached from one of these intermediary positions bya gradient descent motion. These algorithms work with a discretized representation of thecon guration space. They are known to be probabilistically complete because the probabilityof terminating with a solution (a path has been found or no path exists) converges to oneas the allowed time increase towards in nity. As in the previous section, it is also possibleto design simple deceptive environments that will make this kind of algorithm slower thana pure random approach. However, they have been tested for robots with a high num-ber of dof and they have been shown to work quickly in relatively complex and naturalenvironments.Other methods using landmarks have been devised. For example, sandros, introducedby Chen and Hwang(1992), makes use of landmarks to approximate the free space. Thisapproach is similar to the \\hierarchical planning\" approach used in ai: should the method299\nMazer, Ahuactzin, & Bessi erefail to reach a goal, new subgoals are generated until the problem is easy enough to besolved. In their approach, rst a local planner is used to reach the nal position: should thelocal planner fail, the con guration space is divided into two subspaces, one containing thegoal and the other a new sub-goal. The problem is therefore divided into two sub-problems:(i) going from the initial position to the subgoal, and (ii) going from the subgoal to the nal position. sandros has been shown to be particularly well adapted to nd paths formanipulators. It has been implemented and tested for planning paths for Puma and Adeptrobots.2.4 Path Planning in the Trajectory SpaceThe previous methods were essentially based on the con guration space: the retraction, thedecomposition, or the optimization is made in this space. An alternative is to consider the\\trajectory space\". For example, in his method vdp, Ferbach (1996) starts by consideringthe straight line segment joining the initial and the nal con guration in C. This path isprogressively modi ed in such a manner that the forbidden regions it crosses are reduced.At each iteration, a sub-manifold of C containing the current path is randomly generated.It is then discretized and explored using a dynamic programming method that uses thelength across the forbidden region as the cost function in order to minimize. The searchresults in a new trajectory whose intersection with the forbidden regions is smaller than theoriginal trajectory. The process is repeated until an admissible trajectory is found. As inthe previous sections, it is also possible to design simple deceptive environments that willmake this kind of algorithm slower than a pure random approach.The work of Lin, Xiao, and Michalewicz (1994) is similar to our approach. As in an earlyversion of our algorithm (Ahuactzin, Mazer, Bessi ere, & Talbi, 1992), genetic algorithms areused to carry out optimization in the trajectory space. Trajectories are parameterized usingthe coordinates of intermediary via-points. An evolutionary algorithm is used to optimizea cost function based on the length of the trajectory and the forbidden region crossed.The standard operators of the genetic algorithms have been modi ed and later extendedto produce a large variety of paths (Xiao, Michalewicz, & Zhang, 1996). The number ofintermediary via-points is xed and chosen using an heuristic. Given this number, nothingprevents to design a deceptive problem which solution will require more intermediary points,leading the algorithm to fail while one solution exists.3. Principle of the Ariadne's Clew AlgorithmAs we have seen in the previous section, the computation of the con guration space C is avery time-consuming task. The main idea behind the Ariadne's clew algorithm is to avoidthis computation. In order to do this, the algorithm searches directly for a feasible path inthe trajectory space. The con guration space C is never explicitly computed.As will be shown, in the trajectory space, path planning may be seen as an optimizationproblem and solved as such by an algorithm called search. It is possible to build anapproximation of free space by another algorithm called explore that is also posed asan optimization problem. The Ariadne's clew algorithm is the result of the interleavedexecution of search and explore. 300\nThe Ariadne's clew algorithm ROBOT\nPSfrag replacements 1 2 3 d1d2d3 q̂\nq̂ = (xf ; yf )\nx\ny\nq̂`\nFigure 3: A parameterized trajectory ( 1; d1; 2; d2; ::: l; dl) and a starting point q̂0 implic-itly de ne a path (in the operational space) for a holonomic mobile robot.3.1 Path Planning as an Optimization Problem: searchGiven a robot with k dof, a trajectory of length l may be parameterized as a sequenceof n = k l successive movements. A starting point q̂ along with such a parameterizedtrajectory implicitly de ne a path and a nal con guration q̂l in the con guration space.For example, for a holonomic mobile robot the trajectory ( 1; d1; 2; d2; ::: l; dl) can beinterpreted as making a 1 degree turn, moving straight d1, making a 2 degree turn andso on. Given the starting con guration q̂ , this trajectory leads to the nal con guration q̂l(see Figure 3).Given a distance function d on the con guration space, if we nd a trajectory such thatit does not collide with any obstacles and such that the distance between q̂l and the goal q̂ is zero, then we have a solution to our path planning problem. Therefore, the path planningproblem may be seen as a minimization problem where:1. The search space is a space of suitably parameterized trajectories, the trajectory space.2. The function to minimize is d(q̂l; q̂ ) if the path is collision-free, and d(q̂i; q̂ ) otherwise(q̂i being the rst collision point).22. Another possible choice would be to give the +1 value to the distance when a collision occurs. However,this is less informative than the chosen function because the rst part of a colliding path could be agood start toward the goal and should not be discarded. Note that the cost function does not includeany optimality criteria such as the length of the trajectory or the amount of energy used.301\nMazer, Ahuactzin, & Bessi ereThe algorithm search, based on this very simple technique and a randomized optimiza-tion method, is already able to solve quite complex problems of robot motion planning. Forexample, Figure 4 represents the two paths found for the holonomic mobile robot. Eachpath was computed on a standard workstation (sparc 5) in less than 0.5 second withoutusing any pre-computation of the con guration space. Thus, it is possible, albeit slowly, toget a planner that can be used in a dynamic environment (where the obstacles may move)by \\dropping\" a new world into the system every 0.5 second. search is very e cient but itis not complete, since it may fail to nd a path even if one exists for two di erent reasons:1. Due to the optimization-based formulation, search can get trapped by local minimaof the objective function, which in turn may place the robot far away from the goal(see Figure 5).2. The length l of the trajectories considered may be too short to reach all the accessibleregions of the con guration space.\nFigure 4: Reactive replanning in a changing environment3.2 Exploring as an Optimization Problem: exploreIn order to build a complete planner, we propose a second algorithm called explore. Whilethe purpose of search was to look directly for a path from q̂ to q̂ , the purpose of exploreis to compute an approximation of the region of the con guration space accessible from q̂ .The explore algorithm builds an approximation of the accessible space by placinglandmarks in the con guration space C in such a way that a path from the initial positionq̂ to any landmark is known. In order to learn as much as possible about the free space, theexplore algorithm tries to spread the landmarks uniformly over the space (see Figure 6).To do this, it tries to put the landmarks as far as possible from one another by maximizingthe distances between them.Therefore, explore may be seen as a maximization problem where:302\nThe Ariadne's clew algorithm PSfrag replacements q̂ q̂\nFigure 6: The rst picture represents the initial position and the rst landmark. The sub-sequent landmarks are then uniformly spread over the search space while themethod keeps track of all paths joining the landmarks to the initial position.The algorithm is named after Ariadne because by placing landmarks, exploreunwinds as if it were using a thread as Theseus did.1. The search space is the set of all paths starting from one of the previously placedlandmarks.2. The function to maximize is d(q̂l; ), where is the set of landmarks already placed.3.3 The Ariadne's Clew Algorithm: explore + searchIn order to have a planner that is both complete and e cient, we combined the two previousalgorithms search and explore to obtain the Ariadne's clew algorithm.The principle of the Ariadne's clew algorithm is very simple:1. Use the search algorithm to nd whether a \\simple\" path exists between q̂ and q̂ .303\nMazer, Ahuactzin, & Bessi ere a b\nc dFigure 7: Bouncing against C-obstacles. Figure (a) presents the original path in the con- guration space. Figure (b) shows the same path after two bounces along thesecond segment on obstacle 2 and on obstacle 1. Figure (c) is the result obtainedafter a bounce of segment 3 against obstacle 2. Finally, Figure (d) presents avalid path obtained after a nal bounce of segment 4 against obstacle 2.2. If no \\simple\" path is found by step 1, then continue until a path is found.(a) Use explore to generate a new landmark.(b) Use search to look for a \\simple\" path from that landmark to q̂ .The Ariadne's clew algorithm will nd a path if one exists. In an overwhelming numberof cases, just a few landmarks are necessary for the Ariadne's clew algorithm to reach thetarget and stop.3.4 A Major Improvement: Bouncing on C-ObstaclesA typical di culty for a path planning algorithm is to nd a collision-free path througha small corridor in the con guration space. This is also the case for the basic version ofthe Ariadne's clew algorithm, presented above. The problem is that very few trajectoriesencode such paths and therefore they are very di cult to nd. Most trajectories collide withthe obstacles. We propose a very simple idea to deal with this problem: going backwards ateach collision point. If, for a given trajectory, a collision is detected along the correspondingpath, then we simply consider transforming that trajectory so that it encodes a new path,one that is found by bouncing o the obstacle at the collision point (see Figure 7). Notethat this construction is applied recursively until the entire trajectory corresponds to acollision-free path. 304\nThe Ariadne's clew algorithmUsing this technique, all trajectories are so transformed that they encode valid paths.This improved version of the Ariadne's clew algorithm no longer cares about obstacles. Fromthe point of view of a search in the trajectory space, it is as if the obstacles have simplyvanished. This method is especially e cient for narrow corridors in the con guration space.Without bouncing, the mapping of a corridor in the con guration space to the trajectoryspace is a set of very few points. With bouncing, every single trajectory going through apart of the corridor is \\folded\" into the corridor (see Figure 7). The resultant mappingof the corridor in the trajectory space is consequently a much larger set of points, andtherefore it is much easier to nd a member of this set. This empirical improvement hasa major practical impact because it makes the proposed algorithm faster ( fteen times) inthe problem considered below.3.5 The AlgorithmWe can now give a nal version of the Ariadne's clew algorithm. It has three inputs: q̂ (the initial position), q̂ (the goal position), and (the maximum allowed distance for apath to the C-obstacles). It returns a legal path or terminates if no path exists at the givenresolution. ALGORITHM ARIADNE(q̂ ; q̂ ; )begini := 1; ̂1 := q̂ ;/* Initialize the set of landmarks with the initial position 1 := f̂1g; \"1 = +1;do while (\"i > );/* run search : look for the goal with a local methodif (minl2IR` d(q̂ ; q̂(l)) == 0)return; /* A path has been found !else/* run explore : place a new landmarki := i+ 1;̂i := q̂ : supl2IR` d( i 1; q̂(l)); i := i 1 [ f̂ig;\"i := d( i 1; ̂i);endifenddo = i;\" = \"i;return(\"); /* No path !end Figure 8: The Ariadne's Clew Algorithm305\nMazer, Ahuactzin, & Bessi ereThe algorithm is based on the following optimization problems:EXPLORE : ( sup d( i 1; q̂(l))l 2 IR`SEARCH : ( min d(q̂(l); q̂ )l 2 IR`q̂(l) denotes the extremity of a legal path parameterized with ` real parameters andstarting either from each of the previously placed landmarks (explore) or from the latestplaced landmark (search).The algorithm is resolution-complete under the following assumptions: \\Space lling completeness\": The global maximum distance can be found by theoptimization algorithm used in explore; the con guration space is a compact set. \\ completeness\": The optimization procedure used in search always nd a completepath (or returns 0) when the starting and the goal positions are located within a ballof radius of the free space.In practice, the rst condition cannot be met with a randomized optimization algorithmin a bounded time, and only local maxima are found. However, the landmarks placedaccording to the new algorithm are better distributed over the free space than landmarksplaced randomly, leading to better performances. The goal of the next section is to justifythis claim, experimentally.4. Path Planning for a Six dof Arm in a Dynamic EnvironmentIn order to demonstrate the feasibility and qualities of the Ariadne's clew algorithm, wehave developed a realistic application of the algorithm. We selected a problem where wewant to have a path planner for a six dof robot arm in a dynamic environment whereanother arm is used as a mobile obstacle. The robot (robot A) is under the control of theAriadne's clew algorithm. It shares its workspace with a second robot (robot B) that ismoving under the control of a random motion generator. The Ariadne's clew algorithmmust be able to compute paths for A in \\real time\" (here, real time means fast enough toensure that robot A will never collide with robot B).In order to reach such a level of performance, we chose to implement the Ariadne'sclew algorithm on a massively parallel machine (Meganode with 128 T800 Transputers).Furthermore, we selected a genetic algorithm as our optimization technique. The reasonsfor this choice are:1. Genetic algorithms are well suited for problems where the search space is huge butwhere there are many acceptable solutions. This is exactly the case here. The tra-jectory space is huge but there are, barring exceptional cases, numerous acceptablepaths going from q̂ to q̂ without collision.306\nThe Ariadne's clew algorithm2. Genetic algorithms, unlike a number of the other optimization techniques (Bessi ere,Talbi, Ahuactzin, & Mazer, 1996), are very easy to implement on parallel architec-tures. We have previously developed a parallel genetic algorithm (pga) and we havealready had signi cant experience using it (Talbi, 1993).3. pga, unlike most parallel programs, shows linear speed-up (when you double thenumber of processors you reduce the computation time by half) and even super-linearspeed-up under certain circumstances (Talbi & Bessi ere, 1996).4.1 Parallel Genetic AlgorithmGenetic algorithms are stochastic optimization techniques introduced by Holland (1975)twenty years ago. They are used in a large variety of domains including robotics (Ahuactzinet al., 1992; Lawrence, 1991; Falkenauer & Bou ouix, 1991; Falkenauer & Delchambre, 1992;Meygret & Levine, 1992) because they are easy to implement and do not require algebraicexpression for the function to be optimized.4.1.1 Principle of Genetic AlgorithmThe goal of the algorithm is to nd a point reaching a \\good\" value of a given function Fover a search space S. First, a quantization step is de ned for S and the search is conductedover a discrete subset, Sd of S. Sd contains 2N elements. In practice, the cardinality of Sdcan be extremely large. For example, in our implementation of explore, N = 116. Thus,a continuous domain is discretized with a given resolution.During an initialization phase a small subset of Sd is drawn at random. This subset iscalled a population. Each element of this population is coded by a string of N bits.The genetic algorithm iterates the following four steps until a solution is found.1. Evaluation: Rank the population according to the value of F for each element of Sd.Decide if the best element can serve as an acceptable solution; if yes, exit.2. Selection: Use the function F to de ne a probability distribution over the population.Select a pair of elements randomly according to this probability distribution.3. Reproduction: Produce a new element from each pair using \\genetic\" operators.4. Replacement: Replace the elements of the starting population by better new ele-ments produced in step 3.Many genetic operators (Davidor, 1989) are available. However, the more commonlyused are the mutation and the cross-over operators. The mutation operator consists ofrandomly ipping some bits of an element of the population. The cross-over operatorconsists of rst randomly choosing a place where to cut the two strings of bits, and thenbuilding two new elements from this pair by simply gluing the right and the left parts ofthe initial pair of strings (see Figure 9).We use both operators to produce new elements. First, we use the cross-over operatorto get an intermediate string. Then, the mutation operator is used on this intermediatestring to get the nal string. 307\nMazer, Ahuactzin, & Bessi ere k PARENTS Cross−over NEW ELEMENTS\nFigure 9: The cross-over operation.4.1.2 Principle of the Parallel Genetic Algorithm (pga)There are many parallel versions of genetic algorithms: the standard parallel version (Robert-son, 1987), the decomposition version (Tanese, 1987) and the massively parallel version (Talbi,1993). We chose this last method. The main idea is to allocate one element of the popula-tion for each processor so that steps 1, 3, and 4 can be executed in parallel. Furthermore,the selection step (step 2) is carried out locally, in that each individual may mate onlywith the individuals placed on processors physically connected to it. This ensures that thecommunication overhead does not increase as the number of processors increases. This isthe reason why pga shows linear speed-up.The parallel genetic algorithm iterates the following four steps until a solution is found.1. Evaluation: Evaluate in parallel all the individuals.2. Selection: Select in parallel, among the neighbors, the mate with the best evaluation.3. Reproduction: Reproduce in parallel with the chosen mate.4. Replacement: Replace in parallel the parents by the o spring.On the Meganode, we implemented the pga on a torus of processors where each indi-vidual has four neighbors (see Figure 10)4.2 Parallel Evaluation of the Cost FunctionThe evaluation functions used in search and explore are very similar: they both computethe nal position of the arm given a Manhattan path of a xed order. In our implementation,based on experience, we chose to use Manhattan paths of order 2. Order 2 appearedto be a good compromise between the number of landmarks needed (increases as orderdecreases) and the computing time necessary for the optimization functions (increases asorder increases). Since our robot has six dof, the argument of the cost function in search isa vector in R12: ( 11; 12; :::; 16; : : : ; 21; : : : ; 26) and the argument of the cost function usedfor explore is a vector in IN IR12 : (i; 11; 12; :::; 16; : : : ; 21; : : : ; 26) where i codes thelandmark used as a starting point for the path. In both cases the functions are de ned onlyon a bounded subset of IR12 and IN IR12, whose limits are xed by the mechanical stopsof the robot and the maximum number of landmarks. A discretization step is chosen forthese two subsets by de ning the resolution at which each elementary motion is discretized.308\nThe Ariadne's clew algorithm\nINDIVIDUALS\n\"HOST\"\n\"ROOT\"\nFigure 10: A torus with sixteen processors. One individual is placed on each processor.Each individual has four neighbors.In our case, each ji is discretized with 9 bits and the number of landmarks is limited to256. Thus, given a binary string of 116 = 8 + 12 9 bits, we can convert it into a vector(as an argument) for the cost function of search, or explore, respectively.Manhattan paths are evaluated in a simpli ed model of the environment. This modelis obtained by enclosing each element of the scene into a bounding rectangular box.The evaluation of a vector is performed as follows:For each ji in ( 11; 12; :::; 16; : : : ; 21; : : : ; 26)Compute the limits on the motion for joint i.Compute ji 0 by bouncing on these limits (see Section 3.4).Update the position of the robot.The limits on the motion of joint i are obtained by merging the legal ranges of motionof all the links that move when joint i moves, and all the obstacles. To obtain a legal rangeof motion between a link and an obstacle, we consider the two enclosing parallelepipeds andexpress their coordinates in the joint frame. Then, we use a classical method to computethe range (Lozano-P erez, 1987).In our parallel implementation, we distributed the geometric computations among sev-eral processors. Each processor is dedicated to the computation of a single type of interac-tion.4.3 Parallel Implementation of the Ariadne's Clew AlgorithmFinally, the Ariadne's clew algorithm is implemented in parallel with three levels of paral-lelism.1. Obviously, a rst level of parallelization can be obtained by running search andexplore at the same time on two sets of processors. While search is checking309\nMazer, Ahuactzin, & Bessi erewhether a path exists between the last placed landmark and the goal, explore isgenerating the next landmark.2. The second level of parallelism corresponds to a parallel implementation of both ge-netic algorithms employed by search and explore to treat their respective opti-mization problems.3. The third level corresponds to a parallelization of the collision checking function andrange computation.We completed a full implementation of these three levels on a Meganode with 128 t800transputers. Figure 11 represents our parallel implementation of the Ariadne's clew algo-rithm and Figure 12 shows how we have embedded this architecture into our experimentalsetup. A cad system (act) is used to model the scene with the two robots. The robotsare under the control of kali (Hayward, Daneshmend, & Hayati, 1988). First, a simpli edgeometric model of the scene is downloaded into the memory of the transputers. Then, aSilicon Graphics workstation works as a global controller and loops over the following steps:1. Generate and execute a legal random motion for robot B.2. Send the new con guration of robot B to the Meganode as well as the desired nalcon guration for robot A.3. Get the planned path for robot A from the Meganode and execute it.4. Wait for a random time and stop robot A.5. Go to 1.This sequence allows us to test our algorithm extensively in real situations by havingto deal with many di erent environments. Of course, the most interesting gure we canobtain from this experiment is the mean time necessary to compute one path given a newenvironment. For this experimental setup this mean time is 1.421 seconds. Using the samearchitecture with more up-to-date processors (t9000) would reduce this time by a factor often. The same computation on a single processor (sparc 5) would take three times longerthan the current implementation.In summary, we have achieved our main goal by proving that it is indeed possible (withthe Ariadne's clew algorithm) to plan collision-free paths for a real robot with many dof ina dynamic realistic environment.5. Conclusion: Contributions, Di culties, and PerspectivesAs mentioned in the Introduction, the Ariadne's clew algorithm has two main qualities:e ciency, and generality. Let us, in conclusion, explain and discuss these two qualities.310\nThe Ariadne's clew algorithm\nPSfrag replacements\nAriadne's clew algorithm\npgapga\nRange computationRange computation\ntype A et Btype A et B type C type C\nMaster Search Explore\nAG GammaGamma Psi ABPsi AB Psi CPsi C\npsi abpsi ab psi cpsi cFigure 11: A parallel implementation of the Ariadne's clew algorithm311\nMazer, Ahuactzin, & Bessi ere 68030\nMega−Node 128 Transputers\nSun 3\nE th ern et\nSilicon Graphics\n(Unix)\n(Unix)\nRobot II\nKALI\nSun 4 (Unix)\nACT\nserver Mega−Node\nserver VxWorks\nBus VME\n(VxWorks)\n68030\nBus VME\n(VxWorks)\nKALI\nRobot I\nGENETIC ALGORITHM\n(SEARCH)\nGENETIC ALGORITHM\n(EXPLORE)\nCAD SYSTEM Figure 12: The experimental setup5.1 PerformanceComparing the performance of this kind of algorithm is a very delicate subject. Performancemay be a matter of computing time, e orts needed to program, or ease of application todi erent problems (see Section 5.2). Evaluating the performance in terms of computingtime is very di cult for one fundamental and three practical reasons:312\nThe Ariadne's clew algorithm1. The fundamental reason is, once again, the np-completeness of the path planningproblem. As deceptive cases may always be designed, the only performance resultsone may reasonably present are always speci c.2. The three practical reasons are:(a) Obviously, the rst requirement for such a comparison is that di erent algorithmsrun on the same machines with the same available memory. This may seem simplebut it is a main di culty in our case because our algorithm has been designedto run on rather speci c kinds of machines, namely, massively parallel ones. Itcould also be implemented on non-parallel machines, but then it may lose partof its interest. A fair comparison would be to compare the algorithms on bothtypes of machines. This would imply programming other algorithms in parallel,which is very di cult in practice.(b) Many known path planning algorithms rst compute the con guration space(or an approximation of it) o -line, and then e ciently solve the path planningproblem on-line. As we saw, in order to deal with a dynamic environment, theAriadne's clew algorithm adopts a completely di erent approach.(c) For practical reasons, many test problems are toy problems (2d, few obstacles,few faces, simulated robots) and the performance results using these kinds ofproblems are very di cult to generalize to realistic industrial problems (3d, tensof obstacles, hundreds of faces, real robots).Considering all these reasons, we tested our algorithm by implementing a realistic roboticapplication to the very end. To achieve this goal, we assembled a complex experimentalsetup including six di erent machines (1 meganode, 2 68030, 2 sun 4, and 1 silicongraphics), two mechanical arms, and running seven di erent cooperative programs (2kali, 1 act, 2 vxworks, 1 parx, and 1 Ariadne's clew algorithm).Our challenge was to be able to solve the path planning problem fast enough to drive areal six dof arm in a dynamic environment. The Ariadne's clew algorithm indeed achievedthis goal in our experiments where the environment is composed of ve xed obstacles anda six dof arm moving independently.We are not aware of any other methods capable of such performance. To the best of ourknowledge, currently implemented planners would take a number of seconds (ten) to place aset of landmarks on a 2d example for a robot with ve dof (Kavraki et al., 1996). Despitethe fact that nding a general purpose planning technique for real industrial application isa very di cult problem, we believe that the Ariadne's clew algorithm provides an e ectiveapproach to such problems.The number of range computations for a Manhattan motion of order 1 is C k2+k2 nwhere n is the number of faces, k the number of dof, and C a constant factor, dependingon the number of parts used to model the robot. Obviously, such a number of faces may bea severe di culty for the implementation of the Ariadne's clew algorithm described so far.To speed up the computation we use a number of geometric lters that reduce the numberof pairs of entities to be analyzed.However, it was possible to follow two research tracks in combination. First, we coulduse collision checking methods that allow access to the pairs in collision in a logarithmic313\nMazer, Ahuactzin, & Bessi eretime (Faverjon & Tournassoud, 1987). Second, we could preserve part of the landmarkgraph when the environment is changing (McLean & Mazon, 1996).5.2 GeneralityThe Ariadne's clew algorithm is general in the sense that it may be used for numerous andvery di erent applications in robotics. Basically, the main thing that needs to be changedin the algorithm is the distance d used in the evaluation functions of the two optimizationproblems.Several planners have been implemented in this way: a ne motion planner (De la Rosa,Laugier, & Najera, 1996), two motion planners for holonomic and non-holonomic mobilerobots (Scheuer & Fraichard, 1997), a reorientation planner for an articulated hand(Gupta,1995), a planner for grasping and regrasping (Ahuactzin, Gupta, & Mazer, 1998), and aplanner for a robotic arm placed in the steam generator of a nuclear plant (McLean &Mazon, 1996). Adapting the algorithm to a new application is, therefore, clearly a veryeasy task. For instance, the application to path planning for the non-holonomic trailer wasdeveloped in three days.The Ariadne's clew algorithm is also general in the sense that it may be used for any kindof path planning problem in a continuous space, in elds other than robotics. Although itmay be su cient to change the distance function d, one may also consider changing the formof the function d, or even the nature of the searched spaces. For instance, the concept ofobstacles may be reconsidered. Instead of \\hard\" obstacles, one could replace them by zonesof constraints. In that case, the path planning problem does not consist of nding a pathwithout collisions but rather nding a path best satisfying the di erent constraints. Sucha planner has been developed for a naval application where the problem was to nd a pathfor a boat with various constraints on the trajectory. This opens numerous perspectives ofapplications for applying the Ariadne's clew algorithm in a broader eld than pure robotics.AcknowledgmentsThe authors are greatly indebted to Dr. Kamal Gupta from Simon Fraser University whocarefully read the paper and suggested valuable corrections that greatly improve the qualityof the nal paper.This work has been made possible by: Le Centre National de la Recherche Scienti que(France), Consejo Nacional de Ciencia y Tecnologia (Mexico) and esprit 2, P2528 (eec).ReferencesAhuactzin, J., Gupta, K., & Mazer, E. (1998). Manipulation Planning for RedundantRobots: A Practical Approach. The International Journal of Robotics Research,17 (7), 731{747.Ahuactzin, J., Mazer, E., Bessi ere, P., & Talbi, E. (1992). Using Genetic Algorithms forRobot Motion Planning. In Proceedings of the 1992 European Conference on Arti cialIntelligence, pp. 671{675. 314\nThe Ariadne's clew algorithmBarraquand, J., & Latombe, J. (1990). A Monte Carlo Algorithm for Path Planning withMany Degrees of Freedom. In Proceedings of the 1990 IEEE International Conferenceon Robotics and Automation, pp. 1712{1717.Bessi ere, P., Talbi, E., Ahuactzin, J., & Mazer, E. (1996). Un Algorithme G en etiqueParall elle pour l'Optimisation. Technique et Science Informatique, 15 (8), 1105{1130.Brooks, R. (1983). Solving the Find-Path Problem by Good Representation of the FreeSpace. IEEE Transactions on System, Man and Cybernetics, 13 (4), 190{197.Canny, J. (1988). The Complexity of Robot Motion Planning. MIT Press.Davidor, Y. (1989). Analogous Crossover. In Proceedings of the Third International Con-ference on Genetic Algorithms, pp. 98{103.De la Rosa, F., Laugier, C., & Najera, J. (1996). Robust Path Planning in the Plane. IEEETransactions on Robotics and Automation, 12 (3), 347{352.Falkenauer, E., & Bou ouix, S. (1991). A Genetic Algorithm for Job Shop. In Proceedingsof the 1991 IEEE International Conference on Robotics and Automation, pp. 824{829.Falkenauer, E., & Delchambre, A. (1992). A Genetic Algorithm for Bin Packing and LineBalancing. In Proceedings of the 1992 IEEE International Conference on Roboticsand Automation, pp. 1186{1192.Faverjon, B., & Tournassoud, P. (1987). A Local Based Approach for Path Planning ofManipulators with a High Number of Degrees of Freedom. In Proceedings of the 1987IEEE International Conference on Robotics and Automation, pp. 1152{1159.Ferbach, P. (1996). Contribution a la Plani cation de Trajectoires. Rapport de RechercheEDF-DER HP-28/96/026, Direction des Etudes et Recherches EDF.Gupta, K. (1995). Motion Planning for Re-Orientation Using Finger Tracking: Landmarksin SO(3) !. In Proceedings of the 1995 IEEE International Conference on Roboticsand Automation, pp. 446{451.Hayward, V., Daneshmend, L., & Hayati, S. (1988). An Overview of KALI: A Systemto Program and Control Cooperative Manipulators. In Proceedings of the FourthInternational Conference on Advanced Robotics, pp. 236{240.Holland, J. (1975). Adaptation in Natural and Arti cial Systems. University of MichiganPress.Hwang, Y., & Ahuja, N. (1992). Gross Motion Planning: A Survey. ACM ComputingSurveys, 24 (3).Kavraki, L., Svestka, P., Latombe, J., & Overmars, M. (1996). Probabilistic Roadmapsfor Path Planning in High-Dimensional Con guration Spaces. IEEE Transactions onRobotics and Automation, 14 (4), 566{580.Lawrence, D. (Ed.). (1991). Handbook of Genetic Algorithms. Van Nostrand Reinhold.315\nMazer, Ahuactzin, & Bessi ereLin, H., Xiao, J., & Michalewicz, Z. (1994). Evolutionary Navigator for a Mobile Robot. InProceedings of the 1994 IEEE International Conference on Robotics and Automation,pp. 2199{2004.Lozano-P erez, T. (1987). A Simple Motion-Planning Algorithm for General Robot Manip-ulators. IEEE Transactions on Robotics and Automation, 3 (3), 224{238.McLean, A., & Mazon, T. (1996). Incremental Roadmaps and Global Path Planning inEvolving Industrial Environments. In Proceedings of the 1996 IEEE InternationalConference on Robotics and Automation, pp. 101{106.Meygret, A., & Levine, M. (1992). Extraction de Primitives G eom etriques: Utilisationd'un Algorithme G en etique. Rapport Annuel, Center for Intelligent Machines, McGillUniversity, Montr eal.Overmars, M. (1992). A Random Approach to Motion Planning. Technical Report RUU-CS-92-32, Department of Computer Science, Utrecht University.Robertson, G. (1987). Parallel Implementation of Genetic Algorithms in a Classi er System.In Davis, L. (Ed.), Genetic Algorithms and Simulated Annealing. Morgan KaufmannPublishers.Scheuer, A., & Fraichard, T. (1997). Continuous-Curvature Path Planning for Car-LikeVehicles. In Proceedings of the IEEE/RSJ International Conference on IntelligentRobots and Systems, pp. 997{1003.Talbi, E. (1993). Allocation de Processus sur les Architectures Parall eles a M emoir Dis-tribu ee. Ph.D. thesis, Institut National Polytechnique de Grenoble - France.Talbi, E., & Bessi ere, P. (1996). A Parallel Genetic Algorithm Applied to the MappingProblem. In Astfalk, G. (Ed.), Applications on Advanced Architecture Computers.SIAM.Tanese, R. (1987). Parallel Genetic Algorithm for a Hypercube. In Proceedings of the SecondInternational Conference on Genetic Algorithms, pp. 177{183.Xiao, J., Michalewicz, Z., & Zhang, L. (1996). Evolutionary Planner/Navigator: OperatorPerformance and Self-Tuning. In Proceedings of 1996 IEEE International Conferenceon Evolutionary Computation, pp. 336{371.\n316"
    } ],
    "references" : [ {
      "title" : "Manipulation Planning for Redundant",
      "author" : [ "J. Ahuactzin", "K. Gupta", "E. Mazer" ],
      "venue" : null,
      "citeRegEx" : "Ahuactzin et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Ahuactzin et al\\.",
      "year" : 1998
    }, {
      "title" : "Using Genetic Algorithms",
      "author" : [ "P. ere", "E. Talbi" ],
      "venue" : null,
      "citeRegEx" : "ere and Talbi,? \\Q1992\\E",
      "shortCiteRegEx" : "ere and Talbi",
      "year" : 1992
    }, {
      "title" : "A Monte Carlo Algorithm for Path Planning",
      "author" : [ "J. Barraquand", "J. Latombe" ],
      "venue" : null,
      "citeRegEx" : "Barraquand and Latombe,? \\Q1990\\E",
      "shortCiteRegEx" : "Barraquand and Latombe",
      "year" : 1990
    }, {
      "title" : "Solving the Find-Path Problem by Good Representation of the Free",
      "author" : [ "R. Brooks" ],
      "venue" : null,
      "citeRegEx" : "Brooks,? \\Q1983\\E",
      "shortCiteRegEx" : "Brooks",
      "year" : 1983
    }, {
      "title" : "The Complexity of Robot Motion Planning",
      "author" : [ "J. Canny" ],
      "venue" : "MIT Press.",
      "citeRegEx" : "Canny,? 1988",
      "shortCiteRegEx" : "Canny",
      "year" : 1988
    }, {
      "title" : "Analogous Crossover",
      "author" : [ "Y. Davidor" ],
      "venue" : "Proceedings of the Third International Con-",
      "citeRegEx" : "Davidor,? 1989",
      "shortCiteRegEx" : "Davidor",
      "year" : 1989
    }, {
      "title" : "Robust Path Planning in the Plane",
      "author" : [ "F. De la Rosa", "C. Laugier", "J. Najera" ],
      "venue" : null,
      "citeRegEx" : "Rosa et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Rosa et al\\.",
      "year" : 1996
    }, {
      "title" : "A Genetic Algorithm for Job Shop",
      "author" : [ "E. Falkenauer", "S. Bou ouix" ],
      "venue" : null,
      "citeRegEx" : "Falkenauer and ouix,? \\Q1991\\E",
      "shortCiteRegEx" : "Falkenauer and ouix",
      "year" : 1991
    }, {
      "title" : "A Genetic Algorithm for Bin Packing and Line",
      "author" : [ "E. Falkenauer", "A. Delchambre" ],
      "venue" : null,
      "citeRegEx" : "Falkenauer and Delchambre,? \\Q1992\\E",
      "shortCiteRegEx" : "Falkenauer and Delchambre",
      "year" : 1992
    }, {
      "title" : "A Local Based Approach for Path Planning",
      "author" : [ "B. Faverjon", "P. Tournassoud" ],
      "venue" : null,
      "citeRegEx" : "Faverjon and Tournassoud,? \\Q1987\\E",
      "shortCiteRegEx" : "Faverjon and Tournassoud",
      "year" : 1987
    }, {
      "title" : "Contribution a la Plani cation de Trajectoires",
      "author" : [ "P. Ferbach" ],
      "venue" : "Rapport de Recherche",
      "citeRegEx" : "Ferbach,? 1996",
      "shortCiteRegEx" : "Ferbach",
      "year" : 1996
    }, {
      "title" : "Motion Planning for Re-Orientation Using Finger Tracking: Landmarks",
      "author" : [ "K. Gupta" ],
      "venue" : null,
      "citeRegEx" : "Gupta,? \\Q1995\\E",
      "shortCiteRegEx" : "Gupta",
      "year" : 1995
    }, {
      "title" : "An Overview of KALI: A System",
      "author" : [ "V. Hayward", "L. Daneshmend", "S. Hayati" ],
      "venue" : null,
      "citeRegEx" : "Hayward et al\\.,? \\Q1988\\E",
      "shortCiteRegEx" : "Hayward et al\\.",
      "year" : 1988
    }, {
      "title" : "Adaptation in Natural and Arti cial Systems",
      "author" : [ "J. Holland" ],
      "venue" : "University of Michigan",
      "citeRegEx" : "Holland,? 1975",
      "shortCiteRegEx" : "Holland",
      "year" : 1975
    }, {
      "title" : "Evolutionary Navigator for a Mobile Robot",
      "author" : [ "H. Lin", "J. Xiao", "Z. Michalewicz" ],
      "venue" : null,
      "citeRegEx" : "Lin et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Lin et al\\.",
      "year" : 1994
    }, {
      "title" : "A Simple Motion-Planning Algorithm for General Robot Manip",
      "author" : [ "T. erez" ],
      "venue" : null,
      "citeRegEx" : "erez,? \\Q1987\\E",
      "shortCiteRegEx" : "erez",
      "year" : 1987
    }, {
      "title" : "Incremental Roadmaps and Global Path Planning",
      "author" : [ "A. McLean", "T. Mazon" ],
      "venue" : null,
      "citeRegEx" : "McLean and Mazon,? \\Q1996\\E",
      "shortCiteRegEx" : "McLean and Mazon",
      "year" : 1996
    }, {
      "title" : "A Random Approach to Motion Planning",
      "author" : [ "M. Overmars" ],
      "venue" : "Technical Report RUU-",
      "citeRegEx" : "Overmars,? 1992",
      "shortCiteRegEx" : "Overmars",
      "year" : 1992
    }, {
      "title" : "Parallel Implementation of Genetic Algorithms in a Classi er System",
      "author" : [ "G. Robertson" ],
      "venue" : null,
      "citeRegEx" : "Robertson,? \\Q1987\\E",
      "shortCiteRegEx" : "Robertson",
      "year" : 1987
    }, {
      "title" : "Continuous-Curvature Path Planning for Car-Like",
      "author" : [ "A. Scheuer", "T. Fraichard" ],
      "venue" : null,
      "citeRegEx" : "Scheuer and Fraichard,? \\Q1997\\E",
      "shortCiteRegEx" : "Scheuer and Fraichard",
      "year" : 1997
    }, {
      "title" : "Allocation de Processus sur les Architectures",
      "author" : [ "E. Talbi" ],
      "venue" : null,
      "citeRegEx" : "Talbi,? \\Q1993\\E",
      "shortCiteRegEx" : "Talbi",
      "year" : 1993
    }, {
      "title" : "A Parallel Genetic Algorithm Applied to the Mapping",
      "author" : [ "P. ere" ],
      "venue" : null,
      "citeRegEx" : "ere,? \\Q1996\\E",
      "shortCiteRegEx" : "ere",
      "year" : 1996
    }, {
      "title" : "Parallel Genetic Algorithm for a Hypercube",
      "author" : [ "R. Tanese" ],
      "venue" : "Proceedings of the Second",
      "citeRegEx" : "Tanese,? 1987",
      "shortCiteRegEx" : "Tanese",
      "year" : 1987
    }, {
      "title" : "Evolutionary Planner/Navigator: Operator",
      "author" : [ "J. Xiao", "Z. Michalewicz", "L. Zhang" ],
      "venue" : null,
      "citeRegEx" : "Xiao et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Xiao et al\\.",
      "year" : 1996
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "A simple version of the problem, that of planning the motion of a point robot among 3-dimensional polyhedral obstacles, has been proved to be np-complete (Canny, 1988).",
      "startOffset" : 154,
      "endOffset" : 167
    }, {
      "referenceID" : 3,
      "context" : "To drive the robot amidst the obstacles, early methods (Brooks, 1983) directly used the 3d cad models of the robot and of the obstacles to nd a solution, i.",
      "startOffset" : 55,
      "endOffset" : 69
    }, {
      "referenceID" : 10,
      "context" : "A recent trend in the eld is to consider the \\trajectory space\" (Ferbach, 1996) where a whole path is represented by a single point.",
      "startOffset" : 64,
      "endOffset" : 79
    }, {
      "referenceID" : 4,
      "context" : "Unfortunately, computing the retraction or the decomposition graph is an np-complete problem: the complexity of this task grows exponentially as the number of dof increases (Canny, 1988).",
      "startOffset" : 173,
      "endOffset" : 186
    }, {
      "referenceID" : 2,
      "context" : "3 Path Planning with Randomized Techniques and Landmarks The stochastic or random approach was rst introduced by Barraquand and Latombe (1990), and later used by Overmars (1992), and more recently by Kavraki (1996).",
      "startOffset" : 113,
      "endOffset" : 143
    }, {
      "referenceID" : 2,
      "context" : "3 Path Planning with Randomized Techniques and Landmarks The stochastic or random approach was rst introduced by Barraquand and Latombe (1990), and later used by Overmars (1992), and more recently by Kavraki (1996).",
      "startOffset" : 113,
      "endOffset" : 178
    }, {
      "referenceID" : 2,
      "context" : "3 Path Planning with Randomized Techniques and Landmarks The stochastic or random approach was rst introduced by Barraquand and Latombe (1990), and later used by Overmars (1992), and more recently by Kavraki (1996). The main idea behind these algorithms is to build a graph in the con guration space.",
      "startOffset" : 113,
      "endOffset" : 215
    }, {
      "referenceID" : 2,
      "context" : "3 Path Planning with Randomized Techniques and Landmarks The stochastic or random approach was rst introduced by Barraquand and Latombe (1990), and later used by Overmars (1992), and more recently by Kavraki (1996). The main idea behind these algorithms is to build a graph in the con guration space. The graph is obtained incrementally as follows: a local planner is used to try to reach the goal. Should the motion stop at a local minimum, a new node (or landmark) is created by generating a random motion starting from that local minimum. The method iterates these two steps until the goal con guration has been reached from one of these intermediary positions by a gradient descent motion. These algorithms work with a discretized representation of the con guration space. They are known to be probabilistically complete because the probability of terminating with a solution (a path has been found or no path exists) converges to one as the allowed time increase towards in nity. As in the previous section, it is also possible to design simple deceptive environments that will make this kind of algorithm slower than a pure random approach. However, they have been tested for robots with a high number of dof and they have been shown to work quickly in relatively complex and natural environments. Other methods using landmarks have been devised. For example, sandros, introduced by Chen and Hwang(1992), makes use of landmarks to approximate the free space.",
      "startOffset" : 113,
      "endOffset" : 1410
    }, {
      "referenceID" : 10,
      "context" : "For example, in his method vdp, Ferbach (1996) starts by considering the straight line segment joining the initial and the nal con guration in C.",
      "startOffset" : 32,
      "endOffset" : 47
    }, {
      "referenceID" : 10,
      "context" : "For example, in his method vdp, Ferbach (1996) starts by considering the straight line segment joining the initial and the nal con guration in C. This path is progressively modi ed in such a manner that the forbidden regions it crosses are reduced. At each iteration, a sub-manifold of C containing the current path is randomly generated. It is then discretized and explored using a dynamic programming method that uses the length across the forbidden region as the cost function in order to minimize. The search results in a new trajectory whose intersection with the forbidden regions is smaller than the original trajectory. The process is repeated until an admissible trajectory is found. As in the previous sections, it is also possible to design simple deceptive environments that will make this kind of algorithm slower than a pure random approach. The work of Lin, Xiao, and Michalewicz (1994) is similar to our approach.",
      "startOffset" : 32,
      "endOffset" : 902
    }, {
      "referenceID" : 20,
      "context" : "We have previously developed a parallel genetic algorithm (pga) and we have already had signi cant experience using it (Talbi, 1993).",
      "startOffset" : 119,
      "endOffset" : 132
    }, {
      "referenceID" : 5,
      "context" : "Many genetic operators (Davidor, 1989) are available.",
      "startOffset" : 23,
      "endOffset" : 38
    }, {
      "referenceID" : 11,
      "context" : "1 Parallel Genetic Algorithm Genetic algorithms are stochastic optimization techniques introduced by Holland (1975) twenty years ago.",
      "startOffset" : 101,
      "endOffset" : 116
    }, {
      "referenceID" : 18,
      "context" : "2 Principle of the Parallel Genetic Algorithm (pga) There are many parallel versions of genetic algorithms: the standard parallel version (Robertson, 1987), the decomposition version (Tanese, 1987) and the massively parallel version (Talbi, 1993).",
      "startOffset" : 138,
      "endOffset" : 155
    }, {
      "referenceID" : 22,
      "context" : "2 Principle of the Parallel Genetic Algorithm (pga) There are many parallel versions of genetic algorithms: the standard parallel version (Robertson, 1987), the decomposition version (Tanese, 1987) and the massively parallel version (Talbi, 1993).",
      "startOffset" : 183,
      "endOffset" : 197
    }, {
      "referenceID" : 20,
      "context" : "2 Principle of the Parallel Genetic Algorithm (pga) There are many parallel versions of genetic algorithms: the standard parallel version (Robertson, 1987), the decomposition version (Tanese, 1987) and the massively parallel version (Talbi, 1993).",
      "startOffset" : 233,
      "endOffset" : 246
    } ],
    "year" : 2011,
    "abstractText" : null,
    "creator" : "dvipsk 5.66a Copyright 1986-97 Radical Eye Software (www.radicaleye.com)"
  }
}