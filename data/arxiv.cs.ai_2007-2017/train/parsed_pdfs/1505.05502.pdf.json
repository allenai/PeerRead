{
  "name" : "1505.05502.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "João Leite" ],
    "emails" : [ "rjrg@fct.unl.pt" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 5.\n05 50\n2v 1\n[ cs\n.A I]\n2 0\nM ay\n2 01\n5"
    }, {
      "heading" : "1 Introduction",
      "text" : "Multi-Context Systems (MCSs) were introduced in [7], building on the work in [16, 27], to address the need for a general framework that integrates knowledge bases expressed in heterogeneous KR formalisms. Intuitively, instead of designing a unifying language (see e.g., [17, 26], and [23] with its reasoner NoHR [22]) to which other languages could be translated, in an MCS the different formalisms and knowledge bases are considered as modules, and means are provided to model the flow of information between them (cf. [1, 21, 24] and references therein for further motivation on hybrid languages and their connection to MCSs).\nMore specifically, an MCS consists of a set of contexts, each of which is a knowledge base in some KR formalism, such that each context can access information from the other contexts using socalled bridge rules. Such non-monotonic bridge rules add its head to the context’s knowledge base provided the queries (to other contexts) in the body are successful. Managed Multi-Context Systems (mMCSs) were introduced in [8] to provide an extension of MCSs by allowing operations, other than simple addition, to be expressed in the heads of bridge rules. This allows mMCSs to properly deal with the problem of consistency management within contexts.\nOne recent challenge for KR languages is to shift from static application scenarios which assume a one-shot computation, usually triggered by a user query, to open and dynamic scenarios where there is a need to react and evolve in the presence of incoming information. Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.\nWhereas mMCSs are quite general and flexible to address the problem of integration of different KR formalisms, they are essentially static in the sense that the contexts do not evolve to incorporate\n1 CENTRIA & Departamento de Informática, Faculdade Ciências e Tecnologia, Universidade Nova de Lisboa, email: rjrg@fct.unl.pt\nthe changes in the dynamic scenarios. In such scenarios, new knowledge and information is dynamically produced, often from several different sources – for example a stream of raw data produced by some sensors, new ontological axioms written by some user, newly found exceptions to some general rule, etc.\nTo address this issue, two recent frameworks, evolving MultiContext Systems (eMCSs) [19] and reactive Multi-Context Systems (rMCSs) [6, 12, 9] have been proposed sharing the broad motivation of designing general and flexible frameworks inheriting from mMCSs the ability to integrate and manage knowledge represented in heterogeneous KR formalisms, and at the same time be able to incorporate knowledge obtained from dynamic observations.\nWhereas some differences set eMCSs and rMCSs apart (see related work in Sec. 6), the definition of eMCSs is presented in a more general way. That, however, means that, as shown in [19], the worstcase complexity is in general high, which may be problematic in dynamic scenarios where the overall system needs to evolve and react interactively. This is all the more true for huge amounts of data – for example raw sensor data is likely to be constantly produced in large quantities – and systems that are capable of processing and reasoning with such data are required.\nAt the same time, eMCSs inherit from MCSs the property that models, i.e., equilibria, may be non-minimal, which potentially admits that certain pieces of information are considered true based solely on self-justification. As argued in [7], minimality may not always be desired, which can in principle be solved by indicating for each context whether it requires minimality or not. Yet, avoiding selfjustifications for those contexts where minimality is desired has not been considered in eMCSs.\nIn this paper, we tackle these problems and, in particular, consider under which conditions reasoning with evolving Multi-Context Systems can be done in polynomial time. For that purpose, we base our work on a number of notions studied in the context of MCSs that solve these problems in this case [7]. Namely, we adapt the notions of minimal and grounded equilibria to eMCSs, and subsequently a well-founded semantics, which indeed paves the way to the desired result.\nThe remainder of this paper is structured as follows. After introducing the main concepts regarding mMCSs in Sect. 2, in Sect. 3 we recall with more detail the framework of eMCSs already introducing adjustments to achieve polynomial reasoning. Then, in Sect. 4 we present an example use case, before we adapt and generalize notions from MCSs in Sect. 5 as outlined. We conclude in Sect. 6 with discussing related work and possible future directions."
    }, {
      "heading" : "2 Preliminaries: Managed Multi-Context Systems",
      "text" : "Following [7], a multi-context system (MCS) consists of a collection of components, each of which contains knowledge represented in some logic, defined as a triple L = 〈KB,BS,ACC〉 where KB is the set of well-formed knowledge bases of L, BS is the set of possible belief sets, and ACC : KB → 2BS is a function describing the semantics of L by assigning to each knowledge base a set of acceptable belief sets. We assume that each element of KB and BS is a set, and define F = {s : s ∈ kb ∧ kb ∈ KB}.\nIn addition to the knowledge base in each component, bridge rules are used to interconnect the components, specifying what knowledge to assert in one component given certain beliefs held in the components of the MCS. Bridge rules in MCSs only allow adding information to the knowledge base of their corresponding context. In [8], an extension, called managed Multi-Context Systems (mMCSs), is introduced in order to allow other types of operations to be performed on a knowledge base. For that purpose, each context of an mMCS is associated with a management base, which is a set of operations that can be applied to the possible knowledge bases of that context. Given a management base OP and a logic L, let OF = {op(s) : op ∈ OP ∧ s ∈ F} be the set of operational formulas that can be built from OP and F. Each context of an mMCS gives semantics to operations in its management base using a management function over a logic L and a management base OP , mng : 2OF ×KB → KB, i.e., mng(op, kb) is the knowledge base that results from applying the operations in op to the knowledge base kb. Note that this is already a specific restriction in our case, as mng commonly returns a (non-empty) set of possible knowledge bases for mMCS (and eMCS). We also assume that mng(∅, kb) = kb. Now, for a sequence of logics L = 〈L1, . . . , Ln〉 and a management base OPi, an Li-bridge rule σ over L, 1 ≤ i ≤ n, is of the form H(σ) ← B(σ) where H(σ) ∈ OFi and B(σ) is a set of bridge literals of the forms (r : b) and not (r : b), 1 ≤ r ≤ n, with b a belief formula of Lr .\nA managed Multi-Context System (mMCS) is a sequence M = 〈C1, . . . , Cn〉, where each Ci, i ∈ {1, . . . , n}, called a managed context, is defined as Ci = 〈Li, kbi, br i, OPi,mngi〉 where Li = 〈KBi,BSi,ACCi〉 is a logic, kbi ∈ KBi, br i is a set of Li-bridge rules, OPi is a management base, and mngi is a management function over Li and OPi. Note that, for the sake of readability, we consider a slightly restricted version of mMCSs where ACCi is still a function and not a set of functions as for logic suites [8].\nFor an mMCS M = 〈C1, . . . , Cn〉, a belief state of M is a sequence S = 〈S1, . . . , Sn〉 such that each Si is an element of BSi. For a bridge literal (r : b), S |= (r : b) if b ∈ Sr and S |= not (r : b) if b /∈ Sr; for a set of bridge literals B, S |= B if S |= L for every L ∈ B. We say that a bridge rule σ of a context Ci is applicable given a belief state S of M if S satisfies B(σ). We can then define appi(S), the set of heads of bridge rules of Ci which are applicable in S, by setting appi(S) = {H(σ) : σ ∈ br i ∧ S |= B(σ)}.\nEquilibria are belief states that simultaneously assign an acceptable belief set to each context in the mMCS such that the applicable operational formulas in bridge rule heads are taken into account. Formally, a belief state S = 〈S1, . . . , Sn〉 of an mMCS M is an equilibrium of M if, for every 1 ≤ i ≤ n, Si ∈ ACCi(mngi(appi(S), kbi))."
    }, {
      "heading" : "3 Evolving Multi-Context Systems",
      "text" : "In this section, we recall evolving Multi-Context Systems as introduced in [19] including some alterations that are in line with our intentions to achieve polynomial reasoning. As indicated in [19], we consider that some of the contexts in the MCS become so-called observation contexts whose knowledge bases will be constantly changing over time according to the observations made, similar, e.g., to streams of data from sensors.2\nThe changing observations then will also affect the other contexts by means of the bridge rules. As we will see, such effect can either be instantaneous and temporary, i.e., limited to the current time instant, similar to (static) mMCSs, where the body of a bridge rule is evaluated in a state that already includes the effects of the operation in its head, or persistent, but only affecting the next time instant. To achieve the latter, we extend the operational language with a unary meta-operation next that can only be applied on top of operations.\nDefinition 1 Given a management base OP and a logic L, we define eOF , the evolving operational language, as eOF = OF ∪ {next(op(s)) : op(s) ∈ OF}.\nWe can now define evolving Multi-Context Systems.\nDefinition 2 An evolving Multi-Context System (eMCS) is a sequence Me = 〈C1, . . . , Cn〉, where each evolving context Ci, i ∈ {1, . . . , n} is defined as Ci = 〈Li, kbi, br i, OPi,mngi〉 where\n• Li = 〈KBi,BSi,ACCi〉 is a logic • kbi ∈ KBi • br i is a set of Li-bridge rules s.t. H(σ) ∈ eOFi • OPi is a management base • mngi is a management function over Li and OPi.\nAs already outlined, evolving contexts can be divided into regular reasoning contexts and special observation contexts that are meant to process a stream of observations which ultimately enables the entire eMCS to react and evolve in the presence of incoming observations. To ease the reading and simplify notation, w.l.o.g., we assume that the first ℓ contexts, 0 ≤ ℓ ≤ n, in the sequence 〈C1, . . . , Cn〉 are observation contexts, and, whenever necessary, such an eMCS can be explicitly represented by 〈Co1 , . . . , C o ℓ , Cℓ+1, . . . , Cn〉.\nAs for mMCSs, a belief state for Me is a sequence S = 〈S1, . . . , Sn〉 such that, for each 1 ≤ i ≤ n, we have Si ∈ BSi.\nRecall that the heads of bridge rules in an eMCS are more expressive than in an mMCS, since they may be of two types: those that contain next and those that do not. As already mentioned, the former are to be applied to the current knowledge base and not persist, whereas the latter are to be applied in the next time instant and persist. Therefore, we distinguish these two subsets.\nDefinition 3 Let Me = 〈C1, . . . , Cn〉 be an eMCS and S a belief state for Me. Then, for each 1 ≤ i ≤ n, consider the following sets:\n• appnexti (S) = {op(s) : next(op(s)) ∈ appi(S)} • appnowi (S) = {op(s) : op(s) ∈ appi(S)}\nNote that if we want an effect to be instantaneous and persistent, then this can also be achieved using two bridge rules with identical body, one with and one without next in the head.\nSimilar to equilibria in mMCS, the (static) equilibrium is defined to incorporate instantaneous effects based on appnowi (S) alone.\n2 For simplicity of presentation, we consider discrete steps in time here.\nDefinition 4 Let Me = 〈C1, . . . , Cn〉 be an eMCS. A belief state S = 〈S1, . . . , Sn〉 for Me is a static equilibrium of Me iff, for each 1 ≤ i ≤ n, we have Si ∈ ACCi(mngi(appnowi (S), kbi)).\nNote the minor change due to mng now only returning one kb. To be able to assign meaning to an eMCS evolving over time, we introduce evolving belief states, which are sequences of belief states, each referring to a subsequent time instant.\nDefinition 5 Let Me = 〈C1, . . . , Cn〉 be an eMCS. An evolving belief state of size s for Me is a sequence Se = 〈S1, . . . , Ss〉 where each Sj , 1 ≤ j ≤ s, is a belief state for Me.\nTo enable an eMCS to react to incoming observations and evolve, an observation sequence defined in the following has to be processed. The idea is that the knowledge bases of the observation contexts Coi change according to that sequence.\nDefinition 6 Let Me = 〈Co1 , . . . , C o ℓ , Cℓ+1, . . . , Cn〉 be an eMCS. An observation sequence for Me is a sequence Obs = 〈O1, . . . ,Om〉, such that, for each 1 ≤ j ≤ m, Oj = 〈oj1, . . . , o j\nℓ〉 is an instant observation with oji ∈ KBi for each 1 ≤ i ≤ ℓ.\nTo be able to update the knowledge bases in the evolving contexts, we need one further notation. Given an evolving context Ci and k ∈ KBi, we denote by Ci[k] the evolving context in which kbi is replaced by k, i.e., Ci[k] = 〈Li, k, br i, OPi,mngi〉.\nWe can now define that certain evolving belief states are evolving equilibria of an eMCS Me = 〈Co1 , . . . , C o ℓ , Cℓ+1, . . . , Cn〉 given an observation sequence Obs = 〈O1, . . . ,Om〉 for Me. The intuitive idea is that, given an evolving belief state Se = 〈S1, . . . , Ss〉 for Me, in order to check if Se is an evolving equilibrium, we need to consider a sequence of eMCSs, M1, . . . ,Ms (each with ℓ observation contexts), representing a possible evolution of Me according to the observations in Obs, such that Sj is a (static) equilibrium of M j . The knowledge bases of the observation contexts in M j are exactly their corresponding elements oji in O\nj . For each of the other contexts Ci, ℓ + 1 ≤ i ≤ n, its knowledge base in M j is obtained from the one in M j−1 by applying the operations in appnexti (S j−1).\nDefinition 7 Let Me = 〈Co1 , . . . , C o ℓ , Cℓ+1, . . . , Cn〉 be an eMCS, Se = 〈S 1, . . . , Ss〉 an evolving belief state of size s for Me, and Obs = 〈O1, . . . ,Om〉 an observation sequence for Me such that m ≥ s. Then, Se is an evolving equilibrium of size s of Me given Obs iff, for each 1 ≤ j ≤ s, Sj is an equilibrium of M j = 〈Co1 [o j 1], . . . , C o ℓ [o j ℓ ], Cℓ+1[k j ℓ+1], . . . , Cn[k j n]〉 where, for each ℓ+ 1 ≤ i ≤ n, kji is defined inductively as follows: • k1i = kbi • kj+1i = mngi(app next i (S j), kji )\nNote that next in bridge rule heads of observation contexts are thus without any effect, in other words, observation contexts can indeed be understood as managed contexts whose knowledge base changes with each time instant.\nThe essential difference to [19] is that the kj+1i can be effectively computed (instead of picking one of several options), simply because mng always returns one knowledge base. The same applies in Def. 4.\nAs shown in [19], two consequences of the previous definitions are that any subsequence of an evolving equilibrium is also an evolving equilibrium, and mMCSs are a particular case of eMCSs."
    }, {
      "heading" : "4 Use Case Scenario",
      "text" : "In this section, we illustrate eMCSs adapting a scenario on cargo shipment assessment taken from [32].\nThe customs service for any developed country assesses imported cargo for a variety of risk factors including terrorism, narcotics, food and consumer safety, pest infestation, tariff violations, and intellectual property rights.3 Assessing this risk, even at a preliminary level, involves extensive knowledge about commodities, business entities, trade patterns, government policies and trade agreements. Some of this knowledge may be external to a given customs agency: for instance the broad classification of commodities according to the international Harmonized Tariff System (HTS), or international trade agreements. Other knowledge may be internal to a customs agency, such as lists of suspected violators or of importers who have a history of good compliance with regulations. While some of this knowledge is relatively stable, much of it changes rapidly. Changes are made not only at a specific level, such as knowledge about the expected arrival date of a shipment; but at a more general level as well. For instance, while the broad HTS code for tomatoes (0702) does not change, the full classification and tariffs for cherry tomatoes for import into the US changes seasonally.\nHere, we consider an eMCS Me = 〈Co1 , C o 2 , C3, C4〉 composed of two observation contexts Co1 and C o 2 , and two reasoning contexts C3 and C4. The first observation context is used to capture the data of passing shipments, i.e., the country of their origination, the commodity they contain, their importers and producers. Thus, the knowledge base and belief set language of Co1 is composed of all the ground atoms over ShpmtCommod/2, ShpmtDeclHTSCode/2, ShpmtImporter/2, ShpmtCountry/2, ShpmtProducer/2, and also GrapeTomato/1 and CherryTomato/1. The second observation context Co2 serves to insert administrative information and data from other institutions. Its knowledge base and belief set language is composed of all the ground atoms over NewEUMember/1, Misfiling/1, and RandomInspection/1. Neither of the two observation contexts has any bridge rules.\nThe reasoning context C3 is an ontological Description Logic (DL) context that contains a geographic classification, along with information about producers who are located in various countries. It also contains a classification of commodities based on their harmonized tariff information (HTS chapters, headings and codes, cf. http://www.usitc.gov/tata/hts). We refer to [11] and [8] for the standard definition of L3; kb3 is given as follows:\nCommodity ≡ (∃HTSCode.⊤) EdibleVegetable ≡ (∃HTSChapter. { ‘07’ }) CherryTomato ≡ (∃HTSCode. { ‘07020020’ }) Tomato ≡ (∃HTSHeading. { ‘0702’ }) GrapeTomato ≡ (∃HTSCode. { ‘07020010’ }) CherryTomato ⊑ Tomato CherryTomato ⊓ GrapeTomato ⊑ ⊥ GrapeTomato ⊑ Tomato Tomato ⊑ EdibleVegetable EURegisteredProducer ≡ (∃RegisteredProducer.EUCountry) LowRiskEUCommodity ≡ (∃ExpeditableImporter.⊤)⊓ (∃CommodCountry.EUCountry) EUCountry(portugal ) RegisteredProducer(p1 , portugal ) EUCountry(slovakia) RegisteredProducer(p2 , slovakia)\nOP3 contains a single add operation to add factual knowledge. The bridge rules br3 are given as follows:\n3 The system described here is not intended to reflect the policies of any country or agency.\nadd(CherryTomato(x)) ← (1 :CherryTomato(x)) add(GrapeTomato(x)) ← (1 :GrapeTomato(x)) next(add(EUCountry(x))) ← (2 :NewEUMember(x)) add(CommodCountry(x,y)) ← (1 :ShpmtCommod(z,x)),\n(1 :ShpmtCountry(z,y)) add(ExpeditableImporter(x,y)) ← (1 :ShpmtCommod(z,x)),\n(1 :ShpmtImporter(z,y)), (4 :AdmissibleImporter(y)), (4 :ApprovedImporterOf(y,x))\nNote that kb3 can indeed be expressed in the DL EL++ [4] for which standard reasoning tasks, such as subsumption, can be computed in PTIME.\nFinally, C4 is a logic programming (LP) indicating information about importers, and about whether to inspect a shipment either to check for compliance of tariff information or for food safety issues. For L4 we consider that KBi the set of normal logic programs over a signature Σ, BSi is the set of atoms over Σ, and ACCi(kb) returns returns a singleton set containing only the set of true atoms in the unique well-founded model. The latter is a bit unconventional, since this way undefinedness under the well-founded semantics [15] is merged with false information. However, as long as no loops over negation occur in the LP context (in combination with its bridge rules), undefinedness does not occur, and the obvious benefit of this choice is that computing the well-founded model is PTIME-datacomplete [10]. We consider OP4 = OP3, and kb4 and br4 are given as follows:\nAdmissibleImporter(x) ← ∼SuspectedBadGuy(x). PartialInspection(x) ← RandomInspection(x). FullInspection(x) ← ∼CompliantShpmt(x). SuspectedBadGuy(i1 ).\nnext((SuspectedBadGuy(x)) ← (2 :Misfiling(x)) add(ApprovedImporterOf(i2 ,x)) ← (3 :EdibleVegetable(x)) add(ApprovedImporterOf(i3 ,x)) ← (1 :GrapeTomato(x)) add(CompliantShpmt(x)) ← (1 :ShpmtCommod(x,y)),\n(3 :HTSCode(y,z)), (1 :ShpmtDeclHTSCode(x, z)) add(RandomInspection(x)) ← (1 :ShpmtCommod(x,y)),\n(2 :Random(y)) add(PartialInspection(x)) ← (1 :ShpmtCommod(x,y)),\nnot (3 :LowRiskEUCommodity(y)) add(FullInspection(x)) ← (1 :ShpmtCommod(x,y)),\n(3 :Tomato(y)), (1 :ShpmtCountry(x, slovakia))\nNow consider the observation sequence Obs = 〈O1,O2,O3〉 where o11 consists of the following atoms on s1 (where s in s1 stands for shipment, c for commodity, and i for importer):\nShpmtCommod(s1 , c1 ) ShpmtDeclHTSCode(s1 , ‘07020010’) ShpmtImporter(s1 , i1 ) CherryTomato(c1 )\no21 of the following atoms on s2 :\nShpmtCommod(s2 , c2 ) ShpmtDeclHTSCode(s2 , ‘07020020’) ShpmtImporter(s2 , i2 ) ShpmtCountry(s2 , portugal ) CherryTomato(c2 )\nand o31 of the following atoms on s3 :\nShpmtCommod(s3 , c3 ) ShpmtDeclHTSCode(s3 , ‘07020010’) ShpmtImporter(s3 , i3 ) ShpmtCountry(s3 , portugal ) GrapeTomato(c3 ) ShpmtProducer(s3 , p1 )\nwhile o12 = o 3 2 = ∅ and o 2 2 = {Misfiling(i3 )}. Then, an evolving equilibrium of size 3 of Me given Obs is the sequence Se = 〈S1, S2, S3〉 such that, for each 1 ≤ j ≤ 3, Sj = 〈Sj1, S j 2 , S j 3 , S j 4〉. Since it is not feasible to present the entire Se, we just highlight some interesting parts related to the evolution of the system. E.g., we have that FullInspection(s1 ) ∈ S14 since the HTS code does not correspond to the cargo; no inspection on s2 in S24 since the shipment is compliant, c2 is a EU commodity, and s2 was not picked for random inspection; and PartialInspection(s3 ) ∈ S34 , even though s3 comes from a EU country, because i3 has been identified at time instant 2 for misfiling, which has become permanent info available at time 3."
    }, {
      "heading" : "5 Grounded Equilibria and Well-founded Semantics",
      "text" : "Even if we only consider MCSs M , which are static and where an implicit mng always returns precisely one knowledge base, such that reasoning in all contexts can be done in PTIME, then deciding whether M has an equilibrium is in NP [7, 8]. The same result necessarily also holds for eMCSs, which can also be obtained from the considerations on eMCSs [19].\nA number of special notions were studied in the context of MCSs that tackle this problem [7]. In fact, the notion of minimal equilibria was introduced with the aim of avoiding potential self-justifications. Then, grounded equilibria as a special case for so-called reducible MCSs were presented for which the existence of minimal equilibria can be effectively checked. Subsequently, a well-founded semantics for such reducible MCSs was defined under which an approximation of all grounded equilibria can be computed more efficiently. In the following, we transfer these notions from static MCSs in [7] to dynamic eMCSs and discuss under which (non-trivial) conditions they can actually be applied.\nGiven an eMCS Me = 〈C1, . . . , Cn〉, we say that a static equilibrium S = 〈S1, . . . , Sn〉 is minimal if there is no equilibrium S′ = 〈S′1, . . . , S ′ n〉 such that S ′ i ⊆ Si for all i with 1 ≤ i ≤ n and S′j ( Sj for some j with 1 ≤ j ≤ n. This notion of minimality ensures the avoidance of selfjustifications in evolving equilibria. The problem with this notion in terms of computation is that such minimization in general adds an additional level in the polynomial hierarchy. Therefore, we now formalize conditions under which minimal equilibria can be effectively checked. The idea is that the grounded equilibrium will be assigned to an eMCS Me if all the logics of all its contexts can be reduced to special monotonic ones using a so-called reduction function. In the case where the logics of all contexts in Me turn out to be monotonic, the minimal equilibrium will be unique.\nFormally, a logic L = (KB,BS,ACC) is monotonic if\n1. ACC(kb) is a singleton set for each kb ∈ KB, and\n2. S ⊆ S′ whenever kb ⊆ kb ′, ACC(kb) = {S }, and ACC(kb′) = {S′ }.\nFurthermore, L = (KB,BS,ACC) is reducible if for some KB∗ ⊆ KB and some reduction function red : KB × BS → KB∗,\n1. the restriction of L to KB∗ is monotonic,\n2. for each kb ∈ KB, and all S, S′ ∈ BS:\n• red(kb, S) = kb whenever kb ∈ KB∗,\n• red(kb, S) ⊆ red(kb, S′) whenever S′ ⊆ S,\n• S ∈ ACC(kb) iff ACC(red(kb, S)) = {S }.\nThen, an evolving context C = (L, kb, br , OP,mng) is reducible if its logic L is reducible and, for all op ∈ FOPL and all belief sets S, red(mng(op, kb), S) = mng(op, red(kb, S)).\nAn eMCS is reducible if all of its contexts are. Note that a context is reducible whenever its logic L is monotonic. In this case KB∗ coincides with KB and red is the identity with respect to the first argument.\nAs pointed out in [7], reducibility is inspired by the reduct in (nonmonotonic) answer set programming. The crucial and novel condition in our case is the one that essentially says that the reduction function red and the management function mng can be applied in an arbitrary order. This may restrict to some extent the sets of operations OP and mng, but in our use case scenario in Sect. 4, all contexts are indeed reducible.\nA particular case of reducible eMCSs, definite eMCSs, does not require the reduction function and admits the polynomial computation of minimal evolving equilibria as we will see next. Namely, a reducible eMCS Me = 〈C1, . . . , Cn〉 is definite if\n1. none of the bridge rules in any context contains not ,\n2. for all i and all S ∈ BSi, kbi = red i(kbi, S).\nIn a definite eMCS, bridge rules are monotonic, and knowledge bases are already in reduced form. Inference is thus monotonic and a unique minimal equilibrium exists. We take this equilibrium to be the grounded equilibrium. Let Me be a definite eMCS. A belief state S of Me is the grounded equilibrium of Me, denoted by GE(Me), if S is the unique minimal (static) equilibrium of Me. This notion gives rise to evolving grounded equilibria.\nDefinition 8 Let Me = 〈C1, . . . , Cn〉 be a definite eMCS, Se = 〈S1, . . . , Ss〉 an evolving belief state of size s for Me, and Obs = 〈O1, . . . ,Om〉 an observation sequence for Me such that m ≥ s. Then, Se is the evolving grounded equilibrium of size s of Me given Obs iff, for each 1 ≤ j ≤ s, Sj is a grounded equilibrium of M j defined as in Definition 7.\nGrounded equilibria for definite eMCSs can indeed be efficiently computed following [7]. The only additional requirement is that all operations op ∈ OP are monotonic, i.e., for kb, we have that kb ⊆ mng(op(s), kb). Note that this is indeed a further restriction and not covered by reducible eMCSs. Now, for 1 ≤ i ≤ n, let kb0i = kbi and define, for each successor ordinal α+ 1,\nkb α+1 i = mng(app now i (E α), kbαi ),\nwhere Eα = (Eα1 , . . . , E α n) and ACCi(kb α i ) = {E α i }. Furthermore, for each limit ordinal α, define kbαi = ⋃ β≤α kb β i , and let kb∞i = ⋃ α>0 kbαi . Then Proposition 1 [7] can be adapted:\nProposition 1 Let Me = 〈C1, . . . , Cn〉 be a definite eMCS s.t. all OPi are monotonic. A belief state S = 〈S1, . . . , Sn〉 is the grounded equilibrium of Me iff ACCi(kb∞i ) = {Si}, for 1 ≤ i ≤ n.\nAs pointed out in [7], for many logics, kb∞i = kb ω i holds, i.e., the iteration stops after finitely many steps. This is indeed the case for the use case scenario in Sect. 4.\nFor evolving belief states Se of size s and an observation sequence Obs for Me, this proposition yields that the evolving grounded equilibrium for definite eMCSs can be obtained by simply applying this iteration s times.\nGrounded equilibria for general eMCSs are defined based on a reduct which generalizes the Gelfond-Lifschitz reduct to the multicontext case:\nDefinition 9 Let Me = 〈C1, . . . , Cn〉 be a reducible eMCS and S = 〈S1, . . . , Sn〉 a belief state of Me. The Sreduct of Me is defined as MSe = 〈C S 1 , . . . , C S n 〉 where, for each Ci = 〈Li, kbi, br i, OPi,mngi〉, we define CSi = (Li, red i(kbi, Si), br S i , OPi, mngi). Here, br S i results from br i by deleting all\n1. rules with not (r : p) in the body such that S |= (r : p), and\n2. not literals from the bodies of remaining rules.\nFor each reducible eMCS Me and each belief set S, the S-reduct of Me is definite. We can thus check whether S is a grounded equilibrium in the usual manner:\nDefinition 10 Let Me be a reducible eMCS such that all OPi are monotonic. A belief state S of Me is a grounded equilibrium of Me if S is the grounded equilibrium of MSe , that is S = GE(M S e ).\nThe following result generalizes Proposition 2 from [7].\nProposition 2 Every grounded equilibrium of a reducible eMCS Me such that all OPi are monotonic is a minimal equilibrium of Me.\nThis can again be generalized to evolving grounded equilibria.\nDefinition 11 Let Me = 〈C1, . . . , Cn〉 be a normal, reducible eMCS such that all OPi are monotonic, Se = 〈S1, . . . , Ss〉 an evolving belief state of size s for Me, and Obs = 〈O1, . . . ,Om〉 an observation sequence for Me such that m ≥ s. Then, Se is the evolving grounded equilibrium of size s of Me given Obs iff, for each 1 ≤ j ≤ s, Sj is the grounded equilibrium of (M j)S j\nwith M j defined as in Definition 7.\nThis computation is still not polynomial, since, intuitively, we have to guess and check the (evolving) equilibrium, which is why the well-founded semantics for reducible eMCSs Me is introduced following [7]. Its definition is based on the operator γMe(S) = GE(MSe ), provided BSi for each logic Li in all the contexts of Me has a least element S∗. Such eMCSs are called normal.\nThe following result can be straightforwardly adopted from [7].\nProposition 3 Let Me = 〈C1, . . . , Cn〉 be a reducible eMCS such that all OPi are monotonic. Then γMe is antimonotone.\nAs usual, applying γMe twice yields a monotonic operator. Hence, by the Knaster-Tarski theorem, (γMe)\n2 has a least fixpoint which determines the well-founded semantics.\nDefinition 12 Let Me = 〈C1, . . . , Cn〉 be a normal, reducible eMCS such that all OPi are monotonic. The well-founded semantics of Me, denoted WFS(M), is the least fixpoint of (γMe) 2.\nStarting with the least belief state S∗ = 〈S∗1 , . . . , S ∗ n〉, this fixpoint can be iterated, and the following correspondence between WFS(Me) and the grounded equilibria of Me can be shown.\nProposition 4 Let Me = 〈C1, . . . , Cn〉 be a normal, reducible eMCS such that all OPi are monotonic, WFS(Me) = 〈W1, . . .Wn〉, and S = 〈S1, . . . , Sn〉 a grounded equilibrium of Me. Then Wi ⊆ Si for 1 ≤ i ≤ n.\nThe well-founded semantics can thus be viewed as an approximation of the belief state representing what is accepted in all grounded\nequilibria, even though WFS(Me) may itself not necessarily be an equilibrium. Yet, if all ACCi deterministically return one element of BSi and the eMCS is acyclic (i.e., no cyclic dependencies over bridge rules exist between beliefs in the eMCS see [19]), then the grounded equilibrium is unique and identical to the well-founded semantics. This is indeed the case for the use case in Sect. 4.\nAs before, the well-founded semantics can be generalized to evolving belief states.\nDefinition 13 Let Me = 〈C1, . . . , Cn〉 be a normal, reducible eMCS such that all OPi are monotonic, and Obs = 〈O1, . . . ,Om〉 an observation sequence for Me such that m ≥ s. The evolving well-founded semantics of Me, denoted WFSe(M), is the evolving belief state Se = 〈S1, . . . , Ss〉 of size s for Me such that Sj is the well-founded semantics of M j defined as in Definition 7.\nFinally, as intended, we can show that computing the evolving well-founded semantics of Me can be done in polynomial time under the restrictions established so far. For analyzing the complexity in each time instant, we can utilize output-projected belief states [11]. The idea is to consider only those beliefs that appear in some bridge rule body. Formally, given an evolving context Ci within Me = 〈C1, . . . , Cn〉, we can define OUTi to be the set of all beliefs of Ci occurring in the body of some bridge rule in Me. The output-projection of a belief state S = 〈S1, . . . , Sn〉 of Me is the belief state S′ = 〈S′1, . . . , S ′ n〉, S ′ i = Si ∩OUTi, for 1 ≤ i ≤ n.\nFollowing [11, 8], we can adapt the context complexity of Ci from [19] as the complexity of the following problem:\n(CC) Decide, given Opi ⊆ OFi and S′i ⊆ OUTi, if exist kb ′ i =\nmngi(Opi, kbi) and Si ∈ ACCi(kb′i) s.t. S ′ i = Si ∩OUTi.\nProblem (CC) can intuitively be divided into two subproblems: (MC) compute some kb′i = mngi(Opi, kbi) and (EC) decide whether Si ∈ ACC(kb′i) exists s.t. S ′ i = Si∩OUTi. Here, (MC) is trivial for monotonic operations, so (EC) determines the complexity of (CC).\nTheorem 1 Let Me = 〈C1, . . . , Cn〉 be a normal, reducible eMCS such that all OPi are monotonic, Obs = 〈O1, . . . ,Om〉 an observation sequence for Me, and (CC) is in PTIME for all Ci. Then, for s ≤ m, computing WFSse(Me) is in PTIME.\nThis, together with the observation that WFSe(Me) coincides with the unique grounded equilibrium, allows us to verify that computing the results in our use case scenario can be done in polynomial time."
    }, {
      "heading" : "6 Related and Future Work",
      "text" : "In this paper we have studied how eMCSs can be revised in such a way that polynomial reasoning is possible, and we have discussed an example use case to which this result applies. We have also investigated the adaptation of notions concerning minimality of (evolving) equilibria, and we observe that the notion of reducible eMCSs is considerably restricted, but not to the same extent as the efficient computation of the well-founded semantics requires. An open question is whether a more refined computation eventually tailored to less restrictive operations than considered here can be used to achieve similar results.\nAs mentioned in the Introduction, eMCSs share the main ideas of reactive Multi-Context Systems sketched in [6, 12, 9] inasmuch as both aim at extending mMCSs to cope with dynamic observations. Three main differences distinguish them. First, whereas eMCSs rely\non a sequence of observations, each independent from the previous ones, rMCSs encode such sequences within the same observation contexts, with its elements being explicitly timestamped. This means that with rMCSs it is perhaps easier to write bridge rules that refer, e.g., to specific sequences of observations, which in eMCSs would require explicit timestamps and storing the observations in some context, although at the cost that rMCSs need to deal with explicit time which adds an additional overhead. Second, since in rMCSs the contexts resulting from the application of the management operations are the ones that are used in the subsequent state, difficulties may arise in separating non-persistent and persistent effects, for example, allowing an observation to override some fact in some context while the observation holds, but without changing the context itself – such separation is easily encodable in eMCSs given the two kinds of bridge rules, i.e., with or without operator next. Finally, bridge rules with next allow for the specification of transitions based on the current state, such as the one encoded by the rule next(add(p)) ← not p, which do not seem possible in rMCSs. Overall, these differences indicate that an interesting future direction would be to merge both approaches, exploring a combination of explicitly timestamped observations with the expressiveness provided by operator next.\nAnother framework that aims at modeling the dynamics of knowledge is that of evolving logic programs EVOLP [2] focusing on updates of generalized logic programs. It is possible to show that EVOLP can be seen as a particular case of eMCSs, using the operator next to capture the operator assert of EVOLP. We leave the details for an extended version. Closely related to EVOLP, hence to eMCS, are the two frameworks of reactive ASP, one implemented as a solver clingo [14] and one described in [6]. The system oclingo extends an ASP solver for handling external modules provided at runtime by a controller. The output of these external modules can be seen as the observations of EVOLP. Unlike the observations in EVOLP, which can be rules, external modules in oclingo are restricted to produce atoms so the evolving capabilities are very restricted. On the other hand, clingo permits committing to a specific answer-set at each state, a feature that is not part of EVOLP, nor of eMCS. Reactive ASP as described in [6] can be seen as a more straightforward generalization of EVOLP where operations other than assert for self-updating a program are permitted. Given the above mentioned embedding of EVOLP in eMCS, and the fact that eMCSs permit several (evolution) operations in the head of bridge rules, it is also not difficult to show that Reactive ASP as described in [6] can be captured by eMCSs.\nAlso, as already outlined in [20], an important non-trivial topic is the study of the notion of minimal change within an evolving equilibrium. Whereas minimal change may be desirable to obtain more coherent evolving equilibria, there are also arguments against adopting a one-size-fits-all approach embedded in the semantics. Different contexts, i.e., KR formalisms, may require different notions of minimal change, or even require to avoid it – e.g., suppose we want to represent some variable that can non-deterministically takes one of two values at each time instant: minimal change could force a constant value.\nAnother important issue open for future work is a more finegrained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].\nAlso interesting is to study how to perform AGM style belief revision at the (semantic) level of the equilibria, as in Wang et al [33], though different since knowledge is not incorporated in the contexts."
    }, {
      "heading" : "ACKNOWLEDGEMENTS",
      "text" : "We would like to thank the referees for their comments, which helped improve this paper considerably. Matthias Knorr and João Leite were partially supported by FCT under project “ERRO – Efficient Reasoning with Rules and Ontologies” (PTDC/EIACCO/121823/2010). Ricardo Gonçalves was supported by FCT grant SFRH/BPD/47245/2008 and Matthias Knorr was also partially supported by FCT grant SFRH/BPD/86970/2012."
    } ],
    "references" : [ {
      "title" : "Normative systems represented as hybrid knowledge bases",
      "author" : [ "M. Alberti", "A.S. Gomes", "R. Gonçalves", "J. Leite", "M. Slota" ],
      "venue" : "CLIMA, eds., J. Leite, P. Torroni, T. Ågotnes, G. Boella, and L. van der Torre, volume 6814 of LNCS, pp. 330–346. Springer, ",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Evolving logic programs",
      "author" : [ "J. Alferes", "A. Brogi", "J. Leite", "L. Pereira" ],
      "venue" : "JELIA, eds., S. Flesca, S. Greco, N. Leone, and G. Ianni, volume 2424 of LNCS, pp. 50–61. Springer, ",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Stream reasoning and complex event processing in ETALIS",
      "author" : [ "D. Anicic", "S. Rudolph", "P. Fodor", "N. Stojanovic" ],
      "venue" : "Semantic Web, 3(4), 397– 407, ",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Pushing the el envelope",
      "author" : [ "Franz Baader", "Sebastian Brandt", "Carsten Lutz" ],
      "venue" : "Professional Book Center,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2005
    }, {
      "title" : "C- SPARQL: a continuous query language for RDF data streams",
      "author" : [ "D. Barbieri", "D. Braga", "S. Ceri", "E. Valle", "M. Grossniklaus" ],
      "venue" : "Int. J. Semantic Computing, 4(1), 3–25, ",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Towards reactive multi-context systems",
      "author" : [ "G. Brewka" ],
      "venue" : "LPNMR, eds., P. Cabalar and T. C. Son, volume 8148 of LNCS, pp. 1–10. Springer, ",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Equilibria in heterogeneous nonmonotonic multi-context systems",
      "author" : [ "G. Brewka", "T. Eiter" ],
      "venue" : "AAAI, pp. 385–390. AAAI Press, ",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Managed multi-context systems",
      "author" : [ "G. Brewka", "T. Eiter", "M. Fink", "A. Weinzierl" ],
      "venue" : "IJCAI, ed., T. Walsh, pp. 786–791. IJCAI/AAAI, ",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Multi-context systems for reactive reasoning in dynamic environments",
      "author" : [ "G. Brewka", "S. Ellmauthaler", "J. Pührer" ],
      "venue" : "ECAI, eds., T. Schaub, G. Friedrich, and B. O’Sullivan. IOS Press, ",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Complexity and expressive power of logic programming",
      "author" : [ "Evgeny Dantsin", "Thomas Eiter", "Georg Gottlob", "Andrei Voronkov" ],
      "venue" : "ACM Comput. Surv.,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2001
    }, {
      "title" : "Finding explanations of inconsistency in multi-context systems",
      "author" : [ "T. Eiter", "M. Fink", "P. Schüller", "A. Weinzierl" ],
      "venue" : "KR, eds., F. Lin, U. Sattler, and M. Truszczynski. AAAI Press, ",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Generalizing multi-context systems for reactive stream reasoning applications",
      "author" : [ "S. Ellmauthaler" ],
      "venue" : "ICCSW, eds., A. V. Jones and N. Ng, volume 35 of OASICS, pp. 19–26. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, Germany, ",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Stream reasoning with answer set programming: Preliminary report",
      "author" : [ "M. Gebser", "T. Grote", "R. Kaminski", "P. Obermeier", "O. Sabuncu", "T. Schaub" ],
      "venue" : "KR, eds., G Brewka, T. Eiter, and S. A. McIlraith. AAAI Press, ",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Reactive answer set programming",
      "author" : [ "M. Gebser", "T. Grote", "R. Kaminski", "T. Schaub" ],
      "venue" : "LPNMR, eds., J. P. Delgrande and W. Faber, volume 6645 of LNCS, pp. 54–66. Springer, ",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "The wellfounded semantics for general logic programs",
      "author" : [ "Allen Van Gelder", "Kenneth A. Ross", "John S. Schlipf" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1991
    }, {
      "title" : "Multilanguage hierarchical logics or: How we can do without modal logics",
      "author" : [ "F. Giunchiglia", "L. Serafini" ],
      "venue" : "Artif. Intell., 65(1), 29–70, ",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Parametrized logic programming",
      "author" : [ "R. Gonçalves", "J. Alferes" ],
      "venue" : "JELIA, eds., T. Janhunen and I. Niemelä, volume 6341 of LNCS, pp. 182–194. Springer, ",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Evolving bridge rules in evolving multi-context systems",
      "author" : [ "R. Gonçalves", "M. Knorr", "J. Leite" ],
      "venue" : "CLIMA XV, eds., N. Bulling, L. van der Torre, S. Villata, W. Jamroga, and W. Vasconcelos, ",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Evolving multi-context systems",
      "author" : [ "R. Gonçalves", "M. Knorr", "J. Leite" ],
      "venue" : "ECAI, eds., T. Schaub, G. Friedrich, and B. O’Sullivan. IOS Press, ",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "On minimal change in evolving multi-context systems (preliminary report)",
      "author" : [ "R. Gonçalves", "M. Knorr", "J. Leite" ],
      "venue" : "ReactKnow 2014, ",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "MKNF knowledge bases in multi-context systems",
      "author" : [ "M. Homola", "M. Knorr", "J. Leite", "M. Slota" ],
      "venue" : "CLIMA, eds., M. Fisher, L. van der Torre, M. Dastani, and G. Governatori, volume 7486 of LNCS, pp. 146–162. Springer, ",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A query tool for EL with nonmonotonic rules",
      "author" : [ "V. Ivanov", "M. Knorr", "J. Leite" ],
      "venue" : "ISWC, eds., H. Alani, L. Kagal, A. Fokoue, P. T. Groth, C. Biemann, J. Parreira, L. Aroyo, N. F. Noy, C. Welty, and K. Janowicz, volume 8218 of LNCS, pp. 216–231. Springer, ",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Local closed world reasoning with description logics under the well-founded semantics",
      "author" : [ "M. Knorr", "J. Alferes", "P. Hitzler" ],
      "venue" : "Artif. Intell., 175(9-10), 1528–1554, ",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "What if no hybrid reasoner is available? Hybrid MKNF in multi-context systems",
      "author" : [ "M. Knorr", "M. Slota", "J. Leite", "M. Homola" ],
      "venue" : "J. Log. Comput., ",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Predicting knowledge in an ontology stream",
      "author" : [ "F. Lécué", "J. Pan" ],
      "venue" : "IJCAI, ed., F. Rossi. IJCAI/AAAI, ",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Reconciling description logics and rules",
      "author" : [ "B. Motik", "R. Rosati" ],
      "venue" : "J. ACM, 57(5), ",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Minimal and absent information in contexts",
      "author" : [ "F. Roelofsen", "L. Serafini" ],
      "venue" : "IJCAI, eds., L. Kaelbling and A. Saffiotti, pp. 558–563. Professional Book Center, ",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "On semantic update operators for answer-set programs",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "ECAI, eds., H. Coelho, R. Studer, and M. Wooldridge, volume 215 of Frontiers in Artificial Intelligence and Applications, pp. 957–962. IOS Press, ",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Robust equivalence models for semantic updates of answer-set programs",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "KR, eds., G. Brewka, T. Eiter, and S. A. McIlraith. AAAI Press, ",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A unifying perspective on knowledge updates",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "JELIA, eds., L. del Cerro, A. Herzig, and J. Mengin, volume 7519 of LNCS, pp. 372–384. Springer, ",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "The rise and fall of semantic rule updates based on SE-models",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "TPLP, ",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Splitting and updating hybrid knowledge bases",
      "author" : [ "Martin Slota", "João Leite", "Terrance Swift" ],
      "venue" : "TPLP, 11(4-5),",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2011
    }, {
      "title" : "Belief change in nonmonotonic multi-context systems",
      "author" : [ "Y. Wang", "Z. Zhuang", "K. Wang" ],
      "venue" : "LPNMR, eds., P. Cabalar and T. C. Son, volume 8148 of LNCS, pp. 543–555. Springer, ",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "Multi-Context Systems (MCSs) were introduced in [7], building on the work in [16, 27], to address the need for a general framework that integrates knowledge bases expressed in heterogeneous KR formalisms.",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 15,
      "context" : "Multi-Context Systems (MCSs) were introduced in [7], building on the work in [16, 27], to address the need for a general framework that integrates knowledge bases expressed in heterogeneous KR formalisms.",
      "startOffset" : 77,
      "endOffset" : 85
    }, {
      "referenceID" : 26,
      "context" : "Multi-Context Systems (MCSs) were introduced in [7], building on the work in [16, 27], to address the need for a general framework that integrates knowledge bases expressed in heterogeneous KR formalisms.",
      "startOffset" : 77,
      "endOffset" : 85
    }, {
      "referenceID" : 16,
      "context" : ", [17, 26], and [23] with its reasoner NoHR [22]) to which other languages could be translated, in an MCS the different formalisms and knowledge bases are considered as modules, and means are provided to model the flow of information between them (cf.",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 25,
      "context" : ", [17, 26], and [23] with its reasoner NoHR [22]) to which other languages could be translated, in an MCS the different formalisms and knowledge bases are considered as modules, and means are provided to model the flow of information between them (cf.",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 22,
      "context" : ", [17, 26], and [23] with its reasoner NoHR [22]) to which other languages could be translated, in an MCS the different formalisms and knowledge bases are considered as modules, and means are provided to model the flow of information between them (cf.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 21,
      "context" : ", [17, 26], and [23] with its reasoner NoHR [22]) to which other languages could be translated, in an MCS the different formalisms and knowledge bases are considered as modules, and means are provided to model the flow of information between them (cf.",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 0,
      "context" : "[1, 21, 24] and references therein for further motivation on hybrid languages and their connection to MCSs).",
      "startOffset" : 0,
      "endOffset" : 11
    }, {
      "referenceID" : 20,
      "context" : "[1, 21, 24] and references therein for further motivation on hybrid languages and their connection to MCSs).",
      "startOffset" : 0,
      "endOffset" : 11
    }, {
      "referenceID" : 23,
      "context" : "[1, 21, 24] and references therein for further motivation on hybrid languages and their connection to MCSs).",
      "startOffset" : 0,
      "endOffset" : 11
    }, {
      "referenceID" : 7,
      "context" : "Managed Multi-Context Systems (mMCSs) were introduced in [8] to provide an extension of MCSs by allowing operations, other than simple addition, to be expressed in the heads of bridge rules.",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 1,
      "context" : "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 13,
      "context" : "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 12,
      "context" : "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 4,
      "context" : "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 24,
      "context" : "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 2,
      "context" : "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.",
      "startOffset" : 98,
      "endOffset" : 101
    }, {
      "referenceID" : 18,
      "context" : "To address this issue, two recent frameworks, evolving MultiContext Systems (eMCSs) [19] and reactive Multi-Context Systems (rMCSs) [6, 12, 9] have been proposed sharing the broad motiva-",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 5,
      "context" : "To address this issue, two recent frameworks, evolving MultiContext Systems (eMCSs) [19] and reactive Multi-Context Systems (rMCSs) [6, 12, 9] have been proposed sharing the broad motiva-",
      "startOffset" : 132,
      "endOffset" : 142
    }, {
      "referenceID" : 11,
      "context" : "To address this issue, two recent frameworks, evolving MultiContext Systems (eMCSs) [19] and reactive Multi-Context Systems (rMCSs) [6, 12, 9] have been proposed sharing the broad motiva-",
      "startOffset" : 132,
      "endOffset" : 142
    }, {
      "referenceID" : 8,
      "context" : "To address this issue, two recent frameworks, evolving MultiContext Systems (eMCSs) [19] and reactive Multi-Context Systems (rMCSs) [6, 12, 9] have been proposed sharing the broad motiva-",
      "startOffset" : 132,
      "endOffset" : 142
    }, {
      "referenceID" : 18,
      "context" : "That, however, means that, as shown in [19], the worstcase complexity is in general high, which may be problematic in dynamic scenarios where the overall system needs to evolve and react interactively.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 6,
      "context" : "As argued in [7], minimality may not always be desired, which can in principle be solved by indicating for",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 6,
      "context" : "For that purpose, we base our work on a number of notions studied in the context of MCSs that solve these problems in this case [7].",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 6,
      "context" : "Following [7], a multi-context system (MCS) consists of a collec-",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 7,
      "context" : "In [8], an extension, called managed Multi-Context Systems (mMCSs), is introduced in order to allow other types of operations to be performed on a knowledge base.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 7,
      "context" : "Note that, for the sake of readability, we consider a slightly restricted version of mMCSs where ACCi is still a function and not a set of functions as for logic suites [8].",
      "startOffset" : 169,
      "endOffset" : 172
    }, {
      "referenceID" : 18,
      "context" : "duced in [19] including some alterations that are in line with our intentions to achieve polynomial reasoning.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 18,
      "context" : "As indicated in [19], we consider that some of the contexts in the MCS become so-called ob-",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 18,
      "context" : "The essential difference to [19] is that the k i can be effectively computed (instead of picking one of several options), simply because mng always returns one knowledge base.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 18,
      "context" : "As shown in [19], two consequences of the previous definitions are that any subsequence of an evolving equilibrium is also an evolving equilibrium, and mMCSs are a particular case of eMCSs.",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 31,
      "context" : "In this section, we illustrate eMCSs adapting a scenario on cargo shipment assessment taken from [32].",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 10,
      "context" : "We refer to [11] and [8] for the standard definition of L3; kb3 is given as follows:",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 7,
      "context" : "We refer to [11] and [8] for the standard definition of L3; kb3 is given as follows:",
      "startOffset" : 21,
      "endOffset" : 24
    }, {
      "referenceID" : 3,
      "context" : "Note that kb3 can indeed be expressed in the DL EL [4] for which standard reasoning tasks, such as subsumption, can be computed in PTIME.",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 14,
      "context" : "The latter is a bit unconventional, since this way undefinedness under the well-founded semantics [15] is merged with false information.",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 9,
      "context" : "complete [10].",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 6,
      "context" : "ing whether M has an equilibrium is in NP [7, 8].",
      "startOffset" : 42,
      "endOffset" : 48
    }, {
      "referenceID" : 7,
      "context" : "ing whether M has an equilibrium is in NP [7, 8].",
      "startOffset" : 42,
      "endOffset" : 48
    }, {
      "referenceID" : 18,
      "context" : "The same result necessarily also holds for eMCSs, which can also be obtained from the considerations on eMCSs [19].",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 6,
      "context" : "A number of special notions were studied in the context of MCSs that tackle this problem [7].",
      "startOffset" : 89,
      "endOffset" : 92
    }, {
      "referenceID" : 6,
      "context" : "In the following, we transfer these notions from static MCSs in [7] to dynamic eMCSs and discuss under which (non-trivial) conditions they can actually be applied.",
      "startOffset" : 64,
      "endOffset" : 67
    }, {
      "referenceID" : 6,
      "context" : "As pointed out in [7], reducibility is inspired by the reduct in (nonmonotonic) answer set programming.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 6,
      "context" : "Grounded equilibria for definite eMCSs can indeed be efficiently computed following [7].",
      "startOffset" : 84,
      "endOffset" : 87
    }, {
      "referenceID" : 6,
      "context" : "Then Proposition 1 [7] can be adapted:",
      "startOffset" : 19,
      "endOffset" : 22
    }, {
      "referenceID" : 6,
      "context" : "As pointed out in [7], for many logics, kbi = kb ω i holds, i.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 6,
      "context" : "The following result generalizes Proposition 2 from [7].",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 6,
      "context" : "This computation is still not polynomial, since, intuitively, we have to guess and check the (evolving) equilibrium, which is why the well-founded semantics for reducible eMCSs Me is introduced following [7].",
      "startOffset" : 204,
      "endOffset" : 207
    }, {
      "referenceID" : 6,
      "context" : "The following result can be straightforwardly adopted from [7].",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 18,
      "context" : ", no cyclic dependencies over bridge rules exist between beliefs in the eMCS see [19]), then the grounded equilibrium is unique and identical to the well-founded semantics.",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 10,
      "context" : "For analyzing the complexity in each time instant, we can utilize output-projected belief states [11].",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 10,
      "context" : "Following [11, 8], we can adapt the context complexity of Ci from [19] as the complexity of the following problem:",
      "startOffset" : 10,
      "endOffset" : 17
    }, {
      "referenceID" : 7,
      "context" : "Following [11, 8], we can adapt the context complexity of Ci from [19] as the complexity of the following problem:",
      "startOffset" : 10,
      "endOffset" : 17
    }, {
      "referenceID" : 18,
      "context" : "Following [11, 8], we can adapt the context complexity of Ci from [19] as the complexity of the following problem:",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 5,
      "context" : "reactive Multi-Context Systems sketched in [6, 12, 9] inasmuch as both aim at extending mMCSs to cope with dynamic observations.",
      "startOffset" : 43,
      "endOffset" : 53
    }, {
      "referenceID" : 11,
      "context" : "reactive Multi-Context Systems sketched in [6, 12, 9] inasmuch as both aim at extending mMCSs to cope with dynamic observations.",
      "startOffset" : 43,
      "endOffset" : 53
    }, {
      "referenceID" : 8,
      "context" : "reactive Multi-Context Systems sketched in [6, 12, 9] inasmuch as both aim at extending mMCSs to cope with dynamic observations.",
      "startOffset" : 43,
      "endOffset" : 53
    }, {
      "referenceID" : 1,
      "context" : "Another framework that aims at modeling the dynamics of knowledge is that of evolving logic programs EVOLP [2] focusing on updates of generalized logic programs.",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 13,
      "context" : "Closely related to EVOLP, hence to eMCS, are the two frameworks of reactive ASP, one implemented as a solver clingo [14] and one described in [6].",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 5,
      "context" : "Closely related to EVOLP, hence to eMCS, are the two frameworks of reactive ASP, one implemented as a solver clingo [14] and one described in [6].",
      "startOffset" : 142,
      "endOffset" : 145
    }, {
      "referenceID" : 5,
      "context" : "Reactive ASP as described in [6] can be seen as a more straightforward generalization of EVOLP where operations other than assert for self-updating a program are permitted.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 5,
      "context" : "operations in the head of bridge rules, it is also not difficult to show that Reactive ASP as described in [6] can be captured by eMCSs.",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 19,
      "context" : "Also, as already outlined in [20], an important non-trivial topic is the study of the notion of minimal change within an evolving equilibrium.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 17,
      "context" : "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 27,
      "context" : "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].",
      "startOffset" : 152,
      "endOffset" : 164
    }, {
      "referenceID" : 28,
      "context" : "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].",
      "startOffset" : 152,
      "endOffset" : 164
    }, {
      "referenceID" : 30,
      "context" : "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].",
      "startOffset" : 152,
      "endOffset" : 164
    }, {
      "referenceID" : 28,
      "context" : "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].",
      "startOffset" : 220,
      "endOffset" : 228
    }, {
      "referenceID" : 29,
      "context" : "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].",
      "startOffset" : 220,
      "endOffset" : 228
    }, {
      "referenceID" : 32,
      "context" : "Also interesting is to study how to perform AGM style belief revision at the (semantic) level of the equilibria, as in Wang et al [33], though different since knowledge is not incorporated in the contexts.",
      "startOffset" : 130,
      "endOffset" : 134
    } ],
    "year" : 2015,
    "abstractText" : "Managed Multi-Context Systems (mMCSs) provide a general framework for integrating knowledge represented in heterogeneous KR formalisms. Recently, evolving Multi-Context Systems (eMCSs) have been introduced as an extension of mMCSs that add the ability to both react to, and reason in the presence of commonly temporary dynamic observations, and evolve by incorporating new knowledge. However, the general complexity of such an expressive formalism may simply be too high in cases where huge amounts of information have to be processed within a limited short amount of time, or even instantaneously. In this paper, we investigate under which conditions eMCSs may scale in such situations and we show that such polynomial eMCSs can be applied in a practical use case.",
    "creator" : "LaTeX with hyperref package"
  }
}