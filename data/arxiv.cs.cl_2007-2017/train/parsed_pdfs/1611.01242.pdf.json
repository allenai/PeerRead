{
  "name" : "1611.01242.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Answering Complicated Question Intents Expressed in Decomposed Question Sequences",
    "authors" : [ "Mohit Iyyer", "Wen-tau Yih", "Ming-Wei Chang" ],
    "emails" : [ "miyyer@umd.edu", "scottyih@microsoft.com", "minchang@microsoft.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Recent work in semantic parsing for question answering has focused on long and complicated questions, many of which would seem unnatural if asked in a normal conversation between two humans. In an effort to explore a conversational QA setting, we present a more realistic task: answering sequences of simple but inter-related questions. We collect a dataset of 6,066 question sequences that inquire about semi-structured tables from Wikipedia, with 17,553 question-answer pairs in total. Existing QA systems face two major problems when evaluated on our dataset: (1) handling questions that contain coreferences to previous questions or answers, and (2) matching words or phrases in a question to corresponding entries in the associated table. We conclude by proposing strategies to handle both of these issues."
    }, {
      "heading" : "1 Introduction",
      "text" : "Semantic parsing, which maps natural language text to meaning representations in formal logic, has emerged as a key technical component for building question answering systems (Liang, 2016). Once a natural language question has been mapped to a formal query, its answer can be retrieved simply by executing the query on a back-end structured database.\nOne of the main focuses of semantic parsing research is how to address compositionality in language. Extremely complicated questions have been used to\n∗Work done during an internship at Microsoft Research\ndemonstrate the sophistication of semantic parsers,1 and such questions have been specifically targeted in the design of a recently-released QA dataset (Pasupat and Liang, 2015). Take for example the following question: “of those actresses who won a Tony after 1960, which one took the most amount of years after winning the Tony to win an Oscar?” The corresponding logical form is highly compositional; in order to answer it, many sub-questions must be implicitly answered in the process (e.g., “who won a Tony after 1960?”).\nWhile we agree that semantic parsers should be able to answer very complicated questions, in reality these questions are rarely issued by human users of QA systems.2 Because users can interact with a QA system repeatedly, there is no need to assume a singleturn QA setting where the exact question intent has to be captured with just one complex question. The same intent can be more naturally expressed through a sequence of simpler questions, as shown below:\n1. What actresses won a Tony after 1960? 2. Of those, who later won an Oscar? 3. Who had the biggest gap between their two\naward wins?\nDecomposing complicated intents into multiple related but simpler questions is arguably a more effective strategy to explore a topic of interest, and it reduces the cognitive burden on both the person who\n1For example, “will it be warmer than 70 degrees near the Golden Gate Bridge after 5PM the day after tomorrow?” (Dye, 2016)\n2As indirect evidence, the percentage of questions with more than 15 words is only 3.75% in the WikiAnswers questions dataset (Fader et al., 2014).\nar X\niv :1\n61 1.\n01 24\n2v 1\n[ cs\n.C L\n] 4\nN ov\nasks the question as well as the one who answers it.3\nIn this work, we study the semantic parsing problem for answering sequences of simple related questions. We collect a dataset of question sequences that we call SequentialQA (SQA)4 by asking crowdsourced workers to decompose complicated questions sampled from the WikiTableQuestions dataset (Pasupat and Liang, 2015) into multiple easier ones. In addition, each question is associated with answers selected by workers from a corresponding Wikipedia HTML table. Using the SQA dataset, we investigate experimentally how we should modify traditional semantic parser design to address different properties in this new, multi-turn QA setting, such as inter-question coreferences.\nOur contributions are twofold. First, to the best of our knowledge, SQA is the first semantic parsing dataset for sequential question answering. We believe this dataset will be valuable to future research on both semantic parsing and question answering in the more natural interactive setting. Second, after evaluating existing question answering systems on SQA, we find that none of them performs adequately, despite the relative lack of compositionality. We provide a detailed error analysis, which suggests that improperly-resolved references and mismatches between question text and table entries are the main sources of errors.\nThe rest of the paper is structured as follows. Sec. 2 contrasts the existing tasks and datasets to SQA. Sec. 3 describes how we collect the data in detail. Sec. 4 presents our experimental study, followed by the discussion in Sec. 5.2. Finally, Sec. 6 concludes the paper."
    }, {
      "heading" : "2 Related Work",
      "text" : "Our work is related to existing research on conversational (or contextual) semantic parsing, as well as more generally to interactive question-answering systems that operate on semi-structured data.\nPrevious work on conversational QA has focused on small, single-domain datasets. Perhaps most related to our task is the context-dependent sentence\n3While cognitive load has not been measured specifically for complicated questions, there have been many studies linking increased sentence complexity to longer reading times (Hale, 2006; Levy, 2008; Frank, 2013).\n4To be released at http://aka.ms/sqa\nanalysis described in Zettlemoyer and Collins (2009), where conversations between customers and travel agents are mapped to logical forms after resolving referential expressions. Another dataset of travel booking conversations is used by Artzi and Zettlemoyer (2011) to learn a semantic parser for complicated queries given user clarifications. More recently, Long et al. (2016) collect three contextual semantic parsing datasets (from synthetic domains) that contain coreferences to entities and actions. We differentiate ourselves from these prior works in two significant ways: first, our dataset is not restricted to a particular domain, which results in major challenges further detailed in Section 5.2; and second, a major goal of our work is to analyze the different types of sequence progressions people create when they are trying to express a complicated intent.\nComplex, interactive QA tasks have also been proposed in the information retrieval community, where the data source is a corpus of newswire text (Kelly and Lin, 2007). We also build on aspects of some existing interactive question-answering systems. For example, the system of Harabagiu et al. (2005) includes a module that predicts what a user will ask next given their current question. A follow-up work (Lacatusu et al., 2006) proposes syntax-based heuristics to automatically decompose complex questions into simpler ones. Both works rely on proprietary limited-domain datasets; it is unlikely that the proposed heuristics would scale across arbitrary domains."
    }, {
      "heading" : "3 A Dataset of Question Sequences",
      "text" : "Since there are no previous publicly-available datasets for our task, we collect the SequentialQA (SQA) dataset via crowdsourcing. We leverage WikiTableQuestions (Pasupat and Liang, 2015, henceforth WTQ), which contains highly compositional questions associated with HTML tables from Wikipedia. Each crowdsourcing task contains a long, complex question originally from WTQ as the question intent. The workers are asked to compose a sequence of simpler questions that lead to the final intent; an example of this process is shown in Figure 1.\nTo simplify the task for workers, we only select certain types of questions from WTQ. In particular, we only use questions from WTQ whose answers\nare cells in the table, which excludes those involving arithmetic and counting. We likewise also restrict the questions our workers can write to those that are answerable by only table cells. These restrictions speed the annotation process because, instead of typing their answers, workers can just click on the table to answer their question. They also allow us to collect answer coordinates (row and column in the table) as opposed to answer text, which removes many normalization issues for answer string matching that are present in the original WTQ dataset. Finally, we only use intents that contain nine or more words; we find that shorter questions tend to be simpler and are thus less amenable to decomposition.\nAfter iterating on the task design with many pilot tasks, we found that the following constraints are necessary for workers to produce good sequences:\nMinimum sequence length: Workers must create sequences that contain at least two questions. If the intent is not easily decomposed into multiple questions, we instruct workers to create an alternate intent whose answer is the same as that of the original. We also encourage workers to write longer sequences if possible.\nFinal answer same as original answer: The final question of a sequence must have the same answer as that of the original intent. Without this constraint, some workers were writing sequences that diverged\ndrastically from the intent.\nNo copying the intent: After adding the previous constraint, we found that many workers were just copying the intent as the final question of their sequence, which resulted in unnatural-sounding sequences. After we disallowed copying, the workers’ final questions contained many more references to previous questions and answers.\nWe also encouraged (but did not enforce) the following:\nSimplicity: When decomposing a complicated intent into a sequence of questions, we expect that each question in the sequence should be simpler than the intent itself. However, defining “simple” is difficult, and enforcing any definition is even harder. Instead, we told workers to try to limit their questions to those that can be answered with just a single primitive operation (e.g., column selection, argmax/argmin, filtering with a single condition) and provided them with examples of each primitive. Following this definition too closely, however, can result in unnatural sequences, so we do not make any UI changes to limit questions to single primitives.\nInter-question coreferences: Take the following two sequences generated from the same question intent:\n1. What country won the World Cup in 2014? Of the players on the team that won the World Cup in 2014, which ones were midfielders? 2. What country won the World Cup in 2014? Of the players on that team, which ones were midfielders?\nThe second question of the first sequence clumsily repeats information found in the preceding question, while the second sequence avoids this repetition with the referring expression “that team”. To encourage more coreferences between questions, we showed workers example sequences like these and stated that the second one is preferred."
    }, {
      "heading" : "3.1 Properties of SQA",
      "text" : "In total, we used 2,022 question intents from the train and test folds of the WTQ for decomposition. We had three workers decompose each intent, resulting in 6,066 unique questions sequences containing 17,553\ntotal question-answer pairs (for an average of 2.9 questions per sequence). We divide the dataset into train and test using the original WTQ folds, resulting in an 83/17 train/test split. Importantly, just like in WTQ, none of the tables in the test set are seen in the training set.\nWe identify three frequently-occurring question classes: select column, select subset, and select row. In select column questions, the answer is an entire column of the table; these questions account for 23% of all questions in SQA. Subset and row selection are more complicated than column selection, particularly because they usually contain coreferences to the previous question’s answer. In select subset questions, the answer is a subset of the previous question’s answer; similarly, the answers to select row questions occur in the same row(s) as the previous answer but in a different column. Select subset questions make up 27% of SQA, while select row is 19%. The remaining 31% of SQA is comprised of more complex questions that are combinations of these three types. In the sequence “what are all of the tournaments? in which one did he score the least points? on what date was that?”, the first question is a column selection, the second question is a subset selection, and the final question is a row selection.\nWe also observe dramatic differences in the types of questions that are asked at each position of the sequence. For example, looking at just the first question of each sequence, 51% of them are of the select column variety (e.g., “what are all of the teams?”). This number dwindles to just 18% when we look at the second question of each sequence, which indicates that the collected sequences start with general questions and progress to more specific ones. By definition, select subset and select row questions cannot be the first question in a sequence."
    }, {
      "heading" : "4 Baseline Experiments",
      "text" : "We evaluate two existing QA systems on SQA, a semantic parsing system called floating parser and an end-to-end neural network. The floating parser considers each question in a sequence independently of the previous questions, while the neural network leverages contextual information from the sequence. Our goals with these experiments are (1) to measure the difficulty of SQAand (2) to better understand the\nbehaviors of existing state-of-the-art systems."
    }, {
      "heading" : "4.1 Floating parser",
      "text" : "An obvious baseline is the floating parser (FP) developed by Pasupat and Liang (2015), which FP maps questions to logical forms and then executes them on the table to retrieve the answers. It achieves 37.0% accuracy on the WTQ test set. One of the key challenges in semantic parsing is the “semantic matching problem”, where question text cannot be matched to the corresponding answer column or cell verbatim. Without external knowledge, it is often hard to map words or phrases in a question to predicates in its corresponding logical form. Further compounding this problem is that the train and test tables are disjoint, which renders lexicon induction futile. Therefore, FP does not anchor predicates to tokens in the question, relying instead on typing constraints to reduce the search space.5\nUsing FP as-is results in poor performance on SQA. The main reason is that the system is configured for questions with single answers, while SQA contains a high percentage of questions with multiplecell answers. We address this issue by removing a pruning hyperparameter (tooManyValues that eliminates all candidate parses with more than ten items in their denotations, as well as by removing features that add bias on the denotation size."
    }, {
      "heading" : "4.2 End-to-end neural network",
      "text" : "Recently, two different end-to-end neural network architectures for question-answering on tables have been proposed (Neelakantan et al., 2015; Yin et al., 2016). Both models show promising results on synthetic datasets, but neither has been evaluated on real data. We implement our own end-to-end neural model (NEURAL) by generally following both models but deviating when necessary to account for our dataset characteristics.\nAs a brief description, we encode the question, each column header, and each cell in the table with a character-level LSTM. We identify three high-level operations based on our dataset characteristics (select column, select row, and select cell) and design modules that perform each of these functions. A module-level soft attention mechanism, effectively a\n5See Pasupat and Liang (2015) for more details.\nweighted sum of the module scores, decides which module to use given a question.6 We also place an additional LSTM over the question sequence in order to pass information about previous answers and questions to the current time step. Finally, the output of the attention mechanism and the question sequence LSTM is combined and fed to a binary classifier that, given each cell of the table, decides if the cell is part of the answer to the current question or not.\nFig. 2 shows an example of how the modules in NEURAL work together to answer a given question. In particular, since the question “which of them won a Tony after 1960?” is asking for the names of the actresses, the column selection module places most of its weight on the “Name” column, while the row selection module highly weights rows that satisfy the condition “Tony after 1960”. The modules, which take the question and table as input, are merged with an attention mechanism a that also considers the answer to the previous question. A full specification of NEURAL can be found in Appendix A.\nIn contrast to both the neural programmer of Neelakantan et al. (2015) and the neural enquirer of Yin et al. (2016), we make the simplifying assumption that each question in a sequence can be solved with just a single operation. Another major difference is that we use a character-level LSTM, as the training and test vocabulary are radically different.7"
    }, {
      "heading" : "4.3 Results",
      "text" : "Table 1 shows the results of both FP and NEURAL on the test set of SQA. We present both the overall accuracy and the accuracy of answers to questions at each position. Although the accuracy of FP on position-1 questions (48.7%) is much higher than its performance on WTQ (37.0%), the overall accuracy (32.8%) is still lower, which indicates that our SQA dataset remains difficult. In addition, the NEURAL model significantly underperforms FP, suggesting that it requires more data or more sophisticated archi-\n6We did not design more specific modules to handle arithmetic or aggregation like those of Neelakantan et al. (2015), although this is a potentially interesting direction for larger datasets.\n7Due to the fact that much of our vocabulary (e.g., numbers, entities) is not included in a regular corpus, we suspect that the alternative of leveraging publicly-available word embeddings will not be effective.\ntectural design to generalize to all of SQA’s complexities."
    }, {
      "heading" : "5 Directions for Improving Sequential Question Answering",
      "text" : "In this section, we explore possible directions for improving the system performance in the sequential question answering setting. We start from investigating different strategies for handling the coreference issues of questions, and then revisited the semantic matching issue by conducting some error analysis."
    }, {
      "heading" : "5.1 Adapting Existing Semantic Parsers",
      "text" : "As we observed in Sec. 4, existing semantic parsers perform suboptimally on SQA. One possible explanation for the suboptimal performance of existing semantic parsers, shown in Table 1, is that questions that contain references to previous questions or answers are not handled properly. By leveraging FP we propose two ways to deal with this issue: question\nrewriting and table rewriting.\nQuestion rewriting: Take for example the partial sequence “what are all the countries that participated in the olympics? which ones won more than two gold medals?” Any system that treats these two questions independently of each other has a high likelihood of failing on the second question because “ones” is not resolved to “countries”. The obvious solution is to apply coreference resolution. However, existing coreference resolution systems struggle at identifying coreferences across two questions, potentially due to the fact that their training data came from newswire text with few questions.\nAn alternative approach is to create a set of common referential expressions (e.g., “ones”, “them”, “those”) and replace them with noun phrases from the previous question. As we do not have ground-truth coreference annotations, we compute upper-bound improvements on question rewriting instead. That is, we rewrite a reference in a question with all possible noun phrases in the previous question and count the question as correct if any of the rewritten questions are answered correctly. Interestingly, we observe an upper bound improvement of only ≈2% accuracy.\nWhy is the upper bound so low? An error analysis finds that in many cases, the logical form predicted by FP is wrong even when the referential expression is correctly resolved. We will discuss this phenomenon more in Sec. 5.2, but here we concentrate on another common scenario: the question contains a coreference to the answer of the previous question. If we modify our example sequence to “what are all the countries that participated in the olympics in 2012? which ones won more than two gold medals?”, then simply replacing “ones” with “countries” does not resolve the reference.\nTable rewriting: Instead of building a model that can learn to rewrite the second question to “which countries won more than two gold medals in 2012”, or training a semantic parser that can incrementally update the logical form from the previous question as in Zettlemoyer and Collins (2009), we propose to simply rewrite the table based on the first question’s answer. Specifically, if we know that a particular question is a row or subset selection type, then we also know that its answer must be located in the rows that contain the previous answer. For example, take\nthe second question of the decomposed sequence in Fig. 1, which contains a coreference to the answer of the first question (“which of them won a Tony after 1960”) that refers to four actresses. The smallest possible table from which we can still answer this question is one that has four rows (for each of the four actresses) and two columns (“Name” and “Tony”). However, identifying the columns necessary to answer each question is often difficult, so we leave this task to the semantic parser and remove only rows (not columns) that do not contain the previous question’s answers (see the rewritten table for this example in Fig. 2). In this way, we implicitly resolve the coreference “of them”, as any rows that do not correspond to actresses are excluded.\nBefore rewriting the table, we have to first decide whether the question contains a coreference to the answer or not. We know that we should only rewrite the table for subset and row selection questions. Since we can identify the question type in our dataset based on the coordinates of the answers, we assume that we know which questions should and should not be rewritten and use this information to compute upper bounds for semantic parser improvement with table rewriting. We evaluate five different rewriting policies which vary in their knowledge of both the question type and the correctness of the previous predicted answer:\n1. never rewrite the table 2. always rewrite the table based on the previous\npredicted answer, regardless of whether table rewriting is applicable to the question 3. rewrite row/subset: rewrite the table based on the previous predicted answer only when table rewriting is applicable (i.e., the question is subset or row selection) 4. reference: same as rewrite row/subset, except we only rewrite when we know the previous predicted answer is correct 5. upper bound: same as rewrite row/subset, except we rewrite using the previous ground-truth answer instead of the previous predicted answer\nTable 2 shows the results of running these different rewriting policies on our dev set. The oracle score represents the percentage of questions for which at least one candidate logical form generated by the\nparser8 evaluates to the correct answer. The most important takeaway is that accuracy improvements are very small when we rewrite based on the previous predictions. Intuitively, this makes sense: if the parser only gets 30% accuracy, then 70% of the time it will be incorrect on the previous question, and rewriting the table based on a wrong answer could make it impossible for the parser to get the right answer (see the lower oracle scores for always rewrite and rewrite row/subset). Based on these results, table rewriting will only be useful if the base parser’s accuracy is high."
    }, {
      "heading" : "5.2 The semantic matching problem",
      "text" : "The underwhelming improvements from question and table rewriting force us to re-evaluate our original hypothesis that reference resolution is the main source of complexity in our dataset. We take 70 questions from our dev set and manually annotate them with reasons why FP answered them incorrectly. Somewhat surprisingly, we find that only 15 of these errors are due solely to coreferences! The majority of errors are due to wrong logical forms that cannot be corrected by simply resolving a coreference (e.g., the wrong operations are used, or the order of the operations is incorrect).\nWhen checking these questions in detail, we find that the majority of the errors are due to the semantic matching problem – mismatches between question text and table text. The error analysis in (Pasupat and Liang, 2015) on the more complicated WTQ dataset shows that 25% of errors are due to these mismatches and an additional 29% to normalization issues (e.g.,\n8The number of candidate parses considered by FP varies and could sometimes be hundreds.\nan answer cell may contain “Beijing, China” but the crowdsourced answer is just “Beijing”). Because all answers in SQA are the exact text of cells in the table, we avoid these normalization issues; however, the results in Table 1 show that the sequential nature of SQA makes it equally as difficult as WTQ for machines. The examples in Figure 3 suggest that without solving the semantic matching problem, we will not be able to properly take advantage of our question or table rewriting adaptations."
    }, {
      "heading" : "6 Conclusion",
      "text" : "While most current QA systems assume a singleturn setting, in this work we move towards a more conversational, multi-turn scenario in which systems must rely on prior context to answer the user’s current question. To this end, we introduce SQA, a dataset that consists of 6,066 unique sequences of inter-related questions about Wikipedia tables, with 17,553 questions-answer pairs in total. To the best of our knowledge, SQA is the first semantic parsing dataset that addresses sequential question answering, which is a more natural interface for information access.\nThe unique setting and task scenario defined in SQA immediately triggers several interesting research questions, such as whether the simpler questions make the semantic parsing problem easier and\nhow should a system address the coreferences among questions and answers. Our preliminary experimental study found that existing systems do not perform well on SQA. Moreover, the potential of various kinds of question and table rewriting strategies for handling coreferences is hindered by semantic matching errors between question text and cells or column headers in the table. In the near future, we plan to resolve such errors by incorporating large external knowledge sources into semantic parsers. Longer-term, we hope that research on SQA will push towards more interactive settings where systems can ask users for clarifications and incorporate user feedback into future predictions."
    } ],
    "references" : [ {
      "title" : "Bootstrapping semantic parsers from conversations",
      "author" : [ "Artzi", "Zettlemoyer2011] Yoav Artzi", "Luke Zettlemoyer" ],
      "venue" : "In Proceedings of Empirical Methods in Natural Language Processing",
      "citeRegEx" : "Artzi et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Artzi et al\\.",
      "year" : 2011
    }, {
      "title" : "The creator of Siri showcases Viv, an impressive AI personal assistant. http://www.androidauthority.com/ dag-kittlaus-showcase-viv-691539/, May",
      "author" : [ "John Dye" ],
      "venue" : null,
      "citeRegEx" : "Dye.,? \\Q2016\\E",
      "shortCiteRegEx" : "Dye.",
      "year" : 2016
    }, {
      "title" : "Open question answering over curated and extracted knowledge bases",
      "author" : [ "Fader et al.2014] Anthony Fader", "Luke Zettlemoyer", "Oren Etzioni" ],
      "venue" : "In Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining,",
      "citeRegEx" : "Fader et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Fader et al\\.",
      "year" : 2014
    }, {
      "title" : "Uncertainty reduction as a measure of cognitive load in sentence comprehension",
      "author" : [ "Stefan L Frank" ],
      "venue" : "Topics in Cognitive Science,",
      "citeRegEx" : "Frank.,? \\Q2013\\E",
      "shortCiteRegEx" : "Frank.",
      "year" : 2013
    }, {
      "title" : "Uncertainty about the rest of the sentence",
      "author" : [ "John Hale" ],
      "venue" : "Cognitive Science,",
      "citeRegEx" : "Hale.,? \\Q2006\\E",
      "shortCiteRegEx" : "Hale.",
      "year" : 2006
    }, {
      "title" : "Experiments with interactive question-answering",
      "author" : [ "Andrew Hickl", "John Lehmann", "Dan Moldovan" ],
      "venue" : "In Proceedings of the Association for Computational Linguistics",
      "citeRegEx" : "Harabagiu et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Harabagiu et al\\.",
      "year" : 2005
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Kingma", "Ba2014] Diederik Kingma", "Jimmy Ba" ],
      "venue" : "In Proceedings of the International Conference on Learning Representations",
      "citeRegEx" : "Kingma et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kingma et al\\.",
      "year" : 2014
    }, {
      "title" : "Impact of question decomposition on the quality of answer summaries",
      "author" : [ "Andrew Hickl", "Sanda Harabagiu" ],
      "venue" : "In International Language Resources and Evaluation",
      "citeRegEx" : "Lacatusu et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Lacatusu et al\\.",
      "year" : 2006
    }, {
      "title" : "Neural enquirer: Learning",
      "author" : [ "Ben Kao" ],
      "venue" : null,
      "citeRegEx" : "Kao.,? \\Q2016\\E",
      "shortCiteRegEx" : "Kao.",
      "year" : 2016
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "For example, “will it be warmer than 70 degrees near the Golden Gate Bridge after 5PM the day after tomorrow?” (Dye, 2016) As indirect evidence, the percentage of questions with more than 15 words is only 3.",
      "startOffset" : 111,
      "endOffset" : 122
    }, {
      "referenceID" : 2,
      "context" : "75% in the WikiAnswers questions dataset (Fader et al., 2014).",
      "startOffset" : 41,
      "endOffset" : 61
    }, {
      "referenceID" : 4,
      "context" : "While cognitive load has not been measured specifically for complicated questions, there have been many studies linking increased sentence complexity to longer reading times (Hale, 2006; Levy, 2008; Frank, 2013).",
      "startOffset" : 174,
      "endOffset" : 211
    }, {
      "referenceID" : 3,
      "context" : "While cognitive load has not been measured specifically for complicated questions, there have been many studies linking increased sentence complexity to longer reading times (Hale, 2006; Levy, 2008; Frank, 2013).",
      "startOffset" : 174,
      "endOffset" : 211
    }, {
      "referenceID" : 3,
      "context" : "While cognitive load has not been measured specifically for complicated questions, there have been many studies linking increased sentence complexity to longer reading times (Hale, 2006; Levy, 2008; Frank, 2013). To be released at http://aka.ms/sqa analysis described in Zettlemoyer and Collins (2009), where conversations between customers and travel agents are mapped to logical forms after resolving referential expressions.",
      "startOffset" : 199,
      "endOffset" : 302
    }, {
      "referenceID" : 3,
      "context" : "While cognitive load has not been measured specifically for complicated questions, there have been many studies linking increased sentence complexity to longer reading times (Hale, 2006; Levy, 2008; Frank, 2013). To be released at http://aka.ms/sqa analysis described in Zettlemoyer and Collins (2009), where conversations between customers and travel agents are mapped to logical forms after resolving referential expressions. Another dataset of travel booking conversations is used by Artzi and Zettlemoyer (2011) to learn a semantic parser for complicated queries given user clarifications.",
      "startOffset" : 199,
      "endOffset" : 516
    }, {
      "referenceID" : 3,
      "context" : "While cognitive load has not been measured specifically for complicated questions, there have been many studies linking increased sentence complexity to longer reading times (Hale, 2006; Levy, 2008; Frank, 2013). To be released at http://aka.ms/sqa analysis described in Zettlemoyer and Collins (2009), where conversations between customers and travel agents are mapped to logical forms after resolving referential expressions. Another dataset of travel booking conversations is used by Artzi and Zettlemoyer (2011) to learn a semantic parser for complicated queries given user clarifications. More recently, Long et al. (2016) collect three contextual semantic parsing datasets (from synthetic domains) that contain coreferences to entities and actions.",
      "startOffset" : 199,
      "endOffset" : 628
    }, {
      "referenceID" : 7,
      "context" : "A follow-up work (Lacatusu et al., 2006) proposes syntax-based heuristics to automatically decompose complex questions into simpler ones.",
      "startOffset" : 17,
      "endOffset" : 40
    }, {
      "referenceID" : 5,
      "context" : "For example, the system of Harabagiu et al. (2005) includes a module that predicts what a user will ask next given their current question.",
      "startOffset" : 27,
      "endOffset" : 51
    } ],
    "year" : 2016,
    "abstractText" : "Recent work in semantic parsing for question answering has focused on long and complicated questions, many of which would seem unnatural if asked in a normal conversation between two humans. In an effort to explore a conversational QA setting, we present a more realistic task: answering sequences of simple but inter-related questions. We collect a dataset of 6,066 question sequences that inquire about semi-structured tables from Wikipedia, with 17,553 question-answer pairs in total. Existing QA systems face two major problems when evaluated on our dataset: (1) handling questions that contain coreferences to previous questions or answers, and (2) matching words or phrases in a question to corresponding entries in the associated table. We conclude by proposing strategies to handle both of these issues.",
    "creator" : "LaTeX with hyperref package"
  }
}