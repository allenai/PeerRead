{
  "name" : "1510.02951.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "On oblivious branching programs with bounded repetition that cannot efficiently compute CNFs of bounded treewidth",
    "authors" : [ "Igor Razgon" ],
    "emails" : [ "igor@dcs.bbk.ac.uk" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Ordered Binary Decision Diagrams obdds is a famous representation of Boolean functions being actively investigated from both applied and theoretical perspective. The theoretical research, among other things, has resulted in many upper and lower bounds of obdd size realizing various classes of functions [14].\nOne such an upper bound, established in [7] states that a cnf of treewidth k of its primal graph can be represented by an obdd of size O(nk). In terms of parameterized complexity, this is an xp upper bound, that is the degree of the polynomial depends on k. A natural open question is whether this upper bound can be improved to an fpt upper bound, i.e. one of the form f(k) ∗ nc, where c is a universal constant.\nThis question is of a particular interest in the area of knowledge compilation because of the recent introduction of Sentential Decision Diagrams (sdds) [6] for which an fpt upper bound does hold. sdds share with obdds a number of nice properties and have a good potential to replace obdds in applications. Yet obdd-related machinery is much more developed (one reason for that is that obdds have been investigated for a much longer time) and hence it is interesting\nar X\niv :1\n51 0.\n02 95\n1v 1\n[ cs\n.C C\n] 1\nto say if this gap between upper bounds can be significantly tightened by finding a better upper bound for obdds.\nIn [12], we answered this question negatively by demonstrating that for each k ≥ 3 there is a class of cnfs of primal graph treewidth at most k for which the size of equivalent obdds is Ω(nk/4). In this paper, which can be considered as a follow-up version of [12], our motivation is to see how far the obdd can be extended so that the above lower bound would hold for that extended model in a way that the lower bound in [12] would follow as a special case. As a result, we extend obdds as follows. First, for an arbitrary (but fixed) constant c we use c-obdds instead obdd. That is, we allow each variable to occur at most c times along each computational path, however the occurrences are ordered as c concatenated copies of the same fixed permutation (in this setting the obdd is simply 1-obdd). Second, we allow the model to be non-deterministic. Roughly speaking, this means that instead of applying this restriction on a branching program, the restriction is applied on a switching and rectifier network. Third, we allow this restriction to be semantic, i.e to hold only for consistent paths that do not contain opposite occurrences of the same variables. The in-consistent paths are not constrained at all. We call the resulting model Nondeterministic Semantic c-obdd and abbreviate it c-nsobdd. In particular, we show that for each fixed k ≥ 3 there is a class of cnfs (in fact, the same class as we used in [12]) for which the smallest c-nsobdd is of size Ω(nk/(8c−4)). Clearly, the lower bound for obdds follows if we substitute c = 1.\nThe above lower bound shows that c-nsobdds are inherently different from sdd with respect to representation of cnf of bounded treewidth. Our second result shows that this difference can, in fact, be turned into a (non-parameterized) separation. In particular by, essentially, setting k to log n, we obtain a class of cnf that can be represented by polynomial size sdds but require c-nsobdd of quasipolynomial size.\nOur third result is related to the way the main lower bound is obtained. In particular, the cnfs we consider for the sake of obtaining lower bounds, correspond to undirected graphs. We introduce a graph parameter called matching width and show that the size of c-nsobdd equivalent to the considered cnf is exponential in the matching width of the corresponding graph. Then we show that there are graphs for which the matching width is Ω(log n) times larger than their treewidth. The lower bound readily follows from the combination of these results. The relationship between matching width and treewidth suggests that the former is similar to pathwdith. Our third result shows that this is indeed true, that is pathwidth and matching width are linearly related.\nThe last result might seem a little bit out of scope. The reason why we provide it in this paper is that matching width has already been used several time to obtain lower bounds [12, 11, 5]. So, it is interesting to see how it is connected to well known graph parameters. To the best of our knowledge [12] is the first paper where matching width for used for lower bounds, so a followup version of [12], seems the natural place for showing how matching width is connected to pathwidth.\nLet us overview the related work. The c-obdd have been considered in [10]\nwith exponential lower bound provided for several functions. The c-obdd model is known to be more powerful than the ordinary obdd. In particular, Theorem 7.2.2. of [14] provides a class of functions polynomial for 2-obdd and exponential even for Free Binary Decision Diagrams (fbdd) (that is, read-once branching programs). Moreover, it is known that increse of c adds computational power. In particular, it has been demonstrated in [3] that for each c ≥ 2 there is a class of functions computable by poly-size c-obdds and requiring exponential size c − 1-obdds. Interesting refinements of this hierarchy involving width of branching programs have been proposed in [1, 9].\nIt is also known that non-determinism adds power to obdd. In particular, Theorem 10.2.3. of [14] demonstrates a class of functions that can be computed by poly-size non-deterministic obdds, yet require exponential size fbdds. We are not aware of the any existing research specifically on non-deterministic cobdds. They are obviously a special case of non-deterministic read k-times branching programs and hence exponential lower bounds (e.g. [4]) apply to them. It is well known that semantic rather than syntactic restriction adds a lot of power if the obliviousness requirement is dropped. In particular, [8] demonstrates a class of functions that can be computed by poly-size semantic non-deterministic read-once branching programs but require exponential size if ‘semantic’ is replaced by ‘syntactic’. In fact, no super-polynomial lower bound is known for the former. We are not aware, however, if the semantic restriction adds any power to non-deterministic obdds. The lower bound of [12] has been generalized in [11] to a different direction than the one considered in this paper: namely the obliviousness was dropped. In particular, it has been shown that the non FPT lower bound holds for non-deterministic read-once branching programs.\nMatching width can be seen as a special case of maximum matching width introduced in [13] when the underlying tree is a caterpillar. It has been shown in [13] that maximum matching width is linearly related to the treewidth. The linear relationship between matching width and pathwdith, established in this paper, looks natural in this context.\nThe rest of the paper is structured as follows. Section 2 introduces the necessary background. Section 3 states the lower bound on c-nsobdds along with the separation from sdd. The lower is proved in Section 4. The proof of linear relationship between matching width and pathwidth is provided in Section 5."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "In this paper by a set of literals we mean one that does not contain an occurrence of a variable and its negation. For a set S of literals we denote by V ar(S) the set of variables whose literals occur in S. If F is a Boolean function or its representation by a cnf or obdd, we denote by V ar(F ) the set of variables of F . A truth assignment to V ar(F ) on which F is true is called a satisfying assignment of F . A set S of literals represents the truth assignment to V ar(S)\nwhere variables occurring positively in S (i.e. whose literals in S are positive) are assigned with true and the variables occurring negatively are assigned with false.\nA non-deterministic branching program Z is a directed acyclic graph dag with one root rt and one leaf lf . Some of the edges of Z are labelled with literals of variables. A path P of Z is consistent if it does not have two edges labelled with opposite occurrences of the same variable. This gives us possibility to define A(P ), the set of literals labelling the edges of a consistent path P . A consistent root-leaf path of Z is also called a computational path. The function F computed by Z is defined as follows. Let S be an assignment to the variables of Z. Then S is a satisfying assignment of F if and only if there is a computational path P of Z such that A(P ) ⊆ S.\nSpecial classes of non-deterministic branching programs can be defined by putting restrictions on properties of their root-leaf paths. A restriction is semantic if it is applied to computational paths only and syntactic if it is applied to all the root-leaf paths. In order to define the restriction we use in this paper, we need an additional notation.\nLet SV be a permutation of variables and let S be a sequence of literals of (some) variables occurring in SV . We say that S is ordered according to SV if for any two variables X and Y occurring in S, the occurrence of X is ordered before the occurrence of Y in S if and only if S is ordered before Y in V . For instance if SV = (X2, X4, X5, X1, X3) then (¬X4, X5,¬X3) is ordered according to SV .\nLet P, P1, P2 be paths of a directed graph G. Then P = P1 + P2 if P is obtained by appending P2 to the end of P1. For example, suppose that a path is represented by a sequence of its vertices and let P = (v1, v2, v3, v4, v5). Then P = (v1, v2, v3) + (v3, v4, v5) and also P = P + (v5) and also P = (v1) +P . This definition is naturally extended to a a decomposition of P = P1 + . . . , Pk into an arbitrary number of paths.\nWe consider a class of non-deterministic branching programs Z for which there is a permutation SV of its variables and a constant c such that each computational (that is, the restriction is semantic) path P of Z can be represented as P = P1, . . . , Pc so that on each Pi each variable occurs at most once and the sequence of literals labelling the edges along Pi is ordered according to SV .\nWe call this class of branching programs Nondeterministic Semantic c-obdd and abbreviate it c-nsobdd. Notice that the ordering imposed on computational paths is more restrictive than the one imposed on read-c-times oblivious branching programs. Indeed, in the latter case, variables can occur along a path in an arbitrary (though the same for all paths) order. In our case, however, the order of occurrences is determined by concatenation of c copies of the same permutation of variables.\nGiven a cnf F , its primal graph has the set of vertices corresponding to the variables of F . Two vertices are adjacent if and only if there is a clause of F where the corresponding variables both occur.\nGiven a graph G, its tree decomposition is a pair (T,B) where T is a tree and B is a set of bags B(t) corresponding to the vertices t of T . Each B(t) is a\nsubset of V (G) and the bags obey the rules of union (that is, ⋃\nt∈V (T )B(t) =\nV (G)), containment (that is, for each {u, v} ∈ E(G) there is t ∈ V (t) such that {u, v} ⊆ B(t)), and connectedness (that is for each u ∈ V (G), the set of all t such that u ∈ B(t) induces a subtree of T ). The width of (T,B) is the size of the largest bag minus one. The treewidth of G is the smallest width of a tree decomposition of G. If T is a path then (T,B) is a path decomposition The pathwidth of a graph is the smallest width of its path decomposition.\nV2 V3\nV4 V5 V6 V7\nV1\nFigure 1 shows a graph and its tree decomposition. The width of this tree decomposition is 2 since the size of the largest bag is 3."
    }, {
      "heading" : "3 Lower bound parameterized by treewidth",
      "text" : "In this section, given two integers r and k, we define a class of cnfs, roughly speaking, based on complete binary trees of height r where each node is associated with a clique of size k. Then we prove that the treewidth of the primal graphs of cnfs of this class is linearly bounded by k. Further on, we state the main technical theorem (proven in the next section) that claims that the smallest c-nsobdd size for cnfs of this class exponentially depends on rk. Finally, we re-interpret this lower bound in terms of the number of variables and the treewidth to get the lower bound announced in the Introduction.\nLet G be a graph. A graph based cnf denoted by CNF (G) is defined as follows. The set of variables consists of variables Xu for each u ∈ V (G) and variables Xu,v = Xv,u for each {u, v} ∈ E(G). The set of clauses consists of clauses Cu,v = Cv,u = (Xu∨Xu,v ∨Xv) for each {u, v} ∈ E(G). In other words, the variables of CNF (G) correspond to the vertices and edges of G. The clauses correspond to the edges of G.\nDenote by Tr a complete binary tree of height r. Let CTr,k be the graph obtained from Tr by associating each vertex with a clique of size k and, for each edge {u, v} of Tr, making all the vertices of the cliques associated with u and v\nmutually adjacent. Denote CNF (CTr,k) by Fr,k.\nFigure 2 shows T2 and CT2,3. To avoid shading the picture of CT2,3 with many edges, the cliques corresponding to the vertices of T2 are marked by circles and the bold edges between the circles mean that that there are edges between all pairs of vertices of the corresponding cliques.\nLemma 1 Let k ≥ 2. Then the treewidth of the primal graph of Fr,k is at most 2k − 1.\nProof. The primal graph of Fr,k can be obtained from CTr,k by adding one vertex ve for each edge e of CTr,k and making this vertex adjacent to the ends of e. Let (T,B) be a tree decomposition of CTr,k of size at most 2k − 1. For each vertex ve, add a new vertex x to T adjacent to the vertex whose bag contains the ends of e. Associate with x a bag containing ve and the ends of e. It is not hard to see that as a result we obtain a tree decomposition of the primal graph of Fr,k. Also, as the size of each new bag is 3 and k ≥ 2, the width of the tree decomposition remains at most 2k − 1. So, it remains to show that the treewidth of CTr,k is at most 2k − 1.\nConsider the following tree decomposition (T,B) of CTr,k. T is just Tr. We look upon Tr as a rooted tree, the centre of Tr being the root. The bag B(u) of each node u contains the clique of CTr,k corresponding to u. In addition, if u is not the root vertex then B(u) also contains the clique corresponding to the parent of u. Observe that (T,B) satisfies the connectivity property. Indeed, each vertex appears in the bag corresponding to its ‘own’ clique and the cliques of its children. Clearly, the set of nodes corresponding to the bags induce a connected subgraph. The rest of the tree decomposition properties can be verified straightforwardly. We conclude that (T,B) is indeed a tree decomposition of CTr,k. As the size of each bag is at most 2k, the width of (T,B) is at most 2k − 1.\nThe following is the main technical result whose proof is given in the next section.\nTheorem 1 The size of obdd computing Fr,k is at least 2 rk/(4c−2).\nThe following lemma reformulates the statement of Theorem 1 in terms of the number of variables of Fr,k and k.\nLemma 2 Let m be the number of variables of Fr,k. Then the size of c-nsobdd computing Fr,k is at least ( m 6k2 ) k/(4c−2).\nProof. Recall that Tr has 2 r+1 − 1 nodes. For each node a of Tr, Fr,k has k variables corresponding to the vertices of the clique of a plus ( k 2 ) variables corresponding to the edges of this clique. In addition, if a is a non-root node then it is associated with k2 variables connecting the clique of a with the clique of its parent. Thus each node of Tr is associated with at most k + ( k 2 ) + k2 variables\nand hence the total number of variables m ≤ (2r+1−1)∗(k+ ( k 2 ) +k2) ≤ 2r∗6k2. Thus 2r ≥ m6k2 . It follows from Theorem 1 that the size of a c-nsobdd computing Fr,k is at least 2rk/(4c−2) = (2r)k/(4c−2) ≥ ( m6k2 ) k/(4c−2) as required.\nTwo lower bound parameterized by the treewdith now easily follows.\nTheorem 2 For each p ≥ 3 there is an infinite sequence of cnfs F1, F2 . . . , of treewidth at most p of their primal graphs such that for each Fi the size of cobdd computing it is at least ( m3p2 )\np/(8c−4), where m is the number of variables of Fi. In particular, for c = 1 and every fixed p, we get the earlier obtained obdd lower bound of Ω(mp/4) as a special case.\nProof. For an odd p, consider the cnfs Fr,(p+1)/2 for all r ≥ 1 and for an even p, consider the cnfs Fr,p/2 for all r ≥ 1. By Lemma 1, the treewidth of the primal graph of Fr,(p+1)/2 is at most p and of Fr,p/2 at most p − 1. Thus the treewidth requirement is satisfied regarding these classes.\nTaking into account Lemma 2 and performing simple algebraic calculation, we observe the c-nsobdd size is lower-bounded by ( m3p2 )\np/(8c−4). Theorem 1 also allows us to separate between c-nsobdd and Sentential De-\ncision Diagrams sdd [6] for every fixed c.\nTheorem 3 There is an infinite family of functions that can be computed by SDDs of size O(n3) and for which the smallest c-NSOBDD are of size nΩ(log n) (for each fixed c)\nProof Consider functions Fr,r. Let us compute the number n of variables of Fr,r. Following the calculation as in Lemma 2, we observe that n = (2\nr+1 − 1) ∗ ( r∗(r−1)2 + r) + (2 r+1 − 2) ∗ r2 = 2r(3r2 + r)− 5r 2+r 2\nDenote 3r2 + r by p1 and 5r2+r 2 by p2. Then r = log n+p2 p1 .\nIn particular, r ≥ log n − log p1 ≥ log n − r and hence r ≥ log n/2 for a sufficiently large r. Substituting log n/2 instead r and k in the lower bound\nprovided by Theorem 1 gives us lower bound 2 log2 n 16c−4 = n log 16c−4 which is Ω(nlog n for every fixed c. On the other hand, for a sufficiently large n, r ≤ log(n + p2) ≤ log(2n) = log n + 1. By Lemma 1, the treewidth of the primal graph of Fr,r is at most 2r − 1 which is at most 2 log n+ 1 by the above upper bound. Thus, according to [6], the size of sdd for Tr,r is bounded by O(2 2lognn) = O(n3), as required."
    }, {
      "heading" : "4 Lower bound parameterized by the matching",
      "text" : "width\nThe central concept we use for the proof of Theorem 1 is that of matching width. A matching M of a graph G is a set of edges of G such that no two edges are incident to the same vertex. Let SV be a permutation of the set V = V (G) of vertices of a graph G. Let S1 be a prefix of SV (i.e. all vertices of SV \\ S1 are ordered after S1). Let us call the matching width of S1, the size of the largest matching consisting of the edges between S1 and V \\ S1 (we take the liberty to use sequences as sets, the correct use will be always clear from the context). Further on, the matching width of SV is the largest matching width of a prefix of SV . Finally the matching width of G, is the smallest matching width of a permutation of V (G).\nExample 1 Consider a path of 10 vertices v1, . . . , v10 so that vi is adjacent to vi+1 for 1 ≤ i < 10. The matching width of permutation (v1, . . . , v10) is 1 since between any suffix and prefix there is only one edge. However, the matching width of the permutation (v1, v3, v5, v7, v9, v2, v4, v6, v8, v10) is 5 as witnessed by the partition {v1, v3, v5, v7, v9} and {v2, v4, v6, v8, v10}. Since the matching width of a graph is determined by the permutation having the smallest matching width, and, since the graph has some edges, there cannot be a permutation of matching width 0, we conclude that the matching width of this graph is 1.\nThe main ‘engine’ for establishing the lower bound for Theorem 1 is the following theorem, stating a lower bound on the size of a c-nsobdd.\nTheorem 4 Let G be a graph of matching width at least t and let Z be a cnsobdd computing CNF (G). Then |Z| ≥ 2t/2c−1.\nTheorem 4 is proved in Section 4.1. In order use Theorem 4 for a proof of Theorem 1, we need an additional statement providing a lower bound on the matching width of graphs CTr,k (recall Fr,k = CNF (CTr,k)).\nTheorem 5 (Lemma 2 of [12]) For any r, the matching width of CTr,k is at least rk/2.\nNow, we are ready to prove Theorem 1\nProof of Theorem 1 According to Theorem 4, the size of Z implementing Fr,k = CNF (CTr,k) is at least 2\nt/2c−1 where t is the matching width of CTr,k Replace t by the lower bound rk/2 on the matching width of CTr,k provided by Theorem 5. The required lower bound 2rk/(4c−2) immediately follows."
    }, {
      "heading" : "4.1 Proof of Theorem 4",
      "text" : "Let SV be a permutation of the vertices of G where u precedes v if and only if Xu precedes Xv in te underlying permutation SV\n∗ of Z. We refer to SV as the permutation of V (G) corresponding to Z. Let SV P be a prefix of SV such that there is a matching M = {{u1, v1}, . . . , {ut, vt}} of G such that all of u1, . . . , ut belong to SV P and all of v1, . . . vt do not. Such a prefix exists by definition of matching width and our assumption that matching width of G is at least t.\nLet S be the set of all assignments S to the variables of CNF (G) satisfying the following conditions.\n• Each ¬Xui,vi ∈ S for 1 ≤ i ≤ t.\n• For each 1 ≤ i ≤ t, the occurrences of Xui and Xvi have distinct signs (if the former occurs positively the latter occurs negatively and if the former occurs negatively the latter occurs positively).\n• All the variables besides ⋃t\ni=1{Xui , Xui,vi , Xvi} are assigned positively.\nThen the following statements are easy to observe.\nObservation 1 1. Each S ∈ S is a satisfying assignment of S.\n2. |S| ≥ 2t.\nProof. For the first statement, note that all the clauses (Xu ∨Xu,v ∨Xv) besides (Xui ∨Xui,vi ∨Xvi) are clearly satisfied by S because Xu,v is assigned positively by construction. The clauses (Xui ∨Xui,vi ∨Xvi) are also satisfied by S because one of Xui , Xvi is assigned positively. This proves the first statement.\nThere are 2t ways to assign variables Xu1 , . . . , Xut . By definition of S each such assignment can be extended to an element of S and these elements are clearly all distinct. This proves the second statement.\nIn light of the first statement of Observation 1, for each S ∈ S we can identify a computational path PS of Z such that A(PS) ⊆ S. For each PS we are going to identify a sequence of its vertices of length at most 2c− 1 and to show that for distinct S1, S2 ∈ S, the sequences associated with PS1 and PS2 are distinct. In light of the second statement of Observation 1, it will follow that Z contains at least 2t sequences of nodes of length 2c−1. As the number of such sequences is at most |Z|2c−1, it will immediately follow that |Z| ≥ 2t/(2c−1).\nIn order to define a sequence of vertices associated with each PS , we need some preparation. Let P be an arbitrary computational path of Z and let P1, . . . , Pc be subpaths of P such that P = P1 + · · ·+Pc and the following holds for each Pi.\n• Each variable occurs at most once as a label of Pi.\n• The labels on Pi are ordered according to SV ∗.\nNote that the required P1, . . . , Pc exists according to definition of c-nsobdd. Further on, let P ′1, . . . , P ′ 2c be subpaths of P such that for each 1 ≤ i ≤ c,\nthe following holds.\n• Pi = P ′2i−1 + P ′2i.\n• For each v ∈ SV P , Xv can occur only in P ′2i−1 (not in P ′2i).\n• For each v /∈ SV P , Xv can occur only in P ′2i (not in P ′2i−1).\nNote that P ′1, . . . , P ′ 2c exists. Indeed, by definition of SV P , all the variables X1 = {Xv|v ∈ SV P} occur in SV ∗ before all the variables X2 = {Xv|v /∈ SV P}. Therefore, if both X1 and X2 occur on Pi, we can identify the last edge e of Pi labelled by a variable of X1 and let P ′ 2i−1 to be the prefix of Pi ending at the head of e. If only variables of X1 occur on Pi then let P ′ 2i−1 = Pi and P2i be the last vertex of Pi. If only variables of X2 occur on Pi then let P ′ 2i−1 be the first vertex of Pi and P ′ 2i = Pi. Finally, if no variables occur on Pi, the partition can be arbitrary. Let x1, . . . , x2c−1 be the respective ends of P ′ 1, . . . , P ′ 2c−1. We call x1, . . . , x2c−1 the separation vector of P and P ′1, . . . , P2c the decomposition of P w.r.t. x1, . . . , x2c−1. Remark. Note that there may be more than one possible P ′1, . . . , P ′ 2c satisfying the above conditions and hence P can have several separation vectors. We just pick an arbitrary one and call it the separation vector.\nThe separation vectors of paths PS are these very sequences mentioned in the proof plan above. Now we are going to prove that distinct paths PS have different separation vectors.\nLemma 3 Let S1, S2 be two distinct elements of S. Then P = PS1 and Q = PS2 have different separation vectors.\nProof. Assume that P andQ have the same separation vector (x1, . . . , x2c−1). Let ui be a variable having opposite assignments in S1 and S2. (Such a variable necessarily exists because the assignments of v1, . . . vt are determined by assignments of u1, . . . , ut. So, if the assignments if each ui has the same occurrence in both S1 and S2, the same is true regarding each vi, and hence S1 = S2, a contradiction). Assume w.l.o.g. that ui occurs negatively in S1 and positively in S2.\nLet P1, . . . , P2c and Q1, . . . , Q2c be the respective decompositions of P and Q w.r.t. to x1, . . . , x2c−1. Let PQ be the path obtained from P by replacement of each Pj with even j by Qj .\nClaim 1 PQ is a computational path.\nProof. We need only to verify that there is no variable occurring both positively and negatively on PQ. By definition of S, each variable Xu,v has the same occurrence in both S1 and S2. As A(P ) ⊆ S1 and A(Q) ⊆ S2, Xu,v cannot have distinct occurrences in A(P ) and A(Q). By definition of the decomposition w.r.t. the separation vector, a variable Xv with v ∈ SV P cannot occur in Qi with even i. It follows that in PQ, Xv can only occur on P1 ∪ . . . P2c−1 which is a subgrpah of P . As P is a computational path, it does not contain opposite literals of Xv and hence neither does P1 ∪ . . . P2c−1. Due to the same reason, a variable Xv with v /∈ SV P cannot occur on Pi with even i. It follows that in PQ Xv can only occur on Q2 ∪ . . . Q2c which is a subgrpah of Q. As Q is a computational path, it does not contain opposite literals of Xv and hence neither does Q2 ∪ . . . Q2c.\nClaim 2 A(PQ) is disjoint with {Xui , Xui,vi , Xvi}.\nProof. By definition of S Xui,vi occurs negatively in both S1 and S2 and hence it cannot occur positively in A(P ) nor in A(Q) and hence, in turn it cannot occur positively in A(PQ) composed of subpaths of P and Q. Since ui ∈ SV P , a literal of Xui cannot occur on Q2, . . . , Q2c (by definition of the decomposition w.r.t. the separation vector). If a literal of Xui occurs on P1, . . . , P2c−1 then it is an element of S1 and hence negative by assumption. Similarly, a literal of Xvi cannot occur on P1, . . . , P2c−1 (since vi /∈ SV P ). If a literal of Xvi occurs on Q2, . . . , Q2c then it is an element of S2 and hence negative (by assumption, Xui ∈ S2 and hence ¬Xvi ∈ S2 by definition of S).\nBy Claim 1 and definition of Z, an arbitrary extension of A(PQ) is a satisfying assignment of CNF (G). By Claim 2, there is an extension S of A(PQ) containing all of ¬Xui ,¬Xui,vi ,¬Xvi . However, S falsifies clause (Xui∨Xui,vi∨Xvi) existing since {ui, vi} is an edge of G. This contradiction shows that our initial assumption that P and Q have the same separation vector is incorrect and hence the lemma holds.\nProof of Theorem 4 It follows from Lemma 3 and the second statement of Observation 1 that there are at least 2t distinct separation vectors of computational paths of Z. Each separation vector is a sequence of nodes of Z. Clearly, there are at most Z2c−1 such sequences. That is 2t ≤ Z2c−1. Hence Z ≥ 2t/(2c−1), as required."
    }, {
      "heading" : "5 Matching width vs. pathwidth",
      "text" : "In this section we will show that the matching width, mw(G), of a graph G is linearly related to its pathwidth, pw(G). It particular, we will show that pw(G)/2 ≤ mw(G) ≤ pw(G) + 1.\nLet us extend our notation. The maximum matching size of a graph G is denoted by ν(G). Let SV = (v1, . . . vn) be an ordering of vertices of G. For 1 ≤ i < n, we denote {v1, . . . , vi} by V SVi and V (G) \\ V SVi by ¬V SVi . The superscript can be omitted if the ordering is clear from the context. We denote by GSVi or by Gi, if the ordering is clear from the context, the graph with the set\nof vertices V (G) and the set of edges {{u, v}|{u, v} ∈ E(G), u ∈ Vi, v ∈ ¬Vi}. In other words the edges of Gi are exactly those edges of G that have one end in Vi and one end in ¬Vi. With this notation in mind, the matching width mwSV (G) of SV can be stated as follows.\nmwSV (G) = max n i=1ν(Gi) (1)\nIf we denote by SV the set of all permutations of vertices of G then\nmw(G) = minSV ∈SVmwSV (G) (2)\nRecall that a vertex cover (VC) of graph G is a set of vertices incident to all of its edges. The smallest size of vertex cover of G is denoted by τ(G).\nObserve that each Gi is a bipartite graph because Vi and ¬Vi, partitioning its set of vertices are indepdent sets of Gi. It is well known that for a bipartite graph the size of the smallest vertex cover equals the size of maximum matching, that is ν(Gi) = τ(Gi). Hence mwSV (G) can be restated as follows\nmwSV (G) = max n i=1τ(Gi) (3)\nNow we are bready to prove an upper bound on mw(G).\nTheorem 6 For any graph G, mw(G) ≤ pw(G) + 1.\nProof. Let (P,B) be a path decomposition of G of width pw(G). Let x1, . . . , xm be the vertices of P chronologically listed as they occur along P . Recall that B = {B(x1), . . . , B(xm)} are the bags of the decomposition and the size of each bag is at most pw(G) + 1.\nNow we are going to define a permutation SV of V (G) for which we will show that mwSV (G) ≤ pw(G) + 1, which will imply the theorem because, by definition mw(G) ≤ mwSV (G).\nFor u ∈ V (G), let f(u) be the smallest number i such that u ∈ Bxi . Let SV is an arbitrary permutation of V (G) such that u <SV v whenever f(u) < f(v). It is not hard to see that such an order indeed exists. For instance, SV can be created as follows. Arbitrary order the vertices of B(x1). For each 1 < i ≤ n, suppose that the vertices B(x1) ∪ · · · ∪ B(xi−1) have been already ordered and let SV ′ be the corresponding permutation. Then create a permuation of B(x1)∪· · ·∪B(xi) by arbitrary ordering the vertices of Bxi \\SV ′ and appending them to the end of SV ′.\nWe are going to show that for each 1 ≤ i < n, B(xf(vi)) is a vertex cover of Gi that is for each {u, v} ∈ E(Gi) either u ∈ B(xf(vi)) or u ∈ B(xf(vi)). Observe that this will imply the desired statement that mwSV (G) ≤ pw(G) + 1. Indeed, by definition, there is 1 ≤ i < n such that mwSV (G) = τ(Gi). Combining with the claim we are going to prove, we will have\nmwSV (G) = τ(Gi) ≤ B(xf(vi)) ≤ pw(G) + 1 (4)\nthe first and the second inequalities follow from the definitions of τ and pathwidth, respectively.\nPick 1 ≤ i < n and let {u, v} ∈ E(Gi). Assume w.l.o.g. that u ∈ Vi and v ∈ ¬Vi. Then, by definition of SV , f(u) ≤ f(vi) and f(v) ≥ f(vi). If the equality occurs regarding any of them, say f(u) = f(vi) then, by definition of function f , u ∈ B(xf(u)) = B(xf(vi)). Thus it remains to consider the case where f(u) < f(vi) and f(v) > f(vi).\nBy the containment property of the path decomposition, there is j such that {u, v} ⊆ B(xj). By definition of f(v), f(v) ≤ j and hence f(vi) < j. To preserve the connectedness property, u must occur in all bags B(xr) for f(u) ≤ r ≤ j. In particular, since f(u) < f(vi) and f(vi) < j, u ∈ B(xf(vi)), as required.\nNext we are going to show that pw(G) ≤ 2 ∗mw(G). For this we need the following definition.\nDefinition 1 Let SV be a permutation of V (G). For each Gi, 1 ≤ i < n, let V Ci be a smallest VC of Gi. The sets V C1, . . . , V Cn−1 are called settled w.r.t. SV if for each 1 ≤ i < n− 1, V Ci ∩ ¬Vi ⊆ V Ci+1\nThe following lemma is proved in Section 5.1.\nLemma 4 For each permutation SV of V (G) there are V C1, . . . , V Cn−1 that are settled w.r.t. SV .\nNow we are ready for the theorem.\nTheorem 7 For any graph G, pw(G) ≤ 2mw(G).\nProof. Let SV = (v1, . . . , vn) be a permutation of V (G) such thatmwSV (G) = mw(G). Let V C1, . . . , V Cn−1 be the smallest VCs of G1, . . . , Gn−1, respectively, that are settled w.r.t. SV .\nOur candidate for path decomposition of width 2mw(G) is a pair (P,B) where P is a path x1, . . . , xn and B is a set of bags B(x1), . . . , B(xn) defined as follows.\n• B(x1) = V C1 ∪ {v1}.\n• For 1 < i < n, B(xi) = V Ci−1 ∪ V Ci ∪ {vi}.\n• B(xn) = V Cn−1 ∪ {vn}.\nIn the rest of the proof we demonstrate that (P,B) is indeed a path decomposition of G having width at most 2mw(G). This amounts to proving the following statements.\n• (P,B) satisfies the union property. Indeed, by construction, for 1 ≤ i ≤ n, vi ∈ B(xi).\n• (P,B) satisfies the containment property. Indeed, let {vi, vj} ∈ E(G) and assume w.l.o.g. that i < j. This means that {vi, vj} is an edge of each of Gi, . . . , Gj−1 and hence each of V Ci, . . . , V Cj−1 has a non-empty intersection with {vi, vj}.\nAssume that vj ∈ V Ci. Then, by construction, {vi, vj} ∈ B(xi), satisfying the containment property. Assume next that vi ∈ V Cj−1. Then, by construction, {vi, vj} ∈ B(xj), satisfying the containment property. If none of the above assumptions hold then vi ∈ V Ci and vj ∈ V Cj−1. It follows that there is i ≤ j′ < j − 1 such that vi ∈ V Cj′ and vj ∈ V Cj′+1. Then by construction, {vi, vj} ∈ B(xj′+1), satisfying the containment property.\n• (P,B) satisfies the connectedness property. Assume by contradiction that the connectedness property is violated. That is, there is a vertex u and i, j > i+ 1 such that u ∈ B(xi), u /∈ B(xi+1), and u ∈ B(Xj). We assume that j is smallest possible subject to this property, that is, u /∈ B(xj−1). Since u /∈ B(xi+1), u /∈ V Ci. That is u ∈ B(Xi) \\ V Ci ⊆ V Ci−1 ∪ {vi}. It follows that u ∈ Vi. Indeed, if u = vi, this follows by definition of Vi. Otherwise, notice that since V C1, . . . , V Cn are settled, V Ci−1 ∩ ¬Vi ⊆ V Ci. As we know that u /∈ V Ci, we conclude that u ∈ V Ci−1 \\ ¬Vi = V Ci−1 ∩ Vi As u /∈ V Cj−1, NGj−1(u) ⊆ V Cj−1. By Definition 1, NGj−1(u) ∩ ¬Vj ⊆ V Cj . We claim that NGj (u) ⊆ NGj−1(u) ∩ ¬Vj . This claim will imply that NGj (u) ⊆ V Cj and hence u /∈ V Cj by the minimality of V Cj (as all the neighbours of u are already there). This is a contradiction to our assumption, confirming correctness of the connectedness property. It thus remains to prove the claim.\nLet v ∈ NGj (u). As i < j and u ∈ Vi, u ∈ Vj and hence v ∈ ¬Vj . Consequently, v ∈ ¬Vj−1. As i < j − 1, u ∈ Vj−1. Thus {u, v} is an edge of G with one end in Vj−1, the other in ¬Vj−1. Hence {u, v} is an edge of Gj−1, that is v ∈ NGj−1(u) confirming the claim and the connectedness property as specified in the previous paragraph.\n• The width of (P,B) is at most 2mw(G). That is, we have to show that for each 1 ≤ i ≤ n, |B(xi)| ≤ 2mw(G) + 1. By definition, |V Ci| = τ(Gi) for 1 ≤ i < n. According to ((3)) τ(Gi) ≤ mwSV (G). Thus, in our case, |V Ci| = τ(Gi) ≤ mw(G). It follows that for 1 < i < n, |B(xi)| ≤ |V Ci−1|+ |V Ci|+1 ≤ 2mw(G)+1. Clearly, the same upper bound applies to B(x1) and B(xn)."
    }, {
      "heading" : "5.1 Proof of Lemma 4",
      "text" : "Let G = (U, V,E) be a bipartite graph with set of vertices U ∪ V and the set of edges E, all having one end in U the other end in V . In order to prove Lemma 4, we need the following three auxiliary statements.\nProposition 1 Let V C ′ be a smallest VC of a G = (U, V,E). Let X ⊆ V C ′. Let V C ′′ be a smallest VC of G \\X. Then V C ′′ ∪X is a smallest VC of G.\nProof. V C ′ \\X is a VC of G \\X. Indeed, none of the edges covered G \\X are covered by X and hence they are covered by V C ′ \\X.\nIf we assume that V C ′′∪X is not a smallest VC of G then |V C ′| < |V C ′′∪X|. That is, |V C ′ \\X|+ |X| = |V C ′| < |V C ′′ ∪X| = |V C ′′|+ |X|, from where we conclude that |V C ′ \\X| < |V C ′′|. That is, V C ′ \\X is a VC of G \\X smaller than V C ′′ in contradiction to the definition of V C ′′.\nLemma 5 Let G = (U, V,E) be a bipartite graph and let X ⊆ V be such that there is V C1, a smallest VC of G, such that X ⊆ V C1. Let Y ⊆ V . Then G\\Y has a smallest VC being a superset of X \\ Y .\nProof. Assume that the lemma is not true. Further on, assume that Y is a largest possible subset of V for which the lemma does not hold.\nLet us represent V C1 as V C ′ 1 ∪ V C ′′1 where V C ′1 consists of all vertices of V C1 incident to the edges of G \\ Y and V C ′′1 consists of all vertices incident to edges of G[U ∪ Y ]. Denote V C ′1 ∩ V C ′′1 by PR. Observe that both V C ′1 and V C ′′1 are VCs of G \\ Y and G[U ∪ Y ], respectively. Indeed, each edge e of, say G \\ Y is covered by V C but it can be covered only by a vertex of V C incident to it and this vertex belongs to V C ′1 by definition. Note also that PR ⊆ U . Indeed, an edge of G\\Y and and edge of G[U ∪Y ] cannot have a joint end that belongs to V .\nLet V C∗1 be a smallest VC of G \\ Y . Observe that PR \\ V C∗1 6= ∅. Indeed, assume the opposite, that is we assume that PR ⊆ V C∗1 . Note that V C∗1 ∪V C ′′1 is a VC of G as each edge of G is an edge of either G \\ Y or of G[U ∪ Y ]. Note further that since PR ⊆ V C∗1 , V C∗1 ∪ V C ′′1 = V C∗1 ∪ (V C ′′1 \\ PR). Now, as V C1 is a smallest VC of G by definition, |V C ′1| + |V C ′′1 \\ PR| = |V C1| ≤ |V C∗1 ∪ (V C ′′1 \\ PR)| ≤ |V C∗1 | + |V C ′′1 \\ PR| from where we conclude that |V C ′1| ≤ |V C∗1 | and hence V C ′1 is also a smallest VC of G \\ Y . However, this is a contradiction because X \\ Y ⊆ V C ′1. Thus we have confirmed that PR \\ V C∗1 6= ∅.\nLet Y ′ = NG\\Y (PR \\ V C∗1 ). Note that Y ′ is not empty as by definition of PR is element of it is incident to an edge of G \\ Y . Furthermore, as PR ⊆ U , Y ′ ⊆ V and disjoint with Y by definition. That is |Y ∪Y ′| > |Y |. By maximality of Y , there is a smallest VC V C2 of G \\ (Y ∪ Y ′) that includes X \\ (Y ∪ Y ′) as a subset. As elements of Y ′ incident to edges of G \\Y whose other ends are not contained in V C∗1 , Y\n′ ⊆ V C∗1 . Thus by Proposition 1, V C2 ∪ Y ′ is a smallest VC of G \\ Y . However, (X \\ Y ) = ((X \\ Y ) \\ Y ′)∪ ((X \\ Y )∩ Y ′) ⊆ V C2 ∪ Y ′ . providing contradiction to our initial assumption and completing the proof.\nLemma 6 Let G = (U, V,E) be a bipartite graph. Let Y ⊆ V and let X ⊆ U be such that X is a subset of a smallest VC of G \\ Y . Then X is a subset of a smallest VC of G.\nProof. Let V C1 be a smallest VC of G. If X ⊆ V C1, we are done. Otherwise, we will show that there is another smallest VC of G including X as a subset.\nGiven G,V C1, and Y , let V C ′ 1, V C ′′ 1 , PR be defined as in Lemma 5.\nObserve that E(G\\V C ′′1 ) = E((G\\Y )\\PR). Indeed, if e ∈ E(G\\V C ′′1 ) then e ∈ E(G \\ Y ) (recall from the proof of Lemma 5 that V C ′′1 covers all the edges of G[U ∪ Y ]. Moreover, since PR ⊆ V C ′′1 , e ∈ E((G \\ Y ) \\ PR). Conversely, suppose that e ∈ E((G \\ Y ) \\ PR). Then e is not covered by any vertex of V C ′′1 (as all the vertices of V C ′′ 1 covering edges of G \\ Y belong to PR). Hence e ∈ G \\ V C ′′1 . Recall that PR ⊆ U . Since G \\ Y has a smallest VC including X, it follows from Lemma 5 (applied to G \\ Y with playing the role of G and Y playing the role of U for the substitution into the statement of Lemma 5) that (G\\Y )\\PR has a smallest VC V C2 including X\\PR. Employing the previous paragraph we observe that V C2 is also a smallest VC of G\\V C ′′1 . By Proposition 1, V C2∪V C ′′1 is a smallest VC of G including X because X = (X \\ PR) ∪ PR ⊆ V C2 ∪ V C ′′1 as required.\nProof of Lemma 4. Let V C1 be an arbitrary smallest VC of G1. For 1 ≤ i < n, having constructed V Ci, we construct V Ci+1\nFirst we observe that Gi \\ vi+1 = Gi+1 \\ vi+1. By Theorem 5, Gi \\ vi+1 has a smallest VC including (V Ci ∩ ¬Vi) \\ {vi+1} = V Ci ∩ ¬Vi+1. Next, by Theorem 6, Gi+1 has a smallest VC including V Ci ∩ ¬Vi+1. Set V Ci+1 to be such a smallest VC. This construction guarantees the required property for all i."
    } ],
    "references" : [ {
      "title" : "Extension of the hierarchy for k-obdds of small width",
      "author" : [ "Fardid M. Ablayev", "Kamil R. Khadiev" ],
      "venue" : "Russian Mathematics,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2013
    }, {
      "title" : "The pathwidth and treewidth of cographs",
      "author" : [ "Hans L. Bodlaender", "Rolf H. Möhring" ],
      "venue" : "SIAM J. Discrete Math.,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1993
    }, {
      "title" : "Hierarchy theorems for kobdds and k ibdds",
      "author" : [ "Beate Bollig", "Martin Sauerhoff", "Detlef Sieling", "Ingo Wegener" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1998
    }, {
      "title" : "On lower bounds for read-k-times branching programs",
      "author" : [ "Allan Borodin", "Alexander A. Razborov", "Roman Smolensky" ],
      "venue" : "Computational Complexity,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1993
    }, {
      "title" : "Expander cnfs have exponential DNNF size",
      "author" : [ "Simone Bova", "Florent Capelli", "Stefan Mengel", "Friedrich Slivovsky" ],
      "venue" : "CoRR, abs/1411.1995,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2014
    }, {
      "title" : "SDD: A new canonical representation of propositional knowledge bases",
      "author" : [ "Adnan Darwiche" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2011
    }, {
      "title" : "Treewidth in verification: Local vs. global",
      "author" : [ "Andrea Ferrara", "Guoqiang Pan", "Moshe Y. Vardi" ],
      "venue" : "In LPAR,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2005
    }, {
      "title" : "Boolean Function Complexity: Advances and Frontiers",
      "author" : [ "Stasys Jukna" ],
      "venue" : null,
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2012
    }, {
      "title" : "Width hierarchy for $k$-obdd of small width",
      "author" : [ "Kamil Khadiev" ],
      "venue" : "Electronic Colloquium on Computational Complexity (ECCC),",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2015
    }, {
      "title" : "Lower bounds for depth-restricted branching programs",
      "author" : [ "Matthias Krause" ],
      "venue" : "Inf. Comput.,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1991
    }, {
      "title" : "No small nondeterministic read-once branching programs for cnfs of bounded treewidth",
      "author" : [ "Igor Razgon" ],
      "venue" : "In IPEC,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2014
    }, {
      "title" : "On OBDDs for CNFs of bounded treewidth",
      "author" : [ "Igor Razgon" ],
      "venue" : "In Principles of Knowledge Representation and Reasoning(KR),",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2014
    }, {
      "title" : "New width parameters of graphs",
      "author" : [ "Martin Vatshelle" ],
      "venue" : "PhD thesis, Department of Informatics,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2012
    }, {
      "title" : "Branching Programs and Binary Decision Diagrams",
      "author" : [ "Ingo Wegener" ],
      "venue" : null,
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2000
    } ],
    "referenceMentions" : [ {
      "referenceID" : 13,
      "context" : "The theoretical research, among other things, has resulted in many upper and lower bounds of obdd size realizing various classes of functions [14].",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 6,
      "context" : "One such an upper bound, established in [7] states that a cnf of treewidth k of its primal graph can be represented by an obdd of size O(n).",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 5,
      "context" : "This question is of a particular interest in the area of knowledge compilation because of the recent introduction of Sentential Decision Diagrams (sdds) [6] for which an fpt upper bound does hold.",
      "startOffset" : 153,
      "endOffset" : 156
    }, {
      "referenceID" : 11,
      "context" : "In [12], we answered this question negatively by demonstrating that for each k ≥ 3 there is a class of cnfs of primal graph treewidth at most k for which the size of equivalent obdds is Ω(n).",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 11,
      "context" : "In this paper, which can be considered as a follow-up version of [12], our motivation is to see how far the obdd can be extended so that the above lower bound would hold for that extended model in a way that the lower bound in [12] would follow as a special case.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 11,
      "context" : "In this paper, which can be considered as a follow-up version of [12], our motivation is to see how far the obdd can be extended so that the above lower bound would hold for that extended model in a way that the lower bound in [12] would follow as a special case.",
      "startOffset" : 227,
      "endOffset" : 231
    }, {
      "referenceID" : 11,
      "context" : "In particular, we show that for each fixed k ≥ 3 there is a class of cnfs (in fact, the same class as we used in [12]) for which the smallest c-nsobdd is of size Ω(nk/(8c−4)).",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 11,
      "context" : "The reason why we provide it in this paper is that matching width has already been used several time to obtain lower bounds [12, 11, 5].",
      "startOffset" : 124,
      "endOffset" : 135
    }, {
      "referenceID" : 10,
      "context" : "The reason why we provide it in this paper is that matching width has already been used several time to obtain lower bounds [12, 11, 5].",
      "startOffset" : 124,
      "endOffset" : 135
    }, {
      "referenceID" : 4,
      "context" : "The reason why we provide it in this paper is that matching width has already been used several time to obtain lower bounds [12, 11, 5].",
      "startOffset" : 124,
      "endOffset" : 135
    }, {
      "referenceID" : 11,
      "context" : "To the best of our knowledge [12] is the first paper where matching width for used for lower bounds, so a followup version of [12], seems the natural place for showing how matching width is connected to pathwidth.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 11,
      "context" : "To the best of our knowledge [12] is the first paper where matching width for used for lower bounds, so a followup version of [12], seems the natural place for showing how matching width is connected to pathwidth.",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 9,
      "context" : "The c-obdd have been considered in [10]",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 13,
      "context" : "of [14] provides a class of functions polynomial for 2-obdd and exponential even for Free Binary Decision Diagrams (fbdd) (that is, read-once branching programs).",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 2,
      "context" : "In particular, it has been demonstrated in [3] that for each c ≥ 2 there is a class of functions computable by poly-size c-obdds and requiring exponential size c − 1-obdds.",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 0,
      "context" : "Interesting refinements of this hierarchy involving width of branching programs have been proposed in [1, 9].",
      "startOffset" : 102,
      "endOffset" : 108
    }, {
      "referenceID" : 8,
      "context" : "Interesting refinements of this hierarchy involving width of branching programs have been proposed in [1, 9].",
      "startOffset" : 102,
      "endOffset" : 108
    }, {
      "referenceID" : 13,
      "context" : "of [14] demonstrates a class of functions that can be computed by poly-size non-deterministic obdds, yet require exponential size fbdds.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 3,
      "context" : "[4]) apply to them.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "In particular, [8] demonstrates a class of functions that can be computed by poly-size semantic non-deterministic read-once branching programs but require exponential size if ‘semantic’ is replaced by ‘syntactic’.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 11,
      "context" : "The lower bound of [12] has been generalized in [11] to a different direction than the one considered in this paper: namely the obliviousness was dropped.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 10,
      "context" : "The lower bound of [12] has been generalized in [11] to a different direction than the one considered in this paper: namely the obliviousness was dropped.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 12,
      "context" : "Matching width can be seen as a special case of maximum matching width introduced in [13] when the underlying tree is a caterpillar.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 12,
      "context" : "It has been shown in [13] that maximum matching width is linearly related to the treewidth.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 5,
      "context" : "Theorem 1 also allows us to separate between c-nsobdd and Sentential Decision Diagrams sdd [6] for every fixed c.",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 5,
      "context" : "Thus, according to [6], the size of sdd for Tr,r is bounded by O(2 n) = O(n), as required.",
      "startOffset" : 19,
      "endOffset" : 22
    }, {
      "referenceID" : 11,
      "context" : "Theorem 5 (Lemma 2 of [12]) For any r, the matching width of CTr,k is at least rk/2.",
      "startOffset" : 22,
      "endOffset" : 26
    } ],
    "year" : 2015,
    "abstractText" : "In this paper we study complexity of an extension of ordered binary decision diagrams (obdds) called c-obdds on cnfs of bounded (primal graph) treewidth. In particular, we show that for each k there is a class of cnfs of treewidth k ≥ 3 for which the equivalent c-obdds are of size Ω(nk/(8c−4)). Moreover, this lower bound holds if c-obdd is nondeterministic and semantic. Our second result uses the above lower bound to separate the above model from sentential decision diagrams (sdds). In order to obtain the lower bound, we use a structural graph parameter called matching width. Our third result shows that matching width and pathwidth are linearly related.",
    "creator" : "LaTeX with hyperref package"
  }
}