{
  "name" : "1506.01186.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "No More Pesky Learning Rate Guessing Games",
    "authors" : [ "Leslie N. Smith" ],
    "emails" : [ "leslie.smith@nrl.navy.mil" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Deep convolutional neural networks (CNN) are giving state-of-the-art results for image recognition [13, 18, 16], object detection [7], face recognition [19], speech recognition [8], machine translation [17], image caption generation [21], and driverless car technology [10]. However, training a CNN is a difficult global optimization problem.\nA CNN is typically updated by stochastic gradient descent (SGD) where the parameters θ (weights) are updated by\nθt = θt−1 − t ∂L\n∂θ (1)\nwhere L is a loss function and t is the learning rate. In the book “Neural Networks: Tricks of the Trade”, the chapter “Practical recommendations for gradient-based training of deep architectures” says that the learning rate is the\nmost important hyper-parameter to optimize and if “there is only time to optimize one hyper-parameter and one uses stochastic gradient descent, then this is the hyperparameter that is worth tuning” [2]. It is well known that too small a learning rate will make a training algorithm converge slowly while too large a learning rate will make the training algorithm diverge [22]. Hence one must experiment with a variety of learning rates and schedules (i.e., the timing of learning rate changes).\nThe conventional wisdom is that the learning rate should be a single value that monotonically decreases during the training. This report demonstrates the surprising phenomenon that increasing the learning rate is overall beneficial and thus propose to let the global learning rate vary cyclically within a band of values rather than setting it to a fixed value. In addition, these cyclical learning rates (CLR) eliminate the need to tune the learning rate and achieves near optimal classification accuracy. Furthermore, unlike adaptive learning rates, the CLR meth-\nar X\niv :1\n50 6.\n01 18\n6v 1\n[ cs\n.C V\n] 3\nJ un\n2 01\nods require essentially no additional computation. The potential benefits of CLR can be seen in Figure 1, which shows the classification accuracy of the test data during training with the CIFAR-10 dataset. Here, the original fixed learning rate schedule from the Caffe CIFAR10 tutorial1 requires 60, 000 iterations to reach a plateau in accuracy (blue curve), followed by two order of magnitude drops in learning rate to reach a final accuracy of 81.4% at iteration 70, 000. Runing an exponentially declining learning rate (green curve) only attains a final accuracy of 79.1%. However, Figure 1 shows that by using the CLR method (red curve) it is possible to fully train the network within 25,000 iterations and also attain an accuracy of 81.4%. This result was obtained without fine tuning the learning rate or any other hyper-parameters (the minimum and maximum values are obtained by using a simple method described in Section 3.2.2).\nThe contributions of this report are:\n1. A methodology for setting the global learning rates for convolutional neural networks that eliminates the need to perform numerous experiments in an effort to find the best values and schedule. In addition, this way of setting the learning rate requires essentially no additional computation.\n2. A surprising phenomenon is demonstrated - allowing the learning rate to rise is overall beneficial, even though it might temporarily harm the network’s performance.\n3. In addition to the CIFAR-10 dataset, cyclical learning rates are demonstrated on ImageNet with two well-known architectures: AlexNet [13] and GoogleNet [18]."
    }, {
      "heading" : "2 Related work",
      "text" : "Practical advice on setting hyper-parameters: The book “Neural Networks: Tricks of the Trade” is a terrific source of practical advice. In particular, Yoshua Bengio [2] discusses reasonable ranges for learning rates and stresses the importance of tuning this hyper-parameter. In addition, there are many excellent chapters in this book.\nThere are also a several websites giving practical suggestions for setting the learning rates. One good example can be found in a set of slides from Geoffrey Hinton on ”Neural Networks for Machine Learning: Lecture 6” that can be found online2.\n1Parameters, hyper-parameters, and architecture can be found at caffe.berkeleyvision.org/gathered/examples/cifar10.html\n2www.cs.toronto.edu/ tijmen/csc321/slides/lecture slides lec6.pdf\nAdaptive learning rates: Adaptive learning rates involves computing a learning rate, and often a rate for each layer or parameter, based on the variance in the gradients. The work in this paper is different in that there is no computation of gradients involved but rather practical advice on setting the global learning rate.\nA review of the early work on adaptive learning rates can be found in George and Powell [6].\nDuchi et al.[5] proposed AdaGrad, which is one of the early adaptive methods that estimates the learning rates from the gradients.\nRMSProp is discussed in the slides by Geoffrey Hinton mentioned above2 [20]. RMSProp is described there as “Divide the learning rate for a weight by a running average of the magnitudes of recent gradients for that weight.” RMSProp is a fundamental adaptive learning rate method that others have built upon.\nSchaul et al.[15] discuss an adaptive learning rate based on a diagonal estimation of the Hessian of the gradients. One of the unique features of their method is that they allow their automatic method to decrease or increase the learning rate. However, their paper seems to limit the idea of increasing learning rate to non-stationary problems. On the other hand, this report demonstrates that a schedule of increasing the learning rate is a more universal rule.\nZeiler [22] describes his AdaDelta method that improves on AdaGrad based on two ideas; to limit the sum of squared gradients over all time to a window, and to make the parameter update rule consistent with a units evaluation on the relationship between the update and the Hessian.\nRecently, several papers have appeared on adaptive learning rates. Gulcehre and Bengio [9] propose an adaptive learning rate algorithm, AdaSecant, that utilizes the root mean square statistics and variance of the gradients. Dauphin et al.[3] propose an adaptive learning rate method based on estimating a diagonal equilibration preconditioner. The authors show that RMSProp [20] provides a biased estimate and go on to describe another estimator, ESGD, that is unbiased.\nKingma and Lei-Ba [12] introduce “Adam” that computes individual learning rates for different parameters from the gradients. It is designed to combine the advantages from AdaGrad and RMSProp. Bache et al.[1] propose exploiting solutions to a multi-armed bandit problem for learning rate selection.\nOnce again, adaptive learning rates are fundamentally different than CLR policies and it is anticipated that CLR can be used for the global learning rate while adaptive learning rates are used for each layer or parameter, although testing this is beyond the scope of the current work."
    }, {
      "heading" : "3 Optimal Learning Rates",
      "text" : ""
    }, {
      "heading" : "3.1 Tuning learning rates",
      "text" : "This subsection briefly elaborates on the specifics of the learning rate tuning problem discussed more generally in the Introduction.\nThe difficulty with manually tuning the learning rates can be illustrated with the CIFAR-10 datasetusing the Caffe [11], an open source implementation of convolutional neural networks. Caffe provides a CIFAR-10 tutorial along with the architecture, and the hyper-parameter files. If one runs the “train full.sh” command file, which uses the provided fixed learning rate of 0.001, one will obtain a curve such as the blue curve in Figure 1. The model converges quickly in the first 10, 000 iterations but convergence slows considerably through iterations 10, 000 − 60, 000. However, one can not stop the training and drop the learning rate at iteration 10, 000 because the network is still improving and some accuracy will be lost. For iterations 60, 000 − 70, 000 the learning rate is dropped twice, each time by an order of magnitude to finish up the training.\nAlternatively one can perform a series of experiments with various values of the learning rate and several schedules for dropping the learning rate in order to find the optimum learning rate schedule. In this case, one eventually discovers that the optimum initial learning rate is 0.004. Here the model quickly converges and plateaus so that in quick succession the learning rate can twice be dropped by an order of magnitude (not shown in Figure 1). Therefore, it is possible to fully train the network within 25, 000 iterations and obtain an accuracy of 81.8%. We see that CLR methods are competitive with manually tuned results. The disadvantage of tuning is that it can take dozen(s) of runs to find the best learning rates and schedule. While this is possible for a “small” dataset like CIFAR-10, manually tuning might be infeasible for larger datasets and architectures or when time and computing resources are limited."
    }, {
      "heading" : "3.2 Cyclical Learning Rates",
      "text" : "The essence of our learning rate schedule comes from the observation that increasing the learning rate can have a short term negative effect yet a longer term beneficial effect. This observation leads to idea of letting the learning rate vary within a range of values rather than adopting a fixed or exponentially decreasing value (another common learning rate policy). That is, one sets reasonable minimum and maximum boundaries and the learning rate cyclically varies between these values. Experiments with similarly numerous functional forms, such as a triangular window (linear), a Welch window (parabolic) and a Hann\nwindow (sinusoidal) all produced equivalent results This lead to adopting a triangular window (linearly increasing then linearly decreasing) as the simplest function that incorporates this idea, which is illustrated in Figure 2. The rest of this paper refers to this as the triangular learning rate policy.\nAn intuitive understanding of why CLR methods work comes from considering the loss function topology. Dauphin et al.[21] argue that the difficulty in minimizing the loss arises from saddle points rather than poor local minima. Saddle points have small gradients that slow the learning process. However, increasing the learning rate allows more rapid traversal of saddle point plateaus. A more practical reason why CLR works is that by following the methods in Section 3.2.2 it is likely the optimum learning rate will be between the bounds and near optimal learning rates will often be used during the training.\nImplementation of the code for a new learning rate policy in Caffe is straightforward. The main code modifications were in the GetLearningRate function, which is in the solver.cpp file. An example of the code added is: } e l s e i f ( l r p o l i c y == ” t r i a n g u l a r ” ) {\ni n t i t r = t h i s−> i t e r − t h i s−>param . s t a r t l r p o l i c y ( ) ; i n t c y c l e = i t r / ( 2∗ t h i s−>param . s t e p s i z e ( ) ) ; i f ( i t r > 0) {\nf l o a t x = ( f l o a t ) ( i t r − (2∗ c y c l e +1)∗ t h i s−>param . s t e p s i z e ( ) ) ; x = x / t h i s−>param . s t e p s i z e ( ) ; r a t e = t h i s−>param . b a s e l r ( ) + ( t h i s−>param . m a x l r ()− t h i s−>param . b a s e l r ( ) ) ∗ s t d : : max ( double ( 0 ) , ( 1 . 0 − f a b s ( x ) ) / c y c l e ) ;\n} e l s e { r a t e = t h i s−>param . b a s e l r ( ) ; }\nThis policy is named triangular and is as described\nabove, with a few new input parameters defined: start lr policy (the iteration to start the learning rate policy) and max lr (the maximum learning rate boundary). Also, in this context the existing base lr was redefined as the minimum learning rate value and stepsizewas used to define half the period or cycle length for the CLR policies. This code is an example of varying the learning rate linearly between the minimum (base lr) and the maximum (max lr) but this triangular policy implementation is one where the difference between the maximum and the minimum (max lr−base lr) is divided by the cycle number to ensure that the range of the learning rates should reduce to the minimum (base lr) as the convergence slows.\nThe red curve in Figure 1 shows the result of the triangular policy (described below) on CIFAR-10. To create this curve the minimum learning rate was set to 0.001 (as in the original parameter file) and the maximum was set to 0.006. Also, the cycle length (i.e., the number of iterations for the learning rate to return to the starting value) is set to 4, 000 iterations (stepsize = 2000) and one can see that the accuracy peaks at the end of each cycle then decreases slightly. The CLR accuracy at iteration 16, 000 is much better than that of the fixed learning rate, even though at this iteration the learning rate for both policies is 0.001.\nIn addition to the triangular policy, the following CLR policies were used in the experiments discussed in this report:\n1. triangular2; the same as the triangular policy except the learning rate difference is cut in half at the end of each cycle. This is the same as triangular for two cycles and afterwards the learning rate difference drops more quickly.\n2. exp range; the learning rate varies between the minimum and maximum boundaries and each boundary value declines by an exponential factor of gammaiteration.\n3. welch; the learning rate varies non-linearly between the minimum and maximum boundaries using a parabolic function.\n4. hann; the learning rate varies non-linearly between minimum and maximum boundaries using a cosine function.\nA few of the earlier policies investigated and reported only briefly are:\n1. linear; the same as triangular but there is only one cycle, followed by a fixed learning rate at base lr.\n2. decay; starts at the maximum value (max lr) and drops linearly to the minumum value (base lr), followed by a fixed learning rate at base lr. This policy\nshows that the benefits of CRL policies are not just from reducing the learning rate.\n3. exp step; Defined as:\nlearningRate = base lr∗ (1 + floor(iter/stepsize)) ∗ gammaiter\n4. exp cont; Defined as:\nlearningRate = base lr∗ (1 + iter/stepsize) ∗ gammaiter\nThese policies were less flexible, hence only a limited number of experiments were run during this investigation.\nTo run any of the new CLR policies, several input parameters need to be specified in the solver.prototxt file. These parameters are: base lr (either the initial or minimum learning rate), max lr (maximum learning rate), lr policy (learning rate schedule to follow), gamma (either the exponential decay factor or step down factor for the “step” policy), stepsize (either half the cycle length or number of iterations for each “step”), and start lr policy (the iteration number to start the specified policy). Examples of the solver.prototxt file are given in Section 4.\nThere are several reasonable questions the interested reader might ask regarding how to set the hyperparameters for the CLR methods. The next subsections address some of these questions.\n3.2.1 How can one estimate a good value for stepsize?\nThe length of a cycle and stepsize can be easily computed from the number of iterations in an epoch. An epoch is calculated by dividing the number of training images by the batchsize used in Caffe’s architecture file. For example, CIFAR-10 has 50, 000 training images and the batchsize is 100 so an epoch = 50, 000/100 = 500 iterations.\nExperiments show that it seems best to set stepsize equal to 2 − 8 times the number of iterations in an epoch but the final results are actually quite robust to stepsize. For example, setting stepsize = 8 ∗ epoch with the CIFAR-10 training run only gives slightly better results than setting stepsize = 2 ∗ epoch.\nFurthermore, there is a certain elegance to the rhythm of these cycles and it simplifies the decision of when to drop learning rates and when to stop the current training run (i.e., max iter in Caffe). Experiments show that 6∗ stepsize number of iterations (3 cycles) trains the network weights most of the way and it is a good point for dropping the learning rates. However, if you have the time\nand resources to more fully optimize your network, running for 4 cycles will get you more performance. In addition, it is best that max iter is set to the end of a cycle, which is when the learning rate is at the minimum value and the accuracy is at a peak. Setting max iter to 6 ∗ stepsize or 8 ∗ stepsize iterations works well for the triangular and triangular2 policies.\nWhen performing restarts to drop the learning rate, it is worthwhile to reduce the stepsize because the network parameters require fewer iterations to reach a convergence plateau and the rule of thumb of 6 ∗ stepsize number of iterations still holds. An example of this is given for AlexNet in Section 4."
    }, {
      "heading" : "3.2.2 How can one estimate reasonable minimum and maximum boundary values?",
      "text" : "There is a simple way to estimate reasonable minimum and maximum boundaries with one training run of the network for a few epochs. This alleviates the need to experimentally find these boundary values. Do this by running your model for 4−8 epochs (these are typically iterations of high convergence) while letting the learning rate vary linearly from a reasonably low value to a reasonably high value. If one has experience with one’s dataset and model, one typically has some idea of the approximate range that will be appropriate (and if not, one can repeat this exercise twice; once for low values such as 0.0001− 0.01 and again for higher values such as 0.01− 0.1).\nThe triangular learning rate policy provides a mechanism to do this. Set base lr to the minimum value and set max lr to the maximum value. Set both the stepsize and max iter to the number corresponding to 4−8 epochs. In this case, the learning rate will increase linearly from the minimum value to the maximum value during this short run. Next, plot the accuracy versus learning rate (a simple computation from the iteration number). Then note the learning rate value when the accuracy starts to increase and when the accuracy slows, becomes ragged, or starts to fall. These two learning rates are good choices for bounds; that is, set base lr to the first value and set max lr to the latter value. Also, one can use the rule of thumb that the optimum learning rate is usually within a factor of two of the largest one that converges [2] and set base lr to 13 or 1 4 of max lr.\nFigure 3 shows an example of making this type of run with the CIFAR-10 dataset, using the architecture and hyper-parameters provided by Caffe.3 One can see from Figure 3 that the model starts converging right away, so 0.001 is a reasonable minimum learning rate. Furthermore, above a learning rate of 0.006 the accuracy rise gets\n3caffe.berkeleyvision.org/gathered/examples/cifar10.html\nrough and eventually begins to drop so it is reasonable to set max lr = 0.006.\nThis same exercise for choosing a learning rate range can be performed at restarts when the learning rate value is reduced.\n3.2.3 How can one estimate a good value for gamma?\nThe hyper-parameter gamma is used in the original Caffe exp learning rate policies but there doesn’t appear to be any guidance on setting it. Here I offer a rule of thumb for setting it when using it with exponentially declining policies, such as exp or the new exp range.\nThe learning rate is computed for exp as rate = base lr ∗ gammaiter where iter is the iteration number. Since one wants the learning rate to decline very slowly with iteration number iter, gamma needs to be set close to 1. Experiments show it is reasonable to have the learning rate reduce in the range 0.1 − 0.05 in the number of iterations corresponding to about 25 epochs. If you want to maximize the performance of your network, you can let the learning rate decline even more slowly by using 50 or more epochs. With this information, one computes as gamma = iter √ 0.1, where iter is the number of iterations in your chosen number of epochs. This rule of thumb might not be universally applicable but it is often useful."
    }, {
      "heading" : "4 Results",
      "text" : "The purpose of this section is to demonstrate the effectiveness of the CLR methods on some standard datasets. In the subsections below, CLR policies are used for training with the CIFAR-10 dataset and the AlexNet [13] and GoogleNet [18] architectures with the ImageNet dataset. These three cases cover a range of data and architecture sizes.\nThe subsections attempt to answer several questions. Some of these questions are:\n1. How do the CLR policies compare to using the original fixed or exp learning rate policies?\n2. Are the guidelines described above for the hyperparameters stepsize, max lr, base lr, and gamma valid?\n3. Is it better to use a triangular or exp range policy?\nAll of the following experiments were run with Caffe using Cuda 7.0 and Nvidia’s CuDNN. The CIFAR-10 and AlexNet experiments ran on Titan GPU’s with 6 GB of memory while the GoogLeNet architecture required running on K40’s with 12GB of memory."
    }, {
      "heading" : "4.1 CIFAR-10",
      "text" : "The Caffe website provides a CIFAR-10 tutorial that for this report is assumed to be a fairly standard architecture and hyper-parameter settings. These architecture and hyper-parameter files are available from the website and were used here as a baseline.\nThe CIFAR-10 architecture and hyper-parameter settings on the Caffe website is fairly standard and were used here as a baseline. As discussed in Section ??, an epoch is equal to 500 iterations and good a setting for stepsize is 2, 000. Section 3.2.2 discussed how to estimate reasonable minimum and maximum boundary values for the learning rate from Figure 3. The recommendation is to set base lr = 0.001 and max lr = 0.006. This is all that is needed to optimally train the network. For the triangular policy run in shown in Figure 1, the stepsize and learning rate bounds are shown in Table 1.\nThe full solver.prototxt file for the triangular learning rate policy is:\nn e t : ” examples / c i f a r 1 0 / t r a i n t e s t 1 . p r o t o t x t ” t e s t i t e r : 100 t e s t i n t e r v a l : 100\nd i s p l a y : 100 m a x i t e r : 16000 l r p o l i c y : ” t r i a n g u l a r ” b a s e l r : 0 . 001 s t a r t l r p o l i c y : 0 m a x l r : 0 . 005 momentum : 0 . 9 w e i g h t d e c a y : 0 .004 s t e p s i z e : 2000 s n a p s h o t : 16000 s n a p s h o t p r e f i x : ” s n a p s h o t s / t r i a n g u l a r ” s o l v e r m o d e : GPU\nAs indicated in Table 1, Figure 1 shows the results of running with the triangular policy for four cycles (until iteration 16, 000), then resuming for three cycles (until iteration 22, 000) with a smaller learning rate range, and resuming again for three cycles (until iteration 25, 000) with an even smaller learning rate range. As shown in Table 2, one obtains the same test classification accuracy of 81.4% after only 25, 000 iterations with the triangular policy as obtained by running the standard hyper-parameter settings for 70, 000 iterations.\nOne might speculate that the benefits from the triangular policy derives from reducing the learning rate because this is when the accuracy climbs the most. As a test, the decay policy was implemented where the learning rate starts at the max lr value then is linearly reduced to the base lr value for stepsize number of iterations. After that, the learning rate is fixed to base lr. Figure 4 shows a comparison of the triangular policy to this decay policy for 25, 000 iterations. For the decay policy, max lr = 0.007, base lr = 0.001, and\nstepsize = 4000. It is clear from Table 2 and this plot that both increasing and decreasing the learning rate are essential for the benefits of the CLR method.\nFigure 5 compares the exp learning rate policy in Caffe with the new exp range policy. The parameter file is similar as the one for triangular except that lr policy is exp range, gamma = 0.99994, and max iter = 70000. The result is that when using the exp range policy one can stop training at iteration 42, 000 with a test accuracy of 82.2% (going to iteration 70, 000 does not improve on this result). This is substantially better than the best test accuracy of 79.1% one obtains from using the exp learning rate policy.\nEarlier work on various CLR methods showed some of the promise of increasing learning rates. Figure 6 compares using the exp learning rate policy in Caffe with the an experimental exp cont policy mentioned in Section 3.2. As shown in Table 2, the exp cont policy achieves a final test accuracy of 82.7%, which is dramatically better than the exp learning rate policy test accuracy of 79.1%. In addition, the similar exp step policy produces similar results as the exp cont policy.\n/"
    }, {
      "heading" : "4.2 AlexNet",
      "text" : "ImageNet4 [14] is commonly used in many studies in the deep learning literature. Fortunately, the Caffe website provides the architecture and hyper-parameter files for a modified AlexNet5 [13]. These architecture and hyperparameter files were downloaded from the website and\n4www.image-net.org/ 5caffe.berkeleyvision.org/gathered/examples/imagenet.html\nused as a baseline. In the training results reported in this section, all weights were initialized the same so as to avoid differences due to different random initializations.\nThe number of training images provided by ImageNet for the 1, 000 class classification challenge is 1, 281, 167. Since the batchsize in the architecture file is 256, an epoch is equal to 1, 281, 167/256 = 5, 005 iterations. Hence, good settings for stepsize is 30, 000.\nNext, one can estimate reasonable minimum and maximum boundaries for the learning rate from Figure 7. It can be seen from this Figure that the training doesn’t start converging until at least 0.006 so setting base lr to 0.006 is reasonable. However, for a fair comparison to the baseline where base lr = 0.01, it is necessary to set the minimum learning rate (base lr) to 0.01 for the triangular and triangular2 policies or else the majority of the apparent improvement in the accuracy will be from the smaller learning rate. As for the maximum boundary value, the training gets rough and drops above a learning rate of 0.015 so max lr = 0.015 is reasonable. For comparing the exp range policy to the exp policy, setting base lr = 0.006 and max lr = 0.014 is reasonable and in this case one expects that the average accuracy of the exp range policy to be equal to the accuracy from the exp policy.\nAn example of the full solver.prototxt file for the exp range learning rate policy is:\nn e t : ” t r a i n v a l . p r o t o t x t ” t e s t i t e r : 1000 t e s t i n t e r v a l : 1000 l r p o l i c y : ” e x p r a n g e ” b a s e l r : 0 . 006 m a x l r : 0 . 014\ngamma : 0 .999995 s t e p s i z e : 20000 s t a r t l i n e a r : 4000 d i s p l a y : 1000 m a x i t e r : 300000 momentum : 0 . 9 w e i g h t d e c a y : 0 .0005 s n a p s h o t : 40000 s n a p s h o t p r e f i x : ” s n a p s h o t s / expRange ” s o l v e r m o d e : GPU d e v i c e i d : 1\nFigure 8 compares the results of running with the fixed versus the triangular2 policy for the AlexNet architecture. For the triangular2 policy, the the parameter settings are listed in Table 3. Here the peaks at iterations that are multiples of 60,000 should produce a classification accuracy that corresponds to the fixed policy. Indeed, the accuracy peaks at the end of a cycle for the triangular2 policy are similar to the accuracies from the standard fixed policy, which implies that the baseline learning rates are set quite well. As shown in Table 2, the final accuracies from the CLR training run are only 0.4% better than the accuracies from the fixed policy.\nFigure 9 compares the results of running with the exp\nversus the exp range policy for the AlexNet architecture. Since the minimum and maximum learning rates are set 0.004 under and over, respectively, of the base learning rate used for the exp policy, one expects the accuracies from the exp range policy to oscillate around the exp policy accuracies. Indeed, Figure 9 shows that the accuracies from the exp range policy do oscillate around the exp policy accuracies. The advantage of the exp range policy is that the accuracy of 56.5% is obtained at only iteration 300, 000 whereas the exp policy goes from 56.0% at iteration 300, 000 to 56.5% at iteration 460, 000.\nFinally, a comparison between the fixed and exp policies in Table 2 shows the fixed and triangular2 policies produce accuracies that are almost 2% better than their exponentially decreasing counterparts but it is likely that not having tuned gamma is the cause of the difference."
    }, {
      "heading" : "4.3 GoogLeNet",
      "text" : "The GoogLeNet architecture was a winning entry to the ImageNet 2014 image classification competition. Szegedy et al.[18] describe the architecture in detail but did not provide the architecture file. Fortunately, the Caffe Model Zoo website6 points to the architecture file from Princeton7 and this was used in these experiments.\nHowever, the GoogLeNet paper [18] does not state the values used for the learning rate and the hyper-parameter solver file is not available for a baseline. Not having these files is a typical situation when one is developing a new architecture or applying a CNN to a new dataset. Rather\n6https://github.com/BVLC/caffe/wiki/Model-Zoo 7vision.princeton.edu/pvt/GoogLeNet/\nthan running numerous experiments to find optimal learning rates, the base lr was set to a best guess value of 0.01 as a baseline case.\nThe first step is to estimate the stepsize setting. Since the architecture uses a batchsize of 128 an epoch is equal to 1, 281, 167/128 = 10, 009. Hence, good settings for stepsize would be 20, 000, 30, 000, or possibly 40, 000. Table 4 shows the hyper-parameter settings for the results shown in this section.\nThe next step is to estimate the bounds for the learning rate, which is found by making a run for 4 epochs where the learning rate linearly increases from 0.001 to 0.065. Figure 10 shows the result of such a run. From this figure one can see that one can use bounds between 0.01 and 0.04 and still have the model reach convergence. However, learning rates above 0.025 causes the training to have short term divergences. For both triangular2 and the exp range policies, the base lr was set to 0.01 and max lr was set to 0.026. As above, the accuracy peaks for both these learning rate policy correspond to the same learning rate value as the fixed and exp policies. Hence, the comparisons below will focus on the peak accuracies from the LCR methods.\nAn example of the full solver.prototxt file for the triangular2 learning rate policy is:\nn e t : ” t r a i n v a l g o o g l e n e t . p r o t o t x t ” t e s t i t e r : 1000 t e s t i n t e r v a l : 1000 d i s p l a y : 1000 l r p o l i c y : ” t r i a n g u l a r 2 ” b a s e l r : 0 . 0 1 m a x l r : 0 . 026 s t e p s i z e : 30000 s t a r t l r p o l i c y : 0 m a x i t e r : 180000 momentum : 0 . 9 w e i g h t d e c a y : 0 .0002 s n a p s h o t : 30000\ns n a p s h o t p r e f i x : ” s n a p s h o t s / g n t r i 2 ” s o l v e r m o d e : GPU d e v i c e i d : 1\nFigure 11 compares the results of running with the fixed versus the triangular2 policy for this architecture (due to time limitations, each training stage was not run until it fully plateaued). In this case, the peaks at the end of each cycle for the triangular2 policy produce better validation accuracies than the fixed policy. The final accuracy shows an improvement from the network trained by the triangular2 policy (Table 2) to be 1.4% better than the accuracy from the fixed policy. This demonstrates that the triangular2 policy improves on a “best guess” for a fixed learning rate.\nFigure 12 compares the results of running with the exp versus the exp range policy for this architecture. Once again, the peaks at the end of each cycle for the exp range policy produce better validation accuracies than the exp policy. Furthermore, the accuracy results after 150, 000 iterations remain above the results from the exp policy run. The final accuracy from the exp range policy (Table 2) is 2% better than from the exp policy."
    }, {
      "heading" : "5 Summary",
      "text" : "The results presented in this report demonstrate the benefits of the cyclic learning rate (CLR) methods. A short run of only a few epochs where the learning rate linearly increases is sufficient to estimate boundary learning rates for the CLR policies. Then a policy where the learning rate cyclically varies between these bounds is sufficient to obtain near optimal classification results, often with many fewer iterations. This policy is easy to run and unlike\nadaptive learning rate methods, incurs no additional computational expense.\nThis report presents several possible cyclic functions. All the functions tested gave some improvements. The triangular and exp range policies were described in the most depth because they are both simple and flexible. In addition, the cyclic nature of these methods provides natural times to drop the learning rate values (after 3 or 4 cycles) and when to stop the the training. All of these factors reduce the guesswork in setting the learning rates and make these methods practical tools for everyone who trains convolutional neural networks.\nThis work has not explored the full range of applications of the cyclic learning rate methods. In the future we plan to test these learning rate methods combined with local adaptive learning rates methods and determine if they perform well together. Furthermore, we plan to determine if equivalent policies work for training different architectures, such as recurrent neural networks. Finally, we believe that a theoretical analysis would provide an improved understanding of these methods, which will lead to improvements in the algorithms."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The author expresses his appreciation to David Aha, David Bonanno, Timothy Doster, and Emily Hand for their suggestions and helpful comments regarding this work. This work was supported by the US Naval Research Laboratory base program, Recursive Structure Learning."
    } ],
    "references" : [ {
      "title" : "Hot swapping for online adaptation of optimization hyperparameters",
      "author" : [ "K. Bache", "D. DeCoste", "P. Smyth" ],
      "venue" : "arXiv preprint arXiv:1412.6599,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2014
    }, {
      "title" : "Neural Networks: Tricks of the Trade, chapter Practical recommendations for gradient-based training of deep architectures, pages 437–478",
      "author" : [ "Y. Bengio" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2012
    }, {
      "title" : "Rmsprop and equilibrated adaptive learning rates for nonconvex optimization",
      "author" : [ "Y.N. Dauphin", "H. de Vries", "J. Chung", "Y. Bengio" ],
      "venue" : "arXiv preprint arXiv:1502.04390,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2015
    }, {
      "title" : "Identifying and attacking the saddle point problem in high-dimensional non-convex optimization",
      "author" : [ "Y.N. Dauphin", "R. Pascanu", "C. Gulcehre", "K. Cho", "S. Ganguli", "Y. Bengio" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2014
    }, {
      "title" : "Adaptive subgradient methods for online learning and stochastic optimization",
      "author" : [ "J. Duchi", "E. Hazan", "Y. Singer" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "Adaptive stepsizes for recursive estimation with applications in approximate dynamic programming",
      "author" : [ "A.P. George", "W.B. Powell" ],
      "venue" : "Machine learning,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2006
    }, {
      "title" : "Rich feature hierarchies for accurate object detection and semantic segmentation",
      "author" : [ "R. Girshick", "J. Donahue", "T. Darrell", "J. Malik" ],
      "venue" : "In Computer Vision and Pattern Recognition (CVPR),",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2014
    }, {
      "title" : "Towards end-to-end speech recognition with recurrent neural networks",
      "author" : [ "A. Graves", "N. Jaitly" ],
      "venue" : "In Proceedings of the 31st International Conference on Machine Learning",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2014
    }, {
      "title" : "Adasecant: Robust adaptive secant method for stochastic gradient",
      "author" : [ "C. Gulcehre", "Y. Bengio" ],
      "venue" : "arXiv preprint arXiv:1412.7419,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2014
    }, {
      "title" : "An empirical evaluation of deep learning on highway driving",
      "author" : [ "B. Huval", "T. Wang", "S. Tandon", "J. Kiske", "W. Song", "J. Pazhayampallil", "M. Andriluka", "R. Cheng-Yue", "F. Mujica", "A. Coates" ],
      "venue" : "arXiv preprint arXiv:1504.01716,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2015
    }, {
      "title" : "Caffe: Convolutional architecture for fast feature embedding",
      "author" : [ "Y. Jia", "E. Shelhamer", "J. Donahue", "S. Karayev", "J. Long", "R. Girshick", "S. Guadarrama", "T. Darrell" ],
      "venue" : "In Proceedings of the ACM International Conference on Multimedia,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2014
    }, {
      "title" : "Adam: a method for stochastic optimization",
      "author" : [ "D. Kingma", "J. Lei-Ba" ],
      "venue" : "arXiv preprint arXiv:1412.6980,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2015
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevsky", "I. Sutskever", "G.E. Hinton" ],
      "venue" : "Advances in neural information processing systems,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2012
    }, {
      "title" : "ImageNet Large Scale Visual  Recognition Challenge",
      "author" : [ "O. Russakovsky", "J. Deng", "H. Su", "J. Krause", "S. Satheesh", "S. Ma", "Z. Huang", "A. Karpathy", "A. Khosla", "M. Bernstein", "A.C. Berg", "L. Fei-Fei" ],
      "venue" : "International Journal of Computer Vision (IJCV),",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2015
    }, {
      "title" : "No more pesky learning rates",
      "author" : [ "T. Schaul", "S. Zhang", "Y. LeCun" ],
      "venue" : "arXiv preprint arXiv:1206.1106,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "Very deep convolutional networks for large-scale image recognition",
      "author" : [ "K. Simonyan", "A. Zisserman" ],
      "venue" : "arXiv preprint arXiv:1409.1556,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2014
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "I. Sutskever", "O. Vinyals", "Q.V. Le" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2014
    }, {
      "title" : "Going deeper with convolutions",
      "author" : [ "C. Szegedy", "W. Liu", "Y. Jia", "P. Sermanet", "S. Reed", "D. Anguelov", "D. Erhan", "V. Vanhoucke", "A. Rabinovich" ],
      "venue" : "arXiv preprint arXiv:1409.4842,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2014
    }, {
      "title" : "Deepface: Closing the gap to human-level performance in face verification",
      "author" : [ "Y. Taigman", "M. Yang", "M. Ranzato", "L. Wolf" ],
      "venue" : "In Computer Vision and Pattern Recognition (CVPR),",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2014
    }, {
      "title" : "Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude",
      "author" : [ "T. Tieleman", "G. Hinton" ],
      "venue" : "COURSERA: Neural Networks for Machine Learning,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2012
    }, {
      "title" : "Show and tell: A neural image caption generator",
      "author" : [ "O. Vinyals", "A. Toshev", "S. Bengio", "D. Erhan" ],
      "venue" : "arXiv preprint arXiv:1411.4555,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2014
    }, {
      "title" : "Adadelta: an adaptive learning rate method",
      "author" : [ "M.D. Zeiler" ],
      "venue" : "arXiv preprint arXiv:1212.5701,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 12,
      "context" : "Deep convolutional neural networks (CNN) are giving state-of-the-art results for image recognition [13, 18, 16], object detection [7], face recognition [19], speech recognition [8], machine translation [17], image caption generation [21], and driverless car technology [10].",
      "startOffset" : 99,
      "endOffset" : 111
    }, {
      "referenceID" : 17,
      "context" : "Deep convolutional neural networks (CNN) are giving state-of-the-art results for image recognition [13, 18, 16], object detection [7], face recognition [19], speech recognition [8], machine translation [17], image caption generation [21], and driverless car technology [10].",
      "startOffset" : 99,
      "endOffset" : 111
    }, {
      "referenceID" : 15,
      "context" : "Deep convolutional neural networks (CNN) are giving state-of-the-art results for image recognition [13, 18, 16], object detection [7], face recognition [19], speech recognition [8], machine translation [17], image caption generation [21], and driverless car technology [10].",
      "startOffset" : 99,
      "endOffset" : 111
    }, {
      "referenceID" : 6,
      "context" : "Deep convolutional neural networks (CNN) are giving state-of-the-art results for image recognition [13, 18, 16], object detection [7], face recognition [19], speech recognition [8], machine translation [17], image caption generation [21], and driverless car technology [10].",
      "startOffset" : 130,
      "endOffset" : 133
    }, {
      "referenceID" : 18,
      "context" : "Deep convolutional neural networks (CNN) are giving state-of-the-art results for image recognition [13, 18, 16], object detection [7], face recognition [19], speech recognition [8], machine translation [17], image caption generation [21], and driverless car technology [10].",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 7,
      "context" : "Deep convolutional neural networks (CNN) are giving state-of-the-art results for image recognition [13, 18, 16], object detection [7], face recognition [19], speech recognition [8], machine translation [17], image caption generation [21], and driverless car technology [10].",
      "startOffset" : 177,
      "endOffset" : 180
    }, {
      "referenceID" : 16,
      "context" : "Deep convolutional neural networks (CNN) are giving state-of-the-art results for image recognition [13, 18, 16], object detection [7], face recognition [19], speech recognition [8], machine translation [17], image caption generation [21], and driverless car technology [10].",
      "startOffset" : 202,
      "endOffset" : 206
    }, {
      "referenceID" : 20,
      "context" : "Deep convolutional neural networks (CNN) are giving state-of-the-art results for image recognition [13, 18, 16], object detection [7], face recognition [19], speech recognition [8], machine translation [17], image caption generation [21], and driverless car technology [10].",
      "startOffset" : 233,
      "endOffset" : 237
    }, {
      "referenceID" : 9,
      "context" : "Deep convolutional neural networks (CNN) are giving state-of-the-art results for image recognition [13, 18, 16], object detection [7], face recognition [19], speech recognition [8], machine translation [17], image caption generation [21], and driverless car technology [10].",
      "startOffset" : 269,
      "endOffset" : 273
    }, {
      "referenceID" : 1,
      "context" : "most important hyper-parameter to optimize and if “there is only time to optimize one hyper-parameter and one uses stochastic gradient descent, then this is the hyperparameter that is worth tuning” [2].",
      "startOffset" : 198,
      "endOffset" : 201
    }, {
      "referenceID" : 21,
      "context" : "It is well known that too small a learning rate will make a training algorithm converge slowly while too large a learning rate will make the training algorithm diverge [22].",
      "startOffset" : 168,
      "endOffset" : 172
    }, {
      "referenceID" : 12,
      "context" : "In addition to the CIFAR-10 dataset, cyclical learning rates are demonstrated on ImageNet with two well-known architectures: AlexNet [13] and GoogleNet [18].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 17,
      "context" : "In addition to the CIFAR-10 dataset, cyclical learning rates are demonstrated on ImageNet with two well-known architectures: AlexNet [13] and GoogleNet [18].",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 1,
      "context" : "In particular, Yoshua Bengio [2] discusses reasonable ranges for learning rates and stresses the importance of tuning this hyper-parameter.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 5,
      "context" : "A review of the early work on adaptive learning rates can be found in George and Powell [6].",
      "startOffset" : 88,
      "endOffset" : 91
    }, {
      "referenceID" : 4,
      "context" : "[5] proposed AdaGrad, which is one of the early adaptive methods that estimates the learning rates from the gradients.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 19,
      "context" : "RMSProp is discussed in the slides by Geoffrey Hinton mentioned above2 [20].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 14,
      "context" : "[15] discuss an adaptive learning rate based on a diagonal estimation of the Hessian of the gradients.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 21,
      "context" : "Zeiler [22] describes his AdaDelta method that improves on AdaGrad based on two ideas; to limit the sum of squared gradients over all time to a window, and to make the parameter update rule consistent with a units evaluation on the relationship between the update and the Hessian.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 8,
      "context" : "Gulcehre and Bengio [9] propose an adaptive learning rate algorithm, AdaSecant, that utilizes the root mean square statistics and variance of the gradients.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 2,
      "context" : "[3] propose an adaptive learning rate method based on estimating a diagonal equilibration preconditioner.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 19,
      "context" : "The authors show that RMSProp [20] provides a biased estimate and go on to describe another estimator, ESGD, that is unbiased.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 11,
      "context" : "Kingma and Lei-Ba [12] introduce “Adam” that computes individual learning rates for different parameters from the gradients.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 0,
      "context" : "[1] propose exploiting solutions to a multi-armed bandit problem for learning rate selection.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 10,
      "context" : "The difficulty with manually tuning the learning rates can be illustrated with the CIFAR-10 datasetusing the Caffe [11], an open source implementation of convolutional neural networks.",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 20,
      "context" : "[21] argue that the difficulty in minimizing the loss arises from saddle points rather than poor local minima.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 1,
      "context" : "Also, one can use the rule of thumb that the optimum learning rate is usually within a factor of two of the largest one that converges [2] and set base lr to 1 3 or 1 4 of max lr.",
      "startOffset" : 135,
      "endOffset" : 138
    }, {
      "referenceID" : 12,
      "context" : "In the subsections below, CLR policies are used for training with the CIFAR-10 dataset and the AlexNet [13] and GoogleNet [18] architectures with the ImageNet dataset.",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 17,
      "context" : "In the subsections below, CLR policies are used for training with the CIFAR-10 dataset and the AlexNet [13] and GoogleNet [18] architectures with the ImageNet dataset.",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 13,
      "context" : "ImageNet4 [14] is commonly used in many studies in the deep learning literature.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 12,
      "context" : "Fortunately, the Caffe website provides the architecture and hyper-parameter files for a modified AlexNet5 [13].",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 17,
      "context" : "[18] describe the architecture in detail but did not provide the architecture file.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 17,
      "context" : "However, the GoogLeNet paper [18] does not state the values used for the learning rate and the hyper-parameter solver file is not available for a baseline.",
      "startOffset" : 29,
      "endOffset" : 33
    } ],
    "year" : 2015,
    "abstractText" : "It is known that the learning rate is the most important hyper-parameter to tune for training deep convolutional neural networks (i.e., a “guessing game”). This report describes a new method for setting the learning rate, named cyclical learning rates, that eliminates the need to experimentally find the best values and schedule for the learning rates. Instead of setting the learning rate to fixed values, this method lets the learning rate cyclically vary within reasonable boundary values. This report shows that training with cyclical learning rates achieves near optimal classification accuracy without tuning and often in many fewer iterations. This report also describes a simple way to estimate “reasonable bounds” by linearly increasing the learning rate in one training run of the network for only a few epochs. In addition, cyclical learning rates are demonstrated on training with the CIFAR-10 dataset and the AlexNet and GoogLeNet architectures on the ImageNet dataset. These methods are practical tools for everyone who trains convolutional neural networks.",
    "creator" : "LaTeX with hyperref package"
  }
}