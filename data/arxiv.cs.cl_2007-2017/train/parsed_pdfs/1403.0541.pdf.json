{
  "name" : "1403.0541.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Representing, Reasoning and Answering Questions About Biological Pathways - Various Applications",
    "authors" : [ "Saadat Anwar" ],
    "emails" : [ "sanwar@asu.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Over the last decade high-throughput technologies, new algorithms and speed improvements have resulted in deeper knowledge about biological systems and pathways, resulting in more refined models. These refined models tend to be large and complex, making it difficult for a person to remember all aspects of it. Thus, computer models are needed to represent and analyze them. The refinement activity itself requires reasoning with a pathway model by posing queries against it and comparing the results against a real biological system. We want to model biological systems and pathways in such a way that we can answer questions about them.\nMany existing models focus on structural and/or factoid questions, relying on surface-level information that does not require understanding the underlying model. We believe these are not the kind of questions that a biologist may ask someone to test their understanding of the biological processes. We want our system to be able to answer the kind of questions a biologist may ask. So, we turned to early college level text books on biology for such questions.\nThus the main goal of our thesis is to develop a system that allows us to encode knowledge about biological pathways and answer such questions about them that demonstrate understanding of the pathway. To that end, we develop a language that will allow posing such questions and illustrate the utility of our framework with various applications in the biological domain. We use some existing tools with modifications to accomplish our goal.\nFinally, we use our question answering system in real world applications by extracting pathway knowledge from text and answering questions related to drug development.\nContents\n1 Introduction 9 1.1 Choosing the right questions . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 1.2 Choosing the right tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.3 Need for a pathway a specification and a query language . . . . . . . . . . . . 10 1.4 Text extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 1.5 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 1.6 Specific contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n1.6.1 General ASP encoding of Petri Net for simulation . . . . . . . . . . . . 12 1.6.2 Answering simulation based reasoning questions . . . . . . . . . . . . 13 1.6.3 BioPathQA: a system and a language to represent pathways and query\nthem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 1.6.4 Text Extraction to Answer Questions about Real World Applications . . 14\n1.7 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n2 Petri Net Encoding in ASP for Biological Domain 16 2.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 2.2 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n2.2.1 Answer Set Programming . . . . . . . . . . . . . . . . . . . . . . . . 17 2.2.2 Multiset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 2.2.3 Petri Net . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n2.3 Translating Basic Petri Net Into ASP . . . . . . . . . . . . . . . . . . . . . . . 22 2.3.1 An example execution . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n2.4 Changing Firing Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 2.5 Extension - Reset Arcs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 2.6 Extension - Inhibitor Arcs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 2.7 Extension - Read Arcs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 2.8 Extension - Colored Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 2.9 Translating Petri Nets with Colored Tokens to ASP . . . . . . . . . . . . . . . 33 2.10 Extension - Priority Transitions . . . . . . . . . . . . . . . . . . . . . . . . . . 36 2.11 Extension - Timed Transitions . . . . . . . . . . . . . . . . . . . . . . . . . . 37 2.12 Other Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n1\nCONTENTS 2\n2.13 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 2.14 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n3 Answering Questions using Petri Nets and ASP 40 3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 3.2 Comparing Altered Trajectories due to Reset Intervention . . . . . . . . . . . . 40 3.3 Determining Conditions Leading to an Observation . . . . . . . . . . . . . . . 44 3.4 Comparing Altered Trajectories due to Accumulation Intervention . . . . . . . 46 3.5 Comparing Altered Trajectories due to Initial Value Intervention . . . . . . . . 48 3.6 Comparing Altered Trajectories due to Inhibition Intervention . . . . . . . . . 51 3.7 Comparing Altered Trajectories due to Gradient Equilization Intervention . . . 54 3.8 Comparing Altered Trajectories due to Delay Intervention . . . . . . . . . . . 56 3.9 Comparing Altered Trajectories due to Priority and Read Interventions . . . . . 58 3.10 Comparing Altered Trajectories due to Automatic Conversion Intervention . . . 61 3.11 Comparing Altered Trajectories due to Initial Value Intervention . . . . . . . . 63 3.12 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n4 The BioPathQA System 68 4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 4.2 Description of BioPathQA . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 4.3 Syntax of Pathway Specification Language (BioPathQA-PL) . . . . . . . . . . 69 4.4 Semantics of Pathway Specification Language (BioPathQA-PL) . . . . . . . . 74\n4.4.1 Guarded-Arc Petri Net . . . . . . . . . . . . . . . . . . . . . . . . . . 75 4.4.2 Construction of Guarded-Arc Petri Net from a Pathway Specification . 78 4.4.3 Guarded-Arc Petri Net with Colored Tokens . . . . . . . . . . . . . . . 80 4.4.4 Construction of Guarded-Arc Petri Net with Colored Tokens from a\nPathway Specification with Locational Fluents . . . . . . . . . . . . . 83 4.5 Syntax of Query Language (BioPathQA-QL) . . . . . . . . . . . . . . . . . . 85 4.6 Semantics of the Query Language (BioPathQA-QL) . . . . . . . . . . . . . . . 94\n4.6.1 An Illustrative Example . . . . . . . . . . . . . . . . . . . . . . . . . 94 4.6.2 Domain Transformation due to Interventions and Initial Conditions . . 96 4.6.3 Formula Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 4.6.4 Trajectory Filtering due to Internal Observations . . . . . . . . . . . . 109 4.6.5 Query Description Satisfaction . . . . . . . . . . . . . . . . . . . . . . 113 4.6.6 Query Statement Satisfaction . . . . . . . . . . . . . . . . . . . . . . . 121 4.6.7 Example Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 4.6.8 Example Encoding with Conditional Actions . . . . . . . . . . . . . . 130 4.6.9 ASP Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132 4.6.10 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132 4.6.11 Evaluation Methodolgy . . . . . . . . . . . . . . . . . . . . . . . . . . 148\n4.7 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148 4.7.1 Comparison with π-Calculus . . . . . . . . . . . . . . . . . . . . . . . 148\nCONTENTS 3\n4.7.2 Comparison with Action LanguageA . . . . . . . . . . . . . . . . . . 148 4.7.3 Comparison with Action Language B . . . . . . . . . . . . . . . . . . 149 4.7.4 Comparison with Action Language C . . . . . . . . . . . . . . . . . . 149 4.7.5 Comparison with Action Language C+ . . . . . . . . . . . . . . . . . 150 4.7.6 Comparison with BC . . . . . . . . . . . . . . . . . . . . . . . . . . . 151 4.7.7 Comparison with ASPMT . . . . . . . . . . . . . . . . . . . . . . . . 152 4.7.8 Comparison with BioSigNet-RR . . . . . . . . . . . . . . . . . . . . . 152\n4.8 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153\n5 Text Extraction for Real World Applications 155 5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155 5.2 Extracting Relationships about Drug Interactions . . . . . . . . . . . . . . . . 156\n5.2.1 Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 5.2.2 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160\n5.3 Extracting Knowledge About Genetic Variants . . . . . . . . . . . . . . . . . . 160 5.3.1 Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161 5.3.2 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164\n5.4 Applying BioPathQA to Drug-Drug Interaction Discovery . . . . . . . . . . . 164 5.4.1 Drug Administration . . . . . . . . . . . . . . . . . . . . . . . . . . . 165 5.4.2 Drug Development . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 5.4.3 Drug Administration in Presence of Genetic Variation . . . . . . . . . 166\n5.5 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167\n6 Conclusion and Future Work 169 6.1 Pathway Extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 6.2 Pathway Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 6.3 Pathway Modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 6.4 Pathway Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172 6.5 Extend High Level Language . . . . . . . . . . . . . . . . . . . . . . . . . . . 172 6.6 Result Formatting and Visualization . . . . . . . . . . . . . . . . . . . . . . . 173 6.7 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nA Proofs of Various Propositions 174 A.1 Proof of Proposition 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183 A.2 Proof of Proposition 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191 A.3 Proof of Proposition 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202 A.4 Poof of Proposition 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213 A.5 Proof of Proposition 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225 A.6 Proof of Proposition 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237 A.7 Proof of Proposition 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248 A.8 Proof of Proposition 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\nCONTENTS 4\nB Drug-Drug Interaction Queries 282 B.1 Drug Activates Gene . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282 B.2 Gene Induces Gene . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283 B.3 Gene Inhibits Gene . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284 B.4 Drug Changes Gene Expression/Activity . . . . . . . . . . . . . . . . . . . . . 285 B.5 Drug Induces/Stimulates Gene . . . . . . . . . . . . . . . . . . . . . . . . . . 286 B.6 Drug Inhibits Gene . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288 B.7 Gene Metabolized Drug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296 B.8 Gene Regulates Gene . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299 B.9 Gene Regulate Gene (Xenobiotic Metabolism) . . . . . . . . . . . . . . . . . . 299 B.10 Negative Drug Induces/Metabolizes/Inhibits Gene . . . . . . . . . . . . . . . . 299 B.11 Negative Drug Induces Gene . . . . . . . . . . . . . . . . . . . . . . . . . . . 301 B.12 Negative Drug Inhibits Gene . . . . . . . . . . . . . . . . . . . . . . . . . . . 301 B.13 Negative Gene Metabolizes Drug . . . . . . . . . . . . . . . . . . . . . . . . . 302 B.14 Negative Gene Downregulates Gene . . . . . . . . . . . . . . . . . . . . . . . 302 B.15 Negative Gene Upregulates Gene . . . . . . . . . . . . . . . . . . . . . . . . . 303 B.16 Drug Gene Co-Occurrence . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\nList of Figures\n2.1 Petri Net graph (of sub-section of glycolysis pathway) showing places as circles, transitions as boxes and arcs as directed arrows. Places have token count (or marking) written above them, assumed 0 when missing. Arcs labels represent arc-weights, assumed 1 when missing. . . . . . . . . . . . . . . . . . . . . . . 21\n2.2 Petri Net of Fig 2.1 extended with a reset arc from dhap to tr shown with double arrowhead. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n2.3 Petri Net showing feedback inhibition arc from atp to gly1 with a bullet arrowhead. Inhibitor arc weight is assumed 1 when not specified. . . . . . . . . . . . 29\n2.4 Petri Net with read arc from h is to syn shown with arrowhead on both ends. The transition syn will not fire unless there are at least 25 tokens in h is, but when it executes, it only consumes 3 tokens. . . . . . . . . . . . . . . . . . . . 30 2.5 Petri Net with tokens of colors {e, h, h2o, nadh, nadp, o2}. Circles represent places, and rectangles represent transitions. Arc weights such as “nadh/2, h/2”, “h/2, h2o/1” specify the number of tokens consumed and produced during the execution of their respective transitions, where “nadh/2, h/2” means 2 tokens of color nadh and 2 tokens of h. Similar notation is used to specify marking on places, when not present, the place is assumed to be empty of tokens. . . . . . . 33\n2.6 An extended version of the Petri Net model from Fig. 2.5. The new transitions tq, tcytc have a duration of 2 each (shown in square brackets (“[ ]”) next to the transition). When missing, transition duration is assumed to be 1. . . . . . . . . 38\n3.1 Petri Net graph relevant to question 1. “f16bp” is the compound Fructose 1,6- biphosphate, “bpg13” is 1,3-Bisphosphoglycerate. Transition tr shown in dotted lines is added to model the elimination of dhap as soon as it is produced. . . . . 41\n3.2 Amount of “bpg13” produced in unique answer-sets produced by a 10 step simulation. The graph shows two situations, without the (dhap, tr) reset arc (normal situation) and with the reset arc (abnormal situation). The purpose of this graph is to depict the variation in the amounts of glycolysis produced in various answer sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n5\nLIST OF FIGURES 6\n3.3 Average amount of “bpg13” produced during the 10-step simulation at various time steps. The average is over all answer-sets. The graph shows two situations, without the (dhap, tr) reset arc (normal situation) and with the reset arc (abnormal situation). The divergence in “bpg13” production is clearly shown. . 43\n3.4 Minimal version of the Petri Net graph in Figure 3.1. All reactants that do not contribute to the estimation of the rate of glycolysis have been removed. . . . . 43\n3.5 Petri Net graph relevant to question 2. “fats” are fats, “prot” are proteins, “fac” are fatty acids, “sug” are sugars, “amin” are amino acids and “acoa” is ACoA. Transition “box” is the beta oxidation, “t5” is glycolysis, “t1” is fat digestion into fatty acids, and “t9” is protein deamination. . . . . . . . . . . . . . . . . . 44\n3.6 Petri Net graph relevant to question 3. “glu” is Glucose, “pyr” is Pyruvate. Transitions “gly1” represents glycolysis and “cw1” is cellular work that consumes ATP and produces AMP. Transition “gly1” is inhibited only when the number of atp tokens is greater than 4. . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n3.7 Amount of pyruvate produced from various lengths of runs. . . . . . . . . . . . 48 3.8 Petri Net graph relevant to question 4. “glu” is Glucose, “pyr” is Pyruvate, “atp”\nis ATP, “eth” is ethenol or other products of fermentation, and “o2” is Oxygen. Transitions “gly1” represents glycolysis, “res1” is respiration in presence of oxygen, “fer1” is fermentation when no oxygen is present, and “cw1” is cellular work that consumes ATP. Transition “gly1” is inhibited only when the number of atp tokens is greater than 4. . . . . . . . . . . . . . . . . . . . . . . . . . . 49\n3.9 Firing counts of glycolysis (gly1) and respiration (res1) for different simulation lengths for the petri net in Figure 3.8 . . . . . . . . . . . . . . . . . . . . . . . 50\n3.10 Petri Net graph relevant to question 5. “is” is the intermembrane space, “mm” is mitochondrial matrix, “q” is ubiquinone and “cytc” is cytochrome c. The inhibition arcs (q, t1), (q, t2) and (cytc, t3) capture the electron carrying capacities of q and cytc. Over capacity will cause backup in electron transport chain. Tokens are colored, e.g. “h:1, nadh:1” specify one token of h and nadh each. Token types are “h” for H+, “nadh” for NADH, “nadp” for NADP, “fadh2” for FADH2, “fad” for FAD, “e” for electrons, “o2” for oxygen and “h2o” for water. We remove t4 to model non-functioning protein complex IV . . . . . . . . . . . 52\n3.11 Simulation of Petri Net in Figure 3.10. In a complete model of the biological system, there will be a mechanism that keeps the quantity of H+ in check in the intermembrane space and will plateau at some point. . . . . . . . . . . . . . . 53\nLIST OF FIGURES 7\n3.12 Petri Net graph relevant to question 6. “is” is the intermembrane space, “mm” is mitochondrial matrix, “q” is ubiquinone and “cytc” is cytochrome c. Tokens are colored, e.g. “h:1, nadh:1” specify one token of h and nadh each. Token types are “h” for H+, “nadh” for NADH, “e” for electrons, “o2” for oxygen, “h2o” for water, “atp” for ATP and “adp” for ADP. We add t6, t7 to model cross domain diffusion from intermembrane space to mitochondrial matrix. One or both of t6, t7 may be enabled at a time to control the degree of permeability. The text above “t5” is an additional condition which must be satisfied for “t5” to be enabled. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\n3.13 Quantities of H+ and ATP at various run lengths and permeabilities for the Petri Net model in Figure 3.12. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n3.14 Petri Net graph relevant to question 7. “is” is the intermembrane space, “mm” is mitochondrial matrix, “q” is ubiquinone and “cytc” is cytochrome c. Tokens are colored, e.g. “h:1, nadh:1” specify one token of h and nadh each. Token types are “h” for H+, “nadh” for NADH, “e” for electrons. Numbers in square brackets below the transition represent transition durations with default of one time unit, if the number is missing. . . . . . . . . . . . . . . . . . . . . . . . . 57\n3.15 Quantities of H+ produced in the intermembrane space at various run lengths and fluidities for the Petri Net model in Figure 3.14. . . . . . . . . . . . . . . . 58\n3.16 Petri Net graph relevant to question 8. “pfk” is phosphofructokinase, “f6p” is fructose 6-phosphate, “atp” is ATP and “pfkatp” is the pfk bound with atp for allosteric regulation. Transition “t3” represents enzymic action of pfk, “t4” represents the binding of pfk with atp. The double arrowed arc represents a threshold arc, which enables “t4” when there are at least 4 tokens available at “atp”. Numbers above transitions in angular brackets represent arc priorities. . 59\n3.17 Petri Net model in Figure 3.16. . . . . . . . . . . . . . . . . . . . . . . . . . . 61 3.18 Petri Net graph relevant to question 9. “glu” represents glucose, “gly1” rep-\nresents glycolysis, “pyr” represents pyruvate, “ox1” represents oxidative phosphorylation, “nadh” represents NADH and “nadp” represents NAD+. “ox1” is removed to model stoppage of oxidation of NADH to NAD+. . . . . . . . . . . 62\n3.19 Amount of “pyr” produced by runs of various lengths of Petri Net in Figure 3.18. It shows results for both normal situation where “nadh” is recycled to “nadp” as well as the abnormal situation where this recycling is stopped. . . . . . . . . . 63\n3.20 Petri Net graph relevant to question 10. “fats” are fats, “dig” is digestion of fats, “gly” is glycerol, “fac” is fatty acid, “g3p” is Glyceraldehyde 3-phosphate, “pyr” is pyruvate, “o2” is oxygen, “nadh” is NADH, “acoa” is Acyl CoA, “atp” is ATP, “op1” is oxidative phosphorylation, “cac1” is citric acid cycle, “fer1” is fermentation, “ox1” is oxidation of pyruvate to Acyl CoA and “box1” is beta oxidation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.21 Amount of “atp” produced by runs of various lengths of Petri Net in Figure 3.20. Two situations are shown: when oxygen is in short supply and when it is abundant. 66\nLIST OF FIGURES 8\n4.1 Example of a guarded-arc Petri Net. . . . . . . . . . . . . . . . . . . . . . . . 75 4.2 Example of a guarded-arc Petri Net with colored tokens. . . . . . . . . . . . . 80 4.3 Petri Net for question 11 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 4.4 Petri Net for question 12 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 4.5 Petri Net for question 13 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126 4.6 Petri Net with colored tokens alternate for question 14 . . . . . . . . . . . . . 128 4.7 BioPathQA Implementation System Architecture . . . . . . . . . . . . . . . . 133 4.8 BioPathQA Graphical User Interface . . . . . . . . . . . . . . . . . . . . . . . 135\n5.1 This figure from Tari et al. (2010b) outlines the effects of drug A on drug B through (a) direct induction/inhibition of enzymes; (b) indirect induction/inhibition of transportation factors that regulate the drug-metabolizing enzymes. . . 158\nChapter 1\nIntroduction\nBiological organisms are composed of cells that contain numerous interconnected and interacting biochemical processes occurring simultaneously. Disruptions in the normal functionality of these processes causes diseases, which appear as symptoms (of these diseases). As a result understanding these processes is a fundamental activity in the biological domain and is prerequisite for activities such as disease diagnosis and drug discovery. One aspect of understanding the biological systems is the identification of pathways responsible for drug metabolism, diseases, and signal transduction, etc. The availability of high throughput approaches like micro-arrays, improvements in algorithms, and hardware that have come online during the last decade has resulted in significant refinement in these pathways. The pathways have become much larger in size and complexity to the degree that it is not reasonable for one person to fully retain all aspects of the pathway. As a result, computer based models of pathways are needed that allow the biologists to ask questions against them and compare them with real-world knowledge. The model should be such that it has an understanding of the pathway. Such a system would be considered intelligent and would assist the biologists in expanding the breadth of their search for new drugs and diagnoses. Source knowledge for these pathways comes from volumes of research papers published every year. Though there are a number of curated pathway resources available, they significantly lag behind the current state of the research in biology. As a result, we need a way to extract this pathway information from published text.\n1.1 Choosing the right questions\nA large body of research exists on computer modeling of biological processes and it continues to be an active area of research. However, many such models focus on surface properties, like structure; or factoid questions. Though important, we feel these systems do not test the understanding of the underlying system being modeled. We want to go beyond this surface level information and answer questions requiring deeper reasoning. We want our system to answer questions that a biology teacher expects his / her students to answer after reading the required text. So, we turned to college level biological text books for the questions that we\n9\nCHAPTER 1. INTRODUCTION 10\nfeel are more indicative of such understanding. Following questions from Reece et al. (2010) illustrate the kind of questions we are interested in answering:\n• “What would happen to the rate of glycolysis if DHAP were removed from the process of glycolysis as quickly as it was produced?”\n• “A muscle cell had used up its supply of oxygen and ATP. Explain what affect would this have on the rate of cellular respiration and glycolysis?”\nThese questions and others like it were the subject of a recent deep knowledge representation challenge1. In this thesis, we focus on questions that require reasoning over simulations.\n1.2 Choosing the right tools\nData about biological systems can be qualitative or quantitative in nature. The fully quantitative data about reaction dynamics is based on ordinary differential equations (ODEs) of reaction kinetics, which are often lacking Chaouiya (2007). Qualitative data is more prevalent. It is less precise, but tends to capture general relationships between various components of a biological pathway. Adding quantitative information to a qualitative model provides the next step in refinement of the biological pathways Heiner et al. (2004), providing better coverage of biological systems and processes. We want to use this qualitative+quantitative data for our modeling.\nTo simulate and reason with the pathways, we need tools that can model a biological pathway that contains qualitative+quantitative information, simulate the pathway and reason with the results.\n1.3 Need for a pathway a specification and a query language\nPathway information comes in various formats, such as cartoon drawings, formal graphical representations like Kohn’s Maps Kohn et al. (2006), curated databases of pathways Kanehisa and Goto (2000); Karp et al. (2002); Croft et al. (2011) and free text. The depth of this knowledge as well as its taxonomy varies with the source. Thus, a common specification language is needed. Such a language must be easy to understand and must have a well defined semantics.\nQueries are normally specified in natural language, which is vague. So, a more precise query language is needed. One could ask queries in one of the existing formal languages Gelfond and Lifschitz (1998), but that will be burdensome for a user to become fluent. As a result, we need a language that has a simple English-like syntax, but a well defined semantics, so that it does not have the vagaries of the natural language.\n1https://sites.google.com/site/2nddeepkrchallenge/\nCHAPTER 1. INTRODUCTION 11\n1.4 Text extraction\nKnowledge about biological pathways is spread over collections of published papers as nuggets of information, such as relationships between proteins; between proteins and drugs; genetic variation; and association of population groups with genetic variation; to name a few. Published research may also contain contradictory information, e.g. an earlier conjecture that was proven to be untrue in later research, or knowledge with limited amount of certainty. To extract these nuggets and to assemble them into a coherent pathway requires background knowledge, similar to other technical fields. Portions of this knowledge are published in books and online repositories. Thus, we need a method of text extraction that allows one to extract nuggets of information, consult available databases and produce knowledge about pathway that is self-consistent.\n1.5 Overview\nIn this thesis, we propose to build a system, called BioPathQA, to answer deeper reasoning questions using existing tools with modifications. To that end, we develop a language to specify pathways and queries. Our system is designed to answer reasoning questions requiring simulation. We demonstrate the applicability of our system with applications to drug development on knowledge obtained from text extraction.\nTo implement an answering system that can answer simulation based reasoning questions, we first looked for available tools that could help in this task and we found Petri Nets as providing the right level of formalism for our application. Petri Nets Peterson (1977) are a popular representation formalism used to model biological systems and to simulate them. They have been used to model and analyze the dynamic behavior as well as structural properties of biological systems. However, such analysis is usually limited to invariant determination, liveness, boundedness and reachability. To our knowledge they have not been used to answer questions similar to the aforementioned.\nIn order to represent deeper reasoning questions, we have to make extensions to the Petri Net model as the basic model lacks sufficient richness. For example, we may want to change the firing semantics to limit the state space or maximize parallel activity. Although numerous Petri Net modeling, simulation and analysis systems exist Jensen et al. (2007); Rohr et al. (2010); Kounev et al. (2006); Berthomieu* et al. (2004); Nagasaki et al. (2010); Kummer et al. (2000), we found certain limitations in the default implementation of these systems as well that prevented us from using them as is. For example, the Colored Petri Net implementation CPNtools 2 does not allow inhibitor arcs (we use to model protein inhibition); Cell Illustrator Nagasaki et al. (2010) is closed source and does not support colored tokens (we use to model locations); Snoopy Rohr et al. (2010) supports a large number of extensions, but it is unclear how one exports the simulation results for further reasoning; and most did not allow exploring all possible state evolutions of a pathway or using different firing semantics.\n2http://cpntools.org\nCHAPTER 1. INTRODUCTION 12\nTo make these extensions in an easy manner we use Answer Set Programming (ASP) Lifschitz (2008) as the language to represent and simulate Petri Nets. It allows a simple encoding of the Petri Net and can be easily extended to incorporate extensions 3. In addition, ASP allows powerful reasoning capability and the possibility of implementing additional constructs not supported by Petri Nets directly, such as the ability to filter trajectories.\nPetri Net to ASP translation has been studied before Behrens and Dix (2007); Heljanko and Niemelä (2000). However, these implementations have been limited to specific classes of Petri Nets and have different focus. For example, the Simple Logic Petri Nets Behrens and Dix (2007) do not allow numerical accumulation of the same tokens from multiple transitions to a single place and the Binary Petri Nets Heljanko and Niemelä (2000) do not allow more than one tokens at any place.\n1.6 Specific contributions\nThe research contribution of this thesis can be divided into four major parts. The first part gives a general encoding of Petri Nets in ASP, which allows easy extension by making local changes. The second part shows how the ASP encoding of Petri Nets can be used to answer simulation based reasoning questions. The third part describes the high-level language for pathway and query specification; and the system that we have developed to answer deep reasoning questions. The fourth part shows how knowledge is extracted from text of research papers, cleaned and assembled into a pathway to answer simulation based reasoning questions using our system.\n1.6.1 General ASP encoding of Petri Net for simulation\nAlthough previous work on encoding Petri Nets in ASP exists, it is limited to specific classes of Petri Nets. We present an encoding of a basic Petri Net in ASP to show it is done in an intuitive yet concise way. The default execution semantics of a Petri Net is the set-semantics, which allows a subset of transitions to fire simultaneously when ready. This can result in far too many combinations of transition firing arrangements. A simpler approach is to use the so called interleaved execution semantics, in which at most one transition fires when ready. This too can generate many firing arrangements. Biological systems are highly parallel in nature, as a result it is beneficial to model maximum parallel activity. So, we introduce a new firing semantics, called the maximal firing set semantics by extending the set semantics. In this semantics, a maximal subset of non-conflicting enabled transitions fire simultaneously when ready.\nThen, we extend the basic ASP encoding to include Petri Net extensions like reset-arcs (to model immediate consumption of any amount of substrate), inhibit-arcs (to model gene/protein inhibition), read-arcs (to model additional pre-conditions of a reaction, such as different start vs. maintenance quantity of a reactant), colored-tokens (to model quantities of different types\n3Certain commercial tools, like Cell Illustrator (http://www.cellillustrator.com) do allow exporting their model into a high level language, but we believe that a declarative language is more suited to succinctly describe the problem.\nCHAPTER 1. INTRODUCTION 13\nof substances at the same location), priority-transitions (to select between alternate metabolic paths), and timed-transitions (to model slow reactions) that allow modeling of various concepts in biological systems. We show how ASP allows us to make these extensions with small amount of local changes.\nThis component is one of the major focuses of our research. It is described in Chapter 2 and is the basis for implementation of our system to model pathways and answer questions about them.\n1.6.2 Answering simulation based reasoning questions\nWe use the encoding developed in Chapter 2 to questions in (Reece et al., 2010, Chapter 9) that were a part of the Second Deep Knowledge Representation Challenge 4. These questions are focused on the mechanism of cellular respiration and test the understanding of the student studying the material; and appear in two main forms: (i) inquiry about change of rate of a process due to a change in the modeled system, and (ii) explanation of a change due to a change in the modeled system.\nWe built Petri Net models for the situations specified in the questions, encoded them in ASP and simulated them over a period of time. For change of rate questions, we computed the rate for both nominal and modified cases and observed that they matched the responses provided with the challenge questions. For the explanation of change questions, we collected the summary of firing transitions as well as substance quantities produced at various times. This information formed the basis of our answer. We compared our results with the answers provided with the challenge questions.\nA novel aspect of our approach is that we apply the initial conditions and interventions mentioned in the questions as modifications to the pathway representation. These interventions can be considered as a generalized form of actions.\nFor certain questions, additional domain knowledge outside the source material was required. We filled this gap in knowledge as necessary. We also kept the models to a subset of the pathway for performance as well as to reduce clutter in the output that can bury the results with unnecessary details.\nThis component of our research is described in Chapter 3.\n1.6.3 BioPathQA: a system and a language to represent pathways and query them\nWe combined the techniques learned from Chapter 2, action languages, and biological modeling languages to build a question answering system that takes a pathway and a query as input. Both the pathway specification language and the query language have strict formal semantics, which allow them to be free of the vagaries of natural language, the language of the research papers as well as the query statements.\n4https://sites.google.com/site/2nddeepkrchallenge/\nCHAPTER 1. INTRODUCTION 14\nGuarded-Arc Petri Net\nSince the biological pathways are constructed of biochemical reactions, they are effected by environmental changes. Mutations within the cell can also result in conditional change in behavior of certain processes. As a result, we needed actions with conditional effects. Our Petri Net model wasn’t rich enough to model conditional actions, so we extended the Petri Nets with conditional arcs. We call this extension, the Guarded-Arc Petri Net, where a guard is a condition on an arc, which must be true for that arc to be traversed. With this extension, a Petri Net transition can have different outcomes for different markings. Our model is similar to the model in Jensen et al. (2007) in many aspects.\nThis component of our research is described in Chapter 4.\n1.6.4 Text Extraction to Answer Questions about Real World Applications\nTo apply our system to real world applications, we have to extract pathway knowledge from published papers, which are published in natural language text. For this, we use a system called the Parse Tree Query Language (PTQL) Tari et al. (2012) to nuggets of information from the abstracts published on PubMed 5. Sentences are parsed using the Link Grammar Sleator and Temperley (1993) or Stanford Parser de Marneffe and Manning (2008); with various objectclasses identified within the sentence. Unlike Information Retrieval (IR) approaches that tend to treat documents as unstructured bags-of-words, PTQL treats words (or word-groups) as sentence elements with syntactic as well as dependency relationships between them. PTQL queries combine lexical, syntactic and semantic features of sentence elements. Thus with PTQL, one can ask for the first-noun of a noun-phrase that is the direct-object of a verb-phrase for some specific verb string. To accomplish its task, PTQL performs a number of pre-processing steps on its input useful for text extraction and leverages on various existing databases. These include sentence splitting, tokenization, part-of-speech (POS) tagging, named entity recognition, entitymention normalization, cross-linking with concepts from external databases, such as Gene Ontology Camon et al. (2004) and UniProt Consortium (2012). We extract gene-gene, gene-drug, and gene-disease relationships using PTQL, assemble them into a pathway specification and reason with the extracted knowledge to determine possible drug interactions.\nFacts and relationships extracted using PTQL are further subject to filtering to remove inconsistent information. A pathway specification is then constructed from the extracted facts, which can be queried using the query specification language. We illustrate the use of our deep reasoning system by an example from the drug-drug interaction domain.\nThis component is described in Chapter 5.\n1.7 Summary\nThe main contributions of this thesis can be summarized as follows: 5http://www.ncbi.nlm.nih.gov/pubmed\nCHAPTER 1. INTRODUCTION 15\n1. Generalized Petri Net encoding in ASP, including a new maximal firing set semantics (Chapter 2)\n• An easy to extend encoding is developed, that allows adding extensions using local changes\n• A new Petri Net firing semantics, the so called maximal firing set semantics is defined, which ensures maximum possible parallel activity at any given point\n2. Answering simulation based deep reasoning questions using our ASP encoding (Chapter 3)\n• It is shown, how deep reasoning questions requiring simulation based reasoning can be answered.\n3. Developed a system called BioPathQA and a language to specify biological pathways and answer deep reasoning questions about it (Chapter 4)\n• A pathway specification language is developed, combining concepts from Petri Nets, Action Languages, and Biological Pathways\n• A query specification language is developed, which is english like, with well defined semantics, avoiding the vagaries of Natural Language\n• A description of our implementation using ASP and Python is given; and an execution trace is shown\n4. Performed text extraction to extract pathway knowledge (Chapter 5)\n• It is shown pathway knowledge is extracted and used to answer questions in the drug-drug interaction domain\nChapter 2\nPetri Net Encoding in ASP for Biological Domain\n2.1 Introduction\nPetri Net Peterson (1977) is a graphical modeling language with formal semantics used for description of distributed systems. It is named after Carl Adam Petri, who formally defined Petri Nets in his PhD thesis in the 1960’s Brauer and Reisig (2006). Petri nets have been widely used to model a wide range of systems, from distributed systems to biological pathways. The main advantages of Petri Net representation include its simplicity and the ability to model concurrent and asynchronous systems and processes.\nA variety of Petri Net extensions have been proposed in the literature, e.g. inhibitor arcs, reset transitions, timed transitions, stochastic transitions, prioritized transitions, colored petri nets, logic petri nets, hierarchical petri nets, hybrid petri nets and functional petri nets to a name a few Behrens and Dix (2007); Music (2012); Hardy and Robillard (2004).\nOur interest in Petri Nets is for representing biological pathways and simulating them in order to answer simulation based reasoning questions. We show how Petri nets can be represented in ASP. We also demonstrate how various extensions of basic Petri nets can be easily expressed and implemented by making small changes to the initial encoding. During this process we will relate the extensions to their use in the biological domain. Later chapters will show how this representation and simulation is used to answer biologically relevant questions.\nThe rest of this chapter is organized as follows: We present some background material on Answer Set Programming (ASP) and Petri Nets. Following that, we present the Answer Set encoding of a basic Petri Net. After that we will introduce various Petri Nets extensions and the relevant ASP code changes to implement such extensions.\n16\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 17\n2.2 Background\n2.2.1 Answer Set Programming\nAnswer Set Programming (ASP) is a declarative logic programming language that is based on the Stable Model Semantics Gelfond and Lifschitz (1988). It has been applied to a problems ranging from spacecrafts, work flows, natural language processing and biological systems modeling.\nAlthough ASP language is quite general, we limit ourselves to language and extensions relevant to our work.\nDefinition 1 (Term) A term is a term in the propositional logic sense.\nDefinition 2 (Literal) A literal is an atom in the propositional logic sense. A literal prefixed with not is referred to as a negation-as-failure literal or a naf-literal, with not representing negation-as-failure.\nWe will refer to propositional atoms as basic atoms to differentiate them from other atoms, such as the aggregate atoms defined below.\nDefinition 3 (Aggregate Atom) A sum aggregate atom is of the form:\nL [B0 = w0, . . . , Bm = wm] U (2.1)\nwhere, Bi are basic atoms, wi are positive integer weight terms, L,U are integer terms specifying the lower and upper limits of aggregate weights. The lower and upper limits are assumed to be −∞ and∞, if not specified.\nA count aggregate atom is a special case of the sum aggregate atom in which all weights are 1, i.e. L [B0 = 1, . . . , Bm = 1] U and it is represented by:\nL {B0, . . . , Bm} U (2.2)\nA choice atom is a special case of the count aggregate atom (2.2) in which n = m.\nDefinition 4 (ASP Program) An ASP program Π is a finite set of rules of the following form:\nA0 ← A1, . . . , Am,not B1, . . . ,not Bn,C1, . . . ,Ck. (2.3)\nwhere each A0 is either a basic atom or a choice atom, Ai and Bi are basic atoms, Ci are aggregate atoms and not is negation-as-failure.\nIn rule (2.3), {A0} is called the head of the rule, and {A1, . . . , Am, not B1, . . . , not Bn,C1, . . . , Ck} is called its tail. A rule in which A0 is a choice atom is called a choice rule. A rule without\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 18\na head is called a constraint. A rule with a basic atom as its head and empty tail is called a fact in which case the “←” is dropped.\nLet R be an ASP rule of the form (2.3) and let pos(R) = {A1, . . . , Am} represent the positive atoms, neg(R) = {B1, . . . , Bn} the negation-as-failure atoms, and agg(R) = {C1, . . . ,Ck} represent the aggregate atoms in the body of a rule R. Let lit(A) represent the set of basic literals in atom A, i.e. lit(A) = {A} if A is a basic atom; lit(A) = {B0, . . . , Bn} if A is an aggregate atom. Let C be an aggregate atom of the form (2.1) and let pos(C) = {B0, . . . , Bm} be the sets of basic positive literals such that lit(C) = pos(C).\nLet lit(R) = lit(head(R)) ∪ pos(R) ∪ neg(R) ∪⋃C∈agg(R) lit(C) for a rule R ∈ Π and lit(Π) =⋃ R∈Π lit(R) be the set of basic literals in ASP program Π.\nDefinition 5 (Aggregate Atom Satisfaction) A ground aggregate atom C of the form (2.1) is satisfied by a set of basic ground atoms S , if L ≤ ∑0≤i≤m,Bi∈S wi ≤ U and we write S |= C.\nGiven a set of basic ground literals S and a basic ground atom A, we say S |= A if A ∈ S , S |= not A if A < S . For a rule R of the form (2.3) S |= body(R) if ∀A ∈ {A1, . . . , Am}, S |= A, ∀B ∈ {B1, . . . , Bn}, S |= not B, and ∀C ∈ {C1, . . . ,Ck}, S |= C; S |= head(R) if S |= A0.\nDefinition 6 (Rule Satisfaction) A ground rule R ∈ Π is satisfied by a set of basic ground atoms S , iff, S |= body(R) implies S |= head(R). A constraint rule R ∈ Π is satisfied by set S if S 6|= body(R).\nWe define reduct of an ASP program by treating aggregate atoms in a similar way as negation-as-failure literals, since our code does not contain recursion through aggregation (which can yield non-intuitive answer-sets Son and Pontelli (2007)).\nDefinition 7 (Reduct) Let S be a set of ground basic atoms, the reduct of ground ASP program Π w.r.t. S , written ΠS is the set of rules: {p ← A1, . . . , Am. | A0 ← A1, . . . , Am, not B1, . . . , not Bn, C1, . . . , Ck. ∈ Π, p ∈ lit(A0) ∩ S , {A1, . . . , Am} ⊆ S , {B1, . . . , Bn} ∩ S = ∅, @C ∈ {C1, . . . ,Ck}, S 6|= C}.\nIntuitively, this definition of reduct removes all rules which contain a naf-literal or an aggregate atom in their bodies that does not hold in S , and it removes aggregate atoms as well as naf-literals from the body of the remaining rules.\nHeads of choice-rules are split into multiple rules containing at most one atom in their heads. The resulting reduct is a program that does not contain any aggregate atoms or negative literals. The rules of such a program are monotonic, such that if it satisfied by a set S of atoms, it is also satisfied by any superset of S .\nA deductive closure of such a (positive) monotonic program is defined as the unique smallest set of atoms S such that whenever all body atoms of a rule hold in S , the head also holds in S . The deductive closure can be iteratively computed by starting with an empty set and adding heads of rules for which the bodies are satisfied, until a fix point is reached, where no additional rules can be satisfied. (adopted from Baral (2003))\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 19\nDefinition 8 (Answer Set) A set of basic ground atoms S is an answer set of a ground ASP program Π, iff S is equal to the deductive closure of ΠS and S satisfies each rule of Π. (adopted from Baral (2003))\nClingo Specific Syntactic Elements\nThe ASP code in this thesis is in the syntax of ASP solver called clingo Gebser et al. (2011). The “←” in ASP rules is replaced by the symbol “:-”. Though the semantics of ASP are defined on ground programs, Clingo allows variables and other constructs for compact representation. We intuitively describe specific syntactic elements and their meanings below:\nComments: Text following “%” to the end of the line is treated as a comment. Interval: Atoms defined over an contiguous range of integer values can be compactly writ-\nten as intervals, e.g. p(1 .. 5) represents atoms p(1), p(2), p(3), p(4), p(5). Pooling: Symbol “;” allows for pooling alternative terms. For example, an atom p(. . . , X, . . . )\nand p(. . . ,Y, . . . ) can be pooled together into a single atom as p(. . . , X; Y, . . . ). Aggregate assignment atom: An aggregate assignment atom Q = #sum[A0 = w0, . . . , Am = wm, not Am+1 = wm+1, . . . , not An = wn] assigns the sum∑ Ai∈S ,0≤i≤m wi+ ∑ A j<S ,m+1≤n w j to Q w.r.t. a consistent set of basic ground atoms S .\nCondition: Conditions allow instantiating variables to collections of terms within aggregates, e.g. {p(X) : q(X)} instantiates p(X) for only those X that q(X) satisfies. For example, if we have p(1..5) but only q(3; 5), then {p(X) : q(X)} is expanded to {p(3), p(5)}.\nGrounding\nGrounding makes a program variable free by replacing variables with the possible values they can take. Clingo uses the grounder Gringo ? for “smart” grounding, which results in substantial reduction in the size of the program. Details of this grounding are implementation specific. We present the intuitive process of grounding below.\n1. A set of ground terms is constructed, where a ground term is a term that contains no variables.\n2. The variables are split into two categories: local and global. Local variables are the ones that appear only within an aggregate atom (minus the limits) and nowhere else in a rule. Such variables are considered local writ. the aggregate atom. All other variables are considered global.\n3. First the global variables are eliminated in the rules as follows:\n• Each rule r containing an aggregate assignment atom of the form (2.1) is replaced with set of rules r′ in which the aggregate assignment atom is is replaced with an aggregate atom with lower and upper bounds of Q for all possible substitutions of Q. This is generalized to multiple aggregate assignment atoms by repeating this step\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 20\nfor each such atom, where output of previous iteration forms the input of the next iteration.\n• Each rule r′, is replaced with the set of all rules r′′ obtained by all possible substitutions of ground terms for global variables in r.\n4. Then the local variables are eliminated in the rules by expanding conditions, such that p(. . . , X, . . . ) : d(X) are replaced by p(. . . , d1, . . . ), . . . , p(. . . , dk, . . . ) for the extent {d1, . . . , dk} of d(X). This is generalized to multiple conditions in the obvious way.\nFollowing the convention of the Clingo system, Variables in rules presented in this thesis start with capital letters while lower-case text and numbers are constants. Italicized text represents a constant term from a definition in context.\nA recent work Harrison et al. (2013) gives the semantics of Gringo with ASP Core 2 syntax Calimeri et al. (2013) using Infintary Propositional Formulas, which translate Gringo to propositional formulas with infinitely long conjunctions and disjunctions. Their approach removes the safety requirement, but the subset of Gringo presented does appear to cover assignments. Although their approach provides a way to improve our ASP encoding by removing the requirement of specifying the maximum number of tokens or running simulations until a condition holds, our simpler (limited) semantics is sufficient for the limited syntax and semantics we use.\n2.2.2 Multiset\nA multiset A over a domain set D is a pair 〈D,m〉, where m : D → N is a function giving the multiplicity of d ∈ D in A. Given two multsets A = 〈D,mA〉, B = 〈D,mB〉, A B if ∀d ∈ D : mA(d) mB(d), where ∈ {<, >,≤,≥,=}, and A , B if ∃d ∈ D : mA(d) , mB(d). Multiset sum/difference is defined in the usual way. We use the short-hands d ∈ A to represent mA(d) > 0, A = ∅ to represent ∀d ∈ D,m(d) = 0, A ⊗ n to represent ∀d ∈ D,m(d) ⊗ n, where n ∈ N, ⊗ ∈ {<, >,≤,≥,=,,}. We use the notation d/n ∈ A to represent that d appears n-times in A; we drop A when clear from context. The reader is referred to Syropoulos (2001) for details.\n2.2.3 Petri Net\nA Petri Net is a graph of a finite set of nodes and directed arcs, where nodes are split between places and transitions, and each arc either connects a place to a transition or a transition to a place. Each place has a number of tokens (called the its marking) 1. Collective marking of all places in a Petri Net is called its marking (or state). Arc labels represent arc weights. When missing, arc-weight is assumed as one, and place marking is assumed as zero.\nThe set of place nodes on incoming and outgoing arcs of a transition are called its preset (input place set or input-set) and post-set (output place set or output-set), respectively. A\n1Standard convention is to use dots in place nodes to represent the marking of the place. We use numbers for compact representation.\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 21\ntransition t is enabled when each of its pre-set place p has at least the number of tokens equal to the arc-weight from p to t. An enabled transition may fire, consuming tokens equal to arc-weight from place p to transition t from each pre-set place p, producing tokens equal to arc-weight from transition t to place p to each post-set place p.\nMultiple transitions may fire as long as they consume no more than the available tokens, with the assumption that tokens cannot be shared. Fig. 2.1 shows a representation of a portion of the glycolysis pathway as given in Reece et al. (2010). In this figure, places represent reactants and products, transitions represent reactions, and arc weights represent reactant quantity consumed or the product quantity produced by the reaction. When unspecified, arc-weight is assumed to be 1 and place-marking is assumed to be 0.\nDefinition 9 (Petri Net) A Petri Net is a tuple PN = (P,T, E,W), where, P = {p1, . . . , pn} is a finite set of places; T = {t1, . . . , tm} is a finite set of transitions, P ∩ T = ∅; E+ ⊆ T × P is a set of arcs from transitions to places; E− ⊆ P × T is a set of arcs from places to transitions; E = E+ ∪ E−; and W : E → N \\ {0} is the arc-weight function\nDefinition 10 (Marking) A marking M = (M(p1), . . . ,M(pn)) is the token assignment of each place node pi ∈ P of PN, where M(pi) ∈ N. Initial token assignment M0 : P→ N is called the initial marking. Marking at step k is written as Mk.\nDefinition 11 (Pre-set & post-set of a transition) Pre-set / input-set of a transition t ∈ T of PN is •t = {p ∈ P : (p, t) ∈ E−}, while the post-set / output-set is t• = {p ∈ P : (t, p) ∈ E+}\nDefinition 12 (Enabled Transition) A transition t ∈ T of PN is enabled with respect to marking M, enabledM(t), if ∀p ∈ •t,W(p, t) ≤ M(p). An enabled transition may fire.\nDefinition 13 (Transition Execution) A transition execution is the simulation of change of marking from Mk to Mk+1 due to firing of a transition t ∈ T of PN. Mk+1 is computed as follows:\n∀pi ∈ •t,Mk+1(pi) = Mk(pi) −W(pi, t)\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 22\n∀p j ∈ t•,Mk+1(p j) = Mk(p j) + W(t, p j)\nPetri Nets allow simultaneous firing of a set of enabled transitions w.r.t. a marking as long as they do not conflict.\nDefinition 14 (Conflicting Transitions) Given PN with marking M. A set of enabled transitions Te = {t ∈ T : enabledM(t)} of PN conflict if their simultaneous firing will consume more tokens than are available at an input place:\n∃p ∈ P : M(p) < ∑\nt∈Te∧p∈•t W(p, t)\nDefinition 15 (Firing Set) A firing set is a set Tk = {t1, . . . , tm} ⊆ T of simultaneously firing transitions that are enabled and do not conflict w.r.t. to the current marking Mk of PN.\nDefinition 16 (Firing Set Execution) Execution of a firing set Tk of PN on a marking Mk computes the new marking Mk+1 as follows:\n∀p ∈ P,Mk+1(p) = Mk(p) − ∑\nt∈Tk∧p∈•t W(p, t) + ∑ t∈Tk∧p∈t• W(t, p)\nwhere ∑ t∈Tk∧p∈•t W(p, t) is the total consumption from place p and ∑\nt∈Tk∧p∈t•W(t, p) is the total production at place p.\nDefinition 17 (Execution Sequence) An execution sequence X = M0,T0,M1,T1, . . . , Mk,Tk,Mk+1 of PN is the simulation of a firing set sequence σ = T1,T2, . . . ,Tk w.r.t. an initial marking M0, producing the final marking Mk+1. Mk+1 is the transitive closure of firing set executions, where subsequent marking become the initial marking for the next firing set.\nFor an execution sequence X = M0,T0,M1,T1, . . . ,Mk,Tk,Mk+1, the firing of T0 with respect to marking M0 produces the marking M1 which becomes the initial marking for T1, which produces M2 and so on.\n2.3 Translating Basic Petri Net Into ASP In this section we present ASP encoding of simple Petri Nets. We describe, how a given Petri Net PN, and an initial marking M0 are encoded into ASP for a simulation length k. Following sections will show how Petri Net extensions can be easily added to it. We represent a Petri Net with the following facts:\nf1: Facts place(pi). where pi ∈ P is a place. f2: Facts trans(t j). where t j ∈ T is a transition. f3: Facts ptarc(pi, t j,W(pi, t j)). where (pi, t j) ∈ E− with weight W(pi, t j). f4: Facts tparc(ti, p j,W(ti, p j)). where (ti, p j) ∈ E+ with weight W(ti, p j).\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 23\nPetri Net execution simulation proceeds in discrete time-steps, these time steps are encoded by the following facts:\nf5: Facts time(tsi) where 0 ≤ tsi ≤ k.\nThe initial marking (or initial state) of the Petri Net is represented by the following facts:\ni1: Facts holds(pi,M0(pi), 0) for every place pi ∈ P with initial marking M0(pi).\nASP requires all variables in rule bodies be domain restricted. So, we add the following facts to capture the possible token quantities produced during the simulation 2:\nf6: Facts num(n)., where 0 ≤ n ≤ ntok\nA transition ti is enabled if each of its input places p j ∈ •ti has at least arc-weight W(p j, ti) tokens. Conversely, ti is not enabled if ∃p j ∈ •ti : M(p j) < W(p j, ti), and is only enabled when no such place p j exists. These are captured in e1 and e2 respectively:\ne1: notenabled(T,TS):-ptarc(P,T,N),holds(P,Q,TS),Q<N, place(P), trans(T), time(TS),num(N),num(Q).\ne2: enabled(T,TS) :- trans(T), time(TS), not notenabled(T, TS).\nRule e1 encodes notenabled(T,TS)which captures the existence of an input place P of transition T that violates the minimum token requirement N at time-step TS . Where, the predicate holds(P,Q,TS) encodes the marking Q of place P at TS .\nRule e2 encodes enabled(T,TS) which captures that transition T is enabled at TS since there is no input place P of transition T that violates the minimum input token requirement at TS . In biological context, e2 captures the conditions when a reaction (represented by T ) is ready to proceed. A subset of enabled transitions may fire simultaneously at a given time-step. This is encoded as:\na1: {fires(T,TS)} :- enabled(T,TS), trans(T), time(TS).\nRule a1 encodes fires(T,TS), which captures the firing of transition T at TS . The rule is encoded with a count atom as its head, which makes it a choice rule. This rule either picks the enabled transition T for firing at TS or not, effectively enumerating a subset of enabled transitions to fire. Whether this set can fire or not in an answer set is subject to conflict checking, which is done by rules a2, a3, a4 shown later.\nIn biological context, the selected transition-set models simultaneously occurring reactions and the conflict models limited reactant supply that cannot be shared. Such a conflict can lead to multiple choices in parallel reaction evolutions and different outcomes.\nThe next set of rules captures the consumption and production of tokens due to the firing of individual transitions in a firing-set as well as their aggregate effect, which computes the marking for the next time step:\n2Note that ntok can be arbitrarily chosen to be larger than the maximum expected token quantity produced during the simulation.\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 24\nr1: add(P,Q,T,TS) :- fires(T,TS), tparc(T,P,Q), time(TS).\nr2: del(P,Q,T,TS) :- fires(T,TS), ptarc(P,T,Q), time(TS).\nr3: tot incr(P,QQ,TS) :- QQ=#sum[add(P,Q,T,TS)=Q:num(Q):trans(T)], time(TS), num(QQ), place(P).\nr4: tot decr(P,QQ,TS) :- QQ=#sum[del(P,Q,T,TS)=Q:num(Q):trans(T)], time(TS), num(QQ), place(P).\nr5: holds(P,Q,TS+1) :-holds(P,Q1,TS),tot incr(P,Q2,TS),time(TS+1), tot decr(P,Q3,TS),Q=Q1+Q2-Q3,place(P),num(Q;Q1;Q2;Q3),time(TS).\nRule r1 encodes add(P,Q,T,TS) and captures the addition of Q tokens to place P due to firing of transition T at time-step TS . Rule r2 encodes del(P,Q,T,TS) and captures the deletion of Q tokens from place P due to firing of transition T at TS .\nRules r3 and r4 aggregate all add’s and del’s for place P due to r1 and r2 at time-step TS , respectively, by using the QQ=#sum[] construct to sum the Q values into QQ. Rule r5 which encodes holds(P,Q,TS+1) uses these aggregate adds and removes and updates P’s marking for the next time-step TS +1. In biological context, these rules capture the effect of a reaction on reactant and product quantities available in the next simulation step. To prevent overconsumption at a place following rules are added:\na2: consumesmore(P,TS) :- holds(P,Q,TS), tot decr(P,Q1,TS), Q1 > Q.\na3: consumesmore :- consumesmore(P,TS).\na4: :- consumesmore.\nRule a2 encodes consumesmore(P,TS) which captures overconsumption of tokens at input place P at time TS due to the firing set selected by a1. Overconsumption (and hence conflict) occurs when tokens Q1 consumed by the firing set are greater than the tokens Q available at P. Rule a3 generalizes this notion of overconsumption and constraint a4 eliminates answers where overconsumption is possible.\nDefinition 18 Given a Petri Net PN, its initial marking M0 and its encoding Π(PN, M0, k, ntok) for k-steps and maximum ntok tokens at any place. We say that there is a 1-1 correspondence between the answer sets of Π(PN,M0, k, ntok) and the execution sequences of PN iff for each answer set A of Π(PN,M0, k, ntok), there is a corresponding execution sequence X = M0,T0,M1, . . . ,Mk,Tk,Mk+1 of PN and for each execution sequence X of PN there is an answer-set A of Π(PN,M0, k, ntok) such that\n{ f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} = { f ires(t, ts) : f ires(t, ts) ∈ A}\n{holds(p, q, ts) : p ∈ P, q = Mts(p), 0 ≤ ts ≤ k + 1} = {holds(p, q, ts) : holds(p, q, ts) ∈ A}\nProposition 1 There is a 1-1 correspondence between the answer sets of Π0(PN, M0, k, ntok) and the execution sequences of PN.\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 25\n2.3.1 An example execution Next we look at an example execution of the Petri Net shown in Figure 2.1. The Petri Net and its initial marking are encoded as follows3:\nnum(0..60).time(0..5).place(f16bp;dhap;g3p;bpg13).\ntrans(t3;t4;t5a;t5b;t6).tparc(t3,f16bp,1).ptarc(f16bp,t4,1).\ntparc(t4,dhap,1).tparc(t4,g3p,1).ptarc(dhap,t5a,1).\ntparc(t5a,g3p,1).ptarc(g3p,t5b,1).tparc(t5b,dhap,1).\nptarc(g3p,t6,1).tparc(t6,bpg13,2).holds(f16bp;dhap;g3p;bgp13,0,0).\nwe get thousands of answer-sets, for example4:\nholds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0)\nholds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,1,1) holds(g3p,0,1)\nholds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,1,2) holds(g3p,1,2)\nholds(bpg13,0,3) holds(dhap,2,3) holds(f16bp,1,3) holds(g3p,2,3)\nholds(bpg13,2,4) holds(dhap,3,4) holds(f16bp,1,4) holds(g3p,2,4)\nholds(bpg13,4,5) holds(dhap,4,5) holds(f16bp,1,5) holds(g3p,2,5)\nfires(t3,0) fires(t3;t4,1) fires(t3;t4;t5a;t5b,2)\nfires(t3;t4;t5a;t5b;t6,3) fires(t3;t4;t5a;t5b;t6,4)\nfires(t3;t4;t5a;t5b;t6,5)\n2.4 Changing Firing Semantics\nThe ASP code above implements the set firing semantics. It can produce a large number of answer-sets, since any subset of a firing set will also be fired as a firing set. For our biological system modeling, it is often beneficial to simulate only the maximum activity at any given timestep. We accomplish this by defining the maximal firing set semantics, which requires that a maximal subset of non-conflicting transitions fires at a single time step5. Our semantics is different from the firing multiplier approach used by Krepska et al. (2008), in which a transition can fire as many times as allowed by the tokens available in its source places. Their approach requires an exponential time firing algorithm in the number of transitions. Our maximal firing set semantics is implemented by adding the following rules to the encoding in Section 2.3:\na5: could not have(T,TS) :- enabled(T,TS), not fires(T,TS), ptarc(S,T,Q), holds(S,QQ,TS), tot decr(S,QQQ,TS), Q > QQ - QQQ.\na6: :- not could not have(T,TS), enabled(T,TS), not fires(T,TS), trans(T), time(TS).\n3{holds(p1,0,0),...,holds(pN,0,0)}, {num(0),...,num(60)}, {time(0),...,time(5)} have been written as holds(p1;...;pN,0,0), num(0..60), time(0..5), respectively, to save space.\n4{fires(t1,ts1),...,fires(tN,ts1)} have been written as fires(t1;...;tN;ts1) to save space. 5Such a semantics reduces the reachable markings. See Burkhard (1980) for the analysis of its computational\npower.\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 26\nRule a5 encodes could not have(T,TS) which means that an enabled transition T that did not fire at time TS , could not have fired because its firing would have resulted in overconsumption. Rule a6 eliminates any answer-sets in which an enabled transition did not fire, that could not have caused overconsumption. Intuitively, these two rules guarantee that the only reason for an enabled transition to not fire is conflict avoidance (due to overconsumption). With this firing semantics, the number of answer-sets produced for Petri Net in Figure 2.1 reduces to 2.\nProposition 2 There is 1-1 correspondence between the answer sets of Π1(PN, M0, k, ntok) and the execution sequences of PN.\nOther firing semantics can be encoded with similar ease. For example, if interleaved firing semantics is desired, replace rules a5, a6 with the following:\na5’: more than one fires :- fires(T1,TS), fires(T2, TS), T1 != T2, time(TS).\na6’: :- more than one fires.\nWe now look at Petri Net extensions and show how they can be easily encoded in ASP.\n2.5 Extension - Reset Arcs\nDefinition 19 (Reset Arc) A Reset Arc in a Petri Net PNR is an arc from place p to transition t that consumes all tokens from its input place p upon firing of t. A Reset Petri Net is a tuple PNR = (P,T, E,W,R) where, P,T, E,W are the same as for PN; and R : T → 2P defines reset arcs\nFigure 2.2 shows an extended version of the Petri Net in Figure 2.1 with a reset arc from dhap to tr (shown with double arrowhead). In biological context it models the removal of all quantity of compound dhap. Petri Net execution semantics with reset arcs is modified for conflict detection and execution as follows:\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 27\nDefinition 20 (Reset Transition) A transition t ∈ T of PNR is called a reset-transition if it has a reset arc incident on it, i.e. R(t) , ∅.\nDefinition 21 (Firing Set) A firing set is a set Tk = {t1, . . . , tm} ⊆ T of simultaneously firing transitions that are enabled and do not conflict w.r.t. to the current marking Mk of PNR. Tk is not a firing set if there is an enabled reset-transition that is not in Tk, i.e. ∃t : enabledMk (t),R(t) , ∅, t < Tk. 6.\nDefinition 22 (Transition Execution in PNR) A transition execution is the simulation of change of marking from Mk to Mk+1 due to firing of a transition t ∈ T of PNR. Mk+1 is computed as follows:\n∀pi ∈ •t,Mk+1(pi) = Mk(pi) −W(pi, t) ∀p j ∈ t•,Mk+1(p j) = Mk(p j) + W(t, p j) ∀pr ∈ R(t),Mk+1(pr) = Mk(pr) − Mk(pr)\nDefinition 23 (Conflicting Transitions in PNR) A set of enabled transitions conflict in PNR w.r.t. Mk if firing them simultaneously will consume more tokens than are available at any one of their common input-places. Te = {t ∈ T : enabledMk (t)} conflict if:\n∃p ∈ P : Mk(p) < ( ∑\nt∈Te∧(p,t)∈E− W(p, t) + ∑ t∈Te∧p∈R(t) Mk(p))\nDefinition 24 (Firing Set Execution in PNR) Execution of a transition set Ti in PNR has the following effect:\n∀p ∈ P \\ R(Ti),Mk+1(p) = Mk(p) − ∑\nt∈Ti∧p∈•t W(p, t) + ∑ t∈Ti∧p∈t• W(t, p)\n∀p ∈ R(Ti),Mk+1(p) = ∑\nt∈Ti∧p∈t• W(t, p)\nwhere R(Ti) = ⋃ t∈Ti R(t) and represents the places emptied by Ti due to reset arcs 7.\nSince a reset arc from p to t, p ∈ R(t) consumes current marking dependent tokens, we extend ptarc to include time-step and replace f 3, f 4, e1, r1, r2, a5 with f 7, f 8, e3, r6, r7, a7, respectively in the Section 2.4 encoding and add rule f 9 for each reset arc:\n6The reset arc is involved here because we use a modified execution semantics of reset arcs compared to the standard definition Araki and Kasami (1976). Even though both capture similar operation, our definition allows us to model elimination of all quantity of a substance as soon as it is produced, even in a maximal firing set semantics. Our semantics considers reset arc’s token consumption in contention with other arcs, while the standard definition does not.\n7Our definition of conflicting transitions allows at most one transition with a reset arc from a place to fire, any more create a conflict. Thus, the new marking computation is equivalent to ∀p ∈ P,Mk+1(p) = Mk(p) − ( ∑ t∈Tk∧p∈•t W(p, t) + ∑ t∈Tk∧p∈R(t) Mk(p)) + ∑ t∈Tk∧p∈t•W(t, p)\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 28\nf7: Rules ptarc(pi, t j,W(pi, t j), tsk):-time(tsk). for each non-reset arc (pi, t j) ∈ E−\nf8: Rules tparc(ti, p j,W(ti, p j), tsk):-time(tsk). for each non-reset arc (ti, p j) ∈ E+\ne3: notenabled(T,TS) :- ptarc(P,T,N,TS), holds(P,Q,TS), Q < N, place(P), trans(T), time(TS), num(N), num(Q).\nr6: add(P,Q,T,TS) :- fires(T,TS), tparc(T,P,Q,TS), time(TS).\nr7: del(P,Q,T,TS) :- fires(T,TS), ptarc(P,T,Q,TS), time(TS).\nf9: Rules ptarc(pi, t j, X, tsk) :- holds(pi, X, tsk), num(X), X > 0. for each reset arc between pi and t j using X = Mk(pi) as arc-weight at time step tsk.\nf10: Rules :- enabled(t j, tsk),not fires(t j, tsk), time(tsk). for each transition t j with an incoming reset arc, i.e. R(t j) , ∅.\na7: could not have(T,TS) :- enabled(T,TS), not fires(T,TS), ptarc(S,T,Q,TS), holds(S,QQ,TS), tot decr(S,QQQ,TS), Q>QQ-QQQ.\nRule f 9 encodes place-transition arc with marking dependent weight to capture the notion of a reset arc, while rule f 10 ensures that the reset-transition (i.e. the transition on which the reset arc terminates) always fires when enabled.\nProposition 3 There is 1-1 correspondence between the answer sets of Π2(PNR,M0, k, ntok) and the execution sequences of PNR.\nThe execution semantics of our definition are slightly different from the standard definition in Araki and Kasami (1976), even though both capture similar operations. Our implementation considers token consumption by reset arc in contention with other token consuming arcs from the same place, while the standard definition considers token consumption as a side effect, not in contention with other arcs.\nWe chose our definition to allow modeling of biological process that removes all available quantity of a substance in a maximal firing set. Consider Figure 2.2, if dhap has 1 or more tokens, our semantics would only permit either t5a or tr to fire in a single time-step, while the standard semantics can allow both t5a and tr to fire simultaneously, such that the reset arc removes left over tokens after (dhap, t5a) consumes one token.\nWe could have, instead, extended our encoding to include self-modifying nets Valk (1978), but our modified-definition provides a simpler solution. Standard semantics, however, can be easily encoded by replacing r5 by r5a′, r5b′; replacing f 9, f 10 with f 9′; and adding a8 as follows:\nf9’: rptarc(pi,t j). - for each reset arc between pi ∈ R(t j) and t j. a8: reset(P,TS) :- rptarc(P,T), place(P), trans(T), fires(T,TS), time(TS).\nr5a’: holds(P,Q,TS+1) :- holds(P,Q1,TS), tot incr(P,Q2,TS), tot decr(P,Q3,TS), Q=Q1+Q2-Q3, place(P), num(Q;Q1;Q2;Q3), time(TS), time(TS+1), not\nreset(P,TS).\nr5b’: holds(P,Q,TS+1) :- tot incr(P,Q,TS), place(P), num(Q), time(TS), time(TS+1), reset(P,TS).\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 29\nwhere, the fact f 9′ encodes the reset arc; rule a8 encodes if place P will be reset at time TS due to firing of transition T that has a reset arc on it from P to T ; rule r5a′ computes marking at TS + 1 when place P is not being reset; and rule r5b′ computes marking at TS + 1 when P is being reset.\n2.6 Extension - Inhibitor Arcs\nDefinition 25 (Inhibitor Arc) An inhibitor arc Peterson (1977) is a place-transition arc that inhibits its transition from firing as long as the place has any tokens in it. An inhibitor arc does not consume any tokens from its input place. A Petri Net with reset and inhibitor arcs is a tuple PNRI = (P,T, E,W,R, I), where, P,T, E,W,R are the same as for PNR; and I : T → 2P defines inhibitor arcs.\nFigure 2.3 shows a Petri Net with inhibition arc from atp to gly1 with a bulleted arrowhead. It models biological feedback regulation in simplistic terms, where excess atp downstream causes the upstream atp production by glycolysis gly to be inhibited until the excess quantity is consumed Reece et al. (2010). Petri Net execution semantics with inhibit arcs is modified for determining enabled transitions as follows:\nDefinition 26 (Enabled Transition in PNRI) A transition t is enabled with respect to marking M, enabledM(t), if all its input places p have at least the number of tokens as the arc-weight W(p, t) and all p ∈ I(t) have zero tokens, i.e. (∀p ∈ •t,W(p, t) ≤ M(p)) ∧ (∀p ∈ I(t),M(p) = 0)\nWe add inhibitor arcs to our encoding in Section 2.5 as follows:\nf11: Rules iptarc(pi, t j, 1, tsk):-time(tsk). for each inhibitor arc between pi ∈ I(t j) and t j. e4: notenabled(T,TS) :- iptarc(P,T,N,TS), holds(P,Q,TS), place(P),\ntrans(T), time(TS), num(N), num(Q), Q >= N.\nThe new rule e4 encodes another reason for a transition to be disabled (or not enabled). An inhibitor arc from p to t with arc weight N will cause its target transition t to not enable when\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 30\nthe number of tokens at its source place p is greater than or equal to N, where N is always 1 per rule f 11.\nProposition 4 There is 1-1 correspondence between the answer sets of Π3(PNRI ,M0, k, ntok) and the execution sequences of PN.\n2.7 Extension - Read Arcs\nDefinition 27 (Read Arc) A read arc (a test arc or a query arc) Christensen and Hansen (1993) is an arc from place to transition, which enables its transition only when its source place has at least the number of tokens as its arc weight. It does not consume any tokens from its input place. A Petri Net with reset, inhibitor and read arcs is a tuple PNRIQ = (P,T,W,R, I,Q,QW), where, P,T, E,W,R, I are the same as for PNRI; Q ⊆ P × T defines read arcs; and QW : Q → N \\ {0} defines read arc weight.\nFigure 2.4 shows a Petri Net with read arc from h is to syn shown with arrowhead on both ends. It models the ATP synthase syn activation requiring a higher concentration of H+ ions h is in the intermembrane space 8. The reaction itself consumes a lower quantity of H+ ions represented by the regular place-transition arc Reece et al. (2010); Berg et al. (2002). Petri Net execution semantics with read arcs is modified for determining enabled transitions as follows:\nDefinition 28 (Enabled Transition in PNRIQ) A transition t is enabled with respect to marking M, enabledM(t), if all its input places p have at least the number of tokens as the arc-weight W(p, t), all pi ∈ I(t) have zero tokens and all pq : (pq, t) ∈ Q have at least the number of tokens as the arc-weight W(p, t), i.e. (∀p ∈ •t,W(p, t) ≤ M(p)) ∧ (∀p ∈ I(t),M(p) = 0) ∧ (∀(p, t) ∈ Q,M(p) ≥ QW(p, t))\n8This is an oversimplified model of syn (ATP synthase) activation, since the actual model requires an H+ concentration differential across membrane.\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 31\nWe add read arcs to our encoding of Section 2.6 as follows:\nf12: Rules tptarc(pi, t j,QW(pi, t j), tsk):-time(tsk). for each read arc (pi, t j) ∈ Q. e5: notenabled(T,TS):-tptarc(P,T,N,TS),holds(P,Q,TS),\nplace(P),trans(T), time(TS), num(N), num(Q), Q < N.\nThe new rule f 12 captures the read arc and its arc-weight; and the new rule e5 encodes another reason for a transition to not be enabled. A read arc from p to t with arc weight N will cause its target transition t to not enable when the number of tokens at its source place p is less than the arc weight N.\nProposition 5 There is a 1-1 correspondence between the answer sets of Π4(PNRIQ,M0, k, ntok) and the execution sequences of PNRIQ.\n2.8 Extension - Colored Tokens\nHigher level Petri Nets extend the notion of tokens to typed (or colored) tokens. This allows a more compact representation of complicated networks Peterson et al. (1980).\nDefinition 29 (Petri Net with Colored Tokens) A Petri Net with Colored Tokens (with reset, inhibit and read arcs) is a tuple PNC = (P,T, E,C,W,R, I,Q,QW), where P,T, E,R, I,Q are the same as for basic Petri Nets, C = {c1, . . . , cl} is a finite set of colors (or types), and arc weights W : E → 〈C,m〉, QW : Q → 〈C,m〉 are specified as multi-sets of colored tokens over color set C. The state (or marking) of place nodes M(pi) = 〈C,m〉, pi ∈ P is specified as a multiset of colored tokens over set C.\nWe will now update some definitions related to Petri Nets to include colored tokens.\nDefinition 30 (Marking) A marking M = (M(p1), . . . ,M(pn)) assigns a colored multi-set of tokens over the domain of colors C to each place {p1, . . . , pn} ∈ P of PNC . The initial marking is the initial token assignment of place nodes and is represented by M0. The marking at time-step k is written as Mk.\nDefinition 31 (Pre-set and post-set of a transition) The pre-set (or input-set) of a transition t is •t = {p ∈ P|(p, t) ∈ E−}, while the post-set (or output-set) is t• = {p ∈ P|(t, p) ∈ E+}.\nDefinition 32 (Enabled Transition) A transition t is enabled with respect to marking M, enabledM(t), if each of its input places p has at least the number of colored-tokens as the arc-weight W(p, t)9, each of its inhibiting places pi ∈ I(t) have zero tokens and each of its read places pq : (pq, t) ∈ Q have at least the number of colored-tokens as the read-arc-weight QW(pq, t), i.e. (∀p ∈ •t,W(p, t) ≤ M(p)) ∧ (∀p ∈ I(t),M(p) = ∅) ∧ (∀(p, t) ∈ Q,M(p) ≥ QW(p, t)) for a given t.10\n9In the following text, for simplicity, we will use W(p, t) to mean W(〈p, t〉). We use similar simpler notation for QW.\n10This is equivalent to ∀c ∈ C, (∀p ∈ •t,mW(p,t)(c) ≤ mM(p)(c))∧(∀p ∈ I(t),mM(p)(c) = 0)∧(∀(p, t) ∈ Q,mM(p)(c) ≥ mQW(p,t)(c)).\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 32\nDefinition 33 (Transition Execution) Execution of a transition t of PNC on a marking Mk computes a new marking Mk+1 as:\n∀p ∈ •tMk+1(p) = Mk(p) −W(p, t)\n∀p ∈ t • Mk+1(p) = Mk(p) + W(t, p) ∀p ∈ R(t)Mk+1(p) = Mk(p) − Mk(p)\nAny number of enabled transitions may fire simultaneously as long as they don’t conflict. A transition when fired consumed tokens from its pre-set places equivalent to the (place,transition) arc-weight.\nDefinition 34 (Conflicting Transitions) A set of transitions Tc ⊆ {t : enabledMk (t)} is in conflict in PNC with respect to Mk if firing them will consume more tokens than are available at one of their common input places, i.e., ∃p ∈ P : Mk(p) < ( ∑ t∈Tc∧p∈•t W(p, t) + ∑ t∈Tc∧p∈R(t) Mk(p))\nDefinition 35 (Firing Set) A firing set is a set Tk = {tk1 , . . . , tkn} ⊆ T of simultaneously firing transitions of PNC that are enabled and do not conflict w.r.t. to the current marking Mk of PN. A set Tk is not a firing set if there is an enabled reset-transition that is not in Tk, i.e. ∃t ∈ enabledMk ,R(t) , ∅, t < Tk. 11\nDefinition 36 (Firing Set Execution) Execution of a firing set Tk of PNC on a marking Mk computes a new marking Mk+1 as:\n∀p ∈ P \\ R(Tk),Mk+1(p) = Mk(p) − ∑\nt∈Tk∧p∈•t W(p, t) + ∑ t∈Tk∧p∈t• W(t, p)\n∀p ∈ R(Tk),Mk+1(p) = ∑\nt∈Tk∧p∈t• W(t, p)\nwhere R(Tk) = ⋃ t∈Tk R(t) 12\nDefinition 37 (Execution Sequence) An execution sequence X = M0,T0,M1, T1, . . . , Mk, Tk,Mk+1 of PN is the simulation of a firing set sequence σ = T1,T2, . . . ,Tk w.r.t. an initial marking M0, producing the final marking Mk+1. Mk+1 is the transitive closure of firing set executions, where subsequent marking become the initial marking for the next firing set.\nFor an execution sequence X = M0,T0,M1,T1, . . . , Mk,Tk,Mk+1, the firing of T0 with respect to marking M0 produces the marking M1 which becomes the initial marking for T1, which produces M2 and so on.\nIf the Figure 2.5 Petri Net has the marking: M0(mm) = [nadh/2, h/6], M0(q) = [e/2], M0(cytc) = [e/2], M0(is) = [o2/1], then transitions t1, t3, t4 are enabled. However, either {t1, t3} or {t4} can fire simultaneously in a single firing at time 0 due to limited h tokens in mm. t4 is said to be in conflict with t1, t3.\n11See footnote 6 12See footnote 7\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 33\n2.9 Translating Petri Nets with Colored Tokens to ASP\nIn order to represent the Petri Net PNC with colored tokens, initial marking M0, and simulation length k, we modify our encoding in Section 2.7 to add a new color parameter to all rules and facts containing token counts in them. We keep rules f 1, f 2, f 5, f 6, f 10 remain as they were for basic Petri Nets. We add a new rule f 13 for possible set of token colors and replace rules f 7, f 8, f 9, f 11, f 12, i1 with f 14, f 15, f 16, f 17, f 18, i2 to add the color parameter as follows:\nf13: Facts col(ck) where ck ∈ C is a color.\nf14: Rules ptarc(pi, t j, nc, c, tsk) :- time(tsk). for each (pi, t j) ∈ E−, c ∈ C, nc = mW(pi,t j)(c) : nc > 0.13\nf15: Rules tparc(ti, p j, nc, c, tsk) :- time(tsk). for each (ti, p j) ∈ E+ , c ∈ C, nc = mW(ti,p j)(c) : nc > 0.\nf16: Rules ptarc(pi, t j, nc, c, tsk) :- holds(pi, nc, c, tsk), num(nc), nc>0, time(tsk). for each (pi, t j) : pi ∈ R(t j), c ∈ C, nc = mMk(pi)(c).\nf17: Rules iptarc(pi, t j, 1, c, tsk) :- time(tsk). for each (pi, t j) : pi ∈ I(t j), c ∈ C.\nf18: Rules tptarc(pi, t j, nc, c, tsk) :- time(tsk). for each (pi, t j) ∈ Q, c ∈ C, nc = mQW(pi,t j)(c) : nc > 0.\ni2: Facts holds(pi, nc, c, 0). for each place pi ∈ P, c ∈ C, nc = mM0(pi)(c). 13The time parameter tsk allows us to capture reset arcs, which consume tokens equal to the current (time-step based) marking of their source nodes.\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 34\nNext, we encode Petri Net’s execution behavior, which proceeds in discrete time steps. Rules e3, e4, e5, e2 are replaced by e6, e7, e8, e9. For a transition ti to be enabled, it must satisfy the following conditions: (i) @p j ∈ •ti : M(p j) < W(p j, ti), (ii) @p j ∈ I(ti) : M(p j) > 0, and (iii) @(p j, ti) ∈ Q : M(p j) < QW(p j, ti) . These three conditions are encoded as e6, e7, e8, respectively and we encode the absence of any of these conditions for a transition as e9:\ne6: notenabled(T,TS) :- ptarc(P,T, N,C,TS), holds(P,Q,C,TS), place(P), trans(T), time(TS), num(N), num(Q), col(C), Q<N.\ne7: notenabled(T,TS) :- iptarc(P,T,N,C,TS), holds(P,Q,C,TS), place(P), trans(T), time(TS), num(N), num(Q), col(C), Q>=N.\ne8: notenabled(T,TS) :- tptarc(P,T,N,C,TS), holds(P,Q,C,TS), place(P), trans(T), time(TS), num(N), num(Q), col(C), Q<N.\ne9: enabled(T,TS) :- trans(T), time(TS), not notenabled(T,TS).\nRule e6 captures the existence of an input place P with insufficient number of tokens for transition T to fire. Rule e7 captures existence of a non-empty source place P of an inhibitor arc to T preventing T from firing. Rule e8 captures existence of a source place P with less than arc-weight tokens required by the read arc to transition T for T to be enabled. The, holds(P,Q,C,TS) predicate captures the marking of place P at time TS as Q tokens of color C. Rule e9 captures enabling of transition T when no reason for it to be not enabled is determined by e6, e7, e8. In a biological context, this enabling is equivalent to a reaction’s pre-conditions being satisfied. A reaction can proceed when its input substances are available in the required quantities, it is not inhibited, and any required activation quantity of activating substances is available.\nAny subset of enabled transitions can fire simultaneously at a given time-step. We select a subset of fireable transitions using the choice rule a1 The choice rule a1 either picks an enabled transition T for firing at time TS or not. The combined effect over all transitions is to pick a subset of enabled transitions to fire. Rule f 10 ensures that enabled reset-transitions will be a part of this firing set. Whether these transitions are in conflict are checked by later rules a9, a3, a4. In a biological context, the multiple firing models parallel processes occurring simultaneously. The marking is updated according to the firing set using rules r8, r9, r10, r11, r12 which replaced r6, r7, r3, r4, r5 as follows:\nr8: add(P,Q,T,C,TS) :- fires(T,TS), tparc(T,P,Q,C,TS), time(TS).\nr9: del(P,Q,T,C,TS) :- fires(T,TS), ptarc(P,T,Q,C,TS), time(TS).\nr10: tot incr(P,QQ,C,TS) :- col(C), QQ = #sum[add(P,Q,T,C,TS) = Q : num(Q) : trans(T)], time(TS), num(QQ), place(P).\nr11: tot decr(P,QQ,C,TS) :- col(C), QQ = #sum[del(P,Q,T,C,TS) = Q : num(Q) : trans(T)], time(TS), num(QQ), place(P).\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 35\nr12: holds(P,Q,C,TS+1):-place(P),num(Q;Q1;Q2;Q3),time(TS),time(TS+1),col(C), holds(P,Q1,C,TS), tot incr(P,Q2,C,TS), tot decr(P,Q3,C,TS), Q=Q1+Q2-Q3.\nRules r8 and r9 capture that Q tokens of color C will be added or removed to/from place P due to firing of transition T at the respective time-step TS . Rules r10 and r11 aggregate these tokens for each C for each place P (using aggregate assignment QQ = #sum[...]) at the respective time-step TS . Rule r12 uses the aggregates to compute the next marking of P for color C at the time-step (TS + 1) by subtracting removed tokens and adding added tokens to the current marking. In a biological context, this captures the effect of a process / reaction, which consumes its inputs and produces outputs for the downstream processes. We capture token overconsumption using the rules a9, a3, a4 of which a9 is a colored replacement for a2 and is encoded as follows:\na9: consumesmore(P,TS) :- holds(P,Q,C,TS), tot decr(P,Q1,C,TS), Q1 > Q.\nRule a9 determines whether firing set selected by a1 will cause overconsumption of tokens at P at time TS by comparing available tokens to aggregate tokens removed as determined by r11. Rule a3 generalizes the notion of overconsumption, while rule a4 eliminates answer with such overconsumption.\nIn a biological context, conflict (through overconsumption) models the limitation of input substances, which dictate which downstream processes can occur simultaneously.\nWe remove rules a5, a6 from previous encoding to get the set firing semantics. Now, we extend the definition (18) of 1-1 correspondence between the execution sequence of Petri Net and the answer-sets of its ASP encoding to Petri Nets with colored tokens as follows.\nDefinition 38 Given a Petri Net PN with colored tokens, its initial marking M0 and its encoding Π(PN,M0, k, ntok) for k-steps and maximum ntok tokens at any place. We say that there is a 1-1 correspondence between the answer sets of Π(PN,M0, k, ntok) and the execution sequences of PN iff for each answer set A of Π(PN,M0, k, ntok), there is a corresponding execution sequence X = M0,T0,M1, . . . ,Mk,Tk,Mk+1 of PN and for each execution sequence X of PN there is an answer-set A of Π(PN,M0, k, ntok) such that\n{ f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} = { f ires(t, ts) : f ires(t, ts) ∈ A}\n{holds(p, q, c, ts) : p ∈ P, c/q = Mts(p), 0 ≤ ts ≤ k + 1} = {holds(p, q, c, ts) : holds(p, q, c, ts) ∈ A}\nProposition 6 There is 1-1 correspondence between the answer sets of Π5(PNC ,M0, k, ntok) and the execution sequences of PN.\nTo add maximal firing semantics, we add a6 as it is and replace a5 with a10 as follows:\na10: could not have(T,TS):-enabled(T,TS),not fires(T,TS), ptarc(S,T,Q,C,TS), holds(S,QQ,C,TS), tot decr(S,QQQ,C,TS), Q > QQ - QQQ.\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 36\nRule a10 captures the fact that transition T , though enabled, could not have fired at TS , as its firing would have caused overconsumption. Rule a6 eliminates any answers where an enabled transition could have fired without causing overconsumption but did not. This modification reduces the number of answers produced for the Petri Net in Figure 2.5 to 4. We can encode other firing semantics with similar ease14. We now look at how additional extensions can be easily encoded by making small code changes.\n2.10 Extension - Priority Transitions\nPriority transitions enable ordering of Petri Net transitions, favoring high priority transitions over lower priority ones Best and Koutny (1992). In a biological context, this is used to model primary (or dominant) vs. secondary pathways / processes in a biological system. This prioritization may be due to an intervention (such as prioritizing elimination of a metabolite over recycling it).\nDefinition 39 (Priority Colored Petri Net) A Priority Colored Petri Net with reset, inhibit, and read arcs is a tuple PN pri = (P,T, E,C,W,R, I,Q,QW,Z), where: P,T, E,C,W,R, I,Q,QW are the same as for PNC , and Z : T → N is a priority function that assigns priorities to transitions. Lower number signifies higher priority.\nDefinition 40 (Enabled Transition) A transition ti is enabled in PN pri w.r.t. a marking M (prenabledM(t)) if it would be enabled in PNC w.r.t. M and there isn’t another transition t j that would be enabled in PNC (with respect to M) s.t. Z(t j) < Z(ti).\nDefinition 41 (Firing Set) A firing set is a set Tk = {tk1 , . . . , tkn} ⊆ T of simultaneously firing transitions of PN pri that are priority enabled and do not conflict w.r.t. to the current marking Mk of PN. A set Tk is not a firing set if there is an priority enabled reset-transition that is not in Tk, i.e. ∃t : prenabledMk (t),R(t) , ∅, t < Tk. 15\nWe add the following facts and rules to encode transition priority and enabled priority transitions:\nf19: Facts transpr(ti,pri) where pri = Z(ti) is t′i s priority.\na11: notprenabled(T,TS) :- enabled(T,TS), transpr(T,P), enabled(TT,TS), transpr(TT,PP), PP < P.\na12: prenabled(T,TS) :- enabled(T,TS), not notprenabled(T,TS). 14For example, if interleaved semantics is desired, rules a10, a6 can changed to capture and eliminate answer-sets in which more than one transition fires in a firing set as: a10’: more than one fires :- fires(T1,TS),fires(T2,TS),T1!=T2,time(TS).\na6’: :-more than one fires.\n15See footnote 6\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 37\nRule a11 captures that an enabled transition T is not priority-enabled, if there is another enabled transition with higher priority at TS . Rule a12 captures that transition T is priorityenabled at TS since there is no enabled transition with higher priority. We replace rules a1, f 10, a10, a6 with a13, f 20, a14, a15 respectively to propagate priority as follows:\na13: {fires(T,TS)} :- prenabled(T,TS), trans(T), time(TS). f20: Rules :- prenabled(t j, tsk),not fires(t j, tsk), time(tsk). for each transition t j with an in-\ncoming reset arc.\na14: could not have(T,TS) :- prenabled(T,TS), not fires(T,TS), ptarc(S,T,Q,C,TS), holds(S,QQ,C,TS), tot decr(S,QQQ,C,TS), Q > QQ - QQQ.\na15: :- not could not have(T,TS), time(TS), prenabled(T,TS), not fires(T,TS), trans(T).\nRules a13, f 10, a14, a15 perform the same function as a1, f 20, a10, a6, except that they consider only priority-enabled transitions as compared all enabled transitions.\nProposition 7 There is 1-1 correspondence between the answer sets of Π6(PN pri,M0, k, ntok) and the execution sequences of PN pri.\n2.11 Extension - Timed Transitions\nBiological processes vary in time required for them to complete. Timed transitions Ramchandani (1974) model this variation of duration. The timed transitions can be reentrant or nonreentrant16. We extend our encoding to allow reentrant timed transitions.\nDefinition 42 (Priority Colored Petri Net with Timed Transitions) A Priority Colored Petri Net with Timed Transitions, reset, inhibit, and query arcs is a tuple PND = (P,T, E,C,W,R, I,Q,QW,Z,D), where P,T, E,C,W,R, I,Q,QW,Z are the same as for PN pri, and D : T → N \\ {0} is a duration function that assigns positive integer durations to transitions.\nFigure 2.6 shows an extended version of Petri Net model of the Electron Transport Chain Reece et al. (2010) shown in Figure 2.5. The new transitions tq and tcytc (shown in dotted outline) are timed transitions modeling the speed of the small carrier molecules, Coenzyme Q (q) and Cytochrome C (cytc) as an effect of membrane fluidity. Higher numbers for transition duration represent slower movement of the carrier molecules due to lower fluidity.\nDefinition 43 (Transition Execution) A transition t in PND consumes tokens from its input places and reset places immediately, while it produces tokens in its output places at the end of transition duration D(t), as follows:\n∀p ∈ •t,Mk+1(p) = Mk(p) −W(p, t) 16A reentrant transition is like a vehicle assembly line, which accepts new parts while working on multiple vehicles at various stages of completion; whereas a non-reentrant transition only accepts new input when the current processing is finished.\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 38\n∀p ∈ t•,Mk+D(t)(p) = Mk+D(t)−1(p) + W(p, t) ∀p ∈ R(t),Mk+1(p) = Mk(p) − Mk(p)\nExecution in PND changes, since the token update from Mk to Mk+1 can involve transitions that started at some time l before time k, but finish at k + 1.\nDefinition 44 (Firing Set Execution) New marking due to firing set execution is computed as follows:\n∀p ∈ P \\ R(Tk),Mk+1(p) = Mk(p) − ∑\nt∈Tk ,p∈•t W(p, t) + ∑ t∈Tl,p∈t•:0≤l≤k,l+D(t)=k+1 W(t, p)\n∀p ∈ R(Tk),Mk+1(p) = ∑\nt∈Tl,p∈t•:l≤k,l+D(t)=k+1 W(t, p)\nwhere R(Ti) = ∪t∈TiR(t).\nA timed transition t produces its output D(t) time units after being fired. We replace f 15 with f 21 adding transition duration and replace rule r8 with r13 that produces tokens at the end of transition duration:\nf21: Rules tparc(ti, p j, nc, c, tsk,D(ti)):-time(tsk). for each (ti, p j) ∈ E+, c ∈ C, nc = mW(ti,p j)(c) : nc > 0.\nCHAPTER 2. PETRI NET ENCODING IN ASP FOR BIOLOGICAL DOMAIN 39\nr13: add(P,Q,T,C,TS):-fires(T,TS0),time(TS0;TS), tparc(T,P,Q,C,TS0,D), TS=TS0+D-1.\nProposition 8 There is 1-1 correspondence between the answer sets of Π7(PND,M0, k, ntok) and the execution sequences of PND.\nAbove implementation of timed-transition is reentrant, however, we can easily make these timed transitions non-reentrant by adding rule e10 that disallows a transition from being enabled if it is already in progress:\ne10: notenabled(T,TS):-fires(T,TS0), num(N), TS>TS0, tparc(T,P,N,C,TS0,D), col(C), time(TS0), time(TS), TS<(TS0+D).\n2.12 Other Extensions\nOther Petri Net extensions can be implemented with similar ease. For example, Guard Conditions on transitions can be trivially implemented as a notenabled/2 rules. Self Modifying Petri Nets Valk (1978), which allow marking-dependent arc-weights can be implemented in a similar manner as the Reset Arc extension in section 2.5. Object Petri Nets Valk (2004), in which each token is a Petri Net itself can be implemented (using token reference semantics) by adding an additional “network-id” parameter to our encoding, where “id=0” is reserved for system net and higher numbers are used for token nets. Transition coordination between system & token nets is enforced through constraints on transition labels, where transition labels are added as additional facts about transitions.\n2.13 Related Work\nPetri Nets have been previously encoded in ASP, but the previous implementations have been limited to restricted classes of Petri Nets. For example, 1-safe Petri Net to ASP translation has been presented in Heljanko and Niemelä (2000), which is limited to binary Petri Nets. Translation of Logic Petri Nets to ASP has been presented in Behrens and Dix (2007), but their model cannot handle numerical aggregation of tokens from multiple input transitions to the same place. Our work focused on problems in the biological domain and is more generalized. We can represent reset arcs, inhibition arcs, priority arcs as well as durative transitions.\n2.14 Conclusion\nWe have presented an encoding of basic Petri Nets in ASP and showed how it can be easily extended to include extension to model various biological constructs. Portions of this work were published in Anwar et al. (2013b) and Anwar et al. (2013a). In the next chapter we will use Petri Nets and their ASP encoding to model biological pathways to answer questions about them.\nChapter 3\nAnswering Questions using Petri Nets and ASP\n3.1 Introduction\nIn this chapter we use various Petri Net extensions presented in Chapter 2 and their ASP encoding to answer question from Reece et al. (2010) that were a part of the Second Deep Knowledge Representation Challenge1.\nDefinition 45 (Rate) Rate of product P is defined as the quantity of P produced per unit-time. Rate of an action A is defined as the number of time A occurs per unit-time.\n3.2 Comparing Altered Trajectories due to Reset Intervention\nQuestion 1 At one point in the process of glycolysis, both dihydroxyacetone phosphate (DHAP) and glyceraldehyde 3-phosphate (G3P) are produced. Isomerase catalyzes the reversible conversion between these two isomers. The conversion of DHAP to G3P never reaches equilibrium and G3P is used in the next step of glycolysis. What would happen to the rate of glycolysis if DHAP were removed from the process of glycolysis as quickly as it was produced?\nProvided Answer:\n“Glycolysis is likely to stop, or at least slow it down. The conversion of the two isomers is reversible, and the removal of DHAP will cause the reaction to shift in that direction so more G3P is converted to DHAP. If less (or no) G3P were available, the conversion of G3P into DHAP would slow down (or be unable to occur).”\nSolution 1 The process of glycolysis is shown in Fig 9.9 of Campbell’s book. Glycolysis splits Glucose into Pyruvate. In the process it produces ATP and NADH. Any one of these can be used\n1https://sites.google.com/site/2nddeepkrchallenge/\n40\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 41\nto gauge the glycolysis rate, since they will be produced in proportion to the input Glucose. The amount of pyruvate produced is the best choice since it is the direct end product of glycolysis. The ratio of the quantity of pyruvate produced over a representative span of time gives us the glycolysis rate. We assume a steady supply of Glucose is available and also assume that sufficient quantity of various enzymes used in glycolysis is available, since the question does not place any restriction on these substances.\nWe narrow our focus to a subsection from Fructose 1,6-bisphosphate (F16BP) to 1,3-Bisphosphoglycerate (BPG13) as shown in Figure 3.1 since that is the part the question is concerned with. We can ignore the linear chain up-stream of F16BP as well as the linear chain down-stream of BPG13 since the amount of F16BP available will be equal to Glucose and the amount of BPG13 will be equal to the amount of Pyruvate given our steady supply assumption.\nWe fulfill the steady supply requirement of Glucose by a source transition-node t3. We fulfill sufficient enzyme supply by a fixed quantity for each enzyme such that this quantity is in excess of what can be consumed during our simulation interval. Where the simulation interval is the number of time-steps over which we will measure the rate of glycolysis.\nWe model the elimination of DHAP as soon as it is produced with a reset arc, shown with a dotted style in Figures 3.1. Such an arc removes all tokens from its source place when it fires. Since we have added it as an unconditional arc, it is always enabled for firing. We encode both situations in ASP with the maximal firing set policy. Both situations (without and with reset arc)\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 42\nare encoded in ASP and run for 10 steps. At the end of those 10 steps the amount of BPG13 is compared to determine the difference in the rate of glycolysis.\nIn normal situation (without (dhap, tr) reset arc), unique quantities of “bpg13” from all (2) answer-sets after 10 steps were as follows:\nholds(bpg13,14,10) holds(bpg13,16,10)\nwith reset arc tr, unique quantities of “bpg13” from all (512) answer-sets after 10 steps were as follows:\nholds(bpg13,0,10) holds(bpg13,10,10) holds(bpg13,12,10) holds(bpg13,14,10) holds(bpg13,16,10) holds(bpg13,2,10) holds(bpg13,4,10) holds(bpg13,6,10) holds(bpg13,8,10)\nNote that the rate of glycolysis is generally lower when DHAP is immediately consumed. It is as low as zero essentially stopping glycolysis. The range of values are due to the choice between G3P being converted to DHAP or BPG13. If more G3P is converted to DHAP, then less\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 43\nBPG13 is produced and vice versa. Also, note that if G3P is not converted to BPG13, no NADH or ATP is produced either due to the liner chain from G3P to Pyruvate. The unique quantities of BPG13 are shown in a graphical format in Figure 3.2, while a trend of average quantity of BPG13 produced is shown in Figure 3.3.\nWe created a minimal model of the Petri Net in Figure 3.1 by removing enzymes and reactants that were not relevant to the question and did not contribute to the estimation of glycolysis. This is shown in Figure 3.4.\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 44\nSimulating it for 10 steps with the same initial marking as the Petri Net in Figure 3.1 produced the same results as for Figure 3.1.\n3.3 Determining Conditions Leading to an Observation\nQuestion 2 When and how does the body switch to B oxidation versus glycolysis as the major way of burning fuel?\nProvided Answer:\n“The relative volumes of the raw materials for B oxidation and glycolysis indicate which of these two processes will occur. Glycolysis uses the raw material glucose, and B oxidation uses Acyl CoA from fatty acids. When the blood sugar level decreases below its homeostatic level, then B oxidation will occur with available fatty acids. If no fatty acids are immediately available, glucagon and other hormones regulate release of stored sugar and fat, or even catabolism of proteins and nucleic acids, to be used as energy sources.”\nSolution 2 The answer provided requires background knowledge about the mechanism that regulates which source of energy will be used. This information is not presented in Chapter 9 of Campbell’s book, which is the source material of this exercise. However, we can model it based on background information combined with Figure 9.19 of Campbell’s book. Our model is presented in Figure 3.52.\nWe can test the model by simulating it for a time period and testing whether beta oxidation (box) is started when sugar (sug) is finished. We do not need a steady supply of sugar in this\n2We can extend this model by adding expressions to inhibition arcs that compare available substances.\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 45\ncase, just enough to be consumed in a few time steps to capture the switch over. Fats and proteins may or may not modeled as a steady supply, since their bioavailability is dependent upon a number of external factors. We assume a steady supply of both and model it with large enough initial quantity that will last beyond the simulation period.\nWe translate the petri net model into ASP and run it for 10 iterations. Following are the results:\nholds(acoa,0,0) holds(amin,0,0) holds(fac,0,0) holds(fats,5,0) holds(prot,3,0) holds(sug,4,0)\nfires(t1,0) fires(t5,0) fires(t9,0)\nholds(acoa,1,1) holds(amin,1,1) holds(fac,1,1) holds(fats,4,1) holds(prot,3,1) holds(sug,3,1)\nfires(t5,1)\nholds(acoa,2,2) holds(amin,1,2) holds(fac,1,2) holds(fats,4,2) holds(prot,3,2) holds(sug,2,2)\nfires(t5,2)\nholds(acoa,3,3) holds(amin,1,3) holds(fac,1,3) holds(fats,4,3) holds(prot,3,3) holds(sug,1,3)\nfires(t5,3)\nholds(acoa,4,4) holds(amin,1,4) holds(fac,1,4) holds(fats,4,4) holds(prot,3,4) holds(sug,0,4)\nfires(box,4)\nholds(acoa,5,5) holds(amin,1,5) holds(fac,0,5) holds(fats,4,5) holds(prot,3,5) holds(sug,0,5)\nfires(t1,5) fires(t9,5)\nholds(acoa,5,6) holds(amin,2,6) holds(fac,1,6) holds(fats,3,6) holds(prot,3,6) holds(sug,0,6)\nfires(box,6)c\nholds(acoa,6,7) holds(amin,2,7) holds(fac,0,7) holds(fats,3,7) holds(prot,3,7) holds(sug,0,7)\nfires(t1,7) fires(t9,7)\nholds(acoa,6,8) holds(amin,3,8) holds(fac,1,8) holds(fats,2,8) holds(prot,3,8) holds(sug,0,8)\nfires(box,8)\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 46\nholds(acoa,7,9) holds(amin,3,9) holds(fac,0,9) holds(fats,2,9) holds(prot,3,9) holds(sug,0,9)\nfires(t1,9) fires(t9,9)\nholds(acoa,7,10) holds(amin,4,10) holds(fac,1,10) holds(fats,1,10) holds(prot,3,10) holds(sug,0,10)\nfires(box,10)\nWe can see that by time-step 4, the sugar supply is depleted and beta oxidation starts occurring.\n3.4 Comparing Altered Trajectories due to Accumulation Intervention\nQuestion 3 ATP is accumulating in the cell. What affect would this have on the rate of glycolysis? Explain.\nProvided Answer:\n“ATP and AMP regulate the activity of phosphofructokinase. When there is an abundance of AMP in the cell, this indicates that the rate of ATP consumption is high. The cell is in need for more ATP. If ATP is accumulating in the cell, this indicates that the cell’s demand for ATP had decreased. The cell can decrease its production of ATP. Therefore, the rate of glycolysis will decrease.”\nSolution 3 Control of cellular respiration is summarized in Fig 9.20 of Campbell’s book. We can gauge the rate of glycolysis by the amount of Pyruvate produced, which is the end product of glycolysis. We assume a steady supply of glucose is available. Its availability is not impacted by any of the feedback mechanism depicted in Fig 9.20 of Campbell’s book or restricted by the question. We can ignore the respiration steps after glycolysis, since they are directly dependent upon the end product of glycolysis, i.e. Pyruvate. These steps only reinforce the negative effect of ATP. The Citrate feed-back shown in Campbell’s Fig 9.20 is also not relevant to the question, so we can assume a constant level of it and leave it out of the picture. Another simplification that we do is to treat the inhibition of Phosphofructokinase (PFK) by ATP as the inhibition of glycolysis itself. This is justified, since PFK is on a linear path from Glucose to Fructose 1,6- bisphosphate (F16BP), and all downstream product quantities are directly dependent upon the amount of F16BP (as shown in Campbell’s Fig 9.9), given steady supply of substances involved in glycolysis. Our assumption also applies to ATP consumed in Fig 9.9. Our simplified picture is shown in Figure 3.6 as a Petri Net.\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 47\nWe model cellular work that recycles ATP to AMP (see p/181 of Campbell’s book) by the cw1 transition, shown in dotted style. In normal circumstances, this arc does not let ATP to collect. If we reduce the arc-weights incident on cw1 to 1, we get the situation where less work is being done and some ATP will collect, as a result glycolysis will pause and resume. If we remove cw1 (representing no cellular work), ATP will start accumulating and glycolysis will stop. We use an arbitrary arc-weight of 4 on the inhibition arc (atp, gly1) to model an elevated level of ATP beyond normal that would cause inhibition 3. We encode all three situations in ASP with maximal firing set policy. We run them for 10 steps and compare the quantity of pyruvate produced to determine the difference in the rate of glycolysis.\nIn normal situation when cellular work is being performed (cw1 arc is present), unique quantities of “pyr” after 10 step are as follows:\nholds(pyr,20,10)\nwhen the cellular work is reduced, i.e. ((atp, cw1), (cw1, amp) arc weights changed to 1), unique quantities of “pyr” after 10 steps are as follows:\nholds(pyr,14,10)\nwith no cellular work (cw1 arc removed), unique quantities of “pyr” after 10 steps are as follows:\nholds(pyr,6,10)\nThe results show the rate of glycolysis reducing as the cellular work decreases to the point where it stops once ATP reaches the inhibition threshold. Higher numbers of ATP produced\n3An alternate modeling would be compare the number of tokens on the amp node and the atp node and set a level-threshold that inhibits gly1. Such technique is common in colored-peri nets.\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 48\nin later steps of cellular respiration will reinforce this inhibition even more quickly. Trend of answers from various runs is shown in Figure 3.7.\n3.5 Comparing Altered Trajectories due to Initial Value Intervention\nQuestion 4 A muscle cell had used up its supply of oxygen and ATP. Explain what affect would this have on the rate of cellular respiration and glycolysis?\nProvided Answer:\n“Oxygen is needed for cellular respiration to occur. Therefore, cellular respiration would stop. The cell would generate ATP by glycolysis only. Decrease in the concentration of ATP in the cell would stimulate an increased rate of glycolysis in order to produce more ATP.”\nSolution 4 Figure 9.18 of Campbell’s book gives the general idea of what happens when oxygen is not present. Figure 9.20 of Campbell’s book shows the control of glycolysis by ATP. To formulate the answer, we need pieces from both.\nATP inhibits Phosphofructokinase (Fig 9.20 of Campbell), which is an enzyme used in glycolysis. No ATP means that enzyme is no longer inhibited and glycolysis can proceed at full throttle. Pyruvate either goes through aerobic respiration when oxygen is present or it goes through fermentation when oxygen is absent (Fig 9.18 of Campbell). We can monitor the rate of glycolysis and cellular respiration by observing these operations occurring (by looking at corresponding transition firing) over a simulation time period. Our simplified Petri Net model is shown in Figure 3.8.\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 49\nWe ignore the details of processes following glycolysis, except that these steps produce additional ATP. We do not need an exact number of ATP produced as long as we keep it higher than the ATP produced by glycolysis. Higher numbers will just have a higher negative feed-back (or inhibition) effect on glycolysis. We ignore citrate’s inhibition of glycolysis since that is not relevant to the question and since it gets recycled by the citric acid cycle (see Fig 9.12 of Campbell). We also ignore AMP, since it is not relevant to the question, by assuming sufficient supply to maintain glycolysis. We also assume continuous cellular work consuming ATP, without that ATP will accumulate almost immediately and stop glycolysis.\nWe assume a steady supply of glucose is available to carry out glycolysis and fulfill this requirement by having a quantity in excess of the consumption during our simulation interval. All other substances participating in glycolysis are assumed to be available in a steady supply so that glycolysis can continue.\nWe then consider two scenarios, one where oxygen is present and where oxygen is absent and determine the change in rate of glycolysis and respiration by counting the firings of their respective transitions. We encode both situations in ASP with maximal firing set policy. Both situations are executed for 10 steps. At the end of those steps the firing count of “gly1” and “res1” is computed and compared to determine the difference in the rates of glycolysis and respiration respectively.\nIn the normal situation (when oxygen is present), we get the following answer sets:\nfires(gly1,0) fires(cw1,1) fires(gly1,1) fires(res1,1) fires(cw1,2) fires(res1,2) fires(cw1,3) fires(cw1,4)\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 50\nfires(cw1,5) fires(gly1,5) fires(cw1,6) fires(gly1,6) fires(res1,6) fires(cw1,7) fires(res1,7) fires(cw1,8) fires(cw1,9) fires(cw1,10)\nwhile in the abnormal situation (when oxygen is absent), we get the following firings:\nfires(gly1,0) fires(cw1,1) fires(fer1,1) fires(gly1,1) fires(cw1,2) fires(fer1,2) fires(gly1,2) fires(cw1,3) fires(fer1,3) fires(gly1,3) fires(cw1,4) fires(fer1,4) fires(gly1,4) fires(cw1,5) fires(fer1,5) fires(gly1,5) fires(cw1,6) fires(fer1,6) fires(gly1,6) fires(cw1,7) fires(fer1,7) fires(gly1,7) fires(cw1,8) fires(fer1,8) fires(gly1,8) fires(cw1,9) fires(fer1,9) fires(gly1,9) fires(cw1,10) fires(fer1,10) fires(gly1,10)\nNote that the number of firings of glycolysis for normal situation is lower when oxygen is present and higher when oxygen is absent. While, the number of firings is zero when no oxygen is present. Thus, respiration stops when no oxygen is present and the need of ATP by cellular work is fulfilled by a higher amount of glycolysis. Trend from various runs is shown in Figure 3.9.\nFiring counts of gly1 and res1 at various run lengths\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 51\n3.6 Comparing Altered Trajectories due to Inhibition Intervention\nQuestion 5 The final protein complex in the electron transport chain of the mitochondria is non-functional. Explain the effect of this on pH of the intermembrane space of the mitochondria.\nProvided Answer:\n“The H+ ion gradient would gradually decrease and the pH would gradually increase. The other proteins in the chain are still able to produce the H+ ion gradient. However, a non-functional, final protein in the electron transport chain would mean that oxygen is not shuttling electrons away from the electron transport chain. This would cause a backup in the chain, and the other proteins in the electron transport chain would no longer be able to accept electrons and pump H+ ions into the intermembrane space. A concentration decrease in the H+ ions means an increase in the pH.”\nSolution 5 The electron transport chain is shown in Fig 9.15 (1) of Campbell’s book. In order to explain the effect on pH, we will show the change in the execution of the electron transport chain with both a functioning and non-functioning final protein. Since pH depends upon the concentration of H+ ions, we will quantify the difference its quantity in the intermembrane space in both scenarios as well. We assume that a steady input of NADH, FADH2, H+ and O2 are available in the mitochondrial matrix. We also assume an electron carrying capacity of 2 for both ubiquinone (Q)4 and cytochrome c (Cyt c). This carrying capacity is background information not provided in Campbell’s Chapter 9. As with previous questions, we fulfill the steady supply requirement of substances by having input quantities in excess of what would be consumed during our simulation interval.\n4http://www.benbest.com/nutrceut/CoEnzymeQ.html\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 52\nWe model this problem as a colored petri net shown in Figure 3.10. The normal situation is made up of the entire graph. The abnormal situation (with non-functional final protein complex) is modeled by removing transition t4 from the graph5. We encode both situations in ASP with maximal firing set policy. Both are run for 10 steps. The amount of h (H+) is compared in the is (intermembrane space) to determine change in pH and the firing sequence is compared to explain the effect.\nIn normal situation (entire graph), we get the following:\nfires(t1,0) fires(t2,0) fires(t3,1) fires(t1,2) fires(t2,2) fires(t3,2) fires(t4,2) fires(t3,3) fires(t4,3) fires(t6,3) fires(t1,4) fires(t2,4) fires(t3,4) fires(t4,4) fires(t6,4) fires(t3,5) fires(t4,5) fires(t6,5) fires(t1,6) fires(t2,6) fires(t3,6) fires(t4,6) fires(t6,6) fires(t3,7) fires(t4,7) fires(t6,7)\n5Alternatively, we can model a non-functioning transition by attaching an inhibition arc to it with one token at its source place\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 53\nfires(t1,8) fires(t2,8) fires(t3,8) fires(t4,8) fires(t6,8) fires(t3,9) fires(t4,9) fires(t6,9) fires(t1,10) fires(t2,10) fires(t3,10) fires(t4,10) fires(t6,10)\nholds(is,15,h,10)\nwith t4 removed, we get the following:\nfires(t1,0) fires(t2,0) fires(t3,1) fires(t1,2) fires(t2,2) fires(t3,2) fires(t6,3) fires(t6,4)\nholds(is,2,h,10)\nNote that the amount of H+ (h) produced in the intermembrane space (is) is much smaller when the final protein complex is non-functional (t4 removed). Lower H+ translates to higher pH. Thus, the pH of intermembrane space will increase as a result of nonfunctional final protein. Also, note that the firing of t3, t1 and t2 responsible for shuttling electrons also stop very quickly when t4 no longer removes the electrons (e) from Cyt c (cytc) to produce H2O. This is because cytc and q are at their capacity on electrons that they can carry and stop the electron transport chain by inhibiting transitions t3, t2 and t1. Trend for various runs is shown in Figure 3.11.\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 54\n3.7 Comparing Altered Trajectories due to Gradient Equilization Intervention\nQuestion 6 Exposure to a toxin caused the membranes to become permeable to ions. In a mitochondrion, how would this affect the pH in the intermembrane space and also ATP production?\nProvided Answer:\n“The pH of the intermembrane space would decrease as H+ ions diffuse through the membrane, and the H+ ion gradient is lost. The H+ gradient is essential in ATP production b/c facilitated diffusion of H+ through ATP synthase drives ATP synthesis. Decreasing the pH would lead to a decrease in the rate of diffusion through ATP synthase and therefore a decrease in the production of ATP.”\nSolution 6 Oxidative phosphorylation is shown in Fig 9.15 of Campbell’s book. In order to explain the effect on pH in the intermembrane space and the ATP production we will show the change in the amount of H+ ions in the intermembrane space as well as the amount of ATP produced when the inner mitochondrial membrane is impermeable and permeable. Note that the concentration of H+ determines the pH. we have chosen to simplify the diagram by not having FADH2 in the picture. Its removal does not change the response, since it provides an alternate input mechanism to electron transport chain. We will assume that a steady input of NADH, H+, O2, ADP and P is available in the mitochondrial matrix. We also assume an electron carrying capacity of 2 for both ubiquinone (Q) and cytochrome c (Cyt c). We fulfill the steady supply requirement of substances by having input quantities in excess of what would be consumed during our simulation interval.\nWe model this problem as a colored petri net shown in Figure 3.12. Transition t6, t7 shown in dotted style are added to model the abnormal situation6. They capture the diffusion of H+ ions back from Intermembrane Space to the Mitochondrial matrix. One or both may be enabled to capture degrees of permeability. we have added a condition on the firing of t5 (ATP Synthase activation) to enforce gradient to pump ATP Synthase.\n6If reverse permeability is also desired additional arcs may be added from mm to is\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 55\nWe encode both situations in ASP with maximal firing set policy. Both are run for 10 steps each and the amount of h and atp is compared to determine the effect of pH and ATP production. We capture the gradient requirement as the following ASP code7:\nnotenabled(T,TS) :-\nT==t5, C==h, trans(T), col(C), holds(is,Qis,C,TS),\nholds(mm,Qmm,C,TS), Qmm+3 > Qis,\nnum(Qis;Qmm), time(TS).\nIn the normal situation, we get the following h token distribution after 10 steps:\nholds(is,11,h,10) holds(mm,1,h,10) holds(mm,6,atp,10)\nwe change the permeability to 1 (t6 enabled), we get the following token distribution instead:\nholds(is,10,h,10) holds(mm,2,h,10) holds(mm,5,atp,10)\nwe change the permeability to 2 (t6, t7 enabled), the distribution changes as follows:\nholds(is,8,h,10) holds(mm,4,h,10) holds(mm,2,atp,10)\n7We can alternatively model this by having a threshold arc from “is” to “t5” if only a minimum trigger quantity is required in the intermembrane space.\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 56\nNote that as the permeability increases, the amount of H+ (h) in intermembrane space (is) decreases and so does the amount of ATP (h) in mitochondrial matrix. Thus, an increase in permeability will increase the pH. If the permeability increases even beyond 2, no ATP will be produced from ADP due to insufficient H+ gradient. Trend from various runs is shown in Figure 3.13.\nQuantity of H+ and ATP produced by various run lengths and permeabilities\n3.8 Comparing Altered Trajectories due to Delay Intervention\nQuestion 7 Membranes must be fluid to function properly. How would decreased fluidity of the membrane affect the efficiency of the electron transport chain?\nProvided Answer:\n“Some of the components of the electron transport chain are mobile electron carriers, which means they must be able to move within the membrane. If fluidity decreases, these movable components would be encumbered and move more slowly. This would cause decreased efficiency of the electron transport chain.”\nSolution 7 The answer deals requires background knowledge about fluidity and how it relates to mobile carriers not presented in the source chapter. From background knowledge we find that the higher the fluidity, higher the mobility. The electron transport chain is presented in Fig 9.15 of Campbell’s book. From background knowledge, we know that the efficiency of the electron transport chain is measured by the amount of ATP produced per NADH/FADH2. The ATP\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 57\nproduction happens due to the gradient of H+ ions across the mitochondrial membrane. The higher the number of H+ ions in the intermembrane space, the higher would be the gradient and the resulting efficiency. So we measure the efficiency of the chain by the amount of H+ transported to intermembrane space, assuming all other (fixed) molecules behave normally. This is a valid assumption since H+ transported from mitochondrial matrix is directly proportional to the amount of electrons shuttled through the non-mobile complexes and there is a linear chain from the electron carrier to oxygen.\nWe model this chain using a Petri Net with durative transitions shown in Figure 3.14. Higher the duration of transitions, lower the fluidity of the membrane. We assume that a steady supply of NADH and H+ is available in the mitochondrial membrane. We fulfill this requirement by having quantities in excess of what will be consumed during the simulation. We ignore FADH2 from the diagram, since it is just an alternate path to the electron chain. Using it by itself will produce a lower number of H+ transporter to intermembrane space, but it will not change the result. We compare the amount of H+ transported into the intermembrane space to gauge the efficiency of the electron transport chain. More efficient the chain is, more H+ will it transport.\nWe model three scenarios: normal fluidity, low fluidity with transitions t3 and t4 having an execution time of 2 and an lower fluidity with transitions t3, t4 having execution time of 4.\nWe encode these cases in ASP with maximal firing set semantics and simulate them for 10 time steps. For the normal fluidity we get:\nholds(is,27,h,10)\nfor low fluidity we get:\nholds(is,24,h,10)\nfor lower fluidity we get:\nholds(is,18,h,10)\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 58\nNote that as the fluidity decreases, so does the amount of H+ transported to intermembrane space, pointing to lower efficiency of electron transport chain. Trend of various runs is shown in Figure 3.15.\nQuantity of H+ produced by various run lengths fluidity (simulated by transition duration)\n3.9 Comparing Altered Trajectories due to Priority and Read Interventions\nQuestion 8 Phosphofructokinase (PFK) is allosterically regulated by ATP. Considering the result of glycolysis, is the allosteric regulation of PFK likely to increase or decrease the rate of activity for this enzyme?\nProvided Answer:\n“Considering that one of the end products of glycolysis is ATP, PFK is inhibited when ATP is abundant and bound to the enzyme. The inhibition decreases ATP production along this pathway.”\nSolution 8 Regulation of Phosphofructokinase (PFK) is presented in Figure 9.20 of Campbell’s book. We ignore substances upstream of Fructose 6-phosphate (F6P) by assuming they are available in abundance. We also ignore AMP by assuming normal supply of it. We also ignore any output of glycolysis other than ATP production since the downstream processes ultimately produce additional ATP. Citric acid is also ignored since it is not relevant to the question at hand. We monitor the rate of activity of PFK by the number of times it gets used for glycolysis.\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 59\nWe model this problem as a Petri Net shown in Figure 3.16. Allosteric regulation of PFK is modeled by a compound “pfkatp” which represents PFK’s binding with ATP to form a compound. Details of allosteric regulation are not provided in the same chapter, they are background knowledge from external sources. Higher than normal quantity of ATP is modeled by a threshold arc (shown with arrow-heads at both ends) with an arbitrary threshold value of 4. This number can be increased as necessary. The output of glycolysis and down stream processes “t3” has been set to 2 to run the simulation in a reasonable amount of time. It can be made larger as necessary. The allosteric regulation transition “t4” has also been given a higher priority than glycolysis transition “t3”. This way, ATP in excess will cause PFK to be converted to PFK+ATP compound, reducing action of PFK.\nWe assume that F6P is available in sufficient quantity and so is PFK. This requirement is fulfilled by having more quantity than can be consumed in the simulation duration. We model both the normal situation including transition t4 shown in dotted style and the abnormal situation where t4 is removed.\nWe encode both situations in ASP with maximal firing set policy and run them for 10 time steps. At the end of the run we compare the firing count of transition t3 for both cases. For the normal case (with t4), we get the following results:\nholds(atp,0,c,0) holds(f6p,20,c,0) holds(pfk,20,c,0) holds(pfkatp,0,c,0) fires(t3,0) holds(atp,2,c,1) holds(f6p,19,c,1) holds(pfk,19,c,1) holds(pfkatp,0,c,1) fires(t3,1) holds(atp,4,c,2) holds(f6p,18,c,2) holds(pfk,18,c,2) holds(pfkatp,0,c,2) fires(t4,2) holds(atp,3,c,3) holds(f6p,18,c,3) holds(pfk,17,c,3) holds(pfkatp,1,c,3) fires(t3,3)\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 60\nholds(atp,5,c,4) holds(f6p,17,c,4) holds(pfk,16,c,4) holds(pfkatp,1,c,4) fires(t4,4) holds(atp,4,c,5) holds(f6p,17,c,5) holds(pfk,15,c,5) holds(pfkatp,2,c,5) fires(t4,5) holds(atp,3,c,6) holds(f6p,17,c,6) holds(pfk,14,c,6) holds(pfkatp,3,c,6) fires(t3,6) holds(atp,5,c,7) holds(f6p,16,c,7) holds(pfk,13,c,7) holds(pfkatp,3,c,7) fires(t4,7) holds(atp,4,c,8) holds(f6p,16,c,8) holds(pfk,12,c,8) holds(pfkatp,4,c,8) fires(t4,8) holds(atp,3,c,9) holds(f6p,16,c,9) holds(pfk,11,c,9) holds(pfkatp,5,c,9) fires(t3,9) holds(atp,5,c,10) holds(f6p,15,c,10) holds(pfk,10,c,10) holds(pfkatp,5,c,10) fires(t4,10)\nNote that t3 fires only when the ATP falls below our set threshold, above it PFK is converted to PFK+ATP compound via t4. For the abnormal case (without t4) we get the following results:\nholds(atp,0,c,0) holds(f6p,20,c,0) holds(pfk,20,c,0) holds(pfkatp,0,c,0) fires(t3,0) holds(atp,2,c,1) holds(f6p,19,c,1) holds(pfk,19,c,1) holds(pfkatp,0,c,1) fires(t3,1) holds(atp,4,c,2) holds(f6p,18,c,2) holds(pfk,18,c,2) holds(pfkatp,0,c,2) fires(t3,2) holds(atp,6,c,3) holds(f6p,17,c,3) holds(pfk,17,c,3) holds(pfkatp,0,c,3) fires(t3,3) holds(atp,8,c,4) holds(f6p,16,c,4) holds(pfk,16,c,4) holds(pfkatp,0,c,4) fires(t3,4) holds(atp,10,c,5) holds(f6p,15,c,5) holds(pfk,15,c,5) holds(pfkatp,0,c,5) fires(t3,5) holds(atp,12,c,6) holds(f6p,14,c,6) holds(pfk,14,c,6) holds(pfkatp,0,c,6) fires(t3,6) holds(atp,14,c,7) holds(f6p,13,c,7) holds(pfk,13,c,7) holds(pfkatp,0,c,7) fires(t3,7) holds(atp,16,c,8) holds(f6p,12,c,8) holds(pfk,12,c,8) holds(pfkatp,0,c,8) fires(t3,8) holds(atp,18,c,9) holds(f6p,11,c,9) holds(pfk,11,c,9) holds(pfkatp,0,c,9) fires(t3,9) holds(atp,20,c,10) holds(f6p,10,c,10) holds(pfk,10,c,10) holds(pfkatp,0,c,10) fires(t3,10)\nNote that when ATP is not abundant, transition t3 fires continuously, which represents the enzymic activity that converts F6P to downstream substances. Trend of various runs is shown in Figure 3.17.\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 61\n3.10 Comparing Altered Trajectories due to Automatic Conversion Intervention\nQuestion 9 How does the oxidation of NADH affect the rate of glycolysis?\nProvided Answer:\n“NADH must be oxidized back to NAD+ in order to be used in glycolysis. Without this molecule, glycolysis cannot occur.”\nSolution 9 Cellular respiration is summarized in Fig 9.6 of Campbell’s book. NAD+ is reduced to NADH during glycolysis (see Campbell’s Fig 9.9) during the process of converting Glyceraldehyde 3-phosphate (G3P) to 1,3-Bisphosphoglycerate (BPG13). NADH is oxidized back to NAD+ during oxidative phosphorylation by the electron transport chain (see Campbell’s Fig 9.15). We can gauge the rate of glycolysis by the amount of Pyruvate produced, which is the end product of glycolysis. We simplify our model by abstracting glycolysis as a black-box that takes Glucose and NAD+ as input and produces NADH and Pyruvate as output, since there is a linear chain from Glucose to Pyruvate that depends upon the availability of NAD+. We also abstract oxidative phosphorylation as a black-box which takes NADH as input and produces NAD+ as output. None of the other inner workings of oxidative phosphorylation play a role in answering the question assuming they are functioning normally. We also ignore the pyruvate oxidation and citric acid cycle stages of cellular respiration since their end products only provide additional raw material for oxidative phosphorylation and do not add value to answering the question.\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 62\nWe assume a steady supply of Glucose and all other substances used in glycolysis but a limited supply of NAD+, since it can be recycled from NADH and we want to model its impact. We fulfill the steady supply requirement of Glucose with sufficient initial quantity in excess of what will be consumed during our simulation interval. We also ensure that we have sufficient initial quantity of NAD+ to maintain glycolysis as long as it can be recycled.\nFigure 3.18 is a Petri Net representation of our simplified model. Normal situation is modeled by the entire graph, where NADH is recycled back to NAD+, while the abnormal situation is modeled by the graph with the transition ox1 (shown in dotted style) removed. We encode both situations in ASP with the maximal firing set policy. Both situations are run for 5 steps and the amount of pyruvate is compared to determine the difference in the rate of glycolysis.\nIn normal situation (with ox1 transition), unique quantities of pyruvate (pyr) are as follows:\nfires(gly1,0) fires(gly1,1) fires(gly1,2) fires(gly1,3) fires(gly1,4)\nholds(pyr,10,5)\nwhile in abnormal situation (without ox1 transition), unique quantities of pyruvate are as follows:\nfires(gly1,0) fires(gly1,1) fires(gly1,2)\nholds(pyr,6,5)\nNote that the rate of glycolysis is lower when NADH is not recycled back to NAD+, as the glycolysis stops after the initial quantity of 6 NAD+ is consumed. Also, the gly1 transition does\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 63\nnot fire after time-step 2, indicating glycolysis has stopped. Trend of various runs is shown in Figure 3.19.\n3.11 Comparing Altered Trajectories due to Initial Value Intervention\nQuestion 10 During intense exercise, can a muscle cell use fat as a concentrated source of chemical energy? Explain.\nProvided Answer:\n“When oxygen is present, the fatty acid chains containing most of the energy of a fat are oxidized and fed into the citric acid cycle and the electron transport chain. During intense exercise, however, oxygen is scarce in muscle cells, so ATP must be generated by glycolysis alone. A very small part of the fat molecule, the glycerol backbone, can be oxidized via glycolysis, but the amount of energy released by this portion is insignificant compared to that released by the fatty acid chains. (This is why moderate exercise, staying below 70% maximum heart rate, is better for burning fat because enough oxygen remains available to the muscles.)”\nSolution 10 The process of fat consumption in glycolysis and citric acid cycle is summarized in\nFig 9.19 of Campbell’s book. Fats are digested into glycerol and fatty acids. Glycerol gets fed into glycolysis after being converted into Gyceraldehyde 3-phosphate (G3P), while fatty acids get fed into citric acid cycle after being broken down through beta oxidation and converted into\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 64\nAcetyl CoA. Campbell’s Fig 9.18 identify a junction in catabolism where aerobic respiration or fermentation take place depending upon whether oxygen is present or not. Energy produced at various steps is in terms of ATP produced. In order to explain whether fat can be used as a concentrated source of chemical energy or not, we have to show the different ways of ATP production and when they kick in.\nWe combine the various pieces of information collected from Fig 9.19, second paragraph on second column of p/180, Fig 9.15, Fig 9.16 and Fig 9.18 of Campbell’s book into Figure 3.20. We model two situations when oxygen is not available in the muscle cells (at the start of a intense exercise) and when oxygen is available in the muscle cells (after the exercise intensity is plateaued). We then compare and contrast them on the amount of ATP produced and the reasons for the firing sequences.\nFigure 3.20 is a petri net representation of our simplified model. Our edge labels have lower numbers on them than the yield in Fig 9.16 of Campbell’s book but they still capture the difference in volume that would be produced due to oxidative phosphorylation vs. glycolysis. Using exact amounts will only increase the difference of ATP production due to the two mechanisms. We encode both situations (when oxygen is present and when it is not) in ASP with maximal firing set policy. We run them for 10 steps. The firing sequence and the resulting yield of ATP explain what the possible use of fat as a source of chemical energy.\nAt he start of intense exercise, when oxygen is in short supply:\nholds(acoa,0,0) holds(atp,0,0) holds(fac,0,0) holds(fats,5,0) holds(g3p,0,0) holds(gly,0,0) holds(nadh,0,0) holds(o2,0,0) holds(pyr,0,0) fires(dig,0) holds(acoa,0,1) holds(atp,0,1) holds(fac,1,1) holds(fats,4,1)\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 65\nholds(g3p,0,1) holds(gly,1,1) holds(nadh,0,1) holds(o2,0,1) holds(pyr,0,1) fires(box1,1) fires(dig,1) fires(t2,1) holds(acoa,1,2) holds(atp,0,2) holds(fac,1,2) holds(fats,3,2) holds(g3p,1,2) holds(gly,1,2) holds(nadh,1,2) holds(o2,0,2) holds(pyr,0,2) fires(box1,2) fires(cac1,2) fires(dig,2) fires(gly6,2) fires(t2,2) holds(acoa,1,3) holds(atp,2,3) holds(fac,1,3) holds(fats,2,3) holds(g3p,1,3) holds(gly,1,3) holds(nadh,3,3) holds(o2,0,3) holds(pyr,1,3) fires(box1,3) fires(cac1,3) fires(dig,3) fires(fer1,3) fires(gly6,3) fires(t2,3) holds(acoa,1,4) holds(atp,4,4) holds(fac,1,4) holds(fats,1,4) holds(g3p,1,4) holds(gly,1,4) holds(nadh,5,4) holds(o2,0,4) holds(pyr,1,4) fires(box1,4) fires(cac1,4) fires(dig,4) fires(fer1,4) fires(gly6,4) fires(t2,4) holds(acoa,1,5) holds(atp,6,5) holds(fac,1,5) holds(fats,0,5) holds(g3p,1,5) holds(gly,1,5) holds(nadh,7,5) holds(o2,0,5) holds(pyr,1,5) fires(box1,5) fires(cac1,5) fires(fer1,5) fires(gly6,5) fires(t2,5) holds(acoa,1,6) holds(atp,8,6) holds(fac,0,6) holds(fats,0,6) holds(g3p,1,6) holds(gly,0,6) holds(nadh,9,6) holds(o2,0,6) holds(pyr,1,6) fires(cac1,6) fires(fer1,6) fires(gly6,6) holds(acoa,0,7) holds(atp,10,7) holds(fac,0,7) holds(fats,0,7) holds(g3p,0,7) holds(gly,0,7) holds(nadh,10,7) holds(o2,0,7) holds(pyr,1,7) fires(fer1,7) holds(acoa,0,8) holds(atp,10,8) holds(fac,0,8) holds(fats,0,8) holds(g3p,0,8) holds(gly,0,8) holds(nadh,10,8) holds(o2,0,8) holds(pyr,0,8) holds(acoa,0,9) holds(atp,10,9) holds(fac,0,9) holds(fats,0,9) holds(g3p,0,9) holds(gly,0,9) holds(nadh,10,9) holds(o2,0,9) holds(pyr,0,9) holds(acoa,0,10) holds(atp,10,10) holds(fac,0,10) holds(fats,0,10) holds(g3p,0,10) holds(gly,0,10) holds(nadh,10,10) holds(o2,0,10) holds(pyr,0,10)\nwhen the exercise intensity has plateaued and oxygen is no longer in short supply:\nholds(acoa,0,0) holds(atp,0,0) holds(fac,0,0) holds(fats,5,0) holds(g3p,0,0) holds(gly,0,0) holds(nadh,0,0) holds(o2,10,0) holds(pyr,0,0) fires(dig,0) holds(acoa,0,1) holds(atp,0,1) holds(fac,1,1) holds(fats,4,1) holds(g3p,0,1) holds(gly,1,1) holds(nadh,0,1) holds(o2,10,1) holds(pyr,0,1) fires(box1,1) fires(dig,1) fires(t2,1) holds(acoa,1,2) holds(atp,0,2) holds(fac,1,2) holds(fats,3,2) holds(g3p,1,2) holds(gly,1,2) holds(nadh,1,2) holds(o2,10,2) holds(pyr,0,2) fires(box1,2) fires(cac1,2) fires(dig,2) fires(gly6,2) fires(op1,2) fires(t2,2) holds(acoa,1,3) holds(atp,5,3) holds(fac,1,3) holds(fats,2,3) holds(g3p,1,3) holds(gly,1,3) holds(nadh,2,3) holds(o2,9,3) holds(pyr,1,3) fires(box1,3) fires(cac1,3) fires(dig,3) fires(gly6,3) fires(op1,3)\nfires(ox1,3) fires(t2,3)\nholds(acoa,2,4) holds(atp,10,4) holds(fac,1,4) holds(fats,1,4) holds(g3p,1,4) holds(gly,1,4) holds(nadh,4,4) holds(o2,8,4) holds(pyr,1,4) fires(box1,4) fires(cac1,4) fires(dig,4) fires(gly6,4) fires(op1,4)\nfires(ox1,4) fires(t2,4)\nholds(acoa,3,5) holds(atp,15,5) holds(fac,1,5) holds(fats,0,5) holds(g3p,1,5) holds(gly,1,5) holds(nadh,6,5) holds(o2,7,5) holds(pyr,1,5) fires(box1,5) fires(cac1,5) fires(gly6,5) fires(op1,5) fires(ox1,5) fires(t2,5) holds(acoa,4,6) holds(atp,20,6) holds(fac,0,6) holds(fats,0,6) holds(g3p,1,6) holds(gly,0,6) holds(nadh,8,6) holds(o2,6,6) holds(pyr,1,6) fires(cac1,6) fires(gly6,6) fires(op1,6) fires(ox1,6)\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 66\nholds(acoa,4,7) holds(atp,25,7) holds(fac,0,7) holds(fats,0,7) holds(g3p,0,7) holds(gly,0,7) holds(nadh,9,7) holds(o2,5,7) holds(pyr,1,7) fires(cac1,7) fires(op1,7) fires(ox1,7) holds(acoa,4,8) holds(atp,29,8) holds(fac,0,8) holds(fats,0,8) holds(g3p,0,8) holds(gly,0,8) holds(nadh,10,8) holds(o2,4,8) holds(pyr,0,8) fires(cac1,8) fires(op1,8) holds(acoa,3,9) holds(atp,33,9) holds(fac,0,9) holds(fats,0,9) holds(g3p,0,9) holds(gly,0,9) holds(nadh,10,9) holds(o2,3,9) holds(pyr,0,9) fires(cac1,9) fires(op1,9) holds(acoa,2,10) holds(atp,37,10) holds(fac,0,10) holds(fats,0,10) holds(g3p,0,10) holds(gly,0,10) holds(nadh,10,10) holds(o2,2,10) holds(pyr,0,10) fires(cac1,10) fires(op1,10)\nWe see that more ATP is produced when oxygen is available. Most ATP (energy) is produced by the oxidative phosphorylation which requires oxygen. When oxygen is not available, small amount of energy is produced due to glycolysis of glycerol (gly). With oxygen a lot more energy is produced, most of it due to fatty acids ( f ac). Trend of various runs is shown in Figure 3.21.\n3.12 Conclusion\nIn this chapter we presented how to model biological systems as Petri Nets, translated them into ASP, reasoned with them and answered questions about them. We used diagrams from Campbell’s book, background knowledge and assumptions to facilitate our modeling work. However, source knowledge for real world applications comes from published papers, magazines and books. This means that we have to do text extraction. In one of the following chapters we look at some of the real applications that we have worked on in the past in collaboration with other researchers to develop models using text extraction. But first, we look at how we use the concept\nCHAPTER 3. ANSWERING QUESTIONS USING PETRI NETS AND ASP 67\nof answering questions using Petri Nets to build a question answering system. We will extend the Petri Nets even more for this.\nChapter 4\nBioPathQA - A System for Modeling, Simulating, and Querying Biological Pathways\n4.1 Introduction\nIn this chapter we combine the methods from Chapter 3, notions from action languages, and ASP to build a system BioPathQA and a language to specify pathways and query them. We show how various biological pathways are encoded in BioPathQA and how it computes answers of queries against them.\n4.2 Description of BioPathQA\nOur system has the following components: (i) a pathway specification language (ii) a query language to specify the deep reasoning question, (iii) an ASP program that encodes the pathway model and its extensions for simulation.\nKnowledge about biological pathways comes in many different forms, such as cartoon diagrams, maps with well defined syntax and semantics (e.g. Kohn’s maps Kohn et al. (2006)), and biological publications. Similar to other technical domains, some amount of domain knowledge is also required. Users want to collect information from disparate sources and encode it in a pathway specification. We have developed a language to allow users to describe their pathway. This description includes describing the substances and actions that make up the pathway, the initial state of the substances, and how the state of the pathway changes due to the actions. An evolution of a pathway’s state from the initial state, through a set of actions is called a trajectory. Being a specification language targeted at biological systems, multiple actions autonomously execute in parallel as soon as their preconditions are satisfied. The amount of parallelism is dictated by any resource conflicts between the actions. When that occurs, only one sub-set of the possible actions can execute, leading to multiple outcomes from that point on.\n68\nCHAPTER 4. THE BIOPATHQA SYSTEM 69\nQuestions are usually provided in natural language, which is vague. To avoid the vagaries of natural language, we developed a language with syntax close to natural language but with a well defined formal semantics. The query language allows a user to make changes to the pathway through interventions, and restrict its trajectories through observations and query on aggregate values in a trajectory, across a set of trajectories and even over two sets of trajectories. This allows the user to compare a base case of a pathway specification with an alternate case modified due to interventions and observations. This new feature is a major contribution of our research.\nInspiration for our high level language comes from action languages and query languages such as Gelfond and Lifschitz (1993). While action languages generally describe transition systems Gelfond and Lifschitz (1998), our language describes trajectories. In addition, our language is geared towards modeling natural systems, in which actions occur autonomously Reiter (1996) when their pre-conditions are satisfied; and we do not allow the quantities to become negative (as the quantities represent amounts of physical entities).\nNext we describe the syntax of our pathway specification language and the query language. Following that we will describe the syntax of our language and how we encode it in ASP.\n4.3 Syntax of Pathway Specification Language (BioPathQA-PL)\nThe alphabet of pathway specification languageP consists of disjoint nonempty domain-dependent sets A, F, L representing actions, fluents, and locations, respectively; a fixed set S of firing styles; a fixed set K of keywords providing syntactic sugar (shown in bold face in pathway specification language below); a fixed set of punctuations {‘,′ }; and a fixed set of special constants {‘1′, ‘∗′, ‘max′}; and integers.\nEach fluent f ∈ F has a domain dom( f ) which is either integer or binary and specifies the values f can take. A fluent is either simple, such as f or locational, such as f [l], where l ∈ L. A state s is an interpretation of F that maps fluents to their values. We write s( f ) = v to represent “ f has the value v in state s”. States are indexed, such that consecutive states si and si+1 represent an evolution over one time step from i to i + 1 due to firing of an action set Ti in si.\nWe illustrate the role of various symbols in the alphabet with examples from the biological domain. Consider the following example of a hypothetical pathway specification:\ndomain of sug is integer, f ac is integer, acoa is integer, h2o is integer (4.1) gly may execute causing sug change value by − 1, acoa change value by + 1 (4.2) box may execute causing f ac change value by − 1, acoa change value by + 1 (4.3)\nif h2o has value 1 or higher (4.4) inhibit box if sug has value 1 or higher (4.5) initially sug has value 3, f ac has value 4, acoa has value 0 (4.6)\nCHAPTER 4. THE BIOPATHQA SYSTEM 70\nIt describes two processes glycolysis and beta-oxidation represented by actions ‘gly’ and ‘box’ in lines (4.2) and (4.3)-(4.4) respectively. Substances used by the pathway, i.e. sugar, fattyacids, acetyl-CoA, and water are represented by numeric fluents ‘sug’,‘ f ac’,‘acoa’, and ‘h2o’ respectively in line (4.1). When glycolysis occurs, it consumes 1 unit of sugar and produces 1 unit of acetyl-CoA (line (4.2). When beta-oxidation occurs, it consumes 1 unit of fatty-acids and produces 1 unit of acetyl-CoA (line (4.3)). The inputs of glycolysis implicitly impose a requirement that glycolysis can only occur when at least 1 unit of sugar is available. Similarly, the input of beta-oxidation implicitly a requirement that beta-oxidation can only occur when at least 1 unit of fatty-acids is available. Beta oxidation has an additional condition imposed on it in line (4.4) that there must be at least 1 unit of water available. We call this a guard condition on beta-oxidation. Line (4.5) explictly inhibits beta-oxidation when there is any sugar available; and line (4.6) sets up the initial conditions of the pathway, i.e. Initially 3 units of each sugar, 4 units of fatty-acids are available and no acetyl-CoA is available. The words ‘{domain, is, may, execute, causing, change, value, by, has, or, higher, inhibit, i f , initially}’ are keywords.\nWhen locations are involved, locational fluents take place of simple fluents and our representation changes to include locations. For example:\ngly may execute causing sug atloc mm change value by − 1, acoa atloc mm change value by + 1\nrepresents glycolysis taking 1 unit of sugar from mitochondrial matrix (represented by ‘mm’) and produces acetyl-CoA in the mitochondrial matrix. Here ‘atloc’ is an additional keyword.\nA pathway is composed of a collection of different types of statements and clauses. We first introduce their syntax, following that we will give intuitive definitions, and following that we will show how they are combined together to construct a pathway specification.\nDefinition 46 (Fluent domain declaration statement) A fluent domain declaration statement declares the values a fluent can take. It has the form:\ndomain of f is ‘integer′|‘binary′ (4.7) domain of f atloc l is ‘integer′|‘binary′ (4.8)\nfor simple fluent “ f ”, and locational fluent “ f [l]”. Multiple domain statements are compactly written as:\ndomain of f1 is ‘integer′|‘binary′, . . . , fn is ‘integer′|‘binary′ (4.9) domain of f1 atloc l1 is ‘integer′|‘binary′, . . . , fn atloc ln is ‘integer′|‘binary′ (4.10)\nBinary domain is usually used for representing substances in a signaling pathway, while a metabolic pathways take positive numeric values. Since the domain is for a physical entity, we do not allow negative values for fluents.\nDefinition 47 (Guard condition) A guard condition takes one of the following forms:\nf has value w or higher (4.11) f atloc l has value w or higher (4.12)\nCHAPTER 4. THE BIOPATHQA SYSTEM 71\nf has value lower than w (4.13) f atloc l has value lower than w (4.14) f has value equal to w (4.15) f atloc l has value equal to w (4.16) f1 has value higher than f2 (4.17) f1 atloc l1 has value higher than f2 atloc l2 (4.18)\nwhere, each f in (4.11), (4.13), (4.15), (4.17) is a simple fluent, each f [l] in (4.12), (4.14), (4.16), (4.18) is a locational fluent with location l, and each w ∈ N+ ∪ {0}.\nDefinition 48 (Effect clause) An effect clause can take one of the following forms:\nf change value by e (4.19) f atloc l change value by e (4.20)\nwhere a is an action, f in (4.19) is a simple fluent, f [l] in (4.20) is a locational fluent with location l, e ∈ N+ ∪ {∗} for integer fluents or e ∈ {1,−1, ∗} for binary fluents.\nDefinition 49 (May-execute statement) A may-execute statement captures the conditions for firing an action a and its impact. It is of the form:\na may execute causing effect1, . . . , effectm if guard cond1, . . . , guard condn (4.21)\nwhere effecti is an effect clause; and guard cond j is a guard condition clause, m > 0, and n ≥ 0. If n = 0, the effect statement is unconditional (guarded by >) and the if is dropped. A single may-execute statement must not have effecti, effect j with ei < 0, e j < 0 for the same fluent; or ei > 0, e j > 0 for the same fluent.\nDefinition 50 (Must-execute statement) An must-execute statement captures the impact of firing of an action a that must fire when enabled (as long as it is not inhibited). It is an expression of the form:\na normally must execute causing effect1, . . . , effectm if guard cond1, . . . , guard condn (4.22)\nwhere effecti, and guard cond j are as in (4.21) above.\nDefinition 51 (Inhibit statement) An inhibit statement captures the conditions that inhibit an action from occurring. It is an expression of the form:\ninhibit a if guard cond1, . . . , guard condn (4.23)\nwhere a is an action, guard condi is a guard condition clause, and n ≥ 0. if n = 0, the inhibition of action ‘a’ is unconditional ‘if’ is dropped.\nDefinition 52 (Initial condition statement) An initial condition statement captures the initial state of pathway. It is of the form:\ninitially f has value w (4.24)\nCHAPTER 4. THE BIOPATHQA SYSTEM 72\ninitially f atloc l has value w (4.25)\nwhere each f in (4.24) is a simple fluent, f [l] in (4.25) is a locational fluent with location l, and each w is a non-negative integer. Multiple initial condition statements are written compactly as:\ninitially f1 has value w1, . . . , fn has value wn initially f1 atloc l1 has value w1, . . . , fn atloc ln has value wn\nDefinition 53 (Duration Statement) A duration statement represents the duration of an action that takes longer than a single time unit to execute. It is of the form:\na executes in d time units (4.26)\nwhere d is a positive integer representing the action duration.\nDefinition 54 (Stimulate Statement) A stimulate statement changes the rate of an action. It is an expression of the form:\nnormally stimulate a by factor n if guard cond1, . . . , guard condn (4.27)\nwhere guard condi is a condition, n > 0. When n = 0, the stimulation is unconditional and if is dropped. A stimulation causes the effect in may-cause and must-fire multiplied by n.\nActions execute automatically when fireable, subject to the available fluent quantities.\nDefinition 55 (Firing Style Statement) A firing style statement specifies how many actions execute simultaneously (or action parallelism). It is of the form:\nfiring style S (4.28)\nwhere, S is either “1”, “∗”, or “max” for serial execution, interleaved execution, and maximum parallelism.\nWe will now give the intuitive meaning of these statements and put them into context w.r.t. the biological domain. Though our description below uses simple fluents only, it applies to locational fluents in a obvious manner. The reason for having locational fluents at all is that they allow a more natural pathway specification when substance locations are involved instead of devising one’s own encoding scheme. For example, in a mitochondria, hydrogen ions (H+) appear in multiple locations (intermembrane space and mitochondrial matrix), with each location carrying its distinct quantity separate from other locations.\nIntuitively, a may-execute statement (4.21) represents an action a that may fire if all conditions ‘guard cond1, . . . , guard condn’ hold in the current state. When it executes, it impacts the state as specified in effects. In biological context, action a represents a process, such as a reaction, effects represent the inputs / ingredients of the reaction, and guard cond represent additional preconditions necessary for the reaction to proceed. Condition (4.11) holds in a state s if s( f ) ≥ w. It could represent an initiation concentration w of a substance f which is higher than the quantity consumed by the reaction a. Condition (4.13) holds in a state s if s( f ) < w. Condition (4.15) holds in a state s if s( f ) = w. Condition (4.17) holds in a state s if s( f1) > s( f2) capturing a situation where a substance gradient is required for a biological process to occur.\nCHAPTER 4. THE BIOPATHQA SYSTEM 73\nAn example of one such process is the synthesis of ATP by ATP Synthase, which requires a H+ (Hydrogen ion) gradient across the inner mitochondrial matrix (Reece et al., 2010, Figure 9.15).\nIntuitively, the effect clause (4.19) of an action describes the impact of an action on a fluent. When an action a fires in a state s, the value of f changes according to the effect clause for f . The value of f increases by e if e > 0, decreases by e if e < 0, or decreases by s( f ) if e = ‘∗′ (where ‘∗′ can be interpreted as −s( f )). For a reaction a, a fluent with e < 0 represents an ingredient consumed in quantity |e| by the reaction; a fluent with e > 0 represents a product of the reaction in quantity e; a fluent with e = ‘∗′ represents consuming all quantity of the substance due to the reaction. Since the fluents represent physical substances, their quantities cannot become negative. As a result, any action that may cause a fluent quantity to go below zero is disallowed.\nIntuitively, a must-execute statement (4.22) is similar to a may-exec, except that when enabled, it preferentially fires over other actions as long as there isn’t an inhibit proposition that will cause the action to become inactive. It captures the effect of an action that must happen whenever enabled.\nIntuitively, an inhibit statement (4.23) specifies the conditions that inhibits an action. In a biological context, it defines inhibition of reactions, e.g., through biological feedback control. Though we could have added these conditions to may-exec, it is more intuitive to keep them separate as inhibition conditions are usually discovered separately in a biological domain. Including them as part of may-fire would constitute a surgery of existing knowledge bases.\nIntuitively, an initial condition statement (4.24) specifies the initial values of fluents. The collection of such propositions defines the initial state s0 of the pathway. In a biological context, this defines the initial distribution of substances in the biological system.\nIntuitively, an action duration statement (4.26) represents action durations, especially when an action takes longer to execute. When an action a with duration d fires in state sk, it immediately decreases the values of fluents with e < 0 and e = ∗ upon execution, however, it does not increase the value of fluents with e > 0 until time the end of its execution in state sk+d. In a biological context the action duration captures a reaction’s duration. A reaction consumes its ingredients immediately on firing, processes them for duration d and generates its products at the end of this duration.\nIntuitively, a stimulate statement (4.27) represents a change in the rate of an action a. The stimulation causes the action to change its rate of consumption of its ingredients and production of its products by a factor n. In biological context, this stimulation can be a result of an enzyme or a stimulant’s availability, causing a reaction that normally proceeds slowly to occur faster.\nIntuitively, a firing style statement (4.28) specifies the parallelism of actions. When it is “1”, at most one action may fire, when it is “max”, the maximum allowable actions must fire, and when it is “∗”, any subset of fireable actions may fire simultaneously. In a biological domain the firing style allows one to model serial operations, parallel operations and maximally parallel operations. The maximum parallelism is also useful in quickly discovering changes that occur in a biological system.\nDefinition 56 (Pathway Specification) A pathway specification is composed of one or more\nCHAPTER 4. THE BIOPATHQA SYSTEM 74\nmay-execute, must-execute, effect, inhibit, stimulate, initially, priority, duration statements, and one firing style statement. When a duration statement is not specified for an action, it is assumed to be 1. Any fluents for which an initial quantity is not specified are assumed to have a value of zero.\nA pathway specification is consistent if (i) there is at most one firing style, priority, duration statement for each action a; (ii) the guard cond1, . . . , guard condn from a may-execute or mustexecute are disjoint from any other may-execute or must-execute 1; (iii) locational and nonlocational fluents may not be intermixed; (iv) domain of fluents, effects, conditions and numeric values are consistent, i.e., effects and conditions on binary fluents must be binary; and (v) the pathway specification does not cause it to violate fluent domains by producing non-binary values for binary fluents.\nEach pathway specification D represents a collection of trajectories of the form: σ = s0,T0, s1, . . . , sk−1,Tk−1, sk. Each trajectory encodes an evolution of the pathway starting from an initial state s0, where si’s are states, and Ti’s are sets of actions that fired in state si.\nIntuitively, a trajectory starts from the initial state s0. Each si, si+1 pair represents the state evolution in one time step due to the action set Ti. An action set Ti is only executable in state si, if the sum of changes to fluents due to ei < 0 and ei = ∗ will not result in any of the fluents going negative. Changes to fluents due to ei > 0 for the action set Ti occur over subsequent time-steps depending upon the durations of actions involved. Thus, the state si( fi) is the sum of ei > 0 for actions of duration d that occurred d time steps before (current time step) i, i.e. a ∈ Ti−d, where the default duration d of an action is 1 if none specified.\nNext we describe the semantics of the pathway specification language, which describes how these trajectories are generated.\n4.4 Semantics of Pathway Specification Language (BioPathQA-PL)\nThe semantics of the pathway specification language are defined in terms of the trajectories of the domain description D. Since our pathway specification language is inspired by Petri Nets, we use Petri Nets execution semantics to define its trajectories. However, some constructs in our pathway language specification are not directly representable in standard Petri Nets, as a result, we will have to extend them.\nLet an arc-guard be a conjunction of guard conditions of the form (4.11)-(4.18), such that it is wholly constructed of either locational or non-locational fluents, but not both.\nWe introduce a new type of Guarded-arc Petri Net in which each arc has an arc-guard expression associated with it. Arcs with the same arc-guard are traversed when a transition connected to them fires and the arc-guard is found to hold in the current state. The arc-guards of arcs connected to the same transition form an exclusive set, such that only arcs corresponding\n1Note that ‘ f 1 has value 5 or higher ’ overlaps with ‘ f 1 has value 7 or higher’ and the two conditions are not considered disjoint.\nCHAPTER 4. THE BIOPATHQA SYSTEM 75\nto one guard expression may fire (for one transition). This setup can lead to different outcomes of an action2.\nThe transitions in this new type of Petri Net can have the following inscriptions on them:\n1. Propositional formula, specifying the executability conditions of the transition.\n2. Arc-durations, represented as “dur(n)”, where n ∈ N+\n3. A must-execute inscription, “must-execute(guard)”, requires that when the guard holds in a state where this transition is enabled, it must fire, unless explicitly inhibited. The guard has the same form as an arc-guard\n4. A stimulation inscription, “stimulate(n, guard)”, applies a multiplication factor n ∈ N+ to the input and output quantities consumed and produced by the transition, when guard hold in the current state, where guard has the same form as an arc-guard.\nCertain aspects of our nets are similar to CPNs Jensen et al. (2007). However, the CPNs do not allow our semantics of the reset arcs, or must-fire guards.\n4.4.1 Guarded-Arc Petri Net\nFigure 4.1 shows an example of a guarded-arc Petri Net. There are two arc-guard expressions f 1 < 5 and f 1 > 5. When f 1 < 5, t1 consumes one token from place f 1 and produces one token in place f 2. When f 1 > 5, t1’s consumption and production of the same tokens doubles. The transition t1 implicitly gets the guards for each arc represented the or-ed conditions ( f 1 < 5) ∨ ( f 1 > 5)). The arc also has two conditions inhibiting it, they are represented by the and-ed conditions ¬( f 1 > 7) ∧ ¬( f 1 < 3), where ‘¬’ represents logical not. Transition t1 is stimulated by factor 3 when f 1 > 5 and it has a duration of 10 time units. A transition cannot fire even though one of its arc-guards is enabled, unless the token requirements on the arc itself are also fulfilled, e.g. if f 1 has value 0 in the current state, even though f 1 < 5 guard is satisfied, the transition cannot execute, because the input arc ( f 1, t1) for this guard needs 1 token.\n2Arcs for different guard expressions emanating / terminating at a place can further be combined into a single conditional arc with conditional arc-weights. If none of the condition applies then the arc is assumed to be missing.\nCHAPTER 4. THE BIOPATHQA SYSTEM 76\nDefinition 57 (Guard) A condition is of the form: ( f < v), ( f ≤ v), ( f > v), ( f ≥ v), ( f = v), where f is a fluent and v either a fluent or a numeric constant. Then, a guard is a propositional formula of conditions, with each condition treated as a proposition, subject to the restriction that all fluents in all conditions in a guard are either locational or simple, but not both.\nDefinition 58 (Interpretation of a Guard) An interpretation of a guard G is a possible assignment of a value to each fleuent f ∈ G from the domain of f .\nDefinition 59 (Guard Satisfaction) A guard G with simple fluents is satisfied w.r.t. a state s, written s |= G iff G has an interpretation in which each of its fluents f has the value s( f ) and G is true. A guard G with locational fluents is satisfied w.r.r. a state s, written s |= G iff G has an interpretation in which each of its fluents f [l] has the value ms(l)( f ) and G is true, where mX( f ) is the multiplicity of f in X.\nDefinition 60 (Guarded-Arc Petri Net) A Guarded-Arc Petri Net is a tuple PNG = (P,T,G, E,R,W,D, B,TG,MF, L), where:\nP is a finite set of places\nT is a finite set of transitions\nG is a set of guards as defined in definition (57)\nTG : T → G are the transition guards E ⊆ (T × P ×G) ∪ (P × T ×G) are the guarded arcs R ⊆ P × T ×G are the guarded reset arcs\nW : E → N+ are arc weights D : T → N+ are the transition durations B : T → G × N+ transition stimulation or boost\nMF : T → 2G must-fire guards for a transition L : P→ N+ specifies maximum number to tokens for each place\nsubject to constraints:\n1. P ∩ T = ∅\n2. R ∩ E = ∅\n3. Let t1 ∈ T and t2 ∈ T be any two distinct transitions, then g1 ∈ MF(t1) and g2 ∈ MF(t2) must not have an interpretation that make both g1 and g2 true.\n4. Let t ∈ T be a transition, and ggt = {g : (t, p, g) ∈ E}∪{g : (p, t, g) ∈ E}∪{g : (p, t, g) ∈ R} be the set of arc-guards for normal and reset arcs connected to it, then g1 ∈ ggt, g2 ∈ ggt must not have an interpretation that makes both g1 and g2 true.\nCHAPTER 4. THE BIOPATHQA SYSTEM 77\n5. Let t ∈ T be a transition, and ggt = {g : (g, n) ∈ B(t)} be its stimulation arc-guards, then g1 ∈ ggt, g2 ∈ ggt must not have an interpretation that makes both g1 and g2 true.\n6. Let t ∈ T be a transition, and (g, n) ∈ B(t) : n > 1, then there must not exist a place p ∈ P : (p, t, g) ∈ E, L(p) = 1. Intuitively, stimulation of binary inputs is not supported.\nWe will make a simplifying assumption that all places are readable by using their place names. Execution of the PNG occurs in discrete time steps.\nDefinition 61 (Marking (or State)) Marking (or State) of a Guarded-Arc Petri Net PNG is the token assignment of each place pi ∈ P. Initial marking M0 : P → N0, while the token assignment at step k is written as Mk.\nNext we define the execution semantics of PNG. First we introduce some terminology that will be used below. Let\n1. s0 = M0 represent the the initial marking (or state), sk = Mk represent the marking (or state) at time step k,\n2. sk(p) represent the marking of place p at time step k, such that sk = [sk(p0), . . . , sk(pn)], where P = {p0, . . . , pn}\n3. Tk be the firing-set that fired in step k,\n4. bk(t) be the stimulation value applied to a transition t w.r.t. step k\n5. enk be the set of enabled transitions in state sk,\n6. m fk be the set of must-execute transitions in state sk,\n7. consumek(p, {t1, . . . , tn}) be the sum of tokens that will be consumed from place p if transitions t1, . . . , tn fired in state sk,\n8. overck({t1, . . . , tn}) be the set of places that will have over-consumption of tokens if transitions t1, . . . , tn were to fire simultaneously in state sk,\n9. selk( f s) be the set of possible firing-set choices in state sk using fs firing style\n10. producek(p) be the total production of tokens in place p (in state sk) due to actions terminating in state sk,\n11. sk+1 be the next state computed from current state sk due to firing of transition-set Tk\n12. min(a, b) gives the minimum of numbers a, b, such that min(a, b) = a if a < b or b otherwise .\nCHAPTER 4. THE BIOPATHQA SYSTEM 78\nThen, the execution semantics of the guarded-arc Petri Net starting from state s0 using firingstyle fs is given as follows:\nbk(t) = n if (g, n) ∈ B(t), sk |= g1 otherwise enk = {t : t ∈ T, sk |= TG(t),∀(p, t, g) ∈ E,\n(sk |= g, sk(p) ≥ W(p, t, g) ∗ bk(t))} m fk = {t : t ∈ enk,∃g ∈ MF(t), sk |= g}\nconsumek(p, {t1, . . . , tn}) = ∑\ni=1,...,n\nW(p, ti, g) ∗ bk(t) : (p, ti, g) ∈ E, sk |= g\n+ ∑\ni=1,...,n\nsk(p) : (p, ti, g) ∈ R, sk |= g\noverck({t1, . . . , tn}) = {p : p ∈ P, sk(p) < consumek(p, {t1, . . . , tn})}\nselk(1) = m fk if |m fk | = 1{{t} : t ∈ enk} if |m fk | < 1 selk(∗) = {ss : ss ∈ 2enk ,m fk ⊆ ss, overck(ss) = ∅}\nselk(max) = {ss : ss ∈ 2enk ,m fk ⊆ ss, overck(p, ss) = ∅, (@ss′ ∈ 2enk : ss ⊂ ss′,m fk ⊆ ss′, overck(ss′) = ∅)}\nTk = T ′k : T ′ k ∈ selk(fs), (@t ∈ enk \\ T ′k, t is a reset transition ) producek(p) = ∑\nj=0,...,k\nW(ti, p, g) ∗ b j(ti) : (ti, p, g) ∈ E, ti ∈ T j,D(ti) + j = k + 1\nsk+1(p) = min(sk(p) − consumek(p,Tk) + producek(p), L(p)) (4.29)\nDefinition 62 (Trajectory) σ = s0,T0, s1, . . . , sk,Tk, sk+1 is a trajectory of PNG iff given s0 = M0, each Ti is a possible firing-set in si whose firing produces si+1 per PNG’s execution semantics in (4.29).\n4.4.2 Construction of Guarded-Arc Petri Net from a Pathway Specification\nNow we describe how to construct such a Petri Net from a given pathway specification D with locational fluents. We proceed as follows:\n1. The set of transitions T = {a : a is an action in D}.\n2. The set of places P = { f : f is a fluent in D}.\n3. The limit relation for places L( f ) = 1 if ‘domain of f is binary′ ∈ D∞ otherwise . 4. An arc-guard expression guard cond1, . . . , guard condn is translated into the conjunction\n(guard1, . . . , guardn), where guardi is obtained from guard condi as follows:\nCHAPTER 4. THE BIOPATHQA SYSTEM 79\n(a) A guard condition (4.11) is translated to f ≥ w (b) A guard condition (4.13) is translated to f < w\n(c) A guard condition (4.15) is translated to f = w\n(d) A guard condition (4.17) is translated to f1 > f2\n5. A may-execute statement (4.21) is translated into guarded arcs as follows:\n(a) Let guard G be the translation of arc-guard conditions guard cond1, . . . , guard condn specified in the may-execute proposition.\n(b) The effect clause (4.19) are translated into arcs as follows:\ni. An effect clause with e < 0 is translated into an input arc ( f , a,G), with arcweight W( f , a,G) = |e|. ii. An effect clause with e = ‘∗′ is translated into a reset set ( f , a,G) with arcweight W( f , a,G) = ∗.\niii. An effect clause with e > 0 is translated into an output arc (a, f ,G), with arcweight W(a, f ,G) = e.\n6. A must-execute statement (4.22) is translated into guarded arcs in the same way as may execute. In addition, it adds an arc-inscription must-exec(G), where G is the translation of the arc-guard.\n7. An inhibit statement (4.23) is translated into IG = (guard1, . . . , guardn), where (guard1, . . . , guardn) is the translation of (guard cond 1, . . . , guard condn)\n8. An initial condition statement (4.25) sets the initial marking of a specific place p to w, i.e. M0(p) = w.\n9. An duration statement (4.26) adds a dur(d) inscription to transition a.\n10. A stimulate statement (4.27) adds a stimulate(n,G) inscription to transition a, where G is the translation of the stimulate guard, a conjunction of guard cond1, . . . , guard condn.\n11. A guard (G1 ∨ · · · ∨ Gn) ∧ (¬IG1 ∧ · · · ∧ ¬IGm) is added to each transition a, where Gi, 1 ≤ i ≤ n is a guard for a may-execute or a must-execute statement and IGi, 1 ≤ i ≤ m is a guard for an inhibit statement.\n12. A firing style statement (4.28) does not visibly appear on a Petri Net diagram, but it specifies the transition firing regime the Petri Net follows.\nCHAPTER 4. THE BIOPATHQA SYSTEM 80\nExample: Consider the following pathway specification:\ndomain of f1 is integer, f2 is integer t1 may execute\ncausing f1 change value by − 1, f2 change value by + 1 if f1 has value lower than 5\nt1 may execute causing f1 change value by − 2, f2 change value by + 2 if f1 has value higher than 5 duration of t1 is 10 inhibit t1 if f1 has value higher than 7 inhibit t1 if f1 has value lower than 3 normally stimulate t1 by factor 3 if f2 has value higher than 5 initially f1 has value 0, f2 has value 0, firing style max\n(4.30)\nThis pathway specification is encoded as the Petri Net in figure 4.1.\n4.4.3 Guarded-Arc Petri Net with Colored Tokens\nNext we extend the Guarded-arc Petri Nets to add Colored tokens. We will use this extension to model pathways with locational fluents.\nFigure 4.2 shows an example of a guarded-arc Petri Net with colored tokens. There are two arc-guard expressions f 3[p1] < 5 and f 3[p1] > 5. When f 3[p1] < 5, t1 consumes one token of color f 1 from place p1 and produces one token of color f 2 in place p2. When f 3[p1] > 5, t1’s consumption and production of the same colored tokens doubles. The transition t1 implicitly gets the guards for each arc represented the or-ed conditions (( f 3[p1] < 5) ∨ ( f 3[p1] > 5)). The arc also has two conditions inhibiting it, they are represented by the and-ed conditions ¬( f 3[p1] > 7)∧¬( f 3[p1] < 3), where ‘¬’ represents logical not. Transition t1 is stimulated by factor 3 when f 3[p1] > 5 and it has a duration of 10 time units.\nDefinition 63 (Guarded-Arc Petri Net with Colored Tokens) A Guarded-Arc Petri Net with Colored Tokens is a tuple PNGC = (P,T,C,G, E,R,W,D, B,TG, MF, L), such that:\nP : finite set of places\nCHAPTER 4. THE BIOPATHQA SYSTEM 81\nT : finite set of transitions\nC : finite set of colors\nG : set of guards as defined in definition (57) with locational fluents\nTG : T → G are the transition guards E ⊆ (T × P ×G) ∪ (P × T ×G) are the guarded arcs R ⊆ P × T ×G are the guarded reset arcs\nW : E → 〈C,m〉 are arc weights; each arc weight is a multiset over C D : T → N+ are the transition durations B : T → G × N+ transition stimulation or boost\nMF : T → 2G must-fire guards for a transition L : P ×C → N+ specifies maximum number of tokens for each color in each place\nsubject to constraints:\n1. P ∩ T = ∅\n2. R ∩ E = ∅\n3. Let t1 ∈ T and t2 ∈ T be any two distinct transitions, then g1 ∈ MF(t1) and g2 ∈ MF(t2) must not have an interpretation that make both g1 and g2 true.\n4. Let t ∈ T be a transition, and ggt = {g : (t, p, g) ∈ E}∪{g : (p, t, g) ∈ E}∪{g : (p, t, g) ∈ R} be the set of arc-guards for normal and reset arcs connected to it, then g1 ∈ ggt, g2 ∈ ggt must not have an interpretation that makes both g1 and g2 true.\n5. Let t ∈ T be a transition, and ggt = {g : (g, n) ∈ B(t)} be its stimulation guards, then g1 ∈ ggt, g2 ∈ ggt must not have an interpretation that makes both g1 and g2 true.\n6. Let t ∈ T be a transition, and (g, n) ∈ B(t) : n > 1, then there must not exist a place p ∈ P and a color c ∈ C such that (p, t, g) ∈ E, L(p, c) = 1. Intuitively, stimulation of binary inputs is not supported.\nDefinition 64 (Marking (or State)) Marking (or State) of a Guarded-Arc Petri Net with Colored Tokens PNGC is the colored token assignment of each place pi ∈ P. Initial marking is written as M0 : P→ 〈C,m〉, while the token assignment at step k is written as Mk.\nWe make a simplifying assumption that all places are readable by using their place name. Next we define the execution semantics of the guarded-arc Petri Net. First we introduce some terminology that will be used below. Let\n1. s0 = M0 represent the the initial marking (or state), sk = Mk represent the marking (or state) at time step k,\nCHAPTER 4. THE BIOPATHQA SYSTEM 82\n2. sk(p) represent the marking of place p at time step k, such that sk = [sk(p0), . . . , sk(pn)], where P = {p0, . . . , pn}.\n3. Tk be the firing-set that fired in state sk,\n4. bk(t) be the stimulation value applied to transition t w.r.t. state sk,\n5. enk be the set of enabled transitions in state sk,\n6. m fk be the set of must-fire transitions in state sk,\n7. consumek(p, {t1, . . . , tn}) be the sum of colored tokens that will be consumed from place p if transitions t1, . . . , tn fired in state sk,\n8. overck({t1, . . . , tn}) be the set of places that will have over-consumption of tokens if transitions t1, . . . , tn were to fire simultaneously in state sk,\n9. selk( f s) be the set of possible firing-sets in state sk using fs firing style,\n10. producek(p) be the total production of tokens in place p in state sk due to actions terminating in state sk,\n11. sk+1 be the next state computed from current state sk and Tk,\n12. mX(c) represents the multiplicity of c ∈ C in multiset X = 〈C,m〉,\n13. c/n represents repetition of an element c of a multi-set n-times,\n14. multiplication of multiset X = 〈C,m〉 with a number n be defined in terms of multiplication of element multiplicities by n, i.e. ∀c ∈ C,mX(c) ∗ n, and\n15. min(a, b) gives the minimum of numbers a, b, such that min(a, b) = a if a < b or b otherwise .\nThen, the execution semantics of the guarded-arc Petri Net starting from state s0 using firingstyle fs is given as follows:\nbk(t) = n if (g, n) ∈ B(t), sk |= g1 otherwise enk = {t ∈ T, sk |= TG(t),∀(p, t, g) ∈ E,\n(sk |= g, sk(p) ≥ W(p, t, g) ∗ bk(t))} m fk = {t ∈ enk,∃g ∈ MF(t), sk |= g}\nconsumek(p, {t1, . . . , tn}) = ∑\ni=1,...,n\nW(p, ti, g) ∗ bk(t) : (p, ti, g) ∈ E, sk |= g\n+ ∑\ni=1,...,n\nsk(p) : (p, ti, g) ∈ R, sk |= g\noverck({t1, . . . , tn}) = {p ∈ P : ∃c ∈ C,msk(p)(c) < mconsumek(p,{t1,...,tn})(c)}\nCHAPTER 4. THE BIOPATHQA SYSTEM 83\nselk(1) = m fk if |m fk | = 1{{t} : t ∈ enk} if |m fk | < 1 selk(∗) = { ss ∈ 2enk : m fk ⊆ ss, overck(ss) = ∅\nselk(max) = ss ∈ 2enk : m fk ⊆ ss, overck(p, ss) = ∅,(@ss′ ∈ 2enk : ss ⊂ ss′,m fk ⊆ ss′, overck(ss′) = ∅) Tk = T ′k : T ′ k ∈ selk(fs), (@t ∈ enk \\ T ′k, t is a reset transition )\nproducek(p) = ∑\nj=0,...,k\nW(ti, p, g) ∗ b j(ti) : (ti, p, g) ∈ E, ti ∈ T j),D(ti) + j = k + 1\nsk+1 = [c/n : c ∈ C, n = min(msk(p)(c)\n− mconsumek(p,Tk)(c) + mproducek(p)(c), L(p, c))] (4.31)\nDefinition 65 (Trajectory) σ = s0,T0, s1, . . . , sk,Tk, sk+1 is a trajectory of PNGC iff given s0 = M0, each Ti is a possible firing-set in si whose firing produces si+1 per PNGC’s execution semantics in (4.31).\n4.4.4 Construction of Guarded-Arc Petri Net with Colored Tokens from a Pathway Specification with Locational Fluents\nNow we describe how to construct such a Petri Net from a given pathway specification D with locational fluents. We proceed as follows:\n1. The set of transitions T = {a : a is an action in D}.\n2. The set of colors C = { f : f [l] is a fluent in D}.\n3. The set of places P = {l : f [l] is a fluent in D}.\n4. The limit relation for each colored token in a place\nL( f , c) = 1 if ‘domain of f atloc l is binary′ ∈ D∞ otherwise . 5. A guard expression guard cond1, . . . , guard condn is translated into the conjunction (guard1, . . . ,\nguardn), where guardi is obtained from guard condi as follows:\n(a) A guard condition (4.14) is translated to f [l] < w\n(b) A guard condition (4.16) is translated to f [l] = w\n(c) A guard condition (4.12) is translated to f [l] ≥ w (d) A guard condition (4.18) is translated to f1[l1] > f2[l2]\nCHAPTER 4. THE BIOPATHQA SYSTEM 84\n6. A may-execute statement (4.21) is translated into guarded arcs as follows:\n(a) Let guard G be the translation of guard conditions guard cond1, . . . , guard condn specified in the may-execute proposition.\n(b) The effect clauses of the form (4.20) are grouped into input, reset and output effect sets for an action as follows:\ni. The clauses with e < 0 for the same place l are grouped together into an input set of a requiring input from place l. ii. The clauses with e = ‘∗′ for the same place l are grouped together into a reset set of a requiring input from place l.\niii. The clauses with e > 0 for the same place l are grouped together into an output set of a to place l.\n(c) A group of input effect clauses effect1, . . . , effectm,m > 0 of the form (4.20) is translated into an input arc (l, a,G), with arc-weight W(l, a,G) = w+, where w+ is the multi-set union of fi/|ei| in effecti, 1 ≤ i ≤ m.\n(d) A group of output effect clauses effect1, . . . , effectm,m > 0 of the form (4.20) is translated into an output arc (a, l,G), with arc-weight W(a, l,G) = w−, where w− is the multi-set union of fi/ei in effecti, 1 ≤ i ≤ m.\n(e) A group of reset effect clauses effect1, . . . , effectm,m > 0 of the form (4.20) is translated into a reset arc (l, a,G) with arc-weight W(l, a,G) = ∗.\n7. A must-execute statement (4.22) is translated into guarded arcs in the same way as may execute. In addition, it adds an arc-inscription must-exec(G), where G is the guard, which is the translation of guard cond1, . . . , guard condn.\n8. An inhibit statement (4.23) is translated into IG = (guard1, . . . , guardn), where (guard1, . . . , guardn) is the translation of (guard cond 1, . . . , guard condn)\n9. An initial condition statement (4.25) sets the initial marking of a specific place l for a specific color f to w, i.e. m(M0(l))( f ) = w.\n10. An duration statement (4.26) adds a dur(d) inscription to transition a.\n11. A stimulate statement (4.27) adds a stimulate(n,G) inscription to transition a, where guard G is the translation of its guard expression guard cond1, . . . , guard condn.\n12. A guard (G1∨· · ·∨Gn)∧ (¬IG1∧· · ·∧¬IGm) is added to each transition a, where Gi, 1 ≤ i ≤ n is the guard for a may-execute or a must-execute proposition and IGi, 1 ≤ i ≤ m is a guard for an inhibit proposition.\n13. A firing style statement (4.28) does not visibly show on a Petri Net, but it specifies the transition firing regime the Petri Net follows.\nCHAPTER 4. THE BIOPATHQA SYSTEM 85\nExample\nConsider the following pathway specification:\ndomain of f1 atloc l1 is integer, f2 atloc l1 is integer, f3 atloc l1 is integer, f1 atloc l2 is integer, f2 atloc l2 is integer, f3 atloc l2 is integer\nt1 may execute causing f1 atloc l1 change value by − 1, f2 atloc l2 change value by + 1\nif f3 atloc l1 has value lower than 5 t1 may execute causing\nf1 atloc l1 change value by − 2, f2 atloc l2 change value by + 2\nif f3 atloc l1 has value higher than 5 duration of t1 is 10 inhibit t1 if f3 atloc l1 has value higher than 7 inhibit t1 if f3 atloc l1 has value lower than 3 normally stimulate t1 by factor 3\nif f2 atloc l2 has value higher than 5 initially\nf1 atloc l1 has value 0, f1 atloc l2 has value 0, f2 atloc l1 has value 0, f2 atloc l2 has value 0, f3 atloc l1 has value 0, f3 atloc l2 has value 0\nfiring style max (4.32)\n4.5 Syntax of Query Language (BioPathQA-QL)\nThe alphabet of query language Q consists of the same sets A, F, L from P representing actions, fluents, and locations, respectively; a fixed set of reserved keywords K shown in bold in syntax below; a fixed set {‘ :′, ‘;′ , ‘,′ , ‘′′} of punctuations; a fixed set of {‘ <′, ‘ >′, ‘ =′} of directions; and constants. Our query language asks questions about biological entities and processes in a biological pathway described through the pathway specification language. This is our domain description. A query statement is composed of a query description (the quantity, observation, or condition being sought by the question), interventions (changes to the pathway), observations (about states and actions of the pathway), and initial setup conditions.\nThe query statement is evaluated against the trajectories of the pathway, generated by simulating the pathway. These trajectories are modified by the initial setup and interventions. The\nCHAPTER 4. THE BIOPATHQA SYSTEM 86\nresulting trajectories are then filtered to retain only those which satisfy the observations specified in the query statement.\nA query statement can take various forms: The simplest queries do not modify the pathway and check if a specific observation is true on a trajectory or not. An observation can be a point observation or an interval observation depending upon whether they can be evaluated w.r.t. a point or an interval on a trajectory. More complex queries modify the pathway in various ways and ask for comparison of an observation before and after such modification.\nFollowing query statements about the rate of production of ‘bpg13’ illustrate the kind of queries that can be asked from our system about the specified glycolysis pathway as given in (Reece et al., 2010, Figure 9.9).\nDetermine if ‘n’ is a possible rate of production of substance ‘bpg13’:\nrate of production of ′bpg13′ is n when observed between time step 0 and time step k; (4.33)\nDetermine if ‘n’ is a possible rate of production of substance ‘bpg13’ in a pathway when it is being supplied with a limited supply of an upstream substance ‘ f 16bp’:\nrate of production of ′bpg13′ is n when observed between time step 0 and time step k; using initial setup : set value of ‘ f 16bp′ to 5; (4.34)\nDetermine if ‘n’ is a possible rate of production of substance ‘bpg13’ in a pathway when it is being supplied with a steady state supply of an upstream substance ‘ f 16bp’ at the rate of 5 units per time-step:\nrate of production of ′bpg13′ is n when observed between time step 0 and time step k; using initial setup : continuously supply ‘ f 16bp′ in quantity 5; (4.35)\nDetermine if ‘n’ is a possible rate of production of substance ‘bpg13’ in a pathway when it is being supplied with a steady state supply of an upstream substance ‘ f 16bp’ at the rate of 5 units per time-step and the pathway is modified to remove all quantity of the substance ’dhap’ as soon as it is produced:\nrate of production of ′bpg13′ is n when observed between time step 0 and time step k; due to interventions : remove ‘dhap′ as soon as produced; using initial setup : continuously supply ‘ f 16bp′ in quantity 5; (4.36)\nDetermine if ‘n’ is a possible rate of production of substance ‘bpg13’ in a pathway when it is being supplied with a steady state supply of an upstream substance ‘ f 16bp’ at the rate of 5 units per time-step and the pathway is modified to remove all quantity of the substance ’dhap’ as soon as it is produced and a non-functional pathway process / reaction named ‘t5b’:\nrate of production of ′bpg13′ is n\nCHAPTER 4. THE BIOPATHQA SYSTEM 87\nwhen observed between time step 0 and time step k; due to interventions : remove ‘dhap′ as soon as produced; due to observations : ‘t5b′ does not occur; using initial setup : continuously supply ‘ f 16bp′ in quantity 5; (4.37)\nDetermine if ‘n’ is the average rate of production of substance ‘bpg13’ in a pathway when it is being supplied with a steady state supply of an upstream substance ‘ f 16bp’ at the rate of 5 units per time-step and the pathway is modified to remove all quantity of the substance ’dhap’ as soon as it is produced and a non-functional pathway process / reaction named ‘t5b’:\naverage rate of production of ′bpg13′ is n when observed between time step 0 and time step k; due to interventions : remove ‘dhap′ as soon as produced; due to observations : ‘t5b′ does not occur; using initial setup : continuously supply ‘ f 16bp′ in quantity 5; (4.38)\nDetermine if ‘d’ is the direction of change in the average rate of production of substance ‘bpg13’ with a steady state supply of an upstream pathway input when compared with a pathway with the same steady state supply of an upstream pathway input, but in which the substance ‘dhap’ is removed from the pathway as soon as it is produced and pathway process / reaction called ‘t5b’ is non-functional:\ndirection of change in average rate of production of ′bpg13′ is d when observed between time step 0 and time step k; comparing nominal pathway with modified pathway obtained\ndue to interventions : remove ‘dhap′ as soon as produced ; due to observations : ‘t5b′ does not occur;\nusing initial setup : continuously supply ‘ f 16bp′ in quantity 5; (4.39)\nQueries can also be about actions, as illustrated in the following examples. Determine if action ‘t5b’ ever occurs when there is a continuous supply of ‘ f 16bp’ is available and ‘t5a’ is disabled:\n‘t5b′ occurs ; due to interventions : disable ‘t5a′; using initial setup : continuously produce ‘ f 16bp′ in quantity 5; (4.40)\nDetermine if glycolysis (‘gly′) gets replaced with beta-oxidation (‘box′) when sugar (‘sug′) is exhausted but fatty acids (‘ f ac′) are available, when starting with a fixed initial supply of sugar and fatty acids in quantity 5:\n‘gly′ switches to ‘box′ when value of ′sug′ is 0, value of ′ f ac′ is higher than 0 in all trajectories;\nCHAPTER 4. THE BIOPATHQA SYSTEM 88\ndue to observations : ‘gly′ switches to ‘box′\nusing initial setup : set value of ‘sug′ to 5, set value of ‘ f ac′ to 5; (4.41)\nNext we define various syntactic elements of a query statement, give their intuitive meaning, and how these components fit together to form a query statement. We will define the formal semantics in a later section. Note that some of the single-trajectory queries can be represented as LTL formulas. However, we have chosen to keep the current representation as it is more intuitive for our biological domain.\nIn the following description, fi’s are fluents, li’s are locations, n’s are numbers, q’s are positive integer numbers, d is one of the directions from {<, >,=}. Definition 66 (Point) A point is a time-step on the trajectory. It has the form:\ntime step ts (4.42)\nDefinition 67 (Interval) An interval is a sub-sequence of time-steps on a trajectory. It has the form:\n〈point〉 and 〈point〉 (4.43)\nDefinition 68 (Aggregate Operator (aggop)) An aggregate operator computes an aggregate quantity over a sequence of values. It can be one of the following:\nminimum (4.44) maximum (4.45) average (4.46)\nDefinition 69 (Quantitative Interval Formula) A quantitative interval formula is a formula that is evaluated w.r.t. an interval on a trajectory for some quantity n.\nrate of production of f is n (4.47) rate of production of f atloc l is n (4.48) rate of firing of a is n (4.49) total production of f is n (4.50) total production of f atloc l is n (4.51)\nIntuitively, the rate of production of a fluent f in interval si, . . . , s j on a trajectory s0,T0, . . . ,Tk−1, sk is n = (s j( f ) − si( f ))/( j − i); rate of firing of an action a in interval si, . . . , s j is n = |{Tl : a ∈ Tl, i ≤ l ≤ j−1}|/( j−i); and total production of a fluent f in interval si, . . . , s j is n = s j( f )−si( f ). If the given n equals the computed n, then the formula holds. The same intuition extends to locational fluents, except that fluent f is replaced by f [l], e.g. rate of production of fluent f at location l in interval si, . . . , s j on a trajectory is n = (s j( f [l]) − si( f [l]))/( j − i). In biological context, the actions represent reactions and fluents substances used in these reactions. The rate and total production formulas are used in aggregate observations to determine if reactions are slowing down or speeding up during various portions of a simulation.\nCHAPTER 4. THE BIOPATHQA SYSTEM 89\nDefinition 70 (Quantitative Point Formula) A quantitative point formula is a formula that is evaluated w.r.t. a point on a trajectory for some quantity n.\nvalue of f is higher than n (4.52) value of f atloc l is higher than n (4.53) value of f is lower than n (4.54) value of f atloc l is lower than n (4.55) value of f is n (4.56) value of f atloc l is n (4.57)\nDefinition 71 (Qualitative Interval Formula) A qualitative interval formula is a formula that is evaluated w.r.t. an interval on a trajectory.\nf is accumulating (4.58) f is accumulating atloc l (4.59) f is decreasing (4.60) f is decreasing atloc l (4.61)\nIntuitively, a fluent f is accumulating in interval si, . . . , s j on a trajectory if f ’s value monotonically increases during the interval. A fluent f is decreasing in interval si, . . . , s j on a trajectory if f ’s value monotonically decreases during the interval. The same intuition extends to locational fluents by replacing f with f [l].\nDefinition 72 (Qualitative Point Formula) A qualitative point formula is a formula that is evaluated w.r.t. a point on a trajectory.\na occurs (4.62) a does not occur (4.63) a1 switches to a2 (4.64)\n(4.65)\nIntuitively, an action occurs at a point i on the trajectory if a ∈ Ti; an action does not occur at point i if a < Ti; an action a1 switches to a2 at point i if a1 ∈ Ti−1, a2 < Ti−1, a1 < Ti, a2 ∈ Ti. Definition 73 (Quantitative All Interval Formula) A quantitative all interval formula is a formula that is evaluated w.r.t. an interval on a set of trajectories σ1, . . . , σm and corresponding quantities r1, . . . , rm.\nrates of production of f are [r1, . . . , rm] (4.66) rates of production of f altoc l are [r1, . . . , rm] (4.67) rates of firing of f are [r1, . . . , rm] (4.68) totals of production of f are [r1, . . . , rm] (4.69) totals of production of f altoc l are [r1, . . . , rm] (4.70)\nIntuitively, a quantitative all interval formula holds on some interval [i, j] over a set of trajectories σ1, . . . , σm for values [r1, . . . , rm] if for each rx the corresponding quantitative interval formula holds in interval [i, j] in trajectoryσx . For example, rates of production of f are [r1, . . . , rm] in interval [i, j] over a set of trajectoriesσ1, . . . , σm if for each x ∈ {1 . . .m}, rate of production of f is rx in interval [i, j] in trajectory σx.\nCHAPTER 4. THE BIOPATHQA SYSTEM 90\nDefinition 74 (Quantitative All Point Formula) A quantitative all point formula is a formula that is evaluated w.r.t. a point on a set of trajectories σ1, . . . , σm and corresponding quantities r1, . . . , rm.\nvalues of f are [r1, . . . , rm] (4.71) values of f atloc l are [r1, . . . , rm] (4.72)\nIntuitively, a quantitative all point formula holds at some point i over a set of trajectories σ1, . . . , σm for values [r1, . . . , rm] if for each rx the corresponding quantitative point formula holds at point i in trajectory σx . For example, values of f are [r1, . . . , rm] at point i over a set of trajectories σ1, . . . , σm if for each x ∈ {1 . . .m}, value of f is rx at point i in trajectory σx.\nDefinition 75 (Quantitative Aggregate Interval Formula) A quantitative aggregate interval formula is a formula that is evaluated w.r.t. an interval on a set of trajectories σ1, . . . , σm and an aggregate value r, where r is the aggregate of [r1, . . . , rm] using aggop.\n〈aggop〉 rate of production of f is n (4.73) 〈aggop〉 rate of production of f atloc l is n (4.74) 〈aggop〉 rate of firing of a is n (4.75) 〈aggop〉 total production of f is n (4.76) 〈aggop〉 total production of f atloc l is n (4.77)\nIntuitively, a quantitative aggregate interval formula holds on some interval [i, j] over a set of trajectories σ1, . . . , σm for a value r if there exist [r1, . . . , rm] whose aggregate value per aggop is r, such that for each rx the quantitative interval formula (corresponding to the quantitative aggregate interval formual) holds in interval [i, j] in trajectory σx. For example, average rate of production of f is r in interval [i, j] over a set of trajectories σ1, . . . , σm if r = (r1 + · · ·+ rm)/m and for each x ∈ {1 . . .m}, rate of production of f is rx in interval [i, j] in trajectory σx.\nDefinition 76 (Quantitative Aggregate Point Formula) A quantitative aggregate point formula is a formula that is evaluated w.r.t. a point on a set of trajectories σ1, . . . , σm and an aggregate value r, where r is the aggregate of [r1, . . . , rm] using aggop.\n〈aggop〉 value of f is r (4.78) 〈aggop〉 value of f atloc l is r (4.79)\nIntuitively, a quantitative aggregate point formula holds at some point i over a set of trajectories σ1, . . . , σm for a value r if there exist [r1, . . . , rm] whose aggregate value per aggop is r, such that for each rx the quantitative point formula (corresponding to the quantitative aggregate point formual) holds at point i in trajectory σx. For example, average value of f is r at point i over a set of trajectories σ1, . . . , σm if r = (r1 + · · · + rm)/m and for each x ∈ {1 . . .m}, value of f is rx at point i in trajectory σx.\nDefinition 77 (Quantitative Comparative Aggregate Interval Formula) A quantitative comparative aggregate interval formula is a formula that is evaluated w.r.t. an interval over two sets of trajectories and a direction ‘d’ such that ‘d’ relates the two sets of trajectories.\ndirection of change in 〈aggop〉 rate of production of f is d (4.80)\nCHAPTER 4. THE BIOPATHQA SYSTEM 91\ndirection of change in 〈aggop〉 rate of production of f atloc l is d (4.81) direction of change in 〈aggop〉 rate of firing of a is d (4.82) direction of change in 〈aggop〉 total production of f is d (4.83) direction of change in 〈aggop〉 total production of f atloc l is d (4.84)\nIntuitively, a comparative quantitative aggregate interval formula compares two quantitative interval formulas over using the direction d over a given interval.\nDefinition 78 (Quantitative Comparative Aggregate Point Formula) A quantitative comparative aggregate point formula is a formula that is evaluated w.r.t. a point over two sets of trajectories and a direction ‘d’ such that ‘d’ relates the two sets of trajectories.\ndirection of change in 〈aggop〉 value of f is d (4.85) direction of change in 〈aggop〉 value of f atloc l is d (4.86)\nIntuitively, a comparative quantitative aggregate point formula compares two quantitative point formulas over using the direction d at a given point.\nDefinition 79 (Simple Interval Formula) A simple interval formula takes the following forms: 〈quantitative interval formula〉 (4.87) 〈qualitative interval formula〉 (4.88)\nDefinition 80 (Simple Point Formula) A simple interval formula takes the following forms: 〈quantitative point formula〉 (4.89) 〈qualitative point formula〉 (4.90)\nDefinition 81 (Internal Observation Description) An internal observation description takes the following form:\n〈simple point formula〉 (4.91) 〈simple point formula〉 at 〈point〉 (4.92) 〈simple interval formula〉 (4.93) 〈simple interval formula〉 when observed between 〈interval〉 (4.94)\nDefinition 82 (Simple Point Formula Cascade) A simple point formula cascade takes the following form:\n〈simple point formula〉0 after 〈simple point formula〉1,1, . . . , 〈simple point formula〉1,n1 ...\nafter 〈simple point formula〉u,1, . . . , 〈simple point formula〉u,nu (4.95) 〈simple point formula〉0 when 〈simple point formula〉1,1, . . . , 〈simple point formula〉1,n1 (4.96) 〈simple point formula〉0\nwhen 〈cond〉 (4.97)\nwhere u ≥ 1 and ‘cond’ is a conjunction of simple point formulas that is true in the same point as the simple point formula.\nCHAPTER 4. THE BIOPATHQA SYSTEM 92\nIntuitively, the simple point formula cascade (4.95) holds if a given sequence of point formulas hold in order in a trajectory. Intuitively, simple point formula cascade (4.96) holds if a given point formula occurs at the same point as a set of simple point formulas in a trajectory. Note that these formulas and many other of our single trajectory formulas can be replaced by an LTL Manna and Pnueli (1992) formula, but we have kept this syntax as it is more relevant to the question answering needs in the biological domain.\nDefinition 83 (Query Description) A query description specifies a non-comparative observation that can be made either on a trajectory or a set of trajectories.\n〈quantitative aggregate interval formula〉 when observed between 〈interval〉 (4.98) 〈quantitative aggregate point formula〉 when observed at 〈point〉 (4.99) 〈quantitative all interval formula〉 when observed between 〈interval〉 (4.100) 〈quantitative all point formula〉 when observed at 〈point〉 (4.101) 〈internal observation description〉 (4.102) 〈internal observation description〉 in all trajectories (4.103) 〈simple point formula cascade〉 (4.104) 〈simple point formula cascade〉 in all trajectories (4.105)\nThe single trajectory observations are can be represented using LTL formulas, but we have chosen to keep them in this form for ease of use by users from the biological domain.\nDefinition 84 (Comparative Query Description) A comparative query description specifies a comparative observation that can be made w.r.t. two sets of trajectories.\n〈quantitative comparative aggregate interval formula〉 when observed between 〈interval〉 (4.106)\n〈quantitative comparative aggregate point formula〉 when observed at 〈point〉 (4.107)\nDefinition 85 (Intervention) Interventions define modifications to domain descriptions. remove f1 as soon as produced (4.108) remove f1 atloc l1 as soon as produced (4.109) disable a2 (4.110) continuously transform f1 in quantity q1 to f2 (4.111) continuously transform f1 atloc l1 in quantity q1 to f2 atloc l2 (4.112) make f3 inhibit a3 (4.113) make f3 atloc l3 inhibit a3 (4.114) continuously supply f4 in quantity q4 (4.115) contiunously supply f4 atloc l4 in quantity q4 (4.116) continuously transfer f1 in quantity q1 across l1, l2 to lower gradient (4.117) add delay of q1 time units in availability of f1 (4.118) add delay of q1 time units in availability of f1 atloc l1 (4.119) set value of f4 to q4 (4.120) set value of f4 atloc l4 to q4 (4.121)\nCHAPTER 4. THE BIOPATHQA SYSTEM 93\nIntuitively, intervention (4.108) modifies the pathway such that all quantity of f1 is removed as soon as it is produced; intervention (4.109) modifies the pathway such that all quantity of f1[l1] is removed as soon as it is produced; intervention (4.110) disables the action a2; intervention (4.111) modifies the pathway such that f1 gets converted to f2 at the rate of q1 units per time-unit; intervention (4.112) modifies the pathway such that f1[l1] gets converted to f2[l2] at the rate of q1 units per time-unit; intervention (4.113) modifies the pathway such that action a3 is now inhibited each time there is 1 or more units of f3 and sets value of f3 to 1 to initially inhibit a3; intervention (4.114) modifies the pathway such that action a3 is now inhibited each time there is 1 or more units of f3[l3] and sets value of f3[l3] to 1 to initially inhibit a3; intervention (4.115) modifies the pathway to continuously supply f4 at the rate of q4 units per time-unit; intervention (4.116) modifies the pathway to continuously supply f4[l4] at the rate of q4 units per time-unit; intervention (4.117) modifies the pathway to transfer f1[l1] to f1[l2] in quantity q1 or back depending upon whether f1[l1] is higher than f1[l2] or lower; intervention (4.118) modifies the pathway to add delay of q1 time units between when f1 is produced to when it is made available to next action; intervention (4.119) modifies the pathway to add delay of q1 time units between when f1[l1] is produced to when it is made available to next action; intervention (4.120) modifies the pathway to set the initial value of f4 to q4; and intervention (4.121) modifies the pathway to set the initial value of f4[l4] to q4.\nDefinition 86 (Initial Condition) An initial condition is one of the intervention (4.115), (4.116), (4.120), (4.121) as given in definition 85.\nIntuitively, initial conditions are interventions that setup fixed or continuous supply of substances participating in a pathway.\nDefinition 87 (Query Statement) A query statement can be of the following forms: 〈query description〉;\ndue to interventions : 〈intervention〉1, . . . , 〈intervention〉N1; due to observations : 〈internal observation〉1, . . . , 〈internal observation〉N2; using initial setup : 〈initial condition〉1, . . . , 〈initial condition〉N3; (4.122)\n〈comparative query description〉; comparing nominal pathway with modified pathway obtained\ndue to interventions : 〈intervention〉1, . . . , 〈intervention〉N1; due to observations : 〈internal observation〉1, . . . , 〈internal observation〉N2;\nusing initial setup : 〈initial condition〉1, . . . , 〈initial condition〉N3; (4.123)\nwhere interventions, observations, and initial setup are optional.\nIntuitively, a query statement asks whether a query description holds in a pathway, perhaps after modifying it with initial setup, interventions and observations. Intuitively, a comparative query statement asks whether a comparative query description holds with a nominal pathway is compared against a modified pathway, where both pathways have the same initial setup, but only the modified pathway has been modified with interventions and observations.\nCHAPTER 4. THE BIOPATHQA SYSTEM 94\n4.6 Semantics of the Query Language (BioPathQA-QL)\nIn this section we give the semantics of our pathway specification language and the query language. The semantics of the query language is in terms of the trajectories of a domain description D that satisfy a query Q. We will present the semantics using LTL-style formulas. First, we informally define the semantics of the query language as follows.\nLet Q be a query statement of the form (4.122) with a query description U, interventions V1, . . . ,V|V |, internal observations O1, . . . ,O|O|, and initial setup conditions I1, . . . , I|I|. We construct a modified domain description D1 by applying I1, . . . , I|I| andV1, . . . ,V|V | to D. We filter the trajectories of D1 to retain only those trajectories that satisfy the observations O1, . . . ,O|O|. Then we determine if U holds on any of the retained trajectories. If it does, then we say that D satisfies Q.\nLet Q be a comparative query statement of the form (4.123) with quantitative comparative aggregate query description U, interventions V1, . . . ,V|V |, internal observations O1, . . . ,O|O|, and initial conditions I1, . . . , I|I|. Then we evaluate Q by deriving two sub-query statements. Q0 is constructed by removing the interventions V1, . . . ,V|V | and observations O1, . . . ,O|O| from Q and replacing the quantitative comparative aggregate query description U with the corresponding quantitative aggregate query description U′, Q1 is constructed by replacing the quantitative comparative aggregate query description U with the corresponding quantitative aggregate query description U′. Then D satisfies Q iff we can find d ∈ {<, >,=} s.t. n d n′, where D satisfies Q0 for some value n and D satisfies Q1 for some value n′.\n4.6.1 An Illustrative Example\nIn this section, we illustrate with an example how we intuitively evaluate a comparative query statement. In the later sections, we will give the formal semantics of query satisfaction.\nConsider the following simple pathway specification:\ndomain of f1 is integer, f2 is integer t1 may fire causing f1 change value by − 1, f2 change value by + 1 initially f1 has value 0, f2 has value 0, firing style max\n(4.124)\nLet the following specify a query statement Q:\ndirection of change in average rate of production of f2 is d when observed between time step 0 and time step k; comparing nominal pathway with modified pathway obtained\ndue to interventions : remove f2 as soon as produced; using initial setup : continuously supply f1 in quantity 1;\nthat we want to evaluate against D using a simulation length k with maximum ntok tokens at any place to determine ‘d’ that satisfies it.\nCHAPTER 4. THE BIOPATHQA SYSTEM 95\nWe construct the baseline query Q0 by removing interventions and observations, and replacing the comparative aggregate quantitative query description with the corresponding aggregate quantitative query description as follows:\naverage rate of production of f2 is n when observed between time step 0 and time step k; using initial setup : continuously supply f1 in quantity 1;\nWe construct the alternate query Q1 by replacing the comparative aggregate quantitative query description with the corresponding aggregate quantitative query description as follows:\naverage rate of production of f2 is n′\nwhen observed between time step 0 and time step k; due to interventions : remove f2 as soon as produced; using initial setup : continuously supply f1 in quantity 1;\nWe build a modified domain description D0 as D (continuously supply f1 in quantity 1) based on initial conditions in Q0. We get:\ndomain of f1 is integer, f2 is integer t1 may fire causing f1 change value by − 1, f2 change value by + 1 t f1 may fire causing f1 change value by + 1 initially f1 has value 0, f2 has value 0, firing style max\nWe evaluate Q0 against D0. It results in m0 trajectories with rate of productions n j = (sk( f2)− s0( f2))/k on trajectory τ j = s0, . . . , sk, 1 ≤ j ≤ m0 using time interval [0, k]. The rate of productions are averaged to produce n = (n1 + · · · + nm0)/m0.\nNext, we construct the alternate domain description D1 as D0 (remove f2 as soon as produced ) based on initial conditions and interventions in Q1. We get:\ndomain of f1 is integer, f2 is integer t1 may fire causing f1 change value by − 1, f2 change value by + 1 t f1 may fire causing f1 change value by + 1 t f2 may fire causing f2 change value by ∗ initially f1 has value 0, f2 has value 0 firing style max\nWe evaluate Q1 against D1. Since there are no observations, no filtering is required. This results in m1 trajectories, each with rate of production n′j = (sk( f2) − s0( f2))/k on trajectory τ′j = s0, . . . , sk, 1 ≤ j ≤ m1 using time interval [0, k]. The rate of productions are averaged to produce n′ = (n′1 + · · · + n′m1)/m1.\nDue to the simple nature of our domain description, it has only one trajectory for each of the two domains. As a result, for any k > 1, n′ < n. Thus, D satisfies Q iff d = “ <′′.\nCHAPTER 4. THE BIOPATHQA SYSTEM 96\nWe will now define the semantics of how a domain description D is modified according to the interventions and initial conditions, the semantics of conditions imposed by the internal observations. We will then formally define how Q is entailed in D.\n4.6.2 Domain Transformation due to Interventions and Initial Conditions\nAn intervention I modifies a given domain description D, potentially resulting in a different set of trajectories than D. We define a binary operator that transforms D by applying an intervention I as a set of edits to D using the pathway specification language. The trajectories of the modified domain description D′ = D I are given by the semantics of the pathway specification language. Below, we give the intuitive impact and edits required by each of the interventions.\nDomain modification by intervention (4.108) D′ = D (remove f1 as soon as produced) modifies the pathway by removing all existing quantity of f1 at each time step:\nD′ = D + { tr may execute causing f1 change value by ∗ }\nDomain modification by intervention (4.109) D′ = D (remove f1 atloc l1) modifies the pathway by removing all existing quantity of f1 at each time step:\nD′ = D + { tr may execute causing f1 atloc l1 change value by ∗ }\nDomain modification by intervention (4.110) D′ = D (disable a2) modifies the pathway such that its trajectories have a2 < Ti, where i ≥ 0.\nD′ = D + { inhibit a2 }\nDomain modification by intervention (4.111) D′ = D (continuously transform f1 in quantity q1 to f2) where si+1( f1) decreases, and si+1( f2) increases by q1 at each time step i ≥ 0, when si( f1) ≥ q1.\nD′ = D + {\na f1,2 may execute causing f1 change value by − q1, f2 change value by + q1\n}\nDomain modification by intervention (4.112) D′ = D (continuously transform f1 atloc l1 in quantity q1 to f2 atloc l2) where si+1( f1[l1]) decreases, and si+1( f2[l2]) increases by q1 at each time step i ≥ 0, when si( f1[l1]) ≥ q1.\nD′ = D + {\na f1,2 may execute causing f1 atloc l1 change value by − q1, f2 atloc l2 change value by + q1\n}\nDomain modification by intervention (4.113) D′ = D (make f3 inhibit a3) modifies the pathway such that it has a3 inhibited due to f3.\nD′ = D − { initially f3 has value q ∈ D }\n+ { inhibit a3 if f3 has value 1 or higher initially f3 has value 1 }\nCHAPTER 4. THE BIOPATHQA SYSTEM 97\nDomain modification by intervention (4.114) D′ = D (make f3 atloc l3 inhibit a3) modifies the pathway such that it has a3 inhibited due to f3[l3].\nD′ = D − { initially f3 atloc l3 has value q ∈ D }\n+ { inhibit a3 if f3 atloc l3 has value 1 or higher, initially f3 atloc l3 has value 1 }\nDomain modification by intervention (4.115) D′ = D ( continuously supply f4 in quantity q4) modifies the pathway such that a quantity q4 of substance f4 is supplied at each time step.\nD′ = D + { t f4 may execute causing f4 change value by + q4 }\nDomain modification by intervention (4.116) D′ = D ( continuously supply f4 atloc l4 in quantity q4) modifies the pathway such that a quantity q4 of substance f4 at location l4 is supplied at each time step.\nD′ = D + { t f4 may execute causing f4 atloc l4 change value by + q4 }\nDomain modification by intervention (4.117) D′ = D (continuously transfer f1 in quantity q1 across l1, l2 to lower gradient) modifies the pathway such that substance represented by f1 is transferred from location l1 to l2 or l2 to l1 depending upon whether it is at a higher quantity at l1 or l2.\nD′ = D +  t f1 may execute causing f1 atloc l1 change value by − q1, f1 atloc l2 change value by + q1 if f1 atloc l1 has higher value than f1 atloc l2, t′f1 may execute causing f1 atloc l2 change value by − q1,\nf1 atloc l1 change value by + q1 if f1 atloc l2 has higher value than f1 atloc l1,  Domain modification by intervention (4.118) D′ = D (add delay of q1 time units in availability of f1)\nmodifies the pathway such that f1’s arrival is delayed by q1 time units. We create additional cases for all actions that produce f1, such that it goes through an additional delay action.\nD′ = D −  a may execute causing f1 change value by + w1,\neffect1, . . . , effectn if cond1, . . . , condm ∈ D\n\n+  a may execute causing f ′1 change value by + w1, effect1, . . . , effectn, if cond1, . . . , condm a f1 may execute causing f ′1 change value by − w1, f1 change value by + w1\na f1 executes in q1 time units  Domain modification by intervention (4.119) D′ = D (add delay ofq1 time units in availability of f1 atloc l1)\nmodifies trajectories such that f1[l1]’s arrival is delayed by q1 time units. We create additional cases for all actions that produce f1 atloc l1, such that it goes through an additional delay action.\nD′ = D −  a may execute causing f1 atloc l1 change value by + w1,\neffect1, . . . , effectn if cond1, . . . , condm ∈ D\n\nCHAPTER 4. THE BIOPATHQA SYSTEM 98\n+  a may execute causing f1 atloc l′1 change value by + w1, effect1, . . . , effectn if cond1, . . . , condn a f1 may execute causing f1 atloc l′1 change value by − w1, f1 atloc l1 change value by + w1\na f1 executes in q1 time units  Domain modification by intervention (4.120) D′ = D ( set value of f4 to q4) modifies the\npathway such that its trajectories have s0( f4) = q4.\nD′ = D − { initially f4 has value n ∈ D }\n+ { initially f4 has value q4 }\nDomain modification by intervention (4.121) D′ = D ( set value of f4 atloc l4 to q4) modifies the pathway such that its trajectories have s0( f4l4) = q4.\nD′ = D − { initially f4 atloc l4 has value n ∈ D }\n+ { initially f4 atloc l4 has value q4 }\n4.6.3 Formula Semantics\nWe will now define the semantics of some common formulas that we will use in the following sections. First we introduce the LTL-style formulas that we will be using to define the syntax.\nA formula 〈si, σ〉 |= F represents that F holds at point i. A formula {〈s1i , σ1〉, . . . , 〈smi , σm〉} |= F represents that F holds at point i on a set of trajec-\ntories σ1, . . . , σm. A formula {{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}} |= F represents that F holds at point i on two sets of trajectories σ1, . . . , σm and {σ̄1, . . . , σ̄m̄}.\nA formula (〈si, σ〉, j) |= F represents that F holds in the interval [i, j] on trajectory σ. A formula ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= F represents that F holds in the interval [i, j] on a\nset of trajectories σ1, . . . , σm. A formula ( {{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}}, j) |= F represents that F holds in the interval [i, j] over two sets of trajectories {σ1, . . . , σm} and {σ̄1, . . . , σ̄m̄}.\nGiven a domain description D with simple fluents represented by a Guarded-Arc Petri Net as defined in definition 60. Let σ = s0,T0, s1, . . . ,Tk−1, sk be its trajectory as defined in (62), and si be a state on that trajectory. Let actions Ti firing in state si be observable in si such that Ti ⊆ si.\nFirst we define how interval formulas are satisfied on a trajectory σ, starting state si and an ending point j:\n(〈si, σ〉, j) |= rate of production of f is n if n = (s j( f ) − si( f ))/( j − i) (4.125) (〈si, σ〉, j) |= rate of firing of a is n\nCHAPTER 4. THE BIOPATHQA SYSTEM 99\nif n = ∑\ni≤k≤ j,〈sk ,σ〉|=a occurs 1/( j − i) (4.126)\n(〈si, σ〉, j) |= total production of f is n if n = (s j( f ) − si( f )) (4.127) (〈si, σ〉, j) |= f is accumulating if (@k, i ≤ k ≤ j : sk+1( f ) < sk( f )) and s j( f ) > si( f ) (4.128) (〈si, σ〉, j) |= f is decreasing if (@k, i ≤ k ≤ j : sk+1( f ) > sk( f )) and s j( f ) < si( f ) (4.129)\nNext we define how a point formula is satisfied on a trajectory σ, in a state si:\n〈si, σ〉 |= value of f is higher than n if si( f ) > n (4.130) 〈si, σ〉 |= value of f is lower than n if si( f ) < n (4.131) 〈si, σ〉 |= value of f is n if si( f ) = n (4.132) 〈si, σ〉 |=a occurs if a ∈ si (4.133) 〈si, σ〉 |=a does not occur if a < si (4.134) 〈si, σ〉 |=a1 switches to a2 if a1 ∈ si−1 and a2 < si−1 and a1 < si and a2 ∈ si (4.135)\nNext we define how a quantitative all interval formula is satisfied on a set of trajectories σ1, . . . , σm with starting states s1i , . . . , s m i and end point j:\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= rates of production of f are [r1, . . . , rm] if (〈s1i , σ1〉, j) |= rate of production of f is r1 ... and (〈smi , σm〉, j) |= rate of production of f is rm (4.136) ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= rates of firing of a are [r1, . . . , rm]\nif (〈s1i , σ1〉, j) |= rate of firing of a is r1 ...\nand (〈smi , σm〉, j) |= rate of firing of a is rm (4.137) ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= totals of production of f are [r1, . . . , rm]\nif (〈s1i , σ1〉, j) |= total production of f is r1 ...\nand (〈smi , σm〉, j) |= total production of f is rm (4.138)\nCHAPTER 4. THE BIOPATHQA SYSTEM 100\nNext we define how a quantitative all point formula is satisfied on a set of trajectories σ1, . . . , σm in states s1i , . . . , s m i :\n{〈s1i , σ1〉, . . . , 〈smi , σm〉} |= values of f are [r1, . . . , rm] if 〈s1i , σ1〉 |= value of f is r1 ...\nand 〈smi , σm〉 |= value of f is rm (4.139)\nNext we define how a quantitative aggregate interval formula is satisfied on a set of trajectories σ1, . . . , σm with starting states s1i , . . . , s m i and end point j:\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average rate of production of f is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of production of f is r1 ...\n(〈smi , σm〉, j) |= rate of production of f is rm and r = (r1 + · · · + rm)/m (4.140)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum rate of production of f is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of production of f is r1 ...\n(〈smi , σm〉, j) |= rate of production of f is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≤ rx (4.141)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum rate of production of f is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of production of f is r1 ...\n(〈smi , σm〉, j) |= rate of production of f is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≥ rx (4.142)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average rate of firing of f is r iff ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of firing of f is r1 ...\n(〈smi , σm〉, j) |= rate of firing of f is rm and r = (r1 + · · · + rm)/m (4.143)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum rate of firing of f is r iff ∃[r1, . . . , rm] :\nCHAPTER 4. THE BIOPATHQA SYSTEM 101\n(〈s1i , σ1〉, j) |= rate of firing of f is r1 ...\n(〈smi , σm〉, j) |= rate of firing of f is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≤ rx (4.144)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum rate of firing of f is r iff ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of firing of f is r1 ...\n(〈smi , σm〉, j) |= rate of firing of f is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≥ rx (4.145)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average total production of f is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= total production of f is r1 ...\n(〈smi , σm〉, j) |= total production of f is rm and r = (r1 + · · · + rm)/m (4.146)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum total production of f is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= total production of f is r1 ...\n(〈smi , σm〉, j) |= total production of f is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≤ rx (4.147)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum total production of f is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= total production of f is r1 ...\n(〈smi , σm〉, j) |= total production of f is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≥ rx (4.148)\nNext we define how a quantitative aggregate point formula is satisfied on a set of trajectories σ1, . . . , σm in states s1i , . . . , s m i :\n{〈s1i , σ1〉, . . . , 〈smi , σm〉} |= average value of f is r if ∃[r1, . . . , rm] : 〈s1i , σ1〉 |= value of f is r1 ...\nCHAPTER 4. THE BIOPATHQA SYSTEM 102\n〈smi , σm〉 |= value of f is rm and r = (r1 + · · · + rm)/m (4.149)\n{〈s1i , σ1〉, . . . , 〈smi , σm〉} |= minimum value of f is r if ∃[r1, . . . , rm] : 〈s1i , σ1〉 |= value of f is r1 ...\n〈smi , σm〉 |= value of f is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≤ rx (4.150)\n{〈s1i , σ1〉, . . . , 〈smi , σm〉} |= maximum value of f is r if ∃[r1, . . . , rm] : 〈s1i , σ1〉 |= value of f is r1 ...\n〈smi , σm〉 |= value of f is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≥ rx (4.151)\nNext we define how a comparative quantitative aggregate interval formula is satisfied on two sets of trajectories σ1, . . . , σm, and σ̄1, . . . , σ̄m̄ a starting point i and an ending point j:({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in average rate of production of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average rate of production of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= average rate of production of f is n2 and n2 d n1 (4.152)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in minimum rate of production of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum rate of production of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= minimum rate of production of f is n2 and n2 d n1 (4.153)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in maximum rate of production of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum rate of production of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= maximum rate of production of f is n2 and n2 d n1 (4.154)\n({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in average rate of firing of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average rate of firing of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= average rate of firing of f is n2\nCHAPTER 4. THE BIOPATHQA SYSTEM 103\nand n2 d n1 (4.155)({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in minimum rate of firing of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum rate of firing of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= minimum rate of firing of f is n2 and n2 d n1 (4.156)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in maximum rate of firing of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum rate of firing of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= maximum rate of firing of f is n2 and n2 d n1 (4.157)\n({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in average total production of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average total production of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= average total production of f is n2 and n2 d n1 (4.158)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in minimum total production of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum total production of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= minimum total production of f is n2 and n2 d n1 (4.159)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in maximum total production of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum total production of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= maximum total production of f is n2 and n2 d n1 (4.160)\nNext we define how a comparative quantitative aggregate point formula is satisfied on two sets of trajectories σ1, . . . , σm, and σ̄1, . . . , σ̄m̄ at point i:{\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} }\n|= direction of change in average value of f is d if ∃ n1 : {〈s1i , σ1〉, . . . , 〈smi , σm〉} |= average value of f is n1 and ∃ n2 : {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} |= average value of f is n2 and n2 d n1 (4.161){\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} }\n|= direction of change in minimum value of f is d\nCHAPTER 4. THE BIOPATHQA SYSTEM 104\nif ∃ n1 : {〈s1i , σ1〉, . . . , 〈smi , σm〉} |= minimum value of f is n1 and ∃ n2 : {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} |= minimum value of f is n2 and n2 d n1 (4.162){\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} }\n|= direction of change in maximum value of f is d if ∃ n1 : {〈s1i , σ1〉, . . . , 〈smi , σm〉} |= maximum value of f is n1 and ∃ n2 : {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} |= maximum value of f is n2 and n2 d n1 (4.163)\nGiven a domain description D with simple fluents represented by a Guarded-Arc Petri Net with Colored tokens as defined in definition 63. Let σ = s0,T0, s1, . . . ,Tk−1, sk be its trajectory as defined in definition 65, and si be a state on that trajectory. Let actions Ti firing in state si be observable in si such that Ti ⊆ si. We define observation semantics using LTL below. We will use si( f [l]) to represent msi(l)( f ) (multiplicity / value of f in location l) in state si.\nFirst we define how interval formulas are satisfied on a trajectory σ, starting state si and an ending point j:\n(〈si, σ〉, j) |= rate of production of f atloc l is n if n = (s j( f [l]) − si( f [l]))/( j − i) (4.164) (〈si, σ〉, j) |= rate of firing of a is n\nif n = ∑\ni≤k≤ j,〈sk ,σ〉|=a occurs 1/( j − i) (4.165)\n(〈si, σ〉, j) |= total production of f atloc l is n if n = (s j( f [l]) − si( f [l])) (4.166) (〈si, σ〉, j) |= f is accumulating atloc l if (@k, i ≤ k ≤ j : sk+1( f [l]) < sk( f [l])) and s j( f [l]) > si( f [l]) (4.167) (〈si, σ〉, j) |= f is decreasing atloc l if (@k, i ≤ k ≤ j : sk+1( f [l]) > sk( f [l])) and s j( f [l]) < si( f [l]) (4.168)\nNext we define how a point formula is satisfied on a trajectory σ, in a state si:\n〈si, σ〉 |= value of f atloc l is higher than n if si( f [l]) > n (4.169) 〈si, σ〉 |= value of f atloc l is lower than n if si( f [l]) < n (4.170) 〈si, σ〉 |= value of f atloc l is n if si( f [l]) = n (4.171) 〈si, σ〉 |=a occurs if a ∈ si (4.172)\nCHAPTER 4. THE BIOPATHQA SYSTEM 105\n〈si, σ〉 |=a does not occur if a < si (4.173) 〈si, σ〉 |=a1 switches to a2 if a1 ∈ si−1 and a2 < si−1 and a1 < si and a2 ∈ si (4.174)\nNext we define how a quantitative all interval formula is satisfied on a set of trajectories σ1, . . . , σm with starting states s1i , . . . , s m i and end point j:\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= rates of production of f atloc l are [r1, . . . , rm] if (〈s1i , σ1〉, j) |= rate of production of f atloc l is r1 ... and (〈smi , σm〉, j) |= rate of production of f atloc l is rm (4.175) ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= rates of firing of a are [r1, . . . , rm]\nif (〈s1i , σ1〉, j) |= rate of firing of a is r1 ...\nand (〈smi , σm〉, j) |= rate of firing of a is rm (4.176) ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= totals of production of f atloc l are [r1, . . . , rm]\nif (〈s1i , σ1〉, j) |= total production of f atloc l is r1 ...\nand (〈smi , σm〉, j) |= total production of f atloc l is rm (4.177)\nNext we define how a quantitative all point formula is satisfied w.r.t. a set of trajectories σ1, . . . , σm in states s1i , . . . , s m i :\n{〈s1i , σ1〉, . . . , 〈smi , σm〉} |= values of f atloc l are [r1, . . . , rm] if 〈s1i , σ1〉 |= value of f atloc l is r1 ...\nand 〈smi , σm〉 |= value of f atloc l is rm (4.178)\nNext we define how a quantitative aggregate interval formula is satisfied w.r.t. a set of trajectories σ1, . . . , σm with starting states s1i , . . . , s m i and end point j:\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average rate of production of f atloc l is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of production of f atloc l is r1 ...\n(〈smi , σm〉, j) |= rate of production of f atloc l is rm and r = (r1 + · · · + rm)/m (4.179)\nCHAPTER 4. THE BIOPATHQA SYSTEM 106\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum rate of production of f atloc l is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of production of f atloc l is r1 ...\n(〈smi , σm〉, j) |= rate of production of f atloc l is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≤ rx (4.180)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum rate of production of f atloc l is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of production of f atloc l is r1 ...\n(〈smi , σm〉, j) |= rate of production of f atloc l is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≥ rx (4.181)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average rate of firing of f is r iff ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of firing of f is r1 ...\n(〈smi , σm〉, j) |= rate of firing of f is rm and r = (r1 + · · · + rm)/m (4.182)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum rate of firing of f is r iff ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of firing of f is r1 ...\n(〈smi , σm〉, j) |= rate of firing of f is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≤ rx (4.183)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum rate of firing of f is r iff ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= rate of firing of f is r1 ...\n(〈smi , σm〉, j) |= rate of firing of f is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≥ rx (4.184)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average total production of f atloc l is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= total production of f atloc l is r1 ...\nCHAPTER 4. THE BIOPATHQA SYSTEM 107\n(〈smi , σm〉, j) |= total production of f atloc l is rm and r = (r1 + · · · + rm)/m (4.185)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum total production of f atloc l is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= total production of f atloc l is r1 ...\n(〈smi , σm〉, j) |= total production of f atloc l is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≤ rx (4.186)\n({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum total production of f atloc l is r if ∃[r1, . . . , rm] :\n(〈s1i , σ1〉, j) |= total production of f atloc l is r1 ...\n(〈smi , σm〉, j) |= total production of f atloc l is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≥ rx (4.187)\nNext we define how a quantitative aggregate point formula is satisfied w.r.t. a set of trajectories σ1, . . . , σm in states s1i , . . . , s m i :\n{〈s1i , σ1〉, . . . , 〈smi , σm〉} |= average value of f atloc l is r if ∃[r1, . . . , rm] : 〈s1i , σ1〉 |= value of f atloc l is r1 ...\n〈smi , σm〉 |= value of f atloc l is rm and r = (r1 + · · · + rm)/m (4.188)\n{〈s1i , σ1〉, . . . , 〈smi , σm〉} |= minimum value of f atloc l is r if ∃[r1, . . . , rm] : 〈s1i , σ1〉 |= value of f atloc l is r1 ...\n〈smi , σm〉 |= value of f atloc l is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≤ rx (4.189)\n{〈s1i , σ1〉, . . . , 〈smi , σm〉} |= maximum value of f atloc l is r if ∃[r1, . . . , rm] : 〈s1i , σ1〉 |= value of f atloc l is r1 ...\n〈smi , σm〉 |= value of f atloc l is rm and ∃k, 1 ≤ k ≤ m : r = rk and ∀x, 1 ≤ x ≤ m, rk ≥ rx (4.190)\nCHAPTER 4. THE BIOPATHQA SYSTEM 108\nNext we define how a comparative quantitative aggregate interval formula is satisfied w.r.t. two sets of trajectories σ1, . . . , σm, and σ̄1, . . . , σ̄m̄ a starting point i and an ending point j:({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in average rate of production of f atloc l is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average rate of production of f atloc l is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= average rate of production of f atloc l is n2 and n2 d n1 (4.191)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in minimum rate of production of f atloc l is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum rate of production of f atloc l is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= minimum rate of production of f atloc l is n2 and n2 d n1 (4.192)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in maximum rate of production of f atloc l is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum rate of production of f atloc l is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= maximum rate of production of f atloc l is n2 and n2 d n1 (4.193)\n({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in average rate of firing of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average rate of firing of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= average rate of firing of f is n2 and n2 d n1 (4.194)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in minimum rate of firing of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum rate of firing of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= minimum rate of firing of f is n2 and n2 d n1 (4.195)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in maximum rate of firing of f is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum rate of firing of f is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= maximum rate of firing of f is n2 and n2 d n1 (4.196)\n({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in average total production of f atloc l is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= average total production of f atloc l is n1\nCHAPTER 4. THE BIOPATHQA SYSTEM 109\nand ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= average total production of f atloc l is n2 and n2 d n1 (4.197)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in minimum total production of f atloc l is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= minimum total production of f atloc l is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= minimum total production of f atloc l is n2 and n2 d n1 (4.198)({\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in maximum total production of f atloc l is d if ∃ n1 : ({〈s1i , σ1〉, . . . , 〈smi , σm〉}, j) |= maximum total production of f atloc l is n1 and ∃ n2 : ({〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉}, j) |= maximum total production of f atloc l is n2 and n2 d n1 (4.199)\nNext we define how a comparative quantitative aggregate point formula is satisfied w.r.t. two sets of trajectories σ1, . . . , σm, and σ̄1, . . . , σ̄m̄ at point i:{\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} }\n|= direction of change in average value of f atloc l is d if ∃ n1 : {〈s1i , σ1〉, . . . , 〈smi , σm〉} |= average value of f atloc l is n1 and ∃ n2 : {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} |= average value of f atloc l is n2 and n2 d n1 (4.200){\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} }\n|= direction of change in minimum value of f atloc l is d if ∃ n1 : {〈s1i , σ1〉, . . . , 〈smi , σm〉} |= minimum value of f atloc l is n1 and ∃ n2 : {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} |= minimum value of f atloc l is n2 and n2 d n1 (4.201){\n{〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} }\n|= direction of change in maximum value of f atloc l is d if ∃ n1 : {〈s1i , σ1〉, . . . , 〈smi , σm〉} |= maximum value of f atloc l is n1 and ∃ n2 : {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} |= maximum value of f atloc l is n2 and n2 d n1 (4.202)\n4.6.4 Trajectory Filtering due to Internal Observations The trajectories produced by the Guarded-Arc Petri Net execution are filtered to retain only the trajectories that satisfy all internal observations in a query statement. Let σ = s0, . . . , sk be a trajectory as given in definition 62. Then σ satisfies an observation:\nrate of production of f is n\nCHAPTER 4. THE BIOPATHQA SYSTEM 110\nif (〈s0, σ〉, k) |= rate of production of f is n (4.203) rate of production of f is n\nif (〈s0, σ〉, k) |= rate of firing of a is n (4.204) total production of f is n\nif (〈s0, σ〉, k) |= total production of f is n (4.205) f is accumulating\nif (〈s0, σ〉, k) |= f is accumulating (4.206) f is decreasing\nif (〈s0, σ〉, k) |= f is decreasing (4.207)\nrate of production of f is n when observed between time step i and time step j if (〈si, σ〉, j) |= rate of production of f is n (4.208) rate of production of f is n when observed between time step i and time step j if (〈si, σ〉, j) |= rate of firing of a is n (4.209) total production of f is n when observed between time step i and time step j if (〈si, σ〉, j) |= total production of f is n (4.210) f is accumulating when observed between time step i and time step j if (〈si, σ〉, j) |= f is accumulating (4.211) f is decreasing when observed between time step i and time step j if (〈si, σ〉, j) |= f is decreasing (4.212)\nf is higher than n if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= value of f is higher than n (4.213) f is lower than n if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= value of f is lower than n (4.214) f is n if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= value of f is n (4.215) a occurs if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= a occurs (4.216) a does not occur if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= a does not occur (4.217) a1 switches to a2 if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= a1 switches to a2 f is higher than n at time step i\nCHAPTER 4. THE BIOPATHQA SYSTEM 111\nif 〈si, σ〉 |= value of f is higher than n (4.218) f is lower than n\nat time step i if 〈si, σ〉 |= value of f is lower than n (4.219) f is n at time step i if 〈si, σ〉 |= value of f is n (4.220) a occurs at time step i if 〈si, σ〉 |= a occurs (4.221) a does not occur at time step i if 〈si, σ〉 |= a does not occur (4.222) a1 switches to a2 at time step i if 〈si, σ〉 |= a1 switches to a2 (4.223)\nLet σ = s0, . . . , sk be a trajectory of the form (65). Then σ satisfies an observation:\nrate of production of f atloc l is n if (〈s0, σ〉, k) |= rate of production of f atloc l is n (4.224) rate of production of f atloc l is n if (〈s0, σ〉, k) |= rate of firing of a is n (4.225) total production of f atloc l is n if (〈s0, σ〉, k) |= total production of f atloc l is n (4.226) f is accumulating atloc l if (〈s0, σ〉, k) |= f is accumulating atloc l (4.227) f is decreasing atloc l if (〈s0, σ〉, k) |= f is decreasing atloc l (4.228)\nrate of production of f atloc l is n when observed between time step i and time step j if (〈si, σ〉, j) |= rate of production of f atloc l is n (4.229) rate of production of f atloc l is n when observed between time step i and time step j if (〈si, σ〉, j) |= rate of firing of a is n (4.230) total production of f atloc l is n when observed between time step i and time step j if (〈si, σ〉, j) |= total production of f atloc l is n (4.231) f is accumulating atloc l when observed between time step i and time step j\nCHAPTER 4. THE BIOPATHQA SYSTEM 112\nif (〈si, σ〉, j) |= f is accumulating atloc l (4.232) f is decreasing atloc l\nwhen observed between time step i and time step j if (〈si, σ〉, j) |= f is decreasing atloc l (4.233)\nf atloc l is higher than n if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= value of f atloc l is higher than n (4.234) f atloc l is lower than n if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= value of f atloc l is lower than n (4.235) f atloc l is n if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= value of f atloc l is n (4.236) a occurs if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= a occurs (4.237) a does not occur if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= a does not occur (4.238) a1 switches to a2 if ∃i, 0 ≤ i ≤ k : 〈si, σ〉 |= a1 switches to a2 f atloc l is higher than n at time step i if 〈si, σ〉 |= value of f atloc l is higher than n (4.239) f atloc l is lower than n at time step i if 〈si, σ〉 |= value of f atloc l is lower than n (4.240) f atloc l is n at time step i if 〈si, σ〉 |= value of f atloc l is n (4.241) a occurs at time step i if 〈si, σ〉 |= a occurs (4.242) a does not occur at time step i if 〈si, σ〉 |= a does not occur (4.243) a1 switches to a2 at time step i if 〈si, σ〉 |= a1 switches to a2 (4.244)\nA trajectory σ is kept for further processing w.r.t. a set of internal observations 〈internal observation〉1, . . . , 〈internal observation〉n if σ |= 〈internal observation〉i, 1 ≤ i ≤ n.\nCHAPTER 4. THE BIOPATHQA SYSTEM 113\n4.6.5 Query Description Satisfaction\nNow, we define query statement semantics using LTL syntax. Let D be a domain description with simple fluents and σ = s0, . . . , sk be its trajectory of length k as defined in (62). Let σ1, . . . , σm represent the set of trajectories of D filtered by observations as necessary, with each trajectory has the form σi = si0, . . . , s i k 1 ≤ i ≤ m. Let D̄ be a modified domain description and σ̄1, . . . , σ̄m̄ be its trajectories of the form σ̄i = s̄i0, . . . , s̄ i k. Then we define query satisfaction using the formula satisfaction in section 4.6.3 as follows. Two sets of trajectories σ1, . . . , σm and σ̄1, . . . , σ̄m̄ satisfy a comparative query description based on formula satisfaction of section 4.6.3 as follows:{ {〈s10, σ1〉, . . . , 〈sm0 , σm〉}, {〈s̄10, σ̄1〉, . . . , 〈s̄m̄0 , σ̄m̄〉}\n} |= direction of change in aggop rate of production of f is d\nwhen observed between time step i and time step j if ({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in aggop rate of production of f is d (4.245){\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉}, {〈s̄10, σ̄1〉, . . . , 〈s̄m̄0 , σ̄m̄〉} }\n|= direction of change in aggop rate of firing of f is d when observed between time step i and time step j\nif ({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in aggop rate of firing of f is d (4.246){\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉}, {〈s̄10, σ̄1〉, . . . , 〈s̄m̄0 , σ̄m̄〉} }\n|= direction of change in aggop total production of f is d when observed between time step i and time step j\nif ({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in aggop total production of f is d (4.247){\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉}, {〈s̄10, σ̄1〉, . . . , 〈s̄m̄0 , σ̄m̄〉} }\n|= direction of change in aggop value of f is d when observed at time step i\nif { {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } |= direction of change in aggop value of f is d (4.248)\nA set of trajectories σ1, . . . , σm, each of length k satisfies a quantitative or a qualitative interval query description based on formula satisfaction of section 4.6.3 as follows:\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of production of f is n if ∃x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= rate of production of f is n (4.249) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of firing of a is n if ∃x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= rate of firing of a is n (4.250) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= total production of f is n if ∃x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= total production of f is n (4.251)\nCHAPTER 4. THE BIOPATHQA SYSTEM 114\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of production of f is n when observed between time step i and time step j\nif ∃x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= rate of production of f is n (4.252) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of firing of a is n\nwhen observed between time step i and time step j if ∃x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= rate of firing of a is n (4.253)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= total production of f is n when observed between time step i and time step j\nif ∃x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= total production of f is n (4.254)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is accumulating if ∃x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= f is accumulating (4.255) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is decreasing if ∃x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= f is decreasing (4.256)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is accumulating when observed between time step i and time step j\nif ∃x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= f is accumulating (4.257) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is decreasing\nwhen observed between time step i and time step j if ∃x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= f is decreasing (4.258)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of production of f is n in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= rate of production of f is n (4.259) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of firing of a is n\nin all trajectories if ∀x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= rate of firing of a is n (4.260)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= total production of f is n in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= total production of f is n (4.261)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of production of f is n when observed between time step i and time step j in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= rate of production of f is n (4.262) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of firing of a is n\nwhen observed between time step i and time step j in all trajectories\nCHAPTER 4. THE BIOPATHQA SYSTEM 115\nif ∀x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= rate of firing of a is n (4.263) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= total production of f is n\nwhen observed between time step i and time step j in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= total production of f is n (4.264)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is accumulating in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= f is accumulating (4.265) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is decreasing\nin all trajectories if ∀x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= f is decreasing (4.266)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is accumulating when observed between time step i and time step j in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= f is accumulating (4.267) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is decreasing\nwhen observed between time step i and time step j in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= f is decreasing (4.268)\nA set of trajectories σ1, . . . , σm, each of length k satisfies a quantitative or a qualitative point query description based on formula satisfaction of section 4.6.3 as follows:\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is higher than n if ∃x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f is higher than n (4.269) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is lower than n if ∃x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f is lower than n (4.270) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is n if ∃x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f is n (4.271)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is higher than n at time step i\nif ∃x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f is higher than n (4.272) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is lower than n\nat time step i if ∃x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f is lower than n (4.273)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is n at time step i\nif ∃x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f is n (4.274)\nCHAPTER 4. THE BIOPATHQA SYSTEM 116\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is higher than n in all trajectories\nif ∀x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f is higher than n (4.275) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is lower than n\nin all trajectories if ∀x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f is lower than n (4.276)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is n in all trajectories\nif ∀x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f is n (4.277)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is higher than n at time step i in all trajectories\nif ∀x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f is higher than n (4.278) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is lower than n\nat time step i in all trajectories\nif ∀x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f is lower than n (4.279) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f is n\nat time step i in all trajectories\nif ∀x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f is n (4.280)\nNow, we turn our attention to domain descriptions with locational fluents. Let D be a domain description and σ = s0, . . . , sk be its trajectory of length k as defined in (65). Let σ1, . . . , σm represent the set of trajectories of D filtered by observations as necessary, with each trajectory has the form σi = si0, . . . , s i k 1 ≤ i ≤ m. Let D̄ be a modified domain description and σ̄1, . . . , σ̄m̄ be its trajectories of the form σ̄i = s̄i0, . . . , s̄ i k. Then we define query satisfaction using the formula satisfaction in section 4.6.3 as follows. Two sets of trajectories σ1, . . . , σm and σ̄1, . . . , σ̄m̄ satisfy a comparative query description based on formula satisfaction of section 4.6.3 as follows:{ {〈s10, σ1〉, . . . , 〈sm0 , σm〉}, {〈s̄10, σ̄1〉, . . . , 〈s̄m̄0 , σ̄m̄〉}\n} |= direction of change in 〈aggop〉 rate of production of f atloc l is d\nwhen observed between time step i and time step j if ({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in 〈aggop〉 rate of production of f atloc l is d (4.281)\nCHAPTER 4. THE BIOPATHQA SYSTEM 117\n{ {〈s10, σ1〉, . . . , 〈sm0 , σm〉}, {〈s̄10, σ̄1〉, . . . , 〈s̄m̄0 , σ̄m̄〉} } |= direction of change in 〈aggop〉 rate of firing of f is d\nwhen observed between time step i and time step j if ({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in 〈aggop〉 rate of firing of f is d (4.282){\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉}, {〈s̄10, σ̄1〉, . . . , 〈s̄m̄0 , σ̄m̄〉} }\n|= direction of change in 〈aggop〉 total production of f atloc l is d when observed between time step i and time step j\nif ({ {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } , j ) |= direction of change in 〈aggop〉 total production of f atloc l is d (4.283){\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉}, {〈s̄10, σ̄1〉, . . . , 〈s̄m̄0 , σ̄m̄〉} }\n|= direction of change in 〈aggop〉 value of f atloc l is d when observed at time step i\nif { {〈s1i , σ1〉, . . . , 〈smi , σm〉}, {〈s̄1i , σ̄1〉, . . . , 〈s̄m̄i , σ̄m̄〉} } |= direction of change in 〈aggop〉 value of f atloc l is d (4.284)\nA set of trajectories σ1, . . . , σm, each of length k satisfies a quantitative or a qualitative interval query description based on formula satisfaction of section 4.6.3 as follows:\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of production of f atloc l is n if ∃x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= rate of production of f atloc l is n (4.285) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of firing of a is n if ∃x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= rate of firing of a is n (4.286) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= total production of f atloc l is n if ∃x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= total production of f atloc l is n (4.287)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of production of f atloc l is n when observed between time step i and time step j\nif ∃x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= rate of production of f atloc l is n (4.288) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of firing of a is n\nwhen observed between time step i and time step j if ∃x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= rate of firing of a is n (4.289)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= total production of f atloc l is n when observed between time step i and time step j\nif ∃x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= total production of f atloc l is n (4.290)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is accumulating atloc l if ∃x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= f is accumulating atloc l (4.291) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is decreasing atloc l\nCHAPTER 4. THE BIOPATHQA SYSTEM 118\nif ∃x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= f is decreasing atloc l (4.292)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is accumulating atloc l when observed between time step i and time step j\nif ∃x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= f is accumulating atloc l (4.293) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is decreasing atloc l\nwhen observed between time step i and time step j if ∃x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= f is decreasing atloc l (4.294)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of production of f atloc l is n in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= rate of production of f atloc l is n (4.295) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of firing of a is n\nin all trajectories if ∀x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= rate of firing of a is n (4.296)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= total production of f atloc l is n in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= total production of f atloc l is n (4.297)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of production of f atloc l is n when observed between time step i and time step j in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= rate of production of f atloc l is n (4.298) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= rate of firing of a is n\nwhen observed between time step i and time step j in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= rate of firing of a is n (4.299) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= total production of f atloc l is n\nwhen observed between time step i and time step j in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= total production of f atloc l is n till j (4.300)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is accumulating atloc l in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= f is accumulating atloc l (4.301) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is decreasing atloc l\nin all trajectories if ∀x, 1 ≤ x ≤ m : (〈sx0, σx〉, k) |= f is decreasing atloc l (4.302)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is accumulating atloc l\nCHAPTER 4. THE BIOPATHQA SYSTEM 119\nwhen observed between time step i and time step j in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= f is accumulating atloc l (4.303) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= f is decreasing atloc l\nwhen observed between time step i and time step j in all trajectories\nif ∀x, 1 ≤ x ≤ m : (〈sxi , σx〉, j) |= f is decreasing atloc l (4.304)\nA set of trajectories σ1, . . . , σm, each of length k satisfies a quantitative or a qualitative point query description based on formula satisfaction of section 4.6.3 as follows:\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is higher than n if ∃x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f atloc l is higher than n (4.305) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is lower than n if ∃x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f atloc l is lower than n (4.306) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is n if ∃x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f atloc l is n (4.307)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is higher than n at time step i\nif ∃x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f atloc l is higher than n (4.308) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is lower than n\nat time step i if ∃x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f atloc l is lower than n (4.309)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is n at time step i\nif ∃x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f atloc l is n (4.310)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is higher than n in all trajectories\nif ∀x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f atloc l is higher than n (4.311) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is lower than n\nin all trajectories if ∀x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f atloc l is lower than n (4.312)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is n in all trajectories\nif ∀x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi , σx〉 |= value of f atloc l is n (4.313)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is higher than n at time step i in all trajectories\nCHAPTER 4. THE BIOPATHQA SYSTEM 120\nif ∀x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f atloc l is higher than n (4.314) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is lower than n\nat time step i in all trajectories\nif ∀x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f atloc l is lower than n (4.315) {〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= value of f atloc l is n\nat time step i in all trajectories\nif ∀x, 1 ≤ x ≤ m : 〈sxi , σx〉 |= value of f atloc l is n (4.316)\nNext, we generically define the satisfaction of a simple point formula cascade query w.r.t. a set of trajectories σ1, . . . , σm. The trajectories will either be as defined in definitions (62) or (65) for simple point formula cascade query statement made up of simple fluents or locational fluents, respectively. A set of trajectories σ1, . . . , σm, each of length k satisfies a simple point formula cascade based on formula satisfaction of section 4.6.3 as follows:\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= 〈simple point formula〉0 after 〈simple point formula〉1,1, . . . , 〈simple point formula〉1,n1 ...\nafter 〈simple point formula〉u,1, . . . , 〈simple point formula〉u,nu if ∃x∃i0∃i1 . . .∃iu, 1 ≤ x ≤ m, i1 < i0 ≤ k, . . . , iu < iu−1 ≤ k, 0 ≤ iu ≤ k : 〈sxi0 , σx〉 |= 〈simple point formula〉0 and 〈sxi1 , σx〉 |= 〈simple point formula〉1,1 and . . . and 〈s x i1 , σx〉 |= 〈simple point formula〉1,n1 and\n...\n〈sxiu , σx〉 |= 〈simple point formula〉u,1 and . . . and 〈s x iu , σx〉 |= 〈simple point formula〉u,nu\n(4.317)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= 〈simple point formula〉0 after 〈simple point formula〉1,1, . . . , 〈simple point formula〉1,n1 ...\nafter 〈simple point formula〉u,1, . . . , 〈simple point formula〉u,nu in all trajectories\nif ∀x, 1 ≤ x ≤ m,∃i0∃i1 . . .∃iu, i1 < i0 ≤ k, . . . , iu < iu−1 ≤ k, 0 ≤ iu ≤ k : 〈sxi0 , σx〉 |= 〈simple point formula〉0 and 〈sxi1 , σx〉 |= 〈simple point formula〉1,1 and . . . and 〈s x i1 , σx〉 |= 〈simple point formula〉1,n1 and\n...\n〈sxiu , σx〉 |= 〈simple point formula〉u,1 and . . . and 〈s x iu , σx〉 |= 〈simple point formula〉u,nu\nCHAPTER 4. THE BIOPATHQA SYSTEM 121\n(4.318)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= 〈simple point formula〉0 when 〈simple point formula〉1,1, . . . , 〈simple point formula〉1,n1\nif ∃x∃i, 1 ≤ x ≤ m, 0 ≤ i ≤ k : 〈sxi0 , σx〉 |= 〈simple point formula〉0 and 〈sxi1 , σx〉 |= 〈simple point formula〉1,1 and . . . and 〈s x i1 , σx〉 |= 〈simple point formula〉1,n1\n(4.319)\n{〈s10, σ1〉, . . . , 〈sm0 , σm〉} |= 〈simple point formula〉0 when 〈simple point formula〉1,1, . . . , 〈simple point formula〉1,n1 in all trajectories\nif ∀x, 1 ≤ x ≤ m,∃i, 0 ≤ i ≤ k : 〈sxi0 , σx〉 |= 〈simple point formula〉0 and 〈sxi1 , σx〉 |= 〈simple point formula〉1,1 and . . . and 〈s x i1 , σx〉 |= 〈simple point formula〉1,n1\n(4.320)\n4.6.6 Query Statement Satisfaction\nLet D as defined in section 4.3 be a domain description and Q be a query statement (4.122) as defined in section 4.5 with query description U, interventions V1, . . . ,V|V |, internal observations O1, . . . ,O|O|, and initial conditions I1, . . . , I|I|. Let D1 ≡ D I1 · · · I|I| V1 · · · V|V | be the modified domain description constructed by applying the initial conditions and interventions from Q as defined in section 4.6.2. Let σ1, . . . , σm be the trajectories of D1 that satisfy O1, . . . ,O|O| as given in section 4.6.4. Then, D satisfies Q if {σ1, . . . , σm} |= U as defined in section 4.6.5.\nLet D as defined in section 4.3 be a domain description and Q be a query statement (4.123) as defined in section 4.5 with query description U, interventions V1, . . . ,V|V |, internal observations O1, . . . ,O|O|, and initial conditions I1, . . . , I|I|. Let D) ≡ D I1 · · · I|I| be the nominal domain description constructed by applying the initial conditions from Q as defined in section 4.6.2. Let σ1, . . . , σm be the trajectories of D0. Let D1 ≡ D I1 · · · I|I| V1 · · · V|V | be the modified domain description constructed by applying the initial conditions and interventions from Q as defined in section 4.6.2. Let σ̄1, . . . , σ̄m̄ be the trajectories of D1 that satisfy O1, . . . ,O|O| as given in section 4.6.4. Then, D satisfies Q if { {σ1, . . . , σm}, {σ̄1, . . . , σ̄m̄} } |= U as defined in section 4.6.5.\nCHAPTER 4. THE BIOPATHQA SYSTEM 122\n4.6.7 Example Encodings\nIn this section we give some examples of how we will encode queries and pathways related to these queries. We will also show how the pathway is modified to answer questions 3.\nQuestion 11 At one point in the process of glycolysis, both DHAP and G3P are produced. Isomerase catalyzes the reversible conversion between these two isomers. The conversion of DHAP to G3P never reaches equilibrium and G3P is used in the next step of glycolysis. What would happen to the rate of glycolysis if DHAP were removed from the process of glycolysis as quickly as it was produced?\nThe question is asking for the direction of change in the rate of glycolysis when the nominal glycolysis pathway is compared against a modified pathway in which dhap is removed as soon as it is produced. Since this rate can vary with the trajectory followed by the world evolution, we consider the average change in rate. From the domain knowledge (Reece et al., 2010, Figure 9.9) we know that the rate of glycolysis can be measured by the rate of pyruvate (the end product of glycolysis) and that the rate of pyruvate is equal to the rate of bpg13 (due to linear chain from bpg13 to pyruvate). Thus, we can monitor the rate of bpg13 instead to determine the rate of glycolysis. To ensure that our pathway is not starved due to source ingredients, we add a continuous supply of f 16bp in quantity 1 to the pathway.\n3Some of the same pathways appear in previous chapters, they have been updated here with additional background knowledge.\nCHAPTER 4. THE BIOPATHQA SYSTEM 123\nThen, the following pathway specification encodes the domain description D for question 11 and produces the PN in Fig. 4.3 minus the tr, t3 transitions:\ndomain of f 16bp is integer, dhap is integer, g3p is integer, bpg13 is integer t4 may execute causing f 16bp change value by − 1, dhap change value by + 1, g3p change value by + 1 t5a may execute causing dhap change value by − 1, g3p change value by + 1 t5b may execute causing g3p change value by − 1, dhap change value by + 1 t6 may execute causing g3p change value by − 1, bpg13 change value by + 2 initially f 16bp has value 0, dhap has value 0, g3p has value 0, bpg13 has value 0 firing style max\n(4.321)\nAnd the following query Q for a simulation of length k encodes the question:\ndirection of change in average rate of production of bpg13 is d when observed between time step 0 and time step k; comparing nominal pathway with modified pathway obtained\ndue to interventions : remove dhap as soon as produced; using initial setup : continuously supply f 16bp in quantity 1; (4.322)\nSince this is a comparative quantitative query statement, it is decomposed into two subqueries, Q0 capturing the nominal case of average rate of production w.r.t. given initial conditions:\naverage rate of production of bpg13 is navg when observed between time step 0 and time step k;\nusing initial setup : continuously supply f 16bp in quantity 1;\nand Q1 capturing the modified case in which the pathway is subject to interventions and observations w.r.t. initial conditions:\naverage rate of production of bpg13 is n′avg when observed between time step 0 and time step k;\ndue to interventions : remove dhap as soon as produced; using initial setup : continuously supply f 16bp in quantity 1;\nThen the task is to determine d, such that D |= Q0 for some value of navg, D |= Q1 for some value of n′avg, and n ′ avg d navg. To answer the sub-queries Q0 and Q1 we build modified domain descriptions D0 and D1, where, D0 ≡ D (continuously supply f 16bp in quantity 1) is the nominal domain description D modified according to Q0 to include the initial conditions; and D1 ≡ D0 (remove dhap as soon as produced) is the modified domain description D modified according to Q1 to include the initial conditions as well as the interventions. The operator modifies the domain description to its left by adding, removing or modifying pathway specification language statements to add the interventions and initial conditions description to its right. Thus,\nD0 = D + { t f f 16bp may execute causing f 16bp change value by + 1\nCHAPTER 4. THE BIOPATHQA SYSTEM 124\nD1 = D0 + { tr may execute causing dhap change value by ∗\nPerforming a simulation of k = 5 steps with ntok = 20 max tokens, we find that the average rate of bpg13 production decreases from navg = 0.83 to n′avg = 0.5. Thus, D |= Q iff d =′<′. Alternatively, we say that the rate of glycolysis decreases when DHAP is removed as quickly as it is produced.\nQuestion 12 When and how does the body switch to B-oxidation versus glycolysis as the major way of burning fuel?\nThe following pathway specification encodes the domain description D for question 12 and produces the PN in Fig. 4.4:\ndomain of gly is integer, sug is integer, f ac is integer, acoa is integer gly may execute causing sug change value by − 1, acoa change value by + 1 box may execute causing f ac change value by − 1, acoa change value by + 1 inhibit box if sug has value 1 or higher initially sug has value 3, f ac has value 3 acoa has value 0 t1 may execute causing sug change value by + 1 t2 may execute causing f ac change value by + 1 firing style ∗\nwhere, f ac represents fatty acids, sug represents sugar, acoa represents acetyl coenzyme-A, gly represents the process of glycolysis, and box represents the process of beta oxidation.\nThe question is asking for the general conditions when glycolysis switches to beta-oxidation, which is some property “p” that holds after which the switch occurs. The query Q is encoded as:\ngly switches to box when p; due to observations :\ngly switches to box in all trajectories\nCHAPTER 4. THE BIOPATHQA SYSTEM 125\nwhere condition ‘p’ is a conjunction of simple point formulas. Then the task is to determine a minimal such conjunction of formulas that is satisfied in the state where ‘gly′ switches to ‘box′ holds over all trajectories.4\nSince there is no change in initial conditions of the pathway and there are no interventions, the modified domain description D1 ≡ D.\nIntuitively, p is the property that holds over fluents of the transitional state s j in which the switch takes palce, such that gly ∈ T j−1, box < T j−1, gly < T j, box ∈ T j and the minimal set of firings leading up to it. The only trajectories to consider are the ones in which the observation is true. Thus the condition p is determined as the intersection of sets of fluent based conditions that were true at the time of the switch, such as:\n{sug has value s j(sug), sug has value higher than 0, . . . sug has value higher than s j(sug) − 1, sug has value lower than s j(sug) + 1, f ac has value s j( f ac), f ac has value higher than 0, . . . f ac has value higher than s j( f ac) − 1, f ac has value lower than s j( f ac) + 1, acoa has value s j(acoa), acoa has value higher than 0, . . . acoa has value higher than s j(acoa) − 1, acoa has value lower than s j(acoa) + 1}\nSimulating it for k = 5 steps with ntok = 20 max tokens, we find the condition p = acoa has value greater than 0, sug has value 0, sug has value lower than 1, f ac has value higher than 0}. Thus, the state when this switch occurs must sugar (sug) depleted and available supply of fatty acids ( f ac).\nQuestion 13 The final protein complex in the electron transport chain of the mitochondria is non-functional. Explain the effect of this on pH of the intermembrane space of the mitochondria.\nThe question is asking for the direction of change in the pH of the intermembrane space when the nominal case is compared against a modified pathway in which the complex 4 (t4) is defective. Since pH is defined as −log10(H+), we monitor the total production of H+ ions to determine the change in pH value. However, since different world evolutions can follow different trajectories, we consider the average production of H+. Furthermore, we model the defective t4 as being unable to carry out its reaction, by disabling/inhibiting it.\nThen the following pathway specification encodes the domain description D for question 13 and produces the PN in Fig. 4.5 without the f t4 place node. In the pathway description below, we have included only one domain declaration for all fluents as an example and left the rest out to save space. Assume integer domain declaration for all fluents.\ndomain of nadh atloc mm is integer\nt1 may execute causing nadh atloc mm change value by − 2, h atloc mm change value by − 2, e atloc q change value by + 2, h atloc is change value by + 2,\n4Note that this could be an LTL formula that must hold in all trajectories, but we did not add it here to keep the language simple.\nCHAPTER 4. THE BIOPATHQA SYSTEM 126\nnadp atloc mm change value by + 2 t2 may execute causing\nf adh2 atloc mm change value by − 2, e atloc q change value by + 2, f ad atloc mm change value by + 2\nt3 may execute causing e atloc q change value by − 2, h atloc mm change value by − 2, e atloc cytc change value by + 2, h atloc is change value by + 2\nt4 may execute causing o2 atloc mm change value by − 1, e atloc cytc change value by − 2, h atloc mm change value by − 6, h2o atloc mm change value by + 2, h atloc is change value by + 2\nt10 may execute causing nadh atloc mm change value by + 2, h atloc change value by + 4, o2 atloc mm change value by + 1\ninitially f adh2 atloc mm has value 0, e atloc mm has value 0, f ad atloc mm has value 0, o2 atloc mm has value 0, h2o atloc mm has value 0, atp atloc mm has value 0\ninitially f adh2 atloc is has value 0, e atloc is has value 0, f ad atloc is has value 0, o2 atloc is has value 0, h2o atloc is has value 0, atp atloc is has value 0\ninitially f adh2 atloc q has value 0, e atloc q has value 0, f ad atloc q has value 0, o2 atloc q has value 0,\nCHAPTER 4. THE BIOPATHQA SYSTEM 127\nh2o atloc q has value 0, atp atloc q has value 0 initially\nf adh2 atloc cytc has value 0, e atloc cytc has value 0, f ad atloc cytc has value 0, o2 atloc cytc has value 0, h2o atloc cytc has value 0, atp atloc cytc has value 0 firing style max\nwhere mm represents the mitochondrial matrix, is represents the intermembrane space, t1 − t4 represent the reaction of the four complexes making up the electron transport chain, h is the H+ ion, nadh is NADH, f adh2 is FADH2, f ad is FAD, e is electrons, o2 is oxygen O2, atp is AT P, h2o is water H2O, and t10 is a source transition that supply a continuous supply of source ingredients for the chain to function, such as nadh, h, o2.\nAs a result, the query Q asked by the question is encoded as follows:\ndirection of change in average total production of h atloc is is d when observed between time step 0 and time step k; comparing nominal pathway with modified pathway obtained due to intervention t4 disabled;\nSince this is a comparative quantitative query statement, it is decomposed into two queries, Q0 capturing the nominal case of average production w.r.t. given initial conditions:\naverage total production of h atloc is is navg when observed between time step 0 and time step k;\nand Q1 the modified case w.r.t. initial conditions, modified to include interventions and subject to observations:\naverage total production of h atloc is is n′avg when observed between time step 0 and time step k; due to intervention t4 disabled;\nThe the task is to determine d, such that D |= Q0 for some value of navg, D |= Q1 for some value of n′avg, and n ′ avg d navg. To answer the sub-queries Q0 and Q1 we build nominal description D0 and modified pathway D1, where D0 ≡ D since there are no initial conditions; and D1 ≡ D0 (t4 disabled) is the domain description D modified according to Q1 to modified to include the initial conditions as well as interventions. The operator modifies the domain description to its left by adding, removing or modifying pathway specification language statements to add the intervention and initial conditions to its right. Thus,\nD1 = D0 + { inhibit t4\nPerforming a simulation of k = 5 steps with ntok = 20 max tokens, we find that the average total production of H+ in the intermembrane space (h at location is) reduces from 16 to 14. Lower quantity of H+ translates to a higer numeric value of −log10, as a result the pH increases.\nQuestion 14 Membranes must be fluid to function properly. How would decreased fluidity of the membrane affect the efficiency of the electron transport chain?\nCHAPTER 4. THE BIOPATHQA SYSTEM 128\nFrom background knowledge, we know that, “Establishing the H+ gradient is a major function of the electron transport chain” (Reece et al., 2010, Chapter 9), we measure the efficiency in terms of H+ ions moved to the intermembrane space (is) over time. Thus, we interpret the question is asking for the direction of change in the production of H+ moved to the intermembrane space when the nominal case is compared against a modified pathway with decreased fluidity of membrane. Additional background knowledge from Reece et al. (2010) tells us that the decreased fluidity reduces the speed of mobile carriers such as q and cytc. Fluidity can span a range of values, but we will consider one such value v per query.\nThe following pathway specification encodes the domain description D for question 14 and produces the PN in Fig. 4.6 minus the places q 3, cytc 4 and transitions tq, tcytc. In the pathway description below, we have included only one domain declaration for all fluents as an example and left the rest out to save space. Assume integer domain declaration for all fluents.\ndomain of nadh atloc mm is integer\nt1 may execute causing nadh atloc mm change value by − 2, h atloc mm change value by − 2, e atloc q change value by + 2, h atloc is change value by + 2, nadp atloc mm change value by + 2\nt3 may execute causing e atloc q change value by − 2, h atloc mm change value by − 2, e atloc cytc change value by + 2, h atloc is change value by + 2\nt4 may execute causing o2 atloc mm change value by − 1, e atloc cytc change value by − 2, h atloc mm change value by − 2, h2o atloc mm change value by + 2, h atloc is change value by + 2\nt10 may execute causing nadh atloc mm change value by + 2, h atloc mm change value by + 4, o2 atloc mm change value by + 1\ninitially nadh atloc mm has value 0, h atloc mm has value 0, nadp atloc mm has value 0, o2 atloc mm has value 0 h2o atloc mm has value 0\nCHAPTER 4. THE BIOPATHQA SYSTEM 129\ninitially nadh atloc is has value 0, h atloc is has value 0, nadp atloc is has value 0, o2 atloc is has value 0 h2o atloc is has value 0\ninitially nadh atloc q has value 0, h atloc q has value 0, nadp atloc q has value 0, o2 atloc q has value 0 h2o atloc q has value 0\ninitially nadh atloc cytc has value 0, h atloc cytc has value 0, nadp atloc cytc has value 0, o2 atloc cytc has value 0 h2o atloc cytc has value 0\nfiring style max\nThe query Q asked by the question is encoded as follows:\ndirection of change in average total production of h atloc is is d when observed between time step 0 and time step k; comparing nominal pathway with modified pathway obtained\ndue to interventions : add delay of v time units in availability of e atloc q, add delay of v time units in availability of e atloc cytc;\nSince this is a comparative quantitative query statement, we decompose it into two queries, Q0 capturing the nominal case of average rate of production w.r.t. given initial conditions:\naverage total production of h atloc is is d when observed between time step 0 and time step k;\nand Q1 the modified case w.r.t. initial conditions, modified to include interventions and subject to observations:\naverage total production of h atloc is is d when observed between time step 0 and time step k;\ndue to interventions : add delay of v time units in availability of e atloc q, add delay of v time units in availability of e atloc cytc;\nThen the task is to determine d, such that D |= Q0 for some value of navg, D |= Q1 for some value of n′avg, and n ′ avg d navg. To answer the sub-queries Q0 and Q1 we build modified domain descriptions D0 and D1, where, D0 ≡ D is the nominal domain description D modified according to Q0 to include the initial conditions; and D1 ≡ D0 (add delay of v time units in availability of e atloc q) (add delay of v time units in availability of e atloc cytc) is the modified domain description D modified according to Q1 to include the initial conditions as well as the interventions. The operator modifies the domain description to its left by adding, removing or\nCHAPTER 4. THE BIOPATHQA SYSTEM 130\nmodifying pathway specification language statements to add the interventions and initial conditions description to its right. Thus,\nD1 = D −  t1 may execute causing nadh atloc mm change value by − 2, h atloc mm change value by − 2, e atloc q change value by + 2, h atloc is change value by + 2, nadp atloc mm change value by + 2 t3 may execute causing e atloc q change value by − 2, h atloc mm change value by − 2, e atloc cytc change value by + 2, h atloc is change value by + 2 \n+  t1 may execute causing nadh atloc mm change value by − 2, h atloc mm change value by − 2, e atloc q 3 change value by + 2, h atloc is change value by + 2, nadp atloc mm change value by + 2 t3 may execute causing e atloc q change value by − 2, h atloc mm change value by − 2, e atloc cytc 4 change value by + 2, h atloc is change value by + 2 tq may fire causing e atloc q 3 change value by − 2, e atloc q change value by + 2 tcytc may fire causing e atloc cytc 4 change value by − 2, e atloc cytc change value by + 2\ntq executes in 4 time units tcytc executes in 4 time units\n\nPerforming a simulation of k = 5 steps with ntok = 20 max tokens with a fluidity based delay of 2, we find that the average total production of H+ in the intermembrane space (h at location is) reduces from 16 to 10. Lower quantity of H+ going into the intermembrane space means lower efficiency, where we define the efficiency as the total amount of H+ ions transferred to the intermembrane space over the simulation run.\n4.6.8 Example Encoding with Conditional Actions Next, we illustrate how conditional actions would be encoded in our high-level language with an example. Consider the pathway from question 11. Say, the reaction step t4 has developed a fault, in which it has two modes of operation, in the first mode, when f 16bp has less than 3 units available, the reaction proceeds normally, but when f 16bp is available in 3 units or higher, the reaction continues to produce g3p but not dhap directly. dhap can still be produced by subsequent step from g3p. The modified pathway is given in our pathway specification\nCHAPTER 4. THE BIOPATHQA SYSTEM 131\nlanguage below:\nt3 may execute causing f 16bp change value by + 1 t4 may execute causing f 16bp change value by − 1, dhap change value by + 1,\ng3p change value by + 1 if g3p has value lower than 3\nt4 may execute causing f 16bp change value by − 1, dhap change value by + 1 if g3p has value 3 or higher t5a may execute causing dhap change value by − 1, g3p change value by + 1 t5b may execute causing g3p change value by − 1, dhap change value by + 1 t6 may execute causing g3p change value by − 1, bpg13 change value by + 2 initially f 16bp has value 0, dhap has value 0, g3p has value 0, bpg13 has value 0 firing style max\nWe ask the same question Q: direction of change in average rate of production of bpg13 is d\nwhen observed between time step 0 and time step k; comparing nominal pathway with modified pathway obtained\ndue to interventions : remove dhap as soon as produced; using initial setup : continuously supply f 16bp in quantity 1;\nSince this is a comparative quantitative query statement, we decompose it into two queries, Q0 capturing the nominal case of average rate of production w.r.t. given initial conditions:\naverage rate of production of bpg13 is n when observed between time step 0 and time step k;\nusing initial setup : continuously supply f 16bp in quantity 1;\nand Q1 the modified case w.r.t. initial conditions, modified to include interventions and subject to observations:\naverage rate of production of bpg13 is n when observed between time step 0 and time step k;\ndue to interventions : remove dhap as soon as produced; using initial setup : continuously supply f 16bp in quantity 1;\nThen the task is to determine d, such that D |= Q0 for some value of navg, D |= Q1 for some value of n′avg, and n ′ avg d navg. To answer the sub-queries Q0 and Q1 we build modified domain descriptions D0 and D1, where, D0 ≡ D (continuously supply f 16bp in quantity 1) is the nominal domain description D modified according to Q0 to include the initial conditions; and D1 ≡ D0 (remove dhap as soon as produced) is the modified domain description D modified according to Q1 to include the initial conditions as well as the interventions. The operator modifies the domain description to its left by adding, removing or modifying pathway specification language statements to add the interventions and initial conditions description to its right. Thus,\nD0 = D + { t f f 16bp may execute causing f 16bp change value by + 1\nD1 = D0 + { tr may execute causing dhap change value by ∗\nCHAPTER 4. THE BIOPATHQA SYSTEM 132\n4.6.9 ASP Program\nNext we briefly outline how the pathway specification and the query statement components are encoded in ASP (using Clingo syntax). In the following section, we will illustrate the process using an example.\nAs evident from the previous sections, we need to simulate non-comparative queries only. Any comparative queries are translated into non-comparative sub-queries, each of which is simulated and their results compared to evaluate the comparative query.\nThe ASP program is a concatenation of the translation of a pathway specification (domain description which includes the firing style) and internal observations. Any initial setup conditions and interventions are pre-applied to the pathway specification using intervention semantics in section 4.6.2 before it is translated to ASP using the translation in chapter 2 as our basis. The encoded pathway specification has the semantics defined in section 4.4. Internal observations in the ‘due to observations:’ portion of query statement are translated into ASP constraints using the internal observation semantics defined in section 4.6.4 and added to the encoding of the pathway specification.\nThe program if simulated for a specified simulation length k produces all trajectories of the pathway for the specified firing style, filtered by the internal observations. The query description specified in the query statement is then evaluated w.r.t. these trajectories. Although this part can be done in ASP, we have currently implemented it outside ASP in our implementation for ease of using floating point math.\nNext, we describe an implementation of our high level language and illustrate the construction of an ASP program, its simulation, and query statement evaluation.\n4.6.10 Implementation\nWe have developed an implementation 5 of a subset of our high level (Pathway and Query specification) language in Python. We use the Clingo ASP implementation for our simulation. In this section we describe various components of this implementation. An architectural overview of our implementation is shown in figure 4.7.\nThe Pathway Specification Language (BioPathQA-PL) Parser component is responsible for parsing the Pathway Specification Language (BioPathQA-PL). It use PLY (Python Lex-Yacc)6\nto parse a given pathway specification using grammar based on section 4.3. On a successful parse, a Guarded-Arc Petri Net pathway model based on section 4.4 is constructed for the pathway specification.\nThe Query Language Parser component is responsible for parsing the Query Specification Language (BioPathQA-QL). It uses PLY to parse a given query statement using grammar based on section 4.5. On a successful parse, an internal representation of the query statement is constructed. Elements of this internal representation include objects representing the query description, the list of interventions, the list of internal observations, and the list of initial setup\n5Implementation available at: https://sites.google.com/site/deepqa2014/ 6http://www.dabeaz.com/ply\nCHAPTER 4. THE BIOPATHQA SYSTEM 133\nCHAPTER 4. THE BIOPATHQA SYSTEM 134\nconditions. Each intervention and initial setup condition object has logic in it to modify a given pathway per the intervention semantics described in section 4.6.2. The Query Statement Model component is also responsible for generating basic queries for aggregate queries and implementing interventions in the Petri Net Pathway Model.\nThe Dictionary of fluents, locations, and actions is consulted by the ASP code generator to standardize symbol names in the ASP code produced for the pathway specification and the internal observations.\nThe ASP Translator component is responsible for translating the Guarded-Arc Petri Net model into ASP facts and rules; and the driver needed to simulate the model using the firing semantics specified in the pathway model. The code generated is based on the ASP translation of Petri Nets and its various extensions given in chapter 2. To reduce the ASP code and its complexity, the translator limits the output model to the extensions used in the Petri Net model to be translated. Thus, the colored tokens extension code is not produced unless colored tokens have been used. Similarly, guarded-arcs code is not produced if no arc-guards are used in the model.\nThe ASP Translator component is also responsible for translating internal observations from the Query Statement into ASP constraints to filter Petri Net trajectories based on the observation semantics in section 4.6.4. Following examples illustrate our encoding scheme. The observation ‘a1 switches to a2’ is encoded as a constraint using the following rules:\nobs_1_occurred(TS+1) :- time(TS;TS+1), trans(a1;a2),\nfires(a1,TS), not fires(a2,TS), not fires(a1,TS+1), fires(a2,TS+1).\nobs_1_occurred :- obs_1_occurred(TS), time(TS). obs_1_had_occurred(TSS) :- obs_1_occurred(TS), TS<=TSS, time(TSS;TS). :- not obs_1_occurred.\nThe observation ‘a1 occurs at time step 5’ is encoded as a constraint using the following rules:\nobs_2_occurred(TS) :- fires(a1,TS), trans(a1), time(TS), TS=5. obs_2_occurred :- obs_2_occurred(TS), time(TS). obs_2_had_occurred(TSS) :- obs_2_occurred(TS), TS<=TSS, time(TSS;TS). :- not obs_2_occurred.\nThe observation ‘s1 is decreasing atloc l1 when observed between time step 0 and time step 5’ is encoded as a constraint using the following rules:\n% obs_3_violated(TS) :- place(l1), col(s1),\nholds(l1,Q1,s1,TS), holds(l1,Q2,s1,TS+1), num(Q1;Q2), Q2 > Q1, time(TS;TS+1), TS=0, TS+1=5.\nobs_3_violated :- obs_3_violated(TS), time(TS).\n% obs_3_occurred(TS+1) :- not obs_3_violated,\nholds(l1,Q1,s1,TS), holds(l1,Q2,s1,TS+1), time(TS;TS+1), num(Q1;Q2), Q2<Q1, TS=0, TS+1=5.\nobs_3_occurred :- obs_3_occurred(TS), time(TS).\nobs_3_had_occurred(TSS) :- obs_3_occurred(TS), TS<=TSS, time(TSS;TS). :- obs_3_occurred.\nCHAPTER 4. THE BIOPATHQA SYSTEM 135\nIn addition, the translator is also responsible for any rules needed to ease post-processing of the query description. For example, for qualitative queries, a generic predicate tgt obs occurred(TS) is generated that is true when the given qualitative description holds in an answer-set at time step TS . The output of the translator is an ASP program, which when simulated using Clingo produces the (possibly) filtered trajectories of the pathway.\nThe Post Processor component is responsible for parsing the ASP answer sets, identifying the correct atoms from it, extracting quantities from atom-bodies as necessary, organizing them into a matrix form, and aggregating them as needed.\nThe User Interface component is responsible for coordinating the processing of query statement. It presents the user with a graphical user interface shown in figure 4.8. The user types a Pathway Specification (in BioPathQA-PL syntax), a Query Specification (in BioPathQA-QL syntax), and simulation parameters. On pressing “Execute Query”, the user interface component processes the query as prints results in the bottom box. Query evaluation differs by the type of query. We describe the query evaluation methodology used below.\nFor non-comparative quantitative queries:\n1. Pathway specification is parsed into a Guarded-Arc Petri Net model.\n2. Query statement is parsed into an internal form.\n3. Initial conditions from the query are applied to the pathway model.\n4. Interventions are applied to the pathway model.\n5. Modified pathway model is translated to ASP.\nCHAPTER 4. THE BIOPATHQA SYSTEM 136\n6. Internal observations are added to the ASP code as ASP constraints.\n7. Answer sets of the ASP code are computed using Clingo.\n8. Relevant atoms are extracted: fires/2 predicate for firing rate, holds/3 (or holds/4 – colored tokens) predicate for fluent quantity or rate formulas.\n9. Fluent value or firing-count values are extracted and organized as matrices with rows representing answer-sets and columns representing time-steps.\n10. Within answer-set interval or point value sub-select is done and the values converted to rates or totals as needed.\n11. If aggregation, such as average, minimum, or maximum is desired, it is performed over rows of values from the last step.\n12. If a value was specified in the query, it is compared against the computed aggregate for boolean result.\n13. If a value was not specified, the computed value is returned as the value satisfying the query statement.\n14. For queries over all trajectories, the same value must hold over all trajectories, otherwise, only one match is required to satisfy the query.\nFor non-comparative qualitative queries:\n1. Follow steps (1)-(6) of non-comparative quantitative queries.\n2. Add rules for the query description for post-processing.\n3. Answer sets of the ASP code are computed using Clingo.\n4. Relevant atoms are extracted: tgt obs occurred/1 identifying the time step when the observation within the query description is satisfied.\n5. Truth value of the query observation is determined, including determining the truth value over all trajectories.\nFor comparative quantitative queries:\n1. Query statement is decomposed into two non-comparative quantitative sub-query statements as illustrated in section 4.6.1:\n(a) A nominal sub-query which has the same initial conditions as the comparative query, but none of its interventions or observations\n(b) A modified sub-query which has the same initial conditions, interventions, and observations as the comparative query\nCHAPTER 4. THE BIOPATHQA SYSTEM 137\nboth sub-query statements have the same query description, which is the non-aggregate form of the comparative query description. Thus, a comparative average rate query is translated to non-comparative average rate sub-queries.\n2. Each sub-query statements is evaluated using steps (1)-(11) from the non-comparative quantitative query processing.\n3. A direction of change is computed by comparing the computed aggregate value for the modified query statement to the nominal query statement.\n4. If the comparative quantitative query has a direction specified, it is the compared against the computed value for a boolean result.\n5. If the comparative quantitative query did not have a direction specified, the computed value is returned as the value satisfying the query statement.\nFor explanation queries with query description with formula of the form (4.97), it is expected that the number of answer-sets will be quite large. So, we avoid generating all answer-sets before processing them, instead we process them in-line as they are generated. It is a bit slower, but leads to a smaller memory foot print.\n1. Follow steps (1)-(6) of non-comparative quantitative queries.\n2. Add rules for the query description for post-processing.\n3. Compute answer sets of the ASP code using Clingo.\n4. Extract relevant atoms:\n(a) extract tgt obs occurred/1 identifying the time step when the query description is satisfied\n(b) extract holds/3 (or holds/4 – for colored tokens) at the same time-step as tgt obs occurred/1 to construct fluent-based conditions\n5. Construct fluent-based conditions as explanation of the query observation.\n6. If the query is over all trajectories, fluent-based conditions for each trajectory are intersected across trajectories to determine the minimum set of conditions explaining the query observation.\nNext we illustrate query processing through an execution trace of question (11). The following shows the encoding of the base case domain, which includes the pathway specification from (4.321) with initial setup conditions from the query statement (4.322) applied:\n% #const nts=1. time(0..nts).\nCHAPTER 4. THE BIOPATHQA SYSTEM 138\n% #const ntok=1. num(0..ntok).\n% place(bpg13). place(dhap). place(f16bp). place(g3p).\n% trans(src_f16bp_1). trans(t3). trans(t4). trans(t5a). trans(t5b). trans(t6).\n% tparc(src_f16bp_1,f16bp,1,TS) :- time(TS).\ntparc(t3,f16bp,1,TS) :- time(TS).\nptarc(f16bp,t4,1,TS) :- time(TS). tparc(t4,g3p,1,TS) :- time(TS). tparc(t4,dhap,1,TS) :- time(TS).\nptarc(dhap,t5a,1,TS) :- time(TS). tparc(t5a,g3p,1,TS) :- time(TS).\nptarc(g3p,t5b,1,TS) :- time(TS). tparc(t5b,dhap,1,TS) :- time(TS).\nptarc(g3p,t6,1,TS) :- time(TS). tparc(t6,bpg13,2,TS) :- time(TS).\n% holds(bpg13,0,0). holds(dhap,0,0). holds(f16bp,0,0). holds(g3p,0,0).\n%\n% could_not_have(T,TS) :- enabled(T,TS), not fires(T,TS), ptarc(P,T,Q,TS),\nholds(P,QQ,TS), tot_decr(P,QQQ,TS), Q > QQ - QQQ.\n:- not could_not_have(T,TS), time(TS), enabled(T,TS), not fires(T,TS), trans(T).\n%\nCHAPTER 4. THE BIOPATHQA SYSTEM 139\n% min(A,B,A) :- A<=B, num(A;B). min(A,B,B) :- B<=A, num(A;B). #hide min/3.\n% holdspos(P):- holds(P,N,0), place(P), num(N), N > 0. holds(P,0,0) :- place(P), not holdspos(P).\n% notenabled(T,TS) :- ptarc(P,T,N,TS), holds(P,Q,TS), Q < N, place(P), trans(T),\ntime(TS), num(N), num(Q).\n% enabled(T,TS) :- trans(T), time(TS), not notenabled(T, TS).\n% { fires(T,TS) } :- enabled(T,TS), trans(T), time(TS).\n% add(P,Q,T,TS) :- fires(T,TS), tparc(T,P,Q,TS), time(TS). del(P,Q,T,TS) :- fires(T,TS), ptarc(P,T,Q,TS), time(TS).\n% tot_incr(P,QQ,TS) :- QQ = #sum[add(P,Q,T,TS) = Q : num(Q) : trans(T)],\ntime(TS), num(QQ), place(P).\ntot_decr(P,QQ,TS) :- QQ = #sum[del(P,Q,T,TS) = Q : num(Q) : trans(T)],\ntime(TS), num(QQ), place(P).\n% holds(P,Q,TS+1) :- holds(P,Q1,TS), tot_incr(P,Q2,TS), tot_decr(P,Q3,TS),\nQ=Q1+Q2-Q3, place(P), num(Q;Q1;Q2;Q3), time(TS), time(TS+1).\n% % consumesmore(P,TS) :- holds(P,Q,TS), tot_decr(P,Q1,TS), Q1 > Q. consumesmore :- consumesmore(P,TS). :- consumesmore.\nThe following shows encoding of the alternate case domain, which consists of the pathway specification from (4.321) with initial setup conditions and interventions applied; and any internal observations from the query statement (4.322) added:\n% #const nts=1. time(0..nts).\n% #const ntok=1. num(0..ntok).\nCHAPTER 4. THE BIOPATHQA SYSTEM 140\n% place(bpg13). place(dhap). place(f16bp). place(g3p).\n% trans(reset_dhap_1). trans(src_f16bp_1). trans(t3). trans(t4). trans(t5a). trans(t5b). trans(t6).\n% ptarc(dhap,reset_dhap_1,Q,TS) :- holds(dhap,Q,TS), Q>0, time(TS). :- enabled(reset_dhap_1,TS), not fires(reset_dhap_1,TS), time(TS).\ntparc(src_f16bp_1,f16bp,1,TS) :- time(TS).\ntparc(t3,f16bp,1,TS) :- time(TS).\nptarc(f16bp,t4,1,TS) :- time(TS). tparc(t4,g3p,1,TS) :- time(TS). tparc(t4,dhap,1,TS) :- time(TS).\nptarc(dhap,t5a,1,TS) :- time(TS). tparc(t5a,g3p,1,TS) :- time(TS).\nptarc(g3p,t5b,1,TS) :- time(TS). tparc(t5b,dhap,1,TS) :- time(TS).\nptarc(g3p,t6,1,TS) :- time(TS). tparc(t6,bpg13,2,TS) :- time(TS).\n% holds(bpg13,0,0). holds(dhap,0,0). holds(f16bp,0,0). holds(g3p,0,0).\n%\n% could_not_have(T,TS) :- enabled(T,TS), not fires(T,TS), ptarc(P,T,Q,TS),\nholds(P,QQ,TS), tot_decr(P,QQQ,TS), Q > QQ - QQQ.\n:- not could_not_have(T,TS), time(TS), enabled(T,TS), not fires(T,TS), trans(T).\n%\nCHAPTER 4. THE BIOPATHQA SYSTEM 141\n% min(A,B,A) :- A<=B, num(A;B). min(A,B,B) :- B<=A, num(A;B). #hide min/3.\n% holdspos(P):- holds(P,N,0), place(P), num(N), N > 0. holds(P,0,0) :- place(P), not holdspos(P).\n% notenabled(T,TS) :- ptarc(P,T,N,TS), holds(P,Q,TS), Q < N, place(P), trans(T),\ntime(TS), num(N), num(Q).\n% enabled(T,TS) :- trans(T), time(TS), not notenabled(T, TS).\n% { fires(T,TS) } :- enabled(T,TS), trans(T), time(TS).\n% add(P,Q,T,TS) :- fires(T,TS), tparc(T,P,Q,TS), time(TS). del(P,Q,T,TS) :- fires(T,TS), ptarc(P,T,Q,TS), time(TS).\n% tot_incr(P,QQ,TS) :- QQ = #sum[add(P,Q,T,TS) = Q : num(Q) : trans(T)],\ntime(TS), num(QQ), place(P).\ntot_decr(P,QQ,TS) :- QQ = #sum[del(P,Q,T,TS) = Q : num(Q) : trans(T)],\ntime(TS), num(QQ), place(P).\n% holds(P,Q,TS+1) :- holds(P,Q1,TS), tot_incr(P,Q2,TS), tot_decr(P,Q3,TS),\nQ=Q1+Q2-Q3, place(P), num(Q;Q1;Q2;Q3), time(TS), time(TS+1).\n% % consumesmore(P,TS) :- holds(P,Q,TS), tot_decr(P,Q1,TS), Q1 > Q. consumesmore :- consumesmore(P,TS). :- consumesmore.\nBoth programs are simulated for 5 time-steps and 20 max tokens using the following Clingo command:\nclingo 0 -cntok=20 -cnts=5 program.lp\nAnswer sets of the base case are as follows:\nAnswer: 1 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2)\nCHAPTER 4. THE BIOPATHQA SYSTEM 142\nfires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t5a,2) fires(t5b,2) holds(bpg13,0,3) holds(dhap,2,3) holds(f16bp,4,3) holds(g3p,2,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t5a,3) fires(t5b,3) fires(t6,3) holds(bpg13,2,4) holds(dhap,3,4) holds(f16bp,5,4) holds(g3p,2,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t5a,4) fires(t5b,4) fires(t6,4) holds(bpg13,4,5) holds(dhap,4,5) holds(f16bp,6,5) holds(g3p,2,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t5a,5) fires(t5b,5) fires(t6,5) Answer: 2 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t5a,2) fires(t6,2) holds(bpg13,2,3) holds(dhap,1,3) holds(f16bp,4,3) holds(g3p,2,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t5a,3) fires(t5b,3) fires(t6,3) holds(bpg13,4,4) holds(dhap,2,4) holds(f16bp,5,4) holds(g3p,2,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t5a,4) fires(t5b,4) fires(t6,4) holds(bpg13,6,5) holds(dhap,3,5) holds(f16bp,6,5) holds(g3p,2,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t5a,5) fires(t5b,5) fires(t6,5)\nAnswer sets of the alternate case are as follows:\nAnswer: 1 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t6,2) holds(bpg13,2,3) holds(dhap,1,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t5b,3) holds(bpg13,2,4) holds(dhap,2,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t5b,4) holds(bpg13,2,5) holds(dhap,2,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t5b,5) Answer: 2 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t6,2) holds(bpg13,2,3) holds(dhap,1,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t5b,3) holds(bpg13,2,4) holds(dhap,2,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t5b,4) holds(bpg13,2,5) holds(dhap,2,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t6,5) Answer: 3 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0)\nCHAPTER 4. THE BIOPATHQA SYSTEM 143\nholds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t6,2) holds(bpg13,2,3) holds(dhap,1,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t5b,3) holds(bpg13,2,4) holds(dhap,2,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t6,4) holds(bpg13,4,5) holds(dhap,1,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t5b,5) Answer: 4 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t6,2) holds(bpg13,2,3) holds(dhap,1,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t5b,3) holds(bpg13,2,4) holds(dhap,2,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t6,4) holds(bpg13,4,5) holds(dhap,1,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t6,5) Answer: 5 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t5b,2) holds(bpg13,0,3) holds(dhap,2,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t5b,3) holds(bpg13,0,4) holds(dhap,2,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t5b,4) holds(bpg13,0,5) holds(dhap,2,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t5b,5) Answer: 6 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t5b,2) holds(bpg13,0,3) holds(dhap,2,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t5b,3) holds(bpg13,0,4) holds(dhap,2,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t5b,4) holds(bpg13,0,5) holds(dhap,2,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t6,5) Answer: 7 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0)\nCHAPTER 4. THE BIOPATHQA SYSTEM 144\nfires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t5b,2) holds(bpg13,0,3) holds(dhap,2,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t5b,3) holds(bpg13,0,4) holds(dhap,2,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t6,4) holds(bpg13,2,5) holds(dhap,1,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t5b,5) Answer: 8 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t5b,2) holds(bpg13,0,3) holds(dhap,2,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t5b,3) holds(bpg13,0,4) holds(dhap,2,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t6,4) holds(bpg13,2,5) holds(dhap,1,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t6,5) Answer: 9 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t5b,2) holds(bpg13,0,3) holds(dhap,2,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t6,3) holds(bpg13,2,4) holds(dhap,1,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t5b,4) holds(bpg13,2,5) holds(dhap,2,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t5b,5) Answer: 10 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t5b,2) holds(bpg13,0,3) holds(dhap,2,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t6,3) holds(bpg13,2,4) holds(dhap,1,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t5b,4) holds(bpg13,2,5) holds(dhap,2,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t6,5) Answer: 11\nCHAPTER 4. THE BIOPATHQA SYSTEM 145\nholds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t5b,2) holds(bpg13,0,3) holds(dhap,2,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t6,3) holds(bpg13,2,4) holds(dhap,1,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t6,4) holds(bpg13,4,5) holds(dhap,1,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t5b,5) Answer: 12 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t5b,2) holds(bpg13,0,3) holds(dhap,2,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t6,3) holds(bpg13,2,4) holds(dhap,1,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t6,4) holds(bpg13,4,5) holds(dhap,1,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t6,5) Answer: 13 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t6,2) holds(bpg13,2,3) holds(dhap,1,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t6,3) holds(bpg13,4,4) holds(dhap,1,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t5b,4) holds(bpg13,4,5) holds(dhap,2,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t6,5) Answer: 14 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t6,2) holds(bpg13,2,3) holds(dhap,1,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t6,3) holds(bpg13,4,4) holds(dhap,1,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t5b,4) holds(bpg13,4,5) holds(dhap,2,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t5b,5)\nCHAPTER 4. THE BIOPATHQA SYSTEM 146\nAnswer: 15 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t6,2) holds(bpg13,2,3) holds(dhap,1,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t6,3) holds(bpg13,4,4) holds(dhap,1,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t6,4) holds(bpg13,6,5) holds(dhap,1,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t5b,5) Answer: 16 holds(bpg13,0,0) holds(dhap,0,0) holds(f16bp,0,0) holds(g3p,0,0) fires(reset_dhap_1,0) fires(src_f16bp_1,0) fires(t3,0) holds(bpg13,0,1) holds(dhap,0,1) holds(f16bp,2,1) holds(g3p,0,1) fires(reset_dhap_1,1) fires(src_f16bp_1,1) fires(t3,1) fires(t4,1) holds(bpg13,0,2) holds(dhap,1,2) holds(f16bp,3,2) holds(g3p,1,2) fires(reset_dhap_1,2) fires(src_f16bp_1,2) fires(t3,2) fires(t4,2) fires(t6,2) holds(bpg13,2,3) holds(dhap,1,3) holds(f16bp,4,3) holds(g3p,1,3) fires(reset_dhap_1,3) fires(src_f16bp_1,3) fires(t3,3) fires(t4,3) fires(t6,3) holds(bpg13,4,4) holds(dhap,1,4) holds(f16bp,5,4) holds(g3p,1,4) fires(reset_dhap_1,4) fires(src_f16bp_1,4) fires(t3,4) fires(t4,4) fires(t6,4) holds(bpg13,6,5) holds(dhap,1,5) holds(f16bp,6,5) holds(g3p,1,5) fires(reset_dhap_1,5) fires(src_f16bp_1,5) fires(t3,5) fires(t4,5) fires(t6,5)\nAtoms selected for bpg13 quantity extraction for the nominal case:\n[holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,0,3),holds(bpg13,2,4),holds(bpg13,4,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,2,3),holds(bpg13,4,4),holds(bpg13,6,5)]\nAtoms selected for bpg13 quantity extraction for the modified case:\n[holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,2,3),holds(bpg13,2,4),holds(bpg13,2,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,2,3),holds(bpg13,2,4),holds(bpg13,2,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,2,3),holds(bpg13,2,4),holds(bpg13,4,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,2,3),holds(bpg13,2,4),holds(bpg13,4,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,0,3),holds(bpg13,0,4),holds(bpg13,0,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,0,3),holds(bpg13,0,4),holds(bpg13,0,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,0,3),holds(bpg13,0,4),holds(bpg13,2,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,0,3),holds(bpg13,0,4),holds(bpg13,2,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2),\nCHAPTER 4. THE BIOPATHQA SYSTEM 147\nholds(bpg13,0,3),holds(bpg13,2,4),holds(bpg13,2,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,0,3),holds(bpg13,2,4),holds(bpg13,2,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,0,3),holds(bpg13,2,4),holds(bpg13,4,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,0,3),holds(bpg13,2,4),holds(bpg13,4,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,2,3),holds(bpg13,4,4),holds(bpg13,4,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,2,3),holds(bpg13,4,4),holds(bpg13,4,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,2,3),holds(bpg13,4,4),holds(bpg13,6,5)], [holds(bpg13,0,0),holds(bpg13,0,1),holds(bpg13,0,2), holds(bpg13,2,3),holds(bpg13,4,4),holds(bpg13,6,5)]\nProgression from raw matrix of bpg13 quantities in various answer-sets (rows) at various simulation steps (columns) to rates and finally to the average aggregate for the nominal case:[\n0 0 0 0 2 4 0 0 0 2 4 6\n] = rate => [ 0.8 1.2 ] = average => 1.0\nProgression from raw matrix of bpg13 quantities in various answer-sets (rows) at various simulation steps (columns) to rates and finally to the average aggregate for the modified case: 0 0 0 2 2 2 0 0 0 2 2 2 0 0 0 2 2 4 0 0 0 2 2 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 2 2 0 0 0 0 2 2 0 0 0 0 2 4 0 0 0 0 2 4 0 0 0 2 4 4 0 0 0 2 4 4 0 0 0 2 4 6 0 0 0 2 4 6  = rate =>  0.4 0.4 0.8 0.8 0. 0. 0.4 0.4 0.4 0.4 0.8 0.8 0.8 0.8 1.2 1.2  = average => 0.6\nWe find that d =′<′ comparing the modified case rate of 0.6 to the nominal case rate of 1.0. Since the direction d was an unknown in the query statement, our system generates produces the full query specification with d replaced by ′ <′ as follows:\ndirection of change in average rate of production of ’bpg13’ is ’<’ (0.6<1)\nwhen observed between time step 0 and time step 5 comparing nominal pathway with modified pathway obtained; due to interventions:\nremove ’dhap’ as soon as produced;\nCHAPTER 4. THE BIOPATHQA SYSTEM 148\nusing initial setup:\ncontinuously supply ’f16bp’ in quantity 1;\n4.6.11 Evaluation Methodolgy\nA direct comparison against other tools is not possible, since most other programs explore one state evolution, while we explore all possible state evolutions. In addition ASP has to ground the program completely, irrespective of whether we are computing one answer or all. So, to evaluate our system, we compare our results for the questions from the 2nd Deep KR Challenge against the answers they have provided. Our results in essence match the responses given for the questions.\n4.7 Related Work\nIn this section, we relate our high level language with other high level action languages.\n4.7.1 Comparison with π-Calculus\nπ-calculus is a formalism that is used to model biological systems and pathways by modeling biological systems as mobile communication systems. We use the biological model described by Regev (2001) for comparison against our system. In their model they represent molecules and their domains as computational processes, interacting elements of molecules as communication channels (two molecules interact if they fit together as in a lock-and-key mechanism), and reactions as communication through channel transmission.\n• π-calculus models have the ability of changing their structure during simulation. Our system on the other hand only allows modification of the pathway at the start of simulation.\n• Regular π-calculus models appear qualitative in nature. However, stochastic extensions allow representation of quantitative data Priami et al. (2001). In contrast, the focus of our system is on the quantitative+qualitative representation using numeric fluents.\n• It is unclear how one can easily implement maximal-parallelism of our system in πcalculus, where a maximum number of simultaneous actions occur such that they do not cause a conflict. Where, a set of actions is said to be in conflict if their simultaneous execution will cause a fluent to become negative.\n4.7.2 Comparison with Action LanguageA Action language A Gelfond and Lifschitz (1993) is a formalism that has been used to model biological systems and pathways. First we give a brief overview of A in an intuitive manner. Assume two sets of disjoint symbols containing fluent names and action names, then a fluent expression is either a fluent name F or ¬F. A domain description is composed of propositions of the following form:\nCHAPTER 4. THE BIOPATHQA SYSTEM 149\nvalue proposition: F after A1; . . . ; Am, where (m ≥ 0), F is a fluent and A1, . . . , Am are fluents.\neffect propostion: A causes F if P1, . . . , Pn, where (n ≥ 0), A is an action, F, P1, . . . , Pn are fluent expressions. P1, . . . , Pn are called preconditions of A and the effect proposition describes the effect on F.\nWe relate it to our work:\n• Fluents are boolean. We support numeric valued fluents, with binary fluents.\n• Fluents are non-inertial, but inertia can be added. Our fluents are always intertial.\n• Action description specifies the effect of an action. Our domain description specifies ‘natural’-actions, which execute automatically when their pre-conditions are satisfied, subject to certain conditions. As a result our domain description represents trajectories.\n• No built in support for aggregates exists. We support a selected set of aggregates, on a single trajectory and over multiple trajectories.\n• Value propositions inA are representable as observations in our query language.\n4.7.3 Comparison with Action Language B Action language B extendsA by adding static causal laws, which allows one to specify indirect effects or ramifications of an action Gelfond and Lifschitz (2012). We relate it to our work below:\n• Inertia is built into the semantics of B Gelfond and Lifschitz (2012). Our language also has intertia built in.\n• B supports static causal laws that allow defining a fluent in terms of other fluents. We do not support static causal laws.\n4.7.4 Comparison with Action Language C Action language C is based on the theory of causal explanation, i.e. a formula is true if there is a cause for it to be true Giunchiglia and Lifschitz (1998). It has been previously used to represent and reason about biological pathways Dworschak et al. (2008). We relate it to our work below:\n• C supports boolean fluents only. We support numeric valued fluents, and binary fluents.\n• C allows both inertial and non-inertial fluents. While our fluents are always inertial.\n• C support static causal laws (or ramifications), that allow defining a fluent in terms of other fluents. We do not support them.\n• C describes causal relationships between fluents and actions. Our language on the other hand describes trajectories.\nCHAPTER 4. THE BIOPATHQA SYSTEM 150\n4.7.5 Comparison with Action Language C+ First, we give a brief overview of C+ Giunchiglia et al. (2004). Intuitively, atoms C+ are of the form c = v, where c is either a fluent or an action constant, v belongs to the domain of c, and fluents and actions form a disjoint set. A formula is a propositional combination of atoms. A fluent formula is a formula in which all constants are fluent constants; and an action formula is a formula with one action constant but no fluent constants. An action description in C+ is composed of causal laws of the following forms:\nstatic law: caused F if G, where F and G are fluent formulas\naction dynamic law: caused F if G, where F is an action formula and G is a formula\nfluent dynamic law: caused F if G after H, where F and G are fluent formulas and H is a formula\nConcise forms of these laws exist, e.g. ‘intertial f ≡ caused f = v if f = v after f = v,∀v ∈ domain of f ’ that allow a more intuitive program declaration.\nWe now relate it to our work.\n• Some of the main differences include:\n– Fluents are multi-valued, fluent values can be integer, boolean or other types. We support integer and binary valued fluents only.\n– Actions are multi-valued. We do not support multi-valued actions. – Both inertial and non-inertial fluents are supported. In comparison we allow inertial\nfluents only.\n– Static causal laws are supported that allow changing the value of a fluent based on other fluents (ramifications). We do not allow static causal laws.\n– Effect of parallel actions on numeric fluents is not additive. However, the additive fluents extension Lee and Lifschitz (2003) adds the capability of additive fluents through new rules. The extended language, however, imposes certain restrictions on additive fluents and also restricts the domain of additive actions to boolean actions only. Our fluents are always additive.\n– Supports defaults. We do not have the same notion as defaults, but allow initial values for fluents in our domain description.\n– Action’s occurrence and its effect are defined in separate statements. In our case, the action’s occurrence and effect are generally combined in one statement.\n• Although parallel actions are supported, it is unclear how one can concisely describe the condition implicit in our system that simultaneously occurring actions may not conflict. Two actions conflict if their simultaneous execution will cause a fluent to become negative.\nCHAPTER 4. THE BIOPATHQA SYSTEM 151\n• Exogenous actions seem the closest match to our may execute actions. However, our actions are ‘natural’, in that they execute automatically when their pre-conditions are satisfied, they are not explicitly inhibited, and they do not conflict. Actions conflict when their simultaneous execution will cause one of the fluents to become negative. The exogenousstyle character of our actions holds when the firing style is ‘∗’. When the firing style changes, the execution semantics change as well. Consider the following two may execute statements in our language:\na1 may execute causing f1 change value by − 5 if f2 has value 3 or higher a2 may execute causing f1 change value by − 3 if f2 has value 2 or higher\nand two states: (i) f1 = 10, f2 = 5, (ii) f1 = 6, f2 = 5. In state (i) both a1, a2 can occur simultaneously (at one point) resulting in firing-choices {{a1, a2}, {a1}, {a2}, {}, }; whereas, in state (ii) only one of a1 or a2 can occur at one point resulting in the firing-choices:{{a1}, {a2}, {}, } because of a conflict due to the limited amount of f1. These firing choices apply for firing style ‘*’, which allows any combination of fireable actions to occur. If the firing style is set to ‘max’, the maximum set of non-conflicting actions may fire, and the firing choices for state (i) change to\n{{a1, a2}} and the firing choices for state (ii) change to\n{{a1}, {a2}}. If the firing style is set to ‘1’, at most one action may fire at one point, and the firing choices for both state (i) and state (ii) reduce to\n{{a1}, {a2}, {}}. So, the case with ‘*’ firing style can be represented in C+ with exogenous actions a1, a2; the case with ‘1’ firing style can be represented in C+ with exogenous actions a1, a2 and a constraint requiring that both a1, a2 do not occur simultaneously; while the case with ‘max’ firing style can be represented by exogenous actions a1, a2 with additional action dynamic laws. They will still be subject to the conflict checking. Action dynamic laws can be used to force actions similar to our must execute actions.\n• Specification of initial values of fluents seem possible through the query language. The default statement comes close, but it does not have the same notion as setting a fluent to a value once. We support specifying initial values both in the domain description as well as the query.\n• There does not appear built-in support for aggregation of fluent values within the same answer set, such as sum, count, rate, minimum, maximum etc. Although some of it could be implemented using the additive fluents extension. We support a set of aggregates, such as total, and rate. Additional aggregates can be easily added.\n• We support queries over aggregates (such as minimum, maximum, average) of singletrajectory aggregates (such as total, and rate etc.) over a set of trajectories. We also support comparative queries over two sets of trajectories. Our queries allow modification of the domain description as part of query evaluation.\n4.7.6 Comparison with BC Action language BC combines features of B and C+ Lee et al. (2013). First we give a brief overview of BC.\nCHAPTER 4. THE BIOPATHQA SYSTEM 152\nIntuitively, BC has actions and valued fluents. A valued fluent, called an atom, is of the form ‘ f = v’, where f is a fluent constant and v ∈ domain( f ). A fluent can be regular or statically determined. An action description in BC is composed of static and dynamic laws of the following form:\nstatic law: A0 if A1, . . . , Am ifcons Am+1, . . . , An, where (n ≥ m ≥ 0), and each Ai is an atom.\ndynamic law: A0 after A1, . . . , Am ifcons Am+1, . . . , An, where (n ≥ m ≥ 0), A0 is a regular fluent atom, each of A1, . . . , Am is an atom or an action constant, and Am+1, . . . , An are atoms.\nConcise forms of these laws exist that allow a more intuitive program declaration. Now we relate it to our work.\n• Some of the main differences include:\n– Fluents are multi-valued, fluent values can which can be integer, boolean, or other types. We only support integer and binary fluents.\n– Static causal laws are allowed. We do not support static causal laws. – Similar to C+ numeric fluent accumulation is not supported. It is supported in our\nsystem.\n– It is unclear how aggregate queries within a trajectory can be concisely represented. Aggregate queries such as rate are supported in our system.\n– It does not seem that queries over multiple trajectories or sets of trajectories are supported. Such queries are supported in our system.\n4.7.7 Comparison with ASPMT\nASPMT combines ASP with Satisfiability Modulo Theories. We relate the work in Lee and Meng (2013) where C+ is extended using ASPMT with our work.\n• It adds support for real valued fluents to C+ including additive fluents. Thus, it allows reasoning with continuous and discrete processes simultaneously. Our language does not support real numbers directly.\nSeveral systems also exist to model and reason with biological pathway. For example:\n4.7.8 Comparison with BioSigNet-RR\nBioSigNet-RR Baral et al. (2004) is a system for representing and reasoning with signaling networks. We relate it to our work in an intuitive manner.\n• Fluents are boolean, so qualitative queries are possible. We support both integer and binary fluents, so quantiative queries are also possible.\nCHAPTER 4. THE BIOPATHQA SYSTEM 153\n• Indirect effects (or ramifications) are supported. We do not support these.\n• Action effects are captured separately in ‘ causes statement’ from action triggering statements ‘ triggers ’ and ‘ n triggers ’. We capture both components in a ‘ may execute causing ’ or ‘ normally must execute causing ’ statement.\n• Their action triggering semantics have some similarity to our actions. Just like their actions get triggered when the action’s pre-conditions are satisfied, our actions are also triggered when their pre-conditions are satisfied. However, the triggering semantics are different, e.g. their triggers statement causes an action to occur even if it is disabled, we do not have an equivalent for it; and their n triggers is similar in semantics to normally must execute causing statement.\n• It is not clear how loops in biological systems can be modeled in their system. Loops are possible in our by virtue of the Petri Net semantics.\n• Their queries can have time-points and their precedence relations as part of the query. Though our queries allow the specification of some time points for interval queries, timepoints are not supported in a similar way. However, we do support certain types of observation relative queries.\n• The intervention in their planning queries has similarities to interventions in our system. However, it appears that our intervention descriptions are higher level.\n4.8 Conclusion\nIn this chapter we presented the BioPathQA system and the languages to represent and query biological pathways. We also presented a new type of Petri Net, the so called Guarded-Arc Petri Net that is used as a model behind our pathway specification language, which shares certain aspects with CPNs Jensen et al. (2007), but our semantics for reset arcs is different, and we allow must-fire actions that prioritize actions for firing over other actions. We also showed how the system can be applied to questions from college level text books that require deeper reasoning and cannot be answered by using surface level knowledge. Although our system is developed with respect to the biological domain, it can be applied to non-biological domain as well.\nSome of the features of our language include: natural-actions that automatically fire when their prerequisite conditions are met (subject to certain restrictions); an automatic default constraint that ensures fluents do not go negative, since they model natural systems substances; a more natural representation of locations; and control of the level of parallelism to a certain degree. Our query language also allows interventions similar to Pearl’s surgeries Pearl (1995), which are more general than actions.\nNext we want to apply BioPathQA to a real world application by doing text extraction. Knowledge for real world is extracted from research papers. In the next chapter we show how\nCHAPTER 4. THE BIOPATHQA SYSTEM 154\nsuch text extraction is done for pathway construction and drug development. We will then show how we can apply BioPathQA to the extracted knowledge to answer questions about the extracted knowledge.\nChapter 5\nText Extraction for Real World Applications\nIn the previous chapter we looked at the BioPathQA system and how it answers simulation based reasoning questions about biological pathways, including questions that require comparison of alternate scenarios through simulation. These so called ‘what-if’ questions arise in biological activities such as drug development, drug interaction, and personalized medicine. We will now put our system and language in context of such activities.\nCutting-edge knowledge about pathways for activities such as drug development, drug interaction, and personalized medicine comes in the form of natural language research papers, thousands of which are published each year. To use this knowledge with our system, we need to perform extraction. In this chapter we describe techniques we use for such knowledge extraction for discovering drug interactions. We illustrate with an example extraction how we organize the extracted knowledge into a pathway specification and give examples of relevant what-if questions that a researcher performing may ask in the drug development domain.\n5.1 Introduction\nThousands of research papers are published each year about biological systems and pathways over a broad spectrum of activities, including interactions between dugs and diseases, the associated pathways, and genetic variation. Thus, one has to perform text extraction to extract relationships between the biochemical processes, their involvement in diseases, and their interaction with drugs. For personalized medicine, one is also interested in how these interrelationships change in presence of genetic variation. In short, we are looking for relationships between various components of the biochemical processes and their internal and external stimuli.\nMany approaches exist for extracting relationships from a document. Most rely on some form of co-occurrence, relative distance, or order of words in a single document. Some use shallow parsing as well. Although these techniques tend to have a higher recall, they focus on extracting explicit relationships, which are relationships that are fully captured in a sentence\n155\nCHAPTER 5. TEXT EXTRACTION FOR REAL WORLD APPLICATIONS 156\nor a document. These techniques also do not capture implicit relationships that may be spread across multiple documents. are spread across multiple documents relating to different species. Additional issues arise from the level of detail from in older vs. newer texts and seemingly contradictory information due to various levels of confidence in the techniques used. Many do not handle negative statements.\nWe primarily use a system called PTQL Tari et al. (2012) to extract these relationships, which allows combining the syntactic structure (parse tree), semantic elements, and word order in a relationship query. The sentences are pre-processed by using named-entity recognition, and entity normalization to allow querying on classes of entity types, such as drugs, and diseases; and also to allow cross-linking relationships across documents when they refer to the same entity with a different name. Queries that use such semantic association between words/phrases are likely to produce higher precision results.\nSource knowledge for extraction primarily comes from thousands of biological abstracts published each year in PubMed 1.\nNext we briefly describe how we extract relationships about drug interactions. Following that we briefly describe how we extract association of drugs, and diseases with genetic variation. We conclude this chapter with an illustrative example of how the drug interaction relationships are used with our system to answer questions about drug interactions and how genetic variation could be utilized in our system.\n5.2 Extracting Relationships about Drug Interactions\nWe summarize the extraction of relationships for our work on drug-drug interactions from Tari et al. (2010b).\nStudying drug-drug interactions are a major activity in drug development. Drug interactions occur due to the interactions between the biological processes / pathways that are responsible metabolizing and transporting drugs. Metabolic processes remove a drug from the system within a certain time period. For a drug to remain effective, it must be maintained within its therapeutic window for the period of treatment, requiring taking the drug periodically. Outside the therapeutic window, a drug can become toxic if a quantity greater than the therapeutic window is retained; or it can become ineffective if a quantity less than the therapeutic window is retained.\nSince liver enzymes metabolize most drugs, it is the location where most metabolic-interaction takes place. Induction or inhibition of these enzymes can affect the bioavailability of a drug through transcriptional regulation, either directly or indirectly. For example, if drug A inhibits enzyme E, which metabolizes drug B, then the bioavailability of drug B will be higher than normal, rendering it toxic. On the other hand, if drug A induces enzyme E, which metabolizes drug B, then drug B’s bioavailability will be lesser than normal, rendering it ineffective.\nInhibition of enzymes is a common form of drug-drug interactions Boobis (2009). In direct inhibition, a drug A inhibit enzyme E, which is responsible for metabolism of drug B. Drug A, leads to a decrease in the level of enzyme E, which in turn can increase bioavailability of\n1http://www.ncbi.nlm.nih.gov/pubmed\nCHAPTER 5. TEXT EXTRACTION FOR REAL WORLD APPLICATIONS 157\ndrug B potentially leading to toxicity. Alternatively, insufficient metabolism of drug B can lead to smaller amount of drug B’s metabolites being produced, leading to therapeutic failure. An example of one such direct inhibition is the interaction between CYP2D6 inhibitor quinidine and CYP2D6 substrates (i.e. substances metabolized by CYP2D6), such as Codeine. The inhibition of CYP2D6 increases the bioavailability of drugs metabolized by CYP2D6 leading to adverse side effects.\nAnother form of drug interactions is through induction of enzymes Boobis (2009). In direct induction, a drug A induces enzyme E, which is responsible for metabolism of drug B. An example of such direct induction is between phenobarbital, a CYP2C9 inducer and warfarin (a CYP2C9 substrate). Phenobarbital leads to increased metabolism of warfarin, decreasing warfarins bioavailability. Direct interaction due to induction though possible is not as common as indirect interaction through transcription factors, which regulate the drug metabolizing enzymes. In such an interaction, drug A activates a transcription factor T F, which regulates and induces enzyme E, where enzyme E metabolizes drug B. Transcription factors are referred to as regulators of xenobiotic-metabolizing enzymes. Examples of such regulators include aryl hydrocarbon receptor AhR, pregnane X receptor PXR and constitutive androstane receptor CAR.\nDrug interactions can also occur due to the induction or inhibition of transporters. Transporters are mainly responsible for cellular uptake or efflux (elimination) of drugs. They play an important part in drug disposition, by transporting drugs into the liver cells, for example. Transporter-based drug interactions, however, are not as well studies as metabolism-based interactions Boobis (2009).\n5.2.1 Method\nExtraction of drug-drug interactions from the text can either be explicit or implicit. Explicit extraction refers to extraction of drug-drug interaction mentioned within a single sentence, while implicit extraction requires extraction of bio-properties of drug transport, metabolism and elimination that can lead to drug-drug interaction. This type of indirect extraction combines background information about biological processes, identification of protein families and the interactions that are involved in drug metabolism. Our approach is to extract both explicit and implicit drug interactions as summarized in Fig 5.1 and it builds upon the work done in Tari et al. (2009).\nExplicit Drug Interaction Extraction\nExplicit extraction mainly extracts drug-drug interactions directly mentioned in PubMed (or Medline) abstracts. For example, the following sentences each have a metabolic interaction mentioned within the same sentence:\nS1: Ciprofloxacin strongly inhibits clozapine metabolism. (PMID: 19067475)\nS2: Enantioselective induction of cyclophosphamide metabolism by phenytoin.\nwhich can be extracted by using the following PTQL query using the underlined keywords from above sentences:\nCHAPTER 5. TEXT EXTRACTION FOR REAL WORLD APPLICATIONS 158\n//S{//?[Tag=‘Drug’](d1) =>\n//?[Value IN {‘induce’,‘induces’,‘inhibit’,‘inhibits’}](v) => //?[Tag=‘Drug’](d2) => //?[Value=‘metabolism’](w)} ::: [d1 v d2 w] 5 : d1.value, v.value, d2.value.\nThis PTQL query specifies that a drug (denoted by d1) must be followed by one of the keywords from {‘induce′, ‘inhibit′, ‘inhibits′} (denoted by v), which in turn must be followed by another drug (denoted by d2) followed the keyword ‘metabolism′ (denoted by w); all found within a proximity of 5 words of each other. The query produces tripes of 〈d1, v, d2〉 values as output. Thus the results will produce triples 〈d1, induces, d2〉 and 〈d1, inhibits, d2〉 which mean that the drug d1 increases the effect of d2 (i.e. 〈d1, increases, d2〉) and decreases the effect of d2 (i.e. 〈d1, decreases, d2〉) respectively. For example, the sentence S1 above matches this PTQL query and the query will produce the triplet 〈ciprofloxacin, increases, clozapine〉.\nImplicit Drug Interaction Extraction\nImplicit extraction mainly extracts drug-drug interactions not yet published, but which can be inferred from published articles and properties of drug metabolism. The metabolic properties themselves have their origin in various publications. The metabolic interactions extracted from published articles and the background knowledge of properties of drug metabolism are reasoned with in an automated fashion to infer drug interactions. The following table outlines the kinds of interactions extracted from the text:\nwhich require multiple PTQL queries for extraction. As an example, the following PTQL query is used to extract 〈protein,metabolizes, drug〉 triplets:\n//S{/?[Tag=‘Drug’](d1) =>\n//VP{//?[Value IN {‘metabolized’,‘metabolised’}](rel) => //?[Tag=‘GENE’](g1)}} ::: g1.value, rel.value, d1.value\nwhich specifies that the extracted triplets must have a drug (denoted by d1) followed by a verb phrase (denoted by VP) with the verb in {‘metabolized′, ‘metabolised′}, followed by a gene (denoted by g1). Table 5.2 shows examples of extracted triplets.\nData Cleaning\nThe protein-protein and protein-drug relationships extracted from the parse tree database need an extra step of refinement to ensure that they correspond to the known properties of drug metabolism. For instance, for a protein to metabolize a drug, the protein must be an enzyme. Similarly, for a protein to regulate an enzyme, the protein must be a transcription factor. Thus, the 〈protein,metabolizes, drug〉 facts get refined to 〈enzyme,metabolizes, drug〉 and 〈protein, regulates, protein〉 gets refined to 〈transcription f actor, regulates, enzyme〉 respectively. Classification of proteins is done using UniProt, the Gene Ontology (GO) and Entrez Gene summary by applying rules such as:\n• A protein p is an enzyme if it belongs to a known enzyme family, such as CYP, UGT or SULT gene families; or is annotated under UniProt with the hydrolase, ligase, lyase or transferase keywords; or is listed under the “metabolic process” GO-term; or its Entrez Gene summary mentions key phrases like “drug metabolism” or roots for “enzyme” or “catalyzes”.\n• A protein p is considered as a transcription factor if it is annotated with keywords transcription, transcription-regulator or activator under UniProt; or it is listed under the “transcription factor activity” category in GO; or its Entrez Gene summary contains the phrase “transcription factor”.\nAdditional rules are applied to remove conflicting information, such as, favoring negative extractions (such as ‘P does not metabolize D’) over positive extractions (such as ‘P metabolizes D’). For details, see Tari et al. (2010b).\n5.2.2 Results\nThe correctness of extracted interactions was determined by manually compiling a gold standard for each type of interaction using co-occurrence queries. For example, for 〈protein,metabolizes, drug〉 relations, we examined sentences that contain co-occurrence of protein, drug and one of the keywords “metabolized”, “metabolize”, “metabolises”, “metabolise”, “substrate” etc. Table 5.3 summarizes the performance of our extraction approach.\n5.3 Extracting Knowledge About Genetic Variants\nWe summarize the relevant portion of our work on associating genetic variants with drugs, diseases and adverse reactions as presented in Hakenberg et al. (2012).\nIncorrect drug dosage is the leading cause of adverse drug reactions. Doctors prescribe the same amount of medicine to a patient for most drugs using the average drug response, even though a particular person’s drug response may be higher or lower than the average case. A large part of the difference in drug response can be attributed to single nucleotide polymorphisms (SNPs). For example, the enzyme CYP2D6 has 70 known allelic variations, 50 of which are non-functional H et al. (2002). Patients with poor metabolizer variations may retain higher concentration of drug for typical dosage, while patients with rapid metabolizers may not even reach therapeutic level of drug or toxic level of drug metabolites SF (2009). Thus, it is important to consider the individual’s genetic composition for dosage determination, especially for narrow therapeutic index drugs.\nScientists studying these variations have grouped metabolizers into categories of poor (PM), intermediate (IM), rapid (RM) and ultra-rapid metabolizers (UM) and found that for some drugs, only 20% of usual dosage was required for PM and up to 140% for UM J et al. (2001). Information about SNPs, their frequency in various population groups, their effect on genes (enzymic activity) and related data is stored in research papers, clinical studies and surveys. However, it is spread-out among them. Various databases collect this information in different forms. PharmGKB collects information such information and how it related to drug response Thorn et al.\nCHAPTER 5. TEXT EXTRACTION FOR REAL WORLD APPLICATIONS 161\n(2010). However, it is a small percentage of the total number of articles on PharmGKB, due to time consuming manual curation of data.\nOur work focuses on automatically extracting genetic variations and their impact on drug responses from PubMed abstracts to catch up with the current state of research in the biological domain, producing a repository of knowledge to assist in personalized medicine. Our approach leverages on as many existing tools as possible.\n5.3.1 Methods\nNext, we describe the methods used in our extraction, including: named entity recognition, entity normalization, and relation extraction.\nNamed Entity Recognition\nWe want to identify entities including genes (also proteins and enzymes), drugs, diseases, ADRs (adverse drug reactions), SNPs, RefSNPs (rs-numbers), names of alleles, populations and frequencies.\nFor genes, we use BANNER Leaman et al. (2008) trained on BioCreative II GM training set Krallinger et al. (2008). For genotypes (genetic variations including SNPs) we used a combination of MutationFinder Caporaso et al. (2007) and custom components. Custom components were targeted mostly on non-SNPs (“c.76 78delACT”, 11MV324KF”) and insertions/deletions (“1707 del T”, “c.76 77insG”), RefSNPs (rs-numbers) and names of alleles/haplotypes (“CYP2D6*4”, “T allele”, “null allele”).\nFor diseases (and ADRs), we used BANNER trained on a corpus of 3000 sentences with disease annotations Leaman et al. (2009). An additional 200 random sentences containing no disease were added from BioCreative II GM data to offset the low percentage (10%) of sentences without disease in the 3000 sentence corpus. In addition to BANNER, we used a dictionary extracted from UMLS. This dictionary consisted of 162k terms for 54k concepts from the six categories “Disease or Syndrome”, ”Neoplastic Process”,“Congenital Abnormality”,“Mental or Behavioral Dysfunction”,“Experimental Model of Disease” and “Acquired Abnormality”. The list was filtered to remove unspecific as well as spurious disease names such as “symptoms”, “disorder”, . . . . A dictionary for adverse drug reactions originated from SIDER Side Effect Resource Kuhn et al. (2010), which provides a mapping of ADR terminology to UMLS CUIs. It consisted of 1.6k UMLS concepts with 6.5k terms.\nFor drugs, we used a dictionary based on DrugBankWishart et al. (2006) containing about 29k different drug names including both generic as well as brand names. We used the crosslinking information from DrugBank to collect additional synonyms and IDs from PharmGKB. We cross linked to Compound and Substance IDs from PubChem to provide hyperlinks to additional information.\nFor population, we collected a dictionary of terms referring to countries, regions, regions inhabitants and their ethnicities from WikiPedia, e.g. “Caucasian”, “Italian”, “North African”, . . . . We filtered out irrelevant phrases like “Chinese [hamster]”.\nCHAPTER 5. TEXT EXTRACTION FOR REAL WORLD APPLICATIONS 162\nFor frequencies, we extract all numbers and percentages as well as ranges from sentences that contain the word “allele”, “variant”, “mutation”, or “population”. The output is filtered in this case as well to remove false positives referring to p-values, odd ratios, confidence intervals and common trigger words.\nEntity Normalization\nGenes, diseases and drugs can appear with many different names in the text. For example, “CYP2D6” can appear as “Cytochrome p450 2D6” or “P450 IID6” among others, but they all refer to the same enzyme (EntrezGene ID 1565). We use GNAT on recognized genes Hakenberg et al. (2008), but limit them to human, mouse and rat genes. The gene name recognized by BANNER is filtered by GNAT to remove non-useful modifiers and looked up against EntrezGene restricted to human, mouse and rat genes to find candidate IDs for each gene name. Ambiguity (multiple matches) is resolved by matching the text surrounding the gene mention with gene’s annotation from a set of resources, like EntrezGene, UniProt.\nDrugs and diseases/ADRs are resolved to their official IDs from DrugBank or UMLS. If none is found, we choose an ID for it based on its name. Genetic variants\nGenetic variations are converted to HGVScite den Dunnen and Antonarakis (200) recommended format. Alleles were converted to the star notation (e.g. “CYP2D6*1”) and the genotype (“TT allele”) or fixed terms such as “null allele” and “variant allele”.\nPopulations mentions are mapped to controlled vocabulary to remove orthographic and lexical variations.\nRelation Extraction\nTwelve type of relations were extracted between the detected entities as given in Table 5.4. Different methods were applied to detect different relations depending upon relation type, sentence structure and whether another method was able to extraction a relation beforehand. Gene-drug, gene-disease, drug-disease were extracted using sentence based co-occurrence (possibly refined by using relation-specific keywords) due to its good precision yield of this method for these relations. For other relations additional extraction methods were implemented. These include:\nHigh-confidence co-occurrence that includes keywords These co-occurences have the relation keyword in them. This method is applied to gene-drug, gene-disease, drug-ADR, drug-disease and mutation-disease associations. It uses keywords from PolySearch Wishart et al. (2008) as well as our own.\nCo-occurrence without keywords Such co-occurrences do not require any relationship keyword. This method is used for allele-population and variant-population relationships. This method can misidentify negative relationships. High-confidence relationships, if not found with a keyword drop down to this method for a lower confidence result.\n1:n co-occurrence Relationships where one entity has one instance in a given sentence and the other occurs one or more times. Single instance entity may have more than one occur-\nrence. This method is useful in identifying gene mutations, where a gene is mentioned in a sentence along with a number of its mutations. The gene itself may be repeated.\nEnumerations with matching counts Captures entities in sentences where a list of entities is followed by an equal number of counts. This method is useful in capturing alleles and their associated frequencies, e.g. “The frequencies of CYP1B1*1, *2, *3, and *4 alleles were 0.087, 0.293, 0.444, and 0.175, respectively.”\nLeast common ancestor (LCA) sub-tree Assigns associations based on distance in parse tree. We used Stanford parser Klein and Manning (2003) to get grammatical structure of a sentence as a dependency tree. This allows relating verb to its subject and noun to its modifiers. This method picks the closest pair in the lowest common ancestors (dependency) sub-tree of the entities. Maximum distance in terms of edges connecting the entity nodes was set to 10, which was determined empirically to provide the best balance between precision and recall. This method associates frequencies with alleles in the sentence “The allele frequencies were 18.3% (-24T) and 21.2% (1249A)”.\nm:n co-occurrence This method builds associations between all pairs of entities.\nLow confidence co-occurrence This acts as the catch-all case if none of the above methods work.\nThese methods were applied in order to each sentence, stoping at the first method that extracted the desired relationship. Order of these methods was determined empirically based of their precision. The order of the method used determines our confidence in the result. If none of the higher confidence methods are successful, a co-occurrence based method is used for extraction with low confidence.\nCHAPTER 5. TEXT EXTRACTION FOR REAL WORLD APPLICATIONS 164\nAbstract-level co-occurrence are also extracted to provide hits on potential relations. They appear in the database only when they appear in more than a pre-set threshold number of abstracts.\n5.3.2 Results\nPerformance was evaluated by evaluating the precision and recall of individual components and coverage of existing results. Precision and recall were tested by processing 3500 PubMed abstracts found via PharmGKB relations and manually checking the 2500 predictions. Coverage was tested against DrugBank and PharmGKB. Extracted relations went through manual evaluation for correctness. Each extraction was also assigned a confidence value based on the confidence in the method of extraction used. We got a coverage of 91% of data in DrugBank and 94% in PharmGKB. Taking into false positive rates for genes, drugs and gene-drug relations, SNPshot has more than 10,000 new relations.\n5.4 Applying BioPathQA to Drug-Drug Interaction Discovery\nNow we use our BioPathQA system from chapter 4 to answer questions about drug-drug interaction using knowledge extracted from research publications using the approach in sections 5.2,5.3. We supplement the extracted knowledge with domain knowledge as needed.\nLet the extracted facts be as follows:\n• The drug ge f itinib is metabolized by CYP3A4.\n• The drug phenytoin induces CYP3A4.\nFollowing additional facts have been provided about a new drug currently in development:\n• A new drug being developed test drug is a CYP3A4 inhibitor\nWe show the pathway specification based on the above facts and background knowledge, then elaborate on each component:\ndomain of ge f itinib is integer, cyp3a4 is integer, phenytoin is integer, test drug is integer (5.1)\nt1 may execute causing ge f itinib change value by − 1, cyp3a4 change value by − 1, cyp3a4 change value by + 1 (5.2)\nnormally stimulate t1 by factor 2 if phenytoin has value 1 or higher (5.3)\ninhibit t1 if test drug has value 1 or higher (5.4) initially ge f itinib has value 20, cyp3a4 has value 60,\nCHAPTER 5. TEXT EXTRACTION FOR REAL WORLD APPLICATIONS 165\nphenytoin has value 0, test drug has value 0 (5.5) firing style max (5.6)\nLine 5.1 declares the domain of the fluents as integer numbers. Line 5.2 represents the activity of enzyme cyp3a4 as the action t1. Due to the enzymic action t1, one unit of ge f itinib is metabolized, and thus converted to various metabolites (not shown here). The enzymic action uses one unit of cyp3a4 as catalyst, which is used in the reaction and released afterwards. Line 5.3 represents the knowledge that phenytoin induces the activity of cyp3a4. From background knowledge we find out that the stimulation in the activity can be as high as 2-times Luo et al. (2002). Line 5.4 represents the knowledge that there is a new drug test drug being tested that is known to inhibit the activity of cyp3a4. Line 5.5 specifies the initial distribution of the drugs and enzymes in the pathway. Assuming the patient has been given some fixed dose, say 20 units, of the medicine ge f itinib. It also specifies there is a large 60 units quantity of cyp3a4 available to ensure reactions do not slow down due to unavailability of enzyme availability. Additionaly, the drug phenytoin is absent from the system and a new drug test drug to be tested is not in the system either. This gives us our pathway specification. Now we consider two application scenarios for drug development.\n5.4.1 Drug Administration\nA patient is taking 20 units of ge f itinib, and is being prescribed additional drugs to be coadministered. The drug administrator wants to know if there will be an interaction with ge f itinib if 5 units of phenytoin are co-administered. If there is an interaction, what will be the bioavailability of ge f itinib so that its dosage could be appropriately adjusted.\nThe first question is asking whether giving the patient 5-units of phenytoin in addition to the existing ge f itinib dose will cause a drug-interaction. It is encoded as the following query statement Q for a k-step simulation:\ndirection of change in average value of ge f itinib is d when observed at time step k; comparing nominal pathway with modified pathway obtained\ndue to interventions : set value of phenytoin to 5;\nIf the direction of change is “=” then there was no drug-interaction. Otherwise, an interaction was noticed. For a simulation of length k = 5, we find 15 units of ge f itinib remained at the end of simulation in the nominal case when no phenytoin is administered. The amount drops to 10 units of ge f itinib when phenytoin is co-administered. The change in direction is “<”. Thus there is an interaction.\nThe second question is asking about the bioavailability of the drug ge f itinib after some after giving phenytoin in 5 units. If this bioavailability falls below the efficacy level of the drug, then the drug would not treat the disease effectively. It is encoded as the following query statement\nCHAPTER 5. TEXT EXTRACTION FOR REAL WORLD APPLICATIONS 166\nQ for a k-step simulation:\naverage value of ge f itinib is n when observed at time step k; due to interventions :\nset value of phenytoin to 5;\nFor a simulation of length k = 5, we find 10 units of ge f itinib remain. A drug administrator (such as a pharmacist) can adjust the drug accordingly.\n5.4.2 Drug Development\nA drug manufacturer is developing a new drug test drug that is known to inhibit CYP3A4 that will be co-administered with drugs ge f itinib and phenytoin. He wants to determine the bioavailability of ge f itinib over time to determine the risk of toxicity.\nThe question is asking about the bioavailability of the drug ge f itinib after 10 time units after giving phenytoin in 5 units and the new drug test drug in 5 units. If this bioavailability remains high, there is chance for toxicity due to the drug at the subsequent dosage intervals. It is encoded as the following query statement Q for a k-step simulation:\naverage value of ge f itinib is n when observed at time step k; due to interventions :\nset value of phenytoin to 5, set value of test drug to 5;\nFor a simulation of length k = 5, we find all 20 units of ge f itinib remain. This could lead to toxicity by building high concentration of ge f itinib in the body.\n5.4.3 Drug Administration in Presence of Genetic Variation\nA drug administrator wants to establish the dosage of morphine for a person based on its genetic profile using its bioavailability.\nConsider the following facts extracted about a simplified morphine pathway:\n• codeine is metabolized by CYP2D6 producing morphine\n• CYP2D6 has three allelic variations\n– “*1” – (EM) effective metabolizer (normal case) – “*2” – (UM) ultra rapid metabolizer – “*9” – (PM) poor metabolizer\nCHAPTER 5. TEXT EXTRACTION FOR REAL WORLD APPLICATIONS 167\nFor simplicity, assume UM allele doubles the metabolic rate, while PM allele halves the metabolic rate of CYP2D6. Then, the resulting pathway is given by:\ndomain of cyp2d6 allele is integer, cyp2d6 is integer domain of codeine is integer,morphine is integer cyp2d6 action may execute causing\ncodeine change value by − 2,morphine change value by + 2 if cyp2d6 allele has value equal to 1\ncyp2d6 action may execute causing codeine change value by − 4,morphine change value by + 4 if cyp2d6 allele has value equal to 2\ncyp2d6 action may execute causing codeine change value by − 1,morphine change value by + 1 if cyp2d6 allele has value equal to 9\ninitially codeine has value 0,morphine has value 0, cyp2d6 has value 20, cyp2d6 allele has value 1\nfiring style max\nThen, the bioavailability of morphine can be determined by the following query:\naverage value of morphine is n when observed at time step k; due to interventions :\nset value of codeine to 20, set value of cyp2d6 to 20, set value of cyp2d6 allele to 9;\nSimulation for 5 time steps reveal that the average bioavailability of morphine after 5 time-steps is 5 for PM (down from 10 for EM).\nAlthough this is a toy example, it is easy to see the potential of capturing known genetic variations in the pathway and setting the complete genetic profile of a person in the intervention part of the query.\n5.5 Conclusion\nIn this chapter we presented how we extract biological pathway knowledge from text, including knowledge about drug-gene interactions and their relationship to genetic variation. We showed\nCHAPTER 5. TEXT EXTRACTION FOR REAL WORLD APPLICATIONS 168\nhow the information extracted is used to build pathway specification and illustrated how biologically relevant questions can be answered about drug-drug interaction using the BioPathQA system developed in chapter 4. Next we look at the future directions in which the research work done in this thesis can be extended.\nChapter 6\nConclusion and Future Work\nThe field of knowledge representation and reasoning (KR) is currently one of the most active research areas. It represents the next step in the evolution of systems that know how to organize knowledge, and have the ability to intelligently respond to questions about this knowledge. Such questions could be about static knowledge or the dynamic processes.\nBiological systems are uniquely positioned as role models for this next evolutionary step due to their precise vocabulary and mechanical nature. As a result, a number of recent research challenges in the KR field are focused on it. The biological field itself needs systems that can intelligently answer questions about such biological processes and systems in an automated fashion, given the large number of research papers published each year. Curating these publications is time consuming and expensive, as a result the state of over all knowledge about biological systems lags behind the cutting edge research.\nAn important class of questions asked about biological systems are the so called “what-if” questions that compare alternate scenarios of a biological pathway. To answer such questions, one has to perform simulation on a nominal pathway against a pathway modified due to the interventions specified for the alternate scenario. Often, this means creating two pathways (for nominal and alternate cases) and simulate them separately. This opens up the possibility that the two pathways can become out of synchronization. A better approach is to allow the user to specify the needed interventions in the query statement itself. In addition, to understand the full spread of possible outcomes, given the parallel nature of biological pathways, one must consider all possible pathway evolutions, otherwise, some outcomes may remain hidden.\nIf a system is to be used by biologists, it must have a simple interface, lowering the barrier of entry. Since biological pathway knowledge can arrive from different sources, including books, published articles, and lab experiments, a common input format is desired. Such a format allows specification of pathways due to automatic extraction, as well as any changes / additions due to locally available information.\nA comprehensive end-to-end system that accomplish all the goals would take a natural language query along with any additional specific knowledge about the pathway as input, extract the relevant portion of the relevant pathway from published material (and background knowl-\n169\nCHAPTER 6. CONCLUSION AND FUTURE WORK 170\nedge), simulate it based on the query, and generate the results in a visual format. Each of these tasks comes with its own challenges, some of which have been addressed in this thesis.\nIn this thesis, we have developed a system and a high level language to specify a biological pathway and answer simulation based reasoning questions about it. The high level language uses controlled-English vocabulary to make it more natural for a researcher to use directly. The high level language has two components: a pathway specification language, and a query specification language. The pathway specification language allows the user to specify a pathway in a source independent form, thus locally obtained knowledge (e.g. from lab) can be combined with automatically extracted knowledge. We believe that our pathway specification language is easy for a person to understand and encode, lowering the bar to using our system. Our pathway specification language allows conditional actions, enabling the encoding of alternate action outcomes due to genetic variation. An important aspect of our pathway specification language is that it specifies trajectories, which includes specifying the initial configuration of substances, as well as state evolution style, such as maximal firing of actions, or serialized actions etc.\nOur query specification language provides a bridge between natural language questions and their formal representation. It is English-like but with precise semantics. A main feature of our query language is its support for comparative queries over alternate scenarios, which is not currently supported by any of the query languages (associated with action languages) we have reviewed. Our specification of alternate scenarios uses interventions (a general form of actions), that allow the user to modify the pathway as part of the query processing. We believe our query language is easier for a biologist to understand without requiring formal training.\nTo model the pathways, we use Petri Nets, which have been used in the past to model and simulate biological pathways. Petri Nets have a simple visual representation, which closely matches biological pathways; and they inherently support parallelism. We extended the Petri Nets to add features that we needed to suit our domain, e.g., reset arcs that remove all quantity of a substance as soon as it is produced, and conditional arcs that specify the conditional outcome of an action.\nFor simulation, we use ASP, which allowed us straight forward way to implement Petri Nets. It also gave us the ability to add extensions to the Petri Net by making local edits, implement different firing semantics, filter trajectories based on observations, and reason with the results. One of the major advantage of using Petri Net based simulation is the ability to generate all possible state evolutions, enabling us to process queries that determine the conditions when a certain observation becomes true.\nOur post-processing step is done in Python, which allows strong text processing capabilities using regular expressions, as well as libraries to easy process large matrices of numbers for summarization of results.\nNow we present additional challenges that need to be addressed.\nCHAPTER 6. CONCLUSION AND FUTURE WORK 171\n6.1 Pathway Extraction\nIn Chapter 5 we described how we extract facts for drug-drug interaction and gene variation. This work needs to be extended to include some of the newer databases that have come online recently. This may provide us with enzyme reaction rates, and substance quantities used in various reactions. The relation extraction for pathways must also be cognizant of any genetic variation mentioned in the text.\nSince the knowledge about the pathway appears in relationships at varying degree of detail, a process needs to be devised to assemble the pathway from the same level to granularity together, while also maintaining pathways at different levels of granularities.\nSince pathway extraction is a time consuming task, it would be best to create a catalog of the pathways. The cataloged pathways could be manually edited by the user as necessary. Storing pathways in this way means that would have to be updated periodically, requiring merging of new knowledge into existing pathways. Manual edits would have to be identified, such that the updated pathway does not overwrite them without the user’s knowledge.\n6.2 Pathway Selection\nQuestions presented in biological texts do not explicitly mention the relevant pathway to use for answering the question. One way to address this issue is to maintain a catalog of predefined pathways with keywords associated with them. Such keywords can include names of the substances, names of the processes, and other relevant meta-data about the pathway. The catalog can be searched to find the closest match to the query being asked.\nAn additional aspect in proper pathway selection is to use the proper abstraction level. If our catalog contains a pathway at different abstraction levels, the coarsest pathway that contains the processes and substances in the query should be selected. Any higher fidelity will increase the processing time and generate too much irrelevant data. Alternatively, the catalog could contain the pathway in a hierarchical form, allowing extraction of all elements of a pathway at the same depth. A common way to hierarchically organize the pathway related to our system is to have hierarchical actions, which is the approach taken by hierarchical Petri nets.\nLastly, the question may only ask about a small subsection of a much larger pathway. For better performance, it is beneficial to extract the smallest biological pathway network model that can answer the question.\n6.3 Pathway Modeling\nIn Chapter 3, we presented our modeling of biological questions using Petri Nets and their extensions encoded in ASP. We came across concepts like allosteric regulation, inhibition of inhibition, and inhibition of activation that we currently do not model. In allosteric regulation, an enzyme is not fully enabled or disabled, the enzyme’s shape changes, making it more or less active. The level of its activity depends upon concentrations of activators and inhibitors.\nCHAPTER 6. CONCLUSION AND FUTURE WORK 172\nIn inhibition of inhibition, the inhibition of a reaction is itself inhibited by another inhibition; while in inhibition of activation (or stimulation), a substance inhibits the stimulation produced by a substance. Both of these appear to be actions on actions, something that Petri Nets do not allow. An alternate coding for these would have to be devised.\nAs more detailed information about pathways becomes available, the reactions and processes that we have in current pathways may get replaced with more detailed sub-pathways themselves. However, such refinement may not come at the same time for separate legs of the pathway. Just replacing the coarse transition with a refined transition may not be sufficient due to relative timing constraints. Hence, a hierarchical Petri Net model may need to be implemented (see ??).\n6.4 Pathway Simulation\nIn Chapter 2 we presented our approach to encode Petri Nets and their extensions. We used a discrete solver called clingo for our ASP encoding. As the number of simulation length increases in size or larger quantities are involved, the solver slows down significantly. This is due to an increased grounding cost of the program. Incremental solving (using iclingo) does not help, since the program size still increases, and the increments merely delays the slow down but does not stop it.\nSystems such as constraint logic solvers (such as ?) could be used for discrete cases. Alternatively, a system developed on the ASPMT Lee and Meng (2013) approach could be used, since it can represent longer runs, larger quantities, and real number quantities.\n6.5 Extend High Level Language\nIn Chapter 4 we described the BioPathQA system, the pathway specification and the query specification high level languages. As we enhance the modeling of the biological pathways, we will need to improve or extend the system as well as the high level language. We give a few examples of such extensions.\nOur pathway specification language currently does not support continuous quantities (real numbers). Extending to real numbers will improve the coverage of the pathways that can be modeled. In addition, derived quantities (fluents) can be added, e.g. pH could be defined as a formula that is read-only in nature.\nCertain observations and queries can be easily specified using a language such as LTL, especially for questions requiring conditions leading to an action or a state. As a result, it may be useful to add LTL formulas to the query language. We did not take this approach because it would have presented an additional non-English style syntax for the biologists.\nOur substance production / consumption rates and amounts are currently tied to the fluents. In certain situations it is desirable to analyze the quantity of a substance produced / consumed by a specific action, e.g. one is interested in finding the amount of H+ ions produced by a multi-protein complex IV only.\nCHAPTER 6. CONCLUSION AND FUTURE WORK 173\nInterventions (that are a part of the query statement) presented in this thesis are applied at the start of the simulation. Eliminating this restriction would allow applying surgeries to the pathway mid execution. Thus, instead of specifying the steady state conditions in the query statement, one could apply the intervention when a certain steady state is reached.\n6.6 Result Formatting and Visualization\nIn Chapter 4 we described our system that answers questions specified in our high level language. At the end of its process, it outputs the final result. This output method can be enhanced by allowing to look at the progression of results in addition to the final result. This provides the biologist with the whole spread of possible outcomes. An example of such a spread is shown in Fig. fig:q1:result for question 1. A graphical representation of the simulation progression is also beneficial in enhancing the confidence of the biologist. Indeed many existing tools do this. A similar effect can be achieved by parsing and showing the relevant portion of the answer set.\n6.7 Summary\nIn Chapter 1 we introduced the thesis topic and summarized specific research contributions In Chapter 2 we introduced the foundational material of this thesis including Petri Nets\nand ASP. We showed how ASP could be used to encode basic Petri Nets. We also showed how ASP’s elaboration tolerance and declarative syntax allows us to encode various Petri Net extensions with small localized changes. We also introduced a new firing semantics, the so called maximal firing set semantics to simulate a Petri Net with maximum parallel activity.\nIn Chapter 3 we showed how the Petri Net extensions and the ASP encoding can be used to answer simulation based deep reasoning questions. This and the work in Chapter 2 was published in Anwar et al. (2013a,b).\nIn Chapter 4 we developed a system called BioPathQA to allow users to specify a pathway and answer queries against it. We also developed a pathway specification language and a query language for this system in order to avoid the vagaries of natural language. We introduced a new type of Guarded-arc Petri Nets to model conditional actions as a model for pathway simulation. We also described our implementation developed around a subset of the pathway specification language.\nIn Chapter 5 we briefly described how text extraction is done to extract real world knowledge about pathways and drug interactions. We then used the extracted knowledge to answer question using BioPathQA. The text extraction work was published in Tari et al. (2010b,a); Hakenberg et al. (2012).\nAppendix A\nProofs of Various Propositions\n174\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 175\nAssumption: The definitions in this section assume the programs Π do not have recursion through aggregate atoms. Our ASP translation ensures this due to the construction of programs Π.\nFirst we extend some definitions and properties related to ASP, such that they apply to rules with aggregate atoms. We will refer to the non-aggregate atoms as basic atoms. Recall the definitions of an ASP program given in section 2.2.1.\nProposition 9 (Forced Atom Proposition) Let S be an answer set of a ground ASP program Π as defined in definition 4. For any ground instance of a rule R in Π of the form A0:-A1, . . . , Am,not B1, . . . , not Bn,C1, . . . , Ck. if ∀Ai, 1 ≤ i ≤ m, S |= Ai, and ∀B j, 1 ≤ j ≤ n, S 6|= B j, ∀Cl, 1 ≤ l ≤ k, S |= Cl then S |= A0.\nProof: Let S be an answer set of a ground ASP program Π, R ∈ Π be a ground rule such that ∀B j, 1 ≤ j ≤ n, S 6|= B j; and ∀Cl, 1 ≤ l ≤ k, S |= Cl. Then, the reduct RS ≡ {p1:-A1, . . . , Am.; . . . ; ph:-A1, . . . , Am. | {p1, . . . , ph} = S ∩ lit(A0)} . Since S is an answer set of Π, it is a model of ΠS . As a result, whenever, ∀Ai, 1 ≤ i ≤ m, S |= Ai, {p1, . . . , ph} ⊆ S and S |= A0.\nProposition 10 (Supporting Rule Proposition) If S is an answer set of a ground ASP program Π as defined in definition 4 then S is supported by Π. That is, if S |= A0, then there exists a ground instance of a rule R in Π of the type A0:-A1, . . . , Am, not B1, . . . , not Bn, C1, . . . ,Ck. such that ∀Ai, 1 ≤ i ≤ m, S |= Ai, ∀B j, 1 ≤ j ≤ n, S 6|= B j, and ∀Cl, 1 ≤ l ≤ k, S |= Cl.\nProof: For S to be an answer set of Π, it must be the deductive closure of reduct ΠS . The deductive closure S of ΠS is iteratively built by starting from an empty set S , and adding head atoms of rules RSh ≡ ph:-A1, . . . , Am.,R S h ∈ Π\nS , whenever, S |= Ai, 1 ≤ i ≤ m, where, RSh is a rule in the reduct of ground rule R ∈ Π with ph ∈ lit(A0) ∩ S . Thus, there is a rule R ≡ A0:-A1, . . . , Am, not B1, . . . , not Bn,C1, . . . ,Ck., R ∈ Π, such that ∀Cl, 1 ≤ l ≤ k and ∀B j, 1 ≤ j ≤ n, S 6|= B j. Nothing else belongs in S .\nNext, we extend the splitting set theorem ? to include aggregate atoms.\nDefinition 88 (Splitting Set) A Splitting Set for a program Π is any set U of literals such that, for every rule R ∈ Π, if U |= head(R) then lit(R) ⊂ U. The set U splits Π into upper and lower parts. The set of rules R ∈ Π s.t. lit(R) ⊂ U is called the bottom of Π w.r.t. U, denoted by botU(Π). The rest of the rules, i.e. Π \\ botU(Π) is called the top of Π w.r.t. U, denoted by topU(Π).\nProposition 11 Let U be a splitting set of Π with answer set S and let X = S ∩U and Y = S \\U. Then, the reduct of Π w.r.t. S , i.e. ΠS is equal to botU(Π)X ∪ (Π \\ botU(Π))X∪Y .\nProof: We can rewrite Π as botU(Π) ∪ (Π \\ botU(Π)) using the definition of splitting set. Then the reduct of Π w.r.t. S can be written in terms of X and Y , since S = X ∪ Y . ΠS = ΠX∪Y = (botU(Π) ∪ (Π \\ botU(Π)))X∪Y = botU(Π)X∪Y∪ (Π \\ botU(Π))X∪Y . Since lit(botU(Π)) ⊆ U and Y ∩U = ∅, the reduct of botU(Π)X∪Y = botU(Π)X . Thus, ΠX∪Y = botU(Π)X ∪ (Π \\ botU(Π))X∪Y .\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 176\nProposition 12 Let S be an answer set of a program Π, then S ⊆ lit(head(Π)).\nProof: If S is an answer set of a program Π then S is produced by the deductive closure of ΠS\n(the reduct of Π w.r.t S ). By definition of the deductive closure, nothing can be in S unless it is the head of some rule supported by S .\nSplitting allow computing the answer set of a program Π in layers. Answer sets of the bottom layer are first used to partially evaluate the top layer, and then answer sets of the top layer are computed. Next, we define how a program is partially evaluated.\nIntuitively, the partial evaluation of an aggregate atom c given splitting set U w.r.t. a set of literals X removes all literals that are part of the splitting set U from c and updates c’s lower and upper bounds based on the literals in X, which usually come from botU of a program. The set X represents our knowledge about the positive literals, while the set U \\ X represents our knowledge about naf-literals at this stage. We can remove all literals in U from c, since the literals in U will not appear in the head of any rule in topU .\nDefinition 89 (Partial Evaluation of Aggregate Atom) The partial evaluation of an aggregate atom c = l [B0 = w0, . . . , Bm = wm] u, given splitting set U w.r.t. a set of literals X, written evalU(c, X) is a new aggregate atom c′ constructed from c as follows:\n1. pos(c′) = pos(c) \\ U\n2. d = ∑\nBi∈pos(c)∩U∩X wi\n3. l′ = l − d, u′ = u − d are the lower and upper limits of c′\nNext, we define how a program is partially evaluated given a splitting set U w.r.t. a set of literals X that form the answer-set of the lower layer. Intuitively, a partial evaluation deletes all rules from the partial evaluation for which the body of the rule is determined to be not supported by U w.r.t. X. This includes rules which have an aggregate atom c in their body s.t. lit(c) ⊆ U, but X 6|= c 1. In the remaining rules, the positive and negative literals that overlap with U are deleted, and so are the aggregate atoms that have lit(c) ⊆ U (since such a c can be fully evaluated w.r.t. X). Each remaining aggregate atom is updated by removing atoms that belong to U 2, and updating its limits based on the answer-set X 3. The head atom is not modified, since evalU(...) is performed on Π \\botU(Π), which already removes all rules with heads atoms that intersect U.\nDefinition 90 (Partial Evaluation) The partial evaluation of Π, given splitting set U w.r.t. a set of literals X is the program evalU(Π, X) composed of rules R′ for each R ∈ Π that satisfies all the following conditions:\n1. pos(R) ∩ U ⊆ X, 1Note that we can fully evaluate an aggregate atom c w.r.t. answer-set X if lit(c) ⊆ U. 2Since the atoms in U will not appear in the head of any atoms in topU and hence will not form a basis in future\nevaluations of c. 3The limit update requires knowledge of the current answer-set to update limit values.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 177\n2. ((neg(R) ∩ U) ∩ X) = ∅, and\n3. if there is a c ∈ agg(R) s.t. lit(c) ⊆ U, then X |= c\nA new rule R′ is constructed from a rule R as follows:\n1. head(R′) = head(R),\n2. pos(R′) = pos(R) \\ U,\n3. neg(R′) = neg(R) \\ U,\n4. agg(R′) = {evalU(c, X) : c ∈ agg(R), lit(c) * U}\nProposition 13 Let U be a splitting set for Π, X be an answer set of botU(Π), and Y be an answer set of evalU(Π \\ botU(Π), X). Then, X ⊆ lit(Π) ∩ U and Y ⊆ lit(Π) \\ U.\nProof: By proposition 12, X ⊆ lit(head(botU(Π))), and Y ⊆ lit(head(evalU(Π \\ botU(Π), X))). In addition, lit(head(botU(Π))) ⊆ lit(botU(Π)) and lit(botU(Π)) ⊆ lit(Π) ∩ U by definition of botU(Π). Then X ⊆ lit(Π) ∩ U, and Y ⊆ lit(Π) \\ U.\nDefinition 91 (Solution) Baral (2003) Let U be a splitting set for a program Π. A solution to Π w.r.t. U is a pair 〈X,Y〉 of literals such that:\n• X is an answer set for botU(Π)\n• Y is an answer set for evalU(topU(Π), X); and\n• X ∪ Y is consistent.\nProposition 14 (Splitting Theorem) Baral (2003) Let U be a splitting set for a program Π. A set S of literals is a consistent answer set for Π iff S = X ∪Y for some solution 〈X,Y〉 of Π w.r.t. U.\nLemma 1 Let U be a splitting set of Π, C be an aggregate atom in Π, and X and Y be subsets of lit(Π) s.t. X ⊆ U, and Y ∩ U = ∅. Then, X ∪ Y |= C iff Y |= evalU(C, X).\nProof:\n1. Let C′ = evalU(C, X), then by definition of partial evaluation of aggregate atom, pos(C′) = pos(C) \\U, with lower limit l′ = l− d, and upper limit u′ = u− d, computed from l, u, the lower and upper limits of C, where\nd = ∑\nBi∈pos(C)∩U∩X wi\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 178\n2. Y |= C′ iff\nl′ ≤  ∑ B′i∈pos(C′)∩Y w′i  ≤ u′ – by definition of aggregate atom satisfaction.\n3. then Y |= C iff\nl ≤  ∑ Bi∈pos(C)∩U∩X wi + ∑ B′i∈(pos(C)\\U)∩Y w′i  ≤ u 4. however, (pos(C)∩U)∩ X and (pos(C) \\U)∩ Y combined represent pos(C)∩ (X ∪ Y) –\nsince\npos(C) ∩ (X ∪ Y) = ((pos(C) ∩ U) ∪ (pos(C) \\ U)) ∩ (X ∪ Y) = [((pos(C) ∩ U) ∪ (pos(C) \\ U)) ∩ X] ∪ [((pos(C) ∩ U) ∪ (pos(C) \\ U)) ∩ Y]\n= [(pos(C) ∩ U) ∩ X) ∪ ((pos(C) \\ U) ∩ X)] ∪ [(pos(C) ∩ U) ∩ Y) ∪ ((pos(C) \\ U) ∩ Y)]\n= [((pos(C) ∩ U) ∩ X) ∪ ∅] ∪ [∅ ∪ ((pos(C) \\ U) ∩ Y)] = ((pos(C) ∩ U) ∩ X) ∪ ((pos(C) \\ U) ∩ Y)\nwhere X ⊆ U and Y ∩ U = ∅\n5. thus, Y |= C iff\nl ≤  ∑ Bi∈pos(C)∩(X∪Y) wi  ≤ u 6. which is the same as X ∪ Y |= C\nLemma 2 Let U be a splitting set for Π, and X,Y be subsets of lit(Π) s.t. X ⊆ U and Y ∩U = ∅. Then the body of a rule R′ ∈ evalU(Π, X) is satisfied by Y iff the body of the rule R ∈ Π it was constructed from is satisfied by X ∪ Y.\nProof: Y satisfies body(R′) iff pos(R′) ⊆ Y , neg(R′) ∩ Y = ∅, Y |= C′ for each C′ ∈ agg(R′) – by definition of rule\nsatisfaction iff (pos(R) ∩ U) ⊆ X, (pos(R) \\ U) ⊆ Y , (neg(R) ∩ U) ∩ X) = ∅, (neg(R) \\ U) ∩ Y) = ∅, X satisfies C for all C ∈ agg(C) in which lit(C) ⊆ U, and Y satisfies evalU(C, X) for all C ∈ agg(C) in which lit(C) * U – using definition of partial evaluation\niff pos(R) ⊆ X ∪ Y , neg(R) ∩ (X ∪ Y) = ∅, X ∪ Y |= C – using\n• (A ∩ U) ∪ (A \\ U) = A\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 179\n• A∩ (X ∪Y) = ((A∩U)∪ (A \\U))∩ (X ∪Y) = ((A∩U)∩ (X ∪Y))∪ ((A \\U)∩ (X ∪Y)) = (A ∩ U) ∩ X) ∪ ((A \\ U) ∩ Y) – given X ⊆ U and Y ∩ U = ∅.\n• and lemma 1\nProof of Splitting Theorem: Let U be a splitting set of Π, then a consistent set of literals S is an answer set of Π iff it can be written as S = X ∪ Y , where X is an answer set of botU(Π); and Y is an answer set of evalU(Π \\ botU(Π),Y).\n(⇐) Let X is an answer set of botU(Π); and Y is an answer set of evalU(Π \\ botU(Π), X); we show that X ∪ Y is an answer set of Π.\nBy definition of botU(Π), lit(botU(Π)) ⊆ U. In addition, by proposition 13, Y ∩ U = ∅. Then, ΠX∪Y = (botU(Π) ∪ (Π \\ botU(Π)))X∪Y = botU(Π)X∪Y ∪ (Π \\ botU(Π))X∪Y = botU(Π)X ∪ (Π \\ botU(Π))X∪Y .\nLet r be a rule in ΠX∪Y , s.t. X ∪ Y |= body(r) then we show that X ∪ Y |= head(r). The rule r either belongs to botU(Π)X or (Π \\ botU(Π))X∪Y .\nCase 1: say r ∈ botU(Π)X be a rule whose body is satisfied by X ∪ Y\n1. then there is a rule R ∈ botU(Π) s.t. r ∈ RX\n2. then X |= body(R) – since X ∪ Y |= body(r); lit(botU(Π)) ⊆ U and Y ∩ U = ∅\n3. we already have X |= head(R) – since X is an answer set of botU(Π); given\n4. then X ∪ Y |= head(R) – because lit(R) ⊆ U and Y ∩ U = ∅\n5. consequently, X ∪ Y |= head(r)\nCase 2: say r ∈ (Π \\ botU(Π))X∪Y be a rule whose body is satisfied by X ∪ Y\n1. then there is a rule R ∈ (Π \\ botU(Π)) s.t. r ∈ RX∪Y\n2. then lit(head(R)) ∩ U = ∅ – otherwise, R would have belonged to botU(Π), by definition of splitting set\n3. then head(r) ∈ Y – since X ⊆ U\n4. in addition, pos(R) ⊆ X ∪ Y , neg(R) ∩ (X ∪ Y) = ∅, X ∪ Y |= C for each C ∈ agg(R) – using definition of reduct\n5. then pos(R)∩U ⊆ X or pos(R) \\U ⊆ Y; (neg(R)∩U)∩ X = ∅ and (neg(R) \\U)∩ Y = ∅; and for each C ∈ agg(R), either X |= C if lit(C) ⊆ U, or Y |= evalU(C, X) if lit(C) * U – by rearranging, lemma 1, X ⊆ U, Y ∩ U = ∅, and definition of partial evaluation of an aggregate atom\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 180\n6. note that pos(R)∩U ⊆ X, (neg(R)∩U)∩X = ∅, and for each C ∈ agg(R), s.t. lit(C) ⊆ U, X |= C, represent conditions satisfied by each rule that become part of a partial evaluation – using definition of partial evaluation\n7. and pos(R) \\ U, neg(R) \\ U, and for each C ∈ agg(R), evalU(C, X) are the modifications made to the rule during partial evaluation given splitting set U w.r.t. X – using definition of partial evaluation\n8. and pos(R) \\ U ⊆ Y , (neg(R) \\ U) ∩ Y = ∅, and for each C ∈ agg(R), Y |= evalU(C, X) if lit(C) * U represent conditions satisfied by rules that become part of the reduct w.r.t Y – using definition of partial evaluation and reduct\n9. then r is a rule in reduct evalU(Π \\ botU(Π), X)Y – using (8), (2) above\n10. in addition, given that Y satisfies evalU(Π \\ botU(Π), X), and head(r) ∩ U = ∅, we have X ∪ Y |= head(r)\nNext we show that X∪Y satisfies all rules of Π. Say, R is a rule in Π not satisfied by X∪Y . Then, either it belongs to botU(Π) or (Π \\botU(Π)). If it belongs to botU(Π), it must not be satisfied by X, since lit(botU(Π)) ⊆ U and Y∩U = ∅. However, the contrary is given to be true. On the other hand if it belongs to (Π \\ botU(Π)), then X ∪ Y satisfies body(R) but not head(R). That would mean that its head(R) is not satisfied by Y , since head(R) ∩ U = ∅ by definition of splitting set. However, from lemma 2 we know that if body(R) is satisfied by X∪Y , body(R′) is satisfied by Y for R′ ∈ evalU(Π \\ botU(Π), X). We also know that Y satisfies all rules in evalU(Π \\ botU(Π), X). So, R′ must be satisfied by Y contradicting our assumption. Thus, all rules of Π are satisfied by X ∪ Y and X ∪ Y is an answer set of Π.\n(⇒) Let S be a consistent answer set of Π, we show that S = X ∪ Y for sets X and Y s.t. X is an answer set of botU(Π) and Y is an answer set of evalU(Π \\ botU(Π), X). We take X = S ∩ U, Y = S \\ U, then S = X ∪ Y .\nCase 1: We show that X is answer set of botU(Π)\n1. Π can be split into botU(Π) ∪ (Π \\ botU(Π)) – by definition of splitting\n2. then X ∪ Y satisfies botU(Π) – X ∪ Y is an answer set of Π; given\n3. however lit(botU(Π)) ⊆ U, Y ∩ U = ∅ – by definition of splitting\n4. then X satisfies botU(Π) – since elements of Y do not appear in the rules of botU(Π)\n5. then X is an answer set of botU(Π)\nCase 2: We show that Y is answer set of evalU(Π \\ botU(Π), X)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 181\n1. let r be a rule in evalU(Π \\ botU(Π), X)Y , s.t. its body is satisfied by Y\n2. then r ∈ RY for an R ∈ evalU(Π \\ botU(Π), X) s.t. (i) pos(R) ⊆ Y (ii) neg(R) ∩ Y = ∅ (iii) Y |= C for all C ∈ agg(R) (iv) head(R) ∩ Y , ∅ – using definition of reduct\n3. each R is constructed from R′ ∈ Π that satisfies all the following conditions (i) pos(R′) ⊆ U ∩ X (ii) (neg(R′) ∩ U) ∩ X = ∅ (iii) if there is a C′ ∈ agg(R′) s.t. lit(C′) ⊆ U, then X |= C′ ; and each C ∈ agg(R) is a partial evaluation of C′ ∈ agg(R′) s.t. C = evalU(C′, X) – using definition of partial evaluation\n4. then the body(R′) satisfies all the following conditions:\n(a) pos(R′) ⊆ X ∪ Y – since X ⊆ U, X ∩ Y = ∅ (b) neg(R′) ∩ (X ∪ Y) = ∅ – since X ⊆ U, X ∩ Y = ∅ (c) X ∪ Y |= C′ for each C′ ∈ agg(R′) – since (i) each C′ ∈ agg(R′) with lit(C′) ⊆ U\nsatisfied by X is also satisfied by X ∪ Y as lit(Y) ∩ lit(C′) = ∅; and (ii) each C′ ∈ agg(R′) with lit(C′) * U is satisfied by X ∪ Y – using partial evaluation, reduct construction, and X ∩ Y = ∅\n5. then X ∪ Y satisfies body(R′) – from previous line\n6. in addition, lit(head(R′)) ∩ U = ∅, otherwise, R′ would have belonged to botU(Π) by definition of splitting set\n7. then R′ is a rule in Π \\ botU(Π) – from the last two lines\n8. we know that X ∪ Y satisfies every rule in (Π \\ botU(Π)) – given; and that elements of U do not appear in the head of rules in (Π \\ botU(Π)) – from definition of splitting; then Y must satisfy the head of these rules\n9. then Y satisfies head(R′) – from (8)\n10. Next we show that Y satisfies all rules of evalU(Π \\ botU(Π), X). Let R′ be a rule in evalU(Π\\botU(Π), X) such that body(R′) is satisfied by Y but not head(R′). Since head(R′)∩ Y = ∅, head(R′) is not satisfied by X ∪ Y either. Then, there is an R ∈ (Π \\ botU(Π)) such that X∪Y satisfies body(R) but not head(R), which contradicts given. Thus, Y satisfies all rules of evalU(Π \\ botU(Π), X).\n11. Then Y is an answer set of evalU(Π \\ botU(Π), X)\nDefinition 92 (Splitting Sequence) Baral (2003) A splitting sequence for a program Π is a monotone, continuous sequence 〈Uα〉α<µ of splitting sets of Π such that ⋃ α<µ Uµ = lit(Π).\nDefinition 93 (Solution) Baral (2003) Let U = 〈Uα〉α<µ be a splitting sequence for a program Π. A solution to Π w.r.t U is a sequence 〈Xα〉α<µ of sets of literals such that:\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 182\n1. X0 is an answer set for botU0(Π)\n2. for any ordinal α + 1 < µ, Xα+1 is an answer set of the program: evalUα(botUα+1(Π) \\ botUα(Π), ⋃ ν≤α Xν)\n3. for any limit ordinal α < µ, Xα = ∅, and\n4. ⋃ α≤µ(Xα) is consistent\nProposition 15 (Splitting Sequence Theorem) Baral (2003) Let U = 〈Uα〉α<µ be a splitting sequence for a program Π. A set S of literals is a consistent answer set for Π iff S = ⋃ α<µ Xα for some solution 〈Xα〉α<µ to Π w.r.t U.\nProof: Let U = 〈Uα〉α<µ be a splitting sequence of Π, then a consistent set of literals S =⋃ α<µ Xα is an answer set of ΠS iff X0 is an answer set of botU0(Π) and for any ordinal α+1 < µ,\nXα+1 is an answer set of evalUα(botUα+1(Π) \\ botUα(Π), ⋃ ν≤α Xν).\nNote that every literal in botU0(Π) belongs to lit(Π) ∩ U0, and every literal occurring in evalUα(botUα+1(Π) \\botUα(Π), ⋃ ν≤α Xν), (α+ 1 < µ) belongs to lit(Π)∩ (Uα+1 \\Uα). In addition, X0, and all Xα+1 are pairwise disjoint.\nWe prove the theorem by induction over the splitting sequence. Base case: α = 1. The splitting sequence is U0 ⊆ U1.\nThen the sub-program Π1 = botU1(Π) contains all literals in U1; and U0 splits Π1 into botU0(Π1) and botU1(Π1) \\ botU0(Π1). Then, S 1 = X0 ∪ X1 is a consistent answer set of Π1 iff X0 = S 1 ∩ U0 is an answer set of botU0(Π1) and X1 = S 1 \\ U0 is an answer set of evalU0(Π1 \\ botU0(Π1), X1) – by the splitting theorem\nSince botU0(Π1) = botU0(Π) and botU1(Π1)\\botU0(Π1) = botU1(Π)\\botU0(Π); S 1 = X0∪X1 is an answer set for Π \\ botU1(Π). Induction: Assume theorem holds for α = k, show theorem holds for α = k + 1.\nThe inductive assumption holds for the splitting sequence U0 ⊆ · · · ⊆ Uk. Then the subprogram Πk = botUk (Π) contains all literals in Uk and S k = X0 ∪ · · · ∪ Xk is a consistent answer set of ΠS k iff X0 is an answer set for botU0(Πk) and for any α ≤ k, Xα+1 is answer set of evalUα(botUα+1(Π) \\ botUα(Π), X0 ∪ · · · ∪ Xα)\nWe show that the theorem holds for α = k + 1. The splitting sequence is U0 ⊆ Uk+1. Then the sub-program Πk+1 = botUk+1(Π) contains all literals Uk+1. We have Uk split Πk+1 into botUk (Πk+1) and botUk+1(Πk+1) \\ botUk (Πk+1). Then, S k+1 = X0:k ∪ Xk+1 is a consistent answer set of Πk+1 iff X0:k = S k+1 ∩Uk is an answer set of botUk (Πk+1) and Xk+1 = S k+1 \\Uk is an answer set of evalUk (Πk+1 \\ botUk (Πk+1, Xk+1) – by the splitting theorem\nSince botUk (Πk+1) = botUk (Π) and botUk+1(Πk+1) \\ botUk (Πk+1) = botUk+1(Π) \\ botUk (Π); S k+1 = X0:k ∪ X1 is an answer set for Π \\ botUk+1(Π).\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 183\nFrom the inductive assumption we know that X0 ∪ · · · ∪ Xk is a consistent answer set of botUk (Π), X0 is the answer set of botU0(Π), and for each 0 ≤ α ≤ k, Xα+1 is answer set of evalUα(botUα+1(Π) \\ botUα(Π), X0 ∪ · · · ∪ Xα). Thus, X0:k = X0 ∪ · · · ∪ Xk.\nCombining above with the inductive assumption, we get S k+1 = X0∪· · ·∪Xk+1 is a consistent answer set of ΠS k+1 iff X0 is an answer set for botU0(Πk+1) and for any α ≤ k + 1, Xα+1 is answer set of evalUα(botUα+1(Π) \\ botUα(Π), X0 ∪ · · · ∪ Xα).\nIn addition, for some α < µ, where µ is the length of the splitting sequence U = 〈Uα〉α<µ of Π, botUα(Π) will be the entire Π, i.e. lit(Π) = Uα. Then the set S of literals is a consistent answer set of Π iff S = ⋃ α<µ(Xα) for some solution 〈Xα〉α<µ to Π w.r.t U.\nA.1 Proof of Proposition 1\nLet PN = (P,T, E,W) be a Petri Net, M0 be its initial marking and let Π0(PN,M0, k, ntok) be the ASP encoding of PN and M0 over a simulation length k, with maximum ntok tokens on any place node, as defined in section 2.3. Then X = M0,T0,M1, . . . ,Mk,Tk,Mk+1 is an execution sequence of a PN (w.r.t. M0) iff there is an answer set A of Π0(PN,M0, k, ntok) such that:\n{ f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} = { f ires(t, ts) : f ires(t, ts) ∈ A} (A.1)\n{holds(p, q, ts) : p ∈ P, q = Mts(p), 0 ≤ ts ≤ k + 1} = {holds(p, q, ts) : holds(p, q, ts) ∈ A}\n(A.2)\nWe prove this by showing that:\n(I) Given an execution sequence X, we create a set A such that it satisfies (A.1) and (A.2) and show that A is an answer set of Π0\n(II) Given an answer set A of Π0, we create an execution sequence X such that (A.1) and (A.2) are satisfied\nFirst we show (I): Given PN and its execution sequence X, we create a set A as a union of the following sets:\n1. A1 = {num(n) : 0 ≤ n ≤ ntok}\n2. A2 = {time(ts) : 0 ≤ ts ≤ k}\n3. A3 = {place(p) : p ∈ P}\n4. A4 = {trans(t) : t ∈ T }\n5. A5 = {ptarc(p, t, n) : (p, t) ∈ E−, n = W(p, t)}, where E− ⊆ E\n6. A6 = {tparc(t, p, n) : (t, p) ∈ E+, n = W(t, p)}, where E+ ⊆ E\n7. A7 = {holds(p, q, 0) : p ∈ P, q = M0(p)}\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 184\n8. A8 = {notenabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∃p ∈ •t,Mts(p) < W(p, t)} per definition 12 (enabled transition)\n9. A9 = {enabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∀p ∈ •t,W(p, t) ≤ Mts(p)} per definition 12 (enabled transition)\n10. A10 = { f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} from definition 15 (firing set) , only an enabled transition may fire\n11. A11 = {add(p, q, t, ts) : t ∈ Tts, p ∈ t•, q = W(t, p), 0 ≤ ts ≤ k} per definition 13 (transition execution)\n12. A12 = {del(p, q, t, ts) : t ∈ Tts, p ∈ •t, q = W(p, t), 0 ≤ ts ≤ k} per definition 13 (transition execution)\n13. A13 = {tot incr(p, q, ts) : p ∈ P, q = ∑\nt∈Tts,p∈t•W(t, p), 0 ≤ ts ≤ k} per definition 16 (firing set execution)\n14. A14 = {tot decr(p, q, ts) : p ∈ P, q = ∑\nt∈Tts,p∈•t W(p, t), 0 ≤ ts ≤ k} per definition 16 (firing set execution)\n15. A15 = {consumesmore(p, ts) : p ∈ P, q = Mts(p), q1 = ∑\nt∈Tts,p∈•t W(p, t), q1 > q, 0 ≤ ts ≤ k} per definition 14 (conflicting transitions) for enabled transition set Tts\n16. A16 = {consumesmore : ∃p ∈ P : q = Mts(p), q1 = ∑\nt∈Tts,p∈•t W(p, t), q1 > q, 0 ≤ ts ≤ k} per definition 14 (conflicting transitions)\n17. A17 = {holds(p, q, ts + 1) : p ∈ P, q = Mts+1(p), 0 ≤ ts < k}, where Mts+1(p) = Mts(p) − ∑ t∈Tts,p∈•t W(p, t) + ∑ t∈Tts,p∈t•W(t, p)\naccording to definition 15 (firing set execution)\nWe show that A satisfies (A.1) and (A.2), and A is an answer set of Π0. A satisfies (A.1) and (A.2) by its construction (given above). We show A is an answer set of Π0 by splitting. We split lit(Π0) (literals of Π0) into a sequence of 6(k + 1) + 2 sets:\n• U0 = head( f 1) ∪ head( f 2) ∪ head( f 3) ∪ head( f 4) ∪ head( f 5) ∪ head( f 6) ∪ head(i1) = {place(p) : p ∈ P} ∪ {trans(t) : t ∈ T } ∪ {ptarc(p, t, n) : (p, t) ∈ E−, n = W(p, t)} ∪ {tparc(t, p, n) : (t, p) ∈ E+, n = W(t, p)}∪ {time(0), . . . , time(k)}∪{num(0), . . . , num(ntok)}∪ {holds(p, q, 0) : p ∈ P, q = M0(p)}\n• U6k+1 = U6k+0 ∪ head(e1)ts=k = U6k+0 ∪ {notenabled(t, k) : t ∈ T }\n• U6k+2 = U6k+1 ∪ head(e2)ts=k = U6k+1 ∪ {enabled(t, k) : t ∈ T }\n• U6k+3 = U6k+2 ∪ head(a1)ts=k = U6k+2 ∪ { f ires(t, k) : t ∈ T }\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 185\n• U6k+4 = U6k+3 ∪ head(r1)ts=k ∪ head(r2)ts=k = U6k+3 ∪ {add(p, q, t, k) : p ∈ P, t ∈ T, q = W(t, p)} ∪ {del(p, q, t, k) : p ∈ P, t ∈ T, q = W(p, t)}\n• U6k+5 = U6k+4 ∪ head(r3)ts=k ∪ head(r4)ts=k = U6k+4 ∪ {tot incr(p, q, k) : p ∈ P, 0 ≤ q ≤ ntok} ∪ {tot decr(p, q, k) : p ∈ P, 0 ≤ q ≤ ntok}\n• U6k+6 = U6k+5 ∪ head(r5)ts=k ∪ head(a2)ts=k = U6k+5 ∪ {holds(p, q, k + 1) : p ∈ P, 0 ≤ q ≤ ntok} ∪ {consumesmore(p, k) : p ∈ P}\n• U6k+7 = U6k+6 ∪ head(a3) = U7k+6 ∪ {consumesmore}\nwhere head(ri)ts=k are head atoms of ground rule ri in which ts = k. We write Ats=ki = {a(. . . , ts) : a(. . . , ts) ∈ Ai, ts = k} as short hand for all atoms in Ai with ts = k. Uα, 0 ≤ α ≤ 6k + 7 form a splitting sequence, since each Ui is a splitting set of Π0, and 〈Uα〉α<µ is a monotone continuous sequence, where U0 ⊆ U1 · · · ⊆ U6k+7 and ⋃ α<µ Uα = lit(Π0).\nWe compute the answer set of Π0 using the splitting sets as follows:\n1. botU0(Π 0) = f 1∪ f 2∪ f 3∪ f 4∪ f 5∪ i1∪ f 6 and X0 = A1 ∪ · · · ∪A7 (= U0) is its answer\nset – using forced atom proposition\n2. evalU0(botU1(Π 0)\\botU0(Π0), X0) = {notenabled(t, 0):-.|{trans(t), ptarc(p, t, n), holds(p, q, 0)} ⊆\nX0, where q < n}. Its answer set X1 = Ats=08 – using forced atom proposition and construction of A8.\n(a) where, q = M0(p), n = W(p, t), and for an arc (p, t) ∈ E− – by construction of i1 and f 3 in Π0, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 11 of preset) (c) thus, notenabled(t, 0) ∈ X1 represents ∃p ∈ •t : M0(p) < W(p, t).\n3. evalU1(botU2(Π 0)\\botU1(Π0), X0∪X1) = {enabled(t, 0):-.|trans(t) ∈ X0∪X1, notenabled(t, 0) <\nX0 ∪ X1}. Its answer set is X2 = Ats=09 – using forced atom proposition and construction of A9.\n(a) since an enabled(t, 0) ∈ X2 if @ notenabled(t, 0) ∈ X0 ∪ X1, which is equivalent to @p ∈ •t : M0(p) < W(p, t) ≡ ∀p ∈ •t : M0(p) ≥ W(p, t).\n4. evalU2(botU3(Π 0) \\ botU2(Π0), X0 ∪ X1 ∪ X2) = {{ f ires(t, 0)}:-.|enabled(t, 0)\nholds in X0 ∪ X1 ∪ X2}. It has multiple answer sets X3.1, . . . , X3.n, corresponding to elements of power set of f ires(t, 0) atoms in evalU2(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π0 determined using splitting is equal to A, we only consider the set that matches the f ires(t, 0) elements in A and call it X3, ignoring the rest. Thus, X3 = Ats=010 , representing T0.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 186\n5. evalU3(botU4(Π 0) \\ botU3(Π0), X0 ∪ · · · ∪ X3) = {add(p, n, t, 0):-.|{ f ires(t, 0),\ntparc(t, p, n)} ⊆ X0∪· · ·∪X3}∪{del(p, n, t, 0):-.|{ f ires(t, 0), ptarc(p, t, n)} ⊆ X0∪· · ·∪X3}. It’s answer set is X4 = Ats=011 ∪ A ts=0 12 – using forced atom proposition and definitions of A11 and A12.\n(a) where each add atom is equivalent to n = W(t, p) : p ∈ t•, (b) and each del atom is equivalent to n = W(p, t) : p ∈ •t, (c) representing the effect of transitions in T0 – by construction\n6. evalU4(botU5(Π 0) \\ botU4(Π0), X0 ∪ · · · ∪ X4) = {tot incr(p, qq, 0):-.| qq = ∑ add(p,q,t,0)∈X0∪···∪X4 q}∪ {tot decr(p, qq, 0):-.|qq = ∑\ndel(p,q,t,0)∈X0∪···∪X4 q}. It’s answer set is X5 = Ats=013 ∪ A ts=0 14 – using forced atom proposition and definitions of A13 and A14, ad definition 3 (semantics of aggregate assignment atom).\n(a) where each tot incr(p, qq, 0), qq = ∑\nadd(p,q,t,0)∈X0∪...X4 q ≡ qq = ∑t∈X3,p∈t•W(p, t),\n(b) and each tot decr(p, qq, 0), qq = ∑\ndel(p,q,t,0)∈X0∪...X4 q ≡ qq = ∑t∈X3,p∈•t W(t, p),\n(c) represent the net effect of transitions in T0 – by construction\n7. evalU5(botU6(Π 0) \\ botU5(Π0), X0 ∪ · · · ∪ X5) = {consumesmore(p, 0):-.|\n{holds(p, q, 0), tot decr(p, q1, 0)} ⊆ X0∪· · ·∪X5, q1 > q}∪ {holds(p, q, 1):-.| {holds(p, q1, 0), tot incr(p, q2, 0), tot decr(p, q3, 0)} ⊆ X0 ∪ · · · ∪ X5, q = q1 + q2 − q3}. It’s answer set is X6 = Ats=015 ∪ A ts=0 17 – using forced atom proposition.\n(a) where, consumesmore(p, 0) represents ∃p : q = M0(p), q1 = ∑ t∈T0,p∈•t W(p, t), q1 > q – indicating place p will be overconsumed if T0 is\nfired as defined in definition 14 (conflicting transitions)\n(b) and holds(p, q, 1) represents q = M1(p) – by construction\n...\n8. evalU6k+0(botU6k+1(Π 0) \\ botU6k+0(Π0), X0 ∪ · · · ∪ X6k+0) =\n{notenabled(t, k):-.|{trans(t), ptarc(p, t, n), holds(p, q, k)} ⊆ X0 ∪ · · · ∪ X6k+0, where q < n}. Its answer set X6k+1 = Ats=k8 – using forced atom proposition and construction of A8.\n(a) where, q = Mk(p), and n = W(p, t) for an arc (p, t) ∈ E− – by construction of holds and ptarc predicates in Π0, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 11 of preset) (c) thus, notenabled(t, k) ∈ X6k+1 represents ∃p ∈ •t : Mk(p) < W(p, t).\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 187\n9. evalU6k+1(botU6k+2(Π 0) \\ botU6k+1(Π0), X0 ∪ · · · ∪ X6k+1) = {enabled(t, k):-.|\ntrans(t) ∈ X0 ∪ · · · ∪ X6k+1, notenabled(t, k) < X0 ∪ · · · ∪ X6k+1}. Its answer set is X6k+2 = Ats=k9 – using forced atom proposition and construction of A9.\n(a) since an enabled(t, k) ∈ X6k+2 if @ notenabled(t, k) ∈ X0 ∪ · · · ∪ X6k+1, which is equivalent to @p ∈ •t : Mk(p) < W(p, t) ≡ ∀p ∈ •t : Mk(p) ≥ W(p, t).\n10. evalU6k+2(botU6k+3(Π 0) \\ botU6k+2(Π0), X0 ∪ · · · ∪ X6k+2) =\n{{ f ires(t, k)}:-.| enabled(t, k) holds in X0∪· · ·∪X6k+2}. It has multiple answer sets X6k+3.1, . . . , X6k+3.n, corresponding to elements of power set of f ires(t, k) atoms in evalU6k+2(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π0 determined using splitting is equal to A, we only consider the set that matches the f ires(t, k) elements in A and call it X6k+3, ignoring the reset. Thus, X6k+3 = Ats=k10 , representing Tk.\n11. evalU6k+3(botU6k+4(Π 0) \\ botU6k+3(Π0), X0 ∪ · · · ∪ X6k+3) = {add(p, n, t, k):-.|\n{ f ires(t, k), tparc(t, p, n)} ⊆ X0∪· · ·∪X6k+3}∪ {del(p, n, t, k):-.| { f ires(t, k), ptarc(p, t, n)} ⊆ X0 ∪ · · · ∪ X6k+3}. It’s answer set is X6k+4 = Ats=k11 ∪ A ts=k 12 – using forced atom proposition and definitions of A11 and A12.\n(a) where, each add atom is equivalent to n = W(t, p) : p ∈ t•, (b) and each del atom is equivalent to n = W(p, t) : p ∈ •t (c) representing the effect of transitions in Tk\n12. evalU6k+4(botU6k+5(Π 0) \\ botU6k+4(Π0), X0 ∪ · · · ∪ X6k+4) = {tot incr(p, qq, k):-.| qq = ∑\nadd(p,q,t,k)∈X0∪···∪X6k+4 q}∪ {tot decr(p, qq, k):-.| qq = ∑ del(p,q,t,k)∈X0∪···∪X6k+4 q}. It’s answer set is X5 = Ats=k13 ∪ A ts=k 14 – using forced atom proposition and definitions of A13 and A14.\n(a) where, each tot incr(p, qq, k), qq = ∑\nadd(p,q,t,k)∈X0∪...X7k+4 q ≡ qq = ∑t∈X6k+3,p∈t•W(p, t),\n(b) and each tot decr(p, qq, k), qq = ∑\ndel(p,q,t,k)∈X0∪...X7k+4 q ≡ qq = ∑t∈X6k+3,p∈•t W(t, p),\n(c) represent the net effect of transitions in Tk\n13. evalU6k+5(botU6k+6(Π 0)\\botU6k+5(Π0), X0∪· · ·∪X6k+5) = {consumesmore(p, k):-.| {holds(p, q, k),\ntot decr(p, q1, k)} ⊆ X0∪· · ·∪X6k+5, q1 > q}∪{holds(p, q, k+1):-., |{holds(p, q1, k), tot incr(p, q2, k), tot decr(p, q3, k)} ⊆ X0 ∪ · · · ∪ X6k+5, q = q1 + q2 − q3}. It’s answer set is X6k+6 = Ats=k15 ∪ A ts=k 17 – using forced atom proposition.\n(a) where, holds(p, q, k + 1) represents the marking of place p in the next time step due to firing Tk,\n(b) and, consumesmore(p, k) represents ∃p : q = Mk(p), q1 = ∑\nt∈Tk ,p∈•t W(p, t), q1 > q indicating place p that will be overconsumed if Tk is fired as defined in definition 14 (conflicting transitions)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 188\n14. evalU6k+6(botU6k+7(Π 0)\\botU6k+6(Π0), X0∪· · ·∪X6k+6) = {consumesmore:-.| {consumesmore(p, 0),\n. . . , consumesmore(p, k)} ∩ (X0 ∪ · · · ∪ X6k+7) , ∅}. It’s answer set is X6k+7 = Ats=k16 – using forced atom proposition\n(a) X6k+7 will be empty since none of consumesmore(p, 0), . . . , consumesmore(p, k) hold in X0 ∪ · · · ∪ X6k+6 due to the construction of A and encoding of a2, and it is not eliminated by the constraint a4.\nThe set X = X0 ∪ · · · ∪ X6k+7 is the answer set of Π0 by the splitting sequence theorem 15. Each Xi, 0 ≤ i ≤ 6k + 7 matches a distinct partition of A, and X = A, thus A is an answer set of Π0.\nNext we show (II): Given Π0 be the encoding of a Petri Net PN(P,T, E,W) with initial marking M0, and A be an answer set of Π0 that satisfies (A.1) and (A.2), then we can construct X = M0,T0, . . . ,Mk,Tk,Mk+1 from A, such that it is an execution sequence of PN.\nWe construct the X as follows:\n1. Mi = (Mi(p0), . . . ,Mi(pn)), where {holds(p0,Mi(p0), i), . . . holds(pn,Mi(pn), i)} ⊆ A, for 0 ≤ i ≤ k + 1\n2. Ti = {t : f ires(t, i) ∈ A}, for 0 ≤ i ≤ k\nand show that X is indeed an execution sequence of PN. We show this by induction over k (i.e. given Mk, Tk is a valid firing set and its firing produces marking Mk+1).\nBase case: Let k = 0, show (1) T0 is a valid firing set for M0, and (2) T0’s firing in M0 producing marking M1.\n1. We show T0 is a valid firing set w.r.t. M0. Let { f ires(t0, 0), . . . , f ires(tx, 0)} be the set of all f ires(. . . , 0) atoms in A,\n(a) Then for each f ires(ti, 0) ∈ A i. enabled(ti, 0) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, 0) < A – from rule e2 and supported rule proposition iii. Then body(e1) must not hold in A – from rule e1 and forced atom proposition iv. Then q ≮ ni ≡ q ≥ ni in e1 for all {holds(p, q, 0), ptarc(p, ti, ni)} ⊆ A – from e1,\nforced atom proposition, and the following: A. holds(p, q, 0) ∈ A represents q = M0(p) – rule i1 construction B. ptarc(p, ti, ni) ∈ A represents ni = W(p, ti) – rule f 3 construction\nv. Then ∀p ∈ •ti,M0(p) > W(p, ti) – from definition 11 of preset •ti in PN\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 189\nvi. Then ti is enabled and can fire in PN, as a result it can belong to T0 – from definition 12 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π0 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, 0) ∈ A – from rule a3 and supported rule proposition ii. Then @{holds(p, q, 0), tot decr(p, q1, 0)} ⊆ A : q1 > q in body(a2) – from a2\nand forced atom proposition iii. Then @p : ∑ ti∈{t0,...,tx},p∈•ti W(p, ti) > M0(p) – from the following\nA. holds(p, q, 0) represents q = M0(p) – from rule i1 construction, given B. tot decr(p, q1, 0) ∈ A if {del(p, q10, t0, 0), . . . del(p, q1x, tx, 0)} ⊆ A, where\nq1 = q10 + · · · + q1x – from r4 and forced atom proposition C. del(p, q1i, ti, 0) ∈ A if { f ires(ti, 0), ptarc(p, ti, q1i)} ⊆ A – from r2 and\nsupported rule proposition D. del(p, q1i, ti, 0) ∈ A represents removal of q1i = W(p, ti) tokens from p ∈ •ti – from r2, supported rule proposition, and definition 13 of transition execution in PN\niv. Then the set of transitions in T0 do not conflict – by the definition 14 of conflicting transitions\n(c) Then {t0, . . . , tx} = T0 – using 1(a),1(b) above, and definition of firing set\n2. We show M1 is produced by firing T0 in M0. Let holds(p, q, 1) ∈ A\n(a) Then {holds(p, q1, 0), tot incr(p, q2, 0), tot decr(p, q3, 0)} ⊆ A : q = q1 + q2 − q3 – from rule r5 and supported rule proposition\n(b) Then holds(p, q1, 0) ∈ A represents q1 = M0(p) – given, rule i1 construction; and {add(p, q0, t0, 0), . . . , add(p, q j, t j, 0)} ⊆ A : q0+· · ·+q j = q2 ; and {del(p, q0, t0, 0), . . . , del(p, ql, tl, 0)} ⊆ A : q0 + · · ·+ ql = q3 – rules r3, r4 and supported rule proposition, respectively\n(c) Then { f ires(t0, 0), . . . , f ires(t j, 0)} ⊆ A and { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A – rules r1, r2 and supported rule proposition; and the following\ni. tparc(ty, p, qy) ∈ A, 0 ≤ y ≤ j represents qy = W(ty, p) – given ii. ptarc(p, tz, qz) ∈ A, 0 ≤ z ≤ l represents qz = W(p, tz) – given\n(d) Then { f ires(t0, 0), . . . , f ires(t j, 0)} ∪ { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A = { f ires(t0, 0), . . . , f ires(tx, 0)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, 0) ∈ A we have tx ∈ T0 – already shown in item 1 above (f) Then q = M0(p)+ ∑ tx∈T0∧p∈tx•W(tx, p)− ∑ tx∈T0∧p∈•tx W(p, tx) – from (2b) above and\nthe following\ni. Each add(p, q j, t j, 0) ∈ A represents q j = W(t j, p) for p ∈ t j• – rule r1 encoding, and definition 13 of transition execution in PN\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 190\nii. Each del(p, ty, qy, 0) ∈ A represents qy = W(p, ty) for p ∈ •ty – from rule r2 encoding, and definition 13 of transition execution in PN\niii. Each tot incr(p, q2, 0) ∈ A represents q2 = ∑tx∈T0∧p∈tx•W(tx, p) – aggregate assignment atom semantics in rule r3\niv. Each tot decr(p, q3, 0) ∈ A represents q3 = ∑tx∈T0∧p∈•tx W(p, tx) – aggregate assignment atom semantics in rule r4\n(g) Then, M1(p) = q – since holds(p, q, 1) ∈ A encodes q = M1(p) – by construction\nInductive Step: Assume Mk is a valid marking in X for PN, show (1) Tk is a valid firing set for Mk, and (2) firing Tk in Mk produces marking Mk+1.\n1. We show that Tk is a valid firing set for Mk. Let { f ires(t0, k), . . . , f ires(tx, k)} be the set of all f ires(. . . , k) atoms in A,\n(a) Then for each f ires(ti, k) ∈ A i. enabled(ti, k) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, k) < A – from rule e2 and supported rule proposition iii. Then body of e1 must hold in A – from rule e1 and forced proposition iv. Then q ≮ ni ≡ q ≥ ni in e1 for all {holds(p, q, k), ptarc(p, ti, ni)} ⊆ A – from e1\nusing forced atom proposition, and the following A. holds(p, q, k) ∈ A represents q = Mk(p) – construction, inductive assump-\ntion B. ptarc(p, t, ni) ∈ A represents ni = W(p, t) – rule f 4 construction\nv. Then ∀p ∈ •ti,Mk(p) > W(p, ti) – from definition 11 of preset •ti in PN vi. Then ti is enabled and can fire in PN, as a result it can belong to Tk – from\ndefinition 12 of enabled transition (b) And consumesmore < A, since A is an answer set of Π0 – from rule a4 and supported\nrule proposition i. Then @consumesmore(p, k) ∈ A – from rule a3 and forced atom proposition\nii. Then @{holds(p, q, k), tot decr(p, q1, k)} ⊆ A : q1 > q in body(a2) – from a2 and forced atom proposition\niii. Then @p : ∑\nti∈{t0,...,tx},p∈•ti W(p, ti) > Mk(p) – from the following A. holds(p, q, k) ∈ A represents q = Mk(p) – by construction, and the induc-\ntive assumption B. tot decr(p, q1, k) ∈ A if {del(p, q10, t0, k), . . . , del(p, q1x, tx, k)} ⊆ A, where\nq1 = q10 + · · · + q1x – from r4 and forced atom proposition C. del(p, q1i, ti, k) ∈ A if { f ires(ti, k), ptarc(p, ti, q1i)} ⊆ A – from r2 and\nsupported rule proposition D. del(p, q1i, ti, k) represents removal of q1i = W(p, ti) tokens from p ∈ •ti –\nfrom construction rule r2, supported rule proposition, and definition 13 of transition execution in PN\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 191\niv. Then the set of transitions Tk does conflict – by the definition 14 of conflicting transitions\n(c) Then {t0, . . . , tx} = Tk – using 1(a),1(b) above\n2. We show Mk+1 is produced by firing Tk in Mk. Let holds(p, q, k + 1) ∈ A\n(a) Then {holds(p, q1, k), tot incr(p, q2, k), tot decr(p, q3, k)} ∈ A : q = q2 + q2 − q3 – from rule r5 and supported rule proposition\n(b) Then holds(p, q1, k) ∈ A represents q1 = Mk(p) – inductive assumption and construction; and {add(p, q20, t0, k), . . . , add(p, q2 j, t j, k)} ⊆ A : q20 + · · · + q2 j = q2 and {del(p, q30, t0, k), . . . , del(p, q3l, tl, k)} ⊆ A : q30 + · · · + q3l = q3 – from rules r3, r4 using supported rule proposition, respectively\n(c) Then { f ires(t0, k), . . . , f ires(t j, k)} ⊆ A and { f ires(t0, k), . . . , f ires(tl, k)} ⊆ A – from rules r1, r2 using supported rule proposition, respectively\n(d) Then { f ires(t0, k), . . . , f ires(t j, k)} ∪ { f ires(t0, k), . . . , f ires(tl, k)} = { f ires(t0, k), . . . , f ires(tx, k)} ⊆ A – subset union property\n(e) Then for each f ires(tx, k) ∈ A we have tx ∈ Tk - already shown in item 1 above (f) Then q = Mk(p) + ∑ tx∈Tk∧p∈tx•W(tx, p)− ∑ tx∈Tk∧p∈•tx W(p, tx – from (2b) above and\nthe following\ni. Each add(p, q j, t j, 0) ∈ A represents q j = W(t j, p) for p ∈ t j• – encoding of r1 and definition 13 of transition execution in PN\nii. Each del(p, ty, qy, 0) ∈ A represents qy = W(p, ty) for p ∈ •ty – encoding of r2 and definition 13 of transition execution in PN\niii. Each tot incr(p, q2, 0) ∈ A represents q2 = ∑tx∈Tk∧p∈tx•W(tx, p) – aggregate assignment atom semantics in rule r3\niv. Each tot decr(p, q3, 0) ∈ A represents q3 = ∑tx∈Tk∧p∈•tx W(p, tx) – aggregate assignment atom semantics in rule r4\n(g) Then Mk+1(p) = q – since holds(p, q, k + 1) ∈ A encodes q = Mk+1(p) by construction\nAs a result, for any n > k, Tn is a valid firing set w.r.t. Mn and its firing produces marking Mn+1.\nConclusion: Since both I and II hold, X = M0,T0,M1, . . . ,Mk,Tk,Mk+1 is an execution sequence of PN(P,T, E,W) (w.r.t. M0) iff there is an answer set A of Π0(PN,M0, k, ntok) such that (A.1) and (A.2) hold.\nA.2 Proof of Proposition 2\nLet PN = (P,T, E,W) be a Petri Net, M0 be its initial marking and let Π1(PN,M0, k, ntok) be the ASP encoding of PN and M0 over a simulation length k, with maximum ntok tokens on any\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 192\nplace node, as defined in section 2.4. Then X = M0,T0,M1, . . . ,Mk,Tk,Mk+1 is an execution sequence of PN (w.r.t. M0) iff there is an answer set A of Π1(PN,M0, k, ntok) such that:\n{ f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} = { f ires(t, ts) : f ires(t, ts) ∈ A} (A.3)\n{holds(p, q, ts) : p ∈ P, q = Mts(p), 0 ≤ ts ≤ k + 1} = {holds(p, q, ts) : holds(p, q, ts) ∈ A}\n(A.4)\nWe prove this by showing that:\n(I) Given an execution sequence X, we create a set A such that it satisfies (A.3) and (A.4) and show that A is an answer set of Π1\n(II) Given an answer set A of Π1, we create an execution sequence X such that (A.3) and (A.4) are satisfied.\nFirst we show (I): Given a PN and an execution sequence X of PN, we create a set A as a union of the following sets:\n1. A1 = {num(n) : 0 ≤ n ≤ ntok}\n2. A2 = {time(ts) : 0 ≤ ts ≤ k}\n3. A3 = {place(p) : p ∈ P}\n4. A4 = {trans(t) : t ∈ T }\n5. A5 = {ptarc(p, t, n) : (p, t) ∈ E−, n = W(p, t)}, where E− ⊆ E\n6. A6 = {tparc(t, p, n) : (t, p) ∈ E+, n = W(t, p)}, where E+ ⊆ E\n7. A7 = {holds(p, q, 0) : p ∈ P, q = M0(p)}\n8. A8 = {notenabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∃p ∈ •t,Mts(p) < W(p, t)} per definition 12 (enabled transition)\n9. A9 = {enabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∀p ∈ •t,W(p, t) ≤ Mts(p)} per definition 12 (enabled transition)\n10. A10 = { f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} per definition 15 (firing set), only an enabled transition may fire\n11. A11 = {add(p, q, t, ts) : t ∈ Tts, p ∈ t•, q = W(t, p), 0 ≤ ts ≤ k} per definition 13 (transition execution)\n12. A12 = {del(p, q, t, ts) : t ∈ Tts, p ∈ •t, q = W(p, t), 0 ≤ ts ≤ k} per definition 13 (transition execution)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 193\n13. A13 = {tot incr(p, q, ts) : p ∈ P, q = ∑\nt∈Tts,p∈t•W(t, p), 0 ≤ ts ≤ k} per definition 15 (firing set execution)\n14. A14 = {tot decr(p, q, ts) : p ∈ P, q = ∑\nt∈Tts,p∈•t W(p, t), 0 ≤ ts ≤ k} per definition 15 (firing set execution)\n15. A15 = {consumesmore(p, ts) : p ∈ P, q = Mts(p), q1 = ∑\nt∈Tts,p∈•t W(p, t), q1 > q, 0 ≤ ts ≤ k} per definition 14 (conflicting transitions) for enabled transition set Tts\n16. A16 = {consumesmore : ∃p ∈ P : q = Mts(p), q1 = ∑\nt∈Tts,p∈•t W(p, t), q1 > q, 0 ≤ ts ≤ k} per definition 14 (conflicting transitions)\n17. A17 = {could not have(t, ts) : t ∈ T, (∀p ∈ •t,W(p, t) ≤ Mts(p)), t < Tts, (∃p ∈ •t : W(p, t) > Mts(p) − ∑ t′∈Tts,p∈•t′ W(p, t\n′)), 0 ≤ ts ≤ k} per the maximal firing set semantics\n18. A18 = {holds(p, q, ts + 1) : p ∈ P, q = Mts+1(p), 0 ≤ ts < k}, where Mts+1(p) = Mts(p) − ∑ t∈Tts,p∈•t W(p, t) + ∑ t∈Tts,p∈t•W(t, p)\naccording to definition 16 (firing set execution)\nWe show that A satisfies (A.3) and (A.4), and A is an answer set of Π1. A satisfies (A.3) and (A.4) by its construction above. We show A is an answer set of Π1 by splitting. We split lit(Π1) into a sequence of 6k + 8 sets:\n• U0 = head( f 1) ∪ head( f 2) ∪ head( f 3) ∪ head( f 4) ∪ head( f 5) ∪ head( f 6) ∪head(i1) = {place(p) : p ∈ P} ∪ {trans(t) : t ∈ T } ∪ {ptarc(p, t, n) : (p, t) ∈ E−, n = W(p, t)} ∪ {tparc(t, p, n) : (t, p) ∈ E+, n = W(t, p)}∪ {time(0), . . . , time(k)}∪{num(0), . . . , num(ntok)}∪ {holds(p, q, 0) : p ∈ P, q = M0(p)}\n• U6k+1 = U6k+0 ∪ head(e1)ts=k = U6k+0 ∪ {notenabled(t, k) : t ∈ T }\n• U6k+2 = U6k+1 ∪ head(e2)ts=k = U6k+1 ∪ {enabled(t, k) : t ∈ T }\n• U6k+3 = U6k+2 ∪ head(a1)ts=k = U6k+2 ∪ { f ires(t, k) : t ∈ T }\n• U6k+4 = U6k+3 ∪ head(r1)ts=k ∪ head(r2)ts=k = U6k+3 ∪ {add(p, q, t, k) : p ∈ P, t ∈ T, q = W(t, p)} ∪ {del(p, q, t, k) : p ∈ P, t ∈ T, q = W(p, t)}\n• U6k+5 = U6k+4 ∪ head(r3)ts=k ∪ head(r4)ts=k = U6k+4 ∪ {tot incr(p, q, k) : p ∈ P, 0 ≤ q ≤ ntok} ∪ {tot decr(p, q, k) : p ∈ P, 0 ≤ q ≤ ntok}\n• U6k+6 = U6k+5 ∪ head(r5)ts=k ∪ head(a2)ts=k ∪ head(a5)ts=k = U6k+5 ∪ {consumesmore(p, k) : p ∈ P} ∪ {holds(p, q, k + 1) : p ∈ P, 0 ≤ q ≤ ntok}∪ {could not have(t, k) : t ∈ T }\n• U6k+7 = U6k+6 ∪ head(a3) = U6k+6 ∪ {consumesmore}\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 194\nwhere head(ri)ts=k are head atoms of ground rule ri in which ts = k. We write Ats=ki = {a(. . . , ts) : a(. . . , ts) ∈ Ai, ts = k} as short hand for all atoms in Ai with ts = k. Uα, 0 ≤ α ≤ 6k + 7 form a splitting sequence, since each Ui is a splitting set of Π1, and 〈Uα〉α<µ is a monotone continuous sequence, where U0 ⊆ U1 · · · ⊆ U6k+7 and ⋃ α<µ Uα = lit(Π1).\nWe compute the answer set of Π1 using the splitting sets as follows:\n1. botU0(Π 1) = f 1∪ f 2∪ f 3∪ f 4∪ f 5∪ i1∪ f 6 and X0 = A1 ∪ · · · ∪A7 (= U0) is its answer\nset – using forced atom proposition\n2. evalU0(botU1(Π 1) \\ botU0(Π1), X0) = {notenabled(t, 0):-.|{trans(t),\nptarc(p, t, n), holds(p, q, 0)} ⊆ X0, where q < n}. Its answer set X1 = Ats=08 – using forced atom proposition and construction of A8.\n(a) where, q = M0(p), and n = W(p, t) for an arc (p, t) ∈ E− – by construction of i1 and f 3 in Π1, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 11 of preset) (c) thus, notenabled(t, 0) ∈ X1 represents ∃p ∈ •t : M0(p) < W(p, t).\n3. evalU1(botU2(Π 1)\\botU1(Π1), X0∪X1) = {enabled(t, 0):-.|trans(t) ∈ X0∪X1, notenabled(t, 0) <\nX0 ∪ X1}. Its answer set is X2 = Ats=09 – using forced atom proposition and construction of A9.\n(a) since an enabled(t, 0) ∈ X2 if @ notenabled(t, 0) ∈ X0 ∪ X1, which is equivalent to @p ∈ •t : M0(p) < W(p, t) ≡ ∀p ∈ •t : M0(p) ≥ W(p, t).\n4. evalU2(botU3(Π 1) \\ botU2(Π1), X0 ∪ X1 ∪ X2) = {{ f ires(t, 0)}:-.|enabled(t, 0)\nholds in X0 ∪ X1 ∪ X2}. It has multiple answer sets X3.1, . . . , X3.n, corresponding to elements of power set of f ires(t, 0) atoms in evalU2(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π1 determined using splitting is equal to A, we only consider the set that matches the f ires(t, 0) elements in A and call it X3, ignoring the rest. Thus, X3 = Ats=010 , representing T0.\n5. evalU3(botU4(Π 1) \\ botU3(Π1), X0 ∪ · · · ∪ X3) = {add(p, n, t, 0):-.|{ f ires(t, 0),\ntparc(t, p, n)} ⊆ X0∪· · ·∪X3}∪{del(p, n, t, 0):-.|{ f ires(t, 0), ptarc(p, t, n)} ⊆ X0∪· · ·∪X3}. It’s answer set is X4 = Ats=011 ∪ A ts=0 12 – using forced atom proposition and definitions of A11 and A12.\n(a) where, each add atom encodes n = W(t, p) : p ∈ t•, (b) and each del atom encodes n = W(p, t) : p ∈ •t (c) representing the effect of transitions in T0 – by construction\n6. evalU4(botU5(Π 1) \\ botU4(Π1), X0 ∪ · · · ∪ X4) = {tot incr(p, qq, 0):-.| qq = ∑ add(p,q,t,0)∈X0∪···∪X4 q} ∪ {tot decr(p, qq, 0):-.|qq = ∑\ndel(p,q,t,0)∈X0∪···∪X4 q}. It’s answer set is X5 = Ats=013 ∪A ts=0 14 – using forced atom proposition and definitions of A13, A14, and semantics of aggregate assignment atom\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 195\n(a) where, each tot incr(p, qq, 0), qq = ∑\nadd(p,q,t,0)∈X0∪...X4 q ≡ qq = ∑t∈X3,p∈t•W(p, t),\n(b) and, each tot decr(p, qq, 0), qq = ∑\ndel(p,q,t,0)∈X0∪...X4 q ≡ qq = ∑t∈X3,p∈•t W(t, p),\n(c) represent the net effect of actions in T0 – by construction\n7. evalU5(botU6(Π 1) \\ botU5(Π1), X0 ∪ · · · ∪ X5) = {consumesmore(p, 0):-.|\n{holds(p, q, 0), tot decr(p, q1, 0)} ⊆ X0 ∪ · · · ∪ X5 : q1 > q} ∪ {holds(p, q, 1):-., | {holds(p, q1, 0), tot incr(p, q2, 0), tot decr(p, q3, 0)} ⊆ X0 ∪ · · · ∪ X5, q = q1 + q2− q3} ∪ {could not have(t, 0):-.|{enabled(t, 0), ptarc(s, t, q), holds(s, qq, 0), tot decr(s, qqq, 0)} ⊆ X0 ∪ · · · ∪ X5, f ires(t, 0) < (X0 ∪ · · · ∪ X5), q > qq − qqq}. It’s answer set is X6 = Ats=015 ∪ A ts=0 17 ∪ A ts=0 18 – using forced atom proposition and definitions of A15, A17, A18.\n(a) where, consumesmore(p, 0) represents ∃p : q = M0(p), q1 = ∑\nt∈T0,p∈•t W(p, t), q1 > q indicating place p will be overconsumed if T0 is fired, as defined in definition 14 (conflicting transitions)\n(b) and, holds(p, q, 1) encodes q = M1(p) – by construction\n(c) and could not have(t, 0) represents an enabled transition t in T0 that could not fire due to insufficient tokens\n(d) X6 does not contain could not have(t, 0), when enabled(t, 0) ∈ X0 ∪ · · · ∪ X5 and f ires(t, 0) < X0 ∪ · · · ∪ X5 due to construction of A, encoding of a5 and its body atoms. As a result it is not eliminated by the constraint a6\n...\n8. evalU6k+0(botU6k+1(Π 1) \\ botU6k+0(Π1), X0 ∪ · · · ∪ X6k+0) =\n{notenabled(t, k):-.|{trans(t), ptarc(p, t, n), holds(p, q, k)} ⊆ X0 ∪ · · · ∪ X6k+0, where q < n}. Its answer set X6k+1 = Ats=k8 – using forced atom proposition and construction of A8.\n(a) where, q = Mk(p), and n = W(p, t) for an arc (p, t) ∈ E− – by construction of holds and ptarc predicates in Π1, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 11 of preset) (c) thus, notenabled(t, k) ∈ X6k+1 represents ∃p ∈ •t : Mk(p) < W(p, t).\n9. evalU6k+1(botU6k+2(Π 1) \\ botU6k+1(Π1), X0 ∪ · · · ∪ X6k+1) = {enabled(t, k):-.|\ntrans(t) ∈ X0 ∪ · · · ∪ X6k+1, notenabled(t, k) < X0 ∪ · · · ∪ X6k+1}. Its answer set is X6k+2 = Ats=k9 – using forced atom proposition and construction of A9.\n(a) since an enabled(t, k) ∈ X6k+2 if @ notenabled(t, k) ∈ X0 ∪ · · · ∪ X6k+1, which is equivalent to @p ∈ •t : Mk(p) < W(p, t) ≡ ∀p ∈ •t : Mk(p) ≥ W(p, t).\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 196\n10. evalU6k+2(botU6k+3(Π 1) \\ botU6k+2(Π1), X0 ∪ · · · ∪ X6k+2) =\n{{ f ires(t, k)}:-.|enabled(t, k) holds in X0∪· · ·∪X6k+2}. It has multiple answer sets X6k+3.1, . . . , X6k+3.n, corresponding to elements of power set of f ires(t, k) atoms in evalU6k+2(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π1 determined using splitting is equal to A, we only consider the set that matches the f ires(t, k) elements in A and call it X6k+3, ignoring the reset. Thus, X6k+3 = Ats=k10 , representing Tk.\n11. evalU6k+3(botU6k+4(Π 1) \\ botU6k+3(Π1), X0 ∪ · · · ∪ X6k+3) =\n{add(p, n, t, k):-.|{ f ires(t, k), tparc(t, p, n)} ⊆ X0 ∪ · · · ∪ X6k+3} ∪ {del(p, n, t, k):-.|{ f ires(t, k), ptarc(p, t, n)} ⊆ X0 ∪ · · · ∪ X6k+3}. It’s answer set is X6k+4 = Ats=k11 ∪ A ts=k 12 – using forced atom proposition and definitions of A11 and A12.\n(a) where, each add atom is equivalent to n = W(t, p) : p ∈ t•, (b) and, each del atom is equivalent to n = W(p, t) : p ∈ •t, (c) representing the effect of transitions in Tk\n12. evalU6k+4(botU6k+5(Π 1) \\ botU6k+4(Π1), X0 ∪ · · · ∪ X6k+4) = {tot incr(p, qq, k):-.| qq = ∑\nadd(p,q,t,k)∈X0∪···∪X6k+4 q} ∪ {tot decr(p, qq, k):-.| qq = ∑ del(p,q,t,k)∈X0∪···∪X6k+4 q}. It’s answer set is X6k+5 = Ats=k13 ∪A ts=k 14 – using forced atom proposition and definitions of A13 and A14.\n(a) where, each tot incr(p, qq, k), qq = ∑\nadd(p,q,t,k)∈X0∪...X6k+4 q ≡ qq = ∑ t∈X6k+3,p∈t•W(p, t),\n(b) and, each tot decr(p, qq, k), qq = ∑\ndel(p,q,t,k)∈X0∪...X6k+4 q ≡ qq = ∑ t∈X6k+3,p∈•t W(t, p),\n(c) represent the net effect of transitions in Tk\n13. evalU6k+5(botU6k+6(Π 1) \\ botU6k+5(Π1), X0 ∪ · · · ∪ X6k+5) =\n{consumesmore(p, k):-.|{holds(p, q, k), tot decr(p, q1, k)} ⊆ X0 ∪ · · · ∪ X6k+5 : q1 > q} ∪ {holds(p, q, k + 1):-., |{holds(p, q1, k), tot incr(p, q2, k), tot decr(p, q3, k)} ⊆ X0 ∪ · · · ∪ X6k+5 : q = q1 + q2 − q3} ∪ {could not have(t, k):{enabled(t, k), ptarc(s, t, q), holds(s, qq, k), tot decr(s, qqq, k)} ⊆ X0∪· · ·∪X6k+5, f ires(t, k) < (X0 ∪ · · · ∪ X6k+5), q > qq − qqq}. It’s answer set is X6k+6 = Ats=k15 ∪ A ts=k 17 ∪ A ts=k 18 – using forced atom proposition.\n(a) where, consumesmore(p, k) represents ∃p : q = Mk(p), q1 = ∑ t∈Tk ,p∈•t W(p, t), q1 > q\n(b) holds(p, q, k + 1) represents q = Mk+1(p) indicating place p that will be over consumed if Tk is fired, as defined in definition 14 (conflicting transitions),\n(c) holds(p, q, k + 1) represents q = Mk+1(p) – by construction\n(d) and could not have(t, k) represents an enabled transition t in Tk that could not fire due to insufficient tokens\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 197\n(e) X6k+6 does not contain could not have(t, k), when enabled(t, k) ∈ X0 ∪ · · · ∪ X6k+5 and f ires(t, k) < X0 ∪ · · · ∪ X6k+5 due to construction of A, encoding of a5 and its body atoms. As a result it is note eliminated by the constraint a6\n14. evalU6k+6(botU6k+7(Π 1) \\ botU6k+6(Π1), X0 ∪ · · · ∪ X6k+6) = {consumesmore:-.|\n{consumesmore(p, 0), . . . , consumesmore(p, k)}∩ (X0 ∪ · · · ∪ X6k+6) , ∅}. It’s answer set is X6k+7 = A16 – using forced atom proposition\n(a) X6k+7 will be empty since none of consumesmore(p, 0), . . . , consumesmore(p, k) hold in X0 ∪ · · · ∪ X6k+6 due to the construction of A, encoding of a2 and its body atoms. As a result, it is not eliminated by the constraint a4\nThe set X = X0 ∪ · · · ∪ X6k+7 is the answer set of Π0 by the splitting sequence theorem 15. Each Xi, 0 ≤ i ≤ 6k + 7 matches a distinct portion of A, and X = A, thus A is an answer set of Π1.\nNext we show (II): Given Π1 be the encoding of a Petri Net PN(P,T, E,W) with initial marking M0, and A be an answer set of Π1 that satisfies (A.3) and (A.4), then we can construct X = M0,T0, . . . ,Mk,Tk,Mk+1 from A, such that it is an execution sequence of PN.\nWe construct the X as follows:\n1. Mi = (Mi(p0), . . . ,Mi(pn)), where {holds(p0,Mi(p0), i), . . . holds(pn,Mi(pn), i)} ⊆ A, for 0 ≤ i ≤ k + 1\n2. Ti = {t : f ires(t, i) ∈ A}, for 0 ≤ i ≤ k\nand show that X is indeed an execution sequence of PN. We show this by induction over k (i.e. given Mk, Tk is a valid firing set and its firing produces marking Mk+1).\nBase case: Let k = 0, and M0 is a valid marking in X for PN, show (1) T0 is a valid firing set for M0, and (2) T0’s firing w.r.t. marking M0 produces M1.\n1. We show T0 is a valid firing set for M0. Let { f ires(t0, 0), . . . , f ires(tx, 0)} be the set of all f ires(. . . , 0) atoms in A,\n(a) Then for each f ires(ti, 0) ∈ A i. enabled(ti, 0) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, 0) < A – from rule e2 and supported rule proposition iii. Then body(e1) must not hold in A – from rule e1 and forced atom proposition iv. Then q ≮ ni ≡ q ≥ ni in e1 for all {holds(p, q, 0), ptarc(p, ti, ni)} ⊆ A – from e1,\nforced atom proposition, and the following A. holds(p, q, 0) ∈ A represents q = M0(p) – rule i1 construction\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 198\nB. ptarc(p, ti, ni) ∈ A represents ni = W(p, ti) – rule f 3 construction v. Then ∀p ∈ •ti,M0(p) > W(p, ti) – from definition 11 of preset •ti in PN\nvi. Then ti is enabled and can fire in PN, as a result it can belong to T0 – from definition 12 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π1 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, 0) ∈ A – from rule a3 and supported rule proposition ii. Then @{holds(p, q, 0), tot decr(p, q1, 0)} ⊆ A : q1 > q in body(a2) – from a2\nand forced atom proposition iii. Then @p : ∑ ti∈{t0,...,tx},p∈•ti W(p, ti) > M0(p) – from the following\nA. holds(p, q, 0) represents q = M0(p) – from rule i1 construction, given B. tot decr(p, q1, 0) ∈ A if {del(p, q10, t0, 0), . . . , del(p, q1x, tx, 0)} ⊆ A, where\nq1 = q10 + · · · + q1x – from r4 and forced atom proposition C. del(p, q1i, ti, 0) ∈ A if { f ires(ti, 0), ptarc(p, ti, q1i)} ⊆ A – from r2 and\nsupported rule proposition D. del(p, q1i, ti, 0) represents removal of q1i = W(p, ti) tokens from p ∈ •ti\n– from rule r2, supported rule proposition, and definition 13 of transition execution in PN\niv. Then the set of transitions in T0 do not conflict – by the definition 14 of conflicting transitions\n(c) And for each enabled(t j, 0) ∈ A and f ires(t j, 0) < A, could not have(t j, 0) ∈ A, since A is an answer set of Π1 - from rule a6 and supported rule proposition\ni. Then {enabled(t j, 0), holds(s, qq, 0), ptarc(s, t j, q, 0), tot decr(s, qqq, 0)} ⊆ A, such that q > qq − qqq and f ires(t j, 0) < A - from rule a5 and supported rule proposition\nii. Then for an s ∈ •t j, W(s, t j) > M0(s)− ∑\nti∈T0,s∈•ti W(s, ti) - from the following: A. ptarc(s, ti, q) represents q = W(s, ti) – from rule f 7 construction B. holds(s, qq, 0) represents qq = M0(s) – from i1 construction C. tot decr(s, qqq, 0) ∈ A if {del(s, qqq0, t0, 0), . . . , del(s, qqqx, tx, 0)} ⊆ A –\nfrom rule r4 construction and supported rule proposition D. del(s, qqqi, ti, 0) ∈ A if { f ires(ti, 0), ptarc(s, ti, qqqi)} ⊆ A – from rule r7\nand supported rule proposition E. del(s, qqqi, ti, 0) represents qqqi = W(s, ti) : ti ∈ T0, (s, ti) ∈ E− – from rule\nf 7 construction F. tot decr(q, qqq, 0) represents ∑ ti∈T0,s∈•ti W(s, ti) – from (C,D,E) above\niii. Then firing T0 ∪ {t j} would have required more tokens than are present at its source place s ∈ •t j. Thus, T0 is a maximal set of transitions that can simultaneously fire.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 199\n(d) Then {t0, . . . , tx} = T0 – using 1(a),1(b) above; and using 1(c) it is a maximal firing set\n2. We show M1 is produced by firing T0 in M0. Let holds(p, q, 1) ∈ A\n(a) Then {holds(p, q1, 0), tot incr(p, q2, 0), tot decr(p, q3, 0)} ⊆ A : q = q1 + q2 − q3 – from rule r5 and supported rule proposition\n(b) Then, holds(p, q1, 0) ∈ A represents q1 = M0(p) – given, rule i1 construction; and {add(p, q20, t0, 0), . . . , add(p, q2 j, t j, 0)} ⊆ A : q20 + · · · + q2 j = q2 and {del(p, q30, t0, 0), . . . , del(p, q3l, tl, 0)} ⊆ A : q30 + · · · + q3l = q3 – rules r3, r4 using supported rule proposition\n(c) Then { f ires(t0, 0), . . . , f ires(t j, 0)} ⊆ A and { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A – rules r1, r2 and supported rule proposition, respectively\n(d) Then { f ires(t0, 0), . . . , f ires(t j, 0)}∪{ f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A = { f ires(t0, 0), . . . , f ires(tx, 0)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, 0) ∈ A we have tx ∈ T0 – already shown in item 1 above (f) Then q = M0(p)+ ∑ tx∈T0∧p∈tx•W(tx, p)− ∑ tx∈T0∧p∈•tx W(p, tx) – from (2b) above and\nthe following\ni. Each add(p, q j, t j, 0) ∈ A represents q j = W(t j, p) for p ∈ t j• – rule r1 encoding, and definition 13 of transition execution in PN\nii. Each del(p, ty, qy, 0) ∈ A represents qy = W(p, ty) for p ∈ •ty – from rule r2 encoding, and definition 13 of transition execution in PN\niii. Each tot incr(p, q2, 0) ∈ A represents q2 = ∑tx∈T0∧p∈tx•W(tx, p) – aggregate assignment atom semantics in rule r3\niv. Each tot decr(p, q3, 0) ∈ A represents q3 = ∑tx∈T0∧p∈•tx W(p, tx) – aggregate assignment atom semantics in rule r4\n(g) Then, M1(p) = q – since holds(p, q, 1) ∈ A encodes q = M1(p) from construction\nInductive Step: Let k > 0, and Mk is a valid marking in X for PN, show (1) Tk is a valid firing set for Mk, and (2) Tk’s firing in Mk produces marking Mk+1.\n1. We show Tk is a valid firing set. Let { f ires(t0, k), . . . , f ires(tx, k)} be the set of all f ires(. . . , k) atoms in A,\n(a) Then for each f ires(ti, k) ∈ A i. enabled(ti, k) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, k) < A – from rule e2 and supported rule proposition iii. Then body(e1) must hold in A – from rule e1 and forced atom proposition iv. Then q ≮ ni ≡ q ≥ ni in e1 for all {holds(p, q, k), ptarc(p, ti, n)} ⊆ A – from e1,\nforced atom proposition, and the following\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 200\nA. holds(p, q, k) ∈ A represents q = Mk(p) – construction, inductive assumption\nB. ptarc(p, t, ni) ∈ A represents ni = W(p, ti) – rule f 3 construction v. Then ∀p ∈ •ti, Mk(p) ≥ W(p, ti) – from definition 11 of preset •ti in PN\nvi. Then ti is enabled and can fire in PN, as a result it can belong to Tk – from definition 12 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π1 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, k) ∈ A – from rule a3 and forced atom proposition ii. Then @{holds(p, q, k), tot decr(p, q1, k)} ⊆ A : q1 > q in body(a2) – from a2\nand forced atom proposition iii. Then @p : ∑ ti∈{t0,...,tx},p∈•ti W(p, ti) > Mk(p) – from the following\nA. holds(p, q, k) ∈ A represents q = Mk(p) – by construction of Π1, and the inductive assumption about Mk(p) B. tot decr(p, q1, k) ∈ A if {del(p, q10, t0, k), . . . , del(p, q1x, tx, k)} ⊆ A, where q1 = q10 + · · · + q1x – from r4 and forced atom proposition C. del(p, q1i, ti, k) ∈ A if { f ires(ti, k), ptarc(p, ti, q1i)} ⊆ A – from r2 and supported rule proposition\nD. del(p, q1i, ti, k) represents removal of q1i = W(p, ti) tokens from p ∈ •ti – from construction rule r2, supported rule proposition, and definition 13 of transition execution in PN\niv. Then the set of transitions Tk do not conf – by the definition 14 of conflicting transitions\n(c) And for each enabled(t j, k) ∈ A and f ires(t j, k) < A, could not have(t j, k) ∈ A, since A is an answer set of Π1 - from rule a6 and supported rule proposition\ni. Then {enabled(t j, k), holds(s, qq, k), ptarc(s, t j, q, k), tot decr(s, qqq, k)} ⊆ A, such that q > qq − qqq and f ires(t j, 0) < A - from rule a5 and supported rule proposition\nii. Then for an s ∈ •t j, W(s, t j) > Mk(s) − ∑\nti∈Tk ,s∈•ti W(s, ti) - from the following: A. ptarc(s, ti, q) represents q = W(s, ti) – from rule f 7 construction B. holds(s, qq, k) represents qq = Mk(s) – from i1 construction C. tot decr(s, qqq, k) ∈ A if {del(s, qqq0, t0, k), . . . , del(s, qqqx, tx, k)} ⊆ A –\nfrom rule r4 construction and supported rule proposition D. del(s, qqqi, ti, k) ∈ A if { f ires(ti, k), ptarc(s, ti, qqqi)} ⊆ A – from rule r7\nand supported rule proposition E. del(s, qqqi, ti, k) represents qqqi = W(s, ti) : ti ∈ Tk, (s, ti) ∈ E− – from rule\nf 7 construction F. tot decr(q, qqq, k) represents ∑ ti∈Tk ,s∈•ti W(s, ti) – from (C,D,E) above\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 201\niii. Then firing Tk ∪ {t j} would have required more tokens than are present at its source place s ∈ •t j. Thus, Tk is a maximal set of transitions that can simultaneously fire.\n(d) Then {t0, . . . , tx} = Tk – using 1(a),1(b) above; and using 1(c) it is a maximal firing set\n2. We show Mk+1 is produced by firing Tk in Mk. Let holds(p, q, k + 1) ∈ A\n(a) Then {holds(p, q1, k), tot incr(p, q2, k), tot decr(p, q3, k)} ∈ A : q = q2 + q2 − q3 – from rule r5 and supported rule proposition\n(b) holds(p, q1, k) ∈ A represents q1 = Mk(p) – construction, inductive assumption; and {add(p, q20, t0, k), . . . , add(p, q2 j, t j, k)} ⊆ A : q20 + · · · + q2 j = q2 and {del(p, q30, t0, k), . . . , del(p, q3l, tl, k)} ⊆ A : q30 + · · · + q3l = q3 – from rules r3, r4 using supported rule proposition, respectively\n(c) Then { f ires(t0, k), . . . , f ires(t j, k)} ⊆ A and { f ires(t0, k), . . . , f ires(tl, k)} ⊆ A – from rules r1, r2 using supported rule proposition, respectively\n(d) Then { f ires(t0, k), . . . , f ires(t j, k)}∪{ f ires(t0, k), . . . , f ires(tl, k)} = { f ires(t0, k), . . . , f ires(tx, k)} ⊆ A – subset union property\n(e) Then for each f ires(tx, k) ∈ A we have tx ∈ Tk - already shown in item (1a) above (f) Then q = Mk(p)+ ∑ tx∈Tk∧p∈tx•W(tx, p)− ∑ tx∈Tk∧p∈•tx W(p, tx) – from (2b) above and\nthe following\ni. Each add(p, q j, t j, k) ∈ A represents q j = W(t j, p) for p ∈ t j• – rule r1 encoding and definition 13 of transition execution in PN\nii. Each del(p, ty, qy, k) ∈ A represents qy = W(p, ty) for p ∈ •ty – rule r2 encoding and definition 13 of transition execution in PN\niii. Each tot incr(p, q2, k) ∈ A represents q2 = ∑tx∈Tk∧p∈tx•W(tx, p) – aggregate assignment atom semantics in rule r3\niv. Each tot decr(p, q3, k) ∈ A represents q3 = ∑tx∈Tk∧p∈•tx W(p, tx) – aggregate assignment atom semantics in rule r4\n(g) Then Mk+1(p) = q – since holds(p, q, k + 1) ∈ A encodes q = Mk+1(p) – from construction\nAs a result, for any n > k, Tn will be a valid firing set w.r.t. Mn and its firing produces marking Mn+1.\nConclusion: Since both I and II hold, X = M0,T0,M1, . . . ,Mk,Tk,Mk+1 is an execution sequence of PN(P,T, E,W) (w.r.t. M0) iff there is an answer set A of Π1(PN,M0, k, ntok) such that (A.3) and (A.4) hold.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 202\nA.3 Proof of Proposition 3\nLet PN = (P,T, E,W,R) be a Petri Net, M0 be its initial marking and let Π2(PN,M0, k, ntok) by the ASP encoding of PN and M0 over a simulation length k, with maximum ntok tokens on any place node, as defined in section 2.5. Then X = M0,T0,M1, . . . ,Mk,Tk,Mk+1 is an execution sequence of PN (w.r.t M0) iff there is an answer set A of Π2(PN,M0, k, ntok) such that:\n{ f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} = { f ires(t, ts) : f ires(t, ts) ∈ A} (A.5)\n{holds(p, q, ts) : p ∈ P, q = Mts(p), 0 ≤ ts ≤ k + 1} = {holds(p, q, ts) : holds(p, q, ts) ∈ A}\n(A.6)\nWe prove this by showing that:\n(I) Given an execution sequence X, we create a set A such that it satisfies (A.5) and (A.6) and show that A is an answer set of Π2\n(II) Given an answer set A of Π2, we create an execution sequence X such that (A.5) and (A.6) are satisfied.\nFirst we show (I): Given PN and an execution sequence X of PN, we create a set A as a union of the following sets:\n1. A1 = {num(n) : 0 ≤ n ≤ ntok}\n2. A2 = {time(ts) : 0 ≤ ts ≤ k}\n3. A3 = {place(p) : p ∈ P}\n4. A4 = {trans(t) : t ∈ T }\n5. A5 = {ptarc(p, t, n, ts) : (p, t) ∈ E−, n = W(p, t), 0 ≤ ts ≤ k}, where E− ⊆ E\n6. A6 = {tparc(t, p, n, ts) : (t, p) ∈ E+, n = W(t, p), 0 ≤ ts ≤ k}, where E+ ⊆ E\n7. A7 = {holds(p, q, 0) : p ∈ P, q = M0(p)}\n8. A8 = {notenabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∃p ∈ •t,Mts(p) < W(p, t)} per definition 12 (enabled transition)\n9. A9 = {enabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∀p ∈ •t,W(p, t) ≤ Mts(p)} per definition 12 (enabled transition)\n10. A10 = { f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} per definition 21 (firing set), only an enabled transition may fire\n11. A11 = {add(p, q, t, ts) : t ∈ Tts, p ∈ t•, q = W(t, p), 0 ≤ ts ≤ k} per definition 22 (transition execution)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 203\n12. A12 = {del(p, q, t, ts) : t ∈ Tts, p ∈ •t, q = W(p, t), 0 ≤ ts ≤ k} ∪ {del(p, q, t, ts) : t ∈ Tts, p ∈ R(t), q = Mts(p), 0 ≤ ts ≤ k} per definition 22 (transition execution)\n13. A13 = {tot incr(p, q, ts) : p ∈ P, q = ∑\nt∈Tts,p∈t•W(t, p), 0 ≤ ts ≤ k} per definition 24 (execution)\n14. A14 = {tot decr(p, q, ts) : p ∈ P, q = ∑ t∈Tts,p∈•t W(p, t) + ∑\nt∈Tts,p∈R(t) Mts(p), 0 ≤ ts ≤ k} per definition 24 (execution)\n15. A15 = {consumesmore(p, ts) : p ∈ P, q = Mts(p), q1 = ∑ t∈Tts,p∈•t W(p, t)+ ∑\nt∈Tts,p∈R(t) Mts(p), q1 > q, 0 ≤ ts ≤ k} per definition 23 (conflicting transitions)\n16. A16 = {consumesmore : ∃p ∈ P : q = Mts(p), q1 = ∑ t∈Tts,p∈•t W(p, t)+ ∑\nt∈Tts,p∈R(t) Mts(p), q1 > q, 0 ≤ ts ≤ k} per definition 23 (conflicting transitions)\n17. A17 = {could not have(t, ts) : t ∈ T, (∀p ∈ •t,W(p, t) ≤ Mts(p)), t < Tts, (∃p ∈ •t ∪ R(t) : q > Mts(p) − ( ∑ t′∈Tts,p∈•t′ W(p, t ′) + ∑\nt′∈Tts,p∈R(t′) Mts(p)), q = W(p, t) if p ∈ •t or Mts(p) otherwise ), 0 ≤ ts ≤ k} per the maximal firing set semantics\n18. A18 = {holds(p, q, ts + 1) : p ∈ P, q = Mts+1(p), 0 ≤ ts < k}, where Mts+1(p) = Mts(p) − ( ∑ t∈Tts,p∈•t W(p, t) + ∑ t∈Tts,p∈R(t) Mts(p)) + ∑\nt∈Tts,p∈t•W(t, p) according to definition 24 (firing set execution)\n19. A19 = {ptarc(p, t, n, ts) : p ∈ R(t), n = Mts(p), n > 0, 0 ≤ ts ≤ k}\nWe show that A satisfies (A.5) and (A.6), and A is an answer set of Π1. A satisfies (A.5) and (A.6) by its construction above. We show A is an answer set of Π1 by\nsplitting. We split lit(Π1) into a sequence of 7(k + 1) + 2 sets:\n• U0 = head( f 1) ∪ head( f 2) ∪ head( f 5) ∪ head( f 6) ∪ head(i1) = {place(p) : p ∈ P} ∪ {trans(t) : t ∈ T }∪ {time(0), . . . , time(k)}∪ {num(0), . . . , num(ntok)}∪ {holds(p, q, 0) : p ∈ P, q = M0(p)}\n• U7k+1 = U7k+0 ∪ head( f 7)ts=k ∪ head( f 8)ts=k ∪ head( f 9)ts=k = U7k+0 ∪ {ptarc(p, t, n, k) : (p, t) ∈ E−, n = W(p, t)} ∪ {tparc(t, p, n, k) : (t, p) ∈ E+, n = W(t, p)} ∪ {ptarc(p, t, n, k) : p ∈ R(t), n = Mk(p), n > 0}\n• U7k+2 = U7k+1 ∪ head(e3)ts=k = U7k+1 ∪ {notenabled(t, k) : t ∈ T }\n• U7k+3 = U7k+2 ∪ head(e2)ts=k = U7k+2 ∪ {enabled(t, k) : t ∈ T }\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 204\n• U7k+4 = U7k+3 ∪ head(a1)ts=k = U7k+3 ∪ { f ires(t, k) : t ∈ T }\n• U7k+5 = U7k+4 ∪ head(r6)ts=k ∪ head(r7)ts=k = U7k+4 ∪ {add(p, q, t, k) : p ∈ P, t ∈ T, q = W(t, p)} ∪ {del(p, q, t, k) : p ∈ P, t ∈ T, q = W(p, t)} ∪ {del(p, q, t, k) : p ∈ P, t ∈ T, q = Mk(p)}\n• U7k+6 = U7k+5 ∪ head(r3)ts=k ∪ head(r4)ts=k = U7k+5 ∪ {tot incr(p, q, k) : p ∈ P, 0 ≤ q ≤ ntok} ∪ {tot decr(p, q, k) : p ∈ P, 0 ≤ q ≤ ntok}\n• U7k+7 = U7k+6 ∪ head(r5)ts=k ∪ head(a2)ts=k ∪ head(a7)ts=k = U7k+6 ∪ {consumesmore(p, k) : p ∈ P}∪{holds(p, q, k+1) : p ∈ P, 0 ≤ q ≤ ntok}∪{could not have(t, k) : t ∈ T }\n• U7k+8 = U7k+7 ∪ head(a3) = U7k+7 ∪ {consumesmore}\nwhere head(ri)ts=k are head atoms of ground rule ri in which ts = k. We write Ats=ki = {a(. . . , ts) : a(. . . , ts) ∈ Ai, ts = k} as short hand for all atoms in Ai with ts = k. Uα, 0 ≤ α ≤ 7k + 8 form a splitting sequence, since each Ui is a splitting set of Π1, and 〈Uα〉α<µ is a monotone continuous sequence, where U0 ⊆ U1 · · · ⊆ U7k+8 and ⋃ α<µ Uα = lit(Π1).\nWe compute the answer set of Π2 using the splitting sets as follows:\n1. botU0(Π 2) = f 1 ∪ f 2 ∪ f 5 ∪ i1 ∪ f 6 and X0 = A1 ∪ · · · ∪ A4 ∪ A7 (= U0) is its answer set\n– using forced atom proposition\n2. evalU0(botU1(Π 2) \\ botU0(Π2), X0) = {ptarc(p, t, q, 0):-.|q = W(p, t)} ∪\n{tparc(t, p, q, 0):-.| q = W(t, p)} ∪ {ptarc(p, t, q, 0):-.| q = M0(p)}. Its answer set X1 = Ats=05 ∪ A ts=0 6 ∪ A ts=0 19 – using forced atom proposition and construction of A5, A6, A19.\n3. evalU1(botU2(Π 2) \\ botU1(Π2), X0 ∪ X1) = {notenabled(t, 0):-.|{trans(t),\nptarc(p, t, n, 0), holds(p, q, 0)} ⊆ X0∪X1, where q < n}. Its answer set X2 = Ats=08 – using forced atom proposition and construction of A8.\n(a) where, q = M0(p), and n = W(p, t) for an arc (p, t) ∈ E− – by construction of i1 and f 7 in Π2, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 11 of preset) (c) thus, notenabled(t, 0) ∈ X1 represents ∃p ∈ •t : M0(p) < W(p, t).\n4. evalU2(botU3(Π 2) \\ botU2(Π2), X0 ∪ · · · ∪ X2) = {enabled(t, 0):-.|trans(t) ∈ X0 ∪ · · · ∪\nX2, notenabled(t, 0) < X0 ∪ · · · ∪ X2}. Its answer set is X3 = Ats=09 – using forced atom proposition and construction of A9.\n(a) since an enabled(t, 0) ∈ X3 if @ notenabled(t, 0) ∈ X0 ∪ · · · ∪ X2; which is equivalent to @p ∈ •t : M0(p) < W(p, t) ≡ ∀p ∈ •t : M0(p) ≥ W(p, t).\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 205\n5. evalU3(botU4(Π 2) \\ botU3(Π2), X0 ∪ · · · ∪ X3) = {{ f ires(t, 0)}:-.|enabled(t, 0)\nholds in X0 ∪ · · · ∪ X3}. It has multiple answer sets X4.1, . . . , X4.n, corresponding to elements of power set of f ires(t, 0) atoms in evalU3(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π2 determined using splitting is equal to A, we only consider the set that matches the f ires(t, 0) elements in A and call it X4, ignoring the rest. Thus, X4 = Ats=010 , representing T0.\n(a) in addition, for every t such that enabled(t, 0) ∈ X0 ∪ · · · ∪ X3,R(t) , ∅; f ires(t, 0) ∈ X4 – per definition 21 (firing set); requiring that a reset transition is fired when enabled\n(b) thus, the firing set T0 will not be eliminated by the constraint f 10\n6. evalU4(botU5(Π 2) \\ botU4(Π2), X0 ∪ · · · ∪ X4) = {add(p, n, t, 0):-.|{ f ires(t, 0),\ntparc(t, p, n, 0)} ⊆ X0∪· · ·∪X4}∪{del(p, n, t, 0):-.|{ f ires(t, 0), ptarc(p, t, n, 0)} ⊆ X0∪· · ·∪ X4}. It’s answer set is X5 = Ats=011 ∪ A ts=0 12 – using forced atom proposition and definitions of A11 and A12.\n(a) where, each add atom is equivalent to n = W(t, p) : p ∈ t•, (b) and each del atom is equivalent to n = W(p, t) : p ∈ •t; or n = Mk(p) : p ∈ R(t), (c) representing the effect of transitions in T0 – by construction\n7. evalU5(botU6(Π 2) \\ botU5(Π2), X0 ∪ · · · ∪ X5) = {tot incr(p, qq, 0):-.| qq = ∑ add(p,q,t,0)∈X0∪···∪X5 q} ∪ {tot decr(p, qq, 0):-.|qq = ∑\ndel(p,q,t,0)∈X0∪···∪X5 q}. It’s answer set is X6 = Ats=013 ∪ A ts=0 14 – using forced atom proposition, definitions of A13, A14, and definition 5 (semantics of aggregate assignment atom).\n(a) where, each for tot incr(p, qq, 0), qq = ∑\nadd(p,q,t,0)∈X0∪...X5 q ≡ qq = ∑t∈X4,p∈t•W(p, t),\n(b) and each tot decr(p, qq, 0), qq = ∑\ndel(p,q,t,0)∈X0∪...X5 q ≡ qq = ∑t∈X4,p∈•t W(t, p) + ∑t∈X4,p∈R(t) Mk(p),\n(c) represent the net effect of transitions in T0 – by construction\n8. evalU6(botU7(Π 2) \\ botU6(Π2), X0 ∪ · · · ∪ X6) = {consumesmore(p, 0):-.|\n{holds(p, q, 0), tot decr(p, q1, 0)} ⊆ X0 ∪ · · · ∪ X6, q1 > q} ∪ {holds(p, q, 1):-., | {holds(p, q1, 0), tot incr(p, q2, 0), tot decr(p, q3, 0)} ⊆ X0 ∪ · · · ∪ X6, q = q1 + q2− q3} ∪ {could not have(t, 0):-.|{enabled(t, 0), ptarc(s, t, q), holds(s, qq, 0), tot decr(s, qqq, 0)} ⊆ X0 ∪ · · · ∪ X6, f ires(t, 0) < (X0 ∪ · · · ∪ X6), q > qq − qqq}. It’s answer set is X7 = Ats=015 ∪ A ts=0 17 ∪ A ts=0 18 – using forced atom proposition and definitions of A15, A17, A18.\n(a) where, consumesmore(p, 0) represents ∃p : q = M0(p), q1 =∑ t∈T0,p∈•t W(p, t)+ ∑ t∈T0,p∈R(t) Mk(p), q1 > q, indicating place p will be overcon-\nsumed if T0 is fired – as defined in definition 23 (conflicting transitions)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 206\n(b) and, holds(p, q, 1) represents q = M1(p) – by construction of Π2\n(c) and could not have(t, 0) represents an enabled transition t in T0 that could not fire due to insufficient tokens\n(d) X7 does not contain could not have(t, 0), when enabled(t, 0) ∈ X0 ∪ · · · ∪ X6 and f ires(t, 0) < X0 ∪ · · · ∪ X6 due to construction of A, encoding of a7 and its body atoms. As a result it is not eliminated by the constraint a6\n...\n9. evalU7k+0(botU7k+1(Π 2) \\ botU7k+0(Π2), X0 ∪ · · · ∪ X7k+0) = {ptarc(p, t, q, k):-.|q = W(p, t)} ∪\n{tparc(t, p, q, k):-.|q = W(t, p)} ∪ {ptarc(p, t, q, k):-.|q = M0(p)}. Its answer set X7k+1 = Ats=k5 ∪ A ts=k 6 ∪ A ts=k 19 – using forced atom proposition and construction of A5, A6, A19.\n10. evalU7k+1(botU7k+2(Π 2) \\ botU7k+1(Π2), X0 ∪ X7k+1) = {notenabled(t, k):-.|{trans(t),\nptarc(p, t, n, k), holds(p, q, k)} ⊆ X0 ∪ X7k+1, where q < n}. Its answer set X7k+2 = Ats=k8 – using forced atom proposition and construction of A8.\n(a) where, q = M0(p), and n = W(p, t) for an arc (p, t) ∈ E− – by construction of holds and ptarc predicates in Π2, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 11 of preset) (c) thus, notenabled(t, k) ∈ X7k+1 represents ∃p ∈ •t : M0(p) < W(p, t).\n11. evalU7k+2(botU7k+3(Π 2) \\ botU7k+2(Π2), X0 ∪ · · · ∪ X7k+2) = {enabled(t, k):-.|trans(t) ∈ X0 ∪\n· · · ∪ X7k+2, notenabled(t, k) < X0 ∪ · · · ∪ X7k+2}. Its answer set is X7k+3 = Ats=k9 – using forced atom proposition and construction of A9.\n(a) since an enabled(t, k) ∈ X7k+3 if @ notenabled(t, k) ∈ X0 ∪ · · · ∪ X7k+2; which is equivalent to @p ∈ •t : M0(p) < W(p, t) ≡ ∀p ∈ •t : M0(p) ≥ W(p, t).\n12. evalU7k+3(botU7k+4(Π 2) \\ botU7k+3(Π2), X0 ∪ · · · ∪ X7k+3) = {{ f ires(t, k)}:-.|\nenabled(t, k) holds in X0 ∪ · · · ∪ X7k+3}. It has multiple answer sets X7k+4.1, . . . , X1k+4.n, corresponding to elements of power set of f ires(t, k) atoms in evalU7k+3(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π2 determined using splitting is equal to A, we only consider the set that matches the f ires(t, k) elements in A and call it X7k+4, ignoring the rest. Thus, X7k+4 = Ats=k10 , representing Tk.\n(a) in addition, for every t such that enabled(t, k) ∈ X0∪· · ·∪X7k+3,R(t) , ∅; f ires(t, k) ∈ X7k+4 – per definition 21 (firing set); requiring that a reset transition is fired when enabled\n(b) thus, the firing set Tk will not be eliminated by the constraint f 10\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 207\n13. evalU7k+4(botU7k+5(Π 2) \\ botU7k+4(Π2), X0 ∪ · · · ∪ X7k+4) =\n{add(p, n, t, k):-.|{ f ires(t, k), tparc(t, p, n, k)} ⊆ X0 ∪ · · · ∪ X7k+4} ∪ {del(p, n, t, k):-.|{ f ires(t, k), ptarc(p, t, n, k)} ⊆ X0∪· · ·∪X7k+4}. It’s answer set is X7k+5 = Ats=k11 ∪ A ts=k 12 – using forced atom proposition and definitions of A11 and A12.\n(a) where, each add atom is equivalent to n = W(t, p) : p ∈ •t, (b) and each del atom is equivalent to n = W(p, t) : p ∈ t•; or n = Mk(p) : p ∈ R(t), (c) representing the effect of transitions in Tk\n14. evalU7k+5(botU7k+6(Π 2) \\ botU7k+5(Π2), X0 ∪ · · · ∪ X7k+5) = {tot incr(p, qq, k):-.|qq = ∑add(p,q,t,k)∈X0∪···∪X7k+5 q} ∪ {tot decr(p, qq, k):-.|qq = ∑del(p,q,t,k)∈X0∪···∪X7k+5 q}. It’s answer set is X7k+6 = Ats=k13 ∪Ats=k14 – using forced atom proposition and definitions of A13 and A14.\n(a) where, each tot incr(p, qq, k), qq = ∑\nadd(p,q,t,k)∈X0∪...X7k+5 q ≡ qq = ∑t∈X7k+4,p∈t•W(p, t),\n(b) and each tot decr(p, qq, k), qq = ∑\ndel(p,q,t,k)∈X0∪...X7k+5 q ≡ qq = ∑t∈X7k+4,p∈•t W(t, p) + ∑t∈X7k+4,p∈R(t) Mk(p),\n(c) represent the net effect of transitions in Tk\n15. evalU7k+6(botU7k+7(Π 2) \\ botU7k+6(Π2), X0 ∪ · · · ∪ X7k+6) = {consumesmore(p, k):-.|\n{holds(p, q, k), tot decr(p, q1, k)} ⊆ X0 ∪ · · · ∪ X7k+6, q1 > q} ∪ {holds(p, q, k + 1):-., | {holds(p, q1, k), tot incr(p, q2, k), tot decr(p, q3, k)} ⊆ X0 ∪ · · · ∪ X7k+6, q = q1 + q2 − q3} ∪ {could not have(t, k):-.|{enabled(t, k), ptarc(s, t, q), holds(s, qq, k), tot decr(s, qqq, k)} ⊆ X0 ∪ · · · ∪ X7k+6, f ires(t, k) < (X0 ∪ · · · ∪ X7k+6), q > qq − qqq}. It’s answer set is X7k+7 = Ats=k15 ∪A ts=k 17 ∪A ts=k 18 – using forced atom proposition and definitions of A15, A17, A18.\n(a) where, consumesmore(p, k) represents ∃p : q = M0(p), q1 =∑ t∈T0,p∈•t W(p, t) + ∑ t∈T0,p∈R(t) Mk(p), q1 > q, indicating place p that will be over\nconsumed if Tk is fired, as defined in definition 23 (conflicting transitions)\n(b) holds(p, q, k + 1) represents q = Mk+1(p) – by construction of Π2,\n(c) and could not have(t, k) represents enabled transition t in Tk that could not be fired due to insufficient tokens\n(d) X7k+7 does not contain could not have(t, k), when enabled(t, k) ∈ X0 ∪ · · · ∪ X7k+6 and f ires(t, k) < X0 ∪ · · · ∪ X7k+6 due to the construction of A, encoding of a7 and its body atoms. As a result it is not eliminated by the constraint a6\n16. evalU7k+7(botU7k+8(Π 2) \\ botU7k+7(Π2), X0 ∪ · · · ∪ X7k+7) = {consumesmore:-.|\n{consumesmore(p, 0), . . . , consumesmore(p, k)} ⊆ X0 ∪ · · · ∪ X7k+7}. It’s answer set is X7k+8 = A16 – using forced atom proposition\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 208\n(a) X7k+8 will be empty since none of consumesmore(p, 0), . . . , consumesmore(p, k) hold in X0 ∪ · · · ∪ X7k+7 due to the construction of A, encoding of a2 and its body atoms. As a result, it is not eliminated by the constraint a4\nThe set X = X0 ∪ · · · ∪ X7k+8 is the answer set of Π2 by the splitting sequence theorem 15. Each Xi, 0 ≤ i ≤ 7k + 8 matches a distinct portion of A, and X = A, thus A is an answer set of Π2.\nNext we show (II): Given Π2 be the encoding of a Petri Net PN(P,T, E,W,R) with initial marking M0, and A be an answer set of Π2 that satisfies (A.5) and (A.6), then we can construct X = M0,T0, . . . ,Mk,Tk,Mk+1 from A, such that it is an execution sequence of PN.\nWe construct the X as follows:\n1. Mi = (Mi(p0), . . . ,Mi(pn)), where {holds(p0,Mi(p0), i), . . . holds(pn,Mi(pn), i)} ⊆ A, for 0 ≤ i ≤ k + 1\n2. Ti = {t : f ires(t, i) ∈ A}, for 0 ≤ i ≤ k\nand show that X is indeed an execution sequence of PN. We show this by induction over k (i.e. given Mk, Tk is a valid firing set and its firing produces marking Mk+1).\nBase case: Let k = 0, and M0 is a valid marking in X for PN, show (1) T0 is a valid firing set for M0, and (2) T0’s firing in M0 produces marking M1.\n1. We show T0 is a valid firing set for M0. Let { f ires(t0, 0), . . . , f ires(tx, 0)} be the set of all f ires(. . . , 0) atoms in A,\n(a) Then for each f ires(ti, 0) ∈ A i. enabled(ti, 0) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, 0) < A – from rule e2 and supported rule proposition iii. Then body(e3) must not hold in A – from rule e3 and forced atom proposition iv. Then q ≮ ni ≡ q ≥ ni in e3 for all {holds(p, q, 0), ptarc(p, ti, ni, 0)} ⊆ A – from\ne3, forced atom proposition, and the following A. holds(p, q, 0) ∈ A represents q = M0(p) – rule i1 construction B. ptarc(p, ti, ni, 0) ∈ A represents ni = W(p, ti) – rule f 7 construction; or\nit represents ni = M0(p) – rule f 9 construction; the construction of f 9 ensures that notenabled(t, 0) is never true due to the reset arc\nv. Then ∀p ∈ •ti,M0(p) ≥ W(p, ti) – from definition 11 of preset •ti in PN vi. Then ti is enabled and can fire in PN, as a result it can belong to T0 – from\ndefinition 12 of enabled transition\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 209\n(b) And consumesmore < A, since A is an answer set of Π2 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, 0) ∈ A – from rule a3 and supported rule proposition ii. Then @{holds(p, q, 0), tot decr(p, q1, 0)} ⊆ A : q1 > q in body(a2) – from a2\nand forced atom proposition iii. Then @p : ( ∑ ti∈{t0,...,tx},p∈•ti W(p, ti) + ∑ ti∈{t0,...,tx},p∈R(ti) M0(p)) > M0(p) – from\nthe following A. holds(p, q, 0) represents q = M0(p) – from rule i1 construction, given B. tot decr(p, q1, 0) ∈ A if {del(p, q10, t0, 0), . . . , del(p, q1x, tx, 0)} ⊆ A, where\nq1 = q10 + · · · + q1x – from r4 and forced atom proposition C. del(p, q1i, ti, 0) ∈ A if { f ires(ti, 0), ptarc(p, ti, q1i, 0)} ⊆ A – from r7 and\nsupported rule proposition D. del(p, q1i, ti, 0) either represents removal of q1i = W(p, ti) tokens from\np ∈ •ti; or it represents removal of q1i = M0(p) tokens from p ∈ R(ti)– from rule r7, supported rule proposition, and definition 22 of transition execution in PN\niv. Then the set of transitions in T0 do not conflict – by the definition 23 of conflicting transitions\n(c) And for each enabled(t j, 0) ∈ A and f ires(t j, 0) < A, could not have(t j, 0) ∈ A, since A is an answer set of Π2 - from rule a6 and supported rule proposition\ni. Then {enabled(t j, 0), holds(s, qq, 0), ptarc(s, t j, q, 0), tot decr(s, qqq, 0)} ⊆ A, such that q > qq − qqq and f ires(t j, 0) < A - from rule a7 and supported rule proposition\nii. Then for an s ∈ •t j∪R(t j), q > M0(s)−( ∑ ti∈T0,s∈•ti W(s, ti)+ ∑\nti∈T0,s∈R(ti) M0(s)), where q = W(s, t j) if s ∈ •t j, or M0(s) otherwise - from the following: A. ptarc(s, ti, q, 0) represents q = W(s, ti) if (s, ti) ∈ E− or q = M0(s) if s ∈\nR(ti) – from rule f 7, f 9 construction B. holds(s, qq, 0) represents qq = M0(s) – from i1 construction C. tot decr(s, qqq, 0) ∈ A if {del(s, qqq0, t0, 0), . . . , del(s, qqqx, tx, 0)} ⊆ A –\nfrom rule r4 construction and supported rule proposition D. del(s, qqqi, ti, 0) ∈ A if { f ires(ti, 0), ptarc(s, ti, qqqi, 0)} ⊆ A – from rule r7\nand supported rule proposition E. del(s, qqqi, ti, 0) represents qqqi = W(s, ti) : ti ∈ T0, (s, ti) ∈ E−, or qqqi =\nM0(ti) : ti ∈ T0, s ∈ R(ti) – from rule f 7, f 9 construction F. tot decr(q, qqq, 0) represents ∑ ti∈T0,s∈•ti W(s, ti) +∑\nti∈T0,s∈R(ti) M0(s) – from (C,D,E) above iii. Then firing T0 ∪ {t j} would have required more tokens than are present at its\nsource place s ∈ •t j ∪ R(t j). Thus, T0 is a maximal set of transitions that can simultaneously fire.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 210\n(d) And for each reset transition tr with enabled(tr, 0) ∈ A, f ires(tr, 0) ∈ A, since A is an answer set of Π2 - from rule f 10 and supported rule proposition\ni. Then, the firing set T0 satisfies the reset-transition requirement of definition 21 (firing set)\n(e) Then {t0, . . . , tx} = T0 – using 1(a),1(b),1(d) above; and using 1(c) it is a maximal firing set\n2. We show M1 is produced by firing T0 in M0. Let holds(p, q, 1) ∈ A\n(a) Then {holds(p, q1, 0), tot incr(p, q2, 0), tot decr(p, q3, 0)} ⊆ A : q = q1 + q2 − q3 – from rule r5 and supported rule proposition\n(b) holds(p, q1, 0) ∈ A represents q1 = M0(p) – given, rule i1 construction; and {add(p, q20, t0, 0), . . . , add(p, q2 j, t j, 0)} ⊆ A : q20+· · ·+q2 j = q2 and {del(p, q30, t0, 0), . . . , del(p, q3l, tl, 0)} ⊆ A : q30 + · · · + q3l = q3 – rules r3, r4 using supported rule proposition\n(c) Then { f ires(t0, 0), . . . , f ires(t j, 0)} ⊆ A and { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A – rules r6, r7 and supported rule proposition, respectively\n(d) Then { f ires(t0, 0), . . . , f ires(t j, 0)}∪{ f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A = { f ires(t0, 0), . . . , f ires(tx, 0)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, 0) ∈ A we have tx ∈ T0 – already shown in item 1 above (f) Then q = M0(p) + ∑ tx∈T0∧p∈tx•W(tx, p) − ( ∑ tx∈T0∧p∈•tx W(p, tx) +∑\ntx∈T0∧p∈R(tx) M0(p)) – from (2a),(2b) (2b) above and the following i. Each add(p, q j, t j, 0) ∈ A represents q j = W(t j, p) for p ∈ t j• – rule r6 encoding, and definition 11 of postset in PN\nii. Each del(p, ty, qy, 0) ∈ A represents either qy = W(p, ty) for p ∈ •ty, or qy = M0(p) for p ∈ R(ty) – from rule r7, f 7 encoding and definition 11 of preset in PN; or from rule r7, f 9 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2, 0) ∈ A represents q2 = ∑tx∈T0∧p∈tx•W(tx, p) – aggregate assignment atom semantics in rule r3\niv. Each tot decr(p, q3, 0) ∈ A represents q3 = ∑tx∈T0∧p∈•tx W(p, tx)+ ∑tx∈T0∧p∈R(tx) M0(p) – aggregate assignment atom semantics in rule r4\n(g) Then M1(p) = q – since holds(p, q, 1) ∈ A encodes q = M1(p) – from construction\nInductive Step: Let k > 0, and Mk is a valid marking in X for PN, show (1) Tk is a valid firing set in Mk, and (2) firing Tk in Mk produces marking Mk+1.\n1. We show that Tk is a valid firing set in Mk. Let { f ires(t0, k), . . . , f ires(tx, k)} be the set of all f ires(. . . , k) atoms in A,\n(a) Then for each f ires(ti, k) ∈ A i. enabled(ti, k) ∈ A – from rule a1 and supported rule proposition\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 211\nii. Then notenabled(ti, k) < A – from rule e2 and supported rule proposition iii. Then body(e3) must not hold in A – from rule e3 and forced atom proposition iv. Then q ≮ ni ≡ q ≥ ni in e3 for all {holds(p, q, k), ptarc(p, ti, ni, k)} ⊆ A – from\ne3, forced atom proposition, and the following A. holds(p, q, k) ∈ A represents q = Mk(p) – construction, inductive assump-\ntion B. ptarc(p, ti, ni, k) ∈ A represents ni = W(p, ti) – rule f 7 construction; or\nit represents ni = Mk(p) – rule f 9 construction; the construction of f 9 ensures that notenabled(t, 0) is never true due to the reset arc\nv. Then ∀p ∈ •ti,Mk(p) ≥ W(p, ti) – from definition 11 of preset •ti in PN vi. Then ti is enabled and can fire in PN, as a result it can belong to Tk – from\ndefinition 12 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π2 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, k) ∈ A – from rule a3 and supported rule proposition ii. Then @{holds(p, q, k), tot decr(p, q1, k)} ⊆ A : q1 > q in body(a2) – from a2\nand forced atom proposition iii. Then @p : ( ∑ ti∈{t0,...,tx},p∈•ti W(p, ti) + ∑ ti∈{t0,...,tx},p∈R(ti) Mk(p)) > Mk(p) – from\nthe following A. holds(p, q, k) represents q = Mk(p) – inductive assumption, given B. tot decr(p, q1, k) ∈ A if {del(p, q10, t0, k), . . . , del(p, q1x, tx, k)} ⊆ A, where\nq1 = q10 + · · · + q1x – from r4 and forced atom proposition C. del(p, q1i, ti, k) ∈ A if { f ires(ti, k), ptarc(p, ti, q1i, k)} ⊆ A – from r7 and\nsupported rule proposition D. del(p, q1i, ti, k) either represents removal of q1i = W(p, ti) tokens from\np ∈ •ti; or it represents removal of q1i = Mk(p) tokens from p ∈ R(ti)– from rule r7, supported rule proposition, and definition 22 of transition execution in PN\niv. Then the set of transitions in Tk do not conflict – by the definition 23 of conflicting transitions\n(c) And for each enabled(t j, k) ∈ A and f ires(t j, k) < A, could not have(t j, k) ∈ A, since A is an answer set of Π2 - from rule a6 and supported rule proposition\ni. Then {enabled(t j, k), holds(s, qq, k), ptarc(s, t j, q, k), tot decr(s, qqq, k)} ⊆ A, such that q > qq − qqq and f ires(t j, k) < A - from rule a7 and supported rule proposition\nii. Then for an s ∈ •t j∪R(t j), q > Mk(s)−( ∑ ti∈Tk ,s∈•ti W(s, ti)+ ∑\nti∈Tk ,s∈R(ti) Mk(s)), where q = W(s, t j) if s ∈ •t j, or Mk(s) otherwise - from the following: A. ptarc(s, ti, q, k) represents q = W(s, ti) if (s, ti) ∈ E− or q = Mk(s) if s ∈\nR(ti) – from rule f 7, f 9 construction\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 212\nB. holds(s, qq, k) represents qq = Mk(s) – construction C. tot decr(s, qqq, k) ∈ A if {del(s, qqq0, t0, k), . . . , del(s, qqqx, tx, k)} ⊆ A –\nfrom rule r4 construction and supported rule proposition D. del(s, qqqi, ti, k) ∈ A if { f ires(ti, k), ptarc(s, ti, qqqi, k)} ⊆ A – from rule r7\nand supported rule proposition E. del(s, qqqi, ti, k) represents qqqi = W(s, ti) : ti ∈ Tk, (s, ti) ∈ E−, or qqqi =\nMk(ti) : ti ∈ Tk, s ∈ R(ti) – from rule f 7, f 9 construction F. tot decr(q, qqq, k) represents ∑ ti∈Tk ,s∈•ti W(s, ti) +∑\nti∈Tk ,s∈R(ti) Mk(s) – from (C,D,E) above iii. Then firing Tk ∪ {t j} would have required more tokens than are present at its\nsource place s ∈ •t j ∪ R(t j). Thus, Tk is a maximal set of transitions that can simultaneously fire.\n(d) And for each reset transition tr with enabled(tr, k) ∈ A, f ires(tr, k) ∈ A, since A is an answer set of Π2 - from rule f 10 and supported rule proposition\ni. Then the firing set Tk satisfies the reset transition requirement of definition 21 (firing set)\n(e) Then {t0, . . . , tx} = Tk – using 1(a),1(b), 1(d) above; and using 1(c) it is a maximal firing set\n2. We show that Mk+1 is produced by firing Tk in Mk. Let holds(p, q, k + 1) ∈ A\n(a) Then {holds(p, q1, k), tot incr(p, q2, k), tot decr(p, q3, k)} ⊆ A : q = q1 + q2 − q3 – from rule r5 and supported rule proposition\n(b) holds(p, q1, k) ∈ A represents q1 = Mk(p) – construction, inductive assumption; and {add(p, q20, t0, k), . . . , add(p, q2 j, t j, k)} ⊆ A : q20 + · · · + q2 j = q2 and {del(p, q30, t0, k), . . . , del(p, q3l, tl, k)} ⊆ A : q30 + · · · + q3l = q3 – rules r3, r4 using supported rule proposition\n(c) Then { f ires(t0, k), . . . , f ires(t j, k)} ⊆ A and { f ires(t0, k), . . . , f ires(tl, k)} ⊆ A – rules r6, r7 and supported rule proposition, respectively\n(d) Then { f ires(t0, k), . . . , f ires(t j, k)}∪{ f ires(t0, k), . . . , f ires(tl, k)} ⊆ A = { f ires(t0, k), . . . , f ires(tx, k)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, k) ∈ A we have tx ∈ Tk – already shown in item 1 above (f) Then q = Mk(p) + ∑ tx∈T0∧p∈tx•W(tx, p) − ( ∑ tx∈Tk∧p∈•tx W(p, tx) +∑\ntx∈Tk∧p∈R(tx) Mk(p)) – from (2b) above and the following i. Each add(p, q j, t j, k) ∈ A represents q j = W(t j, p) for p ∈ t j• – rule r6 encoding, and definition 22 of transition execution in PN\nii. Each del(p, ty, qy, k) ∈ A represents either qy = W(p, ty) for p ∈ •ty, or qy = Mk(p) for p ∈ R(ty) – from rule r7, f 7 encoding and definition 22 of transition execution in PN; or from rule r7, f 9 encoding and definition of reset arc in PN\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 213\niii. Each tot incr(p, q2, k) ∈ A represents q2 = ∑tx∈Tk∧p∈tx•W(tx, p) – aggregate assignment atom semantics in rule r3\niv. Each tot decr(p, q3, 0) ∈ A represents q3 = ∑tx∈Tk∧p∈•tx W(p, tx)+ ∑tx∈Tk∧p∈R(tx) M0(p) – aggregate assignment atom semantics in rule r4\n(g) Then, Mk+1(p) = q – since holds(p, q, k + 1) ∈ A encodes q = Mk+1(p) – from construction\nAs a result, for any n > k, Tn is a valid firing set w.r.t. Mn and its firing produces marking Mn+1. Conclusion: Since both (I) and (II) hold, X = M0,T0,M1, . . . ,Mk,Tk+1 is an execution sequence of PN(P,T, E,W,R) (w.r.t M0) iff there is an answer set A of Π2(PN,M0, k, ntok) such that (A.5) and (A.6) hold.\nA.4 Poof of Proposition 4\nLet PN = (P,T, E,W,R, I) be a Petri Net, M0 be its initial marking and let Π3(PN,M0, k, ntok) be the ASP encoding of PN and M0 over a simulation length k, with maximum ntok tokens on any place node, as defined in section 2.6. Then X = M0,T0,M1, . . . ,Mk,Tk,Mk+1 is an execution sequence of PN (w.r.t. M0) iff there is an answer set A of Π3(PN,M0, k, ntok) such that:\n{ f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} = { f ires(t, ts) : f ires(t, ts) ∈ A} (A.7) {holds(p, q, ts) : p ∈ P, q = Mts(p), 0 ≤ ts ≤ k + 1}\n= {holds(p, q, ts) : holds(p, q, ts) ∈ A} (A.8)\nWe prove this by showing that:\n(I) Given an execution sequence X, we create a set A such that it satisfies (A.7) and (A.4) and show that A is an answer set of Π3\n(II) Given an answer set A of Π3, we create an execution sequence X such that (A.3) and (A.8) are satisfied.\nFirst we show (I): Given PN and an execution sequence X of PN, we create a set A as a union of the following sets:\n1. A1 = {num(n) : 0 ≤ n ≤ ntok}\n2. A2 = {time(ts) : 0 ≤ ts ≤ k}\n3. A3 = {place(p) : p ∈ P}\n4. A4 = {trans(t) : t ∈ T }\n5. A5 = {ptarc(p, t, n, ts) : (p, t) ∈ E−, n = W(p, t), 0 ≤ ts ≤ k}, where E− ⊆ E\n6. A6 = {tparc(t, p, n, ts) : (t, p) ∈ E+, n = W(t, p), 0 ≤ ts ≤ k}, where E+ ⊆ E\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 214\n7. A7 = {holds(p, q, 0) : p ∈ P, q = M0(p)}\n8. A8 = {notenabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k, (∃p ∈ •t,Mts(p) < W(p, t)) ∨ (∃p ∈ I(t),Mts(p) , 0)} per definition 26 (enabled transition)\n9. A9 = {enabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k, (∀p ∈ •t,W(p, t) ≤ Mts(p)) ∧ (∀p ∈ I(t),Mts(p) = 0)} per definition 26 (enabled transition)\n10. A10 = { f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} per definition 21 (firing set), only an enabled transition may fire\n11. A11 = {add(p, q, t, ts) : t ∈ Tts, p ∈ t•, q = W(t, p), 0 ≤ ts ≤ k} per definition 22 (transition execution)\n12. A12 = {del(p, q, t, ts) : t ∈ Tts, p ∈ •t, q = W(p, t), 0 ≤ ts ≤ k} ∪ {del(p, q, t, ts) : t ∈ Tts, p ∈ R(t), q = Mts(p), 0 ≤ ts ≤ k} per definition 24 (transition execution)\n13. A13 = {tot incr(p, q, ts) : p ∈ P, q = ∑\nt∈Tts,p∈t•W(t, p), 0 ≤ ts ≤ k} per definition 24 (firing set execution)\n14. A14 = {tot decr(p, q, ts) : p ∈ P, q = ∑ t∈Tts,p∈•t W(p, t) + ∑\nt∈Tts,p∈R(t) Mts(p), 0 ≤ ts ≤ k} per definition 24 (firing set execution)\n15. A15 = {consumesmore(p, ts) : p ∈ P, q = Mts(p), q1 = ∑ t∈Tts,p∈•t W(p, t)+ ∑\nt∈Tts,p∈R(t) Mts(p), q1 > q, 0 ≤ ts ≤ k} per definition 23 (conflicting transitions)\n16. A16 = {consumesmore : ∃p ∈ P : q = Mts(p), q1 = ∑ t∈Tts,p∈•t W(p, t)+ ∑\nt∈Tts,p∈R(t)(Mts(p)), q1 > q, 0 ≤ ts ≤ k} per definition 23 (conflicting transitions)\n17. A17 = {could not have(t, ts) : t ∈ T, (∀p ∈ •t,W(p, t) ≤ Mts(p)), t < Tts, (∃p ∈ •t : W(p, t) > Mts(p) − ( ∑ t′∈Tts,p∈•t′ W(p, t ′) + ∑\nt′∈Tts,p∈R(t′) Mts(p)), 0 ≤ ts ≤ k} per the maximal firing set semantics\n18. A18 = {holds(p, q, ts + 1) : p ∈ P, q = Mts+1(p), 0 ≤ ts < k}, where Mts+1(p) = Mts(p) − ( ∑ t∈Tts,p∈•t W(p, t)+ ∑ t∈Tts,p∈R(t) Mts(p)) +∑\nt∈Tts,p∈t•W(t, p) according to definition 21 (firing set execution)\n19. A19 = {ptarc(p, t, n, ts) : p ∈ R(t), n = Mts(p), n > 0, 0 ≤ ts ≤ k}\n20. A20 = {iptarc(p, t, 1, ts) : p ∈ P, 0 ≤ ts < k}\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 215\nWe show that A satisfies (A.7) and (A.8), and A is an answer set of Π3. A satisfies (A.7) and (A.8) by its construction above. We show A is an answer set of Π3 by splitting. We split lit(Π3) into a sequence of 7k + 9 sets:\n• U0 = head( f 1) ∪ head( f 2) ∪ head( f 5) ∪ head( f 6) ∪ head(i1) = {place(p) : p ∈ P} ∪ {trans(t) : t ∈ T }∪ {time(0), . . . , time(k)}∪ {num(0), . . . , num(ntok)}∪ {holds(p, q, 0) : p ∈ P, q = M0(p)}\n• U7k+1 = U7k+0 ∪ head( f 7)ts=k ∪ head( f 8)ts=k ∪ head( f 9)ts=k ∪ head( f 11)ts=k = U7k+0 ∪ {ptarc(p, t, n, k) : (p, t) ∈ E−, n = W(p, t)} ∪ {tparc(t, p, n, k) : (t, p) ∈ E+, n = W(t, p)} ∪ {ptarc(p, t, n, k) : p ∈ R(t), n = Mk(p), n > 0} ∪ {iptarc(p, t, 1, k) : p ∈ I(t)}\n• U7k+2 = U7k+1 ∪ head(e3)ts=k ∪ head(e4)ts=k = U7k+1 ∪ {notenabled(t, k) : t ∈ T }\n• U7k+3 = U7k+2 ∪ head(e2)ts=k = U7k+2 ∪ {enabled(t, k) : t ∈ T }\n• U7k+4 = U7k+3 ∪ head(a1)ts=k = U7k+3 ∪ { f ires(t, k) : t ∈ T }\n• U7k+5 = U7k+4 ∪ head(r6)ts=k ∪ head(r7)ts=k = U7k+4 ∪ {add(p, q, t, k) : p ∈ P, t ∈ T, q = W(t, p)} ∪ {del(p, q, t, k) : p ∈ P, t ∈ T, q = W(p, t)} ∪ {del(p, q, t, k) : p ∈ P, t ∈ T, q = Mk(p)}\n• U7k+6 = U7k+5 ∪ head(r3)ts=k ∪ head(r4)ts=k = U7k+5 ∪ {tot incr(p, q, k) : p ∈ P, 0 ≤ q ≤ ntok} ∪ {tot decr(p, q, k) : p ∈ P, 0 ≤ q ≤ ntok}\n• U7k+7 = U7k+6 ∪ head(r5)ts=k ∪ head(a2)ts=k ∪ head(a7)ts=k = U7k+6 ∪ {consumesmore(p, k) : p ∈ P}∪{holds(p, q, k+1) : p ∈ P, 0 ≤ q ≤ ntok}∪{could not have(t, k) : t ∈ T }\n• U7k+8 = U7k+7 ∪ head(a3)ts=k = U7k+7 ∪ {consumesmore}\nwhere head(ri)ts=k are head atoms of ground rule ri in which ts = k. We write Ats=ki = {a(. . . , ts) : a(. . . , ts) ∈ Ai, ts = k} as short hand for all atoms in Ai with ts = k. Uα, 0 ≤ α ≤ 7k + 8 form a splitting sequence, since each Ui is a splitting set of Π1, and 〈Uα〉α<µ is a monotone continuous sequence, where U0 ⊆ U1 · · · ⊆ U7k+8 and ⋃ α<µ Uα = lit(Π1).\nWe compute the answer set of Π3 using the splitting sets as follows:\n1. botU0(Π 3) = f 1 ∪ f 2 ∪ f 5 ∪ i1 ∪ f 6 and X0 = A1 ∪ · · · ∪ A4 ∪ A7 (= U0) is its answer set\n– using forced atom proposition\n2. evalU0(botU1(Π 3) \\ botU0(Π3), X0) = {ptarc(p, t, q, 0):-.|q = W(p, t)} ∪\n{tparc(t, p, q, 0):-.|q = W(t, p)} ∪ {ptarc(p, t, q, 0):-.|q = M0(p)} ∪ {iptarc(p, t, 1, 0):-.}. Its answer set X1 = Ats=05 ∪ A ts=0 6 ∪ A ts=0 19 ∪ A ts=0 20 – using forced atom proposition and construction of A5, A6, A19, A20.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 216\n3. evalU1(botU2(Π 3) \\ botU1(Π3), X0 ∪ X1) = {notenabled(t, 0):-.|({trans(t),\nptarc(p, t, n, 0), holds(p, q, 0)} ⊆ X0 ∪ X1, where q < n) or {notenabled(t, 0):-.| ({trans(t), iptarc(p, t, n2, 0), holds(p, q, 0)} ⊆ X0 ∪ X1, where q ≥ n2}}. Its answer set X2 = Ats=08 – using forced atom proposition and construction of A8.\n(a) where, q = M0(p), and n = W(p, t) for an arc (p, t) ∈ E− – by construction i1 and f 7 in Π3, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 11 of preset) (c) n2 = 1 – by construction of iptarc predicates in Π3, meaning q ≥ n2 ≡ q ≥ 1 ≡ q >\n0,\n(d) thus, notenabled(t, 0) ∈ X1 represents (∃p ∈ •t : M0(p) < W(p, t)) ∨ (∃p ∈ I(t) : M0(p) > 0).\n4. evalU2(botU3(Π 3) \\ botU2(Π3), X0 ∪ · · · ∪ X2) = {enabled(t, 0):-.|trans(t) ∈ X0 ∪ · · · ∪\nX2, notenabled(t, 0) < X0 ∪ · · · ∪ X2}. Its answer set is X3 = Ats=09 – using forced atom proposition and construction of A9.\n(a) since an enabled(t, 0) ∈ X3 if @ notenabled(t, 0) ∈ X0 ∪ · · · ∪ X2; which is equivalent to (@p ∈ •t : M0(p) < W(p, t)) ∧ (@p ∈ I(t) : M0(p) > 0) ≡ (∀p ∈ •t : M0(p) ≥ W(p, t)) ∧ (∀p ∈ I(t) : M0(p) = 0).\n5. evalU3(botU4(Π 3) \\ botU3(Π3), X0 ∪ · · · ∪ X3) = {{ f ires(t, 0)}:-.|enabled(t, 0)\nholds in X0 ∪ · · · ∪ X3}. It has multiple answer sets X4.1, . . . , X4.n, corresponding to elements of power set of f ires(t, 0) atoms in evalU3(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π3 determined using splitting is equal to A, we only consider the set that matches the f ires(t, 0) elements in A and call it X4, ignoring the rest. Thus, X4 = Ats=010 , representing T0.\n(a) in addition, for every t such that enabled(t, 0) ∈ X0 ∪ · · · ∪ X3,R(t) , ∅; f ires(t, 0) ∈ X4 – per definition 21 (firing set); requiring that a reset transition is fired when enabled\n(b) thus, the firing set T0 will not be eliminated by the constraint f 10\n6. evalU4(botU5(Π 3) \\ botU4(Π3), X0 ∪ · · · ∪ X4) = {add(p, n, t, 0):-.|{ f ires(t, 0),\ntparc(t, p, n, 0)} ⊆ X0 ∪ · · · ∪ X4} ∪ {del(p, n, t, 0):-.|{ f ires(t, 0), ptarc(p, t, n, 0)} ⊆ X0 ∪ · · · ∪ X4}. It’s answer set is X5 = Ats=011 ∪ A ts=0 12 – using forced atom proposition and definitions of A11 and A12.\n(a) where, each add atom is equivalent to n = W(t, p) : p ∈ t•, (b) and each del atom is equivalent to n = W(p, t) : p ∈ •t; or n = Mk(p) : p ∈ R(t), (c) representing the effect of transitions in T0.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 217\n7. evalU5(botU6(Π 3) \\ botU5(Π3), X0 ∪ · · · ∪ X5) = {tot incr(p, qq, 0):-.| qq = ∑ add(p,q,t,0)∈X0∪···∪X5 q} ∪ {tot decr(p, qq, 0):-.|qq = ∑\ndel(p,q,t,0)∈X0∪···∪X5 q}. It’s answer set is X6 = Ats=013 ∪ A ts=0 14 – using forced atom proposition and definitions of A13 and A14.\n(a) where, each tot incr(p, qq, 0), qq = ∑\nadd(p,q,t,0)∈X0∪...X5 q ≡ qq = ∑t∈X4,p∈t•W(p, t),\n(b) and each tot decr(p, qq, 0), qq = ∑\ndel(p,q,t,0)∈X0∪...X5 q ≡ qq = ∑t∈X4,p∈•t W(t, p) + ∑t∈X4,p∈R(t) Mk(p),\n(c) represent the net effect of transitions in T0.\n8. evalU6(botU7(Π 3) \\ botU6(Π3), X0 ∪ · · · ∪ X6) = {consumesmore(p, 0):-.|\n{holds(p, q, 0), tot decr(p, q1, 0)} ⊆ X0 ∪ · · · ∪ X6, q1 > q} ∪ {holds(p, q, 1):-., | {holds(p, q1, 0), tot incr(p, q2, 0), tot decr(p, q3, 0)} ⊆ X0 ∪ · · · ∪ X6, q = q1 + q2− q3} ∪ {could not have(t, 0):-.|{enabled(t, 0), ptarc(s, t, q), holds(s, qq, 0), tot decr(s, qqq, 0)} ⊆ X0 ∪ · · · ∪ X6, f ires(t, 0) < (X0 ∪ · · · ∪ X6), q > qq − qqq}. It’s answer set is X7 = Ats=015 ∪ A ts=0 17 ∪ A ts=0 18 – using forced atom proposition and definitions of A15, A17, A18, A9.\n(a) where, consumesmore(p, 0) represents ∃p : q = M0(p), q1 =∑ t∈T0,p∈•t W(p, t) + ∑ t∈T0,p∈R(t) Mk(p), q1 > q, indicating place p will be over con-\nsumed if T0 is fired, as defined in definition 23 (conflicting transitions)\n(b) holds(p, q, 1) represents q = M1(p) – by construction of Π3\n(c) and could not have(t, 0) represents enabled transition t ∈ T0 that could not fire due to insufficient tokens\n(d) X7 does not contain could not have(t, 0), when enabled(t, 0) ∈ X0 ∪ · · · ∪ X5 and f ires(t, 0) < X0 ∪ · · · ∪ X6 due to construction of A, encoding of a7 and its body atoms. As a result it is not eliminated by the constraint a6\n...\n9. evalU7k+0(botU7k+1(Π 3) \\ botU7k+0(Π3), X0 ∪ · · · ∪ X7k+0) = {ptarc(p, t, q, k):-.|q = W(p, t)} ∪\n{tparc(t, p, q, k):-.|q = W(t, p)} ∪ {ptarc(p, t, q, k):-.|q = Mk(p)} ∪ {iptarc(p, t, 1, k):-.}. Its answer set X7k+1 = Ats=k5 ∪ A ts=k 6 ∪ A ts=k 19 ∪ A ts=k 20 – using forced atom proposition and construction of A5, A6, A19, A20.\n10. evalU7k+1(botU7k+2(Π 3) \\ botU7k+1(Π3), X0 ∪ · · · ∪ X7k+1) = {notenabled(t, k):-.|\n({trans(t), ptarc(p, t, n, k), holds(p, q, k)} ⊆ X0∪· · ·∪X7k+1, where q < n)} or {notenabled(t, k):-.|({trans(t), iptarc(p, t, n2, k), holds(p, q, k)} ⊆\nX0 ∪ · · · ∪ X7k+1, where q ≥ n2}}. Its answer set X7k+2 = Ats=k8 – using forced atom proposition and construction of A8.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 218\n(a) where, q = Mk(p), and n = W(p, t) for an arc (p, t) ∈ E− – by construction of holds and ptarc predicates in Π3, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 11 of preset) (c) n2 = 1 – by construction of iptarc predicates in Π3, meaning q ≥ n2 ≡ q ≥ 1 ≡ q >\n0,\n(d) thus, notenabled(t, k) ∈ X7k+1 represents (∃p ∈ •t : Mk(p) < W(p, t)) ∨ (∃p ∈ I(t) : Mk(p) > k).\n11. evalU7k+2(botU7k+3(Π 3) \\ botU7k+2(Π3), X0 ∪ · · · ∪ X7k+2) = {enabled(t, k):-.|\ntrans(t) ∈ X0 ∪ · · · ∪ X7k+2 ∧ notenabled(t, k) < X0 ∪ · · · ∪ X7k+2}. Its answer set is X7k+3 = Ats=k9 – using forced atom proposition and construction of A9.\n(a) since an enabled(t, k) ∈ X7k+3 if @ notenabled(t, k) ∈ X0 ∪ · · · ∪ X7k+2; which is equivalent to (@p ∈ •t : Mk(p) < W(p, t)) ∧ (@p ∈ I(t) : Mk(p) > k) ≡ (∀p ∈ •t : Mk(p) ≥ W(p, t)) ∧ (∀p ∈ I(t) : Mk(p) = k).\n12. evalU7k+3(botU7k+4(Π 3) \\ botU7k+3(Π3), X0 ∪ · · · ∪ X7k+3) = {{ f ires(t, k)}:-.|\nenabled(t, k) holds in X0 ∪ · · · ∪ X7k+3}. It has multiple answer sets X7k+4.1, . . . , X1k+4.n, corresponding to elements of power set of f ires(t, k) atoms in evalU7k+3(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π3 determined using splitting is equal to A, we only consider the set that matches the f ires(t, k) elements in A and call it X7k+4, ignoring the rest. Thus, X7k+4 = Ats=k10 , representing Tk.\n(a) in addition, for every t such that enabled(t, k) ∈ X0∪· · ·∪X7k+3,R(t) , ∅; f ires(t, k) ∈ X7k+4 – per definition 21 (firing set); requiring that a reset transition is fired when enabled\n(b) thus, the firing set Tk will not be eliminated by the constraint f 10\n13. evalU7k+4(botU7k+5(Π 3) \\ botU7k+4(Π3), X0 ∪ · · · ∪ X7k+4) = {add(p, n, t, k):-.|\n{ f ires(t, k), tparc(t, p, n, k)} ⊆ X0 ∪ · · · ∪ X7k+4} ∪ {del(p, n, t, k):-.|{ f ires(t, k), ptarc(p, t, n, k)} ⊆ X0∪· · ·∪X7k+4}. It’s answer set is X7k+5 = Ats=k11 ∪A ts=k 12 – using forced atom proposition and definitions of A11 and A12.\n(a) where, each add atom is equivalent to n = W(t, p) : p ∈ t•, (b) and each del atom is equivalent to n = W(p, t) : p ∈ •t; or n = Mk(p) : p ∈ R(t), (c) representing the effect of transitions in Tk\n14. evalU7k+5(botU7k+6(Π 3) \\ botU7k+5(Π3), X0 ∪ · · · ∪ X7k+5) = {tot incr(p, qq, k):-.| qq = ∑add(p,q,t,k)∈X0∪···∪X7k+5 q}∪ {tot decr(p, qq, k):-.| qq = ∑del(p,q,t,k)∈X0∪···∪X7k+5 q}. It’s answer set is X7k+6 = Ats=k13 ∪ A ts=k 14 – using forced atom proposition and definitions of\nA13 and A14.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 219\n(a) where, each tot incr(p, qq, k), qq = ∑\nadd(p,q,t,k)∈X0∪...X7k+5 q ≡ qq = ∑t∈X7k+4,p∈t•W(p, t),\n(b) and each tot decr(p, qq, k), qq = ∑\ndel(p,q,t,k)∈X0∪...X7k+5 q ≡ qq = ∑t∈X7k+4,p∈•t W(t, p) + ∑t∈X7k+4,p∈R(t) Mk(p),\n(c) representing the net effect of transitions in Tk\n15. evalU7k+6(botU7k+7(Π 3) \\ botU7k+6(Π3), X0 ∪ · · · ∪ X7k+6) = {consumesmore(p, k):-.|\n{holds(p, q, k), tot decr(p, q1, k)} ⊆ X0 ∪ · · · ∪ X7k+6, q1 > q} ∪ {holds(p, q, 1):-., | {holds(p, q1, k), tot incr(p, q2, k), tot decr(p, q3, k)} ⊆ X0 ∪ · · · ∪ X7k+6, q = q1 + q2 − q3} ∪ {could not have(t, k):-.|{enabled(t, k), ptarc(s, t, q), holds(s, qq, k), tot decr(s, qqq, k)} ⊆ X0 ∪ · · · ∪ X7k+6, f ires(t, k) < (X0 ∪ · · · ∪ X7k+6), q > qq − qqq}. It’s answer set is X7k+7 = Ats=k15 ∪A ts=k 17 ∪A ts=k 18 – using forced atom proposition and definitions of A15, A17, A18, A9.\n(a) where, consumesmore(p, k) represents ∃p : q = Mk(p), q1 = ∑ t∈Tk ,p∈•t W(p, t) + ∑ t∈Tk ,p∈R(t) Mk(p), q1 > q, indicating place p that will be\nover consumed if Tk is fired, as defined in definition 23 (conflicting transitions),\n(b) holds(p, q, k + 1) represents q = Mk+1(p) – by construction of Π3\n(c) and could not have(t, k) represents enabled transition t in Tk that could not be fired due to insufficient tokens\n(d) X7k+7 does not contain could not have(t, k), when enabled(t, k) ∈ X0 ∪ · · · ∪ X7k+6 and f ires(t, k) < X0 ∪ · · · ∪ X7k+6 due to construction of A, encoding of a7 and its body atoms. As a result it is not eliminated by the constraint a6\n16. evalU7k+7(botU7k+8(Π 3) \\ botU7k+7(Π3), X0 ∪ · · · ∪ X7k+7) = {consumesmore:-.|\n{consumesmore(p, 0), . . . , consumesmore(p, k)} ∩ (X0 ∪ · · · ∪ X7k+7) , ∅}. It’s answer set is X7k+8 = A16 – using forced atom proposition\n(a) X7k+8 will be empty since none of consumesmore(p, 0), . . . , consumesmore(p, k) hold in X0 ∪ · · · ∪ X7k+7 due to the construction of A, encoding of a2 and its body atoms. As a result, it is not eliminated by the constraint a4\nThe set X = X0 ∪ · · · ∪ X7k+8 is the answer set of Π3 by the splitting sequence theorem 15. Each Xi, 0 ≤ i ≤ 7k + 8 matches a distinct portion of A, and X = A, thus A is an answer set of Π3.\nNext we show (II): Given Π3 be the encoding of a Petri Net PN(P,T, E,W,R, I) with initial marking M0, and A be an answer set of Π3 that satisfies (A.7) and (A.8), then we can construct X = M0,T0, . . . ,Mk,Tk,Mk+1 from A, such that it is an execution sequence of PN.\nWe construct the X as follows:\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 220\n1. Mi = (Mi(p0), . . . ,Mi(pn)), where {holds(p0,Mi(p0), i), . . . holds(pn,Mi(pn), i)} ⊆ A, for 0 ≤ i ≤ k + 1\n2. Ti = {t : f ires(t, i) ∈ A}, for 0 ≤ i ≤ k\nand show that X is indeed an execution sequence of PN. We show this by induction over k (i.e. given Mk, Tk is a valid firing set and its firing produces marking Mk+1).\nBase case: Let k = 0, and M0 is a valid marking in X for PN, show (1) T0 is a valid firing set for M0, and (2) M1 is T0’s target marking w.r.t. M0.\n1. We show T0 is a valid firing set for M0. Let { f ires(t0, 0), . . . , f ires(tx, 0)} be the set of all f ires(. . . , 0) atoms in A,\n(a) Then for each f ires(ti, 0) ∈ A i. enabled(ti, 0) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, 0) < A – from rule e2 and supported rule proposition iii. Then body(e3) must not hold in A and body(e4) must not hold in A – from rules\ne3, e4 and forced atom proposition iv. Then q ≮ ni ≡ q ≥ ni in e3 for all {holds(p, q, 0), ptarc(p, ti, ni, 0)} ⊆ A – from\ne3, forced atom proposition, and given facts (holds(p, q, 0) ∈ A, ptarc(p, ti, ni, 0) ∈ A)\nv. And q ni ≡ q < ni in e4 for all {holds(p, q, 0), iptarc(p, ti, ni, 0)} ⊆ A, ni = 1; q > ni ≡ q = 0 – from e4, forced atom proposition, given facts (holds(p, q, 0) ∈ A, iptarc(p, ti, 1, 0) ∈ A), and q is a positive integer vi. Then (∀p ∈ •ti,M0(p) ≥ W(p, ti)) ∧ (∀p ∈ I(ti),M0(p) = 0) – from A. holds(p, q, 0) ∈ A represents q = M0(p) – rule i1 construction B. ptarc(p, ti, ni, 0) ∈ A represents ni = W(p, ti) – rule f 7 construction; or\nit represents ni = M0(p) – rule f 9 construction; the construction of f 9 ensures that notenabled(t, 0) is never true due to the reset arc\nC. definition 11 of preset •ti in PN vii. Then ti is enabled and can fire in PN, as a result it can belong to T0 – from\ndefinition 26 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π3 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, 0) ∈ A – from rule a3 and supported rule proposition ii. Then @{holds(p, q, 0), tot decr(p, q1, 0)} ⊆ A : q1 > q in body(a2) – from a2\nand forced atom proposition iii. Then @p : ( ∑ ti∈{t0,...,tx},p∈•ti W(p, ti) + ∑ ti∈{t0,...,tx},p∈R(ti) M0(p)) > M0(p) – from\nthe following\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 221\nA. holds(p, q, 0) represents q = M0(p) – from rule i1 encoding, given B. tot decr(p, q1, 0) ∈ A if {del(p, q10, t0, 0), . . . , del(p, q1x, tx, 0)} ⊆ A, where\nq1 = q10 + · · · + q1x – from r4 and forced atom proposition C. del(p, q1i, ti, 0) ∈ A if { f ires(ti, 0), ptarc(p, ti, q1i, 0)} ⊆ A – from r7 and\nsupported rule proposition D. del(p, q1i, ti, 0) either represents removal of q1i = W(p, ti) tokens from\np ∈ •ti; or it represents removal of q1i = M0(p) tokens from p ∈ R(ti)– from rule r7, supported rule proposition, and definition 22 of transition execution in PN\niv. Then the set of transitions in T0 do not conflict – by the definition 23 of conflicting transitions\n(c) And for each enabled(t j, 0) ∈ A and f ires(t j, 0) < A, could not have(t j, 0) ∈ A, since A is an answer set of Π3 - from rule a6 and supported rule proposition\ni. Then {enabled(t j, 0), holds(s, qq, 0), ptarc(s, t j, q, 0), tot decr(s, qqq, 0)} ⊆ A, such that q > qq − qqq and f ires(t j, 0) < A - from rule a7 and supported rule proposition\nii. Then for an s ∈ •t j∪R(t j), q > M0(s)−( ∑ ti∈T0,s∈•ti W(s, ti)+ ∑\nti∈T0,s∈R(ti) M0(s)), where q = W(s, t j) if s ∈ •t j, or M0(s) otherwise - from the following: A. ptarc(s, ti, q, 0) represents q = W(s, ti) if (s, ti) ∈ E− or q = M0(s) if s ∈\nR(ti) – from rule f 7, f 9 construction B. holds(s, qq, 0) represents qq = M0(s) – from i1 construction C. tot decr(s, qqq, 0) ∈ A if {del(s, qqq0, t0, 0), . . . , del(s, qqqx, tx, 0)} ⊆ A –\nfrom rule r4 construction and supported rule proposition D. del(s, qqqi, ti, 0) ∈ A if { f ires(ti, 0), ptarc(s, ti, qqqi, 0)} ⊆ A – from rule r7\nand supported rule proposition E. del(s, qqqi, ti, 0) represents qqqi = W(s, ti) : ti ∈ T0, (s, ti) ∈ E−, or qqqi =\nM0(ti) : ti ∈ T0, s ∈ R(ti) – from rule f 7, f 9 construction F. tot decr(q, qqq, 0) represents ∑ ti∈T0,s∈•ti W(s, ti) +∑\nti∈T0,s∈R(ti) M0(s) – from (C,D,E) above iii. Then firing T0 ∪ {t j} would have required more tokens than are present at its\nsource place s ∈ •t j ∪ R(t j). Thus, T0 is a maximal set of transitions that can simultaneously fire.\n(d) And for each reset transition tr with enabled(tr, 0) ∈ A, f ires(tr, 0) ∈ A, since A is an answer set of Π2 - from rule f 10 and supported rule proposition\ni. Then, the firing set T0 satisfies the reset-transition requirement of definition 21 (firing set)\n(e) Then {t0, . . . , tx} = T0 – using 1(a),1(b),1(d) above; and using 1(c) it is a maximal firing set\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 222\n2. We show M1 is produced by firing T0 in M0. Let holds(p, q, 1) ∈ A\n(a) Then {holds(p, q1, 0), tot incr(p, q2, 0), tot decr(p, q3, 0)} ⊆ A : q = q1 + q2 − q3 – from rule r5 and supported rule proposition\n(b) Then holds(p, q1, 0) ∈ A represents q1 = M0(p) – given, rule i1 construction; and {add(p, q20, t0, 0), . . . , add(p, q2 j, t j, 0)} ⊆ A : q20 + · · · + q2 j = q2 and {del(p, q30, t0, 0), . . . , del(p, q3l, tl, 0)} ⊆ A : q30 + · · · + q3l = q3 – rules r3, r4 and supported rule proposition, respectively\n(c) Then { f ires(t0, 0), . . . , f ires(t j, 0)} ⊆ A and { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A – rules r6, r7 and supported rule proposition, respectively\n(d) Then { f ires(t0, 0), . . . , f ires(t j, 0)}∪{ f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A = { f ires(t0, 0), . . . , f ires(tx, 0)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, 0) ∈ A we have tx ∈ T0 – already shown in item 1 above (f) Then q = M0(p) + ∑ tx∈T0∧p∈tx•W(tx, p) − ( ∑ tx∈T0∧p∈•tx W(p, tx) +∑\ntx∈T0∧p∈R(tx) M0(p)) – from (2b) above and the following i. Each add(p, q j, t j, 0) ∈ A represents q j = W(t j, p) for p ∈ t j• – rule r6 encoding, and definition 22 of transition execution in PN\nii. Each del(p, ty, qy, 0) ∈ A represents either qy = W(p, ty) for p ∈ •ty, or qy = M0(p) for p ∈ R(ty) – from rule r7, f 7 encoding and definition 22 of transition execution in PN; or from rule r7, f 9 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2, 0) ∈ A represents q2 = ∑tx∈T0∧p∈tx•W(tx, p) – aggregate assignment atom semantics in rule r3\niv. Each tot decr(p, q3, 0) ∈ A represents q3 = ∑tx∈T0∧p∈•tx W(p, tx)+ ∑tx∈T0∧p∈R(tx) M0(p) – aggregate assignment atom semantics in rule r4\n(g) Then, M1(p) = q – since holds(p, q, 1) ∈ A encodes q = M1(p) – from construction\nInductive Step: Let k > 0, and Mk is a valid marking in X for PN, show (1) Tk is a valid firing set for Mk, and (2) firing Tk in Mk produces marking Mk+1.\n1. We show that Tk is a valid firing set in Mk. Let { f ires(t0, k), . . . , f ires(tx, k)} be the set of all f ires(. . . , k) atoms in A,\n(a) Then for each f ires(ti, k) ∈ A i. enabled(ti, k) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, k) < A – from rule e2 and supported rule proposition iii. Then body(e3) must not hold in A and body(e4) must not hold in A – from rule\ne3, e4 and forced atom proposition iv. Then q ≮ ni ≡ q ≥ ni in e3 for all {holds(p, q, k), ptarc(p, ti, ni, k)} ⊆ A – from\ne3, forced atom proposition, and given facts (holds(p, q, k) ∈ A, ptarc(p, ti, ni, k) ∈ A)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 223\nv. And q ni ≡ q < ni in e4 for all {holds(p, q, k), iptarc(p, ti, ni, k)} ⊆ A, ni = 1; q > ni ≡ q = 0 – from e4, forced atom proposition, given facts (holds(p, q, k) ∈ A, iptarc(p, ti, 1, k) ∈ A), and q is a positive integer\nvi. Then (∀p ∈ •ti,Mk(p) ≥ W(p, ti)) ∧ (∀p ∈ I(ti),Mk(p) = 0) – from A. holds(p, q, k) ∈ A represents q = Mk(p) – inductive assumption, given B. ptarc(p, ti, ni, k) ∈ A represents ni = W(p, ti) – rule f 7 construction; or\nit represents ni = Mk(p) – rule f 9 construction; the construction of f 9 ensures that notenabled(t, 0) is never true due to the reset arc\nC. definition 11 of preset •ti in PN vii. Then ti is enabled and can fire in PN, as a result it can belong to Tk – from\ndefinition 26 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π3 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, k) ∈ A – from rule a3 and supported rule proposition ii. Then @{holds(p, q, k), tot decr(p, q1, k)} ⊆ A : q1 > q in body(a2) – from a2\nand forced atom proposition iii. Then @p : ( ∑ ti∈{t0,...,tx},p∈•ti W(p, ti) + ∑ ti∈{t0,...,tx},p∈R(ti) Mk(p)) > Mk(p) – from\nthe following A. holds(p, q, k) represents q = Mk(p) – inductive assumption, construction B. tot decr(p, q1, k) ∈ A if {del(p, q10, t0, k), . . . , del(p, q1x, tx, k)} ⊆ A, where\nq1 = q10 + · · · + q1x – from r4 and forced atom proposition C. del(p, q1i, ti, k) ∈ A if { f ires(ti, k), ptarc(p, ti, q1i, k)} ⊆ A – from r7 and\nsupported rule proposition D. del(p, q1i, ti, k) either represents removal of q1i = W(p, ti) tokens from\np ∈ •ti; or it represents removal of q1i = Mk(p) tokens from p ∈ R(ti)– from rule r7, supported rule proposition, and definition 22 of transition execution in PN\niv. Then Tk does not contain conflicting transitions – by the definition 23 of conflicting transitions\n(c) And for each enabled(t j, k) ∈ A and f ires(t j, k) < A, could not have(t j, k) ∈ A, since A is an answer set of Π3 - from rule a6 and supported rule proposition\ni. Then {enabled(t j, k), holds(s, qq, k), ptarc(s, t j, q, k), tot decr(s, qqq, k)} ⊆ A, such that q > qq − qqq and f ires(t j, k) < A - from rule a7 and supported rule proposition\nii. Then for an s ∈ •t j∪R(t j), q > Mk(s)−( ∑ ti∈Tk ,s∈•ti W(s, ti)+ ∑\nti∈Tk ,s∈R(ti) Mk(s)), where q = W(s, t j) if s ∈ •t j, or Mk(s) otherwise - from the following: A. ptarc(s, ti, q, k) represents q = W(s, ti) if (s, ti) ∈ E− or q = Mk(s) if s ∈\nR(ti) – from rule f 7, f 9 construction B. holds(s, qq, k) represents qq = Mk(s) – construction\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 224\nC. tot decr(s, qqq, k) ∈ A if {del(s, qqq0, t0, k), . . . , del(s, qqqx, tx, k)} ⊆ A – from rule r4 construction and supported rule proposition\nD. del(s, qqqi, ti, k) ∈ A if { f ires(ti, k), ptarc(s, ti, qqqi, k)} ⊆ A – from rule r7 and supported rule proposition E. del(s, qqqi, ti, k) represents qqqi = W(s, ti) : ti ∈ Tk, (s, ti) ∈ E−, or qqqi = Mk(ti) : ti ∈ Tk, s ∈ R(ti) – from rule f 7, f 9 construction\nF. tot decr(q, qqq, k) represents ∑\nti∈Tk ,s∈•ti W(s, ti) +∑ ti∈Tk ,s∈R(ti) Mk(s) – from (C,D,E) above\niii. Then firing Tk ∪ {t j} would have required more tokens than are present at its source place s ∈ •t j ∪ R(t j). Thus, Tk is a maximal set of transitions that can simultaneously fire.\n(d) And for each reset transition tr with enabled(tr, k) ∈ A, f ires(tr, k) ∈ A, since A is an answer set of Π2 - from rule f 10 and supported rule proposition\ni. Then the firing set Tk satisfies the reset transition requirement of definition 21 (firing set)\n(e) Then {t0, . . . , tx} = Tk – using 1(a),1(b), 1(d) above; and using 1(c) it is a maximal firing set\n2. We show that Mk+1 is produced by firing Tk in Mk. Let holds(p, q, k + 1) ∈ A\n(a) Then {holds(p, q1, k), tot incr(p, q2, k), tot decr(p, q3, k)} ⊆ A : q = q1 + q2 − q3 – from rule r5 and supported rule proposition\n(b) Then, holds(p, q1, k) ∈ A represents q1 = Mk(p) – inductive assumption, construction ; and {add(p, q20, t0, k), . . . , add(p, q2 j, t j, k)} ⊆ A : q20 + · · · + q2 j = q2 and {del(p, q30, t0, k), . . . , del(p, q3l, tl, k)} ⊆ A : q30 + · · · + q3l = q3 – rules r3, r4 and supported rule proposition, respectively\n(c) Then { f ires(t0, k), . . . , f ires(t j, k)} ⊆ A and { f ires(t0, k), . . . , f ires(tl, k)} ⊆ A – rules r6, r7 and supported rule proposition, respectively\n(d) Then { f ires(t0, k), . . . , f ires(t j, k)}∪{ f ires(t0, k), . . . , f ires(tl, k)} ⊆ A = { f ires(t0, k), . . . , f ires(tx, k)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, k) ∈ A we have tx ∈ Tk – already shown in item 1 above (f) Then q = Mk(p) + ∑ tx∈T0∧p∈tx•W(tx, p) − ( ∑ tx∈Tk∧p∈•tx W(p, tx) +∑\ntx∈Tk∧p∈R(tx) Mk(p)) – from (2b) above and the following i. Each add(p, q j, t j, k) ∈ A represents q j = W(t j, p) for p ∈ t j• – rule r6 encoding, and definition 22 of transition execution in PN\nii. Each del(p, ty, qy, k) ∈ A represents either qy = W(p, ty) for p ∈ •ty, or qy = Mk(p) for p ∈ R(ty) – from rule r7, f 7 encoding and definition 22 of transition execution in PN; or from rule r7, f 9 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2, k) ∈ A represents q2 = ∑tx∈Tk∧p∈tx•W(tx, p) – aggregate assignment atom semantics in rule r3\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 225\niv. Each tot decr(p, q3, 0) ∈ A represents q3 = ∑tx∈Tk∧p∈•tx W(p, tx)+ ∑tx∈Tk∧p∈R(tx) Mk(p) – aggregate assignment atom semantics in rule r4\n(g) Then, Mk+1(p) = q – since holds(p, q, k + 1) ∈ A encodes q = Mk+1(p) – from construction\nAs a result, for any n > k, Tn will be a valid firing set for Mn and Mn+1 will be its target marking. Conclusion: Since both (I) and (II) hold, X = M0,T0,M1, . . . ,Mk,Tk+1 is an execution sequence of PN(P,T, E,W,R) (w.r.t M0) iff there is an answer set A of Π3(PN,M0, k, ntok) such that (A.5) and (A.6) hold.\nA.5 Proof of Proposition 5\nLet PN = (P,T, E,W,R, I,Q,QW) be a Petri Net, M0 be its initial marking and let Π4(PN,M0, k, ntok) be the ASP encoding of PN and M0 over a simulation length k, with maximum ntok tokens on any place node, as defined in section 2.7. Then X = M0,T0,M1, . . . ,Mk,Tk,Mk+1 is an execution sequence of PN (w.r.t. M0) iff there is an answer set A of Π4(PN,M0, k, ntok) such that:\n{ f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} = { f ires(t, ts) : f ires(t, ts) ∈ A} (A.9) {holds(p, q, ts) : p ∈ P, q = Mts(p), 0 ≤ ts ≤ k + 1}\n= {holds(p, q, ts) : holds(p, q, ts) ∈ A} (A.10)\nWe prove this by showing that:\n(I) Given an execution sequence X, we create a set A such that it satisfies (A.9) and (A.10) and show that A is an answer set of Π4\n(II) Given an answer set A of Π4, we create an execution sequence X such that (A.9) and (A.10) are satisfied.\nFirst we show (I): Given PN and an execution sequence X of PN, we create a set A as a union of the following sets:\n1. A1 = {num(n) : 0 ≤ n ≤ ntok}\n2. A2 = {time(ts) : 0 ≤ ts ≤ k}\n3. A3 = {place(p) : p ∈ P}\n4. A4 = {trans(t) : t ∈ T }\n5. A5 = {ptarc(p, t, n, ts) : (p, t) ∈ E−, n = W(p, t), 0 ≤ ts ≤ k}, where E− ⊆ E\n6. A6 = {tparc(t, p, n, ts) : (t, p) ∈ E+, n = W(t, p), 0 ≤ ts ≤ k}, where E+ ⊆ E\n7. A7 = {holds(p, q, 0) : p ∈ P, q = M0(p)}\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 226\n8. A8 = {notenabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k, (∃p ∈ •t,Mts(p) < W(p, t)) ∨ (∃p ∈ I(t),Mts(p) , 0) ∨ (∃(p, t) ∈ Q,Mts(p) < QW(p, t))} per definition 28 (enabled transition)\n9. A9 = {enabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k, (∀p ∈ •t,W(p, t) ≤ Mts(p)) ∧ (∀p ∈ I(t),Mts(p) = 0) ∧ (∀(p, t) ∈ Q,Mts(p) ≥ QW(p, t))} per definition 28 (enabled transition)\n10. A10 = { f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} per definition 28 (enabled transitions), only an enabled transition may fire\n11. A11 = {add(p, q, t, ts) : t ∈ Tts, p ∈ t•, q = W(t, p), 0 ≤ ts ≤ k} per definition 22 (transition execution)\n12. A12 = {del(p, q, t, ts) : t ∈ Tts, p ∈ •t, q = W(p, t), 0 ≤ ts ≤ k} ∪ {del(p, q, t, ts) : t ∈ Tts, p ∈ R(t), q = Mts(p), 0 ≤ ts ≤ k} per definition 22 (transition execution)\n13. A13 = {tot incr(p, q, ts) : p ∈ P, q = ∑\nt∈Tts,p∈t•W(t, p), 0 ≤ ts ≤ k} per definition 24 (firing set execution)\n14. A14 = {tot decr(p, q, ts) : p ∈ P, q = ∑ t∈Tts,p∈•t W(p, t) + ∑\nt∈Tts,p∈R(t) Mts(p), 0 ≤ ts ≤ k} per definition 24 (firing set execution)\n15. A15 = {consumesmore(p, ts) : p ∈ P, q = Mts(p), q1 = ∑ t∈Tts,p∈•t W(p, t)+ ∑\nt∈Tts,p∈R(t) Mts(p), q1 > q, 0 ≤ ts ≤ k} per definition 23 (conflicting transitions)\n16. A16 = {consumesmore : ∃p ∈ P : q = Mts(p), q1 = ∑ t∈Tts,p∈•t W(p, t)+ ∑\nt∈Tts,p∈R(t)(Mts(p)), q1 > q, 0 ≤ ts ≤ k} per definition 23 (conflicting transitions)\n17. A17 = {could not have(t, ts) : t ∈ T, (∀p ∈ •t,W(p, t) ≤ Mts(p)), t < Tts, (∃p ∈ •t : W(p, t) > Mts(p) − ( ∑ t′∈Tts,p∈•t′ W(p, t ′) + ∑\nt′∈Tts,p∈R(t′) Mts(p)), 0 ≤ ts ≤ k} per the maximal firing set semantics\n18. A18 = {holds(p, q, ts + 1) : p ∈ P, q = Mts+1(p), 0 ≤ ts < k}, where Mts+1(p) = Mts(p) − ( ∑ t∈Tts,p∈•t W(p, t) +∑\nt∈Tts,p∈R(t) Mts(p))+ ∑\nt∈Tts,p∈t•W(t, p) according to definition 21 (firing set execution)\n19. A19 = {ptarc(p, t, n, ts) : p ∈ R(t), n = Mts(p), n > 0, 0 ≤ ts ≤ k}\n20. A20 = {iptarc(p, t, 1, ts) : p ∈ P, 0 ≤ ts < k}\n21. A21 = {tptarc(p, t, n, ts) : (p, t) ∈ Q, n = QW(p, t), 0 ≤ ts ≤ k}\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 227\nWe show that A satisfies (A.7) and (A.8), and A is an answer set of Π4. A satisfies (A.7) and (A.8) by its construction above. We show A is an answer set of Π4 by splitting. We split lit(Π4) into a sequence of 7k + 9 sets:\n• U0 = head( f 1) ∪ head( f 2) ∪ head( f 5) ∪ head( f 6) ∪ head(i1) = {place(p) : p ∈ P} ∪ {trans(t) : t ∈ T }∪ {time(0), . . . , time(k)}∪ {num(0), . . . , num(ntok)}∪ {holds(p, q, 0) : p ∈ P, q = M0(p)}\n• U7k+1 = U7k+0∪head( f 7)ts=k∪head( f 8)ts=k∪head( f 9)ts=k∪head( f 11)ts=k∪head( f 12)ts=k = U7k+0 ∪ {ptarc(p, t, n, k) : (p, t) ∈ E−, n = W(p, t)} ∪ {tparc(t, p, n, k) : (t, p) ∈ E+, n = W(t, p)}∪ {ptarc(p, t, n, k) : p ∈ R(t), n = Mk(p), n > 0}∪ {iptarc(p, t, 1, k) : p ∈ I(t)}∪ {tptarc(p, t, n, k) : (p, t) ∈ Q, n = QW(p, t)}\n• U7k+2 = U7k+1 ∪ head(e3)ts=k = U7k+1 ∪ {notenabled(t, k) : t ∈ T }\n• U7k+3 = U7k+2 ∪ head(e2)ts=k = U7k+2 ∪ {enabled(t, k) : t ∈ T }\n• U7k+4 = U7k+3 ∪ head(a1)ts=k = U7k+3 ∪ { f ires(t, k) : t ∈ T }\n• U7k+5 = U7k+4 ∪ head(r6)ts=k ∪ head(r7)ts=k = U7k+4 ∪ {add(p, q, t, k) : p ∈ P, t ∈ T, q = W(t, p)} ∪ {del(p, q, t, k) : p ∈ P, t ∈ T, q = W(p, t)} ∪ {del(p, q, t, k) : p ∈ P, t ∈ T, q = Mk(p)}\n• U7k+6 = U7k+5 ∪ head(r3)ts=k ∪ head(r4)ts=k = U7k+5 ∪ {tot incr(p, q, k) : p ∈ P, 0 ≤ q ≤ ntok} ∪ {tot decr(p, q, k) : p ∈ P, 0 ≤ q ≤ ntok}\n• U7k+7 = U7k+6 ∪ head(r5)ts=k ∪ head(a2)ts=k ∪ head(a7)ts=k = U7k+6 ∪ {consumesmore(p, k) : p ∈ P}∪{holds(p, q, k+1) : p ∈ P, 0 ≤ q ≤ ntok}∪{could not have(t, k) : t ∈ T }\n• U7k+8 = U7k+7 ∪ head(a3) = U7k+7 ∪ {consumesmore}\nwhere head(ri)ts=k are head atoms of ground rule ri in which ts = k. We write Ats=ki = {a(. . . , ts) : a(. . . , ts) ∈ Ai, ts = k} as short hand for all atoms in Ai with ts = k. Uα, 0 ≤ α ≤ 7k + 8 form a splitting sequence, since each Ui is a splitting set of Π4, and 〈Uα〉α<µ is a monotone continuous sequence, where U0 ⊆ U1 · · · ⊆ U8(k+1) and ⋃ α<µ Uα = lit(Π4).\nWe compute the answer set of Π4 using the splitting sets as follows:\n1. botU0(Π 4) = f 1 ∪ f 2 ∪ f 5 ∪ i1 ∪ f 6 and X0 = A1 ∪ · · · ∪ A4 ∪ A7 (= U0) is its answer set\n– using forced atom proposition\n2. evalU0(botU1(Π 4) \\ botU0(Π4), X0) = {ptarc(p, t, q, 0):-.|q = W(p, t)} ∪\n{tparc(t, p, q, 0):-.|q = W(t, p)} ∪ {ptarc(p, t, q, 0):-.|q = M0(p)} ∪ {iptarc(p, t, 1, 0):-.}∪{tptarc(p, t, q, 0):-.|q = QW(p, t)}. Its answer set X1 = Ats=05 ∪A ts=0 6 ∪ Ats=019 ∪A ts=0 20 ∪A ts=0 21 – using forced atom proposition and construction of A5, A6, A19, A20, A21.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 228\n3. evalU1(botU2(Π 4) \\ botU1(Π4), X0 ∪ X1) = {notenabled(t, 0):-.|({trans(t),\nptarc(p, t, n, 0), holds(p, q, 0)} ⊆ X0 ∪ X1, where q < n) or ({notenabled(t, 0):-.| ({trans(t), iptarc(p, t, n2, 0), holds(p, q, 0)} ⊆ X0 ∪ X1, where q ≥ n2}) or ({trans(t), tptarc(p, t, n3, 0), holds(p, q, 0)} ⊆ X0 ∪ X1, where q < n3)}. Its answer set X2 = Ats=08 – using forced atom proposition and construction of A8.\n(a) where, q = M0(p), and n = W(p, t) for an arc (p, t) ∈ E− – by construction of i1 and f 7 in Π4, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 11 of preset) (c) n2 = 1 – by construction of iptarc predicates in Π4, meaning q ≥ n2 ≡ q ≥ 1 ≡ q >\n0,\n(d) tptarc(p, t, n3, 0) represents n3 = QW(p, t), where (p, t) ∈ Q (e) thus, notenabled(t, 0) ∈ X1 represents (∃p ∈ •t : M0(p) < W(p, t)) ∨ (∃p ∈ I(t) :\nM0(p) > 0) ∨ (∃(p, t) ∈ Q : Mts(p) < QW(p, t)).\n4. evalU2(botU3(Π 4) \\ botU2(Π4), X0 ∪ · · · ∪ X2) = {enabled(t, 0):-.|trans(t) ∈ X0 ∪ · · · ∪\nX2, notenabled(t, 0) < X0 ∪ · · · ∪ X2}. Its answer set is X3 = Ats=09 – using forced atom proposition and construction of A9.\n(a) since an enabled(t, 0) ∈ X3 if @ notenabled(t, 0) ∈ X0 ∪ · · · ∪ X2; which is equivalent to (@p ∈ •t : M0(p) < W(p, t)) ∧ (@p ∈ I(t) : M0(p) > 0) ∧ (@(p, t) ∈ Q : M0(p) < QW(p, t)) ≡ (∀p ∈ •t : M0(p) ≥ W(p, t)) ∧ (∀p ∈ I(t) : M0(p) = 0).\n5. evalU3(botU4(Π 4) \\ botU3(Π4), X0 ∪ · · · ∪ X3) = {{ f ires(t, 0)}:-.|enabled(t, 0)\nholds in X0 ∪ · · · ∪ X3}. It has multiple answer sets X4.1, . . . , X4.n, corresponding to elements of power set of f ires(t, 0) atoms in evalU3(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π4 determined using splitting is equal to A, we only consider the set that matches the f ires(t, 0) elements in A and call it X4, ignoring the rest. Thus, X4 = Ats=010 , representing T0.\n(a) in addition, for every t such that enabled(t, 0) ∈ X0 ∪ · · · ∪ X3,R(t) , ∅; f ires(t, 0) ∈ X4 – per definition 21 (firing set); requiring that a reset transition is fired when enabled\n(b) thus, the firing set T0 will not be eliminated by the constraint f 10\n6. evalU4(botU5(Π 4) \\ botU4(Π4), X0 ∪ · · · ∪ X4) = {add(p, n, t, 0):-.|{ f ires(t, 0),\ntparc(t, p, n, 0)} ⊆ X0 ∪ · · · ∪ X4} ∪ {del(p, n, t, 0):-.|{ f ires(t, 0), ptarc(p, t, n, 0)} ⊆ X0 ∪ · · · ∪ X4}. It’s answer set is X5 = Ats=011 ∪ A ts=0 12 – using forced atom proposition and definitions of A11 and A12.\n(a) where, each add atom is equivalent to n = W(t, p), p ∈ t•, (b) and each del atom is equivalent to n = W(p, t), p ∈ •t; or n = Mk(p), p ∈ R(t),\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 229\n(c) representing the effect of transitions in T0 – by construction\n7. evalU5(botU6(Π 4) \\ botU5(Π4), X0 ∪ · · · ∪ X5) = {tot incr(p, qq, 0):-.| qq = ∑ add(p,q,t,0)∈X0∪···∪X5 q} ∪ {tot decr(p, qq, 0):-.|qq = ∑\ndel(p,q,t,0)∈X0∪···∪X5 q}. It’s answer set is X6 = Ats=013 ∪ A ts=0 14 – using forced atom proposition and definitions of A13 and A14.\n(a) where, each tot incr(p, qq, 0), qq = ∑\nadd(p,q,t,0)∈X0∪...X5 q ≡ qq = ∑t∈X4,p∈t•W(p, t),\n(b) and each tot decr(p, qq, 0), qq = ∑\ndel(p,q,t,0)∈X0∪...X5 q ≡ qq = ∑t∈X4,p∈•t W(t, p) + ∑t∈X4,p∈R(t) Mk(p),\n(c) represent the net effect of transitions in T0 – by construction\n8. evalU6(botU7(Π 4) \\ botU6(Π4), X0 ∪ · · · ∪ X6) = {consumesmore(p, 0):-.|\n{holds(p, q, 0), tot decr(p, q1, 0)} ⊆ X0 ∪ · · · ∪ X6, q1 > q} ∪ {holds(p, q, 1):-., | {holds(p, q1, 0), tot incr(p, q2, 0), tot decr(p, q3, 0)} ⊆ X0 ∪ · · · ∪ X6, q = q1 + q2− q3} ∪ {could not have(t, 0):-.|{enabled(t, 0), ptarc(s, t, q), holds(s, qq, 0), tot decr(s, qqq, 0)} ⊆ X0 ∪ · · · ∪ X6, f ires(t, 0) < (X0 ∪ · · · ∪ X6), q > qq − qqq}. It’s answer set is X7 = Ats=015 ∪ A ts=0 17 ∪ A ts=0 18 – using forced atom proposition and definitions of A15, A17, A18, A9.\n(a) where, consumesmore(p, 0) represents ∃p : q = M0(p), q1 =∑ t∈T0,p∈•t W(p, t) + ∑ t∈T0,p∈R(t) M0(p), q1 > q, indicating place p will be over con-\nsumed if T0 is fired, as defined in definition 23 (conflicting transitions), (b) holds(p, q, 1) represents q = M1(p) – by construction of Π4, (c) and could not have(t, 0) represents enabled transition t ∈ T0 that could not fire due\nto insufficient tokens (d) X7 does not contain could not have(t, 0), when enabled(t, 0) ∈ X0 ∪ · · · ∪ X6 and\nf ires(t, 0) < X0 ∪ · · · ∪ X6 due to construction of A, encoding of a7 and its body atoms. As a result it is not eliminated by the constraint a6\n...\n9. evalU7k+0(botU7k+1(Π 4) \\ botU7k+0(Π4), X0 ∪ · · · ∪ X7k+0) = {ptarc(p, t, q, k):-.|q = W(p, t)} ∪\n{tparc(t, p, q, k):-.|q = W(t, p)} ∪ {ptarc(p, t, q, k):-.|q = Mk(p)} ∪ {iptarc(p, t, 1, k):-.}. Its answer set X7k+1 = Ats=k5 ∪ A ts=k 6 ∪ A ts=k 19 ∪ A ts=k 20 – using forced atom proposition and construction of A5, A6, A19, A20.\n10. evalU7k+1(botU7k+2(Π 4)\\botU7k+1(Π4), X0∪· · ·∪X7k+1) = {notenabled(t, k):-.| ({trans(t), ptarc(p, t, n, k), holds(p, q, k)} ⊆\nX0 ∪ · · · ∪ X7k+1, where q < n) or {notenabled(t, k):-.|({trans(t), iptarc(p, t, n2, k), holds(p, q, k)} ⊆ X0 ∪ · · · ∪ X7k+1, where q ≥ n2}}. Its answer set X7k+2 = Ats=k8 – using forced atom proposition and construction of A8.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 230\n(a) where, q = Mk(p), and n = W(p, t) for an arc (p, t) ∈ E− – by construction of holds and ptarc predicates in Π4, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 11 of preset) (c) n2 = 1 – by construction of iptarc predicates in Π4, meaning q ≥ n2 ≡ q ≥ 1 ≡ q >\n0,\n(d) thus, notenabled(t, k) ∈ X7k+1 represents (∃p ∈ •t : Mk(p) < W(p, t)) ∨ (∃p ∈ I(t) : Mk(p) > k).\n11. evalU7k+2(botU7k+3(Π 4) \\ botU7k+2(Π4), X0 ∪ · · · ∪ X7k+2) = {enabled(t, k):-.|\ntrans(t) ∈ X0 ∪ · · · ∪ X7k+2 ∧ notenabled(t, k) < X0 ∪ · · · ∪ X7k+2}. Its answer set is X7k+3 = Ats=k9 – using forced atom proposition and construction of A9.\n(a) since an enabled(t, k) ∈ X7k+3 if @ notenabled(t, k) ∈ X0 ∪ · · · ∪ X7k+2; which is equivalent to (@p ∈ •t : Mk(p) < W(p, t)) ∧ (@p ∈ I(t) : Mk(p) > k) ≡ (∀p ∈ •t : Mk(p) ≥ W(p, t)) ∧ (∀p ∈ I(t) : Mk(p) = k).\n12. evalU7k+3(botU7k+4(Π 4) \\ botU7k+3(Π4), X0 ∪ · · · ∪ X7k+3) = {{ f ires(t, k)}:-.|\nenabled(t, k) holds in X0 ∪ · · · ∪ X7k+3}. It has multiple answer sets X7k+4.1, . . . , X7k+4.n, corresponding to elements of power set of f ires(t, k) atoms in evalU7k+3(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π4 determined using splitting is equal to A, we only consider the set that matches the f ires(t, k) elements in A and call it X7k+4, ignoring the rest. Thus, X7k+4 = Ats=k10 , representing Tk.\n(a) in addition, for every t such that enabled(t, k) ∈ X0∪· · ·∪X7k+3,R(t) , ∅; f ires(t, k) ∈ X7k+4 – per definition 21 (firing set); requiring that a reset transition is fired when enabled\n(b) thus, the firing set Tk will not be eliminated by the constraint f 10\n13. evalU7k+4(botU7k+5(Π 4) \\ botU7k+4(Π4), X0 ∪ · · · ∪ X7k+4) = {add(p, n, t, k):-.|\n{ f ires(t, k), tparc(t, p, n, k)} ⊆ X0 ∪ · · · ∪ X7k+4} ∪ {del(p, n, t, k):-.|{ f ires(t, k), ptarc(p, t, n, k)} ⊆ X0∪· · ·∪X7k+4}. It’s answer set is X7k+5 = Ats=k11 ∪A ts=k 12 – using forced atom proposition and definitions of A11 and A12.\n(a) where, each add atom is equivalent to n = W(t, p) : p ∈ t•, (b) and each del atom is equivalent to n = W(p, t) : p ∈ •t; or n = Mk(p) : p ∈ R(t), (c) representing the effect of transitions in Tk\n14. evalU7k+5(botU7k+6(Π 4) \\ botU7k+5(Π4), X0 ∪ · · · ∪ X7k+5) = {tot incr(p, qq, k):-.|qq = ∑add(p,q,t,k)∈X0∪···∪X7k+5 q} ∪ {tot decr(p, qq, k):-.|qq = ∑del(p,q,t,k)∈X0∪···∪X7k+5 q}. It’s answer set is X7k+6 = Ats=k13 ∪Ats=k14 – using forced atom proposition and definitions of A13 and A14.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 231\n(a) where, each tot incr(p, qq, k), qq = ∑\nadd(p,q,t,k)∈X0∪...X7k+5 q ≡ qq = ∑t∈X7k+4,p∈t•W(p, t),\n(b) and each tot decr(p, qq, k), qq = ∑\ndel(p,q,t,k)∈X0∪...X7k+5 q ≡ qq = ∑t∈X7k+4,p∈•t W(t, p) + ∑t∈X7k+4,p∈R(t) Mk(p),\n(c) represent the net effect of transition in Tk\n15. evalU7k+6(botU7k+7(Π 4) \\ botU7k+6(Π4), X0 ∪ · · · ∪ X7k+6) = {consumesmore(p, k):-.|\n{holds(p, q, k), tot decr(p, q1, k)} ⊆ X0 ∪ · · · ∪ X7k+6, q1 > q} ∪ {holds(p, q, 1):-., | {holds(p, q1, k), tot incr(p, q2, k), tot decr(p, q3, k)} ⊆ X0 ∪ · · · ∪ X7k+6, q = q1 + q2 − q3} ∪ {could not have(t, k):-.|{enabled(t, k), ptarc(s, t, q), holds(s, qq, k), tot decr(s, qqq, k)} ⊆ X0 ∪ · · · ∪ X7k+6, f ires(t, k) < (X0 ∪ · · · ∪ X7k+6), q > qq − qqq}. It’s answer set is X7k+7 = Ats=k15 ∪A ts=k 17 ∪A ts=k 18 – using forced atom proposition and definitions of A15, A17, A18, A9.\n(a) where, consumesmore(p, k) represents ∃p : q = Mk(p), q1 =∑ t∈Tk ,p∈•t W(p, t) + ∑ t∈Tk ,p∈R(t) Mk(p), q1 > q, indicating place p that will be over\nconsumed if Tk is fired, as defined in definition 23 (conflicting transitions),\n(b) holds(p, q, k + 1) represents q = Mk+1(p) – by construction of Π4,\n(c) and could not have(t, k) represents enabled transition t in Tk that could not be fired due to insufficient tokens\n(d) X7k+7 does not contain could not have(t, k), when enabled(t, k) ∈ X0 ∪ · · · ∪ X7k+6 and f ires(t, k) < X0 ∪ · · · ∪ X7k+6 due to construction of A, encoding of a7 and its body atoms. As a result it is not eliminated by the constraint a6\n16. evalU7k+7(botU7k+8(Π 4) \\ botU7k+7(Π4), X0 ∪ · · · ∪ X7k+7) = {consumesmore:-.|\n{consumesmore(p, 0), . . . , consumesmore(p, k)} ∩ (X0 ∪ · · · ∪ X7k+7) , ∅}. It’s answer set is X7k+8 = A16 – using forced atom proposition\n(a) X7k+8 will be empty since none of consumesmore(p, 0), . . . , consumesmore(p, k) hold in X0 ∪ · · · ∪ X7k+8 due to the construction of A, encoding of a2 and its body atoms. As a result, it is not eliminated by the constraint a4\nThe set X = X0 ∪ · · · ∪ X7k+8 is the answer set of Π4 by the splitting sequence theorem 15. Each Xi, 0 ≤ i ≤ 7k + 8 matches a distinct portion of A, and X = A, thus A is an answer set of Π4.\nNext we show (II): Given Π4 be the encoding of a Petri Net PN(P,T, E,W,R, I) with initial marking M0, and A be an answer set of Π4 that satisfies (A.7) and (A.8), then we can construct X = M0,T0, . . . ,Mk,Tk,Mk+1 from A, such that it is an execution sequence of PN.\nWe construct the X as follows:\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 232\n1. Mi = (Mi(p0), . . . ,Mi(pn)), where {holds(p0,Mi(p0), i), . . . holds(pn,Mi(pn), i)} ⊆ A, for 0 ≤ i ≤ k + 1\n2. Ti = {t : f ires(t, i) ∈ A}, for 0 ≤ i ≤ k\nand show that X is indeed an execution sequence of PN. We show this by induction over k (i.e. given Mk, Tk is a valid firing set and its firing produces marking Mk+1).\nBase case: Let k = 0, and M0 is a valid marking in X for PN, show (1) T0 is a valid firing set for M0, and (2) firing of T0 in M0 produces marking M1.\n1. We show T0 is a valid firing set for M0. Let { f ires(t0, 0), . . . , f ires(tx, 0)} be the set of all f ires(. . . , 0) atoms in A,\n(a) Then for each f ires(ti, 0) ∈ A i. enabled(ti, 0) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, 0) < A – from rule e2 and supported rule proposition iii. Then either of body(e3), body(e4), or body(e5) must not hold in A – from rules\ne3, e4, e5 and forced atom proposition iv. Then q ≮ ni ≡ q ≥ ni in e3 for all {holds(p, q, 0), ptarc(p, ti, ni, 0)} ⊆ A – from\ne3, forced atom proposition, and given facts (holds(p, q, 0) ∈ A, ptarc(p, ti, ni, 0) ∈ A)\nv. And q ni ≡ q < ni in e4 for all {holds(p, q, 0), iptarc(p, ti, ni, 0)} ⊆ A, ni = 1; q > ni ≡ q = 0 – from e4, forced atom proposition, given facts (holds(p, q, 0) ∈ A, iptarc(p, ti, 1, 0) ∈ A), and q is a positive integer vi. And q ≮ ni ≡ q ≥ ni in e5 for all {holds(p, q, 0), tptarc(p, ti, ni, 0)} ⊆ A – from e5, forced atom proposition, and given facts\nvii. Then (∀p ∈ •ti,M0(p) ≥ W(p, ti)) ∧ (∀p ∈ I(ti),M0(p) = 0) ∧ (∀(p, ti) ∈ Q,M0(p) ≥ QW(p, ti)) – from the following A. holds(p, q, 0) ∈ A represents q = M0(p) – rule i1 construction B. ptarc(p, ti, ni, 0) ∈ A represents ni = W(p, ti) – rule f 7 construction; or\nit represents ni = M0(p) – rule f 9 construction; the construction of f 9 ensures that notenabled(t, 0) is never true due to the reset arc\nC. definition 11 of preset •ti in PN D. definition 28 of enabled transition in PN\nviii. Then ti is enabled and can fire in PN, as a result it can belong to T0 – from definition 28 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π4 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, 0) ∈ A – from rule a3 and supported rule proposition\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 233\nii. Then @{holds(p, q, 0), tot decr(p, q1, 0)} ⊆ A : q1 > q in body(a2) – from a2 and forced atom proposition\niii. Then @p : ( ∑ ti∈{t0,...,tx},p∈•ti W(p, ti) + ∑\nti∈{t0,...,tx},p∈R(ti) M0(p)) > M0(p) – from the following A. holds(p, q, 0) represents q = M0(p) – from rule i1 construction, given B. tot decr(p, q1, 0) ∈ A if {del(p, q10, t0, 0), . . . , del(p, q1x, tx, 0)} ⊆ A, where\nq1 = q10 + · · · + q1x – from r4 and forced atom proposition C. del(p, q1i, ti, 0) ∈ A if { f ires(ti, 0), ptarc(p, ti, q1i, 0)} ⊆ A – from r7 and\nsupported rule proposition D. del(p, q1i, ti, 0) represents removal of q1i = W(p, ti) tokens from p ∈ •ti; or\nit represents removal of q1i = M0(p) tokens from p ∈ R(ti)– from rule r7, supported rule proposition, and definition 22 of transition execution in PN\niv. Then the set of transitions in T0 do not conflict – by the definition 23 of conflicting transitions\n(c) And for each enabled(t j, 0) ∈ A and f ires(t j, 0) < A, could not have(t j, 0) ∈ A, since A is an answer set of Π4 - from rule a6 and supported rule proposition\ni. Then {enabled(t j, 0), holds(s, qq, 0), ptarc(s, t j, q, 0), tot decr(s, qqq, 0)} ⊆ A, such that q > qq − qqq and f ires(t j, 0) < A - from rule a7 and supported rule proposition\nii. Then for an s ∈ •t j∪R(t j), q > M0(s)−( ∑ ti∈T0,s∈•ti W(s, ti)+ ∑\nti∈T0,s∈R(ti) M0(s)), where q = W(s, t j) if s ∈ •t j, or M0(s) otherwise - from the following: A. ptarc(s, ti, q, 0) represents q = W(s, ti) if (s, ti) ∈ E− or q = M0(s) if s ∈\nR(ti) – from rule f 7, f 9 construction B. holds(s, qq, 0) represents qq = M0(s) – from i1 construction C. tot decr(s, qqq, 0) ∈ A if {del(s, qqq0, t0, 0), . . . , del(s, qqqx, tx, 0)} ⊆ A –\nfrom rule r4 construction and supported rule proposition D. del(s, qqqi, ti, 0) ∈ A if { f ires(ti, 0), ptarc(s, ti, qqqi, 0)} ⊆ A – from rule r7\nand supported rule proposition E. del(s, qqqi, ti, 0) represents qqqi = W(s, ti) : ti ∈ T0, (s, ti) ∈ E−, or qqqi =\nM0(ti) : ti ∈ T0, s ∈ R(ti) – from rule f 7, f 9 construction F. tot decr(q, qqq, 0) represents ∑ ti∈T0,s∈•ti W(s, ti) +∑\nti∈T0,s∈R(ti) M0(s) – from (C,D,E) above iii. Then firing T0 ∪ {t j} would have required more tokens than are present at its\nsource place s ∈ •t j ∪ R(t j). Thus, T0 is a maximal set of transitions that can simultaneously fire.\n(d) And for each reset transition tr with enabled(tr, 0) ∈ A, f ires(tr, 0) ∈ A, since A is an answer set of Π2 - from rule f 10 and supported rule proposition\ni. Then, the firing set T0 satisfies the reset-transition requirement of definition 21 (firing set)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 234\n(e) Then {t0, . . . , tx} = T0 – using 1(a),1(b),1(d) above; and using 1(c) it is a maximal firing set\n2. We show M1 is produced by firing T0 in M0. Let holds(p, q, 1) ∈ A\n(a) Then {holds(p, q1, 0), tot incr(p, q2, 0), tot decr(p, q3, 0)} ⊆ A : q = q1 + q2 − q3 – from rule r5 and supported rule proposition\n(b) Then holds(p, q1, 0) ∈ A represents q1 = M0(p) – given, rule i1 construction; (c) Then {add(p, q20, t0, 0), . . . , add(p, q2 j, t j, 0)} ⊆ A : q20 + · · · + q2 j = q2 and {del(p, q30, t0, 0), . . . , del(p, q3l, tl, 0)} ⊆ A : q30 + · · · + q3l = q3 – rules r3, r4 and supported rule proposition, respectively\n(d) Then { f ires(t0, 0), . . . , f ires(t j, 0)} ⊆ A and { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A – rules r6, r7 and supported rule proposition, respectively\n(e) Then { f ires(t0, 0), . . . , f ires(t j, 0)}∪{ f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A = { f ires(t0, 0), . . . , f ires(tx, 0)} ⊆ A – set union of subsets\n(f) Then for each f ires(tx, 0) ∈ A we have tx ∈ T0 – already shown in item 1 above (g) Then q = M0(p) + ∑ tx∈T0∧p∈tx•W(tx, p) − ( ∑ tx∈T0∧p∈•tx W(p, tx) +∑\ntx∈T0∧p∈R(tx) M0(p)) – from (2b) above and the following i. Each add(p, q j, t j, 0) ∈ A represents q j = W(t j, p) for p ∈ t j• – rule r6 encoding, and definition 22 of transition execution in PN\nii. Each del(p, ty, qy, 0) ∈ A represents either qy = W(p, ty) for p ∈ •ty, or qy = M0(p) for p ∈ R(ty) – from rule r7, f 7 encoding and definition 22 of transition execution in PN; or from rule r7, f 9 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2, 0) ∈ A represents q2 = ∑tx∈T0∧p∈tx•W(tx, p) – aggregate assignment atom semantics in rule r3\niv. Each tot decr(p, q3, 0) ∈ A represents q3 = ∑tx∈T0∧p∈•tx W(p, tx)+∑tx∈T0∧p∈R(tx) M0(p) – aggregate assignment atom semantics in rule r4\n(h) Then, M1(p) = q – since holds(p, q, 1) ∈ A encodes q = M1(p) – from construction\nInductive Step: Let k > 0, and Mk is a valid marking in X for PN, show (1) Tk is a valid firing set for Mk, and (2) firing Tk in Mk produces marking Mk+1.\n1. We show that Tk is a valid firing set in Mk. Let { f ires(t0, k), . . . , f ires(tx, k)} be the set of all f ires(. . . , k) atoms in A,\n(a) Then for each f ires(ti, k) ∈ A i. enabled(ti, k) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, k) < A – from rule e2 and supported rule proposition iii. Then either of body(e3), body(e4), or body(e5) must not hold in A – from rule\ne3, e4, e5 and forced atom proposition\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 235\niv. Then q ≮ ni ≡ q ≥ ni in e3 for all {holds(p, q, k), ptarc(p, ti, ni, k)} ⊆ A – from e3, forced atom proposition, and given facts (holds(p, q, k) ∈ A, ptarc(p, ti, ni, k) ∈ A)\nv. And q ni ≡ q < ni in e4 for all {holds(p, q, k), iptarc(p, ti, ni, k)} ⊆ A, ni = 1; q > ni ≡ q = 0 – from e4, forced atom proposition, given facts (holds(p, q, k) ∈ A, iptarc(p, ti, 1, k) ∈ A), and q is a positive integer\nvi. And q ≮ ni ≡ q ≥ ni in e5 for all {holds(p, q, k), tptarc(p, ti, ni, k)} ⊆ A – from e5, forced atom proposition, and given facts\nvii. Then (∀p ∈ •ti,Mk(p) ≥ W(p, ti)) ∧ (∀p ∈ I(ti),Mk(p) = 0) ∧ (∀(p, ti) ∈ Q,Mk(p) ≥ QW(p, ti)) – from A. holds(p, q, k) ∈ A represents q = Mk(p) – inductive assumption, given B. ptarc(p, ti, ni, k) ∈ A represents ni = W(p, ti) – rule f 7 construction; or\nit represents ni = Mk(p) – rule f 9 construction; the construction of f 9 ensures that notenabled(t, k) is never true due to the reset arc\nC. definition 11 of preset •ti in PN D. definition 28 of enabled transition in PN\nviii. Then ti is enabled and can fire in PN, as a result it can belong to Tk – from definition 28 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π4 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, k) ∈ A – from rule a3 and supported rule proposition ii. Then @{holds(p, q, k), tot decr(p, q1, k)} ⊆ A : q1 > q in body(e3) – from a2\nand forced atom proposition iii. Then @p : ( ∑ ti∈{t0,...,tx},p∈•ti W(p, ti) + ∑ ti∈{t0,...,tx},p∈R(ti) Mk(p)) > Mk(p) – from\nthe following A. holds(p, q, k) represents q = Mk(p) – inductive assumption, given B. tot decr(p, q1, k) ∈ A if {del(p, q10, t0, k), . . . , del(p, q1x, tx, k)} ⊆ A, where\nq1 = q10 + · · · + q1x – from r4 and forced atom proposition C. del(p, q1i, ti, k) ∈ A if { f ires(ti, k), ptarc(p, ti, q1i, k)} ⊆ A – from r7 and\nsupported rule proposition D. del(p, q1i, ti, k) either represents removal of q1i = W(p, ti) tokens from\np ∈ •ti; or it represents removal of q1i = Mk(p) tokens from p ∈ R(ti)– from rule r7, supported rule proposition, and definition 22 of transition execution in PN\niv. Then Tk does not contain conflicting transitions – by the definition 23 of conflicting transitions\n(c) And for each enabled(t j, k) ∈ A and f ires(t j, k) < A, could not have(t j, k) ∈ A, since A is an answer set of Π4 - from rule a6 and supported rule proposition\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 236\ni. Then {enabled(t j, k), holds(s, qq, k), ptarc(s, t j, q, k), tot decr(s, qqq, k)} ⊆ A, such that q > qq − qqq and f ires(t j, k) < A - from rule a7 and supported rule proposition\nii. Then for an s ∈ •t j∪R(t j), q > Mk(s)−( ∑ ti∈Tk ,s∈•ti W(s, ti)+ ∑\nti∈Tk ,s∈R(ti) Mk(s)), where q = W(s, t j) if s ∈ •t j, or Mk(s) otherwise - from the following: A. ptarc(s, ti, q, k) represents q = W(s, ti) if (s, ti) ∈ E− or q = Mk(s) if s ∈\nR(ti) – from rule f 7, f 9 construction B. holds(s, qq, k) represents qq = Mk(s) – construction C. tot decr(s, qqq, k) ∈ A if {del(s, qqq0, t0, k), . . . , del(s, qqqx, tx, k)} ⊆ A – from rule r4 construction and supported rule proposition\nD. del(s, qqqi, ti, k) ∈ A if { f ires(ti, k), ptarc(s, ti, qqqi, k)} ⊆ A – from rule r7 and supported rule proposition E. del(s, qqqi, ti, k) represents qqqi = W(s, ti) : ti ∈ Tk, (s, ti) ∈ E−, or qqqi = Mk(ti) : ti ∈ Tk, s ∈ R(ti) – from rule f 7, f 9 construction\nF. tot decr(q, qqq, k) represents ∑\nti∈Tk ,s∈•ti W(s, ti) +∑ ti∈Tk ,s∈R(ti) Mk(s) – from (C,D,E) above\niii. Then firing Tk ∪ {t j} would have required more tokens than are present at its source place s ∈ •t j ∪ R(t j). Thus, Tk is a maximal set of transitions that can simultaneously fire.\n(d) And for each reset transition tr with enabled(tr, k) ∈ A, f ires(tr, k) ∈ A, since A is an answer set of Π2 - from rule f 10 and supported rule proposition\ni. Then the firing set Tk satisfies the reset transition requirement of definition 21 (firing set)\n(e) Then {t0, . . . , tx} = Tk – using 1(a),1(b), 1(d) above; and using 1(c) it is a maximal firing set\n2. We show that Mk+1 is produced by firing Tk in Mk. Let holds(p, q, k + 1) ∈ A\n(a) Then {holds(p, q1, k), tot incr(p, q2, k), tot decr(p, q3, k)} ⊆ A : q = q1 + q2 − q3 – from rule r5 and supported rule proposition\n(b) Then holds(p, q1, k) ∈ A represents q1 = Mk(p) – construction, inductive assumption; and {add(p, q20, t0, k), . . . , add(p, q2 j, t j, k)} ⊆ A : q20 + · · · + q2 j = q2 and {del(p, q30, t0, k), . . . , del(p, q3l, tl, k)} ⊆ A : q30 + · · · + q3l = q3 – rules r3, r4 and supported rule proposition, respectively\n(c) Then { f ires(t0, k), . . . , f ires(t j, k)} ⊆ A and { f ires(t0, k), . . . , f ires(tl, k)} ⊆ A – rules r6, r7 and supported rule proposition, respectively\n(d) Then { f ires(t0, k), . . . , f ires(t j, k)}∪{ f ires(t0, k), . . . , f ires(tl, k)} ⊆ A = { f ires(t0, k), . . . , f ires(tx, k)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, k) ∈ A we have tx ∈ Tk – already shown in item 1 above\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 237\n(f) Then q = Mk(p) + ∑ tx∈T0∧p∈tx•W(tx, p) − ( ∑\ntx∈Tk∧p∈•tx W(p, tx) +∑ tx∈Tk∧p∈R(tx) Mk(p)) – from (2b) above and the following\ni. Each add(p, q j, t j, k) ∈ A represents q j = W(t j, p) for p ∈ t j• – rule r6 encoding, and definition 22 of transition execution in PN\nii. Each del(p, ty, qy, k) ∈ A represents either qy = W(p, ty) for p ∈ •ty, or qy = Mk(p) for p ∈ R(ty) – from rule r7, f 7 encoding and definition 22 of transition execution in PN; or from rule r7, f 9 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2, k) ∈ A represents q2 = ∑tx∈Tk∧p∈tx•W(tx, p) – aggregate assignment atom semantics in rule r3\niv. Each tot decr(p, q3, 0) ∈ A represents q3 = ∑tx∈Tk∧p∈•tx W(p, tx)+∑tx∈Tk∧p∈R(tx) M0(p) – aggregate assignment atom semantics in rule r4\n(g) Then, Mk+1(p) = q – since holds(p, q, k + 1) ∈ A encodes q = Mk+1(p) – from construction\nAs a result, for any n > k, Tn will be a valid firing set for Mn and Mn+1 will be its target marking. Conclusion: Since both (I) and (II) hold, X = M0,T0,M1, . . . ,Mk,Tk+1 is an execution sequence of PN(P,T, E,W,R) (w.r.t M0) iff there is an answer set A of Π4(PN,M0, k, ntok) such that (A.5) and (A.6) hold.\nA.6 Proof of Proposition 6\nLet PN = (P,T, E,C,W,R, I,Q,QW) be a Petri Net, M0 be its initial marking and let Π5(PN,M0, k, ntok) be the ASP encoding of PN and M0 over a simulation length k, with maximum ntok tokens on any place node, as defined in section 2.8. Then X = M0,Tk,M1, . . . ,Mk,Tk,Mk+1 is an execution sequence of PN (w.r.t. M0) iff there is an answer set A of Π5(PN,M0, k, ntok) such that:\n{ f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} = { f ires(t, ts) : f ires(t, ts) ∈ A} (A.11) {holds(p, q, c, ts) : p ∈ P, c/q = Mts(p), 0 ≤ ts ≤ k + 1}\n= {holds(p, q, c, ts) : holds(p, q, c, ts) ∈ A} (A.12)\nWe prove this by showing that:\n(I) Given an execution sequence X, we create a set A such that it satisfies (A.11) and (A.12) and show that A is an answer set of Π5\n(II) Given an answer set A of Π5, we create an execution sequence X such that (A.11) and (A.12) are satisfied.\nFirst we show (I): Given PN and an execution sequence X of PN, we create a set A as a union of the following sets:\n1. A1 = {num(n) : 0 ≤ n ≤ ntok}\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 238\n2. A2 = {time(ts) : 0 ≤ ts ≤ k}\n3. A3 = {place(p) : p ∈ P}\n4. A4 = {trans(t) : t ∈ T }\n5. A5 = {color(c) : c ∈ C}\n6. A6 = {ptarc(p, t, nc, c, ts) : (p, t) ∈ E−, c ∈ C, nc = mW(p,t)(c), nc > 0, 0 ≤ ts ≤ k}, where E− ⊆ E\n7. A7 = {tparc(t, p, nc, c, ts) : (t, p) ∈ E+, c ∈ C, nc = mW(t,p)(c), nc > 0, 0 ≤ ts ≤ k}, where E+ ⊆ E\n8. A8 = {holds(p, qc, c, 0) : p ∈ P, c ∈ C, qc = mM0(p)(c)}\n9. A9 = {ptarc(p, t, nc, c, ts) : p ∈ R(t), c ∈ C, nc = mMts(p), nc > 0, 0 ≤ ts ≤ k}\n10. A10 = {iptarc(p, t, 1, c, ts) : p ∈ I(t), c ∈ C, 0 ≤ ts < k}\n11. A11 = {tptarc(p, t, nc, c, ts) : (p, t) ∈ Q, c ∈ C, nc = mQW(p,t)(c), nc > 0, 0 ≤ ts ≤ k}\n12. A12 = {notenabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∃c ∈ C, (∃p ∈ •t,mMts(p)(c) < mW(p,t)(c)) ∨ (∃p ∈ I(t),mMts(p)(c) > 0) ∨ (∃(p, t) ∈ Q,mMts(p)(c) < mQW(p,t)(c))} per definition 32 (enabled transition)\n13. A13 = {enabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∀c ∈ C, (∀p ∈ •t,mW(p,t)(c) ≤ mMts(p)(c)) ∧ (∀p ∈ I(t),mMts(p)(c) = 0) ∧ (∀(p, t) ∈ Q,mMts(p)(c) ≥ mQW(p,t)(c))} per definition 32 (enabled transition)\n14. A14 = { f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} per definition 35 (firing set), only an enabled transition may fire\n15. A15 = {add(p, qc, t, c, ts) : t ∈ Tts, p ∈ t•, c ∈ C, qc = mW(t,p)(c), 0 ≤ ts ≤ k} per definition 33 (transition execution)\n16. A16 = {del(p, qc, t, c, ts) : t ∈ Tts, p ∈ •t, c ∈ C, qc = mW(p,t)(c), 0 ≤ ts ≤ k} ∪ {del(p, qc, t, c, ts) : t ∈ Tts, p ∈ R(t), c ∈ C, qc = mMts(p)(c), 0 ≤ ts ≤ k} per definition 33 (transition execution)\n17. A17 = {tot incr(p, qc, c, ts) : p ∈ P, c ∈ C, qc = ∑\nt∈Tts,p∈t•mW(t,p)(c), 0 ≤ ts ≤ k} per definition 36 (firing set execution)\n18. A18 = {tot decr(p, qc, c, ts) : p ∈ P, c ∈ C, qc = ∑\nt∈Tts,p∈•t mW(p,t)(c) +∑ t∈Tts,p∈R(t) mMts(p)(c), 0 ≤ ts ≤ k} per definition 36 (firing set execution)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 239\n19. A19 = {consumesmore(p, ts) : p ∈ P, c ∈ C, qc = mMts(p)(c), q1c = ∑ t∈Tts,p∈•t mW(p,t)(c) + ∑ t∈Tts,p∈R(t) mMts(p)(c), q1 > q, 0 ≤ ts ≤ k}\nper definition 34 (conflicting transitions)\n20. A20 = {consumesmore : ∃p ∈ P, c ∈ C, qc = mMts(p)(c), q1c = ∑ t∈Tts,p∈•t mW(p,t)(c) + ∑ t∈Tts,p∈R(t)(mMts(p)(c)), q1 > q, 0 ≤ ts ≤ k}\nper definition 34 (conflicting transitions) per the maximal firing set semantics\n21. A21 = {holds(p, qc, c, ts + 1) : p ∈ P, c ∈ C, qc = mMts+1(p)(c), 0 ≤ ts < k}, where Mts+1(p) = Mts(p) − ( ∑ t∈Tts,p∈•t W(p, t) +∑\nt∈Tts,p∈R(t) Mts(p)) + ∑\nt∈Tts,p∈t•W(t, p) according to definition 36 (firing set execution)\nWe show that A satisfies (A.11) and (A.12), and A is an answer set of Π5. A satisfies (A.11) and (A.12) by its construction above. We show A is an answer set of Π5 by splitting. We split lit(Π5) into a sequence of 7k + 9 sets:\n• U0 = head( f 1)∪head( f 2)∪head( f 13)∪head( f 5)∪head( f 6)∪head(i2) = {place(p) : p ∈ P}∪{trans(t) : t ∈ T }∪{col(c) : c ∈ C}∪{time(0), . . . , time(k)}∪{num(0), . . . , num(ntok)}∪ {holds(p, qc, c, 0) : p ∈ P, c ∈ C, qc = mM0(p)(c)}\n• U7k+1 = U7k+0∪head( f 14)ts=k∪head( f 15)ts=k∪head( f 16)ts=k∪head( f 17)ts=k∪head( f 18)ts=k = U7k+0 ∪ {ptarc(p, t, nc, c, k) : (p, t) ∈ E−, c ∈ C, nc = mW(p,t)(c)} ∪ {tparc(t, p, nc, c, k) : (t, p) ∈ E+, c ∈ C, nc = mW(t,p)(c)} ∪ {ptarc(p, t, nc, c, k) : p ∈ R(t), c ∈ C, nc = mMk(p)(c), n > 0} ∪ {iptarc(p, t, 1, c, k) : p ∈ I(t), c ∈ C} ∪ {tptarc(p, t, nc, c, k) : (p, t) ∈ Q, c ∈ C, nc = mQW(p,t)(c)}\n• U7k+2 = U7k+1 ∪ head(e6)ts=k ∪ head(e7)ts=k ∪ head(e8)ts=k = U7k+1 ∪ {notenabled(t, k) : t ∈ T }\n• U7k+3 = U7k+2 ∪ head(e9)ts=k = U7k+2 ∪ {enabled(t, k) : t ∈ T }\n• U7k+4 = U7k+3 ∪ head(a1)ts=k = U7k+3 ∪ { f ires(t, k) : t ∈ T }\n• U7k+5 = U7k+4 ∪ head(r8)ts=k ∪ head(r9)ts=k = U7k+4 ∪ {add(p, qc, t, c, k) : p ∈ P, t ∈ T, c ∈ C, qc = mW(t,p)(c)} ∪ {del(p, qc, t, c, k) : p ∈ P, t ∈ T, c ∈ C, qc = mW(p,t)(c)} ∪ {del(p, qc, t, c, k) : p ∈ P, t ∈ T, c ∈ C, qc = mMk(p)(c)}\n• U7k+6 = U7k+5 ∪ head(r10)ts=k ∪ head(r11)ts=k = U7k+5 ∪ {tot incr(p, qc, c, k) : p ∈ P, c ∈ C, 0 ≤ qc ≤ ntok} ∪ {tot decr(p, qc, c, k) : p ∈ P, c ∈ C, 0 ≤ qc ≤ ntok}\n• U7k+7 = U7k+6 ∪ head(a9)ts=k ∪ head(r12)ts=k = U7k+6 ∪ {consumesmore(p, k) : p ∈ P} ∪ {holds(p, q, k + 1) : p ∈ P, 0 ≤ q ≤ ntok}\n• U7k+8 = U7k+7 ∪ head(a3) = U7k+7 ∪ {consumesmore}\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 240\nwhere head(ri)ts=k are head atoms of ground rule ri in which ts = k. We write Ats=ki = {a(. . . , ts) : a(. . . , ts) ∈ Ai, ts = k} as short hand for all atoms in Ai with ts = k. Uα, 0 ≤ α ≤ 7k + 8 form a splitting sequence, since each Ui is a splitting set of Π5, and 〈Uα〉α<µ is a monotone continuous sequence, where U0 ⊆ U1 · · · ⊆ U7k+8 and ⋃ α<µ Uα = lit(Π5).\nWe compute the answer set of Π5 using the splitting sets as follows:\n1. botU0(Π 5) = f 1 ∪ f 2 ∪ f 14 ∪ f 9 ∪ f 18 ∪ i2 and X0 = A1 ∪ · · · ∪ A5 ∪ A8 (= U0) is its\nanswer set – using forced atom proposition\n2. evalU0(botU1(Π 5) \\ botU0(Π5), X0) = {ptarc(p, t, qc, c, 0):-.|c ∈ C, qc = mW(p,t)(c), qc >\n0} ∪ {tparc(t, p, qc, c, 0):-.|c ∈ C, qc = mW(t,p)(c), qc > 0} ∪ {ptarc(p, t, qc, c, 0):-.|c ∈ C, qc = mM0(p)(c), qc > 0} ∪ {iptarc(p, t, 1, c, 0):-.|c ∈ C} ∪ {tptarc(p, t, qc, c, 0):-.|c ∈ C, qc = mQW(p,t)(c), qc > 0}. Its answer set X1 = Ats=06 ∪ A ts=0 7 ∪ A ts=0 9 ∪ A ts=0 10 ∪ A ts=0 11 – using forced atom proposition and construction of A6, A7, A9, A10, A11.\n3. evalU1(botU2(Π 5) \\ botU1(Π5), X0 ∪ X1) = {notenabled(t, 0):-.|({trans(t),\nptarc(p, t, nc, c, 0), holds(p, qc, c, 0)} ⊆ X0 ∪ X1, where qc < nc) or ({notenabled(t, 0):-.|({trans(t), iptarc(p, t, n2c, c, 0), holds(p, qc, c, 0)} ⊆ X0 ∪ X1, where qc ≥ n2c}) or ({trans(t), tptarc(p, t, n3c, c, 0), holds(p, qc, c, 0)} ⊆ X0∪X1, where qc < n3c)}. Its answer set X2 = Ats=012 – using forced atom proposition and construction of A12.\n(a) where, qc = mM0(p)(c), and nc = mW(p,t)(c) for an arc (p, t) ∈ E− – by construction of i2 and f 14 in Π5, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 31 of preset) (c) n2c = 1 – by construction of iptarc predicates in Π5, meaning qc ≥ n2c ≡ qc ≥ 1 ≡\nqc > 0,\n(d) tptarc(p, t, n3c, c, 0) represents n3c = mQW(p,t)(c), where (p, t) ∈ Q (e) thus, notenabled(t, 0) ∈ X1 represents ∃c ∈ C, (∃p ∈ •t : mM0(p)(c) < mW(p,t)(c)) ∨\n(∃p ∈ I(t) : mM0(p)(c) > 0) ∨ (∃(p, t) ∈ Q : mM0(p)(c) < mQW(p,t)(c)).\n4. evalU2(botU3(Π 5) \\ botU2(Π5), X0 ∪ · · · ∪ X2) = {enabled(t, 0):-.|trans(t) ∈ X0 ∪ · · · ∪\nX2, notenabled(t, 0) < X0 ∪ · · · ∪ X2}. Its answer set is X3 = Ats=013 – using forced atom proposition and construction of A13.\n(a) where, an enabled(t, 0) ∈ X3 if @ notenabled(t, 0) ∈ X0∪· · ·∪X2; which is equivalent to ∀c ∈ C, (@p ∈ •t : mM0(p)(c) < mW(p,t)(c))∧(@p ∈ I(t) : mM0(p)(c) > 0)∧(@(p, t) ∈ Q : mM0(p)(c) < mQW(p,t)(c)) ≡ ∀c ∈ C, (∀p ∈ •t : mM0(p)(c) ≥ mW(p,t)(c)) ∧ (∀p ∈ I(t) : mM0(p)(c) = 0).\n5. evalU3(botU4(Π 5) \\ botU3(Π5), X0 ∪ · · · ∪ X3) = {{ f ires(t, 0)}:-.|enabled(t, 0)\nholds in X0 ∪ · · · ∪ X3}. It has multiple answer sets X4.1, . . . , X4.n, corresponding to elements of power set of f ires(t, 0) atoms in evalU3(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π5 determined using splitting is\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 241\nequal to A, we only consider the set that matches the f ires(t, 0) elements in A and call it X4, ignoring the rest. Thus, X4 = Ats=014 , representing T0.\n(a) in addition, for every t such that enabled(t, 0) ∈ X0 ∪ · · · ∪ X3,R(t) , ∅; f ires(t, 0) ∈ X4 – per definition 35 (firing set); requiring that a reset transition is fired when enabled\n(b) thus, the firing set T0 will not be eliminated by the constraint f 10\n6. evalU4(botU5(Π 5) \\ botU4(Π5), X0 ∪ · · · ∪ X4) = {add(p, nc, t, c, 0):-.|{ f ires(t, 0),\ntparc(t, p, nc, c, 0)} ⊆ X0 ∪ · · · ∪ X4} ∪ {del(p, nc, t, c, 0):-.|{ f ires(t, 0), ptarc(p, t, nc, c, 0)} ⊆ X0 ∪ · · · ∪ X4}. It’s answer set is X5 = Ats=015 ∪ A ts=0 16 – using forced atom proposition and definitions of A15 and A16.\n(a) where, each add atom is equivalent to nc = mW(t,p)(c), c ∈ C, p ∈ t•, (b) and each del atom is equivalent to nc = mW(p,t)(c), c ∈ C, p ∈ •t; or nc = mM0(p)(c), c ∈\nC, p ∈ R(t), (c) representing the effect of transitions in T0\n7. evalU5(botU6(Π 5)\\botU5(Π5), X0∪· · ·∪X5) = {tot incr(p, qqc, c, 0):-.|qqc = ∑ add(p,qc,t,c,0)∈X0∪···∪X5 qc}∪\n{tot decr(p, qqc, c, 0):-.|qqc =∑ del(p,qc,t,c,0)∈X0∪···∪X5 qc}. It’s answer set is X6 = Ats=017 ∪ A ts=0 18 – using forced atom proposition and definitions of A17 and A18.\n(a) where, each tot incr(p, qqc, c, 0), qqc = ∑\nadd(p,qc,t,c,0)∈X0∪...X5 qc ≡ qqc = ∑ t∈X4,p∈t•mW(p,t)(c),\n(b) and each tot decr(p, qqc, c, 0), qqc = ∑\ndel(p,qc,t,c,0)∈X0∪...X5 qc ≡ qq = ∑t∈X4,p∈•t mW(t,p)(c) + ∑t∈X4,p∈R(t) mM0(p)(c),\n(c) represent the net effect of transitions in T0\n8. evalU6(botU7(Π 5) \\ botU6(Π5), X0 ∪ · · · ∪ X6) = {consumesmore(p, 0):-.|\n{holds(p, qc, c, 0), tot decr(p, q1c, c, 0)} ⊆ X0 ∪ · · · ∪ X6, q1c > qc} ∪ {holds(p, qc, c, 1):-., |{holds(p, q1c, c, 0), tot incr(p, q2c, c, 0), tot decr(p, q3c, c, 0)} ⊆ X0 ∪ · · · ∪ X6, qc = q1c + q2c − q3c}. It’s answer set is X7 = Ats=019 ∪ A ts=0 21 – using forced atom proposition and definitions of A19, A21.\n(a) where, consumesmore(p, 0) represents ∃p : qc = mM0(p)(c), q1c =∑ t∈T0,p∈•t mW(p,t)(c) + ∑ t∈T0,p∈R(t) mM0(p)(c), q1c > qc, c ∈ C, indicating place p will\nbe over consumed if T0 is fired, as defined in definition 34 (conflicting transitions),\n(b) holds(p, qc, c, 1) represents qc = mM1(p)(c) – by construction of Π 5\n...\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 242\n9. evalU7k+0(botU7k+1(Π 5) \\ botU7k+0(Π5), X0 ∪ · · · ∪ X7k+0) = {ptarc(p, t, qc, c, k):-.|c ∈ C, qc =\nmW(p, t)(c), qc > 0}∪{tparc(t, p, qc, c, k):-.|c ∈ C, qc = mW(t,p)(c), qc > 0}∪ {ptarc(p, t, qc, c, k):-.| c ∈ C, qc = mMk(p)(c), qc > 0} ∪ {iptarc(p, t, 1, c, k):-.|c ∈ C} ∪ {tptarc(p, t, qc, c, k):-.|c ∈ C, qc = mQW(p,t)(c), qc > 0}. Its answer set X7k+1 = Ats=k6 ∪ A ts=k 7 ∪ A ts=k 9 ∪ A ts=k 10 ∪ A ts=k 11 – using forced atom proposition and construction of A6, A7, A9, A10, A11.\n10. evalU7k+1(botU7k+2(Π 5) \\ botU7k+1(Π5), X0 ∪ · · · ∪ X7k+1) = {notenabled(t, k):-.|\n({trans(t), ptarc(p, t, nc, c, k), holds(p, qc, c, k)} ⊆ X0 ∪ · · · ∪ X7k+1, where qc < nc) or ({notenabled(t, k):-.|({trans(t), iptarc(p, t, n2c, c, k), holds(p, qc, c, k)} ⊆ X0∪· · ·∪X7k+1, where qc ≥ n2c}) or ({trans(t), tptarc(p, t, n3c, c, k), holds(p, qc, c, k)} ⊆ X0 ∪ · · · ∪ X7k+1, where qc < n3c)}. Its answer set X7k+2 = Ats=k12 – using forced atom proposition and construction of A12.\n(a) since qc = mMk(p)(c), and nc = mW(p,t)(c) for an arc (p, t) ∈ E− – by construction of holds and ptarc predicates in Π5, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 31 of preset) (c) n2c = 1 – by construction of iptarc predicates in Π5, meaning qc ≥ n2c ≡ qc ≥ 1 ≡\nqc > 0,\n(d) tptarc(p, t, n3c, c, k) represents n3c = mQW(p,t)(c), where (p, t) ∈ Q (e) thus, notenabled(t, k) ∈ X8k+1 represents ∃c ∈ C(∃p ∈ •t : mMk(p)(c) < mW(p,t)(c)) ∨\n(∃p ∈ I(t) : mMk(p)(c) > 0) ∨ (∃(p, t) ∈ Q : mMts(p)(c) < mQW(p,t)(c)).\n11. evalU7k+2(botU7k+3(Π 5) \\ botU7k+2(Π5), X0 ∪ · · · ∪ X7k+2) = {enabled(t, k):-.|trans(t) ∈ X0 ∪\n· · · ∪ X7k+2 ∧ notenabled(t, k) < X0 ∪ · · · ∪ X7k+2}. Its answer set is X7k+3 = Ats=k13 – using forced atom proposition and construction of A13.\n(a) since an enabled(t, k) ∈ X7k+3 if @ notenabled(t, k) ∈ X0 ∪ · · · ∪ X7k+2; which is equivalent to ∀c ∈ C, (@p ∈ •t : mMk(p)(c) < mW(p,t)(c)) ∧ (@p ∈ I(t) : mMk(p)(c) > 0) ∧ (@(p, t) ∈ Q : mMk(p)(c) < mQW(p,t)(c)) ≡ ∀c ∈ C, (∀p ∈ •t : mMk(p)(c) ≥ mW(p,t)(c)) ∧ (∀p ∈ I(t) : mMk(p)(c) = 0).\n12. evalU7k+3(botU7k+4(Π 5) \\ botU7k+3(Π5), X0 ∪ · · · ∪ X7k+3) = {{ f ires(t, k)}:-.|\nenabled(t, k) holds in X0 ∪ · · · ∪ X7k+3}. It has multiple answer sets X7k+4.1, . . . , X7k+4.n, corresponding to elements of power set of f ires(t, k) atoms in evalU3(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π5 determined using splitting is equal to A, we only consider the set that matches the f ires(t, k) elements in A and call it X7k+4, ignoring the rest. Thus, X7k+4 = Ats=k14 , representing Tk.\n(a) in addition, for every t such that enabled(t, k) ∈ X0∪· · ·∪X7k+3,R(t) , ∅; f ires(t, k) ∈ X7k+4 – per definition 35 (firing set); requiring that a reset transition is fired when enabled\n(b) thus, the firing set Tk will not be eliminated by the constraint f 10\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 243\n13. evalU7k+4(botU7k+5(Π 5) \\ botU7k+4(Π5), X0 ∪ · · · ∪ X7k+4) = {add(p, nc, t, c, k):-.| { f ires(t, k),\ntparc(t, p, nc, c, k)} ⊆ X0 ∪ · · · ∪ X7k+4}∪ {del(p, nc, t, c, k):-.| { f ires(t, k), ptarc(p, t, nc, c, k)} ⊆ X0 ∪ · · · ∪ X7k+4}. It’s answer set is X7k+5 = Ats=k15 ∪ A ts=k 16 – using forced atom proposition and definitions of A15 and A16.\n(a) where each add atom is equivalent to nc = mW(t,p)(c), c ∈ C, p ∈ t•, (b) and each del atom is equivalent to nc = mW(p,t)(c), c ∈ C, p ∈ •t; or nc = mMk(p)(c), c ∈\nC, p ∈ R(t), (c) representing the effect of transitions in Tk\n14. evalU7k+5(botU7k+6(Π 5) \\ botU7k+5(Π5), X0 ∪ · · · ∪ X7k+5) = {tot incr(p, qqc, c, k):-.| qq =∑\nadd(p,qc,t,c,k)∈X0∪···∪X7k+5 qc}∪ {tot decr(p, qqc, c, k):-.| qqc = ∑ del(p,qc,t,c,k)∈X0∪···∪X7k+5 qc}. It’s answer set is X7k+6 = Ats=k17 ∪ A ts=k 18 – using forced atom proposition and definitions of A17 and A18.\n(a) where, each tot incr(p, qqc, c, k), qqc = ∑\nadd(p,qc,t,c,k)∈X0∪...X8k+5 qc ≡ qqc = ∑ t∈X7k+4,p∈t•mW(p,t)(c),\n(b) and each tot decr(p, qqc, c, k), qqc = ∑\ndel(p,qc,t,c,k)∈X0∪...X8k+5 qc ≡ qq = ∑t∈X7k+4,p∈•t mW(t,p)(c) + ∑t∈X7k+4,p∈R(t) mMk(p)(c),\n(c) represent the net effect of transitions in Tk\n15. evalU7k+6(botU7k+7(Π 5) \\ botU7k+6(Π5), X0 ∪ · · · ∪ X7k+6) = {consumesmore(p, k):-.|\n{holds(p, qc, c, k), tot decr(p, q1c, c, k)} ⊆ X0 ∪ · · · ∪ X7k+6, q1 > q} ∪ {holds(p, qc, c, k + 1):-.|{holds(p, q1c, c, k), tot incr(p, q2c, c, k), tot decr(p, q3c, c, k)} ⊆ X0 ∪ · · · ∪ X7k+6, qc = q1c + q2c − q3c}. It’s answer set is X7k+7 = Ats=k19 ∪ A ts=k 21 – using forced atom proposition and definitions of A19, A21.\n(a) where, consumesmore(p, k) represents ∃p : qc = mMk(p)(c), q1c =∑ t∈Tk ,p∈•t mW(p,t)(c) + ∑ t∈Tk ,p∈R(t) mMk(p)(c), q1c > qc, c ∈ C, indicating place p that\nwill be over consumed if Tk is fired, as defined in definition 34 (conflicting transitions),\n(b) and holds(p, qc, c, k + 1) represents qc = mMk+1(p)(c) – by construction of Π 5\n16. evalU7k+7(botU7k+8(Π 5) \\ botU7k+7(Π5), X0 ∪ · · · ∪ X7k+7) = {consumesmore:-.|\n{consumesmore(p, 0), . . . , consumesmore(p, k)} ∩ (X0 ∪ · · · ∪ X7k+7) , ∅}. It’s answer set is X7k+8 = Ats=k20 – using forced atom proposition and the definition of A20\n(a) X7k+7 will be empty since none of consumesmore(p, 0), . . . , consumesmore(p, k) hold in X0 ∪ · · · ∪ X7k+7 due to the construction of A, encoding of a9 and its body atoms. As a result, it is not eliminated by the constraint a4\nThe set X = X0 ∪ · · · ∪ X7k+8 is the answer set of Π5 by the splitting sequence theorem 15. Each Xi, 0 ≤ i ≤ 7k + 8 matches a distinct portion of A, and X = A, thus A is an answer set of Π5.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 244\nNext we show (II): Given Π5 be the encoding of a Petri Net PN(P,T, E,C,W,R, I, Q,WQ) with initial marking M0, and A be an answer set of Π5 that satisfies (A.11) and (A.12), then we can construct X = M0,Tk, . . . ,Mk,Tk,Mk+1 from A, such that it is an execution sequence of PN.\nWe construct the X as follows:\n1. Mi = (Mi(p0), . . . ,Mi(pn)), where {holds(p0,mMi(p0)(c), c, i), . . . holds(pn,mMi(pn)(c), c, i)} ⊆ A, for c ∈ C, 0 ≤ i ≤ k + 1\n2. Ti = {t : f ires(t, i) ∈ A}, for 0 ≤ i ≤ k\nand show that X is indeed an execution sequence of PN. We show this by induction over k (i.e. given Mk, Tk is a valid firing set and its firing produces marking Mk+1).\nBase case: Let k = 0, and M0 is a valid marking in X for PN, show (1) T0 is a valid firing set for M0, and (2) firing T0 in M0 results in marking M1.\n1. We show T0 is a valid firing set for M0. Let { f ires(t0, 0), . . . , f ires(tx, 0)} be the set of all f ires(. . . , 0) atoms in A,\n(a) Then for each f ires(ti, 0) ∈ A i. enabled(ti, 0) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, 0) < A – from rule e9 and supported rule proposition iii. Then either of body(e6), body(e7), or body(e8) must not hold in A – from rules\ne6, e7, e8 and forced atom proposition iv. Then qc ≮ nic ≡ qc ≥ nic in e6 for all {holds(p, qc, c, 0),\nptarc(p, ti, nic, c, 0)} ⊆ A – from e6, forced atom proposition, and given facts (holds(p, qc, c, 0) ∈ A, ptarc(p, ti, nic, 0) ∈ A) v. And qc nic ≡ qc < nic in e7 for all {holds(p, qc, c, 0), iptarc(p, ti, nic, c, 0)} ⊆ A, nic = 1; qc > nic ≡ qc = 0 – from e7, forced atom proposition, given facts (holds(p, qc, c, 0) ∈ A, iptarc(p, ti, 1, c, 0) ∈ A), and qc is a positive integer\nvi. And qc ≮ nic ≡ qc ≥ nic in e8 for all {holds(p, qc, c, 0), tptarc(p, ti, nic, c, 0)} ⊆ A – from e8, forced atom proposition, and given facts\nvii. Then ∀c ∈ C, (∀p ∈ •ti,mM0(p)(c) ≥ mW(p,ti)(c)) ∧ (∀p ∈ I(ti),mM0(p)(c) = 0) ∧ (∀(p, ti) ∈ Q,mM0(p)(c) ≥ mQW(p,ti)(c)) – from the following A. holds(p, qc, c, 0) ∈ A represents qc = mM0(p)(c) – rule i2 construction B. ptarc(p, ti, nic, 0) ∈ A represents nic = mW(p,ti)(c) – rule f 14 construction;\nor it represents nic = mM0(p)(c) – rule f 16 construction; the construction of f 16 ensures that notenabled(t, 0) is never true for a reset arc\nC. definition 31 of preset •ti in PN D. definition 32 of enabled transition in PN\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 245\nviii. Then ti is enabled and can fire in PN, as a result it can belong to T0 – from definition 32 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π5 – from rule a3 and supported rule proposition\ni. Then @consumesmore(p, 0) ∈ A – from rule a9 and supported rule proposition ii. Then @{holds(p, qc, c, 0), tot decr(p, q1c, c, 0)} ⊆ A, q1c > qc in body(a9) –\nfrom a9 and forced atom proposition iii. Then @c ∈ C@p ∈ P, (∑ti∈{t0,...,tx},p∈•ti mW(p,ti)(c) +∑\nti∈{t0,...,tx},p∈R(ti) mM0(p)(c)) > mM0(p)(c) – from the following A. holds(p, qc, c, 0) represents qc = mM0(p)(c) – from rule i2 construction,\ngiven B. tot decr(p, q1c, c, 0) ∈ A if {del(p, q10c, t0, c, 0), . . . ,\ndel(p, q1xc, tx, c, 0)} ⊆ A, where q1c = q10c + · · · + q1xc – from r11 and forced atom proposition\nC. del(p, q1ic, ti, c, 0) ∈ A if { f ires(ti, 0), ptarc(p, ti, q1ic, c, 0)} ⊆ A – from r9 and supported rule proposition\nD. del(p, q1ic, ti, c, 0) either represents removal of q1ic = mW(p,ti)(c) tokens from p ∈ •ti; or it represents removal of q1ic = mM0(p)(c) tokens from p ∈ R(ti)– from rules r9, f 14, f 16, supported rule proposition, and definition 33 of transition execution in PN\niv. Then the set of transitions in T0 do not conflict – by the definition 34 of conflicting transitions\n(c) And for each reset transition tr with enabled(tr, 0) ∈ A, f ires(tr, 0) ∈ A, since A is an answer set of Π5 - from rule f 10 and supported rule proposition\ni. Then, the firing set T0 satisfies the reset-transition requirement of definition 35 (firing set)\n(d) Then {t0, . . . , tx} = T0 – using 1(a),1(b),1(d) above; and using 1(c) it is a maximal firing set\n2. We show M1 is produced by firing T0 in M0. Let holds(p, qc, c, 1) ∈ A\n(a) Then {holds(p, q1c, c, 0), tot incr(p, q2c, c, 0), tot decr(p, q3c, c, 0)} ⊆ A : qc = q1c+ q2c − q3c – from rule r12 and supported rule proposition\n(b) Then, holds(p, q1c, c, 0) ∈ A represents q1c = mM0(p)(c) – given, rule i2 construction; and {add(p, q20c, t0, c, 0), . . . , add(p, q2 jc, t j, c, 0)} ⊆ A : q20c+· · ·+q2 jc = q2c and {del(p, q30c, t0, c, 0), . . . , del(p, q3lc, tl, c, 0)} ⊆ A : q30c +· · ·+q3lc = q3c – rules r10, r11 and supported rule proposition, respectively\n(c) Then { f ires(t0, 0), . . . , f ires(t j, 0)} ⊆ A and { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A – rules r8, r9 and supported rule proposition, respectively\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 246\n(d) Then { f ires(t0, 0), . . . , f ires(t j, 0)}∪ { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A = { f ires(t0, 0), . . . , f ires(tx, 0)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, 0) ∈ A we have tx ∈ T0 – already shown in item 1 above (f) Then qc = mM0(p)(c)+ ∑ tx∈T0∧p∈tx•mW(tx,p)(c)−( ∑ tx∈T0∧p∈•tx mW(p,tx)(c)+ ∑ tx∈T0∧p∈R(tx) mM0(p)(c))\n– from (2b) above and the following\ni. Each add(p, q jc, t j, c, 0) ∈ A represents q jc = mW(t j,p)(c) for p ∈ t j• – rule r8, f 15 encoding, and definition 33 of transition execution in PN\nii. Each del(p, ty, qyc, c, 0) ∈ A represents either qyc = mW(p,ty)(c) for p ∈ •ty, or qyc = mM0(p)(c) for p ∈ R(ty) – from rule r9, f 14 encoding and definition 33 of transition execution in PN; or from rule r9, f 16 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2c, c, 0) ∈ A represents q2c = ∑\ntx∈T0∧p∈tx•mW(tx,p)(c) – aggregate assignment atom semantics in rule r10\niv. Each tot decr(p, q3c, c, 0) ∈ A represents q3c = ∑ tx∈T0∧p∈•tx mW(p,tx)(c)+ ∑\ntx∈T0∧p∈R(tx) mM0(p)(c) – aggregate assignment atom semantics in rule r11\n(g) Then, mM1(p)(c) = qc – since holds(p, qc, c, 1) ∈ A encodes qc = mM1(p)(c) – from construction\nInductive Step: Let k > 0, and Mk is a valid marking in X for PN, show (1) Tk is a valid firing set for Mk, and (2) firing Tk in Mk produces marking Mk+1.\n1. We show that Tk is a valid firing set in Mk. Let { f ires(t0, k), . . . , f ires(tx, k)} be the set of all f ires(. . . , k) atoms in A,\n(a) Then for each f ires(ti, k) ∈ A i. enabled(ti, k) ∈ A – from rule a1 and supported rule proposition\nii. Then notenabled(ti, k) < A – from rule e9 and supported rule proposition iii. Then either of body(e6), body(e7), or body(e8) must not hold in A – from rules\ne6, e7, e8 and forced atom proposition iv. Then qc ≮ nic ≡ qc ≥ nic in e6 for all {holds(p, qc, c, k),\nptarc(p, ti, nic, c, k)} ⊆ A – from e6, forced atom proposition, given facts, and the inductive assumption\nv. And qc nic ≡ qc < nic in e7 for all {holds(p, qc, c, k), iptarc(p, ti, nic, c, k)} ⊆ A, nic = 1; qc > nic ≡ qc = 0 – from e7, forced atom proposition, given facts (holds(p, qc, c, k) ∈ A, iptarc(p, ti, 1, c, k) ∈ A), and qc is a positive integer\nvi. And qc ≮ nic ≡ qc ≥ nic in e8 for all {holds(p, qc, c, k), tptarc(p, ti, nic, c, k)} ⊆ A – from e8, forced atom proposition, and inductive assumption\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 247\nvii. Then (∀p ∈ •ti,mMk(p)(c) ≥ mW(p,ti)(c))∧(∀p ∈ I(ti),mMk(p)(c) = 0)∧(∀(p, ti) ∈ Q,mMk(p)(c) ≥ mQW(p,ti)(c)) – from A. holds(p, qc, c, k) ∈ A represents qc = mMk(p)(c) – construction of Π5 B. ptarc(p, ti, nic, k) ∈ A represents nic = mW(p,ti)(c) – rule f 14 construction;\nor it represents nic = mMk(p)(c) – rule f 16 construction; the construction of f 16 ensures that notenabled(t, k) is never true for a reset arc\nC. definition 31 of preset •ti in PN D. definition 32 of enabled transition in PN\nviii. Then ti is enabled and can fire in PN, as a result it can belong to Tk – from definition 32 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π5 – from rule a3 and supported rule proposition\ni. Then @consumesmore(p, k) ∈ A – from rule a9 and supported rule proposition ii. Then @{holds(p, qc, c, k), tot decr(p, q1c, c, k)} ⊆ A, q1c > qc in body(a9) –\nfrom a9 and forced atom proposition iii. Then @c ∈ C,@p ∈ P, (∑ti∈{t0,...,tx},p∈•ti mW(p,ti)(c) +∑\nti∈{t0,...,tx},p∈R(ti) mMk(p)(c)) > mMk(p)(c) – from the following A. holds(p, qc, c, k) represents qc = mMk(p)(c) – construction of Π\n5, inductive assumption\nB. tot decr(p, q1c, c, k) ∈ A if {del(p, q10c, t0, c, k), . . . , del(p, q1xc, tx, c, k)} ⊆ A, where q1c = q10c + · · · + q1xc – from r11 and forced atom proposition\nC. del(p, q1ic, ti, c, k) ∈ A if { f ires(ti, k), ptarc(p, ti, q1ic, c, k)} ⊆ A – from r9 and supported rule proposition\nD. del(p, q1ic, ti, c, k) either represents removal of q1ic = mW(p,ti)(c) tokens from p ∈ •ti; or it represents removal of q1ic = mMk(p)(c) tokens from p ∈ R(ti)– from rules r9, f 14, f 16, supported rule proposition, and definition 33 of transition execution in PN\niv. Then the set of transitions in Tk do not conflict – by the definition 34 of conflicting transitions\n(c) And for each reset transition tr with enabled(tr, k) ∈ A, f ires(tr, k) ∈ A, since A is an answer set of Π5 - from rule f 10 and supported rule proposition\ni. Then the firing set Tk satisfies the reset transition requirement of definition 35 (firing set)\n(d) Then {t0, . . . , tx} = Tk – using 1(a),1(b), 1(d) above; and using 1(c) it is a maximal firing set\n2. We show that Mk+1 is produced by firing Tk in Mk. Let holds(p, qc, c, k + 1) ∈ A\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 248\n(a) Then {holds(p, q1c, c, k), tot incr(p, q2c, c, k), tot decr(p, q3c, c, k)} ⊆ A : qc = q1c+ q2c − q3c – from rule r12 and supported rule proposition\n(b) Then, holds(p, q1c, c, k) ∈ A represents q1c = mMk(p)(c) – construction, inductive assumption; and {add(p, q20c, t0, c, k), . . . , add(p, q2 jc, t j, c, k)} ⊆ A : q20c + · · · + q2 jc = q2c and {del(p, q30c, t0, c, k), . . . , del(p, q3lc, tl, c, k)} ⊆ A : q30c + · · ·+q3lc = q3c – rules r10, r11 and supported rule proposition, respectively\n(c) Then { f ires(t0, k), . . . , f ires(t j, k)} ⊆ A and { f ires(t0, k), . . . , f ires(tl, k)} ⊆ A – rules r8, r9 and supported rule proposition, respectively\n(d) Then { f ires(t0, k), . . . , f ires(t j, k)}∪{ f ires(t0, k), . . . , f ires(tl, k)} ⊆ A = { f ires(t0, k), . . . , f ires(tx, k)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, k) ∈ A we have tx ∈ Tk – already shown in item 1 above (f) Then qc = mMk(p)(c)+ ∑ tx∈Tk∧p∈tx•mW(tx,p)(c)−( ∑ tx∈Tk∧p∈•tx mW(p,tx)(c)+ ∑ tx∈Tk∧p∈R(tx) mMk(p)(c))\n– from (2b) above and the following\ni. Each add(p, q jc, t j, c, k) ∈ A represents q jc = mW(t j,p)(c) for p ∈ t j• – rule r8, f 15 encoding, and definition 33 of transition execution in PN\nii. Each del(p, ty, qyc, c, k) ∈ A represents either qyc = mW(p,ty)(c) for p ∈ •ty, or qyc = mMk(p)(c) for p ∈ R(ty) – from rule r9, f 14 encoding and definition 33 of transition execution in PN; or from rule r9, f 16 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2c, c, k) ∈ A represents q2c = ∑\ntx∈Tk∧p∈tx•mW(tx,p)(c) – aggregate assignment atom semantics in rule r10\niv. Each tot decr(p, q3c, c, k) ∈ A represents q3c = ∑ tx∈Tk∧p∈•tx mW(p,tx)(c)+ ∑\ntx∈Tk∧p∈R(tx) mMk(p)(c) – aggregate assignment atom semantics in rule r11\n(g) Then, mMk+1(p)(c) = qc – since holds(p, qc, c, k + 1) ∈ A encodes qc = mMk+1(p)(c) – from construction\nAs a result, for any n > k, Tn will be a valid firing set for Mn and Mn+1 will be its target marking. Conclusion: Since both (I) and (II) hold, X = M0,Tk,M1, . . . ,Mk,Tk+1 is an execution sequence of PN(P,T, E,C,W,R, I,Q,QW) (w.r.t M0) iff there is an answer set A of Π5(PN,M0, k, ntok) such that (A.11) and (A.12) hold.\nA.7 Proof of Proposition 7\nLet PN = (P,T, E,C,W,R, I,Q,QW,Z) be a Petri Net, M0 be its initial marking and let Π6(PN,M0, k, ntok) be the ASP encoding of PN and M0 over a simulation length k, with maximum ntok tokens on any place node, as defined in section 2.10. Then X = M0,Tk,M1, . . . ,Mk,Tk,Mk+1 is an execution sequence of PN (w.r.t. M0) iff there is an answer set A of Π6(PN,M0, k, ntok) such that:\n{ f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} = { f ires(t, ts) : f ires(t, ts) ∈ A} (A.13)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 249\n{holds(p, q, c, ts) : p ∈ P, c/q = Mts(p), 0 ≤ ts ≤ k + 1} = {holds(p, q, c, ts) : holds(p, q, c, ts) ∈ A}\n(A.14)\nWe prove this by showing that:\n(I) Given an execution sequence X, we create a set A such that it satisfies (A.13) and (A.14) and show that A is an answer set of Π6\n(II) Given an answer set A of Π6, we create an execution sequence X such that (A.13) and (A.14) are satisfied.\nFirst we show (I): We create a set A as a union of the following sets:\n1. A1 = {num(n) : 0 ≤ n ≤ ntok}\n2. A2 = {time(ts) : 0 ≤ ts ≤ k}\n3. A3 = {place(p) : p ∈ P}\n4. A4 = {trans(t) : t ∈ T }\n5. A5 = {color(c) : c ∈ C}\n6. A6 = {ptarc(p, t, nc, c, ts) : (p, t) ∈ E−, c ∈ C, nc = mW(p,t)(c), nc > 0, 0 ≤ ts ≤ k}, where E− ⊆ E\n7. A7 = {tparc(t, p, nc, c, ts) : (t, p) ∈ E+, c ∈ C, nc = mW(t,p)(c), nc > 0, 0 ≤ ts ≤ k}, where E+ ⊆ E\n8. A8 = {holds(p, qc, c, 0) : p ∈ P, c ∈ C, qc = mM0(p)(c)}\n9. A9 = {ptarc(p, t, nc, c, ts) : p ∈ R(t), c ∈ C, nc = mMts(p), nc > 0, 0 ≤ ts ≤ k}\n10. A10 = {iptarc(p, t, 1, c, ts) : p ∈ I(t), c ∈ C, 0 ≤ ts < k}\n11. A11 = {tptarc(p, t, nc, c, ts) : (p, t) ∈ Q, c ∈ C, nc = mQW(p,t)(c), nc > 0, 0 ≤ ts ≤ k}\n12. A12 = {notenabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∃c ∈ C, (∃p ∈ •t,mMts(p)(c) < mW(p,t)(c)) ∨ (∃p ∈ I(t),mMts(p)(c) > 0) ∨ (∃(p, t) ∈ Q,mMts(p)(c) < mQW(p,t)(c))} per definition 40 (enabled transition)\n13. A13 = {enabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∀c ∈ C, (∀p ∈ •t,mW(p,t)(c) ≤ mMts(p)(c)) ∧ (∀p ∈ I(t),mMts(p)(c) = 0) ∧ (∀(p, t) ∈ Q,mMts(p)(c) ≥ mQW(p,t)(c))} per definition 40 (enabled transition)\n14. A14 = { f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} per definition 41 (firing set), only an enabled transition may fire\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 250\n15. A15 = {add(p, qc, t, c, ts) : t ∈ Tts, p ∈ t•, c ∈ C, qc = mW(t,p)(c), 0 ≤ ts ≤ k} per definition 33 (transition execution)\n16. A16 = {del(p, qc, t, c, ts) : t ∈ Tts, p ∈ •t, c ∈ C, qc = mW(p,t)(c), 0 ≤ ts ≤ k} ∪ {del(p, qc, t, c, ts) : t ∈ Tts, p ∈ R(t), c ∈ C, qc = mMts(p)(c), 0 ≤ ts ≤ k} per definition 33 (transition execution)\n17. A17 = {tot incr(p, qc, c, ts) : p ∈ P, c ∈ C, qc = ∑\nt∈Tts,p∈t•mW(t,p)(c), 0 ≤ ts ≤ k} per definition 36 (firing set execution)\n18. A18 = {tot decr(p, qc, c, ts) : p ∈ P, c ∈ C, qc = ∑\nt∈Tts,p∈•t mW(p,t)(c) +∑ t∈Tts,p∈R(t) mMts(p)(c), 0 ≤ ts ≤ k} per definition 36 (firing set execution)\n19. A19 = {consumesmore(p, ts) : p ∈ P, c ∈ C, qc = mMts(p)(c), q1c = ∑ t∈Tts,p∈•t mW(p,t)(c) + ∑ t∈Tts,p∈R(t) mMts(p)(c), q1c > qc, 0 ≤ ts ≤ k}\nper definition 34 (conflicting transitions)\n20. A20 = {consumesmore : ∃p ∈ P, c ∈ C, qc = mMts(p)(c), q1c = ∑ t∈Tts,p∈•t mW(p,t)(c) + ∑ t∈Tts,p∈R(t)(mMts(p)(c)), q1c > qc, 0 ≤ ts ≤ k}\nper definition 34 (conflicting transitions)\n21. A21 = {holds(p, qc, c, ts + 1) : p ∈ P, c ∈ C, qc = mMts+1(p)(c), 0 ≤ ts < k}, where Mts+1(p) = M j(p) − ( ∑ t∈Tts,p∈•t W(p, t) + ∑ t∈Tts,p∈R(t) Mts(p)) +∑\nt∈Tts,p∈t•W(t, p) according to definition 36 (firing set execution)\n22. A22 = {transpr(t, pr) : t ∈ T, pr = Z(t)}\n23. A23 = {notprenabled(t, ts) : t ∈ T, enabled(t, ts) ∈ A13, (∃tt ∈ T, enabled(tt, ts) ∈ A13,Z(tt) < Z(t)), 0 ≤ ts ≤ k} = {notprenabled(t, ts) : t ∈ T, (∀p ∈ •t,W(p, t) ≤ Mts(p)), (∀p ∈ I(t),Mts(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ WQ(p, t)),∃tt ∈ T, (∀pp ∈ •tt,W(pp, tt) ≤ Mts(pp)), (∀pp ∈ I(tt),Mts(pp) = 0), (∀(pp, tt) ∈ Q,Mts(pp) ≥ QW(pp, tt)),Z(tt) < Z(t), 0 ≤ ts ≤ k}\n24. A24 = {prenabled(t, ts) : t ∈ T, enabled(t, ts) ∈ A13, (@tt ∈ T : enabled(tt, ts) ∈ A13,Z(tt) < Z(t)), 0 ≤ ts ≤ k} = {prenabled(t, ts) : t ∈ T, (∀p ∈ •t,W(p, t) ≤ Mts(p)), (∀p ∈ I(t),Mts(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ WQ(p, t)),@tt ∈ T, (∀pp ∈ •tt,W(pp, tt) ≤ Mts(pp)), (∀pp ∈ I(tt),Mts(pp) = 0), (∀(pp, tt) ∈ Q,Mts(pp) ≥ QW(pp, tt)),Z(tt) < Z(t), 0 ≤ ts ≤ k}\n25. A25 = {could not have(t, ts) : t ∈ T, prenabled(t, ts) ∈ A24, f ires(t, ts) < A14, (∃p ∈ •t∪R(t) : q > Mts(p)− ( ∑ t′∈Tts,p∈•t′ W(p, t ′) + ∑\nt′∈Tts,p∈R(t′) Mts(p)), q = W(p, t) if (p, t) ∈ E− or R(t) otherwise), 0 ≤ ts ≤ k} = {could not have(t, ts) : t ∈ T, (∀p ∈ •t,W(p, t) ≤\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 251\nMts(p)), (∀p ∈ I(t),Mts(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)), (@tt ∈ T, (∀pp ∈ •tt,W(pp, tt) ≤ Mts(pp)), (∀pp ∈ I(tt),Mts(pp) = 0), (∀(pp, tt) ∈ Q,Mts(pp) ≥ QW(pp, tt)),Z(tt) < Z(t)), t < Tts, (∃p ∈ •t∪R(t) : q > Mts(p)−( ∑ t′∈Tts,p∈•t′ W(p, t ′)+ ∑\nt′∈Tts,p∈R(t′) Mts(p)), q = W(p, t) if (p, t) ∈ E− or R(t) otherwise), 0 ≤ ts ≤ k} per the maximal firing set semantics\nWe show that A satisfies (A.13) and (A.14), and A is an answer set of Π6. A satisfies (A.13) and (A.14) by its construction above. We show A is an answer set of Π6 by splitting. We split lit(Π6) into a sequence of 9k + 11 sets:\n• U0 = head( f 1)∪head( f 2)∪head( f 13)∪head( f 5)∪head( f 6)∪head(i2)∪head( f 19) = {place(p) : p ∈ P} ∪ {trans(t) : t ∈ T } ∪ {col(c) : c ∈ C} ∪ {time(0), . . . , time(k)} ∪ {num(0), . . . , num(ntok)}∪{holds(p, qc, c, 0) : p ∈ P, c ∈ C, qc = mM0(p)(c)}∪{transpr(t, pr) : t ∈ T, pr = Z(t)}\n• U9k+1 = U9k+0∪head( f 14)ts=k∪head( f 15)ts=k∪head( f 16)ts=k∪head( f 17)ts=k∪head( f 18)ts=k = U10k+0 ∪ {ptarc(p, t, nc, c, k) : (p, t) ∈ E−, c ∈ C, nc = mW(p,t)(c)} ∪ {tparc(t, p, nc, c, k) : (t, p) ∈ E+, c ∈ C, nc = mW(t,p)(c)} ∪ {ptarc(p, t, nc, c, k) : p ∈ R(t), c ∈ C, nc = mMk(p)(c), n > 0}∪{iptarc(p, t, 1, c, k) : p ∈ I(t), c ∈ C}∪{tptarc(p, t, nc, c, k) : (p, t) ∈ Q, c ∈ C, nc = mQW(p,t)(c)}\n• U9k+2 = U9k+1 ∪ head(e6)ts=k ∪ head(e7)ts=k ∪ head(e8)ts=k = U9k+1 ∪ {notenabled(t, k) : t ∈ T }\n• U9k+3 = U9k+2 ∪ head(e9)ts=k = U9k+2 ∪ {enabled(t, k) : t ∈ T }\n• U9k+4 = U9k+3 ∪ head(a11)ts=k = U9k+3 ∪ {notprenabled(t, k) : t ∈ T }\n• U9k+5 = U9k+4 ∪ head(a12)ts=k = U9k+4 ∪ {prenabled(t, k) : t ∈ T }\n• U9k+6 = U9k+5 ∪ head(a13)ts=k = U9k+5 ∪ { f ires(t, k) : t ∈ T }\n• U9k+7 = U9k+6 ∪ head(r8)ts=k ∪ head(r9)ts=k = U9k+6 ∪ {add(p, qc, t, c, k) : p ∈ P, t ∈ T, c ∈ C, qc = mW(t,p)(c)} ∪ {del(p, qc, t, c, k) : p ∈ P, t ∈ T, c ∈ C, qc = mW(p,t)(c)} ∪ {del(p, qc, t, c, k) : p ∈ P, t ∈ T, c ∈ C, qc = mMk(p)(c)}\n• U9k+8 = U9k+7 ∪ head(r10)ts=k ∪ head(r11)ts=k = U9k+7 ∪ {tot incr(p, qc, c, k) : p ∈ P, c ∈ C, 0 ≤ qc ≤ ntok} ∪ {tot decr(p, qc, c, k) : p ∈ P, c ∈ C, 0 ≤ qc ≤ ntok}\n• U9k+9 = U9k+8 ∪ head(a9)ts=k ∪ head(r12)ts=k ∪ head(a14)ts=k = U9k+8 ∪ {consumesmore(p, k) : p ∈ P}∪{holds(p, q, k+1) : p ∈ P, 0 ≤ q ≤ ntok}∪{could not have(t, k) : t ∈ T }\n• U9k+10 = U9k+9 ∪ head(a3)ts=k = U9k+9 ∪ {consumesmore}\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 252\nwhere head(ri)ts=k are head atoms of ground rule ri in which ts = k. We write Ats=ki = {a(. . . , ts) : a(. . . , ts) ∈ Ai, ts = k} as short hand for all atoms in Ai with ts = k. Uα, 0 ≤ α ≤ 9k + 10 form a splitting sequence, since each Ui is a splitting set of Π6, and 〈Uα〉α<µ is a monotone continuous sequence, where U0 ⊆ U1 · · · ⊆ U9k+10 and ⋃ α<µ Uα = lit(Π6).\nWe compute the answer set of Π6 using the splitting sets as follows:\n1. botU0(Π 6) = f 1 ∪ f 2 ∪ f 13 ∪ f 5 ∪ f 6 ∪ i2 ∪ f 19 and X0 = A1 ∪ · · · ∪ A5 ∪ A8 (= U0) is\nits answer set – using forced atom proposition\n2. evalU0(botU1(Π 6) \\ botU0(Π6), X0) = {ptarc(p, t, qc, c, 0):-.|c ∈ C, qc = mW(p,t)(c), qc >\n0} ∪ {tparc(t, p, qc, c, 0):-.|c ∈ C, qc = mW(t,p)(c), qc > 0} ∪ {ptarc(p, t, qc, c, 0):-.|c ∈ C, qc = mM0(p)(c), qc > 0} ∪ {iptarc(p, t, 1, c, 0):-.|c ∈ C} ∪ {tptarc(p, t, qc, c, 0):-.|c ∈ C, qc = mQW(p,t)(c), qc > 0}. Its answer set X1 = Ats=06 ∪ A ts=0 7 ∪ A ts=0 9 ∪ A ts=0 10 ∪ A ts=0 11 – using forced atom proposition and construction of A6, A7, A9, A10, A11.\n3. evalU1(botU2(Π 6) \\ botU1(Π6), X0 ∪ X1) = {notenabled(t, 0):-.|({trans(t),\nptarc(p, t, nc, c, 0), holds(p, qc, c, 0)} ⊆ X0 ∪ X1, where qc < nc) or ({notenabled(t, 0):-.|({trans(t), iptarc(p, t, n2c, c, 0), holds(p, qc, c, 0)} ⊆ X0 ∪ X1, where qc ≥ n2c}) or ({trans(t), tptarc(p, t, n3c, c, 0), holds(p, qc, c, 0)} ⊆ X0 ∪ X1, where qc < n3c)}. Its answer set X2 = Ats=012 – using forced atom proposition and construction of A12.\n(a) where, qc = mM0(p)(c), and nc = mW(p,t)(c) for an arc (p, t) ∈ E− – by construction of i2 and f 14 in Π6, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 31 of preset) (c) n2c = 1 – by construction of iptarc predicates in Π6, meaning qc ≥ n2c ≡ qc ≥ 1 ≡\nqc > 0,\n(d) tptarc(p, t, n3c, c, 0) represents n3c = mQW(p,t)(c), where (p, t) ∈ Q (e) thus, notenabled(t, 0) ∈ X1 represents ∃c ∈ C, (∃p ∈ •t : mM0(p)(c) < mW(p,t)(c)) ∨\n(∃p ∈ I(t) : mM0(p)(c) > 0) ∨ (∃(p, t) ∈ Q : mM0(p)(c) < mQW(p,t)(c)).\n4. evalU2(botU3(Π 6) \\ botU2(Π6), X0 ∪ · · · ∪ X2) = {enabled(t, 0):-.|trans(t) ∈ X0 ∪ · · · ∪\nX2, notenabled(t, 0) < X0 ∪ · · · ∪ X2}. Its answer set is X3 = Ats=013 – using forced atom proposition and construction of A13.\n(a) since an enabled(t, 0) ∈ X3 if @ notenabled(t, 0) ∈ X0 ∪ · · · ∪ X2; which is equivalent to @t,∀c ∈ C, (@p ∈ •t,mM0(p)(c) < mW(p,t)(c)), (@p ∈ I(t), mM0(p)(c) > 0), (@(p, t) ∈ Q : mM0(p)(c) < mQW(p,t)(c)),∀c ∈ C, (∀p ∈ •t : mM0(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t) : mM0(p)(c) = 0).\n5. evalU3(botU4(Π 6) \\ botU3(Π6), X0 ∪ · · · ∪ X3) = {notprenabled(t, 0):-.|\n{enabled(t, 0), transpr(t, p), enabled(tt, 0), transpr(tt, pp)} ⊆ X0 ∪ · · · ∪ X3, pp < p}. Its answer set is X4 = Ats=k23 – using forced atom proposition and construction of A23.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 253\n(a) enabled(t, 0) represents ∃t ∈ T,∀c ∈ C, (∀p ∈ •t,mM0(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t),mM0(p)(c) = 0), (∀(p, t) ∈ Q,mM0(p)(c) ≥ mQW(p,t)(c)) (b) enabled(tt, 0) represents ∃tt ∈ T,∀c ∈ C, (∀pp ∈ •tt,mM0(pp)(c) ≥ mW(pp,tt)(c))∧(∀pp ∈ I(tt),mM0(pp)(c) = 0), (∀(pp, tt) ∈ Q,mM0(pp)(c) ≥ mQW(pp,tt)(c))\n(c) transpr(t, p) represents p = Z(t) – by construction\n(d) transpr(tt, pp) represents pp = Z(tt) – by construction\n(e) thus, notprenabled(t, 0) represents ∀c ∈ C, (∀p ∈ •t,mM0(p)(c) ≥ mW(p,t)(c))∧(∀p ∈ I(t),mM0(p)(c) = 0),∃tt ∈ T, (∀pp ∈ •tt,mM0(pp)(c) ≥ mW(pp,tt)(c))∧ (∀pp ∈ I(tt),mM0(pp)(c) = 0),Z(tt) < Z(t) (f) which is equivalent to (∀p ∈ •t : M0(p) ≥ W(p, t)) ∧ (∀p ∈ I(t),M0(p) = 0),∃tt ∈ T, (∀pp ∈ •tt,M0(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),M0(pp) = 0),Z(tt) < Z(t) – assuming multiset domain C for all operations\n6. evalU4(botU5(Π 6) \\ botU4(Π6), X0 ∪ · · · ∪ X4) = {prenabled(t, 0):-.|enabled(t, 0) ∈ X0 ∪\n· · · ∪ X4, notprenabled(t, 0) < X0 ∪ · · · ∪ X4}. Its answer set is X5 = Ats=k24 – using forced atom proposition and construction of A24\n(a) enabled(t, 0) represents ∀c ∈ C, (∀p ∈ •t,mM0(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t),mM0(p)(c) = 0), (∀(p, t) ∈ Q,mM0(p)(c) ≥ mQW(p,t)(c)) ≡ (∀p ∈ •t, M0(p) ≥ W(p, t)), (∀p ∈ I(t),M0(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)) – from 4 above and assuming multiset domain C for all operations\n(b) notprenabled(t, 0) represents (∀p ∈ •t,M0(p) ≥ W(p, t)), (∀p ∈ I(t), M0(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)),∃tt ∈ T, (∀pp ∈ •tt,M0(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),M0(pp) = 0), (∀(pp, tt) ∈ Q,M0(pp) ≥ W(pp, tt)), Z(tt) < Z(t) – from 5 above and assuming multiset domain C for all operations\n(c) then, prenabled(t, 0) represents (∀p ∈ •t,M0(p) ≥ W(p, t)), (∀p ∈ I(t), M0(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)),@tt ∈ T, ((∀pp ∈ •tt,M0(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),M0(pp) = 0), (∀(pp, tt) ∈ Q,M0(pp) ≥ W(pp, tt)), Z(tt) < Z(t)) – from (a), (b) and enabled(t, 0) ∈ X0 ∪ · · · ∪ X4\n7. evalU5(botU6(Π 6) \\ botU5(Π6), X0 ∪ · · · ∪ X5) = {{ f ires(t, 0)}:-.|prenabled(t, 0)\nholds in X0 ∪ · · · ∪ X5}. It has multiple answer sets X6.1, . . . , X6.n, corresponding to elements of power set of f ires(t, 0) atoms in evalU5(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π6 determined using splitting is equal to A, we only consider the set that matches the f ires(t, 0) elements in A and call it X6, ignoring the rest. Thus, X6 = Ats=014 , representing T0.\n(a) in addition, for every t such that prenabled(t, 0) ∈ X0∪· · ·∪X5,R(t) , ∅; f ires(t, 0) ∈ X6 – per definition 41 (firing set); requiring that a reset transition is fired when enabled\n(b) thus, the firing set T0 will not be eliminated by the constraint f 20\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 254\n8. evalU6(botU7(Π 6) \\ botU6(Π6), X0 ∪ · · · ∪ X6) = {add(p, nc, t, c, 0):-.|{ f ires(t, 0),\ntparc(t, p, nc, c, 0)} ⊆ X0 ∪ · · · ∪ X6} ∪ {del(p, nc, t, c, 0):-.|{ f ires(t, 0), ptarc(p, t, nc, c, 0)} ⊆ X0 ∪ · · · ∪ X6}. It’s answer set is X7 = Ats=015 ∪ A ts=0 16 – using forced atom proposition and definitions of A15 and A16.\n(a) where, each add atom is equivalent to nc = mW(t,p)(c), c ∈ C, p ∈ t•, (b) and each del atom is equivalent to nc = mW(p,t)(c), c ∈ C, p ∈ •t; or nc = mM0(p)(c), c ∈\nC, p ∈ R(t), (c) representing the effect of transitions in T0 – by construction\n9. evalU7(botU8(Π 6)\\botU7(Π6), X0∪· · ·∪X7) = {tot incr(p, qqc, c, 0):-.|qqc = ∑ add(p,qc,t,c,0)∈X0∪···∪X7 qc}∪\n{tot decr(p, qqc, c, 0):-.|qqc = ∑\ndel(p,qc,t,c,0)∈X0∪···∪X7 qc}. It’s answer set is X8 = Ats=017 ∪ Ats=018 – using forced atom proposition and definitions of A17 and A18.\n(a) where, each tot incr(p, qqc, c, 0), qqc = ∑\nadd(p,qc,t,c,0)∈X0∪...X7 qc ≡ qqc = ∑ t∈X6,p∈t•mW(p,t)(c),\n(b) where, each tot decr(p, qqc, c, 0), qqc = ∑\ndel(p,qc,t,c,0)∈X0∪...X7 qc ≡ qq = ∑t∈X6,p∈•t mW(t,p)(c) + ∑t∈X6,p∈R(t) mM0(p)(c),\n(c) represent the net effect of transitions in T0\n10. evalU8(botU9(Π 6) \\ botU8(Π6), X0 ∪ · · · ∪ X8) = {consumesmore(p, 0):-.|\n{holds(p, qc, c, 0), tot decr(p, q1c, c, 0)} ⊆ X0 ∪ · · · ∪ X8, q1c > qc} ∪ {holds(p, qc, c, 1):-.|{holds(p, q1c, c, 0), tot incr(p, q2c, c, 0), tot decr(p, q3c, c, 0)} ⊆ X0 ∪ · · · ∪ X6, qc = q1c + q2c − q3c} ∪ {could not have(t, 0):-.|{prenabled(t, 0), ptarc(s, t, q, c, 0), holds(s, qq, c, 0), tot decr(s, qqq, c, 0)} ⊆ X0 ∪ · · · ∪ X8, f ires(t, 0) < X0 ∪ · · · ∪ X8, q > qq − qqq}. It’s answer set is X9 = Ats=019 ∪ A ts=0 21 ∪ A ts=0 25 – using forced atom proposition and definitions of A19, A21, A25.\n(a) where, consumesmore(p, 0) represents ∃p : qc = mM0(p)(c), q1c =∑ t∈T0,p∈•t mW(p,t)(c) + ∑ t∈T0,p∈R(t) mM0(p)(c), q1c > qc, c ∈ C, indicating place p will\nbe over consumed if T0 is fired, as defined in definition 34 (conflicting transitions), (b) holds(p, qc, c, 1) if qc = mM0(p)(c) + ∑\nt∈T0,p∈t•mW(t,p)(c) − ( ∑ t∈T0,p∈•t mW(p,t)(c)+ ∑\nt∈T0,p∈R(t) mM0(p)(c)) represented by qc = mM1(p)(c) for some c ∈ C – by construction of Π6\n(c) could not have(t, 0) if\ni. (∀p ∈ •t,W(p, t) ≤ M0(p)), (∀p ∈ I(t),M0(p) = 0), (∀(p, t) ∈ Q, M0(p) ≥ WQ(p, t)),@tt ∈ T, (∀pp ∈ •tt,W(pp, tt) ≤ Mts(pp)), (∀pp ∈ I(tt),M0(pp) = 0), (∀(pp, tt) ∈ Q,M0(pp) ≥ QW(pp, tt)),Z(tt) < Z(t),\nii. and qc > mM0(s)(c) − ( ∑ t′∈T0,s∈•t′ mW(s,t′)(c) + ∑\nt′∈T0,s∈R(t) mM0(s)(c)), qc = mW(s,t)(c) if s ∈ •t or mM0(s)(c) otherwise for some c ∈ C, which becomes q > M0(s) − ( ∑ t′∈T0,s∈•t′ W(s, t ′) + ∑\nt′∈T0,s∈R(t) M0(s)), q = W(s, t) if s ∈ •t or M0(s) otherwise for all c ∈ C\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 255\niii. (i), (ii) above combined match the definition of A25 (d) X9 does not contain could not have(t, 0), when prenabled(t, 0) ∈ X0 ∪ · · · ∪ X8 and\nf ires(t, 0) < X0 ∪ · · · ∪ X8 due to construction of A, encoding of a9 and its body atoms. As a result, it is not eliminated by the constraint a6\n...\n11. evalU9k+0(botU9k+1(Π 6) \\ botU9k+0(Π6), X0 ∪ · · · ∪ X9k+0) = {ptarc(p, t, qc, c, k):-.|c ∈ C, qc =\nmW(p,t)(c), qc > 0}∪{tparc(t, p, qc, c, k):-.|c ∈ C, qc = mW(t,p)(c), qc > 0}∪{ptarc(p, t, qc, c, k):-.|c ∈ C, qc = mM0(p)(c), qc > 0} ∪ {iptarc(p, t, 1, c, k):-.|c ∈ C} ∪ {tptarc(p, t, qc, c, k):-.|c ∈ C, qc = mQW(p,t)(c), qc > 0}. Its answer set X9k+1 = Ats=k6 ∪ A ts=k 7 ∪ A ts=k 9 ∪ A ts=k 10 ∪ A ts=k 11 – using forced atom proposition and construction of A6, A7, A9, A10, A11.\n12. evalU9k+1(botU9k+2(Π 6) \\ botU9k+1(Π6), X0 ∪ · · · ∪ X9k+1) = {notenabled(t, k):-.| ({trans(t),\nptarc(p, t, nc, c, k), holds(p, qc, c, k)} ⊆ X0∪· · ·∪X10k+1, where qc < nc) or ({notenabled(t, k):-.| ({trans(t), iptarc(p, t, n2c, c, k), holds(p, qc, c, k)} ⊆ X0∪· · ·∪X10k+1, where qc ≥ n2c}) or ({trans(t), tptarc(p, t, n3c, c, k), holds(p, qc, c, k)} ⊆ X0 ∪ X9k+1, where qc < n3c)}. Its answer set X9k+2 = Ats=k12 – using forced atom proposition and construction of A12.\n(a) where, qc = mM0(p)(c), and nc = mW(p,t)(c) for an arc (p, t) ∈ E− – by construction of i2 and f 14 predicates in Π6, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 31 of preset) (c) n2c = 1 – by construction of iptarc predicates in Π6, meaning qc ≥ n2c ≡ qc ≥ 1 ≡\nqc > 0,\n(d) tptarc(p, t, n3c, c, k) represents n3c = mQW(p,t)(c), where (p, t) ∈ Q (e) thus, notenabled(t, k) ∈ X9k+1 represents ∃c ∈ C, (∃p ∈ •t : mM0(p)(c) < mW(p,t)(c))∨\n(∃p ∈ I(t) : mM0(p)(c) > k) ∨ (∃(p, t) ∈ Q : mM0(p)(c) < mQW(p,t)(c)).\n13. evalU9k+2(botU9k+3(Π 6) \\ botU9k+2(Π6), X0 ∪ · · · ∪ X9k+2) = {enabled(t, k):-.|trans(t) ∈ X0 ∪\n· · · ∪ X9k+2, notenabled(t, k) < X0 ∪ · · · ∪ X9k+2}. Its answer set is X9k+3 = Ats=k13 – using forced atom proposition and construction of A13.\n(a) since an enabled(t, k) ∈ X9k+3 if @ notenabled(t, k) ∈ X0 ∪ · · · ∪ X9k+2; which is equivalent to @t,∀c ∈ C, (@p ∈ •t,mM0(p)(c) < mW(p,t)(c)), (@p ∈ I(t),mM0(p)(c) > k), (@(p, t) ∈ Q : mM0(p)(c) < mQW(p,t)(c)),∀c ∈ C, (∀p ∈ •t : mM0(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t) : mM0(p)(c) = k).\n14. evalU9k+3(botU9k+4(Π 6) \\ botU9k+3(Π6), X0 ∪ · · · ∪ X9k+3) = {notprenabled(t, k):-.|\n{enabled(t, k), transpr(t, p), enabled(tt, k), transpr(tt, pp)} ⊆ X0 ∪ · · · ∪ X9k+3, pp < p}. Its answer set is X9k+4 = Ats=k23 – using forced atom proposition and construction of A23.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 256\n(a) enabled(t, k) represents ∃t ∈ T,∀c ∈ C, (∀p ∈ •t,mM0(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t),mM0(p)(c) = k), (∀(p, t) ∈ Q,mM0(p)(c) ≥ mQW(p,t)(c))\n(b) enabled(tt, k) represents ∃tt ∈ T,∀c ∈ C, (∀pp ∈ •tt,mM0(pp)(c) ≥ mW(pp,tt)(c))∧(∀pp ∈ I(tt),mM0(pp)(c) = k), (∀(pp, tt) ∈ Q,mM0(pp)(c) ≥ mQW(pp,tt)(c))\n(c) transpr(t, p) represents p = Z(t) – by construction\n(d) transpr(tt, pp) represents pp = Z(tt) – by construction\n(e) thus, notprenabled(t, k) represents ∀c ∈ C, (∀p ∈ •t,mM0(p)(c) ≥ mW(p,t)(c)) ∧ (∀p ∈ I(t),mM0(p)(c) = k),∃tt ∈ T, (∀pp ∈ •tt,mM0(pp)(c) ≥ mW(pp,tt)(c))∧ (∀pp ∈ I(tt),mM0(pp)(c) = k),Z(tt) < Z(t)\n(f) which is equivalent to (∀p ∈ •t : M0(p) ≥ W(p, t)) ∧ (∀p ∈ I(t),M0(p) = k),∃tt ∈ T, (∀pp ∈ •tt,M0(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),M0(pp) = k),Z(tt) < Z(t) – assuming multiset domain C for all operations\n15. evalU9k+4(botU9k+5(Π 6)\\botU9k+4(Π6), X0∪· · ·∪X9k+4) = {prenabled(t, k):-.| enabled(t, k) ∈\nX0 ∪ · · · ∪ X9k+4, notprenabled(t, k) < X0 ∪ · · · ∪ X9k+4}. Its answer set is X9k+5 = Ats=k24 – using forced atom proposition and construction of A24\n(a) enabled(t, k) represents ∀c ∈ C, (∀p ∈ •t,mM0(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t),mM0(p)(c) = k), (∀(p, t) ∈ Q,mM0(p)(c) ≥ mQW(p,t)(c)) ≡ (∀p ∈ •t,M0(p) ≥ W(p, t)), (∀p ∈ I(t),M0(p) = k), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)) – from 13 above and assuming multiset domain C for all operations\n(b) notprenabled(t, k) represents (∀p ∈ •t,M0(p) ≥ W(p, t)), (∀p ∈ I(t), M0(p) = k), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)),∃tt ∈ T, (∀pp ∈ •tt,M0(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),M0(pp) = k), (∀(pp, tt) ∈ Q,M0(pp) ≥ W(pp, tt)), Z(tt) < Z(t) – from 14 above and assuming multiset domain C for all operations\n(c) then, prenabled(t, k) represents (∀p ∈ •t,M0(p) ≥ W(p, t)), (∀p ∈ I(t), M0(p) = k), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)),@tt ∈ T, ((∀pp ∈ •tt,M0(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),M0(pp) = k), (∀(pp, tt) ∈ Q,M0(pp) ≥ W(pp, tt)), Z(tt) < Z(t)) – from (a), (b) and enabled(t, k) ∈ X0 ∪ · · · ∪ X9k+4\n16. evalU9k+5(botU9k+6(Π 6) \\ botU9k+5(Π6), X0 ∪ · · · ∪ X9k+5) = {{ f ires(t, k)}:-.|\nprenabled(t, k) holds in X0 ∪ · · · ∪ X9k+5}. It has multiple answer sets X9k+6.1, . . . , X9k+6.n, corresponding to elements of power set of f ires(t, k) atoms in evalU9k+5(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π6 determined using splitting is equal to A, we only consider the set that matches the f ires(t, k) elements in A and call it X9k+6, ignoring the rest. Thus, X9k+6 = Ats=k14 , representing Tk.\n(a) in addition, for every t such that prenabled(t, k) ∈ X0 ∪ · · · ∪ X9k+5,R(t) , ∅; f ires(t, k) ∈ X9k+6 – per definition 41 (firing set); requiring that a reset transition is fired when enabled\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 257\n(b) thus, the firing set Tk will not be eliminated by the constraint f 20\n17. evalU9k+6(botU9k+7(Π 6) \\ botU9k+6(Π6), X0 ∪ · · · ∪ X9k+6) = {add(p, nc, t, c, k):-.|\n{ f ires(t, k), tparc(t, p, nc, c, k)} ⊆ X0 ∪ · · · ∪ X9k+6} ∪ {del(p, nc, t, c, k):-.| { f ires(t, k), ptarc(p, t, nc, c, k)} ⊆ X0∪· · ·∪X9k+6}. It’s answer set is X9k+7 = Ats=k15 ∪A ts=k 16 – using forced atom proposition and definitions of A15 and A16.\n(a) where, each add atom is equivalent to nc = mW(t,p)(c), c ∈ C, p ∈ t•, (b) and each del atom is equivalent to nc = mW(p,t)(c), c ∈ C, p ∈ •t; or nc = mM0(p)(c), c ∈\nC, p ∈ R(t), (c) representing the effect of transitions in Tk.\n18. evalU9k+7(botU9k+8(Π 6) \\ botU9k+7(Π6), X0 ∪ · · · ∪ X9k+7) = {tot incr(p, qqc, c, k):-.| qqc =∑\nadd(p,qc,t,c,k)∈X0∪···∪X10k+7 qc} ∪ {tot decr(p, qqc, c, k):-.|qqc =∑ del(p,qc,t,c,k)∈X0∪···∪X9k+7 qc}. It’s answer set is X10k+8 = Ats=k17 ∪ A ts=k 18 – using forced atom proposition and definitions of A17 and A18.\n(a) where, each tot incr(p, qqc, c, k), qqc = ∑\nadd(p,qc,t,c,k)∈X0∪...X10k+7 qc ≡ qqc = ∑ t∈X9k+6,p∈t•mW(p,t)(c),\n(b) and each tot decr(p, qqc, c, k), qqc = ∑\ndel(p,qc,t,c,k)∈X0∪...X10k+7 qc ≡ qq = ∑t∈X10k+6,p∈•t mW(t,p)(c) + ∑t∈X9k+6,p∈R(t) mM0(p)(c),\n(c) represent the net effect of transitions in Tk\n19. evalU9k+8(botU9k+9(Π 6) \\ botU9k+8(Π6), X0 ∪ · · · ∪ X9k+8) = {consumesmore(p, k):-.|\n{holds(p, qc, c, k), tot decr(p, q1c, c, k)} ⊆ X0 ∪ · · · ∪ X9k+8, q1c > qc} ∪ {holds(p, qc, c, 1):-.|{holds(p, q1c, c, k), tot incr(p, q2c, c, k), tot decr(p, q3c, c, k)} ⊆ X0 ∪ · · · ∪ X9k+6, qc = q1c + q2c − q3c} ∪ {could not have(t, k):-.|{prenabled(t, k), ptarc(s, t, q, c, k), holds(s, qq, c, k), tot decr(s, qqq, c, k)} ⊆ X0 ∪ · · · ∪ X9k+8, f ires(t, k) < X0∪· · ·∪X9k+8, q > qq−qqq}. It’s answer set is X10k+9 = Ats=k19 ∪A ts=k 21 ∪A ts=k 25 – using forced atom proposition and definitions of A19, A21, A25.\n(a) where, consumesmore(p, k) represents ∃p : qc = mM0(p)(c), q1c = ∑ t∈Tk ,p∈•t mW(p,t)(c) + ∑ t∈Tk ,p∈R(t) mM0(p)(c), q1c > qc, c ∈ C, indicating place\np that will be over consumed if Tk is fired, as defined in definition 34 (conflicting transition)\n(b) holds(p, qc, c, k + 1) if qc = mM0(p)(c) + ∑\nt∈Tk ,p∈t•mW(t,p)(c) − ( ∑ t∈Tk ,p∈•t mW(p,t)(c)+ ∑\nt∈Tk ,p∈R(t) mM0(p)(c)) represented by qc = mM1(p)(c) for some c ∈ C – by construction of Π6\n(c) could not have(t, k) if\ni. (∀p ∈ •t,W(p, t) ≤ M0(p)), (∀p ∈ I(t),M0(p) = k), (∀(p, t) ∈ Q, M0(p) ≥ WQ(p, t)),@tt ∈ T, (∀pp ∈ •tt,W(pp, tt) ≤ Mts(pp)), (∀pp ∈ I(tt),M0(pp) = k), (∀(pp, tt) ∈ Q, M0(pp) ≥ QW(pp, tt)),Z(tt) < Z(t),\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 258\nii. and qc > mM0(s)(c)−( ∑ t′∈Tk ,s∈•t′ mW(s,t′)(c)+ ∑\nt′∈Tk ,s∈R(t) mM0(s)(c)), qc = mW(s,t)(c) if s ∈ •t or mM0(s)(c) otherwise for some c ∈ C, which becomes q > M0(s)−( ∑ t′∈Tk ,s∈•t′ W(s, t\n′)+∑ t′∈Tk ,s∈R(t) M0(s)), q = W(s, t) if s ∈ •t or M0(s) otherwise for all c ∈ C\niii. (i), (ii) above combined match the definition of A25 (d) X9k+9 does not contain could not have(t, k), when prenabled(t, k) ∈ X0∪ · · ·∪X9k+6\nand f ires(t, k) < X0 ∪ · · · ∪ X9k+5due to construction of A, encoding of a10 and its body atoms. As a result it is not eliminated by the constraint a6\n20. evalU9k+9(botU9k+10(Π 6) \\ botU9k+9(Π6), X0 ∪ · · · ∪ X9k+9) = {consumesmore:-.|\n{consumesmore(p, k)} ⊆ A}. It’s answer set is X9k+10 = A20 – using forced atom proposition and the definition of A20\n(a) X9k+10 will be empty since none of consumesmore(p, 0), . . . , consumesmore(p, k) hold in X0 ∪ · · · ∪ X9k+9 due to the construction of A, encoding of a9 and its body atoms. As a result, it is not eliminated by the constraint a4\nThe set X = X0 ∪ · · · ∪ X9k+10 is the answer set of Π6 by the splitting sequence theorem 15. Each Xi, 0 ≤ i ≤ 9k + 10 matches a distinct portion of A, and X = A, thus A is an answer set of Π6.\nNext we show (II): Given Π6 be the encoding of a Petri Net PN(P,T, E,C,W,R, I, Q,QW,Z) with initial marking M0, and A be an answer set of Π6 that satisfies (A.13) and (A.14), then we can construct X = M0,Tk, . . . ,Mk,Tk,Mk+1 from A, such that it is an execution sequence of PN.\nWe construct the X as follows:\n1. Mi = (Mi(p0), . . . ,Mi(pn)), where {holds(p0,mMi(p0)(c), c, i), . . . , holds(pn,mMi(pn)(c), c, i)} ⊆ A, for c ∈ C, 0 ≤ i ≤ k + 1\n2. Ti = {t : f ires(t, i) ∈ A}, for 0 ≤ i ≤ k\nand show that X is indeed an execution sequence of PN. We show this by induction over k (i.e. given Mk, Tk is a valid firing set and its firing produces marking Mk+1).\nBase case: Let k = 0, and M0 is a valid marking in X for PN, show (1) T0 is a valid firing set for M0, and (2) firing T0 in M0 produces marking M1.\n1. We show T0 is a valid firing set for M0. Let { f ires(t0, 0), . . . , f ires(tx, 0)} be the set of all f ires(. . . , 0) atoms in A,\n(a) Then for each f ires(ti, 0) ∈ A i. prenabled(ti, 0) ∈ A – from rule a13 and supported rule proposition\nii. Then enabled(ti, 0) ∈ A – from rule a12 and supported rule proposition\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 259\niii. And notprenabled(ti, 0) < A – from rule a12 and supported rule proposition iv. For enabled(ti, 0) ∈ A\nA. notenabled(ti, 0) < A – from rule e9 and supported rule proposition B. Then either of body(e6), body(e7), or body(e8) must not hold in A for ti –\nfrom rules e6, e7, e8 and forced atom proposition C. Then qc ≮ nic ≡ qc ≥ nic in e6 for all {holds(p, qc, c, 0),\nptarc(p, ti, nic, c, 0)} ⊆ A – from e : 6, forced atom proposition, and given facts (holds(p, qc, c, 0) ∈ A, ptarc(p, ti, nic, 0) ∈ A) D. And qc nic ≡ qc < nic in e7 for all {holds(p, qc, c, 0), iptarc(p, ti, nic, c, 0)} ⊆ A, nic = 1; qc > nic ≡ qc = 0 – from e7, forced atom proposition, given facts (holds(p, qc, c, 0) ∈ A, iptarc(p, ti, 1, c, 0) ∈ A), and qc is a positive integer E. And qc ≮ nic ≡ qc ≥ nic in e8 for all {holds(p, qc, c, 0), tptarc(p, ti, nic, c, 0)} ⊆ A – from e8, forced atom proposition, and given facts\nF. Then ∀c ∈ C, (∀p ∈ •ti,mM0(p)(c) ≥ mW(p,ti)(c)) ∧ (∀p ∈ I(ti), mM0(p)(c) = 0)∧(∀(p, ti) ∈ Q,mM0(p)(c) ≥ mQW(p,ti)(c)) – from i2, f 14, f 17, f 18 construction, definition 31 of preset •ti in PN, definition 40 of enabled transition in PN, and that the construction of reset arcs by f 16 ensures notenabled(t, 0) is never true for a reset arc, where holds(p, qc, c, 0) ∈ A represents qc = mM0(p)(c), ptarc(p, ti, nic, 0) ∈ A represents nic = mW(p,ti)(c), nic = mM0(p)(c).\nG. Which is equivalent to (∀p ∈ •ti,M0(p) ≥ W(p, ti)) ∧ (∀p ∈ I(ti),M0(p) = 0) ∧ (∀(p, ti) ∈ Q,M0(p) ≥ QW(p, ti)) – assuming multiset domain C\nv. For notprenabled(ti, 0) < A A. Either (@enabled(tt, 0) ∈ A : pp < pi) or (∀enabled(tt, 0) ∈ A : pp ≮\npi) where pp = Z(tt), pi = Z(ti) – from rule a11, f 19 and forced atom proposition\nB. This matches the definition of an enabled priority transition vi. Then ti is enabled and can fire in PN, as a result it can belong to T0 – from\ndefinition 40 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π6 – from rule a3 and supported rule proposition\ni. Then @consumesmore(p, 0) ∈ A – from rule a9 and supported rule proposition ii. Then @{holds(p, qc, c, 0), tot decr(p, q1c, c, 0)} ⊆ A, q1c > qc in body(a9) –\nfrom a9 and forced atom proposition iii. Then @c ∈ C@p ∈ P, (∑ti∈{t0,...,tx},p∈•ti mW(p,ti)(c) +∑\nti∈{t0,...,tx},p∈R(ti) mM0(p)(c)) > mM0(p)(c) – from the following A. holds(p, qc, c, 0) represents qc = mM0(p)(c) – from rule i2 encoding, given\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 260\nB. tot decr(p, q1c, c, 0) ∈ A if {del(p, q10c, t0, c, 0), . . . , del(p, q1xc, tx, c, 0)} ⊆ A, where q1c = q10c + · · · + q1xc – from r11 and forced atom proposition\nC. del(p, q1ic, ti, c, 0) ∈ A if { f ires(ti, 0), ptarc(p, ti, q1ic, c, 0)} ⊆ A – from r9 and supported rule proposition\nD. del(p, q1ic, ti, c, 0) either represents removal of q1ic = mW(p,ti)(c) tokens from p ∈ •ti; or it represents removal of q1ic = mM0(p)(c) tokens from p ∈ R(ti)– from rules r9, f 14, f 16, supported rule proposition, and definition 33 of transition execution in PN\niv. Then the set of transitions in T0 do not conflict – by the definition 34 of conflicting transitions\n(c) And for each prenabled(t j, 0) ∈ A and f ires(t j, 0) < A, could not have(t j, 0) ∈ A, since A is an answer set of Π6 - from rule a15 and supported rule proposition\ni. Then {prenabled(t j, 0), holds(s, qqc, c, 0), ptarc(s, t j, qc, c, 0), tot decr(s, qqqc, c, 0)} ⊆ A, such that qc > qqc − qqqc and f ires(t j, 0) < A - from rule a14 and supported rule proposition\nii. Then for an s ∈ •t j∪R(t j), qc > mM0(s)(c)−( ∑ ti∈T0,s∈•ti mW(s,ti)(c)+ ∑\nti∈T0,s∈R(ti) mM0(s)(c)), where qc = mW(s,t j)(c) if s ∈ •t j, or mM0(s)(c) otherwise – from the following A. ptarc(s, ti, qc, c, 0) represents qc = mW(s,ti)(c) if (s, ti) ∈ E− or qc = mM0(s)(c)\nif s ∈ R(ti) – from rule f 14, f 16 construction B. holds(s, qqc, c, 0) represents qqc = mM0(s)(c) – from i2 construction C. tot decr(s, qqqc, c, 0) ∈ A if {del(s, qqq0c, t0, c, 0), . . . ,\ndel(s, qqqxc, tx, c, 0)} ⊆ A – from rule r11 construction and supported rule proposition\nD. del(s, qqqic, ti, c, 0) ∈ A if { f ires(ti, 0), ptarc(s, ti, qqqic, c, 0)} ⊆ A – from rule r9 and supported rule proposition\nE. del(s, qqqic, ti, c, 0) either represents qqqic = mW(s,ti)(c) : ti ∈ T0, (s, ti) ∈ E−, or qqqic = mM0(ti)(c) : ti ∈ T0, s ∈ R(ti) – from rule f 14, f 16 construction\nF. tot decr(q, qqqc, c, 0) represents ∑\nti∈T0,s∈•ti mW(s,ti)(c) +∑ ti∈T0,s∈R(ti) mM0(s)(c) – from (C,D,E) above\niii. Then firing T0 ∪ {t j} would have required more tokens than are present at its source place s ∈ •t j ∪ R(t j). Thus, T0 is a maximal set of transitions that can simultaneously fire.\n(d) And for each reset transition tr with prenabled(tr, 0) ∈ A, f ires(tr, 0) ∈ A, since A is an answer set of Π6 - from rule f 20 and supported rule proposition\ni. Then, the firing set T0 satisfies the reset-transition requirement of definition 41 (firing set)\n(e) Then {t0, . . . , tx} = T0 – using 1(a),1(b),1(d) above; and using 1(c) it is a maximal firing set\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 261\n2. We show M1 is produced by firing T0 in M0. Let holds(p, qc, c, 1) ∈ A\n(a) Then {holds(p, q1c, c, 0), tot incr(p, q2c, c, 0), tot decr(p, q3c, c, 0)} ⊆ A : qc = q1c+ q2c − q3c – from rule r12 and supported rule proposition\n(b) Then, holds(p, q1c, c, 0) ∈ A represents q1c = mM0(p)(c) – given, construction; and {add(p, q20c, t0, c, 0), . . . , add(p, q2 jc, t j, c, 0)} ⊆ A : q20c + · · ·+q2 jc = q2c and {del(p, q30c, t0, c, 0), . . . , del(p, q3lc, tl, c, 0)} ⊆ A : q30c + · · · + q3lc = q3c – rules r10, r11 and supported rule proposition, respectively\n(c) Then { f ires(t0, 0), . . . , f ires(t j, 0)} ⊆ A and { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A – rules r8, r9 and supported rule proposition, respectively\n(d) Then { f ires(t0, 0), . . . , f ires(t j, 0)}∪ { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A = { f ires(t0, 0), . . . , f ires(tx, 0)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, 0) ∈ A we have tx ∈ T0 – already shown in item 1 above (f) Then qc = mM0(p)(c)+ ∑ tx∈T0∧p∈tx•mW(tx,p)(c)−( ∑ tx∈T0∧p∈•tx mW(p,tx)(c)+ ∑ tx∈T0∧p∈R(tx) mM0(p)(c))\n– from (2b) above and the following\ni. Each add(p, q jc, t j, c, 0) ∈ A represents q jc = mW(t j,p)(c) for p ∈ t j• – rule r8, f 15 encoding, and definition 33 of transition execution in PN\nii. Each del(p, ty, qyc, c, 0) ∈ A represents either qyc = mW(p,ty)(c) for p ∈ •ty, or qyc = mM0(p)(c) for p ∈ R(ty) – from rule r9, f 14 encoding and definition 33 of transition execution in PN; or from rule r9, f 16 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2c, c, 0) ∈ A represents q2c = ∑\ntx∈T0∧p∈tx•mW(tx,p)(c) – aggregate assignment atom semantics in rule r10\niv. Each tot decr(p, q3c, c, 0) ∈ A represents q3c = ∑ tx∈T0∧p∈•tx mW(p,tx)(c)+ ∑\ntx∈T0∧p∈R(tx) mM0(p)(c) – aggregate assignment atom semantics in rule r11\n(g) Then, mM1(p)(c) = qc – since holds(p, qc, c, 1) ∈ A encodes qc = mM1(p)(c) – from construction\nInductive Step: Let k > 0, and Mk is a valid marking in X for PN, show (1) Tk is a valid firing set for Mk, and (2) firing Tk in Mk produces marking Mk+1.\n1. We show that Tk is a valid firing set in Mk. Let { f ires(Tk, k), . . . , f ires(tx, k)} be the set of all f ires(. . . , k) atoms in A,\n(a) Then for each f ires(ti, k) ∈ A i. prenabled(ti, k) ∈ A – from rule a13 and supported rule proposition\nii. Then enabled(ti, k) ∈ A – from rule a12 and supported rule proposition iii. And notprenabled(ti, k) < A – from rule a12 and supported rule proposition iv. For enabled(ti, k) ∈ A\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 262\nA. notenabled(ti, k) < A – from rule e9 and supported rule proposition B. Then either of body(e6), body(e7), or body(e8) must not hold in A for ti –\nfrom rules e6, e7, e8 and forced atom proposition C. Then qc ≮ nic ≡ qc ≥ nic in e6 for all {holds(p, qc, c, k),\nptarc(p, ti, nic, c, k)} ⊆ A – from e6, forced atom proposition, and given facts (holds(p, qc, c, k) ∈ A, ptarc(p, ti, nic, k) ∈ A) D. And qc nic ≡ qc < nic in e7 for all {holds(p, qc, c, k), iptarc(p, ti, nic, c, k)} ⊆ A, nic = 1; qc > nic ≡ qc = 0 – from e7, forced atom proposition, given facts (holds(p, qc, c, k) ∈ A, iptarc(p, ti, 1, c, k) ∈ A), and qc is a positive integer E. And qc ≮ nic ≡ qc ≥ nic in e8 for all {holds(p, qc, c, k), tptarc(p, ti, nic, c, k)} ⊆ A – from e8, forced atom proposition, and given facts\nF. Then ∀c ∈ C, (∀p ∈ •ti,mMk(p)(c) ≥ mW(p,ti)(c)) ∧ (∀p ∈ I(ti), mMk(p)(c) = k) ∧ (∀(p, ti) ∈ Q,mMk(p)(c) ≥ mQW(p,ti)(c)) – from f 14, f 17, f 18 construction, inductive assumption, definition 31 of preset •ti in PN, definition 40 of enabled transition in PN, and that the construction of reset arcs by f 16 ensures notenabled(t, k) is never true for a reset arc, where holds(p, qc, c, k) ∈ A represents qc = mMk(p)(c), ptarc(p, ti, nic, k) ∈ A represents nic = mW(p,ti)(c), nic = mMk(p)(c).\nG. Which is equivalent to (∀p ∈ •ti,Mk(p) ≥ W(p, ti)) ∧ (∀p ∈ I(ti),Mk(p) = k) ∧ (∀(p, ti) ∈ Q,Mk(p) ≥ QW(p, ti)) – assuming multiset domain C\nv. For notprenabled(ti, k) < A A. Either (@enabled(tt, k) ∈ A : pp < pi) or (∀enabled(tt, k) ∈ A : pp ≮\npi) where pp = Z(tt), pi = Z(ti) – from rule a11, f 19 and forced atom proposition\nB. This matches the definition of an enabled priority transition vi. Then ti is enabled and can fire in PN, as a result it can belong to Tk – from\ndefinition 40 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π6 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, k) ∈ A – from rule a4 and supported rule proposition ii. Then @{holds(p, qc, c, k), tot decr(p, q1c, c, k)} ⊆ A, q1c > qc in body(a9) –\nfrom a9 and forced atom proposition iii. Then @c ∈ C@p ∈ P, (∑ti∈{Tk ,...,tx},p∈•ti mW(p,ti)(c) +∑\nti∈{Tk ,...,tx},p∈R(ti) mMk(p)(c)) > mMk(p)(c) – from the following A. holds(p, qc, c, k) represents qc = mMk(p)(c) – from inductive assumption\nand construction, given\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 263\nB. tot decr(p, q1c, c, k) ∈ A if {del(p, q10c,Tk, c, k), . . . , del(p, q1xc, tx, c, k)} ⊆ A, where q1c = q10c + · · · + q1xc – from r11 and forced atom proposition\nC. del(p, q1ic, ti, c, k) ∈ A if { f ires(ti, k), ptarc(p, ti, q1ic, c, k)} ⊆ A – from r9 and supported rule proposition\nD. del(p, q1ic, ti, c, k) either represents removal of q1ic = mW(p,ti)(c) tokens from p ∈ •ti; or it represents removal of q1ic = mMk(p)(c) tokens from p ∈ R(ti)– from rules r9, f 14, f 16, supported rule proposition, and definition 33 of transition execution in PN\niv. Then the set of transitions in Tk do not conflict – by the definition 34 of conflicting transitions\n(c) And for each prenabled(t j, k) ∈ A and f ires(t j, k) < A, could not have(t j, k) ∈ A, since A is an answer set of Π6 - from rule a15 and supported rule proposition\ni. Then {prenabled(t j, k), holds(s, qqc, c, k), ptarc(s, t j, qc, c, k), tot decr(s, qqqc, c, k)} ⊆ A, such that qc > qqc − qqqc and f ires(t j, k) < A - from rule a14 and supported rule proposition\nii. Then for an s ∈ •t j∪R(t j), qc > mMk(s)(c)−( ∑ ti∈Tk ,s∈•ti mW(s,ti)(c)+ ∑\nti∈Tk ,s∈R(ti) mMk(s)(c)), where qc = mW(s,t j)(c) if s ∈ •t j, or mMk(s)(c) otherwise. A. ptarc(s, ti, qc, c, k) represents qc = mW(s,ti)(c) if (s, ti) ∈ E− or qc = mMk(s)(c)\nif s ∈ R(ti) – from rule f 14, f 16 construction B. holds(s, qqc, c, k) represents qqc = mMk(s)(c) – from inductive assumption\nand construction C. tot decr(s, qqqc, c, k) ∈ A if {del(s, qqq0c,Tk, c, k), . . . ,\ndel(s, qqqxc, tx, c, k)} ⊆ A – from rule r11 construction and supported rule proposition\nD. del(s, qqqic, ti, c, k) ∈ A if { f ires(ti, k), ptarc(s, ti, qqqic, c, k)} ⊆ A – from rule r9 and supported rule proposition\nE. del(s, qqqic, ti, c, k) either represents qqqic = mW(s,ti)(c) : ti ∈ Tk, (s, ti) ∈ E−, or qqqic = mMk(ti)(c) : ti ∈ Tk, s ∈ R(ti) – from rule f 14, f 16 construction\nF. tot decr(q, qqqc, c, k) represents ∑\nti∈Tk ,s∈•ti mW(s,ti)(c) +∑ ti∈Tk ,s∈R(ti) mMk(s)(c) – from (C,D,E) above\niii. Then firing Tk ∪ {t j} would have required more tokens than are present at its source place s ∈ •t j ∪ R(t j). Thus, Tk is a maximal set of transitions that can simultaneously fire.\n(d) And for each reset transition tr with prenabled(tr, k) ∈ A, f ires(tr, k) ∈ A, since A is an answer set of Π6 - from rule f 20 and supported rule proposition\ni. Then the firing set Tk satisfies the reset transition requirement of definition 41 (firing set)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 264\n(e) Then {t0, . . . , tx} = Tk – using 1(a),1(b), 1(d) above; and using 1(c) it is a maximal firing set\n2. We show that Mk+1 is produced by firing Tk in Mk. Let holds(p, qc, c, k + 1) ∈ A\n(a) Then {holds(p, q1c, c, k), tot incr(p, q2c, c, k), tot decr(p, q3c, c, k)} ⊆ A : qc = q1c+ q2c − q3c – from rule r12 and supported rule proposition (b) Then, holds(p, q1c, c, k) ∈ A represents q1c = mMk(p)(c) – inductive assumption; and {add(p, q20c,Tk, c, k), . . . , add(p, q2 jc, t j, c, k)} ⊆ A : q20c + · · · + q2 jc = q2c and {del(p, q30c,Tk, c, k), . . . , del(p, q3lc, tl, c, k)} ⊆ A : q30c + · · · + q3lc = q3c – rules r10, r11 and supported rule proposition, respectively\n(c) Then { f ires(Tk, k), . . . , f ires(t j, k)} ⊆ A and { f ires(Tk, k), . . . , f ires(tl, k)} ⊆ A – rules r8, r9 and supported rule proposition, respectively (d) Then { f ires(Tk, k), . . . , f ires(t j, k)}∪ { f ires(Tk, k), . . . , f ires(tl, k)} ⊆ A = { f ires(Tk, k), . . . , f ires(tx, k)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, k) ∈ A we have tx ∈ Tk – already shown in item 1 above (f) Then qc = mMk(p)(c)+ ∑ tx∈Tk∧p∈tx•mW(tx,p)(c)−( ∑ tx∈Tk∧p∈•tx mW(p,tx)(c)+ ∑ tx∈Tk∧p∈R(tx) mMk(p)(c))\n– from (2b) above and the following i. Each add(p, q jc, t j, c, k) ∈ A represents q jc = mW(t j,p)(c) for p ∈ t j• – rule\nr8, f 15 encoding, and definition 33 of transition execution in PN ii. Each del(p, ty, qyc, c, k) ∈ A represents either qyc = mW(p,ty)(c) for p ∈ •ty, or\nqyc = mMk(p)(c) for p ∈ R(ty) – from rule r9, f 14 encoding and definition 33 of transition execution in PN; or from rule r9, f 16 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2c, c, k) ∈ A represents q2c = ∑\ntx∈Tk∧p∈tx•mW(tx,p)(c) – aggregate assignment atom semantics in rule r10\niv. Each tot decr(p, q3c, c, k) ∈ A represents q3c = ∑ tx∈Tk∧p∈•tx mW(p,tx)(c)+ ∑\ntx∈Tk∧p∈R(tx) mMk(p)(c) – aggregate assignment atom semantics in rule r11\n(g) Then, mMk+1(p)(c) = qc – since holds(p, qc, c, k + 1) ∈ A encodes qc = mMk+1(p)(c) – from construction\nAs a result, for any n > k, Tn will be a valid firing set for Mn and Mn+1 will be its target marking. Conclusion: Since both (I) and (II) hold, X = M0,Tk,M1, . . . ,Mk,Tk+1 is an execution sequence of PN(P,T, E,C,W,R, I,Q,QW,Z) (w.r.t M0) iff there is an answer set A of Π6(PN,M0, k, ntok) such that (A.13) and (A.14) hold.\nA.8 Proof of Proposition 8\nLet PN = (P,T, E,C,W,R, I,Q,QW,Z,D) be a Petri Net, M0 be its initial marking and let Π7(PN,M0, k, ntok) be the ASP encoding of PN and M0 over a simulation length k, with maximum ntok tokens on any place node, as defined in section 2.11. Then X = M0,Tk,M1, . . . ,Mk,Tk,Mk+1\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 265\nis an execution sequence of PN (w.r.t. M0) iff there is an answer set A of Π7(PN,M0, k, ntok) such that:\n{ f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} = { f ires(t, ts) : f ires(t, ts) ∈ A} (A.15) {holds(p, q, c, ts) : p ∈ P, c/q = Mts(p), 0 ≤ ts ≤ k + 1}\n= {holds(p, q, c, ts) : holds(p, q, c, ts) ∈ A} (A.16)\nWe prove this by showing that:\n(I) Given an execution sequence X, we create a set A such that it satisfies (A.15) and (A.16) and show that A is an answer set of Π7\n(II) Given an answer set A of Π7, we create an execution sequence X such that (A.15) and (A.16) are satisfied.\nFirst we show (I): We create a set A as a union of the following sets:\n1. A1 = {num(n) : 0 ≤ n ≤ ntok}\n2. A2 = {time(ts) : 0 ≤ ts ≤ k}\n3. A3 = {place(p) : p ∈ P}\n4. A4 = {trans(t) : t ∈ T }\n5. A5 = {color(c) : c ∈ C}\n6. A6 = {ptarc(p, t, nc, c, ts) : (p, t) ∈ E−, c ∈ C, nc = mW(p,t)(c), nc > 0, 0 ≤ ts ≤ k}, where E− ⊆ E\n7. A7 = {tparc(t, p, nc, c, ts, d) : (t, p) ∈ E+, c ∈ C, nc = mW(t,p)(c), nc > 0, d = D(t), 0 ≤ ts ≤ k}, where E+ ⊆ E\n8. A8 = {holds(p, qc, c, 0) : p ∈ P, c ∈ C, qc = mM0(p)(c)}\n9. A9 = {ptarc(p, t, nc, c, ts) : p ∈ R(t), c ∈ C, nc = mMts(p), nc > 0, 0 ≤ ts ≤ k}\n10. A10 = {iptarc(p, t, 1, c, ts) : p ∈ I(t), c ∈ C, 0 ≤ ts < k}\n11. A11 = {tptarc(p, t, nc, c, ts) : (p, t) ∈ Q, c ∈ C, nc = mQW(p,t)(c), nc > 0, 0 ≤ ts ≤ k}\n12. A12 = {notenabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∃c ∈ C, (∃p ∈ •t,mMts(p)(c) < mW(p,t)(c)) ∨ (∃p ∈ I(t),mMts(p)(c) > 0) ∨ (∃(p, t) ∈ Q,mMts(p)(c) < mQW(p,t)(c))} per definition 40 (enabled transition)\n13. A13 = {enabled(t, ts) : t ∈ T, 0 ≤ ts ≤ k,∀c ∈ C, (∀p ∈ •t,mW(p,t)(c) ≤ mMts(p)(c)) ∧ (∀p ∈ I(t),mMts(p)(c) = 0) ∧ (∀(p, t) ∈ Q,mMts(p)(c) ≥ mQW(p,t)(c))} per definition 40 (enabled transition)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 266\n14. A14 = { f ires(t, ts) : t ∈ Tts, 0 ≤ ts ≤ k} per definition 40 (enabled transitions), only an enabled transition may fire\n15. A15 = {add(p, qc, t, c, ts + d − 1) : t ∈ Tts, p ∈ t•, c ∈ C, qc = mW(t,p)(c), d = D(t), 0 ≤ ts ≤ k} per definition 43 (transition execution)\n16. A16 = {del(p, qc, t, c, ts) : t ∈ Tts, p ∈ •t, c ∈ C, qc = mW(p,t)(c), 0 ≤ ts ≤ k} ∪ {del(p, qc, t, c, ts) : t ∈ Tts, p ∈ R(t), c ∈ C, qc = mMts(p)(c), 0 ≤ ts ≤ k} per definition 43 (transition execution)\n17. A17 = {tot incr(p, qc, c, ts) : p ∈ P, c ∈ C, qc = ∑ t∈Tl,p∈t•,l≤ts,l+D(t)=ts+1 mW(t,p)(c), 0 ≤ ts ≤ k}\nper definition 44 (firing set execution)\n18. A18 = {tot decr(p, qc, c, ts) : p ∈ P, c ∈ C, qc = ∑\nt∈Tts,p∈•t mW(p,t)(c) +∑ t∈Tts,p∈R(t) mMts(p)(c), 0 ≤ ts ≤ k} per definition 44 (firing set execution)\n19. A19 = {consumesmore(p, ts) : p ∈ P, c ∈ C, qc = mMts(p)(c), q1c = ∑ t∈Tts,p∈•t mW(p,t)(c) + ∑ t∈Tts,p∈R(t) mMts(p)(c), q1c > qc, 0 ≤ ts ≤ k}\nper definition 34 (conflicting transitions)\n20. A20 = {consumesmore : ∃p ∈ P, c ∈ C, qc = mMts(p)(c), q1c = ∑ t∈Tts,p∈•t mW(p,t)(c) + ∑ t∈Tts,p∈R(t)(mMts(p)(c)), q1c > qc, 0 ≤ ts ≤ k}\nper definition 34 (conflicting transitions)\n21. A21 = {holds(p, qc, c, ts + 1) : p ∈ P, c ∈ C, qc = mMts+1(p)(c), 0 ≤ ts < k}, where Mts+1(p) = Mts(p) − ( ∑ t∈Tts,p∈•t W(p, t) + ∑ t∈Tts,p∈R(t) Mts(p)) +∑\nt∈Tl,p∈t•,l≤ts,l+D(t)−1=ts W(t, p) according to definition 44 (firing set execution)\n22. A22 = {transpr(t, pr) : t ∈ T, pr = Z(t)}\n23. A23 = {notprenabled(t, ts) : t ∈ T, enabled(t, ts) ∈ A13, (∃tt ∈ T, enabled(tt, ts) ∈ A13,Z(tt) < Z(t)), 0 ≤ ts ≤ k} = {notprenabled(t, ts) : t ∈ T, (∀p ∈ •t,W(p, t) ≤ Mts(p)), (∀p ∈ I(t),Mts(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ WQ(p, t)),∃tt ∈ T, (∀pp ∈ •tt,W(pp, tt) ≤ Mts(pp)), (∀pp ∈ I(tt),Mts(pp) = 0), (∀(pp, tt) ∈ Q,Mts(pp) ≥ QW(pp, tt)),Z(tt) < Z(t), 0 ≤ ts ≤ k}\n24. A24 = {prenabled(t, ts) : t ∈ T, enabled(t, ts) ∈ A13, (@tt ∈ T : enabled(tt, ts) ∈ A13,Z(tt) < Z(t)), 0 ≤ ts ≤ k} = {prenabled(t, ts) : t ∈ T, (∀p ∈ •t,W(p, t) ≤ Mts(p)), (∀p ∈ I(t),Mts(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ WQ(p, t)),@tt ∈ T, (∀pp ∈ •tt,W(pp, tt) ≤ Mts(pp)), (∀pp ∈ I(tt),Mts(pp) = 0), (∀(pp, tt) ∈ Q,Mts(pp) ≥ QW(pp, tt)),Z(tt) < Z(t), 0 ≤ ts ≤ k}\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 267\n25. A25 = {could not have(t, ts) : t ∈ T, prenabled(t, ts) ∈ A24, f ires(t, ts) < A14, (∃p ∈ •t∪R(t) : q > Mts(p)− ( ∑ t′∈Tts,p∈•t′ W(p, t ′) + ∑\nt′∈Tts,p∈R(t′) Mts(p)), q = W(p, t) if (p, t) ∈ E− or R(t) otherwise), 0 ≤ ts ≤ k} = {could not have(t, ts) : t ∈ T, (∀p ∈ •t,W(p, t) ≤ Mts(p)), (∀p ∈ I(t),Mts(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)), (@tt ∈ T, (∀pp ∈ •tt,W(pp, tt) ≤ Mts(pp)), (∀pp ∈ I(tt),Mts(pp) = 0), (∀(pp, tt) ∈ Q,Mts(pp) ≥ QW(pp, tt)),Z(tt) < Z(t)), t < Tts, (∃p ∈ •t ∪ R(t) : q > Mts(p) − ( ∑ t′∈Tts,p∈•t′ W(p, t\n′) +∑ t′∈Tts,p∈R(t′) Mts(p)), q = W(p, t) if (p, t) ∈ E− or R(t) otherwise), 0 ≤ ts ≤ k} per the maximal firing set semantics\nWe show that A satisfies (A.15) and (A.16), and A is an answer set of Π7. A satisfies (A.15) and (A.16) by its construction above. We show A is an answer set of Π7 by splitting. We split lit(Π7) into a sequence of 9k + 11 sets:\n• U0 = head( f 1)∪head( f 2)∪head( f 13)∪head( f 5)∪head( f 6)∪head(i2)∪head( f 19) = {place(p) : p ∈ P} ∪ {trans(t) : t ∈ T } ∪ {col(c) : c ∈ C} ∪ {time(0), . . . , time(k)} ∪ {num(0), . . . , num(ntok)}∪{holds(p, qc, c, 0) : p ∈ P, c ∈ C, qc = mM0(p)(c)}∪{transpr(t, pr) : t ∈ T, pr = Z(t)}\n• U9k+1 = U9k+0∪head( f 14)ts=k∪head( f 15)ts=k∪head( f 16)ts=k∪head( f 17)ts=k∪head( f 18)ts=k = U9k+0∪ {ptarc(p, t, nc, c, k) : (p, t) ∈ E−, c ∈ C, nc = mW(p,t)(c)} ∪{tparc(t, p, nc, c, k, d) : (t, p) ∈ E+, c ∈ C, nc = mW(t,p)(c), d = D(t)}∪ {ptarc(p, t, nc, c, k) : p ∈ R(t), c ∈ C, nc = mMk(p)(c), n > 0} ∪ {iptarc(p, t, 1, c, k) : p ∈ I(t), c ∈ C}∪ {tptarc(p, t, nc, c, k) : (p, t) ∈ Q, c ∈ C, nc = mQW(p,t)(c)}\n• U9k+2 = U9k+1 ∪ head(e6)ts=k ∪ head(e7)ts=k ∪ head(e8)ts=k = U10k+1 ∪ {notenabled(t, k) : t ∈ T }\n• U9k+3 = U9k+2 ∪ head(e9)ts=k = U9k+2 ∪ {enabled(t, k) : t ∈ T }\n• U9k+4 = U9k+3 ∪ head(a11)ts=k = U9k+3 ∪ {notprenabled(t, k) : t ∈ T }\n• U9k+5 = U9k+4 ∪ head(a12)ts=k = U9k+4 ∪ {prenabled(t, k) : t ∈ T }\n• U9k+6 = U9k+5 ∪ head(a13)ts=k = U9k+5 ∪ { f ires(t, k) : t ∈ T }\n• U9k+7 = U9k+6 ∪ head(r13)ts=k ∪ head(r9)ts=k = U9k+6 ∪ {add(p, qc, t, c, k) : p ∈ P, t ∈ T, c ∈ C, qc = mW(t,p)(c)} ∪ {del(p, qc, t, c, k) : p ∈ P, t ∈ T, c ∈ C, qc = mW(p,t)(c)} ∪ {del(p, qc, t, c, k) : p ∈ P, t ∈ T, c ∈ C, qc = mMk(p)(c)}\n• U9k+8 = U9k+7 ∪ head(r10)ts=k ∪ head(r11)ts=k = U9k+7 ∪ {tot incr(p, qc, c, k) : p ∈ P, c ∈ C, 0 ≤ qc ≤ ntok} ∪ {tot decr(p, qc, c, k) : p ∈ P, c ∈ C, 0 ≤ qc ≤ ntok}\n• U9k+9 = U9k+8 ∪ head(a9)ts=k ∪ head(r12)ts=k ∪ head(a14)ts=k = U9k+8 ∪ {consumesmore(p, k) : p ∈ P}∪{holds(p, q, k+1) : p ∈ P, 0 ≤ q ≤ ntok}∪{could not have(t, k) : t ∈ T }\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 268\n• U9k+10 = U9k+9 ∪ head(a3) = U9k+9 ∪ {consumesmore}\nwhere head(ri)ts=k are head atoms of ground rule ri in which ts = k. We write Ats=ki = {a(. . . , ts) : a(. . . , ts) ∈ Ai, ts = k} as short hand for all atoms in Ai with ts = k. Uα, 0 ≤ α ≤ 9k + 10 form a splitting sequence, since each Ui is a splitting set of Π7, and 〈Uα〉α<µ is a monotone continuous sequence, where U0 ⊆ U1 · · · ⊆ U9k+10 and ⋃ α<µ Uα = lit(Π7).\nWe compute the answer set of Π7 using the splitting sets as follows:\n1. botU0(Π 7) = f 1 ∪ f 2 ∪ f 13 ∪ f 5 ∪ f 6 ∪ i2 ∪ f 19 and X0 = A1 ∪ · · · ∪ A5 ∪ A8 (= U0) is\nits answer set – using forced atom proposition\n2. evalU0(botU1(Π 7)\\botU0(Π7), X0) = {ptarc(p, t, qc, c, 0):-.|c ∈ C, qc = mW(p,t)(c), qc > 0}∪\n{tparc(t, p, qc, c, 0, d):-.|c ∈ C, qc = mW(t,p)(c), qc > 0, d = D(t)} ∪ {ptarc(p, t, qc, c, 0):-.|c ∈ C, qc = mM0(p)(c), qc > 0}∪ {iptarc(p, t, 1, c, 0):-.|c ∈ C}∪ {tptarc(p, t, qc, c, 0):-.|c ∈ C, qc = mQW(p,t)(c), qc > 0}. Its answer set X1 = Ats=06 ∪A ts=0 7 ∪ Ats=09 ∪A ts=0 10 ∪A ts=0 11 – using forced atom proposition and construction of A6, A7, A9, A10, A11.\n3. evalU1(botU2(Π 7) \\ botU1(Π7), X0 ∪ X1) = {notenabled(t, 0):-.|({trans(t),\nptarc(p, t, nc, c, 0), holds(p, qc, c, 0)} ⊆ X0 ∪ X1, where qc < nc) or ({notenabled(t, 0):-.| ({trans(t), iptarc(p, t, n2c, c, 0), holds(p, qc, c, 0)} ⊆ X0∪X1, where qc ≥ n2c}) or ({trans(t), tptarc(p, t, n3c, c, 0), holds(p, qc, c, 0)} ⊆ X0 ∪ X1, where qc < n3c)}. Its answer set X2 = Ats=012 – using forced atom proposition and construction of A12.\n(a) where, qc = mM0(p)(c), and nc = mW(p,t)(c) for an arc (p, t) ∈ E− – by construction of i2 and f 14 in Π7, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 31 of preset) (c) n2c = 1 – by construction of iptarc predicates in Π7, meaning qc ≥ n2c ≡ qc ≥ 1 ≡\nqc > 0,\n(d) tptarc(p, t, n3c, c, 0) represents n3c = mQW(p,t)(c), where (p, t) ∈ Q (e) thus, notenabled(t, 0) ∈ X1 means ∃c ∈ C, (∃p ∈ •t : mM0(p)(c) < mW(p,t)(c)) ∨ (∃p ∈ I(t) : mM0(p)(c) > 0) ∨ (∃(p, t) ∈ Q : mM0(p)(c) < mQW(p,t)(c)).\n4. evalU2(botU3(Π 7) \\ botU2(Π7), X0 ∪ · · · ∪ X2) = {enabled(t, 0):-.|trans(t) ∈ X0 ∪ · · · ∪\nX2, notenabled(t, 0) < X0 ∪ · · · ∪ X2}. Its answer set is X3 = Ats=013 – using forced atom proposition and construction of A13.\n(a) since an enabled(t, 0) ∈ X3 if @ notenabled(t, 0) ∈ X0 ∪ · · · ∪ X2; which is equivalent to @t,∀c ∈ C, (@p ∈ •t,mM0(p)(c) < mW(p,t)(c)), (@p ∈ I(t), mM0(p)(c) > 0), (@(p, t) ∈ Q : mM0(p)(c) < mQW(p,t)(c)),∀c ∈ C, (∀p ∈ •t : mM0(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t) : mM0(p)(c) = 0).\n5. evalU3(botU4(Π 7) \\ botU3(Π7), X0 ∪ · · · ∪ X3) = {notprenabled(t, 0):-.|\n{enabled(t, 0), transpr(t, p), enabled(tt, 0), transpr(tt, pp)} ⊆ X0 ∪ · · · ∪ X3, pp < p}. Its answer set is X4 = Ats=k23 – using forced atom proposition and construction of A23.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 269\n(a) enabled(t, 0) represents ∃t ∈ T,∀c ∈ C, (∀p ∈ •t,mM0(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t),mM0(p)(c) = 0), (∀(p, t) ∈ Q,mM0(p)(c) ≥ mQW(p,t)(c)) (b) enabled(tt, 0) represents ∃tt ∈ T,∀c ∈ C, (∀pp ∈ •tt,mM0(pp)(c) ≥ mW(pp,tt)(c))∧ (∀pp ∈ I(tt),mM0(pp)(c) = 0), (∀(pp, tt) ∈ Q,mM0(pp)(c) ≥ mQW(pp,tt)(c))\n(c) transpr(t, p) represents p = Z(t) – by construction\n(d) transpr(tt, pp) represents pp = Z(tt) – by construction\n(e) thus, notprenabled(t, 0) represents ∀c ∈ C, (∀p ∈ •t,mM0(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t),mM0(p)(c) = 0), (∀(p, t) ∈ Q,mM0(p)(c) ≥ mQW(p,t)(c)),∃tt ∈ T, (∀pp ∈ •tt,mM0(pp)(c) ≥ mW(pp,tt)(c)), (∀pp ∈ I(tt),mM0(pp)(c) = 0), (∀(pp, tt) ∈ Q,mM0(pp)(c) ≥ mQW(pp,tt)(c)),Z(tt) < Z(t) (f) which is equivalent to (∀p ∈ •t : M0(p) ≥ W(p, t)), (∀p ∈ I(t),M0(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)),∃tt ∈ T, (∀pp ∈ •tt,M0(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),M0(pp) = 0), (∀(pp, tt) ∈ Q,M0 ≥ QW(pp, tt)), Z(tt) < Z(t) – assuming multiset domain C for all operations\n6. evalU4(botU5(Π 7) \\ botU4(Π7), X0 ∪ · · · ∪ X4) = {prenabled(t, 0):-.|enabled(t, 0) ∈ X0 ∪\n· · · ∪ X4, notprenabled(t, 0) < X0 ∪ · · · ∪ X4}. Its answer set is X5 = Ats=k24 – using forced atom proposition and construction of A24\n(a) enabled(t, 0) represents ∀c ∈ C, (∀p ∈ •t,mM0(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t),mM0(p)(c) = 0), (∀(p, t) ∈ Q,mM0(p)(c) ≥ mQW(p,t)(c)) ≡ (∀p ∈ •t, M0(p) ≥ W(p, t)), (∀p ∈ I(t),M0(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)) – from 4 above and assuming multiset domain C for all operations\n(b) notprenabled(t, 0) represents (∀p ∈ •t,M0(p) ≥ W(p, t)), (∀p ∈ I(t), M0(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)),∃tt ∈ T, (∀pp ∈ •tt,M0(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),M0(pp) = 0), (∀(pp, tt) ∈ Q,M0(pp) ≥ QW(pp, tt)), Z(tt) < Z(t) – from 5 above and assuming multiset domain C for all operations\n(c) then, prenabled(t, 0) represents (∀p ∈ •t,M0(p) ≥ W(p, t)), (∀p ∈ I(t), M0(p) = 0), (∀(p, t) ∈ Q,M0(p) ≥ QW(p, t)),@tt ∈ T, ((∀pp ∈ •tt, M0(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),M0(pp) = 0), (∀(pp, tt) ∈ Q,M0(pp) ≥ QW(pp, tt)),Z(tt) < Z(t)) – from (a), (b) and enabled(t, 0) ∈ X0 ∪ · · · ∪ X4\n7. evalU5(botU6(Π 7) \\ botU5(Π7), X0 ∪ · · · ∪ X5) = {{ f ires(t, 0)}:-.|prenabled(t, 0)\nholds in X0 ∪ · · · ∪ X5}. It has multiple answer sets X6.1, . . . , X6.n, corresponding to elements of power set of f ires(t, 0) atoms in evalU5(...) – using supported rule proposition. Since we are showing that the union of answer sets of Π7 determined using splitting is equal to A, we only consider the set that matches the f ires(t, 0) elements in A and call it X6, ignoring the rest. Thus, X6 = Ats=014 , representing T0.\n(a) in addition, for every t such that prenabled(t, 0) ∈ X0∪· · ·∪X5,R(t) , ∅; f ires(t, 0) ∈ X6 – per definition 41 (firing set); requiring that a reset transition is fired when enabled\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 270\n(b) thus, the firing set T0 will not be eliminated by the constraint f 20\n8. evalU6(botU7(Π 7) \\ botU6(Π7), X0 ∪ · · · ∪ X6) = {add(p, nc, t, c, 0):-.| { f ires(t, 0 − d + 1),\ntparc(t, p, nc, c, 0, d)} ⊆ X0∪· · ·∪X6}∪{del(p, nc, t, c, 0):-.| { f ires(t, 0), ptarc(p, t, nc, c, 0)} ⊆ X0 ∪ · · · ∪ X6}. It’s answer set is X7 = Ats=015 ∪ A ts=0 16 – using forced atom proposition and definitions of A15 and A16.\n(a) where, each add atom is equivalent to nc = mW(t,p)(c), c ∈ C, p ∈ t•, (b) and each del atom is equivalent to nc = mW(p,t)(c), c ∈ C, p ∈ •t; or nc = mM0(p)(c), c ∈\nC, p ∈ R(t), (c) representing the effect of transitions in T0\n9. evalU7(botU8(Π 7) \\ botU7(Π7), X0 ∪ · · · ∪ X7) = {tot incr(p, qqc, c, 0):-.|qqc = ∑\nadd(p,qc,t,c,0)∈X0∪···∪X7 qc} ∪ {tot decr(p, qqc, c, 0):-.|qqc = ∑ del(p,qc,t,c,0)∈X0∪···∪X7 qc}. It’s answer set is X8 = Ats=017 ∪ Ats=018 – using forced atom proposition and definitions of A17 and A18.\n(a) where, each tot incr(p, qqc, c, 0), qqc = ∑\nadd(p,qc,t,c,0)∈X0∪...X7 qc ≡ qqc = ∑ t∈X6,p∈t•,0+D(t)−1=0 mW(p,t)(c),\n(b) tot decr(p, qqc, c, 0), qqc = ∑\ndel(p,qc,t,c,0)∈X0∪...X7 qc ≡ qq = ∑t∈X6,p∈•t mW(t,p)(c) + ∑t∈X6,p∈R(t) mM0(p)(c),\n(c) represent the net effect of transitions in T0\n10. evalU8(botU9(Π 7) \\ botU8(Π7), X0 ∪ · · · ∪ X8) = {consumesmore(p, 0):-.|\n{holds(p, qc, c, 0), tot decr(p, q1c, c, 0)} ⊆ X0 ∪ · · · ∪ X8, q1c > qc}∪ {holds(p, qc, c, 1):-.|{holds(p, q1c, c, 0), tot incr(p, q2c, c, 0), tot decr(p, q3c, c, 0)} ⊆ X0 ∪ · · · ∪ X6, qc = q1c + q2c − q3c} ∪ {could not have(t, 0):-.| {prenabled(t, 0), ptarc(s, t, q, c, 0), holds(s, qq, c, 0), tot decr(s, qqq, c, 0)} ⊆ X0 ∪ · · · ∪ X8, f ires(t, 0) < X0 ∪ · · · ∪ X8, q > qq− qqq}. It’s answer set is X9 = Ats=019 ∪ A ts=0 21 ∪ A ts=0 25 – using forced atom proposition and definitions of A19, A21, A25.\n(a) where consumesmore(p, 0) represents ∃p : qc = mM0(p)(c), q1c =∑ t∈T0,p∈•t mW(p,t)(c) + ∑ t∈T0,p∈R(t) mM0(p)(c), q1c > qc, c ∈ C, indicating place p will\nbe over consumed if T0 is fired, as defined in definition 34 (conflicting transitions), (b) holds(p, qc, c, 1) if qc = mM0(p)(c) + ∑ t∈T0,p∈t•,0+D(t)−1=0 mW(t,p)(c) −\n( ∑ t∈T0,p∈•t mW(p,t)(c)+ ∑\nt∈T0,p∈R(t) mM0(p)(c)) represented by qc = mM1(p)(c) for some c ∈ C – by construction of Π7\n(c) and consumesmore(p, 0) if ∑ t∈T0,p∈•t mW(p,t)(c)+ ∑\nt∈T0,p∈R(t) mM0(p)(c) > mM0(p)(c) for any c ∈ C\n(d) could not have(t, 0) if i. (∀p ∈ •t,W(p, t) ≤ M0(p)), (∀p ∈ I(t),M0(p) = 0), (∀(p, t) ∈ Q,\nM0(p) ≥ WQ(p, t)),@tt ∈ T, (∀pp ∈ •tt,W(pp, tt) ≤ Mts(pp)), (∀pp ∈ I(tt),M0(pp) = 0), (∀(pp, tt) ∈ Q,M0(pp) ≥ QW(pp, tt)),Z(tt) < Z(t),\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 271\nii. and qc > mM0(s)(c) − ( ∑ t′∈T0,s∈•t′ mW(s,t′)(c) + ∑\nt′∈T0,s∈R(t) mM0(s)(c)), qc = mW(s,t)(c) if s ∈ •t or mM0(s)(c) otherwise for some c ∈ C, which becomes q > M0(s) − ( ∑ t′∈T0,s∈•t′ W(s, t ′) + ∑\nt′∈T0,s∈R(t) M0(s)), q = W(s, t) if s ∈ •t or M0(s) otherwise for all c ∈ C\niii. (i), (ii) above combined match the definition of A25 (e) X9 does not contain could not have(t, 0), when prenabled(t, 0) ∈ X0 ∪ · · · ∪ X6 and\nf ires(t, 0) < X0 ∪ · · · ∪ X5 due to construction of A, encoding of a10 and its body atoms. As a result, it is not eliminated by the constraint a15\n...\n11. evalU9k+0(botU9k+1(Π 7) \\ botU9k+0(Π7), X0 ∪ · · · ∪ X9k+0) = {ptarc(p, t, qc, c, k):-.|c ∈ C, qc =\nmW(p,t)(c), qc > 0} ∪ {tparc(t, p, qc, c, k, d):-.|c ∈ C, qc = mW(t,p)(c), qc > 0, d = D(t)}∪ {ptarc(p, t, qc, c, k):-.|c ∈ C, qc = mMk(p)(c), qc > 0} ∪ {iptarc(p, t, 1, c, k):-.|c ∈ C}∪ {tptarc(p, t, qc, c, k):-.|c ∈ C, qc = mQW(p,t)(c), qc > 0}. Its answer set X9k+1 = Ats=k6 ∪ A ts=k 7 ∪ A ts=k 9 ∪ A ts=k 10 ∪ A ts=k 11 – using forced atom proposition and construction of A6, A7, A9, A10, A11.\n12. evalU9k+1(botU10k+2(Π 7) \\ botU9k+1(Π7), X0 ∪ · · · ∪ X9k+1) = {notenabled(t, k):-.|\n({trans(t), ptarc(p, t, nc, c, k), holds(p, qc, c, k)} ⊆ X0∪· · ·∪X9k+1, where qc < nc) or ({notenabled(t, k):-.|({trans(t), iptarc(p, t, n2c, c, k), holds(p, qc, c, k)} ⊆ X0 ∪ · · · ∪ X9k+1, where qc ≥ n2c}) or ({trans(t), tptarc(p, t, n3c, c, k), holds(p, qc, c, k)} ⊆ X0 ∪ · · · ∪ X9k+1, where qc < n3c)}. Its answer set X9k+2 = Ats=k12 – using forced atom proposition and construction of A12.\n(a) where, qc = mMk(p)(c), and nc = mW(p,t)(c) for an arc (p, t) ∈ E− – by construction of i2 and f 14 predicates in Π7, and\n(b) in an arc (p, t) ∈ E−, p ∈ •t (by definition 31 of preset) (c) n2c = 1 – by construction of iptarc predicates in Π7, meaning qc ≥ n2c ≡ qc ≥ 1 ≡\nqc > 0,\n(d) tptarc(p, t, n3c, c, k) represents n3c = mQW(p,t)(c), where (p, t) ∈ Q (e) thus, notenabled(t, k) ∈ X9k+1 represents ∃c ∈ C, (∃p ∈ •t : mMk(p)(c) < mW(p,t)(c))∨\n(∃p ∈ I(t) : mMk(p)(c) > 0) ∨ (∃(p, t) ∈ Q : mMk(p)(c) < mQW(p,t)(c)).\n13. evalU9k+2(botU9k+3(Π 7) \\ botU9k+2(Π7), X0 ∪ · · · ∪ X9k+2) = {enabled(t, k):-.|trans(t) ∈ X0 ∪\n· · · ∪ X9k+2, notenabled(t, k) < X0 ∪ · · · ∪ X9k+2}. Its answer set is X9k+3 = Ats=k13 – using forced atom proposition and construction of A13.\n(a) Since an enabled(t, k) ∈ X9k+3 if @ notenabled(t, k) ∈ X0 ∪ · · · ∪ X9k+2; which is equivalent to @t,∀c ∈ C, (@p ∈ •t,mMk(p)(c) < mW(p,t)(c)), (@p ∈ I(t),mMk(p)(c) > 0), (@(p, t) ∈ Q : mMk(p)(c) < mQW(p,t)(c)),∀c ∈ C, (∀p ∈ •t : mMk(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t) : mMk(p)(c) = 0).\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 272\n14. evalU9k+3(botU9k+4(Π 7) \\ botU9k+3(Π7), X0 ∪ · · · ∪ X9k+3) = {notprenabled(t, k):-.|\n{enabled(t, k), transpr(t, p), enabled(tt, k), transpr(tt, pp)} ⊆ X0 ∪ · · · ∪ X9k+3, pp < p}. Its answer set is X9k+4 = Ats=k23 – using forced atom proposition and construction of A23.\n(a) enabled(t, k) represents ∃t ∈ T,∀c ∈ C, (∀p ∈ •t,mMk(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t),mMk(p)(c) = 0), (∀(p, t) ∈ Q,mMk(p)(c) ≥ mQW(p,t)(c)) (b) enabled(tt, k) represents ∃tt ∈ T,∀c ∈ C, (∀pp ∈ •tt,mMk(pp)(c) ≥ mW(pp,tt)(c))∧(∀pp ∈ I(tt),mMk(pp)(c) = 0), (∀(pp, tt) ∈ Q,mMk(pp)(c) ≥ mQW(pp,tt)(c))\n(c) transpr(t, p) represents p = Z(t) – by construction\n(d) transpr(tt, pp) represents pp = Z(tt) – by construction\n(e) thus, notprenabled(t, k) represents ∀c ∈ C, (∀p ∈ •t,mMk(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t),mMk(p)(c) = 0), (∀(p, t) ∈ Q,mMk(p)(c) ≥ mQW(p,t)(c)),∃tt ∈ T, (∀pp ∈ •tt,mMk(pp)(c) ≥ mW(pp,tt)(c)), (∀pp ∈ I(tt), mMk(pp)(c) = 0), (∀(pp, tt) ∈ Q,mMk(pp)(c) ≥ mQW(pp,tt)(c)),Z(tt) < Z(t) (f) which is equivalent to (∀p ∈ •t : Mk(p) ≥ W(p, t)), (∀p ∈ I(t), Mk(p) = 0), (∀(p, t) ∈ Q,Mk(p) ≥ QW(p, t)),∃tt ∈ T, (∀pp ∈ •tt, Mk(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),Mk(pp) = 0), (∀(pp, tt) ∈ Q,Mk(pp) ≥ QW(pp, tt)),Z(tt) < Z(t) – assuming multiset domain C for all operations\n15. evalU9k+4(botU9k+5(Π 7) \\ botU9k+4(Π7), X0 ∪ · · · ∪ X9k+4) = {prenabled(t, k):-.|\nenabled(t, k) ∈ X0 ∪ · · · ∪ X9k+4, notprenabled(t, k) < X0 ∪ · · · ∪ X9k+4}. Its answer set is X9k+5 = Ats=k24 – using forced atom proposition and construction of A24\n(a) enabled(t, k) represents ∀c ∈ C, (∀p ∈ •t,mMk(p)(c) ≥ mW(p,t)(c)), (∀p ∈ I(t),mMk(p)(c) = 0), (∀(p, t) ∈ Q,mMk(p)(c) ≥ mQW(p,t)(c)) ≡ (∀p ∈ •t,Mk(p) ≥ W(p, t)), (∀p ∈ I(t),Mk(p) = 0), (∀(p, t) ∈ Q,Mk(p) ≥ QW(p, t)) – from 13 above and assuming multiset domain C for all operations\n(b) notprenabled(t, k) represents (∀p ∈ •t,Mk(p) ≥ W(p, t)), (∀p ∈ I(t), Mk(p) = 0), (∀(p, t) ∈ Q,Mk(p) ≥ QW(p, t)),∃tt ∈ T, (∀pp ∈ •tt,Mk(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),Mk(pp) = 0), (∀(pp, tt) ∈ Q,Mk(pp) ≥ QW(pp, tt)), Z(tt) < Z(t) – from 14 above and assuming multiset domain C for all operations\n(c) then, prenabled(t, k) represents (∀p ∈ •t,Mk(p) ≥ W(p, t)), (∀p ∈ I(t), Mk(p) = 0), (∀(p, t) ∈ Q,Mk(p) ≥ QW(p, t)),@tt ∈ T, ((∀pp ∈ •tt,Mk(pp) ≥ W(pp, tt)), (∀pp ∈ I(tt),Mk(pp) = 0), (∀(pp, tt) ∈ Q, Mk(pp) ≥ QW(pp, tt)),Z(tt) < Z(t)) – from (a), (b) and enabled(t, k) ∈ X0 ∪ · · · ∪ X9k+4\n16. evalU9k+5(botU9k+6(Π 7) \\ botU9k+5(Π7), X0 ∪ · · · ∪ X9k+5) = {{ f ires(t, k)}:-.|\nprenabled(t, k) holds in X0 ∪ · · · ∪ X9k+5}. It has multiple answer sets X9k+6.1, . . . , X9k+6.n, corresponding to elements of power set of f ires(t, k) atoms in evalU9k+5(...)\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 273\n– using supported rule proposition. Since we are showing that the union of answer sets of Π7 determined using splitting is equal to A, we only consider the set that matches the f ires(t, k) elements in A and call it X9k+6, ignoring the rest. Thus, X9k+6 = Ats=k14 , representing Tk.\n(a) in addition, for every t such that prenabled(t, k) ∈ X0 ∪ · · · ∪ X9k+5,R(t) , ∅; f ires(t, k) ∈ X9k+6 – per definition 41 (firing set); requiring that a reset transition is fired when enabled\n(b) thus, the firing set Tk will not be eliminated by the constraint f 20\n17. evalU9k+6(botU9k+7(Π 7) \\ botU9k+6(Π7), X0 ∪ · · · ∪ X9k+6) = {add(p, nc, t, c, k):-.| { f ires(t, k −\nd + 1), tparc(t, p, nc, c, 0, d)} ⊆ X0 ∪ · · · ∪ X9k+6} ∪ {del(p, nc, t, c, k):-.|{ f ires(t, k), ptarc(p, t, nc, c, k)} ⊆ X0 ∪ · · · ∪ X9k+6}. It’s answer set is X9k+7 = Ats=k15 ∪ A ts=k 16 – using forced atom proposition and definitions of A15 and A16.\n(a) where, each add atom is equivalent to nc = mW(t,p)(c), c ∈ C, p ∈ t•, (b) and each del atom is equivalent to nc = mW(p,t)(c), c ∈ C, p ∈ •t; or nc = mMk(p)(c), c ∈\nC, p ∈ R(t), (c) representing the effect of transitions in Tk\n18. evalU9k+7(botU9k+8(Π 7) \\ botU9k+7(Π7), X0 ∪ · · · ∪ X9k+7) = {tot incr(p, qqc, c, k):-.| qqc = ∑\nadd(p,qc,t,c,k)∈X0∪···∪X9k+7 qc} ∪ {tot decr(p, qqc, c, k):-.| qqc = ∑ del(p,qc,t,c,k)∈X0∪···∪X9k+7 qc}. It’s answer set is X9k+8 = Ats=k17 ∪ A ts=k 18 – using forced atom proposition and definitions of A17 and A18.\n(a) where, each tot incr(p, qqc, c, k), qqc = ∑\nadd(p,qc,t,c,k)∈X0∪...X9k+7 qc ≡ qqc = ∑ t∈X9k+6,p∈t•,0≤l≤k,l+D(t)−1=k mW(p,t)(c),\n(b) and each tot decr(p, qqc, c, k), qqc = ∑\ndel(p,qc,t,c,k)∈X0∪...X9k+7 qc ≡ qq = ∑t∈X9k+6,p∈•t mW(t,p)(c) + ∑t∈X9k+6,p∈R(t) mMk(p)(c),\n(c) represent the net effect of transitions in Tk\n19. evalU9k+8(botU9k+9(Π 7) \\ botU9k+8(Π7), X0 ∪ · · · ∪ X9k+8) = {consumesmore(p, k):-.|\n{holds(p, qc, c, k), tot decr(p, q1c, c, k)} ⊆ X0 ∪ · · · ∪ X9k+8, q1c > qc} ∪ {holds(p, qc, c, k + 1):-., |{holds(p, q1c, c, k), tot incr(p, q2c, c, k), tot decr(p, q3c, c, k)} ⊆ X0 ∪ · · · ∪ X9k+6, qc = q1c + q2c − q3c} ∪ {could not have(t, k):-.|{prenabled(t, k), ptarc(s, t, q, c, k), holds(s, qq, c, k), tot decr(s, qqq, c, k)} ⊆ X0 ∪ · · · ∪ X9k+8, f ires(t, k) < X0∪· · ·∪X10k+8, q > qq−qqq}. It’s answer set is X9k+9 = Ats=k19 ∪A ts=k 21 ∪A ts=k 25 – using forced atom proposition and definitions of A19, A21, A25.\n(a) where, consumesmore(p, k) represents ∃p : qc = mMk(p)(c), q1c = ∑ t∈Tk ,p∈•t mW(p,t)(c) + ∑ t∈Tk ,p∈R(t) mMk(p)(c), q1c > qc, c ∈ C, indicating place\np that will be over consumed if Tk is fired, as defined in definition 34 (conflicting transitions),\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 274\n(b) holds(p, qc, c, k+1) if qc = mMk(p)(c)+ ∑ t∈Tl,p∈t•,0≤l≤k,l+D(t)−1=k mW(t,p)(c)−( ∑\nt∈Tk ,p∈•t mW(p,t)(c)+∑ t∈Tk ,p∈R(t) mMk(p)(c)) represented by qc = mM1(p)(c) for some c ∈ C – by construc-\ntion of Π7, (c) and could not have(t, k) if\ni. (∀p ∈ •t,W(p, t) ≤ Mk(p)), (∀p ∈ I(t),Mk(p) = 0), (∀(p, t) ∈ Q, Mk(p) ≥ WQ(p, t)),@tt ∈ T, (∀pp ∈ •tt,W(pp, tt) ≤ Mts(pp)), (∀pp ∈ I(tt),Mk(pp) = 0), (∀(pp, tt) ∈ Q,Mk(pp) ≥ QW(pp, tt)),Z(tt) < Z(t),\nii. and qc > mMk(s)(c) − ( ∑ t′∈Tk ,s∈•t′ mW(s,t′)(c) + ∑\nt′∈Tk ,s∈R(t) mMk(s)(c)), qc = mW(s,t)(c) if s ∈ •t or mMk(s)(c) otherwise for some c ∈ C, which becomes q > Mk(s) − ( ∑ t′∈Tk ,s∈•t′ W(s, t ′) + ∑\nt′∈Tk ,s∈R(t) Mk(s)), q = W(s, t) if s ∈ •t or Mk(s) otherwise for all c ∈ C iii. (i), (ii) above combined match the definition of A25 (d) X9k+9 does not contain could not have(t, k), when prenabled(t, k) ∈ X0∪ · · ·∪X9k+6\nand f ires(t, k) < X0 ∪ · · · ∪ X9k+5 due to construction of A, encoding of a10 and its body atoms. As a result it is not eliminated by the constraint a15\n20. evalU9k+9(botU9k+10(Π 7) \\ botU9k+9(Π7), X0 ∪ · · · ∪ X9k+9) = {consumesmore:-.|\n{consumesmore(p, 0), . . . , consumesmore(p, k)} ∩ (X0 ∪ · · · ∪ X9k+9) , ∅}. It’s answer set is X9k+10 = A20 – using forced atom proposition and the definition of A20\n(a) X9k+10 will be empty since none of consumesmore(p, 0), . . . , consumesmore(p, k) hold in X0∪ · · ·∪X9k+10 due to the construction of A, encoding of a2 and its body atoms. As a result, it is not eliminated by the constraint a4\nThe set X = X0 ∪ · · · ∪ X9k+10 is the answer set of Π7 by the splitting sequence theorem 15. Each Xi, 0 ≤ i ≤ 9k + 10 matches a distinct portion of A, and X = A, thus A is an answer set of Π7.\nNext we show (II): Given Π7 be the encoding of a Petri Net PN(P,T, E,C,W,R, I, Q,QW,Z,D) with initial marking M0, and A be an answer set of Π7 that satisfies (A.15) and (A.16), then we can construct X = M0,Tk, . . . ,Mk,Tk,Mk+1 from A, such that it is an execution sequence of PN.\nWe construct the X as follows:\n1. Mi = (Mi(p0), . . . ,Mi(pn)), where {holds(p0,mMi(p0)(c), c, i), . . . , holds(pn,mMi(pn)(c), c, i)} ⊆ A, for c ∈ C, 0 ≤ i ≤ k + 1\n2. Ti = {t : f ires(t, i) ∈ A}, for 0 ≤ i ≤ k and show that X is indeed an execution sequence of PN. We show this by induction over k (i.e. given Mk, Tk is a valid firing set and its firing produces marking Mk+1).\nBase case: Let k = 0, and M0 is a valid marking in X for PN, show (1) T0 is a valid firing set for M0, and (2) firing T0 in M0 produces marking M1.\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 275\n1. We show T0 is a valid firing set for M0. Let { f ires(t0, 0), . . . , f ires(tx, 0)} be the set of all f ires(. . . , 0) atoms in A,\n(a) Then for each f ires(ti, 0) ∈ A i. prenabled(ti, 0) ∈ A – from rule a13 and supported rule proposition\nii. Then enabled(ti, 0) ∈ A – from rule a12 and supported rule proposition iii. And notprenabled(ti, 0) < A – from rule a12 and supported rule proposition iv. For enabled(ti, 0) ∈ A\nA. notenabled(ti, 0) < A – from rule e9 and supported rule proposition B. Then either of body(e6), body(e7), or body(e8) must not hold in A for ti –\nfrom rules body(e6), body(e7), body(e8) and forced atom proposition C. Then qc ≮ nic ≡ qc ≥ nic in e6 for all {holds(p, qc, c, 0),\nptarc(p, ti, nic, c, 0)} ⊆ A – from e6, forced atom proposition, and given facts (holds(p, qc, c, 0) ∈ A, ptarc(p, ti, nic, 0) ∈ A) D. And qc nic ≡ qc < nic in e7 for all {holds(p, qc, c, 0), iptarc(p, ti, nic, c, 0)} ⊆ A, nic = 1; qc > nic ≡ qc = 0 – from e7, forced atom proposition, given facts (holds(p, qc, c, 0) ∈ A, iptarc(p, ti, 1, c, 0) ∈ A), and qc is a positive integer E. And qc ≮ nic ≡ qc ≥ nic in e8 for all {holds(p, qc, c, 0), tptarc(p, ti, nic, c, 0)} ⊆ A – from e8, forced atom proposition, and given facts\nF. Then ∀c ∈ C, (∀p ∈ •ti,mM0(p)(c) ≥ mW(p,ti)(c)) ∧ (∀p ∈ I(ti), mM0(p)(c) = 0)∧ (∀(p, ti) ∈ Q,mM0(p)(c) ≥ mQW(p,ti)(c)) – from i2, f 14, f 16 construction, definition 31 of preset •ti in PN, definition 40 of enabled transition in PN, and that the construction of reset arcs by f 16 ensures notenabled(t, 0) is never true for a reset arc, where holds(p, qc, c, 0) ∈ A represents qc = mM0(p)(c), ptarc(p, ti, nic, 0) ∈ A represents nic = mW(p,ti)(c), nic = mM0(p)(c).\nG. Which is equivalent to (∀p ∈ •ti,M0(p) ≥ W(p, ti)) ∧ (∀p ∈ I(ti),M0(p) = 0) ∧ (∀(p, ti) ∈ Q,M0(p) ≥ QW(p, ti)) – assuming multiset domain C\nv. For notprenabled(ti, 0) < A A. Either (@enabled(tt, 0) ∈ A : pp < pi) or (∀enabled(tt, 0) ∈ A : pp ≮\npi) where pp = Z(tt), pi = Z(ti) – from rule a11, f 19 and forced atom proposition\nB. This matches the definition of an enabled priority transition vi. Then ti is enabled and can fire in PN, as a result it can belong to T0 – from\ndefinition 40 of enabled transition\n(b) And consumesmore < A, since A is an answer set of Π7 – from rule a4 and supported rule proposition\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 276\ni. Then @consumesmore(p, 0) ∈ A – from rule a3 and supported rule proposition ii. Then @{holds(p, qc, c, 0), tot decr(p, q1c, c, 0)} ⊆ A, q1c > qc in body(a9) –\nfrom a9 and forced atom proposition iii. Then @c ∈ C@p ∈ P, (∑ti∈{t0,...,tx},p∈•ti mW(p,ti)(c) +∑\nti∈{t0,...,tx},p∈R(ti) mM0(p)(c)) > mM0(p)(c) – from the following A. holds(p, qc, c, 0) represents qc = mM0(p)(c) – from rule i2 encoding, given B. tot decr(p, q1c, c, 0) ∈ A if {del(p, q10c, t0, c, 0), . . . ,\ndel(p, q1xc, tx, c, 0)} ⊆ A, where q1c = q10c + · · · + q1xc – from r11 and forced atom proposition\nC. del(p, q1ic, ti, c, 0) ∈ A if { f ires(ti, 0), ptarc(p, ti, q1ic, c, 0)} ⊆ A – from r9 and supported rule proposition\nD. del(p, q1ic, ti, c, 0) represents removal of q1ic = mW(p,ti)(c) tokens from p ∈ •ti; or it represents removal of q1ic = mM0(p)(c) tokens from p ∈ R(ti)– from rules r9, f 14, f 16, supported rule proposition, and definition 31 of preset in PN\niv. Then the set of transitions in T0 do not conflict – by the definition 34 of conflicting transitions\n(c) And for each prenabled(t j, 0) ∈ A and f ires(t j, 0) < A, could not have(t j, 0) ∈ A, since A is an answer set of Π7 - from rule a15 and supported rule proposition\ni. Then {prenabled(t j, 0), holds(s, qqc, c, 0), ptarc(s, t j, qc, c, 0), tot decr(s, qqqc, c, 0)} ⊆ A, such that qc > qqc − qqqc and f ires(t j, 0) < A - from rule a14 and supported rule proposition\nii. Then for an s ∈ •t j∪R(t j), qc > mM0(s)(c)−( ∑ ti∈T0,s∈•ti mW(s,ti)(c)+ ∑\nti∈T0,s∈R(ti) mM0(s)(c)), where qc = mW(s,t j)(c) if s ∈ •t j, or mM0(s)(c) otherwise. A. ptarc(s, ti, qc, c, 0) represents qc = mW(s,ti)(c) if (s, ti) ∈ E− or qc = mM0(s)(c)\nif s ∈ R(ti) – from rule f 14, f 16 construction B. holds(s, qqc, c, 0) represents qqc = mM0(s)(c) – from i2 construction C. tot decr(s, qqqc, c, 0) ∈ A if {del(s, qqq0c, t0, c, 0), . . . ,\ndel(s, qqqxc, tx, c, 0)} ⊆ A – from rule r11 construction and supported rule proposition\nD. del(s, qqqic, ti, c, 0) ∈ A if { f ires(ti, 0), ptarc(s, ti, qqqic, c, 0)} ⊆ A – from rule r9 and supported rule proposition\nE. del(s, qqqic, ti, c, 0) either represents qqqic = mW(s,ti)(c) : ti ∈ T0, (s, ti) ∈ E−, or qqqic = mM0(ti)(c) : ti ∈ T0, s ∈ R(ti) – from rule f 14, f 16 construction\nF. tot decr(q, qqqc, c, 0) represents ∑\nti∈T0,s∈•ti mW(s,ti)(c) +∑ ti∈T0,s∈R(ti) mM0(s)(c) – from (C,D,E) above\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 277\niii. Then firing T0 ∪ {t j} would have required more tokens than are present at its source place s ∈ •t j ∪ R(t j). Thus, T0 is a maximal set of transitions that can simultaneously fire.\n(d) And for each reset transition tr with prenabled(tr, 0) ∈ A, f ires(tr, 0) ∈ A, since A is an answer set of Π7 - from rule f 20 and supported rule proposition\ni. Then, the firing set T0 satisfies the reset-transition requirement of definition 41 (firing set)\n(e) Then {t0, . . . , tx} = T0 – using 1(a),1(b),1(d) above; and using 1(c) it is a maximal firing set\n2. Let holds(p, qc, c, 1) ∈ A\n(a) Then {holds(p, q1c, c, 0), tot incr(p, q2c, c, 0), tot decr(p, q3c, c, 0)} ⊆ A : qc = q1c+ q2c − q3c – from rule r12 and supported rule proposition\n(b) Then, holds(p, q1c, c, 0) ∈ A represents q1c = mM0(p)(c) – given ; and {add(p, q20c, t0, c, 0), . . . , add(p, q2 jc, t j, c, 0)} ⊆ A : q20c + · · ·+q2 jc = q2c and {del(p, q30c, t0, c, 0), . . . , del(p, q3lc, tl, c, 0)} ⊆ A : q30c + · · · + q3lc = q3c – rules r10, r11 and supported rule proposition, respectively\n(c) Then { f ires(t0, 0), . . . , f ires(t j, 0)} ⊆ A and { f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A – rules r13, r9 and supported rule proposition, respectively\n(d) Then { f ires(t0, 0), . . . , f ires(t j, 0)}∪{ f ires(t0, 0), . . . , f ires(tl, 0)} ⊆ A = { f ires(t0, 0), . . . , f ires(tx, 0)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, 0) ∈ A we have tx ∈ T0 – already shown in item 1 above (f) Then qc = mM0(p)(c) + ∑ tx∈T0,p∈tx•,0+D(tx)−1=0 mW(tx,p)(c) −\n( ∑ tx∈T0∧p∈•tx mW(p,tx)(c)+ ∑\ntx∈T0∧p∈R(tx) mM0(p)(c)) – from (2b) above and the following\ni. Each add(p, q jc, t j, c, 0) ∈ A represents q jc = mW(t j,p)(c) for p ∈ t j• – rule r13, f 21 encoding, and definition 43 of transition execution in PN\nii. Each del(p, ty, qyc, c, 0) ∈ A represents either qyc = mW(p,ty)(c) for p ∈ •ty, or qyc = mM0(p)(c) for p ∈ R(ty) – from rule r9, f 14 encoding and definition 43 of transition execution in PN; or from rule r9, f 16 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2c, c, 0) ∈ A represents q2c = ∑ tx∈T0∧p∈tx•,0+D(tx)−1=0 mW(tx,p)(c) – aggregate assignment atom seman-\ntics in rule r10 iv. Each tot decr(p, q3c, c, 0) ∈ A represents q3c = ∑ tx∈T0∧p∈•tx mW(p,tx)(c)\n+ ∑\ntx∈T0∧p∈R(tx) mM0(p)(c) – aggregate assignment atom semantics in rule r11\n(g) Then, mM1(p)(c) = qc – since holds(p, qc, c, 1) ∈ A encodes qc = mM1(p)(c) – from construction\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 278\nInductive Step: Let k > 0, and Mk is a valid marking in X for PN, show (1) Tk is a valid firing set for Mk, and (2) firing Tk in Mk produces marking Mk+1.\n1. We show that Tk is a valid firing set in Mk. Let { f ires(t0, k), . . . , f ires(tx, k)} be the set of all f ires(. . . , k) atoms in A,\n(a) We show that Tk is a valid firing set in Mk. Then for each f ires(ti, k) ∈ A i. prenabled(ti, k) ∈ A – from rule a13 and supported rule proposition\nii. Then enabled(ti, k) ∈ A – from rule a12 and supported rule proposition iii. And notprenabled(ti, k) < A – from rule a12 and supported rule proposition iv. For enabled(ti, k) ∈ A\nA. notenabled(ti, k) < A – from rule e9 and supported rule proposition B. Then either of body(e6), body(e7), or body(e8) must not hold in A for ti –\nfrom rules body(e6), body(e7), body(e8) and forced atom proposition C. Then qc ≮ nic ≡ qc ≥ nic in e6 for all {holds(p, qc, c, k),\nptarc(p, ti, nic, c, k)} ⊆ A – from e6, forced atom proposition, and given facts (holds(p, qc, c, k) ∈ A, ptarc(p, ti, nic, k) ∈ A) D. And qc nic ≡ qc < nic in e7 for all {holds(p, qc, c, k), iptarc(p, ti, nic, c, k)} ⊆ A, nic = 1; qc > nic ≡ qc = 0 – from e7, forced atom proposition, given facts (holds(p, qc, c, k) ∈ A, iptarc(p, ti, 1, c, k) ∈ A), and qc is a positive integer E. And qc ≮ nic ≡ qc ≥ nic in e8 for all {holds(p, qc, c, k), tptarc(p, ti, nic, c, k)} ⊆ A – from e8, forced atom proposition, and given facts\nF. Then ∀c ∈ C, (∀p ∈ •ti,mMk(p)(c) ≥ mW(p,ti)(c)) ∧ (∀p ∈ I(ti), mMk(p)(c) = 0) ∧ (∀(p, ti) ∈ Q,mMk(p)(c) ≥ mQW(p,ti)(c)) – from the inductive assumption, f 14, f 16 construction, definition 31 of preset •ti in PN, definition 40 of enabled transition in PN, and that the construction of reset arcs by f 16 ensures notenabled(t, k) is never true for a reset arc, where holds(p, qc, c, k) ∈ A represents qc = mMk(p)(c), ptarc(p, ti, nic, k) ∈ A represents nic = mW(p,ti)(c), nic = mMk(p)(c).\nG. Which is equivalent to (∀p ∈ •ti,Mk(p) ≥ W(p, ti)) ∧ (∀p ∈ I(ti),Mk(p) = 0) ∧ (∀(p, ti) ∈ Q,Mk(p) ≥ QW(p, ti)) – assuming multiset domain C\nv. For notprenabled(ti, k) < A A. Either (@enabled(tt, k) ∈ A : pp < pi) or (∀enabled(tt, k) ∈ A : pp ≮\npi) where pp = Z(tt), pi = Z(ti) – from rule a11, f 19 and forced atom proposition\nB. This matches the definition of an enabled priority transition vi. Then ti is enabled and can fire in PN, as a result it can belong to Tk – from\ndefinition 40 of enabled transition\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 279\n(b) And consumesmore < A, since A is an answer set of Π7 – from rule a4 and supported rule proposition\ni. Then @consumesmore(p, k) ∈ A – from rule a3 and supported rule proposition ii. Then @{holds(p, qc, c, k), tot decr(p, q1c, c, k)} ⊆ A, q1c > qc in body(a9) –\nfrom a9 and forced atom proposition iii. Then @c ∈ C@p ∈ P, (∑ti∈{t0,...,tx},p∈•ti mW(p,ti)(c) +∑\nti∈{t0,...,tx},p∈R(ti) mMk(p)(c)) > mMk(p)(c) – from the following A. holds(p, qc, c, k) represents qc = mMk(p)(c) – from rule PN encoding, given B. tot decr(p, q1c, c, k) ∈ A if {del(p, q10c, t0, c, k), . . . ,\ndel(p, q1xc, tx, c, k)} ⊆ A, where q1c = q10c + · · · + q1xc – from r11 and forced atom proposition\nC. del(p, q1ic, ti, c, k) ∈ A if { f ires(ti, k), ptarc(p, ti, q1ic, c, k)} ⊆ A – from r9 and supported rule proposition\nD. del(p, q1ic, ti, c, k) either represents removal of q1ic = mW(p,ti)(c) tokens from p ∈ •ti; or it represents removal of q1ic = mMk(p)(c) tokens from p ∈ R(ti)– from rules r9, f 14, f 16, supported rule proposition, and definition 43 of transition execution in PN\niv. Then the set of transitions in Tk do not conflict – by the definition 34 of conflicting transitions\n(c) And for each prenabled(t j, k) ∈ A and f ires(t j, k) < A, could not have(t j, k) ∈ A, since A is an answer set of Π7 - from rule a15 and supported rule proposition\ni. Then {prenabled(t j, k), holds(s, qqc, c, k), ptarc(s, t j, qc, c, k), tot decr(s, qqqc, c, k)} ⊆ A, such that qc > qqc − qqqc and f ires(t j, k) < A - from rule a14 and supported rule proposition\nii. Then for an s ∈ •t j∪R(t j), qc > mMk(s)(c)−( ∑ ti∈Tk ,s∈•ti mW(s,ti)(c)+ ∑\nti∈Tk ,s∈R(ti) mMk(s)(c)), where qc = mW(s,t j)(c) if s ∈ •t j, or mMk(s)(c) otherwise. A. ptarc(s, ti, qc, c, k) represents qc = mW(s,ti)(c) if (s, ti) ∈ E− or qc = mMk(s)(c)\nif s ∈ R(ti) – from rule f 14, f 16 construction B. holds(s, qqc, c, k) represents qqc = mMk(s)(c) – from i2 construction C. tot decr(s, qqqc, c, k) ∈ A if {del(s, qqq0c, t0, c, k), . . . ,\ndel(s, qqqxc, tx, c, k)} ⊆ A – from rule r11 construction and supported rule proposition\nD. del(s, qqqic, ti, c, k) ∈ A if { f ires(ti, k), ptarc(s, ti, qqqic, c, k)} ⊆ A – from rule r9 and supported rule proposition E. del(s, qqqic, ti, c, k) represents qqqic = mW(s,ti)(c) : ti ∈ Tk, (s, ti) ∈ E−, or qqqic = mMk(ti)(c) : ti ∈ Tk, s ∈ R(ti) – from rule f 14, f 16 construction\nF. tot decr(q, qqqc, c, k) represents ∑\nti∈Tk ,s∈•ti mW(s,ti)(c) +∑ ti∈Tk ,s∈R(ti) mMk(s)(c) – from (C,D,E) above\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 280\niii. Then firing Tk ∪ {t j} would have required more tokens than are present at its source place s ∈ •t j ∪ R(t j). Thus, Tk is a maximal set of transitions that can simultaneously fire.\n(d) And for each reset transition tr with enabled(tr, k) ∈ A, f ires(tr, k) ∈ A, since A is an answer set of Π7 - from rule f 20 and supported rule proposition\ni. Then the firing set Tk satisfies the reset transition requirement of definition 41 (firing set)\n(e) Then {t0, . . . , tx} = Tk – using 1(a),1(b), 1(d) above; and using 1(c) it is a maximal firing set\n2. We show that Mk+1 is produced by firing Tk in Mk. Let holds(p, qc, c, k + 1) ∈ A\n(a) Then {holds(p, q1c, c, k), tot incr(p, q2c, c, k), tot decr(p, q3c, c, k)} ⊆ A : qc = q1c+ q2c − q3c – from rule r12 and supported rule proposition\n(b) Then holds(p, q1c, c, k) ∈ A represents q1c = mMk(p)(c) – inductive assumption; and {add(p, q20c, t0, c, k), . . . , add(p, q2 jc, t j, c, k)} ⊆ A : q20c + · · · + q2 jc = q2c and {del(p, q30c, t0, c, k), . . . , del(p, q3lc, tl, c, k)} ⊆ A : q30c + · · · + q3lc = q3c – rules r10, r11 and supported rule proposition, respectively\n(c) Then { f ires(t0, k), . . . , f ires(t j, k)} ⊆ A and { f ires(t0, k), . . . , f ires(tl, k)} ⊆ A – rules r13, r9 and supported rule proposition, respectively\n(d) Then { f ires(t0, k), . . . , f ires(t j, k)}∪{ f ires(t0, k), . . . , f ires(tl, k)} ⊆ A = { f ires(t0, k), . . . , f ires(tx, k)} ⊆ A – set union of subsets\n(e) Then for each f ires(tx, k) ∈ A we have tx ∈ Tk – already shown in item 1 above (f) Then qc = mMk(p)(c) + ∑ tx∈Tl,p∈tx•,0≤l≤k,l+D(tx)−1=k mW(tx,p)(c) −\n( ∑ tx∈Tk∧p∈•tx mW(p,tx)(c) + ∑\ntx∈Tk∧p∈R(tx) mMk(p)(c)) – from (2b) above and the following\ni. Each add(p, q jc, t j, c, k) ∈ A represents q jc = mW(t j,p)(c) for p ∈ t j• – rule r13, f 21 encoding, and definition 31 of postset in PN\nii. Each del(p, ty, qyc, c, k) ∈ A represents either qyc = mW(p,ty)(c) for p ∈ •ty, or qyc = mMk(p)(c) for p ∈ R(ty) – from rule r9, f 14 encoding and definition 31 of preset in PN; or from rule r9, f 16 encoding and definition of reset arc in PN\niii. Each tot incr(p, q2c, c, k) ∈ A represents q2c = ∑ tx∈Tl,p∈tx•,0≤l≤k,l+D(tx)−1=k mW(tx,p)(c) – aggregate assignment atom se-\nmantics in rule r10 iv. Each tot decr(p, q3c, c, k) ∈ A represents q3c = ∑ tx∈Tk∧p∈•tx mW(p,tx)(c)\n+ ∑\ntx∈Tk∧p∈R(tx) mMk(p)(c) – aggregate assignment atom semantics in rule r11\n(g) Then, mMk+1(p)(c) = qc – since holds(p, qc, c, k + 1) ∈ A encodes qc = mMk+1(p)(c) – from construction\nAPPENDIX A. PROOFS OF VARIOUS PROPOSITIONS 281\nAs a result, for any n > k, Tn will be a valid firing set for Mn and Mn+1 will be its target marking. Conclusion: Since both (I) and (II) hold, X = M0,Tk,M1, . . . ,Mk,Tk+1 is an execution sequence of PN(P,T, E,C,W,R, I,Q,QW,Z,D) (w.r.t M0) iff there is an answer set A of Π7(PN,M0, k, ntok) such that (A.15) and (A.16) hold.\nAppendix B\nComplete Set of Queries Used for Drug-Drug Interaction\nB.1 Drug Activates Gene\n1 / / S { / NP { / / ? [ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) = > / /? [ Value = ’ of ’ ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’DRUG’ ] ( kw3 ) } } : : : d i s t i n c t s e n t . c id , kw3 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 2 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw3 ) = > /?[ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value = ’ of\n’ ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } : : : d i s t i n c t s e n t . c id , kw3 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e\n3 / / NP { / ? [ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) =>/PP { / ? [ Value = ’ of ’ ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’DRUG’ ] ( kw3 ) } } : : : d i s t i n c t s e n t . c id , kw3 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 4 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw2 ) }=> /VP { / / ? [ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) = > / /? [ Tag= ’\nDRUG’ ] ( kw0 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n5 / / S { / NP { / / ? [ Tag= ’DRUG’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) = > / /? [ Tag= ’ GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 6 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw0 ) = > /?[ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’GENE ’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 7 / / S { / NP { / / ? [ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) }=> /VP { / / ? [ Tag= ’ DRUG’ ] ( kw0 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 8 / / S { / NP { / / ? [ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) = > / /? [ Value = ’ of ’ ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’DRUG’ ] ( kw3 ) } } : : : d i s t i n c t s e n t . c id , kw3 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 9 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw3 ) = > /?[ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value = ’ of\n’ ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } : : : d i s t i n c t s e n t . c id , kw3 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e\n10 / / NP { / ? [ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) =>/PP { / ? [ Value = ’ of ’ ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’DRUG’ ] ( kw3 ) } } : : : d i s t i n c t s e n t . c id ,\nkw3 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e\n282\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 283\nB.2 Gene Induces Gene\n1 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ induced ’ ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 2 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ induced ’ ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 3 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value IN { ’ i n c r e a s e ’ , ’ i n c r e a s e d ’ } ] ( kw1\n) = > / /? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value = ’ a c t i v i t y ’ ] ( kw3 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n4 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ a c t i v i t y ’ ] ( kw3 ) }=> /VP { / / ? [ Value = ’ i n c r e a s e ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 5 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value IN { ’ s t i m u l a t e s ’ , ’ s t i m u l a t e ’ , ’ s t i m u l a t e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 6 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value IN { ’ s t i m u l a t e s ’ , ’ s t i m u l a t e ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 7 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value = ’ s t i m u l a t e s ’ ] ( kw1 ) = > / /? [ Tag= ’GENE\n’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n8 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value = ’ a c t i v a t e d ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 9 / / NP { / NP { / ? [ Value = ’ i n d u c t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value = ’ of ’ ] ( kw3 ) =>/NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 10 / / NP { / NP { / ? [ Value = ’ s t i m u l a t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value = ’ of ’ ] ( kw3 ) =>/NP { / / ? [ Tag = ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 11 / / NP { / NP { / ? [ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value IN { ’ of ’ } ] ( kw3 ) =>/NP { / / ? [\nTag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n12 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ i n d u c i b l e ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 13 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ induced ’ ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 14 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ induced ’ ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 15 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value IN { ’ i n c r e a s e ’ , ’ i n c r e a s e d ’ } ] ( kw1\n) = > / /? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value = ’ a c t i v i t y ’ ] ( kw3 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n16 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ a c t i v i t y ’ ] ( kw3 ) }=> /VP { / / ? [ Value = ’ i n c r e a s e ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 17 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ s t i m u l a t e d ’ ] ( kw1 ) = > / /? [ Tag= ’\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 284\nGENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n18 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value IN { ’ s t i m u l a t e s ’ , ’ s t i m u l a t e ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 19 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value = ’ s t i m u l a t e s ’ ] ( kw1 ) = > / /? [ Tag= ’GENE\n’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n20 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value = ’ a c t i v a t e d ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 21 / / VP { / ? [ Value = ’ a c t i v a t e d ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 22 / / NP { / NP { / ? [ Value = ’ i n d u c t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value = ’ of ’ ] ( kw3 ) =>/NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 23 / / NP { / NP { / ? [ Value = ’ s t i m u l a t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value = ’ of ’ ] ( kw3 ) =>/NP { / / ? [ Tag = ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 24 / / NP { / NP { / ? [ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value IN { ’ of ’ } ] ( kw3 ) =>/NP { / / ? [\nTag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n25 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ i n d u c i b l e ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\nB.3 Gene Inhibits Gene\n1 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ induced ’ ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 2 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ induced ’ ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 3 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value IN { ’ i n c r e a s e ’ , ’ i n c r e a s e d ’ } ] ( kw1\n) = > / /? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value = ’ a c t i v i t y ’ ] ( kw3 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n4 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ a c t i v i t y ’ ] ( kw3 ) }=> /VP { / / ? [ Value = ’ i n c r e a s e ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 5 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value IN { ’ s t i m u l a t e s ’ , ’ s t i m u l a t e ’ , ’ s t i m u l a t e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 6 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value IN { ’ s t i m u l a t e s ’ , ’ s t i m u l a t e ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 7 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value = ’ s t i m u l a t e s ’ ] ( kw1 ) = > / /? [ Tag= ’GENE\n’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n8 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value = ’ a c t i v a t e d ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t .\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 285\nv a l u e 9 / / NP { / NP { / ? [ Value = ’ i n d u c t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value = ’ of ’ ] ( kw3 ) =>/NP { / / ? [ Tag= ’\nGENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n10 / / NP { / NP { / ? [ Value = ’ s t i m u l a t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value = ’ of ’ ] ( kw3 ) =>/NP { / / ? [ Tag = ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 11 / / NP { / NP { / ? [ Value = ’ a c t i v a t i o n ’ ] ( kw1 ) }=> /PP { / ? [ Value IN { ’ of ’ } ] ( kw3 ) =>/NP { / / ? [\nTag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n12 / / S { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / / ? [ Value = ’ i n d u c i b l e ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\nB.4 Drug Changes Gene Expression/Activity\n1 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value IN { ’ i n c r e a s e d ’ , ’ i n c r e a s e ’ , ’ i n c r e a s e s ’ } ] ( kw1 ) = > /?[ Value IN { ’ l e v e l s ’ , ’ l e v e l ’ } ] ( kw3 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 2 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value IN { ’ i n c r e a s e d ’ , ’ i n c r e a s e s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ e x p r e s s i o n ’ , ’ l e v e l ’ , ’ a c t i v i t y ’ , ’ a c t i v i t i e s ’ , ’ l e v e l s ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 3 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / NP { / / ? [ Value IN { ’ i n c r e a s e s ’ , ’ i n c r e a s e ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ l e v e l s ’ , ’ a c t i v i t y ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 4 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ i n c r e a s e d ’ , ’ i n c r e a s e s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ a c t i v i t y ’ , ’ a c t i v i t i e s ’ , ’ l e v e l s ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 5 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value = ’ i n c r e a s e d ’ ] ( kw1 ) =>/NP { / / ? [ Value IN { ’ a c t i v i t y ’ , ’ l e v e l s ’ , ’ e x p r e s s i o n ’ } ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 6 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value IN { ’ i n c r e a s e d ’ , ’ i n c r e a s e s ’ , ’ i n c r e a s e ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ a c t i v i t y ’ , ’ l e v e l s ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 7 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / ? [ Value = ’ i n c r e a s e d ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ e x p r e s s i o n ’ , ’ a c t i v i t y ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 8 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ i n c r e a s e d ’ , ’ i n c r e a s e s ’ } ] ( kw1 ) =>/NP { / / ? [ Value IN { ’ e x p r e s s i o n ’ , ’ a c t i v i t y ’ , ’ a c t i v i t i e s ’ , ’ l e v e l ’ , ’ l e v e l s ’ } ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 9 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ d e c r e a s e d ’ , ’ d e c r e a s e s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ a c t i v i t y ’ , ’ e x p r e s s i o n ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 , va lue , kw0 . va lue , s e n t . v a l u e\n10 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value IN { ’ i n c r e a s e d ’ , ’ i n c r e a s e ’ , ’ i n c r e a s e s ’ } ] ( kw1 ) = > /?[ Value IN { ’ l e v e l s ’ , ’ l e v e l ’ } ] ( kw3 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 11 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value IN { ’ i n c r e a s e d ’ , ’ i n c r e a s e s ’ } ] ( kw1 )\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 286\n=>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ e x p r e s s i o n ’ , ’ l e v e l ’ , ’ a c t i v i t y ’ , ’ a c t i v i t i e s ’ , ’ l e v e l s ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e\n12 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / NP { / / ? [ Value IN { ’ i n c r e a s e s ’ , ’ i n c r e a s e ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ l e v e l s ’ , ’ a c t i v i t y ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 13 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ i n c r e a s e d ’ , ’ i n c r e a s e s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ a c t i v i t y ’ , ’ a c t i v i t i e s ’ , ’ l e v e l s ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 14 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value = ’ i n c r e a s e d ’ ] ( kw1 ) =>/NP { / / ? [ Value IN { ’ a c t i v i t y ’ , ’ l e v e l s ’ , ’ e x p r e s s i o n ’ } ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 15 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value IN { ’ i n c r e a s e d ’ , ’ i n c r e a s e s ’ , ’ i n c r e a s e ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ a c t i v i t y ’ , ’ l e v e l s ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 16 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / ? [ Value = ’ i n c r e a s e d ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ e x p r e s s i o n ’ , ’ a c t i v i t y ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 17 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ i n c r e a s e d ’ , ’ i n c r e a s e s ’ } ] ( kw1 ) =>/NP { / / ? [ Value IN { ’ e x p r e s s i o n ’ , ’ a c t i v i t y ’ , ’ a c t i v i t i e s ’ , ’ l e v e l ’ , ’ l e v e l s ’ } ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 18 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ d e c r e a s e d ’ , ’ d e c r e a s e s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ a c t i v i t y ’ , ’ e x p r e s s i o n ’ } ] ( kw3 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e\nB.5 Drug Induces/Stimulates Gene\n1 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 2 / / VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/PP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 3 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 4 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 5 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 6 / / S { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 7 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 287\n, kw0 . va lue , s e n t . v a l u e 8 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / / ? [ Value = ’ induced ’ ] ( kw1 ) = > / /? [ Tag= ’\nDRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e\n9 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e\n10 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value IN { ’ s t i m u l a t e ’ , ’ induce ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 11 / / NP { / NP { / ? [ Value IN { ’ i n d u c t i o n ’ , ’ s t i m u l a t i o n ’ } ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 12 / / S { / NP { / ? [ Value IN { ’ s t i m u l a t i o n ’ , ’ i n d u c t i o n ’ } ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / VP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 13 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / NP { / / ? [ Value IN { ’ s t i m u l a t i o n ’ , ’ i n d u c t i o n\n’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e\n14 / / NP { / NP { / NP { / ? [ Value = ’ i n d u c t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 15 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value IN { ’ s t i m u l a t i o n ’ , ’ i n d u c t i o n ’ } ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 16 / / NP { / ? [ Value IN { ’ s t i m u l a t i o n ’ , ’ i n d u c t i o n ’ } ] ( kw1 ) =>/PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 17 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value IN { ’ s t i m u l a t e s ’ , ’ i n d u c e s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 18 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ s t i m u l a t e s ’ , ’ i n d u c e s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 19 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 20 / / VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/PP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 21 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 22 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 23 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 24 / / S { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue ,\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 288\nkw1 . va lue , kw2 . va lue , s e n t . v a l u e 25 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] (\nkw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n26 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / / ? [ Value = ’ induced ’ ] ( kw1 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 27 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ s t i m u l a t e d ’ , ’ induced ’ } ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 28 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value IN { ’ s t i m u l a t e ’ , ’ induce ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 29 / / NP { / NP { / ? [ Value IN { ’ i n d u c t i o n ’ , ’ s t i m u l a t i o n ’ } ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 30 / / S { / NP { / ? [ Value IN { ’ s t i m u l a t i o n ’ , ’ i n d u c t i o n ’ } ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / VP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 31 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / NP { / / ? [ Value IN { ’ s t i m u l a t i o n ’ , ’ i n d u c t i o n\n’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n32 / / NP { / NP { / NP { / ? [ Value = ’ i n d u c t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 33 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value IN { ’ s t i m u l a t i o n ’ , ’ i n d u c t i o n ’ } ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 34 / / NP { / ? [ Value IN { ’ s t i m u l a t i o n ’ , ’ i n d u c t i o n ’ } ] ( kw1 ) =>/PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 35 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value IN { ’ s t i m u l a t e s ’ , ’ i n d u c e s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 36 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value IN { ’ s t i m u l a t e s ’ , ’ i n d u c e s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\nB.6 Drug Inhibits Gene\n1 / / NP { / NP { / NP { / ? [ Value = ’ i n h i b i t o r y ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > / PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 2 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 3 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 4 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) }= > /? [ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 5 / / NP { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } }= > / ? [ Value = ’ i n h i b i t o r\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 289\n’ ] ( kw1 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n6 / / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 7 / / NP { / NP { / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 8 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 9 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / NP { / / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n10 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 11 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 12 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 13 / / S { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 14 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / NP { / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 15 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 16 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / NP { / / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > / /? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 17 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 18 / / NP { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) }=> /NP { / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 19 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 20 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 21 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 22 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 23 / / NP { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) }= > /? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 24 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] (\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 290\nkw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e\n25 / / S { / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 26 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 27 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 28 / / S { / NP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 29 / / S { / NP { / PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 30 / / S { / NP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 31 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 32 / / S { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 33 / / S { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 34 / / S { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 35 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 36 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 37 / / S { / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / ? [ Tag = ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 38 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 39 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / ? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 40 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 41 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t .\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 291\nv a l u e 42 / / S { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t\n’ ] ( kw1 ) } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e\n43 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / VP { / / ? [ Value = ’ i n h i b i t ’ ] ( kw1 ) = > / /? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 44 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value = ’ i n h i b i t ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 45 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 46 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / PP { / / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 47 / / S { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / NP { / / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 48 / / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) =>/PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag= ’DRUG ’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 49 / / S { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) =>/PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag= ’DRUG ’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 50 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 51 / / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 52 / / S { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 53 / / S { / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 54 / / S { / ? [ Value IN { ’ i n h i b i t i o n ’ , ’ I n h i b i t i o n ’ } ] ( kw1 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 55 / / NP { / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { /\nNP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e\n56 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 57 / / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag = ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 58 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / NP { / / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t .\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 292\nv a l u e 59 / / S { / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / NP\n{ / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e\n60 / / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 61 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 62 / / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 63 / / NP { / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 64 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value = ’ i n h i b i t s ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 65 / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ i n h i b i t s ’ ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 66 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / ? [ Value = ’ i n h i b i t s ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 67 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ i n h i b i t s ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , s e n t . v a l u e 68 / / NP { / NP { / NP { / ? [ Value = ’ i n h i b i t o r y ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > / PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 69 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 70 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 71 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) }= > /? [ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 72 / / NP { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } }= > / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 73 / / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 74 / / NP { / NP { / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 75 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 76 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / NP { / / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 293\n77 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 78 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 79 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 80 / / S { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 81 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / NP { / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 82 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 83 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / NP { / / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > / /? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 84 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 85 / / NP { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) }=> /NP { / ? [ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 86 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 87 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 88 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 89 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 90 / / NP { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) }= > /? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t o r ’ ] ( kw1 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 91 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 92 / / S { / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 93 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 94 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 95 / / S { / NP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 294\n96 / / S { / NP { / PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 97 / / S { / NP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 98 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 99 / / S { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n100 / / S { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 101 / / S { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 102 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 103 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 104 / / S { / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / ? [ Tag = ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 105 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 106 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / ? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 107 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 108 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ i n h i b i t e d ’ ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 109 / / S { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ i n h i b i t ’ ] ( kw1 ) } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 110 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / VP { / / ? [ Value = ’ i n h i b i t ’ ] ( kw1 ) = > / /? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 111 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value = ’ i n h i b i t ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 112 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 295\n113 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / PP { / / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 114 / / S { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / NP { / / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 115 / / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) =>/PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag= ’DRUG ’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 116 / / S { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) =>/PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag= ’DRUG ’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 117 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 118 / / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 119 / / S { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 120 / / S { / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 121 / / S { / ? [ Value IN { ’ i n h i b i t i o n ’ , ’ I n h i b i t i o n ’ } ] ( kw1 ) = > /?[ Tag= ’GENE’ ] ( kw0 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 122 / / NP { / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { /\nNP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n123 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 124 / / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Tag = ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 125 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / NP { / / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 126 / / S { / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 127 / / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 128 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 129 / / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 296\n130 / / NP { / NP { / NP { / ? [ Value = ’ i n h i b i t i o n ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 131 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / ? [ Value = ’ i n h i b i t s ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 132 / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ i n h i b i t s ’ ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 133 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / ? [ Value = ’ i n h i b i t s ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 134 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ i n h i b i t s ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\nB.7 Gene Metabolized Drug\n1 / / S { / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / VP { / ? [ Value IN { ’ m e t a b o l i s e d ’ , ’ m e t a b o l i z e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 2 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value IN { ’ m e t a b o l i s e d ’ , ’ m e t a b o l i z e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 3 / / S { / NP { / SBAR { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value IN { ’ m e t a b o l i s e d ’ , ’ m e t a b o l i z e d ’ } ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 4 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / VP { / ? [ Value IN { ’ m e t a b o l i s e d ’ , ’ m e t a b o l i z e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 5 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / VP { / / ? [ Value IN { ’ m e t a b o l i z e d ’ , ’ m e t a b o l i s e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 6 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / ? [ Value IN { ’ m e t a b o l i s e d ’ , ’ m e t a b o l i z e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 7 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ m e t a b o l i z e d ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 8 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) }=> /VP { / VP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 9 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Value = ’ metabol i sm ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n10 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ metabol i sm ’ ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 11 / / NP { / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) =>/PP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 12 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) = > / /? [ Tag= ’\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 297\nDRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n13 / / S { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / NP { / / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 14 / / NP { / NP { / PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ metabol i sm ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 15 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / PP { / / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 16 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ metabol i sm ’ ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 17 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ metabol i sm ’ ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 18 / / S { / NP { / NP { / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / VP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 19 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Value = ’ metabol i sm ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 20 / / NP { / NP { / PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 21 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / NP { / / ? [ Value = ’ s u b s t r a t e ’ ] ( kw1 ) = > / /? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 22 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Value = ’ s u b s t r a t e ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 23 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value = ’ s u b s t r a t e ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 24 / / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ s u b s t r a t e ’ ] ( kw1 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 25 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / NP { / ? [ Value = ’ s u b s t r a t e ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 26 / / S { / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / VP { / ? [ Value IN { ’ m e t a b o l i s e d ’ , ’ m e t a b o l i z e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 27 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value IN { ’ m e t a b o l i s e d ’ , ’ m e t a b o l i z e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 28 / / S { / NP { / SBAR { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / ? [ Value IN { ’ m e t a b o l i s e d ’ , ’ m e t a b o l i z e d ’ } ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 29 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / VP { / ? [ Value IN { ’ m e t a b o l i s e d ’ , ’ m e t a b o l i z e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 .\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 298\nva lue , kw2 . va lue , s e n t . v a l u e 30 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / VP { / / ? [ Value IN { ’ m e t a b o l i z e d ’ , ’\nm e t a b o l i s e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n31 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / ? [ Value IN { ’ m e t a b o l i s e d ’ , ’ m e t a b o l i z e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 32 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / ? [ Value = ’ m e t a b o l i z e d ’ ] ( kw1 ) =>/PP { / / ? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 33 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) }=> /VP { / VP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 34 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Value = ’ metabol i sm ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 35 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ metabol i sm ’ ] ( kw1 ) }=> /PP { / NP { / ? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 36 / / NP { / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) =>/PP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 37 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 38 / / S { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > /VP { / NP { / / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 39 / / NP { / NP { / PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ metabol i sm ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 40 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / PP { / / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 41 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) = > /?[ Value = ’ metabol i sm ’ ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 42 / / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ metabol i sm ’ ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’ DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 43 / / S { / NP { / NP { / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) } }= > /VP { / VP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 44 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Value = ’ metabol i sm ’ ] ( kw1 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 45 / / NP { / NP { / PP { / / ? [ Tag= ’GENE’ ] ( kw0 ) } }= > / PP { / NP { / / ? [ Value = ’ metabol i sm ’ ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 46 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) }=> /VP { / NP { / / ? [ Value = ’ s u b s t r a t e ’ ] ( kw1 ) = > / /? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue ,\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 299\ns e n t . v a l u e 47 / / NP { / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / ? [ Value = ’ s u b s t r a t e ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’\nGENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\n48 / / S { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/VP { / VP { / / ? [ Value = ’ s u b s t r a t e ’ ] ( kw1 ) = > / /? [ Tag= ’GENE ’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 49 / / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) = > /?[ Value = ’ s u b s t r a t e ’ ] ( kw1 ) = > /?[ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 50 / / NP { / ? [ Tag= ’DRUG’ ] ( kw2 ) =>/NP { / NP { / ? [ Value = ’ s u b s t r a t e ’ ] ( kw1 ) }=> /PP { / / ? [ Tag= ’ GENE’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e\nB.8 Gene Regulates Gene\n1 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / / ? [ Value IN { ’ r e g u l a t e d ’ , ’ u p r e g u l a t e d ’ , ’ downregu l a t ed ’ , ’ up− r e g u l a t e d ’ , ’down− r e g u l a t e d ’ } ] ( kw1 ) = > / /? [ Value = ’ by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 2 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / ? [ Value IN { ’ r e g u l a t e d ’ , ’ u p r e g u l a t e d ’ , ’ downregu l a t ed ’ , ’ up− r e g u l a t e d ’ , ’down− r e g u l a t e d ’ } ] ( kw1 ) = > / /? [ Value = ’ by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 3 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value IN { ’ r e g u l a t e d ’ , ’ down− r e g u l a t e d ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 4 / / NP { / NP { / ? [ Value IN { ’ r e g u l a t i o n ’ , ’ u p r e g u l a t i o n ’ , ’ d o w n r e g u l a t i o n ’ , ’ up− r e g u l a t i o n ’ , ’down− r e g u l a t i o n ’ } ] ( kw1 ) }=> /PP { / NP { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 5 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / ? [ Value IN { ’ r e g u l a t e s ’ , ’ u p r e g u l a t e s ’ , ’ d o w n r e g u l a t e s ’ , ’ up− r e g u l a t e s ’ , ’down− r e g u l a t e s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’ GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , s e n t . v a l u e 6 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw0 ) }=> /VP { / VP { / / ? [ Value = ’ in ’ ] ( kw3 ) = > / /? [ Value = ’ r e g u l a t i n g ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e\nB.9 Gene Regulate Gene (Xenobiotic Metabolism)\n1 / / S { / / ? [ Tag= ’GENE’ AND C a n o n i c a l LIKE ’CYP\\% ’](kw0 ) <= > / /?[ Tag= ’GENE’ AND C a n o n i c a l IN { ’AhR’ , ’CASR’ , ’CAR’ , ’PXR’ , ’ NR1I2 ’ , ’ NR1I3 ’ } ] ( kw1 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , s e n t . v a l u e 2 / / S { / / ? [ Tag= ’GENE’ AND Value LIKE ’ cy tochrome \\% ’](kw0 ) <= > / /?[ Tag= ’GENE’ AND C a n o n i c a l IN { ’AhR’ , ’CASR’ , ’CAR’ , ’PXR’ , ’ NR1I2 ’ , ’ NR1I3 ’ } ] ( kw1 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , s e n t . v a l u e\nB.10 Negative Drug Induces/Metabolizes/Inhibits Gene\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 300\n1 / / S { / ? [ Tag= ’DRUG’ ] ( kw0 ) =>/VP { / VP { / ? [ Value IN { ’ induced ’ , ’ i n h i b i t e d ’ , ’ m e t a b o l i z e d ’ , ’ m e t a b o l i s e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value = ’ not ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw4 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw4 . va lue , kw3 . va lue , s e n t . v a l u e 2 / / S { / ? [ Tag= ’DRUG’ ] ( kw0 ) = > /?[ Value = ’ not ’ ] ( kw3 ) = > /?[ Tag= ’DRUG’ ] ( kw4 ) = > /?[ Value = ’ i n h i b i t e d ’ ] ( kw1 ) = > /?[ Tag= ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw4 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 3 / / S { / SBAR { / S { / / ? [ Tag= ’DRUG’ ] ( kw0 ) } }= > / S { / S { / / ? [ Value = ’ m e t a b o l i z e d ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value = ’ not ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw4 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw4 . va lue , kw3 . va lue , s e n t . v a l u e 4 / / S { / NP { / PP { / / ? [ Tag= ’GENE’ ] ( kw2 ) } }= > /VP { / VP { / ? [ Value IN { ’ induced ’ , ’ i n h i b i t e d ’ , ’ m e t a b o l i z e d ’ , ’ m e t a b o l i s e d ’ } ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw3 ) = > / /? [ Tag= ’DRUG’ ] ( kw4 ) } } } : : : d i s t i n c t s e n t . c id , kw4 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 5 / / S { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw0 ) } }= > /VP { / VP { / ? [ Value IN { ’ induced ’ , ’ i n h i b i t e d ’ , ’ m e t a b o l i z e d ’ , ’ m e t a b o l i s e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value IN { ’ not ’ , ’ no ’ } ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw4 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw4 . va lue , kw3 . va lue , s e n t . v a l u e 6 / / S { / ? [ Tag= ’DRUG’ ] ( kw0 ) =>/VP { / ? [ Value = ’ not ’ ] ( kw3 ) =>/VP { / / ? [ Value IN { ’ induced ’ , ’ i n h i b i t e d ’ , ’ m e t a b o l i z e d ’ , ’ m e t a b o l i s e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 7 / / S { / NP { / ? [ Tag= ’GENE’ ] ( kw2 ) }=> /VP { / VP { / ? [ Value IN { ’ induced ’ , ’ i n h i b i t e d ’ , ’ m e t a b o l i z e d ’ , ’ m e t a b o l i s e d ’ } ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw3 ) = > / /? [ Tag= ’DRUG’ ] ( kw4 ) } } } : : : d i s t i n c t s e n t . c id , kw4 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 8 / / S { / NP { / NP { / ? [ Value = ’ not ’ ] ( kw3 ) = > /?[ Tag= ’DRUG’ ] ( kw0 ) } }= > /VP { / ? [ Value IN { ’ i n h i b i t e d ’ , ’ induced ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 9 / / S { / NP { / NP { / ? [ Value IN { ’ no ’ , ’ not ’ } ] ( kw3 ) = > /?[ Tag= ’DRUG’ ] ( kw0 ) } }= > /VP { / ? [ Value IN { ’ i n h i b i t e d ’ , ’ induced ’ } ] ( kw1 ) =>/NP { / ? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 10 / / S { / ? [ Tag= ’DRUG’ ] ( kw0 ) =>/S { / S { / / ? [ Value = ’ not ’ ] ( kw3 ) = > / /? [ Value IN { ’ induce ’ , ’ i n h i b i t ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 11 / / S { / ? [ Tag= ’DRUG’ ] ( kw0 ) = > /?[ Tag= ’GENE’ ] ( kw2 ) = > /?[ Value IN { ’ not ’ } ] ( kw3 ) = > /?[\nValue IN { ’ i n h i b i t ’ , ’ induce ’ } ] ( kw1 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e\n12 / / S { / ? [ Tag= ’DRUG’ ] ( kw0 ) =>/VP { / ? [ Value = ’ not ’ ] ( kw3 ) =>/VP { / ? [ Value IN { ’ i n h i b i t ’ , ’ induce ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 13 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw0 ) }=> /VP { / VP { / ? [ Value = ’ not ’ ] ( kw3 ) = > / /? [ Value = ’ i n h i b i t ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 14 / / S { / NP { / NP { / ? [ Tag= ’GENE’ ] ( kw2 ) } }= > /VP { / ? [ Value = ’ not ’ ] ( kw3 ) =>/VP { / ? [ Value = ’ m e t a b o l i z e ’ ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw0 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 15 / / S { / NP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw0 ) } }= > /VP { / ? [ Value = ’ not ’ ] ( kw3 ) =>/VP { / ? [ Value IN { ’ i n h i b i t ’ , ’ induce ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t .\nc id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 301\n16 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw0 ) }=> /VP { / ? [ Value = ’ not ’ ] ( kw3 ) =>/VP { / ? [ Value = ’ i n h i b i t ’ ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 17 / / S { / NP { / ? [ Tag= ’DRUG’ ] ( kw0 ) }=> /VP { / ? [ Value IN { ’ i n d u c e s ’ , ’ i n h i b i t s ’ } ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value = ’ not ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw4 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw4 . va lue , kw3 . va lue , s e n t . v a l u e 18 / / S { / ? [ Tag= ’DRUG’ ] ( kw0 ) =>/VP { / ? [ Value = ’ i n h i b i t s ’ ] ( kw1 ) =>/NP { / / ? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value = ’ not ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw4 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw4 . va lue , kw3 . va lue , s e n t . v a l u e 19 / / S { / ? [ Tag= ’DRUG’ ] ( kw0 ) =>/VP { / NP { / / ? [ Value = ’no ’ ] ( kw3 ) = > / /? [ Value IN { ’ i n d u c t i o n ’ , ’ metabol i sm ’ , ’ i n h i b i t i o n ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 20 / / S { / NP { / NP { / / ? [ Tag= ’DRUG’ ] ( kw0 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value IN { ’ i n d u c t i o n ’ , ’ metabol i sm ’ , ’ i n h i b i t i o n ’ } ] ( kw1 ) } }= > /VP { / ? [ Value = ’ not ’ ] ( kw3 ) } }\n: : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e\n21 / / S { / ? [ Tag= ’DRUG’ ] ( kw0 ) =>/VP { / ? [ Value = ’ not ’ ] ( kw3 ) =>/VP { / / ? [ Value IN { ’ i n d u c t i o n ’ , ’ metabol i sm ’ , ’ i n h i b i t i o n ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e 22 / / S { / NP { / PP { / / ? [ Tag= ’DRUG’ ] ( kw0 ) } }= > /VP { / ? [ Value = ’ not ’ ] ( kw3 ) =>/VP { / / ? [ Value IN { ’ i n d u c t i o n ’ , ’ metabol i sm ’ , ’ i n h i b i t i o n ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } } }\n: : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw3 . va lue , s e n t . v a l u e\nB.11 Negative Drug Induces Gene\n1 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ induced ’ , ’ i n c r e a s e d ’ , ’ s t i m u l a t e d ’ } ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’DRUG’ ] ( kw5 ) } : : : d i s t i n c t s e n t . c id , kw5 . va lue , kw1 . va lue , kw0 . va lue , kw4 . va lue , s e n t . v a l u e 2 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw5 ) = > / /? [ Value IN { ’ induced ’ , ’ i n c r e a s e d ’ , ’ s t i m u l a t e d ’ } ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw5 . va lue , kw4 . va lue , s e n t . v a l u e 3 / / S { / / ? [ Tag= ’DRUG’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Value IN { ’ induce ’ , ’ induced ’ , ’ i n c r e a s e ’ , ’ i n c r e a s e d ’ , ’ s t i m u l a t e ’ , ’ s t i m u l a t e d ’ } ] ( kw1 ) = > / /? [ Tag = ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw4 . va lue , s e n t . v a l u e 4 / / S { / / ? [ Tag= ’DRUG’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’DRUG’ ] ( kw5 ) = > / /? [ Value IN { ’ i n d u c e s ’ , ’ i n c r e a s e s ’ , ’ s t i m u l a t e s ’ , ’ induced ’ , ’ i n c r e a s e d ’ , ’ s t i m u l a t e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw5 . va lue , kw1 . va lue , kw2 . va lue , kw4 . va lue , s e n t . v a l u e 5 / / S { / / ? [ Value = ’no ’ ] ( kw5 ) = > / /? [ v a l u e IN { ’ i n d u c t i o n ’ , ’ s t i m u l a t i o n ’ } ] ( kw1 ) = > / /? [ Value IN { ’ of ’ } ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ v a l u e IN { ’ by ’ } ] ( kw3 ) = > / /? [ Tag= ’DRUG’ ] ( kw4 ) } : : : d i s t i n c t s e n t . c id , kw4 . va lue , kw1 . va lue , kw0 . va lue , kw5 . va lue , s e n t . v a l u e\nB.12 Negative Drug Inhibits Gene\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 302\n1 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ i n h i b i t e d ’ , ’ d e c r e a s e d ’ } ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’ DRUG’ ] ( kw5 ) } : : : d i s t i n c t s e n t . c id , kw5 . va lue , kw1 . va lue , kw0 . va lue , kw4 . va lue , s e n t . v a l u e 2 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw5 ) = > / /? [ Value IN { ’ i n h i b i t e d ’ , ’ d e c r e a s e d ’ } ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’ DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw5 . va lue , kw4 . va lue , s e n t . v a l u e 3 / / S { / / ? [ Tag= ’DRUG’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Value IN { ’ i n h i b i t ’ , ’ i n h i b i t e d ’ , ’ d e c r e a s e ’ , ’ d e c r e a s e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw4 . va lue , s e n t . v a l u e 4 / / S { / / ? [ Tag= ’DRUG’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’DRUG’ ] ( kw5 ) = > / /? [ Value IN { ’ i n h i b i t s ’ , ’ d e c r e a s e s ’ , ’ i n h i b i t e d ’ , ’ d e c r e a s e d ’ } ] ( kw1 ) = > / /? [ Tag = ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw5 . va lue , kw1 . va lue , kw2 . va lue , kw4 . va lue , s e n t . v a l u e 5 / / S { / / ? [ Value = ’no ’ ] ( kw5 ) = > / /? [ v a l u e IN { ’ i n h i b i t i o n ’ } ] ( kw1 ) = > / /? [ Value IN { ’ of ’ } ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ v a l u e IN { ’ by ’ } ] ( kw3 ) = > / /? [ Tag= ’ DRUG’ ] ( kw4 ) } : : : d i s t i n c t s e n t . c id , kw4 . va lue , kw1 . va lue , kw0 . va lue , kw5 . va lue , s e n t . v a l u e\nB.13 Negative Gene Metabolizes Drug\n1 / / S { / / ? [ Tag= ’DRUG’ ] ( kw0 ) = > / /? [ Value IN { ’ m e t a b o l i z e d ’ , ’ m e t a b o l i s e d ’ } ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw5 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw5 . va lue , kw4 . va lue , s e n t . v a l u e 2 / / S { / / ? [ Tag= ’DRUG’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’DRUG’ ] ( kw5 ) = > / /? [\nValue IN { ’ m e t a b o l i z e d ’ , ’ m e t a b o l i s e d ’ } ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw5 . va lue , kw1 . va lue , kw2 . va lue ,\nkw4 . va lue , s e n t . v a l u e 3 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Value IN { ’ m e t a b o l i z e ’ , ’\nm e t a b o l i s e ’ } ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw0 . va lue , kw4 . va lue , s e n t . v a l u e\n4 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw5 ) = > / /? [ Value IN { ’ m e t a b o l i z e ’ , ’ m e t a b o l i s e ’ , ’ m e t a b o l i z e s ’ , ’ m e t a b o l i s e s ’ } ] ( kw1 ) = > / /? [ Tag= ’DRUG’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw5 . va lue , kw4 . va lue , s e n t . v a l u e\nB.14 Negative Gene Downregulates Gene\n1 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ s u p p r e s s e d ’ , ’ downregu l a t ed ’ , ’ i n h i b i t e d ’ , ’ down− r e g u l a t e d ’ , ’ r e p r e s s e d ’ , ’ d i s r u p t e d ’ } ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw5 ) } : : : d i s t i n c t s e n t . c id , kw5 . va lue , kw1 . va lue , kw0 . va lue , kw4 . va lue , s e n t . v a l u e 2 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw5 ) = > / /? [ Value IN { ’ s u p p r e s s e d ’ , ’ downregu l a t ed ’ , ’ i n h i b i t e d ’ , ’ down− r e g u l a t e d ’ , ’ r e p r e s s e d ’ , ’ d i s r u p t e d ’ } ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw5 . va lue , kw4 . va lue , s e n t . v a l u e\nAPPENDIX B. DRUG-DRUG INTERACTION QUERIES 303\n3 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Value IN { ’ s u p p r e s s e d ’ , ’ s u p p r e s s ’ , ’ downregu l a t ed ’ , ’ d ow nr eg u l a t e ’ , ’ i n h i b i t e d ’ , ’ i n h i b i t ’ , ’ down− r e g u l a t e d ’ , ’ down− r e g u l a t e ’ , ’ r e p r e s s e d ’ , ’ r e p r e s s ’ , ’ d i s r u p t e d ’ , ’ d i s r u p t ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw4 . va lue , s e n t . v a l u e 4 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw5 ) = > / /? [ Value IN { ’ s u p p r e s s e s ’ , ’ d o w n r e g u l a t e s ’ , ’ i n h i b i t s ’ , ’ down− r e g u l a t e s ’ , ’ r e p r e s s e s ’ , ’ d i s r u p t s ’ , ’ s u p p r e s s e d ’ , ’ downregu l a t ed ’ , ’ i n h i b i t e d ’ , ’ down− r e g u l a t e d ’ , ’ r e p r e s s e d ’ , ’ d i s r u p t e d ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw5 . va lue , kw1 . va lue , kw2 . va lue , kw4 . va lue , s e n t . v a l u e 5 / / S { / / ? [ Value = ’no ’ ] ( kw5 ) = > / /? [ v a l u e IN { ’ i n h i b i t i o n ’ , ’ d o w n r e g u l a t i o n ’ , ’ down− r e g u l a t i o n ’ } ] ( kw1 ) = > / /? [ Value IN { ’ of ’ } ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ v a l u e IN { ’ on ’ } ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw4 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw4 . va lue , kw5 . va lue , s e n t . v a l u e\nB.15 Negative Gene Upregulates Gene\n1 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value IN { ’ a c t i v a t e d ’ , ’ induced ’ , ’ s t i m u l a t e d ’ , ’ r e g u l a t e d ’ , ’ u p r e g u l a t e d ’ , ’ up− r e g u l a t e d ’ } ] ( kw1 ) = > / /? [ Value = ’by ’ ] ( kw3 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw5 ) } : : : d i s t i n c t s e n t . c id , kw5 . va lue , kw1 . va lue , kw0 . va lue , kw4 . va lue , s e n t . v a l u e 2 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw5 ) = > / /? [ Value IN { ’ a c t i v a t e d ’ , ’ induced ’ , ’ s t i m u l a t e d ’ , ’ r e g u l a t e d ’ , ’ u p r e g u l a t e d ’ , ’ up− r e g u l a t e d ’ } ] ( kw1 ) : : : d i s t i n c t s e n t . c id , kw2 . va lue , kw1 . va lue , kw5 . va lue , kw4 . va lue , s e n t . v a l u e 3 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Value IN { ’ a c t i v a t e d ’ , ’ induced ’ , ’ s t i m u l a t e d ’ , ’ r e g u l a t e d ’ , ’ u p r e g u l a t e d ’ , ’ up− r e g u l a t e d ’ , ’ a c t i v a t e ’ , ’ induce ’ , ’ s t i m u l a t e ’ , ’ r e g u l a t e ’ , ’ u p r e g u l a t e ’ , ’ up− r e g u l a t e ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw2 . va lue , kw4 . va lue , s e n t . v a l u e 4 / / S { / / ? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ Value = ’ not ’ ] ( kw4 ) = > / /? [ Tag= ’GENE’ ] ( kw5 ) = > / /? [\nValue IN { ’ a c t i v a t e s ’ , ’ i n d u c e s ’ , ’ s t i m u l a t e s ’ , ’ r e g u l a t e s ’ , ’ u p r e g u l a t e s ’ , ’ up− r e g u l a t e s ’ , ’ a c t i v a t e ’ , ’ induce ’ , ’ s t i m u l a t e ’ , ’ r e g u l a t e ’ , ’ u p r e g u l a t e ’ , ’ up − r e g u l a t e ’ } ] ( kw1 ) = > / /? [ Tag= ’GENE’ ] ( kw2 ) } : : : d i s t i n c t s e n t . c id , kw5 . va lue , kw1 . va lue , kw2 . va lue , kw4 . va lue , s e n t . v a l u e\n5 / / S { / / ? [ Value = ’no ’ ] ( kw5 ) = > / /? [ v a l u e IN { ’ i n d u c t i o n ’ , ’ a c t i v a t i o n ’ , ’ s t i m u l a t i o n ’ , ’ r e g u l a t i o n ’ , ’ u p r e g u l a t i o n ’ , ’ up− r e g u l a t i o n ’ } ] ( kw1 ) = > / /? [ Value IN { ’ of ’ } ] ( kw2 ) = > / /? [ Tag= ’GENE’ ] ( kw0 ) = > / /? [ v a l u e IN { ’ by ’ } ] ( kw3 ) = > / /? [ Tag= ’GENE ’ ] ( kw4 ) } : : : d i s t i n c t s e n t . c id , kw4 . va lue , kw1 . va lue , kw0 . va lue , kw5 . va lue , s e n t . v a l u e\nB.16 Drug Gene Co-Occurrence\n1 / / S { / / ? [ Tag= ’DRUG’ ] ( kw0 ) <= > / /?[ Tag= ’GENE’ ] ( kw1 ) } : : : d i s t i n c t s e n t . c id , kw0 . va lue , kw1 . va lue , kw0 . type , kw1 . type , s e n t . v a l u e\nBibliography\nAnwar, S., C. Baral and K. Inoue, “Encoding higher level extensions of petri nets in answer set programming”, arXiv preprint arXiv:1306.3548 (2013a).\nAnwar, S., C. Baral and K. Inoue, “Encoding petri nets in answer set programming for simulation based reasoning”, arXiv preprint arXiv:1306.3542 (2013b).\nAraki, T. and T. Kasami, “Some decision problems related to the reachability problem for Petri nets”, Theoretical Computer Science 3, 1, 85–104 (1976).\nBaral, C., Knowledge Representation, Reasoning and Declarative Problem Solving (Cambridge University Press, 2003).\nBaral, C., K. Chancellor, N. Tran, N. Tran, A. Joy and M. Berens, “A knowledge based approach for representing and reasoning about signaling networks”, Bioinformatics 20, suppl 1, i15– i22 (2004).\nBehrens, T. M. and J. Dix, “Model checking with logic based petri nets”, Pre-Proceedings of CLIMA 7, 6–21 (2007).\nBerg, J. M., J. L. Tymoczko and L. Stryer, Biochemistry. 5th edition. (New York: WH Freeman, 2002).\nBerthomieu*, B., P.-O. Ribet and F. Vernadat, “The tool tina–construction of abstract state spaces for petri nets and time petri nets”, International Journal of Production Research 42, 14, 2741–2756 (2004).\nBest, E. and M. Koutny, “Petri net semantics of priority systems”, Theoretical Computer Science 96, 1, 175–215 (1992).\nBoobis, A., “Drug interactions”, Drug Metabolism Review 41, 3, 486–527 (2009).\nBrauer, W. and W. Reisig, “Carl Adam Petri and “Petri Nets””, Informatik-Spektrum 29, 5, 369–374 (2006).\nBurkhard, H.-D., “Ordered firing in petri nets”, Journal of Information Processing and Cybernetics 17, 2-3, 71–86 (1980).\n304\nBIBLIOGRAPHY 305\nCalimeri, F., W. Faber, M. Gebser, G. Ianni, R. Kaminski, T. Krennwallner, N. Leone, F. Ricca and T. Schaub, “Asp-core-2 input language format”, (2013).\nCamon, E., D. Barrell and V. Lee, “The gene ontology annotation (goa) database - an integrated resource of go annotations to the uniprot knowledgebase”, Silico Biology 4, 1, 5–6 (2004).\nCaporaso, J. G., W. A. B. Jr, D. A. Randolph, K. B. Cohen and L. Hunter, “Mutationfinder: A high-performance system for extracting point mutation mentions from text”, Bioinformatics 23, 14, 1862–1865 (2007).\nChaouiya, C., “Petri net modelling of biological networks”, Briefings in bioinformatics 8, 4, 210–219 (2007).\nChristensen, S. and N. D. Hansen, Coloured Petri nets extended with place capacities, test arcs and inhibitor arcs (Springer, 1993).\nConsortium, T. U., “Reorganizing the protein space at the universal protein resource (uniprot)”, Nucleic Acids research 40 (2012).\nCroft, D., G. O’Kelly, G. Wu, R. Haw, M. Gillespie, L. Matthews, M. Caudy, P. Garapati, G. Gopinath, B. Jassal et al., “Reactome: a database of reactions, pathways and biological processes”, Nucleic acids research 39, suppl 1, D691–D697 (2011).\nde Marneffe, M.-C. and C. D. Manning, “The stanford typed dependencies representation”, Coling 2008: Proceedings of the Workshop on Cross-Framework and Cross-Domain Parser Evaluation (2008).\nden Dunnen, J. and S. Antonarakis, “Mutation nomenclature extensions and suggestions to describe complex mutations: a discussion”, Human Mutation 15, 1, 7–12 (200).\nDimroth, P., C. von Ballmoos, T. Meier and G. Kaim, “Electrical power fuels rotary atp synthase”, Structure 11, 12, 1469–1473 (2003).\nDworschak, S., T. Grote, A. König, T. Schaub and P. Veber, “Tools for representing and reasoning about biological models in action language c”, in “Proceedings of the Twelfth International Workshop on Nonmonotonic Reasoning (NMR 2008). The University of New South Wales, Technical Report Series”, pp. 94–102 (2008).\nGebser, M., R. Kaminski, B. Kaufmann, M. Ostrowski, T. Schaub and M. Schneider, “Potassco: The Potsdam answer set solving collection”, aicom 24, 2, 105–124 (2011).\nGelfond, M. and V. Lifschitz, “The stable model semantics for logic programming”, Logic Programming: Proceedings of the Fifth International Conference and Symposium pp. 1070– 1080 (1988).\nGelfond, M. and V. Lifschitz, “Representing action and change by logic programs”, The Journal of Logic Programming 17, 2, 301–321 (1993).\nBIBLIOGRAPHY 306\nGelfond, M. and V. Lifschitz, “Action languages”, Electronic Transactions on AI 3, 16 (1998).\nGelfond, M. and V. Lifschitz, “The common core of action languages B and C”, in “Proceedings of the 14th International Workshop on Non-Monotonic Reasoning (NMR 2012)”, (2012).\nGiunchiglia, E., J. Lee, V. Lifschitz, N. McCain and H. Turner, “Nonmonotonic causal theories”, Artificial Intelligence 153, 1, 49–104 (2004).\nGiunchiglia, E. and V. Lifschitz, “An action language based on causal explanation: Preliminary report”, in “AAAI/IAAI”, pp. 623–630 (Citeseer, 1998).\nH, W., R. T, H. R, B. K, B. M and W. J, “Increased frequency of cytochrome p450 2d6 poor metabolizers among patients with metoprolol-associcated adverse effects”, Pharmacogenomics in Clinical Therapeutics 72, 429–437 (2002).\nHakenberg, J., C. Plake, R. Leaman, M. Schroeder and G. Gonzalez, “Inter-species normalization of gene mentions”, Bioinformatics 24, 16, 126–132 (2008).\nHakenberg, J., D. Voronov, V. H. Nguyen, S. Liang, B. Lumpkin, S. Anwar, R. Leaman, L. Tari and C. Baral, “Taking a snpshot of pubmed - a repository of genetic variants and their drug response phenotypes”, Journal of Biomedical Informatics (2012).\nHardy, S. and P. N. Robillard, “Modeling and simulation of molecular biology systems using petri nets: Modeling goals of various approaches”, Journal of Bioinformatics and Computational Biology 2, 4, 619–637 (2004).\nHarrison, A., V. Lifschitz and F. Yang, “On the semantics of gringo”, arXiv preprint arXiv:1312.6149 (2013).\nHeiner, M., I. Koch and J. Will, “Model validation of biological pathways using petri nets— demonstrated for apoptosis”, Biosystems 75, 1, 15–28 (2004).\nHeljanko, K. and I. Niemelä, “Petri net analysis and nonmonotomic reasoning”, Leksa Notes in Computer Science pp. 7–19 (2000).\nJ, K., B. K, D. ML, G. LF, K. S, R. I, S. F, S. E and B. J, “Cyp2d6 and cyp2c19 genotypebased dose recommendations for antidepressants: a first step towards subpopulation-specific dosages”, Acta Psychiatr Scand 104, 3, 173–192 (2001).\nJensen, K., L. M. Kristensen and L. Wells, “Coloured petri nets and cpn tools for modelling and validation of concurrent systems”, International Journal on Software Tools for Technology Transfer 9, 3-4, 213–254 (2007).\nKanehisa, M. and S. Goto, “Kegg: kyoto encyclopedia of genes and genomes”, Nucleic acids research 28, 1, 27–30 (2000).\nBIBLIOGRAPHY 307\nKarp, P. D., M. Riley, S. M. Paley and A. Pellegrini-Toole, “The metacyc database”, Nucleic acids research 30, 1, 59–61 (2002).\nKlein, D. and C. Manning, “Accurate unlexicalized parsing”, Proceedings of the 41st meeting of the association for computation linguistics pp. 423–430 (2003).\nKohn, K. W., M. I. Aladjem, J. N. Weinstein and Y. Pommier, “Molecular interaction maps of bioregulatory networks: a general rubric for systems biology”, Molecular biology of the cell 17, 1, 1–13 (2006).\nKounev, S., C. Dutz and A. Buchmann, “Qpme-queueing petri net modeling environment”, in “Quantitative Evaluation of Systems, 2006. QEST 2006. Third International Conference on”, pp. 115–116 (IEEE, 2006).\nKrallinger, M., A. Morgan, L. Smith, F. Leitner, L. Tanabe, J. Wilbur, L. Hirschman and A. Valencia, “Evaluation of text-mining systems for biology: overview of the second biocreative community challenge”, Gnome Biology 9, 2 (2008).\nKrepska, E., N. Bonzanni, A. Feenstra, W. Fokkink, T. Kielmann, H. Bal and J. Heringa, “Design issues for qualitative modelling of biological cells with petri nets”, Formal Methods in Systems Biology pp. 48–62 (2008).\nKuhn, M., M. Campillos, I. Letunic, L. J. Jensen and P. Bork, “A side effect resource to capture phenotypic effects of drugs”, Molecular Systems Biology 6, 343 (2010).\nKummer, O., F. Wienberg, M. Duvigneau, M. Köhler, D. Moldt and H. Rölke, “Renew–the reference net workshop”, in “Tool Demonstrations, 21st International Conference on Application and Theory of Petri Nets, Computer Science Department, Aarhus University, Aarhus, Denmark”, pp. 87–89 (2000).\nLeaman, R., G. Gonzalez et al., “Banner: An executable survey of advances in biomedical named entity recognition”, in “Pacific Symposium on Biocomputing”, vol. 13, pp. 652–663 (2008).\nLeaman, R., C. Miller and G. Gonzalez, “Enabling recognition of diseases in biomedical text with machine learning: Corpus and benchmark”, International Symposium on Languages in Biology and Medicine pp. 82–89 (2009).\nLee, J. and V. Lifschitz, “Describing additive fluents in action language C+”, in “Proc. of IJCAI 2003”, (2003).\nLee, J., V. Lifschitz and F. Yang, “Action language bc: Preliminary report”, in “Proceedings of the Twenty-Third international joint conference on Artificial Intelligence”, pp. 983–989 (AAAI Press, 2013).\nBIBLIOGRAPHY 308\nLee, J. and Y. Meng, “Answer set programming modulo theories and reasoning about continuous changes”, in “Proceedings of the Twenty-Third international joint conference on Artificial Intelligence”, pp. 990–996 (AAAI Press, 2013).\nLifschitz, V., “What is answer set programming?”, Proceedings of the Twenty-Third AAAI Conferece on Artificial Intelligence pp. 1594–1597 (2008).\nLuo, G., M. Cunningham, S. Kim, T. Burn, J. Lin, M. Sinz, G. Hamilton, C. Rizzo, S. Jolley, D. Gilbert et al., “Cyp3a4 induction by drugs: correlation between a pregnane x receptor reporter gene assay and cyp3a4 expression in human hepatocytes”, Drug Metabolism and Disposition 30, 7, 795–804 (2002).\nManna, Z. and A. Pnueli, The temporal logic of reactive and concurrent systems: specifications, vol. 1 (springer, 1992).\nMusic, G., “Schedule optimization based on coloured petri nets and local search”, in “Mathematical Modelling”, vol. 7, pp. 352–357 (2012).\nNagasaki, M., A. Saito, E. Jeong, C. Li, K. Kojima, E. Ikeda and S. Miyano, “Cell illustrator 4.0: A computational platform for systems biology”, In silico biology 10, 1, 5–26 (2010).\nPearl, J., “Action as local surgery”, in “Working Notes of AAAI Spring Symposium Series, Extending Theories of Actions”, pp. 157–162 (1995).\nPeterson, J. et al., “A note on colored Petri nets”, Information Processing Letters 11, 1, 40–43 (1980).\nPeterson, J. L., “Petri nets”, Computing Surveys 9, 3, 223–252 (1977).\nPriami, C., A. Regev, E. Shapiro and W. Silverman, “Application of a stochastic name-passing calculus to representation and simulation of molecular processes”, Information processing letters 80, 1, 25–31 (2001).\nRamchandani, C., “Analysis of asynchronous concurrent systems by Petri nets.”, Tech. rep., DTIC Document (1974).\nReece, J., M. Cain, L. Urry, P. Minorsky and S. Wasserman, Campbell Biology (Pearson Benjamin Cummings, 2010), URL http://books.google.com/books?id=39vMSgAACAAJ.\nRegev, A., “Representation and simulation of molecular pathways in the stochastic pi-calculus”, in “Proceedings of the 2nd workshop on Computation of Biochemical Pathways and Genetic Networks”, vol. 88 (2001).\nReiter, R., “Natural actions, concurrency and continuous time in the situation calculus”, KR 96, 2–13 (1996).\nBIBLIOGRAPHY 309\nRohr, C., W. Marwan and M. Heiner, “Snoopy—a unifying petri net framework to investigate biomolecular networks”, Bioinformatics 26, 7, 974–975 (2010).\nSF, Z., “Polymorphism of human cytochrome p450 2d6 and its clinical significance: Part i”, Clinical Pharmacoknetics 48, 11, 689–723 (2009).\nSleator, D. and D. Temperley, “Parsing english with a link grammar”, Third International Workshop on Parsing Technologies (1993).\nSon, T. C. and E. Pontelli, “A constructive semantic characterization of aggregates in answer set programming”, Theory and Practice of Logic Programming 7, 3, 355 (2007).\nSyropoulos, A., “Mathematics of multisets”, Multiset Processing pp. 347–358 (2001).\nTari, L., C. Baral, S. Anwar, S. Liang and J. Hakenberg, “Synthesis of pharmacokinetic pathways through knowledge acquisition and automated reasoning”, Pacific Symposium on Biocomputing 15, 465–476 (2010a).\nTari, L., J. Cai, C. Baral, S. Liang and S. Anwar, “Discovering drug interactions: a text-mining and reasoning approach based on properties of drug metabolism.”, European Conference on Computational Biology (2010b).\nTari, L., J. Hakenberg, G. Gonzalez and C. Baral, “Querying a parse tree database of medline text to synthesize user-specific biomolecular networks”, Proc Pac Symp Biocomput 14, 87–98 (2009).\nTari, L., P. H. Tu, J. Hakenberg, Y. Chen, T. C. Son, G. Gonzalez and C. Baral, “Incremental information extraction using relational databases”, IEEE Transactions on Knowledge and Data Engineering 24, 1, 86–99 (2012).\nThorn, C. F., T. E. Klein and R. B. Altman, “Pharmacogenomics and bioinformatics: Pharmgkb”, Pharmacogenomics 11, 4, 501–505 (2010).\nValk, R., “Self-modifying nets, a natural extension of Petri nets”, in “Automata, Languages and Programming”, vol. 62 of Lecture Notes in Computer Science, pp. 464–476 (Springer, 1978).\nValk, R., “Object Petri nets: Using the nets-within-nets paradigm”, in “Advances in Petri Nets: Lectures on Concurrency and Petri Nets”, edited by J. Desel, W. Reisig and G. Rozenberg, vol. 3098 of Lecture Notes in Computer Science, pp. 819–848 (Springer-Verlag, 2004).\nWishart, D., C. Knox, A. Guo, D. Cheng, S. Shrivastava, D. Tzur, B. Gautam and M. Hassanali, “Drugbank: a knowledgebase for drugs, drug actions and drug targets.”, Nucleic Acids research 36, 901–906 (2008).\nWishart, D. S., C. Knox and A. C. Guo, “Drugbank: a comprehensive resource for in silico drug discovery and exploration”, Nucleic Acids research 34, 1, 668–672 (2006)."
    } ],
    "references" : [ {
      "title" : "Accurate unlexicalized parsing”, Proceedings of the 41st meeting of the association for computation linguistics pp",
      "author" : [ "D. Klein", "C. Manning" ],
      "venue" : null,
      "citeRegEx" : "Klein and Manning,? \\Q2003\\E",
      "shortCiteRegEx" : "Klein and Manning",
      "year" : 2003
    }, {
      "title" : "Molecular interaction maps of bioregulatory networks: a general rubric for systems biology",
      "author" : [ "K.W. Kohn", "M.I. Aladjem", "J.N. Weinstein", "Y. Pommier" ],
      "venue" : "Molecular biology of the cell 17,",
      "citeRegEx" : "Kohn et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Kohn et al\\.",
      "year" : 2006
    }, {
      "title" : "Qpme-queueing petri net modeling environment",
      "author" : [ "S. Kounev", "C. Dutz", "A. Buchmann" ],
      "venue" : "in “Quantitative Evaluation of Systems,",
      "citeRegEx" : "Kounev et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Kounev et al\\.",
      "year" : 2006
    }, {
      "title" : "A side effect resource to capture phenotypic effects of drugs",
      "author" : [ "M. Kuhn", "M. Campillos", "I. Letunic", "L.J. Jensen", "P. Bork" ],
      "venue" : "Molecular Systems Biology 6,",
      "citeRegEx" : "Kuhn et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kuhn et al\\.",
      "year" : 2010
    }, {
      "title" : "Banner: An executable survey of advances in biomedical named entity recognition",
      "author" : [ "R. Leaman", "G. Gonzalez" ],
      "venue" : "in “Pacific Symposium on Biocomputing”,",
      "citeRegEx" : "Leaman and Gonzalez,? \\Q2008\\E",
      "shortCiteRegEx" : "Leaman and Gonzalez",
      "year" : 2008
    }, {
      "title" : "Enabling recognition of diseases in biomedical text with machine learning: Corpus and benchmark",
      "author" : [ "R. Leaman", "C. Miller", "G. Gonzalez" ],
      "venue" : "International Symposium on Languages in Biology and Medicine pp",
      "citeRegEx" : "Leaman et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Leaman et al\\.",
      "year" : 2009
    }, {
      "title" : "Action language bc: Preliminary report",
      "author" : [ "J. Lee", "V. Lifschitz", "F. Yang" ],
      "venue" : "in “Proceedings of the Twenty-Third international joint conference on Artificial Intelligence”,",
      "citeRegEx" : "Lee et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2013
    }, {
      "title" : "Answer set programming modulo theories and reasoning about continuous changes",
      "author" : [ "J. Lee", "Y. Meng" ],
      "venue" : "in “Proceedings of the Twenty-Third international joint conference on Artificial Intelligence”,",
      "citeRegEx" : "Lee and Meng,? \\Q2013\\E",
      "shortCiteRegEx" : "Lee and Meng",
      "year" : 2013
    }, {
      "title" : "What is answer set programming?",
      "author" : [ "V. Lifschitz" ],
      "venue" : "Proceedings of the Twenty-Third AAAI Conferece on Artificial Intelligence pp",
      "citeRegEx" : "Lifschitz,? \\Q2008\\E",
      "shortCiteRegEx" : "Lifschitz",
      "year" : 2008
    }, {
      "title" : "Cyp3a4 induction by drugs: correlation between a pregnane x receptor reporter gene assay and cyp3a4 expression in human hepatocytes",
      "author" : [ "G. Luo", "M. Cunningham", "S. Kim", "T. Burn", "J. Lin", "M. Sinz", "G. Hamilton", "C. Rizzo", "S. Jolley", "D. Gilbert" ],
      "venue" : "Drug Metabolism and Disposition",
      "citeRegEx" : "Luo et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Luo et al\\.",
      "year" : 2002
    }, {
      "title" : "The temporal logic of reactive and concurrent systems: specifications, vol. 1 (springer",
      "author" : [ "Z. Manna", "A. Pnueli" ],
      "venue" : null,
      "citeRegEx" : "Manna and Pnueli,? \\Q1992\\E",
      "shortCiteRegEx" : "Manna and Pnueli",
      "year" : 1992
    }, {
      "title" : "Schedule optimization based on coloured petri nets and local search",
      "author" : [ "G. Music" ],
      "venue" : "in “Mathematical Modelling”,",
      "citeRegEx" : "Music,? \\Q2012\\E",
      "shortCiteRegEx" : "Music",
      "year" : 2012
    }, {
      "title" : "Action as local surgery”, in “Working Notes of AAAI Spring Symposium Series, Extending Theories of Actions",
      "author" : [ "J. Pearl" ],
      "venue" : null,
      "citeRegEx" : "Pearl,? \\Q1995\\E",
      "shortCiteRegEx" : "Pearl",
      "year" : 1995
    }, {
      "title" : "A note on colored Petri nets",
      "author" : [ "J Peterson" ],
      "venue" : "Information Processing Letters 11,",
      "citeRegEx" : "Peterson,? \\Q1980\\E",
      "shortCiteRegEx" : "Peterson",
      "year" : 1980
    }, {
      "title" : "Petri nets",
      "author" : [ "J.L. Peterson" ],
      "venue" : "Computing Surveys",
      "citeRegEx" : "Peterson,? \\Q1977\\E",
      "shortCiteRegEx" : "Peterson",
      "year" : 1977
    }, {
      "title" : "Application of a stochastic name-passing calculus to representation and simulation of molecular processes”, Information processing letters",
      "author" : [ "C. Priami", "A. Regev", "E. Shapiro", "W. Silverman" ],
      "venue" : null,
      "citeRegEx" : "Priami et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Priami et al\\.",
      "year" : 2001
    }, {
      "title" : "Analysis of asynchronous concurrent systems by Petri nets.",
      "author" : [ "C. Ramchandani" ],
      "venue" : "Tech. rep., DTIC Document",
      "citeRegEx" : "Ramchandani,? \\Q1974\\E",
      "shortCiteRegEx" : "Ramchandani",
      "year" : 1974
    }, {
      "title" : "Representation and simulation of molecular pathways in the stochastic pi-calculus”, in “Proceedings of the 2nd workshop on Computation of Biochemical Pathways and Genetic Networks",
      "author" : [ "A. Regev" ],
      "venue" : null,
      "citeRegEx" : "Regev,? \\Q2001\\E",
      "shortCiteRegEx" : "Regev",
      "year" : 2001
    }, {
      "title" : "Natural actions, concurrency and continuous time in the situation calculus",
      "author" : [ "R. Reiter" ],
      "venue" : "KR 96,",
      "citeRegEx" : "Reiter,? \\Q1996\\E",
      "shortCiteRegEx" : "Reiter",
      "year" : 1996
    }, {
      "title" : "Snoopy—a unifying petri net framework to investigate biomolecular networks",
      "author" : [ "C. Rohr", "W. Marwan", "M. Heiner" ],
      "venue" : "Bioinformatics 26,",
      "citeRegEx" : "Rohr et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Rohr et al\\.",
      "year" : 2010
    }, {
      "title" : "Polymorphism of human cytochrome p450 2d6 and its clinical significance: Part i",
      "author" : [ "SF Z" ],
      "venue" : "Clinical Pharmacoknetics 48,",
      "citeRegEx" : "Z.,? \\Q2009\\E",
      "shortCiteRegEx" : "Z.",
      "year" : 2009
    }, {
      "title" : "A constructive semantic characterization of aggregates in answer set programming",
      "author" : [ "T.C. Son", "E. Pontelli" ],
      "venue" : "Theory and Practice of Logic Programming",
      "citeRegEx" : "Son and Pontelli,? \\Q2007\\E",
      "shortCiteRegEx" : "Son and Pontelli",
      "year" : 2007
    }, {
      "title" : "Mathematics of multisets",
      "author" : [ "A. Syropoulos" ],
      "venue" : "Multiset Processing pp",
      "citeRegEx" : "Syropoulos,? \\Q2001\\E",
      "shortCiteRegEx" : "Syropoulos",
      "year" : 2001
    }, {
      "title" : "Synthesis of pharmacokinetic pathways through knowledge acquisition and automated reasoning",
      "author" : [ "L. Tari", "C. Baral", "S. Anwar", "S. Liang", "J. Hakenberg" ],
      "venue" : "Pacific Symposium on Biocomputing",
      "citeRegEx" : "Tari et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Tari et al\\.",
      "year" : 2010
    }, {
      "title" : "Discovering drug interactions: a text-mining and reasoning approach based on properties of drug metabolism.",
      "author" : [ "L. Tari", "J. Cai", "C. Baral", "S. Liang", "S. Anwar" ],
      "venue" : "European Conference on Computational Biology",
      "citeRegEx" : "Tari et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Tari et al\\.",
      "year" : 2010
    }, {
      "title" : "Querying a parse tree database of medline text to synthesize user-specific biomolecular networks",
      "author" : [ "L. Tari", "J. Hakenberg", "G. Gonzalez", "C. Baral" ],
      "venue" : "Proc Pac Symp Biocomput 14,",
      "citeRegEx" : "Tari et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Tari et al\\.",
      "year" : 2009
    }, {
      "title" : "Incremental information extraction using relational databases",
      "author" : [ "L. Tari", "P.H. Tu", "J. Hakenberg", "Y. Chen", "T.C. Son", "G. Gonzalez", "C. Baral" ],
      "venue" : "IEEE Transactions on Knowledge and Data Engineering",
      "citeRegEx" : "Tari et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Tari et al\\.",
      "year" : 2012
    }, {
      "title" : "Pharmacogenomics and bioinformatics: Pharmgkb",
      "author" : [ "C.F. Thorn", "T.E. Klein", "R.B. Altman" ],
      "venue" : "Pharmacogenomics 11,",
      "citeRegEx" : "Thorn et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Thorn et al\\.",
      "year" : 2010
    }, {
      "title" : "Self-modifying nets, a natural extension of Petri nets”, in “Automata, Languages and Programming",
      "author" : [ "R. Valk" ],
      "venue" : "vol. 62 of Lecture Notes in Computer Science,",
      "citeRegEx" : "Valk,? \\Q1978\\E",
      "shortCiteRegEx" : "Valk",
      "year" : 1978
    }, {
      "title" : "Object Petri nets: Using the nets-within-nets paradigm”, in “Advances in Petri Nets: Lectures on Concurrency and Petri Nets",
      "author" : [ "R. Valk" ],
      "venue" : "vol. 3098 of Lecture Notes in Computer Science,",
      "citeRegEx" : "Valk,? \\Q2004\\E",
      "shortCiteRegEx" : "Valk",
      "year" : 2004
    }, {
      "title" : "Drugbank: a knowledgebase for drugs, drug actions and drug targets.",
      "author" : [ "D. Wishart", "C. Knox", "A. Guo", "D. Cheng", "S. Shrivastava", "D. Tzur", "B. Gautam", "M. Hassanali" ],
      "venue" : "Nucleic Acids research 36,",
      "citeRegEx" : "Wishart et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Wishart et al\\.",
      "year" : 2008
    }, {
      "title" : "Drugbank: a comprehensive resource for in silico drug discovery and exploration",
      "author" : [ "D.S. Wishart", "C. Knox", "A.C. Guo" ],
      "venue" : "Nucleic Acids research 34,",
      "citeRegEx" : "Wishart et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Wishart et al\\.",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 23,
      "context" : "1 This figure from Tari et al. (2010b) outlines the effects of drug A on drug B through (a) direct induction/inhibition of enzymes; (b) indirect induction/inhibition of transportation factors that regulate the drug-metabolizing enzymes.",
      "startOffset" : 19,
      "endOffset" : 39
    }, {
      "referenceID" : 1,
      "context" : "Pathway information comes in various formats, such as cartoon drawings, formal graphical representations like Kohn’s Maps Kohn et al. (2006), curated databases of pathways Kanehisa and Goto (2000); Karp et al.",
      "startOffset" : 122,
      "endOffset" : 141
    }, {
      "referenceID" : 1,
      "context" : "Pathway information comes in various formats, such as cartoon drawings, formal graphical representations like Kohn’s Maps Kohn et al. (2006), curated databases of pathways Kanehisa and Goto (2000); Karp et al.",
      "startOffset" : 122,
      "endOffset" : 197
    }, {
      "referenceID" : 1,
      "context" : "Pathway information comes in various formats, such as cartoon drawings, formal graphical representations like Kohn’s Maps Kohn et al. (2006), curated databases of pathways Kanehisa and Goto (2000); Karp et al. (2002); Croft et al.",
      "startOffset" : 122,
      "endOffset" : 217
    }, {
      "referenceID" : 1,
      "context" : "Pathway information comes in various formats, such as cartoon drawings, formal graphical representations like Kohn’s Maps Kohn et al. (2006), curated databases of pathways Kanehisa and Goto (2000); Karp et al. (2002); Croft et al. (2011) and free text.",
      "startOffset" : 122,
      "endOffset" : 238
    }, {
      "referenceID" : 1,
      "context" : "Pathway information comes in various formats, such as cartoon drawings, formal graphical representations like Kohn’s Maps Kohn et al. (2006), curated databases of pathways Kanehisa and Goto (2000); Karp et al. (2002); Croft et al. (2011) and free text. The depth of this knowledge as well as its taxonomy varies with the source. Thus, a common specification language is needed. Such a language must be easy to understand and must have a well defined semantics. Queries are normally specified in natural language, which is vague. So, a more precise query language is needed. One could ask queries in one of the existing formal languages Gelfond and Lifschitz (1998), but that will be burdensome for a user to become fluent.",
      "startOffset" : 122,
      "endOffset" : 665
    }, {
      "referenceID" : 12,
      "context" : "Petri Nets Peterson (1977) are a popular representation formalism used to model biological systems and to simulate them.",
      "startOffset" : 11,
      "endOffset" : 27
    }, {
      "referenceID" : 12,
      "context" : "Petri Nets Peterson (1977) are a popular representation formalism used to model biological systems and to simulate them. They have been used to model and analyze the dynamic behavior as well as structural properties of biological systems. However, such analysis is usually limited to invariant determination, liveness, boundedness and reachability. To our knowledge they have not been used to answer questions similar to the aforementioned. In order to represent deeper reasoning questions, we have to make extensions to the Petri Net model as the basic model lacks sufficient richness. For example, we may want to change the firing semantics to limit the state space or maximize parallel activity. Although numerous Petri Net modeling, simulation and analysis systems exist Jensen et al. (2007); Rohr et al.",
      "startOffset" : 11,
      "endOffset" : 796
    }, {
      "referenceID" : 12,
      "context" : "Petri Nets Peterson (1977) are a popular representation formalism used to model biological systems and to simulate them. They have been used to model and analyze the dynamic behavior as well as structural properties of biological systems. However, such analysis is usually limited to invariant determination, liveness, boundedness and reachability. To our knowledge they have not been used to answer questions similar to the aforementioned. In order to represent deeper reasoning questions, we have to make extensions to the Petri Net model as the basic model lacks sufficient richness. For example, we may want to change the firing semantics to limit the state space or maximize parallel activity. Although numerous Petri Net modeling, simulation and analysis systems exist Jensen et al. (2007); Rohr et al. (2010); Kounev et al.",
      "startOffset" : 11,
      "endOffset" : 816
    }, {
      "referenceID" : 2,
      "context" : "(2010); Kounev et al. (2006); Berthomieu* et al.",
      "startOffset" : 8,
      "endOffset" : 29
    }, {
      "referenceID" : 2,
      "context" : "(2010); Kounev et al. (2006); Berthomieu* et al. (2004); Nagasaki et al.",
      "startOffset" : 8,
      "endOffset" : 56
    }, {
      "referenceID" : 2,
      "context" : "(2010); Kounev et al. (2006); Berthomieu* et al. (2004); Nagasaki et al. (2010); Kummer et al.",
      "startOffset" : 8,
      "endOffset" : 80
    }, {
      "referenceID" : 2,
      "context" : "(2010); Kounev et al. (2006); Berthomieu* et al. (2004); Nagasaki et al. (2010); Kummer et al. (2000), we found certain limitations in the default implementation of these systems as well that prevented us from using them as is.",
      "startOffset" : 8,
      "endOffset" : 102
    }, {
      "referenceID" : 2,
      "context" : "(2010); Kounev et al. (2006); Berthomieu* et al. (2004); Nagasaki et al. (2010); Kummer et al. (2000), we found certain limitations in the default implementation of these systems as well that prevented us from using them as is. For example, the Colored Petri Net implementation CPNtools 2 does not allow inhibitor arcs (we use to model protein inhibition); Cell Illustrator Nagasaki et al. (2010) is closed source and does not support colored tokens (we use to model locations); Snoopy Rohr et al.",
      "startOffset" : 8,
      "endOffset" : 397
    }, {
      "referenceID" : 2,
      "context" : "(2010); Kounev et al. (2006); Berthomieu* et al. (2004); Nagasaki et al. (2010); Kummer et al. (2000), we found certain limitations in the default implementation of these systems as well that prevented us from using them as is. For example, the Colored Petri Net implementation CPNtools 2 does not allow inhibitor arcs (we use to model protein inhibition); Cell Illustrator Nagasaki et al. (2010) is closed source and does not support colored tokens (we use to model locations); Snoopy Rohr et al. (2010) supports a large number of extensions, but it is unclear how one exports the simulation results for further reasoning; and most did not allow exploring all possible state evolutions of a pathway or using different firing semantics.",
      "startOffset" : 8,
      "endOffset" : 505
    }, {
      "referenceID" : 8,
      "context" : "To make these extensions in an easy manner we use Answer Set Programming (ASP) Lifschitz (2008) as the language to represent and simulate Petri Nets.",
      "startOffset" : 79,
      "endOffset" : 96
    }, {
      "referenceID" : 8,
      "context" : "To make these extensions in an easy manner we use Answer Set Programming (ASP) Lifschitz (2008) as the language to represent and simulate Petri Nets. It allows a simple encoding of the Petri Net and can be easily extended to incorporate extensions 3. In addition, ASP allows powerful reasoning capability and the possibility of implementing additional constructs not supported by Petri Nets directly, such as the ability to filter trajectories. Petri Net to ASP translation has been studied before Behrens and Dix (2007); Heljanko and Niemelä (2000).",
      "startOffset" : 79,
      "endOffset" : 521
    }, {
      "referenceID" : 8,
      "context" : "To make these extensions in an easy manner we use Answer Set Programming (ASP) Lifschitz (2008) as the language to represent and simulate Petri Nets. It allows a simple encoding of the Petri Net and can be easily extended to incorporate extensions 3. In addition, ASP allows powerful reasoning capability and the possibility of implementing additional constructs not supported by Petri Nets directly, such as the ability to filter trajectories. Petri Net to ASP translation has been studied before Behrens and Dix (2007); Heljanko and Niemelä (2000). However, these implementations have been limited to specific classes of Petri Nets and have different focus.",
      "startOffset" : 79,
      "endOffset" : 550
    }, {
      "referenceID" : 8,
      "context" : "To make these extensions in an easy manner we use Answer Set Programming (ASP) Lifschitz (2008) as the language to represent and simulate Petri Nets. It allows a simple encoding of the Petri Net and can be easily extended to incorporate extensions 3. In addition, ASP allows powerful reasoning capability and the possibility of implementing additional constructs not supported by Petri Nets directly, such as the ability to filter trajectories. Petri Net to ASP translation has been studied before Behrens and Dix (2007); Heljanko and Niemelä (2000). However, these implementations have been limited to specific classes of Petri Nets and have different focus. For example, the Simple Logic Petri Nets Behrens and Dix (2007) do not allow numerical accumulation of the same tokens from multiple transitions to a single place and the Binary Petri Nets Heljanko and Niemelä (2000) do not allow more than one tokens at any place.",
      "startOffset" : 79,
      "endOffset" : 724
    }, {
      "referenceID" : 8,
      "context" : "To make these extensions in an easy manner we use Answer Set Programming (ASP) Lifschitz (2008) as the language to represent and simulate Petri Nets. It allows a simple encoding of the Petri Net and can be easily extended to incorporate extensions 3. In addition, ASP allows powerful reasoning capability and the possibility of implementing additional constructs not supported by Petri Nets directly, such as the ability to filter trajectories. Petri Net to ASP translation has been studied before Behrens and Dix (2007); Heljanko and Niemelä (2000). However, these implementations have been limited to specific classes of Petri Nets and have different focus. For example, the Simple Logic Petri Nets Behrens and Dix (2007) do not allow numerical accumulation of the same tokens from multiple transitions to a single place and the Binary Petri Nets Heljanko and Niemelä (2000) do not allow more than one tokens at any place.",
      "startOffset" : 79,
      "endOffset" : 877
    }, {
      "referenceID" : 23,
      "context" : "For this, we use a system called the Parse Tree Query Language (PTQL) Tari et al. (2012) to nuggets of information from the abstracts published on PubMed 5.",
      "startOffset" : 70,
      "endOffset" : 89
    }, {
      "referenceID" : 23,
      "context" : "For this, we use a system called the Parse Tree Query Language (PTQL) Tari et al. (2012) to nuggets of information from the abstracts published on PubMed 5. Sentences are parsed using the Link Grammar Sleator and Temperley (1993) or Stanford Parser de Marneffe and Manning (2008); with various objectclasses identified within the sentence.",
      "startOffset" : 70,
      "endOffset" : 230
    }, {
      "referenceID" : 23,
      "context" : "For this, we use a system called the Parse Tree Query Language (PTQL) Tari et al. (2012) to nuggets of information from the abstracts published on PubMed 5. Sentences are parsed using the Link Grammar Sleator and Temperley (1993) or Stanford Parser de Marneffe and Manning (2008); with various objectclasses identified within the sentence.",
      "startOffset" : 70,
      "endOffset" : 280
    }, {
      "referenceID" : 23,
      "context" : "For this, we use a system called the Parse Tree Query Language (PTQL) Tari et al. (2012) to nuggets of information from the abstracts published on PubMed 5. Sentences are parsed using the Link Grammar Sleator and Temperley (1993) or Stanford Parser de Marneffe and Manning (2008); with various objectclasses identified within the sentence. Unlike Information Retrieval (IR) approaches that tend to treat documents as unstructured bags-of-words, PTQL treats words (or word-groups) as sentence elements with syntactic as well as dependency relationships between them. PTQL queries combine lexical, syntactic and semantic features of sentence elements. Thus with PTQL, one can ask for the first-noun of a noun-phrase that is the direct-object of a verb-phrase for some specific verb string. To accomplish its task, PTQL performs a number of pre-processing steps on its input useful for text extraction and leverages on various existing databases. These include sentence splitting, tokenization, part-of-speech (POS) tagging, named entity recognition, entitymention normalization, cross-linking with concepts from external databases, such as Gene Ontology Camon et al. (2004) and UniProt Consortium (2012).",
      "startOffset" : 70,
      "endOffset" : 1172
    }, {
      "referenceID" : 23,
      "context" : "For this, we use a system called the Parse Tree Query Language (PTQL) Tari et al. (2012) to nuggets of information from the abstracts published on PubMed 5. Sentences are parsed using the Link Grammar Sleator and Temperley (1993) or Stanford Parser de Marneffe and Manning (2008); with various objectclasses identified within the sentence. Unlike Information Retrieval (IR) approaches that tend to treat documents as unstructured bags-of-words, PTQL treats words (or word-groups) as sentence elements with syntactic as well as dependency relationships between them. PTQL queries combine lexical, syntactic and semantic features of sentence elements. Thus with PTQL, one can ask for the first-noun of a noun-phrase that is the direct-object of a verb-phrase for some specific verb string. To accomplish its task, PTQL performs a number of pre-processing steps on its input useful for text extraction and leverages on various existing databases. These include sentence splitting, tokenization, part-of-speech (POS) tagging, named entity recognition, entitymention normalization, cross-linking with concepts from external databases, such as Gene Ontology Camon et al. (2004) and UniProt Consortium (2012). We extract gene-gene, gene-drug, and gene-disease relationships using PTQL, assemble them into a pathway specification and reason with the extracted knowledge to determine possible drug interactions.",
      "startOffset" : 70,
      "endOffset" : 1202
    }, {
      "referenceID" : 12,
      "context" : "Petri Net Peterson (1977) is a graphical modeling language with formal semantics used for description of distributed systems.",
      "startOffset" : 10,
      "endOffset" : 26
    }, {
      "referenceID" : 12,
      "context" : "Petri Net Peterson (1977) is a graphical modeling language with formal semantics used for description of distributed systems. It is named after Carl Adam Petri, who formally defined Petri Nets in his PhD thesis in the 1960’s Brauer and Reisig (2006). Petri nets have been widely used to model a wide range of systems, from distributed systems to biological pathways.",
      "startOffset" : 10,
      "endOffset" : 250
    }, {
      "referenceID" : 12,
      "context" : "Petri Net Peterson (1977) is a graphical modeling language with formal semantics used for description of distributed systems. It is named after Carl Adam Petri, who formally defined Petri Nets in his PhD thesis in the 1960’s Brauer and Reisig (2006). Petri nets have been widely used to model a wide range of systems, from distributed systems to biological pathways. The main advantages of Petri Net representation include its simplicity and the ability to model concurrent and asynchronous systems and processes. A variety of Petri Net extensions have been proposed in the literature, e.g. inhibitor arcs, reset transitions, timed transitions, stochastic transitions, prioritized transitions, colored petri nets, logic petri nets, hierarchical petri nets, hybrid petri nets and functional petri nets to a name a few Behrens and Dix (2007); Music (2012); Hardy and Robillard (2004).",
      "startOffset" : 10,
      "endOffset" : 840
    }, {
      "referenceID" : 11,
      "context" : "inhibitor arcs, reset transitions, timed transitions, stochastic transitions, prioritized transitions, colored petri nets, logic petri nets, hierarchical petri nets, hybrid petri nets and functional petri nets to a name a few Behrens and Dix (2007); Music (2012); Hardy and Robillard (2004).",
      "startOffset" : 250,
      "endOffset" : 263
    }, {
      "referenceID" : 11,
      "context" : "inhibitor arcs, reset transitions, timed transitions, stochastic transitions, prioritized transitions, colored petri nets, logic petri nets, hierarchical petri nets, hybrid petri nets and functional petri nets to a name a few Behrens and Dix (2007); Music (2012); Hardy and Robillard (2004). Our interest in Petri Nets is for representing biological pathways and simulating them in order to answer simulation based reasoning questions.",
      "startOffset" : 250,
      "endOffset" : 291
    }, {
      "referenceID" : 8,
      "context" : "Answer Set Programming (ASP) is a declarative logic programming language that is based on the Stable Model Semantics Gelfond and Lifschitz (1988). It has been applied to a problems ranging from spacecrafts, work flows, natural language processing and biological systems modeling.",
      "startOffset" : 129,
      "endOffset" : 146
    }, {
      "referenceID" : 21,
      "context" : "We define reduct of an ASP program by treating aggregate atoms in a similar way as negation-as-failure literals, since our code does not contain recursion through aggregation (which can yield non-intuitive answer-sets Son and Pontelli (2007)).",
      "startOffset" : 218,
      "endOffset" : 242
    }, {
      "referenceID" : 22,
      "context" : "The reader is referred to Syropoulos (2001) for details.",
      "startOffset" : 26,
      "endOffset" : 44
    }, {
      "referenceID" : 28,
      "context" : "We could have, instead, extended our encoding to include self-modifying nets Valk (1978), but our modified-definition provides a simpler solution.",
      "startOffset" : 77,
      "endOffset" : 89
    }, {
      "referenceID" : 13,
      "context" : "Definition 25 (Inhibitor Arc) An inhibitor arc Peterson (1977) is a place-transition arc that inhibits its transition from firing as long as the place has any tokens in it.",
      "startOffset" : 47,
      "endOffset" : 63
    }, {
      "referenceID" : 13,
      "context" : "This allows a more compact representation of complicated networks Peterson et al. (1980).",
      "startOffset" : 66,
      "endOffset" : 89
    }, {
      "referenceID" : 16,
      "context" : "Timed transitions Ramchandani (1974) model this variation of duration.",
      "startOffset" : 18,
      "endOffset" : 37
    }, {
      "referenceID" : 28,
      "context" : "Self Modifying Petri Nets Valk (1978), which allow marking-dependent arc-weights can be implemented in a similar manner as the Reset Arc extension in section 2.",
      "startOffset" : 26,
      "endOffset" : 38
    }, {
      "referenceID" : 28,
      "context" : "Self Modifying Petri Nets Valk (1978), which allow marking-dependent arc-weights can be implemented in a similar manner as the Reset Arc extension in section 2.5. Object Petri Nets Valk (2004), in which each token is a Petri Net itself can be implemented (using token reference semantics) by adding an additional “network-id” parameter to our encoding, where “id=0” is reserved for system net and higher numbers are used for token nets.",
      "startOffset" : 26,
      "endOffset" : 193
    }, {
      "referenceID" : 1,
      "context" : "Kohn’s maps Kohn et al. (2006)), and biological publications.",
      "startOffset" : 12,
      "endOffset" : 31
    }, {
      "referenceID" : 8,
      "context" : "Inspiration for our high level language comes from action languages and query languages such as Gelfond and Lifschitz (1993). While action languages generally describe transition systems Gelfond and Lifschitz (1998), our language describes trajectories.",
      "startOffset" : 108,
      "endOffset" : 125
    }, {
      "referenceID" : 8,
      "context" : "Inspiration for our high level language comes from action languages and query languages such as Gelfond and Lifschitz (1993). While action languages generally describe transition systems Gelfond and Lifschitz (1998), our language describes trajectories.",
      "startOffset" : 108,
      "endOffset" : 216
    }, {
      "referenceID" : 8,
      "context" : "Inspiration for our high level language comes from action languages and query languages such as Gelfond and Lifschitz (1993). While action languages generally describe transition systems Gelfond and Lifschitz (1998), our language describes trajectories. In addition, our language is geared towards modeling natural systems, in which actions occur autonomously Reiter (1996) when their pre-conditions are satisfied; and we do not allow the quantities to become negative (as the quantities represent amounts of physical entities).",
      "startOffset" : 108,
      "endOffset" : 374
    }, {
      "referenceID" : 10,
      "context" : "Note that these formulas and many other of our single trajectory formulas can be replaced by an LTL Manna and Pnueli (1992) formula, but we have kept this syntax as it is more relevant to the question answering needs in the biological domain.",
      "startOffset" : 100,
      "endOffset" : 124
    }, {
      "referenceID" : 17,
      "context" : "We use the biological model described by Regev (2001) for comparison against our system.",
      "startOffset" : 41,
      "endOffset" : 54
    }, {
      "referenceID" : 15,
      "context" : "However, stochastic extensions allow representation of quantitative data Priami et al. (2001). In contrast, the focus of our system is on the quantitative+qualitative representation using numeric fluents.",
      "startOffset" : 73,
      "endOffset" : 94
    }, {
      "referenceID" : 8,
      "context" : "Action language A Gelfond and Lifschitz (1993) is a formalism that has been used to model biological systems and pathways.",
      "startOffset" : 30,
      "endOffset" : 47
    }, {
      "referenceID" : 8,
      "context" : "Action language B extendsA by adding static causal laws, which allows one to specify indirect effects or ramifications of an action Gelfond and Lifschitz (2012). We relate it to our work below:",
      "startOffset" : 144,
      "endOffset" : 161
    }, {
      "referenceID" : 8,
      "context" : "• Inertia is built into the semantics of B Gelfond and Lifschitz (2012). Our language also has intertia built in.",
      "startOffset" : 55,
      "endOffset" : 72
    }, {
      "referenceID" : 8,
      "context" : "a formula is true if there is a cause for it to be true Giunchiglia and Lifschitz (1998). It has been previously used to represent and reason about biological pathways Dworschak et al.",
      "startOffset" : 72,
      "endOffset" : 89
    }, {
      "referenceID" : 8,
      "context" : "a formula is true if there is a cause for it to be true Giunchiglia and Lifschitz (1998). It has been previously used to represent and reason about biological pathways Dworschak et al. (2008). We relate it to our work below:",
      "startOffset" : 72,
      "endOffset" : 192
    }, {
      "referenceID" : 8,
      "context" : "However, the additive fluents extension Lee and Lifschitz (2003) adds the capability of additive fluents through new rules.",
      "startOffset" : 48,
      "endOffset" : 65
    }, {
      "referenceID" : 6,
      "context" : "Action language BC combines features of B and C+ Lee et al. (2013). First we give a brief overview of BC.",
      "startOffset" : 49,
      "endOffset" : 67
    }, {
      "referenceID" : 7,
      "context" : "We relate the work in Lee and Meng (2013) where C+ is extended using ASPMT with our work.",
      "startOffset" : 22,
      "endOffset" : 42
    }, {
      "referenceID" : 12,
      "context" : "Our query language also allows interventions similar to Pearl’s surgeries Pearl (1995), which are more general than actions.",
      "startOffset" : 56,
      "endOffset" : 87
    }, {
      "referenceID" : 23,
      "context" : "We primarily use a system called PTQL Tari et al. (2012) to extract these relationships, which allows combining the syntactic structure (parse tree), semantic elements, and word order in a relationship query.",
      "startOffset" : 38,
      "endOffset" : 57
    }, {
      "referenceID" : 23,
      "context" : "We summarize the extraction of relationships for our work on drug-drug interactions from Tari et al. (2010b). Studying drug-drug interactions are a major activity in drug development.",
      "startOffset" : 89,
      "endOffset" : 109
    }, {
      "referenceID" : 23,
      "context" : "We summarize the extraction of relationships for our work on drug-drug interactions from Tari et al. (2010b). Studying drug-drug interactions are a major activity in drug development. Drug interactions occur due to the interactions between the biological processes / pathways that are responsible metabolizing and transporting drugs. Metabolic processes remove a drug from the system within a certain time period. For a drug to remain effective, it must be maintained within its therapeutic window for the period of treatment, requiring taking the drug periodically. Outside the therapeutic window, a drug can become toxic if a quantity greater than the therapeutic window is retained; or it can become ineffective if a quantity less than the therapeutic window is retained. Since liver enzymes metabolize most drugs, it is the location where most metabolic-interaction takes place. Induction or inhibition of these enzymes can affect the bioavailability of a drug through transcriptional regulation, either directly or indirectly. For example, if drug A inhibits enzyme E, which metabolizes drug B, then the bioavailability of drug B will be higher than normal, rendering it toxic. On the other hand, if drug A induces enzyme E, which metabolizes drug B, then drug B’s bioavailability will be lesser than normal, rendering it ineffective. Inhibition of enzymes is a common form of drug-drug interactions Boobis (2009). In direct inhibition, a drug A inhibit enzyme E, which is responsible for metabolism of drug B.",
      "startOffset" : 89,
      "endOffset" : 1419
    }, {
      "referenceID" : 23,
      "context" : "1 and it builds upon the work done in Tari et al. (2009).",
      "startOffset" : 38,
      "endOffset" : 57
    }, {
      "referenceID" : 23,
      "context" : "1: This figure from Tari et al. (2010b) outlines the effects of drug A on drug B through (a) direct induction/inhibition of enzymes; (b) indirect induction/inhibition of transportation factors that regulate the drug-metabolizing enzymes.",
      "startOffset" : 20,
      "endOffset" : 40
    }, {
      "referenceID" : 23,
      "context" : "1: This table from Tari et al. (2010b) shows the triplets representing various properties relevant to the extraction of implicit drug interactions and their description.",
      "startOffset" : 19,
      "endOffset" : 39
    }, {
      "referenceID" : 23,
      "context" : "2: This table from Tari et al. (2010b) shows the triplets representing various properties relevant to the extraction of implicit drug interactions and their description.",
      "startOffset" : 19,
      "endOffset" : 39
    }, {
      "referenceID" : 23,
      "context" : "TP represents truepositives, while FN represents false-negatives Tari et al. (2010b)",
      "startOffset" : 65,
      "endOffset" : 85
    }, {
      "referenceID" : 23,
      "context" : "For details, see Tari et al. (2010b).",
      "startOffset" : 17,
      "endOffset" : 37
    }, {
      "referenceID" : 4,
      "context" : "For genes, we use BANNER Leaman et al. (2008) trained on BioCreative II GM training set Krallinger et al.",
      "startOffset" : 25,
      "endOffset" : 46
    }, {
      "referenceID" : 4,
      "context" : "For genes, we use BANNER Leaman et al. (2008) trained on BioCreative II GM training set Krallinger et al. (2008). For genotypes (genetic variations including SNPs) we used a combination of MutationFinder Caporaso et al.",
      "startOffset" : 25,
      "endOffset" : 113
    }, {
      "referenceID" : 4,
      "context" : "For genes, we use BANNER Leaman et al. (2008) trained on BioCreative II GM training set Krallinger et al. (2008). For genotypes (genetic variations including SNPs) we used a combination of MutationFinder Caporaso et al. (2007) and custom components.",
      "startOffset" : 25,
      "endOffset" : 227
    }, {
      "referenceID" : 4,
      "context" : "For genes, we use BANNER Leaman et al. (2008) trained on BioCreative II GM training set Krallinger et al. (2008). For genotypes (genetic variations including SNPs) we used a combination of MutationFinder Caporaso et al. (2007) and custom components. Custom components were targeted mostly on non-SNPs (“c.76 78delACT”, 11MV324KF”) and insertions/deletions (“1707 del T”, “c.76 77insG”), RefSNPs (rs-numbers) and names of alleles/haplotypes (“CYP2D6*4”, “T allele”, “null allele”). For diseases (and ADRs), we used BANNER trained on a corpus of 3000 sentences with disease annotations Leaman et al. (2009). An additional 200 random sentences containing no disease were added from BioCreative II GM data to offset the low percentage (10%) of sentences without disease in the 3000 sentence corpus.",
      "startOffset" : 25,
      "endOffset" : 605
    }, {
      "referenceID" : 3,
      "context" : "A dictionary for adverse drug reactions originated from SIDER Side Effect Resource Kuhn et al. (2010), which provides a mapping of ADR terminology to UMLS CUIs.",
      "startOffset" : 83,
      "endOffset" : 102
    }, {
      "referenceID" : 3,
      "context" : "A dictionary for adverse drug reactions originated from SIDER Side Effect Resource Kuhn et al. (2010), which provides a mapping of ADR terminology to UMLS CUIs. It consisted of 1.6k UMLS concepts with 6.5k terms. For drugs, we used a dictionary based on DrugBankWishart et al. (2006) containing about 29k different drug names including both generic as well as brand names.",
      "startOffset" : 83,
      "endOffset" : 284
    }, {
      "referenceID" : 30,
      "context" : "It uses keywords from PolySearch Wishart et al. (2008) as well as our own.",
      "startOffset" : 33,
      "endOffset" : 55
    }, {
      "referenceID" : 0,
      "context" : "We used Stanford parser Klein and Manning (2003) to get grammatical structure of a sentence as a dependency tree.",
      "startOffset" : 24,
      "endOffset" : 49
    }, {
      "referenceID" : 9,
      "context" : "From background knowledge we find out that the stimulation in the activity can be as high as 2-times Luo et al. (2002). Line 5.",
      "startOffset" : 101,
      "endOffset" : 119
    }, {
      "referenceID" : 7,
      "context" : "Alternatively, a system developed on the ASPMT Lee and Meng (2013) approach could be used, since it can represent longer runs, larger quantities, and real number quantities.",
      "startOffset" : 47,
      "endOffset" : 67
    }, {
      "referenceID" : 23,
      "context" : "The text extraction work was published in Tari et al. (2010b,a); Hakenberg et al. (2012).",
      "startOffset" : 42,
      "endOffset" : 89
    } ],
    "year" : 2014,
    "abstractText" : "Biological organisms are made up of cells containing numerous interconnected biochemical processes. Diseases occur when normal functionality of these processes is disrupted, manifesting as disease symptoms. Thus, understanding these biochemical processes and their interrelationships is a primary task in biomedical research and a prerequisite for activities including diagnosing diseases, and drug development. Scientists studying these interconnected processes have identified various pathways involved in drug metabolism, diseases, and signal transduction, etc. Over the last decade high-throughput technologies, new algorithms and speed improvements have resulted in deeper knowledge about biological systems and pathways, resulting in more refined models. These refined models tend to be large and complex, making it difficult for a person to remember all aspects of it. Thus, computer models are needed to represent and analyze them. The refinement activity itself requires reasoning with a pathway model by posing queries against it and comparing the results against a real biological system. We want to model biological systems and pathways in such a way that we can answer questions about them. Many existing models focus on structural and/or factoid questions, relying on surface-level information that does not require understanding the underlying model. We believe these are not the kind of questions that a biologist may ask someone to test their understanding of the biological processes. We want our system to be able to answer the kind of questions a biologist may ask. So, we turned to early college level text books on biology for such questions. Thus the main goal of our thesis is to develop a system that allows us to encode knowledge about biological pathways and answer such questions about them that demonstrate understanding of the pathway. To that end, we develop a language that will allow posing such questions and illustrate the utility of our framework with various applications in the biological domain. We use some existing tools with modifications to accomplish our goal. Finally, we use our question answering system in real world applications by extracting pathway knowledge from text and answering questions related to drug development.",
    "creator" : "LaTeX with hyperref package"
  }
}