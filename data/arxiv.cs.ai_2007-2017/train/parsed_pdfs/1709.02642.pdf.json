{
  "name" : "1709.02642.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Object-Oriented Knowledge Extraction using Universal Exploiters",
    "authors" : [ "Dmytro Terletskyi" ],
    "emails" : [ "dmytro.terletskyi@gmail.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "exploiters-based knowledge extraction methods, which allow generation of new knowledge, based on the basic ones. The main achievement of the paper is useful features of some universal exploiters proof, which allow extending set of basic classes and set of basic relations by finite set of new classes of objects and relations among them, which allow creating of complete lattice. Proposed approach gives an opportunity to compute quantity of new classes, which can be generated using it, and quantity of different types, which each of obtained classes describes; constructing of defined hierarchy of classes with determined subsumption relation; avoidance of some problems of inheritance and more efficient restoring of basic knowledge within the database.\nKeywords — knowledge extraction; object-oriented dynamic networks; universal exploiters; lattice; semilattice; inheritance; hierarchies of classes.\nI. INTRODUCTION\nDuring recent years application of knowledge-based systems has extremely increased, therefore variety of systems and knowledge bases for different domains were developed. In spite of this, the invention of efficient methods for knowledge representation (KR), inference and extraction is still topical issue.\nNowadays there are many knowledge representation formalisms (KRFs), which are used for knowledge-based systems (KBSs) development. Currently the most commonlyused approaches are semantic networks, ontologies, logical and rule-based formalisms. However, the certain programming paradigm, language and some stack of programming technologies should be chosen for development of a KBS. This choice is very important, because each programming paradigm and language provides certain tools for system development and determined mechanisms of interaction among its modules, in particular interaction with database. Thus, chosen KRF and programming technologies for its implementation, should be at least compatible with respect to each other. Otherwise, developed KBS will have complicated interaction between the level of KRF and the level of its implementation. Consequently it can decrease the efficiency of such system. Despite this, chosen formalism should provide efficient representation of\nhierarchically-structured knowledge about particular domain, because concepts hierarchy makes KR more compact and allows performing of reasoning over itself. Furthermore, the hierarchy should be stored in the database in such way, that KBS can be able to extract the knowledge efficiently and represent them in terms of programming language, using which the system was developed. However, the representation of hierarchies is possible, only if chosen KRF and programming language support mechanism of inheritance.\nCurrently, the most commonly used programming paradigm is an object-oriented programming (OOP). All OOP-languages and many KRFs support single inheritance. However, as it was shown in [1]–[3], inheritance mechanism causes problem of exceptions, redundancy and ambiguity, which usually arise during construction of hierarchies and reasoning over them.\nII. KNOWLEDGE EXTRACTION\nAccording to [4]–[7], knowledge extraction is defined as creation or acquiring of knowledge from structured (e.g. relational databases, object-oriented database models, UML, XML and their fuzzy extensions, proposed in [8], [9]), semistructured (e.g. infoboxes) and unstructured (e.g. text, documents, images) data sources. In addition, the extracted knowledge should be represented in machine-processable format that enables inference.\nAccording to [6], there are two main paradigms of KE: ontology-based and open domain. They also can be called as close world knowledge extraction and open world knowledge extraction. The idea of first approach is to use ontology as vocabulary, which defines the types of concepts used in the knowledge base. It means that knowledge base contains defined number of types of entities and relationships. Thus, only relations included in the vocabulary can be extracted from the knowledge base.\nIn the second approach, knowledge-based system does not have any vocabulary and pre-specified relationship types in the knowledge base. It means that each entity or relation in knowledge base can be considered as a candidate. Therefore, any possible relation or assertion in the knowledge base can be extracted.\nHowever, Unbehauen, Hellmann, Auer, Stadler et al. in [4], [5] argued about absence of clear definition of what extracted knowledge is and paid attention to the fact, that mere usage such KRFs as RDF/OWL can not sufficiently define the notion of «knowledge». They have formulated two important questions:\n1. What is the result of data representation in terms of RDF/OWL (triplification process)? Structured data or\nrepresented knowledge?\n2. When does structured data became knowledge?\nAnalyzing these questions, it is possible to conclude that result of such knowledge extraction, first of all, will be structured data, which then can be interpreted as some knowledge. However, such interpretation can be performed only using particular KRF, where notion of knowledge is defined in a proper way. Therefore, any KRF can be considered as interpreter of data, according to its own specifics and specifics of particular domain, for representation of which the formalism was developed.\nOne of attempts to solve earlier mentioned problems is such KRF as object-oriented dynamic networks (OODN), which was proposed in [10]. It provides representation of knowledge in OOP-like style and is compatible with respect to many OOPlanguages. In addition, as it was demonstrated in [3], OODN allow constructing of polyhierarchies and avoiding, in many cases, problems of inheritance, which were mentioned above. Moreover, OODN have fuzzy extension, proposed in [11], [12], which provides representation of vague and imprecise knowledge, using the same structure as for the crisp case. One more feature of OODN is exploiters-based knowledge extraction (KE) methods, which provide generating of finitely defined set of new classes of objects and finitely set of new relations among them, based on the set of basic classes and relations among them. It allows calculation of quantity of new classes, which can be extracted, and quantity of different types, which each obtained class describes. Furthermore, according to [13], the set of basic classes of any OODN, extended by extracted classes, together with union exploiter, create upper semilattice. Constructed upper semilattice forms a hierarchy of classes, where each class satisfies subsumption relation defined over the hierarchy that makes it possible to find more general class for arbitrary pair of classes. Such approach allows extracting of new knowledge from the basic ones and provides an ability to reconstruct the knowledge base for increasing its compactness.\nIII. UNIVERSAL EXPLOITERS AND KNOWLEDGE EXTRACTION\nAs it was shown in [12], some universal exploiters can be efficiently used for KE. According to [12, Th. 1], all possible applications of union exploiter, including all its possible superpositions, to homogeneous classes of objects, which do not have common properties and methods, always generate finite quantity of new classes of objects, which can be precisely calculated.\nHowever, there are situations when homogeneous classes of objects can have common properties and (or) methods. Before we start to consider them, let us make clear what we mean by type, subtype and subclass. As it was mentioned in [13], inhomogeneous class of objects describes at least two different types of objects within one class, where type is defined as follows.\nDefinition 1. Type of objects it of arbitrary inhomogeneous\nclass of objects ))(),...,(),(( 1 TprTprTCoreT n , which\ndescribes types ntt ,...,1 , is a homogeneous class of objects\n))(),(( iii tprTCoret  , where ni ,1 .\nConsequently, each homogeneous class of objects describes particular type of objects. The definition shows that type and class of objects does not always mean the same, more precisely, homogeneous class of objects is equivalent to type of objects, however inhomogeneous class of objects is not equivalent to type of objects, because it describes some set of types. Now let us define notion of subtype.\nDefinition 2. Arbitrary type of objects 1t is a subtype of arbitrary type of objects 2t , i.e. 21 tt  if and only if\n         2121 tFtFtPtP  ,\nwhere  1tP ,  2tP are specifications of types 1t , 2t and  1tF ,  2tF are their signatures.\nThis definition actually defines the notion of subclass for the case of homogeneous classes, however it is not enough for the inhomogeneous classes of objects. The notion of subclass for inhomogeneous classes was introduced in [13], nevertheless it is restricted and does not take into account some cases, when classes of objects have common properties and methods. Let us consider an example for clear understanding.\nSuppose we have three homogeneous classes of objects\n        1111111 ,...,,,..., TfTfTpTpT mn ,\n        2212212 ,...,,,..., TfTfTpTpT wk ,\n        3313313 ,...,,,..., TfTfTpTpT rv .\nLet us assume that\n     312111 TpTpTp  ;      322212 TpTpTp  ,\n     332313 TpTpTp  ;    2414 TpTp  .\nUsing union exploiter, let us compute 21 TT  , 31 TT  and\n321 TTT  , i.e.\n        2211121221 ,, tprtprTCoreTTT\n         124123122121 ,,, TpTpTpTp ,\n        111115 ,...,,,..., tftftptp mn ,\n        221225 ,...,,,..., tftftptp wk .\n        3211131331 ,, tprtprTCoreTTT\n       133132131 ,, TpTpTp ,\n        111114 ,...,,,..., tftftptp mn ,\n        331334 ,...,,,..., tftftptp rv .\n 123321 TTTT\n          332211123 ,,, tprtprtprTCore\n       123312321231 ,, TpTpTp ,\n        111114 ,...,,,..., tftftptp mn ,\n        221224 ,...,,,..., tftftptp wk ,\n        331334 ,...,,,..., tftftptp rv .\nAccording to [13, Def. 12], 12313 TT  , however 12312 TT  . Nevertheless, according to Def. 1 and Def. 2,\n    111231 , tprTCoreT  ,\n    111232 , tprTCoreT  .\nDespite this, [13, Def. 12] is correct for the case when classes of objects have no common properties and methods. Let us assume that classes 1T , 2T and 3T do not have common properties and methods, then we have\n      22111221 , tprtprTTT\n         111111 ,...,,,..., tftftptp mn ,\n        221221 ,...,,,..., tftftptp wk .\n      32111331 , tprtprTTT\n         111111 ,...,,,..., tftftptp mn ,\n        331331 ,...,,,..., tftftptp rv .\n 123321 TTTT\n        332211 ,, tprtprtpr\n         111111 ,...,,,..., tftftptp mn ,\n        221221 ,...,,,..., tftftptp wk ,\n        331331 ,...,,,..., tftftptp rv .\nAccording to [13, Def. 12], 12313 TT  and 12312 TT  , therefore all results, which were presented in [13] are correct. That is why, let us extend the notion of subclass given in [13], using Def. 1 and Def. 2.\nDefinition 3. Arbitrary class of objects 1T , which describes types 11\n1 ,..., ntt , is a subclass of arbitrary class of objects 2T ,\nwhich describes types 22\n1 ,..., mtt , i.e. 21 TT  if and only if\n2121 | jiji tttt  , where ni ,1 , mj ,1 and 1, mn .\nNow, using this definition for classes 12T , 13T and 123T\nfrom Example 1, we can conclude that 12312 TT  and\n12313 TT  for both cases, when classes 1T , 2T and 3T have common properties and methods and when they do not have them.\nLet us consider homogeneous classes of objects nTT ,...,1 ,\nwhich describes types of objects ntt ,...,1 . Let us assume that\nthere is such type t , that ntttttt  ,...,, 21 . It means\nthat classes of objects nTT ,...,1 have some common properties and (or) methods. It is clearly, that the application of union exploiter to them will produce a set of new classes of objects. Using this idea, let us formulate and prove the following theorem.\nTheorem 1. For any\n  MERTTCOOODN n },{,,,...,, 1  ,\nwhere nTT ,...,1 are homogeneous classes, which describe\ntypes of objects ntt ,...,1 and there is a type t , such that\nntttttt  ,...,, 21 , all possible applications of union exploiter, including all possible its superpositions, to classes of objects from the set C and obtaining classes of objects using union exploiter, always generate finite quantity of new classes of objects, which can be precisely calculated by the following formula:\n  12  nCq nE ,\nwhere Cn  .\nProof: According to definition of union exploiter for classes of objects [13, Def. 14], the result of union of two arbitrary nonequivalent classes of objects 1T and 2T , which describe type of objects 1t and 2t respectively, is inhomogeneous class\nof objects T , which describes both these types. If there is a type t , such that ntttttt  ,...,, 21 , then class T will have the following structure\n )(),(),( 2211 tprtprTCoreT  .\nAccording to proof of [13, Th. 1], the number of all possible unique classes of objects created from the basic set of classes  nTTC ,...,1 using union exploiter can be\nrepresented as a combination of nk ,2 different classes\nfrom the set C . It is known that\n \n k\nn\nnk\nnC 0 2 .\nHowever, we cannot create classes of objects, which describe 1 and 0 different types, applying union exploiter to the classes of objects from the set C , i.e. we do not count 0nC and 1 nC . Therefore, we can conclude that\n     \n n\nk\nn\nk\nnk\nnnn\nk\nnE nCCCCCq 0 2\n01 12 . ■\nSimilarly to [13, Th. 2], we can formulate and prove the\nfollowing theorem.\nTheorem 2. Set of classes of objects\n  1211 ,...,,,...,   nTTTTC nn\nof any OODN, extended according to Th. 1, with union exploiter create the join-semilattice })1,{,(  ECJSL ,\nwhere class nJSL TTT  ...1 is its greatest upper bound, i.e. 1 .\nProof: According to the definition of join-semilattice given\nin [14], [15], it is a system })1,{,(  AJSL , where A is a poset,  is a binary, idempotent, commutative and associative operation and 1 is an unary operation, which are defined over the set A . In addition Aa  , 1 satisfies\n  11:1 aL (identity law).\nAccording to the theorem, carrier of join-semilattice is the set of classes C , set of exploiters E contains binary operation  and unary operation 1 , which are defined over the set C . Therefore })1,{,(  ECJSL , where\n  1211 ,...,,,...,   nTTTTC nn .\nFrom the [13, Def. 14] it follows, that mentioned properties\nof  are also true for  , i.e.\n1. 111 TTT  ,\n2. 1221 TTTT  ,\n3.     321321 TTTTTT  ,\nwhere CTTT 321 ,, . From the definition of  it follows\nthat JSLJSL TTT 1 , where nJSL TTT  ...1 .\nNow we need to prove that C is a poset. For this we should define 2212121 |, TTTTTCTT  and show that  is a relation of partial order under the set C . Taking into account that we have two types of classes, we need to define three kinds of  relation, i.e.\n1. homogeneous  homogeneous,\n2. homogeneous  inhomogeneous,\n3. inhomogeneous  inhomogeneous.\nIt was done in Def. 2 and Def. 3. Now let us prove reflexivity, anti-symmetry and transitivity of these relations.\n1. Reflexivity: 11111 TTTTT  follows from\nidempotency of  ;\n2. Anti-symmetry:\n22121 TTTTT  ,\n11212 TTTTT \nand from commutativity of  , we can conclude that 21 TT  ;\n3. Transitivity:\n22121 TTTTT  ,  3232 TTTT\n     3213213 TTTTTTT\n31331331 TTTTTTTT  .\nTherefore,\n  }1,{,,...,,,..., 1211   ETTTTCJSL nnn\nis a join-semilattice, where class nJSL TTT  ...1 is its greatest upper bound, i.e. 1 . ■\nNow let us define intersection exploiter for classes of\nobjects, using Def. 1.\nDefinition 4. Intersection of two arbitrary nonequivalent classes of objects 21 TT  , which describe types of objects 11 1 ,..., ntt and 22 1 ,..., mtt , respectively, where 1, mn , is inhomogeneous class of objects T , which describes types of objects 33\n1 ,..., wtt , where 1w , such that\n        lkljkikjik tttttttttt 32313213 ||,    21 jlil tttt  ,\nwhere wk ,1 , ni ,1 , mj ,1 .\nUsing this definition, let us formulate and prove the\nfollowing theorem.\nTheorem 3. For any\n  MERTTCOOODN n },{,,,...,, 1  ,\nwhere nTT ,...,1 are homogeneous classes, which describe\ntypes of objects ntt ,...,1 and there is a type t , such that\n        ttttttt n |...1\n   ntttt  ...1 ,\nall possible applications of intersection exploiter, including all possible its superpositions, to classes of objects from the set C and obtaining classes of objects, using intersection exploiter, always generate finite quantity of new classes of objects, which can be precisely calculated by the following formula:\n  12  nCq nE ,\nwhere Cn  .\nProof: According to Def. 4, the result of intersection of two arbitrary nonequivalent classes of objects 1T and 2T is inhomogeneous class of objects T that describes subtypes, which are common for all types of class 1T and 2T simultaneously.\nIt is known that the number of all possible unique classes of objects created from the basic set of classes  nTTC ,...,1 using intersection exploiter can be represented as a\ncombination of nk ,2 different classes from the set C . It is known that\n \n k\nn\nnk\nnC 0 2 .\nHowever, intersection exploiter is a binary operation, that is why we cannot count 0\nnC and 1 nC , therefore\n     \n n\nk\nn\nk\nnk\nnnn\nk\nnE nCCCCCq 0 2\n01 12 . ■\nSimilarly to [13, Th. 2] and Th. 2, we can formulate and\nprove the following theorem.\nTheorem 4. Set of classes of objects\n  1211 ,...,,,...,   nTTTTC nn\nof any OODN, extended according to Th. 3, with exploiter  create the meet-semilattice })0,{,(  ECMSL , where\nclass nMSL TTT  ...1 is its least lower bound, i.e. 0 .\nProof: According to definition of meet-semilattice given in\n[14], [15], it is a system })0,{,(  AMSL , where A is a poset,  is binary, idempotent, commutative and associative operation and 0 is unary operation, which are defined over the set A . In addition, Aa  , 0 satisfies\n  00:1 aL (identity law).\nAccording to the theorem, carrier of meet-semilattice is the set of classes C , set of exploiters E contains binary operation  and unary operation 0 , which are defined over the set C . Therefore, })0,{,(  ECMSL , where\n  1211 ,...,,,...,   nTTTTC nn .\nFrom the Def. 4 it follows, that all mentioned properties of  are also true for  , i.e.\n1. 111 TTT  ,\n2. 1221 TTTT  ,\n3.     321321 TTTTTT  ,\nwhere CTTT 321 ,, . From the definition of  it follows\nthat, MSLMSL TTT 1 , where nMSL TTT  ...1 .\nNow we need to prove that C is a poset. For this we\nshould define 1212121 |, TTTTTCTT  and show that  is a relation of partial order under the set C . Taking into account that we have two types of classes, we need to define three kinds of  relation, i.e.\n1. homogeneous  homogeneous,\n2. homogeneous  inhomogeneous,\n3. inhomogeneous  inhomogeneous.\nIt was done in Def. 2 and Def. 3. Now let us prove reflexivity, anti-symmetry and transitivity of these relations.\n1. Reflexivity: 11111 TTTTT  follows from\nidempotency of  ;\n2. Anti-symmetry: 12121 TTTTT  , and\n21212 TTTTT  and from commutativity of  , we can conclude that 21 TT  ;\n3. Transitivity:\n22112 TTTTT  ,  3223 TTTT\n     3213213 TTTTTTT\n13331331 TTTTTTTT  .\nTherefore,\n  }0,{,,...,,,..., 1211   ETTTTCMSL nnn\nis a meet-semilattice, where class nMSL TTT  ...1 is its least lower bound, i.e. 0 . ■\nUsing Th. 1 and Th. 3, let us formulate and prove the\nfollowing theorem.\nTheorem 5. For any ),,,,( MERCOOODN  , where\n  1211 ,...,,,...,   nTTTTC nn , },{ E , and nTT ,...,1 are homogeneous classes, which describe types of objects ntt ,...,1 and there is a type t , such that\n        ttttttt n |...1\n   ntttt  ...1 ,\nall possible applications of union and intersection exploiters, including all possible their superpositions, to classes of objects from the set C and obtaining classes of objects, using these exploiters respectively, always generate finite quantity of new classes of objects, which can be precisely calculated by the following formula:\n  )1(22 1   nCq nE ,\nwhere Cn  .\nProof: Proof of the theorem follows from proofs of Th. 1\nand Th. 3, i.e.\n     \n  n\nk\nn\nk\nnk\nnnn\nk\nnE nCCCCCq 0 2\n101 )1(2222 ,\nwhere Cn  . ■\nSimilarly to Th. 2 and Th. 4, we can formulate and prove\nthe following important theorem.\nTheorem 6. Set of classes of objects\n  )1(2221211 1 ,...,,,...,,,...,    nnn nnn TTTTTTC\nof any OODN, extended according to Th. 5, with exploiters  ,  create the complete lattice })0,1,,{,(  ECL ,\nwhere class nJSM TTT  ...1 is the greatest upper bound,\ni.e. 1 and class nMSL TTT  ...1 is its least lower bound, i.e. 0 .\nProof: According to definition of complete lattice given in\n[14], [15], it is a system })0,1,,{,(  AL , where A\nis a poset and  ,  , 1 and 0 satisfy, for all Acba ,, :\n  )()(:1 cbacbaL  (associative laws)\n)()( cbacba \n  abbaL :2 (commutative laws)\nabba \n  aaaL :3 (idempotency laws)\naaa \n  abaaL  )(:4 (absorption laws)\nabaa  )(\n  aaL 0:5 (identity laws)\naa 1\n00 a\n11a\nAccording to the theorem, carrier of the lattice is the set of classes C , set of exploiters E contains two binary operations  ,  and two unary operations 1 and 0 , which are defined over the set C . Therefore, })0,1,,{,(  ECL , where\n  )1(2221211 1 ,...,,,...,,,...,    nnn nnn TTTTTTC\nFacts that\n1. ),( C is a poset,\n2.  and  satisfy the laws    31 LL  ,\n3. nJSL TTT  ...1 is 1 of join-semilattice,\n4. nMSL TTT  ...1 is 0 of meet-semilattice,\nwere shown in the proves of Th. 2 and Th. 4.\nFrom the [13, Def. 14] and Def. 4 it follows, that 11 TTT MSL  , 11 TTT JSL  , MSLMSL TTT 1 , and\nJSLJSL TTT 1 , where CT 1 , nJSL TTT  ...1 , nMSL TTT  ...1 . Therefore, })0,1,,{,(  ECL is a complete lattice, where\n  )1(2221211 1 ,...,,,...,,,...,    nnn nnn TTTTTTC ,\nand nJSL TTT  ...1 is its greatest upper bound, i.e. 1 and\nnMSL TTT  ...1 is its least lower bound, i.e. 0 . ■\nIV. EXPLOITERS-BASED KNOWLEDGE EXTRACTION\nLet us consider classes of objects, which describe such types of convex polygons as square )(S , rhombus )(Rb ,\nparallelogram )(P , and rectangle )(Rt . Let us define for\nthem an OODN\n),,,,( MERCOQuadrangle .\nFor this purpose, we need to define set of classes of objects },,,{ RtPRbSC  and set of exploiters },{ E . Sets\nO and R will be undefined, because of the lack of information. In addition, we do not define the set of modifiers M , because it is not necessary within consideration of exploiters-based KE. Suppose classes from the set C have following structures\n),,4()(( 1 sidesSpS \n),4()(2 anglesSp \n),)),(((),)),(((()( 32313 cmSpvcmSpvSp \n)),)),(((),)),((( 3433 cmSpvcmSpv\n),90,90,90,90()(4 ooooSp\n,1)()( 55  SvfSp\n,1)()( 66  SvfSp\n,1)()( 77  SvfSp\n),,4))((()( 311 cmSpvSf \n ,,))(()( 22312 cmSpvSf \nwhere )(1 Sp – quantity of sides, )(2 Sp – quantity of angles, )(3 Sp – sizes of sides, )(4 Sp – measures of internal\nangles, )(5 Sp – verification function, which defines property «sum of internal angles is equal to o360 », i.e.\n}1,0{)(:)( 55 SpSvf ,\nwhere\n ))(())(())((()( 4342415 SpvSpvSpvSp\n)360))(( 44  Spv ,\n)(6 Sp – verification function, which defines property «all\nsides are equal», i.e. }1,0{)(:)( 66 SpSvf , where\n ))(())(())((()( 3332316 SpvSpvSpvSp\n)))(( 34 Spv ,\n)(7 Sp – verification function, which defines property «all angles are equal to o90 », i.e. }1,0{)(:)( 77 SpSvf , where\n ))(())(())((()( 4344417 SpvSpvSpvSp\n)90))(( 44  Spv ,\n)(1 Sf – method for perimeter computing, and )(2 Sf –\nmethod for area computing;\n),,4()(( 1 sidesRbpRb \n),,4()(2 anglesRbp \n),)),(((),)),(((()( 32313 cmRbpvcmRbpvRbp \n)),)),(((),)),((( 3433 cmRbpvcmRbpv\n),)),(((),)),(((()( 42414 oo RbpvRbpvRbp \n)),)),(((),)),((( 4443 oo RbpvRbpv\n,1)()( 55  RbvfRbp\n,1)()( 66  RbvfRbp\n),,4))((()( 311 cmRbpvRbf \n ,))),((sin())(()( 2412312 cmRbpvRbpvRbf \nwhere )(1 Rbp – quantity of sides, )(2 Rbp – quantity of angles, )(3 Rbp – sizes of sides, )(4 Rbp – measures of\ninternal angles, )(5 Rbp – verification function, which defines property «sum of internal angles is equal to o360 », i.e.\n}1,0{)(:)( 55 RbpRbvf ,\nwhere\n ))(())(())((()( 4342415 RbpvRbpvRbpvRbp\n)360))(( 44  Rbpv ,\n)(6 Rbp – verification function, which defines property «all\nsides are equal», i.e. }1,0{)(:)( 66 RbpRbvf , where\n ))(())(())((()( 3332316 RbpvRbpvRbpvRbp\n)))(( 34 Rbpv ,\n)(1 Rbf – method for perimeter computing, and )(2 Rbf –\nmethod for area computing;\n),,4()(( 1 sidesPpP \n),,4()(2 anglesPp \n),)),(((),)),(((()( 32313 cmPpvcmPpvPp \n)),)),(((),)),((( 3433 cmRpvcmRpv\n),)),(((),)),(((()( 42414 oo PpvPpvPp \n)),)),(((),)),((( 4443 oo PpvPpv\n,1)()( 55  PvfPp\n,1)()( 66  PvfPp\n,1)()( 77  PvfPp\n),))),(())(((2()( 32311 cmPpvPpvPf \n ))(())((()( 32312 PpvPpvPf\n,))),((sin( 241 cmPpv\nwhere )(1 Pp – quantity of sides, )(2 Pp – quantity of angles, )(3 Pp – sizes of sides, )(4 Pp – measures of internal\nangles, )(5 Pp – verification function, which defines property «sum of internal angles is equal to o360 », i.e.\n}1,0{)(:)( 55 PpPvf ,\nwhere\n ))(())(())((()( 4342415 PpvPpvPpvPp\n)360))(( 44  Ppv ,\n)(6 Pp – verification function, which defines property\n«opposite sides are parallel», i.e. }1,0{)(:)( 66 PpPvf , where\n ))((()))(())((()( 4243416 PpvPpvPpvPp\n)))(( 44 Ppv ,\n)(7 Pp – verification function, which defines property\n«opposite sides are equal», i.e. }1,0{)(:)( 77 PpPvf , where\n ))((()))(())((()( 3233317 PpvPpvPpvPp\n)))(( 34 Ppv ,\n)(1 Pf – method for perimeter computing, and )(2 Pf –\nmethod for area computing;\n),,4()(( 1 sidesRtpRt \n),,4()(2 anglesRtp \n),)),(((),)),(((()( 32313 cmRtpvcmRtpvRtp \n)),)),(((),)),((( 3333 cmRtpvcmRtpv\n)),,90(),,90(),,90(),,90(()(4 ooooRtp\n,1)()( 55  RtvfRtp\n,1)()( 66  RtvfRtp\n)),))),(())(((2()( 32311 cmRtpvRtpvRtf \n ,)),(())(()( 232312 cmRtpvRtpvRtf \nwhere )(1 Rtp – quantity of sides, )(2 Rtp – quantity of angles, )(3 Rtp – sizes of sides, )(4 Rtp – measures of internal angles, )(5 Rtp – verification function, which defines property «sum of internal angles is equal to o360 », i.e.\n}1,0{)(:)( 55 RtpRtvf ,\nwhere\n ))(())(())((()( 4342415 RtpvRtpvRtpvRtp\n)360))(( 44  Rtpv ,\n)(6 Rtp – verification function, which defines property\n«opposite sides are equal», i.e. }1,0{)(:)( 66 RtpRtvf , where\n ))((()))(())((()( 3233316 RtpvRtpvRtpvRtp\n)))(( 34 Rtpv ,\n)(1 Rtf – method for perimeter computing, and )(2 Rtf –\nmethod for area computing.\nWe have defined OODN for early mentioned types of convex polygons. It is clear, that all elements of the set C represent basic knowledge. Let us apply union and intersection exploiters to them and obtain all possible new classes of objects. According to [13, Def. 14],\n  )(),(, 21 RbprSprSRbCoreSRbRbS   ,\nwhere\n        ,,, 321   SRbpSRbpSRbpSRbCore\n    SRbfSRbp 14 , ,\nwhere  SRbp1 – quantity of sides,  SRbp2 – quantity of angles,  SRbp3 – verification function, which defines property «sum of internal angles is equal to o360 », i.e.\n    }1,0{: 33  SRbpSRbvf ,\nwhere\n   ))(())(())((( 4342413 iii tpvtpvtpvSRbp\n)360))(( 44  itpv , },{ RbSi  ,\n SRbp4 – verification function, which defines property «all sides are equal», i.e.     }1,0{: 44  SRbpSRbvf , where\n   ))(())(())((( 3332314 iii tpvtpvtpvSRbp\n)))(( 34 itpv , },{ RbSi  ,\n SRbf1 – method for perimeter computing, which is defined as follows   ))),((4( 311 cmtpvSRbf i , where },{ RbSi  .\nProjections )(1 Spr and )(2 Rbpr have the following\nstructure\n))(),(),(),(()( 27651 SfSpSpSpSpr  ,\n))(),(),(()( 2652 RbfRbpRbpRbpr  ,\nwhere )(5 Sp – sizes of sides, )(6 Sp – measures of internal\nangles, )(7 Sp – verification function, which defines property «all angles are equal to o90 », )(2 Sf – method for area computing, )(5 Rbp – sizes of sides, )(6 Rbp – measures of\ninternal angles, )(2 Rbf – method for area computing.\nStructure of the  SRbCore follows from the following equalities\n)()( 11 RbpSp  , )()( 22 RbpSp  , )()( 55 RbpSp  ,\n)()( 66 RbpSp  , )()( 11 RbfSf  .\nIndeed, according to [13, Def 4], )()( 11 RbpSp  and\n)()( 22 RbpSp  , i.e.\n )))(()),((()))(()),((( 11111111 RbpuRbpvSpuSpv\n),4( sides ,\n )))(()),((()))(()),((( 21212121 RbpuRbpvSpuSpv\n),4( angles .\nForm the [13, Def. 5] it follows that )()( 55 RbpSp  and\n)()( 66 RbpSp  , i.e.\n   )()()()( 5555 RbvfRbvfSvfSvf RbSRbS  , that can be computed in the following way\n ))(())(())(()( 4342415 SpvSpvSpvSvf S\n360))(( 44  Spv ,\n ))(())(())(()( 4342415 SpvSpvSpvSvf Rb\n360))(( 44  Spv ,\n ))(())(())(()( 4342415 RbpvRbpvRbpvRbvf S\n360))(( 44  Rbpv ,\n ))(())(())(()( 4342415 RbpvRbpvRbpvRbvf Rb\n360))(( 44  Rbpv ;\n   )()()()( 6666 RbvfRbvfSvfSvf RbSRbS \n ))(())(())((()( 3332316 SpvSpvSpvSvf S\n)))(( 34 Spv ,\n ))(())(())((()( 3332316 SpvSpvSpvSvf Rb\n)))(( 34 Spv ,\n ))(())(())((()( 3332316 RbpvRbpvRbpvRbvf S\n)))(( 34 Rbpv ,\n ))(())(())((()( 3332316 RbpvRbpvRbpvRbvf Rb\n)))(( 34 Rbpv .\nAs the result, in both cases we have )11()11(  , i.e."
    }, {
      "heading" : "111  .",
      "text" : "From the [13, Def. 7] it follows that )()( 11 RbfSf  , i.e.\n   )()()()( 1111 RbfRbfSfSf RbSRbS  , that can be calculated in the following way\n),4))((()( 311 cmSpvSf S  ,\n),4))((()( 311 cmSpvSf Rb  ,\n),4))((()( 311 cmRbpvRbf S  ,\n),4))((()( 311 cmRbpvRbf Rb  ,\nas the result we have\n  ),4))(((),4))((( 3131 cmSpvcmSpv\n ),4))(((),4))((( 3131 cmRbpvcmRbpv  ,\ni.e. 111  .\nAccording to [13, Def. 14], the class of objects SRb is the result of application of union exploiter to classes of objects S and Rb . From the Def. 4, we can conclude, that the result of application of intersection exploiter to these classes is equal to the core of their union, i.e.\n   SRbCoreSRbRbS .\nIn the result of all possible applications of union and intersection exploiters we obtained such 6 classes, that each class describes 2 different types of objects SRb , SP ,\nSRt , RbP , RbRt , PRt such 4 classes, that each\nclass describes 3 different types of objects SRbP ,\nSRbRt , SPRt , RbPRt and 1 class, that describes 4\ndifferent types of objects SRbPRt . In addition, we obtained such 6 classes, that each class describes intersection of 2\ndifferent types of objects SRb , SP , SRt , RbP ,\nRbRt , PRt , such 4 classes, that each class describes\nintersection of 3 different types of objects SRbP , SRbRt ,\nSPRt , RbPRt , and 1 class, that describes intersection f 4 different types of objects SRbPRt .\nUsing exploiters  and  , we have extended the set C by adding 22 new classes of objects, i.e.\n ,,...,,,...,,,,,  RbPRtSRbPPRtSRbRtPRbSC\n,,...,,..,,...,,  RbPRtSRbPPRtSRbSRbPRt\nSRbPRt .\nAccording to Th. 6, the set C together with exploiters  and  create the complete lattice })0,1,,{,(  ECL ,\nwhere SRbPRt is its greatest upper bound, i.e. 1 and SRbPRt is its least lower bound, i.e. 0 . This lattice can be graphically represented as it is shown on Fig. 1.\nIn addition, we define the set of relations R , by adding 96 new relations, namely 56 relations for classes RtS ,..., , 32\nfor classes  PRtSRb ,..., and  PRtSRb ,..., , 8 for classes  RbPRtSRbP ,..., and  RbPRtSRbP ,..., .\nAnalyzing Fig. 1, we can see that obtained lattice defines hierarchy of classes with determined subsumption relation  . It allows performing of subsumption reasoning for information classifying and retrieving. Moreover, obtained hierarchy is protected from ambiguity problem, because all classes, except basic ones, are inhomogeneous.\nJoin-semilattice of the lattice L contains inhomogeneous classes of objects, which define all possible sets of objects of different types, which can be obtained from the basic classes of objects S , Rb , P and Rt . Meet-semilattice of the lattice L contains inhomogeneous classes of objects, which define common subtypes for basic classes.\nThe greatest upper bound SRbPRt of the lattice L\ngives an opportunity to represent and to store the knowledge in the database in more efficient way by storing only one class SRbPRt instead of four basic classes of objects. Moreover,\nsuch storing requires less memory resources then storing of S ,\nRb , P and Rt , because instead of storing of 26 properties\nand 8 methods, it is possible to store only 17 properties and 5 methods.\nWe can conclude that during KE using universal exploiters we have obtained 22 new classes of objects, 96 new relations among them, defined hierarchy of classes with determined subsumption relation  . Using obtained knowledge it is possible to restore basic knowledge in database more efficiently and perform subsumption reasoning within the constructed hierarchy of classes.\nV. CONCLUSIONS AND OUTLOOK\nInvention of KE techniques is very crucial for future development of KRFs and area of KR in general. In this paper the main attention was paid to consideration and extension of KE method within such object-oriented KRF as object-oriented dynamic networks. The main idea of proposed approach is usage of universal exploiters, which allow generation of new classes of objects and relations among them.\nThe main achievement of the paper is proof of useful features of union and intersection exploiters, which allow extending set of basic classes and create complete lattice. Proposed approach has the following features:\n ability to calculate before the generation:\no quantity of new classes, which can be generated, using proposed approach,\no quantity of different types, which each of obtained classes describes;\n extension of the sets of basic classes and relations by adding new classes of objects and relations among\nthem;\n construction of defined hierarchy of classes with\ndetermined subsumption relation  , which allows performing of subsumption reasoning for information classifying and retrieving;\n more efficient restoring of basic knowledge within the database;\n avoidance of inheritance problems, in particular ambiguity problem in the case of multiple inheritance.\nHowever, despite all noted advantages, proposed approach\nrequires further research, at least in the following directions:\n using of useful properties of complete lattices;\n adaptation to different kinds of knowledge sources;\n extension to the case of fuzzy knowledge;\n adaptation and usage in other known object-oriented knowledge representation formalisms."
    } ],
    "references" : [ {
      "title" : "The mathematics of inheritance systems",
      "author" : [ "D.S. Touretzky" ],
      "venue" : "Los Altos, CA, USA: Morgan Kaufmann Publishers",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "Inheritance theory: an artificial intelligence approach",
      "author" : [ "R. Al-Asady" ],
      "venue" : "Norwood, NJ, USA: Ablex Publishing Corporation",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Inheritance in object-oriented knowledge representation,",
      "author" : [ "D. Terletskyi" ],
      "venue" : "Inform. and Software Techn., Commun. in Comput. and Inform. Sci.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2015
    }, {
      "title" : "Report on knowledge extraction from structured sources,",
      "author" : [ "S. Hellmann", "J. Unbehauen" ],
      "venue" : "Technical Report LOD2",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2011
    }, {
      "title" : "S",
      "author" : [ "J. Unbehauen", "S. Hellmann" ],
      "venue" : "Auer and C. Stadler, “Knowledge extraction from structured sources,” in Search Computing: Broadening Web Search, Lecture Notes in Comput. Sci., vol. 7538, S. Ceri and M. Brambilla Eds. Berlin, Germany: Springer",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Extracting knowledge for cultural heritage knowledge base population,",
      "author" : [ "N. Takhirov" ],
      "venue" : "Ph.D. dissertation, Dept. Comput. and Inform. Sci., Norwegian Univ. of Sci. and Technol., Trondheim, Norway,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2013
    }, {
      "title" : "Ontology-based knowledge discovery from unstructured and semi-structured text,",
      "author" : [ "J. Polpinij" ],
      "venue" : "Ph.D. dissertation, School of Comput. Sci. and Software Eng., Univ. of Wollongong,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2014
    }, {
      "title" : "Fuzzy knowledge management for the semantic web",
      "author" : [ "Z. Ma", "F. Zhang", "L. Yan", "J. Cheng" ],
      "venue" : "Berlin, Germany: Springer",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Fuzzy XML data management",
      "author" : [ "L. Yan", "Z. Ma", "F. Zhang" ],
      "venue" : "Berlin, Germany: Springer",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Object-oriented dynamic networks,",
      "author" : [ "D. Terletskyi", "A. Provotar" ],
      "venue" : "Computational Models for Bus. and Eng. Domains, Int. Book Series Inform. Sci. & Computing,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2014
    }, {
      "title" : "Provotar, “Fuzzy object-oriented dynamic networks. I,",
      "author" : [ "A.I.D.A. Terletskyi" ],
      "venue" : "Cybern. and Syst. Anal.,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2015
    }, {
      "title" : "Provotar, “Fuzzy object-oriented dynamic networks. II,",
      "author" : [ "A.I.D.A. Terletskyi" ],
      "venue" : "Cybern. and Syst. Anal.,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2016
    }, {
      "title" : "Exploiters-based knowledge extraction in objectoriented knowledge representation,",
      "author" : [ "D. Terletskyi" ],
      "venue" : "Proc. 24th Int. Workshop Concurrency, Specification & Programming, Rzeszow,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2015
    }, {
      "title" : "Lattice theory",
      "author" : [ "G. Birkhoff" ],
      "venue" : "3rd revised ed. New York, NY, USA: American Mathematical Society Colloquium Publications",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1967
    }, {
      "title" : "Introduction to lattices and order",
      "author" : [ "B.A. Davey", "H.A. Priestley" ],
      "venue" : "2nd ed. New York, NY, USA: Cambridge University Press",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2002
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "However, as it was shown in [1]–[3], inheritance mechanism causes problem of exceptions, redundancy and ambiguity, which usually arise during construction of hierarchies and reasoning over them.",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 2,
      "context" : "However, as it was shown in [1]–[3], inheritance mechanism causes problem of exceptions, redundancy and ambiguity, which usually arise during construction of hierarchies and reasoning over them.",
      "startOffset" : 32,
      "endOffset" : 35
    }, {
      "referenceID" : 3,
      "context" : "KNOWLEDGE EXTRACTION According to [4]–[7], knowledge extraction is defined as creation or acquiring of knowledge from structured (e.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 6,
      "context" : "KNOWLEDGE EXTRACTION According to [4]–[7], knowledge extraction is defined as creation or acquiring of knowledge from structured (e.",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 7,
      "context" : "relational databases, object-oriented database models, UML, XML and their fuzzy extensions, proposed in [8], [9]), semistructured (e.",
      "startOffset" : 104,
      "endOffset" : 107
    }, {
      "referenceID" : 8,
      "context" : "relational databases, object-oriented database models, UML, XML and their fuzzy extensions, proposed in [8], [9]), semistructured (e.",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 5,
      "context" : "According to [6], there are two main paradigms of KE: ontology-based and open domain.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 3,
      "context" : "in [4], [5] argued about absence of clear definition of what extracted knowledge is and paid attention to the fact, that mere usage such KRFs as RDF/OWL can not sufficiently define the notion of «knowledge».",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 4,
      "context" : "in [4], [5] argued about absence of clear definition of what extracted knowledge is and paid attention to the fact, that mere usage such KRFs as RDF/OWL can not sufficiently define the notion of «knowledge».",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 9,
      "context" : "One of attempts to solve earlier mentioned problems is such KRF as object-oriented dynamic networks (OODN), which was proposed in [10].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 2,
      "context" : "In addition, as it was demonstrated in [3], OODN allow constructing of polyhierarchies and avoiding, in many cases, problems of inheritance, which were mentioned above.",
      "startOffset" : 39,
      "endOffset" : 42
    }, {
      "referenceID" : 10,
      "context" : "Moreover, OODN have fuzzy extension, proposed in [11], [12], which provides representation of vague and imprecise knowledge, using the same structure as for the crisp case.",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 11,
      "context" : "Moreover, OODN have fuzzy extension, proposed in [11], [12], which provides representation of vague and imprecise knowledge, using the same structure as for the crisp case.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 12,
      "context" : "Furthermore, according to [13], the set of basic classes of any OODN, extended by extracted classes, together with union exploiter, create upper semilattice.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 11,
      "context" : "UNIVERSAL EXPLOITERS AND KNOWLEDGE EXTRACTION As it was shown in [12], some universal exploiters can be efficiently used for KE.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 12,
      "context" : "As it was mentioned in [13], inhomogeneous class of objects describes at least two different types of objects within one class, where type is defined as follows.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 12,
      "context" : "The notion of subclass for inhomogeneous classes was introduced in [13], nevertheless it is restricted and does not take into account some cases, when classes of objects have common properties and methods.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 12,
      "context" : "12], 123 13 T T  and 123 12 T T  , therefore all results, which were presented in [13] are correct.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 12,
      "context" : "That is why, let us extend the notion of subclass given in [13], using Def.",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 13,
      "context" : "Proof: According to the definition of join-semilattice given in [14], [15], it is a system }) 1 , { , (     A JSL , where A is a poset,  is a binary, idempotent, commutative and associative operation and 1 is an unary operation, which are defined over the set A .",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 14,
      "context" : "Proof: According to the definition of join-semilattice given in [14], [15], it is a system }) 1 , { , (     A JSL , where A is a poset,  is a binary, idempotent, commutative and associative operation and 1 is an unary operation, which are defined over the set A .",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 13,
      "context" : "Proof: According to definition of meet-semilattice given in [14], [15], it is a system }) 0 , { , (     A MSL , where A is a poset,  is binary, idempotent, commutative and associative operation and 0 is unary operation, which are defined over the set A .",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 14,
      "context" : "Proof: According to definition of meet-semilattice given in [14], [15], it is a system }) 0 , { , (     A MSL , where A is a poset,  is binary, idempotent, commutative and associative operation and 0 is unary operation, which are defined over the set A .",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 13,
      "context" : "Proof: According to definition of complete lattice given in [14], [15], it is a system }) 0 , 1 , , { , (      A L , where A is a poset and  ,  , 1 and 0 satisfy, for all A c b a  , , :",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 14,
      "context" : "Proof: According to definition of complete lattice given in [14], [15], it is a system }) 0 , 1 , , { , (      A L , where A is a poset and  ,  , 1 and 0 satisfy, for all A c b a  , , :",
      "startOffset" : 66,
      "endOffset" : 70
    } ],
    "year" : 2017,
    "abstractText" : "This paper contains analysis and extension of exploiters-based knowledge extraction methods, which allow generation of new knowledge, based on the basic ones. The main achievement of the paper is useful features of some universal exploiters proof, which allow extending set of basic classes and set of basic relations by finite set of new classes of objects and relations among them, which allow creating of complete lattice. Proposed approach gives an opportunity to compute quantity of new classes, which can be generated using it, and quantity of different types, which each of obtained classes describes; constructing of defined hierarchy of classes with determined subsumption relation; avoidance of some problems of inheritance and more efficient restoring of basic knowledge within the database.",
    "creator" : "Microsoft® Word 2016"
  }
}