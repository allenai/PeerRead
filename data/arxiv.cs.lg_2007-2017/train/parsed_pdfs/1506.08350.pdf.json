{
  "name" : "1506.08350.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Stochastic Gradient Made Stable: A Manifold Propagation Approach for Large-Scale Optimization",
    "authors" : [ "Yadong Mu", "Wei Liu", "Wei Fan" ],
    "emails" : [ "myd@research.att.com", "weiliu@us.ibm.com", "fanwei03@baidu.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Index Terms—Large-scale optimization, semi-stochastic gradient descent, manifold propagation.\nF"
    }, {
      "heading" : "1 INTRODUCTION",
      "text" : "Regularized risk minimization [20] is a fundamental subject in machine learning and statistics, whose formulations typically admit a combination of a loss function and a regularization term. This paper addresses a general class of convex regularized risk minimization problems which can be expressed as a composition:\nw∗ = arg min w {F (w) := P (w>x) +R(w)}, (1)\nin which w,x denote the parameters and data vector respectively. Both P (w>x) and R(w) are assumed to be convex functions. Moreover, let P (w>x) be a weighted addition of many atomic loss functions, each of which is differentiable. We simply define each atomic function on an input data pair (xi, yi), where xi ∈ Rd represents a feature vector and yi denotes its associated label. Popular choices of the loss functions include the square loss (w>xi − yi)2, the logistic loss log(1 + exp(−yiw>xi)), and the hinge loss |1−yiw>xi|+. In the above cases yi ∈ {±1}, yet in others yi can be real-valued in regression problems or missing in an unsupervised learning setting. R(w) defines a proper regularization function. It imposes some structural preference\n• Yadong Mu is a senior scientist of AT&T Labs Research, Middletown, NJ 07748. E-mail: myd@research.att.com • Wei Liu is a Research Staff Member of IBM T. J. Watson Research Center, Yorktown Heights, NY 10598. E-mail: weiliu@us.ibm.com • Wei Fan is Director and Deputy Head of Baidu Big Data Research Lab, Sunny Vale, CA. E-mail: fanwei03@baidu.com\non the parameters (e.g., structured sparsity or matrix lowrankness). R(w) can be non-smooth with respect to w, such as the sparsity-encouraging 1-norm ‖w‖1.\nWhen facing a large volume of training data, the space and time complexities become the critical limiting factor in building a machine learning model. In such scenarios, stochastic (sub)gradient descent (SGD) [2], [6], [9], [13], [15], [18], [24] is a favored method used by many theorist and practitioners. The most attractive trait of SGD is the lightweight computation at each iteration of updates. Its singlesample or mini-batch [5], [18] updating scheme is a general remedy for the O(n) complexity in exact gradient descent (GD) methods (n represents the number of training samples). Therefore, SGD algorithms are particularly promising whenever there is a limited budget of resources. Given properly-specified step size parameters at each iteration, SGD algorithms often enjoy provably rates of convergence.\nThe major downside of SGD in practical implementations is caused by large gradient variance. Statistically, the mathematical expectation of stochastic gradient is exactly the full gradient. However, the randomness in constructing mini-batch brings large variance to stochastic gradients, particularly for complex data set. In other words, moving along the direction of stochastic gradient does not always guarantee a decrease of the entire training loss. Under large gradient variance, the estimated parameters often drastically bounce around the global optimal solution.\nRecent years have witnessed the emerging efforts of developing sophisticated algorithms which reduce the gradient variance in SGD. The shared idea underlying these works is incorporating an additional gradient-correcting\nar X\niv :1\n50 6.\n08 35\n0v 1\n[ cs\n.L G\n] 2\n8 Ju\nn 20\n15\n2 stochastic gradient\nexact gradient\nStochastic gradient after correction (i.e., semi-stochastic gradient)\nResidual between stochastic and exact gradients Approximate estimation of above residual\nResidual between stochastic and exact gradients\nApproximate estimation of above residual\nFig. 1. Illustration of residual-minimizing gradient correction. Stochastic gradient calculated from a single random sample often significantly deviates from the exact gradient. A simple solution is to compensate the stochastic gradient with the residual between the noisy stochastic gradient and full gradient (plotted as red dotted arrow in this figure). Exact residual is computationally expensive. Instead, semi-stochastic gradient descent approximately estimates the residue (plotted as blue dotted arrow in this figure), and amends the stochastic gradient accordingly. Best viewing in color mode.\noperation when computing the stochastic gradient. The corrected stochastic gradient becomes a more accurate approximation of the full gradient. Statistically, it enjoys a reduced level of variance. For example, the work in [28] explicitly expresses the gradient variance and proves that constructing mini-batch using special non-uniform sampling strategy is able to reduce the gradient variance. The sampling probability is essentially based on the contextual importance of a sample. Another method named stochastic average gradient (SAG) [17] keeps a record of historic stochastic gradients and adaptively averages them for the use in the current iteration. The rate of convergence is thereby improved to O(1/k) for general convex functions, andO(pk) with p < 1 for strongly convex functions, respectively (k is the count of iterations). However, storing historic gradients in SAG entails a heavy burden for machine learning models with many parameters.\nThis paper advocates an efficient manifold propagation approach for reducing stochastic gradient variance in largescale machine learning. It aims to improve the stability of the stochastic gradient, such that large descending step sizes can be used for faster convergence. We adopt the computational framework of residual-minimizing gradient correction which was originally proposed in stochastic variance-reduced gradient (SVRG) [10] by Johnson and Zhang. The computational framework is comprised of two steps: 1) estimate the residual between a stochastic gradient and the full gradient using global information, and 2) compensate the stochastic gradient such that the residual is minimized towards 0.\nSince the optimization proceeds in rounds, we can thus describe it with an update rule. Assume wk is the latest estimation for the problem minw F (w) at the k-th iteration, standard SGD and full (sub)gradient descend (GD) will seek for a new estimation wk+1 according to1\n(SGD) : wk+1 = wk − ηk∇Fi(wk), (2) (GD) : wk+1 = wk − ηk∇F (wk), (3)\n1. When F (w) is non-smooth, sub-differential (rather than gradient) will be used. However, we here abuse the notation ∇ for statement conciseness.\nwhere ηk is a delicately-chosen step-size parameter. For notational simplicity, we here assume that each mini-batch only contains a single random sample. The term Fi(wk) in SGD denotes the atomic function conditioned on a random sample xi and the latest parameters wk. F (wk) is computed using all training set.\nIn contrast, semi-stochastic gradient is obtained by the rule below:\nwk+1 = wk − ηk ( ∇Fi(wk)− (∇Fi(w̃)−∇F (w̃)) ) ︸ ︷︷ ︸\nsemi−stochastic gradient\n, (4)\nwhere w̃ represents some historic memory of recent parameter estimation. w̃ is supposed to be proximal to wk. The term ∇Fi(w̃)−∇F (w̃) approximately estimates the residual between the stochastic gradient of sample xi and full gradient. By subtracting the residual term from ∇Fi(wk), it naturally aligns the stochastic gradient with the full gradient. As an extreme case, letting w̃ = wk will immediately get the full gradient in (4). The idea is intuitively explained in Figure 1.\nTheoretic analysis in [10], [11], [22] reveals that semistochastic algorithms achieve a geometric rate of convergence. Though such a convergence rate is generally regarded as the synonym of satisfactory efficiency, it is important to emphasize that this rate is achieved at the cost of higher iteration complexity compared to standard SGD. In our experiments, we are surprised to find that SGD still dominates in many cases, since its light-weight iteration cost compensates its slow theoretic convergence rate. In other words, the promising geometric convergence rate of existing semi-stochastic algorithms is probably Pyrrhic victories at excessive costs of maintaining high-accuracy estimation of gradient residual.\nWe find that a comprehensive quantitative comparison between semi-stochastic algorithms and SGD is still missing in the literature. In fact, most existing semi-stochastic algorithms either rely on periodic full gradient computation [10] or use Hessian-like covariance matrix operations [21], which account for their high iteration complexities. In this paper we expose a novel way of efficiently computing semistochastic gradient and evaluate it on a variety of massive data sets. We term the new method as stratified semi-stochastic gradient descent (S3GD) hereafter. Our major contributions are described below:\n• As a crucial component of the proposed S3GD, we devise an efficient manifold propagation approach for computing semi-stochastic gradient. First, a fixed number of anchors are drawn in a stratified manner. After that, each sample in the training set is connected to its adjacent anchors, forming a graphdefined manifold. At each iteration, the gradient information computed on the anchors diffuses over the manifold, obtaining an approximate estimation of the full gradient. The idea empirically proves to be a strong competitor to the existing expensive, albeit accurate, gradient-correcting operations such as SVRG. • We provide theoretic analysis about S3GD. Under standard assumptions imposed on the objective functions (i.e., strong convexity and Lipschitz continuity) and with a constant step size, S3GD achieves a\n3 geometric convergence rate (in terms of parameter optimality and iterates) up to a constant which is essentially determined by the Laplacian matrix of manifold-induced graph.\n• Last but not least, we conduct quantitative investigation over 9 different benchmarks, covering a large spectrum of real-world problems. The experimental evaluations fully validate the efficiency and effectiveness that S3GD brings. Moreover, the comparisons between various semi-stochastic algorithms and classic SGD is so far the most comprehensive and supposed to be very useful for re-calibrate the research direction of semi-stochastic algorithms.\nThe remainder of this paper is organized as follows: We start in Section 2 by describing preliminary knowledge and algorithmic details of S3GD. Specifically, Section 2.4 is devoted to applying the generic idea of S3GD to several representative machine learning problems. We then give the theoretic analysis in Section 3, where the major observation is found in Theorem 3.1. In Section 4 we present the quantitative investigation of S3GD on several largescale benchmark datasets widely used in machine learning and statistics. Finally, in Section 5 we draw the concluding remarks and discuss the future perspective."
    }, {
      "heading" : "2 THE PROPOSED ALGORITHM",
      "text" : ""
    }, {
      "heading" : "2.1 Notations and Assumptions",
      "text" : "Notations: We will denote vectors and matrices by boldface letters. Let ‖x‖2, ‖x‖1 be the Euclidean norm and 1- norm (summation of all absolute elements) of a vector respectively. Denote the training data set as X = {(xi, yi)}, which has a cardinality of n and i therein represents the index. Each sample is described by a tuple (xi, yi), where the feature vector xi ∈ Rd and yi corresponds to either labels in supervised learning or response values in regression problems. The smooth part in Problem (1) is premised in an additive form, namely P (w) = (1/n) ∑n i=1 ψ(xi, yi,w)\n2. The regularization term R(w) is convex yet not mandatorily differentiable. Whenever not incurring confusion, we use the notation ψi(w) for simplifying ψ(xi, yi,w). |x|+ = max(x, 0) is the zero-thresholding operation.\nOur theoretic observations are based on the following assumptions, similar to previous semi-stochastic gradient descent methods [22], [27]:\nAssumption 2.1. (strong convexity): We say that a function f : Rd 7→ R is strongly convex, if there exists µ > 0 such that for all u,v ∈ Rd,\nf(u) ≥ f(v) + ξ>(u− v) + µ2 ‖u− v‖ 2, ∀ξ ∈ ∂f(v), (5)\nwhere ∂f(v) is the sub-differential (set of sub-gradients) at point v. The convexity parameter is defined to be the largest µ that satisfies the above condition. Let P (w), R(w) and their composition F (w) have non-negative convexity parameters µP ,\n2. P (w>x) and P (w) will be interchangeably used in this paper. P (w>x) will be used when we highlight the interplay between w and x. Likewise ψi(w) and ψ(w>xi) are also equivalently used.\nAlgorithm 1 The S3GD Algorithm 1: Parameters: maximal number of inner iterations kin, the\nnumber of samples in a mini-batch p and the step-size parameter η; 2: Output: optimal parameter w∗; 3: Initialize w = 0; 4: while not converged do 5: w̃ = w; 6: w0 = w; 7: Calculate the approximate full gradient H(w̃) over the manifold according to Eqn. (23); 8: for k = 1 to kin do 9: Construct a mini-batch by random sampling. Denote\nthe index set as I = {k1, . . . , kp}. Let xk1 , . . . ,xkp be the corresponding feature vectors;\n10: Calculate the stochastic gradient for the mini-batch, obtaining ∇PI(wk−1) = (1/p) ∑p i=1∇ψki(xki ;w\nk−1); 11: Calculate approximate stochastic gradient for the mini-\nbatch on the manifold by Eqn. (20), obtaining hI(w̃) = (1/p) ∑p i=1 hki(w̃);\n12: Calculate the semi-stochastic gradient g(wk) according to Eqn. (9); 13: Solve the following proximal sub-problem to obtain wk:\nwk = argmin w ‖w − (wk−1 − η · g(wk))‖22 +R(w). (8)\n14: end for 15: w = wkin ; 16: end while 17: w∗ = w;\nµR and µ respectively. It is easily verified that µ ≥ µp + µR by definition of strong convexity and function composition.\nAssumption 2.2. (smoothness): A function f : Rd 7→ R is L-smooth if it is differential and there exists L > 0 such that it satisfies\nf(u) ≤ f(v) +∇f(u)(u− v) + L2 ‖u− v‖ 2, (6)\nfor all u,v ∈ Rd. Or equivalently, its gradient is L-Lipschitz continuous, namely we have\n‖∇f(u)−∇f(v)‖ ≤ L‖u− v‖. (7)\nLet the Lipschitz parameter for each atomic function ψi(w) be"
    }, {
      "heading" : "Li respectively. The Lipschitz parameter for their composition",
      "text" : "P (w) is LP ≤ (1/n) ∑n i=1 Li. The regularization term R(w) is mostly assumed to be non-differentiable and thus has no Lipschitz parameter."
    }, {
      "heading" : "2.2 Algorithmic Framework",
      "text" : "The composite optimization problem in (1) is of broad interests in machine learning and data mining fields. Nonetheless, solving it at optimal convergence speed is non-trivial. If we simply treat F (w) as a black-box oracle which only returns the first-order (sub)gradient, there are several off-theshelf tools, including SGD and full (sub)gradient descent. Since full (sub)gradient estimation is extremely expensive when huge volume of data is available, recent work has focused on stochastic optimization.\nSVRG [10], as introduced in preceding section, obeys the update rule in (4). Procedurally, it utilizes two nested loops. At each iteration of the outer loop, it memorizes a recent\n4 estimation w̃ and calculates the full gradient ∇F (w̃) at w̃. In the inner loops, it calculates ∇Fi(wk) and ∇Fi(w̃) for mini-batches, and afterwards amends the stochastic gradient ∇Fi(wk) by the rule in (4). Note that the same w̃ is used for all update within an outer loop. The SVRG method, though simple, profoundly reduces the amortized time complexity at iterations and theoretically achieves geometric convergence rate for strongly-convex smooth functions.\nAnother semi-stochastic algorithm, stochastic control variate (SCV) [21], represents a general approach of using control variate for variance reduction in stochastic gradient. The update rule of SCV is similar to (4) yet the last two (sub)gradients in (4) are replaced by control variate. Data statistics such as low-order moments (vector mean and covariance matrix) is used to form the control variate. The authors apply SCV to solve logistic regression and latent Dirichlet allocation.\nHowever, existing semi-stochastic methods like SVRG and SCV are not guaranteed to beat standard SGD in practice, since computing ∇F (w̃) in SVRG or control variate in SCV significantly increases the iteration complexity. To overcome the key limitations that dramatically restrict their capability in large scale data analysis, we propose S3GD. Algorithm 1 sketches the pseudo-code of S3GD.\nBefore diving into algorithmic details, we want to highlight two defining traits of S3GD:\nManifold-oriented gradient approximation: Given the composite function F (w), S3GD only computes the gradient on the smooth part P (w). For accelerating the computation of semi-stochastic gradient in (4), we argue that the key is to find a function H(w), whose design principals are:\n1) H(w) is a good surrogate to∇P (w), namely H(w) ≈ ∇P (w);\n2) H(w) can be efficiently computed; 3) H(w) is additive, namely H(w) = ∑n i=1 hi(w), where hi(w) ≈ ∇ψi(w) approximates the gradient of an atomic function defined on xi.\nWe defer the construction of function H(w) in Section 2.3, focusing on the algorithmic pipeline here. At specific iteration, denote the index set of a random minibatch as I . Conditioned on current parameter estimation wk, the semi-stochastic gradient in S3GD is computed by the following formula:\ngI(w k) = ∇ψI(wk)− [ hI(w k)−H(wk) ] , (9)\nwhere hI(wk) = ∑ i∈I hi(w\nk)/|I| is the averaged approximate stochastic gradient over index set I .\ngI(w k) actually provides an unbiased estimate of ∇P (wk) when I is uniformly drawn from the index set [1, . . . , n] with replacement. Its soundness is naturally fulfilled by the additive construction of function H . Consequently, the variance of gI(wk) becomes\nV ar [ gI(w k) ] = E ∥∥∥∇ψI(wk)− hI(wk)∥∥∥2 − ( E ∥∥∥∇P (wk)−H(wk)∥∥∥)2\n≤ E ∥∥∥∇ψI(wk)− hI(wk)∥∥∥2 (10)\nIn comparison, the variance of noisy gradient (referred to as g̃I(wk) for notational clarity) in standard SGD is\nV ar [ g̃I(w k) ] = E ∥∥∥∇ψI(wk)−∇P (wk)∥∥∥2 . (11)\nIntuitively, the relative comparison of V ar[gI(wk)] and V ar[g̃I(w\nk)] essentially hinges on which of hI(wk) or ∇P (wk) is more close to ∇ψI(wk). As shown later, we tailor hI(wk) to be a local approximation to ∇ψI(wk), which is supposedly superior to the global average ∇P (wk), particularly when the input data set is with rich variety.\nProximity-regularized linear approximation: After the semi-stochastic gradient gI(wk) is computed, we further solve the following sub-problem:\nwk+1 = arg min w\nP (wk) + 〈gI(wk),w −wk〉 1 2η ∥∥w −wk∥∥2 +R(w), (12) where the first three terms define a proximal regularization of the linearized approximation of P (w) around point wk. R(w) is presumably in a good shape such that solving (12) is trivial. If R(w) is itself composition of several non-smooth functions, one can resort to the modern proximal average techniques [1], [30]. Moreover, it is verified that Problem (12) can be compactly abstracted by the operation prox() below:\nproxηR(u) = arg minw 1 2‖w − u‖ 2 + ηR(w), (13)\nwhere u = wk − η · gI(wk)."
    }, {
      "heading" : "2.3 Gradient Approximation by Manifold Propagation",
      "text" : "This section elaborates on a manifold-oriented method for approximating the gradients ∇ψi(w) and ∇P (w). Our key argument is that a universal gradient-approximating function is either infeasible or inaccurate in general, particularly when the loss function P (w) has large condition number LP /µP . Our proposed remedy is anchor-based gradient approximation over data manifold. The idea has ever been explored in other context yet not in stochastic optimization before. For example, in [23] Yu et al. showed that any Lipschitz-continuous function f(x) residing on lower-dimensional manifolds can be approximated by a linear combination of function values, namely\nf(x) = ∑ z∈Z γz(x)f(z), (16)\nwhere Z is a collection of pre-specified anchors. γz(x) ≥ 0 is the combination coefficient depending on both x and anchor z. The idea is later generalized in the work of locallylinear support vector machine [8], [12], where each anchor determines a function (rather than a fixed value), namely f(z) in (16) is replaced by an x-varying function fz(x).\nRecall that in Problem (1), the loss function P () is defined on w>x. Letting ψ′(u) be the derivative with respect to scalar u, the gradient of P (w) can be factorized as below:\n∇P (w) = (1/n) ∑\ni=1...n\n∇wψ(w>xi)\n= (1/n) ∑\ni=1...n\nψ′(w>xi) · xi. (17)\n5 Algorithm 2 Manifold Based Gradient Approximation 1: Parameters: anchor number m and k-NN parameter k.\nAnchor Selection 2: Perform data clustering to obtain m centers ci, i = 1 . . .m; 3: for i = 1 to m do 4: Find anchor zi by solving\nzi = argminx ‖x− ci‖2, (14)\nwhere x is from the training data set. 5: end for\nSparse Anchor-Sample Graph (ASG) Construction 6: for i = 1 to n do 7: For sample xi, find k-nearest anchors zi1 , . . . , zik ; 8: Learn the Gaussian kernel parameter by\nσ = max ( , inf\nj∈{i1,...,ik}\n√ ‖xi − zj‖ ) , (15)\nwhere is set to be 10−4 to avoid the trivial case σ = 0. 9: for each k-nearest anchor z do\n10: Calculate γz(xi) = exp(−‖xi − z‖2/σ2); 11: end for 12: Normalize γz(xi) to ensure that they sum to 1; 13: end for\nGradient Approximation over ASG 14: Pre-compute the product matrix XM in Eqn. 23; 15: // for approximate gradient hI(w) of any mini-batch 16: for each xi in the mini-batch I do 17: Calculate hi(w) by Eqn. (20); 18: end for 19: hI(w) = ∑ i∈I hi(w)/|I|; 20: // for approximate full gradient H(w) 21: Calculate H(w) by Eqn. (23);\nInspired by the factorization in (17), we propose to establish a manifold over the training data, such that the derivative term ψ′(w>xi) in (17) can be efficiently computed via sparse information propagation on the manifold. Algorithm 2 shows the pseudo-code for the major steps. The proposed scheme consists of the following components:\n1) Constructing anchor set: Compared to universal gradient approximation, anchor set [14] has a stronger representation power by establishing locally low-order (such as quadratic or cubic) approximation around each anchor point. Let m be the number of anchor points. The optimal value of m is mostly dataset-specific. Let Z = {z1, . . . , zm} be the anchor set. We employ a k-means clustering procedure to obtain m centers in stratified manner. The anchor points are chosen as the nearest samples to these centers, since these centers per se are not necessarily corresponding to meaningful features.\n2) Anchor-Sample Graph (ASG) Construction: We follow the local approximation scheme as described in Eqn. (16). Let each anchor z uniquely determine a localized function f(z). Since the primary goal is to approximate the gradient, let us define f(z) = ψ′(w>z). Moreover, let us assume that the derivative ψ′(w>x) for any x lies on a nonlinear manifold, namely\nψ′(w>x) ≈ ∑ z∈Z γz(x) · ψ′(w>z). (18)\nObviously, anchors and samples naturally form an anchor-sample graph (ASG), where the connectivity strengths\nare controlled by {γz(x)}. In graph-based propagation methods, it is known that connecting sample with remote anchors potential does harm to the performance [14]. Therefore, each sample is enforced to only connect to its knearest anchors. The computation of γz(x) is detailed in Algorithm 2.\n3) Gradient Approximation over ASG: Based on the factorization in Eqn. (17), the stochastic gradient for a sample xi can be computed by:\n∇ψ(w>xi) = ψ′(w>xi) · xi ≈ (∑ z∈Z γz(xi) · ψ′(w>z) ) · xi, (19)\nwhere the last approximation holds from the manifold assumption as described in Eqn. (18). The right hand side in (19) serves as our proposed manifold-oriented approximate gradient, namely\nhi(w) = (∑ z∈Z γz(xi) · ψ′(w>z) ) xi. (20)\nImportantly, computing (20) is highly efficient owing to the sparsity of ASG. It only involves executing the derivative function for all anchors in addition to another O(k + d) algorithmic operations per sample. Likewise, the approximate full gradient H(w) in (9) can be computed by:\nH(w) = 1n ∑ i=1...n hi(w)\n= 1n ∑ i=1...n [(∑ z∈Z γz(xi) · ψ′(w>z) ) · xi ]\n= 1n ∑ z∈Z [ ∑ i=1...n γz(xi) · xi] · ψ′(w>z), (21)\nwhich is purely based on the sparse edge coefficients in ASG and the derivatives {ψ′(w>z)} for all anchor z.\nIn fact, the computation in (21) can be further accelerated by per-computing the terms irrelevant to w. Let M ∈ Rn×m be the matrix by compiling all coefficients in ASG. Specifically, M(i, j) = γzj (xi). Moreover, let\ngZ(w) = ( ψ′(w>z1), . . . , ψ ′(w>zm) )> ∈ Rm, (22)\nbe the vector of anchor derivatives conditioned on parameter w and X = (x1, . . . ,xn) ∈ Rd×n be the feature matrix. Eqn. (21) can be compactly expressed as\nH(w) = 1\nn · (XM)× gZ(w), (23)\nThe product XM ∈ Rd×m is not varying with respect to w and thus can be pre-computed for avoiding redundant computation at different outer loops in Algorithm 1."
    }, {
      "heading" : "2.4 Instances of Applications",
      "text" : "This section instantiates our proposed algorithm by several representative loss functions and regularizations.\nLogistic Loss: It is applicable to either real or binary responses. We focus on the binary case, where y = ±1. For any data vector x, the conditional probability of the class label is:3\np(y|x;w) = σ(yw>x) := 1/(1 + exp(−y(w>x))) (24)\n3. For the sake of simplifying notations, we remove the intercept variable by appending an additional dimension of constant 1 to any feature vector x.\n6 The log-likelihood function is then expressed as P (w) =∑n i=1 ψ(w >xi) = ∑n i=1 log p(yi|xi;w). According to the calculus rule of sigmoid function, the gradient of ψ(w>xi) is:\n∇ψ(w>xi) = σ(−yiw>xi) · yi︸ ︷︷ ︸ derivative ψ′(w>xi) ·xi (25)\nDirectly plugging the derivative into Eqn. (20) is problematic, since the label yi and feature vector xi are tightly coupled in Eqn. (25). Therefore, the stochastic gradient of a sample xi shall be handled according to its label. More formally, let us consider the following two cases:\nCase-1: yi = 1. We have ∇ψ(w>xi) = σ(−w>xi) · xi, which can be efficiently solved by the tricks developed in Eqn. (20).\nCase-2: yi = −1. Now there is ∇ψ(w>xi) = σ(w>xi) · (−xi) = (1 − σ(−w>xi)) · (−xi) = −xi + σ(−w>xi) · xi. Note that we use the property of sigmoid function σ(u) = 1 − σ(−u). It turns out that we can still apply the tricks in Eqn. (20) by amending the result with the term −xi.\nThe matrix representation in Eqn. (23) shall be accordingly adjusted. However we omit it and leave it to longer version of this paper.\nHinge Loss and Squared Hinge Loss: The loss function popularized by SVM is known to be hinge loss [1−yw>x]+. It is non-differentiable due to the irregularity at yw>x = 1. However, as discovered in [25], [26], hinge loss can be smoothed by the loss of “modified logistic regression”:\n[1− yw>x]+ ≈ 1 β log ( 1 + exp(−β(yw>x− 1)) ) . (26)\nThe approximation residual asymptotically becomes zero when β → +∞, therefore we can cast hinge loss into the the framework of logistic loss with properly-chosen β.\nAnother solution of smoothing hinge loss is using squared hinge loss as adopted by L2-SVM [4], namely (1/2)([1 − yw>x]+)2, which naturally removes the irregular point at the risk of over-penalizing large response. Its gradient at a sample (xi, yi) is\n∇ψ(w>xi) = [1− yiw>xi]+ · (−yi)︸ ︷︷ ︸ derivative ψ′(w>xi) ·xi. (27)\nTo decouple xi and yi, we can apply the technique which was just discussed about Eqn. (25).\nRegularization: The regularization function R(w) can be either smooth (e.g., Tikhonov regularization) or non-smooth (e.g., 1-norm regularization). Below we list a few regularization functions widely-used in machine learning:\n(Tikhonov) : R(w) = λ‖w‖22. (1-norm) : R(w) = λ‖w‖1.\n(Elastic net) : R(w) = λ(1− α)‖w‖1 + λα‖w‖2.\nWhen parameters w constitute a matrix rather than a vector, regularization terms such as matrix nuclear norm [3] can be applied. However, optimizing with all above regularization under the proximal operator in (13) has been maturely developed. We thus omit more discussion."
    }, {
      "heading" : "2.5 Algorithmic Complexity",
      "text" : "The iteration complexity of the proposed S3GD depends on several variables: the mini-batch size p, the number of anchors m, the k-NN parameter in constructing ASG, the maximal inner loop count kin and the feature dimensionality d. The major computational overhead stems from computing H(w̃) at each outer loop in Algorithm 1. Importantly, the compact matrix form in Eqn. (23) largely reduces the time and space complexities.\nMost of existing semi-stochastic algorithms rely on two nested loop, of which the outer loop incurs exact full gradient computation or covariance matrix estimation. For large data, it entails a tremendous O(nd) or O(d2) complexity. For other sophisticated algorithms that target at improved mini-batch construction (such as SSGD [27]), the iteration complexity is generally better than ours. However, the lack of global information makes these algorithms more vulnerable to gradient noises.\nRegarding space requirement, the major cost comes from the storage of the product matrix in Eqn. (23). To maintain such data structure, it consumes O(nk), where k is the anchor k-NN parameter. Akin to SVRG and SCV, S3GD does not memorize historic gradients. We summarize the space and time complexities for all interested algorithms in Table 1."
    }, {
      "heading" : "3 CONVERGENCE ANALYSIS",
      "text" : "We need two lemmas as below to forward the convergence analysis. The first lemma states that the proximal mapping is firmly nonexpansive, or co-coercive with constant not greater than 1:\nLemma 3.1. Let R(w) : Rd 7→ R be a closed convex function with strong convexity parameter µR ≥ 0, then for any u,v ∈ dom(R) and η > 0,\n‖proxηR(u)− proxηR(v)‖ ≤ 11+ηµR ‖u− v‖. (28)\nThe other lemma is a generalization of Theorem 2.1.5 in [16]. The proofs of both lemmas are deferred to the Appendix.\nLemma 3.2. Suppose P (w) : Rd 7→ R is µP -strongly convex and LP -smooth, then for any u,v ∈ dom(P ),\n〈∇P (u)−∇P (v),u− v〉 ≥ µPLPµP +LP ‖∇P (u)−∇P (v)‖ 2 + 1µP +LP ‖u− v‖ 2.\nThe following is our main observation regarding the convergence property of the proposed S3GD:\nTheorem 3.1. For compositional function L(w) = P (w) + R(w), assume its two components P (w),R(w) have strong convexity parameter µP ≥ 0, µR ≥ 0 and µP · µR > 0. P (w) has Lipschitz parameter LP . Set the step size ηk = η ∈ (0, 2LP +µP ] for all k > 0. The proposed algorithm will satisfy the following inequality for the k-th iteration,\nE‖wk −w∗‖2 ≤ ρk ( ‖w0 −w∗‖2 − ∆1−ρ ) + 11−ργ∆,\nwhere ρ = 11+ηµR ( 1− 2ηµPLPµP +LP ) , γ = η 2 1+ηµR and ∆ reflects the maximal gradient approximation residual..\n7 SGD SSGD SVRG SCV S3GD Time Complexity: O(p× d) O(p× d) O ( p× d+ n\nkin × d\n) O ( p× d+ d2 ) O ( p× d+ m\nkin × d+ n kin × k ) Space Complexity: O(d) O(d) O(d) O(d2) O(d)\nTABLE 1 Time/space iteration complexity for all algorithms involved in the quantitative study. p,m, n, d denote the size of mini-batch, the number of anchors, the number of training samples, and the feature dimensionality respectively. k denotes the anchor k-NN parameter. Note that for SVRG and S3GD, they both adopt nested loop during the optimization. kin denotes the maximal iteration count of the inner loop.\nProof. For convenience let us define the following notations at the k-th iteration\nvk = ∇ψik(wk−1)− [hik(w̃)− Ehik(w̃)], wk = proxηkR(w\nk−1 − ηkvk), ∆k = E(‖∇ψik(wk−1)− hik(w̃)‖2).\nWe proceed the analysis by measuring the expectation of the distance between wk and the global optimum w∗. Taking expectation with respect to the random sample index ik there is\nE‖wk −w∗‖2\n= E‖proxηkR(w k−1 − ηkvk)−\nproxηkR(w ∗ − ηk∇P (w∗))‖2 ≤ E (\n1 1+ηkµR · (‖(wk−1 − ηkvk)− (w∗ − ηk∇P (w∗))‖2) )\n= 11+ηkµR ‖w k−1 −w∗‖2\n+ η2k\n1+ηkµR E‖vk −∇P (w∗)‖2\n− 2ηk1+ηkµRE(vk −∇P (w ∗))>(wk−1 −w∗), (29)\nwhere the first equality comes from the fact that w∗ is fixed point, namely w∗ = proxηkR(w\n∗ − ηk∇P (w∗)). The first inequality is obtained by applying Lemma 3.1.\nRecall that Evk = ∇P (wk−1), we have E‖vk −∇P (w∗)‖2 = E‖vk −∇P (wk−1)‖2 + ‖∇P (wk−1)−∇P (w∗)‖2 = E‖∇ψik(wk−1)− hik(w̃)‖2\n−‖∇P (wk−1)− Ehik(w̃)‖2 +‖∇P (wk−1)−∇P (w∗)‖2\n≤ ∆k + ‖∇P (wk−1)−∇P (w∗)‖2, (30) where the two equalities hold since E‖x‖2 = ‖Ex‖2 +E‖x− Ex‖2. The last inequality is from the definition of Lipschitz continuity. There is also\nE(vk −∇P (w∗))>(wk−1 −w∗) = (∇P (wk−1)−∇P (w∗))>(wk−1 −w∗) ≥ 1µP +LP ‖∇P (w k−1)−∇P (w∗)‖2\n+ µPLPµP +LP ‖w k−1 −w∗‖2. (31)\nPlugging (30)(31) into (29) obtains\nE‖wk −w∗‖2\n= 11+ηkµR ( 1− 2ηkµPLPµP +LP ) ‖wk−1 −w∗‖2\n+ ηk1+ηkµR ( ηk − 2µP +LP ) ‖∇P (wk−1)−∇P (w∗)‖2 + η2k\n1+ηkµR ∆k (32)\nSet ηk = η ∈ (0, 2/(µP + LP )] and assume there exists ∆ ≥ ∆k for all k. We have\nE‖wk −w∗‖2 ≤ ρ‖wk−1 −w∗‖2 + γ∆ (33)\nTaking expectation with respect to all historical choice of i1, . . . , ik and iteratively applying (33), we have\nE‖wk −w∗‖2 ≤ ρk‖w0 −w∗‖2 + ∑k−1\nt=0 ρtγ∆ = ρk ( ‖w0 −w∗‖2 − ∆1−ρ ) + 11−ργ∆.\nIt completes the proof.\nRemarks: The above theorem basically states that, when P (w), R(w) are not simultaneously 0-strongly convex, the upper bound in term of solution optimality is comprised of two terms. One of them exponentially converges to zero, and the other is pertaining to the accuracy of stratified manifold-based gradient approximation. Though the accuracy of gradient approximation is not amenable for bound analysis, we empirically investigates its effect in large-scale optimization. For non-strongly convex functions, adding quadratic perturbation terms can be used to reach similar argument [29]. We omit the details due to trivialness."
    }, {
      "heading" : "4 EXPERIMENTS",
      "text" : "This section reports the numerical studies between our proposed S3GD and other competing algorithms."
    }, {
      "heading" : "4.1 Description of Dataset and Applications",
      "text" : "To make the experiments comprehensive, we include nine benchmarks that cover a variety of heterogeneous tasks and different data scales: 20-Newsgroups4 which contains nicely-organized documents from 20 different news topics, WebSpam5 represents a large collection of annotated spam or non-spam hosts labeled by a group of volunteers, IJCNN6 for time-series data, KDD04 bio and KDD04 phy7 which correspond to the protein homology sub-task and quantum physics sub-task in KDD-Cup 2004 respectively, covtype8 which includes cartographic variables for predicting forest cover type. We also include three computer vision benchmarks: CIFAR109 for image categorization, Kaggle-Face10 for\n4. http://qwone.com/∼jason/20Newsgroups/ 5. http://www.csie.ntu.edu.tw/∼cjlin/libsvmtools/datasets/binary.\nhtml 6. http://www.geocities.com/ijcnn/nnc ijcnn01.pdf 7. http://osmot.cs.cornell.edu/kddcup/datasets.html 8. https://archive.ics.uci.edu/ml/datasets/Covertype 9. http://www.cs.toronto.edu/∼kriz/cifar.html 10. https://www.kaggle.com/c/challenges-in-representationlearning-facial-expression-recognition-challenge\n8 0.5 1 1.5 2 2.5 3 3.5 4\nx 10 4\n10 −0.3\n10 −0.28\n10 −0.26\n10 −0.24\nOptimization Iteration\nO bj\nec tiv\ne F\nun ct\nio n\nV al\nue (\nT ra\nin in\ng)\nCIFAR−10\nSGD with η = 0.1 SGD with η = 1 SGD with η = 5 SGD with η = 10\n0.5 1 1.5 2 2.5 3 3.5 4\nx 10 4\n10 −0.3\n10 −0.28\n10 −0.26\n10 −0.24\nOptimization Iteration\nO bj\nec tiv\ne F\nun ct\nio n\nV al\nue (\nT ra\nin in\ng)\nCIFAR−10\nSSGD with η = 0.1 SSGD with η = 1 SSGD with η = 5 SSGD with η = 10\n0.5 1 1.5 2 2.5 3 3.5 4\nx 10 4\n10 −0.3\n10 −0.28\n10 −0.26\n10 −0.24\nOptimization Iteration\nO bj\nec tiv\ne F\nun ct\nio n\nV al\nue (\nT ra\nin in\ng)\nCIFAR−10\nSCV with η = 0.1 SCV with η = 1 SCV with η = 5 SCV with η = 10\n0.5 1 1.5 2 2.5 3 3.5 4\nx 10 4\n10 −0.3\n10 −0.28\n10 −0.26\n10 −0.24\nOptimization Iteration\nO bj\nec tiv\ne F\nun ct\nio n\nV al\nue (\nT ra\nin in\ng)\nCIFAR−10\nSVRG with η = 0.1 SVRG with η = 1 SVRG with η = 5 SVRG with η = 10\n0.5 1 1.5 2 2.5 3 3.5 4\nx 10 4\n10 −0.3\n10 −0.28\n10 −0.26\n10 −0.24\nOptimization Iteration\nO bj\nec tiv\ne F\nun ct\nio n\nV al\nue (\nT ra\nin in\ng)\nCIFAR−10\nS3GD with η = 0.1 S3GD with η = 1 S3GD with η = 5 S3GD with η = 10\nFig. 2. Investigation of the effect of step sizes on the convergence speed and solution stability. We select CIFAR10 as the testbed and report the training objective values under four different step size parameters. It is seen that large step sizes often indicate faster convergence yet also bring the risk of bouncing around the optimum. Variance reduction is thus critical for using large step sizes. Note that the objective values are plotted in logarithmic scale. Better viewing when enlarged and in color mode.\nfacial expression recognition and MED1111 for video event detection.\nTable 2 summarizes the critical information for abovementioned benchmarks. For most datasets, we adopt the defaulted train/test data split. Regarding the features, we either use the feature files provided by the benchmark organizers or extract them by ourselves. They may not necessarily bring state-of-the-art accuracy since our focus is investigating the convergence speed of the optimization methods instead of just driving for higher performance. The defaulted tasks defined on some benchmarks are multi-class classification. In these cases, a one-vs-rest scheme is applied to simplify the evaluations. We pick the category with the most training samples as the positive class and merge all rest categories as the negative class, converting it into a binary classification problem. Whenever the positive/negative data partitions are heavily unbalanced, we assign samples from positive/negative classes different weights such that the weight summarizations of the two classes are equal. More formally, let Y+,Y− be the index sets of positive/negative classes respectively. The loss is calculated as\nP (w) = 1|Y+| ∑ i∈Y+ ψi(w) + 1 |Y−| ∑ i∈Y− ψi(w). (34)\nIn all experiments we stick to using the logistic loss function and Tikhonov regularization owing to their empirical popularity and non-linear property."
    }, {
      "heading" : "4.2 Baseline Algorithms",
      "text" : "We make comparisons between the proposed S3GD and other four competitors, including\n11. http://www.nist.gov/itl/iad/mig/med11.cfm\n• Mini-Batch Stochastic Gradient Descent (SGD): it represents the standard stochastic gradient method. At each iteration, the SGD algorithm randomly draws p samples from the training set according to weight distribution specified in Eqn. (34), calculate their respective stochastic gradient, and uniformly average these stochastic gradients. • Stratified SGD (SSGD) [27]: This method aims to improve the standard mini-batch SGD using data clustering and stratified sampling. SSGD ensures that each iteration will draw at least one sample from each data cluster (stratum). The inclusion is to contrast different ways of using global information about data. For fair comparison we set the number of clusters to be p. • Stochastic Variance Reduction Gradient (SVRG): This original idea work of SVRG is found in [10]. However, it does not handle non-smooth functions. In the comparison we adopt the extension proposed in [22]. Inheriting the two nested loops of SVRG, one of the key parameters in [22] is the the maximal iteration number in the inner loop. The authors suggest this parameter shall be sufficiently large for achieving better loss bound. We fix this parameter to be always 50 in all experiments, which empirically provides a good balance between convergence speed and heavy complexity caused by exact gradient estimation. • Stochastic Control Variate (SCV) [21]: This is another semi-stochastic gradient method that reports state-of-the-art speed and accuracies. The method relies on the utilization of data statistics such as low-order moments to define “control variate”. The authors rigourously prove the reduction in noisy gradient variance under mild assumptions. Note that for features in high dimension, the computation of data statistics can be its computational bottleneck."
    }, {
      "heading" : "4.3 Evaluation Settings",
      "text" : "For all experiments, we fix the parameter λ = 10−3 for the Tikhonov regularization. The maximal iteration parameter kin in the inner loop of S3GD is fixed to be 20. Each minibatch contains p = 10 random samples. For S3GD, m = 100 anchors are generated on all datasets. We implemented all baseline algorithms and S3GD in optimized C++ programs.\n9 0.001 0.01 0.1 1 10 100 1000 kaggleface cifar10 webspam covtype ijcnn kdd04_phy kdd04_bio med11 20newsgroups El ap se d T im e p e r 1 0 0 it e ra ti o n s (i n u n it s o f se co n d s an d lo ga ri th m ic s ca le ) SGD SSGD SVRG SCV S3GD\nFig. 3. Iteration time complexities in terms of CPU times on all datasets. The time is recorded in seconds. To highlight subtle difference, we adopt logarithmic scale for the vertical axis. The length of time is visualized by a bar that points to its due value. See text for more explanations.\nThe experiments are conducted on shared servers in an industrial research lab. Each of the servers is equipped with 48 CPU cores and 400GB physical memory. Five independent trials are performed for all algorithms and the averaged results are reported. The entire experiments take about one day on five servers.\nThere are two indices which are utterly crucial for evaluating a gradient based optimization scheme: the correlation (or variance) between (semi)stochastic gradient and exact gradient, and the maximal step size which ensures the stability of the optimization. Large step sizes are always favored in practice since they expect improved convergence speed. In the literature of stochastic gradient methods, both decayed and constant step sizes are widely adopted. We found that the decayed step sizes did not work well compared with the constant ones on most data. Therefore we focus on the results using the constant step sizes. In Figure 2 we plot the objective values in each iteration of the training stage on CIFAR10. For all baseline algorithms and our proposed S3GD, the convergence curves under four different constant step sizes η = {0.1, 1, 5, 10} are recorded and plotted. Obviously SVRG and S3GD are two most stable algorithms even operating with large step size parameters. All other three algorithms drastically fluctuate when their current solutions approach the global optimum, even with the moderate parameter η = 5. This empirical investigation highlights the importance of choosing proper step size. To fairly compare different algorithms, we evaluate them under the parameter set η ∈ {0.1, 1, 5, 10} and report the performance with the largest step size that satisfies the following stability condition:\nη∗ = max η s.t. F (w; η) ≤ (1 + )F (w∗), (35)\nwhere F (w∗) denotes the objective value at the global optimum w∗. F (w; η) is the converged point using step size η. In the experiments we average the last 5,000 optimization iterations to obtain F (w; η). is set to be 0.01 in all cases. The condition aims to abandon any step size parameter that drives the solution crazily bounce around the global optimum.\nMost of prior works [10], [21] report the performance with respect to iteration counts. We here argue that the evaluation shall take the iteration complexity into account. Recall that Table 1 summarizes the time and space iteration complexities for all algorithms. Importantly, the complexi-\nties of SVRG and SCV are dominated by the exact gradient computation and class-specific covariance matrix estimation. Both of them are expected to take longer time for accomplishing each iteration. Figure 3 reports the time for performing 50 gradient descent iterations for all datasets and algorithms. The computing time is obtained by averaging all trials. It is observed that on most datasets, the standard SGD consumes the least time. SSGD and our proposed S3GD use slightly more time compared to SGD. The CPU time of SVRG and SCV are significantly larger. Specifically, SVRG is especially slow in comparison when facing large scale data set (such as Kaggle-face and covtype) and high feature dimensions (e.g., 5,000-dimensional features for MED11 and 26,214-dimensional features for 20newsgroups). Likewise, SCV is particularly slow when handling high-dimensional features. On the 20newsgroups, SCV requires 594 seconds for every 50 iterations, which is beyond the scope of most practitioners. In contrast, SGD and S3GD only need 0.21 and 0.30 seconds respectively. Therefore for fairness in comparison, we will majorly concern the performance with respect to CPU times."
    }, {
      "heading" : "4.4 Quantitative Investigations",
      "text" : "Convergence Speed: Figure 4 shows the training objective values with respect to the CPU times. For all algorithms, the step-size parameters are chosen according to the criterion in (35). Interestingly, though semi-stochastic gradient methods are proved to enjoy faster asymptotical convergence speed, most of them are not as “economic” as standard SGD due to significantly higher iteration complexity. Our proposed S3GD exceptionally outperforms all other algorithms on 6 out of 9 datasets. SVRG only dominates the small-scale 22-dimensional dataset IJCNN, and SGD yields the best performance on other two datasets KDD04 bio and 20newsgroups. SSGD is found to be sensitive about imbalanced data partition, such as MED11 and 20newsgroups, where the positive/negative data ratios are 1:25 and 1:20 respectively.\nIt is surprising that the standard SGD is among the best performers on nearly all of 9 datasets despite its simplicity. Based on the experiments we argue that the research of semi-stochastic algorithms shall investigate the balance of larger step size and increased iteration complexity, particulary in the era of large data and high dimension.\n10\nCorrleation of Gradients: We further study the Pearson correlation of (semi)stochastic gradient and the exact gradient. For a semi-stochastic algorithm, the correlation score is favored to approach the value of 1, since it indicates a better approximation scheme for gradient computation.\nIt is clearly observed that SVRG and the proposed S3GD exhibit the most favorable correlation scores. Moreover, most methods enjoy relatively larger correlation scores when the optimization just begins. The correlation scores gradually drop when the optimization proceeds. The reason may be that the exact (sub)gradient tends to zero around the optimum, which makes accurate gradient approximation more challenging. The only exception is SVRG. In all cases its correlation scores quickly rise and stay at 1. It may be caused by the fact that ‖wk+1 − wk‖ tends to zero when approaching the global optimum. Therefore, w̃ ≈ wk in Eqn. (4), which implies that the semi-stochastic gradient becomes increasingly close to the full gradient.\nEffect of Anchor: Recall that we use 100 anchors obtained through clustering in all experiments. One may concern how different choices of anchor number affect the performance and running time. Figure 6 presents the evolution of corre-\nlations scores under different anchor settings on MED11 and CIFAR10 (step size is fixed to be 1 for all cases). Interestingly, we observe that enlarging anchor set does not entail boosted correlation scores. In fact, the scores will reach its peak around data-specific anchor number (100 for MED11 and 20 for CIFAR10) though other choices bring alike performances. This implies that the algorithm is largely robust to the anchor number though empirical tuning does further help. Figure 7 plots the averaged iteration times for different anchor parameters. More anchors entail longer CPU time. Yet the time only increases sub-linearly owing to other kinds of computational overhead at each iteration."
    }, {
      "heading" : "5 CONCLUDING REMARKS",
      "text" : "In this paper we addressed the scalability issue pertaining to semi-stochastic gradient descent methods by proposing a novel approach S3GD. The motivation of S3GD is to reduce the high iteration complexity in existing semi-stochastic algorithms. It exploits stratified manifold-based gradient approximation as a good cure for the time-consuming exact gradient calculation. Our work significantly advances the original idea of residual-minimizing gradient correction.\n11\n10 2\n10 3\n10 4\n10 5\n0\n0.2\n0.4\n0.6\n0.8\n1\nOptimization IterationC or\nre lat\nion o\nf ( se\nm i)s\nto ch\nas tic\ng ra\ndie nt\na nd\ne xtr\nac t g\nra die\nnt kaggleface\nSGD SVRG SSGD SCV S3GD\n10 2\n10 3\n10 4\n10 5\n0\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n1\nOptimization IterationC or\nre lat\nion o\nf ( se\nm i)s\nto ch\nas tic\ng ra\ndie nt\na nd\ne xtr\nac t g\nra die\nnt cifar10\nSGD SVRG SSGD SCV S3GD\n10 2\n10 3\n10 4\n10 5\n0\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n1\nOptimization IterationC or\nre la\ntio n\nof (s\nem i)s\nto ch\nas tic\ng ra\ndi en\nt a nd\ne xt\nra ct\ng ra\ndi en\nt\nwebspam\nSGD SVRG SSGD SCV S3GD\n10 2\n10 3\n10 4\n10 5\n−0.5\n0\n0.5\n1\nOptimization IterationC or\nre la\ntio n\nof (s\nem i)s\nto ch\nas tic\ng ra\ndi en\nt a nd\ne xt\nra ct\ng ra\ndi en\nt\ncovtype\nSGD SVRG SSGD SCV S3GD\n10 2\n10 3\n10 4\n10 5\n−0.2\n0\n0.2\n0.4\n0.6\n0.8\n1\nOptimization IterationC or\nre la\ntio n\nof (s\nem i)s\nto ch\nas tic\ng ra\ndi en\nt a nd\ne xt\nra ct\ng ra\ndi en\nt\nijcnn\nSGD SVRG SSGD SCV S3GD\n10 2\n10 3\n10 4\n10 5\n0\n0.2\n0.4\n0.6\n0.8\n1\nOptimization IterationC or\nre la\ntio n\nof (s\nem i)s\nto ch\nas tic\ng ra\ndi en\nt a nd\ne xt\nra ct\ng ra\ndi en\nt\nkdd04_phy\nSGD SVRG SSGD SCV S3GD\n10 2\n10 3\n10 4\n10 5\n−0.8\n−0.6\n−0.4\n−0.2\n0\n0.2\n0.4\n0.6\n0.8\n1\nOptimization IterationC or\nre la\ntio n\nof (s\nem i)s\nto ch\nas tic\ng ra\ndi en\nt a nd\ne xt\nra ct\ng ra\ndi en\nt\nkdd04_bio\nSGD SVRG SSGD SCV S3GD\n10 2\n10 3\n10 4\n10 5\n−0.8\n−0.6\n−0.4\n−0.2\n0\n0.2\n0.4\n0.6\n0.8\n1\nOptimization IterationC or\nre la\ntio n\nof (s\nem i)s\nto ch\nas tic\ng ra\ndi en\nt a nd\ne xt\nra ct\ng ra\ndi en\nt\nmed11\nSGD SVRG SSGD SCV S3GD\n10 2\n10 3\n10 4\n10 5\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n1\nOptimization IterationC or\nre lat\nion o\nf ( se\nm i)s\nto ch\nas tic\ng ra\ndie nt\na nd\ne xtr\nac t g\nra die\nnt 20newsgroups\nSGD SVRG SSGD S3GD\nFig. 5. Pearson correlation scores of (semi)stochastic gradient and the exact gradient on 9 datasets under the parameter η = 0.1. See text for more explanation. Best viewing in color.\n0 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000\n0.3\n0.35\n0.4\n0.45\n0.5\nC or\nre la\ntio n\nS co\nre s\nOptimization Iteration\nMED11\nanchor number = 20 anchor number = 50 anchor number = 100 anchor number = 200\n0 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000\n0.5\n0.52\n0.54\n0.56\n0.58\n0.6\nC or\nre la\ntio n\nS co\nre s\nOptimization Iteration\nCIFAR10\nanchor number = 20 anchor number = 50 anchor number = 100 anchor number = 200\nFig. 6. Investigation of how the anchors affect gradient correlation scores on MED11 and CIFAR10.\nThe current paper did not discuss the application in a distributed computing environment, since it is out of the main scope. However, we will explore the distributed variants of the proposed S3GD like [19] in the future. Moreover, extension to non-convex formulations such as deep networks [7] is also a meaningful future direction.\n0.0474 0.0518\n0.0591\n0.0768\nm=20 m=50 m=100 m=200\nMED11\n0.0115 0.0116\n0.012\n0.0128\nm=20 m=50 m=100 m=200\nCIFAR10\nFig. 7. Average CPU time for every 50 optimization iterations (in seconds) for S3GD."
    } ],
    "references" : [ {
      "title" : "The proximal average: Basic theory",
      "author" : [ "H. Bauschke", "R. Goebel", "Y. Lucet", "X. Wang" ],
      "venue" : "SIAM Journal on Optimization, 19(2):766–785",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Stochastic learning",
      "author" : [ "L. Bottou" ],
      "venue" : "O. Bousquet and U. von Luxburg, editors, Advanced Lectures on Machine Learning. Springer Verlag",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "A singular value thresholding algorithm for matrix completion",
      "author" : [ "J.-F. Cai", "E.J. Candès", "Z. Shen" ],
      "venue" : "SIAM J. on Optimization, 20(4):1956–1982",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Training a support vector machine in the primal",
      "author" : [ "O. Chapelle" ],
      "venue" : "Neural Comput., 19(5):1155–1178",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Better minibatch algorithms via accelerated gradient methods",
      "author" : [ "A. Cotter", "O. Shamir", "N. Srebro", "K. Sridharan" ],
      "venue" : "NIPS",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Optimal distributed online prediction using mini-batches",
      "author" : [ "O. Dekel", "R. Gilad-Bachrach", "O. Shamir", "L. Xiao" ],
      "venue" : "CoRR, abs/1012.1367",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Deep learning: Methods and applications",
      "author" : [ "L. Deng", "D. Yu" ],
      "venue" : "Technical Report MSR-TR-2014-21,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2014
    }, {
      "title" : "Multiclass latent locally linear support vector machines",
      "author" : [ "M. Fornoni", "B. Caputo", "F. Orabona" ],
      "venue" : "ACML",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Large-scale matrix factorization with distributed stochastic gradient descent",
      "author" : [ "R. Gemulla", "E. Nijkamp", "P.J. Haas", "Y. Sismanis" ],
      "venue" : "SIGKDD",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Accelerating stochastic gradient descent using predictive variance reduction",
      "author" : [ "R. Johnson", "T. Zhang" ],
      "venue" : "NIPS",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Semi-stochastic gradient descent methods",
      "author" : [ "J. Konecny", "P. Richtarik" ],
      "venue" : "CoRR, abs/1312.1666",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Locally linear support vector machines",
      "author" : [ "L. Ladicky", "P.H.S. Torr" ],
      "venue" : "ICML",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Efficient mini-batch training for stochastic optimization",
      "author" : [ "M. Li", "T. Zhang", "Y. Chen", "A.J. Smola" ],
      "venue" : "ACM SIGKDD",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Large graph construction for scalable semi-supervised learning",
      "author" : [ "W. Liu", "J. He", "S. Chang" ],
      "venue" : "ICML",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Constrained stochastic gradient descent for large-scale least squares problem",
      "author" : [ "Y. Mu", "W. Ding", "T. Zhou", "D. Tao" ],
      "venue" : "ACM SIGKDD",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Introductory Lectures on Convex Optimization: A Basic Course",
      "author" : [ "Y. Nesterov" ],
      "venue" : "Springer Netherlands",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Minimizing finite sums with the stochastic average gradient",
      "author" : [ "M.W. Schmidt", "N.L. Roux", "F. Bach" ],
      "venue" : "CoRR, abs/1309.2388",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Accelerated mini-batch stochastic dual coordinate ascent",
      "author" : [ "S. Shalev-Shwartz", "T. Zhang" ],
      "venue" : "NIPS",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Communication-efficient distributed optimization using an approximate newton-type method",
      "author" : [ "O. Shamir", "N. Srebro", "T. Zhang" ],
      "venue" : "ICML",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "The Nature of Statistical Learning Theory",
      "author" : [ "V. Vapnik" ],
      "venue" : "Springer-Verlag New York, Inc., New York, NY, USA",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Variance reduction for stochastic gradient optimization",
      "author" : [ "C. Wang", "X. Chen", "A.J. Smola", "E.P. Xing" ],
      "venue" : "NIPS",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "A proximal stochastic gradient method with progressive variance reduction",
      "author" : [ "L. Xiao", "T. Zhang" ],
      "venue" : "SIAM Journal on Optimization, 24(4):2057–2075",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Nonlinear learning using local coordinate coding",
      "author" : [ "K. Yu", "T. Zhang", "Y. Gong" ],
      "venue" : "NIPS",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "NOMAD: nonlocking",
      "author" : [ "H. Yun", "H. Yu", "C. Hsieh", "S.V.N. Vishwanathan", "I.S. Dhillon" ],
      "venue" : "stochastic multi-machine algorithm for asynchronous and decentralized matrix completion. PVLDB, 7(11):975–986",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Modified logistic regression: An approximation to SVM and its applications in largescale text categorization",
      "author" : [ "J. Zhang", "R. Jin", "Y. Yang", "A.G. Hauptmann" ],
      "venue" : "ICML",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Text categorization based on regularized linear classification methods",
      "author" : [ "T. Zhang", "F.J. Oles" ],
      "venue" : "Inf. Retr., 4(1):5–31",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Accelerating minibatch stochastic gradient descent using stratified sampling",
      "author" : [ "P. Zhao", "T. Zhang" ],
      "venue" : "CoRR, abs/1405.3080",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Stochastic optimization with importance sampling",
      "author" : [ "P. Zhao", "T. Zhang" ],
      "venue" : "CoRR, abs/1401.2753",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Accelerated minibatch randomized block coordinate descent method",
      "author" : [ "T. Zhao", "M. Yu", "Y. Wang", "R. Arora", "H. Liu" ],
      "venue" : "NIPS",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Gradient descent with proximal average for nonconvex and composite regularization",
      "author" : [ "W. Zhong", "J. Kwok" ],
      "venue" : "AAAI",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 19,
      "context" : "Regularized risk minimization [20] is a fundamental subject in machine learning and statistics, whose formulations typically admit a combination of a loss function and a regularization term.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 1,
      "context" : "In such scenarios, stochastic (sub)gradient descent (SGD) [2], [6], [9], [13], [15], [18], [24] is a favored method used by many theorist and practitioners.",
      "startOffset" : 58,
      "endOffset" : 61
    }, {
      "referenceID" : 5,
      "context" : "In such scenarios, stochastic (sub)gradient descent (SGD) [2], [6], [9], [13], [15], [18], [24] is a favored method used by many theorist and practitioners.",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 8,
      "context" : "In such scenarios, stochastic (sub)gradient descent (SGD) [2], [6], [9], [13], [15], [18], [24] is a favored method used by many theorist and practitioners.",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 12,
      "context" : "In such scenarios, stochastic (sub)gradient descent (SGD) [2], [6], [9], [13], [15], [18], [24] is a favored method used by many theorist and practitioners.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 14,
      "context" : "In such scenarios, stochastic (sub)gradient descent (SGD) [2], [6], [9], [13], [15], [18], [24] is a favored method used by many theorist and practitioners.",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 17,
      "context" : "In such scenarios, stochastic (sub)gradient descent (SGD) [2], [6], [9], [13], [15], [18], [24] is a favored method used by many theorist and practitioners.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 23,
      "context" : "In such scenarios, stochastic (sub)gradient descent (SGD) [2], [6], [9], [13], [15], [18], [24] is a favored method used by many theorist and practitioners.",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 4,
      "context" : "Its singlesample or mini-batch [5], [18] updating scheme is a general remedy for the O(n) complexity in exact gradient descent (GD) methods (n represents the number of training samples).",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 17,
      "context" : "Its singlesample or mini-batch [5], [18] updating scheme is a general remedy for the O(n) complexity in exact gradient descent (GD) methods (n represents the number of training samples).",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 27,
      "context" : "For example, the work in [28] explicitly expresses the gradient variance and proves that constructing mini-batch using special non-uniform sampling strategy is able to reduce the gradient variance.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 16,
      "context" : "Another method named stochastic average gradient (SAG) [17] keeps a record of historic stochastic gradients and adaptively averages them for the use in the current iteration.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 9,
      "context" : "We adopt the computational framework of residual-minimizing gradient correction which was originally proposed in stochastic variance-reduced gradient (SVRG) [10] by Johnson and Zhang.",
      "startOffset" : 157,
      "endOffset" : 161
    }, {
      "referenceID" : 9,
      "context" : "Theoretic analysis in [10], [11], [22] reveals that semistochastic algorithms achieve a geometric rate of convergence.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 10,
      "context" : "Theoretic analysis in [10], [11], [22] reveals that semistochastic algorithms achieve a geometric rate of convergence.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 21,
      "context" : "Theoretic analysis in [10], [11], [22] reveals that semistochastic algorithms achieve a geometric rate of convergence.",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 9,
      "context" : "In fact, most existing semi-stochastic algorithms either rely on periodic full gradient computation [10] or use Hessian-like covariance matrix operations [21], which account for their high iteration complexities.",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 20,
      "context" : "In fact, most existing semi-stochastic algorithms either rely on periodic full gradient computation [10] or use Hessian-like covariance matrix operations [21], which account for their high iteration complexities.",
      "startOffset" : 154,
      "endOffset" : 158
    }, {
      "referenceID" : 21,
      "context" : "Our theoretic observations are based on the following assumptions, similar to previous semi-stochastic gradient descent methods [22], [27]:",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 26,
      "context" : "Our theoretic observations are based on the following assumptions, similar to previous semi-stochastic gradient descent methods [22], [27]:",
      "startOffset" : 134,
      "endOffset" : 138
    }, {
      "referenceID" : 9,
      "context" : "SVRG [10], as introduced in preceding section, obeys the update rule in (4).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 20,
      "context" : "Another semi-stochastic algorithm, stochastic control variate (SCV) [21], represents a general approach of using control variate for variance reduction in stochastic gradient.",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 0,
      "context" : "If R(w) is itself composition of several non-smooth functions, one can resort to the modern proximal average techniques [1], [30].",
      "startOffset" : 120,
      "endOffset" : 123
    }, {
      "referenceID" : 29,
      "context" : "If R(w) is itself composition of several non-smooth functions, one can resort to the modern proximal average techniques [1], [30].",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 22,
      "context" : "For example, in [23] Yu et al.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 7,
      "context" : "The idea is later generalized in the work of locallylinear support vector machine [8], [12], where each anchor determines a function (rather than a fixed value), namely f(z) in (16) is replaced by an x-varying function fz(x).",
      "startOffset" : 82,
      "endOffset" : 85
    }, {
      "referenceID" : 11,
      "context" : "The idea is later generalized in the work of locallylinear support vector machine [8], [12], where each anchor determines a function (rather than a fixed value), namely f(z) in (16) is replaced by an x-varying function fz(x).",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 13,
      "context" : "1) Constructing anchor set: Compared to universal gradient approximation, anchor set [14] has a stronger representation power by establishing locally low-order (such as quadratic or cubic) approximation around each anchor point.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 13,
      "context" : "In graph-based propagation methods, it is known that connecting sample with remote anchors potential does harm to the performance [14].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 24,
      "context" : "However, as discovered in [25], [26], hinge loss can be smoothed by the loss of “modified logistic regression”:",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 25,
      "context" : "However, as discovered in [25], [26], hinge loss can be smoothed by the loss of “modified logistic regression”:",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 3,
      "context" : "Another solution of smoothing hinge loss is using squared hinge loss as adopted by L2-SVM [4], namely (1/2)([1 − ywx]+), which naturally removes the irregular point at the risk of over-penalizing large response.",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 2,
      "context" : "When parameters w constitute a matrix rather than a vector, regularization terms such as matrix nuclear norm [3] can be applied.",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 26,
      "context" : "For other sophisticated algorithms that target at improved mini-batch construction (such as SSGD [27]), the iteration complexity is generally better than ours.",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 15,
      "context" : "5 in [16].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 28,
      "context" : "For non-strongly convex functions, adding quadratic perturbation terms can be used to reach similar argument [29].",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 26,
      "context" : "• Stratified SGD (SSGD) [27]: This method aims to improve the standard mini-batch SGD using data clustering and stratified sampling.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 9,
      "context" : "• Stochastic Variance Reduction Gradient (SVRG): This original idea work of SVRG is found in [10].",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 21,
      "context" : "In the comparison we adopt the extension proposed in [22].",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 21,
      "context" : "Inheriting the two nested loops of SVRG, one of the key parameters in [22] is the the maximal iteration number in the inner loop.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 20,
      "context" : "• Stochastic Control Variate (SCV) [21]: This is another semi-stochastic gradient method that reports state-of-the-art speed and accuracies.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 9,
      "context" : "Most of prior works [10], [21] report the performance with respect to iteration counts.",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 20,
      "context" : "Most of prior works [10], [21] report the performance with respect to iteration counts.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 18,
      "context" : "However, we will explore the distributed variants of the proposed S3GD like [19] in the future.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 6,
      "context" : "Moreover, extension to non-convex formulations such as deep networks [7] is also a meaningful future direction.",
      "startOffset" : 69,
      "endOffset" : 72
    } ],
    "year" : 2015,
    "abstractText" : "Stochastic gradient descent (SGD) holds as a classical method to build large scale machine learning models over big data. A stochastic gradient is typically calculated from a limited number of samples (known as mini-batch), so it potentially incurs a high variance and causes the estimated parameters bounce around the optimal solution. To improve the stability of stochastic gradient, recent years have witnessed the proposal of several semi-stochastic gradient descent algorithms, which distinguish themselves from standard SGD by incorporating global information into gradient computation. In this paper we contribute a novel stratified semi-stochastic gradient descent (S3GD) algorithm to this nascent research area, accelerating the optimization of a large family of composite convex functions. Though theoretically converging faster, prior semi-stochastic algorithms are found to suffer from high iteration complexity, which makes them even slower than SGD in practice on many datasets. In our proposed S3GD, the semi-stochastic gradient is calculated based on efficient manifold propagation, which can be numerically accomplished by sparse matrix multiplications. This way S3GD is able to generate a highly-accurate estimate of the exact gradient from each mini-batch with largely-reduced computational complexity. Theoretic analysis reveals that the proposed S3GD elegantly balances the geometric algorithmic convergence rate against the space and time complexities during the optimization. The efficacy of S3GD is also experimentally corroborated on several large-scale benchmark datasets.",
    "creator" : "TeX"
  }
}