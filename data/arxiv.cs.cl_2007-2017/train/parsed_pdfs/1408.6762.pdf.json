{
  "name" : "1408.6762.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Peter Hancox" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "The communication of potential students with a university department is performed manually and it is a very time consuming procedure. The opportunity to communicate with on a one-to-one basis is highly valued. However with many hundreds of applications each year, one-to-one conversations are not feasible in most cases. The communication will require a member of academic staff to expend several hours to find suitable answers and contact each student. It would be useful to reduce his costs and time.\nThe project aims to reduce the burden on the head of admissions, and potentially other users, by developing a convincing chatbot. A suitable algorithm must be devised to search through the set of data and find a potential answer. The program then replies to the user and provides a relevant web link if the user is not satisfied by the answer. Furthermore a web interface is provided for both users and an administrator.\nThe achievements of the project can be summarised as follows. To prepare the background of the project a literature review was undertaken, together with an investigation of existing tools, and consultation with the head of admissions. The requirements of the system were established and a range of algorithms and tools were investigated, including keyword and template matching. An algorithm that combines keyword matching with string similarity has been developed. A usable system using the proposed algorithm has been implemented. The system was evaluated by keeping logs of questions and answers and by feedback received by potential students that used it."
    }, {
      "heading" : "Acknowledgements",
      "text" : "I would like to thank Dr Peter Hancox for his immeasurable help and support throughout this project. I also need to express my thanks to the computer support team for their excellent help and instructions.\nFinally, I feel the need to acknowledge the constant support offered by my parents.\nTable of Contents\nChapter 1 ....................................................................................................................... 9\nIntroduction ................................................................................................................... 9\n1.1 Context .................................................................................................................... 9\n1.2 Aims and Objectives ................................................................................................ 9\n1.3 Achievements ........................................................................................................ 10\n1.4 Methodology.......................................................................................................... 10\n1.5 Contributions ......................................................................................................... 11\n1.6 Outline of Dissertation .......................................................................................... 11\nChapter 2 ..................................................................................................................... 12\nBackground Research .................................................................................................. 12\n2.1 Chatbots ................................................................................................................. 12\n2.2 Existing applications ............................................................................................. 12"
    }, {
      "heading" : "2.2.1 ELIZA ................................................................................................................. 12",
      "text" : ""
    }, {
      "heading" : "2.2.2 A.L.I.C.E ............................................................................................................. 12",
      "text" : "2.3 Learning chatbots ................................................................................................ 123\n2.4 Interaction with humans ........................................................................................ 14\n2.5 Web applications .................................................................................................... 14\n2.6 Web application technologies ................................................................................ 15\n2.6.1 Java ..................................................................................................................... 15\n2.6.2 PostgreSQL......................................................................................................... 15\n2.6.3 Hibernate ............................................................................................................ 15\n2.6.4 Spring ................................................................................................................. 15\n2.6.5 Apache Wicket .................................................................................................... 16\n2.6.6 Javascript ............................................................................................................ 16\n2.6.7 HTML and CSS .................................................................................................. 16\n2.6.8 Third party libraries ............................................................................................ 16\n2.7 Other ideas ............................................................................................................. 16\n2.8 Conclusion ............................................................................................................. 16\nChapter 3 ..................................................................................................................... 18\nAnalysis and Specification .......................................................................................... 18\n3.1 Overview ............................................................................................................... 18\n3.2 Functional Requirements ....................................................................................... 18\n3.3 Non-Functional Requirements .............................................................................. 19\n3.4 Use case model ...................................................................................................... 20\n3.4.1 Actor documentation .......................................................................................... 20\nChapter 4 ..................................................................................................................... 22\nDesign .......................................................................................................................... 22\n4.1 Database design ..................................................................................................... 22\n4.2 Algorithms ............................................................................................................. 23\n4.2.1 Keyword matching ............................................................................................. 22\n4.2.2 String similarity .................................................................................................. 22\n4.2.3 Combination of algorithms ................................................................................. 23\n4.2.4 Spell checker ...................................................................................................... 24\n4.2.5 Natural language parser ...................................................................................... 24\n4.2.6 Google search ..................................................................................................... 24\n4.3 Business logic ........................................................................................................ 26\n4.4 Web Interface ......................................................................................................... 28\nChapter 5 ..................................................................................................................... 30\nImplementation ............................................................................................................ 30\n5.1 Overview ............................................................................................................... 30\n5.2 Database layer implementation ............................................................................. 30\n5.2.1 Hibernate mapping ............................................................................................. 29\n5.2.2 Hibernate configuration ...................................................................................... 30\n5.2.3 Data access objects ............................................................................................. 31\n5.3 Business logic layer implementation ..................................................................... 33\n5.3.1 Business analysis ................................................................................................ 32\n5.4 Presentation layer implementation ........................................................................ 35\n5.4.1 Presentation analysis .......................................................................................... 34\n5.5 User Interface ........................................................................................................ 35\n5.5.1 Chatbot interface ................................................................................................ 34\n5.5.2 Leave feedback ................................................................................................... 35\n5.5.3 Add information ................................................................................................. 36\n5.5.4 View information ................................................................................................ 36\n5.5.5 View feedback .................................................................................................... 37\n5.5.6 View logs ............................................................................................................ 37\nChapter 6 ..................................................................................................................... 39\nTesting and Evaluation ................................................................................................ 39\n6.1 Testing ................................................................................................................... 39\n6.1.1 Overview ............................................................................................................ 38\n6.1.2 Unit and integration testing ................................................................................ 38\n6.1.3 Performance testing ............................................................................................ 39\n6.1.4 Security testing ................................................................................................... 40\n6.2 Evaluation .............................................................................................................. 42\n6.2.1 Overview ............................................................................................................ 41\n6.2.2 Question categories ............................................................................................ 41\n6.2.3 User evaluation ................................................................................................... 42\n6.2.4 Survey ................................................................................................................. 42\n6.2.4.1 Initial results .................................................................................................... 43\n6.2.4.2 Final results ..................................................................................................... 44\nChapter 7 ..................................................................................................................... 47\nSummary ...................................................................................................................... 47\n7.1 Achievements ........................................................................................................ 47\n7.2 Limitations ............................................................................................................. 47\n7.3 Future work ........................................................................................................... 48\n7.4 Conclusions ........................................................................................................... 49\nReferences ................................................................................................................... 50\nAppendix A Project proposal ....................................................................................... 52\nAppendix B How to run the system ............................................................................ 54\nAppendix C Example Conversation ............................................................................ 56\nAppendix D Feedback ................................................................................................. 57\nFigures\nFigure 1.1 Waterfall model .................................................................................................................. 8 Figure 2.1 A sample conversation with ELIZA ................................................................................. 11 Figure 2.2 A sample conversation with ALICE ................................................................................. 12 Figure 2.3 Three Tier Architecture ..................................................................................................... 14 Figure 3.1 Use case diagram .............................................................................................................. 18 Figure 4.1 Entity Relationship diagram ............................................................................................. 20 Figure 4.2 Jaro-Winkler code walk through ...................................................................................... 24 Figure 4.3 Business Logic Implementation ....................................................................................... 25 Figure 4.4 Business Logic Interface .................................................................................................. 28 Figure 4.5 Web interface .................................................................................................................... 26 Figure 4.6 Web interfaces .................................................................................................................. 27 Figure 5.1 Java persistent object ........................................................................................................ 29 Figure 5.2 XML mapping .................................................................................................................. 29 Figure 5.3 Hibernate mapping configuration ..................................................................................... 30 Figure 5.4 Hibernate database configuration ..................................................................................... 30 Figure 5.5 Feedback data access object interface .............................................................................. 31 Figure 5.6 Feedback data access object implementation ................................................................... 31 Figure 5.7 Chatbot service interface .................................................................................................. 32 Figure 5.8 Sentence parse partial implementation ............................................................................. 32 Figure 5.9 Spring security .................................................................................................................. 33 Figure 5.10 Spring Integration with Wicket....................................................................................... 33 Figure 5.11 Chatbot ............................................................................................................................ 34 Figure 5.12 Feedback ......................................................................................................................... 34 Figure 5.13 Add information .............................................................................................................. 35 Figure 5.14 View information ............................................................................................................ 35 Figure 5.15 View feedback ................................................................................................................ 36 Figure 5.16 View logs ........................................................................................................................ 36 Figure 6.1 Performance testing stages ............................................................................................... 38 Figure 6.2 Initial log results ............................................................................................................... 42 Figure 6.3 Final log results ................................................................................................................ 43\nTables\nTable 3.1 Actor documentation ......................................................................................................... 19 Table 4.1 Keyword matching ............................................................................................................. 21 Table 4.2 String similarity .................................................................................................................. 21 Table 4.3 Combination of keyword matching and string similarity .................................................. 22 Table 6.1 Unit and Integration testing ................................................................................................ 38 Table 6.2 Security testing ................................................................................................................... 39 Table 6.3 Initial logs ........................................................................................................................... 42 Table 6.4 Final logs ............................................................................................................................ 43\nChapter 1\nIntroduction\nThis chapter covers an introduction to the project including the context, a description of aims and objectives, a description of what has been achieved, contributions and the structure of the report."
    }, {
      "heading" : "1.1 Context",
      "text" : "Although the admissions process works properly as it is, it is very difficult and time consuming to contact a member of staff of the university. However, the problem would be partially solved if the applicant could talk to a convincing chatbot, able to respond to their concerns with information about admissions, booking accommodation, paying fees in instalments and what pre-sessional courses are on offer.\nThe chatbot should be able to communicate with a user in a way similar to the following:\nChatBot: Hello how can I help you? User: What is the minimum score of IELTS required for entry into MSc Computer Science? ChatBot: The minimum requirement is a total score of 6.0 with no less that 5.5 in any section. User: What other test is accepted by the department? ChatBot: We also accept TOEFL and the certificate of Proficiency of the University of Cambridge. User: What are the entry requirements for the MSc in Computer Security? ChatBot: To enter the programme, you need to have at least an Upper Second Class (2.1) degree or an international equivalent in Computer Science or a closely related discipline and a solid foundation in programming."
    }, {
      "heading" : "1.2 Aims and Objectives",
      "text" : "The aim of this project is to contribute to the solution of the problem of direct communication between applicants and the university.\nThe main objectives of the project are as follows:\nDatabase: To develop a database were all the relevant information about questions, answers, keywords, logs and feedback will be stored.\nAlgorithm: To develop a keyword matching algorithm and a string distance comparison algorithm and combine them in order to retrieve the best possible answer.\nInterface: To develop a web interface which aims to give the ability to potential students and their families to submit questions in a chatbot and get convincing replies. The web system can be hosted on any computer that supports an operating system on which the Java Virtual machine will be able to load. Furthermore the Hibernate, Spring, Apache Wicket, Lingpipe, the Jazzy spelling, the Stanford NLP parser and Google search libraries should be available."
    }, {
      "heading" : "1.3 Achievements",
      "text" : "The following goals were achieved:\n Investigated a range of algorithms for solving the problem of direct communication with the university and developed an algorithm that combines the use of keyword matching with\nstring distance.\n Designed and implemented a usable chat system, which has been extended after being evaluated by users.\n Evaluated the extended system with users. The system was used by potential students of the university.\n Completed a literature research in order to learn more about natural language processing, investigated existing tools and established the requirements."
    }, {
      "heading" : "1.4 Methodology",
      "text" : "The design and development of the system followed the waterfall model as described below.\nThe waterfall model follows a series of processes, which are used during development. Usually the stages will require the gathering of requirements and their analysis. The design of the system is the next stage, followed by coding the actual system. Then evaluation, testing and debugging, if necessary, is the next step. Finally the system will either be accepted and therefore maintained or rejected. It is vital to move to the next process of the waterfall model if the previous step has been completed."
    }, {
      "heading" : "1.5 Contributions",
      "text" : "A number of novel concepts have been incorporated to the system. A keyword matching algorithm has been used in combination with a string similarity algorithm to provide a better reply and is described in sections 4.2.1, 4.2.2 and 4.2.3. Also the Stanford parser has been used to analyse the structure of the given sentence as described in section 4.2.5. Finally the system has been evaluated using feedback and logs from potential students that used it, described in section 6.2."
    }, {
      "heading" : "1.6 Outline of Dissertation",
      "text" : "This report is divided into several chapters.\nChapter two covers the background research, which gives an overview of chatbots, interactions of chatter-bots with humans, matching algorithms and current systems. Chapter three gives and overview and covers the requirements of the system. Chapter four covers the design of the system. It includes the database design, an explanation of the algorithms and how they work. It goes on to explain the functionality provided by the system for the users and the administrator. Chapter five covers the implementation of the system. The system is described with further details on the technologies used. Chapter six contains the evaluation and testing of the final system. Chapter seven is the conclusion of the project. It contains a summary, the main achievements, its limitations and future work.\nChapter 2\nBackground Research\nThis chapter contains the background research about topics relevant to the admissions communication. It presents an overview of chatbots and their interaction with humans. Furthermore the keyword matching and the template matching algorithms are mentioned, followed by real world examples of their use."
    }, {
      "heading" : "2.1 Chatbots",
      "text" : "A chatbot is a program that is used to participate in conversations with humans. It uses an appropriate interface for input and output and with the use of AI techniques it can provide realistic answers so the user will think that the communication taking place is with another human. The implementation of such systems varies from using keyword matching, string similarity or complex natural language processing techniques. More sophisticated chatbots could learn from the user input. Nowadays chat bots are used widely in web applications in order to provide help or information when it is asked by the users.\n“Chatbots are computer programs that interact with users using natural languages[21].”"
    }, {
      "heading" : "2.2 Existing applications",
      "text" : "Chatbots are used in many organisations instead of humans when this is possible. Most of the time systems like that are based on the ways ELIZA or ALICE communicates."
    }, {
      "heading" : "2.2.1 ELIZA",
      "text" : "The first chatbot developed was ELIZA [21]. It was developed by Joseph Weizenbaum using a keyword matching technique. The idea was to read the user input and search for certain keywords, if a keyword was found then the answer was retrieved. If a keyword was not present then ELIZA would try, according to specified rules, to get more information from the user to keep the conversation going. Consider the following example to understand how this would work.\nUser: How can I get in touch with my mother?\nThen the chatbot would identify the keyword mother and would find a connection between mother and family and it would respond with a question.\nELIZA: Tell me more about your family\nThe chatbot doesn't understand what it is saying. It only produces results according to rules and in this case there was a rule connecting mother and family. Then it had to produce an answer that would encourage the user to submit another question with the hope of finding a keyword. However most of the time there are some standard replies that ELIZA would use if a keyword is not found. Some examples would be “Very interesting, please go on” or “Can you think of a special example?”\nThe following figure gives a good example of chatting with ELIZA."
    }, {
      "heading" : "2.2.2 A.L.I.C.E",
      "text" : "ALICE was implemented by Richard Wallace in 1995[21]. It uses pattern matching and stores the information in Artificial Intelligence Mark-up Language, or else known as AIML, files. An AIML file is similar to an XML file that was developed to store pattern knowledge for chatbots. There are three types of AIML categories, atomic categories, default categories and recursive categories, which are described below.\nAtomic categories: Is a type of AIML category where there is an exact match.\n<category>\n<pattern>What is your name</pattern> <template>My name is Nick</template>\n</category>"
    }, {
      "heading" : "In the above example if the user submits “What is your name” then the chatbot will reply with “My name is Nick”.",
      "text" : "Default categories: Is a type of AIML category where the use of a wild character such as * is used to match any input.\n<category>\n<pattern>What is *</pattern> <template>It is my name</template>\n</category>\nIf ALICE does not find a solution using the first category it will proceed to the second. In this case if a user submits “What is a name” then ALICE will do a check until the wild char and if there is a match it will come with the answer.\nRecursive categories: Is a type of an AIML category where special tags are used to refer to a recursion to convince the user to be more specific.\n<category>\n<pattern>Do you know what the * is</pattern> <template>It is my name <srai>What is <star/></srai>\n</template> </category>\nIn this case the wild character * is used to reduce the input submitted by the user. If the user submits “Do you know what the time is” then this becomes “What is the time”.\nThe following figure gives an example of a conversation between a human and ALICE.\nWhen a user submits a question then any relevant punctuation is removed and the sentence goes through the categories to find the longest pattern match. The question “Can you tell me the time, using hours, minutes and seconds?” will become» Can you tell me the time using hours minutes and seconds” and then it will search to find the longest match. When the match is found then it will be forwarded to the output. However ALICE does not have the ability to learn and can only come with data that exist in its database."
    }, {
      "heading" : "2.3 Learning chatbots",
      "text" : "Learning chatbots have the ability to learn from user input. The intelligence of the chatbot is based on specified rules and by assuming that the user will give a correct answer. There are two types of learning and both use the same learning rules. The first one will understand what the user said, will store it for the current session and will reply with that answer if the user asks about. The second one will store the information in its database and will reply with that answer for any user. Certain rules can be specified to understand from previous user input if the possibility of a user saying the truth is high or not and decide to store the information for future users. Also questions and answers among users can be saved in the database and compared to identify the possibility of something being true.\nThe following conversation gives an example of the learning procedure.\nUser: How many lecturers are there in the department of computer science? Chatbot: I am sorry but I don't know the answer. Perhaps you can help me learn User: There are 28 lecturers at the department Chatbot: Is this the correct answer? User: Yes Chatbot: Thank you for helping User: How many lecturers are there in the department of computer science? Chatbot: There are 28 lecturers at the department"
    }, {
      "heading" : "2.4 Interaction with humans",
      "text" : "Humans believe that the concept of a chatbot is not realistic and that a chatbot will not be able to provide satisfying answers. Most of the time chatbots are being developed to serve certain purposes and if a human tries to trick the chatbot it is likely that he will succeed. Moreover humans do not think that a computer program will be able to satisfy their needs and they do not even try to interact. Also if a human is aware that a chatbot has extensive knowledge then he will be more demanding. In the case that we have to convince a human that the conversation is taking place with another human then an extensive database has to be used along with certain rules such as answering multiple questions, occurrence of words and sentence parsing.\nThe Loebner prize is a chatbot competition with a number of judges communicating with both humans and chatbots at the same time and is based on a standard Turing test. There are a number of rounds in which a human judge is communicating with a chatbot and with a human that use a computer interface. Based on the answers the judge will have to decide which one is the chatbot and which one is the human, within a five minute limit.\nAnaphora resolution is a very important aspect for a human like chatbot. It is a way of finding to what an expression refers.\nWe found a room under the university accommodation, but it didn't have an en-suite bathroom.\nIt is clear for a human that the bathroom refers to the room. However it would be more difficult for a chatbot to understand. However there are cases that an expression can become complex and therefore difficult to understand."
    }, {
      "heading" : "I accepted my offer to the university because it was unconditional.",
      "text" : ""
    }, {
      "heading" : "I accepted my offer to the university because it was one of the top.",
      "text" : "In the first case the expression refers to the offer, whereas in the second case refers to the university."
    }, {
      "heading" : "2.5 Web applications",
      "text" : "The classic architecture is the three tier architecture as described in Figure 2.3. The advantages of using this type of model is that the functionality is distributed across three independent systems and also that any of the tier can be replaced or upgraded independently if the requirements or the technology change."
    }, {
      "heading" : "2.6 Web application technologies",
      "text" : "A number of technologies and libraries were investigated for the purpose of development of this project and the following were identified as the ones to be used for creating the system."
    }, {
      "heading" : "2.6.1 Java",
      "text" : "Java is an object oriented programming language that can be used to develop software that it can run on a variety of operating systems without modification. Moreover it is simple to use language, with a large number of APIs, sufficient documentation and it is free."
    }, {
      "heading" : "2.6.2 PostgreSQL",
      "text" : "PostgreSQL is an open source relational database management system. It has been chosen because it is supported by a variety of operating systems, it works efficiently with increasing load and has many advanced features. Furthermore there are a number of command line, web and GUI front end tools that can be used to manipulate databases."
    }, {
      "heading" : "2.6.3 Hibernate",
      "text" : "Hibernate is an open source object-relational mapping set of APIs for the Java language. The purpose of Hibernate is to map the problem of mismatch between relational database systems and object. The idea is to have a Java class for each table and manipulate the objects created by the classes that map the tables. Moreover its thorough documentation and the fact that it is lightweight make it a wise choice."
    }, {
      "heading" : "2.6.4 Spring",
      "text" : "Spring is a lightweight open source application framework that can be easily used with other frameworks. It has a number of features that make it essential to use. There is a centralized configuration file where Java beans can be created, transactions can be handled, without having to manage each transaction separately and security can be managed. Data access objects can be used on top of the Hibernate, which reduces errors and simplifies the development process. Testing application code written using Spring is easier than other similar technologies."
    }, {
      "heading" : "2.6.5 Apache Wicket",
      "text" : "Apache Wicket is a Java, component based, web application framework that is easy to integrate with Spring and Hibernate. It provides a clear separation between static HTML and dynamic Java parts of the presentation layer. It allows the creation of reusable components. Wicket provides authorization roles that can be easily placed on top of each page. Also errors are identified during the compilation process."
    }, {
      "heading" : "2.6.6 Javascript",
      "text" : "Javascript is a scripting, client-side, programming language. It can be used to provide encase the functionality of HTML pages. It can be used for various purposes such as setting character limitations on text areas."
    }, {
      "heading" : "2.6.7 HTML and CSS",
      "text" : "HTML is the standard mark-up language used for the development of web interfaces. It must be used in combination with CSS, which is responsible for the layout of the HTML components.\nThe CSS files have been based on the CSS files developed by Mike Stenhouse[12]."
    }, {
      "heading" : "2.6.8 Third party libraries",
      "text" : "The Jazzy spelling Java API has been used and requires an interaction with a local dictionary file in order to provide a spelling correction if necessary. The Google search Java API has been used and requires communication with the Google search server on user request. Also the lingpipe Java natural language processing API has been used for calculating the string similarity. The Stanford natural language parser has been used for the analysis of a sentence and validity checking."
    }, {
      "heading" : "2.7 Other ideas",
      "text" : "A combination of the keyword matching algorithm with the string similarity algorithm should be used. The keyword matching will start identifying keywords and retrieve the answer that has the most keywords. In the case that the same number of keywords is found in more than one answer or there are no keywords then the String similarity algorithm will run to identify the which question is most similar to the one entered and retrieve the answer."
    }, {
      "heading" : "2.8 Conclusion",
      "text" : "From the information gathered from the research the strongest points and weaknesses of each have been identified and a list of desired features that should be in the system has been created. Finally the conclusion was that the system should contain a combination of the keyword matching with the String similarity algorithm, a customized google search option and a spell checker, log and feedback functionality. Furthermore an administration part should be created where the administrator will be able to add, update and delete information related to the system.\nChapter 3\nAnalysis and Specification\nThis chapter contains an overview, a system proposal and a thorough analysis of functional, nonfunctional requirements and users of the system."
    }, {
      "heading" : "3.1 Overview",
      "text" : "The role of the system is to provide a chatbot that will be able to answer questions related to the admission procedure. It will provide a web interface for the users to interact with the system and an administration interface.\nA user is anyone who would like to visit the website and engage in a conversation. As well as talking the user should be able to submit a log of whether he is satisfied with an answer and produce a link. Other than communicating, the user should be able to rank the system. The rank of the system should be a five star ranking system where one is poor and 5 is excellent. A user should also be able to write a review using the feedback form.\nThe administrator of the system shall be able to log in using a user name and a password. The responsibility of the administrator will be to maintain the system by adding questions and answers to the database and by updating current information sets when necessary. Furthermore he should be able to view the user ranking, feedback messages and logs.\nThe system shall provide its users with spell checking suggestions on screen, when they make such errors. Moreover the parsing of sentences will avoid sending to the system words that do not form a sentence.\nThere are several security issues which need to be taken into consideration when designing the system. These include personal and sensitive information. The data should not be accessed without authorisation and authentication. Disclosure or leak of data should be protected against various types of attacks and be encrypted and password protected.\n3.2 Functional Requirements\n1. Chatting:\na. The system should allow users to chat. b. The system shall inform the user if an answer is not available. c. The system shall inform the user about spelling mistakes. d. The system shall inform the user about the validity of the sentence.\n2. Searching:\na. The system should allow users to search for information about admissions. b. The system should allow users to search for information about tuition fees. c. The system should allow users to search for information about accommodation.\n3. Logs:\na. The system should maintain a log of the current question and answer if the user is not\nsatisfied.\n4. Feedback:\na. The user should be able to leave feedback, which is comprised of a text message and a\nrating.\n5. Administrative system\na. Information management: The administrator should be able to to add, update and delete\nquestions, answers and keywords.\nb. Log management: The administrator should be able to view and delete logs.\nc. Feedback management: The administrator should be able to view and delete feedbacks."
    }, {
      "heading" : "3.3 Non-Functional Requirements",
      "text" : "1. User Interface:\na. The system shall maintain an easy to use interface across all functionality and for all users b. The clients’ user interface should be compatible with all commonly used browsers, such as Internet explorer, Firefox, Google chrome and Safari.\n2. Scalability:\na. The system shall be able to scale based on the number of users using the system.\n3. Security:\na. The administrative system should be protected from unauthorized access. b. The database should protected from attacks and unauthorized access. c. The interface should be protected from attacks. d. All passwords should be stored as a secure hash of the administrator password.\n4. Third party interactions:\na. The system should be able to interact with the Google spelling server, which handles the spelling. b. The system should be able to interact with the Google search server, which is used for the customized search on the admissions website.\n5. Portability:\na. The system should run on a variety of operating systems that support the Java language. b. The system should run on a variety of hardware.\n6. Maintainability:\na. The system should be easy to maintain. b. There should be a clear separation of HTML and Java interface code. c. There should be a clear separation between the interface and the business logic code. d. There should be a clear separation between the data access objects that map the database\nand the business logic code.\n7. Exception handling:\na. Exceptions should be reported effectively to the user if they occur.\n8. Ethics:\na. The system shall not store or process any information about its users."
    }, {
      "heading" : "3.4 Use case model",
      "text" : "The use case diagram describes the functionality of the system as designed from the requirements and can be found below."
    }, {
      "heading" : "3.4.1 Actor documentation",
      "text" : "Chapter 4\nDesign This chapter outlines the design of the system. It comprises a database, a combination of two algorithms, the business logic and the web interface. The system includes interfaces for users and an administrator."
    }, {
      "heading" : "4.1 Database design",
      "text" : "The design of the database aims to keep it as simple and efficient as possible. The user_roles table will hold the user name and a role name, the roles table will store a description of each role and an id, the chatbotuser table will store the user details, the information table will store the questions, answers and keywords, the fdback table will store the feedback received and the log table will store the logs.\nThe figure below shows the entity relationship diagram designed for the database of the system."
    }, {
      "heading" : "4.2 Algorithms",
      "text" : ""
    }, {
      "heading" : "4.2.1 Keyword matching",
      "text" : "The keyword matching algorithm will attempt to identify keywords in a sentence. In the case that one or more keywords are found in the user's input text then an answer will be retrieved. However, in the case that the same number of found keywords exist as keys for more than one answer then there is a deadlock. Again a deadlock occurs in the case that there are no keywords.\nConsider the following example in order to understand better how the keyword matching algorithm works. The table represents a small number of information rows from the database of the system.\nThe user then submits the question: “Does a 2.2 in computer science satisfy the entry requirements for the MSc in computer security?”\nThe algorithm will identify both keywords in the second row and will retrieve the answer."
    }, {
      "heading" : "4.2.2 String similarity",
      "text" : "The string similarity algorithm will try to find similarities between a list of strings and will retrieve the answer that is the closest match to the question submitted by the user.\nConsider the following example in order to understand better how the string similarity algorithm works. The table represents a small number of information rows from the database of the system.\nThe user then submits the question: “Can I pay using visa?”\nThe algorithm will then compare the question of the user with the questions in the system and will respond with a percentage for each, ignoring the keywords, which represents the possibility of similarity between strings. In this case the second question has the closer match with the user submitted question and the answer from that information line will be retrieved.\nThe Jaro-Winkler distance has been used in the development of the algorithm[17]. The figure below gives the code walk through for the Jaro-Winkler distance.\nThe algorithm compares two strings and returns a distance and proximity. The distance is the difference between two strings and the higher its value is, then more the possibility of two strings being irrelevant. The proximity is a value between 0.0 and 1.0. The higher the value returned, the higher the possibility of two strings being the same exists. A string is considered to be a sequence of characters; therefore spaces between words are blank characters and will be checked. Using a loop, the code used in the system checks only the proximity between the string submitted by the user with every question string in the database."
    }, {
      "heading" : "4.2.3 Combination of algorithms",
      "text" : "In order to achieve the best possible outcome we decided to combine the two algorithms. Therefore to the database of the system has been added questions with both answers and keywords and questions with answers but no keywords. For example the keyword matching algorithm will search the keywords and the string similarity algorithm will search all pre-stored questions with or with out keywords. In order to improve this similar questions have been added that have the same answer. Basically if the keyword matching fails then we try to think the way a simple user would think, asking a question. Consider the following example in order to understand better how the combination works.\nThe user then submits the question: “Have you received the pack sent?”\nThen the keyword matching algorithm will run first in order to identify keywords. It will identify one keyword in the first information line, one in the second and none in the third and so a deadlock occurs. In this case the string similarity algorithm will compare the pre-stored questions of the systems with the user's question and it will find that the best match is with the third entry in the table, even though there is no keyword in the database. It will then retrieve the answer of the third one. We can see here that the questions are very similar and have the same answer."
    }, {
      "heading" : "4.2.4 Spell checker",
      "text" : "The system is supported by the jazzy spell checker [20]. The checker will check the sentence before it is submitted to the server. If there is an error then the user will be informed about it and about possible corrections. If it is error free then it will be submitted."
    }, {
      "heading" : "4.2.5 Natural language parser",
      "text" : "The Stanford natural language parser [18] will be used to check is a sentence is valid according to specified rules. If the sentence is not valid then the user is informed and he will have to make the appropriate changes. In the case of our system a sentence is required to have a noun and a verb to be valid. The example below represents how the Stanford parser will analyse a sentence.\nThe user enters the question: “How can I apply?”\nThe parser will parse the sentence and produce a tree as follows:\n(ROOT (SBARQ\n(WHADVP (WRB How)) (SQ (MD can)\n(NP (PRP I)) (VP (VB apply)))\n(. ?)))\nThen the system will check that there is a noun and a verb in the tree. In the case that there is, the question is submitted to the system. In case there is not both a noun and a verb the user is informed and the user's question is not answered. The contribution of the parser is to stop the user from submitting syntactically incorrect questions. The examples below represents syntactically incorrect questions submitted by users, followed by the chatbot reply.\nUser: “Yes and yes not yes” Chatbot: “My name is John.”\nUser: “Tell me about Ph.D.” Chatbot: “Hello there.”"
    }, {
      "heading" : "4.2.6 Google search",
      "text" : "In the case that a user is not satisfied by a system reply then he will be provided with a link from the admissions website. The link will be retrieved using customized Google search, according to the input submitted."
    }, {
      "heading" : "4.3 Business logic",
      "text" : "The business logic of the system is separated in a clear way both from the database and the presentation layer. The following class diagrams describe the business logic of the system. Figure 4.2 des7cribes the implementation diagram and figure 4.3 the implemented interface."
    }, {
      "heading" : "4.4 Web Interface",
      "text" : "The business logic of the system is separated in a clear way both from the database and the presentation layer. The following class diagrams describe the web interface of the system.\nChapter 5\nImplementation\nThis chapter gives a description of the system implementation. User and administrator interfaces are described along with an implementation description of each component."
    }, {
      "heading" : "5.1 Overview",
      "text" : "The system includes a user interface with the following options: Engage in a conversation, produce a customised link and leave feedback. The administration interface provides the options to add questions, answers and keywords. View, update and delete questions, answers and keywords. View and delete logs. View and delete feedback. The three tier architecture has been selected and described in section 2.4. This particular architecture gives the ability to develop a web application in a systematic way, where the presentation layer is separated from the application layer and the data layer. This makes sure that when a change occurs in one of the tiers the other two are not affected."
    }, {
      "heading" : "5.2 Database layer implementation",
      "text" : "The first layer of the three tier architecture is the data layer, which in this case is a database. This can be achieved by using and configuring Hibernate and Spring. First a number of Java persistent objects and hibernate mapping files need to be created, followed by their configuration in the spring container, regarding the creation of the database, the connection and the associated spring data access objects."
    }, {
      "heading" : "5.2.1 Hibernate mapping",
      "text" : "Mapping files have been created and used by hibernate to persist the objects to the database. Each file must be associated with one Java class. The database has five tables, each represented by a Java persistent object and its XML mapping. The code below represents a Java persistent object and its associating mapping XML file, used for the creation of the feedback table."
    }, {
      "heading" : "5.2.2 Hibernate configuration",
      "text" : "To create the database the spring container needs to be aware of the mapping files. This is achieved in the applicationcontext.xml in a bean called sessionFactory. The figure below represents the configuration.\nIn the configuration the database is specified as PostgreSQL and the mapping resources property is used to declare the mapping files.\nIn the applicationcontext.xml the connection properties of the database is also included. The bean with id dataSource is used to configure the connection. The properties include a driver name, a url, a user name, a password and other connection related details. The figure below represents the connection properties."
    }, {
      "heading" : "5.2.3 Data access objects",
      "text" : "A data access object is comprised from an interface and an implementation of that particular interface. Each DAO file is associated with each hibernate mapping file and its associated persistent object. An example of the feedback data access object interface and its implementation is described below."
    }, {
      "heading" : "5.3 Business logic layer implementation",
      "text" : "The business or application logic of a system is considered to be one of the most important aspects. This section aims to give a clear understanding of the logic."
    }, {
      "heading" : "5.3.1 Business analysis",
      "text" : "The business logic of the system is made up using two classes, chatbotService which is an interface and chatbotServiceImplementation which is the implementation of the interface. Every functional part of the system is implemented using an appropriate method. Each method is called from the\npresentation layer when this is necessary. In addition spring security has been used to ensure that users have access only to methods that they are supposed to. The following image represents a partial part of the interface.\nThe following image gives a partial description of the sentence parsing implementation method as found in the chatbot service implementation.\nThe following image gives a description of the spring security used in the system. It is described in the chatbot service security bean in the applicationcontext.xml. In the properties it is specified which methods can be accessed by the admin only."
    }, {
      "heading" : "5.4 Presentation layer implementation",
      "text" : "This sections aims to give an outline of how the interface was created and how it interacts with the business logic."
    }, {
      "heading" : "5.4.1 Presentation analysis",
      "text" : "The presentation layer has been developed using Apache wicket and HTML, which aims to give a clear separation between the template and the business logic. This is achieved by using appropriate wicket ids in the HTML code and give actions to these components in the Java code were the id is associated. Moreover when an action needs to be provided the appropriate method is called from the chatbot service interface. In order to achieve that a bean needs to be declared in the applicationcontext.xml as shown below. The bean is called wicket application and then chatbot service is instantiated. This gives us the ability to call the chatbot service interface in the presentation and subsequently call any of the authorised methods."
    }, {
      "heading" : "5.5 User Interface",
      "text" : "The final system includes a web interface with the following options: Chat, Login, Leave feedback, add information, update information, delete information, view and delete feedback and view and delete logs. This sections shows the interface of the system."
    }, {
      "heading" : "5.5.1 Chatbot interface",
      "text" : "The home page of the system where the user can engage in a conversation is shown below."
    }, {
      "heading" : "5.5.2 Leave feedback",
      "text" : "The feedback page of the system where the user can leave a mark and feedback message is shown below."
    }, {
      "heading" : "5.5.3 Add information",
      "text" : "The add information page of the system where the administrator can add questions, answers and keywords is shown below."
    }, {
      "heading" : "5.5.4 View information",
      "text" : "The view information page of the system where the administrator can view, update and delete questions, answers and keywords is shown below."
    }, {
      "heading" : "5.5.5 View feedback",
      "text" : "The view feedback page of the system where the administrator can view and delete feedback messages is shown below."
    }, {
      "heading" : "5.5.6 View logs",
      "text" : "The view logs page of the system where the administrator can view and delete log messages is shown below.\nChapter 6\nTesting and Evaluation This chapter is divided into two sub chapters. The first part describes the testing of the system and the test cases. The second part describes how the system was evaluated."
    }, {
      "heading" : "6.1 Testing",
      "text" : "It is vital in a software system that it behaves as expected. To ensure that the system and its components will behave as required a number of tests was taken."
    }, {
      "heading" : "6.1.1 Overview",
      "text" : "Every unit of the system was tested to make sure that the actual result of its operation was what we expected. Furthermore when every unit was integrated with other units during the development it was tested again to check its operation with other system units."
    }, {
      "heading" : "6.1.2 Unit and integration testing",
      "text" : "A testing strategy known as unit and integration testing has been used to check that the system behaves as expected. The testing strategy was based on the functionality and the requirements of the system. The testing table below gives a precise description of the tests that took place.\nTest case id Test description Expected result Actual result Result\nTC001 Ask a question Provide answer Answer provided PASS\nTC002 Ask a question\nwith a spelling error\nSpell checker identified the error Spell checker identified the error\nPASS\nTC003 Enter an invalid\nsentence\nSentence parser identified the error Sentence parser identified the error\nPASS\nTC004 User satisfied by\nthe answer\nNothing happened Nothing happened PASS\nTC005 User not satisfied\nby the answer\nA log of the question and answer kept and a relevant link provided A log of the question and answer kept and a relevant link provided\nPASS\nTC006 User submits\nfeedback mark and message\nFeedback submitted\nFeedback submitted\nPASS\nTC007 Administrator logs\nin\nLog in successful Log in successful PASS\nTC008 Administrator Information added Information added PASS"
    }, {
      "heading" : "6.1.3 Performance testing",
      "text" : "Every component developed passed through a performance test to ensure that the system meets certain performance requirements. Finally when each unit was developed and tested then it was integrated with the rest of the system to do a performance test. The figure below describes the stages of performance testing [19].\nEvery component of the system went through each stage of the approached methodology. It was identified that each unit behaved differently as a single entity and differently when it was integrated with other units in respect of speed. The test environment plays a crucial role on the performance of the system. A different result occurs when the system runs on development mode and a different one when the system has been deployed. Moreover the technical specifications of the server that the final system has been deployed play their role as well."
    }, {
      "heading" : "6.1.4 Security testing",
      "text" : "Security testing refers to ensuring that the system will protect its data from unauthorized access and modification and that it will continue to behave as expected. Different security concepts have been used to ensure that the system is secure. Authentication has been used to confirm the identity of someone being either a user or an administrator. Authorisation has been used to ensure that users have access to pages that they are supposed to and that the administrator has an overall control of the system. Access control has been used to achieve that. To make sure that the system is safe from attacks, including SQL injection and XSS, a number of tests took place and are shown below."
    }, {
      "heading" : "6.2 Evaluation",
      "text" : "Evaluation is the process where we collect and analyse information in order to find out if the software system developed is effective and efficient."
    }, {
      "heading" : "6.2.1 Overview",
      "text" : "A major part of this project was to build a usable system, based on real world requirements and to evaluate it using potential students. The system managed to satisfy every requirement, including new requirements introduced after feedback received from potential students. However due to time constraints it was not possible to develop an Android part of the project."
    }, {
      "heading" : "6.2.2 Question categories",
      "text" : "For the purposes of analysis, the types of questions that a user could possibly ask have been categorised into four main categories.\nRelevant question: A relevant question refers to a valid question. The answer exists in the database and the algorithm is able to retrieve it.\nIrrelevant question: An irrelevant question refers to a question that is not related to the admissions processes and has not been included in the database.\nNo response question: A no response question refers to a valid question, however the answer does not exist at the moment in the database.\nPoor response question: A poor response would be that the answer exists in the database but the algorithm would fail to retrieve it and would come back with an incorrect or irrelevant reply.\nExamples of each of these categories are given below."
    }, {
      "heading" : "A relevant question that a user asked: “What are the entry requirements for the computer security",
      "text" : "MSc?” The reply was correct: “To enter the programme, you need to have at least an Upper Second Class (2.1) degree or an international equivalent in Computer Science or a closely related discipline and a solid foundation in programming.”"
    }, {
      "heading" : "An irrelevant question asked: “Size of university grounds in square miles?”",
      "text" : "The reply was irrelevant: “Yes, with most of the major players such as HP,IBM and Logica. Which is the reply to the question: Are there any links with the industry?”"
    }, {
      "heading" : "A no response question asked: “Where is the toilet?”",
      "text" : "The reply was irrelevant: “The starting dates for the programme are: 2011/12: 26th September 2011, 2012/13: 24th September 2012.It is not possible to join the programme in January or at any other time after the start date.”"
    }, {
      "heading" : "A poor response question asked: “Is it OK to pay my fees using a visa?”",
      "text" : "The reply was poor: “Yes, unless you are from an EU or an EEA country. If you require a visa and have accepted your offer you will receive a cas statement by email soon. The answer for the question existed on the database; however the retrieved answer is the answer to the question: Do I need a visa to study in the UK? “"
    }, {
      "heading" : "6.2.3 User evaluation",
      "text" : "The system was evaluated by asking current applicants from Masters and undergraduate programmes to test it over the WWW. The messages were sent to MSc applicants with:\n1. Unconditional offers (not yet accepted) 2. Unconditional offers (accepted) 3. Conditional offers (not yet accepted) 4. Conditional offers (accepted) 5. Applications that still required references and/or transcripts\nMessages were sent to two sets of MSc applicants:\n1. Feasibility study: 108 emails were sent to 74 applicants with surnames beginning with S or T. 2. Main evaluation: 770 emails were sent to 537 applicants with surnames beginning with any other letter.\nMessages were sent in two sets of undergraduate applicants:\n1. Feasibility study: Emails were sent to 18 applicants with surnames beginning with S or T and who had offers. 2. Main evaluation: Emails were sent to 75 applicants with surnames beginning with any other letter and who had unconditional offers.\nApproximately eighty MSc students used the system and left feedback either using the form on the website or by email. Unfortunately only two undergraduate students used the system. Both positive and negative messages were received from the users. Most of the messages were about the knowledge of the chatbot and not being able to answer a number of questions, because an answer did not exist in the database. Moreover a small number of questions could not be answered by the chatbot because the algorithm could not retrieve the answer. Other replies were referring to the fact that the chatbot can not answer specific questions after acceptance and that the user interface is not of a satisfying level.\nA selection of the feedback messages can be found in appendix D."
    }, {
      "heading" : "6.2.4 Survey",
      "text" : "This section aims to analyse the results collected from the logs and the feedback from the period that the system was online. There are two result sets collected from both undergraduate and postgraduate students. The initial result, that is based on the results collected from an initial 7 day period and from applicants with surnames beginning with S or T, the results of which were used to improve the system and upload it a second time to collect feedback from applicants with surnames beginning with any other letter. The final system was hosted for 15 days.\nFeedback was collected by the feedback page of the system, where the user could give a 1-5 scale score and leave comments if desired, and by emails sent by the applicants.\nThe tables and pie charts in the initial results and final results sections below, show the user response when they felt the system had failed. They do not represent the performance of the whole system."
    }, {
      "heading" : "6.2.4.1 Initial results",
      "text" : "Through the feedback page of the system four messages were received, with an overall score of 2.75. Furthermore another four messages were received by email that only contained suggestions about the system.\nAn assumption has been made through the feedback received and by the number of logs that approximately 10 people have used the system. The table below represents the categories and the number of questions not answered by the system for each category.\nThe pie chart below represents the percentages from the number of logs from the database of the system, during its first use.\nAfter the initial use and by careful consideration of the feedback messages a number of changes were made and a final system was introduced. The main changes after the initial evaluation of the system were:\nNatural language parsing: It was decided that the use of a sentence parser was necessary for the system, the parser would analyse the structure of a sentence and identify that a noun and a verb exists, thus avoiding submitting syntactically incorrect questions to the system. After careful consideration the Stanford parser was chosen.\nDatabase enrichment: After the initial use it was clear that the information in the database was not\nof a satisfactory level and more data had to be added to it. A high number of relevant admission questions found in the logs and a response did not exist in the database."
    }, {
      "heading" : "6.2.4.2 Final results",
      "text" : "Through the feedback page of the system thirteen messages were received, with an overall score of 2.53. Furthermore another twenty two messages were received by email that only contained suggestions about the system.\nAn assumption has been made through the feedback received and by the number of logs that approximately 50 people have used the system. The table below represents the categories and the number of questions not answered by the system for each category.\nThere were three cases for which a relevant answer was provided, however the user was not satisfied.\nThe pie chart below represents the percentages from the number of logs from the database of the\nsystem, during the final use.\nThe suggestions from the final feedback have been taken into consideration and the most important ones that will make a better system. These include:\nUser Interface: The user interface should be more interactive and include more details.\n2%\n39%\n39%\n20%\nDatabase enrichment: After the initial use it was clear that the information in the database was not of a satisfactory level and more data had to be added to it. A high number of relevant admission questions and answers were added, however there is still much to be added.\nPrecise answers: Answers must be more specific and include more details.\nInformation colour: The colour of the question and the answer must be different in the chatbot text area.\nMore details regarding future work can be found in section 7.3.\nChapter 7\nSummary This chapter refers to the summary and conclusion. Firstly it discusses the positive points of the system, followed by its limitations, future work and conclusions."
    }, {
      "heading" : "7.1 Achievements",
      "text" : "A number of positive points were identified. A working system was developed using Java and a number of third party libraries. The system was uploaded on two occasions on the schools web server. The first time was used by a small number of potential students, which left feedback and some modifications took place. The second time a larger number of potential students used the system and feedback was taken. An interesting part was the logs kept by the system that revealed how people interact with a chatbot.\nThe fact that the system used a spell checker is considered to be a positive aspect, since the possibility of retrieving the wrong answer due to an error is reduced. Moreover a sentence parser was used to inform the user if a sentence is valid or not, before submitting. A customized google search functionality that provides a link relevant to the question, if the user was not happy by the answer and a log of the question and the answer is kept at this stage. Moreover the user has the option to submit a feedback message. Another positive thing is that the web application is dynamic and has an administrator interface. An administrator has the option to log in and make appropriate changes in a number of ways. The administrator has the option to add information to the database, such as questions, answers and keywords. Information already in the system can be viewed, updated and deleted. Also the option to view feedback messages and delete them is available. The option to view and delete logs is also available. Another positive aspect is that the system is secure from unauthorized access and from various attacks.\nThe results gathered from the users helped to identify the limitations of the system and make changes for a number of them, when time permitted. The evaluation results in combination with the testing strategy used helped to make the system as effective as possible."
    }, {
      "heading" : "7.2 Limitations",
      "text" : "A limitation on the algorithm of the system was found after evaluation and testing. The fact is that the possibility of not retrieving the correct answer exists. A small number of the logs were about this problem. Moreover potential students want to know about a different number of things and not everything is covered in the database. A problem is that the system has no memory and when a user asks the same question for a number of times the answer remains the same. Anaphora resolution is not present, which would be useful in some situation when a user refers to a previous question. However anaphora resolution would require a chatbot memory to be available. A limitation in the spell checking is that the system will suggest a word for a spelling error; however the user will have to change that manually and submit the question again. Although there might be a number of questions that do not require a verb the sentence parser will reject every question that does not contain a noun and a verb and the user will have to restructure the sentence and resubmit it. Regarding the Google customised search the links provided are not hyper linked. The fact that the system is usable was an achievement however the user interface should be improved and be more interactive."
    }, {
      "heading" : "7.3 Future work",
      "text" : "A number of different algorithms should be implemented, tested and evaluated. Template matching should be a high priority algorithm. Furthermore algorithms could be used in combination and specify a percentage for each. A possible solution would be to upload to the web server each implementation separately and collect feedback from users. This will make easier to identify the limitations of each algorithm and come with the best solution that can also be a combination of two or more algorithms. There is also a different number of factors that should be taken into consideration except the retrieval, such as speed and compatibility. Also more advanced natural language processing techniques if used will help to identify a possible answer. Anaphora resolution will help to identify when a user refers to a previous question or answer, which requires the user of a chatbot memory. A number of techniques such as statistical parsing and analysis of the sentence structure will help to identify the meaning of a sentence and provide better answers. Knowledge based information retrieval will help to find an answer to a particular question in the frequently asked questions of the admissions website in the case that the algorithm will not find a particular answer. Also the customised google search helps in that direction with the disadvantage that in a number of cases the link provided might not be the one required.\nThe logs that the system keeps is an important aspect of the system, which will help the administrator to find user questions not answered because the particular query and answer does not exist in the database. It is therefore important to maintain a database updated continuously that aims to cover most of the users' queries, both undergraduate and postgraduate. It would be helpful to create a statistics page and database table where the number of correctly answered and not correctly answered questions will be stored. It is very helpful to find how efficient the system is.\nThere is also a number of small changes that could improve the system in general and do not depend on the natural language processing used. The use of a customised search using an actual search text area will be really useful for the user. The interface of the system should be improved and become more interactive and additional information such as links to the university, the school and to the admissions FAQs should be added.\nRegarding the spell checker it would be more useful when an error is found to provide a hyper linked version of the sentence with the error fixed so the user can have a better and faster experience. Also the case when the user asks more than one question at the same time should be considered and the possibilities of using certain rules and provide separate answers or informing the user to submit only one question at at time. Moreover a more comprehensive dictionary should be used to cover more varieties of English and not U.K only.\nThe option to make a chatbot to learn from users exists if certain rules are used and can be divided into two categories. Learn and use only for the current session and if the user asks the same question or a similar then provide the answer. Moreover this information can be saved to the database and be used to reply to future users. This can be done by just saving or by saving and then comparing to other saved information and decides if it is correct or not. However this is not recommended for an admissions system where every answer must be precise.\nAlso a high number of overseas students wish to apply to the university and at the time of the application the level of English that they process might not be sufficient for a conversation. There are two different aspects regarding the use of foreign languages. The user might not be able to provide a syntactically correct sentence and the parser will reject it. However the keyword matching will identify the important words if the sentence goes through the sentence parser to the keyword matching."
    }, {
      "heading" : "7.4 Conclusions",
      "text" : "The main objectives of the project were to develop an algorithm that will be used to identify answers related to user submitted questions. To develop a database were all the related data will be stored and to develop a web interface. The web interface developed had two parts, one for simple users and one for the administrator.\nThe following objectives were subsequently met. A background research took place, which included an overview of the conversation procedure and any relevant chatbots available. A database was developed, which stores information about questions, answers, keywords, logs and feedback messages. A usable system was designed, developed and deployed to the web server on two occasions. An evaluation took place from data collected by potential students of the University. Also after received feedback from the first deployment, extra requirements were introduced and implemented."
    }, {
      "heading" : "Appendix A Project proposal",
      "text" : ""
    }, {
      "heading" : "1. Introduction",
      "text" : "This document covers an introduction to the project including the context, a description of aims and objectives and a sound plan for completion."
    }, {
      "heading" : "2. Context",
      "text" : "Experience has shown that applicants are more likely to choose to come to a department where they believe that they are treated as a valued individual. The opportunity to communicate with on a oneto-one basis is highly valued. However with many hundreds of applications each year, one-to-one conversations are not feasible in most cases.\nAlthough the admissions process works properly as it is, it is very difficult and time consuming to contact a member of staff of the university. However, the problem would be partially solved if the applicant could talk to a convincing chatbot, able to respond to their concerns with information about admissions, booking accommodation, paying fees in instalments and what pre-sessional courses are on offer.\nBy the end of the development, the chatbot application will be able to communicate with a user in a way similar to the following:\nChat Bot: Hello how can I help you? User: What is the minimum score of IELTS required for entry into MSc Computer Science? Chat Bot: The minimum requirement is a total score of 6.0 with no less that 5.5 in any section. User: What other test is accepted by the department? Chat Bot: We also accept TOEFL and the certificate of Proficiency of the University of Cambridge."
    }, {
      "heading" : "3. Aims and Objectives",
      "text" : "The aim of this project is to contribute to the solution of the problem of direct communication between applicants and the university.\nThe main objectives of the project are as follows:\nInformation resource: To develop an information resource were all the relevant information about the questions and the answers will be stored.\nAlgorithm: To develop an algorithm that will be able to identify meaningful keywords in the users' input and provide a suitable answer.\nInterface: To develop a web interface which aims to give the ability to potential students and their families to submit questions in a chatbot and get convincing replies. The web system can be hosted on any computer that supports an operating system on which the Java Virtual machine will be able to load. Furthermore the Apache Wicket and the Google spelling libraries should be available. The porting of the application to the Android platform will require the use of the Android simulator and the Google spelling library.\n4. Project Plan\nActivities\nWeek 1 13-19 June\n1. Research about chatbot systems in general 2. Use ELIZA and A.L.I.C.E 3. Research NLP in Java and try Open Source spell checkers\nWeek 2 20-26 June\n1. Start developing the web interface 2. Research how chatbots react to sub questions\nWeek 3 27 June – 3 July\n1. Begin developing the algorithm and create a basic version 2. Connect the algorithm with the web interface 3. Test the basic system and collect feedback for improvement\nWeek 4 4-10 July\n1. Continue developing the algorithm 2. Finalize the web interface\nWeek 5 11-17 July\n1. A complete version of the web interface is now available 2. Test the algorithm to see how it behaves when the user jumps\nfrom a topic to another in a way that is difficult to understand\nWeek 6 18-24 July\n1. Include an open source spell checker to the application 2. Test the spell checker 3. Continue developing the algorithm\nWeek 7 25-31 July\n1. A complete version of the algorithm is now available and works with the spell checker and the web interface properly 2. Continue testing on the final version to identify possible errors\nWeek 8 1-7 August\n1. Upload the system to the web server 2. Test the system in the web server context to see how it\nbehaves\nWeek 9 8-14 August\n1. Port the system to the android platform 2. Test the android version of the system\nWeek 10 15-21 August\n1. Continue testing both systems 2. Final enhancements of the system\nWeek 11 22-28 August 1. Prepare the presentation"
    }, {
      "heading" : "Appendix B How to run the system",
      "text" : "The system has been developed using Netbeans and it is recommended to open the project directory using Netbeans. The project directory can be found in the CD and it is called “Chatbot”.\nThe files below can be found under the “Chatbot” directory in the “src” directory.\nUnder the default package the ApplicationContext.xml file can be found. It is the Spring configuration file, which uses the hibernate mapping files to create the database, set up the beans, manage transactions, authentication and security. In that file there exists a bean with the name datasource. We have to change a number of properties to comply with our system. The url property needs to be changed to map to our database, the username need to be changed with the username of our database and the password needs to be changed with the password of our database.\n<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroymethod=\"close\">\n<property name=\"driverClassName\" value=\"org.postgresql.Driver\"/> <property name=\"url\" value=\"jdbc:postgresql://localhost:5432/postgres\"/> <property name=\"username\" value=\"postgres\"/> <property name=\"password\" value=\"pilidis4\"/> <property name=\"maxActive\" value=\"4\"/> <property name=\"maxIdle\" value=\"4\"/> <property name=\"minIdle\" value=\"2\"/> <property name=\"maxWait\" value=\"-1\"/> <property name=\"initialSize\" value=\"2\"/> <property name=\"poolPreparedStatements\" value=\"true\"/> <property name=\"maxOpenPreparedStatements\" value=\"100\"/> <property name=\"testOnBorrow\" value=\"true\"/> <property name=\"testOnReturn\" value=\"false\"/> <property name=\"testWhileIdle\" value=\"false\"/> <property name=\"validationQuery\" value=\"SELECT 1+1\"/>\n</bean>\nAfter this is done we have to run the Main file under the /chatbot/ sub directory. The it will pop up a message as shown in the figure below.\nIf the Yes button is clicked then the tables are created and a number of data fill these tables. If the no button is clicked the database tables are deleted if exist. The no button should be clicked if the database has been created by clicking yes and we have made changes so it is necessary to delete it and re create it.\nThe next step is to Clean and build the project and run it.\nThe other directories of the project are as follows: The /chatbot.dao/ subdirectory stores the interfaces of the data access objects that spring uses to access the database.\nThe /Chatbot.dao.hibernate/ subdirectory stores the implementation of the previous interfaces.\nThe /Chatbot.model/ subdirectory stores the persistent classes and the hibernate mapping files.\nThe /Chatbot.page/ subdirectory stores the Java and HTML files for the presentation layer used by wicket.\nThe /Chatbot.service/ stores the chatbot service interface and the chatbot service implementation that contain the business logic of the project.\nFurthermore on the CD the following files can be found:\nThe eng_com.dic is the dictionary used for the spell checker. In the chatbot service implementation file in the spell Checking method the location of this file needs to be specified.\nThe dissertation.odt is the report of the project, written using open office.\nThe dissertation.doc is a Microsoft word version generated from open office.\nThe dissertation.pdf is the pdf version of the report.\nThe front page .odt is the front page of the report."
    }, {
      "heading" : "Appendix C Example Conversation",
      "text" : "The figures below display how an example conversation would appear if a user decided to engage a conversation with the chatbot."
    }, {
      "heading" : "Appendix D Feedback",
      "text" : "User 1\nI have tried the system out and found it to be quite informative, I hope this helps.\nUser 2\nI don't know how helpful this would be to the project, but the questions I asked this bot are (had these when first applied (answered through website)):\nGeneral Comments: It may help to have a follow up question concerning the course chosen when an answer would differ according to masters courses. It also would seem that having mentioned 'Masters', causes a priority above other nouns that may be more specific to the question at hand. There are answers about the actual applying of courses, but often not answers about the specifics of taking the course itself.\nQuestions not answered: Do I have to do research for the project before the summer? / When do I have to do research for the project? When do I have to get a supervisor for the Project? How long do I have to choose the modules? / When do I have to choose modules? Can I repeat modules that I have already completed in my degree?\nExternal Applicants: What computers can I use? Does it cost money to print? What computers can I use? Chat Bot:My name is John What happens if I send in work late? Who can I email about questions I have about the course? How do I ask questions about something in a module?\nUser 3\nFirstly, is the GUI, in my browser ,the interface shows incomplete, as follows:\nI hope this system can use for all browsers.\nSecondly, I hope this system can add a flash in order to guide the user to use.\nThirdly, I hope this system can provide a link to the main page of university and give the user a contact E-mail address.\nActually I think the main interface is too simple, as a user the first feeling is not good.\nIn addition, can you give me a account to test the main function?\nUser 4\nGood day. Quite an impressive project. It does answer correctly properly structured questions especially ones related to admissions, application contact information. There are a few spelling mistakes\ne.g. reply to Can I have a virtual tour of the computing facilities?\nChat Bot:The school is housed in a modern building with 24 hour access a day, 7 days a weak. There are dedicated laboratories for teaching,robotics,medical imaging, a library and a wireless network.\nIs there any reason why the links displayed as answers are not hyper-linked?\nUser 5\nSo far as I can see, the answers that the chat bot has are very limited (maybe this is because the creator hopes the bot to gives general answer only). There are still a lot of rooms to improve, such as the preprocessing (do not suggest words unrelated to the context, such as \"boat\"), variation uses of question words (what, why, where, etc.) and the other words, part of speech tagging, etc. For this bot, I don't think learning is needed, as the information given almost never change for some period, it can be based on rules only.\nUser 6\nI already try the system, I found that the system doesn't accept short phrases such as U instead of You, Also, When I send the QA there was no replay only the system said that your QA will be answered later like that. So,it is slowly\nThat are my comments,I hope it will help you\nUser 7\nI tested the system and here are my observations:\n- It works well but only for very general cases. For instance I tried asking for application deadlines\nfor an MSc in computer Science and I got the entry qualifications to the programme.\n- I like the fact that if you say that your question was not answered you get a link that probably has the information you need.\nThat's all, Otherwise it is a great project."
    } ],
    "references" : [ {
      "title" : "The Essence of Artificial Intelligence",
      "author" : [ "Cawsey", "Alison" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1998
    }, {
      "title" : "Artificial Intelligence: A guide to intelligent systems, 2nd ed",
      "author" : [ "Negnevitsky", "Michael" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2005
    }, {
      "title" : "Enjoying Web Development with Wicket",
      "author" : [ "Tong Ka Iok", "Kent" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2010
    }, {
      "title" : "Software testing fundamentals",
      "author" : [ "Marnie L Hutcheson" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2003
    }, {
      "title" : "University Centre for Machine Translation Chatterbots, Tinymuds, and the Turing Test Entering the Loebner Prize Competition",
      "author" : [ "Michael L. Mauldin", "Carnegie Mellon" ],
      "venue" : "Available at: http://www.aaai.org/Papers/AAAI/1994/AAAI94-003.pdf [Accessed on",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "Chatbots: Are they really useful? Penn state University",
      "author" : [ "Bayan Abu Shawar", "Eric Atwell" ],
      "venue" : "Available at: http://citeseerx.ist.psu.edu/viewdoc/download doi=10.1.1.106.1099&rep=rep1&type=pdf [Accessed on",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "“Chatbots are computer programs that interact with users using natural languages[21].",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 5,
      "context" : "1 ELIZA The first chatbot developed was ELIZA [21].",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 5,
      "context" : "E ALICE was implemented by Richard Wallace in 1995[21].",
      "startOffset" : 50,
      "endOffset" : 54
    } ],
    "year" : 2014,
    "abstractText" : null,
    "creator" : "Microsoft® Word 2013"
  }
}