{
  "name" : "1703.02689.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Exact MAP Inference by Avoiding Fractional Vertices",
    "authors" : [ "Erik M. Lindgren", "Alexandros G. Dimakis" ],
    "emails" : [ "erikml@utexas.edu", "dimakis@austin.utexas.edu", "klivans@cs.utexas.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 3.\n02 68\n9v 1\n[ st\nat .M\nGiven a graphical model, one essential problem is MAP inference, that is, finding the most likely configuration of states according to the model. Although this problem is NP-hard, large instances can be solved in practice. A major open question is to explain why this is true. We give a natural condition under which we can provably perform MAP inference in polynomial time. We require that the number of fractional vertices in the LP relaxation exceeding the optimal solution is bounded by a polynomial in the problem size. This resolves an open question by Dimakis, Gohari, and Wainwright. In contrast, for general LP relaxations of integer programs, known techniques can only handle a constant number of fractional vertices whose value exceeds the optimal solution. We experimentally verify this condition and demonstrate how efficient various integer programming methods are at removing fractional solutions."
    }, {
      "heading" : "1 Introduction",
      "text" : "Given a graphical model, one essential problem is MAP inference, that is, finding the most likely configuration of states according to the model.\nConsider graphical models with binary random variables and pairwise interactions, also known as Ising models. For a graph G = (V,E) with node weights θ ∈ RV and edge weights W ∈ RE , the probability of a variable configuration is given by\nP(X = x) = 1\nZ exp\n(\n∑\ni∈V\nθixi + ∑\nij∈E\nWijxixj\n)\n, (1)\nwhere Z is a normalizing constant.\nThe MAP problem is to find the configuration x ∈ {0, 1}V that maximizes Equation (1). We can write this as an integer linear program (ILP) as follows:\nmax q∈RV ∪E\n∑\ni∈V\nθiqi + ∑\nij∈E\nWijqij\ns.t. qi ∈ {0, 1} ∀i ∈ V\nqij ≥ max{0, qi + qj − 1} ∀ij ∈ E\nqij ≤ min{qi, qj} ∀ij ∈ E.\n(2)\nThe MAP problem on binary, pairwise graphical models contains, as a special case, the Max-cut problem and is therefore NP-hard. For this reason, a significant amount of attention has focused on analyzing the LP relaxation of the ILP, which can be solved efficiently in practice.\nmax q∈RV ∪E\n∑\ni∈V\nθiqi + ∑\nij∈E\nWijqij\ns.t. 0 ≤ qi ≤ 1 ∀i ∈ V\nqij ≥ max{0, qi + qj − 1} ∀ij ∈ E\nqij ≤ min{qi, qj} ∀ij ∈ E\n(3)\nThis relaxation has been an area of intense research in machine learning and statistics. In [33], the authors state that a major open question is to identify why real world instances of Problem (2) can be solved efficiently despite the theoretical worst case complexity.\nWe make progress on this open problem by analyzing the fractional vertices of the LP relaxation, that is, the extreme points of the polytope with fractional coordinates. Vertices of the relaxed polytope with fractional coordinates are called pseudomarginals for graphical models and pseudocodewords in coding theory. If a fractional vertex has higher objective value (i.e. likelihood) compared to the best integral one, the LP relaxation fails. We call fractional vertices that exceed the best integral vertex in objective value confounding vertices. Our main result is that it is possible to prune all confounding vertices efficiently when their number is polynomial. This is surprising, since we also show that enumerating them is computationally intractable.\nOur contributions:\n• Our first contribution is a general result on integer programs. We show that any 0-1 integer linear program (ILP) can be solved exactly in polynomial time, if the number confounding vertices is bounded by a polynomial. This applies to MAP inference for a graphical model over any alphabet size and any order of connection. The same result (exact solution if the number of confounding vertices is bounded by a polynomial) was established by [9] for the special case of LP decoding of LDPC codes [13]. The algorithm from [9] relies on the special structure of the graphical models that correspond to LDPC codes. In this paper we generalize this result for any ILP in the unit hypercube. Our results extend to finding all integral vertices among the M-best vertices.\n• Given our condition, one may be tempted to think that we generate the top M-best vertices of a linear program (for M polynomial) and output the best integral one in this\nlist. We actually show that such an approach would be computationally intractable. Specifically, we show that it is NP-hard to produce a list of the M-best vertices if M = O(nε) for any fixed ε > 0. This result holds even if the list is allowed to be approximate. This strengthens the previously known hardness result [1] which was M = O(n) for the exact M-best vertices. In terms of achievability, the best previously known result (from [1]) can only solve the ILP if there is at most a constant number of confounding vertices.\n• We obtain a complete characterization of the fractional vertices of the local polytope for binary, pairwise graphical models. We show that any variable in the fractional support must be connected to a frustrated cycle by other fractional variables in the graphical model. This is a complete structural characterization that was not previously known, to the best of our knowledge.\n• We develop an approach to estimate the number of confounding vertices of a halfintegral polytope. We use this method in an empirical evaluation of the number of confounding vertices of previously studied problems and analyze how well common integer programming techniques perform at pruning confounding vertices."
    }, {
      "heading" : "2 Background and Related Work",
      "text" : "For some classes of graphical models, it is possible to solve the MAP problem exactly. For example see [32] for balanced and almost balanced models, [15] for perfect graphs, and [30] for graphs with constant tree-width.\nThese conditions are often not true in practice and a wide variety of general purpose algorithms are able to solve the MAP problem for large inputs. One class is belief propagation and its variants [35, 29, 28]. Another class involves general ILP optimization methods (see e.g. [24]). Techniques specialized to graphical models include cutting-plane methods based on the cycle inequalities [26, 19, 27]. See also [16] for a comparative survey of techniques.\nIn [34], the authors investigate how pseudomarginals and relaxations relate to the success of the Bethe approximation of the partition function was done in [34].\nThere has been substantial prior work on improving inference building on these LP relaxations, especially for LDPC codes in the information theory community. This work ranges from very fast solvers that exploit the special structure of the polytope [6], connections to unequal error protection [10], and graphical model covers [18]. LP decoding currently provides the best known finite-length error-correction bounds for LDPC codes both for random [8, 2], and adversarial bit-flipping errors [12].\nThe work most closely related to this paper involves eliminating fractional vertices (socalled pseudocodewords in coding theory) by changing the polytope or the objective function [36, 7, 22]."
    }, {
      "heading" : "3 Provable Integer Programming",
      "text" : "A binary integer linear program is a optimization problem of the following form.\nmax x\ncTx\nsubject to Ax ≤ b\nx ∈ {0, 1}n\nwhich is relaxed to a linear program by replacing the x ∈ {0, 1}n constraint with 0 ≤ x ≤ 1. Every integral vector x is a vertex of the polytope described by the constraints of the LP relaxation, however fraction vertices may also be in this polytope, and fractional solutions can potentially have an objective value larger than every integral vertex.\nIf the optimal solution to the linear program happens to be integral, then this is the optimal solution to the original integer linear program. If the optimal solution is fractional, then a variety of techniques are available to tighten the LP relaxation and eliminate the fractional solution.\nWe establish a success condition for integer programming based on the number of confounding vertices, which to the best of our knowledge was unknown. The algorithm used in proving Theorem 1 is a version of branch-and-bound, a classic technique in integer programming [20] (see [24] for a modern reference on integer programming). This algorithm works by starting with a root node, then branching on a fractional coordinate by making two new linear programs with all the constraints of the parent node, with the constraint xi = 0 added to one new leaf and xi = 1 added to the other. The decision on which leaf of the tree to branch on next is based on which leaf has the best objective value. When the best leaf is integral, we know that this is the best integral solution. This algorithm is formally written in Algorithm 1.\nTheorem 1. Let x∗ be the optimal integral solution and let {v1, v2, . . . , vM} be the set of confounding vertices in the LP relaxation. Algorithm 1 will find the optimal integral solution x∗ after 2M calls to an LP solver.\nCutting-plane methods, which remove a fractional vertex by introducing a new constraint in the polytope may not have this property, since this cut may create new confounding vertices. This branch-and-bound algorithm has the desirable property that it never creates a new fractional vertex.\nNote that warm starting a linear program with slightly modified constraints allows subsequent calls to an LP solver to be much more efficient after the root LP has been solved.\nWe can generalize Theorem 1. We see after every iteration we potentially remove more than one confounding vertex—we remove all confounding vertices that agree with xI0 = 0 and xI1 = 1 and are fractional with any value at coordinate i. We also observe that we can handle a mixed integer program (MIP) with the same algorithm.\nmax x\ncTx+ dT z\nsubject to Ax+Bz ≤ b\nx ∈ {0, 1}n\nAlgorithm 1 Branch and Bound\nInput: an LP {min cTx : Ax ≤ b, 0 ≤ x ≤ 1}\ndef LP(I0, I1): v∗ ← argmax cTx subject to:\nAx ≤ b xI0 = 0 xI1 = 1\nreturn v∗ if feasible, else return null\nv ← LP(∅, ∅) B ← {(v, ∅, ∅)} while optimal integral vertex not found: (v, I0, I1) ← maxB c\nTv if v is integral: return v else: find a fractional coordinate i v(0) ← LP(I0 ∪ {i}, I1) v(1) ← LP(I0, I1 ∪ {i}) remove (v, I0, I1) from B add (v(0), I0 ∪ {i}, I1) to B if feasible add (v(1), I0, I1 ∪ {i}) to B if feasible\nWe will call a vertex (x, z) fractional if its x component is fractional. For each fractional vertex (x, z), we create a half-integral vector S(x) such that\nS(x)i =\n\n \n \n0 if xi = 0 1 2 if xi is fractional 1 if xi = 1\nFor a set of vertices V , we define S(V ) to be the set {S(x) : (x, z) ∈ V }, i.e. we remove all duplicate entries.\nTheorem 2. Let (x∗, z∗) be the optimal integral solution and let VC be the set of confounding vertices. Algorithm 1 will find the optimal integral solution (x∗, z∗) after 2|S(VC)| calls to an LP solver.\nFor MAP inference in graphical models, S(VC) refers to the fractional singleton marginals qV such that there exists a set of pairwise pseudomarginals qE such that (qV , qE) is a cofounding vertex. Since MAP inference is a binary integer program regardless of the alphabet size of the variables and order of the clique potentials, we have the following corollary:\nCorollary 3. Given a graphical model such that the local polytope has VC as cofounding variables, Algorithm 1 can find the optimal MAP configuration with 2|S(VC)| calls to an LP solver."
    }, {
      "heading" : "3.1 Proof of Theorem 1",
      "text" : "The proof follows from the following invariants:\n• At every iteration we remove at least one fractional vertex.\n• Every integral vertex is in exactly one branch.\n• Every fractional vertex is in at most one branch.\n• No fractional vertices are created by the new constraints.\nTo see the last invariant, note that every vertex of a polytope can be identified by the set of inequality constraints that are satisfied with equality (see [4]). By forcing an inequality constraint to be tight, we cannot possibly introduce new vertices.\n3.2 The M-Best LP Problem\nAs mentioned in the introduction, the algorithm used to prove Theorem 1 does not enumerate all the fractional vertices until it finds an integral vertex. Enumerating the M-best vertices of a linear program is the M-best LP problem.\nDefinition. Given a linear program {min cTx : x ∈ P} over a polytope P and a positive integer M , the M-best LP problem is to optimize\nmax {v1,...,vM}⊆V (P )\nM ∑\nk=1\ncTvk.\nThis was established by [1] to be NP-hard when M = O(n). We strengthen this result to hardness of approximation even when M = nε for any ε > 0.\nTheorem 4. It is NP-hard to approximate the M-best LP problem by a factor better than O(n ε\nM ) for any fixed ε > 0.\nProof. Consider the circulation polytope described in [17], with the graph and weight vector w described in [5]. By adding an O(logM) long series of 2 × 2 bipartite subgraphs, we can make it such that one long path in the original graph implies M long paths in the new graph, and thus it is NP-hard to find any of these long paths in the new graph. By adding the constraint vector wTx ≤ 0, and using the cost function −w, the vertices corresponding to the short paths have value 1/2, the vertices corresponding to the long paths have value O(1/n), and all other vertices have value 0. Thus the optimal set has value O(n + M\nn ).\nHowever it is NP-hard to find a set of value greater than O(n) in polynomial time, which gives an O( n\nM ) approximation. Using a padding argument, we can replace n with nε.\nThe best known algorithm for the M-best LP problem is a generalization of the facet guessing algorithm [9] developed in [1], which would require O(mM) calls to an LP solver, where m is the number of constraints of the LP. Since we only care about integral solutions, we can find the single best integral vertex with O(M) calls to an LP solver, and if we want all integral solutions among the top M vertices of the polytope, we can find these with O(nM) calls to an LP-solver, as we will see in the next section.\n3.3 M-Best Integral Solutions\nFinding the M-best solutions to general optimization problems has uses in several machine learning applications. Producing multiple high-value outputs can be naturally combined with post-processing algorithms that select the most desired solution using additional sideinformation. There is a significant volume of work in the general area, see [14, 3] for MAP solutions in graphical models and [11] for a survey on M-best problems.\nWe further generalize our theorem to find the M-best integral solutions.\nTheorem 5. Let V be the M-best vertices (including integral) in the LP relaxation. We can find all integral solutions contained in V with O(n|S(V )|) calls to an LP solver (and potentially more integral solutions outside of V ).\nThe algorithm used in this theorem is Algorithm 2. It combines Algorithm 1 with the space partitioning technique used in [23, 21]. If the current optimal solution in the solution tree is fractional, then we use the branching technique in Algorithm 1. If the current optimal solution in the solution tree x∗ is integral, then we branch by creating a new leaf for every i not currently constrained by the parent with the constraint xi = ¬x ∗ i ."
    }, {
      "heading" : "4 Fractional Vertices of the Local Polytope",
      "text" : "We now describe the fractional vertices of the local polytope for binary, pairwise graphical models, which is described in Equation 3. It was shown in [25] that all the vertices of this\nAlgorithm 2 M-best Integral\nInput: an LP {min cTx : Ax ≤ b, 0 ≤ x ≤ 1} Input: number of solutions M\ndef LP(I0, I1): v∗ ← argmax cTx subject to:\nAx ≤ b xI0 = 0 xI1 = 1\nreturn v∗ if feasible, else return null\ndef SplitIntegral(v, I0, I1): P ← { } for i ∈ n if i /∈ I0 ∪ I1: a ← ¬vi I ′0, I ′ 1 ← copy(I0, I1)\nadd i to I ′a v′ ← LP(I ′0, I ′ 1) add (v′, I ′0, I ′ a) to P if feasible\nreturn P\nv ← LP(∅, ∅) B ← {(v, ∅, ∅)} results ← { } for M iterations: (v, I0, I1) ← maxB c\nTv if v is integral: add v to results add SplitIntegeral(v, I0, I1) to B remove (v, I0, I1) from B else: find a fractional coordinate i v(0) ← LP(I0 ∪ {i}, I1) v(1) ← LP(I0, I1 ∪ {i}) remove (v, I0, I1) from B add (v(0), I0 ∪ {i}, I1) to B if feasible add (v(1), I0, I1 ∪ {i}) to B if feasible\nreturn results\npolytope are half-integral, that is, all coordinates have a value from {0, 1 2 , 1} (see [32] for a new proof of this). Given a half-integral point q ∈ {0, 1\n2 , 1}V ∪E in the local polytope, we say that a cycle\nC = (VC , EC) ⊆ G is frustrated if there is an odd number of edges ij ∈ EC such that qij = 0. If a point q has a frustrated cycle, then it is a pseudomarginal, as no probability distribution exists that has as its singleton and pairwise marginals the coordinates of q. Half-integral points q with a frustrated cycle do not satisfy the cycle inequalities [26, 30], for all cycles C = (VC , EC), F = (VF , EF ) ⊆ C, |EF | odd we must have\n∑\nij∈EF\nqi + qj − 2qij − ∑\nij∈EC\\EF\nqi + qj − 2qij ≤ |FC | − 1. (4)\nFrustrated cycles allow a solution to be zero on negative weights in a way that is not possible for any integral solution.\nWe have the following theorem describing all the vertices of the local polytope for binary, pairwise graphical models.\nTheorem 6. Given a point q in the local polytope, q is a vertex of this polytope if and only if q ∈ {0, 1\n2 , 1}V ∪E and the induced subgraph on the fractional nodes of q is such that every\nconnected component of this subgraph contains a frustrated cycle."
    }, {
      "heading" : "4.1 Proof of Theorem 6",
      "text" : "Every vertex q of an n-dimensional polytope is such that there are n constraints such that q satisfies them with equality, known as active constraints (see [4]). Every integral q is thus a vertex of the local polytope. We now describe the fractional vertices of the local polytope.\nDefinition. Let q ∈ {0, 1 2 , 1}n+m be a point of the local polytope. Let GF = (VF , EF ) be an induced subgraph of points such that qi = 1 2 for all i ∈ VF . We say that GF is full rank if the following system of equations is full rank.\nqi + qj − qij = 1 ∀ij ∈ EF such that qij = 0\nqij = 0 ∀ij ∈ EF such that qij = 0\nqi − qij = 0 ∀ij ∈ EF such that qij = 1\n2\nqj − qij = 0 ∀ij ∈ EF such that qij = 1\n2\n(5)\nTheorem 6 follows from the following lemmas.\nLemma 7. Let q ∈ {0, 1 2 , 1}n+m be a point of the local polytope. Let GF = (VF , EF ) be the subgraph induced by the nodes i ∈ V such that qi = 1 2 . The point q is a vertex if and only if every connected component of GF is full rank.\nLemma 8. Let q ∈ {0, 1 2 , 1}n+m be a point of the local polytope. Let GF = (VF , EF ) be a connected subgraph induced from nodes such that such that qi = 1 2 for all i ∈ VF . GF is full rank if and only if GF contains cycle that is full rank.\nLemma 9. Let q ∈ {0, 1 2 , 1}n+m be a point of the local polytope. Let C = (VC , EC) be a cycle of G such that qi is fractional for all i ∈ VC. C is full rank if and only if C is a frustrated cycle.\nProof of Lemma 7. Suppose every connected component is full rank. Then every fractional node and edge between fractional nodes is fixed from their corresponding equations in Problem 3. It is easy to check that all integral nodes, edges between integral nodes, and edges between integral and fractional nodes is also fixed. Thus q is a vertex.\nNow suppose that there exists a connected component that is not full rank. The only other constraints involving this connected component are those between fractional nodes and integral nodes. However, note that these constraints are always rank 1, and also introduce a new edge variable. Thus all the constraints where q is tight do not make a full rank system of equations.\nProof of Lemma 8. Suppose GF has a full rank cycle. We will build the graph starting with the full rank cycle then adding one connected edge at a time. It is easy to see from Equations 5 that all new variables introduced to the system of equations have a fixed value, and thus the whole connected component is full rank.\nNow suppose GF has no full rank cycle. We will again build the graph starting from the cycle then adding one connected edge at a time. If we add an edge that connects to a new node, then we added two variables and two equations, thus we did not make the graph full rank. If we add an edge between two existing nodes, then we have a cycle involving this edge. We introduce two new equations, however with one of the equations and the other cycle equations, we can produce the other equation, thus we can increase the rank by one but we also introduced a new edge. Thus the whole graph cannot be full rank.\nThe proof of Lemma 9 from the following lemma.\nLemma 10. Consider a collection of n vectors\nv1 = (1, t1, 0, . . . , 0)\nv2 = (0, 1, t2, 0, . . . , 0)\nv3 = (0, 0, 1, t3, 0, . . . , 0)\n...\nvn−1 = (0, . . . , 0, 1, tn−1)\nvn = (tn, 0, . . . , 0, 1)\nfor ti ∈ {−1, 1}. We have rank(v1, v2, . . . , vn) = n if and only if there is an odd number of vectors such that ti = 1.\nProof of Lemma 10. Let k be the number of vectors such that ti = 1. Let S1 = v1 and define\nSi+1 =\n{\nSi − vi+1 if Si(i+ 1) = 1\nSi + vi+1 if Si(i+ 1) = −1\nfor i = 2, . . . , n− 1.\nNote that if ti+1 = −1 then Si+1(i + 2) = Si(i + 1) and if ti+1 = 1 then Si+1(i + 2) = −Si(i + 1). Thus the number of times the sign changes is exactly the number of ti = 1 for i ∈ {2, . . . , n− 1}.\nUsing the value of Sn−1 we can now we can check for all values of t1 and tn that the following is true.\n• If k is odd then (1, 0, . . . , 0) ∈ span(v1, v2, . . . , vn), which allows us to create the entire standard basis, showing the vectors are full rank.\n• If k is even then vn ∈ span(v1, v2, . . . , vn−1) and thus the vectors are not full rank."
    }, {
      "heading" : "5 Estimating the number of Confounding Singleton Marginals",
      "text" : "In Theorem 2, note that S(VC) is the number of fractional singleton marginals qV such that there exists a set of pairwise marginals qE such that (qV , qE) is a confounding vertex. In this case we call qV a confounding singleton marginal. We develop Algorithm 3 to estimate the number of confounding singleton marginals for our experiments section. It is based on the k-best enumeration method developed in [23, 21].\nAlgorithm 3 works by a branching argument. The root node is the original LP. A leaf node is branched on by introducing a new leaf for every node in V and every element of {0, 1\n2 , 1} such that qi 6= a in the parent node and the constraint {qi = a} is not in the constraints for the parent node. For i ∈ V , a ∈ {0, 1 2 , 1}, we create the leaf such that it has all the constraints of its parents plus the constraint qi = a. Note that Algorithm actually generates a superset of the elements of S(VC), since the introduction of constraints of the type qi = 1 2 introduce vertices into the new polytope that were not in the original polytope. This does not seem to be an issue for the experiments we consider, however this does occur for other graphs. An interesting question is if the vertices of the local polytope can be provably enumerated."
    }, {
      "heading" : "6 Experiments",
      "text" : "We consider a synthetic experiment on randomly created graphical models, which were also used in [26, 31, 34]. The graph topology used is the complete graph on 12 nodes. We first reparametrize the model to use the sufficient statistics 1(xi = xj) and 1(xi = 1). The node weights are drawn θi ∼ Uniform(−1, 1) and the edge weights are drawn Wij ∼ Uniform(−w,w) for varying w. The quantity w determines how strong the connections are between nodes. We do 100 draws for each choice of edge strength w.\nFor the complete graph, we observe that Algorithm 3 does not yield any points that do not correspond to vertices, however this does occur for other topologies.\nWe first compare how the number of fractional singleton marginals |S(VC)| changes with the connection strength w. In Figure 6, we plot the sample CDF of the probability that |S(VC)| is some given value. We observe that |S(VC)| increases as the connection strength\nAlgorithm 3 Estimate S(VC) for Binary, Pairwise Graphical Models\nInput: a binary, pairwise graphical model LP\ndef LP(I0, I 1 2 , I1): optimize LP with additional constraints:\nxI0 = 0 xI 1\n2\n= 1 2\nxI1 = 1 return q∗ if feasible, else return null\nq ← LP(∅, ∅, ∅) B ← {(q, ∅, ∅, ∅)} solution ← { } while optimal integral vertex not found: (q, I0, I 1\n2 , I1) ← maxB objective value of q add q to solution remove (q, I0, I 1\n2\n, I1) from B\nfor i ∈ V if i /∈ I0 ∪ I 1 2 ∪ I1:\nfor a ∈ {0, 1 2 , 1} if qi 6= a:\nI ′0, I ′ 1\n2\n, I ′1 ← copy(I0, I 1 2 , I1)\nI ′a ← I ′ a ∪ {i} q′ ← LP(I ′0, I ′ 1\n2\n, I ′1)\nadd (q′, I ′0, I ′ 1\n2\n, I ′1) to B if feasible\nreturn solution\nincreases. Further we see that while most instances have a small number for |S(VC)|, there are rare instances where |S(VC)| is quite large.\nNow we compare how the number of cycle constraints from Equation (4) that need to be introduced to find the best integral solution changes with the number of confounding singleton marginals in Figure 2. We use the algorithm for finding the most frustrated cycle in [26] to introduce new constraints. We observe that each constraint seems to remove many confounding singleton marginals.\nWe also observe the number of introduced confounding singleton marginals that are introduced by the cycle constraints increases with the number of confounding singleton marginals in Figure 3.\nFinally we compare the number of branches needed to find the optimal solution increases with the number of confounding singleton marginals in Figure 4. A similar trend arises as with the number of cycle inequalities introduced. To compare the methods, note that branchand-bound uses twice as many LP calls as there are branches. For this family of graphical models, branch-and-bound tends to require less calls to an LP solver than the cut constraints."
    }, {
      "heading" : "Acknowledgements",
      "text" : "This material is based upon work supported by the National Science Foundation Graduate Research Fellowship under Grant No. DGE-1110007 as well as NSF Grants CCF 1344364, 1407278, 1422549, 1618689, 1018829 and ARO YIP W911NF-14-1-0258."
    } ],
    "references" : [ {
      "title" : "Message passing algorithms and improved lp decoding",
      "author" : [ "Sanjeev Arora", "Constantinos Daskalakis", "David Steurer" ],
      "venue" : "In Symposium on Theory of Computing,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2009
    }, {
      "title" : "Diverse m-best solutions in markov random fields",
      "author" : [ "Dhruv Batra", "Payman Yadollahpour", "Abner Guzman-Rivera", "Gregory Shakhnarovich" ],
      "venue" : "In European Conference on Computer Vision,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2012
    }, {
      "title" : "Introduction to linear optimization, volume 6",
      "author" : [ "Dimitris Bertsimas", "John N Tsitsiklis" ],
      "venue" : "Athena Scientific Belmont, MA,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1997
    }, {
      "title" : "The negative cycles polyhedron and hardness of checking some polyhedral properties",
      "author" : [ "Endre Boros", "Khaled Elbassioni", "Vladimir Gurvich", "Hans Raj Tiwary" ],
      "venue" : "Annals of Operations Research,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "Iterative approximate linear programming decoding of LDPC codes with linear complexity",
      "author" : [ "David Burshtein" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2009
    }, {
      "title" : "An efficient pseudocodeword search algorithm for linear programming decoding of LDPC codes",
      "author" : [ "Michael Chertkov", "Mikhail G Stepanov" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2008
    }, {
      "title" : "Probabilistic analysis of linear programming decoding",
      "author" : [ "Constantinos Daskalakis", "Alexandros G Dimakis", "Richard M Karp", "Martin J Wainwright" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2008
    }, {
      "title" : "Guessing facets: Polytope structure and improved LP decoder",
      "author" : [ "Alexandros G Dimakis", "Amin A Gohari", "Martin J Wainwright" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2009
    }, {
      "title" : "Unequal growth codes: Intermediate performance and unequal error protection for video streaming",
      "author" : [ "Alexandros G Dimakis", "Jiajun Wang", "Kannan Ramchandran" ],
      "venue" : "In Multimedia Signal Processing,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2007
    }, {
      "title" : "k-best enumeration",
      "author" : [ "D. Eppstein" ],
      "venue" : "Encyclopedia of Algorithms",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "LP decoding corrects a constant fraction of errors",
      "author" : [ "Jon Feldman", "Tal Malkin", "Rocco A Servedio", "Cliff Stein", "Martin J Wainwright" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2007
    }, {
      "title" : "Using linear programming to decode binary linear codes",
      "author" : [ "Jon Feldman", "Martin J Wainwright", "David R Karger" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2005
    }, {
      "title" : "An LP view of the M-best MAP problem",
      "author" : [ "Menachem Fromer", "Amir Globerson" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2009
    }, {
      "title" : "Map estimation, message passing, and perfect graphs. In UAI, pages 258–267",
      "author" : [ "Tony Jebara" ],
      "venue" : null,
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2009
    }, {
      "title" : "A comparative study of modern inference techniques for discrete energy minimization problems",
      "author" : [ "Joerg Kappes", "Bjoern Andres", "Fred Hamprecht", "Christoph Schnorr", "Sebastian Nowozin", "Dhruv Batra", "Sungwoong Kim", "Bernhard Kausler", "Jan Lellmann", "Nikos Komodakis" ],
      "venue" : "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2013
    }, {
      "title" : "Generating all vertices of a polyhedron is hard",
      "author" : [ "Leonid Khachiyan", "Endre Boros", "Konrad Borys", "Khaled Elbassioni", "Vladimir Gurvich" ],
      "venue" : "Discrete & Computational Geometry,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2008
    }, {
      "title" : "Characterizations of pseudo-codewords of (low-density) parity-check codes",
      "author" : [ "Ralf Koetter", "Wen-Ching W Li", "Pascal O Vontobel", "Judy L Walker" ],
      "venue" : "Advances in Mathematics,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2007
    }, {
      "title" : "Beyond loose LP-relaxations: Optimizing MRFs by repairing cycles",
      "author" : [ "Nikos Komodakis", "Nikos Paragios" ],
      "venue" : "In European Conference on Computer Vision,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2008
    }, {
      "title" : "An automatic method of solving discrete programming problems",
      "author" : [ "Ailsa H Land", "Alison G Doig" ],
      "venue" : "Econometrica: Journal of the Econometric Society,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1960
    }, {
      "title" : "A procedure for computing the k best solutions to discrete optimization problems and its application to the shortest path problem",
      "author" : [ "Eugene L Lawler" ],
      "venue" : "Management science,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1972
    }, {
      "title" : "Suppressing pseudocodewords by penalizing the objective of LP decoding",
      "author" : [ "Xishuo Liu", "Stark C Draper", "Benjamin Recht" ],
      "venue" : "In Information Theory Workshop,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2012
    }, {
      "title" : "Letter to the editoran algorithm for ranking all the assignments in order of increasing cost",
      "author" : [ "Katta G Murty" ],
      "venue" : "Operations research,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1968
    }, {
      "title" : "Integer and Combinatorial Optimization",
      "author" : [ "George L Nemhauser", "Laurence A Wolsey" ],
      "venue" : null,
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1999
    }, {
      "title" : "The boolean quadric polytope: some characteristics, facets and relatives",
      "author" : [ "Manfred Padberg" ],
      "venue" : "Mathematical programming,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1989
    }, {
      "title" : "New outer bounds on the marginal polytope",
      "author" : [ "David Sontag", "Tommi S Jaakkola" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2007
    }, {
      "title" : "Efficiently searching for frustrated cycles in map inference",
      "author" : [ "David Sontag", "Yitao Li" ],
      "venue" : "In UAI,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2012
    }, {
      "title" : "Tightening LP relaxations for map using message passing",
      "author" : [ "David Sontag", "Talya Meltzer", "Amir Globerson", "Tommi Jaakkola", "Yair Weiss" ],
      "venue" : "In UAI,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2008
    }, {
      "title" : "Tree-reweighted belief propagation algorithms and approximate ML estimation by pseudo-moment matching",
      "author" : [ "Martin J Wainwright", "Tommi S Jaakkola", "Alan S Willsky" ],
      "venue" : "In AISTATS,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2003
    }, {
      "title" : "Graphical models, exponential families, and variational inference",
      "author" : [ "Martin J Wainwright", "Michael I Jordan" ],
      "venue" : "Foundations and Trends in Machine Learning,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2008
    }, {
      "title" : "Uprooting and rerooting graphical models",
      "author" : [ "Adrian Weller" ],
      "venue" : "In ICML,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2016
    }, {
      "title" : "Tightness of LP relaxations for almost balanced models",
      "author" : [ "Adrian Weller", "Mark Rowland", "David Sontag" ],
      "venue" : "In AISTATS,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2016
    }, {
      "title" : "Train and test tightness of LP relaxations in structured prediction",
      "author" : [ "AdrianWeller", "David Sontag" ],
      "venue" : "In ICML,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2016
    }, {
      "title" : "Understanding the bethe approximation: when and how can it go wrong",
      "author" : [ "Adrian Weller", "Kui Tang", "Tony Jebara", "David Sontag" ],
      "venue" : "In UAI,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2014
    }, {
      "title" : "Generalized belief propagation",
      "author" : [ "Jonathan S Yedidia", "William T Freeman", "Yair Weiss" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2000
    }, {
      "title" : "Adaptive cut generation algorithm for improved linear programming decoding of binary linear codes",
      "author" : [ "Xiaojie Zhang", "Paul H Siegel" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 31,
      "context" : "In [33], the authors state that a major open question is to identify why real world instances of Problem (2) can be solved efficiently despite the theoretical worst case complexity.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 7,
      "context" : "The same result (exact solution if the number of confounding vertices is bounded by a polynomial) was established by [9] for the special case of LP decoding of LDPC codes [13].",
      "startOffset" : 117,
      "endOffset" : 120
    }, {
      "referenceID" : 11,
      "context" : "The same result (exact solution if the number of confounding vertices is bounded by a polynomial) was established by [9] for the special case of LP decoding of LDPC codes [13].",
      "startOffset" : 171,
      "endOffset" : 175
    }, {
      "referenceID" : 7,
      "context" : "The algorithm from [9] relies on the special structure of the graphical models that correspond to LDPC codes.",
      "startOffset" : 19,
      "endOffset" : 22
    }, {
      "referenceID" : 30,
      "context" : "For example see [32] for balanced and almost balanced models, [15] for perfect graphs, and [30] for graphs with constant tree-width.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 13,
      "context" : "For example see [32] for balanced and almost balanced models, [15] for perfect graphs, and [30] for graphs with constant tree-width.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 28,
      "context" : "For example see [32] for balanced and almost balanced models, [15] for perfect graphs, and [30] for graphs with constant tree-width.",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 33,
      "context" : "One class is belief propagation and its variants [35, 29, 28].",
      "startOffset" : 49,
      "endOffset" : 61
    }, {
      "referenceID" : 27,
      "context" : "One class is belief propagation and its variants [35, 29, 28].",
      "startOffset" : 49,
      "endOffset" : 61
    }, {
      "referenceID" : 26,
      "context" : "One class is belief propagation and its variants [35, 29, 28].",
      "startOffset" : 49,
      "endOffset" : 61
    }, {
      "referenceID" : 22,
      "context" : "[24]).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "Techniques specialized to graphical models include cutting-plane methods based on the cycle inequalities [26, 19, 27].",
      "startOffset" : 105,
      "endOffset" : 117
    }, {
      "referenceID" : 17,
      "context" : "Techniques specialized to graphical models include cutting-plane methods based on the cycle inequalities [26, 19, 27].",
      "startOffset" : 105,
      "endOffset" : 117
    }, {
      "referenceID" : 25,
      "context" : "Techniques specialized to graphical models include cutting-plane methods based on the cycle inequalities [26, 19, 27].",
      "startOffset" : 105,
      "endOffset" : 117
    }, {
      "referenceID" : 14,
      "context" : "See also [16] for a comparative survey of techniques.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 32,
      "context" : "In [34], the authors investigate how pseudomarginals and relaxations relate to the success of the Bethe approximation of the partition function was done in [34].",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 32,
      "context" : "In [34], the authors investigate how pseudomarginals and relaxations relate to the success of the Bethe approximation of the partition function was done in [34].",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 4,
      "context" : "This work ranges from very fast solvers that exploit the special structure of the polytope [6], connections to unequal error protection [10], and graphical model covers [18].",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 8,
      "context" : "This work ranges from very fast solvers that exploit the special structure of the polytope [6], connections to unequal error protection [10], and graphical model covers [18].",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 16,
      "context" : "This work ranges from very fast solvers that exploit the special structure of the polytope [6], connections to unequal error protection [10], and graphical model covers [18].",
      "startOffset" : 169,
      "endOffset" : 173
    }, {
      "referenceID" : 6,
      "context" : "LP decoding currently provides the best known finite-length error-correction bounds for LDPC codes both for random [8, 2], and adversarial bit-flipping errors [12].",
      "startOffset" : 115,
      "endOffset" : 121
    }, {
      "referenceID" : 0,
      "context" : "LP decoding currently provides the best known finite-length error-correction bounds for LDPC codes both for random [8, 2], and adversarial bit-flipping errors [12].",
      "startOffset" : 115,
      "endOffset" : 121
    }, {
      "referenceID" : 10,
      "context" : "LP decoding currently provides the best known finite-length error-correction bounds for LDPC codes both for random [8, 2], and adversarial bit-flipping errors [12].",
      "startOffset" : 159,
      "endOffset" : 163
    }, {
      "referenceID" : 34,
      "context" : "The work most closely related to this paper involves eliminating fractional vertices (socalled pseudocodewords in coding theory) by changing the polytope or the objective function [36, 7, 22].",
      "startOffset" : 180,
      "endOffset" : 191
    }, {
      "referenceID" : 5,
      "context" : "The work most closely related to this paper involves eliminating fractional vertices (socalled pseudocodewords in coding theory) by changing the polytope or the objective function [36, 7, 22].",
      "startOffset" : 180,
      "endOffset" : 191
    }, {
      "referenceID" : 20,
      "context" : "The work most closely related to this paper involves eliminating fractional vertices (socalled pseudocodewords in coding theory) by changing the polytope or the objective function [36, 7, 22].",
      "startOffset" : 180,
      "endOffset" : 191
    }, {
      "referenceID" : 18,
      "context" : "The algorithm used in proving Theorem 1 is a version of branch-and-bound, a classic technique in integer programming [20] (see [24] for a modern reference on integer programming).",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 22,
      "context" : "The algorithm used in proving Theorem 1 is a version of branch-and-bound, a classic technique in integer programming [20] (see [24] for a modern reference on integer programming).",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 2,
      "context" : "To see the last invariant, note that every vertex of a polytope can be identified by the set of inequality constraints that are satisfied with equality (see [4]).",
      "startOffset" : 157,
      "endOffset" : 160
    }, {
      "referenceID" : 15,
      "context" : "Consider the circulation polytope described in [17], with the graph and weight vector w described in [5].",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 3,
      "context" : "Consider the circulation polytope described in [17], with the graph and weight vector w described in [5].",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 7,
      "context" : "The best known algorithm for the M-best LP problem is a generalization of the facet guessing algorithm [9] developed in [1], which would require O(m) calls to an LP solver, where m is the number of constraints of the LP.",
      "startOffset" : 103,
      "endOffset" : 106
    }, {
      "referenceID" : 12,
      "context" : "There is a significant volume of work in the general area, see [14, 3] for MAP solutions in graphical models and [11] for a survey on M-best problems.",
      "startOffset" : 63,
      "endOffset" : 70
    }, {
      "referenceID" : 1,
      "context" : "There is a significant volume of work in the general area, see [14, 3] for MAP solutions in graphical models and [11] for a survey on M-best problems.",
      "startOffset" : 63,
      "endOffset" : 70
    }, {
      "referenceID" : 9,
      "context" : "There is a significant volume of work in the general area, see [14, 3] for MAP solutions in graphical models and [11] for a survey on M-best problems.",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 21,
      "context" : "It combines Algorithm 1 with the space partitioning technique used in [23, 21].",
      "startOffset" : 70,
      "endOffset" : 78
    }, {
      "referenceID" : 19,
      "context" : "It combines Algorithm 1 with the space partitioning technique used in [23, 21].",
      "startOffset" : 70,
      "endOffset" : 78
    }, {
      "referenceID" : 23,
      "context" : "It was shown in [25] that all the vertices of this",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 30,
      "context" : "polytope are half-integral, that is, all coordinates have a value from {0, 1 2 , 1} (see [32] for a new proof of this).",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 24,
      "context" : "Half-integral points q with a frustrated cycle do not satisfy the cycle inequalities [26, 30], for all cycles C = (VC , EC), F = (VF , EF ) ⊆ C, |EF | odd we must have",
      "startOffset" : 85,
      "endOffset" : 93
    }, {
      "referenceID" : 28,
      "context" : "Half-integral points q with a frustrated cycle do not satisfy the cycle inequalities [26, 30], for all cycles C = (VC , EC), F = (VF , EF ) ⊆ C, |EF | odd we must have",
      "startOffset" : 85,
      "endOffset" : 93
    }, {
      "referenceID" : 2,
      "context" : "1 Proof of Theorem 6 Every vertex q of an n-dimensional polytope is such that there are n constraints such that q satisfies them with equality, known as active constraints (see [4]).",
      "startOffset" : 177,
      "endOffset" : 180
    }, {
      "referenceID" : 21,
      "context" : "It is based on the k-best enumeration method developed in [23, 21].",
      "startOffset" : 58,
      "endOffset" : 66
    }, {
      "referenceID" : 19,
      "context" : "It is based on the k-best enumeration method developed in [23, 21].",
      "startOffset" : 58,
      "endOffset" : 66
    }, {
      "referenceID" : 24,
      "context" : "We consider a synthetic experiment on randomly created graphical models, which were also used in [26, 31, 34].",
      "startOffset" : 97,
      "endOffset" : 109
    }, {
      "referenceID" : 29,
      "context" : "We consider a synthetic experiment on randomly created graphical models, which were also used in [26, 31, 34].",
      "startOffset" : 97,
      "endOffset" : 109
    }, {
      "referenceID" : 32,
      "context" : "We consider a synthetic experiment on randomly created graphical models, which were also used in [26, 31, 34].",
      "startOffset" : 97,
      "endOffset" : 109
    }, {
      "referenceID" : 24,
      "context" : "We use the algorithm for finding the most frustrated cycle in [26] to introduce new constraints.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 24,
      "context" : "We use the algorithm for finding the most frustrated cycle in [26] to introduce new constraints.",
      "startOffset" : 62,
      "endOffset" : 66
    } ],
    "year" : 2017,
    "abstractText" : "Given a graphical model, one essential problem is MAP inference, that is, finding the most likely configuration of states according to the model. Although this problem is NP-hard, large instances can be solved in practice. A major open question is to explain why this is true. We give a natural condition under which we can provably perform MAP inference in polynomial time. We require that the number of fractional vertices in the LP relaxation exceeding the optimal solution is bounded by a polynomial in the problem size. This resolves an open question by Dimakis, Gohari, and Wainwright. In contrast, for general LP relaxations of integer programs, known techniques can only handle a constant number of fractional vertices whose value exceeds the optimal solution. We experimentally verify this condition and demonstrate how efficient various integer programming methods are at removing fractional solutions.",
    "creator" : "LaTeX with hyperref package"
  }
}