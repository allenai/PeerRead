{
  "name" : "1106.0665.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Infinite-Horizon Policy-Gradient Estimation",
    "authors" : [ "Jonathan Baxter", "Peter L. Bartlett" ],
    "emails" : [ "JBAXTER@WHIZBANG.COM", "BARTLETT@BARNHILLTECHNOLOGIES.COM" ],
    "sections" : [ {
      "heading" : null,
      "text" : "much recent attention as a means to solve problems of partial observability and to avoid some of the problems associated with policy degradation in value-function methods. In this paper we introduce GPOMDP, a simulation-based algorithm for generating a biased estimate of the gradient of the average reward in Partially Observable Markov Decision Processes (POMDPs) controlled by parameterized stochastic policies. A similar algorithm was proposed by Kimura, Yamamura, and Kobayashi (1995). The algorithm’s chief advantages are that it requires storage of only twice the number of policy parameters, uses one free parameter 2 [0; 1) (which has a natural interpretation in terms of bias-variance trade-off), and requires no knowledge of the underlying state. We prove convergence of GPOMDP, and show how the correct choice of the parameter is related to the mixing time of the controlledPOMDP. We briefly describe extensions ofGPOMDP to controlled Markov chains, continuous state, observation and control spaces, multiple-agents, higher-order derivatives, and a version for training stochastic policies with internal states. In a companion paper (Baxter, Bartlett, & Weaver, 2001) we show how the gradient estimates generated by GPOMDP can be used in both a traditional stochastic gradient algorithm and a conjugate-gradient procedure to find local optima of the average reward."
    }, {
      "heading" : "1. Introduction",
      "text" : "Dynamic Programming is the method of choice for solving problems of decision making under uncertainty (Bertsekas, 1995). However, the application of Dynamic Programming becomes problematic in large or infinite state-spaces, in situations where the system dynamics are unknown, or when the state is only partially observed. In such cases one looks for approximate techniques that rely on simulation, rather than an explicit model, and parametric representations of either the valuefunction or the policy, rather than exact representations.\nSimulation-based methods that rely on a parametric form of the value function tend to go by the name “Reinforcement Learning,” and have been extensively studied in the Machine Learning literature (Bertsekas & Tsitsiklis, 1996; Sutton & Barto, 1998). This approach has yielded some remarkable empirical successes in a number of different domains, including learning to play checkers (Samuel, 1959), backgammon (Tesauro, 1992, 1994), and chess (Baxter, Tridgell, & Weaver, 2000), job-shop scheduling (Zhang & Dietterich, 1995) and dynamic channel allocation (Singh & Bertsekas, 1997).\nDespite this success, most algorithms for training approximate value functions suffer from the same theoretical flaw: the performance of the greedy policy derived from the approximate valuefunction is not guaranteed to improve on each iteration, and in fact can be worse than the old policy\nc 2001 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.\nby an amount equal to the maximum approximation error over all states. This can happen even when the parametric class contains a value function whose corresponding greedy policy is optimal. We illustrate this with a concrete and very simple example in Appendix A.\nAn alternative approach that circumvents this problem—the approach we pursue here—is to consider a class of stochastic policies parameterized by 2 RK , compute the gradient with respect to of the average reward, and then improve the policy by adjusting the parameters in the gradient direction. Note that the policy could be directly parameterized, or it could be generated indirectly from a value function. In the latter case the value-function parameters are the parameters of the policy, but instead of being adjusted to minimize error between the approximate and true value function, the parameters are adjusted to directly improve the performance of the policy generated by the value function.\nThese “policy-gradient” algorithms have a long history in Operations Research, Statistics, Control Theory, Discrete Event Systems and Machine Learning. Before describing the contribution of the present paper, it seems appropriate to introduce some background material explaining this approach. Readers already familiar with this material may want to skip directly to section 1.2, where the contributions of the present paper are described."
    }, {
      "heading" : "1.1 A Brief History of Policy-Gradient Algorithms",
      "text" : "For large-scale problems or problems where the system dynamics are unknown, the performance gradient will not be computable in closed form1. Thus the challenging aspect of the policy-gradient approach is to find an algorithm for estimating the gradient via simulation. Naively, the gradient can be calculated numerically by adjusting each parameter in turn and estimating the effect on performance via simulation (the so-called crude Monte-Carlo technique), but that will be prohibitively inefficient for most problems. Somewhat surprisingly, under mild regularity conditions, it turns out that the full gradient can be estimated from a single simulation of the system. The technique is called the score function or likelihood ratio method and appears to have been first proposed in the sixties (Aleksandrov, Sysoyev, & Shemeneva, 1968; Rubinstein, 1969) for computing performance gradients in i.i.d. (independently and identically distributed) processes. Specifically, suppose r(X) is a performance function that depends on some random variableX , and q( ; x) is the probability that X = x, parameterized by 2 RK . Under mild regularity conditions, the gradient with respect to of the expected performance, ( ) = Er(X); (1) may be written r ( ) = Er(X)rq( ;X)q( ;X) : (2) To see this, rewrite (1) as a sum ( ) =Xx r(x)q( ; x); differentiate (one source of the requirement of “mild regularity conditions”) to obtainr ( ) =Xx r(x)rq( ; x);\n1. See equation (17) for a closed-form expression for the performance gradient.\nrewrite as r ( ) =Xx r(x)rq( ; x)q( ; x) q( ; x); and observe that this formula is equivalent to (2).\nIf a simulator is available to generate samples X distributed according to q( ; x), then any sequence X1;X2; : : : ;XN generated i.i.d. according to q( ; x) gives an unbiased estimate,r̂ ( ) = 1N NXi=1 r(Xi)rq( ;Xi)q( ;Xi) ; (3) of r ( ). By the law of large numbers, r̂ ( ) ! r ( ) with probability one. The quantityrq( ;X)=q( ;X) is known as the likelihood ratio or score function in classical statistics. If the performance function r(X) also depends on , then r(X)rq( ;X)=q( ;X) is replaced byrr( ;X) + r( ;X)rq( ;X)=q( ;X) in (2)."
    }, {
      "heading" : "1.1.1 UNBIASED ESTIMATES OF THE PERFORMANCE GRADIENT FOR REGENERATIVE PROCESSES",
      "text" : "Extensions of the likelihood-ratio method to regenerative processes (including Markov Decision Processes or MDPs) were given by Glynn (1986, 1990), Glynn and L‘Ecuyer (1995) and Reiman and Weiss (1986, 1989), and independently for episodic Partially Observable Markov Decision Processes (POMDPs) by Williams (1992), who introduced the REINFORCE algorithm2. Here the i.i.d. samples X of the previous section are sequences of states X0; : : : ;XT (of random length) encountered between visits to some designated recurrent state i , or sequences of states from some start state to a goal state. In this case rq( ;X)=q( ;X) can be written as a sumrq( ;X)q( ;X) = T 1Xt=0 rpXtXt+1( )pXtXt+1( ) ; (4) where pXtXt+1( ) is the transition probability from Xt to Xt+1 given parameters . Equation (4) admits a recursive computation over the course of a regenerative cycle of the form z0 = 0 2 RK , and after each state transition Xt ! Xt+1,zt+1 = zt + rpXtXt+1( )pXtXt+1( ) ; (5) so that each term r(X)rq( ;X)=q( ;X) in the estimate (3) is of the form3 r(X0; : : : ;XT )zT . If, in addition, r(X0; : : : ;XT ) can be recursively computed byr(X0; : : : ;Xt+1) = (r(X0; : : : ;Xt);Xt+1) for some function , then the estimate r(X0; : : : ;XT )zT for each cycle can be computed using storage of only K + 1 parameters (K for zt and 1 parameter to update the performance functionr). Hence, the entire estimate (3) can be computed with storage of only 2K + 1 real parameters, as follows.\n2. A thresholded version of these algorithms for neuron-like elements was described earlier in Barto, Sutton, and Anderson (1983). 3. The vector zT is known in reinforcement learning as an eligibility trace. This terminology is used in Barto et al. (1983).\nAlgorithm 1.1: Policy-Gradient Algorithm for Regenerative Processes.\n1. Set j = 0, r0 = 0, z0 = 0, and 0 = 0 (z0; 0 2 RK ). 2. For each state transition Xt ! Xt+1: If the episode is finished (that is, Xt+1 = i ), set j+1 = j + rtzt,j = j + 1,zt+1 = 0,rt+1 = 0. Otherwise, setzt+1 = zt + rpXtXt+1( )pXtXt+1( ) ;rt+1 = (rt;Xt+1). 3. If j = N return N=N , otherwise goto 2.\nExamples of recursive performance functions include the sum of a scalar reward over a cycle,r(X0; : : : ;XT ) = PTt=0 r(Xt) where r(i) is a scalar reward associated with state i (this corresponds to ( ) being the average reward multiplied by the expected recurrence time E [T ℄); the negative length of the cycle (which can be implemented by assigning a reward of 1 to each state, and is used when the task is to mimimize time taken to get to a goal state, since ( ) in this case is just E [T ℄); the discounted reward from the start state, r(X0; : : : ;XT ) =PTt=0 tr(Xt), where 2 [0; 1) is the discount factor, and so on. As Williams (1992) pointed out, a further simplification is possible in the case that rT =r(X0; : : : ;XT ) is a sum of scalar rewards r(Xt; t) depending on the state and possibly the timet since the starting state (such as r(Xt; t) = r(Xt), or r(Xt; t) = tr(Xt) as above). In that case, the update from a single regenerative cycle may be written as = T 1Xt=0 rpXtXt+1( )pXtXt+1( ) \" tXs=0 r(Xs; s) + TXs=t+1 r(Xs; s)# : Because changes in pXtXt+1( ) have no influence on the rewards r(Xs; s) associated with earlier states (s t), we should be able to drop the first term in the parentheses on the right-hand-side and write = T 1Xt=0 rpXtXt+1( )pXtXt+1( ) TXs=t+1 r(Xs; s): (6) Although the proof is not entirely trivial, this intuition can indeed be shown to be correct.\nEquation (6) allows an even simpler recursive formula for estimating the performance gradient. Set z0 = 0 = 0, and introduce a new variable s = 0. As before, set zt+1 = zt +rpXtXt+1( )=pXtXt+1( ) and s = s + 1 if Xt+1 6= i , or s = 0 and zt+1 = 0 otherwise. But now, on each iteration, set t+1 = r(Xt; s)zt+ t. Then t=t is our estimate of r ( ). Since t is updated on every iteration, this suggests that we can do away with t altogether and simply update directly: t+1 = t+ tr(Xt; s)zt, where the t are suitable step-sizes4 . Proving convergence\n4. The usual requirements on t for convergence of a stochastic gradient algorithm are t > 0, P1t=0 t = 1, andP1t=0 2t <1.\nof such an algorithm is not as straightforward as normal stochastic gradient algorithms because the updates r(Xt)zt are not in the gradient direction (in expectation), although the sum of these updates over a regenerative cycle are. Marbach and Tsitsiklis (1998) provide the only convergence proof that we know of, albeit for a slightly different update of the form t+1 = t + t [r(Xt; s) ̂( t)℄ zt, where ̂( t) is a moving estimate of the expected performance, and is also updated on-line (this update was first suggested in the context of POMDPs by Jaakkola et al. (1995)).\nMarbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search). This last paper contains an interesting insight: through suitable choices of the performance function r(X0; : : : ;XT ; ), one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto et al. (1983); the policy is the actor and the value function is the critic. The primary motivation is to reduce variance in the policy-gradient estimates. Experimental evidence for this phenomenon has been presented by a number of authors, including Barto et al. (1983), Kimura and Kobayashi (1998a), and Baird and Moore (1999). More recent work on this subject includes that of Sutton et al. (2000) and Konda and Tsitsiklis (2000). We discuss the use of VAPS-style updates further in Section 6.2.\nSo far we have not addressed the question of how the parameterized state-transition probabilities pXtXt+1( ) arise. Of course, they could simply be generated by parameterizing the matrix of transition probabilities directly. Alternatively, in the case of MDPs or POMDPs, state transitions are typically generated by feeding an observation Yt that depends stochastically on the state Xt into a parameterized stochastic policy, which selects a control Ut at random from a set of available controls (approximate value-function based approaches that generate controls stochastically via some form of lookahead also fall into this category). The distribution over successor statespXtXt+1(Ut) is then a fixed function of the control. If we denote the probability of control ut given parameters and observation yt by ut( ; yt), then all of the above discussion carries through withrpXtXt+1( )=pXtXt+1( ) replaced by r Ut( ; Yt)= Ut( ; Yt). In that case, Algorithm 1.1 is precisely Williams’ REINFORCE algorithm.\nAlgorithm 1.1 and the variants above have been extended to cover multiple agents (Peshkin et al., 2000), policies with internal state (Meuleau et al., 1999), and importance sampling methods (Meuleau et al., 2000). We also refer the reader to the work of Rubinstein and Shapiro (1993) and Rubinstein and Melamed (1998) for in-depth analysis of the application of the likelihood-ratio method to Discrete-Event Systems (DES), in particular networks of queues. Also worth mentioning is the large literature on Infinitesimal Perturbation Analysis (IPA), which seeks a similar goal of estimating performance gradients, but operates under more restrictive assumptions than the likelihoodratio approach; see, for example, Ho and Cao (1991)."
    }, {
      "heading" : "1.1.2 BIASED ESTIMATES OF THE PERFORMANCE GRADIENT",
      "text" : "All the algorithms described in the previous section rely on an identifiable recurrent state i , either to update the gradient estimate, or in the case of the on-line algorithm, to zero the eligibility tracez. This reliance on a recurrent state can be problematic for two main reasons:\n1. The variance of the algorithms is related to the recurrence time between visits to i , which will typically grow as the state space grows. Furthermore, the time between visits depends on\nthe parameters of the policy, and states that are frequently visited for the initial value of the parameters may become very rare as performance improves.\n2. In situations of partial observability it may be difficult to estimate the underlying states, and therefore to determine when the gradient estimate should be updated, or the eligibility trace zeroed.\nIf the system is available only through simulation, it seems difficult (if not impossible) to obtain unbiased estimates of the gradient direction without access to a recurrent state. Thus, to solve 1 and 2, we must look to biased estimates. Two principle techniques for introducing bias have been proposed, both of which may be viewed as artificial truncations of the eligibility trace z. The first method takes as a starting point the formula5 for the eligibility trace at time t:zt = t 1Xs=0 rpXsXs+1( )pXsXs+1( ) and simply truncates it at some (fixed, not random) number of terms n looking backwards (Glynn, 1990; Rubinstein, 1991, 1992; Cao & Wan, 1998):zt(n) := t 1Xs=t n rpXsXs+1( )pXsXs+1( ) : (7) The eligibility trace zt(n) is then updated after each transition Xt ! Xt+1 byzt+1(n) = zt(n) + rpXtXt+1( )pXtXt+1( ) rpXt nXt n+1( )pXt nXt n+1( ) ; (8) and in the case of state-based rewards r(Xt), the estimated gradient direction after T steps isr̂n ( ) := 1T n+ 1 TXt=n zt(n)r(Xt): (9) Unless n exceeds the maximum recurrence time (which is infinite in an ergodic Markov chain),r̂n ( ) is a biased estimate of the gradient direction, although as n!1, the bias approaches zero. However the variance of r̂n ( ) diverges in the limit of large n. This illustrates a natural trade-off in the selection of the parameter n: it should be large enough to ensure the bias is acceptable (the expectation of r̂n ( ) should at least be within 90Æ of the true gradient direction), but not so large that the variance is prohibitive. Experimental results by Cao and Wan (1998) illustrate nicely this bias/variance trade-off.\nOne potential difficulty with this method is that the likelihood ratios rpXsXs+1( )=pXsXs+1( ) must be remembered for the previous n time steps, requiring storage of Kn parameters. Thus, to obtain small bias, the memory may have to grow without bound. An alternative approach that requires a fixed amount of memory is to discount the eligibility trace, rather than truncating it:zt+1( ) := zt( ) + rpXtXt+1( )pXtXt+1( ) ; (10)\n5. For ease of exposition, we have kept the expression for z in terms of the likelihood ratiosrpXsXs+1( )=pXsXs+1( ) which rely on the availability of the underlying state Xs. If Xs is not available, rpXsXs+1( )=pXsXs+1( ) should be replaced withr Us( ; Ys)= Us( ; Ys).\nwhere z0( ) = 0 and 2 [0; 1) is a discount factor. In this case the estimated gradient direction after T steps is simply r̂ ( ) := 1T T 1Xt=0 r(Xt)zt( ): (11) This is precisely the estimate we analyze in the present paper. A similar estimate with r(Xt)zt( ) replaced by (r(Xt) b)zt( ) where b is a reward baseline was proposed by Kimura et al. (1995, 1997) and for continuous control by Kimura and Kobayashi (1998b). In fact the use of (r(Xt) b) in place of r(Xt) does not affect the expectation of the estimates of the algorithm (although judicious choice of the reward baseline b can reduce the variance of the estimates). While the algorithm presented by Kimura et al. (1995) provides estimates of the expectation under the stationary distribution of the gradient of the discounted reward, we will show that these are in fact biased estimates of the gradient of the expected discounted reward. This arises because the stationary distribution itself depends on the parameters. A similar estimate to (11) was also proposed by Marbach and Tsitsiklis (1998), but this time with r(Xt)zt( ) replaced by (r(Xt) ̂( ))zt( ), where ̂( ) is an estimate of the average reward, and with zt zeroed on visits to an identifiable recurrent state.\nAs a final note, observe that the eligibility traces zt( ) and zt(n) defined by (10) and (8) are simply filtered versions of the sequence rpXtXt+1( )=pXtXt+1( ), a first-order, infinite impulse response filter in the case of zt( ) and an n-th order, finite impulse response filter in the case ofzt(n). This raises the question, not addressed in this paper, of whether there is an interesting theory of optimal filtering for policy-gradient estimators."
    }, {
      "heading" : "1.2 Our Contribution",
      "text" : "We describe GPOMDP, a general algorithm based upon (11) for generating a biased estimate of the performance gradient r ( ) in general POMDPs controlled by parameterized stochastic policies. Here ( ) denotes the average reward of the policy with parameters 2 RK . GPOMDP does not rely on access to an underlying recurrent state. Writing r ( ) for the expectation of the estimate produced by GPOMDP, we show that lim !1r ( ) = r ( ), and more quantitatively thatr ( ) is close to the true gradient provided 1=(1 ) exceeds the mixing time of the Markov chain induced by the POMDP6. As with the truncated estimate above, the trade-off preventing the setting of arbitrarily close to 1 is that the variance of the algorithm’s estimates increase as approaches1. We prove convergence with probability 1 of GPOMDP for both discrete and continuous observation and control spaces. We present algorithms for both general parameterized Markov chains andPOMDPs controlled by parameterized stochastic policies.\nThere are several extensions to GPOMDP that we have investigated since the first version of this paper was written. We outline these developments briefly in Section 7.\nIn a companion paper we show how the gradient estimates produced by GPOMDP can be used to perform gradient ascent on the average reward ( ) (Baxter et al., 2001). We describe both traditional stochastic gradient algorithms, and a conjugate-gradient algorithm that utilizes gradient estimates in a novel way to perform line searches. Experimental results are presented illustrat-\n6. The mixing-time result in this paper applies only to Markov chains with distinct eigenvalues. Better estimates of the bias and variance of GPOMDP may be found in Bartlett and Baxter (2001), for more general Markov chains than those treated here, and for more refined notions of the mixing time. Roughly speaking, the variance of GPOMDP grows with 1=(1 ), while the bias decreases as a function of 1=(1 ).\ning both the theoretical results of the present paper on a toy problem, and practical aspects of the algorithms on a number of more realistic problems."
    }, {
      "heading" : "2. The Reinforcement Learning Problem",
      "text" : "We model reinforcement learning as a Markov decision process (MDP) with a finite state spaceS = f1; : : : ; ng, and a stochastic matrix7 P = [pij℄ giving the probability of transition from statei to state j. Each state i has an associated reward8 r(i). The matrix P belongs to a parameterized class of stochastic matrices, P := fP ( ) : 2 RK g. Denote the Markov chain corresponding toP ( ) by M( ). We assume that these Markov chains and rewards satisfy the following assumptions: Assumption 1. Each P ( ) 2 P has a unique stationary distribution ( ) := [ ( ; 1); : : : ; ( ; n)℄0 satisfying the balance equations 0( )P ( ) = 0( ) (12) (throughout 0 denotes the transpose of ). Assumption 2. The magnitudes of the rewards, jr(i)j, are uniformly bounded by R < 1 for all states i.\nAssumption 1 ensures that the Markov chain forms a single recurrent class for all parameters . Since any finite-state Markov chain always ends up in a recurrent class, and it is the properties of this class that determine the long-term average reward, this assumption is mainly for convenience so that we do not have to include the recurrence class as a quantifier in our theorems. However, when we consider gradient-ascent algorithms Baxter et al. (2001), this assumption becomes more restrictive since it guarantees that the recurrence class cannot change as the parameters are adjusted.\nOrdinarily, a discussion of MDPs would not be complete without some mention of the actions available in each state and the space of policies available to the learner. In particular, the parameters would usually determine a policy (either directly or indirectly via a value function), which would then determine the transition probabilities P ( ). However, for our purposes we do not care how the dependence of P on arises, just that it satisfies Assumption 1 (and some differentiability assumptions that we shall meet in the next section). Note also that it is easy to extend this setup to the case where the rewards also depend on the parameters or on the transitions i ! j. It is equally straightforward to extend our algorithms and results to these cases. See Section 6.1 for an illustration.\nThe goal is to find a 2 RK maximizing the average reward: ( ) := limT!1E \" 1T T 1Xt=0 r(Xt) X0 = i# ; where E denotes the expectation over all sequences X0;X1; : : : ; with transitions generated according to P ( ). Under Assumption 1, ( ) is independent of the starting state i and is equal to ( ) = nXi=1 ( ; i)r(i) = 0( )r; (13) where r = [r(1); : : : ; r(n)℄0 (Bertsekas, 1995).\n7. A stochastic matrix P = [pij ℄ has pij 0 for all i; j andPnj=1 pij = 1 for all i. 8. All the results in the present paper apply to bounded stochastic rewards, in which case r(i) is the expectation of the\nreward in state i."
    }, {
      "heading" : "3. Computing the Gradient of the Average Reward",
      "text" : "For general MDPs little will be known about the average reward ( ), hence finding its optimum will be problematic. However, in this section we will see that under general assumptions the gradientr ( ) exists, and so local optimization of ( ) is possible.\nTo ensure the existence of suitable gradients (and the boundedness of certain random variables), we require that the parameterized class of stochastic matrices satisfies the following additional assumption.\nAssumption 3. The derivatives,rP ( ) := pij( ) k i;j=1:::n;k=1:::K exist for all 2 RK . The ratios 24 pij( ) k pij( ) 35i;j=1:::n;k=1:::K are uniformly bounded by B <1 for all 2 RK .\nThe second part of this assumption allows zero-probability transitions pij( ) = 0 only ifrpij( ) is also zero, in which case we set 0=0 = 0. One example is if i ! j is a forbidden transition, so that pij( ) = 0 for all 2 RK . Another example satisfying the assumption ispij( ) = e ijPnj=1 e ij ; where = [ 11; : : : ; 1n; : : : ; nn℄ 2 Rn2 are the parameters of P ( ), for then pij( )= ijpij( ) = 1 pij( ); and pij( )= klpij( ) = pkl( ):\nAssuming for the moment that r ( ) exists (this will be justified shortly), then, suppressing dependencies, r = r 0r; (14) since the reward r does not depend on . Note that our convention for r in this paper is that it takes precedence over all other operations, so rg( )f( ) = [rg( )℄ f( ). Equations like (14) should be regarded as shorthand notation for K equations of the form ( ) k = ( ; 1) k ; : : : ; ( ; n) k [r(1); : : : ; r(n)℄0 where k = 1; : : : ;K . To compute r , first differentiate the balance equations (12) to obtainr 0P + 0rP = r 0;\nand hence r 0(I P ) = 0rP: (15) The system of equations defined by (15) is under-constrained because I P is not invertible (the balance equations show that I P has a left eigenvector with zero eigenvalue). However, let e denote the n-dimensional column vector consisting of all 1s, so that e 0 is the n n matrix with the stationary distribution 0 in each row. Since r 0e = r( 0e) = r(1) = 0, we can rewrite (15) asr 0 I (P e 0) = 0rP:\nTo see that the inverse [I (P e 0)℄ 1 exists, let A be any matrix satisfying limt!1At = 0. Then we can write limT!1\"(I A) TXt=0 At# = limT!1\" TXt=0 At T+1Xt=1 At#= I limT!1AT+1= I: Thus, (I A) 1 = 1Xt=0 At: It is easy to prove by induction that [P e 0℄t = P t e 0 which converges to 0 as t ! 1 by Assumption 1. So [I (P e 0)℄ 1 exists and is equal toP1t=0 P t e 0 . Hence, we can writer 0 = 0rP I P + e 0 1 ; (16) and so9 r = 0rP I P + e 0 1 r: (17) ForMDPs with a sufficiently small number of states, (17) could be solved exactly to yield the precise gradient direction. However, in general, if the state space is small enough that an exact solution of (17) is possible, then it will be small enough to derive the optimal policy using policy iteration and table-lookup, and there would be no point in pursuing a gradient based approach in the first place10.\nThus, for problems of practical interest, (17) will be intractable and we will need to find some other way of computing the gradient. One approximate technique for doing this is presented in the next section.\n9. The argument leading to (16) coupled with the fact that ( ) is the unique solution to (12) can be used to justify the existence of r . Specifically, we can run through the same steps computing the value of ( + Æ) for small Æ and show that the expression (16) forr is the unique matrix satisfying ( + Æ) = ( ) + Ær ( ) +O(kÆk2). 10. Equation (17) may still be useful for POMDPs, since in that case there is no tractable dynamic programming algorithm."
    }, {
      "heading" : "4. Approximating the Gradient in Parameterized Markov Chains",
      "text" : "In this section, we show that the gradient can be split into two components, one of which becomes negligible as a discount factor approaches 1.\nFor all 2 [0; 1), let J ( ) = [J ( ; 1); : : : ; J ( ; n)℄ denote the vector of expected discounted rewards from each state i: J ( ; i) := E \" 1Xt=0 tr(Xt) X0 = i# : (18) Where the dependence is obvious, we just write J . Proposition 1. For all 2 RK and 2 [0; 1),r = (1 )r 0J + 0rPJ : (19) Proof. Observe that J satisfies the Bellman equations:J = r + PJ : (20) (Bertsekas, 1995). Hence,r = r 0r= r 0 [J PJ ℄= r 0J r 0J + 0rPJ by (15)= (1 )r 0J + 0rPJ :\nWe shall see in the next section that the second term in (19) can be estimated from a single sample path of the Markov chain. In fact, Theorem 1 in (Kimura et al., 1997) shows that the gradient estimates of the algorithm presented in that paper converge to (1 ) 0rJ . By the Bellman equations (20), this is equal to (1 ) ( 0rPJ + 0rJ ), which implies (1 ) 0rJ = 0rPJ . Thus the algorithm of Kimura et al. (1997) also estimates the second term in the expression forr ( ) given by (19). It is important to note that 0rJ 6= r [ 0J ℄—the two quantities disagree by the first term in (19). This arises because the the stationary distribution itself depends on the parameters. Hence, the algorithm of Kimura et al. (1997) does not estimate the gradient of the expected discounted reward. In fact, the expected discounted reward is simply 1=(1 ) times the average reward ( ) (Singh et al., 1994, Fact 7), so the gradient of the expected discounted reward is proportional to the gradient of the average reward.\nThe following theorem shows that the first term in (19) becomes negligible as approaches 1. Notice that this is not immediate from Proposition 1, since J can become arbitrarily large in the limit ! 1. Theorem 2. For all 2 RK , r = lim !1r ; (21) where r := 0rPJ : (22)\nProof. Recalling equation (17) and the discussion preceeding it, we have11r = 0rP 1Xt=0 P t e 0 r: (23) But rPe = r(Pe) = r(1) = 0 since P is a stochastic matrix, so (23) can be rewritten asr = 0 \" 1Xt=0 rPP t# r: (24) Now let 2 [0; 1℄ be a discount factor and consider the expressionf( ) := 0 \" 1Xt=0 rP ( P )t# r (25) Clearly r = lim !1 f( ). To complete the proof we just need to show that f( ) = r .\nSince ( P )t = tP t ! te 0 ! 0, we can invoke the observation before (16) to write1Xt=0( P )t = [I P ℄ 1 : In particular,\nP1t=0( P )t converges, so we can take rP back out of the sum in the right-hand-side of (25) and write12 f( ) = 0rP \" 1Xt=0 tP t# r: (26) But\nP1t=0 tP t r = J . Thus f( ) = 0rPJ = r . Theorem 2 shows that r is a good approximation to the gradient as approaches 1, but it turns out that values of very close to 1 lead to large variance in the estimates of r that we describe in the next section. However, the following theorem shows that 1 need not be too small, provided the transition probability matrix P ( ) has distinct eigenvalues, and the Markov chain has a short mixing time. From any initial state, the distribution over states of a Markov chain converges to the stationary distribution, provided the assumption (Assumption 1) about the existence and uniqueness of the stationary distribution is satisfied (see, for example, Lancaster & Tismenetsky, 1985, Theorem 15.8.1, p. 552). The spectral resolution theorem (Lancaster & Tismenetsky, 1985, Theorem 9.5.1, p. 314) implies that the distribution converges to stationarity at an exponential rate, and the time constant in this convergence rate (the mixing time) depends on the eigenvalues of the transition probability matrix. The existence of a unique stationary distribution implies that the 11. Since e 0r = e , (23) motivates a different kind of algorithm for estimating r based on differential rewards (Marbach & Tsitsiklis, 1998).\n12. We cannot backrP out of the sum in the right-hand-side of (24) becauseP1t=0 P t diverges (P t ! e 0). The reasonP1t=0rPP t converges is that P t becomes orthogonal to rP in the limit of large t. Thus, we can viewP1t=0 P t as a sum of two orthogonal components: an infinite one in the direction e and a finite one in the direction e?. It is the finite component that we need to estimate. Approximating\nP1t=0 P t withP1t=0( P )t is a way of rendering the e-component finite while hopefully not altering the e?-component too much. There should be other substitutions that lead to better approximations (in this context, see the final paragraph in Section 1.1).\nlargest magnitude eigenvalue is 1 and has multiplicity 1, and the corresponding left eigenvector is the stationary distribution. We sort the eigenvalues i in decreasing order of magnitude, so that1 = 1 > j 2j > > j sj for some 2 s n. It turns out that j 2j determines the mixing time of the chain.\nThe following theorem shows that if 1 is small compared to 1 j 2j, the gradient approximation described above is accurate. Since we will be using the estimate as a direction in which to update the parameters, the theorem compares the directions of the gradient and its estimate. In this theorem, 2(A) denotes the spectral condition number of a nonsingular matrix A, which is defined as the product of the spectral norms of the matrices A and A 1, 2(A) = kAk2kA 1k2; where kAk2 = maxx:kxk=1 kAxk; and kxk denotes the Euclidean norm of the vector x. Theorem 3. Suppose that the transition probability matrix P ( ) satisfies Assumption 1 with stationary distribution 0 = ( 1; : : : ; n), and has n distinct eigenvalues. Let S = (x1x2 xn) be the matrix of right eigenvectors of P corresponding, in order, to the eigenvalues 1 = 1 > j 2j j nj. Then the normalized inner product between r and r satisfies1 r r kr k2 2 1=2S kr(p 1; : : : ;p n)kkr k pr0 r 1 1 j 2j ; (27) where = diag( 1; : : : ; n).\nNotice that r0 r is the expectation under the stationary distribution of r(X)2. As well as the mixing time (via j 2j), the bound in the theorem depends on another parameter of the Markov chain: the spectral condition number of 1=2S. If the Markov chain is reversible (which implies that the eigenvectors x1; : : : ; xn are orthogonal), this is equal to the ratio of the maximum to the minimum probability of states under the stationary distribution. However, the eigenvectors do not need to be nearly orthogonal. In fact, the condition that the transition probability matrix have n distinct eigenvalues is not necessary; without it, the condition number is replaced by a more complicated expression involving spectral norms of matrices of the form (P iI). Proof. The existence of n distinct eigenvalues implies that P can be expressed as S S 1, where = diag( 1; : : : ; n) (Lancaster & Tismenetsky, 1985, Theorem 4.10.2, p 153). It follows that for any polynomial f , we can write f(P ) = Sf( )S 1.\nNow, Proposition 1 shows that r r = r 0(1 )J . But(1 )J = (1 ) r + Pr + 2P 2r + = (1 ) I + P + 2P 2 + r= (1 )S 1Xt=0 t t!S 1r= (1 ) nXj=1 xjy0j 1Xt=0( j)t! r;\nwhere S 1 = (y1; : : : ; yn)0. It is easy to verify that yi is the left eigenvector corresponding to i, and that we can choosey1 = and x1 = e. Thus we can write(1 )J = (1 )e 0r + nXj=2 xjy0j 1Xt=0(1 )( j)t! r= (1 )e + nXj=2 xjy0j 1 1 j r= (1 )e + SMS 1r;\nwhere M = diag 0; 1 1 2 ; : : : ; 1 1 n : It follows from this and Proposition 1 that1 r r kr k2 = 1 r (r r 0(1 )J )kr k2= r r 0(1 )J kr k2= r r 0 (1 )e + SMS 1r kr k2= r r 0SMS 1rkr k2 r 0SMS 1r kr k ; by the Cauchy-Schwartz inequality. Since r 0 = r p 0 1=2, we can apply the CauchySchwartz inequality again to obtain1 r r kr k2 r p 0 1=2SMS 1r kr k : (28) We use spectral norms to bound the second factor in the numerator. It is clear from the definition that the spectral norm of a product of nonsingular matrices satisfies kABk2 kAk2kBk2, and that the spectral norm of a diagonal matrix is given by kdiag(d1; : : : ; dn)k2 = maxi jdij. It follows that 1=2SMS 1r = 1=2SMS 1 1=2 1=2r 1=2S 2 S 1 1=2 2 1=2r kMk2 2 1=2S pr0 r 1 1 j 2j : Combining with Equation (28) proves (27)."
    }, {
      "heading" : "5. Estimating the Gradient in Parameterized Markov Chains",
      "text" : "Algorithm 1 introduces MCG (Markov Chain Gradient), an algorithm for estimating the approximate gradient r from a single on-line sample path X0;X1; : : : from the Markov chain M( ).MCG requires only 2K reals to be stored, where K is the dimension of the parameter space: K parameters for the eligibility trace zt, and K parameters for the gradient estimate t. Note that after T time steps T is the average so far of r(Xt)zt, T = 1T T 1Xt=0 ztr(Xt): Algorithm 1 The MCG (Markov Chain Gradient) algorithm\n1: Given: Parameter 2 RK . Parameterized class of stochastic matrices P = fP ( ) : 2 RK g satisfying Assumptions 3 and 1. 2 [0; 1). Arbitrary starting state X0. State sequence X0;X1; : : : generated by M( ) (i.e. the Markov chain with transition probabilities P ( )). Reward sequence r(X0); r(X1); : : : satisfying Assumption 2. 2: Set z0 = 0 and 0 = 0 (z0; 0 2 RK ). 3: for each state Xt+1 visited do 4: zt+1 = zt + rpXtXt+1( )pXtXt+1( ) 5: t+1 = t + 1t+1 [r(Xt+1)zt+1 t℄ 6: end for\nTheorem 4. Under Assumptions 1, 2 and 3, the MCG algorithm starting from any initial state X0 will generate a sequence 0; 1; : : : ; t; : : : satisfyinglimt!1 t = r w.p.1: (29) Proof. Let fXtg = fX0;X1; : : : g denote the random process corresponding to M( ). If X0 then the entire process is stationary. The proof can easily be generalized to arbitrary initial distributions using the fact that under Assumption 1, fXtg is asymptotically stationary. When fXtg is\nstationary, we can write 0rPJ =Xi;j (i)rpij( )J (j)=Xi;j (i)pij( )rpij( )pij( ) J (j)=Xi;j Pr(Xt = i) Pr(Xt+1 = jjXt = i)rpij( )pij( ) E(J(t+ 1)jXt+1 = j); (30) where the first probability is with respect to the stationary distribution and J(t+ 1) is the processJ(t+ 1) = 1Xs=t+1 s t 1r(Xs): The fact that E(J(t + 1)jXt+1) = J (Xt+1) for all Xt+1 follows from the boundedness of the magnitudes of the rewards (Assumption 2) and Lebesgue’s dominated convergence theorem. We can rewrite Equation (30) as 0rPJ =Xi;j E i(Xt) j(Xt+1)rpij( )pij( ) J(t+ 1) ; where i( ) denotes the indicator function for state i, i(Xt) := (1 if Xt = i;0 otherwise; and the expectation is again with respect to the stationary distribution. When Xt is chosen according to the stationary distribution, the process fXtg is ergodic. Since the process fZtg defined byZt := i(Xt) j(Xt+1)rpij( )pij( ) J(t+ 1) is obtained by taking a fixed function of fXtg, fZtg is also stationary and ergodic (Breiman, 1966, Proposition 6.31). Since\nrpij( )pij( ) is bounded by Assumption 3, from the ergodic theorem we have (almost surely): 0rPJ =Xi;j limT!1 1T T 1Xt=0 i(Xt) j(Xt+1)rpij( )pij( ) J(t+ 1)= limT!1 1T T 1Xt=0 rpXtXt+1( )pXtXt+1( ) J(t+ 1)= limT!1 1T T 1Xt=0 rpXtXt+1( )pXtXt+1( ) \" TXs=t+1 s t 1r(Xs) + 1Xs=T+1 s t 1r(Xs)# : (31)\nConcentrating on the second term in the right-hand-side of (31), observe that: 1T T 1Xt=0 rpXtXt+1( )pXtXt+1( ) 1Xs=T+1 s t 1r(Xs) 1T T 1Xt=0 rpXtXt+1( )pXtXt+1( ) 1Xs=T+1 s t 1 jr(Xs)j BRT T 1Xt=0 1Xs=T+1 s t 1= BRT T 1Xt=0 T t1 = BR 1 T T (1 )2! 0 as T !1; where R and B are the bounds on the magnitudes of the rewards and jrpij jpij from Assumptions 2 and 3. Hence, 0rPJ = limT!1 1T T 1Xt=0 rpXtXt+1( )pXtXt+1( ) TXs=t+1 s t 1r(Xs): (32)\nUnrolling the equation for T in the MCG algorithm shows it is equal to1T T 1Xt=0 rpXtXt+1( )pXtXt+1( ) TXs=t+1 s t 1r(is); hence T ! 0rPJ w.p.1 as required."
    }, {
      "heading" : "6. Estimating the Gradient in Partially Observable Markov Decision Processes",
      "text" : "Algorithm 1 applies to any parameterized class of stochastic matrices P ( ) for which we can compute the gradients rpij( ). In this section we consider the special case of P ( ) that arise from a parameterized class of randomized policies controlling a partially observable Markov decision process (POMDP). The ‘partially observable’ qualification means we assume that these policies have access to an observation process that depends on the state, but in general they may not see the state. Specifically, assume that there are N controls U = f1; : : : ; Ng and M observations Y =f1; : : : ;Mg. Each u 2 U determines a stochastic matrix P (u) which does not depend on the parameters . For each state i 2 S , an observation Y 2 Y is generated independently according to a probability distribution (i) over observations in Y . We denote the probability of observation y by y(i). A randomized policy is simply a function mapping observations y 2 Y into probability distributions over the controls U . That is, for each observation y, (y) is a distribution over the controls in U . Denote the probability under of control u given observation y by u(y).\nTo each randomized policy ( ) and observation distribution ( ) there corresponds a Markov chain in which state transitions are generated by first selecting an observation y in state i according\nto the distribution (i), then selecting a control u according to the distribution (y), and then generating a transition to state j according to the probability pij(u). To parameterize these chains we parameterize the policies, so that now becomes a function ( ; y) of a set of parameters 2 RK as well as the observation y. The Markov chain corresponding to has state transition matrix [pij( )℄ given by pij( ) = EY (i)EU ( ;Y )pij(U): (33) Equation (33) implies rpij( ) =Xu;y y(i)pij(u)r u( ; y): (34)\nAlgorithm 2 introduces theGPOMDP algorithm (for Gradient of a Partially Observable Markov Decision Process), a modified form of Algorithm 1 in which updates of zt are based on Ut( ; Yt), rather than pXtXt+1( ). Note that Algorithm 2 does not require knowledge of the transition probability matrix P , nor of the observation process ; it only requires knowledge of the randomized policy . GPOMDP is essentially the algorithm proposed by Kimura et al. (1997) without the reward baseline.\nThe algorithm GPOMDP assumes that the policy is a function only of the current observation. It is immediate that the same algorithm works for any finite history of observations. In general, an optimal policy needs to be a function of the entire observation history. GPOMDP can be extended to apply to policies with internal state (Aberdeen & Baxter, 2001).\nAlgorithm 2 The GPOMDP algorithm. 1: Given: Parameterized class of randomized policies ( ; ) : 2 RK satisfying Assumption 4. Partially observable Markov decision process which when controlled by the randomized\npolicies ( ; ) corresponds to a parameterized class of Markov chains satisfying Assumption 1. 2 [0; 1). Arbitrary (unknown) starting state X0. Observation sequence Y0; Y1; : : : generated by the POMDP with controls U0; U1; : : : generated randomly according to ( ; Yt). Reward sequence r(X0); r(X1); : : : satisfying Assumption 2, where X0;X1; : : : is the (hidden) sequence of states of the Markov decision process.\n2: Set z0 = 0 and 0 = 0 (z0; 0 2 RK ). 3: for each observation Yt, control Ut, and subsequent reward r(Xt+1) do 4: zt+1 = zt + r Ut( ; Yt) Ut( ; Yt) 5: t+1 = t + 1t+1 [r(Xt+1)zt+1 t℄ 6: end for\nFor convergence of Algorithm 2 we need to replace Assumption 3 with a similar bound on the gradient of : Assumption 4. The derivatives, u( ; y) k exist for all u 2 U , y 2 Y and 2 RK . The ratios24 u( ;y) k u( ; y) 35y=1:::M ;u=1:::N ;k=1:::K are uniformly bounded by B <1 for all 2 RK . Theorem 5. Under Assumptions 1, 2 and 4, Algorithm 2 starting from any initial state X0 will generate a sequence 0; 1; : : : ; t; : : : satisfyinglimt!1 t = r w.p.1: (35) Proof. The proof follows the same lines as the proof of Theorem 4. In this case, 0rPJ =Xi;j (i)rpij( )J (j)= Xi;j;y;u (i)pij(u) y(i)r u( ; y)J (j) from (34)= Xi;j;y;u (i)pij(u) y(i)r u( ; y) u( ; y) u( ; y)J (j);= Xi;j;y;uEZ 0t; where the expectation is with respect to the stationary distribution of fXtg, and the process fZ 0tg is defined by Z 0t := i(Xt) j(Xt+1) u(Ut) y(Yt)r u( ; y) u( ; y) J(t+ 1); where Ut is the control process and Yt is the observation process. The result follows from the same arguments used in the proof of Theorem 4."
    }, {
      "heading" : "6.1 Control dependent rewards",
      "text" : "There are many circumstances in which the rewards may themselves depend on the controls u. For example, some controls may consume more energy than others and so we may wish to add a penalty term to the reward function in order to conserve energy. The simplest way to deal with this is to define for each state i the expected reward r(i) by r(i) = EY (i)EU ( ;Y )r(U; i); (36)\nand then redefine J in terms of r: J ( ; i) := limN!1E \" NXt=0 t r(Xt) X0 = i# ; (37) where the expectation is over all trajectories X0;X1; : : : . The performance gradient then becomesr = r 0 r + 0r r; which can be approximated by r = 0 rP J +r r ; due to the fact that J satisfies the Bellman equations (20) with r replaced by r.\nFor GPOMDP to take account of the dependence of r on the controls, its fifth line should be replaced by t+1 = t + 1t+ 1 r(Ut+1;Xt+1) zt+1 + r Ut+1( ; Yt+1) Ut+1( ; Yt+1) t : It is straightforward to extend the proofs of Theorems 2, 3 and 5 to this setting."
    }, {
      "heading" : "6.2 Parameter dependent rewards",
      "text" : "It is possible to modify GPOMDP when the rewards themselves depend directly on . In this case, the fifth line of GPOMDP is replaced with t+1 = t + 1t+ 1 [r( ;Xt+1)zt+1 +rr( ;Xt+1) t℄ : (38) Again, the convergence and approximation theorems will carry through, provided rr( ; i) is uniformly bounded. Parameter-dependent rewards have been considered by Glynn (1990), Marbach and Tsitsiklis (1998), and Baird and Moore (1999). In particular, Baird and Moore (1999) showed how suitable choices of r( ; i) lead to a combination of value and policy search, or “VAPS”. For example, if ~J( ; i) is an approximate value-function, then setting13r( ;Xt;Xt 1) = 12 hr(Xt) + ~J( ;Xt) ~J( ;Xt 1)i2 ; where r(Xt) is the usual reward and 2 [0; 1) is a discount factor, gives an update that seeks to minimize the expected Bellman errornXi=1 ( ; i)24r(i) + nXj=1 pij( ) ~J( ; j) ~J( ; i)352 : (39) This will have the effect of both minimizing the Bellman error in ~J( ; i), and driving the system (via the policy) to states with small Bellman error. The motivation behind such an approach can be understood if one considers a ~J that has zero Bellman error for all states. In that case a greedy policy derived from ~J will be optimal, and regardless of how the actual policy is parameterized, the expectation of ztr( ;Xt;Xt 1) will be zero and so will be the gradient computed by GPOMDP. This kind of update is known as an actor-critic algorithm (Barto et al., 1983), with the policy playing the role of the actor, and the value function playing the role of the critic. 13. The use of rewards r( ;Xt; Xt 1) that depend on the current and previous state does not substantially alter the analysis."
    }, {
      "heading" : "6.3 Extensions to infinite state, observation, and control spaces",
      "text" : "The convergence proof for Algorithm 2 relied on finite state (S), observation (Y) and control (U) spaces. However, it should be clear that with no modification Algorithm 2 can be applied immediately to POMDPs with countably or uncountably infinite S and Y , and countable U . All that changes is that pij(u) becomes a kernel p(x; x0; u) and (i) becomes a density on observations. In addition, with the appropriate interpretation of r = , it can be applied to uncountable U . Specifically, if U is a subset of RN then (y; ) will be a probability density function on U with u(y; ) the density at u. If U and Y are subsets of Euclidean space (but S is a finite set), Theorem 5 can be extended to show that the estimates produced by this algorithm converge almost surely to r . In fact, we can prove a more general result that implies both this case of densities on subsets of RN as well as the finite case of Theorem 5. We allow U and Y to be general spaces satisfying the following topological assumption. (For definitions see, for example, (Dudley, 1989).)\nAssumption 5. The control space U has an associated topology that is separable, Hausdorff, and first-countable. For the corresponding Borel -algebra B generated by this topology, there is a -finite measure defined on the measurable space (U ;B). We say that is the reference measure for U .\nSimilarly, the observation space Y has a topology, Borel -algebra, and reference measure satisfying the same conditions.\nIn the case of Theorem 5, where U and Y are finite, the associated reference measure is the counting measure. For U = RN and Y = RM , the reference measure is Lebesgue measure. We assume that the distributions (i) and ( ; y) are absolutely continuous with respect to the reference measures, and the corresponding Radon-Nikodym derivatives (probability masses in the finite case, densities in the Euclidean case) satisfy the following assumption. Assumption 6. For every y 2 Y and 2 RK , the probability measure ( ; y) is absolutely continuous with respect to the reference measure for U . For every i 2 S , the probability measure (i) is absolutely continuous with respect to the reference measure for Y .\nLet be the reference measure for U . For all u 2 U , y 2 Y , 2 RK , and k 2 f1; : : : ;Kg, the derivatives k d ( ; y)d (u) exist and the ratios k d u( ;y)d (u) d u( ;y)d (u) are bounded by B <1.\nWith these assumptions, we can replace in Algorithm 2 with the Radon-Nikodym derivative of with respect to the reference measure on U . In this case, we have the following convergence result. This generalizes Theorem 5, and also applies to densities on a Euclidean space U . Theorem 6. Suppose the control space U and the observation space Y satisfy Assumption 5 and let be the reference measure on the control space U . Consider Algorithm 2 withr Ut( ; Yt) Ut( ; Yt)\nreplaced by rd ( ;Yt)d (Ut)d ( ;Yt)d (Ut) : Under Assumptions 1, 2 and 6, this algorithm, starting from any initial state X0 will generate a sequence 0; 1; : : : ; t; : : : satisfyinglimt!1 t = r w.p.1: Proof. See Appendix B"
    }, {
      "heading" : "7. New Results",
      "text" : "Since the first version of this paper, we have extended GPOMDP to several new settings, and also proved some new properties of the algorithm. In this section we briefly outline these results."
    }, {
      "heading" : "7.1 Multiple Agents",
      "text" : "Instead of a single agent generating actions according to ( ; y), suppose we have multiple agentsi = 1; : : : ; na, each with their own parameter set i and distinct observation of the environmentyi, and that generate their own actions ui according to a policy ui( i; yi). If the agents all receive the same reward signal r(Xt) (they may be cooperating to solve the same task, for example), then GPOMDP can be applied to the collective POMDP obtained by concatenating the observations, controls, and parameters into single vectors y = y1; : : : ; yna , u = u1; : : : ; una , and = 1; : : : ; na respectively. An easy calculation shows that the gradient estimate generated by GPOMDP in the collective case is precisely the same as that obtained by applying GPOMDP to each agent independently, and then concatenating the results. That is, = 1; : : : ; na , where i is the estimate produced by GPOMDP applied to agent i. This leads to an on-line algorithm in which the agents adjust their parameters independently and without any explicit communication, yet collectively the adjustments are maximizing the global average reward. For similar observations in the context of REINFORCE and VAPS, see Peshkin et al. (2000). This algorithm gives a biologically plausible synaptic weight-update rule when applied to networks of spiking neurons in which the neurons are regarded as independent agents (Bartlett & Baxter, 1999), and has shown some promise in a network routing application (Tao, Baxter, & Weaver, 2001)."
    }, {
      "heading" : "7.2 Policies with internal states",
      "text" : "So far we have only considered purely reactive or memoryless policies in which the chosen control is a function of only the current observation. GPOMDP is easily extended to cover the case of policies that depend on finite histories of observations Yt; Yt 1; : : : ; Yt k, but in general, for optimal control of POMDPs, the policy must be a function of the entire observation history. Fortunately, the observation history may be summarized in the form of a belief state (the current distribution over states), which is itself updated based only upon the current observation, and knowledge of which is sufficient for optimal behaviour (Smallwood & Sondik, 1973; Sondik, 1978). An extension ofGPOMDP to policies with parameterized internal belief states is described by Aberdeen and Baxter (2001), similar in spirit to the extension of VAPS and REINFORCE described by Meuleau et al. (1999).\n7.3 Higher-Order DerivativesGPOMDP can be generalized to compute estimates of second and higher-order derivatives of the average reward (assuming they exist), still from a single sample path of the underlying POMDP. To see this for second-order derivatives, observe that if ( ) = R q( ; x)r(x) dx for some twicedifferentiable density q( ; x) and performance measure r(x), thenr2 ( ) = Z r(x)r2q( ; x)q( ; x) q( ; x) dx where r2 denotes the matrix of second derivatives (Hessian). It can be verified thatr2q( ; x)q( ; x) = r2 log q( ; x) + [r log q( ; x)℄2 (40) where the second term on the right-hand-side is the outer product between r log q( ; x) and itself (that is, the matrix with entries = i log q( ; x) = j log q( ; x)). Taking x to be a sequence of states X0;X1; : : : ;XT between visits to a recurrent state i in a parameterized Markov chain (recall Section 1.1.1), we have q( ;X) = T 1t=0 pXtXt+1( ), which combined with (40) yieldsr2q( ;X)q( ;X) = T 1Xt=0 r2pXtXt+1( )pXtXt+1( ) T 1Xt=0 rpXtXt+1( )pXtXt+1( ) 2 + \"T 1Xt=0 rpXtXt+1( )pXtXt+1( ) #2 (the squared terms in this expression are also outer products). From this expression we can derive a GPOMDP-like algorithm for computing a biased estimate of the Hessian r2 ( ), which involves maintaining—in addition to the usual eligibility trace zt—a second matrix trace updated as follows:Zt+1 = Zt + r2pXtXt+1( )pXtXt+1( ) rpXtXt+1( )pXtXt+1( ) 2 : After T time steps the algorithm returns the average so far of r(Xt) Zt + z2t where the second term is again an outer product. Computation of higher-order derivatives could be used in second-order gradient methods for optimization of policy parameters."
    }, {
      "heading" : "7.4 Bias and Variance Bounds",
      "text" : "Theorem 3 provides a bound on the bias of r ( ) relative to r ( ) that applies when the underlying Markov chain has distinct eigenvalues. We have extended this result to arbitrary Markov chains (Bartlett & Baxter, 2001). However, the extra generality comes at a price, since the latter bound involves the number of states in the chain, whereas Theorem 3 does not. The same paper also supplies a proof that the variance of GPOMDP scales as 1=(1 )2, providing a formal justification for the interpretation of in terms of bias/variance trade-off."
    }, {
      "heading" : "8. Conclusion",
      "text" : "We have presented a general algorithm (MCG) for computing arbitrarily accurate approximations to the gradient of the average reward in a parameterized Markov chain. When the chain’s transition matrix has distinct eigenvalues, the accuracy of the approximation was shown to be controlled by the\nsize of the subdominant eigenvalue j 2j. We showed how the algorithm could be modified to apply to partially observable Markov decision processes controlled by parameterized stochastic policies, with both discrete and continuous control, observation and state spaces (GPOMDP). For the finite state case, we proved convergence with probability 1 of both algorithms.\nWe briefly described extensions to multi-agent problems, policies with internal state, estimating higher-order derivatives, generalizations of the bias result to chains with non-distinct eigenvalues, and a new variance result. There are many avenues for further research. Continuous time results should follow as extensions of the results presented here. The MCG and GPOMDP algorithms can be applied to countably or uncountably infinite state spaces; convergence results are also needed in these cases.\nIn the companion paper (Baxter et al., 2001), we present experimental results showing rapid convergence of the estimates generated by GPOMDP to the true gradient r . We give on-line variants of the algorithms of the present paper, and also variants of gradient ascent that make use of the estimates ofr . We present experimental results showing the effectiveness of these algorithms in a variety of problems, including a three-state MDP, a nonlinear physical control problem, and a call-admission problem."
    }, {
      "heading" : "Acknowledgements",
      "text" : "This work was supported by the Australian Research Council, and benefited from the comments of several anonymous referees. Most of this research was performed while the authors were with the Research School of Information Sciences and Engineering, Australian National University."
    }, {
      "heading" : "Appendix A. A Simple Example of Policy Degradation in Value-Function Learning",
      "text" : "Approximate value-function approaches to reinforcement work by minimizing some form of error between the approximate value function and the true value function. It has long been known that this may not necessarily lead to improved policy performance from the new value function. We include this appendix because it illustrates that this phenomenon can occur in the simplest possible system, a two-state MDP, and also provides some geometric intuition for why the phenomenon arises. Consider the two-state Markov decision process (MDP) in Figure 1. There are two controlsu1; u2 with corresponding transition probability matricesP (u1) = 13 2313 23 ; P (u2) = 23 1323 13 ; so that u1 always takes the system to state 2 with probability 2=3, regardless of the starting state (and therefore to state 1 with probability 1=3), and u2 does the opposite. Since state 2 has a reward of 1, while state 1 has a reward of 0, the optimal policy is to always select action u1. Under this policy the stationary distribution on states is [ 1; 2℄ = [1=3; 2=3℄, while the infinite-horizon discounted value of each state i = 1; 2 with discount value 2 [0; 1) isJ (i) = E 1Xt=0 tr(Xt) X0 = i! ; where the expectation is over all state sequences X0;X1;X2; : : : with state transitions generated according to P (u1). Solving Bellman’s equations: J = r+ P (u1)J , where J = [J (1); J (2)℄0 and r = [r(1); r(2)℄0 yields J (1) = 2 3(1 ) and J (2) = 1 + 2 3(1 ) .\nNow, suppose we are trying to learn an approximate value function ~J for this MDP, i.e. , ~J(i) =w (i) for each state i = 1; 2 and some scalar feature ( must have dimensionality 1 to ensure that~J really is approximate). Here w 2 R is the parameter being learnt. For the greedy policy obtained from ~J to be optimal, ~J must value state 2 above state 1. For the purposes of this illustration choose (1) = 2; (2) = 1, so that for ~J(2) > ~J(1), w must be negative.\nTemporal Difference learning (or TD( )) is one of the most popular techniques for training approximate value functions (Sutton & Barto, 1998). It has been shown that for linear functions,TD(1) converges to a parameter w minimizing the expected squared loss under the stationary distribution (Tsitsikilis & Van-Roy, 1997):w = argminw 2Xi=1 i [w (i) J (i)℄2 : (41) Substituting the previous expressions for 1; 2; and J under the optimal policy and solving for w , yields w = 3+ 9(1 ) . Hence w > 0 for all values of 2 [0; 1), which is the wrong sign. So we have a situation where the optimal policy is implementable as a greedy policy based on an approximate value function in the class (just choose any w < 0), yet TD(1) observing the optimal policy will converge to a value function whose corresponding greedy policy implements the suboptimal policy.\nA geometrical illustration of why this occurs is shown in Figure 2. In this figure, points on the graph represent the values of the states. The scales of the state 1 and state 2 axes are weighted byp (1) and p (2) respectively. In this way, the squared euclidean distance on the graph between two points J and ~J corresponds to the expectation under the stationary distribution of the squared difference between values: hp (1)J(1);p (2)J(2)i hp (1) ~J(1);p (2) ~J(2)i 2 = E J(X) ~J(X) 2 : For any value function in the shaded region, the corresponding greedy policy is optimal, since those value functions rank state 2 above state 1. The bold line represents the set of all realizable approximate value functions (w (1); w (2)). The solution to (41) is then the approximate value function found by projecting the point corresponding to the true value function [(J (1); J (2)℄ onto this line. This is illustrated in the figure for = 3=5. The projection is suboptimal because weighted mean-squared distance in value-function space does not take account of the policy boundary."
    }, {
      "heading" : "Appendix B. Proof of Theorem 6",
      "text" : "The proof needs the following topological lemma. For definitions see, for example, (Dudley, 1989, pp. 24–25).\nLemma 7. Let (X;T ) be a topological space that is Hausdorff, separable, and first-countable. Let B be the Borel -algebra generated by T . Then the measurable space (X;B) has a sequenceS1;S2; : : : B of sets that satisfies the following conditions:\n1. Each Si is a partition of X (that is, X = SfS : S 2 Sig and any two distinct elements of Si have empty intersection).\n2. For all x 2 X , fxg 2 B and 1\\i=1fS 2 Si : x 2 Sg = fxg: Proof. Since X is separable, it has a countable dense subset S = fx1; x2; : : :g. Since X is firstcountable, each of these xi has a countable neighbourhood base, Ni. Now, construct the partitionsSi using the countable set N = S1i=1Ni as follows. Let S0 = X and, for i = 1; 2; : : :, defineSi = fS \\Ni : S 2 Si 1g [ fS \\ (X Ni) : S 2 Si 1g :\nClearly, each Si is a measurable partition of X . Since X is Hausdorff, for each pair x; x0 of distinct points from X , there is a pair of disjoint open sets A and A0 such that x 2 A and x0 2 A0. Since S is dense, there is a pair s; s0 from S with s 2 A and s0 2 A0. Also, N contains neighbourhoods Ns and Ns0 with Ns A and Ns0 A0. So Ns and Ns0 are disjoint. Thus, for sufficiently large i, x and x0 fall in distinct elements of the partition Si. Since this is true for any pair x; x0, it follows that1\\i=1fS 2 Si : x 2 Sg fxg: The reverse inclusion is trivial. The measurability of all singletons fxg follows from the measurability of Sx := SifS 2 Si : S \\ fxg = g and the fact that fxg = X Sx.\nWe shall use Lemma 7 together with the following result to show that we can approximate expectations of certain random variables using a single sample path of the Markov chain.\nLemma 8. Let (X;B) be a measurable space satisfying the conditions of Lemma 7, and let S1;S2; : : : be a suitable sequence of partitions as in that lemma. Let be a probability measure defined on this space. Let f be an absolutely integrable function on X . For an event S, definef(S) = RS f d (S) : For each x 2 X and k = 1; 2; : : :, let Sk(x) be the unique element of Sk containing x. Then for almost all x in X , limk!1 f(Sk(x)) = f(x): Proof. Clearly, the signed finite measure defined by (E) = ZE fd (42) is absolutely continuous with respect to , and Equation (42) defines f as the Radon-Nikodym derivative of with respect to . This derivative can also be defined asd d (x) = limk!1 (Sk(x)) (Sk(x)) : See, for example, (Shilov & Gurevich, 1966, Section 10.2). By the Radon-Nikodym Theorem (Dudley, 1989, Theorem 5.5.4, p. 134), these two expressions are equal a.e. ( ). Proof. (Theorem 6.) From the definitions,r = 0rPJ = nXi=1 nXj=1 (i)rpij( )J (j): (43) For every y, is absolutely continuous with respect to the reference measure , hence for any i andj we can write pij( ) = ZY ZU pij(u) d ( ; y)d (u) d (u) d (i)(y):\nSince and do not depend on and d ( ; y)=d is absolutely integrable, we can differentiate under the integral to obtainrpij( ) = ZY ZU pij(u)rd ( ; y)d (u) d (u) d (i)(y): To avoid cluttering the notation, we shall use to denote the distribution ( ; y) on U , and to denote the distribution (i) on Y . With this notation, we haverpij( ) = ZY ZU pij rd d d d d d : Now, let be the probability measure on Y U generated by and . We can write (43) asr =Xi;j (i)J (j)ZY U pijrd d d d d : Using the notation of Lemma 8, we definepij(S) = RS pij d (S) ;r(S) = 1 (S) ZS rd d d d d ; for a measurable set S Y U . Notice that, for a given i, j, and S,pij(S) = Pr (Xt+1 = j jXt = i; (y; u) 2 S )r(S) = E rd d d d Xt = i; (Yt; Ut) 2 S! : Let S1;S2; : : : be a sequence of partitions of Y U as in Lemma 7, and let Sk(y; u) denote the element of Sk containing (y; u). Using Lemma 8, we haveZY U pij rd d d d d = ZY U limk!1 pij (Sk(y; u)) r (Sk(y; u)) d (y; u)= limk!1 XS2Sk ZS pij(S)r(S) d ;\nwhere we have used Assumption 6 and the Lebesgue dominated convergence theorem to interchange the integral and the limit. Hence,r = limk!1Xi;j XS2Sk (i) (S)pij(S)J (j)r(S)= limk!1Xi;j;SPr(Xt = i) Pr((Yt; Ut) 2 S) Pr (Xt+1 = j jXt = i; (Yt; Ut) 2 S )E (J(t+ 1)jXt+1 = j)E rd d d d Xt = i; (Yt; Ut) 2 S!= limk!1Xi;j;SE\" i(Xt) S(Yt; Ut) j(Xt+1)J(t+ 1)rd d d d # ; where probabilities and expectations are with respect to the stationary distribution of Xt, and the distributions on Yt; Ut. Now, the random process inside the expectation is asymptotically stationary and ergodic. From the ergodic theorem, we have (almost surely)r = limk!1 limT!1 1T Xi;j;S T 1Xt=0 i(Xt) S(Yt; Ut) j(Xt+1)J(t+ 1)rd d d d : It is easy to see that the double limit also exists when the order is reversed, sor = limT!1 1T T 1Xt=0 limk!1Xi;j;S i(Xt) S(Yt; Ut) j(Xt+1)J(t+ 1)rd d d d = limT!1 1T T 1Xt=0 rd ( ;Yt)d (Ut)d ( ;Yt)d (Ut) J(t+ 1): The same argument as in the proof of Theorem 4 shows that the tails of J(t + 1) can be ignored when rd ( ;Yt)d (Ut)d ( ;Yt)d (Ut) and jr(Xt)j are uniformly bounded. It follows that T ! 0rPJ w.p.1, as required."
    } ],
    "references" : [ {
      "title" : "Policy-gradient learning of controllers with internal state",
      "author" : [ "D. Aberdeen", "J. Baxter" ],
      "venue" : null,
      "citeRegEx" : "Aberdeen and Baxter,? \\Q2001\\E",
      "shortCiteRegEx" : "Aberdeen and Baxter",
      "year" : 2001
    }, {
      "title" : "Gradient descent for general reinforcement learning",
      "author" : [ "L. Baird", "A. Moore" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Baird and Moore,? \\Q1999\\E",
      "shortCiteRegEx" : "Baird and Moore",
      "year" : 1999
    }, {
      "title" : "Hebbian synaptic modifications in spiking neurons that learn",
      "author" : [ "P.L. Bartlett", "J. Baxter" ],
      "venue" : "Tech. rep., Research School of Information Sciences and Engineering,",
      "citeRegEx" : "Bartlett and Baxter,? \\Q1999\\E",
      "shortCiteRegEx" : "Bartlett and Baxter",
      "year" : 1999
    }, {
      "title" : "Estimation and approximation bounds for gradient-based reinforcement learning",
      "author" : [ "P.L. Bartlett", "J. Baxter" ],
      "venue" : "Journal of Computer and Systems Sciences,",
      "citeRegEx" : "Bartlett and Baxter,? \\Q2001\\E",
      "shortCiteRegEx" : "Bartlett and Baxter",
      "year" : 2001
    }, {
      "title" : "Neuronlike adaptive elements that can solve difficult learning control problems",
      "author" : [ "A.G. Barto", "R.S. Sutton", "C.W. Anderson" ],
      "venue" : "IEEE Transactions on Systems, Man, and Cybernetics,",
      "citeRegEx" : "Barto et al\\.,? \\Q1983\\E",
      "shortCiteRegEx" : "Barto et al\\.",
      "year" : 1983
    }, {
      "title" : "Experiments with infinite-horizon, policy-gradient estimation",
      "author" : [ "J. Baxter", "P.L. Bartlett", "L. Weaver" ],
      "venue" : "Journal of Artificial Intelligence Research. To appear",
      "citeRegEx" : "Baxter et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Baxter et al\\.",
      "year" : 2001
    }, {
      "title" : "Learning to play chess using temporal-differences",
      "author" : [ "J. Baxter", "A. Tridgell", "L. Weaver" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Baxter et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Baxter et al\\.",
      "year" : 2000
    }, {
      "title" : "Dynamic Programming and Optimal Control, Vol II",
      "author" : [ "D.P. Bertsekas" ],
      "venue" : "Athena Scientific.",
      "citeRegEx" : "Bertsekas,? 1995",
      "shortCiteRegEx" : "Bertsekas",
      "year" : 1995
    }, {
      "title" : "Probability",
      "author" : [ "L. Breiman" ],
      "venue" : "Addison-Wesley.",
      "citeRegEx" : "Breiman,? 1966",
      "shortCiteRegEx" : "Breiman",
      "year" : 1966
    }, {
      "title" : "Algorithms for Sensitivity Analysis of Markov Chains Through Potentials and Perturbation Realization",
      "author" : [ "Cao", "X.-R", "Wan", "Y.-W" ],
      "venue" : "IEEE Transactions on Control Systems Technology,",
      "citeRegEx" : "Cao et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Cao et al\\.",
      "year" : 1998
    }, {
      "title" : "Real Analysis and Probability",
      "author" : [ "R.M. Dudley" ],
      "venue" : "Wadsworth & Brooks/Cole, Belmont, California.",
      "citeRegEx" : "Dudley,? 1989",
      "shortCiteRegEx" : "Dudley",
      "year" : 1989
    }, {
      "title" : "Stochastic approximation for monte-carlo optimization",
      "author" : [ "P.W. Glynn" ],
      "venue" : "Proceedings of the 1986 Winter Simulation Conference, pp. 356–365.",
      "citeRegEx" : "Glynn,? 1986",
      "shortCiteRegEx" : "Glynn",
      "year" : 1986
    }, {
      "title" : "Likelihood ratio gradient estimation for stochastic systems",
      "author" : [ "P.W. Glynn" ],
      "venue" : "Communications of the ACM, 33, 75–84.",
      "citeRegEx" : "Glynn,? 1990",
      "shortCiteRegEx" : "Glynn",
      "year" : 1990
    }, {
      "title" : "Likelihood ratio gradient estimation for regenerative stochastic recursions",
      "author" : [ "P.W. Glynn", "P. L‘Ecuyer" ],
      "venue" : "Advances in Applied Probability,",
      "citeRegEx" : "Glynn and L.Ecuyer,? \\Q1995\\E",
      "shortCiteRegEx" : "Glynn and L.Ecuyer",
      "year" : 1995
    }, {
      "title" : "Perturbation Analysis of Discrete Event Dynamic Systems",
      "author" : [ "Ho", "Y.-C", "Cao", "X.-R" ],
      "venue" : null,
      "citeRegEx" : "Ho et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Ho et al\\.",
      "year" : 1991
    }, {
      "title" : "Reinforcement Learning Algorithm for Partially Observable Markov Decision Problems",
      "author" : [ "T. Jaakkola", "S.P. Singh", "M.I. Jordan" ],
      "venue" : "Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Jaakkola et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Jaakkola et al\\.",
      "year" : 1995
    }, {
      "title" : "An analysis of actor/critic algorithms using eligibility traces: Reinforcement learning with imperfect value functions",
      "author" : [ "H. Kimura", "S. Kobayashi" ],
      "venue" : "In Fifteenth International Conference on Machine Learning,",
      "citeRegEx" : "Kimura and Kobayashi,? \\Q1998\\E",
      "shortCiteRegEx" : "Kimura and Kobayashi",
      "year" : 1998
    }, {
      "title" : "Reinforcement learning for continuous action using stochastic gradient ascent",
      "author" : [ "H. Kimura", "S. Kobayashi" ],
      "venue" : "In Intelligent Autonomous Systems",
      "citeRegEx" : "Kimura and Kobayashi,? \\Q1998\\E",
      "shortCiteRegEx" : "Kimura and Kobayashi",
      "year" : 1998
    }, {
      "title" : "Reinforcement learning in POMDPs with function approximation",
      "author" : [ "H. Kimura", "K. Miyazaki", "S. Kobayashi" ],
      "venue" : "Proceedings of the Fourteenth International Conference on Machine Learning",
      "citeRegEx" : "Kimura et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Kimura et al\\.",
      "year" : 1997
    }, {
      "title" : "Reinforcement learning by stochastic hill climbing on discounted reward",
      "author" : [ "H. Kimura", "M. Yamamura", "S. Kobayashi" ],
      "venue" : "In Proceedings of the Twelfth International Conference on Machine Learning",
      "citeRegEx" : "Kimura et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Kimura et al\\.",
      "year" : 1995
    }, {
      "title" : "Actor-Critic Algorithms",
      "author" : [ "V.R. Konda", "J.N. Tsitsiklis" ],
      "venue" : "In Neural Information Processing Systems",
      "citeRegEx" : "Konda and Tsitsiklis,? \\Q2000\\E",
      "shortCiteRegEx" : "Konda and Tsitsiklis",
      "year" : 2000
    }, {
      "title" : "The Theory of Matrices",
      "author" : [ "P. Lancaster", "M. Tismenetsky" ],
      "venue" : null,
      "citeRegEx" : "Lancaster and Tismenetsky,? \\Q1985\\E",
      "shortCiteRegEx" : "Lancaster and Tismenetsky",
      "year" : 1985
    }, {
      "title" : "Simulation-Based Optimization of Markov Reward Processes",
      "author" : [ "P. Marbach", "J.N. Tsitsiklis" ],
      "venue" : null,
      "citeRegEx" : "Marbach and Tsitsiklis,? \\Q1998\\E",
      "shortCiteRegEx" : "Marbach and Tsitsiklis",
      "year" : 1998
    }, {
      "title" : "Off-policy policy search",
      "author" : [ "N. Meuleau", "L. Peshkin", "L.P. Kaelbling", "Kim", "K.-E" ],
      "venue" : "Tech. rep.,",
      "citeRegEx" : "Meuleau et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Meuleau et al\\.",
      "year" : 2000
    }, {
      "title" : "Learning finite-state controllers for partially observable environments",
      "author" : [ "N. Meuleau", "L. Peshkin", "Kim", "K.-E", "L.P. Kaelbling" ],
      "venue" : "In Proceedings of the Fifteenth International Conference on Uncertainty in Artificial Intelligence",
      "citeRegEx" : "Meuleau et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Meuleau et al\\.",
      "year" : 1999
    }, {
      "title" : "Learning to cooperate via policy search",
      "author" : [ "L. Peshkin", "Kim", "K.-E", "N. Meuleau", "L.P. Kaelbling" ],
      "venue" : "In Proceedings of the Sixteenth International Conference on Uncertainty in Artificial Intelligence",
      "citeRegEx" : "Peshkin et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Peshkin et al\\.",
      "year" : 2000
    }, {
      "title" : "Sensitivity analysis via likelihood ratios",
      "author" : [ "M.I. Reiman", "A. Weiss" ],
      "venue" : "In Proceedings of the 1986 Winter Simulation Conference",
      "citeRegEx" : "Reiman and Weiss,? \\Q1986\\E",
      "shortCiteRegEx" : "Reiman and Weiss",
      "year" : 1986
    }, {
      "title" : "Sensitivity analysis for simulations via likelihood ratios",
      "author" : [ "M.I. Reiman", "A. Weiss" ],
      "venue" : "Operations Research,",
      "citeRegEx" : "Reiman and Weiss,? \\Q1989\\E",
      "shortCiteRegEx" : "Reiman and Weiss",
      "year" : 1989
    }, {
      "title" : "Some Problems in Monte Carlo Optimization",
      "author" : [ "R.Y. Rubinstein" ],
      "venue" : "Ph.D. thesis.",
      "citeRegEx" : "Rubinstein,? 1969",
      "shortCiteRegEx" : "Rubinstein",
      "year" : 1969
    }, {
      "title" : "How to optimize complex stochastic systems from a single sample path by the score function method",
      "author" : [ "R.Y. Rubinstein" ],
      "venue" : "Annals of Operations Research, 27, 175–211.",
      "citeRegEx" : "Rubinstein,? 1991",
      "shortCiteRegEx" : "Rubinstein",
      "year" : 1991
    }, {
      "title" : "Decomposable score function estimators for sensitivity analysis and optimization of queueing networks",
      "author" : [ "R.Y. Rubinstein" ],
      "venue" : "Annals of Operations Research, 39, 195–229.",
      "citeRegEx" : "Rubinstein,? 1992",
      "shortCiteRegEx" : "Rubinstein",
      "year" : 1992
    }, {
      "title" : "Some Studies in Machine Learning Using the Game of Checkers",
      "author" : [ "A.L. Samuel" ],
      "venue" : "IBM Journal of Research and Development, 3, 210–229.",
      "citeRegEx" : "Samuel,? 1959",
      "shortCiteRegEx" : "Samuel",
      "year" : 1959
    }, {
      "title" : "Integral, Measure and Derivative: A Unified Approach",
      "author" : [ "G.E. Shilov", "B.L. Gurevich" ],
      "venue" : null,
      "citeRegEx" : "Shilov and Gurevich,? \\Q1966\\E",
      "shortCiteRegEx" : "Shilov and Gurevich",
      "year" : 1966
    }, {
      "title" : "Learning Without State-Estimation in Partially Observable Markovian Decision Processes",
      "author" : [ "S.P. Singh", "T. Jaakkola", "M.I. Jordan" ],
      "venue" : "In Proceedings of the Eleventh International Conference on Machine Learning",
      "citeRegEx" : "Singh et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Singh et al\\.",
      "year" : 1994
    }, {
      "title" : "Reinforcement learning for dynamic channel allocation in cellular telephone systems",
      "author" : [ "S. Singh", "D. Bertsekas" ],
      "venue" : "In Advances in Neural Information Processing Systems: Proceedings of the 1996 Conference,",
      "citeRegEx" : "Singh and Bertsekas,? \\Q1997\\E",
      "shortCiteRegEx" : "Singh and Bertsekas",
      "year" : 1997
    }, {
      "title" : "The optimal control of partially observable Markov decision processes over a finite horizon",
      "author" : [ "R.D. Smallwood", "E.J. Sondik" ],
      "venue" : "Operations Research,",
      "citeRegEx" : "Smallwood and Sondik,? \\Q1973\\E",
      "shortCiteRegEx" : "Smallwood and Sondik",
      "year" : 1973
    }, {
      "title" : "The optimal control of partially observable Markov decision processes over the infinite horizon: Discounted costs",
      "author" : [ "E.J. Sondik" ],
      "venue" : "Operations Research, 26.",
      "citeRegEx" : "Sondik,? 1978",
      "shortCiteRegEx" : "Sondik",
      "year" : 1978
    }, {
      "title" : "Reinforcement Learning: An Introduction",
      "author" : [ "R.S. Sutton", "A.G. Barto" ],
      "venue" : null,
      "citeRegEx" : "Sutton and Barto,? \\Q1998\\E",
      "shortCiteRegEx" : "Sutton and Barto",
      "year" : 1998
    }, {
      "title" : "Policy Gradient Methods for Reinforcement Learning with Function Approximation",
      "author" : [ "R.S. Sutton", "D. McAllester", "S. Singh", "Y. Mansour" ],
      "venue" : "In Neural Information Processing Systems",
      "citeRegEx" : "Sutton et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Sutton et al\\.",
      "year" : 2000
    }, {
      "title" : "A multi-agent, policy-gradient approach to network routing",
      "author" : [ "N. Tao", "J. Baxter", "L. Weaver" ],
      "venue" : null,
      "citeRegEx" : "Tao et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Tao et al\\.",
      "year" : 2001
    }, {
      "title" : "Practical Issues in Temporal Difference Learning",
      "author" : [ "G. Tesauro" ],
      "venue" : "Machine Learning, 8, 257– 278.",
      "citeRegEx" : "Tesauro,? 1992",
      "shortCiteRegEx" : "Tesauro",
      "year" : 1992
    }, {
      "title" : "TD-Gammon, a self-teaching backgammon program, achieves master-level play",
      "author" : [ "G. Tesauro" ],
      "venue" : "Neural Computation, 6, 215–219.",
      "citeRegEx" : "Tesauro,? 1994",
      "shortCiteRegEx" : "Tesauro",
      "year" : 1994
    }, {
      "title" : "An Analysis of Temporal Difference Learning with Function Approximation",
      "author" : [ "J.N. Tsitsikilis", "B. Van-Roy" ],
      "venue" : "IEEE Transactions on Automatic Control,",
      "citeRegEx" : "Tsitsikilis and Van.Roy,? \\Q1997\\E",
      "shortCiteRegEx" : "Tsitsikilis and Van.Roy",
      "year" : 1997
    }, {
      "title" : "Simple Statistical Gradient-Following Algorithms for Connectionist Reinforcement Learning",
      "author" : [ "R.J. Williams" ],
      "venue" : "Machine Learning, 8, 229–256.",
      "citeRegEx" : "Williams,? 1992",
      "shortCiteRegEx" : "Williams",
      "year" : 1992
    }, {
      "title" : "A reinforcement learning approach to job-shop scheduling",
      "author" : [ "W. Zhang", "T. Dietterich" ],
      "venue" : "In Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Zhang and Dietterich,? \\Q1995\\E",
      "shortCiteRegEx" : "Zhang and Dietterich",
      "year" : 1995
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "Introduction Dynamic Programming is the method of choice for solving problems of decision making under uncertainty (Bertsekas, 1995).",
      "startOffset" : 115,
      "endOffset" : 132
    }, {
      "referenceID" : 31,
      "context" : "This approach has yielded some remarkable empirical successes in a number of different domains, including learning to play checkers (Samuel, 1959), backgammon (Tesauro, 1992, 1994), and chess (Baxter, Tridgell, & Weaver, 2000), job-shop scheduling (Zhang & Dietterich, 1995) and dynamic channel allocation (Singh & Bertsekas, 1997).",
      "startOffset" : 132,
      "endOffset" : 146
    }, {
      "referenceID" : 28,
      "context" : "The technique is called the score function or likelihood ratio method and appears to have been first proposed in the sixties (Aleksandrov, Sysoyev, & Shemeneva, 1968; Rubinstein, 1969) for computing performance gradients in i.",
      "startOffset" : 125,
      "endOffset" : 184
    }, {
      "referenceID" : 11,
      "context" : "1 UNBIASED ESTIMATES OF THE PERFORMANCE GRADIENT FOR REGENERATIVE PROCESSES Extensions of the likelihood-ratio method to regenerative processes (including Markov Decision Processes or MDPs) were given by Glynn (1986, 1990), Glynn and L‘Ecuyer (1995) and Reiman and Weiss (1986, 1989), and independently for episodic Partially Observable Markov Decision Processes (POMDPs) by Williams (1992), who introduced the REINFORCE algorithm2.",
      "startOffset" : 204,
      "endOffset" : 250
    }, {
      "referenceID" : 11,
      "context" : "1 UNBIASED ESTIMATES OF THE PERFORMANCE GRADIENT FOR REGENERATIVE PROCESSES Extensions of the likelihood-ratio method to regenerative processes (including Markov Decision Processes or MDPs) were given by Glynn (1986, 1990), Glynn and L‘Ecuyer (1995) and Reiman and Weiss (1986, 1989), and independently for episodic Partially Observable Markov Decision Processes (POMDPs) by Williams (1992), who introduced the REINFORCE algorithm2.",
      "startOffset" : 204,
      "endOffset" : 391
    }, {
      "referenceID" : 4,
      "context" : "This terminology is used in Barto et al. (1983).",
      "startOffset" : 28,
      "endOffset" : 48
    }, {
      "referenceID" : 43,
      "context" : "As Williams (1992) pointed out, a further simplification is possible in the case that rT = r(X0; : : : ;XT ) is a sum of scalar rewards r(Xt; t) depending on the state and possibly the time t since the starting state (such as r(Xt; t) = r(Xt), or r(Xt; t) = tr(Xt) as above).",
      "startOffset" : 3,
      "endOffset" : 19
    }, {
      "referenceID" : 25,
      "context" : "1 and the variants above have been extended to cover multiple agents (Peshkin et al., 2000), policies with internal state (Meuleau et al.",
      "startOffset" : 69,
      "endOffset" : 91
    }, {
      "referenceID" : 24,
      "context" : ", 2000), policies with internal state (Meuleau et al., 1999), and importance sampling methods (Meuleau et al.",
      "startOffset" : 38,
      "endOffset" : 60
    }, {
      "referenceID" : 23,
      "context" : ", 1999), and importance sampling methods (Meuleau et al., 2000).",
      "startOffset" : 41,
      "endOffset" : 63
    }, {
      "referenceID" : 16,
      "context" : "Marbach and Tsitsiklis (1998) provide the only convergence proof that we know of, albeit for a slightly different update of the form t+1 = t + t [r(Xt; s) \u0011̂( t)℄ zt, where \u0011̂( t) is a moving estimate of the expected performance, and is also updated on-line (this update was first suggested in the context of POMDPs by Jaakkola et al.",
      "startOffset" : 0,
      "endOffset" : 30
    }, {
      "referenceID" : 13,
      "context" : "Marbach and Tsitsiklis (1998) provide the only convergence proof that we know of, albeit for a slightly different update of the form t+1 = t + t [r(Xt; s) \u0011̂( t)℄ zt, where \u0011̂( t) is a moving estimate of the expected performance, and is also updated on-line (this update was first suggested in the context of POMDPs by Jaakkola et al. (1995)).",
      "startOffset" : 319,
      "endOffset" : 342
    }, {
      "referenceID" : 13,
      "context" : "Marbach and Tsitsiklis (1998) provide the only convergence proof that we know of, albeit for a slightly different update of the form t+1 = t + t [r(Xt; s) \u0011̂( t)℄ zt, where \u0011̂( t) is a moving estimate of the expected performance, and is also updated on-line (this update was first suggested in the context of POMDPs by Jaakkola et al. (1995)). Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search).",
      "startOffset" : 319,
      "endOffset" : 374
    }, {
      "referenceID" : 1,
      "context" : "Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search).",
      "startOffset" : 119,
      "endOffset" : 142
    }, {
      "referenceID" : 1,
      "context" : "Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search). This last paper contains an interesting insight: through suitable choices of the performance function r(X0; : : : ;XT ; ), one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto et al. (1983); the policy is the actor and the value function is the critic.",
      "startOffset" : 119,
      "endOffset" : 503
    }, {
      "referenceID" : 1,
      "context" : "Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search). This last paper contains an interesting insight: through suitable choices of the performance function r(X0; : : : ;XT ; ), one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto et al. (1983); the policy is the actor and the value function is the critic. The primary motivation is to reduce variance in the policy-gradient estimates. Experimental evidence for this phenomenon has been presented by a number of authors, including Barto et al. (1983), Kimura and Kobayashi (1998a), and Baird and Moore (1999).",
      "startOffset" : 119,
      "endOffset" : 760
    }, {
      "referenceID" : 1,
      "context" : "Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search). This last paper contains an interesting insight: through suitable choices of the performance function r(X0; : : : ;XT ; ), one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto et al. (1983); the policy is the actor and the value function is the critic. The primary motivation is to reduce variance in the policy-gradient estimates. Experimental evidence for this phenomenon has been presented by a number of authors, including Barto et al. (1983), Kimura and Kobayashi (1998a), and Baird and Moore (1999).",
      "startOffset" : 119,
      "endOffset" : 790
    }, {
      "referenceID" : 1,
      "context" : "Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search). This last paper contains an interesting insight: through suitable choices of the performance function r(X0; : : : ;XT ; ), one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto et al. (1983); the policy is the actor and the value function is the critic. The primary motivation is to reduce variance in the policy-gradient estimates. Experimental evidence for this phenomenon has been presented by a number of authors, including Barto et al. (1983), Kimura and Kobayashi (1998a), and Baird and Moore (1999). More recent work on this subject includes that of Sutton et al.",
      "startOffset" : 119,
      "endOffset" : 818
    }, {
      "referenceID" : 1,
      "context" : "Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search). This last paper contains an interesting insight: through suitable choices of the performance function r(X0; : : : ;XT ; ), one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto et al. (1983); the policy is the actor and the value function is the critic. The primary motivation is to reduce variance in the policy-gradient estimates. Experimental evidence for this phenomenon has been presented by a number of authors, including Barto et al. (1983), Kimura and Kobayashi (1998a), and Baird and Moore (1999). More recent work on this subject includes that of Sutton et al. (2000) and Konda and Tsitsiklis (2000).",
      "startOffset" : 119,
      "endOffset" : 890
    }, {
      "referenceID" : 1,
      "context" : "Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search). This last paper contains an interesting insight: through suitable choices of the performance function r(X0; : : : ;XT ; ), one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto et al. (1983); the policy is the actor and the value function is the critic. The primary motivation is to reduce variance in the policy-gradient estimates. Experimental evidence for this phenomenon has been presented by a number of authors, including Barto et al. (1983), Kimura and Kobayashi (1998a), and Baird and Moore (1999). More recent work on this subject includes that of Sutton et al. (2000) and Konda and Tsitsiklis (2000). We discuss the use of VAPS-style updates further in Section 6.",
      "startOffset" : 119,
      "endOffset" : 922
    }, {
      "referenceID" : 1,
      "context" : "Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search). This last paper contains an interesting insight: through suitable choices of the performance function r(X0; : : : ;XT ; ), one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto et al. (1983); the policy is the actor and the value function is the critic. The primary motivation is to reduce variance in the policy-gradient estimates. Experimental evidence for this phenomenon has been presented by a number of authors, including Barto et al. (1983), Kimura and Kobayashi (1998a), and Baird and Moore (1999). More recent work on this subject includes that of Sutton et al. (2000) and Konda and Tsitsiklis (2000). We discuss the use of VAPS-style updates further in Section 6.2. So far we have not addressed the question of how the parameterized state-transition probabilities pXtXt+1( ) arise. Of course, they could simply be generated by parameterizing the matrix of transition probabilities directly. Alternatively, in the case of MDPs or POMDPs, state transitions are typically generated by feeding an observation Yt that depends stochastically on the state Xt into a parameterized stochastic policy, which selects a control Ut at random from a set of available controls (approximate value-function based approaches that generate controls stochastically via some form of lookahead also fall into this category). The distribution over successor states pXtXt+1(Ut) is then a fixed function of the control. If we denote the probability of control ut given parameters and observation yt by ut( ; yt), then all of the above discussion carries through with rpXtXt+1( )=pXtXt+1( ) replaced by r Ut( ; Yt)= Ut( ; Yt). In that case, Algorithm 1.1 is precisely Williams’ REINFORCE algorithm. Algorithm 1.1 and the variants above have been extended to cover multiple agents (Peshkin et al., 2000), policies with internal state (Meuleau et al., 1999), and importance sampling methods (Meuleau et al., 2000). We also refer the reader to the work of Rubinstein and Shapiro (1993) and Rubinstein and Melamed (1998) for in-depth analysis of the application of the likelihood-ratio method to Discrete-Event Systems (DES), in particular networks of queues.",
      "startOffset" : 119,
      "endOffset" : 2279
    }, {
      "referenceID" : 1,
      "context" : "Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search). This last paper contains an interesting insight: through suitable choices of the performance function r(X0; : : : ;XT ; ), one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto et al. (1983); the policy is the actor and the value function is the critic. The primary motivation is to reduce variance in the policy-gradient estimates. Experimental evidence for this phenomenon has been presented by a number of authors, including Barto et al. (1983), Kimura and Kobayashi (1998a), and Baird and Moore (1999). More recent work on this subject includes that of Sutton et al. (2000) and Konda and Tsitsiklis (2000). We discuss the use of VAPS-style updates further in Section 6.2. So far we have not addressed the question of how the parameterized state-transition probabilities pXtXt+1( ) arise. Of course, they could simply be generated by parameterizing the matrix of transition probabilities directly. Alternatively, in the case of MDPs or POMDPs, state transitions are typically generated by feeding an observation Yt that depends stochastically on the state Xt into a parameterized stochastic policy, which selects a control Ut at random from a set of available controls (approximate value-function based approaches that generate controls stochastically via some form of lookahead also fall into this category). The distribution over successor states pXtXt+1(Ut) is then a fixed function of the control. If we denote the probability of control ut given parameters and observation yt by ut( ; yt), then all of the above discussion carries through with rpXtXt+1( )=pXtXt+1( ) replaced by r Ut( ; Yt)= Ut( ; Yt). In that case, Algorithm 1.1 is precisely Williams’ REINFORCE algorithm. Algorithm 1.1 and the variants above have been extended to cover multiple agents (Peshkin et al., 2000), policies with internal state (Meuleau et al., 1999), and importance sampling methods (Meuleau et al., 2000). We also refer the reader to the work of Rubinstein and Shapiro (1993) and Rubinstein and Melamed (1998) for in-depth analysis of the application of the likelihood-ratio method to Discrete-Event Systems (DES), in particular networks of queues.",
      "startOffset" : 119,
      "endOffset" : 2313
    }, {
      "referenceID" : 1,
      "context" : "Marbach and Tsitsiklis (1998) also considered the case of -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their “VAPS” algorithm (Value And Policy Search). This last paper contains an interesting insight: through suitable choices of the performance function r(X0; : : : ;XT ; ), one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto et al. (1983); the policy is the actor and the value function is the critic. The primary motivation is to reduce variance in the policy-gradient estimates. Experimental evidence for this phenomenon has been presented by a number of authors, including Barto et al. (1983), Kimura and Kobayashi (1998a), and Baird and Moore (1999). More recent work on this subject includes that of Sutton et al. (2000) and Konda and Tsitsiklis (2000). We discuss the use of VAPS-style updates further in Section 6.2. So far we have not addressed the question of how the parameterized state-transition probabilities pXtXt+1( ) arise. Of course, they could simply be generated by parameterizing the matrix of transition probabilities directly. Alternatively, in the case of MDPs or POMDPs, state transitions are typically generated by feeding an observation Yt that depends stochastically on the state Xt into a parameterized stochastic policy, which selects a control Ut at random from a set of available controls (approximate value-function based approaches that generate controls stochastically via some form of lookahead also fall into this category). The distribution over successor states pXtXt+1(Ut) is then a fixed function of the control. If we denote the probability of control ut given parameters and observation yt by ut( ; yt), then all of the above discussion carries through with rpXtXt+1( )=pXtXt+1( ) replaced by r Ut( ; Yt)= Ut( ; Yt). In that case, Algorithm 1.1 is precisely Williams’ REINFORCE algorithm. Algorithm 1.1 and the variants above have been extended to cover multiple agents (Peshkin et al., 2000), policies with internal state (Meuleau et al., 1999), and importance sampling methods (Meuleau et al., 2000). We also refer the reader to the work of Rubinstein and Shapiro (1993) and Rubinstein and Melamed (1998) for in-depth analysis of the application of the likelihood-ratio method to Discrete-Event Systems (DES), in particular networks of queues. Also worth mentioning is the large literature on Infinitesimal Perturbation Analysis (IPA), which seeks a similar goal of estimating performance gradients, but operates under more restrictive assumptions than the likelihoodratio approach; see, for example, Ho and Cao (1991).",
      "startOffset" : 119,
      "endOffset" : 2727
    }, {
      "referenceID" : 12,
      "context" : "The first method takes as a starting point the formula5 for the eligibility trace at time t: zt = t 1 Xs=0 rpXsXs+1( ) pXsXs+1( ) and simply truncates it at some (fixed, not random) number of terms n looking backwards (Glynn, 1990; Rubinstein, 1991, 1992; Cao & Wan, 1998): zt(n) := t 1 X s=t n rpXsXs+1( ) pXsXs+1( ) : (7)",
      "startOffset" : 218,
      "endOffset" : 272
    }, {
      "referenceID" : 16,
      "context" : "(1995, 1997) and for continuous control by Kimura and Kobayashi (1998b). In fact the use of (r(Xt) b) in place of r(Xt) does not affect the expectation of the estimates of the algorithm (although judicious choice of the reward baseline b can reduce the variance of the estimates).",
      "startOffset" : 43,
      "endOffset" : 72
    }, {
      "referenceID" : 16,
      "context" : "(1995, 1997) and for continuous control by Kimura and Kobayashi (1998b). In fact the use of (r(Xt) b) in place of r(Xt) does not affect the expectation of the estimates of the algorithm (although judicious choice of the reward baseline b can reduce the variance of the estimates). While the algorithm presented by Kimura et al. (1995) provides estimates of the expectation under the stationary distribution of the gradient of the discounted reward, we will show that these are in fact biased estimates of the gradient of the expected discounted reward.",
      "startOffset" : 43,
      "endOffset" : 335
    }, {
      "referenceID" : 16,
      "context" : "(1995, 1997) and for continuous control by Kimura and Kobayashi (1998b). In fact the use of (r(Xt) b) in place of r(Xt) does not affect the expectation of the estimates of the algorithm (although judicious choice of the reward baseline b can reduce the variance of the estimates). While the algorithm presented by Kimura et al. (1995) provides estimates of the expectation under the stationary distribution of the gradient of the discounted reward, we will show that these are in fact biased estimates of the gradient of the expected discounted reward. This arises because the stationary distribution itself depends on the parameters. A similar estimate to (11) was also proposed by Marbach and Tsitsiklis (1998), but this time with r(Xt)zt( ) replaced by (r(Xt) \u0011̂( ))zt( ), where \u0011̂( ) is an estimate of the average reward, and with zt zeroed on visits to an identifiable recurrent state.",
      "startOffset" : 43,
      "endOffset" : 713
    }, {
      "referenceID" : 5,
      "context" : "In a companion paper we show how the gradient estimates produced by GPOMDP can be used to perform gradient ascent on the average reward ( ) (Baxter et al., 2001).",
      "startOffset" : 140,
      "endOffset" : 161
    }, {
      "referenceID" : 2,
      "context" : "Better estimates of the bias and variance of GPOMDP may be found in Bartlett and Baxter (2001), for more general Markov chains than those treated here, and for more refined notions of the mixing time.",
      "startOffset" : 68,
      "endOffset" : 95
    }, {
      "referenceID" : 5,
      "context" : "However, when we consider gradient-ascent algorithms Baxter et al. (2001), this assumption becomes more restrictive since it guarantees that the recurrence class cannot change as the parameters are adjusted.",
      "startOffset" : 53,
      "endOffset" : 74
    }, {
      "referenceID" : 7,
      "context" : "where r = [r(1); : : : ; r(n)℄0 (Bertsekas, 1995).",
      "startOffset" : 32,
      "endOffset" : 49
    }, {
      "referenceID" : 7,
      "context" : "Observe that J satisfies the Bellman equations: J = r + PJ : (20) (Bertsekas, 1995).",
      "startOffset" : 66,
      "endOffset" : 83
    }, {
      "referenceID" : 18,
      "context" : "In fact, Theorem 1 in (Kimura et al., 1997) shows that the gradient estimates of the algorithm presented in that paper converge to (1 ) 0rJ .",
      "startOffset" : 22,
      "endOffset" : 43
    }, {
      "referenceID" : 18,
      "context" : "In fact, Theorem 1 in (Kimura et al., 1997) shows that the gradient estimates of the algorithm presented in that paper converge to (1 ) 0rJ . By the Bellman equations (20), this is equal to (1 ) ( 0rPJ + 0rJ ), which implies (1 ) 0rJ = 0rPJ . Thus the algorithm of Kimura et al. (1997) also estimates the second term in the expression for r ( ) given by (19).",
      "startOffset" : 23,
      "endOffset" : 286
    }, {
      "referenceID" : 18,
      "context" : "In fact, Theorem 1 in (Kimura et al., 1997) shows that the gradient estimates of the algorithm presented in that paper converge to (1 ) 0rJ . By the Bellman equations (20), this is equal to (1 ) ( 0rPJ + 0rJ ), which implies (1 ) 0rJ = 0rPJ . Thus the algorithm of Kimura et al. (1997) also estimates the second term in the expression for r ( ) given by (19). It is important to note that 0rJ 6= r [ 0J ℄—the two quantities disagree by the first term in (19). This arises because the the stationary distribution itself depends on the parameters. Hence, the algorithm of Kimura et al. (1997) does not estimate the gradient of the expected discounted reward.",
      "startOffset" : 23,
      "endOffset" : 591
    }, {
      "referenceID" : 18,
      "context" : "GPOMDP is essentially the algorithm proposed by Kimura et al. (1997) without the reward baseline.",
      "startOffset" : 48,
      "endOffset" : 69
    }, {
      "referenceID" : 4,
      "context" : "This kind of update is known as an actor-critic algorithm (Barto et al., 1983), with the policy playing the role of the actor, and the value function playing the role of the critic.",
      "startOffset" : 58,
      "endOffset" : 78
    }, {
      "referenceID" : 9,
      "context" : "Parameter-dependent rewards have been considered by Glynn (1990), Marbach and Tsitsiklis (1998), and Baird and Moore (1999).",
      "startOffset" : 52,
      "endOffset" : 65
    }, {
      "referenceID" : 9,
      "context" : "Parameter-dependent rewards have been considered by Glynn (1990), Marbach and Tsitsiklis (1998), and Baird and Moore (1999).",
      "startOffset" : 52,
      "endOffset" : 96
    }, {
      "referenceID" : 1,
      "context" : "Parameter-dependent rewards have been considered by Glynn (1990), Marbach and Tsitsiklis (1998), and Baird and Moore (1999). In particular, Baird and Moore (1999) showed how suitable choices of r( ; i) lead to a combination of value and policy search, or “VAPS”.",
      "startOffset" : 101,
      "endOffset" : 124
    }, {
      "referenceID" : 1,
      "context" : "Parameter-dependent rewards have been considered by Glynn (1990), Marbach and Tsitsiklis (1998), and Baird and Moore (1999). In particular, Baird and Moore (1999) showed how suitable choices of r( ; i) lead to a combination of value and policy search, or “VAPS”.",
      "startOffset" : 101,
      "endOffset" : 163
    }, {
      "referenceID" : 10,
      "context" : "(For definitions see, for example, (Dudley, 1989).",
      "startOffset" : 35,
      "endOffset" : 49
    }, {
      "referenceID" : 25,
      "context" : "For similar observations in the context of REINFORCE and VAPS, see Peshkin et al. (2000). This algorithm gives a biologically plausible synaptic weight-update rule when applied to networks of spiking neurons in which the neurons are regarded as independent agents (Bartlett & Baxter, 1999), and has shown some promise in a network routing application (Tao, Baxter, & Weaver, 2001).",
      "startOffset" : 67,
      "endOffset" : 89
    }, {
      "referenceID" : 36,
      "context" : "Fortunately, the observation history may be summarized in the form of a belief state (the current distribution over states), which is itself updated based only upon the current observation, and knowledge of which is sufficient for optimal behaviour (Smallwood & Sondik, 1973; Sondik, 1978).",
      "startOffset" : 249,
      "endOffset" : 289
    }, {
      "referenceID" : 0,
      "context" : "An extension of GPOMDP to policies with parameterized internal belief states is described by Aberdeen and Baxter (2001), similar in spirit to the extension of VAPS and REINFORCE described by Meuleau et al.",
      "startOffset" : 93,
      "endOffset" : 120
    }, {
      "referenceID" : 0,
      "context" : "An extension of GPOMDP to policies with parameterized internal belief states is described by Aberdeen and Baxter (2001), similar in spirit to the extension of VAPS and REINFORCE described by Meuleau et al. (1999).",
      "startOffset" : 93,
      "endOffset" : 213
    }, {
      "referenceID" : 5,
      "context" : "In the companion paper (Baxter et al., 2001), we present experimental results showing rapid convergence of the estimates generated by GPOMDP to the true gradient r .",
      "startOffset" : 23,
      "endOffset" : 44
    } ],
    "year" : 2011,
    "abstractText" : "Gradient-based approaches to direct policy search in reinforcement learning have received much recent attention as a means to solve problems of partial observability and to avoid some of the problems associated with policy degradation in value-function methods. In this paper we introduce GPOMDP, a simulation-based algorithm for generating a biased estimate of the gradient of the average reward in Partially Observable Markov Decision Processes (POMDPs) controlled by parameterized stochastic policies. A similar algorithm was proposed by Kimura, Yamamura, and Kobayashi (1995). The algorithm’s chief advantages are that it requires storage of only twice the number of policy parameters, uses one free parameter 2 [0; 1) (which has a natural interpretation in terms of bias-variance trade-off), and requires no knowledge of the underlying state. We prove convergence of GPOMDP, and show how the correct choice of the parameter is related to the mixing time of the controlledPOMDP. We briefly describe extensions ofGPOMDP to controlled Markov chains, continuous state, observation and control spaces, multiple-agents, higher-order derivatives, and a version for training stochastic policies with internal states. In a companion paper (Baxter, Bartlett, & Weaver, 2001) we show how the gradient estimates generated by GPOMDP can be used in both a traditional stochastic gradient algorithm and a conjugate-gradient procedure to find local optima of the average reward.",
    "creator" : "dvips(k) 5.86 Copyright 1999 Radical Eye Software"
  }
}