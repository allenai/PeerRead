{
  "name" : "1501.06595.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "User Clustering in Online Advertising via Topic Models",
    "authors" : [ "Sahin Cem Geyik", "Ali Dasdan" ],
    "emails" : [ "sgeyik@turn.com", "adasdan@turn.com", "leekc307@gmail.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 1.\n06 59\n5v 2\n[ cs\n.A I]\n2 4\nFe b\n20 15\nCategories and Subject Descriptors J.0 [Computer Applications]: General ; I.5.3 [Computing Methodologies]: Pattern Recognition—Clustering\nGeneral Terms Algorithms, Application\nKeywords Online advertising, User clustering, Topic models\n* This work was completed while the author was with Turn Inc.\n."
    }, {
      "heading" : "1. INTRODUCTION",
      "text" : "In online advertising, the goal is to find the best ad under constraints for a given user in an online context. The context varies based on the applicable ad format (e.g., banner or display ad, video ad) and the device (e.g., desktop, mobile) the user is using at the time of the ad impression (showing the ad to user). The constraints are mainly imposed by advertisers on the target user and context parameters, e.g., users of certain age range visiting webpages of certain categories. The expectation of an advertiser is one of: brand recognition, clicks, or actions. Actions are advertiser defined and can be one of inquiring about or purchasing a product, filling out a form, visiting a certain page, etc. [8].\nA certain ad from an advertiser can be shown to a user in an online context only if the value for the ad impression opportunity is high enough to win in a real-time, competitive auction [2]. Advertisers directly or indirectly through demand-side platforms, entities that work on behalf of advertisers to deal with real-time bidding ad exchanges, signal their value via bids. The bid for an ad impression is calculated as the action probability given a user in a certain online context multiplied by the cost-per-action goal an advertiser wants to meet or beat.\nThe action probability computation is about computing the likelihood of an action by a certain user on a certain ad on a certain webpage. Since it is impossible for every user to see every ad on every webpage, the likelihood is almost always unknown. As a result, we need to use campaign/website/user hierarchies and other techniques to reduce this extreme sparsity and compute this extremely rare event [8]. The idea can be explained best by an example: The likelihood of a user visiting a certain webpage can be unknown or zero but we may have better confidence if we consider the likelihood of the same user visiting the top level domain that the webpage belongs to (e.g. finance page of a news website vs. any page under the same news website). The example that applies to this paper is along the user dimension: The likelihood of a user acting on a certain ad on a certain webpage can be unknown but we may approximate the likelihood if we consider the actions of similar users on the same or similar webpages or the top level domains they belong to.\nUser similarity can be deduced from user clustering. User clustering in turn can be done utilizing user attributes such as age, gender, income, geographic attributes; however, most of the user attributes come from third-party data providers, who provide the data to advertisers at a cost (and only for a subset of users). As a result, we have to resort to using\nuser attributes that do not come from these data providers. In this paper, we propose to use the event history of users to cluster users into multiple classes and use the class id as a feature combined with other features, such as advertiser and publisher properties, to calculate the action probability at the time of ad serving. This clustering process, named user segmentation in the advertising domain, is receiving increasing attention. We present current efforts in literature in § 2. Please see Figure 1 for a description of the problem we are attempting to solve. The event history is built by the event tracking process. When a user performs the designed action in the advertiser conversion page, a small piece of java script code, called beacon or tracking pixel, fires an event to the ad serving system to report that a desired action has been fulfilled. Since we use the beacon id to identify each event in our implementation, we will refer to events as beacons for the rest of the paper.\nThe methodology we propose in this paper is inspired highly by probabilistic latent semantic analysis (pLSA) [6], which has been used in document clustering, scene classification [3], and user clustering for news recommendation [4]. However, there is a significant difference between pLSA and our approach. While in pLSA the user and the item (e.g., recommended item for recommender systems, or generated words for document clustering) are independent of each other given the cluster information, in our case, the cluster id and the user id are independent of each other given a previous event of a user. Such a difference actually helps to determine the cluster which a new user belongs to at run-time just by looking at its beacon history. On the contrary, pLSA requires a huge amount of memory to store the cluster id for each existing user, and has to recompute the topic model from scratch for new users. Although the modification proposed for pLSA is pretty general and can be applied to multiple domains, we believe it especially is useful for online advertisement domain (due to the dynamic nature, i.e. constantly evolving set of users). This modification also significantly reduces the computation of the expectation maximization (EM) algorithm that is used to learn the clustering parameters.\nThe rest of the paper is as follows. We first give the relevant previous work for both user clustering, as well as its different applications, in § 2. Then, we introduce our methodology, as well as providing the differences compared to pLSA and our motivation in these differences in § 3. We give the implementation details in § 4. The initial results of our clustering methodology is provided in § 5. Finally, we conclude the paper and propose future work in § 6."
    }, {
      "heading" : "2. PREVIOUS WORK",
      "text" : "User clustering (or user segmentation) for better performance in advertising systems is a subject that has gained increasing attention in the past years. An analysis of how user segmentation can help click-through rate (CTR), i.e. the percentage of the advertisements that are clicked by a user, has been presented in [17], which justifies this interest.\nOne of the most common methodologies for grouping similarly behaving users in the online advertising domain is the utilization of topic models. [16] introduces Probabilistic Latent Semantic User Segmentation (PLSUS) for advertising, where each user is represented as a bag of words according to his/her search queries. Their methodology applies pLSA, hence suffers from the same problems aforementioned (new users and cost of computation). Latent Dirichlet Allocation (LDA) is also another type of topic model that is used commonly to cluster users for many applications. [5] gives an example where web users are clustered, assuming the users are the documents and the visited websites are the words. Furthermore, [14] gives an application of LDA for online advertising (but on a small, sampled set of users). The main problem with LDA is the computational complexity to train them, and the difficulty in assignment of a new user to a cluster (topic). While works such as [12] present distributed implementations of Latent Dirichlet Allocation and the Hierarchical Dirichet Process as fast ways to train topic models, implementation overhead (cost of human resources for implementation, as well as scalability issues that affect applicability on a real advertising scenario) is not negligible.\nOther than directly segmenting the users, there has also been work on estimating clicks or actions via the user properties. The first case we would like to list, similar to our work, is given in [1], where the authors utilize user actions to classify users into two groups for each advertiser: converters (will purchase, or click etc.) and non-converters. They utilize support vector machines (SVM), and train this model using the past actions of users (similar to the beacons we mention in this paper). The problem with this approach is that it effectively classifies users into two groups, and such grouping may not be valid for all campaigns (i.e. converter for an ad for a certain product may not be a converter for another product). Our clustering approach aims at separating users to multiple groups, and calculating action/click probabilities for each group, over many campaigns.\nAnother approach in utilizing user information for advertising is given in [10], where the authors employ friendship data (due to similarity of friends, i.e. homophily) as well as other information that arises in a large online social networking site. This kind of information however is often proprietary, and not available to most online advertisers. The paper in [7] aims at incorporating user demographic information into a text representation. This representation is later utilized for matching relevant ads to both ad and publisher’s textual properties to enhance advertising efficiency. While the authors show a CTR lift due to their methodology, it is not certain whether such matching is feasible or useful in online advertising systems where there is only limited demographic information for users as well as publishers (textual features such as title, keywords etc. are not always available, but are crucial for the methodology presented in the paper).\nFinally, in mobile advertising domain, [11] suggests the usage of mobile user patterns and therefore segmenting users\nbased on the pattern similarity. The authors utilize categorization of location and activities as well as a constraintbased Bayesian Matrix Factorization model to deal with sparsity. Main problems with this approach are due to privacy and scalability, i.e. the lack of detailed activity information available to advertising systems, and the number of users in the advertising domain that make it extremely hard for such methods to be applied."
    }, {
      "heading" : "3. METHODOLOGY",
      "text" : "As aforementioned, our clustering algorithm is highly inspired by the probabilistic Latent Semantic Analysis (pLSA) [6], with a difference in the independence assumption of user and cluster, given the history of the user. In this section, we first give an introduction to pLSA, and then give the difference of our model and our motivation to why we chose that path. We conclude this section with the algorithmic and mathematical details of the model we utilized."
    }, {
      "heading" : "3.1 Probabilistic Latent Semantic Analysis",
      "text" : "Probabilistic latent semantic analysis [6] assumes the existence of a latent class variable (i.e. clusters, or topics), and that each document has a distribution over the set of topics. Furthermore, it assumes that given the topic information, probability of a word being generated by a document is independent of that document’s id:\np(wordk|documentj, topici) = p(wordk|topici). (1)\nThis makes pLSA a really powerful generative model. That is, if we want to generate a new word from a document d, we need to first generate the topic, or cluster c (according to p(c|d)), and then pick up a word w (according to p(w|c)). Mapping of this to a recommendation system is by first selecting the cluster for a user (document) and then generating the item (word, i.e. recommendation) from this cluster.\nThe parameters of the pLSA model is learned using the expectation maximization algorithm [6] as follows:\n• Expectation Step: Update the probability of a cluster given the document and word:\np(ci|dj , wk) = p(ci, dj , wk)∑\ncm p(cm, dj , wk)\n= p(wk|ci) p(ci|dj) p(dj)∑\ncm p(wk|cm) p(cm|dj) p(dj)\n= p(wk|ci) p(ci|dj)∑\ncm p(wk|cm) p(cm|dj)\n.\n• Maximization Step: Update the conditional probabilities of words given clusters, and clusters given documents:\np(wk|ci) =\n∑ dj\np(ci, dj , wk) ∑\nwm ∑ dj p(ci, dj , wm)\n=\n∑ dj\nαp(dj , wk) p(ci|dj , wk) ∑\nwm ∑ dj αp(dj , wm) p(ci|dj , wm)\n=\n∑ dj\nn(dj , wk) p(ci|dj , wk) ∑\nwm ∑ dj n(dj , wm) p(ci|dj , wm)\nwhere n(dj , wk) is the number of times dj and wk has been seen together. This number arises when α is taken to be the total number of word-document cooccurences (i.e. p(dj , wk) =\nn(dj ,wk)∑ dn ∑ wm n(dn,wm) , hence\nα = ∑\ndn ∑ wm n(dn, wm)).\nFurthermore,\np(ci|dj) =\n∑ wk\np(ci, dj , wk)∑ cm ∑ wk p(cm, dj , wk)\n=\n∑ wk p(dj , wk) p(ci|dj , wk)\np(dj)\n=\n∑ wk αp(dj , wk) p(ci|dj , wk)\nαp(dj)\n=\n∑ wk n(dj , wk) p(ci|dj , wk)\nn(dj)\nwhere n(dj) is the number of times we have seen a word from document dj in the training data. This number arises when α is again taken to be the total number of word-document co-occurences (i.e. p(dj) =∑\nwm n(dj ,wm)\n∑ dn ∑ wm n(dn,wm) , hence α =\n∑ dn ∑ wm n(dn, wm)\nand n(dj) = ∑\nwm n(dj , wm). Please note that the\nα value also causes p(dj , wk) above the fraction to be n(dj , wk).\nAs aforementioned, the pLSA model is a very appropriate model for recommendation systems, since it is capable of suggesting a new item (i.e. one that the user has not seen before) to a user, due to the assumption that given the cluster id, the user and the item sets are independent of each other. But it comes with a cost, first being the necessity to store the cluster information for each user, and second the problem of determining cluster for the new users. In most recommendation systems, the user sets are quite stable (i.e. not too many users come and go), hence it is usually unlikely we will have to determine a user’s cluster after the training period is over. Even if the item lists change frequently, it is a much easier task to update the item probabilities for each cluster (a single maximization step), as long as the user sets do not change too frequently, in which case we need to run the whole EM-step.\nWe will next give the difficulties that arise in the domain of online advertising, hence the need for a different approach."
    }, {
      "heading" : "3.2 Challenges of Online Advertising",
      "text" : "As we have explained in the previous subsection, pLSA works well in recommending new items, given the users are stable and we know the cluster id for these users. In online advertising however, we try to provide to all the users over all the web (hence no subscription system), and the user ids are much more volatile, since a web user’s id is based on the cookies on his/her device. If these cookies are deleted, no longer is his cluster id valid, since the user id no longer exists as well. Also note that this causes many new users arrive in (or leave) the ecosystem every day. What we need is a system that looks at the history of the user’s events and assign it to a cluster at the ad-serving time (i.e. run-time).\nAnother problem in online advertising domain is the fact that we are not trying to recommend new items to users, at least not in the context of this paper. What we are trying to do is to be able to understand the action/click probability of a user, given that it belongs to a certain cluster (i.e. if a user belongs to a cluster due to his/her events, we want its cluster id, not what other events (beacons) it will perform, i.e. a generalization given its past events (beacons)). Hence we want a model which only looks at the event history of a user (not its user id, since it is too volatile) and give the group (cluster) id (this also covers all the new users, as long as we know their beacon history), so that we can calculate the action probability of that group (cluster). This also gives us the biggest difference of our methodology compared to pLSA: Given the beacon history, the user is independent of the cluster id. This difference, as well as others that arise from this, are given in the next subsection."
    }, {
      "heading" : "3.3 Differences of Our Methodology Compared to pLSA",
      "text" : "The biggest difference of the clustering method we employ compared to pLSA is in the model. Keeping with the terms of online advertising, while pLSA assumes the independency of the beacons given the user id, as long as the cluster id is known, we assert that the cluster id is independent of user id, given the beacon id. This independence assumption in the model helps us in determining the cluster of a new or existing user at run-time due to its beacon history, therefore, we do not need to store any cluster id for any user. Since now we can determine the cluster of a user at run-time, an ad-serving system tries to calculate the action or click probability of this user given a specific ad on a specific website (publisher) as “What is the action/click probability of a user belonging to cluster i for this ad at this website?”.\nPlease see the difference of the models as a plate notation in Figure 2. In the figure, it can be seen that the user notation could be directly removed from our model, and hence its relationship with pLSA becomes pretty weak (for good reason too, due to the nature of online advertising as we listed in previous section). Furthermore, our model is pretty general and can be applied to different application domains, however it is especially necessary and useful in online advertising due to constantly evolving set of users.\nOur proposed formulation naturally also brings some differences in the EM algorithm that needs to be run for training model probabilities. As an obvious example of this, we had mentioned previously that the expectation step of pLSA was calculating p(ci|dj , wk) which is the conditional probability of a cluster i given document j and word k, which can be interpreted into the online advertising domain as conditional probability of cluster i given user j (uj) and beacon k (bk). But due to our model’s independence assumption, p(ci|uj , bk) = p(ci|bk). The details of the EM algorithm we employ, as well as the determination of cluster for a user at run-time is given in the next subsection."
    }, {
      "heading" : "3.4 Training the Model and Run-time Cluster Determination for Users",
      "text" : "To be able to determine the cluster of a user at run-time, we need to have access to the beacon history of this user. The beacon history of a user is the set of beacons (events) that have been performed by this user in the previous x days (we took this value to be 60 days for our implementation),\ne.g. h(ui) = {bi,1, bi,2, ..., bi,n} for user i, if it has performed n actions/beacons. Not all of these n beacons have to be unique, hence we can come up with a probability distribution such as p(bj |ui) = n(bj ,ui)\nn(ui) , where n(bj , ui) is the number of\ntimes user i has seen beacon j, and n(ui) is the total number of beacons that user i has seen. Therefore, in run-time, we calculate below:\np(ci|uj) = ∑\nbk\np(ci, bk|uj) = ∑\nbk\np(ci|bk)p(bk|uj) (2)\nfor each cluster i, and determine the cluster that gives the maximum conditional probability to be the cluster that user j belongs to. Since the beacon probabilities given users are known during run-time, all we have to store is the beacon to cluster mapping (i.e. p(ci|bk) for all beacon cluster pairs). Please note that this requires much less storage than keeping cluster ids for each user (∼500 million users, while we take ∼600 clusters, due to our previous experience with different numbers of clusters, and around 13,000 beacons, and not every beacon has above zero conditional probability for each cluster). It is also robust to changing beacon history for each user, as well as new users (whose beacons might have been fired elsewhere, or these users were not present when model training was being performed). The EM algorithm is trying to maximize∏\n∀uj ∏ ∀ci where p(ci|uj)>0 p(ci|uj)\n= ∏\n∀uj ∏ ∀ci where p(ci|uj)>0 ∑ bk p(ci|bk)p(bk|uj), per Eq. 2. This process is directed by the above cluster determination policy, and is as follows:\n• Expectation Step: For each user in the training data, calculate the probability of this user belonging to a cluster i:\np(ci|uj) = ∑\nbk\np(ci|bk)p(bk|uj),\nwhich can further be written as: p(ci|uj) = ∑\nbk\np(ci) p(bk|ci)\np(bk) p(bk|uj),\nwhere p(bk) is the probability of beacon k, and is calculated as p(bk) = ∑ un n(un,bk)∑\nun ∑ bm n(un,bm) , where n(un, bk)\nis the number of times the beacon k has been seen by user n in the training data.\n• Maximization Step: In the maximization step, we calculate the values p(ci) and p(bk|ci):\np(ci) = ∑\nuj\np(uj) p(ci|uj),\nwhere p(ci|uj) is the output of the expectation step. Furthermore, the marginal probability for the user ui is p(ui) =\nn(ui)∑ ∀uj n(uj) where n(ui) is the number of\nbeacons ui has fired. We also calculate: p(bk|ci) = ∑\nuj\np(bk|uj)p(uj |ci)\n= ∑\nuj\np(bk|uj) p(ci|uj) p(uj)\np(ci)\nwhere p(ci|uj) is the output of the expectation step, and p(ci) is calculated as part of the maximization step.\nThe above formulation means that in the expectation step, we assign users to clusters (according to beacon cluster mapping, and since we do not have this at the beginning, randomly); and in the maximization step we calculate beacon to cluster mapping parameters, as well as the cluster probabilities. This goes on until convergence (i.e. the cluster probabilities as well as beacon to cluster probabilities no longer change significantly). This scheme is detailed in Algorithm 1. One detail in the algorithm is the difference between hard clustering and soft clustering. In hard clustering, we assign the user to the most likely cluster ci, making p(ci|u) = 1 (similar to run-time cluster determination); while in soft clustering we assign the user to multiple clusters where\n∑ ci p(ci|u) = 1.\nAt the end of EM process, we output p(ci|bk) for each beacon cluster pair, to be used in run-time user to cluster determination."
    }, {
      "heading" : "4. IMPLEMENTATION DETAILS",
      "text" : "We utilized Apache Pig [13] to implement the clustering algorithm outlined in this paper. Pig is a high-level language working on top of Hadoop [15] framework, hence makes our clustering task complete much quicker due to parallelization. As stated in the previous section, the clustering task starts with determining cluster id for each line (i.e. data for a single user) in the user information folder, that contains p(uj) as well as all the set of unique beacons this user has encountered, with their conditional probabilities (p(bk|uj)). This user data is pre-calculated to compress the whole training data, as well as to reduce the time for a single EM step. The pig script section for this cluster determination step is given in Figure 3(a). In the figure, userWeight is p(uj), user is a bag of p(bk|uj), CLUSTERID is a user defined function\nAlgorithm 1 EM Algorithm to Learn the Parameters of the User Clusters\nlearnClusterParameters (userSet U , beaconSet B, numClusters): for each user uj ∈ U do assign uj to a random ci where i ∈ [1,numClusters] p(ci|uj) = 1 end for for each cluster ci do\npold(ci) = null calculate pnew(ci) for each bk do\npold(bk|ci) = null calculate pnew(bk|ci)\nend for end for while {pold(ci) and pnew(ci) are significantly\ndifferent for any ci} OR\n{pold(bk|ci) and pnew(bk|ci) are significantly different for any ci and bk} do\nfor each user uj do if Soft Clustering then\nCalculate p(ci|uj) for all ci else\nChoose ci for uj where p(ci|uj) is maximum p(ci|uj) = 1\nend if end for for each cluster ci do\npold(ci) = pnew(ci) calculate pnew(ci) for each bk do\npold(bk|ci) = pnew(bk|ci) calculate pnew(bk|ci)\nend for end for\nend while for each cluster ci do\nfor each beacon bk do Calculate and return p(ci|bk)\nend for end for\n(udf) which has the inputs of p(ci) and p(bk|ci) as well as the user (bag of p(bk|uj)) and produces a bag of p(ci|uj) (i.e. clusterIdsWeights). This structure means that we can calculate the EM step parameters by flattening (unfolding) either the user bag, or clusterIdsWeights.\nAnother problem is the calculation of normalized probabilities, where at the beginning we have a weight for each probability, but we need the normalized values for the same group. For example, suppose in the below example, we start with a variable clusterBeaconWeight which has for each (ci,bk) pair the value αp(bk|ci) (where α is not known). To calculate the exact value p(bk|ci), we need to first group according to cluster id, then sum up p(bk|ci) as the normalizing factor. Later, we unfold the group with this sum appended, and then divide by the normalizer to find the exact probability. The example code piece that achieves this flow is given in Figure 3(b), where the number after PARALLEL\ngives the number of reducers, and the keyword FLATTEN is used to unfold the bag which is the set of p(bk|ci) for the same cluster.\nThe power of using Pig, hence the Hadoop framework is due to assigning the cluster ids to many users in different machines, as well as the sum operations working on different cluster parameters at the same time. Please note that the algorithm (Algorithm 1) we provided for model training is embarrassingly parallel, i.e. at each point of training we can divide the dataset completely according to current formulation we want to compute (whether by user id, beacon id, or cluster id). This also means that our parallel implementation is linearly scalable, i.e. it is n-times faster than a single machine approach at any step of training∗ , where n is the number of machines (e.g. number of reducers for reducer-side operations such as grouping and counting, or number of mappers for mapper-side operations, such as calculating p(ci|uj) in Algorithm 1). It all adds up to be able to learn the model feasibly for the huge number of users and events we deal with in online advertising domain. In our model, we utilized a set of ∼13,000 beacons that have been captured over 3 months. This set has been selected by first removing the both tails from the whole set of beacons, i.e. removing the most frequent (because they are not separative enough), and the least frequent (because they are too uncommon), and then sampling among the remaining beacons. This set of beacons have translated into ∼500 million users. We have observed that the EM algorithm converge in about 25-30 cycles (for hard clustering). This process takes about 15 minutes (for a setting of ∼3500 mappers, where the processing takes ∼1.5 minutes per mapper; and ∼400 reducers, where the processing takes ∼4 minutes per reducer) for each cycle in our test cluster, hence a total of 7 hours for the whole process.\n* In Algorithm 1, calculation of p(ci|uj) is one map-reduce job (mapper-intensive), and calculation of both pnew(ci) and pnew(bk|ci) is another separate map-reduce job (reducerintensive). These two run sequentially and repeatedly until convergence."
    }, {
      "heading" : "5. RESULTS",
      "text" : "In this section we will present our evaluation of the proposed clustering algorithm. We will provide both interpretability results (i.e. how the constructed clusters look like), as well as numerical results (i.e. how well advertising with the new clustering algorithm performs) in the rest of the section. Please note that we are giving a preliminary overview for the performance of our proposed method, and the reasons for non-exhaustive comparisons with other well-known methods are two-folds. First one is the inappropriateness of methods like pLSA and LDA for the dynamic nature of the users in online advertising, as well as the scalability issues in LDA (for the more advanced parallel training methods as mentioned in § 2, we still have significant implementation overhead in terms of man-hours). Second reason is the way we wanted to evaluate the proposed methodology. In our domain, we deploy new models into our actual advertising system to check their performances and any test means lost/gained revenue in such an industrial scenario. In most cases, the online test is the only feasible way to evaluate a new model/method, since this is the only way we can directly measure more relevant metrics (such as revenue, actions/clicks vs. cost of advertising etc.) in online advertising. This is why some of the more recent work [9] on offline evaluation is often not useful: the metrics that can be examined in such settings (such as click-through rate, AUC etc.) often do not correlate with online metrics. Due to this, it is not often possible to test many models (unless we are fairly confident of the performance) since it may mean lost revenue; this is why we limited the testing of our proposed model and algorithm to our previously employed algorithm based on cosine similarity metric. Therefore, in this section, we are basically evaluating how our model replacement efforts resulted.\nLet us start with our interpretability results, which is a way to manually check whether the clusters generated by our method make sense or not. Figure 4 gives a number of example clusters which were constructed by the proposed algorithm. Although we set our system to generate around 600 clusters (due to our previous experience with the domain, we found this to be a good number of partitions for the whole set of users), we only give eight of those clusters for presentational purposes. In the figure, we only show the top three beacons for each cluster, and the number between parantheses after each beacon definition gives the probability of that beacon being generated by a user belonging to that cluster (e.g. p(bHotel 2 - Conversion Action | Cluster 1) = 0.12). Due to privacy reasons, we did not give the exact names of the beacons we used, but rather we gave a categorization on the subject of the beacon and the type of event the beacon indicates. For example, Homepage Action means the visit of the home page of an advertiser by a user, whereas a Conversion Action usually indicates a purchase. We furthermore give the number of users that had fallen under a specific cluster (during the clustering process) next to the cluster in parantheses (e.g. during the clustering process, 661,083 users out of the ∼ 500M users we processed fell under Cluster 5 ).\nThe results, as a subset is given in the figure, shows that the clusters are mostly meaningful, i.e. the events (beacons) that fall under the same cluster are similar. Furthermore, it can be seen that they do not always belong to the same advertiser, but usually the same subject. For example, it can be seen that Cluster 7 have events/beacons from different\nadvertisers under it, one of them being a political campaign, one a political group, and one a political magazine. The clustering algorithm was able to gather these events under the same cluster since they all belong to the subject Politics (of course this is the expected behavior since the users that fall under this cluster are the ones that are interested in politics). Similar arguments can easily be made for the other clusters presented in the figure, and most of the clusters that are currently being used in our system, but not presented here.\nNext, we will give a comparison of the clustering algorithm against a previous system that was being used at our company’s advertising framework again for user segmentation. Our previous algorithm also utilizes user beacons, but employs a cosine similarity metric (by taking the beacon set as a feature vector for each user) to determine which users are closer, or more similar, to each other, hence should be in the same cluster for action rate and click rate calculation. In this algorithm, each beacon bi has a weight wi, i.e. wi = α|u(bi)| where u(bi) is the set of users that have fired this beacon at least once. Furthermore, each user uj is represented by a vector where the entries for the beacons that have been seen by this user has the value 1, and others 0 (i.e. v(uj) = [v1, ..., vn] where n is the total number of distinct beacons in the system, and vi = 1 if uj has seen beacon bi, 0 otherwise). The algorithm starts with n centroids, where n is the total number of beacons available (furthermore at the beginning, each centroid cm is a vector v(cm) = [v1, ..., vn] where only vm, representing beacon bm, is 1, and all other entries 0), and applies a k-means on these set of centroids (we take k = 600 similar to the new methodology). Each user uj is assigned to a centroid, hence cluster, as follows:\nCluster(uj) = argmaxci∈C v(ci) · v(uj)\n‖v(ci)‖ ‖v(uj)‖\nwhere the norm and dot product calculations take into account the weights (wi) of beacons (bi). Furthermore, the entries for the centroid vectors are updated during the kmeans according to vectors of the users assigned to them. In this algorithm, each k-means is followed by a merging stage where significantly closer centroids are merged. This process goes until no centroid merges are possible. The disadvantage of this algorithm is two-folds. The first one is the already high (and increasing) number of users in the\nadvertising domain, hence the computational issues. Second one is the assumption that any beacon seen by a user has the same weight for that user (i.e. we do not utilize p(beacon|user) values), which does not take into account the possibility that many of the same events (beacons) may indeed indicate higher interest on a specific type of product.\nWe have run an A/B test using two models, one utilizing the new clusters/methodology and one the old clusters/methodology. These models have been run on the whole set of campaigns within Turn, where impression traffic was directed to two models with equal priority. In the models, the users that belong to the same cluster have the same predicted action/click rates (which are utilized for calculating the bid value) for the same campaigns. These rates are again calculated from historical data of action/clicks (separately for each campaign) among the users that belong to the same cluster. Therefore, the cluster id is used as a single feature, alongside with the campaign id. We are providing results in terms of effective cost per action (eCPA) and effective cost per click (eCPC) metrics. These metrics can be described as follows:\n• Effective Cost per Action (eCPA): What is the average amount of money that is spent by an advertiser (on advertising) to receive one action (i.e. purchase etc.)? This metric can be calculated as:\neCPA = Advertising Cost\n# of Actions .\n• Effective Cost per Click (eCPC): What is the average amount of money that is spent by an advertiser (on advertising) to receive one click (on its ad)? This metric can be calculated as:\neCPC = Advertising Cost\n# of Clicks .\nAbove metrics are representative of the quality of clustering since our bidding logic takes the cluster ids of users directly into consideration. If we are able to separate the users into meaningful segments (via clustering), then the action probability calculated for each segment is more accurate (therefore our bid values are closer to the actual value of each impression). Due to this, the money spent for each impression\n(due to bidding) brings more actions/clicks, hence improving eCPC and eCPA metrics.\nThe results of our initial experiments, that span over a 10 day period within July-August 2013, are given in Figures 5 and 6. While Figure 5 compares the day-by-day eCPA performance for both algorithms, Figure 6 presents the same analysis for eCPC performance. Due to privacy issues, we are not presenting the exact values in the plots, but rather we have changed the values by a factor. It can be seen that the proposed algorithm utilizing the topic model performs much better (i.e. lower eCPA or eCPC is better) compared to the algorithm which utilizes the cosine similarity metric. Furthermore, we see that the eCPA has an trend for increasing for both models at the end of the experimentation period. This is due to the action attribution problem inherent in advertising systems, where an action that happens is attributed to an ad that is shown to a user several days ago. Due to this, the later days still have some actions that are to be received in time."
    }, {
      "heading" : "6. CONCLUSIONS AND FUTURE WORK",
      "text" : "In this paper, we described a methodology to cluster users in online advertising. We have explained the difficulties such as non-stable set of users as well as the large data that we have to deal with, and how those factors shape the algorithm we employ or how we implement this algorithm. We have given a brief overview of the implementation in Apache Pig, on Hadoop, as well as some initial experimental results. It is important to mention that we are not claiming to have explored all possible algorithms/models for analysis in this work, but rather that we have developed a meaningful and efficient system that solves a real-world online advertising problem and improves the performance. In summary, we believe that this work fills a significant void in the literature, since it deals directly with the large-scale problems that arise in online advertising domain. Our future work includes the extension of our results, as well as an improved clustering algorithm where the user properties (such as age, gender, location etc.) are used alongside with the item sets (i.e. beacon history) for better determination of clusters."
    }, {
      "heading" : "7. REFERENCES",
      "text" : "[1] M. Aly, A. Hatch, V. Josifovski, and V. K. Narayanan.\nWeb-scale user modeling for targeting. In Proc. ACM WWW, pages 3–12, 2012.\n[2] C. Borgs, J. Chayes, O. Etesami, N. Immorlica, K. Jain, and M. Mahdian. Dynamics of bid optimization in online advertisement auctions. In Proc. ACM WWW, pages 531–540, 2007.\n[3] A. Bosch, A. Zisserman, and X. Munoz. Scene classification via plsa. In Proc. European Conference on Computer Vision, 2006.\n[4] A. Das, M. Datar, A. Garg, and S. Rajaram. Google news personalization: Scalable online collaborative filtering. In Proc. ACM WWW, pages 271–280, 2007.\n[5] H. Fujimoto, M. Etoh, A. Kinno, and Y. Akinaga. Web user profiling on proxy logs and its evaluation in personalization. In LNCS 6612, pages 107–118, 2011.\n[6] T. Hofmann. Latent semantic models for collaborative filtering. ACM Trans. Inf. Sys., 22(1):89–115, 2004.\n[7] A. Joshi, A. Bagherjeiran, and A. Ratnaparkhi. User demographic and behavioral targeting for content match advertising. In Proc. ACM ADKDD, pages 53–60, 2011.\n[8] K.-C. Lee, B. Orten, A. Dasdan, and W. Li. Estimating conversion rate in display advertising from past performance data. In Proc. ACM SIGKDD Conf. on Knowledge Discovery and Data Mining, pages 768–776, 2012.\n[9] L. Li, W. Chu, J. Langford, and X. Wang. Unbiased offline evaluation of contextual-bandit-based news article recommendation algorithms. In Proc. ACM WSDM, pages 297–306, 2011.\n[10] K. Liu and L. Tang. Large-scale behavioral targeting with a social twist. In Proc. ACM CIKM, pages 1815–1824, 2011.\n[11] H. Ma, H. Cao, Q. Yang, E. Chen, and J. Tian. A habit mining approach for discovering similar mobile users. In Proc. ACM WWW, pages 231–240, 2012.\n[12] D. Newman, A. Asuncion, P. Smyth, and M. Welling. Distributed algorithms for topic models. J. Machine Learning Research, 10:1801–1828, 2009.\n[13] C. Olston, B. Reed, U. Srivastava, R. Kumar, and A. Tomkins. Pig latin: A not-so-foreign language for data processing. In Proc. ACM SIGMOD, pages 1099–1110, 2008.\n[14] S. Tu and C. Lu. Topic-based user segmentation for online advertising with latent dirichlet allocation. In LNCS 6441, pages 259–269, 2010.\n[15] T. White. Hadoop: The Definitive Guide. O’Reilly Media, Sebastopol, CA, 2012.\n[16] X. Wu, J. Yan, N. Liu, S. Yan, Y. Chen, and Z. Chen. Probabilistic latent semantic user segmentation for behavioral targeted advertising. In Proc. Proc. ACM ADKDD, pages 10–17, 2009.\n[17] J. Yan, N. Liu, G. Wang, W. Zhang, Y. Jiang, and Z. Chen. How much can behavioral targeting help online advertising? In Proc. ACM WWW, pages 261–270, 2009."
    } ],
    "references" : [ {
      "title" : "Web-scale user modeling for targeting",
      "author" : [ "M. Aly", "A. Hatch", "V. Josifovski", "V.K. Narayanan" ],
      "venue" : "In Proc. ACM WWW,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2012
    }, {
      "title" : "Dynamics of bid optimization in online advertisement auctions",
      "author" : [ "C. Borgs", "J. Chayes", "O. Etesami", "N. Immorlica", "K. Jain", "M. Mahdian" ],
      "venue" : "In Proc. ACM WWW,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2007
    }, {
      "title" : "Scene classification via plsa",
      "author" : [ "A. Bosch", "A. Zisserman", "X. Munoz" ],
      "venue" : "In Proc. European Conference on Computer Vision,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2006
    }, {
      "title" : "Google news personalization: Scalable online collaborative filtering",
      "author" : [ "A. Das", "M. Datar", "A. Garg", "S. Rajaram" ],
      "venue" : "In Proc. ACM WWW,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2007
    }, {
      "title" : "Web user profiling on proxy logs and its evaluation in personalization",
      "author" : [ "H. Fujimoto", "M. Etoh", "A. Kinno", "Y. Akinaga" ],
      "venue" : "In LNCS",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "Latent semantic models for collaborative filtering",
      "author" : [ "T. Hofmann" ],
      "venue" : "ACM Trans. Inf. Sys.,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2004
    }, {
      "title" : "User demographic and behavioral targeting for content match advertising",
      "author" : [ "A. Joshi", "A. Bagherjeiran", "A. Ratnaparkhi" ],
      "venue" : "In Proc. ACM ADKDD,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2011
    }, {
      "title" : "Estimating conversion rate in display advertising from past performance data",
      "author" : [ "K.-C. Lee", "B. Orten", "A. Dasdan", "W. Li" ],
      "venue" : "In Proc. ACM SIGKDD Conf. on Knowledge Discovery and Data Mining,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2012
    }, {
      "title" : "Unbiased offline evaluation of contextual-bandit-based news article recommendation algorithms",
      "author" : [ "L. Li", "W. Chu", "J. Langford", "X. Wang" ],
      "venue" : "In Proc. ACM WSDM,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "Large-scale behavioral targeting with a social twist",
      "author" : [ "K. Liu", "L. Tang" ],
      "venue" : "In Proc. ACM CIKM,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2011
    }, {
      "title" : "A habit mining approach for discovering similar mobile users",
      "author" : [ "H. Ma", "H. Cao", "Q. Yang", "E. Chen", "J. Tian" ],
      "venue" : "In Proc. ACM WWW,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2012
    }, {
      "title" : "Distributed algorithms for topic models",
      "author" : [ "D. Newman", "A. Asuncion", "P. Smyth", "M. Welling" ],
      "venue" : "J. Machine Learning Research,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2009
    }, {
      "title" : "Pig latin: A not-so-foreign language for data processing",
      "author" : [ "C. Olston", "B. Reed", "U. Srivastava", "R. Kumar", "A. Tomkins" ],
      "venue" : "In Proc. ACM SIGMOD,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2008
    }, {
      "title" : "Topic-based user segmentation for online advertising with latent dirichlet allocation",
      "author" : [ "S. Tu", "C. Lu" ],
      "venue" : "In LNCS",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2010
    }, {
      "title" : "Hadoop: The Definitive Guide",
      "author" : [ "T. White" ],
      "venue" : null,
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "Probabilistic latent semantic user segmentation for behavioral targeted advertising",
      "author" : [ "X. Wu", "J. Yan", "N. Liu", "S. Yan", "Y. Chen", "Z. Chen" ],
      "venue" : "In Proc. Proc. ACM ADKDD,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2009
    }, {
      "title" : "How much can behavioral targeting help online advertising",
      "author" : [ "J. Yan", "N. Liu", "G. Wang", "W. Zhang", "Y. Jiang", "Z. Chen" ],
      "venue" : "In Proc. ACM WWW,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "[8].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "A certain ad from an advertiser can be shown to a user in an online context only if the value for the ad impression opportunity is high enough to win in a real-time, competitive auction [2].",
      "startOffset" : 186,
      "endOffset" : 189
    }, {
      "referenceID" : 7,
      "context" : "As a result, we need to use campaign/website/user hierarchies and other techniques to reduce this extreme sparsity and compute this extremely rare event [8].",
      "startOffset" : 153,
      "endOffset" : 156
    }, {
      "referenceID" : 5,
      "context" : "The methodology we propose in this paper is inspired highly by probabilistic latent semantic analysis (pLSA) [6], which has been used in document clustering, scene classification [3], and user clustering for news recommendation [4].",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 2,
      "context" : "The methodology we propose in this paper is inspired highly by probabilistic latent semantic analysis (pLSA) [6], which has been used in document clustering, scene classification [3], and user clustering for news recommendation [4].",
      "startOffset" : 179,
      "endOffset" : 182
    }, {
      "referenceID" : 3,
      "context" : "The methodology we propose in this paper is inspired highly by probabilistic latent semantic analysis (pLSA) [6], which has been used in document clustering, scene classification [3], and user clustering for news recommendation [4].",
      "startOffset" : 228,
      "endOffset" : 231
    }, {
      "referenceID" : 16,
      "context" : "the percentage of the advertisements that are clicked by a user, has been presented in [17], which justifies this interest.",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 15,
      "context" : "[16] introduces Probabilistic Latent Semantic User Segmentation (PLSUS) for advertising, where each user is represented as a bag of words according to his/her search queries.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "[5] gives an example where web users are clustered, assuming the users are the documents and the visited websites are the words.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 13,
      "context" : "Furthermore, [14] gives an application of LDA for online advertising (but on a small, sampled set of users).",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 11,
      "context" : "While works such as [12] present distributed implementations of Latent Dirichlet Allocation and the Hierarchical Dirichet Process as fast ways to train topic models, implementation overhead (cost of human resources for implementation, as well as scalability issues that affect applicability on a real advertising scenario) is not negligible.",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "The first case we would like to list, similar to our work, is given in [1], where the authors utilize user actions to classify users into two groups for each advertiser: converters (will purchase, or click etc.",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 9,
      "context" : "Another approach in utilizing user information for advertising is given in [10], where the authors employ friendship data (due to similarity of friends, i.",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 6,
      "context" : "The paper in [7] aims at incorporating user demographic information into a text representation.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 10,
      "context" : "Finally, in mobile advertising domain, [11] suggests the usage of mobile user patterns and therefore segmenting users",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 5,
      "context" : "As aforementioned, our clustering algorithm is highly inspired by the probabilistic Latent Semantic Analysis (pLSA) [6], with a difference in the independence assumption of user and cluster, given the history of the user.",
      "startOffset" : 116,
      "endOffset" : 119
    }, {
      "referenceID" : 5,
      "context" : "Probabilistic latent semantic analysis [6] assumes the existence of a latent class variable (i.",
      "startOffset" : 39,
      "endOffset" : 42
    }, {
      "referenceID" : 5,
      "context" : "The parameters of the pLSA model is learned using the expectation maximization algorithm [6] as follows:",
      "startOffset" : 89,
      "endOffset" : 92
    }, {
      "referenceID" : 12,
      "context" : "We utilized Apache Pig [13] to implement the clustering algorithm outlined in this paper.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 14,
      "context" : "Pig is a high-level language working on top of Hadoop [15] framework, hence makes our clustering task complete much quicker due to parallelization.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 8,
      "context" : "This is why some of the more recent work [9] on offline evaluation is often not useful: the metrics that can be examined in such settings (such as click-through rate, AUC etc.",
      "startOffset" : 41,
      "endOffset" : 44
    } ],
    "year" : 2013,
    "abstractText" : "In the domain of online advertising, our aim is to serve the best ad to a user who visits a certain webpage, to maximize the chance of a desired action to be performed by this user after seeing the ad. While it is possible to generate a different prediction model for each user to tell if he/she will act on a given ad, the prediction result typically will be quite unreliable with huge variance, since the desired actions are extremely sparse, and the set of users is huge (hundreds of millions) and extremely volatile, i.e., a lot of new users are introduced everyday, or are no longer valid. In this paper we aim to improve the accuracy in finding users who will perform the desired action, by assigning each user to a cluster, where the number of clusters is much smaller than the number of users (in the order of hundreds). Each user will fall into the same cluster with another user if their event history are similar. For this purpose, we modify the probabilistic latent semantic analysis (pLSA) model by assuming the independence of the user and the cluster id, given the history of events. This assumption helps us to identify a cluster of a new user without re-clustering all the users. We present the details of the algorithm we employed as well as the distributed implementation on Hadoop, and some initial results on the clusters that were generated by the algorithm.",
    "creator" : "gnuplot 4.6 patchlevel 3"
  }
}