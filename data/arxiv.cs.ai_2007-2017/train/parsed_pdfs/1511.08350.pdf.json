{
  "name" : "1511.08350.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A global Constraint for mining Sequential Patterns with GAP constraint",
    "authors" : [ "Amina Kemmar", "Samir Loudni", "Yahia Lebbah", "Patrice Boizumault", "Thierry Charnois" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Mining sequential patterns (SPM) is an important task in data mining. There are many useful applications, including discovering changes in customer behaviors, detecting intrusion from web logs and finding relevant genes from DNA sequences. In recent years many studies have focused on SPM with gap constraints [16,18]. Limited gaps allow a mining process to bear a certain degree of flexibility among correlated pattern elements in the original sequences. For example, [6] analyses purchase behaviors to reflect products usually bought by customers at regular time intervals according to time gaps. In computational biology, the gap constraint helps discover periodic patterns with significant biological and medical values [14].\nMining sequential patterns under gap constraint (GSPM) is a challenging task, since the apriori property does not hold for this problem: a subsequence of a frequent sequence is not necessarily frequent. Several specialized approaches have been proposed [6,10,18] but they have a lack of genericity to handle simultaneously various types of constraints. Recently, a few proposals [4,8,11,12] have investigated relationships between GSPM and constraint programming (CP) in order to provide a declarative approach, while exploiting efficient and generic solving methods. But, due to the size of the proposed encodings, these CP methods are not as efficient as specialized ones. More recently, we have proposed the global constraint PREFIX-PROJECTION for SPM which remedies to this drawback [7]. However, as this global constraint uses the projected databases principle, it cannot be directly extended to support gap constraint. ar X\niv :1\n51 1.\n08 35\n0v 1\n[ cs\n.A I]\n2 6\nN ov\nIn this paper, we introduce the global constraint GAP-SEQ enabling to handle SPM with or without gap constraint. GAP-SEQ relies on the principle of right pattern extension and its filtering exploits the prefix anti-monotonicity property of the gap constraint to provide an efficient pruning of the search space. GAP-SEQ enables to handle simultaneously different types of constraints and its encoding does not require any reified constraints nor any extra variables. Finally, experiments show that our approach clearly outperforms CP approaches as well as specialized methods for GSPM and achieves scalability while it is a major issue for CP approaches.\nThe paper is organized as follows. Section 2 introduces the prefix anti-monotonicity of the gap constraint as well as right pattern extensions that will enable an efficient filtering. Section 3 provides a critical review of specialized methods and CP approaches for sequential pattern mining under gap constraint. Section 4 presents the global constraint GAP-SEQ. Section 5 reports experiments we performed. Finally, we conclude and draw some perspectives."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "First, we provide the basic definitions for GSPM. Then, we show that the anti-monotonicity property of frequency of SPM does not hold for GSPM. Finally, we introduce right pattern extensions that will enable an efficient filtering for GSPM."
    }, {
      "heading" : "2.1 Definitions",
      "text" : "Let I be a finite set of distinct items. The language of sequences corresponds to LI = In where n ∈ N+.\nDefinition 1 (sequence, sequence database). A sequence s over LI is an ordered list 〈s1s2 . . . sn〉, where si, 1 ≤ i ≤ n, is an item. n is called the length of the sequence s. A sequence database SDB is a set of tuples (sid, s), where sid is a sequence identifier and s a sequence denoted by SDB[sid].\nWe now define the subsequence relation [M,N ] under gap[M,N ] constraint which restricts the allowed distance between items of subsequences in sequences.\nDefinition 2 (subsequence relation [M,N ] under gap[M,N ]). α = 〈α1 . . . αm〉 is a subsequence of s = 〈s1 . . . sn〉, under gap[M,N ], denoted by (α [M,N ]s), if m ≤ n and, for all 1 ≤ i ≤ m, there exist integers 1 ≤ j1 ≤ . . . ≤ jm ≤ n, such that αi = sji , and ∀k ∈ {1, ...,m−1},M ≤ jk+1−jk−1 ≤ N . In this context, the pair (s, [j1, jm]) denotes an occurrence of α in s, where j1 and jm represent the positions of the first and last items of α in s. We say that α is contained in s or s is a super-sequence of α under gap[M,N ]. We also say that α is a gap[M,N ] constrained pattern in s.\n– Let AllOcc(α, s) = {[j1, jm] | (s, [j1, jm]) is an occurrence of α in s} be the set of all the occurrences of some sequence α under gap[M,N ] in s. – LetAllOcc(α, SDB) = {(sid,AllOcc(α, SDB[sid])) | (sid, SDB[sid]) ∈ SDB} be the set of all the occurrences of some sequence α under gap[M,N ] in SDB. – Let gap[M,∞] and gap[0, N ] the minimum and the maximum gap constraints respectively. – The relation stands for [0,∞] where the gap constraint is inactive.\nFor example, the sequence 〈BABC〉 is a super-sequence of 〈AC〉 under gap[0, 2]: 〈AC〉 [0,2]〈BABC〉.\nDefinition 3 (prefix, postfix). Let β = 〈β1 . . . βn〉 be a sequence. The sequence α = 〈α1 . . . αm〉 where m ≤ n is called the prefix of β iff ∀i ∈ [1..m], αi = βi. The sequence γ = 〈βm+1 . . . βn〉 is called the postfix of s w.r.t. α. With the standard concatenation operator \"concat\", we have β = concat(α, γ).\nThe cover of a sequence α in SDB is the set of all tuples in SDB in which α is contained. The support of a sequence α in SDB is the cardinal of its cover.\nDefinition 4 (coverage and support under gap[M,N ]). Let SDB be a sequence database and α a sequence. cover[M,N ]SDB (α)={(sid, s) ∈ SDB |α [M,N ] s} and sup\n[M,N ] SDB (α) = #cover [M,N ] SDB (α).\nDefinition 5 (gap[M,N ] constrained sequential pattern mining (GSPM)). Given a sequence database SDB, a minimum support threshold minsup and a gap constraint gap[M,N ]. The problem of gap[M,N ] constrained sequential pattern mining is to find all subsequences α such that sup[M,N ]SDB (α) ≥ minsup.\nExample 1. Table 1 represents a sequence database of four sequences where the set of items is I = {A,B,C,D,E}. Let the sequence α = 〈AC〉. The occurrences under gap[0, 1] of α in SDB1[2] is given by AllOcc(α, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}. We have cover[0,1]SDB1(α) = {(1, s1), (2, s2), (3, s3), (4, s4)}. If we consider minsup = 2, α is a gap[0, 1] constrained sequential pattern because sup[0,1]SDB1(α) ≥ 2.\n2.2 Prefix anti-monotonicity of gap[M,N ]\nMost of SPM algorithms rely on the anti-monotonicity property of frequency [1] to reduce the search space: all the subsequences of a frequent sequence are frequent as well (or, equivalently, if a subsequence is infrequent, then no super-sequence of it can be frequent). However, this property does not hold for the gap constraint, and more precisely for the maximum gap constraint. A simple illustration from our running example suffices to show that sequence 〈AB〉 is not a sequential pattern under gap[0, 1] (for minsup = 3) whereas sequence 〈ACB〉 is a gap[0, 1] constrained sequential pattern. As a consequence, one needs to use other techniques for pruning the search space. The following proposition shows how the prefix anti-monotonicity property can be exploited to ensure the anti-monotonicity of the gap constraint.\nDefinition 6 (prefix anti-monotone property). A constraint c is called prefix antimonotone if for every sequence α satisfying c, every prefix of α also satisfies the constraint.\nProposition 1. gap[M,N ] is prefix anti-monotone.\nProof. Let α = 〈α1 . . . αm〉 and s = 〈s1 . . . sn〉 be two sequences s.t. α [M,N ]s and m ≤ n. By definition, there exist integers 1 ≤ j1 ≤ . . . ≤ jm ≤ n, such that αi = sji , and ∀k ∈ {1, ...,m − 1},M ≤ jk+1 − jk − 1 ≤ N . As a consequence, the property also holds for every prefix of α. 2\nHence, if a sequence α does not satisfy gap[M,N ], then all sequences that have α as prefix will not satisfy this constraint. Sect. 4.2 shows how this property can be exploited to provide an efficient filtering."
    }, {
      "heading" : "2.3 Right pattern extensions",
      "text" : "Right pattern extensions of some pattern p gives all the possible subsequences which can be appended at right of p to form a gap[M,N ] constrained pattern. According to proposition 1, the set of all items locally frequent within the right pattern extensions of p in SDB can be used to extend p. In the following, we introduce an operator allowing to compute all the right pattern extensions of a pattern w.r.t. gap[M,N ].\nDefinition 7 (Right pattern extensions). Given some sequence (sid, s) and a pattern p s.t. p [M,N ]s. The right pattern extensions of p in s, denoted by Ext[M,N ]R (p, s), is the collection of legal subsequences of s located at the right of p and satisfying gap[M,N ]. To define Ext[M,N ]R (p, s), we need to define BE\n[M,N ](p, s) basic right extensions :\nBE[M,N ](p, s) = ⋃\n[j1,jm]∈AllOcc(p,s)\n{(jm, SubSeq(s, jm +M + 1,min(jm +N + 1,#s)))}\nwhere SubSeq(s, i1, i2) = { 〈s[i1], ..., s[i2]〉 if i1 ≤ i2 ≤ #s 〈〉 otherwise\nRight pattern extensions Ext[M,N ]R (p, s) is defined as follows:\nExt [M,N ] R (p, s) =  {Sb | (j′m, Sb) ∈ BE[M,N ](p, s)∧ if N ≥ #s\nj′m = min(jm,Sb)∈BE[M,N](p,s){jm}}⋃ (jm,Sb)∈BE[M,N](p,s){Sb} otherwise\n(1)\nFormula (1) states exactly the set of all possible extensions of pattern p within s. In case where (N ≥ #s), since that any extension fromBE[M,N ](p, s) always reaches the end of the sequence s, thus all possible extensions can be aggregated within one unique extension going from the lowest starting position j′m = min(jm,Sb)∈BE[M,N](p,s){jm}. We point out that these cases (N ≥ #s) cover the special case of no gap gap[0,∞].\nThe right pattern extensions of p in SDB is the collection of all its right pattern extensions in all sequences of SDB:\nExt [M,N ] R (p, SDB) = ⋃ (sid,s)∈SDB {(sid, Ext[M,N ]R (p, s))} (2)\nExample 2. Let p1 = 〈AC〉 be a pattern and the gap constraint be gap[0, 1]. We have AllOcc(p1, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}. The right pattern extensions of p1 in SDB1[2] is equal to Ext [0,1] R (p1, SDB1[2]) = {〈CB〉, 〈BA〉, 〈B〉}. The right pattern extensions of p1 in SDB1 is given byExt [0,1] R (p1, SDB1) = {(1, {〈DB〉}), (2, {〈CB〉, 〈BA〉, 〈B〉}), (3, {〈BE〉}), (4, {〈C〉})}. Let the gap constraint be gap[0,∞]. To compute Ext[0,∞]R (p1, SDB1[2]), only the first occurrence of p1 in SDB1[2] need to be considered (i.e. [1, 2]) (cf. Definition 7). Thus, Ext[0,∞]R (p1, SDB1[2]) = {〈CBACB〉}). The right pattern extensions of p1 in SDB1 is equal to Ext [0,∞] R (p1, SDB1) = {(1, {〈DB〉}), (2, {〈CBACB〉}), (3, {〈BEEC〉}), (4, {〈C〉})}.\nGiven a gap[M,N ] constrained pattern p in SDB, according to proposition 1, the set of all items locally frequent within the right pattern extensions of p in SDB can be used to extend p. Proposition 2 establishes the support count of a sequence γ w.r.t. its right pattern extensions.\nProposition 2 (Support count). For any sequence γ in SDB with prefix α and postfix β s.t. γ = concat(α, β), sup[M,N ]SDB (γ) = supExt[M,N]R (α,SDB) (β).\nThis proposition ensures that only the sequences in SDB grown from α need to be considered for the support count of a sequence γ. From proposition 2, we can derive the following proposition to establish a condition to check when a pattern is a gap[M,N ] constrained sequential pattern.\nProposition 3. Let SDB be a sequence database and a minimum support threshold minsup. A pattern p is a gap[M,N ] constrained sequential pattern in SDB if and only if the following condition holds: #Ext[M,N ]R (p, SDB) ≥ minsup Example 3. Let minsup be 2 and the gap constraint be gap[0, 1]. From Example 2, we have #Ext[0,1]R (p1, SDB1) = 4 ≥ minsup. Thus, p1 = 〈AC〉 is a gap[0, 1] constrained sequential pattern. The locally frequent items within the right pattern extensions Ext[0,1]R (p1, SDB1) of p1 are B and C with supports of 3 and 2 respectively. According to proposition 2, p1 can be extended to two gap[0, 1] constrained sequential patterns 〈ACB〉 and 〈ACC〉 ."
    }, {
      "heading" : "3 Related works",
      "text" : "Specialized methods for GSPM. The SPM was first proposed in [1]. Since then, many efficient specialized approaches have been proposed [2,13,17]. There are also several methods focusing on gap constraints. Zaki [16] first proposed cSpade, a depth-first search based on a vertical database format, incorporating max-gap, max-span and length constraints. Ji and al. [6] and Li and al. [9] studied the problem of mining frequent patterns with gap constraints. In [6], a minimal distinguishing subsequence that occurs frequently in the positive sequences and infrequently in the negative sequences is proposed, where the maximum gap constraint is defined. In [9], closed frequent patterns with gap constraints are mined. All these proposals, though efficient, lack of genericity to handle simultaneously various types of constraints.\nCP Methods for GSPM. There are few methods for SPM with gap constraints using CP. [11] have proposed to model a sequence using an automaton capturing all subsequences that can occur in it. The gap constraint is encoded by removing from the automaton all transitions that does not respect the gap constraint. [8] have proposed a CSP model for SPM with explicit wildcards1. The gap constraints is enforced using the regular global constraint. [12] have proposed two CP encodings for the SPM. The first one uses a global constraint to encode the subsequence relation (denoted global-p.f), while the second one (denoted decomposed-p.f) encodes explicitly this relation using additional variables and constraints in order to support constraints like gap. However, all these proposals usually lead to constraints network of huge size. Space complexity is clearly identified as the main bottleneck behind the competitiveness of these declarative approaches. In [7], we have proposed the global constraint PREFIX-PROJECTION for sequential pattern mining which remedies to this drawback. However, this constraint cannot be directly extended to handle gap constraints. This requires changing the way the subsequence relation is encoded.\nThe next section introduces the global constraint GAP-SEQ enabling to handle SPM with or without gap constraints. GAP-SEQ relies on the prefix anti-monotonicity of the gap constraint and on the right pattern extensions to provide an efficient filtering. This global constraint does not require any reified constraints nor any extra variables to encode the subsequence relation."
    }, {
      "heading" : "4 GAP-SEQ global constraint",
      "text" : "This section is devoted to the GAP-SEQ global constraint. Section 4.1 defines the GAP-SEQ global constraint and presents the CSP modeling. Section 4.2 shows how the filtering can take advantage of the prefix anti-monotonicity property of the gap[M,N ] constraint (see Proposition 6) and of the right pattern extensions (see Proposition 5) to remove inconsistent values from the domain of a future variable. Section 4.3 details the filtering algorithm and Section 4.4 provides its temporal and spatial complexities."
    }, {
      "heading" : "4.1 CSP modeling for GSPM",
      "text" : "A Constraint Satisfaction Problem (CSP) consists of a setX of n variables, a domainD mapping each variable Xi ∈ X to a finite set of values D(Xi), and a set of constraints C. An assignment σ is a mapping from variables in X to values in their domains. A constraint c ∈ C is a subset of the cartesian product of the domains of the variables that occur in c. The goal is to find an assignment such that all constraints are satisfied. (a) Variables and domains. Let P be the unknown pattern of size ` we are looking for. The symbol 2 stands for an empty item and denotes the end of a sequence. We encode the unknown pattern P of maximum length ` with a sequence of ` variables 〈P1, P2, . . . , P`〉. Each variable Pj represents the item in the jth position of the sequence. The size ` of P is determined by the length of the longest sequence of SDB. The domains of variables are defined as follows: (i) D(P1) = I to avoid the empty sequence, and (ii) ∀i ∈ [2 . . . `], D(Pi) = I ∪ {2}. To allow patterns with less than ` items, we impose that ∀i ∈ [2..(`−1)], (Pi = 2)→ (Pi+1 = 2).\n1 A wildcard is a special symbol that matches any item of I including itself.\n(b) Definition of GAP-SEQ. The global constraint GAP-SEQ encodes both subsequence relation [M,N ] under gap constraint gap[M,N ] and minimum frequency constraint directly on the data.\nDefinition 8 (GAP-SEQ global constraint). Let P = 〈P1, P2, . . . , P`〉 be a pattern of size ` and gap[M,N ] be the gap constraint. 〈d1, ..., d`〉 ∈ D(P1)× . . .×D(P`) is a solution of GAP-SEQ(P, SDB,minsup,M,N) iff sup[M,N ]SDB (〈d1, ..., d`〉) ≥ minsup.\nProposition 4. GAP-SEQ(P, SDB,minsup,M,N) has a solution iff there exists an assignment σ = 〈d1, ..., d`〉 of variables of P s.t. #Ext[M,N ]R (σ, SDB) ≥ minsup.\nProof: This is a direct consequence of proposition 3. 2 (c) Other SPM constraints can be directly modeled as follows: - Minimum Size constraint restricts the number of items of a pattern to be at least `min: minSize(P, `min) ≡ ∧i=`min i=1 (Pi 6= ) - Maximum Size constraint restricts the number of items of a pattern to be at most `max: maxSize(P, `max) ≡ ∧i=` i=`max+1\n(Pi = ) - Membership constraint states that a subset of items V must belong (or not) to the extracted patterns. item(P, V ) ≡ ∧ t∈V Among(P, {t}, l, u) enforces that items of V should occur at least l times and at most u times in P . To forbid items of V to occur in P , l and u must be set to 0."
    }, {
      "heading" : "4.2 Principles of filtering",
      "text" : "(a) Maintaining a local consistency. SPM is a challenging task due to the exponential number of candidates that should be parsed to find the frequent patterns. For instance, with k items there are O(nk) potentially candidate patterns of length at most k in a sequence of size n. With gap constraints, the problem is even much harder since the complexity of checking for subsequences taking a gap constraint into account is higher than the complexity of the standard subsequence relation. Furthermore, the NPhardness of mining maximal2 frequent sequences was established in [15] by proving the #P-completeness of the problem of counting the number of maximal frequent sequences. Hence, ensuring Domain Consistency (DC) for GAP-SEQ i.e., finding, for every variable Pj , a value dj ∈ D(Pj), satisfying the constraint is NP-hard.\nSo, the filtering of GAP-SEQ constraint maintains a consistency lower than DC. This consistency is based on specific properties of the gap[M,N ] constraint and resembles forward-checking (regarding Proposition 5). GAP-SEQ is considered as a global constraint, since all variables share the same internal data structures that awake and drive the filtering. The prefix anti-monotonicity property of the gap[M,N ] constraint (see Proposition 6) and of the right pattern extensions (see Proposition 5) will enable to remove inconsistent values from the domain of a future variable. (b) Detecting inconsistent values. Let RF [M,N ](σ, SDB) be the set of locally frequent items within the right pattern extensions, defined by {v ∈ I |#{sid | (sid, E) ∈ Ext\n[M,N ] R (σ, SDB) ∧ (∃α ∈ E ∧ 〈v〉 α)} ≥ minsup}. The following proposition\n2 A sequential pattern p is maximal if there is no sequential pattern q such that p q.\ncharacterizes values, of a future (unassigned) variable Pj+1, that are consistent with the current assignment of variables 〈P1, . . . , Pj〉.\nProposition 5. Let 3 σ= 〈d1, . . . , dj〉 be a current assignment of variables 〈P1, . . . , Pj〉, Pj+1 be a future variable. A value d ∈ D(Pj+1) occurs in a solution for the global constraint GAP-SEQ(P, SDB,minsup,M,N) iff d ∈ RF [M,N ](σ, SDB).\nProof: Assume that σ = 〈d1, . . . , dj〉 is gap[M,N ] constrained sequential pattern in SDB. Suppose that value d ∈ D(Pj+1) appears in RF [M,N ](σ, SDB). As the local support of d within the right extensions is equal to sup\nExt [M,N] R (σ,SDB)\n(〈d〉),\nfrom proposition 2 we have sup[M,N ]SDB (concat(σ, 〈d〉)) = supExt[M,N]R (σ,SDB)(〈d〉). Hence, we can get a new assignment σ ∪ 〈d〉 that satisfies the constraint. Therefore, d ∈ D(Pj+1) participates in a solution. 2\nFrom proposition 5 and according to the prefix anti-monotonicity property of the gap constraint, we can derive the following pruning rule:\nProposition 6. Let σ = 〈d1, . . . , dj〉 be a current assignment of variables 〈P1, . . . , Pj〉. All values d ∈ D(Pj+1) that are not in RF [M,N ](σ, SDB) can be removed from the domain of variable Pj+1.\nExample 4. Consider the running example of Table 1, let minsup be 2 and the gap constraint be gap[1, 2]. Let P = 〈P1, P2, P3, P4〉 with D(P1) = I and D(P2) = D(P3) = D(P4) = I ∪{2}. Suppose that σ(P1) = A. We have Ext[1,2]R (〈A〉, SDB1) = {(1, {〈CD〉}), (2, {〈CB〉, 〈B〉}), (3, {〈CB〉}), (4, {〈CC〉, 〈C〉})}. As B and C are the only locally frequent items inExt[1,2]R (〈A〉, SDB1), GAP-SEQ will remove values A, D and E from D(P2).\nThe filtering of GAP-SEQ relies on Proposition 6 and is detailed in the next section."
    }, {
      "heading" : "4.3 Filtering algorithm",
      "text" : "Algorithm 1 describes the pseudo-code of GAP-SEQ filtering algorithm. It takes as input: the index j of the last assigned variable in P , the current partial assignment σ = 〈σ(P1), . . . , σ(Pj)〉, the minimum support threshold minsup, the minimum and the maximum gaps. The internal data-structureALLOCC stores all the intermediate occurrences of patterns in SDB, whereALLOCCj = AllOcc(σ, SDB), for j ∈ [1 . . . `]. If σ = 〈〉, then ALLOCC0 = {(sid, [1,#s]) | (sid, s) ∈ SDB}. ALLOCCj is computed incrementally from ALLOCCj−1 in order to enhance the efficiency.\nAlgorithm 1 starts by computing the right pattern extensions ExtR of σ in SDB (line 1) by calling function GETRIGHTEXT (see Algorithm 2). Then, it checks whether the current assignment σ satisfies the constraint (see Proposition 4) (line 2). If not, we stop growing σ and return False. Otherwise, the algorithm checks if the last assigned variable Pj is instantiated to 2 (line 4). If so, the end of the sequence is reached (since value 2 can only appear at the end) and the sequence 〈σ(P1), . . . , σ(Pj)〉 is a\n3 We indifferently denote σ by 〈d1, . . . , dj〉 or by 〈σ(P1), . . . , σ(Pj)〉.\nAlgorithm 1: FILTER-GAP-SEQ(SDB, σ, j, P , minsup, M , N ) Data: SDB: initial database; σ: current assignment 〈σ(P1), . . . , σ(Pj)〉;minsup: the minimum support\nthreshold;ALLOCC: internal data structure for storing occurrences of patterns in SDB;ExtR: internal data structure for storing right pattern extensions of σ in SDB.\nbegin 1 ExtR ← GETRIGHTEXT(SDB,ALLOCCj−1, σ,M,N) ; 2 if (#ExtR < minsup) then 3 return False ;\n4 if (j ≥ 2 ∧ σ(Pj) = 2) then 5 for k ← j + 1 to ` do 6 Pk ← 2 ;\nelse 7 RF ← GETFREQITEMS(SDB,ExtR,minsup) ; 8 foreach a ∈ D(Pj+1) s.t.(a 6= 2 ∧ a /∈ RF) do 9 D(Pj+1)← D(Pj+1)− {a} ;\n10 return True ;\ngap[M,N ] constrained sequential pattern in SDB; hence, the algorithm sets the remaining (`− j) unassigned variables to 2 and returns True (lines 5-6). If (Pj 6= 2), the set of locally frequent items, within the right pattern extensions ExtR of σ in SDB, is computed by calling function GETFREQITEMS (line 7) and the domain of variable Pj+1 is updated accordingly (lines 8-9).\nAlgorithm 2 gives the pseudo-code of the function GETRIGHTEXT. First, if σ is empty (i.e. #σ = 0), all the sequences of SDB are considered as valid right pattern extensions; the whole SDB should be returned. Otherwise, the function GETALLOCC is called to compute the occurrences of σ in SDB (line 3). Then, the algorithm processes all the entries of ALLOCCj , one by one (line 5), and, for each pair (sid,OccSet), scans the occurrences of σ in the sequence sid (line 7). For each occurrence (j1, jm) ∈ OccSet, the algorithm computes its right pattern extensions, i.e. the part of the sequence sid which is in the range [jm+M+1,min(jm+N+1,#s)] (line 8). If the new range is valid, it is added to the set Sb (line 10). After processing the whole entries inOccSet, the right pattern extensions of σ in the sequence sid are built and then added to the set ExtR (line 11). The process ends when all entries ofALLOCCj have been considered. The right pattern extensions of σ in SDB are then returned (line 12).\nThe function GETALLOCC computes incrementallyALLOCCj fromALLOCCj−1. More precisely, lines (18-19) and (24-25) are considered when the first variable P1 is instanciated (i.e. #σ = 1), and consequently all of its initial occurrences should be found and stored in ALLOCC1 through the initialization step (lines 24-25). After that, ALLOCCj(j > 1) is incrementally computed from ALLOCCj−1 through line (26). To determine ALLOCCj , we avoid computing occurrences leading to redundant right pattern extensions thanks to the conditions ((sup = #s) ∧ (#σ > 1)) in line (27). Moreover, when computing the right pattern extensions, instead of storing the part of subsequence 〈s[j′1], . . . , s[j′m]〉, one can only store the positions of its first and last items (j′1, j ′ m) in the sequence sid. Consider Example 2: Ext [0,1] R (〈AC〉, SDB1) will be encoded as {(1, {(4, 5)}), (2, {(3, 4), (4, 5), (7, 7)}), (3, {(4, 5)}), (4, {(4, 4)})}. Finally, the filtering algorithm handles as efficiently the case without gap constraints. For each pair (sid,OccSet), only the first occurrence (j1, jm) in OccSet is determined thanks to the condition (N ≥ #s) in line (27).\nAlgorithm 2: GETRIGHTEXT(SDB, ALLOCCj−1, σ, M , N ) Data: SDB: initial database;ALLOCCj−1: occurrences of the partial assignment 〈σ(P1), . . . , σ(Pj−1)〉 in\nSDB; σ: the current partial assignment 〈σ(P1), . . . , σ(Pj)〉;OccSet: the positions of the first and last items of 〈σ(P1), . . . , σ(Pj−1)〉 in SDB[sid]; Sb: the positions of the first and last items of the right pattern extensions of σ in SDB[sid].\nbegin 1 if (σ = 〈〉) then 2 return {(sid, [1,#s])|(sid, s) ∈ SDB} ; 3 ALLOCCj ← GETALLOCC(SDB,ALLOCCj−1, σ,M,N) ; 4 ExtR ← ∅ ; 5 foreach pair (sid,OccSet) ∈ ALLOCCj do 6 s← SDB[sid]; Sb← ∅ ; 7 foreach pair [j1, jm] ∈ OccSet do 8 j′1 ← jm +M + 1; j ′ m ← min(jm +N + 1,#s) ; 9 if (j′1 ≤ j ′ m) then\n10 Sb← Sb ∪ {(j′1, j ′ m)} ;\n11 ExtR ← ExtR ∪ {(sid, Sb)} ; 12 returnExtR ;\nFUNCTION GETALLOCC (SDB,ALLOCCj−1, σ,M ,N ) ; begin\n13 ALLOCCj ← ∅; inf ← 0; sup← 0; 14 foreach pair (sid,OccSet) ∈ ALLOCCj−1 do 15 s← SDB[sid]; newOccSet← ∅; redundant← false; i← 1 ; 16 while (i ≤ #OccSet ∧¬redundant) do 17 [j1, jm]← OccSet[i]; i← i+ 1; 18 if (#σ = 1) then 19 inf ← 1; sup← #s ;\nelse 20 inf ← jm +M + 1; sup← min(jm +N + 1,#s) ; 21 k ← inf ; 22 while ((k ≤ sup) ∧ (¬redundant)) do 23 if (s[k] = σ(Pj)) then 24 if (#σ = 1) then 25 newOccSet← newOccSet ∪ {[k, k]} ;\nelse 26 newOccSet← newOccSet ∪ {[j1, k]} ; 27 if (((sup = #s) ∧ (#σ > 1)) ∨ (N ≥ #s)) then 28 redundant← true ;\n29 k ← k + 1 ;\n30 if (newOccSet 6= ∅) then 31 ALLOCCj ← ALLOCCj ∪ (sid, newOccSet) ;\n32 returnALLOCCj ;"
    }, {
      "heading" : "4.4 Temporal and spatial complexities of the filtering algorithm",
      "text" : "Letm=|SDB|, d=|I|, and ` be the length of the longest sequence in SDB. Computing ALLOCCj from ALLOCCj−1 (see function GETALLOCC of Algorithm 2) can be achieved in O(m × `2). The function GETRIGHTEXT (see Algorithm 2) processes all the occurrences of σ in each sequence of the SDB. In the worst case, it may exist ` occurrences for each sequence in the database. So, the time complexity of function GETRIGHTEXT is O(m× `2 +m× `) i.e. O(m× `2).\nProposition 7. In the worst case, (i) filtering can be achieved in O(m × `2 + d) and (ii) the space complexity is O(m× `2).\nProof: (i) The complexity of function GETRIGHTEXT is O(m × `2). The total complexity of function GETFREQITEMS is O(m× `). Lines (8-9) can be achieved in O(d). So, the whole complexity is O(m× `2 +m× `+ d), i.e. O(m× `2 + d). (ii) The space complexity of the filtering algorithm lies in the storage of the ALLOCC internal data structure. The occurrences ALLOCCj of each assignment σ in SDB, with the length of σ varying from 1 to `, have to be stored. Since it may exist at most ` occurrences of σ in each sequence sid, storing any ALLOCCj costs in the worst case O(m × `). Since we can have ` prefixes, the worst space complexity of storing all the occurrences ALLOCCj(j = 1..`), is O(m× `2). 2"
    }, {
      "heading" : "5 Experiments",
      "text" : "This section reports experiments on several real-life datasets [5,3] of large size having varied characteristics and representing different application domains (see Tab. 2). First, we compare our approach with CP methods and with the state-of-the-art specialized method cSpade in terms of scalability. Second, we show the flexibility of our approach for handling different types of constraints simultaneously.\nExperimental protocol. Our approach was carried out using the gecode solver4. All experiments were conducted on a processor Intel X5670 with 24 GB of memory. A time limit of 1 hour has been set. If an approach is not able to complete the extraction within the time limit, it will be reported as (−). ` was set to the length of the longest sequence of SDB. We compare our approach (indicated by GAP-SEQ) with:\n1. decomposed-p.f5, the most efficient CP methods for GSPM, 2. cSpade6, the state-of-the-art specialized method for GSPM, 4 http://www.gecode.org 5 https://dtai.cs.kuleuven.be/CP4IM/cpsm/ 6 http://www.cs.rpi.edu/~zaki/www-new/pmwiki.php/Software/\n3. the PREFIX-PROJECTION global constraint for SPM.\n(a) GSPM: GAP-SEQ vs the most efficient CP method. We compare CPU times for GAP-SEQ and decomposed-p.f. In the experiments, we used the gap constraint gap[0, 1] and various values of minsup. Fig. 1 shows the results for the two datasets FIFA and LEVIATHAN (results are similar for other datasets and not reported due to page limitation). GAP-SEQ clearly outperforms decomposed-p.f on the two datasets even for high values ofminsup: GAP-SEQ is more than an order of magnitude faster than decomposed-p.f. For low values of minsup, decomposed-p.f fails to complete the extraction within the time limit.\nTab. 3 reports for the FIFA dataset and different values of minsup, the number of calls to the propagate function of gecode (col. 5) and the number of nodes of the search tree (col. 6). GAP-SEQ is very effective in terms of number of propagations. For GAP-SEQ, the number of propagations remains very small compared to decomposed-p.f (millions). This is due to the huge number of reified constraints used by decomposed-p.f to encode the subsequence relation. Regarding CPU times, GAP-SEQ requires less than 1s. to complete the extraction, while decomposed-p.f needs much more time to end the extraction (speed-up value up to 938).\n(b) GSPM: GAP-SEQ vs the state-of-the-art specialized method. Second experiments compare GAP-SEQ with cSpade. We first fixed minsup to the smallest possible value w.r.t. the dataset used, and varied the maximum gap N from 0 to 9. The\nminimum gap M was set to 0. Fig. 2 reports the CPU times of both methods. First, GAP-SEQ clearly dominates cSpade on all the datasets. The gains in terms of CPU times are greatly amplified as the value of N increases. On FIFA, the speed-up is 9.5 for N=6. On BIBLE, GAP-SEQ is able to complete the extraction for values of N up to 9 in 433 seconds, while cSpade failed to complete the extraction for N greater than 6. The only exception is for the Kosarak dataset, where cSpade is efficient. For this dataset (which is the largest one both in terms of number of sequences and items), the size of the domains is important as compared to the other datasets. So, filtering takes much more time. This probably explains the behavior of GAP-SEQ on this dataset.\nWe also conducted experiments to evaluate how sensitive GAP-SEQ and cSpade are to minsup. We used the gap[0, 9] constraint, while minsup varied until the two methods were not able to complete the extraction within the time limit. Results are depicted in Fig. 3. Once again, GAP-SEQ obtains the best performance on all datasets (except for Kosarak). When the minimum support decreases, CPU times for GAP-SEQ increase reasonably while for cSpade they increase dramatically. On PubMed, with minsup set to 0.1%, cSpade finished the extraction after 3, 500 seconds, while GAP-SEQ only used 500 seconds (speed-up value 7). These results clearly demonstrate that our approach is very effective as compared to cSpade on large datasets.\n(c) GSPM: evaluating the scalability of GAP-SEQ. We used three datasets and replicated them from 1 to 20 times. The gap constraint was set to gap[0, 9], and minsup to three different values. Fig. 4 reports the CPU times according to the replication factor (i.e. dataset sizes). CPU times increase (almost) linearly as the number of sequences. This indicates that GAP-SEQ achieves scalability while it is a major issue for CP approaches. The behavior of GAP-SEQ on Protein is quite different for low values of minsup. Indeed, for large sequences (such as in Protein), the size ofALLOCC may be very large and thus checking the gap constraint becomes costly (see Sect. 4.4).\n(d) GSPM: handling various additional constraints. To illustrate the flexibility of our approach, we selected the PubMed dataset and stated additional constraints such as minimum frequency, minimum size, and other useful constraints expressing some linguistic knowledge as membership. The goal is to extract sequential patterns which convey linguistic regularities (e.g., gene - rare disease relationships) [3]. The size constraint allows to forbid patterns that are too small w.r.t. the number of items (number of words) to be relevant patterns; we set `min to 3. The membership constraint enables to filter out sequential patterns that do not contain some selected items. For example, we state that extracted patterns must contain at least the two items GENE and DISEASE. We used the gap[0, 9] constraint, which is the best setting found in [3]. As no specialized method exists for this combination of constraints, we thus compare GAP-SEQwith and without additional constraints.\nTable 4 reports, for each value of minsup, the number of patterns extracted and the associated CPU times, the number of propagations and the number of nodes in the search tree. Additional constraints obviously restrict the number of extracted patterns. As the problem is more constrained, the size of the developed search tree is smaller. Even if the number of propagations is higher, the resulting CPU times are smaller. To conclude, thanks to the GAP-SEQ global constraint and its encoding, additional constraints like size, membership and regular expressions constraints can be easily stated.\n(e) Evaluating the ability of GAP-SEQ to efficiently handle SPM. In order to simulate the absence of gap constraints, we used the ineffective gap[0, `] constraint (recall that ` is the size of the longest sequence of SDB). We compared GAP-SEQ[0, `] with PREFIX-PROJECTION and two configurations of cSpade for SPM: cSpade without gap constraint and cSpade with M and N set respectively to 0 and `, denoted by cSpade[0, `]. Let us note that all the above methods will extract the same set of sequential patterns.\nFig. 5 reports the CPU times for the four methods. First, cSpade obtains the best performance (except on Protein). These results confirm those observed in [7].\nSecond, GAP-SEQ[0, `] and PREFIX-PROJECTION exhibit similar behavior, even if GAP-SEQ[0, `] is slightly less faster. So, even if GAP-SEQ handles both cases (with and without gap), it remains very competitive for SPM. Third, GAP-SEQ[0, `] clearly outperforms cSpade[0, `] (except on Kosarak). This is probably due to the huge number of unnecessary joining operations performed by cSpade[0, `]. To conclude, all the performed experiments demonstrate the ability of GAP-SEQ to efficiently handle SPM.\nFinally, the gecode implementation of GAP-SEQ and the datasets used in our experiments are available online7."
    }, {
      "heading" : "6 Conclusion",
      "text" : "In this paper, we have introduced the global constraint GAP-SEQ enabling to handle SPM with or without gap constraints. The filtering algorithm takes benefits from the principle of right pattern extensions and prefix anti-monotonicity property of the gap constraint. GAP-SEQ enables to handle several types of constraints simultaneously and does not require any reified constraints nor any extra variables to encode the subsequence relation. Experiments performed on several real-life datasets (i) show that our approach clearly outperforms existing CP approaches as well as specialized methods for GSPM on large datasets, and (ii) demonstrate the ability of GAP-SEQ to efficiently handle SPM.\nThis work opens several issues for future researches. We plan to handle constraints on set of sequential patterns such as closedness, relevant subgroup and skypattern constraints."
    } ],
    "references" : [ {
      "title" : "Mining sequential patterns",
      "author" : [ "R. Agrawal", "R. Srikant" ],
      "venue" : "Yu, P.S., Chen, A.L.P. (eds.) ICDE. pp. 3–14. IEEE Computer Society",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Sequential pattern mining using a bitmap representation",
      "author" : [ "J. Ayres", "J. Flannick", "J. Gehrke", "T. Yiu" ],
      "venue" : "KDD 2002. pp. 429–435. ACM",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Sequential pattern mining to discover relations between genes and rare diseases",
      "author" : [ "N. Béchet", "P. Cellier", "T. Charnois", "B. Crémilleux" ],
      "venue" : "CBMS",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A SAT-based approach for discovering frequent, closed and maximal patterns in a sequence",
      "author" : [ "E. Coquery", "S. Jabbour", "L. Saïs", "Y. Salhi" ],
      "venue" : "ECAI. pp. 258–263",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "SPMF: A Java Open-Source Pattern Mining Library",
      "author" : [ "P. Fournier-Viger", "A. Gomariz", "T. Gueniche", "A. Soltani", "C. Wu", "V. Tseng" ],
      "venue" : "J. of Machine Learning Resea",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2014
    }, {
      "title" : "Mining minimal distinguishing subsequence patterns with gap constraints",
      "author" : [ "X. Ji", "J. Bailey", "G. Dong" ],
      "venue" : "(ICDM’05. pp. 194–201",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "PREFIX-PROJECTION global constraint for sequential pattern mining",
      "author" : [ "A. Kemmar", "S. Loudni", "Y. Lebbah", "P. Boizumault", "T. Charnois" ],
      "venue" : "Principles and Practice of Constraint Programming - 21st International Conference, CP 2015, Cork, Ireland, August 31 - September 4, 2015, Proceedings. pp. 226–243",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Mining relevant sequence patterns with cp-based framework",
      "author" : [ "A. Kemmar", "W. Ugarte", "S. Loudni", "T. Charnois", "Y. Lebbah", "P. Boizumault", "B. Crémilleux" ],
      "venue" : "ICTAI. pp. 552–559",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Efficiently mining closed subsequences with gap constraints",
      "author" : [ "C. Li", "J. Wang" ],
      "venue" : "SIAM 2008 on Data Mining. pp. 313–322",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Efficient mining of gap-constrained subsequences and its various applications",
      "author" : [ "C. Li", "Q. Yang", "J. Wang", "M. Li" ],
      "venue" : "Trans. Knowl. Discov. Data 6(1), 2:1–2:39",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A constraint programming approach for mining sequential patterns in a sequence database",
      "author" : [ "J.P. Métivier", "S. Loudni", "T. Charnois" ],
      "venue" : "ECML/PKDD Workshop on Languages for Data Mining and Machine Learning",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Constraint-based sequence mining using constraint programming",
      "author" : [ "B. Négrevergne", "T. Guns" ],
      "venue" : "CPAIOR’15. pp. 288–305",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "PrefixSpan: Mining sequential patterns by prefix-projected growth",
      "author" : [ "J. Pei", "J. Han", "B. Mortazavi-Asl", "H. Pinto", "Q. Chen", "U. Dayal", "M. Hsu" ],
      "venue" : "ICDE. pp. 215–224. IEEE Computer Society",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "PMBC: pattern mining from biological sequences with wildcard constraints",
      "author" : [ "X. Wu", "X. Zhu", "Y. He", "A.N. Arslan" ],
      "venue" : "Comp. in Bio. and Med. 43(5), 481–492",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Computational aspects of mining maximal frequent patterns",
      "author" : [ "G. Yang" ],
      "venue" : "Theor. Comput. Sci. 362(1-3), 63–85",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Sequence mining in categorical domains: Incorporating constraints",
      "author" : [ "M.J. Zaki" ],
      "venue" : "CIKM’00. pp. 422–429",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "SPADE: An efficient algorithm for mining frequent sequences",
      "author" : [ "M.J. Zaki" ],
      "venue" : "Machine Learning 42(1/2), 31–60",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Mining periodic patterns with gap requirement from sequences",
      "author" : [ "M. Zhang", "B. Kao", "D.W. Cheung", "K.Y. Yip" ],
      "venue" : "TKDD 1(2)",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "In [7], we have proposed the global constraint PREFIX-PROJECTION for SPM which remedies to this drawback.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 15,
      "context" : "In recent years many studies have focused on SPM with gap constraints [16,18].",
      "startOffset" : 70,
      "endOffset" : 77
    }, {
      "referenceID" : 17,
      "context" : "In recent years many studies have focused on SPM with gap constraints [16,18].",
      "startOffset" : 70,
      "endOffset" : 77
    }, {
      "referenceID" : 5,
      "context" : "For example, [6] analyses purchase behaviors to reflect products usually bought by customers at regular time intervals according to time gaps.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 13,
      "context" : "In computational biology, the gap constraint helps discover periodic patterns with significant biological and medical values [14].",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 5,
      "context" : "Several specialized approaches have been proposed [6,10,18] but they have a lack of genericity to handle simultaneously various types of constraints.",
      "startOffset" : 50,
      "endOffset" : 59
    }, {
      "referenceID" : 9,
      "context" : "Several specialized approaches have been proposed [6,10,18] but they have a lack of genericity to handle simultaneously various types of constraints.",
      "startOffset" : 50,
      "endOffset" : 59
    }, {
      "referenceID" : 17,
      "context" : "Several specialized approaches have been proposed [6,10,18] but they have a lack of genericity to handle simultaneously various types of constraints.",
      "startOffset" : 50,
      "endOffset" : 59
    }, {
      "referenceID" : 3,
      "context" : "Recently, a few proposals [4,8,11,12] have investigated relationships between GSPM and constraint programming (CP) in order to provide a declarative approach, while exploiting efficient and generic solving methods.",
      "startOffset" : 26,
      "endOffset" : 37
    }, {
      "referenceID" : 7,
      "context" : "Recently, a few proposals [4,8,11,12] have investigated relationships between GSPM and constraint programming (CP) in order to provide a declarative approach, while exploiting efficient and generic solving methods.",
      "startOffset" : 26,
      "endOffset" : 37
    }, {
      "referenceID" : 10,
      "context" : "Recently, a few proposals [4,8,11,12] have investigated relationships between GSPM and constraint programming (CP) in order to provide a declarative approach, while exploiting efficient and generic solving methods.",
      "startOffset" : 26,
      "endOffset" : 37
    }, {
      "referenceID" : 11,
      "context" : "Recently, a few proposals [4,8,11,12] have investigated relationships between GSPM and constraint programming (CP) in order to provide a declarative approach, while exploiting efficient and generic solving methods.",
      "startOffset" : 26,
      "endOffset" : 37
    }, {
      "referenceID" : 6,
      "context" : "More recently, we have proposed the global constraint PREFIX-PROJECTION for SPM which remedies to this drawback [7].",
      "startOffset" : 112,
      "endOffset" : 115
    }, {
      "referenceID" : 1,
      "context" : "For example, the sequence 〈BABC〉 is a super-sequence of 〈AC〉 under gap[0, 2]: 〈AC〉 〈BABC〉.",
      "startOffset" : 70,
      "endOffset" : 76
    }, {
      "referenceID" : 0,
      "context" : "The occurrences under gap[0, 1] of α in SDB1[2] is given by AllOcc(α, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 25,
      "endOffset" : 31
    }, {
      "referenceID" : 1,
      "context" : "The occurrences under gap[0, 1] of α in SDB1[2] is given by AllOcc(α, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 1,
      "context" : "The occurrences under gap[0, 1] of α in SDB1[2] is given by AllOcc(α, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 0,
      "context" : "The occurrences under gap[0, 1] of α in SDB1[2] is given by AllOcc(α, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 82,
      "endOffset" : 88
    }, {
      "referenceID" : 1,
      "context" : "The occurrences under gap[0, 1] of α in SDB1[2] is given by AllOcc(α, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 82,
      "endOffset" : 88
    }, {
      "referenceID" : 0,
      "context" : "The occurrences under gap[0, 1] of α in SDB1[2] is given by AllOcc(α, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 91,
      "endOffset" : 97
    }, {
      "referenceID" : 2,
      "context" : "The occurrences under gap[0, 1] of α in SDB1[2] is given by AllOcc(α, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 91,
      "endOffset" : 97
    }, {
      "referenceID" : 4,
      "context" : "The occurrences under gap[0, 1] of α in SDB1[2] is given by AllOcc(α, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 99,
      "endOffset" : 105
    }, {
      "referenceID" : 5,
      "context" : "The occurrences under gap[0, 1] of α in SDB1[2] is given by AllOcc(α, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 99,
      "endOffset" : 105
    }, {
      "referenceID" : 0,
      "context" : "If we consider minsup = 2, α is a gap[0, 1] constrained sequential pattern because sup SDB1(α) ≥ 2.",
      "startOffset" : 37,
      "endOffset" : 43
    }, {
      "referenceID" : 0,
      "context" : "Most of SPM algorithms rely on the anti-monotonicity property of frequency [1] to reduce the search space: all the subsequences of a frequent sequence are frequent as well (or, equivalently, if a subsequence is infrequent, then no super-sequence of it can be frequent).",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 0,
      "context" : "A simple illustration from our running example suffices to show that sequence 〈AB〉 is not a sequential pattern under gap[0, 1] (for minsup = 3) whereas sequence 〈ACB〉 is a gap[0, 1] constrained sequential pattern.",
      "startOffset" : 120,
      "endOffset" : 126
    }, {
      "referenceID" : 0,
      "context" : "A simple illustration from our running example suffices to show that sequence 〈AB〉 is not a sequential pattern under gap[0, 1] (for minsup = 3) whereas sequence 〈ACB〉 is a gap[0, 1] constrained sequential pattern.",
      "startOffset" : 175,
      "endOffset" : 181
    }, {
      "referenceID" : 0,
      "context" : "Let p1 = 〈AC〉 be a pattern and the gap constraint be gap[0, 1].",
      "startOffset" : 56,
      "endOffset" : 62
    }, {
      "referenceID" : 1,
      "context" : "We have AllOcc(p1, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 0,
      "context" : "We have AllOcc(p1, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 31,
      "endOffset" : 37
    }, {
      "referenceID" : 1,
      "context" : "We have AllOcc(p1, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 31,
      "endOffset" : 37
    }, {
      "referenceID" : 0,
      "context" : "We have AllOcc(p1, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 40,
      "endOffset" : 46
    }, {
      "referenceID" : 2,
      "context" : "We have AllOcc(p1, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 40,
      "endOffset" : 46
    }, {
      "referenceID" : 4,
      "context" : "We have AllOcc(p1, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 48,
      "endOffset" : 54
    }, {
      "referenceID" : 5,
      "context" : "We have AllOcc(p1, SDB1[2]) = {[1, 2]), [1, 3], [5, 6]}.",
      "startOffset" : 48,
      "endOffset" : 54
    }, {
      "referenceID" : 1,
      "context" : "The right pattern extensions of p1 in SDB1[2] is equal to Ext [0,1] R (p1, SDB1[2]) = {〈CB〉, 〈BA〉, 〈B〉}.",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 0,
      "context" : "The right pattern extensions of p1 in SDB1[2] is equal to Ext [0,1] R (p1, SDB1[2]) = {〈CB〉, 〈BA〉, 〈B〉}.",
      "startOffset" : 62,
      "endOffset" : 67
    }, {
      "referenceID" : 1,
      "context" : "The right pattern extensions of p1 in SDB1[2] is equal to Ext [0,1] R (p1, SDB1[2]) = {〈CB〉, 〈BA〉, 〈B〉}.",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 0,
      "context" : "The right pattern extensions of p1 in SDB1 is given byExt [0,1] R (p1, SDB1) = {(1, {〈DB〉}), (2, {〈CB〉, 〈BA〉, 〈B〉}), (3, {〈BE〉}), (4, {〈C〉})}.",
      "startOffset" : 58,
      "endOffset" : 63
    }, {
      "referenceID" : 1,
      "context" : "To compute Ext R (p1, SDB1[2]), only the first occurrence of p1 in SDB1[2] need to be considered (i.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 1,
      "context" : "To compute Ext R (p1, SDB1[2]), only the first occurrence of p1 in SDB1[2] need to be considered (i.",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 0,
      "context" : "[1, 2]) (cf.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : "[1, 2]) (cf.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : "Thus, Ext R (p1, SDB1[2]) = {〈CBACB〉}).",
      "startOffset" : 21,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "Let minsup be 2 and the gap constraint be gap[0, 1].",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 0,
      "context" : "Thus, p1 = 〈AC〉 is a gap[0, 1] constrained sequential pattern.",
      "startOffset" : 24,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : "According to proposition 2, p1 can be extended to two gap[0, 1] constrained sequential patterns 〈ACB〉 and 〈ACC〉 .",
      "startOffset" : 57,
      "endOffset" : 63
    }, {
      "referenceID" : 0,
      "context" : "The SPM was first proposed in [1].",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 1,
      "context" : "Since then, many efficient specialized approaches have been proposed [2,13,17].",
      "startOffset" : 69,
      "endOffset" : 78
    }, {
      "referenceID" : 12,
      "context" : "Since then, many efficient specialized approaches have been proposed [2,13,17].",
      "startOffset" : 69,
      "endOffset" : 78
    }, {
      "referenceID" : 16,
      "context" : "Since then, many efficient specialized approaches have been proposed [2,13,17].",
      "startOffset" : 69,
      "endOffset" : 78
    }, {
      "referenceID" : 15,
      "context" : "Zaki [16] first proposed cSpade, a depth-first search based on a vertical database format, incorporating max-gap, max-span and length constraints.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 5,
      "context" : "[6] and Li and al.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[9] studied the problem of mining frequent patterns with gap constraints.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "In [6], a minimal distinguishing subsequence that occurs frequently in the positive sequences and infrequently in the negative sequences is proposed, where the maximum gap constraint is defined.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 8,
      "context" : "In [9], closed frequent patterns with gap constraints are mined.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 10,
      "context" : "[11] have proposed to model a sequence using an automaton capturing all subsequences that can occur in it.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "[8] have proposed a CSP model for SPM with explicit wildcards1.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 11,
      "context" : "[12] have proposed two CP encodings for the SPM.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 6,
      "context" : "In [7], we have proposed the global constraint PREFIX-PROJECTION for sequential pattern mining which remedies to this drawback.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 14,
      "context" : "Furthermore, the NPhardness of mining maximal2 frequent sequences was established in [15] by proving the #P-completeness of the problem of counting the number of maximal frequent sequences.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 0,
      "context" : "Consider the running example of Table 1, let minsup be 2 and the gap constraint be gap[1, 2].",
      "startOffset" : 86,
      "endOffset" : 92
    }, {
      "referenceID" : 1,
      "context" : "Consider the running example of Table 1, let minsup be 2 and the gap constraint be gap[1, 2].",
      "startOffset" : 86,
      "endOffset" : 92
    }, {
      "referenceID" : 0,
      "context" : "Consider Example 2: Ext [0,1] R (〈AC〉, SDB1) will be encoded as {(1, {(4, 5)}), (2, {(3, 4), (4, 5), (7, 7)}), (3, {(4, 5)}), (4, {(4, 4)})}.",
      "startOffset" : 24,
      "endOffset" : 29
    }, {
      "referenceID" : 0,
      "context" : "Minsup (%) GAP-SEQ[0,1] decomposed-p.",
      "startOffset" : 18,
      "endOffset" : 23
    }, {
      "referenceID" : 0,
      "context" : "f[0,1]",
      "startOffset" : 1,
      "endOffset" : 6
    }, {
      "referenceID" : 0,
      "context" : "Minsup (%) GAP-SEQ[0,1] decomposed-p.",
      "startOffset" : 18,
      "endOffset" : 23
    }, {
      "referenceID" : 0,
      "context" : "f[0,1]",
      "startOffset" : 1,
      "endOffset" : 6
    }, {
      "referenceID" : 4,
      "context" : "This section reports experiments on several real-life datasets [5,3] of large size having varied characteristics and representing different application domains (see Tab.",
      "startOffset" : 63,
      "endOffset" : 68
    }, {
      "referenceID" : 2,
      "context" : "This section reports experiments on several real-life datasets [5,3] of large size having varied characteristics and representing different application domains (see Tab.",
      "startOffset" : 63,
      "endOffset" : 68
    }, {
      "referenceID" : 0,
      "context" : "In the experiments, we used the gap constraint gap[0, 1] and various values of minsup.",
      "startOffset" : 50,
      "endOffset" : 56
    }, {
      "referenceID" : 8,
      "context" : "3: Varying the value of minsup with the gap constraint gap[0, 9]: CPU times.",
      "startOffset" : 58,
      "endOffset" : 64
    }, {
      "referenceID" : 8,
      "context" : "We used the gap[0, 9] constraint, while minsup varied until the two methods were not able to complete the extraction within the time limit.",
      "startOffset" : 15,
      "endOffset" : 21
    }, {
      "referenceID" : 8,
      "context" : "The gap constraint was set to gap[0, 9], and minsup to three different values.",
      "startOffset" : 33,
      "endOffset" : 39
    }, {
      "referenceID" : 2,
      "context" : ", gene - rare disease relationships) [3].",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 8,
      "context" : "We used the gap[0, 9] constraint, which is the best setting found in [3].",
      "startOffset" : 15,
      "endOffset" : 21
    }, {
      "referenceID" : 2,
      "context" : "We used the gap[0, 9] constraint, which is the best setting found in [3].",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 6,
      "context" : "These results confirm those observed in [7].",
      "startOffset" : 40,
      "endOffset" : 43
    } ],
    "year" : 2015,
    "abstractText" : "Sequential pattern mining (SPM) under gap constraint is a challenging task. Many efficient specialized methods have been developed but they are all suffering from a lack of genericity. The Constraint Programming (CP) approaches are not so effective because of the size of their encodings. In [7], we have proposed the global constraint PREFIX-PROJECTION for SPM which remedies to this drawback. However, this global constraint cannot be directly extended to support gap constraint. In this paper, we propose the global constraint GAPSEQ enabling to handle SPM with or without gap constraint. GAP-SEQ relies on the principle of right pattern extensions. Experiments show that our approach clearly outperforms both CP approaches and the state-of-the-art cSpade method on large datasets.",
    "creator" : "LaTeX with hyperref package"
  }
}