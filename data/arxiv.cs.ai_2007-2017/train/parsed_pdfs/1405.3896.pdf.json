{
  "name" : "1405.3896.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Properties of Stable Model Semantics Extensions",
    "authors" : [ "Mário Abrantes" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 5.\n38 96\nv1 [\ncs .A\nKEYWORDS: Stable model semantics, Conservative extensions to stable model semantics, Existence, Relevance, Cumulativity, Defectivity, Excessiveness, Irregularity, 2-valued semantics for logic programs"
    }, {
      "heading" : "1 Introduction",
      "text" : "The SM semantics (Gelfond and Lifschitz 1988) is generally accepted by the scientific community working on logic programs semantics as the de facto standard 2-valued semantics. Nevertheless there are some advantageous properties the SM semantics lacks such as (1) model existence for every normal logic program, (2) relevance, and (3) cumulativity (Pinto and Pereira 2011). Model existence guarantees that every normal logic program has a semantics. This is important to allow arbitrary updates and/or merges involving Knowledge Bases, possibly from different authors or sources (Pinto and Pereira 2011). Relevance allows for top-down query solving without the need to always compute complete models, but just the sub-models that sustain the answer to a query, though guaranteed extendable to whole ones (Pinto and Pereira 2011). As for cumulativity, it allows the programmer to take advantage of tabling techniques (Swift 1999) for speeding up computations (Pinto and Pereira 2011). Independently of the motivations that underlay the design of a semantics for logic programs, one may ask if it is easy to guarantee some or all of\nthe above properties, or even if it is easy to assess the profile of the resulting semantics in what concerns these properties. In this work we define a family of 2-valued conservative extensions of the SM semantics, the affix stable model semantics family, ASM. We then take two subclasses, ASMh ⊂ ASM and ASMm ⊂ ASM, and present a number of results that simplify the task of assessing the semantics in ASMh ∪ASMm on the properties of existence, relevance and cumulativity. The semantics in these two classes bear resemblance with the already known SM and MH semantics (see section 3), and this stands for the motivation to consider them. The following results, obtained in this work, should be emphasized: (1) We present a refined definition of cumulativity for semantics in the class ASMh∪ASMm, which turns into an easier job the dismissal of this property by resorting to counter-examples; (2) We divide the sets of rules of normal logic programs into layers, and use the decomposition of models into that layered structure to define three new (structural) properties, defectivity, excessiveness and irregularity, which allow to state a number of relations between the properties of existence, relevance and cumulativity for semantics of the ASMh ∪ASMm class, and at the same time facilitate the assessment of semantics in this class with respect to those properties; (3) As a result of the approach in our work light is shed on the characterization of SM semantics, as we show that the properties of (lack of) existence and (lack of) cautious monotony are equivalent, which opposes statements on this issue that may be found in the literature; we also characterize the relevance failure of SM semantics in a more clear way than usually stated in the literature. It should be stressed that this study is on the properties of a class of 2-valued semantics, under a prospection motivation. The weighing of such semantics rationales under an ‘intuitive’ point of view (or any other equivalently non-objective concept) is beyond the reach of our study. The results presented in this paper are enounced for the universe of finite ground normal logic programs, and are either proved in (Abrantes 2013), or immediate consequences of results there contained.\nThe remainder of the paper proceeds as follows. In section 2 we define the language of normal logic programs and the terminology to be used in the sequel. In section 3 the families ASM, ASMh and ASMm are defined. In section 4 we characterize the property of cumulativity for the families ASMh and ASMm, whilst in section 5 the properties of defectivity, excessiveness and irregularity are defined. Some relations among existence, relevance and cumulativity, which are revealed by means of those properties, are stated. Section 6 is dedicated to final remarks."
    }, {
      "heading" : "2 Language and Terminology of Logic Programs",
      "text" : "A normal logic program defined over a language L is a set of normal rules, each of the form\nb0 ← b1, · · · ,bm,not c1, · · · ,not cn (1)\nwhere m,n are non-negative integers and b j,ck are atoms of L ; bi and not ck are generically designated literals, not ck being specifically designated default literal. The operator ‘,’ stands for the conjunctive connective, the operator ‘not’ stands for negation by default and the operator ‘←’ stands for a dependency operator that establishes a dependence of b0 on the conjunction on the right side of ‘←’. b0 is the head of the rule and b1, · · · ,bm,not c1, · · · ,not cn is the body of the rule. A rule is a fact if m = n = 0. A literal (or a program) is ground if it does not contain variables. The set of all ground atoms of a normal logic program is called Herbrand base of P,\nHP. A program is finite if it has a finite number of rules1. Given a program P, program Q is a subprogram of P if Q ⊆ P, where Q,P are envisaged as sets of rules.\nFor ease of exposition we henceforth use the following abbreviations: Atoms(E), is the set of all atoms that appear in the ground structure E , where E can be a rule, a set of rules or a set of logic expressions; Body(r), is the set of literals in the body of a ground rule r; Facts(E), is the set of all facts that appear in the set of rules E; Heads(E), is the set of all atoms that appear in the heads of the set of rules E; if E is unitary, we may use ‘Head’ instead of ‘Heads’ . We may compound some of these abbreviations, as for instance Atoms(Body(r)) whose meaning is straightforward. Each of the abbreviations may also be taken as the conjunction of the elements contained in the respective sets.\nGiven a 2-valued interpretation I of a logic program P, we represent by I+ (resp. I− ) the set of its positive literals (resp. atoms whose default negations are true with respect to I). If I is 3-valued, we additionally represent by Iu the set of undefined atoms with respect to I.\nThe following concepts concern the structure of programs. Let P be a logic program and r,s any two rules of P. Complete rule graph, CRG(P)2: is the directed graph whose vertices are the rules of P. Two vertices representing rules r and s define an arc from r to s iff Head(r) ⊆ Atoms(Body(s)). Rule depending on a rule2: rule s depends on rule r iff there is a directed path in CRG(P ) from r to s. Subprogram relevant to an atom3: a rule r ∈ P is relevant to an atom a ∈ HP iff there is a rule s such that Head(s) = {a} and s depends on r. The set of all rules of P relevant to a is represented by RelP(a), and is named subprogram (of P) relevant to a. Loop4: a set of rules R forms a loop (or the rules of set R are in loop) iff, for any two rules r,s ∈ R, r depends on s and s depends on r. We say that rule r ∈ R is in loop through literal L ∈ Body(r) iff there is a rule s ∈ R such that Head(s) = Atoms(L). Rule layering3: the rule layering (or just layering, for simplicity) of P is the labeling of each rule r ∈ P with the smallest possible natural number, layer(r), in the following way: for any two rules r and s, (1) if rules r,s are in loop, then layer(r) = layer(s); (2) if rule r depends on rule s but rule s does not depend on rule r, then layer(r)> layer(s). Every integer number T in the image of the layer function defines a layer of P, meaning the set of rules of P labeled with number T – we use the expression ‘layer’ to refer both to a set of all rules with that label, and to the label itself. We represent by P≤T (resp. P>T ) the set of all rules of P whose layer is less than or equal to (resp. greater than) T . T-segment of a program: we say that P≤T is the T-segment of P iff Atoms(P≤T )∩Heads(P>T ) = /0. We may also say ‘segment T ’ to mean the set of rules corresponding to segment P≤T .\nLet SEM be a 2-valued semantics and SEM(P) the set of SEM models of a logic program P. Let also the set of atoms kerSEM(P) =\n⋂ M∈SEM(P) M+ be dubbed semantic kernel of P with respect\nto SEM (the semantic kernel is not defined if SEM(P) = /0). The following properties concern semantics of logic programs. We say that a semantics SEM is: Existential iff every normal logic\n1 In this work, if nothing to the contrary is said, by ‘logic program’, or simply by ‘program’, we mean a finite set of normal ground rules. 2 Adapted from (Pinto and Pereira 2011). 3 Adapted from (Dix 1995b) 4 Adapted from (Costantini 1995)\nprogram has at least one SEM model; Cautious monotonic5 iff for every normal logic program P, and for every set S ⊆ kerSEM(P), we have kerSEM(P) ⊆ kerSEM(P∪ S); Cut iff for every normal logic program P, and for every set S ⊆ kerSEM(P), we have kerSEM(P∪S)⊆ kerSEM(P); Cumulative iff it is cautious monotonic and cut; Relevant iff for every normal logic program P we have\n∀a∈HP(a ∈ kerSEM(P)⇔ a ∈ kerSEM(RelP(a))) (2)\nwhere RelP(a) is the subprogram of P relevant to atom a; Global to local relevant iff the logical entailment ’⇒’ stands in formula (2); Local to global relevant iff the logical entailment ’⇐’ stands in formula (2)."
    }, {
      "heading" : "3 Conservative Extensions of the SM Semantics",
      "text" : "In this section we define a family of abductive 2-valued semantics6, the affix stable model family, ASM, whose members are conservative extensions of the SM semantics. For that purpose we need the concepts of reduction system and MH semantics."
    }, {
      "heading" : "3.1 Reduction System and MH Semantics",
      "text" : "In (Brass et al. 2001) the authors propose a set of five operations to reduce a program (i.e., eliminate rules or literals) – positive reduction, PR, negative reduction, NR, success, S, failure, F and loop detection, L (see Appendix A for the definitions of these operations). We represent this set of operations as 7→W FS:= {PR,NR,S,F,L}. By non-deterministically applying this set of operations on a program P, we obtain the program P̂, the remainder of P, which is invariant under a further application of any of the five operations. This transformation is terminating and confluent (Brass et al. 2001). We denote the transformation of P into P̂ as P 7→W FS P̂. We also write P̂ = remainderWFS(P). It is shown in (Brass et al. 2001) that W FM(P) =WFM(P̂), where WFM stands for the well-founded model (Gelder 1993). See Appendix B for an example of the computation of the remainder of a program.\nOne way to obtain conservative extensions of the SM semantics, is to relax some operations of the reduction system 7→WFS, which yields weaker reduction systems, that is, systems that erase less rules or literals than 7→W FS. An example of such a semantics is the minimal hypotheses semantics, MH (Pinto and Pereira 2011), whose reduction system 7→MH is obtained from 7→W FS by replacing the negative reduction operation, NR, by the layered negative reduction operation, LNR, i.e., 7→MH := {PR,LNR,S,F,L}. LNR is a weaker version of NR that instead of eliminating any rule r containing say not b in the body, in the presence of the fact b, as NR does, only eliminates rule r if this rule is not in loop through literal not b. We write P 7→MH P̊, where P̊ is the layered remainder of P. We also write P̊= remainderMH(P). See Appendix C for an example of the computation of the layered remainder of a program.\n3.2 ASM,ASMh and ASMm Families\nWe define affix stable interpretation and then use this concept to put forward the definition of ASM family.\n5 Adapted from (Dix 1995a; Dix 1995b). 6 See (Denecker and Kakas 2002) for abductive semantics.\nDefinition 1\nAffix Stable Interpretation. Let P be a normal logic program, SEM a 2-valued semantics with a corresponding reduction system 7→SEM , and X ⊆ Atoms(remainderSEM(P)). We say that I is an affix stable interpretation of P with respect to set X and semantics SEM (or simply a SEM stable interpretation with affix X) iff I = WFM(P∪ X) and WFMu(P∪ X) = /0,7 that is, I is the only stable model of the program P∪X . We name X an affix (or hypotheses set) of interpretation I. We also name assumable hypotheses set of program P, Hyps(P), the union of all possible affixes that may be considered to define the stable interpretations (we have Hyps(P)⊆ Atoms(remainderSEM(P))).\nDefinition 2\nAffix Stable Model Semantics Family, ASM. A 2-valued semantics SEM, with a corresponding reduction system 7→SEM , belongs to the affix stable model semantics family, ASM, iff, given any normal logic program P, SEM(P) contains all the SM models of P, in case they exist, plus a subset (possibly empty) of the affix stable interpretations of P chosen by resorting to specifically enounced criteria.\nBoth semantics SM and MH belong to the ASM family. The two non-disjoint subfamilies of ASM next defined, ASMh and ASMm, will be the classes whose formal properties we study in the sequel.\nDefinition 3 ASMh and ASMm Families. A semantics SEM ∈ ASM belongs to the ASMh or ASMm families iff, for any normal logic program P, the models are computed as follows:\n1. For both ASMh and ASMm the set of assumable hypotheses, Hyps(P), is contained in the set of atoms that appear default negated in remainderSEM(P)8; 2. For semantics in the class ASMh, the affixes of the models of P are either those non empty minimal with respect to set inclusion, if Hyps(P) 6= /0, or else the empty set if Hyps(P)= /0. For semantics in the class ASMm, the models in SEM(P) are always minimal models.\nWe now refer some examples of ASMh and ASMm members, whose definitions can be found in Appendix D. Besides SM, MH and others, the following are ASMh family members, referred to subsequently:9 MHLS, MHLoop, MHSustainable, MHSustainablemin , MH\nRegular. Besides SM and others, the following are ASMm family members, referred to subsequently: Navy, Blue, Cyan, Green."
    }, {
      "heading" : "4 Characterization of Cumulativity for the ASMh ∪ASMm Class",
      "text" : "In this section we lay down a characterization of cumulativity for semantics SEM of the ASMh ∪ ASMm class, via the following theorem.\n7 Notice that WFMu(P∪X) is the set of undefined atoms in the model WFM(P∪X). 8 The purpose of computing the remainder of a program, is to obtain the assumable hypotheses set of the program. 9 The first three semantics were suggested by Alexandre Pinto.\nTheorem 1 Let SEM be a semantics of the ASMh ∪ASMm class. For every program P and for every subset S ⊆ kerSEM(P), the following results stand: (1) SEM is cautious monotonic iff SEM(P∪ S) ⊆ SEM(P); (2) SEM is cut iff SEM(P) ⊆ SEM(P ∪ S); (3) SEM is cumulative iff SEM(P) = SEM(P∪S) – this is a consequence of statements (1) and (2).10\nThe three items of this theorem correspond to refinements of the classical definitions of cautious monotony, cut and cumulativity (see section 2). The new definitions establish the properties by means of relations among sets of models, as opposed to the relations among sets of atoms that characterize the classical definitions.\nThe results stated in this theorem are advantageous to spot cumulativity failure in semantics of the ASMh ∪ASMm class by means of counter-examples (logic programs), when compared with common procedures (e.g., (Dix 1995a; Dix 1995b)). The reason is that common procedures always need the counter-examples to fail cumulativity11, whilst the results of theorem 1 allow us to spot failure of cumulativity even in some cases where the counter-examples used do not show any failure of this property. To make this point clear see the examples in Appendix E and Appendix F.\nIt should be stressed that there are 2-valued cumulative semantics to which SEM(P) 6= SEM(P∪ S) for some normal logic program P and some S ⊆ kerSEM(P) (for an example, see the definition of the 2-valued semantics Picky in Appendix G). Theorem 1 states this is not the case if SEM ∈ ASMh ∪ASMm."
    }, {
      "heading" : "5 Defectivity, Excessiveness and Irregularity",
      "text" : "Theorem 1 application for dismissing the cumulativity property by means of counter-examples, demands computing the set of models SEM(P) of a program P, the set kerSEM(P), and after this it needs the computation of the sets of models SEM(P∪ S), S ∈ kerSEM(P), to look for a case that eventually makes SEM(P) = SEM(P∪S) false. In this section three structural properties are defined, defectivity, excessiveness and irregularity, that will turn the dismissal of existence, relevance or cumulativity spottable by means of one model only. It will be shown that for semantics of the ASMh∪ASMm class, defectivity is equivalent to the failure of existence and to the failure of global to local relevance, and also entails the failure of cautious monotony, whilst excessiveness entails the failure of cut, and irregularity is equivalent to the failure of local to global relevance."
    }, {
      "heading" : "5.1 Defectivity",
      "text" : "The rationale for the concept of defective semantics is the following: if a segment P≤T has a SEM model M that is not contained in any whole SEM model of P, then we say the semantics SEM is defective, in the sense that it ‘does not use’ all the models of segment T in order to get whole models of P.\n10 Notice that SEM(P) represents the set of all SEM models of P. 11 The general procedure to spot the failure of cumulativity by resorting to counter-examples is as follows: compute\nall the SEM models of a program P; add to P subsets S ⊆ kerSEM(P), and compute all the models of the resulting programs P∪S, drawing a conclusion about cumulativity failure only in cases where kerSEM (P) 6= kerSEM(P∪S).\nDefinition 4 Defective semantics. A 2-valued semantics SEM is called defective iff there is a normal logic program P, SEM(P) 6= /0, a segment P≤T of P, and a SEM model M of the segment P≤T , such that SEM(P>T ∪M+) = /0. We also say that SEM is defective with respect to segment T of program P, and that M is a defective model of P with respect to segment T and semantics SEM.\nExample 1 Program P = {a ← not b, b ← not a, c ← a, c ← not c} may be used to show that the SM semantics is defective. In fact, the only SM model of P is N = {a,not b,c} with affix {a}. Meanwhile, P≤1 = {a← not b, b← not a} is a segment that has the stable model M = {not a,b}, and we have SM(P>1 ∪{b}) = /0.\nThe next theorem shows how conclusions about existence, relevance and cumulativity may be immediately taken in the case of a defective semantics.\nTheorem 2 The following relations are valid for any semantics of the ASMh ∪ASMm class:\n1. Defectivity ⇔¬Existence ⇔¬Global to Local Relevance;\n2. Defectivity ⇒¬Cautious Monotony.\nThe reader should notice the importance of this theorem: not only defectivity is enough to dismiss existence, relevance and cumulativity, as also these properties appear strongly related for semantics of the class ASMh ∪ASMm: if existence fails then relevance also fails (through global to local relevance failure); if existence fails then cumulativity also fails (through cautious monotony failure); if relevance fails (through global to local relevance failure), then cumulativity also fails (through cautious monotony failure). Definition 4 above shows the structural nature of defectivity, which allows the verification of the property by wisely constructing a program that satisfies it. This may turn easier the assessment of existence, relevance and cumulativity, when compared to dealing with this issue on the basis of abstract proofs. Even more, the relation between existence and defectivity stated in theorem 2, allows the failure of the existence property to be detected by resorting to counter-examples, even in some cases where the program used as counter-example has models. E.g., program P in Appendix E can be used to detect the failure of existence for SM semantics, in spite of the existence of stable models for program P, since it reveals the defectivity of SM.12\nThe results stated in theorem 2 also shed some light on the characterization of SM semantics with respect to the properties of existence and cumulativity. In (Dix 1995b), section 5.6, the author says that the SM is not cumulative and that this fact does not depend on the non existence of stable models (i.e., the author states that lack of cumulativity is not a consequence of lack of existence). Meanwhile theorem 2 above shows that SM is non-existential due to being defective, which in turn makes it not cautious monotonic and thus not cumulative. Thus the failure of cumulativity for the SM semantics case is indeed a consequence of the failure of existence for this semantics. Moreover, with respect to the SM semantics a stronger result relating existence\n12 It should be pointed out that there are 2-valued semantics for which the equivalence de f ectivity ⇔¬existence fails, e.g., MSuppP (Apt et al. 1988) which is not defective in spite of failing the existence property – it is the case that M Supp P\nis not a ASM semantics, since it does not conservatively extend the SM semantics.\nand cautious monotony may be enounced: these two properties show up equivalence in the sense stated in proposition 3 below. To the best of our knowledge, this connection between these two properties had not yet been stated.\nProposition 3 For the SM semantics the following result stands: there is a program P that shows existence failure iff there is a program P∗ that shows cautious monotony failure."
    }, {
      "heading" : "5.2 Excessiveness and Irregularity",
      "text" : "The rationale of the concept of excessive semantics is the following: if a normal logic program P has a model N and a layer P≤T such that for every model M∗ ∈ SEM(P≤T ) it is the case that N /∈ SEM(P>T ∪M+∗ ), then we say that model N (and thus the semantics) is excessive, in the sense that it ‘goes beyond’ the semantics of the segment P≤T by not being a ‘consequence’ of it.\nDefinition 5 Excessive semantics. A 2-valued semantics SEM is called excessive iff there is a logic program P, a segment P≤T , a model M ∈ SEM(P≤T ) and a model N ∈ SEM(P) such that:\n1. M+ = N+≤T , where N + ≤T = N +∩Heads(P≤T ); 2. For every model M∗ ∈ SEM(P≤T ) it is the case that N /∈ SEM(P>T ∪M+∗ ); 3. There is at last a SEM model N∗ of P, such that N∗ ∈ SEM(P>T ∪M+).\nWe also say that SEM is excessive with respect to segment T of program P, and that N is an excessive model of P with respect to segment T and semantics SEM.\nIn the excessiveness example in Appendix H it is shown that the semantics MH,MHLS,MHLoop, Navy,Green are excessive.\nThe rationale of the concept of irregularity is as follows: given a certain whole model N ∈ SEM(P), if the set N+∩Heads(P≤T ) is not a model of a segment P≤T , then we say that SEM is irregular, since N ‘is not a consequence’ of the semantics of segment T .\nDefinition 6 Irregular semantics. A 2-valued semantics SEM is called irregular iff there is a logic program P, a segment P≤T and a SEM model N of P, such that for no model M of P≤T do we have N+≤T = M +, where N+≤T = N +∩Heads(P≤T ). We also say that SEM is irregular with respect to segment T of program P, and that N is an irregular model of P with respect to segment T and semantics SEM. A model that is not irregular is called regular, and a semantics that produces only regular models is called regular.13\nThe concepts of excessiveness and irregularity exhibit independence for semantics of the ASMh ∪ ASMm class, meaning there is a semantics in this class for any of the four possible cases of validity or failure of excessiveness and irregularity. As a matter of fact, it can be shown (Abrantes 2013) that Blue is irregular whilst not excessive (i.e., irregularity ; excessiveness); it is also the case that MHRegular is excessive but not irregular (i.e., excessiveness ; irregularity).\n13 In comparing excessiveness and irregularity, notice that a whole model can be excessive whilst containing models for all the segments of the program (i.e., be a regular model) - see the excessiveness example in Appendix H.\nAlso MH is excessive and irregular, and Cyan is not excessive and is not irregular.\nThe following result states relations between excessiveness and cut, and between irregularity and relevance.\nTheorem 4 The following relations stand for any semantics of the ASMh ∪ASMm class:\n1. Excessiveness ⇒¬Cut;\n2. Irregularity⇔¬Local to Global Relevance.\nAs excessiveness and irregularity are structural properties, being thus detectable by construction of adequate programs, they facilitate, via this theorem, the dismissal of cut and relevance. For instance, this result together with the excessiveness example in Appendix H, shows that semantics MH, MHLS, MHLoop, Navy and Green are excessive, and thus not cut. Also, this result together with the irregularity example in Appendix H, shows that semantics MH, MHLS and MHLoop, Green, Navy and Blue are irregular, and thus not relevant. As was the case for the relation between the properties of existence and cumulativity for the SM semantics, our work sheds also some light on the SM semantics relevance failure, through the following results.\nProposition 5 Let P be a normal logic program and M ∈ SM(P). Then M is neither excessive nor irregular.\nCorollary 6 SM is (vacuously) local to global relevant.\nNotice that this corollary, together with the example in Appendix E and theorem 2, let clear the cause for SM semantics relevance failure: SM fails relevance because it fails global to local relevance. This is a more precise characterization than just saying that SM is not relevant, as usually stated in literature (e.g., (Dix 1995b)).\nIf we consider the five formal properties of existence (∃), global to local relevance (gl), local to global relevance (lg), cautious monotony (cm) and cut (cut), the validity or failure of each of these properties allow, in the general case, the existence of 25 = 32 types of semantics. Meanwhile, the study we present in this work shows that only 12 such types of semantics may exist in the ASMh ∪ASMm class. They are represented in table I 1 in Appendix I."
    }, {
      "heading" : "6 Final Remarks",
      "text" : "In this paper we considered the characterization of 2-valued conservative extensions of the SM semantics on the properties of existence, relevance and cumulativity. This theoretical endeavor is reasonable under a point of view of prospectively assessing the behavior of such types of semantics with respect to a set of properties that are desirable, both under a computational (relevance and cumulativity) and a semantical (existence) standpoint. For that purpose we focused our study on two subsets of the here defined ASM class of 2-valued conservative extensions of the SM semantics, the non-disjoint classes ASMh and ASMm, whose elements maintain a degree of resemblance with already known 2-valued semantics, such as the SM and the MH semantics. As a result of this study, refined definitions of cautious monotony, cut and cumulativity were set.\nThis new definitions turn into an easier job the dismissal of the properties of existence, relevance and cumulativity, as shown in section 4. This study also reveals relations among these properties, unveiled by theorems 2 and 4, that allow to draw conclusions about some of them on basis of held knowledge about others. This last point builds on top of the new structural properties of defectivity, excessiveness and irregularity, which provide an analytical shortcut to assess existence, relevance and cumulativity. The approach taken in this work (characterizing families of semantics, instead of individual semantics), revealed itself advantageous also in clarifying the profile of the well known and studied SM semantics, via the results stated in proposition 3 and corollary 6. Our work also states a maximum of 12 types of semantics in the class ASMh ∪ASMm, with respect to the satisfaction/failure of the properties of existence (∃), global to local relevance (gl), local to global relevance (lg), cautious monotony (cm) and cut (cut).\nFinally, the structural approach put forward in this paper has the potential of being used with semantics other than 2-valued ones, and with other strong and weak properties besides existence, relevance or cumulativity.14"
    }, {
      "heading" : "Acknowledgments",
      "text" : "We thank Alexandre Pinto for some important debates on conservative extensions of the SM semantics. The work on this paper has been partially supported by Fundação para a Ciência e Tecnologia and Instituto Politécnico de Bragança grant PROTEC : SFHR/49747/2009."
    }, {
      "heading" : "Appendix A Reduction Operations",
      "text" : "In the definitions below, P1 and P2 are two ground logic programs.\n1. Positive reduction, PR. Program P2 results from P1 by positive reduction iff there is a rule r ∈ P1 and a default literal not b ∈ Body(r) such that b /∈ Heads(P1), and P2 = (P1 \\{r})∪ {Head(r)← (Body(r)\\ {not b})}. 2. Negative reduction, NR. Program P2 results from P1 by negative reduction iff there is a rule r ∈ P1 and a default literal not b ∈ Body(r) such that b ∈ Facts(P1), and P2 = P1 \\{r}. 3. Success, S. Program P2 results from P1 by success iff there is a rule r ∈ P1 and a fact b ∈ Facts(P1) such that b ∈ Body(r), and P2 = (P1 \\{r})∪{Head(r)← (Body(r)\\{b})}. 4. Failure, F. Program P2 results from P1 by failure iff there is a rule r ∈ P1 and a positive literal b ∈ Body(r) such that b /∈ Heads(P1), and P2 = P1 \\ {r}. 5. Loop Detection, L. Program P2 results from P1 by loop detection iff there is a set A of ground atoms such that:\n(a) For each rule r ∈ P1, if Head(r) ∈ A , then Body(r)∩A 6= /0; (b) P2 := {r ∈ P1|Body(r)∩A = /0}."
    }, {
      "heading" : "Appendix B Remainder Computation Example",
      "text" : "Let P be the set of all rules below. The remainder P̂ is the non shadowed part of the program. The labels (i)–(v) indicate the operations used in the corresponding reductions: (i) PR, (ii) NR, (iii) S, (iv) F, (v) L.\n{a ← not f (i), e ← d (v), a ← not b (i), d ← e (v), b ← not a (ii), c ← a (iii), d ← f (iv)}"
    }, {
      "heading" : "Appendix C Minimal Hypotheses Models Computation",
      "text" : "Let P be the set of rules below, which is equal to the program in Appendix B. The layered remainder P̊ is the non-shadowed part of the program.\na ← not f d ← f\na ← not b e ← d\nb ← not a d ← e\nc ← a\nNotice that rule b ← not a is no longer eliminated by the fact a, since this rule and rule a ← not b are in loop, and in the case of rule b ← not a the loop is through the literal not a.\nThe MH models of a program P are computed as follows: (1) Take as assumable hypotheses set, Hyps(P), the set of all atoms that appear default negated in P̊; in the case of the previous program we have Hyps(P) = {a,b}; (2) Form all programs P∪H, for all possible subsets H ⊆ Hyps, H 6= /0 (if Hyps = /0, then H = /0 is the only set to consider); take all the interpretations for which WFM(P∪H) is a total model (meaning a model that has no undefined literals); H is the hypotheses set of the interpretation WFM(P∪H); (3) Take all the interpretations obtained in the previous point, and chose as MH models the ones that have minimal H sets with respect\nto set inclusion. The MH models of program P in the example above, and the corresponding hypotheses sets, are\nM1 = {a,not b,c,not d,not e,not f} H = {a}\nM2 = {a,b,c,not d,not e,not f} H = {b}.\nNotice that M1 is the only SM model of P. The MH reduction system keeps some loops intact, which are used as choice devices for generating MH models, allowing us to have MH(P)⊇ SM(P). The sets H considered may be taken as abductive explanations (Denecker and Kakas 2002) for the corresponding models.\nAppendix D Definitions of some Elements of ASMh and ASMm Families\nBesides SM and others, the following are ASMh family members. MHLS: the reduction system is obtained by replacing the success operation in 7→MH by the layered success operation;15 MHLS models are computed as in the MH case. MHLoop: the reduction system is 7→MH ; the assumable hypotheses set of a program P, Hyps(P), is formed by the atoms that appear default negated in literals involved in loops in the layered remainder P̊; MHLoop models are computed as in the MH case. MHSustainable: the reduction system is 7→MH ; MHSustainable models are computed as in the MH case with the following additional condition: if H is a set of hypotheses of a MHSustainable model M of P, then\n∀h∈H [(H \\ {h}) 6= /0 ⇒ h ∈WFM u(P∪ (H \\ {h}))],\nthat is, no single hypothesis may be defined in the well-founded model if we join to P all the other remaining hypotheses. MHSustainablemin : the reduction system is 7→MH ; MH Sustainable min (P) retrieves the minimal models contained in MHSustainable(P) for any normal logic program P. MHSustainablemin also belongs to the ASMm family, due to the minimality of its models. MHRegular: the reduction system is 7→MH ; retrieves the same models as MH, except for the irregular ones (cf. Definition 6).\nBesides SM, MHSustainablemin (defined above in this appendix) and others, the following are ASM m family members. Navy: the reduction system is 7→WFS. Given a normal logic program P, Navy(P) contains all the minimal models of P̂.16 Blue: the reduction system is 7→W FS. Given a normal logic program P, Blue(P) contains all the models in Navy(P∪K) where K is obtained after terminating the following algorithm:17 (a) Compute K = kernelNavy(P̂); (b) Compute K′ = kernelNavy(P̂∪K); (c) If K 6= K′, then let P be the new designation of program P∪K′; go to step (a). Repeat steps (a) – (c) until K 6= K′ comes false in (c).\n15 Layered success is an operation proposed by Alexandre Pinto. It weakens the operation of success by allowing it to be performed only in the cases where the rule r, whose body contains the positive literal b to be erased, is not involved in a loop through literal b. 16 See definition of P̂ in subsection 3.1. 17 This algorithm is presented in (Dix 1995a).\nCyan: the reduction system is 7→WFS. Given a normal logic program P, compute Cyan(P) through the steps of Blue computation, but taking only the regular models (cf. Definition 6) to compute the semantic kernel at steps (a) and (b). Green: the reduction system is 7→W FS. Given a normal logic program P, Green(P) contains all the minimal models of P̂ that have the smallest (with respect to set inclusion) subsets of classically unsupported atoms.18"
    }, {
      "heading" : "Appendix E Example of Cumulativity Failure Detection",
      "text" : "The following 1-layer program P is a counter-example for showing, using theorem 1, that SM semantics is not cumulative, due to being not cautious monotonic (program P does not allow us to spot the failure of any of these properties by means of the usual definitions of cumulativity and cautious monotony presented in section 2) .\na ← not b,not s d ← b d ← a\nb ← not a,not c d ← not d c ← k\nc ← not b,not k k ← a,d s ← not a,d\nIn fact, the SM models of P are {a,d,c,k} and {b,d,s}, and thus kerSM(P) = {d}. Now P∪{d} has the stable models {a,d,c,k}, {b,d,s} and {c,d,s}, and thus kerSM(P) = kerSM(P∪{d}) = {d}. Hence no negative conclusion can be afforded about cumulativity, by means of the usual definition of this property. Meanwhile, by using the statement (3) of theorem 1 it is straightforward to conclude that SM semantics does not enjoy the property of cumulativity, because SM(P) 6= SM(P∪{d}). Moreover, statement (1) of the theorem tells us, via this example, that SM semantics is not cautious monotonic because SM(P∪{d})* SM(P)."
    }, {
      "heading" : "Appendix F Proof of Cautious Monotony and Cut Failure",
      "text" : "The following 1-layer program P = P̊ is a counter-example for showing, using theorem 1, that none of the semantics MH, MHLS, MHLoop, MHSustainable and MHRegular is either cautious monotonic or cut (program P does not allow us to spot the failure of any of these properties by means of the usual definitions of cautious monotony and cut presented in section 2) .\nu ← b a ← not b\nu ← c b ← not c\nt ← a c ← h,u\nt ← h h ← not h,not t\nLet SEM represent any of the above semantics. The minimal hypotheses models are the same with respect to any of the four semantics (models are represented considering only positive literals): {c,u,a, t} with affix {c}; {b,h,u,c, t} with affix {b,h}; {t,b,u} with affix {t}. Thus kerSEM(P) = {t,u}. Now it is the case that the remainder of P∪{u} is the same for any of these\n18 Given a logic program P, a model M of P and an atom b ∈ M, we say that b is classically unsupported by M iff there is no rule r ∈ P such that Head(r) = {b} and all literals in Body(r) are true with respect to M.\nsemantics:\nu ← b a ← not b\nu ← c b ← not c\nt ← a c ← h\nt ← h h ← not h,not t u ←\n(as a matter of fact, the remainder for the MHLS has the rule c ← h,u instead of c ← h; but this does not change the sequel of this reasoning). The minimal hypotheses models of P∪{u} are the same with respect to any of the four semantics (models are represented considering only positive literals): {c,u,a, t} with affix {c}; {h,u,c, t,a} with affix {h}; {t,b,u} with affix {t}. Thus kerSEM(P∪{u}) = {t,u}= kerSEM(P), and no conclusions about cumulativity can be drawn by means of the usual general procedures. Meanwhile, M = {h,u,c, t,a}, with affix {h}, is a minimal affix model of P∪{u} but is not a minimal affix model of P, which by point (1) of theorem 1 renders any of these semantics not cautious monotonic. Also N = {b,h,u,c, t}, with affix {b,h}, is a minimal affix model of P, but not a minimal affix model of P∪{u}, which by point (2) of theorem 1 renders any of these semantics as not cut."
    }, {
      "heading" : "Appendix G Picky, a Special 2-valued Cumulative Semantics",
      "text" : "The semantics Picky is defined as follows: for any normal logic program P (1) if SM(P) = /0, then Picky(P) = /0; (2) if SM(P) 6= /0, then (2a) Picky(P) = SM(P) iff kerSM(P) = kerSM(P∪ S), for every S ⊆ kerSM(P); (2b) otherwise Picky(P) = /0. This semantics is cumulative, by definition, but it is not always the case that Picky(P) = Picky(P∪ S), S ⊆ kerSM(P) : for program P of the example in Appendix E, we have Picky(P) = {{a,d,c,k},{b,d,s}} and Picky(P∪ {d}) = {{a,d,c,k},{b,d,s},{c,d,s}}, which means, by theorem 1, that Picky is not cumulative. Notice that Picky is not a ASM semantics, because it does not conservatively extend the SM semantics: for program P in the referred example, we have SM(P) 6= /0 and Picky(P) = /0."
    }, {
      "heading" : "Appendix H Excessiveness and Irregularity",
      "text" : "Excessiveness. The following program P shows that semantics MH, MHLS, MHLoop, Navy and Green are excessive (the dashed lines divide the program into layers; top layer is layer 1, bottom layer is layer 4),\na ← not b\nb ← not a\n−−−−−1\nu ← a\nu ← b\n−−−−−2\np ← not p,not u\n−−−−−3\nq ← not q,not p\n−−−−−4.\nLet SEM represent any of these semantics. It is the case that N = {a,u, p,not b,not q} with affix {a, p}, is a model of P under any of the referred semantics, and for no SEM model M∗ ∈ SEM(P≤2), where SEM(P≤2) = {{a,not b,u},{not a,b,u}}, do we have N ∈ SEM(P>2∪M+∗ ), because atom u ∈ M+∗ eliminates the rule in layer 3 via layered negative reduction operation (which has here the same effect as negative reduction operation), and thus p belongs to no model in SEM(P>2 ∪M+∗ ).\nIrregularity. Program P below shows that the semantics MH, MHLS and MHLoop, Green, Navy and Blue are all irregular.\na ← not b\nb ← not a\n−−−−−1\np ← not p,not a\nq ← not q,not b\nIn fact, all these semantics admit the model N = {a,b,not p,not q}. The models of segment P≤1 are {a,not b} and {b,not a}, none of whose positive sets of atoms equals N+≤T = {a,b}. As Blue is not excessive, this example shows irregularity ; excessiveness.\nAppendix I The 12 possible types of ASMh and ASMm semantics\nIn table I 1 below ‘0’ flags the failure of a property and ‘1’ means the property is verified.\nThe 20 missing types of semantics correspond to cases where (∃ = 0 and gl = 1), or (∃ = 1 and gl = 0), or (∃ = 0 and cm = 1), each of these cases going against the statement of theorem 2. The correspondence of the ASMh ∪ ASMm class semantics presented in this text and\nthe entries in table I 1 is as follows: 1. MHsustainable,MHSustainablemin 2. −− 3. −− 4. SM 5. MH,MHLS,MHLoop,Green 6. −− 7. Navy 8. Blue 9. MHRegular 10. −− 11. −− 12. Cyan. Whether semantics of the ASMh ∪ASMm class exist for the types marked with ’−−’, may be envisaged as an open issue."
    } ],
    "references" : [ {
      "title" : "Revision based total semantics for extended normal logic programs",
      "author" : [ "M. ABRANTES" ],
      "venue" : "Ph.D. thesis, Universidade Nova de Lisboa.",
      "citeRegEx" : "ABRANTES,? 2013",
      "shortCiteRegEx" : "ABRANTES",
      "year" : 2013
    }, {
      "title" : "Towards a theory of declarative knowledge",
      "author" : [ "K. APT", "H.A. BLAIR", "A. WALKER" ],
      "venue" : "Foundations of deductive databases and logic programming, J. Minker, Ed. Morgan Kaufmann, Los Altos, CA, 89–142.",
      "citeRegEx" : "APT et al\\.,? 1988",
      "shortCiteRegEx" : "APT et al\\.",
      "year" : 1988
    }, {
      "title" : "Transformation-based bottom-up computation of the well-founded model",
      "author" : [ "S. BRASS", "J. DIX", "B. FREITAG", "U. ZUKOWSKI" ],
      "venue" : "TPLP, 497–538.",
      "citeRegEx" : "BRASS et al\\.,? 2001",
      "shortCiteRegEx" : "BRASS et al\\.",
      "year" : 2001
    }, {
      "title" : "Contributions to the stable model semantics of logic programs with negation",
      "author" : [ "S. COSTANTINI" ],
      "venue" : "Theoretical Computer Science 149, 2 (2 Oct.), 231–255.",
      "citeRegEx" : "COSTANTINI,? 1995",
      "shortCiteRegEx" : "COSTANTINI",
      "year" : 1995
    }, {
      "title" : "Abduction in logic programming",
      "author" : [ "M. DENECKER", "A.C. KAKAS" ],
      "venue" : "Computational Logic: Logic Programming and Beyond’02. 402–436.",
      "citeRegEx" : "DENECKER and KAKAS,? 2002",
      "shortCiteRegEx" : "DENECKER and KAKAS",
      "year" : 2002
    }, {
      "title" : "A classification theory of semantics of normal logic programs: I",
      "author" : [ "DIX J." ],
      "venue" : "strong properties. Fundam. Inform 22, 3, 227–255.",
      "citeRegEx" : "J.,? 1995a",
      "shortCiteRegEx" : "J.",
      "year" : 1995
    }, {
      "title" : "A classification theory of semantics of normal logic programs: II",
      "author" : [ "DIX J." ],
      "venue" : "weak properties. Fundam. Inform 22, 3, 257–288.",
      "citeRegEx" : "J.,? 1995b",
      "shortCiteRegEx" : "J.",
      "year" : 1995
    }, {
      "title" : "The alternating fixpoint of logic programs with negation",
      "author" : [ "A.V. GELDER" ],
      "venue" : "J. of Comp. System Sciences 47, 1, 185–221.",
      "citeRegEx" : "GELDER,? 1993",
      "shortCiteRegEx" : "GELDER",
      "year" : 1993
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "ICLP/SLP. MIT Press, 1070–1080.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1988",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1988
    }, {
      "title" : "Each normal logic program has a 2-valued minimal hypotheses semantics",
      "author" : [ "A.M. PINTO", "L.M. PEREIRA" ],
      "venue" : "INAP 2011, CoRR abs/1108.5766.",
      "citeRegEx" : "PINTO and PEREIRA,? 2011",
      "shortCiteRegEx" : "PINTO and PEREIRA",
      "year" : 2011
    }, {
      "title" : "Tabling for non-monotonic programming",
      "author" : [ "T. SWIFT" ],
      "venue" : "Ann. Math. Artif. Intell 25, 3-4, 201–240.",
      "citeRegEx" : "SWIFT,? 1999",
      "shortCiteRegEx" : "SWIFT",
      "year" : 1999
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "The SM semantics (Gelfond and Lifschitz 1988) is generally accepted by the scientific community working on logic programs semantics as the de facto standard 2-valued semantics.",
      "startOffset" : 17,
      "endOffset" : 45
    }, {
      "referenceID" : 9,
      "context" : "Nevertheless there are some advantageous properties the SM semantics lacks such as (1) model existence for every normal logic program, (2) relevance, and (3) cumulativity (Pinto and Pereira 2011).",
      "startOffset" : 171,
      "endOffset" : 195
    }, {
      "referenceID" : 9,
      "context" : "This is important to allow arbitrary updates and/or merges involving Knowledge Bases, possibly from different authors or sources (Pinto and Pereira 2011).",
      "startOffset" : 129,
      "endOffset" : 153
    }, {
      "referenceID" : 9,
      "context" : "Relevance allows for top-down query solving without the need to always compute complete models, but just the sub-models that sustain the answer to a query, though guaranteed extendable to whole ones (Pinto and Pereira 2011).",
      "startOffset" : 199,
      "endOffset" : 223
    }, {
      "referenceID" : 10,
      "context" : "As for cumulativity, it allows the programmer to take advantage of tabling techniques (Swift 1999) for speeding up computations (Pinto and Pereira 2011).",
      "startOffset" : 86,
      "endOffset" : 98
    }, {
      "referenceID" : 9,
      "context" : "As for cumulativity, it allows the programmer to take advantage of tabling techniques (Swift 1999) for speeding up computations (Pinto and Pereira 2011).",
      "startOffset" : 128,
      "endOffset" : 152
    }, {
      "referenceID" : 0,
      "context" : "The results presented in this paper are enounced for the universe of finite ground normal logic programs, and are either proved in (Abrantes 2013), or immediate consequences of results there contained.",
      "startOffset" : 131,
      "endOffset" : 146
    }, {
      "referenceID" : 9,
      "context" : "2 Adapted from (Pinto and Pereira 2011).",
      "startOffset" : 15,
      "endOffset" : 39
    }, {
      "referenceID" : 3,
      "context" : "3 Adapted from (Dix 1995b) 4 Adapted from (Costantini 1995)",
      "startOffset" : 42,
      "endOffset" : 59
    }, {
      "referenceID" : 2,
      "context" : "In (Brass et al. 2001) the authors propose a set of five operations to reduce a program (i.",
      "startOffset" : 3,
      "endOffset" : 22
    }, {
      "referenceID" : 2,
      "context" : "This transformation is terminating and confluent (Brass et al. 2001).",
      "startOffset" : 49,
      "endOffset" : 68
    }, {
      "referenceID" : 2,
      "context" : "It is shown in (Brass et al. 2001) that W FM(P) =WFM(P̂), where WFM stands for the well-founded model (Gelder 1993).",
      "startOffset" : 15,
      "endOffset" : 34
    }, {
      "referenceID" : 7,
      "context" : "2001) that W FM(P) =WFM(P̂), where WFM stands for the well-founded model (Gelder 1993).",
      "startOffset" : 73,
      "endOffset" : 86
    }, {
      "referenceID" : 9,
      "context" : "An example of such a semantics is the minimal hypotheses semantics, MH (Pinto and Pereira 2011), whose reduction system 7→MH is obtained from 7→W FS by replacing the negative reduction operation, NR, by the layered negative reduction operation, LNR, i.",
      "startOffset" : 71,
      "endOffset" : 95
    }, {
      "referenceID" : 4,
      "context" : "6 See (Denecker and Kakas 2002) for abductive semantics.",
      "startOffset" : 6,
      "endOffset" : 31
    }, {
      "referenceID" : 1,
      "context" : ", M P (Apt et al. 1988) which is not defective in spite of failing the existence property – it is the case that M Supp P is not a ASM semantics, since it does not conservatively extend the SM semantics.",
      "startOffset" : 6,
      "endOffset" : 23
    }, {
      "referenceID" : 0,
      "context" : "As a matter of fact, it can be shown (Abrantes 2013) that Blue is irregular whilst not excessive (i.",
      "startOffset" : 37,
      "endOffset" : 52
    } ],
    "year" : 2017,
    "abstractText" : "The stable model (SM) semantics lacks the properties of existence, relevance and cumulativity. If we prospectively consider the class of conservative extensions of the SM semantics (i.e., semantics that for each normal logic program P retrieve a superset of the set of stable models of P), one may wander how do the semantics of this class behave in what concerns the aforementioned properties. That is the type of issue dealt with in this paper. We define a large class of conservative extensions of the SM semantics, dubbed affix stable model semantics (ASM), and study the above referred properties into two non-disjoint subfamilies of the class ASM, here dubbed ASMh and ASMm. From this study a number of results stem which facilitate the assessment of semantics in the class ASMh ∪ASMm with respect to the properties of existence, relevance and cumulativity, whilst unveiling relations among these properties. As a result of the approach taken in our work, light is shed on the characterization of the SM semantics, as we show that the properties of (lack of) existence and (lack of) cautious monotony are equivalent, which opposes statements on this issue that may be found in the literature. We also characterize the relevance failure of SM semantics in a more clear way than usually stated in the literature.",
    "creator" : "LaTeX with hyperref package"
  }
}