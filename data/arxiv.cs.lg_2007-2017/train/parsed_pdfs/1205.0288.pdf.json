{
  "name" : "1205.0288.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Randomized Mirror Descent Algorithm for Large Scale Multiple Kernel Learning",
    "authors" : [ "Arash Afkanpour", "András György", "Csaba Szepesvári", "Michael Bowling" ],
    "emails" : [ "afkanpou@ualberta.ca", "gyorgy@ualberta.ca", "szepesva@ualberta.ca", "mbowling@ualberta.ca" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "We look into the computational challenge of finding a good predictor in a multiple kernel learning (MKL) setting where the number of kernels is very large. In particular, we are interested in cases where the base kernels come from a space with combinatorial structure and thus their number d could be exponentially large. Just like some previous works (e.g. Rakotomamonjy et al., 2008; Xu et al., 2008; Nath et al., 2009) we start with the approach that views the MKL problem as a nested, large scale convex optimization problem, where the first layer optimizes the weights of the kernels to be combined. More specifically, as the\nar X\niv :1\n20 5.\n02 88\nv2 [\ncs .L\nobjective we minimize the group p-norm penalized empirical risk. However, as opposed to these works whose underlying iterative methods have a complexity of Ω(d) for just any one iteration, following (Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011) we use a randomized coordinate descent method, which was effectively used in these works to decrease the per iteration complexity to O(1). The role of randomization in our method is to use it to build an unbiased estimate of the gradient at the most recent iteration. The issue then is how the variance (and so the number of iterations required) scales with d. As opposed to the above mentioned works, in this paper we propose to make the distribution over the updated coordinate dependent on the history. We will argue that sampling from a distribution that is proportional to the magnitude of the gradient vector is desirable to keep the variance (actually, second moment) low and in fact we will show that there are interesting cases of MKL (in particular, the case of combining kernels coming from a polynomial family of kernels) when efficient sampling (i.e., sampling at a cost of O(log d)) is feasible from this distribution. Then, the variance is controlled by the a priori weights put on the kernels, making it potentially independent of d. Under these favorable conditions (and in particular, for the polynomial kernel set with some specific prior weights), the complexity of the method as a function of d becomes logarithmic, which makes our MKL algorithm feasible even for large scale problems. This is to be contrasted to the approach of Nesterov (2010, 2012) where a fixed distribution is used and where the a priori bounds on the method’s convergence rate, and, hence, its computational cost to achieve a prescribed precision, will depend linearly on d (note that we are comparing upper bounds here, so the actual complexity could be smaller). Our algorithm is based on the mirror descent (or mirror descent) algorithm (similar to the work of Richtárik and Takáĉ (2011) who uses uniform distributions).\nIt is important to mention that there are algorithms designed to handle the case of infinitely many kernels, for example, the algorithms by Argyriou et al. (2005, 2006); Gehler and Nowozin (2008). However, these methods lack convergence rate guarantees, and, for example, the consistency for the method of Gehler and Nowozin (2008) works only for “small” d. The algorithm of Bach (2008), though practically very efficient, suffers from the same deficiency. A very interesting proposal by Cortes et al. (2009) considers learning to combine a large number of kernels and comes with guarantees, though their algorithm restricts the family of kernels in a specific way.\nThe rest of the paper is organized as follows. The problem is defined formally in Section 2. Our new algorithm is presented and analyzed in Section 3, while its specialized version for learning polynomial kernels is given in Section 4. Finally, experiments are provided in Section 5."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "In this section we give the formal definition of our problem. Let I denote a finite index set, indexing the predictors (features) to be combined, and define the set of predictors considered over the input space X as F = { fw : X → R : fw(x) = ∑ i∈I 〈wi, φi(x)〉 , x ∈ X } . HereWi is a Hilbert space over the reals, φi : X → Wi is a feature-map, 〈x, y〉 is the inner product over the Hilbert space that x, y belong to and w = (wi)i∈I ∈ W . = ×i∈IWi (as an example, Wi may just be a finite dimensional Euclidean space). The problem we consider is to solve\nthe optimization problem\nminimize Ln(fw) + Pen(fw) subject to w ∈ W , (1)\nwhere Pen(fw) is a penalty that will be specified later, and Ln(fw) = 1 n ∑n t=1 `t(fw(xt))is the empirical risk of predictor fw, defined in terms of the convex losses `t : R → R (1 ≤ t ≤ n) and inputs xt ∈ X (1 ≤ t ≤ n). The solution w∗ of the above penalized empirical risk minimization problem is known to have favorable generalization properties under various conditions, see, e.g., Hastie et al. (2009). In supervised learning problems `t(y) = `(yt, y) for some loss function ` : R × R → R, such as the squared-loss, `(yt, y) = 12(y − yt)\n2, or the hinge-loss, `t(yt, y) = max(1 − yyt, 0), where in the former case yt ∈ R, while in the latter case yt ∈ {−1,+1}. We note in passing that for the sake of simplicity, we shall sometimes abuse notation and write Ln(w) for Ln(fw) and even drop the index n when the sample-size is unimportant.\nAs mentioned above, in this paper we consider the special case in (1) when the penalty is a so-called group p-norm penalty with 1 ≤ p ≤ 2, a case considered earlier, e.g., by Kloft et al. (2011). Thus our goal is to solve\nminimize w∈W\nLn(w) + 1\n2 (∑ i∈I ρpi ‖wi‖ p 2 ) 2 p , (2)\nwhere the scaling factors ρi > 0, i ∈ I, are assumed to be given. We introduce the notation u = (ui) ∈ RI to denote the column vector obtained from the values ui.\nThe rationale of using the squared weighted p-norm is that for 1 ≤ p < 2 it is expected to encourage sparsity at the group level which should allow one to handle cases when I is very large (and the case p = 2 comes for free from the same analysis). The actual form, however, is also chosen for reasons of computational convenience. In fact, the reason to use the 2-norm of the weights is to allow the algorithm to work even with infinite-dimensional feature vectors (and thus weights) by resorting to the kernel trick. To see how this works, just notice that the penalty in (2) can also be written as(∑\ni∈I ρpi ‖wi‖ p 2\n) 2 p\n= inf {∑ i∈I ρ2i ‖wi‖22 θi : θ ∈ ∆ p 2−p } ,\nwhere for ν ≥ 1, ∆ν = {θ ∈ [0, 1]|I| : ‖θ‖ν ≤ 1} is the positive quadrant of the |I|-dimensional `ν-ball (see, e.g., Micchelli and Pontil, 2005, Lemma 26). Hence, defining\nJ(w, θ) = L(w) + 1\n2 ∑ i∈I ρ2i ‖wi‖22 θi\nfor any w ∈ W, θ ∈ [0, 1]|I|, an equivalent form of (2) is\nminimize w∈W,θ∈∆ν J(w, θ) (3)\nwhere ν = p/(2 − p) ∈ [1,∞) and we define 0/0 = 0 and u/0 = ∞ for u > 0, which implies that wi = 0 if θi = 0. That this minimization problem is indeed equivalent to our original task (2) for the chosen value of ν follows from the fact that J(w, θ) is jointly convex in (w, θ).1\n1Here and in what follows by equivalence we mean that the set of optimums in terms of w (the primary optimization variable) is the same in the two problems.\nLet κi : X × X → R be the reproducing kernel underlying φi: κi(x, x′) = 〈φi(x), φi(x′)〉 (x, x′ ∈ X ) and let Hi = Hκi the corresponding reproducing kernel Hilbert space (RKHS). Then, for any given fixed value of θ, the above problem becomes an instance of a standard penalized learning problem in the RKHS Hθ underlying the kernel κθ = ∑ i∈I θiρ −2 i κi. In particular, by the theorem on page 353 in Aronszajn (1950), the problem of finding w ∈ W for fixed θ can be seen to be equivalent to minimizef∈Hθ L(f) + 1 2‖f‖ 2 Hθ , and thus (2) is seen to be equivalent to minimizef∈Hθ,θ∈∆ν L(f) + 1 2‖f‖ 2 Hθ . Thus, we see that the method can be thought of as finding the weights of a kernel κθ and a predictor minimizing the Hθnorm penalized empirical risk. This shows that our problem is an instance of multiple kernel learning (for an exhaustive survey of MKL, see, e.g., Gönen and Alpaydın, 2011 and the references therein)."
    }, {
      "heading" : "3 The new approach",
      "text" : "When I is small, or moderate in size, the joint-convexity of J allows one to use off-the-shelf solvers to find the joint minimum of J . However, when I is large, off-the-shelf solvers might be slow or they may run out of memory. Targeting this situation we propose the following approach: Exploiting again that J(w, θ) is jointly convex in (w, θ), find the optimal weights by finding the minimizer of\nJ(θ) . = inf\nw J(w, θ),\nor, alternatively, J(θ) = J(w∗(θ), θ), where w∗(θ) . = arg minw J(w, θ) (here we have slightly abused notation by reusing the symbol J). Note that J(θ) is convex by the joint convexity of J(w, θ). Also, note that w∗(θ) exists and is well-defined as the minimizer of J(·, θ) is unique for any θ ∈ ∆ν (see also Proposition 3.2 below). Again, exploiting the joint convexity of J(w, θ), we find that if θ∗ is the minimizer of J(θ), then w∗(θ∗) will be an optimal solution to the original problem (2). To optimize J(θ) we propose to use stochastic gradient descent with artificially injected randomness to avoid the need to fully evaluate the gradient of J . More precisely, our proposed algorithm is an instance of a randomized version of the mirror descent algorithm (Rockafellar, 1976; Martinet, 1978; Nemirovski and Yudin, 1998), where in each time step only one coordinate of the gradient is sampled."
    }, {
      "heading" : "3.1 A randomized mirror descent algorithm",
      "text" : "Before giving the algorithm, we need a few definitions. Let d = |I|, A ⊂ Rd be nonempty with a convex interior A◦. We call the function Ψ : A→ R a Legendre (or barrier) potential if it is strictly convex, its partial derivatives exist and are continuous, and for every sequence {xk} ⊂ A approaching the boundary of A, limk→∞ ‖∇Ψ(xk)‖ = ∞. Here ∇ is the gradient operator: ∇Ψ(x) = ( ∂∂xΨ(x))\n> is the gradient of Ψ. When ∇ is applied to a non-smooth convex function J ′(θ) (J may be such without additional assumptions) then ∇J ′(θ) is defined as any subgradient of J ′ at θ. The corresponding Bregman-divergence DΨ : A × A◦ → R is defined as DΨ(θ, θ\n′) = Ψ(θ) − Ψ(θ′) − 〈∇Ψ(θ′), θ − θ′〉. The Bregman projection ΠΨ,K : A◦ → K corresponding to the Legendre potential Ψ and a closed convex set K ⊂ Rd such that K ∩A 6= ∅ is defined, for all θ ∈ A◦ as ΠΨ,K(θ) = arg minθ′∈K∩ADψ(θ′, θ).\nAlgorithm 1 shows a randomized version of the standard mirror descent method with an unbiased gradient estimate. By assumption, ηk > 0 is deterministic. Note that step 1 of the\nAlgorithm 1 Randomized mirror descent algorithm\n1: Input: A,K ⊂ Rd, where K is closed and convex with K ∩A 6= ∅, Ψ : A→ R Legendre, step sizes {ηk}, a subroutine, GradSampler, to sample the gradient of J at an arbitrary vector θ ≥ 0 2: Initialization: θ(0) = arg minθ∈K∩A Ψ(θ), k = 0. 3: repeat 4: k = k + 1. 5: Obtain ĝk = GradSampler(θ\n(k−1)) 6: θ̃(k) = arg minθ∈A { ηk−1〈ĝk, θ〉+DΨ(θ, θ(k−1)) } . 7: θ(k) = ΠΨ,K(θ̃ (k)). 8: until convergence.\nalgorithm is well-defined since θ̃(k) ∈ A◦ by the assumption that ‖∇Ψ(x)‖ tends to infinity as x approaches the boundary of A. The performance of Algorithm 1 is bounded in the next theorem. The analysis follows the standard proof technique of analyzing the mirror descent algorithm (see, e.g., Beck and Teboulle, 2003), however, in a slightly more general form than what we have found in the literature. In particular, compared to (Nemirovski et al., 2009a; Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011), our analysis allows for the conditional distribution of the noise in the gradient estimate to be history dependent. The proof is included in Section A in the appendix.\nTheorem 3.1. Assume that Ψ is α-strongly convex with respect to some norm ‖ · ‖ (with dual norm ‖ · ‖∗) for some α > 0, that is, for any θ ∈ A◦, θ′ ∈ A\nΨ(θ′)−Ψ(θ) ≥ 〈 ∇Ψ(θ), θ′ − θ 〉 + α2 ‖θ ′ − θ‖2. (4)\nSuppose, furthermore, that Algorithm 1 is run for T time steps. For 0 ≤ k ≤ T − 1 let Fk denote the σ-algebra generated by θ1, . . . , θk. Assume that, for all 1 ≤ k ≤ T , ĝk ∈ Rd is an unbiased estimate of ∇J(θ(k−1)) given Fk−1, that is,\nE [ ĝk| Fk−1] = ∇J(θ(k−1)). (5)\nFurther, assume that there exists a deterministic constant B ≥ 0 such that for all 1 ≤ k ≤ T ,\nE [ ‖ĝk‖2∗ ∣∣Fk−1] ≤ B a.s. (6) Finally, assume that δ = supθ′∈K∩A Ψ(θ ′) − Ψ(θ(0)) is finite. Then, if ηk−1 = √ 2αδ BT for all k ≥ 1, it holds that\nE [ J ( 1\nT T∑ k=1 θ(k−1) )] − inf θ∈K∩A J(θ) ≤ √ 2Bδ αT . (7)\nFurthermore, if ‖ĝk‖2∗ ≤ B′ a.s. (8)\nfor some deterministic constant B′ and ηk−1 = √ 2αδ B′T for all k ≥ 1 then, for any 0 < < 1, it holds with probability at least 1− that\nJ\n( 1\nT T∑ k=1 θ(k−1) ) − inf θ∈K∩A J(θ) ≤ √ 2B′δ αT + 4 √ B′δ log 1 αT . (9)\nThe convergence rate in the above theorem can be improved if stronger assumptions are made on J , for example if J is assumed to be strongly convex, see, for example, (Hazan et al., 2007; Hazan and Kale, 2011).\nEfficient implementation of Algorithm 1 depends on efficient implementations of steps 1-1, namely, computing an estimate of the gradient, solving the minimization for θ̃(k), and projecting it into K. The first problem is related to the choice of gradient estimate we use, which, in turn, depends on the structure of the feature space, while the last two problems depend on the choice of the Legendre function. In the next subsections we examine how these choices can be made to get a practical variant of the algorithm."
    }, {
      "heading" : "3.2 Application to multiple kernel learning",
      "text" : "It remains to define the gradient estimates ĝk in Algorithm 1. We start by considering importance sampling based estimates. First, however, let us first verify whether the gradient exist. Along the way, we will also derive some explicit expressions which will help us later.\nClosed-form expressions for the gradient. Let us first consider how w∗(θ) can be calculated for a fixed value of θ. As it will turn out, this calculation will be useful not only when the procedure is stopped (to construct the predictor fw∗(θ) but also during the iterations when we will need to calculate the derivative of J with respect to θi. The following proposition summarizes how w∗(θ) can be obtained. Note that this type of result is standard (see, e.g., Shawe-Taylor and Cristianini, 2004; Schölkopf and Smola, 2002), thus we include it only for the sake of completeness (the proof is included in Section A in the appendix).\nProposition 3.2. For 1 ≤ t ≤ n, let `∗t : R→ R denote the convex conjugate of `t: `∗t (v) = supτ∈R {vτ − `t(τ)}, v ∈ R. For i ∈ I, recall that κi(x, x′) = 〈φi(x), φi(x′)〉, and let Ki = (κi(xt, xs))1≤t,s≤n be the n × n kernel matrix underlying κi and let Kθ = ∑ i∈I\nθi ρ2i Ki be the kernel matrix underlying κθ = ∑\ni∈I θi ρ2i κi. Then, for any fixed θ, the minimizer w ∗(θ) of\nJ(·, θ) satisfies\nw∗i (θ) = θi ρ2i n∑ t=1 α∗t (θ)φi(xt), i ∈ I , (10)\nwhere\nα∗(θ) = arg min α∈Rn\n{ 1\n2 α>Kθα+\n1\nn n∑ t=1 `∗t (−nαt)\n} . (11)\nBased on this proposition, we can compute the predictor fw∗(θ) using the kernels {κi}i∈I and the dual variables (α∗t (θ))1≤t≤n: fw∗(θ)(x) = ∑ i∈I 〈w∗i (θ), φi(x)〉 = ∑n t=1 α ∗ t (θ)κθ(xt, x) .\nLet us now consider the differentiability of J = J(θ) and how to compute its derivatives. Under proper conditions with standard calculations (e.g., Rakotomamonjy et al., 2008) we find that J is differentiable over ∆ and its derivative can be written as2\n∂\n∂θ J(θ) = −\n( α∗(θ)>Kiα∗(θ)\nρ2i\n) i∈I . (12)\nImportance sampling based estimates. Let d = |I| and let ei, i ∈ I denote the ith unit vector of the standard basis of Rd, that is, the ith coordinate of ei is 1 while the others are 0. Introduce\ngk,i = 〈 ∇J(θ(k−1)), ei 〉 , i ∈ I (13)\nto denote the ith component of the gradient of J in iteration k (that is, gk,i can be computed based on (12)). Let sk−1 ∈ [0, 1]I be a distribution over I, computed in some way based on the information available up to the end of iteration k − 1 of the algorithm (formally, sk−1 is Fk−1-measurable). Define the importance sampling based gradient estimate to be\nĝk,i = I{Ik=i} sk−1,Ik gk,Ik , i ∈ I, where Ik ∼ sk−1,· . (14)\nThat is, the gradient estimate is obtained by first sampling an index from sk−1,· and then setting the gradient estimate to be zero at all indices i ∈ I except when i = Ik in which case its value is set to be the ratio\ngk,Ik sk−1,Ik . It is easy to see that as long as sk−1,i > 0 holds\nwhenever gk,i 6= 0, then it holds that E [ ĝk| Fk−1] = ∇J(θ(k−1)) a.s. Let us now derive the conditions under which the second moment of the gradient estimate\nstays bounded. Define Ck−1 = ∥∥∇J(θ(k−1))∥∥\n1 . Given the expression for the gradient of J\nshown in (12), we see that supk≥1Ck−1 <∞ will always hold provided that α∗(θ) is continuous since (θ(k−1))k≥1 is guaranteed to belong to a compact set (the continuity of α\n∗ is discussed in Section B in the appendix).\nDefine the probability distribution qk−1,· as follows: qk−1,i = 1 Ck−1 |gk,i| , i ∈ I. Then\nit holds that ‖ĝk‖2∗ = 1s2k−1,Ik g2k,Ik ‖eIk‖ 2 ∗ = q2k−1,Ik s2k−1,Ik C2k−1 ‖eIk‖ 2 ∗. Therefore, it also holds\nthat E [ ‖ĝk‖2∗ ∣∣Fk−1] = C2k−1∑i∈I q2k−1,isk−1,i ‖ei‖2∗ ≤ C2k−1 maxi∈I qk−1,isk−1,i ‖ei‖2∗. This shows that supk≥1 E [ ‖ĝk‖2∗\n∣∣Fk−1] <∞ will hold as long as supk≥1 maxi∈I qk−1,isk−1,i <∞ and supk≥1Ck−1 < ∞. Note that when sk−1 = qk−1, the gradient estimate becomes ĝk,i = Ck−1I{It=i}. That is, in this case we see that in order to be able to calculate ĝk,i, we need to be able to calculate Ck−1 efficiently.\nChoosing the potential Ψ. The efficient sampling of the gradient is not the only practical issue, since the choice of the Legendre function and the convex set K may also cause some complications. For example, if Ψ(x) = ∑ i∈I xi(lnxi − 1), then the resulting algorithm is exponential weighting, and one needs to store and update |I| weights, which is clearly infeasible if |I| is very large (or infinite). On the other hand, if Ψ(x) = 12‖x‖ 2 2 and we project\n2For completeness, the calculations are given in Section B in the appendix.\nAlgorithm 2 Projected stochastic gradient algorithm.\n1: Initialization: Ψ(x) = 12‖x‖ 2 2, θ (0) i = 0 for all i ∈ I, k = 0, step sizes {ηk}. 2: repeat 3: k = k + 1. 4: Sample a gradient estimate ĝk of g(θ\n(k−1) randomly according to (14). 5: θ(k) = ΠΨ,∆2(θ\n(k−1) − ηk−1ĝk). 6: until convergence.\nto K = ∆2, the positive quadrant of the ` 2-ball (with A = [0,∞)I), we obtain a stochastic projected gradient method, shown in Algorithm 2. This is in fact the algorithm that we use in the experiments. Note that in (2) this corresponds to using p = 4/3. The reason we made this choice is because in this case projection is a simple scaling operation. Had we chosen K = ∆1, the `\n2-projection would very often cancel many of the nonzero components, resulting in an overall slow progress. Based on the above calculations and Theorem 3.1 we obtain the following performance bound for our algorithm.\nCorollary 3.3. Assume that α∗(θ) is continuous on ∆2. Then there exists a C > 0 such that ‖ ∂∂θJ(θ)‖1 ≤ C for all θ ∈ ∆2. Let B = 1 2C 2 maxi∈I,1≤k≤T qk−1,i sk−1,i . If Algorithm 2 is run\nfor T steps with ηk−1 = η = 1/ √ BT, k = 1, . . . , T , then, for all θ ∈ ∆2,\nE [ J ( 1\nT T∑ k=1 θ(k−1)\n)] − J(θ) ≤ √ B\nT .\nNote that to implement Algorithm 2 efficiently, one has to be able to sample from sk−1,· and compute the importance sampling ratio gk,i/sk,i efficiently for any k and i."
    }, {
      "heading" : "4 Example: Learning polynomial kernels",
      "text" : "In this section we show how our method can be applied in the context of multiple kernel learning. We provide an example when the kernels in I are tensor products of a set of base kernels (this we shall call learning polynomial kernels). The importance of this example follows from the observation of Gönen and Alpaydın (2011) that the non-linear kernel learning methods of Cortes et al. (2009), which can be viewed as a restricted form of learning polynomial kernels, are far the best MKL methods in practice and can significantly outperform state-of-the-art SVM with a single kernel or with the uniform combination of kernels.\nAssume that we are given a set of base kernels {κ1, . . . , κr}. In this section we consider the setKD of product kernels of degree at mostD: Choose I = {(r1, . . . , rd) : 0 ≤ d ≤ D, 1 ≤ ri ≤ r} and the multi-index r1:d = (r1, . . . , rd) ∈ I defines the kernel κr1:d(x, x′) = ∏d i=1 κri(x, x\n′). For d = 0 we define κr1:0(x, x\n′) = 1. Note that indices that are the permutations of each other define the same kernel. On the language of statistical modeling, κr1:d models interactions of order d between the features underlying the base kernels κ1, . . . , κr. Also note that |I| = Θ(rD), that is, the cardinality of I grows exponentially fast in D.\nWe assume that ρr1:d depends only on d, the order of interactions in κr1:d . By abusing\nAlgorithm 3 Polynomial kernel sampling. The symbol denotes the Hadamard product/power.\n1: Input: α ∈ Rn, the solution to the dual problem; kernel matrices {K1, . . . ,Kr}; the degree D of the polynomial kernel, the weights (ρ20, . . . , ρ 2 D).\n2: S ← ∑r\nj=1Kj , M ← αα> 3: δ(d′)← ρ−2d′ 〈 M,S d ′ 〉 , d′ ∈ {0, . . . , D}\n4: Sample d from δ(·)/ ∑D\nd′=0 δ(d ′)\n5: for i = 1 to d do 6: π(j)← tr(M S\n(d−i) Kj) tr(M S (d−i+1))\n, j ∈ {1, . . . , r} 7: Sample zi from π(·) 8: M ←M Kzi 9: end for\n10: return (z1, . . . , zd)\nnotation, we will write ρd in the rest of this section to emphasize this. 3 Our proposed algorithm to sample from qk−1,· is shown in Algorithm 3. The algorithm is written to return a multi-index (z1, . . . , zd) that is drawn from qk−1,·. The key idea underlying the algorithm is to exploit that ( ∑r j=1 κj) d = ∑\nr1:d∈I κr1:d . The correctness of the algorithm is shown in Section 4.1. In the description of the algorithm denotes the matrix entrywise product (a.k.a. Schur, or Hadamard product) and A s denotes A . . . A︸ ︷︷ ︸\ns\n, and we set the priority\nof to be higher than that of the ordinary matrix product (by definition, all the entries of A 0 are 1).\nLet us now discuss the complexity of Algorithm 3. For this, first note that computing all the Hadamard products S d ′ , d′ = 0, . . . , D requires O(Dn2) computations. Multiplication with Mk−1 can be done in O(n 2) steps. Finally, note that each iteration of the for loop takes O(rn2) steps, which results in the overall worst-case complexity of O(rn2D) if α∗(θk−1) is readily available. The computational complexity of determining α∗(θk−1) depends on the exact form of `t, and can be done efficiently in many situations: if, for example, `t is the squared loss, then α∗ can be computed in O(n3) time. An obvious improvement to the approach described here, however, would be to subsample the empirical loss Ln, which can bring further computational improvements. However, the exploration of this is left for future work.\nFinally, note that despite the exponential cardinality of |I|, due to the strong algebraic structure of the space of kernels, Ck−1 can be calculated efficiently. In fact, it is not hard to see that with the notation of the algorithm, Ck−1 = ∑D d′=0 δ(d\n′). This also shows that if ρd decays “fast enough”, Ck−1 can be bounded independently of the cardinality of I."
    }, {
      "heading" : "4.1 Correctness of the sampling procedure",
      "text" : "In this section we prove the correctness of Algorithm 3. As said earlier, we assume that ρr1:d depends only on d, the order of interactions in κr1:d\n3Using importance sampling, more general weights can also be accommodated, too without effecting the results as long as the range of weights (ρr1:d) is kept under control for all d.\nand, by abusing notation, we will write ρd to emphasize this. Let us now consider how one can sample from qk−1,·. The implementation relies on the fact that ( ∑r j=1 κj) d = ∑\nr1:d∈I κr1:d . Remember that we denoted the kernel matrix underlying some kernel k by Kk, and recall that Kk is an n× n matrix. For brevity, in the rest of this section for κ = κr1:d we will write Kr1:d instead of Kκr1:d . Define Mk−1 = α ∗(θk−1)α ∗(θk−1)\n>. Thanks to (12) and the rotation property of trace, we have\ngk,r1:d = −ρ −2 d tr(Mk−1Kr1:d) . (15) The plan to sample from qk−1,· = |gk,·|/ ∑\nr1:d∈I |gk,r1:d | is as follows: We first draw the order of interactions, 0 ≤ d̂ ≤ D. Given d̂ = d, we restrict the draw of the random multi-index R1:d to the set {r1:d ∈ I}. A multi-index will be sampled in a d̂-step process: in each step we will randomly choose an index from the indices of base kernels according to the following distributions. Let S = K1 + . . .+Kr, let\nP ( d̂ = d|Fk−1 ) = ρ−2d tr(Mk−1S d)∑D\nd′=0 ρ −2 d′ tr(Mk−1S d′)\nand, with a slight abuse of notation, for any 1 ≤ i ≤ d define P ( Ri = ri|Fk−1, d̂ = d,R1:i−1 = r1:i−1 ) = tr ( Mk−1 ( ij=1Krj ) S (d−i) ) ∑r\nr′i=1 tr ( Mk−1\n( i−1j=1Krj ) Kr′i S (d−i) )\nwhere we used the sequence notation (namely, s1:p denotes the sequence (s1, . . . , sp)). We have, by the linearity of trace and the definition of S that\nr∑ r′i=1 tr ( Mk−1\n( i−1j=1Krj ) Kr′i S (d−i) )\n= tr ( Mk−1\n( i−1j=1Krj ) S (d−i+1) ) Thus, by telescoping,\nP ( d̂ = d,R1:d = r1:d|Fk−1 ) =\nρ−2d tr(Mk−1Kr1 . . . Krd−1 Krd)∑D d′=0 ρ −2 d′ tr(Mk−1S d′) .\nas desired. An optimized implementation of drawing these random variables is shown as Algorithm 3. The algorithm is written to return the multi-index R1:d."
    }, {
      "heading" : "5 Experiments",
      "text" : "In this section we apply our method to the problem of multiple kernel learning in regression with the squared loss: L(w) = 12 ∑n t=1(fw(xt) − yt)2, where (xt, yt) ∈ Rr × R are the inputoutput pairs in the data. In these experiments our aim is to learn polynomial kernels (cf. Section 4).\nWe compare our method against several kernel learning algorithms from the literature on synthetic and real data. In all experiments we report mean squared error over test sets. A constant feature is added to act as offset, and the inputs and output are normalized to have zero mean and unit variance. Each experiment is performed with 10 runs in which we randomly choose training, validation, and test sets. The results are averaged over these runs."
    }, {
      "heading" : "5.1 Convergence speed",
      "text" : "In this experiment we examine the speed of convergence of our method and compare it against one of the fastest standard multiple kernel learning algorithms, that is, the p-norm multiple kernel learning algorithm of Kloft et al. (2011) with p = 2,4 and the uniform coordinate descent algorithm that updates one coordinate per iteration uniformly at random (Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011). We aim to learn polynomial kernels of up to degree 3 with all algorithms. Our method uses Algorithm 3 for sampling with D = 3. The set of provided base kernels is the linear kernels built from input variables, that is, κ(i)(x, x ′) = x(i)x ′ (i), where x(i) denotes the i\nth input variable. For the other two algorithms the kernel set consists of product kernels from monomial terms for D ∈ {0, 1, 2, 3} built from r base kernels, where r is the number of input variables. The number of distinct product kernels is ( r+D D ) . In this experiment for all algorithms we use ridge regression with its regularization parameter set to 10−5. Experiments with other values of the regularization parameter achieved similar results.\nWe compare these methods in four datasets from the UCI machine learning repository (Frank and Asuncion, 2010) and the Delve datasets5. The specifications of these datasets are shown in Table 1. We run all algorithms for a fixed amount of time and measure the value\nof the objective function (1), that is, the sum of the empirical loss and the regularization term. Figure 1 shows the performance of these algorithms. In this figure Stoch represents our algorithms, Kloft represents the algorithm of Kloft et al. (2011), and UCD represents the uniform coordinate descent algorithm. The results show that our method consistently outperforms the other algorithms in convergence speed. Note that our stochastic method updates one kernel coefficient per iteration, while Kloft updates ( r+D D ) kernel coefficients per iteration. The difference between the two methods is analogous to the difference between stochastic gradient vs. full gradient algorithms. While UCD also updates one kernel\n4Note that p = 2 in Kloft et al. (2011) notation corresponds to p = 4/3 or ν = 2 in our notation, which gives the same objective function that we minimize with Algorithm 2.\n5See, www.cs.toronto.edu/~delve/data/datasets.html\ncoefficient per iteration its naive method of selecting coordinates results in a slower overall convergence compared to our algorithm. In the next section we compare our algorithm against several representative methods from the MKL literature."
    }, {
      "heading" : "5.2 Synthetic data",
      "text" : "In this experiment we examine the effect of the size of the kernel space on prediction accuracy and training time of MKL algorithms. We generated data for a regression problem. Let r denote the number of dimensions of the input space. The inputs are chosen uniformly at random from [−1, 1]r. The output of each instance is the uniform combination of 10 monomial terms of degree 3 or less. These terms are chosen uniformly at random among all possible terms. The outputs are noise free. We generated data for r ∈ {5, 10, 20, . . . , 100}, with 500 training and 1000 test points. The regularization parameter of the ridge regression algorithm was tuned from {10−8, . . . , 102} using a separate validation set with 1000 data points.\nWe compare our method (Stoch) against the algorithm of Kloft et al. (2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi)\nD, where D is a predetermined integer that specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent to adding polynomial kernels of degree less than D to the combination too. We provide all possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011). For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3.\nThe results are shown in Figure 2, the mean squared errors are on the left plot, while the training times are on the right plot. In the training-time plot the numbers inside brackets\n6While several fast MKL algorithms are available in the literature, such as those of Sonnenburg et al. (2006); Rakotomamonjy et al. (2008); Xu et al. (2010); Orabona and Luo (2011); Kloft et al. (2011), a comparison of the reported experimental results shows that from among these algorithms the method of Kloft et al. (2011) has the best performance overall. Hence, we decided to compare against only this algorithm. Also note that the memory and computational cost of all these methods still scale linearly with the number of kernels, making them unsuitable for the case we are most interested in. Furthermore, to keep the focus of the paper we compare our algorithm to methods with sound theoretical guarantees. As such, it remains for future work to compare with other methods, such as the infinite kernel learning of Gehler and Nowozin (2008), which lack such guarantees but exhibit promising performance in practice.\nindicate the total number of distinct product kernels for each value of r. This is the number of kernels fed to the Kloft algorithm. Since this method deals with a large number of kernels, it was possible to precompute and keep the kernels in memory (8GB) for r ≤ 25. Therefore, we ran this algorithm for r ≤ 25. For r > 25, we could use on-the-fly implementation of this algorithm, however that further increases the training time. Note that the computational cost of this method depends linearly on the number of kernels, which in this experiment, is cubic in the number of input variables since D = 3. While the standard MKL algorithms, such as Kloft, cannot handle such large kernel spaces, in terms of time and space complexity, the other three algorithms can efficiently learn kernel combinations. However their predictive accuracies are quite different. Note that the performance of the method of Cortes et al. (2009) starts to degrade as r increases. This is due to the restricted family of kernels that this method considers. The method of Bach (2008), which is well-suited to learn sparse combination of product kernels, performs better than Cortes et al. (2009) for higher input dimensions. Among all methods, our method performs best in predictive accuracy while its computational cost is close to that of the other two competitors."
    }, {
      "heading" : "5.3 Real data",
      "text" : "In this experiment we aim to compare several MKL methods in real datasets. We compare our new algorithm (Stoch), the algorithm of Bach (2008) (Bach), and the algorithm of Cortes et al. (2009) (Cortes). For each algorithm we consider learning polynomial kernels of degree 2 and 3. We also include uniform combination of product kernels of degree D, i.e. κD = ( ∑r i=1 κi)\nD, for D ∈ {1, 2, 3} (Uniform). To find out if considering higherorder interaction of input variables results in improved performance we also included a MKL algorithm to which we only feed linear kernels (D = 1). We use the MKL algorithm of Kloft et al. (2011) with p ∈ {1, 2} (Kloft).\nWe compare these methods on six datasets from the UCI machine learning repository\nand Delve datasets. In these datasets the number of dimensions of the input space is 20 and above. The specifications of these datasets are shown in Table 1. The regularization parameter is selected from the set {10−4, . . . , 103} for all methods using a validation set. The results are shown in Figure 3.\nOverall, we observe that methods that consider non-linear variable interactions (Stoch, Bach, and Cortes) perform better than linear methods (Kloft). Among non-linear methods, Cortes performs worse than the other two. We believe that this is due to the restricted kernel space considered by this method. The performance of Stoch and Bach methods is similar overall.\nWe observe that our method overfits when it considers kernels of degree 3. However, one can easily prevent overfitting by assigning larger ρ values to higher-degree kernels such that the stochastic algorithm selects lower-degree kernels more often. For this purpose, we repeat this experiment for D = 3 with a modified set of ρ values, where we use ρ2d = 1 for kernels of degree 2 or less and ρ2d = 4 for kernels of degree 3. With the new ρ coefficients we observe an improvement in algorithm’s performance. See Stoch (D = 3, prior) error values in Figure 3."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We introduced a new method for learning a predictor by combining exponentially many linear predictors using a randomized mirror descent algorithm. We derived finite-time performance bounds that show that the method efficiently optimizes our proposed criterion. Our proposed method is a variant of a randomized stochastic coordinate descent algorithm, where the main trick is the careful construction of an unbiased randomized estimate of the gradient vector that keeps the variance of the method under control, and can be computed efficiently when the base kernels have a certain special combinatorial structure. The efficiency of our method\nwas demonstrated for the practically important problem of learning polynomial kernels on a variety of synthetic and real datasets comparing to a representative set of algorithms from the literature. For this case, our method is able to compute an optimal solution in polynomial time as a function of the logarithm of the number of base kernels. To our knowledge, ours is the first method for learning kernel combinations that achieve such an exponential reduction in complexity while satisfying strong performance guarantees, thus opening up the way to apply it to extremely large number of kernels. Furthermore, we believe that our method is applicable beyond the case studied in detail in our paper. For example, the method seems extendible to the case when infinitely many kernels are combined, such as the case of learning a combination of Gaussian kernels. However, the investigation of this important problem remains subject to future work."
    }, {
      "heading" : "Acknowledgements",
      "text" : "This work was supported by Alberta Innovates Technology Futures and NSERC."
    }, {
      "heading" : "A Proofs",
      "text" : "In this section we present the proofs of Theorem 3.1 and Proposition 3.2. The proof of Theorem 3.1 is based on the standard proof of the convergence rate of the proximal point algorithm, see, for example, (Beck and Teboulle, 2003), or the proof of Proposition 2.2 of Nemirovski et al. (2009b), which carry over the same argument to solve very similar but less general problems. We also provide some improvements and simplifications at the end. Before giving the actual proof, we need the following standard lemma:\nLemma A.1 (Lemma 2.1 of Nemirovski et al. 2009b). Assume that Ψ is α-strongly convex with respect to some norm ‖ · ‖ (i.e., (4) holds). Let θ1 ∈ K ∩ A◦, θ ∈ K ∩ A, and g ∈ Rd. Define θ2 = arg minθ′∈K∩A {〈g, θ′〉+DΨ(θ′, θ1)}. Then\n〈g, θ1 − θ〉 ≤ DΨ(θ, θ1)−DΨ(θ, θ2) + ‖g‖2∗ 2α .\nWe provide an alternate proof that is based on the so-called 3-DIV lemma. The 3-DIV lemma (e.g., Lemma 11.1, Cesa-Bianchi and Lugosi, 2006) allows one to express the sum of the divergences between the vectors u, v and v, w in terms of the divergence between u and w and an additional “error term”, where u ∈ A, v, w ∈ A◦:\nDΨ(u, v) +DΨ(v, w) = DΨ(u,w) + 〈∇ψ(w)−∇ψ(v), u− v〉 .\nProof. Note that θ2 ∈ A◦ due to behavior of Ψ at the boundary of A. Thus, Ψ is differentiable at θ2 and\n∇1DΨ(θ2, θ1) = ∇ψ(θ2)−∇ψ(θ1) , (16)\nwhere∇1 denotes differentiation of DΨ w.r.t. its first variable. Let f(θ′) = 〈g, θ′〉+DΨ(θ′, θ1). By the optimality property of θ2 and since θ ∈ K ∩A, we have\n〈∇f(θ2), θ2 − θ〉 ≤ 0 .\nPlugging in the definition of f together with the identity (16) gives\n〈g +∇ψ(θ2)−∇ψ(θ1), θ2 − θ〉 ≤ 0 . (17)\nNow, by the 3-DIV Lemma,\nDΨ(θ, θ2) +DΨ(θ2, θ1) = DΨ(θ, θ1) + 〈∇Ψ(θ1)−∇Ψ(θ2), θ − θ2〉 = DΨ(θ, θ1) + 〈g +∇Ψ(θ2)−∇Ψ(θ1), θ2 − θ〉+ 〈g, θ − θ2〉 .\nHence, by reordering and using the inequality (17) we get\nDΨ(θ, θ2)−DΨ(θ, θ1) ≤ 〈g, θ − θ2〉 −DΨ(θ2, θ1) = 〈g, θ1 − θ2〉 −DΨ(θ2, θ1) + 〈g, θ − θ1〉\n≤ ‖g‖ 2 ∗\n2α + 〈g, θ − θ1〉 ,\nwhere in the last line we used Young’s inequality7 and that due to the strong convexity of Ψ, DΨ(θ2, θ1) ≥ α2 ‖θ2 − θ1‖ 2.\nTheorem 3.1. Assume that Ψ is α-strongly convex with respect to some norm ‖ · ‖ (with dual norm ‖ · ‖∗) for some α > 0, that is, for any θ ∈ A◦, θ′ ∈ A\nΨ(θ′)−Ψ(θ) ≥ 〈 ∇Ψ(θ), θ′ − θ 〉 + α2 ‖θ ′ − θ‖2. (4)\nSuppose, furthermore, that Algorithm 1 is run for T time steps. For 0 ≤ k ≤ T − 1 let Fk denote the σ-algebra generated by θ1, . . . , θk. Assume that, for all 1 ≤ k ≤ T , ĝk ∈ Rd is an unbiased estimate of ∇J(θ(k−1)) given Fk−1, that is,\nE [ ĝk| Fk−1] = ∇J(θ(k−1)). (5)\nFurther, assume that there exists a deterministic constant B ≥ 0 such that for all 1 ≤ k ≤ T , E [ ‖ĝk‖2∗ ∣∣Fk−1] ≤ B a.s. (6) Finally, assume that δ = supθ′∈K∩A Ψ(θ ′) − Ψ(θ(0)) is finite. Then, if ηk−1 = √ 2αδ BT for all k ≥ 1, it holds that\nE [ J ( 1\nT T∑ k=1 θ(k−1) )] − inf θ∈K∩A J(θ) ≤ √ 2Bδ αT . (7)\nFurthermore, if ‖ĝk‖2∗ ≤ B′ a.s. (8)\nfor some deterministic constant B′ and ηk−1 = √ 2αδ B′T for all k ≥ 1 then, for any 0 < < 1, it holds with probability at least 1− that\nJ\n( 1\nT T∑ k=1 θ(k−1) ) − inf θ∈K∩A J(θ) ≤ √ 2B′δ αT + 4 √ B′δ log 1 αT . (9)\n7Young’s inequality states that for any x, y vectors and α > 0, 〈x, y〉 ≤ ‖x‖∗‖y‖ ≤ 12 ( ‖x‖2∗ α + α‖y‖2 ) .\nProof. Introduce the average learning rates η (T ) k = ηk/ ∑T k=1 ηk−1, k = 1, . . . , T , the averaged parameter estimates\nθ̄(T−1) = T∑ k=1 η (T ) k−1θ (k−1)\nand choose some θ∗ ∈ K ∩A. To prove the first part of the theorem, it suffices to show that the bound holds for J(θ̄(T−1)) − J(θ∗). Define gk = ∇J ( θ(k−1) ) . By the convexity of J(θ), we have\nJ ( θ̄(T−1) ) − J(θ∗) ≤ T∑ k=1 η (T ) k−1 ( J ( θ(k−1) ) − J(θ∗) ) ≤\nT∑ k=1 η (T ) k−1 〈 gk, θ (k−1) − θ∗ 〉\n= T∑ k=1 η (T ) k−1 〈 ĝk, θ (k−1) − θ∗ 〉 + T∑ k=1 η (T ) k−1 〈 gk − ĝk, θ(k−1) − θ∗ 〉 (18)\nNotice that the first term on the right hand side above is the sum of linearized losses appearing in the standard analysis of the proximal point algorithm with loss functions ĝk and learning rates η (T ) k−1, and the second sum contains the term that depends on how well ĝk estimates the gradient gk. Thus, in this way, it is separated how the proximal point algorithm and the gradient estimate effect the convergence rate of the algorithm. The first sum can be bounded by invoking the standard bound for the proximal point algorithm (we will give the very short proof for completeness, based on Lemma A.1), while the second sum can be analyzed by noticing that, by assumption (5), its elements form an {Fk}-adapted martingale-difference sequence.\nTo bound the first sum, first note that the conditions of Lemma A.1 are satisfied for\nθ1 = θ (k−1), θ = θ∗, g = η (T ) k−1ĝk, since θ1 ∈ K ∩ A ◦ (as mentioned beforehand, this follows from the behavior of Ψ at the boundary of A). Further, note that due to the so-called projection lemma (i.e., the DΨ-projection of the unconstrained optimizer is the same as the optimizer of the constrained optimization problem),we can conclude that θ(k) = θ2, where θ2 is defined in Lemma A.1. Thus, Lemma A.1 gives\nηk−1 〈 ĝk, θ (k−1) − θ∗ 〉 ≤ DΨ(θ∗, θ(k−1))−DΨ(θ∗, θ(k) +\nη2k−1‖ĝk‖2∗ 2α .\nSumming the above inequality for k = 1, . . . , T , the divergence terms cancel each other, yielding T∑ k=1 η (T ) k−1 〈 ĝk, θ (k−1) − θ∗ 〉 ≤ 1∑T k=1 ηk−1 ( DΨ(θ ∗, θ(0))−DΨ(θ∗, θ(T )) + 1 2α T∑ k=1 η2k−1‖ĝk‖2∗ ) .\n(19) Let us now turn to the second sum. We start with developing a bound on the expected regret. For any 1 ≤ k ≤ T , by construction η(T )k−1 and θ (k−1) are Fk−1-measurable. This, together with (5) gives\nE [ η\n(T ) k−1 〈 gk − ĝk, θ∗ − θ(k−1) 〉∣∣∣Fk−1] = η(T )k−1 〈gk − E [ ĝk| Fk−1] , θ∗ − θ(k−1)〉 = 0 . (20)\nCombining this result with (18) and (19) yields E [ J ( θ̄(T ) ) − J(θ∗) ] ≤ 1∑T\nk=1 ηk−1\n( DΨ(θ ∗, θ(0))−DΨ(θ∗, θ(T )) + 1\n2α T∑ k=1 η2k−1E [ E [ ‖ĝk‖2∗\n∣∣Fk−1]] )\n≤ δ + 12α\n∑T k=1 η\n2 k−1B∑T\nk=1 ηk−1 , (21)\nwhere we used the tower rule to bring in the bound (6), the nonnegativity of Bregman divergences, and DΨ(θ, θ (0)) ≤ Ψ(θ) − Ψ(θ(0)); the latter holds as 〈 ∇Ψ(θ(0)), θ − θ(0) 〉 ≥ 0\nsince θ(0) minimizes Ψ on K. Substituting ηk−1 = η = √ 2αδ BT , k = 1, . . . , T finishes the proof of (7). To prove the high probability result (9), notice that thanks to (5) { ηk−1 〈 gk − ĝk, θ∗ − θ(k−1)\n〉} is an {Fk}-adapted martingale-difference sequence (cf. (20)). By the strong convexity of Ψ we have\nα 2 ‖θ(k−1) − θ∗‖2 ≤ Ψ(θ(k−1))−Ψ(θ∗) ≤ δ.\nFurthermore, conditions (5) and (8) imply that ‖gk‖2∗ ≤ B′ a.s., and so by (8) we have ‖gk − ĝk‖∗ ≤ 2 √ B′ a.s. Then by Hölder’s inequality\n∣∣∣〈gk − ĝk, θ∗ − θ(k−1)〉∣∣∣ ≤ ‖gk − ĝk‖∗ ‖θ∗ − θ(k−1)‖ ≤ 2 √ 2B′δ\nα .\nThus, by the Hoeffding-Azuma inequality (see, e.g., Lemma A.7, Cesa-Bianchi and Lugosi, 2006), for any 0 < < 1 we have, with probability at least 1− ,\nT∑ k=1 η (T ) k−1 〈 gk − ĝk, θ∗ − θ(k−1) 〉 ≤ 4∑T k=1 ηk−1 √√√√B′δ α ( T∑ k=1 η2k−1 ) ln 1 . (22)\nCombining (19) with (8) implies an almost sure upper bound on the first sum on the right hand side of (18) as in (21) with B′ in place of B. This, together with (22) proves the required high probability bound (9) when substituting ηk−1 = η ′ = √ 2αδ B′T .\nProposition 3.2. For 1 ≤ t ≤ n, let `∗t : R→ R denote the convex conjugate of `t: `∗t (v) = supτ∈R {vτ − `t(τ)}, v ∈ R. For i ∈ I, recall that κi(x, x′) = 〈φi(x), φi(x′)〉, and let Ki = (κi(xt, xs))1≤t,s≤n be the n × n kernel matrix underlying κi and let Kθ = ∑ i∈I\nθi ρ2i Ki be the kernel matrix underlying κθ = ∑\ni∈I θi ρ2i κi. Then, for any fixed θ, the minimizer w ∗(θ) of\nJ(·, θ) satisfies\nw∗i (θ) = θi ρ2i n∑ t=1 α∗t (θ)φi(xt), i ∈ I , (10)\nwhere\nα∗(θ) = arg min α∈Rn\n{ 1\n2 α>Kθα+\n1\nn n∑ t=1 `∗t (−nαt)\n} . (11)\nProof. By introducing the variables τ = (τt)1≤t≤n ∈ Rn and using the definition of L we can write the optimization problem (3) as the constrained optimization problem\nminimize w∈W,τ∈Rn\n1\nn n∑ t=1 `t(τt) + 1 2 ∑ i∈I ρ2i ‖wi‖22 θi\ns.t. τt = ∑ i∈I 〈wi, φi(xt)〉 , (23)\nIn what follows, we call this problem the primal problem. The Lagrangian of this problem is\nL(w, τ, α) .= 1 n n∑ t=1 `t(τt) + 1 2 ∑ i∈I ρ2i ‖wi‖22 θi + n∑ t=1 αt\n{ τt −\n∑ i∈I 〈wi, φi(xt)〉\n} ,\nwhere α = (αt)1≤t≤n ∈ Rn is the vector of Lagrange multipliers (or dual variables) associated with the n equality constraints. The Lagrange dual function, g(α) . = infw,τ L(w, τ, α), can be readily seen to satisfy\ng(α) = −\n( 1\n2 α>Kθα+\n1\nn n∑ t=1 `∗t (−nαt)\n) .\nNow, since the objective function of the primal problem is convex and the primal problem involves only affine equality constraints and the primal problem is clearly feasible, by Slater’s condition (p.226, Boyd and Vandenberghe, 2004), if α∗(θ) is the maximizer of g(α) then\nw∗(θ) = arg min w∈W inf τ∈Rn L(w, τ, α∗(θ))\n= arg min w∈W ∑ i∈I\n{ ρ2i ‖wi‖22\n2θi − n∑ t=1 αt 〈wi, φi(xt)〉\n} .\nThe minimum of the last expression is readily seen to be equal to the expression given in (10), thus finishing the proof."
    }, {
      "heading" : "B Calculating the derivative of J(θ)",
      "text" : "In this section we show that under mild conditions the derivative of J exist and we also give explicit forms. These derivations are quite standard and a similar argument can be found in the paper by (e.g.) Rakotomamonjy et al. (2008) specialized to the case when `t is the hinge loss.\nAs it is well-known, thanks to the implicit function theorem (e.g., Brown and Page,\n1970, Theorem 7.5.6), provided that J = J(w, θ) is such that ∂ 2 ∂θ∂wJ(w, θ) and ∂ ∂wJ(w, θ) are continuous, the gradient of J(θ) can be computed by evaluating the partial derivative ∂ ∂θJ(w, θ) of J(w, θ) with respect to θ at (w ∗(θ), θ)), that is, ∂θJ(θ) = ∂ ∂θ J(w, θ)|w=w∗(θ).Note that the derivative is well-defined only if θ > 0, that is, when no coordinates of θ is zero, in which case\n∂\n∂θ J(w∗(θ), θ) = −\n( ρ2i ‖w∗i (θ)‖22\nθ2i\n) i∈I . (24)\nIf θi = 0 for some i ∈ I, we define the derivative in a continuous manner as ∂\n∂θ J(θ) = lim\nθ′→θ θ′∈∆,θ′>0\n∂\n∂θ J(θ′) (25)\nassuming that the limit exists. From (10) we get, for any i ∈ I, ‖w∗i (θ)‖22 = θ2i ρ4i α∗(θ)>Kiα∗(θ). Combining with (24) we obtain\n∂\n∂θ J(w∗(θ), θ) = −\n( α∗(θ)>Kiα∗(θ)\nρ2i\n) i∈I .\nNow, by (25) and the implicit function theorem, α∗(θ) is a continuous function of θ provided that the functions `∗t (1 ≤ t ≤ n) are twice continuously differentiable. This shows that under the conditions listed so far, the limit in (25) exists. In the application we shall be concerned with, these conditions can be readily verified."
    } ],
    "references" : [ {
      "title" : "Learning convex combinations",
      "author" : [ "A. Argyriou", "C. Micchelli", "M. Pontil" ],
      "venue" : null,
      "citeRegEx" : "Argyriou et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Argyriou et al\\.",
      "year" : 2005
    }, {
      "title" : "Mirror descent and nonlinear projected subgradient meth",
      "author" : [ "A. Beck", "M. Teboulle" ],
      "venue" : "Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Beck and Teboulle,? \\Q2003\\E",
      "shortCiteRegEx" : "Beck and Teboulle",
      "year" : 2003
    }, {
      "title" : "Learning non-linear combinations",
      "author" : [ "C. Cortes", "M. Mohri", "A. Rostamizadeh" ],
      "venue" : null,
      "citeRegEx" : "Cortes et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Cortes et al\\.",
      "year" : 2009
    }, {
      "title" : "Infinite kernel learning",
      "author" : [ "A. Asuncion" ],
      "venue" : "Neural Information Processing Systems,",
      "citeRegEx" : "A. and Asuncion,? \\Q2010\\E",
      "shortCiteRegEx" : "A. and Asuncion",
      "year" : 2010
    }, {
      "title" : "Multiple kernel learning algorithms",
      "author" : [ "M. Planck Institute For Biological Cybernetics. Gönen", "E. Alpaydın" ],
      "venue" : "Journal of Machine",
      "citeRegEx" : "Gönen and Alpaydın,? 2011",
      "shortCiteRegEx" : "Gönen and Alpaydın",
      "year" : 2011
    }, {
      "title" : "The Elements of Statistical Learning",
      "author" : [ "T. Hastie", "R. Tibshirani", "J. Friedman" ],
      "venue" : "Learning Research,",
      "citeRegEx" : "Hastie et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Hastie et al\\.",
      "year" : 2009
    }, {
      "title" : "Logarithmic regret algorithms for online convex optimization",
      "author" : [ "E. Hazan", "A. Agarwal", "S. Kale" ],
      "venue" : "Machine Learning Journal, 69(2-3):169–192.",
      "citeRegEx" : "Hazan et al\\.,? 2007",
      "shortCiteRegEx" : "Hazan et al\\.",
      "year" : 2007
    }, {
      "title" : "Beyond the regret minimization barrier: an optimal algorithm for stochastic strongly-convex optimization",
      "author" : [ "E. Hazan", "S. Kale" ],
      "venue" : "Proceedings of the 24th Annual Conference on Learning Theory, volume 19 of JMLR Workshop and Conference Proceedings, pages 421–436.",
      "citeRegEx" : "Hazan and Kale,? 2011",
      "shortCiteRegEx" : "Hazan and Kale",
      "year" : 2011
    }, {
      "title" : "lp-norm multiple kernel learning",
      "author" : [ "M. Kloft", "U. Brefeld", "S. Sonnenburg", "A. Zien" ],
      "venue" : "Journal of Machine Learning Research, 12:953–997.",
      "citeRegEx" : "Kloft et al\\.,? 2011",
      "shortCiteRegEx" : "Kloft et al\\.",
      "year" : 2011
    }, {
      "title" : "Perturbation des méthodes d’optimisation",
      "author" : [ "B. Martinet" ],
      "venue" : "Applications. RAIRO Analyse Numérique, 12:153–171.",
      "citeRegEx" : "Martinet,? 1978",
      "shortCiteRegEx" : "Martinet",
      "year" : 1978
    }, {
      "title" : "Learning the kernel function via regularization",
      "author" : [ "C. Micchelli", "M. Pontil" ],
      "venue" : "Journal of Machine Learning Research, 6:1099–1125.",
      "citeRegEx" : "Micchelli and Pontil,? 2005",
      "shortCiteRegEx" : "Micchelli and Pontil",
      "year" : 2005
    }, {
      "title" : "On the algorithmics and applications of a mixed-norm based kernel learning formulation",
      "author" : [ "J. Nath", "G. Dinesh", "S. Raman", "C. Bhattacharyya", "A. Ben-Tal", "K. Ramakrishnan" ],
      "venue" : "Advances in Neural Information Processing Systems, volume 22, pages 844–852.",
      "citeRegEx" : "Nath et al\\.,? 2009",
      "shortCiteRegEx" : "Nath et al\\.",
      "year" : 2009
    }, {
      "title" : "Robust stochastic approximation approach to stochastic programming",
      "author" : [ "A. Nemirovski", "A. Juditsky", "G. Lan", "A. Shapiro" ],
      "venue" : "SIAM J. Optimization, 4:1574–1609.",
      "citeRegEx" : "Nemirovski et al\\.,? 2009a",
      "shortCiteRegEx" : "Nemirovski et al\\.",
      "year" : 2009
    }, {
      "title" : "Robust stochastic approximation approach to stochastic programming",
      "author" : [ "A. Nemirovski", "A. Juditsky", "G. Lan", "A. Shapiro" ],
      "venue" : "SIAM Journal on Optimization, 19(4):1574– 1609.",
      "citeRegEx" : "Nemirovski et al\\.,? 2009b",
      "shortCiteRegEx" : "Nemirovski et al\\.",
      "year" : 2009
    }, {
      "title" : "Problem Complexity and Method Efficiency in Optimization",
      "author" : [ "A. Nemirovski", "D. Yudin" ],
      "venue" : "Wiley.",
      "citeRegEx" : "Nemirovski and Yudin,? 1998",
      "shortCiteRegEx" : "Nemirovski and Yudin",
      "year" : 1998
    }, {
      "title" : "Efficiency of coordinate descent methods on huge-scale optimization problems",
      "author" : [ "Y. Nesterov" ],
      "venue" : "CORE Discussion paper, (2010/2).",
      "citeRegEx" : "Nesterov,? 2010",
      "shortCiteRegEx" : "Nesterov",
      "year" : 2010
    }, {
      "title" : "Subgradient methods for huge-scale optimization problems",
      "author" : [ "Y. Nesterov" ],
      "venue" : "CORE Discussion paper, (2012/2).",
      "citeRegEx" : "Nesterov,? 2012",
      "shortCiteRegEx" : "Nesterov",
      "year" : 2012
    }, {
      "title" : "Ultra-fast optimization algorithm for sparse multi kernel learning",
      "author" : [ "F. Orabona", "J. Luo" ],
      "venue" : "Proceedings of the 28th International Conference on Machine Learning, pages 249–256.",
      "citeRegEx" : "Orabona and Luo,? 2011",
      "shortCiteRegEx" : "Orabona and Luo",
      "year" : 2011
    }, {
      "title" : "SimpleMKL",
      "author" : [ "A. Rakotomamonjy", "F. Bach", "S. Canu", "Y. Grandvalet" ],
      "venue" : "Journal of Machine Learning Research, 9:2491–2521.",
      "citeRegEx" : "Rakotomamonjy et al\\.,? 2008",
      "shortCiteRegEx" : "Rakotomamonjy et al\\.",
      "year" : 2008
    }, {
      "title" : "Iteration complexity of randomized block-coordinate descent methods for minimizing a composite function",
      "author" : [ "P. Richtárik", "M. Takáĉ" ],
      "venue" : "(revised July 4, 2011) submitted to Mathematical Programming.",
      "citeRegEx" : "Richtárik and Takáĉ,? 2011",
      "shortCiteRegEx" : "Richtárik and Takáĉ",
      "year" : 2011
    }, {
      "title" : "Monotone operators and the proximal point algorithm",
      "author" : [ "R. Rockafellar" ],
      "venue" : "SIAM Journal on Control and Optimization, 14(1):877–898. 21",
      "citeRegEx" : "Rockafellar,? 1976",
      "shortCiteRegEx" : "Rockafellar",
      "year" : 1976
    }, {
      "title" : "Learning with Kernels: Support Vector Machines, Regularization, Optimization, and Beyond",
      "author" : [ "B. Schölkopf", "A. Smola" ],
      "venue" : "MIT Press, Cambridge, MA, USA.",
      "citeRegEx" : "Schölkopf and Smola,? 2002",
      "shortCiteRegEx" : "Schölkopf and Smola",
      "year" : 2002
    }, {
      "title" : "Stochastic methods for l1-regularized loss minimization",
      "author" : [ "S. Shalev-Shwartz", "A. Tewari" ],
      "venue" : "Journal of Machine Learning Research, 12:1865–1892.",
      "citeRegEx" : "Shalev.Shwartz and Tewari,? 2011",
      "shortCiteRegEx" : "Shalev.Shwartz and Tewari",
      "year" : 2011
    }, {
      "title" : "Kernel Methods for Pattern Analysis",
      "author" : [ "J. Shawe-Taylor", "N. Cristianini" ],
      "venue" : "Cambridge Univ Press.",
      "citeRegEx" : "Shawe.Taylor and Cristianini,? 2004",
      "shortCiteRegEx" : "Shawe.Taylor and Cristianini",
      "year" : 2004
    }, {
      "title" : "Large scale multiple kernel learning",
      "author" : [ "S. Sonnenburg", "G. Rätsch", "C. Schäfer", "B. Schölkopf" ],
      "venue" : "The Journal of Machine Learning Research, 7:1531–1565.",
      "citeRegEx" : "Sonnenburg et al\\.,? 2006",
      "shortCiteRegEx" : "Sonnenburg et al\\.",
      "year" : 2006
    }, {
      "title" : "An extended level method for efficient multiple kernel learning",
      "author" : [ "Z. Xu", "R. Jin", "I. King", "M. Lyu" ],
      "venue" : "Advances in Neural Information Processing Systems, volume 21, pages 1825–1832.",
      "citeRegEx" : "Xu et al\\.,? 2008",
      "shortCiteRegEx" : "Xu et al\\.",
      "year" : 2008
    }, {
      "title" : "Simple and efficient multiple kernel learning by group lasso",
      "author" : [ "Z. Xu", "R. Jin", "H. Yang", "I. King", "M.R. Lyu" ],
      "venue" : "Proceedings of the 27th International Conference on Machine Learning, pages 1175–1182. 22",
      "citeRegEx" : "Xu et al\\.,? 2010",
      "shortCiteRegEx" : "Xu et al\\.",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 25,
      "context" : "Just like some previous works (e.g. Rakotomamonjy et al., 2008; Xu et al., 2008; Nath et al., 2009) we start with the approach that views the MKL problem as a nested, large scale convex optimization problem, where the first layer optimizes the weights of the kernels to be combined.",
      "startOffset" : 30,
      "endOffset" : 99
    }, {
      "referenceID" : 11,
      "context" : "Just like some previous works (e.g. Rakotomamonjy et al., 2008; Xu et al., 2008; Nath et al., 2009) we start with the approach that views the MKL problem as a nested, large scale convex optimization problem, where the first layer optimizes the weights of the kernels to be combined.",
      "startOffset" : 30,
      "endOffset" : 99
    }, {
      "referenceID" : 22,
      "context" : "However, as opposed to these works whose underlying iterative methods have a complexity of Ω(d) for just any one iteration, following (Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011) we use a randomized coordinate descent method, which was effectively used in these works to decrease the per iteration complexity to O(1).",
      "startOffset" : 134,
      "endOffset" : 216
    }, {
      "referenceID" : 19,
      "context" : "However, as opposed to these works whose underlying iterative methods have a complexity of Ω(d) for just any one iteration, following (Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011) we use a randomized coordinate descent method, which was effectively used in these works to decrease the per iteration complexity to O(1).",
      "startOffset" : 134,
      "endOffset" : 216
    }, {
      "referenceID" : 13,
      "context" : "However, as opposed to these works whose underlying iterative methods have a complexity of Ω(d) for just any one iteration, following (Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011) we use a randomized coordinate descent method, which was effectively used in these works to decrease the per iteration complexity to O(1). The role of randomization in our method is to use it to build an unbiased estimate of the gradient at the most recent iteration. The issue then is how the variance (and so the number of iterations required) scales with d. As opposed to the above mentioned works, in this paper we propose to make the distribution over the updated coordinate dependent on the history. We will argue that sampling from a distribution that is proportional to the magnitude of the gradient vector is desirable to keep the variance (actually, second moment) low and in fact we will show that there are interesting cases of MKL (in particular, the case of combining kernels coming from a polynomial family of kernels) when efficient sampling (i.e., sampling at a cost of O(log d)) is feasible from this distribution. Then, the variance is controlled by the a priori weights put on the kernels, making it potentially independent of d. Under these favorable conditions (and in particular, for the polynomial kernel set with some specific prior weights), the complexity of the method as a function of d becomes logarithmic, which makes our MKL algorithm feasible even for large scale problems. This is to be contrasted to the approach of Nesterov (2010, 2012) where a fixed distribution is used and where the a priori bounds on the method’s convergence rate, and, hence, its computational cost to achieve a prescribed precision, will depend linearly on d (note that we are comparing upper bounds here, so the actual complexity could be smaller). Our algorithm is based on the mirror descent (or mirror descent) algorithm (similar to the work of Richtárik and Takáĉ (2011) who uses uniform distributions).",
      "startOffset" : 135,
      "endOffset" : 2002
    }, {
      "referenceID" : 0,
      "context" : "It is important to mention that there are algorithms designed to handle the case of infinitely many kernels, for example, the algorithms by Argyriou et al. (2005, 2006); Gehler and Nowozin (2008). However, these methods lack convergence rate guarantees, and, for example, the consistency for the method of Gehler and Nowozin (2008) works only for “small” d.",
      "startOffset" : 140,
      "endOffset" : 196
    }, {
      "referenceID" : 0,
      "context" : "It is important to mention that there are algorithms designed to handle the case of infinitely many kernels, for example, the algorithms by Argyriou et al. (2005, 2006); Gehler and Nowozin (2008). However, these methods lack convergence rate guarantees, and, for example, the consistency for the method of Gehler and Nowozin (2008) works only for “small” d.",
      "startOffset" : 140,
      "endOffset" : 332
    }, {
      "referenceID" : 0,
      "context" : "It is important to mention that there are algorithms designed to handle the case of infinitely many kernels, for example, the algorithms by Argyriou et al. (2005, 2006); Gehler and Nowozin (2008). However, these methods lack convergence rate guarantees, and, for example, the consistency for the method of Gehler and Nowozin (2008) works only for “small” d. The algorithm of Bach (2008), though practically very efficient, suffers from the same deficiency.",
      "startOffset" : 140,
      "endOffset" : 387
    }, {
      "referenceID" : 0,
      "context" : "It is important to mention that there are algorithms designed to handle the case of infinitely many kernels, for example, the algorithms by Argyriou et al. (2005, 2006); Gehler and Nowozin (2008). However, these methods lack convergence rate guarantees, and, for example, the consistency for the method of Gehler and Nowozin (2008) works only for “small” d. The algorithm of Bach (2008), though practically very efficient, suffers from the same deficiency. A very interesting proposal by Cortes et al. (2009) considers learning to combine a large number of kernels and comes with guarantees, though their algorithm restricts the family of kernels in a specific way.",
      "startOffset" : 140,
      "endOffset" : 509
    }, {
      "referenceID" : 5,
      "context" : ", Hastie et al. (2009). In supervised learning problems `t(y) = `(yt, y) for some loss function ` : R × R → R, such as the squared-loss, `(yt, y) = 1 2(y − yt) 2, or the hinge-loss, `t(yt, y) = max(1 − yyt, 0), where in the former case yt ∈ R, while in the latter case yt ∈ {−1,+1}.",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 5,
      "context" : ", Hastie et al. (2009). In supervised learning problems `t(y) = `(yt, y) for some loss function ` : R × R → R, such as the squared-loss, `(yt, y) = 1 2(y − yt) 2, or the hinge-loss, `t(yt, y) = max(1 − yyt, 0), where in the former case yt ∈ R, while in the latter case yt ∈ {−1,+1}. We note in passing that for the sake of simplicity, we shall sometimes abuse notation and write Ln(w) for Ln(fw) and even drop the index n when the sample-size is unimportant. As mentioned above, in this paper we consider the special case in (1) when the penalty is a so-called group p-norm penalty with 1 ≤ p ≤ 2, a case considered earlier, e.g., by Kloft et al. (2011). Thus our goal is to solve",
      "startOffset" : 2,
      "endOffset" : 654
    }, {
      "referenceID" : 20,
      "context" : "More precisely, our proposed algorithm is an instance of a randomized version of the mirror descent algorithm (Rockafellar, 1976; Martinet, 1978; Nemirovski and Yudin, 1998), where in each time step only one coordinate of the gradient is sampled.",
      "startOffset" : 110,
      "endOffset" : 173
    }, {
      "referenceID" : 9,
      "context" : "More precisely, our proposed algorithm is an instance of a randomized version of the mirror descent algorithm (Rockafellar, 1976; Martinet, 1978; Nemirovski and Yudin, 1998), where in each time step only one coordinate of the gradient is sampled.",
      "startOffset" : 110,
      "endOffset" : 173
    }, {
      "referenceID" : 14,
      "context" : "More precisely, our proposed algorithm is an instance of a randomized version of the mirror descent algorithm (Rockafellar, 1976; Martinet, 1978; Nemirovski and Yudin, 1998), where in each time step only one coordinate of the gradient is sampled.",
      "startOffset" : 110,
      "endOffset" : 173
    }, {
      "referenceID" : 12,
      "context" : "In particular, compared to (Nemirovski et al., 2009a; Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011), our analysis allows for the conditional distribution of the noise in the gradient estimate to be history dependent.",
      "startOffset" : 27,
      "endOffset" : 135
    }, {
      "referenceID" : 22,
      "context" : "In particular, compared to (Nemirovski et al., 2009a; Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011), our analysis allows for the conditional distribution of the noise in the gradient estimate to be history dependent.",
      "startOffset" : 27,
      "endOffset" : 135
    }, {
      "referenceID" : 19,
      "context" : "In particular, compared to (Nemirovski et al., 2009a; Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011), our analysis allows for the conditional distribution of the noise in the gradient estimate to be history dependent.",
      "startOffset" : 27,
      "endOffset" : 135
    }, {
      "referenceID" : 6,
      "context" : "The convergence rate in the above theorem can be improved if stronger assumptions are made on J , for example if J is assumed to be strongly convex, see, for example, (Hazan et al., 2007; Hazan and Kale, 2011).",
      "startOffset" : 167,
      "endOffset" : 209
    }, {
      "referenceID" : 7,
      "context" : "The convergence rate in the above theorem can be improved if stronger assumptions are made on J , for example if J is assumed to be strongly convex, see, for example, (Hazan et al., 2007; Hazan and Kale, 2011).",
      "startOffset" : 167,
      "endOffset" : 209
    }, {
      "referenceID" : 21,
      "context" : "Note that this type of result is standard (see, e.g., Shawe-Taylor and Cristianini, 2004; Schölkopf and Smola, 2002), thus we include it only for the sake of completeness (the proof is included in Section A in the appendix).",
      "startOffset" : 42,
      "endOffset" : 116
    }, {
      "referenceID" : 3,
      "context" : "The importance of this example follows from the observation of Gönen and Alpaydın (2011) that the non-linear kernel learning methods of Cortes et al.",
      "startOffset" : 63,
      "endOffset" : 89
    }, {
      "referenceID" : 2,
      "context" : "The importance of this example follows from the observation of Gönen and Alpaydın (2011) that the non-linear kernel learning methods of Cortes et al. (2009), which can be viewed as a restricted form of learning polynomial kernels, are far the best MKL methods in practice and can significantly outperform state-of-the-art SVM with a single kernel or with the uniform combination of kernels.",
      "startOffset" : 136,
      "endOffset" : 157
    }, {
      "referenceID" : 22,
      "context" : "(2011) with p = 2,4 and the uniform coordinate descent algorithm that updates one coordinate per iteration uniformly at random (Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011).",
      "startOffset" : 127,
      "endOffset" : 209
    }, {
      "referenceID" : 19,
      "context" : "(2011) with p = 2,4 and the uniform coordinate descent algorithm that updates one coordinate per iteration uniformly at random (Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011).",
      "startOffset" : 127,
      "endOffset" : 209
    }, {
      "referenceID" : 8,
      "context" : "1 Convergence speed In this experiment we examine the speed of convergence of our method and compare it against one of the fastest standard multiple kernel learning algorithms, that is, the p-norm multiple kernel learning algorithm of Kloft et al. (2011) with p = 2,4 and the uniform coordinate descent algorithm that updates one coordinate per iteration uniformly at random (Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; Richtárik and Takáĉ, 2011).",
      "startOffset" : 235,
      "endOffset" : 255
    }, {
      "referenceID" : 8,
      "context" : "In this figure Stoch represents our algorithms, Kloft represents the algorithm of Kloft et al. (2011), and UCD represents the uniform coordinate descent algorithm.",
      "startOffset" : 82,
      "endOffset" : 102
    }, {
      "referenceID" : 8,
      "context" : "In this figure Stoch represents our algorithms, Kloft represents the algorithm of Kloft et al. (2011), and UCD represents the uniform coordinate descent algorithm. The results show that our method consistently outperforms the other algorithms in convergence speed. Note that our stochastic method updates one kernel coefficient per iteration, while Kloft updates ( r+D D ) kernel coefficients per iteration. The difference between the two methods is analogous to the difference between stochastic gradient vs. full gradient algorithms. While UCD also updates one kernel Note that p = 2 in Kloft et al. (2011) notation corresponds to p = 4/3 or ν = 2 in our notation, which gives the same objective function that we minimize with Algorithm 2.",
      "startOffset" : 82,
      "endOffset" : 609
    }, {
      "referenceID" : 7,
      "context" : "We compare our method (Stoch) against the algorithm of Kloft et al. (2011) (Kloft), the nonlinear kernel learning method of Cortes et al.",
      "startOffset" : 55,
      "endOffset" : 75
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).",
      "startOffset" : 56,
      "endOffset" : 77
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).",
      "startOffset" : 56,
      "endOffset" : 149
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi) D, where D is a predetermined integer that specifies the degree of nonlinear kernel.",
      "startOffset" : 56,
      "endOffset" : 290
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi) D, where D is a predetermined integer that specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent to adding polynomial kernels of degree less than D to the combination too. We provide all possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011). For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3.",
      "startOffset" : 56,
      "endOffset" : 665
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi) D, where D is a predetermined integer that specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent to adding polynomial kernels of degree less than D to the combination too. We provide all possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011). For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3.",
      "startOffset" : 56,
      "endOffset" : 711
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi) D, where D is a predetermined integer that specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent to adding polynomial kernels of degree less than D to the combination too. We provide all possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011). For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3. The results are shown in Figure 2, the mean squared errors are on the left plot, while the training times are on the right plot. In the training-time plot the numbers inside brackets While several fast MKL algorithms are available in the literature, such as those of Sonnenburg et al. (2006); Rakotomamonjy et al.",
      "startOffset" : 56,
      "endOffset" : 1046
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi) D, where D is a predetermined integer that specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent to adding polynomial kernels of degree less than D to the combination too. We provide all possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011). For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3. The results are shown in Figure 2, the mean squared errors are on the left plot, while the training times are on the right plot. In the training-time plot the numbers inside brackets While several fast MKL algorithms are available in the literature, such as those of Sonnenburg et al. (2006); Rakotomamonjy et al. (2008); Xu et al.",
      "startOffset" : 56,
      "endOffset" : 1075
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi) D, where D is a predetermined integer that specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent to adding polynomial kernels of degree less than D to the combination too. We provide all possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011). For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3. The results are shown in Figure 2, the mean squared errors are on the left plot, while the training times are on the right plot. In the training-time plot the numbers inside brackets While several fast MKL algorithms are available in the literature, such as those of Sonnenburg et al. (2006); Rakotomamonjy et al. (2008); Xu et al. (2010); Orabona and Luo (2011); Kloft et al.",
      "startOffset" : 56,
      "endOffset" : 1093
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi) D, where D is a predetermined integer that specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent to adding polynomial kernels of degree less than D to the combination too. We provide all possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011). For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3. The results are shown in Figure 2, the mean squared errors are on the left plot, while the training times are on the right plot. In the training-time plot the numbers inside brackets While several fast MKL algorithms are available in the literature, such as those of Sonnenburg et al. (2006); Rakotomamonjy et al. (2008); Xu et al. (2010); Orabona and Luo (2011); Kloft et al.",
      "startOffset" : 56,
      "endOffset" : 1117
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi) D, where D is a predetermined integer that specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent to adding polynomial kernels of degree less than D to the combination too. We provide all possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011). For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3. The results are shown in Figure 2, the mean squared errors are on the left plot, while the training times are on the right plot. In the training-time plot the numbers inside brackets While several fast MKL algorithms are available in the literature, such as those of Sonnenburg et al. (2006); Rakotomamonjy et al. (2008); Xu et al. (2010); Orabona and Luo (2011); Kloft et al. (2011), a comparison of the reported experimental results shows that from among these algorithms the method of Kloft et al.",
      "startOffset" : 56,
      "endOffset" : 1138
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi) D, where D is a predetermined integer that specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent to adding polynomial kernels of degree less than D to the combination too. We provide all possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011). For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3. The results are shown in Figure 2, the mean squared errors are on the left plot, while the training times are on the right plot. In the training-time plot the numbers inside brackets While several fast MKL algorithms are available in the literature, such as those of Sonnenburg et al. (2006); Rakotomamonjy et al. (2008); Xu et al. (2010); Orabona and Luo (2011); Kloft et al. (2011), a comparison of the reported experimental results shows that from among these algorithms the method of Kloft et al. (2011) has the best performance overall.",
      "startOffset" : 56,
      "endOffset" : 1262
    }, {
      "referenceID" : 2,
      "context" : "(2011) (Kloft), the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear kernels built from the input variables. Recall that the method of Cortes et al. (2009) only considers kernels of the form κθ = ( ∑r i=1 θiκi) D, where D is a predetermined integer that specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent to adding polynomial kernels of degree less than D to the combination too. We provide all possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011). For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3. The results are shown in Figure 2, the mean squared errors are on the left plot, while the training times are on the right plot. In the training-time plot the numbers inside brackets While several fast MKL algorithms are available in the literature, such as those of Sonnenburg et al. (2006); Rakotomamonjy et al. (2008); Xu et al. (2010); Orabona and Luo (2011); Kloft et al. (2011), a comparison of the reported experimental results shows that from among these algorithms the method of Kloft et al. (2011) has the best performance overall. Hence, we decided to compare against only this algorithm. Also note that the memory and computational cost of all these methods still scale linearly with the number of kernels, making them unsuitable for the case we are most interested in. Furthermore, to keep the focus of the paper we compare our algorithm to methods with sound theoretical guarantees. As such, it remains for future work to compare with other methods, such as the infinite kernel learning of Gehler and Nowozin (2008), which lack such guarantees but exhibit promising performance in practice.",
      "startOffset" : 56,
      "endOffset" : 1784
    }, {
      "referenceID" : 2,
      "context" : "Note that the performance of the method of Cortes et al. (2009) starts to degrade as r increases.",
      "startOffset" : 43,
      "endOffset" : 64
    }, {
      "referenceID" : 2,
      "context" : "Note that the performance of the method of Cortes et al. (2009) starts to degrade as r increases. This is due to the restricted family of kernels that this method considers. The method of Bach (2008), which is well-suited to learn sparse combination of product kernels, performs better than Cortes et al.",
      "startOffset" : 43,
      "endOffset" : 200
    }, {
      "referenceID" : 2,
      "context" : "Note that the performance of the method of Cortes et al. (2009) starts to degrade as r increases. This is due to the restricted family of kernels that this method considers. The method of Bach (2008), which is well-suited to learn sparse combination of product kernels, performs better than Cortes et al. (2009) for higher input dimensions.",
      "startOffset" : 43,
      "endOffset" : 312
    }, {
      "referenceID" : 2,
      "context" : "We compare our new algorithm (Stoch), the algorithm of Bach (2008) (Bach), and the algorithm of Cortes et al. (2009) (Cortes).",
      "startOffset" : 96,
      "endOffset" : 117
    }, {
      "referenceID" : 2,
      "context" : "We compare our new algorithm (Stoch), the algorithm of Bach (2008) (Bach), and the algorithm of Cortes et al. (2009) (Cortes). For each algorithm we consider learning polynomial kernels of degree 2 and 3. We also include uniform combination of product kernels of degree D, i.e. κD = ( ∑r i=1 κi) , for D ∈ {1, 2, 3} (Uniform). To find out if considering higherorder interaction of input variables results in improved performance we also included a MKL algorithm to which we only feed linear kernels (D = 1). We use the MKL algorithm of Kloft et al. (2011) with p ∈ {1, 2} (Kloft).",
      "startOffset" : 96,
      "endOffset" : 556
    }, {
      "referenceID" : 1,
      "context" : "1 is based on the standard proof of the convergence rate of the proximal point algorithm, see, for example, (Beck and Teboulle, 2003), or the proof of Proposition 2.",
      "startOffset" : 108,
      "endOffset" : 133
    }, {
      "referenceID" : 1,
      "context" : "1 is based on the standard proof of the convergence rate of the proximal point algorithm, see, for example, (Beck and Teboulle, 2003), or the proof of Proposition 2.2 of Nemirovski et al. (2009b), which carry over the same argument to solve very similar but less general problems.",
      "startOffset" : 109,
      "endOffset" : 196
    }, {
      "referenceID" : 18,
      "context" : ") Rakotomamonjy et al. (2008) specialized to the case when `t is the hinge loss.",
      "startOffset" : 2,
      "endOffset" : 30
    } ],
    "year" : 2013,
    "abstractText" : "We consider the problem of simultaneously learning to linearly combine a very large number of kernels and learn a good predictor based on the learnt kernel. When the number of kernels d to be combined is very large, multiple kernel learning methods whose computational cost scales linearly in d are intractable. We propose a randomized version of the mirror descent algorithm to overcome this issue, under the objective of minimizing the group p-norm penalized empirical risk. The key to achieve the required exponential speed-up is the computationally efficient construction of low-variance estimates of the gradient. We propose importance sampling based estimates, and find that the ideal distribution samples a coordinate with a probability proportional to the magnitude of the corresponding gradient. We show the surprising result that in the case of learning the coefficients of a polynomial kernel, the combinatorial structure of the base kernels to be combined allows the implementation of sampling from this distribution to run in O(log(d)) time, making the total computational cost of the method to achieve an optimal solution to be O(log(d)/ ), thereby allowing our method to operate for very large values of d. Experiments with simulated and real data confirm that the new algorithm is computationally more efficient than its state-of-the-art alternatives.",
    "creator" : "LaTeX with hyperref package"
  }
}