{
  "name" : "1401.3430.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Unifying Framework for Structural Properties of CSPs: Definitions, Complexity, Tractability",
    "authors" : [ "Lucas Bordeaux", "Marco Cadoli", "Toni Mancini" ],
    "emails" : [ "lucasb@microsoft.com", "cadoli@dis.uniroma1.it", "tmancini@dis.uniroma1.it" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Many Constraint Satisfaction Problems (CSPs) which arise in the modelling of real-life applications exhibit “structural” properties that distinguish them from random instances. Detecting such properties has been widely recognised to be an effective way for improving the solving process. To this end, several of them have already been identified, and different techniques have been developed in order to exploit them, with the goal of reducing the search space to be explored. Good examples are value inconsistency (Mackworth, 1977; Montanari, 1974), substitutability and interchangeability (Freuder, 1991), more general\nc©2008 AI Access Foundation. All rights reserved.\nforms of symmetries (Crawford, Ginsberg, Luks, & Roy, 1996; Gent & Smith, 2000), and functional dependencies among variables (Li, 2000; Mancini & Cadoli, 2007).\nUnfortunately, checking whether such properties hold, is (or is thought to be) often computationally hard. As an example, let us consider interchangeability. Value a is said to be interchangeable with value b for variable x if every solution which assigns a to x remains a solution if x is changed to b, and vice versa (Freuder, 1991). The problem of checking interchangeability is coNP-complete (cf. Proposition 4). Analogously, detecting some other forms of symmetry reduces to the graph automorphism problem (Crawford, 1992) (for which there is no known polynomial time algorithm, even if there is evidence that it is not NP-complete, Köbler, Schöning, & Torán, 1993).\nTo this end, in order to allow general algorithms to exploit such properties efficiently, different approaches can be followed. First of all, syntactic restrictions on the constraint languages can be enforced, in order to allow the efficient verification of the properties of interest. Alternatively, “local” versions of such properties can be defined, that can be used to infer their global counterparts, and that can be verified in polynomial time. As an instance of this “local reasoning” approach, instead of checking whether a value is fully interchangeable for a variable, Freuder (1991) proposes to check whether that value is neighbourhood, or k-interchangeable. This task involves considering only bounded-sized subsets of the constraints, and hence can be performed in polynomial time. Neighbourhood and k-interchangeability are sufficient (but not necessary) conditions for full interchangeability, and have been proven to be highly effective in practice (cf., e.g., Choueiry & Noubir, 1998; Lal, Choueiry, & Freuder, 2005).\nIn this paper we give a formal characterisation of several properties of CSPs which can be exploited in order to save search, and present a unifying framework for them that allows for their semantical connections to emerge. Some of the properties are well-known in the Constraint Programming literature, others have been used in other contexts (as in databases), while some others are, to the best of our knowledge, original, and, in our opinion, play a key role in allowing a deep understanding of the topic. In particular, we reconsider the notions of inconsistency, substitutability and interchangeability, and propose those of fixable, removable, and implied value for a given variable, which are instances of the more general definition of satisfiability-preserving transformation and those of determined, dependent, and irrelevant variable. These properties make it possible to transform a problem into a simpler one. Depending on the case, this transformation is guaranteed to preserve all solutions, or the satisfiability of the problem, i.e., at least a solution, if one exists. In general, each of these properties can be detected either statically, during a preprocessing stage of the input CSP (cf., e.g., Cadoli & Mancini, 2007), or dynamically, during search (since they may arise at any time). Moreover, in some cases we don’t even need to explicitly verify whether some properties hold, because this is guaranteed by the intrinsic characteristics of the problem. For instance, some problems are guaranteed to have a unique solution. Such cases are referred to as “promise problems” in the literature (Even, Selman, & Yacobi, 1984), meaning that in addition to the problem description we are informed of certain properties it verifies (cf. forthcoming Example 1 for an example).\nThe formal characterisation of the properties and their connections allow us to shed light on the computational complexity of their recognition task in a very elegant way, proving\nthat, in the worst case, the detection of each of them is as complex as the original problem. In particular, as we will see in Section 3.1, detecting each of the proposed properties is a coNP-complete task. This holds also for Freuder’s substitutability and interchangeability (this result is, to the best of our knowledge, original). Hence, in order to be able to practically make the relevant checks during preprocessing and search, we investigate two different approaches for the efficient verification of the proposed properties: additions of suitable restrictions to the constraint language, and exploitation of efficient forms of local reasoning, i.e., by checking them for single constraints.\nThe outline of the paper is as follows: after giving an intuitive example and recalling some preliminaries, in Section 2 we present the properties we are interested in, and discuss their connections. Then, in Section 3 we focus on the complexity of the various propertydetection tasks. In particular, in Section 3.1 we prove that all of them are intractable; hence, in Section 3.2 we focus on relaxations that guarantee tractability of reasoning, investigating the two aforementioned approaches. Finally, in Section 4 we draw conclusions and address future work."
    }, {
      "heading" : "2. A Hierarchy of Properties",
      "text" : "In this section, we formally define several structural properties of CSPs, discuss the semantical relationships that hold among them, and show how they can be exploited during constraint solving."
    }, {
      "heading" : "2.1 An Intuitive Example",
      "text" : "In order to allow for a gentle introduction of the main properties investigated in the forthcoming sections, we first introduce the following example.\nExample 1 (Factoring, Lenstra & Lenstra, 1990; Pyhälä, 2004). This problem is a simplified version of one of the most important problems in public-key cryptography. Given a (large) positive integer Z and the fact that it is a product of two different unknown prime numbers X and Y (different from 1), the goal is to identify these two numbers.\nAn intuitive formulation of any instance of this problem (i.e., for any given Z) as a CSP, adequate for arbitrarily large numbers, amounts to encode the combinatorial circuit of integer multiplication, and is as follows: assuming Z has n digits (in base b) z1, . . . , zn, we consider 2n variables x1, . . . , xn and y1, . . . , yn one for each digit (in base b) of X and Y (x1 and y1 being the least significant ones). The domain for all these variables is [0, b− 1]. In order to maintain information about the carries, n + 1 additional variables c1, . . . , cn+1 must be considered, with domain [0..(b− 1)2n/b].1\nAs for the constraints (cf. Figure 1 for the intuition, where x4, x5, x6, y4, y5, y6 are equal to 0, and are omitted for readability), they are the following:\n1. Constraints on factors:\n1. In this intuitive example, with a little abuse with respect to what will be permitted by forthcoming Definition 1, we allow, to enhance readability, different variables to be defined over different domains. However, we observe that it is easy to recover from this by using standard and well-known techniques (e.g., adding new monadic constraints to model smaller domains).\n7 8 7 ∗ 7 9 7 =\n0 6 13 18 12 4 0\n49 56 49 63 72 63 − 49 56 49 − − 6 2 7 2 3 9\nx3 x2 x1 ∗ y3 y2 y1 =\nc7 c6 c5 c4 c3 c2 c1\nx3y1 x2y1 x1y1 x3y2 x2y2 x1y2 −\nx3y3 x2y3 x1y3 − − z6 z5 z4 z3 z2 z1\nWhen a guess on the two factors X and Y (i.e., on variables x1, . . . , xn and y1, . . . , yn) has been made, values for variables c1, . . . , cn+1 are completely determined, since they follow from the semantics of the multiplication. This is called a functional dependence among variables.\nFunctional dependencies arise very often in, e.g., problems for which an intermediate state has to be maintained, and their detection and exploitation has been recognized to be of great importance from an efficiency point of view, since it can lead to significant reductions of the search space (cf., e.g., Giunchiglia, Massarotto, & Sebastiani, 1998; Mancini & Cadoli, 2007; Cadoli & Mancini, 2007).\nMoreover, the presence of functional dependencies among variables of a CSP highlights a second interesting problem, i.e., that of computing the values of dependent variables after a choice of the defining ones has been made. This problem, which is always a subproblem of a CSP with dependencies, has exactly one solution, hence, the knowledge of such a promise can be useful to the solver. It is worth noting that there are also problems which intrinsically exhibit promises. This is the case of, e.g., Factoring where we add the symmetry-breaking constraint forcing x1, . . . , xn to be lexicographically less than or equal to y1, . . . , yn. This new formulation is guaranteed to have exactly one solution (since both X and Y are prime).\nThe Factoring problem exhibits also other interesting properties: let us consider an instance such that Z is given in binary notation (i.e., b = 2) and with the least significant digit z1 being equal to 1. This implies that the last digit of both factors X and Y must be 1. Hence, we can say that value 1 is implied for variables x1 and y1, and that 0 is removable for them and, more precisely inconsistent. Moreover, for this problem, which, if the symmetry is broken, has a unique solution, we also know that all variables x1, . . . , xn and y1, . . . , yn\nare determined (cf. forthcoming Definition 2), regardless of the instance, and because of the functional dependence already discussed, we have that variables encoding carries, i.e., ci (i ∈ [1, n]), are dependent on {x1, . . . , xn, y1, . . . , yn}.\nAs for problems with unique solutions, it is known that, unfortunately, their resolution remains intractable (cf., e.g., Papadimitriou, 1994; Valiant & Vijay V. Vazirani, 1986; Calabro, Impagliazzo, Kabanets, & Paturi, 2003). However, this does not exclude the possibility to find good heuristics for instances with such a promise, or to look for other properties that are implied by the existence of unique solutions, that can be exploited in order to improve the search process. In particular, determined and implied values play an important role in this and other classes of problems. As the Factoring example shows, such problems arise frequently in practice, either as subproblems of other CSPs, as in presence of functional dependencies (cf. also Mancini & Cadoli, 2007; Mancini, Cadoli, Micaletto, & Patrizi, 2008, for more examples), or because of intrinsic characteristics of the problem at hand. In general, if a problem has a unique solution, all variables have a determined value.\nAnother central role is played by the removability property, that characterises precisely the case when a value can be safely removed from the domain of a variable, while preserving satisfiability. This property is of course weaker than inconsistency (since some solutions may be lost), but can be safely used in place of it when we are interested in finding only a solution of a CSP, if one exists, and not all of them."
    }, {
      "heading" : "2.2 Preliminaries",
      "text" : "Definition 1 (Constraint Satisfaction Problem (CSP), Dechter, 1992). A Constraint Satisfaction Problem is a triple 〈X,D,C〉 where: • X is a finite set of variables; • D is a finite set of values, representing the domain for each variable; • C is a finite set of constraints {c1, . . . c|C|}, with each of them being of the form ci = ri(Vi), where Vi is a list of k ≤ |X| variables in X (the constraint scope), and ri ⊆ Dk is a k-ary relation over D (the constraint relation). We sometimes will denote the set Vi of variables of constraint ci by var(ci).\nGiven a set of variables V and a domain D, a V -tuple t over D is a mapping which associates a value tx ∈ D to every x ∈ V . Such value is called the x-component of t. Given a V -tuple t and a subset U ⊆ V of its variables, we denote by t|U the restriction of t to U , which has the same value as t on the variables of U and is undefined elsewhere. The explicit assignment of the value a ∈ D to the x-component of a V -tuple t (x ∈ V ) is written t[x := a].\nGiven a CSP 〈X,D,C〉, an X-tuple t satisfies a constraint ci = ri(Vi) ∈ C if t|Vi ∈ ri. We denote by Sol(ci) the set of X-tuples which satisfy ci. The set ⋂ c∈C Sol(c) of X-tuples which satisfy all the constraints is called the solution space, and denoted Sol(C). By solving a CSP we mean to decide whether the set Sol(C) is non-empty and, if so, compute one (or all) the solutions.\nThe set of X-tuples t over D is called the search space and denoted by SD, or simply S if the domain is implicit from the context. The relational operators of selection, projection and complement will be useful: given a V -relation c, a subset U of V and a value a ∈ D, we denote by σx=a(ci) (resp. σx 6=a(ci)) the V -relation which contains the tuples of ci whose value on x is a (resp. is different from a), by πU (ci) the set of restrictions to U of tuples of ci (i.e., the set of U -tuples {t | ∃t′ ∈ ci (t = t′|U )}) and by ci the set of V -tuples {t | t 6∈ ci}.\nNote that σx=a(S) denotes the search space obtained by fixing the value of x to a. For the sake of simplicity, the sets X and C will be considered as globally defined and shall therefore be omitted from the parameters of most definitions; only the search space will be explicitly mentioned.\nExample 2. Consider the CSP 〈X,D,C〉 modeling the 3-coloring problem for the graph in Figure 2. We have that:\n• X = {x1, . . . , x5} is the set of variables (one for each node),\n• D = {R,G,B} is the set of colors, and\n• C is the following finite set of constraints, one for each edge:\nC = {NE(x2, x3), NE(x3, x4), NE(x2, x4), NE(x4, x5)},\nwhere NE (not-equal) is a binary relation defined as\n({R,G,B} × {R,G,B}) \\ {〈R,R〉, 〈G,G〉, 〈B,B〉}."
    }, {
      "heading" : "2.3 Definitions",
      "text" : "In this section, we formally present the properties already introduced in Section 2.1, and show their applicability on some examples.\nDefinition 2. The following properties are defined for a search space S, variables x and y, values a and b, and for a set of variables V :\nfixable(S, x, a) ≡ ∀t ∈ S (t ∈ Sol(C) → t[x := a] ∈ Sol(C))\nsubstitutable(S, x, a, b) ≡ ∀t ∈ S ( tx = a ∧ t ∈ Sol(C) → t[x := b] ∈ Sol(C) )\nremovable(S, x, a) ≡ ∀t ∈ S ( tx = a ∧ t ∈ Sol(C) → ∃b 6= a (t[x := b] ∈ Sol(C)) )\ninconsistent(S, x, a) ≡ ∀t ∈ S ( t ∈ Sol(C) → tx 6= a ) implied(S, x, a) ≡ ∀t ∈ S ( t ∈ Sol(C) → tx = a )\ndetermined(S, x) ≡ ∀t ∈ S ( t ∈ Sol(C) → ∀b 6= tx (t[x := b] 6∈ Sol(C)) )\ndependent(S, V, y) ≡ ∀t, t′ ∈ S  t ∈ Sol(C)∧t′ ∈ Sol(C)∧\n∀x ∈ V (tx = t′x)\n→ ty = t′y \nirrelevant(S, x) ≡ ∀t ∈ S ( t ∈ Sol(C) → ∀a ∈ D (t[x := a] ∈ Sol(C)) )\nAs for interchangeability, it is well-known (Freuder, 1991) that it can be defined in terms of substitutability:\ninterchangeable(S, x, a, b) ≡ substitutable(S, x, a, b) ∧ substitutable(S, x, b, a)\nIn the few cases where an ambiguity arises on the considered set of constraints, we will indicate it using subscript (e.g., irrelevantC (S, x)). Note that all the definitions but the last three are value-oriented, in that they are properties of specific values of the domain. On the contrary, determinacy, irrelevance, and dependence are variable-oriented properties which do not directly express results on particular values of the domains but have important relations with the value-oriented notions (cf. forthcoming Section 2.4).\nAs already claimed in Section 1, some of the properties of Definition 2 are already known, as well as their beneficial effects to search. In particular, the notion of consistency was proposed by Montanari (1974) and Mackworth (1977), and is one of the best-studied notions in CSP. Substitutability and interchangeability were introduced by Freuder (1991). Implied values, which are also known in the literature as backbones, were seemingly first studied explicitly by Monasson, Zecchina, Kirkpatrick, Selman, and Troyansky (1999). To the best of our knowledge, the notions of removable and fixable values (which, as we show in Section 2.4 play a key role in the unifying framework proposed in this paper) have on the contrary not been considered. Determined, irrelevant and dependent variables have been studied in a number of contexts as logic, SAT, and databases, cf., e.g., Beth definability (Chang & Keisler, 1990), don’t care variables in propositional formulae (Thiffault,\nBacchus, & Walsh, 2004; Safarpour, Veneris, Drechsler, & Lee, 2004), and the Audit problem (Jonsson & Krokhin, 2008), but we are aware of little work concerning their application in the context of CSPs.\nThe following examples illustrate some of the properties.\nExample 3 (Example 2 continued). Consider a CSP modeling the coloring problem for the graph in Figure 2. Let Σ denote the search space in which all five variables x1, . . . , x5 have domain {R,G,B}. The following properties hold:\n• fixable(Σ,x1,R), since for every solution t, t[x1 := R] is a solution as well; • substitutable(Σ,x1,R,G), since for every solution t such that tx1 = R, t[x1 := G] is a\nsolution as well;\n• interchangeable(Σ,x1,R,G), from the previous point and the fact that substitutable(Σ,x1,G,R) also holds;\n• removable(Σ,x1,G), because for every solution t such that tx1 = G, there exists a different color K ∈ {R,B} for x1 such that t[x1 := K] is a solution as well; • irrelevant(Σ,x1), because we can actually replace the x1-component of any solution t\nwith any other value, since x1 denotes a disconnected node of the graph.\nThe above properties holding for variable x1 that encodes the disconnected node give some initial suggestions on the relationships that exist among the different notions. As for the other nodes, we have, for example:\n• removable(Σ,x5,G), because for every solution t such that tx5 = G, there exists a different color K ∈ {R,B} for x5 such that t[x5 := K] is a solution as well. This is due to the fact that node 5 is connected only to node 4.\nAs another, more complex, example, consider the following:\nExample 4. Let a CSP be given over boolean variables x, y, z, w, p, q, r, whose constraints are encoded by the formula below:\nx ∧ (x→ y) ∧ ((z ∨ w)↔ p) ∧ ((z ∨ y)↔ (q ∧ r)) Denoting as Ξ the search space in which all variables range over {true, false}, we have, among the others:\n• inconsistent(Ξ,x,false), • fixable(Ξ,x,true), • implied(Ξ,x,true), • implied(Ξ,y,true), • inconsistent(Ξ,y,false),\n• determined(Ξ,y), • dependent(Ξ,{z, w},p), • dependent(Ξ,{z, y},q), • dependent(Ξ,{z, y},r), • fixable(Ξ,q,true),\n• implied(Ξ,q,true), • fixable(Ξ,r,true),\n• implied(Ξ,r,true).\nSome of the definitions of Definition 2 can be used to construct solution-preserving transformations, i.e., mappings which transform solutions into solutions.\nDefinition 3 (solution-preserving transformation). A solution-preserving transformation is a total mapping τ from S to S such that\n∀t ∈ S (t ∈ Sol(C)→ τ(t) ∈ Sol(C))\nTo understand the connection between solution-preserving transformations and the aforementioned properties, consider the following mappings:\nτ1(t) = t[x := a]\nτ2(t) = { t[x := b] if tx = a t otherwise\nτ3(t) =  t[x := b] if tx = a t[x := a] if tx = b t otherwise\nChecking whether value a is fixable for variable x, whether value a is substitutable to value b for variable x, and whether values a and b are interchangeable for variable x amounts to check whether mappings τ1, τ2 and τ3 (respectively) are solution-preserving.\nSolution-preserving transformations are interesting because they allow us to remove values from the search space while preserving the satisfiability of the problem. Moreover, the correspondence between some properties and the existence of particular solution-preserving mappings shows that interesting connections hold among these properties and other concepts, like symmetries. As an example, Mancini and Cadoli (2005) give a logical characterisation of symmetries in problem specifications, which is very similar to, and in fact stronger than, that of Definition 3. In addition, more general forms of solution-preserving transformations could be defined, that, e.g., allow also for the modification of the constraints, i.e., as pairs (τ, σ) such that ∀t ∈ S (t ∈ Sol(C)→ τ(t) ∈ Sol(σ(t, C))). This interesting topic, that may lead to the definition of further and more general properties of a CSP, is left for future research."
    }, {
      "heading" : "2.4 Semantical Relationships",
      "text" : "As already observed (cf. also Examples 3 and 4), several semantical relationships exist among the notions presented in Definition 2, some of which appear weaker, while some others stronger. The main connections are clarified by the following theorem.\nTheorem 1. The relationships shown in Figure 3 hold between the properties of Definition 2.\nProof.\nDependence-determinacy. We have dependent(S, {x1, . . . , xi}, y) iff every solution t has a value on y which is given by a function f of the values it assigns to x1 . . . xi, iff in any search\nspace σx1=a1,...,xi=ai(S) (where all these variables receive a fixed value), all solutions assign the same value f(a1, . . . , an) to y.\nIrrelevance-fixability. t ∈ Sol(C) → ∀a ∈ D (t[x := a] ∈ Sol(C)) rewrites to ∀a ∈ D (t ∈ Sol(C)→ t[x := a] ∈ Sol(C)). Determinacy-implication. If implied(S, x, b) holds for some b, then for each t and a 6= b we have t[x := a] 6∈ Sol(C). Implication-fixability. implied(S, x, b) means that every t ∈ Sol(C) has tx = b. Hence for every t ∈ Sol(C), we have t[x := b] = t ∈ Sol(C). Implication-inconsistency. implied(S, x, a) holds iff ∀t (tx 6= a → t 6∈ Sol(C)), i.e., iff ∀t ∀b ∈ D \\ {a} (tx = b→ t 6∈ Sol(C)). This rewrites to ∀b ∈ D \\ {a} inconsistent(S, x, b). Fixability-substitutability. Let D = {a1, .., ad}. We have ∧ i∈1..d substitutable(S, x, ai, b) iff ∀t ((tx = a1 ∨ · · · ∨ tx = ad) ∧ t ∈ Sol(C) → t[x := b] ∈ Sol(C)), which rewrites to fixable(S, x, b).\nInconsistency-substitutability. Suppose inconsistent(S, x, a) holds. No solution t with tx = a exists, hence the implication tx = a∧ t ∈ Sol(C)→ t[x := b] ∈ Sol(C) is true for all choices of b.\nInconsistency-removability. Same argument as for inconsistency-substitutability.\nSubstitutability-removability. Suppose substitutable(S, x, a, b) holds for some value b 6= a. This can be written ∃b ∀t (tx = a ∧ t ∈ Sol(C) → t[x := b] ∈ Sol(C)), which implies ∀t ∃b(tx = a ∧ t ∈ Sol(C) → t[x := b] ∈ Sol(C)). The latter rewrites to ∀t (tx = a ∧ t ∈ Sol(C)→ ∃b t[x := b] ∈ Sol(C)).\nNote also that implied values and determined variables are strongly related to problems with a unique solution: if a problem has a unique solution, then all its variables have an implied value (cf. Example 1), hence they are determined."
    }, {
      "heading" : "2.5 Exploiting Properties in Constraint Solving",
      "text" : "An important reason why the aforementioned properties are interesting is that, when detected, they allow us to reduce the search space by removing values from the active domains of the variables. In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al., 2004; Safarpour et al., 2004), implication (Monasson et al., 1999), dependence (Mancini & Cadoli, 2007). However, thanks to the unifying framework of Figure 3, we can now show that the wide interest in the aforementioned properties essentially relies in their relations with the two fundamental properties of removability and fixability.\nTheorem 2. Let π be a CSP 〈X,D,C〉. If value a is fixable for variable x ∈ X, then π is satisfiable if and only if the CSP π′ = 〈X,D,C ∪ {x = a}〉 obtained from π by instantiating variable x to value a is satisfiable.\nProof. Assume that π′ is satisfiable. Then there exists a X-tuple t that satisfies all the constraints. Since the constraints of π′ are a superset of those of π, t is also a solution of π.\nAs for the other direction, assume that π is satisfiable. Then there exists a solution t. Since value a if fixable for x, it follows that t[x := a] is a solution as well. t[x := a] satisfies also the additional constraint “x = a” of π′, hence the latter problem is satisfiable as well.\nTheorem 3. Let π be a CSP 〈X,D,C〉. If value a is removable for variable x ∈ X, then π is satisfiable if and only if the CSP π′ = 〈X,D,C ∪ {x 6= a}〉 obtained from π by removing value a from the domain of variable x is satisfiable.\nProof. If π′ is satisfiable, then, by the same arguments of the proof of Theorem 2, π is satisfiable as well.\nAs for the other direction, assume that π is satisfiable. Then there exists a solution t. If tx 6= a, t is of course also a solution of π′. On the other hand, if tx = a, since value a is removable for x in π, it follows that there exists b 6= a such that t[x := b] is a solution as well. t[x := b] satisfies also the additional constraint “x 6= a” of π′, hence the latter problem is also satisfiable.\nThe above results show the key roles played by fixability and removability. They are the ideal properties that should be checked in order to reduce the domain for a variable. The interest in the other notions essentially relies on their relationships with fixability and removability. As an example, an implied value is of interest essentially because it is fixable, an irrelevant variable is of interest essentially because it is fixable to any value of its domain, a substitutable value is of interest essentially because it is removable, etc.\nAlso the interest in inconsistent values relies on the fact that they are removable. However, inconsistency is much stronger that removability, because removing inconsistent values\nguarantees that all solutions (and not only the satisfiability of the problem) are preserved. Hence removability plays exactly the same role of inconsistency in case we do not want to find all solutions of a problem but simply want to find one. In such situations removability is the ideal property to use.\nAs for the other properties, it is worth noting that, although they may appear very strong and unlikely at a first sight, they can still play a precious role when detected dynamically during search. As an example, Thiffault et al. (2004) show that dynamically detecting variables that become irrelevant during search (called don’t care variables in the paper) can greatly speed-up non-CNF SAT solvers, by actually separating problems into independent components."
    }, {
      "heading" : "3. Complexity of reasoning",
      "text" : "In this section we show that the problem of checking whether properties of Definition 2 hold is coNP-complete. Hence, in Section 3.2, we try to determine special cases where checking can be done efficiently (i.e., in polynomial time)."
    }, {
      "heading" : "3.1 Intractability Results",
      "text" : "From now on, we assume that the input is given as a set of constraints C over a set of variables X. We also assume that the problem of checking whether t ∈ Sol(C) is polynomial in the size of the representation of the input. Such properties hold for propositional logic and for CSPs, in the sense of Dechter (1992).\nWe note that the problem of checking whether properties of Definition 2 hold is in coNP, because, for each of them it is possible to find a counter-example by guessing a tuple in S (two, in case of dependency) in non-deterministic polynomial time, and checking, in polynomial time, whether the negation of the subformula between parentheses holds (as for interchangeability, we note that the logical “and” of two properties in coNP is still in coNP). Alternatively, coNP-membership follows observing that succinct certificates exist proving that the various properties do not hold (as an example, a certificate proving that variable x is not fixable to a is a V -tuple t ∈ Sol(C) such that t[x := a] 6∈ Sol(C)). In the rest of this section, proofs are therefore restricted to the coNP-hardness part.\nTheorem 4 (coNP-completeness of properties of Definition 2). Given a CSP, the following tasks are coNP-complete:\n• Checking whether value a is fixable, removable, inconsistent, implied, or determined for variable x ∈ X; • Checking whether value a ∈ D is substitutable to, or interchangeable with value b ∈ D\nfor variable x ∈ X; • Checking whether variable y ∈ X is dependent on variables in a set V ⊆ X; • Checking whether variable x ∈ X is irrelevant.\nProof. To prove that checking such properties is hard for coNP, we reduce a coNP-complete problem, i.e., that of checking that an arbitrary CSP is unsatisfiable, to the problem of\nchecking these properties. In particular, the proofs hold even if the domain is boolean, in which case the CSP can be written as a propositional formula φ, e.g., in CNF. Hence, let φ be an arbitrary propositional formula in CNF over set of variables X, and let x be a variable such that x 6∈ X: the unsatisfiability problem of φ can be reduced into the problem of checking the various properties. Moreover, the semantical relationships defined in Theorem 1 allow to infer in an elegant way hardness results for several properties starting from those of the others.\nIrrelevance. Consider ψ defined as φ ∧ x. ψ is unsatisfiable if and only if φ is unsatisfiable. We now show that φ is unsatisfiable if and only if x is irrelevant in formula ψ. Let us first assume that φ is unsatisfiable. It follows that x is irrelevant in ψ, because ψ has no models. On the other hand, let M be a model of φ. Interpretation M ∪ {x← true} is a model of ψ, while M ∪ {x← false} is not, implying that x is not irrelevant in ψ. Fixability, Substitutability. Results follow from that of irrelevance, combined with the semantical relationships that define irrelevance in terms of fixability, and fixability in terms of substitutability.\nDependence. Consider ψ defined as φ ∧ (x ∨ ¬x). ψ is unsatisfiable if and only if φ is unsatisfiable, and that x is dependent on X in ψ if and only if φ is unsatisfiable.\nDeterminacy. The result follows from that of dependence, combined with the semantical relationship that defines dependence in terms of determinacy.\nImplication. Consider ψ defined as φ ∧ x. Value false is implied for x in ψ if and only if φ is unsatisfiable.\nInconsistency. The result follows from that of implication, combined with the semantical relationship that defines implication in terms of inconsistency.\nRemovability. Consider ψ defined as φ ∧ x. Value true is removable for x in ψ if and only if φ is unsatisfiable.\nFrom the proof of Theorem 4, it can be observed that the intractability of checking each of the properties holds also for binary CSPs (i.e., CSPs in which all constraints relate at most two variables).\nTheorem 5 (coNP-completeness of properties of Definition 2 for binary CSPs). Given a CSP with only binary constraints on a domain of size greater than two, checking the properties of Definition 2 is coNP-complete.\nProof. We give the proof for irrelevance only: the others can be derived similarly. Let Φ = 〈X,D,C〉 be a binary CSP. Consider an arbitrary variable x 6∈ X and let a and b be arbitrary distinct values in D. Let Ψ denote the CSP 〈X ′, D,C ′〉 with X ′ = X∪{x}, and C ′ = C ∪ {x = a}. Ψ is binary and, similarly to the proof of Theorem 4, Φ is unsatisfiable if and only if variable x is irrelevant for Ψ.\nFrom the observation that a CSP encoding of the graph 3-colourability problem can be made using only binary constraints, the thesis follows, since checking unsatisfiability of this problem (which is coNP-hard) can be reduced to checking irrelevance in a binary CSP."
    }, {
      "heading" : "3.2 Tractability Results",
      "text" : "Since detecting any of the properties we are interested in is a computationally hard problem, a natural question is to determine special cases where checking can be done efficiently. To this end, we investigate two approaches: we exhibit syntactical restrictions which make the problem tractable, and we study local relaxations of the definitions which are polynomialtime checkable, and which therefore provide incomplete algorithms for detecting the various properties."
    }, {
      "heading" : "3.2.1 Tractability for Restricted Constraint Languages",
      "text" : "A number of syntactical restrictions to the constraint satisfaction problem are known which make it tractable. For instance, in the case of boolean constraints, i.e., propositional formulae, the satisfiability problem becomes tractable if the instance is expressed using only Horn clauses, only dual Horn clauses (i.e., clauses with at most one negative literal), only clauses of size at most 2, or only affine constraints (i.e., formulae built using XOR). These are known as the Schaefer’s (1978) classes. It is natural to wonder if all the properties identified in Definition 2 are also easy to determine for these classes of formulae. This is indeed the case for most of them, and we give a more general condition under which tractable classes for the consistency property are also tractable for other properties of our framework. We note that a recent paper (Jonsson & Krokhin, 2004) gives a complete characterisation of tractable cases for a related property.\nIn what follows we are interested in classes of CSPs. To this end, we define a constraint language ΓD over domain D to be a finite set of relations (of finite arity) with elements in D, and denote by CSP(ΓD) the set of CSPs of the form 〈X,D,C〉 with every element ci = ri(Vi) ∈ C being such that Vi ⊆ X and ri ∈ ΓD. (We observe that once the constraint language ΓD is fixed, the domain D for all instances of CSP(ΓD) is fixed as well.)\nA constraint language Γ is said to be closed under instantiation (resp. under complementation) if whenever a constraint ci = ri(Vi) is expressible in the language (i.e., ri ∈ Γ), the relation πX\\{x}(σx=a(ci)), a ∈ D (resp. the complementation ci) can be represented by a conjunction of constraints of the language. This means that there exist constraints c′1 = r ′ 1(V ′ 1), . . . , c ′ k = r ′ k(V ′ k), with V ′ j ⊆ X and r′j ∈ Γ for each j, such that πX\\{x}(σx=a(ci)) (resp. ci) is equivalent to c′1∧· · ·∧c′k.2 Well known constraint languages on boolean domains which are closed under instantiation and complementation are those of Horn clauses, dual Horn clauses, 2CNF clauses or affine constraints (since the instantiation or the complement of a Horn /dual Horn/2CNF clause or affine constraint can be expressed as a conjunction of Horn /dual Horn/2CNF clauses or affine constraints).\nTheorem 6. Given a constraint language Γ, if the satisfiability problem CSP(Γ) is tractable and if Γ is closed under instantiation, then the problem of checking determinacy for CSPs in the class CSP(Γ) is tractable as well.\n2. Note that we define closure with respect to complementation with a slightly different non-standard meaning, as the negation of the constraint needs be expressible as a conjunction of constraints. Some definitions impose that it be definable as a single constraint of the language.\nProof. Let us consider an arbitrary instance 〈X,D,C〉 ∈ CSP(Γ). Variable x ∈ X is not determined if and only if there exist two different domain values, a and b ∈ D, such that\nπX\\{x}(σx=a(Sol(C))) ∩ πX\\{x}(σx=b(Sol(C)))\nis not empty, i.e., if and only if one of the CSPs 〈X̂,D, Ĉa,b〉, with:\n• X̂ = X \\ {x}, and • Ĉa,b = {πX\\{x}(σx=a(c)) | c ∈ C} ∪ {πX\\{x}(σx=b(c)) | c ∈ C},\nis satisfiable. If Γ is closed under instantiation, constraints in Ĉa,b can all be written as conjunctions of constraints in Γ. Hence, we have reduced the determinacy-testing problem to solving O(|D|2) instances of CSP(Γ), which is tractable.\nTheorem 7. Given a constraint language Γ, if the satisfiability problem CSP(Γ) is tractable and if Γ is closed under instantiation and complementation, then the problem of checking any property among fixability, substitutability, interchangeability, inconsistency or irrelevance for CSPs in the class CSP(Γ) is tractable as well.\nProof. We start with the substitutability property and note that, given an arbitrary instance 〈X,D,C〉 ∈ CSP(Γ), value a ∈ D is substitutable by b ∈ D for variable x ∈ X if and only if\nπX\\{x}(σx=a(Sol(C))) ⊆ πX\\{x}(σx=b(Sol(C))).\nThis inclusion is false, i.e., substitutability does not hold, if and only if the set\nπX\\{x}(σx=a(Sol(C))) ∩ πX\\{x}(σx=b(Sol(C))) (1)\nis non-empty. Since σx=b(Sol(C)) = σx=b( ⋂ c∈C Sol(c)) = ⋂ c∈C(σx=b(Sol(c))), we have:\nπX\\{x}(σx=b(Sol(C))) = πX\\{x} ( ⋂ c∈C(σx=b(Sol(c))) ) .\nAlthough the projection of an intersection of relations is not equal to the intersection of their projections in general, the latter rewrites to:⋂\nc∈C πX\\{x}(σx=b(Sol(c))).\nThis is due to the fact that we select on x before eliminating it by projection. We only prove the inclusion which does not hold in general: suppose we have t ∈ ⋂c∈C πX\\{x}(σx=b(Sol(c))). This means that ∀c ∈ C, there exists a tuple tc such that tc|X\\{x} = t and tc ∈ σx=b(Sol(c)). It follows that tcx = b and that we have indeed a unique t with tx = b and t\nc|X\\{x} = t which is such that ∀c ∈ C (t ∈ σx=b(Sol(c))), i.e., t ∈ πX\\{x}( ⋂ c∈C(σx=b(Sol(c)))).\nFormula (1) is therefore equivalent to:⋂ c∈C πX\\{x}(σx=a(Sol(c))) ∩ ⋃ c∈C πX\\{x}(σx=b(Sol(c)))\nA solution exists (and therefore substitutability does not hold) if one of the sets⋂ c∈C πX\\{x}(σx=a(Sol(c))) ∩ πX\\{x}(σx=b(Sol(c)))\nobtained for every c ∈ C has a solution. If language Γ is closed under instantiation and complement, we can express the new constraint πX\\{x}(σx=b(Sol(c))) as a conjunction C ′ of constraints in Γ. Each of the sets has a solution iff the CSP 〈X \\{x}, D, {πX\\{x}(σx=a(c)) | c ∈ C} ∪C ′〉 is satisfiable. We have reduced the substitutability testing problem to solving |C| instances of a constraint satisfaction problem whose constraints are all in the language Γ, which is tractable.\nThe results for fixability, interchangeability and irrelevance follow directly, because of the semantical relationships shown in Figure 3. Consistency of value a for variable x can directly be expressed as the satisfiability of πX\\{x}(σx=a(Sol(C))), which can be expressed in Γ, and the proof for implication follows from this result.\nA slightly different closure property is needed for the removability of value a for variable x since it is expressed as πX\\{x}(Sol(C)) ⊆ πX\\{x}(σx 6=a(Sol(C))).\nNevertheless, since on boolean domains a value v is removable if v is substitutable by ¬v, and from the remarks on the closure properties of Schaefer’s classes and the previous theorem, we obtain that:\nCorollary 1. Testing fixability, substitutability, interchangeability, inconsistency, determinacy, irrelevance and removability is tractable for a boolean CSP where constraints are either Horn clauses, dual Horn clauses, clauses of size at most two or affine constraints.\nUnfortunately, we don’t have tractability results for dependence.\nTable below summarizes Theorems 6 and 7, and Corollary 1:\nProperty Polynomial if Γ is Determinacy Tractable and closed under instantiation Fixability, substitutability, interchangeability, inconsistency, irrelevance Tractable and closed under inst. and compl. Removability Boolean Schaefer\nIt is worth noting that conditions become more restrictive when reading the table top-down. Moreover, in all the cases, it can be observed that tractability of the various propertydetection problems derives from tractability of the constraint language Γ. This leads to serious concerns about the practical applicability of such results: if CSP(Γ) is tractable, why worrying for identifying such properties? Actually, preliminary studies show that better results are unlikely to hold: as an example, it can be proven that if the constraint language is intractable, then there is no hope for detecting properties like fixability, irrelevance, substitutability, inconsistency in polynomial time. So these results become of\ninterest, suggesting two main directions of further research: the first is of course that of investigating the practical benefit of detecting such properties in real cases; the second is to exploit sufficient but efficiently evaluable conditions for these properties to hold, that can be regarded as a form of approximate reasoning. One of the most used forms of such kind of reasoning is called local reasoning, which is addressed below."
    }, {
      "heading" : "3.2.2 Tractability Through Locality",
      "text" : "An important class of incomplete criteria to determine in polynomial time whether a complex property holds are those based on local reasoning. This approach has proved extremely successful for consistency (Mackworth, 1977) and interchangeability (Freuder, 1991) (cf. also Choueiry & Noubir, 1998, where a classification of different local forms of interchangeability are studied and classified). We propose in this section a systematic investigation of whether a local approach can be used for value-based properties.\nVerifying a property P (C) of a set of constraints C locally means that we verify the property on a well-chosen number of sub-problems. We must ensure that this approach is sound for the considered property:\nDefinition 4 (soundness of local reasoning). We say that local reasoning on a property P is sound if, for all subsets of constraints C1 ⊆ C, . . . , Ck ⊆ C such that ⋃ i∈1..k Ci = C, we have (depending on the property):( ∧ i∈1..k P (Ci)\n) → P (C) or ( ∨i∈1..k P (Ci) ) → P (C). A typical choice of granularity is to simply consider that each Ci contains one of the constraints of C as is done, for instance, for arc-consistency. On the other extreme, if we take a unique C1 = C, we have a global checking. Between these two extremes, a wide range of intermediate levels can be defined (cf., e.g., Freuder, 1978, 1991).\nExample 5. Consider the CSP 〈X,D,C〉 with X = {x, y, z}, D = {0, 1, 2} and C = {c1, c2, c3}, whose elements are defined as follows:\nx y 0 1 1 2 2 1 2 2\nx z 1 0 1 2 2 0 2 2\ny z 1 1 1 2 2 1 2 2\nc1(x, y) c2(x, z) c3(y, z)\nIt can be observed that value 1 is substitutable to 2 for variable x. In order to check this property locally, we consider a suitable covering C1, . . . , Ck of the set C, and verify it on the induced subproblems. As an example, by taking C1 = {c1}, C2 = {c2}, C3 = {c3}, we have substitutableCi (S, x, 1, 2) for every i ∈ {1, 2, 3}. Since local reasoning is sound for substitutability (cf. Freuder, 1991), we can infer that the global property substitutableC (S, x, 1, 2) holds.\nReasoning locally is typically tractable if we focus on a moderate number of subsets of C, and under the condition that we can bound the complexity of reasoning on each of these\nsubsets. A typical assumption in CSP is that we can bound the arity of the constraints, and that every constraint is for instance binary. In this case, the cost of determining any property of the constraint is polynomial; and if we choose to reason locally by considering each constraint separately, or by taking groups of constraints of bounded size, then local checking is tractable.\nTheorem 8. Local reasoning is sound for the properties of substitutability, interchangeability, fixability, inconsistency, implication, irrelevance, determinacy, dependence. In particular, for any C1 ⊆ C, . . . , Ck ⊆ C such that ⋃ i∈1..k Ci = C:\n• ( ∧i∈1..k substitutableCi (S, x, a, b) )→ substitutableC (S, x, a, b); • ( ∧\ni∈1..k interchangeableCi (S, x, a, b)\n) → interchangeable\nC (S, x, a, b);\n• ( ∧i∈1..k fixableCi (S, x, b) )→ fixableC (S, x, b); • ( ∨i∈1..k inconsistentCi (S, x, a) )→ inconsistentC (S, x, a); • ( ∨\ni∈1..k impliedCi (S, x, a)\n) → implied\nC (S, x, a);\n• ( ∧i∈1..k irrelevantCi (S, x) )→ irrelevantC (S, x); • ( ∨i∈1..k determinedCi (S, x) )→ determinedC (S, x); • ( ∨\ni∈1..k dependentCi (S, V, y)\n) → dependent\nC (S, V, y).\nProof. The result is well-known for consistency (Mackworth, 1977), substitutability and interchangeability (Freuder, 1991). Fixability of variable x to value b can be expressed as\n∀a 6= b (substitutableC (S, x, a, b)) Therefore, if we have ∧ i∈1..k fixableCi (S, x, b) (which is equivalent to ∧ i ∧ a6=b\nsubstitutableCi (S, x, a, b) and to ∧ a6=b ∧\ni substitutableCi (S, x, a, b)), then we have∧ a6=b substitutableC (S, x, a, b), which means fixableC (S, x, b). A similar argument works for irrelevance, which can be analogously defined in terms of fixability (cf. Figure 3). As for implication, if a value a is implied for variable x in any Ci, then all tuples t with tx 6= a violate the constraints of Ci and do a fortiori not belong to Sol(C). Similarly for determinacy: if a variable x is determined in any Ci, then all tuples t ∈ Sol(Ci) will be such that t[x := b] 6∈ Sol(Ci) for any b 6= tx. Hence there cannot be any solution t ∈ Sol(C) such that t[x := b] ∈ Sol(C) with b 6= tx. Finally, as for dependence, if there exists a Ci for which dependent\nCi (S, V, y) holds (it is enough to consider sets of constraints Cis such\nthat V ∩ var(Ci) 6= ∅ and y ∈ var(Ci) for which we have dependentCi (S, V ∩ var(Ci), y)), we have, by definition, that ∀t, t′ ∈ Sol(Ci) (∀x ∈ V ∩ var(Ci) (tx = t′x)) → ty = t′y, and so dependent\nC (S, V, y) also holds, since any solution of the whole problem must satisfy also\nCi.\nExample 6 (Example 5 continued). Value 2 is fixable for z. This can be inferred by performing local reasoning as follows:\n• fixableC1 (S, z, 2) holds, since z does not occur in the scope of c1;\n• fixableC2 (S, z, 2) holds, since for any tuple t that belongs to c2, also t[z := 2] belongs to c2;\n• fixableC3 (S, z, 2) holds, because of the same argument.\nSince by Theorem 8 local reasoning is sound for fixability, we can infer that fixableC (S, z, 2) holds.\nThere is only one (value-based) property, namely removability, for which the local approach is unfortunately not sound:\nTheorem 9. Local reasoning is not sound for the removability property.\nProof. Take C = C1 ∧ C2, where C1 is defined as x ≤ y and C2 as x ≥ y. Suppose the domain has values {1, 2, 3}. Value 2 for x is removable from both constraints considered independently since, in both cases, we can change the value of any solution which assigns 2 to x to another value. Still, value 2 is not removable for x from their conjunction. To see why, consider the solution with 〈x, y〉 = 〈2, 2〉, and observe that neither 〈1, 2〉 or 〈3, 2〉 are solutions.\nNote that removing values which are shown to be removable only locally can even make a satisfiable problem unsatisfiable: if furthermore we add the constraints C3, defined as x 6= 1 and C4, defined as x 6= 3, then value 2 for x is removable in each constraint, while the only (global) solution actually assigns value 2 to x.\nThis result, although negative, is in fact interesting, because it gives an ex-post justification of the extensive use that has been made in the last decades of stronger notions, like inconsistency or substitutability, both of which imply removability (cf. Figure 3). The main reason why current tools and frameworks for CP try to detect these properties is in order to remove values from the active domain of some variables. This naturally relies on the removability property (cf. Section 2.5). However, the reason why removability is not directly used is because it is intractable. For that reason, stronger notions like consistency or substitutability are the forms of removability that have been more commonly used. Actually, unlike full-fledged removability (cf. Theorem 9), these properties can be detected efficiently, but incompletely, through local reasoning. Hence, this raises an interesting open issue: do there exist new (i.e., other than substitutability and inconsistency) properties for which local reasoning is sound and which imply removability?\nWe end this section by noting that the local version of the fixability property is indeed a generalisation to arbitrary domains of the pure literal rule (Davis & Putnam, 1960) which is well-known in the case of boolean constraints in conjunctive normal form. The pure literal rule exploits the cases where no constraint (clause) of the problem has a positive (resp. negative) occurrence of some variable x. In this case, assigning value 0 (resp. 1) to x preserves the satisfiability of the problem: if a solution t with tx = 1 exists, then t[x := 0] will also be a solution since no clause constrains x to have value 1.\nExample 7. Consider the following propositional formula ϕ in CNF:\n(x ∨ y ∨ z) ∧ (x ∨ ¬y ∨ ¬z) ∧ (y ∨ ¬z)\nSince ¬x does not occur in any clause, we can assign x to 1, and maintain the satisfiability of the formula: for any solution t of ϕ, the assignment t[x := 1] is a solution of ϕ as well.\nIt is clear that the pure literal rule detects fixability based on a reasoning local to each clause (a variable x is fixable to, say, 1 in a clause iff this clause does not contain the literal ¬x, and the pure literal rule checks that this condition holds for every constraint).\nNo generalisation of the pure literal rule has, to the best of our knowledge, been proposed for CSP, while a generalisation of the pure literal rule for QBF has been applied to solvers for Quantified CSP under the name pure value rule (Gent, Nightingale, & Stergiou, 2005). It can be observed that such proposal is in fact a local relaxation of the generalisation to quantified constraints of fixability. As will be shortly discussed in Section 4, all the properties presented in this paper can be generalized to Quantified CSP in an elegant way, and many local relaxations remain valid."
    }, {
      "heading" : "4. Conclusions and Perspectives",
      "text" : "In this paper we reconsidered most of the structural properties of CSPs extensively studied and exploited in order to simplify search. Such properties may be of course useful also in other tasks, e.g., for the classification or update of solutions, or for compacting the solution space, and for supporting explanation and interaction with users.\nWe provided a unifying framework for the properties, that clarifies their semantical relationships and allows new ones to emerge. We argued that some of the new notions, namely fixability and removability play a key role in a deep understanding of the topic, being the ideal characterisations of values that can be fixed or removed preserving the satisfiability of the problem. Known properties, like inconsistency and substitutability are thus suitable specialisations of them.\nWe then tackled the questions related to the automated detection of the different properties and of their exploitation by the solving engine for simplifying problems. In particular, we showed how detecting each of the proposed properties is in general as hard as the original CSP. Hence, in order to find efficient ways for their verification, we investigated, according to the CSP approach, two main lines: addition of suitable restrictions of the constraint language and approximation of the reasoning task by exploiting local versions of the various notions. Moreover, we discussed how in some cases such properties may arise from explicit promises made by users. This is the case of problems with properties such as functional dependencies and unique solutions.\nTwo of the perspectives raised by our work concern the new central properties which have emerged from it. We have identified the removability property as an ideal characterisation of the values which can be removed while preserving satisfiability. Unfortunately, negative results (coNP-completeness of the detection of this property and impossibility of local reasoning) make it impossible to directly use the removability property in practice. This gives an ex-post justification for the extensive use that has been made in the last decades of stronger notions (like inconsistency or substitutability) which imply removability, yet can be\nchecked by tractable means (of course at the price of losing completeness). An interesting problem is thus to determine new cases where removability-checking is tractable.\nAlso, the benefits of fixability have long been known in the boolean case, since this property has been used in the form of the pure literal rule in many SAT solvers. However, no generalisation of this property to CSPs has been considered so far.\nFinally, the proposed framework allows a natural and elegant generalisation to the case of Quantified CSP. In particular, in related work (Bordeaux, Cadoli, & Mancini, 2008) we propose the new notion of outcome as the natural counterpart at the quantified level of the concept of solution of a CSP. With such notion in mind, all the properties studied in this paper can be straightforwardly restated for Quantified CSP, as well as their local relaxations, and new, even more general concepts emerge (the so-called shallow properties, that may have an impact also at the pure existential –CSP– level). This opens important new horizons, allowing QCSP solvers to perform a smarter reasoning on the input problem, by taking into proper account the quantifiers prefix, that today is usually ignored."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This paper is an extended and revised version of Bordeaux, Cadoli, and Mancini (2004)."
    } ],
    "references" : [ {
      "title" : "Exploiting fixable, substitutable and determined values in constraint satisfaction problems",
      "author" : [ "L. Bordeaux", "M. Cadoli", "T. Mancini" ],
      "venue" : "Proceedings of the Eleventh International Conference on Logic for Programming and Automated Reasoning (LPAR 2004),",
      "citeRegEx" : "Bordeaux et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Bordeaux et al\\.",
      "year" : 2004
    }, {
      "title" : "Generalizing consistency and other constraint properties to quantified constraints",
      "author" : [ "L. Bordeaux", "M. Cadoli", "T. Mancini" ],
      "venue" : "ACM Transactions on Computational Logic. To appear",
      "citeRegEx" : "Bordeaux et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Bordeaux et al\\.",
      "year" : 2008
    }, {
      "title" : "Using a theorem prover for reasoning on constraint problems",
      "author" : [ "M. Cadoli", "T. Mancini" ],
      "venue" : "Applied Artificial Intelligence,",
      "citeRegEx" : "Cadoli and Mancini,? \\Q2007\\E",
      "shortCiteRegEx" : "Cadoli and Mancini",
      "year" : 2007
    }, {
      "title" : "The complexity of Unique k-SAT: An isolation lemma for k-CNFs",
      "author" : [ "C. Calabro", "R. Impagliazzo", "V. Kabanets", "R. Paturi" ],
      "venue" : "In Proceedings of the Eighteenth IEEE Conference on Computational Complexity (CCC 2003),",
      "citeRegEx" : "Calabro et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Calabro et al\\.",
      "year" : 2003
    }, {
      "title" : "On the computation of local interchangeability in Discrete Constraint Satisfaction Problems",
      "author" : [ "B.Y. Choueiry", "G. Noubir" ],
      "venue" : "In Proceedings of the Fifteenth National Conference on Artificial Intelligence",
      "citeRegEx" : "Choueiry and Noubir,? \\Q1998\\E",
      "shortCiteRegEx" : "Choueiry and Noubir",
      "year" : 1998
    }, {
      "title" : "A theoretical analysis of reasoning by symmetry in first-order logic (extended abstract)",
      "author" : [ "J.M. Crawford" ],
      "venue" : "Proceedings of Workshop on Tractable Reasoning, in conjunction with the Tenth National Conference on Artificial Intelligence (AAAI’92), San Jose, CA, USA.",
      "citeRegEx" : "Crawford,? 1992",
      "shortCiteRegEx" : "Crawford",
      "year" : 1992
    }, {
      "title" : "Symmetry-breaking predicates for search problems",
      "author" : [ "J.M. Crawford", "M.L. Ginsberg", "E.M. Luks", "A. Roy" ],
      "venue" : "In Proceedings of the Fifth International Conference on the Principles of Knowledge Representation and Reasoning",
      "citeRegEx" : "Crawford et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Crawford et al\\.",
      "year" : 1996
    }, {
      "title" : "A computing procedure for Quantification Theory",
      "author" : [ "M. Davis", "H. Putnam" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "Davis and Putnam,? \\Q1960\\E",
      "shortCiteRegEx" : "Davis and Putnam",
      "year" : 1960
    }, {
      "title" : "Constraint networks (survey)",
      "author" : [ "R. Dechter" ],
      "venue" : "Encyclopedia of Artificial Intelligence, 2nd edition, pp. 276–285. John Wiley & Sons.",
      "citeRegEx" : "Dechter,? 1992",
      "shortCiteRegEx" : "Dechter",
      "year" : 1992
    }, {
      "title" : "The complexity of promise problems with applications to public-key cryptography",
      "author" : [ "S. Even", "A. Selman", "Y. Yacobi" ],
      "venue" : "Information and Control,",
      "citeRegEx" : "Even et al\\.,? \\Q1984\\E",
      "shortCiteRegEx" : "Even et al\\.",
      "year" : 1984
    }, {
      "title" : "Synthesizing constraint expressions",
      "author" : [ "E.C. Freuder" ],
      "venue" : "Communications of the ACM, 21 (11), 958–966.",
      "citeRegEx" : "Freuder,? 1978",
      "shortCiteRegEx" : "Freuder",
      "year" : 1978
    }, {
      "title" : "Eliminating interchangeable values in Constraint Satisfaction Problems",
      "author" : [ "E.C. Freuder" ],
      "venue" : "Proceedings of the Ninth National Conference on Artificial Intelligence (AAAI’91), pp. 227–233, Anaheim, CA, USA. AAAI Press/The MIT Press.",
      "citeRegEx" : "Freuder,? 1991",
      "shortCiteRegEx" : "Freuder",
      "year" : 1991
    }, {
      "title" : "Symmetry breaking during search in constraint programming",
      "author" : [ "I.P. Gent", "B. Smith" ],
      "venue" : "In Proceedings of the Fourteenth European Conference on Artificial Intelligence (ECAI",
      "citeRegEx" : "Gent and Smith,? \\Q2000\\E",
      "shortCiteRegEx" : "Gent and Smith",
      "year" : 2000
    }, {
      "title" : "QCSP-Solve: A solver for Quantified Constraint Satisfaction Problems",
      "author" : [ "I. Gent", "P. Nightingale", "K. Stergiou" ],
      "venue" : "In Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Gent et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Gent et al\\.",
      "year" : 2005
    }, {
      "title" : "Act, and the rest will follow: Exploiting determinism in planning as satisfiability",
      "author" : [ "E. Giunchiglia", "A. Massarotto", "R. Sebastiani" ],
      "venue" : "In Proceedings of the Fifteenth National Conference on Artificial Intelligence",
      "citeRegEx" : "Giunchiglia et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Giunchiglia et al\\.",
      "year" : 1998
    }, {
      "title" : "Recognizing frozen variables in constraint satisfaction problems",
      "author" : [ "P. Jonsson", "A. Krokhin" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "Jonsson and Krokhin,? \\Q2004\\E",
      "shortCiteRegEx" : "Jonsson and Krokhin",
      "year" : 2004
    }, {
      "title" : "Computational complexity of auditing discrete attributes in statistical databases",
      "author" : [ "P. Jonsson", "A. Krokhin" ],
      "venue" : "Journal of Computer and System Sciences",
      "citeRegEx" : "Jonsson and Krokhin,? \\Q2008\\E",
      "shortCiteRegEx" : "Jonsson and Krokhin",
      "year" : 2008
    }, {
      "title" : "The graph isomorphism problem: its computational complexity",
      "author" : [ "J. Köbler", "U. Schöning", "J. Torán" ],
      "venue" : null,
      "citeRegEx" : "Köbler et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Köbler et al\\.",
      "year" : 1993
    }, {
      "title" : "Interchangeability and dynamic bundling for non-binary finite CSPs",
      "author" : [ "A. Lal", "B. Choueiry", "E.C. Freuder" ],
      "venue" : "In Proceedings of the Twentieth National Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "Lal et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Lal et al\\.",
      "year" : 2005
    }, {
      "title" : "Algorithms in number theory",
      "author" : [ "A. Lenstra", "H.W. Lenstra" ],
      "venue" : "The Handbook of Theoretical Computer Science,",
      "citeRegEx" : "Lenstra and Lenstra,? \\Q1990\\E",
      "shortCiteRegEx" : "Lenstra and Lenstra",
      "year" : 1990
    }, {
      "title" : "Integrating equivalency reasoning into Davis-Putnam procedure",
      "author" : [ "C.M. Li" ],
      "venue" : "Proceedings of the Seventeenth National Conference on Artificial Intelligence (AAAI 2000), pp. 291–296, Austin, TX, USA. AAAI Press/The MIT Press.",
      "citeRegEx" : "Li,? 2000",
      "shortCiteRegEx" : "Li",
      "year" : 2000
    }, {
      "title" : "Consistency in networks of relations",
      "author" : [ "A.K. Mackworth" ],
      "venue" : "Artificial Intelligence, 8, 99–118.",
      "citeRegEx" : "Mackworth,? 1977",
      "shortCiteRegEx" : "Mackworth",
      "year" : 1977
    }, {
      "title" : "Detecting and breaking symmetries by reasoning on problem specifications",
      "author" : [ "T. Mancini", "M. Cadoli" ],
      "venue" : "In Proceedings of the Sixth International Symposium on Abstraction, Reformulation and Approximation (SARA 2005),",
      "citeRegEx" : "Mancini and Cadoli,? \\Q2005\\E",
      "shortCiteRegEx" : "Mancini and Cadoli",
      "year" : 2005
    }, {
      "title" : "Exploiting functional dependencies in declarative problem specifications",
      "author" : [ "T. Mancini", "M. Cadoli" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Mancini and Cadoli,? \\Q2007\\E",
      "shortCiteRegEx" : "Mancini and Cadoli",
      "year" : 2007
    }, {
      "title" : "Evaluating ASP and commercial solvers on the CSPLib",
      "author" : [ "T. Mancini", "M. Cadoli", "D. Micaletto", "F. Patrizi" ],
      "venue" : null,
      "citeRegEx" : "Mancini et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Mancini et al\\.",
      "year" : 2008
    }, {
      "title" : "Determining computational complexity from characteristic phase transitions",
      "author" : [ "R. Monasson", "R. Zecchina", "S. Kirkpatrick", "B. Selman", "L. Troyansky" ],
      "venue" : null,
      "citeRegEx" : "Monasson et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Monasson et al\\.",
      "year" : 1999
    }, {
      "title" : "Networks of constraints: Fundamental properties and applications to picture processing",
      "author" : [ "U. Montanari" ],
      "venue" : "Information Sciences, 7 (2), 85–132.",
      "citeRegEx" : "Montanari,? 1974",
      "shortCiteRegEx" : "Montanari",
      "year" : 1974
    }, {
      "title" : "Computational Complexity",
      "author" : [ "C.H. Papadimitriou" ],
      "venue" : "Addison Wesley Publishing Company, Reading, Massachussetts, Reading, MA.",
      "citeRegEx" : "Papadimitriou,? 1994",
      "shortCiteRegEx" : "Papadimitriou",
      "year" : 1994
    }, {
      "title" : "Factoring benchmarks for SAT solvers",
      "author" : [ "T. Pyhälä" ],
      "venue" : "Tech. rep., Helsinki university of technology.",
      "citeRegEx" : "Pyhälä,? 2004",
      "shortCiteRegEx" : "Pyhälä",
      "year" : 2004
    }, {
      "title" : "Managing don’t cares in Boolean Satisfiability",
      "author" : [ "S. Safarpour", "A. Veneris", "R. Drechsler", "J. Lee" ],
      "venue" : "In Proceedings of Design Automation and Test Conference in Europe (DATE",
      "citeRegEx" : "Safarpour et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Safarpour et al\\.",
      "year" : 2004
    }, {
      "title" : "The complexity of satisfiability problems",
      "author" : [ "T.J. Schaefer" ],
      "venue" : "Proceedings of the Tenth ACM Symposium on Theory of Computing (STOC’78), pp. 216–226, San Diego, CA, USA. ACM Press.",
      "citeRegEx" : "Schaefer,? 1978",
      "shortCiteRegEx" : "Schaefer",
      "year" : 1978
    }, {
      "title" : "Solving non-clausal formulas with DPLL search",
      "author" : [ "C. Thiffault", "F. Bacchus", "T. Walsh" ],
      "venue" : "In Proceedings of the Tenth International Conference on Principles and Practice of Constraint Programming (CP 2004),",
      "citeRegEx" : "Thiffault et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Thiffault et al\\.",
      "year" : 2004
    }, {
      "title" : "NP is as easy as detecting unique solutions",
      "author" : [ "L.G. Valiant", "V.V. Vijay V. Vazirani" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "Valiant and Vazirani,? \\Q1986\\E",
      "shortCiteRegEx" : "Valiant and Vazirani",
      "year" : 1986
    } ],
    "referenceMentions" : [ {
      "referenceID" : 20,
      "context" : "Journal of Artificial Intelligence Research 32 (2008) 607–629 Submitted 01/08; published 06/08",
      "startOffset" : 27,
      "endOffset" : 54
    }, {
      "referenceID" : 21,
      "context" : "Good examples are value inconsistency (Mackworth, 1977; Montanari, 1974), substitutability and interchangeability (Freuder, 1991), more general",
      "startOffset" : 38,
      "endOffset" : 72
    }, {
      "referenceID" : 26,
      "context" : "Good examples are value inconsistency (Mackworth, 1977; Montanari, 1974), substitutability and interchangeability (Freuder, 1991), more general",
      "startOffset" : 38,
      "endOffset" : 72
    }, {
      "referenceID" : 11,
      "context" : "Good examples are value inconsistency (Mackworth, 1977; Montanari, 1974), substitutability and interchangeability (Freuder, 1991), more general",
      "startOffset" : 114,
      "endOffset" : 129
    }, {
      "referenceID" : 20,
      "context" : "forms of symmetries (Crawford, Ginsberg, Luks, & Roy, 1996; Gent & Smith, 2000), and functional dependencies among variables (Li, 2000; Mancini & Cadoli, 2007).",
      "startOffset" : 125,
      "endOffset" : 159
    }, {
      "referenceID" : 11,
      "context" : "Value a is said to be interchangeable with value b for variable x if every solution which assigns a to x remains a solution if x is changed to b, and vice versa (Freuder, 1991).",
      "startOffset" : 161,
      "endOffset" : 176
    }, {
      "referenceID" : 5,
      "context" : "Analogously, detecting some other forms of symmetry reduces to the graph automorphism problem (Crawford, 1992) (for which there is no known polynomial time algorithm, even if there is evidence that it is not NP-complete, Köbler, Schöning, & Torán, 1993).",
      "startOffset" : 94,
      "endOffset" : 110
    }, {
      "referenceID" : 5,
      "context" : "forms of symmetries (Crawford, Ginsberg, Luks, & Roy, 1996; Gent & Smith, 2000), and functional dependencies among variables (Li, 2000; Mancini & Cadoli, 2007). Unfortunately, checking whether such properties hold, is (or is thought to be) often computationally hard. As an example, let us consider interchangeability. Value a is said to be interchangeable with value b for variable x if every solution which assigns a to x remains a solution if x is changed to b, and vice versa (Freuder, 1991). The problem of checking interchangeability is coNP-complete (cf. Proposition 4). Analogously, detecting some other forms of symmetry reduces to the graph automorphism problem (Crawford, 1992) (for which there is no known polynomial time algorithm, even if there is evidence that it is not NP-complete, Köbler, Schöning, & Torán, 1993). To this end, in order to allow general algorithms to exploit such properties efficiently, different approaches can be followed. First of all, syntactic restrictions on the constraint languages can be enforced, in order to allow the efficient verification of the properties of interest. Alternatively, “local” versions of such properties can be defined, that can be used to infer their global counterparts, and that can be verified in polynomial time. As an instance of this “local reasoning” approach, instead of checking whether a value is fully interchangeable for a variable, Freuder (1991) proposes to check whether that value is neighbourhood, or k-interchangeable.",
      "startOffset" : 21,
      "endOffset" : 1427
    }, {
      "referenceID" : 28,
      "context" : "Example 1 (Factoring, Lenstra & Lenstra, 1990; Pyhälä, 2004).",
      "startOffset" : 10,
      "endOffset" : 60
    }, {
      "referenceID" : 11,
      "context" : "As for interchangeability, it is well-known (Freuder, 1991) that it can be defined in terms of substitutability: interchangeable(S, x, a, b) ≡ substitutable(S, x, a, b) ∧ substitutable(S, x, b, a)",
      "startOffset" : 44,
      "endOffset" : 59
    }, {
      "referenceID" : 22,
      "context" : "In particular, the notion of consistency was proposed by Montanari (1974) and Mackworth (1977), and is one of the best-studied notions in CSP.",
      "startOffset" : 57,
      "endOffset" : 74
    }, {
      "referenceID" : 18,
      "context" : "In particular, the notion of consistency was proposed by Montanari (1974) and Mackworth (1977), and is one of the best-studied notions in CSP.",
      "startOffset" : 78,
      "endOffset" : 95
    }, {
      "referenceID" : 10,
      "context" : "Substitutability and interchangeability were introduced by Freuder (1991). Implied values, which are also known in the literature as backbones, were seemingly first studied explicitly by Monasson, Zecchina, Kirkpatrick, Selman, and Troyansky (1999).",
      "startOffset" : 59,
      "endOffset" : 74
    }, {
      "referenceID" : 10,
      "context" : "Substitutability and interchangeability were introduced by Freuder (1991). Implied values, which are also known in the literature as backbones, were seemingly first studied explicitly by Monasson, Zecchina, Kirkpatrick, Selman, and Troyansky (1999). To the best of our knowledge, the notions of removable and fixable values (which, as we show in Section 2.",
      "startOffset" : 59,
      "endOffset" : 249
    }, {
      "referenceID" : 20,
      "context" : "Solution-preserving transformations are interesting because they allow us to remove values from the search space while preserving the satisfiability of the problem. Moreover, the correspondence between some properties and the existence of particular solution-preserving mappings shows that interesting connections hold among these properties and other concepts, like symmetries. As an example, Mancini and Cadoli (2005) give a logical characterisation of symmetries in problem specifications, which is very similar to, and in fact stronger than, that of Definition 3.",
      "startOffset" : 144,
      "endOffset" : 420
    }, {
      "referenceID" : 26,
      "context" : "In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al.",
      "startOffset" : 104,
      "endOffset" : 138
    }, {
      "referenceID" : 21,
      "context" : "In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al.",
      "startOffset" : 104,
      "endOffset" : 138
    }, {
      "referenceID" : 11,
      "context" : "In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al.",
      "startOffset" : 157,
      "endOffset" : 172
    }, {
      "referenceID" : 31,
      "context" : "In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al., 2004; Safarpour et al., 2004), implication (Monasson et al.",
      "startOffset" : 186,
      "endOffset" : 234
    }, {
      "referenceID" : 29,
      "context" : "In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al., 2004; Safarpour et al., 2004), implication (Monasson et al.",
      "startOffset" : 186,
      "endOffset" : 234
    }, {
      "referenceID" : 25,
      "context" : ", 2004), implication (Monasson et al., 1999), dependence (Mancini & Cadoli, 2007).",
      "startOffset" : 21,
      "endOffset" : 44
    }, {
      "referenceID" : 20,
      "context" : "guarantees that all solutions (and not only the satisfiability of the problem) are preserved. Hence removability plays exactly the same role of inconsistency in case we do not want to find all solutions of a problem but simply want to find one. In such situations removability is the ideal property to use. As for the other properties, it is worth noting that, although they may appear very strong and unlikely at a first sight, they can still play a precious role when detected dynamically during search. As an example, Thiffault et al. (2004) show that dynamically detecting variables that become irrelevant during search (called don’t care variables in the paper) can greatly speed-up non-CNF SAT solvers, by actually separating problems into independent components.",
      "startOffset" : 58,
      "endOffset" : 545
    }, {
      "referenceID" : 8,
      "context" : "Such properties hold for propositional logic and for CSPs, in the sense of Dechter (1992). We note that the problem of checking whether properties of Definition 2 hold is in coNP, because, for each of them it is possible to find a counter-example by guessing a tuple in S (two, in case of dependency) in non-deterministic polynomial time, and checking, in polynomial time, whether the negation of the subformula between parentheses holds (as for interchangeability, we note that the logical “and” of two properties in coNP is still in coNP).",
      "startOffset" : 75,
      "endOffset" : 90
    }, {
      "referenceID" : 20,
      "context" : ", propositional formulae, the satisfiability problem becomes tractable if the instance is expressed using only Horn clauses, only dual Horn clauses (i.e., clauses with at most one negative literal), only clauses of size at most 2, or only affine constraints (i.e., formulae built using XOR). These are known as the Schaefer’s (1978) classes.",
      "startOffset" : 40,
      "endOffset" : 333
    }, {
      "referenceID" : 21,
      "context" : "This approach has proved extremely successful for consistency (Mackworth, 1977) and interchangeability (Freuder, 1991) (cf.",
      "startOffset" : 62,
      "endOffset" : 79
    }, {
      "referenceID" : 11,
      "context" : "This approach has proved extremely successful for consistency (Mackworth, 1977) and interchangeability (Freuder, 1991) (cf.",
      "startOffset" : 103,
      "endOffset" : 118
    }, {
      "referenceID" : 21,
      "context" : "The result is well-known for consistency (Mackworth, 1977), substitutability and interchangeability (Freuder, 1991).",
      "startOffset" : 41,
      "endOffset" : 58
    }, {
      "referenceID" : 11,
      "context" : "The result is well-known for consistency (Mackworth, 1977), substitutability and interchangeability (Freuder, 1991).",
      "startOffset" : 100,
      "endOffset" : 115
    }, {
      "referenceID" : 20,
      "context" : "This paper is an extended and revised version of Bordeaux, Cadoli, and Mancini (2004).",
      "startOffset" : 63,
      "endOffset" : 86
    } ],
    "year" : 2008,
    "abstractText" : "Literature on Constraint Satisfaction exhibits the definition of several “structural” properties that can be possessed by CSPs, like (in)consistency, substitutability or interchangeability. Current tools for constraint solving typically detect such properties efficiently by means of incomplete yet effective algorithms, and use them to reduce the search space and boost search. In this paper, we provide a unifying framework encompassing most of the properties known so far, both in CSP and other fields’ literature, and shed light on the semantical relationships among them. This gives a unified and comprehensive view of the topic, allows new, unknown, properties to emerge, and clarifies the computational complexity of the various detection problems. In particular, among the others, two new concepts, fixability and removability emerge, that come out to be the ideal characterisations of values that may be safely assigned or removed from a variable’s domain, while preserving problem satisfiability. These two notions subsume a large number of known properties, including inconsistency, substitutability and others. Because of the computational intractability of all the property-detection problems, by following the CSP approach we then determine a number of relaxations which provide sufficient conditions for their tractability. In particular, we exploit forms of language restrictions and local reasoning.",
    "creator" : "TeX"
  }
}