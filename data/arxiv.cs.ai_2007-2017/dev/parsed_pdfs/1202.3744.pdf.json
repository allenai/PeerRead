{
  "name" : "1202.3744.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Improving the Scalability of Optimal Bayesian Network Learning with External-Memory Frontier Breadth-First Branch and Bound Search",
    "authors" : [ "Brandon Malone" ],
    "emails" : [ "bm542@msstate.edu,", "bridgess}@cse.msstate.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Previous work has shown that the problem of learning the optimal structure of a Bayesian network can be formulated as a shortest path finding problem in a graph and solved using A* search. In this paper, we improve the scalability of this approach by developing a memoryefficient heuristic search algorithm for learning the structure of a Bayesian network. Instead of using A*, we propose a frontier breadth-first branch and bound search that leverages the layered structure of the search graph of this problem so that no more than two layers of the graph, plus solution reconstruction information, need to be stored in memory at a time. To further improve scalability, the algorithm stores most of the graph in external memory, such as hard disk, when it does not fit in RAM. Experimental results show that the resulting algorithm solves significantly larger problems than the current state of the art."
    }, {
      "heading" : "1 INTRODUCTION",
      "text" : "Bayesian networks are a common machine learning technique used to represent relationships among variables in data sets. When these relationships are not known a priori, the structure of the network must be learned. A common learning approach entails searching for a structure which optimizes a particular scoring function (Cooper and Herskovits 1992; Heckerman, Geiger, and Chickering 1995). Because of the difficulty of the problem, early approaches focused on approximation techniques to learn “good” networks (Cooper and Herskovits 1992; Heckerman, Geiger, and Chickering 1995; Heckerman 1998; Friedman, Nachman, and Peer 1999; Tsamardinos, Brown, and Aliferis 2006). Unfortunately, these algorithms are unable to guarantee anything about the quality of the learned networks.\nExact dynamic programming algorithms have been developed to learn provably optimal Bayesian network struc-\ntures (Ott, Imoto, and Miyano 2004; Koivisto and Sood 2004; Singh and Moore 2005; Silander and Myllymaki 2006). These algorithms identify optimal small subnetworks and add optimal leaves to find large optimal networks until finding the optimal network including all variables. Unfortunately, all of these algorithms must store an exponential number of subnetworks and associated information in memory. Parviainen and Koivisto (2009) recently proposed a divide-and-conquer algorithm in which fewer subnetworks are stored in memory at once at the expense of longer running time. Theoretical results suggest that this algorithm is slower than dynamic programming when an exponential number of processors is not available.\nYuan et al. (2011) developed an A* heuristic search formulation based on the dynamic programming recurrences to learn optimal network structures. The algorithm formulates the learning problem as a shortest-path finding problem in a search graph. Each path in the graph corresponds to an ordering of the variables, and each edge on the path has a cost that corresponds to the choice of an optimal parent set for one variable out of the variables that appear earlier on the path. Together, all the edges on a path encode an optimal directed acyclic graph that is consistent with the path. The solution to the shortest-path finding problem then corresponds to an optimal Bayesian network structure. The A* algorithm also uses a consistent heuristic function to prune provably suboptimal solutions during the search so as to improve its efficiency.\nde Campos et al. (2009) proposed a systematic search algorithm to identify optimal network structures. The algorithm begins by calculating optimal parent sets for all variables. These sets are represented as a directed graph that may have cycles. Cycles are then repeatedly broken by removing one edge at a time. The algorithm terminates with an optimal Bayesian network. However, this algorithm is shown to often learn the optimal structure slower than the dynamic programming algorithm (de Campos, Zeng, and Ji 2009).\nOptimal networks have also been learned using linear programming (Jaakkola et al. 2010). This technique reformu-\nlates the structure learning problem as a linear program. An exponential number of constraints are used to define a convex hull in which each vertex corresponds to a DAG. Coordinate descent is used to identify the vertex which corresponds to the optimal DAG structure. Furthermore, the dual of their formulation provides an upper bound which can help guide the descent algorithm. This algorithm was shown to have similar or slightly better runtime performance as dynamic programming (Jaakkola et al. 2010).\nThis paper describes a novel frontier breadth-first branch and bound algorithm using delayed duplicate detection for learning optimal Bayesian network structures. The basic idea is to formulate the learning task as a graph search problem. The search graph decomposes into natural layers and allows searching one layer at a time. This algorithm improves the scalability of learning optimal Bayesian network structures in three ways. First, the frontier search approach allows us to reduce the memory complexity by working with only a single layer of search graphs at a time during the search. In particular, we store one layer of each search graph, the scores required for that layer and information for solution reconstruction from every previous layer. Other information is deleted. In comparison, previous dynamic programming algorithms have to store an entire exponentiallysized graph in memory. Second, branch and bound techniques allow us to safely prune unpromising search nodes from the search graphs, while dynamic programming algorithms have to evaluate the whole search space. Finally, we use a delayed duplicate detection method to ensure that, given enough hard disk space, optimal network structures can be learned regardless of the amount of RAM. Previous algorithms fail if an exponential amount of RAM is not available.\nThe remainder of this paper is structured as follows. Section 2 provides an overview of the task of Bayesian network learning. Section 3 and 4 introduce two formulations for solving the learning task: dynamic programming and graph search. Section 5 discusses the details of the externalmemory frontier breadth-first branch and bound algorithm we propose in this paper. Section 6 compares the algorithm against several existing approaches on a set of benchmark machine learning datasets. Finally, Section 7 concludes the paper."
    }, {
      "heading" : "2 BACKGROUND",
      "text" : "A Bayesian network consists of a directed acyclic graph (DAG) structure and a set of parameters. The vertices of the graph each correspond to a random variable V = {X1, ..., Xn}. All parents of Xi are referred to as PAi. A variable is conditionally independent of its non-descendants given its parents. The parameters of the network specify a conditional probability distribution, P (Xi|PAi) for each Xi.\nGiven a dataset D = {D1, ..., DN}, where Di is an instantiation of all the variables in V, the optimal structure is the DAG over all of the variables which best fits D (Heckerman 1998). A scoring function measures the fit of a network structure to D. For example, the minimum description length (MDL) scoring function (Rissanen 1978) uses one term to reward structures with low entropy and another to penalize complex structures. Optimal structures minimize the score. Let ri be the number of states of the variable Xi, let Npai be the number of data records consistent with PAi = pai, and let Nxi,pai be the number of data records consistent with PAi = pai and Xi = xi. The MDL score for a structure G is defined as follows (Tian 2000),\nMDL(G) = ∑\ni\nMDL(Xi|PAi), (1)\nwhere\nMDL(Xi|PAi) = H(Xi|PAi) + logN\n2 K(Xi|PAi),\nH(Xi|PAi) = − ∑\nxi,pai\nNxi,pai log Nxi,pai Npai , (2)\nK(Xi|PAi) = (ri − 1) ∏\nXl∈PAi\nrl.\nMDL is decomposable (Heckerman 1998), so the score for a structure is simply the sum of the score for each variable. Our algorithm can be adapted to use any decomposable function. Some sets of parents cannot form an optimal parent for any variable, as described in the following theorems from Tian (2000) and de Campos et al. (2009).\nTheorem 1. In an optimal Bayesian network based on the MDL scoring function, each variable has at most log( 2NlogN ) parents, where N is the number of data points.\nTheorem 2. Let U ⊂ V and X /∈ U. If BestMDL(X,U) < BestMDL(X,V),V cannot be the optimal parent set for X ."
    }, {
      "heading" : "3 DYNAMIC PROGRAMMING",
      "text" : "Learning an optimal Bayesian network structure is NPHard (Chickering 1996). Dynamic programming algorithms learn optimal network structures in O(n2n) time and memory (Ott, Imoto, and Miyano 2004; Koivisto and Sood 2004; Singh and Moore 2005; Silander and Myllymaki 2006). Because a network structure is a DAG, the optimal structure can be divided into an optimal leaf vertex and its parents as well as an optimal subnetwork for the rest of the variables. This subnetwork is also a DAG, so it can recursively be divided until the subnetwork is only a single\nvertex. At that point, the optimal parents have been found for all variables in the network and the optimal structure can be constructed. It has been shown (Silander and Myllymaki 2006) that a more efficient algorithm begins with a 0- variable subnetwork and exhaustively adds optimal leaves. For the MDL scoring function and variables V, this recurrence can be expressed as follows (Ott, Imoto, and Miyano 2004),\nMDL(V) = min X∈V {MDL(V \\ {X}) +\nBestMDL(X,V \\ {X})},\nwhere\nBestMDL(X,V \\ {X}) = min PAX⊆V\\{X} MDL(X |PAX).\nAs this recurrence suggests, all dynamic programming algorithms must perform three steps. First, they must calculate the score of each variable given all subsets of the other variables as parents. There are n2n−1 of these scores. Then, BestMDL must be calculated. For a variable X and set of possible parents V, this function returns the subset of those parents which minimizes the score for X as well as that score. There are n2n−1 of these optimal parent sets. Finally, the optimal subnetworks must be learned. These subnetworks use BestMDL to learn the optimal leaf for every possible subnetwork, including the optimal network with all of the variables. There are 2n optimal subnetworks."
    }, {
      "heading" : "4 GRAPH SEARCH FORMULATION",
      "text" : "We first formulate each phase of the dynamic programming algorithm as a separate search problem, including calculating parent scores, identifying the optimal parent sets, and learning the optimal subnetworks.\nWe use an AD-tree-like search to calculate all of the parent scores. An AD-tree (Moore and Lee 1998) is an unbalanced tree which contains AD-nodes and varying nodes. The tree is used to collect count statistics from a dataset. An AD-node stores the number of records consistent with the variable instantiation of the node, while a varying node assigns a value to a variable. As shown in Equation 2, the entropy component of a score can be calculated based on variable instantiation counts. Each AD-node has an instantiation of a set of variables U and the count of records consistent with that instantiation. That count is a value of pai for all X ∈ V \\ U. Furthermore, it is a value of xi, pai for all X ∈ U with parents U \\ {X}. We can use a depthfirst traversal of the AD-tree to compute the scores. Theorem 1 states that only small parent sets can possibly be optimal parents when using the MDL score. All nodes below the depth specified in the theorem are pruned. The scores which are not pruned are written to disk for retrieval when\nidentifying optimal parent sets. We call this data structure a score cache. Each entry in the score cache contains one value of MDL(X |PA).\nA parent graph is a lattice in which each node stores one value of BestMDL for different candidate sets of variables. The score cache is used to quickly look up the scores for candidate parent sets. Figure 1 shows the construction of the parent graph for variable X1 as a lattice. All 2n−1 subsets of all other variables are present in the graph. Each node contains one value for BestMDL of X1 and the set of candidate parents shown. That is, each node stores the subset of parents from the given candidate set which minimizes the score of X1, as well as that score. The lattice divides the nodes into layers. We call the first layer of the graph, the layer with the single node for {} in Figure 1, layer 0. A node in layer l has l predecessors, all in layer l − 1, and considers candidate parent sets of size l. Layer l has C(n− 1, l) nodes, where C(n, k) is the binomial coefficient. Each variable has a separate parent graph. The complete set of parent graphs stores n2n−1 parent sets.\nAn order graph is also a lattice. Each node contains MDL(V) and the associated optimal subnetwor for one\nsubset of variables. Figure 2 displays an order graph for four variables. Its lattice structure is similar to that of the parent graphs; because it contains subsets of all variables, though, the order graph has 2n nodes. The topmost node in layer 0 containing no variables is the start node. The bottom-most node containing all variables is the goal node. A directed path in the order graph from the start node to any other node induces an ordering on the variables in the path with new variables appearing later in the ordering. For example, the path traversing nodes {}, {X1}, {X1, X2}, {X1, X2, X3} stands for the variable ordering X1, X2, X3. All variables which precede a variable in the ordering are candidate parents of that variable. Each edge on the path has a cost equal to BestMDL for the new variable in the child node given the variables in the parent node as candidate parents. The parent graphs are used to quickly retrieve these costs. For example, the edge between {X1, X2} and {X1, X2, X3} has a cost equal to BestMDL(X3, {X1, X2}). Each node contains a subset of variables, the cost of the best path from the start node to that node, a leaf variable and its optimal parent set. The shortest paths from the start node to all the other nodes correspond to the optimal subnetworks, so the shortest path to the goal node corresponds to the optimal Bayesian network. The lattice again divides the nodes into layers. Nodes in layer l contain optimal subnetworks of l variables. Layer l has C(n, l) nodes."
    }, {
      "heading" : "5 AN EXTERNAL-MEMORY FRONTIER BREADTH-FIRST BRANCH AND BOUND ALGORITHM",
      "text" : "Finding an optimal Bayesian network structure can be considered a search through the order graph. This formulation allows the application of any graph search algorithm, such as A* (Yuan, Malone, and Wu 2011), to find the best path from the start node to the goal node. In particular, such a formulation allows us to treat the order and parent graphs as implicit search graphs. That is, we do not have to keep the entire graphs in memory at once. Dynamic programming can be considered as a breadth-first search through this graph (Malone, Yuan, and Hansen 2011). Previous results show that the scalability of existing algorithms for learning optimal Bayesian networks is typically limited by the amount of RAM available. To eliminate the constraint of limited RAM, we introduce a frontier breadth-first branch and bound algorithm with delayed duplicate detection to do the search by adapting the breadth-first heuristic search algorithm proposed by Zhou and Hansen (2003; 2006). It is also similar to the frontier search described by Korf (2005).\nBreadth-first heuristic search expands a search space in order of layers of increasing g-cost with each layer comprising all nodes with a same g-cost. As each node is generated, a heuristic function is used to calculate a lower bound for\nAlgorithm 1 A Frontier BFBnB Search Algorithm procedure EXPANDORDERGRAPH(l, isPresent, upper, lb,maxSize)\nfor each MDLl(U) ∈ MDLl do for each X ∈ V \\ U do\ns ← MDLl(U) + BMDLl(X|U) − lb(X) if s > upper then continue isPresent(U ∪ {X}) ← true if s < MDLl+1(U ∪ {X}) then\nMDLl+1(U ∪ {X}) ← s MDLPl+1(U ∪ {X}) ← BMDLPl(X|U)\nend if if |MDLl+1| > maxSize then\nwriteTempFile(MDLl+1,MDLPl+1) end if\nend for end for writeTempFile(MDLl+1,MDLPl+1) MDLl+1,MDLPl+1 ← mergeTempFiles delete MDLl\nend procedure\nprocedure EXPANDPARENTGRAPH(l, p, isPresent, maxSize) for each BestMDLl(p|U) ∈ BestMDLl(p do\nfor each X ∈ V \\ U and X 6= p do S ← U ∪ {X} if !isPresent(S) then continue if MDL(p|S) < BMDLl+1(p|S) then\nBMDLl+1(p|S) ← MDL(p|S) BMDLPl+1(p|S) ← S\nend if if BMDLl(p|U) < BMDLl+1(p|S) then\nBMDLl+1(p|S) ← BMDLl(p|U) BMDLPl+1(p|S) ← BMDLPl(p|U)\nend if if |BMDLl+1(p)| > maxSize then\nwriteTempFile(BMDLl+1(p), BMDLSl+1(p)) end if\nend for end for writeTempFile(BMDLl+1(p), BMDLPl+1(p)) BMDLl+1, BMDLPl+1(p) ←mergeTempFiles delete BMDLl, BMDLPl(p)\nend procedure\nprocedure EXPANDADNODE(i, U,Du, d) For j = i + 1 → n do expandVaryNode(j,U,Du, d) end procedure\nprocedure EXPANDVARYNODE(i, U,Du, d) for j = 0 → ri do\nupdateScores(U ∪ {Xi},DXi=j,u) if d > 0 then expandADNode(i,U ∪ {Xi},DXi=j,u, d − 1)\nend for end procedure\nprocedure UPDATESCORES(U, Du) for X ∈ V \\ U do\nif MDL(X|U) is null then MDL(X|U) ← K(X|U) MDL(X|U) ← MDL(X|U) + Nu ∗ logNu\nend for for X ∈ U do\nif MDL(X|U \\ {X}) is null MDL(X|U \\ {X})← K(X|U \\ {X}) MDL(X|U \\ {X}) ← MDL(X|U \\ {X}) − Nu ∗ logNu\nend for end procedure\nprocedure MAIN(D, upper,maxSize) maxParents ← log 2N\nlog N\nexpandADNode(−1, {},D,maxParents) lb ← getBestScores writeScoresToDisk isPresent ← {} for l = 1 → n do\nfor p = 1 → n do expandParentGraph(l, p, isPresent, maxSize) end for expandOrderGraph(l, isPresent, upper, lb, maxSize)\nend for optimalStructure ← reconstructSolution\nend procedure\nthat node. If the lower bound is worse than a given upper bound on the optimal solution, the node is pruned; otherwise, the node is added to the open list for further search. After the search, a divide-and-conquer method is used to reconstruct the optimal solution.\nAlgorithm 1 gives the pseudocode for our BFBnB search algorithm for learning optimal Bayesian networks. The algorithm is very similar to the breadth-first heuristic search algorithm but has several subtle and important differences. First, the layers in our search graphs (the parent and order graphs) do not correspond to the g-costs of nodes; rather, layer l corresponds to variable sets (candidate parent sets or optimal subnetworks) of size l. For the order graph, though, we can calculate both a g- and h-cost for pruning, as described in Section 5.1. We also describe how to propagate this pruning from the order graph to the parent graphs. Another difference is that our search problem is a nested search of order and parent graphs. The layered parent and order graph searches have to be carefully orchestrated to ensure the correct nodes can be accessed easily at the correct time, as described in Section 5.2. This further requires the parent scores are stored in particular order, as described in Section 5.3. Yet another difference is that we use a variant of delayed duplicate detection (Korf 2008) in which a hash table is used to detect as many duplicates in RAM as possible before resorting to external memory, as described in Section 5.4. Finally, we store a portion of each order graph node to reconstruct the optimal network structure after the search, as described in Section 5.5."
    }, {
      "heading" : "5.1 BRANCH AND BOUND",
      "text" : "We need a heuristic function f(U) = g(U) + h(U) that estimates the cost of the best path from the start node to a goal node using order node U. The g cost is simply the sum of the edge costs of the best path from the start node to U. The h cost provides a lower bound on the cost from U to the goal node. We use the following heuristic function h from Yuan et al. (2011).\nDefinition 1.\nh(U) = ∑\nX∈V\\U\nBestMDL(X,V\\{X}). (3)\nThis heuristic function relaxes the acyclic constraint on the remaining variables in V \\ U and allows them to choose parents from all of the variables in V. The following theorem from Yuan et al. (2011) proves that the function is consistent. Consistent heuristics are guaranteed to be admissible.\nTheorem 3. h is consistent.\nIn order to calculate this bound, we must know BestMDL(X,V\\{X}). Fortunately, these scores are calculated during the first phase of the algorithm. Because\nthe score cache contains every score which could possibly be optimal for all variables, it is guaranteed to have the optimal score for all variables given any set of parents, which is BestMDL(X,V \\ {X}). Thus, we can identify these scores while calculating the scores when expanding the AD-tree and store them in an array for reuse. The pseudocode uses the function getBestScores to find these scores and the array lb to store them.\nWe can apply BFBnB to prune nodes in the order graph using the lower bound function in Equation 3; however, pruning is not directly applicable to the parent graphs. An optimal parent score BestMDL(X,U) is only necessary if a node for U is in the order graph. Consequently, if U is pruned from the order graph, then the nodes for U are also pruned from the parent graphs. The pseudocode uses isPresent to track which nodes were not pruned.\nWe also need an upper bound score on the optimal Bayesian network for pruning. A search node U whose heuristic value f(U) is higher than the upper bound is immediately pruned. Numerous fast, approximate methods exist for learning a locally optimal Bayesian network. We use a greedy beam search algorithm based on a local search algorithm described by Heckerman (1998) to quickly find the upper bound. A more sophisticated algorithm could be used to find a better bound and improve pruning. The input argument upper is this bound in the pseudocode."
    }, {
      "heading" : "5.2 COORDINATING THE GRAPH SEARCHES",
      "text" : "The parent and order graph searches must be carefully coordinated to ensure that the parent graphs contain the necessary nodes to expand nodes in the order graph. In particular, expanding a node U in layer l in the order graph requires BestMDL(X,U), which is stored in the node U of the parent graph for X . Hence, before expanding layer |U| in the order graph, that layer of the parent graphs must already exist. Therefore, the algorithm alternates between expanding layers of the parent graphs and order graph.\nExpanding a node U in the parent graph amounts to generating successor nodes with candidate parents U ∪ {X} for all X in V \\ U. For each successor S = U ∪ {X}, the hash table for the next layer is first checked to see if S has already been generated. If not, the score of using all of S as parents of X is retrieved from the score cache and compared to the score of using the parents specified in U. If using all of the variables has a better score, then an entry is added to the hash table indicating that, for possible parents S, using all of them is best. Otherwise, according to Theorem 2, the hash table stores a mapping from S to the parents in U. Similarly, if S has already been generated, the score of the existing best parent set for S is compared to the score using the parents in U. If the score of the parents in U is better, then the hash table mapping is updated accordingly. Once a layer of the parent graph is expanded,\nthe whole layer can be discarded as it is no longer needed. The pseudocode uses BMDLl to store the optimal scores and BMDLPl to store the optimal parents.\nExpanding a node U in the order graph amounts to generating successor nodes U ∪ {X} for all X in V \\ U. To calculate the score of successor S = U∪{X}, the score of the existing node U is added to BestMDL(X,U), which is retrieved from parent graph node U for variable X . The optimal parent set out of U is also recorded. This is equivalent to trying X as the leaf and U as the subnetwork. Next, the hash table for the next layer is consulted. If it contains an entry for S, then a node for this set of variables has already been generated using another variable as the leaf. The score of that node is compared to the score for S. If the score for S is better, or the hash table did not contain an entry for S, then the mapping in the hash table is updated. Unlike the parent graph, however, a portion of each order graph node is used to reconstruct the optimal network at the end of the search, as described in Section 5.5. This information is written to disk, while the other information is deleted. The pseudocode uses MDLl to store the score for each subnetwork and MDLPl to store the associated parent information.\nAdditional care is needed to ensure that parent and order graph nodes for a particular layer are accessed in a regular, structured pattern. We arrange the nodes in the parent and order graphs in queues such that when node U is removed from the order graph queue, the head of each parent graph queue for all X in V \\U is U. So all of the successors of U can be generated by combining it with the head of each of those parent graph queues. Once the parent graph nodes are used, they can be removed, and the queues will be ready to expand the next node in the order graph queue. Because the nodes are removed from the heads of the queues, these invariants hold throughout the expansion of the layer. Regulating such access patterns improves the scalability of the algorithm because these queues can be stored on disk and accessed sequentially to reduce the requirement of RAM. The regular accesses also reduce disk seek time. The pseudocode assumes the nodes are written to disk in this order to easily retrieve the next necessary node.\nThe lexicographic ordering (Knuth 2009) of nodes within each layer is one possible ordering that ensures the queues remain synchronized. For example, the lexicographic ordering of 4 variables of size 2 is {{X1, X2}, {X1, X3}, {X2, X3}, {X1, X4}, {X2, X4}, {X3, X4}}. The order graph queue for layer 2 of a dataset with 4 variables should be arranged in that order. The parent graph queue for variable X should have the same sequence, but without subsets containing X . In the example, the parent graph queue for variable X1 should be {{X2, X3}, {X2, X4}, {X3, X4}}. As described in more detail in Section 5.4, the nodes of the graphs must be sorted to detect duplicates; the lexicographic order ensures that\nthere is no additional work required to arrange the nodes when writing them to disk."
    }, {
      "heading" : "5.3 ORDERING THE SCORES ON DISK",
      "text" : "For large datasets, the score cache can grow quite large. We write it to disk to reduce RAM usage. Each score MDL(X,U) is used once, when node U is first generated in the parent graph for X . As described in Section 5.2, the parent graph nodes are expanded in lexicographic order; however, they are not generated in that order. The score MDL(X,U),U = {Y1 . . . Yl} is needed when expanding node U \\ {Yl} in the parent graph for X . Therefore, the scores must be written to disk in that order. The pseudocode uses the writeScoresToDisk function to sort and write the scores to disk in this order.\nA file is created for each variable for each layer to store these sorted scores. The file for a particular layer can be deleted after expanding that layer in the appropriate parent graph."
    }, {
      "heading" : "5.4 DUPLICATE DETECTION",
      "text" : "Duplicate nodes are generated during the graph searches. Duplicates in the parent and order graphs correspond to nodes which consider the same sets of variables (candidate parent sets and optimal subnetworks, respectively). Because the successors of a node always consider exactly one more variable in both the parent and order graphs, the successors of a node in layer l are always in layer l + 1. Therefore, when a node is generated, it could only be a duplicate of a node in the open list for layer l+ 1. In both the parent and order graphs, the duplicate with the best score should be kept.\nFor large datasets, it is possible that even one layer of the parent or order graph is too large to fit in RAM. We use a variant of the delayed duplicate detection (DDD) (Korf 2008) in our algorithm to utilize external memory to solve such large learning problems. In DDD, search nodes are written to a file on disk as they are generated. After expanding a layer, an external-memory sorting algorithm is used to detect and remove duplicate nodes in the file. The nodes in the file are then expanded to generate the next layer of the search. Consequently, the search uses a minimal amount of RAM; however, all generated nodes are written to disk, so much work is done reading and writing duplicates.\nRather than immediately writing all generated nodes to disk, we instead detect duplicates in RAM as usual with a hash table. Once the open list reaches a user-defined maximum size, its contents are sorted and written to a temporary file on disk. The open list is then cleared. At the end of each layer, the remaining contents of the open list and the temporary files are sorted and merged into a single file which contains the sorted list of nodes from that layer. For rea-\nsons described in Section 5.2, the lexicographic ordering of nodes within a layer is used when sorting. The hash table reduces the number of nodes written to and read from disk by detecting as many duplicates as possible in RAM.\nThe pseudocode uses maxSize as the user-defined maximum size. The function writeT empFile sorts, writes to disk and clears the open list provided as its argument. The scores and optimal parent sets are written together on disk. The function mergeT empFiles performs an external memory merge to detect duplicates in the temp files. For the parent graphs, both the scores and optimal parent sets are kept in a single file; however, as described in Section 5.5, the parent information of the order graph must be stored for the entire search, while the score information can be deleted after use. Therefore, two separate files are used to allow the information to easily be deleted."
    }, {
      "heading" : "5.5 RECONSTRUCTING THE OPTIMAL NETWORK STRUCTURE",
      "text" : "In order to trace back the optimal path and reconstruct the optimal network structure, we write a portion of each node of the order graph to a disk file once it is expanded during the order graph search. For each order graph node we write the subset of variables, the leaf variable and its optimal parents. Solution reconstruction works as follows. The final leaf variable X and its optimal parent set are retrieved from the goal node. Because the goal node considers all variables, its predecessor in the optimal path is U = V \\ {X}. This predecessor is retrieved from the file for layer |U|. That node has the optimal leaf and parent set for that subnetwork. Recursively, the optimal leaves and parent sets are retrieved until reconstructing the entire network structure. We use this approach instead of the standard divide-and-conquer solution reconstruction because, as shown in Section 6, it requires relatively little memory. Furthermore, divide-and-conquer would require regeneration of the parent graphs, which is quite expensive in terms of time and memory. The pseudocode uses the function reconstructSolution to extract this information from the MDLPl files."
    }, {
      "heading" : "5.6 ADVANTAGES OF OUR ALGORITHM",
      "text" : "Our frontier breadth-first branch and bound algorithm has several advantages over previous algorithms for learning optimal Bayesian networks.\nFirst, our top-down search of the AD-tree for calculating scores ensures we never need to calculate scores or counts of large variable sets. The AD-tree method is in contrast to the bottom-up method used by other algorithms (Silander and Myllymaki 2006). Bottom-up methods must always compute the scores, or at least the counts, of large parent sets in order to correctly calculate the counts required for the smaller ones. Since our algorithm neither calculates nor\nstores these counts and scores, it both runs more quickly and uses less memory.\nSecond, the layered search strategy reduces the memory requirements by working with one layer of the parent and order graphs at a time. Other information can be either discarded immediately or stored in hard disk files for later use, e.g., the information needed to reconstruct the optimal network structure. Previous formulations, such as PCaches (Singh and Moore 2005) and arrays (Silander and Myllymaki 2006), could not take advantage of this structure. Singh and Moore propose a depth-first search through the P-Caches, while Silander and Myllymaki’s approach identifies the sets according to their lexicographic ordering. (We use the lexicographic order within each layer, not over all of the variables.) These approaches can identify neither optimal parent sets nor optimal subnetworks one layer at a time. Thus, they must both keep all of the optimal parent sets and subnetworks in memory.\nThird, we prune the order graph using an admissible heuristic function; this further reduces the memory complexity of the algorithm. Pruning unpromising nodes from the order graph not only reduces the amount of computation but also reduces the memory requirement. Furthermore, the savings in running time and memory also propagate to parent graphs. Dynamic programming algorithms always evaluate the full order graph.\nThe duplicate detection method we use lifts the requirement that open lists fit in RAM to detect duplicates. Because our algorithm does not resort to delayed duplicate detection until RAM is full, our algorithm can still take advantage of large amounts of RAM. By writing nodes to disk, we can learn optimal Bayesian networks even when single layers of the search graphs do not fit in RAM.\nOur algorithm also has advantages over other learning formulations. In contrast to the A* algorithm of Yuan et al.( 2011), we only keep one layer of the order graph in memory at a time. The open and closed lists of A* keep all generated nodes in memory to perform duplicate detection. Unlike the systematic search algorithm of de Campos et al. (de Campos, Zeng, and Ji 2009), we always search in the space of DAGs, which is smaller than the space of directed graphs in which that algorithm searches. The LP algorithm (Jaakkola et al. 2010) uses the same mechanism to identify optimal parent sets as DP; therefore, it cannot complete when all optimal parent sets do not fit in memory."
    }, {
      "heading" : "6 EXPERIMENTS",
      "text" : "We compared a Java implementation of the externalmemory frontier BFBnB search with DDD (BFBnB) to an efficient version (Silander and Myllymaki 2006) of dynamic programming which uses external memory written\nin C downloaded from http:/b-course.hiit.fi/bene. We refer to it as DP. Previous results (Silander and Myllymaki 2006) have shown DP is more efficient than other dynamic programming implementations. We also compared to Yuan et al.’s A* implementation (2011) (A*) and de Campos et al.’s branch and bound systematic search algorithm (de Campos, Zeng, and Ji 2009) (SS) downloaded from http://www.ecse.rpi.edu/ cvrl/structlearning.html. We did not include comparison to the DP implementation of Malone et al. (2011) (MDP) because the codebase is similar; however, MDP does not incorporate pruning or delayed duplicate detection. The running times of BFBnB and MDP are similar on datasets which both complete, but, due to duplicate detection, MDP fails when an entire layer of the order graph does not fit in RAM.\nBenchmark datasets from the UCI repository (Frank and Asuncion 2010) were used to test the algorithms. We also constructed a biological dataset consisting of ChIP-Seq data for epigenetic features downloaded from http://dir.nhlbi.nih.gov/papers/lmi/epigenomes/hgtcell.html\nand http://dir.nhlbi.nih.gov/papers/lmi/epigenomes/ hgtcellacetylation.aspx. The experimental datasets were normalized using linear regression using the IgG control dataset downloaded from http://home.gwu.edu/∼wpeng/Software.htm. The largest datasets in the comparison have up to 33 variables and over 70,000 records. Continuous and discrete variables with more than four states were discretized into two states around the mean. Records with missing values were removed.\nDP and SS do not calculate the MDL score for a network; however, they can calculate BIC. The score uses an equivalent calculation as MDL, so the algorithms always learned equivalent networks. The experiments were performed on a 3.07 GHz Intel i7 with 16GB of RAM, 500GB of hard disk space and running Ubuntu version 10.10. On datasets with less than 25 variables, all algorithms were given a maximum runtime of 2 hours (7,200 seconds). On datasets with 25 to 29 variables, all algorithms were given a maximum runtime of 24 hours (86,400 seconds).\nWe empirically evaluated the algorithms for both space and time requirements. For the algorithms which used external memory (BFBnB and DP), we compared the maximum hard disk usage. We also compared the running times of the algorithms. The results are given in Table 1.\nPrevious results found that memory is the main bottleneck restricting the size of learnable networks (Parviainen and Koivisto 2009). As the results show, algorithms which attempt to store entire parent or order graphs in RAM, such as A* and SS, are limited to smaller sets of variables. BFBnB’s duplicate detection strategy allows it to write parital search layers to hard disk when the layers are too large to fit in RAM, so it can learn optimal Bayesian network structures regardless of the amount of RAM. Consequently, hard disk space is its only memory limitation. The inexpensive cost of hard disks coupled with distributed file systems can potentially erase the effect of memory on the scalability of the algorithm.\nFor the datasets which it could solve, A* was sometimes faster than the other algorithms. This is unsurprising since it uses only RAM; however, it is unable to solve the larger datasets that cannot fit entirely in RAM. Even on many of the smaller datasets, though, A* runs more slowly than BFBnB because it has the overhead cost to keep its open list in sorted order.\nBFBnB not only takes an order of magnitude less external memory, but runs several times faster than the DP algorithm on most of the datasets. DP is faster on the adult, letter and meta datasets. These datasets have a small number of variables and a large number of records. The large number of records limits the pruning of the AD-tree from Theorem 1 and increases the runtime of BFBnB. However, BFBnB runs faster on both mushroom (8,000 records) and sensorReadings (5,000 records). Therefore, as the number of variables increases, the number of records impacts the runtime less.\nThe SS algorithm ran much more slowly than the other algorithms. It searches in the space of directed graphs rather than DAGs. These results suggest that search in the space of DAGs is more efficient than the space of directed graphs.\nTo demonstrate that our algorithm is applicable to larger datasets, we also tested it using the wdbc dataset (31 variables, 569 records) and a biological dataset (33 variables, 72,228 records), epigenetic. We learned the optimal network for wdbc in 93,682 seconds (about 26 hours) and the optimal network for epigenetic in 570,760 seconds (about 6 days). We also attempted to use DP, but its hard disk usage exceeded the 500GB of free hard disk space on the server. Figure 3 shows the total memory consumption of our algorithm for wdbc. Very little memory is used before layer 9, and after layer 22, the memory consumption does not change much because the layer sizes decrease. As the figure shows, both of the middle layers use nearly 70 giga-\nbytes of disk space. Most of this space is consumed by the parent graphs, so it is is freed after each layer. Assuming that the running time and size of the middle layers double for each additional variable, which is a rough pattern from Table 1, our algorithm could learn a 36-variable network in about 50 days using approximately 2 terabytes of hard disk space and a single processor. This suggests that our method should scale to larger networks better than the method of Parviainen and Koivisto (2009). They observe that their implementation would take 4 weeks on 100 processors to learn a 31-variable network, and, even with coding improvements and massive parallelization, only networks up to 34 variables would be possible."
    }, {
      "heading" : "7 CONCLUSION",
      "text" : "Learning optimal Bayesian network structures has been thought of in terms of dynamic programming; however, such a formulation naively requiresO(n2n) memory. Other formulations have been shown to have similar or slower runtimes or require other exponential resources, such as processors. This paper formulates the structure learning problem as a frontier breadth-first branch and bound search. The layered search technique allows us to work with one layer of the score cache, parent and order graphs at a time. Consequently, we delete layers of the parent graphs after expanding them and store only a portion of each order graph node to hard disk files to reduce the memory complexity. The delayed duplicate detection strategy further improves the scalability of the algorithm by writing partial layers to disk rather than requiring an entire layer fit in RAM at once. Additionally, a heuristic function allows parts of the order graph to be ignored entirely; this also reduces memory complexity and improves scalability.\nExperimental results demonstrate that this algorithm outperforms the previous best implementation of dynamic programming for learning optimal Bayesian networks. Our algorithm not only runs faster than the existing approach, but also takes much less space. The LP formulation exhibits similar runtime behavior as DP, so our algorithm should\nsimilarly outperform it. It also scales to more variables than A*. Additionally, by searching in the space of DAGs instead of the space of directed graphs with cycles, it proves the optimality of the learned network more quickly than SS.\nFuture work will investigate better upper bounds and heuristic functions to further increase the size of learnable optimal networks. Also, like existing methods (Parviainen and Koivisto 2009; Silander and Myllymaki 2006), our algorithm can benefit from parallel computing. In addition, distributed computing can scale up our algorithm to even larger learning problems. Networks learned from our algorithm could also be used as a “gold standard” in studying the assumptions of approximate structure learning algorithms.\nAcknowledgements This work was supported by NSF CAREER grant IIS-0953723 and EPSCoR grant EPS0903787."
    } ],
    "references" : [ {
      "title" : "Learning Bayesian networks is NP-complete",
      "author" : [ "D.M. Chickering" ],
      "venue" : "Learning from Data: Artificial Intelligence and Statistics V, 121–130. Springer-Verlag.",
      "citeRegEx" : "Chickering,? 1996",
      "shortCiteRegEx" : "Chickering",
      "year" : 1996
    }, {
      "title" : "A Bayesian method for the induction of probabilistic networks from data",
      "author" : [ "G.F. Cooper", "E. Herskovits" ],
      "venue" : "Mach. Learn. 9:309–347.",
      "citeRegEx" : "Cooper and Herskovits,? 1992",
      "shortCiteRegEx" : "Cooper and Herskovits",
      "year" : 1992
    }, {
      "title" : "Structure learning of Bayesian networks using constraints",
      "author" : [ "C.P. de Campos", "Z. Zeng", "Q. Ji" ],
      "venue" : "In Proceedings of the 26th Annual International Conference on Machine Learning,",
      "citeRegEx" : "Campos et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Campos et al\\.",
      "year" : 2009
    }, {
      "title" : "Learning Bayesian network structure from massive datasets: The “sparse candidate” algorithm",
      "author" : [ "N. Friedman", "I. Nachman", "D. Peer" ],
      "venue" : "Proceedings of UAI-13, 206–215.",
      "citeRegEx" : "Friedman et al\\.,? 1999",
      "shortCiteRegEx" : "Friedman et al\\.",
      "year" : 1999
    }, {
      "title" : "Learning Bayesian networks: The combination of knowledge and statistical data",
      "author" : [ "D. Heckerman", "D. Geiger", "D.M. Chickering" ],
      "venue" : "20:197–243.",
      "citeRegEx" : "Heckerman et al\\.,? 1995",
      "shortCiteRegEx" : "Heckerman et al\\.",
      "year" : 1995
    }, {
      "title" : "A tutorial on learning with Bayesian networks",
      "author" : [ "D. Heckerman" ],
      "venue" : "Holmes, D., and Jain, L., eds., Innovations in Bayesian Networks, volume 156 of Studies in Computational Intelligence. Springer Berlin / Heidelberg. 33–82.",
      "citeRegEx" : "Heckerman,? 1998",
      "shortCiteRegEx" : "Heckerman",
      "year" : 1998
    }, {
      "title" : "Learning Bayesian network structure using LP relaxations",
      "author" : [ "T. Jaakkola", "D. Sontag", "A. Globerson", "M. Meila" ],
      "venue" : "Proceedings of the 13th International Conference on Artificial Intelligence and Statistics (AISTATS).",
      "citeRegEx" : "Jaakkola et al\\.,? 2010",
      "shortCiteRegEx" : "Jaakkola et al\\.",
      "year" : 2010
    }, {
      "title" : "The Art of Computer Programming, Volume 4, Fascicles 0-4",
      "author" : [ "D.E. Knuth" ],
      "venue" : "Addison-Wesley Professional, 1st edition.",
      "citeRegEx" : "Knuth,? 2009",
      "shortCiteRegEx" : "Knuth",
      "year" : 2009
    }, {
      "title" : "Exact Bayesian structure discovery in Bayesian networks",
      "author" : [ "M. Koivisto", "K. Sood" ],
      "venue" : "Journal of Machine Learning Research 549–573.",
      "citeRegEx" : "Koivisto and Sood,? 2004",
      "shortCiteRegEx" : "Koivisto and Sood",
      "year" : 2004
    }, {
      "title" : "Frontier search",
      "author" : [ "R. Korf", "W. Zhang", "I. Thayer", "H. Hohwald" ],
      "venue" : "Journal of the ACM 52(5):715–748.",
      "citeRegEx" : "Korf et al\\.,? 2005",
      "shortCiteRegEx" : "Korf et al\\.",
      "year" : 2005
    }, {
      "title" : "Linear-time disk-based implicit graph search",
      "author" : [ "R. Korf" ],
      "venue" : "Journal of the ACM 35(6).",
      "citeRegEx" : "Korf,? 2008",
      "shortCiteRegEx" : "Korf",
      "year" : 2008
    }, {
      "title" : "Memoryefficient dynamic programming for learning optimal Bayesian networks",
      "author" : [ "B. Malone", "C. Yuan", "E. Hansen" ],
      "venue" : "Proceedings of the 25th national conference on Artifical intelligence.",
      "citeRegEx" : "Malone et al\\.,? 2011",
      "shortCiteRegEx" : "Malone et al\\.",
      "year" : 2011
    }, {
      "title" : "Cached sufficient statistics for efficient machine learning with large datasets",
      "author" : [ "A. Moore", "M.S. Lee" ],
      "venue" : "J. Artif. Int. Res. 8:67–91.",
      "citeRegEx" : "Moore and Lee,? 1998",
      "shortCiteRegEx" : "Moore and Lee",
      "year" : 1998
    }, {
      "title" : "Finding optimal models for small gene networks",
      "author" : [ "S. Ott", "S. Imoto", "S. Miyano" ],
      "venue" : "Pac. Symp. Biocomput, 557–567.",
      "citeRegEx" : "Ott et al\\.,? 2004",
      "shortCiteRegEx" : "Ott et al\\.",
      "year" : 2004
    }, {
      "title" : "Exact structure discovery in Bayesian networks with less space",
      "author" : [ "P. Parviainen", "M. Koivisto" ],
      "venue" : "Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence. Montreal, Quebec, Canada: AUAI Press.",
      "citeRegEx" : "Parviainen and Koivisto,? 2009",
      "shortCiteRegEx" : "Parviainen and Koivisto",
      "year" : 2009
    }, {
      "title" : "Modeling by shortest data description",
      "author" : [ "J. Rissanen" ],
      "venue" : "Automatica 14:465–471.",
      "citeRegEx" : "Rissanen,? 1978",
      "shortCiteRegEx" : "Rissanen",
      "year" : 1978
    }, {
      "title" : "A simple approach for finding the globally optimal Bayesian network structure",
      "author" : [ "T. Silander", "P. Myllymaki" ],
      "venue" : "Proceedings of the 22nd Annual Conference on Uncertainty in Artificial Intelligence (UAI-06). Arlington, Virginia: AUAI Press.",
      "citeRegEx" : "Silander and Myllymaki,? 2006",
      "shortCiteRegEx" : "Silander and Myllymaki",
      "year" : 2006
    }, {
      "title" : "Finding optimal Bayesian networks by dynamic programming",
      "author" : [ "A. Singh", "A. Moore" ],
      "venue" : "Technical report, Carnegie Mellon University.",
      "citeRegEx" : "Singh and Moore,? 2005",
      "shortCiteRegEx" : "Singh and Moore",
      "year" : 2005
    }, {
      "title" : "A branch-and-bound algorithm for MDL learning Bayesian networks",
      "author" : [ "J. Tian" ],
      "venue" : "Proceedings of the 16th Conference on Uncertainty in Artificial Intelligence, 580– 588. Morgan Kaufmann Publishers Inc.",
      "citeRegEx" : "Tian,? 2000",
      "shortCiteRegEx" : "Tian",
      "year" : 2000
    }, {
      "title" : "The max-min hill-climbing Bayesian network structure learning algorithm",
      "author" : [ "I. Tsamardinos", "L. Brown", "C. Aliferis" ],
      "venue" : "Machine learning.",
      "citeRegEx" : "Tsamardinos et al\\.,? 2006",
      "shortCiteRegEx" : "Tsamardinos et al\\.",
      "year" : 2006
    }, {
      "title" : "Learning optimal Bayesian networks using A* search",
      "author" : [ "C. Yuan", "B. Malone", "X. Wu" ],
      "venue" : "Proceedings of the 22nd International Joint Conference on Artificial Intelligence.",
      "citeRegEx" : "Yuan et al\\.,? 2011",
      "shortCiteRegEx" : "Yuan et al\\.",
      "year" : 2011
    }, {
      "title" : "Sweep A*: Space-efficient heuristic search in partially ordered graphs",
      "author" : [ "R. Zhou", "E. Hansen" ],
      "venue" : "Proceedings of 15th IEEE International Conf. on Tools with Artificial Intelligence, 427–434.",
      "citeRegEx" : "Zhou and Hansen,? 2003",
      "shortCiteRegEx" : "Zhou and Hansen",
      "year" : 2003
    }, {
      "title" : "Breadth-first heuristic search",
      "author" : [ "R. Zhou", "E.A. Hansen" ],
      "venue" : "Artificial Intelligence 170:385–408.",
      "citeRegEx" : "Zhou and Hansen,? 2006",
      "shortCiteRegEx" : "Zhou and Hansen",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "A common learning approach entails searching for a structure which optimizes a particular scoring function (Cooper and Herskovits 1992; Heckerman, Geiger, and Chickering 1995).",
      "startOffset" : 107,
      "endOffset" : 175
    }, {
      "referenceID" : 1,
      "context" : "Because of the difficulty of the problem, early approaches focused on approximation techniques to learn “good” networks (Cooper and Herskovits 1992; Heckerman, Geiger, and Chickering 1995; Heckerman 1998; Friedman, Nachman, and Peer 1999; Tsamardinos, Brown, and Aliferis 2006).",
      "startOffset" : 120,
      "endOffset" : 277
    }, {
      "referenceID" : 5,
      "context" : "Because of the difficulty of the problem, early approaches focused on approximation techniques to learn “good” networks (Cooper and Herskovits 1992; Heckerman, Geiger, and Chickering 1995; Heckerman 1998; Friedman, Nachman, and Peer 1999; Tsamardinos, Brown, and Aliferis 2006).",
      "startOffset" : 120,
      "endOffset" : 277
    }, {
      "referenceID" : 8,
      "context" : "Exact dynamic programming algorithms have been developed to learn provably optimal Bayesian network structures (Ott, Imoto, and Miyano 2004; Koivisto and Sood 2004; Singh and Moore 2005; Silander and Myllymaki 2006).",
      "startOffset" : 111,
      "endOffset" : 215
    }, {
      "referenceID" : 17,
      "context" : "Exact dynamic programming algorithms have been developed to learn provably optimal Bayesian network structures (Ott, Imoto, and Miyano 2004; Koivisto and Sood 2004; Singh and Moore 2005; Silander and Myllymaki 2006).",
      "startOffset" : 111,
      "endOffset" : 215
    }, {
      "referenceID" : 16,
      "context" : "Exact dynamic programming algorithms have been developed to learn provably optimal Bayesian network structures (Ott, Imoto, and Miyano 2004; Koivisto and Sood 2004; Singh and Moore 2005; Silander and Myllymaki 2006).",
      "startOffset" : 111,
      "endOffset" : 215
    }, {
      "referenceID" : 8,
      "context" : "Exact dynamic programming algorithms have been developed to learn provably optimal Bayesian network structures (Ott, Imoto, and Miyano 2004; Koivisto and Sood 2004; Singh and Moore 2005; Silander and Myllymaki 2006). These algorithms identify optimal small subnetworks and add optimal leaves to find large optimal networks until finding the optimal network including all variables. Unfortunately, all of these algorithms must store an exponential number of subnetworks and associated information in memory. Parviainen and Koivisto (2009) recently proposed a divide-and-conquer algorithm in which fewer subnetworks are stored in memory at once at the expense of longer running time.",
      "startOffset" : 141,
      "endOffset" : 538
    }, {
      "referenceID" : 2,
      "context" : "de Campos et al. (2009) proposed a systematic search algorithm to identify optimal network structures.",
      "startOffset" : 3,
      "endOffset" : 24
    }, {
      "referenceID" : 6,
      "context" : "Optimal networks have also been learned using linear programming (Jaakkola et al. 2010).",
      "startOffset" : 65,
      "endOffset" : 87
    }, {
      "referenceID" : 6,
      "context" : "This algorithm was shown to have similar or slightly better runtime performance as dynamic programming (Jaakkola et al. 2010).",
      "startOffset" : 103,
      "endOffset" : 125
    }, {
      "referenceID" : 5,
      "context" : ", DN}, where Di is an instantiation of all the variables in V, the optimal structure is the DAG over all of the variables which best fits D (Heckerman 1998).",
      "startOffset" : 140,
      "endOffset" : 156
    }, {
      "referenceID" : 15,
      "context" : "For example, the minimum description length (MDL) scoring function (Rissanen 1978) uses one term to reward structures with low entropy and another to penalize complex structures.",
      "startOffset" : 67,
      "endOffset" : 82
    }, {
      "referenceID" : 18,
      "context" : "The MDL score for a structure G is defined as follows (Tian 2000),",
      "startOffset" : 54,
      "endOffset" : 65
    }, {
      "referenceID" : 5,
      "context" : "MDL is decomposable (Heckerman 1998), so the score for a structure is simply the sum of the score for each variable.",
      "startOffset" : 20,
      "endOffset" : 36
    }, {
      "referenceID" : 4,
      "context" : "MDL is decomposable (Heckerman 1998), so the score for a structure is simply the sum of the score for each variable. Our algorithm can be adapted to use any decomposable function. Some sets of parents cannot form an optimal parent for any variable, as described in the following theorems from Tian (2000) and de Campos et al.",
      "startOffset" : 21,
      "endOffset" : 305
    }, {
      "referenceID" : 2,
      "context" : "Some sets of parents cannot form an optimal parent for any variable, as described in the following theorems from Tian (2000) and de Campos et al. (2009).",
      "startOffset" : 132,
      "endOffset" : 153
    }, {
      "referenceID" : 0,
      "context" : "Learning an optimal Bayesian network structure is NPHard (Chickering 1996).",
      "startOffset" : 57,
      "endOffset" : 74
    }, {
      "referenceID" : 8,
      "context" : "Dynamic programming algorithms learn optimal network structures in O(n2) time and memory (Ott, Imoto, and Miyano 2004; Koivisto and Sood 2004; Singh and Moore 2005; Silander and Myllymaki 2006).",
      "startOffset" : 89,
      "endOffset" : 193
    }, {
      "referenceID" : 17,
      "context" : "Dynamic programming algorithms learn optimal network structures in O(n2) time and memory (Ott, Imoto, and Miyano 2004; Koivisto and Sood 2004; Singh and Moore 2005; Silander and Myllymaki 2006).",
      "startOffset" : 89,
      "endOffset" : 193
    }, {
      "referenceID" : 16,
      "context" : "Dynamic programming algorithms learn optimal network structures in O(n2) time and memory (Ott, Imoto, and Miyano 2004; Koivisto and Sood 2004; Singh and Moore 2005; Silander and Myllymaki 2006).",
      "startOffset" : 89,
      "endOffset" : 193
    }, {
      "referenceID" : 16,
      "context" : "It has been shown (Silander and Myllymaki 2006) that a more efficient algorithm begins with a 0variable subnetwork and exhaustively adds optimal leaves.",
      "startOffset" : 18,
      "endOffset" : 47
    }, {
      "referenceID" : 12,
      "context" : "An AD-tree (Moore and Lee 1998) is an unbalanced tree which contains AD-nodes and varying nodes.",
      "startOffset" : 11,
      "endOffset" : 31
    }, {
      "referenceID" : 10,
      "context" : "It is also similar to the frontier search described by Korf (2005).",
      "startOffset" : 55,
      "endOffset" : 67
    }, {
      "referenceID" : 10,
      "context" : "Yet another difference is that we use a variant of delayed duplicate detection (Korf 2008) in which a hash table is used to detect as many duplicates in RAM as possible before resorting to external memory, as described in Section 5.",
      "startOffset" : 79,
      "endOffset" : 90
    }, {
      "referenceID" : 20,
      "context" : "We use the following heuristic function h from Yuan et al. (2011).",
      "startOffset" : 47,
      "endOffset" : 66
    }, {
      "referenceID" : 20,
      "context" : "The following theorem from Yuan et al. (2011) proves that the function is consistent.",
      "startOffset" : 27,
      "endOffset" : 46
    }, {
      "referenceID" : 5,
      "context" : "We use a greedy beam search algorithm based on a local search algorithm described by Heckerman (1998) to quickly find the upper bound.",
      "startOffset" : 85,
      "endOffset" : 102
    }, {
      "referenceID" : 7,
      "context" : "The lexicographic ordering (Knuth 2009) of nodes within each layer is one possible ordering that ensures the queues remain synchronized.",
      "startOffset" : 27,
      "endOffset" : 39
    }, {
      "referenceID" : 10,
      "context" : "We use a variant of the delayed duplicate detection (DDD) (Korf 2008) in our algorithm to utilize external memory to solve such large learning problems.",
      "startOffset" : 58,
      "endOffset" : 69
    }, {
      "referenceID" : 16,
      "context" : "The AD-tree method is in contrast to the bottom-up method used by other algorithms (Silander and Myllymaki 2006).",
      "startOffset" : 83,
      "endOffset" : 112
    }, {
      "referenceID" : 17,
      "context" : "Previous formulations, such as PCaches (Singh and Moore 2005) and arrays (Silander and Myllymaki 2006), could not take advantage of this structure.",
      "startOffset" : 39,
      "endOffset" : 61
    }, {
      "referenceID" : 16,
      "context" : "Previous formulations, such as PCaches (Singh and Moore 2005) and arrays (Silander and Myllymaki 2006), could not take advantage of this structure.",
      "startOffset" : 73,
      "endOffset" : 102
    }, {
      "referenceID" : 6,
      "context" : "The LP algorithm (Jaakkola et al. 2010) uses the same mechanism to identify optimal parent sets as DP; therefore, it cannot complete when all optimal parent sets do not fit in memory.",
      "startOffset" : 17,
      "endOffset" : 39
    }, {
      "referenceID" : 16,
      "context" : "We compared a Java implementation of the externalmemory frontier BFBnB search with DDD (BFBnB) to an efficient version (Silander and Myllymaki 2006) of dynamic programming which uses external memory written",
      "startOffset" : 119,
      "endOffset" : 148
    }, {
      "referenceID" : 16,
      "context" : "Previous results (Silander and Myllymaki 2006) have shown DP is more efficient than other dynamic programming implementations.",
      "startOffset" : 17,
      "endOffset" : 46
    }, {
      "referenceID" : 14,
      "context" : "Previous results (Silander and Myllymaki 2006) have shown DP is more efficient than other dynamic programming implementations. We also compared to Yuan et al.’s A* implementation (2011) (A*) and de Campos et al.",
      "startOffset" : 18,
      "endOffset" : 186
    }, {
      "referenceID" : 2,
      "context" : "’s A* implementation (2011) (A*) and de Campos et al.’s branch and bound systematic search algorithm (de Campos, Zeng, and Ji 2009) (SS) downloaded from http://www.ecse.rpi.edu/ cvrl/structlearning.html. We did not include comparison to the DP implementation of Malone et al. (2011) (MDP) because the codebase is similar; however, MDP does not incorporate pruning or delayed duplicate detection.",
      "startOffset" : 40,
      "endOffset" : 283
    }, {
      "referenceID" : 14,
      "context" : "Previous results found that memory is the main bottleneck restricting the size of learnable networks (Parviainen and Koivisto 2009).",
      "startOffset" : 101,
      "endOffset" : 131
    }, {
      "referenceID" : 14,
      "context" : "This suggests that our method should scale to larger networks better than the method of Parviainen and Koivisto (2009). They observe that their implementation would take 4 weeks on 100 processors to learn a 31-variable network, and, even with coding improvements and massive parallelization, only networks up to 34 variables would be possible.",
      "startOffset" : 88,
      "endOffset" : 119
    }, {
      "referenceID" : 14,
      "context" : "Also, like existing methods (Parviainen and Koivisto 2009; Silander and Myllymaki 2006), our algorithm can benefit from parallel computing.",
      "startOffset" : 28,
      "endOffset" : 87
    }, {
      "referenceID" : 16,
      "context" : "Also, like existing methods (Parviainen and Koivisto 2009; Silander and Myllymaki 2006), our algorithm can benefit from parallel computing.",
      "startOffset" : 28,
      "endOffset" : 87
    } ],
    "year" : 2011,
    "abstractText" : "Previous work has shown that the problem of learning the optimal structure of a Bayesian network can be formulated as a shortest path finding problem in a graph and solved using A* search. In this paper, we improve the scalability of this approach by developing a memoryefficient heuristic search algorithm for learning the structure of a Bayesian network. Instead of using A*, we propose a frontier breadth-first branch and bound search that leverages the layered structure of the search graph of this problem so that no more than two layers of the graph, plus solution reconstruction information, need to be stored in memory at a time. To further improve scalability, the algorithm stores most of the graph in external memory, such as hard disk, when it does not fit in RAM. Experimental results show that the resulting algorithm solves significantly larger problems than the current state of the art.",
    "creator" : "dvips(k) 5.98 Copyright 2009 Radical Eye Software"
  }
}