{
  "name" : "1105.5448.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Ernest Davis" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "Journal of Arti ial Intelligen e Resear h 10 (1999) 1-38 Submitted 4/98; published 1/99",
      "text" : "Order of Magnitude Comparisons of Distan eErnest Davis davise s.nyu.eduCourant InstituteNew York, NY 10012 USA Abstra tOrder of magnitude reasoning | reasoning by rough omparisons of the sizes of quan-tities | is often alled \\ba k of the envelope al ulation\", with the impli ation that the al ulations are qui k though approximate. This paper exhibits an interesting lass of on-straint sets in whi h order of magnitude reasoning is demonstrably fast. Spe i ally, wepresent a polynomial-time algorithm that an solve a set of onstraints of the form \\Pointsa and b are mu h loser together than points and d.\" We prove that this algorithm an beapplied if \\mu h loser together\" is interpreted either as referring to an in nite di eren e ins ale or as referring to a nite di eren e in s ale, as long as the di eren e in s ale is greaterthan the number of variables in the onstraint set. We also prove that the rst-order theoryover su h onstraints is de idable.1. Introdu tionOrder of magnitude reasoning | reasoning by rough omparisons of the sizes of quantities |is often alled \\ba k of the envelope al ulation\", with the impli ation that the al ulationsare qui k though approximate. Previous AI work on order of magnitude reasoning, however,has fo ussed on its expressive power and inferential stru ture, not on its omputationalleverage (Raiman, 1990; Mavrovouniotis and Stephanopoulos, 1990; Davis, 1990; Weld,1990).In this paper we exhibit an interesting ase where solving a set of order of magnitude omparisons is demonstrably mu h faster than solving the analogous set of simple order omparisons. Spe i ally, given a set of onstraints of the form \\Points a and b are mu h loser together than points and d,\" the onsisten y of su h a set an be determined inlow-order polynomial time. By ontrast, it is easily shown that solving a set of onstraintsof the form \\The distan e from a to b is less than or equal to the distan e from to d\" inone dimension is NP- omplete, and in higher dimensions is as hard as solving an arbitraryset of algebrai onstraints over the reals.In parti ular, the paper presents the following results:1. The algorithm \\solve onstraints(S)\" solves a system of onstraints of the form \\Pointsa and b are in nitely loser than points and d\" in polynomial time (Se tion 5).2. An improved version of the algorithm runs in time O(max(n2 (n)); ne; s) where n isthe number of variables, (n) is the inverse A kermann's fun tion, e is the number ofedges mentioned in the onstraint set, and s is the size of the onstraint set. (Se tion6.1).3. An extended version of the algorithm allows the in lusion of non-stri t onstraints ofthe form \\Points a and b are not in nitely further apart than points and d.\" The 1999 AI A ess Foundation and Morgan Kaufmann Publishers. All rights reserved.\nDavisrunning time for this modi ed algorithm is slower than that of solve onstraints, butstill polynomial time. (Se tion 6.2)4. A di erent extension of the algorithm allows the ombination of order of magnitude onstraints on distan es with order omparisons on the points of the form \\Point apre edes point b.\" (Se tion 6.3)5. The same algorithm an be applied to onstraints of the form \\The distan e from ato b is less than 1=B times the distan e from to d,\" where B is a given nite value,as long as B is greater than the number of variables in the onstraint set. (Se tion 7)6. The rst-order theory over su h onstraints is de idable. (Se tion 8)As preliminary steps, we begin with a small example and an informal dis ussion (Se tion2). We then give a formal a ount of order-of-magnitude spa es (Se tion 3) and presenta data stru ture alled a luster tree, whi h expresses order-of-magnitude distan e om-parisons (Se tion 4). We on lude the paper with a dis ussion of the signi an e of theseresults (Se tion 9).2. ExamplesConsider the following inferen es:Example 1: I wish to buy a house and rent oÆ e spa e in a suburb of Metropolis. Forobvious reasons, I want the house to be lose to the s hool, the house to be lose to theoÆ e, and the oÆ e to be lose to the ommuter train station. I am told that in Elmvillethe train station is quite far from the s hool, but in Newton they are lose together.Infer that I will not be able to satisfy my onstraints in Elmville, but may be able toin Newton.Example 2: The Empire State Building is mu h loser to the Washington Monument thanto Versailles. The Statue of Liberty is mu h loser both to the Empire State Building andto Carnegie Hall than to the Washington Monument.Infer that Carnegie Hall is mu h loser to the Empire State Building than to Versailles.Example 3: You have to arry out a olle tion of omputational tasks overing a widerange of diÆ ulty. For instan ea. Add up a olumn of 100 numbers.b. Sort a list of 10,000 elements. . Invert a 100 100 matrix.d. Invert a 1000 1000 matrix.e. Given the O.D.E. x = os(etx), x(0) = 0, nd x(20) to 32-bit a ura y.f. Given a online olle tion of 1,000 photographs in GIF format, use state-of-the-art image re ognition software to sele t all those that show a man onhorseba k. 2\nOrder of Magnitude Comparisons of Distan eg. Do a Web sear h until you have olle ted 100 pi tures of men on horseba k,using state-of-the-art image re ognition software.h. Using state-of-the-art theorem proving software, nd a proof that the me-dians of a triangle are on urrent.i. Using state-of-the-art theorem proving software, nd a proof of Fermat'slittle theorem.It is plausible to suppose that, in many of these ases, you an say reliably that onetask will take mu h longer than another, either by a human judgment or using an expertsystem. For instan e, task (a) is mu h shorter than any of the others. Task (b) is mu hshorter than any of the others ex ept (a) and possibly (h). Task ( ) is ertainly mu hshorter than (d), (f), (g), or (i). However, with ertain pairs su h as ( ) and (h) or ( ) and(e) it would be diÆ ult to guess whether one is mu h shorter than another, or whether theyare of omparable diÆ ulty.You have a number of independent identi al omputers, of unknown vintage and har-a teristi s, on whi h you will s hedule tasks of these kinds. Note that, under these ir um-stan es, there is no way to predi t the absolute time required by any of these tasks within a ouple of orders of magnitude. Nonetheless, the omparative lengths presumably still stand.Given: a parti ular s hedule of tasks on ma hines, infer what you an about the relativeorder of ompletion times. For example, given the following s heduleMa hine M1: tasks a,b,h,d.Ma hine M2: tasks ,i.it should be possible to predi t that (a) and (b) will omplete before ( ); that ( ) will omplete before (d); and that (d) will omplete before (i); but it will not be possible topredi t the order in whi h ( ) and (h) will omplete.In all three examples, the given information has the form \\The distan e between pointsW and X is mu h less than the distan e between Y and Z\". In examples 1 and 2, thepoints are geometri . In example 3, the points are the start and ompletion times of thevarious tasks, and the onstraints on relative lengths an be put in the form \\The distan efrom start(a) to end(a) is mu h less than the distan e from start( ) to end( )\", and so on.In example 3, there is also ordering information: the start of ea h task pre edes its end; theend of (a) is equal to the start of (b); and so on. The problem is to make inferen es basedon this weak kind of onstraint.It should be noted that these examples are meant to be illustrative, rather than se-rious appli ations. Example 1 does not extend in any obvious way to a lass of natural,large problems. Example 2 is implausible as a state of knowledge; how does the reasoner nd himself knowing just the order-of-magnitude relations among distan es and no othergeometri information? Example 3 is ontrived. Nonetheless, these illustrate the kinds ofsituations where order-of-magnitude relations on distan e do arise; where they express asubstantial part of the knowledge of the reasoner; and where inferen es based purely on theorder-of-magnitude omparisons an yield useful on lusions.The methods presented in this paper involve onstruing the relation \\Distan e D is mu hshorter than distan e E\" as if it were \\Distan e D is in nitesimal as ompared to distan eE.\" As we shall see, under this interpretation, systems of onstraints over distan es an be3\nDavissolved eÆ iently. The logi al foundations for dealing with in nitesimal quantities lie in thenon-standard model of the real line with in nitesimals, developed by Abraham Robinson(1965). (A more readable a ount is given by Keisler, 1976.) Reasoning with quantities ofin nitely di erent s ale is known as \\order of magnitude\" reasoning.The reader may ask, \\Sin e in nitesimals have no physi al reality, what is the valueof developing te hniques for reasoning about them?\" In none of the examples, after all, isthe smaller quantity truly in nitesimal or the larger one truly in nite. In example 1 and2, the ratio between su essive sizes is somewhere between 10 and 100; in example 3, itis between 100 and a rather large number diÆ ult to estimate; but one an always givesome kind of upper bound. It is essentially ertain, for instan e, that the ratio between thetimes required for tasks (a) and (i) is less than 10100;000. Why not use the best real-valuedestimate instead?The rst answer is that this is an idealization. Pra ti ally all physi al reasoning and al ulation rest on one idealization or another: the idealization in the situation al ulusthat time is dis rete; the idealization that solid obje ts are rigid, employed in most me han-i s programs; the idealization that su h physi al properties as density, temperature, andpressure are ontinuous rather than lo al averages over atoms, whi h underlies most uses ofpartial di erential equations; the idealization involved in the use of the Dira delta fun tion;and so on. Our idealization here that a very short distan e is in nitesimally smaller than along one simpli es reasoning and yields useful results as long as are is taken to stay withinan appropriate range of appli ation.The se ond answer is that this is a te hnique of mathemati al approximation, whi h weare using to turn an intra table problem into a tra table one. This would be analogous tolinearizing a non-linear equation over a small neighborhood; or to approximating a sum byan integral.There are ir umstan es where we an be sure that the approximation gives an answerthat is guaranteed exa tly orre t; namely if the a tual ratio impli it in the omparison\\D is mu h smaller than E\" is larger than the number of points involved in the system of onstraints. This will be proven in Se tion 7. There is also a broader, less well-de ned, lassof problems where the approximation, though not guaranteed orre t, is more reliable thansome of the other links in the reasoning. For instan e, suppose that one were to onsideran instan e of example 3 involving a ouple of hundred tasks, apply order-of-magnitudereasoning, and ome up with an answer that an be determined to be wrong. It is possiblethat the error would be due to the order-of-magnitude reasoning. However, it seems safeto say that, in most ases, the error is more likely to be due to a mistake in estimating the omparative sizes.3. Order-of-magnitude spa esAn order-of-magnitude spa e, or om-spa e, is a spa e of geometri points. Any two pointsare separated by a distan e. Two distan es d and e are ompared by the relation d e,meaning \\Distan e d is in nitesimal ompared to e\" or, more loosely, \\Distan e d is mu hsmaller than e.\"For example, let < be the non-standard real line with in nitesimals. Let < m be the orresponding m-dimensional spa e. Then we an let a point of the om-spa e be a point in4\nOrder of Magnitude Comparisons of Distan eR m. The distan e between two points a; b is the Eu lidean distan e, whi h is a non-negativevalue in < . The relation d e holds for two distan es d; e, if d=e is in nitesimal.The distan e operator and the omparator are related by a number of axioms, spe i edbelow. The most interesting of these is alled the om-triangle inequality: If ab and b areboth mu h smaller than xy, then a is mu h smaller than xy. This ombines the ordinarytriangle inequality \\The distan e a is less than or equal to distan e ab plus distan e b \"together with the rule from order-of-magnitude algebra, \\If p r and q r then p+q r.\"It will simplify the exposition below if, rather than talking about distan es, we talk aboutorders of magnitude. These are de ned as follows. We say that two distan es d and e havethe same order of magnitude if neither d e nor e d. In < this is the ondition that d=eis nite: neither in nitesimal nor in nite. (Raiman, 1990 uses the notation \\d Co e\" for thisrelation.) By the rules of the order-of-magnitude al ulus, this is an equivalen e relation.Hen e we an de ne an order of magnitude to be an equivalen e lass of distan es underthe relation \\same order of magnitude\". For two points a; b, we de ne the fun tion od(a; b)to be the order of magnitude of the distan e from a to b. For two orders of magnitude p; q,we de ne p q if, for any representatives d 2 p and e 2 q, d e. By the rules of the order-of-magnitude al ulus, if this holds for any representatives, it holds for all representatives.The advantage of using orders-of-magnitude and the fun tion \\od\", rather than distan esand the distan e fun tion, is that it allows us to deal with logi al equality rather than theequivalen e relation \\same order of magnitude\".For example, in the non-standard real line, let Æ be a positive in nitesimal value. Thenvalues su h as f1; 100; 2 50Æ +100Æ2 : : :g, are all of the same order of magnitude, o1. Thevalues fÆ; 1:001Æ; 3Æ + e 1=Æ : : :g are of a di erent order of magnitude o2 o1. The valuesf1=Æ; 10=Æ + Æ5 : : :g are of a third order of magnitude o3 o1.De nition 1: An order-of-magnitude spa e (om-spa e) onsists of: A set of points P; A set of orders of magnitude D; A distinguished value 0 2 D; A fun tion \\od(a; b)\" mapping two points a; b 2 P to an order of magnitude; A relation \\d e\" over two orders of magnitude d; e 2 Dsatisfying the following axioms:A.1 For any orders of magnitude d; e 2 D, exa tly one of the following holds: d e,e d, d = e.A.2 For d; e; f 2 D, if d e and e f then d f .(Transitivity. Together with A.1, this means that is a total ordering on orders ofmagnitude.)A.3 For any d 2 D, not d 0.(0 is the minimal order of magnitude.) 5\nDavisA.4 For points a; b 2 P, od(a; b) = 0 if and only if a = b.(The fun tion od is positive de nite.)A.5 For points a; b 2 P, od(a; b) = od(b; a).(The fun tion od is symmetri .)A.6 For points a; b; 2 P, and order of magnitude d 2 D,if od(a; b) d and od(b; ) d then od(a; ) d.(The om-triangle inequality.)A.7 There are in nitely many di erent orders of magnitude.A.8 For any point a1 2 P and order of magnitude d 2 D, there exists an in nite seta2; a3 : : : su h that od(ai; aj) = d for all i 6= j.The example we have given above of an om-spa e, non-standard Eu lidean spa e, is wildand woolly and hard to on eptualize. Here are two simpler examples of om-spa es:I. Let Æ be an in nitesimal value. We de ne a point to be a polynomial in Æ with integer oeÆ ients, su h as 3 + 5Æ 8Æ5. We de ne an order-of-magnitude to be a power of Æ. Wede ne Æm Æn if m > n; for example, Æ6 Æ4. We de ne od(a; b) to be the smallest powerof Æ in a b. For example, od(1 + Æ2 3Æ3; 1 5Æ2 + 4Æ4) = Æ2.II. Let N be an in nite value. We de ne a point to be a polynomial in N with integer oeÆ ients. We de ne an order of magnitude to be a power of N . We de ne Np N q ifp < q; for example, N4 N6. We de ne od(a; b) to be the largest power of N in a b. Forexample, od(1 +N2 3N3; 1 5N2 + 4N4) = N4.It an be shown that any om-spa e either ontains a subset isomorphi to (I) or a subsetisomorphi to (II). (This is just a spe ial ase of the general rule that any in nite totalordering ontains either an in nite des ending hain or an in nite as ending hain.)We will use the notation \\d e\" as an abbreviation for \\d e or d = e\".4. Cluster TreesLet P be a nite set of points in an om-spa e. If the distan es between di erent pairs ofpoints in P are of di erent orders of magnitude, then the om-spa e imposes a unique tree-like hierar hi al stru ture on P . The points will naturally fall into lusters, ea h luster Cbeing a olle tion of points all of whi h are mu h loser to one another than to any point inP outside C. The olle tion of all the lusters over P forms a stri t tree under the subsetrelation. Moreover, the stru ture of this tree and the omparative sizes of di erent lustersin the tree aptures all of the order-of-magnitude relations between any pair of points in P .The tree of lusters is thus a very powerful data stru ture for reasoning about points in anom-spa e, and it is, indeed, the entral data stru ture for the algorithms we will develop inthis paper. In this se tion, we give a formal de nition of luster trees and prove some basi results as foundations for our algorithms.De nition 2: Let P be a nite set of points in an om-spa e. A non-empty subset C P is alled a luster of P if for every x; y 2 C, z 2 P C, od(x; y) od(x; z). If C is a luster,the diameter of C, denoted \\odiam(C)\", is the maximum value of od(x; y) for x; y 2 C.6\nOrder of Magnitude Comparisons of Distan e\nn53n400 0e g 0 0 0bf n15n24 n330 0a d\nFigure 1: Cluster treeNote that the set of any single element of P is trivially a luster of P . The entire set Pis likewise a luster of P . The empty set is by de nition not a luster of P .Lemma 1: If C and D are lusters of P , then either C D, D C, or C and D aredisjoint.Proof: Suppose not. Then let x 2 C \\D, y 2 C D, z 2 D C. Sin e C is a luster,od(x; y) od(x; z). Sin eD is a luster, od(x; z) od(x; y). Thus we have a ontradi tion.2 By virtue of lemma 1, the lusters of a set P form a tree. We now develop a representa-tion of the order of magnitude relations in P by onstru ting a tree whose nodes orrespondto the lusters of P , labelled with an indi ation of the relative size of ea h luster.De nition 3: A luster tree is a tree T su h that Every leaf of T is a distin t symbol. Every internal node of T has at least two hildren. Ea h internal node of T is labelled with a non-negative value. Two or more nodesmay be given the same value. (For the purposes of Se tions 5-7, labels may be takento be non-negative integers; in Se tion 8, it will be useful to allow rational labels.) Every leaf of the tree is labelled 0. The label of every internal node in the tree is less than the label of its parent.For any node N of T , the eld \\N .symbols\" gives the set of symbols in the leaves in thesubtree of T rooted at N , and the eld \\N .label\" gives the integer label on node N .7\nDavisThus, for example, in Figure 1, n3.label=3 and n3.symbols = fa; dg; n1.label = 5 andn1.symbols = fa; b; ; d; e; f; gg.As we shall see, the nodes of the tree T represent the lusters of a set of points, and thelabels represent the relative sizes of the diameters of the lusters.De nition 4: A valuation over a set of symbols is a fun tion mapping ea h symbol to apoint in an om-spa e. If T is a luster tree, a valuation over T is a valuation over T .symbols.If N is any node in T and is a valuation over T , we will write (N) as an abbreviationfor (N .symbols).We now de ne how a luster tree T expresses the order of magnitude relations over aset of points P .De nition 5: Let T be a luster tree and let be a valuation over T . Let P = (T ), theset of points in the image of T under . We say that j=T (read satis es or instantiatesT ) if the following onditions hold:i. For any internal node N of T , (N) is a luster of P .ii. For any luster C of P , there is a node N su h that C= (N).iii. For any nodes M and N , if M .label < N .label then odiam( (M)) odiam( (N)).iv. If label(M) = 0, then odiam(M) = 0. (That is, all hildren of M are assigned thesame value under .)The following algorithm generates an instantiation given a luster tree T :pro edure instantiate(in T : luster tree; : an om-spa e)return : array of points indexed on the symbols of Tvariable G[N ℄ : array of points indexed on the nodes of T ;Let k be the number of internal nodes in T ;Choose Æ0 = 0 Æ1 Æ2 : : : Æk to be k + 1 di erent orders of magnitude;/* Su h values an be hosen by virtue of axiom A.7 */pi k a point x 2 ;G[root of T ℄ := x;instantiate1(T; ; Æ1 : : : Æk; G);return the restri tion of G to the symbols of T .end instantiate.instantiate1(in N : a node in a luster tree; : an om-spa e; Æ1 : : : Æk : orders of magnitude;in out G : array of points indexed on the nodes of T )if N is not a leaf thenlet C1 : : : Cp be the hildren of N ;x1 := G[N ℄;q := N .label;pi k points x2 : : : xp su h thatfor all i; j 2 1 : : : p, if i 6= j then od(xi; xj) = Æq;/* Su h points an be hosen by virtue of axiom A.8 */8\nOrder of Magnitude Comparisons of Distan efor i = 1 : : : p doG[Ci℄ := xi;instantiate1(Ci; ; Æ1 : : : Æk; G);endforendif end instantiate1.Thus, we begin by pi king orders of magnitude orresponding to the values of the labels.We pi k an arbitrary point for the root of the tree, and then re urse down the nodes of thetree. For ea h node N , we pla e the hildren at points that all lie separated by the desireddiameter of N . The nal pla ement of the leaves is then the desired instantiation.Lemma 2: If T is a luster tree and is an om-spa e, then instantiate(T; ) returns aninstantiation of T .The proof is given in the appendix.Moreover, it is lear that any instantiation of T an be generated as a possible outputof instantiate(T; ). (Given an instantiation , just pi k G[N ℄ at ea h stage to be of somesymbol of N .)Note that, given any valuation over a nite set of symbols S, there exists a lustertree T su h that T .symbols = S and satis es T . Su h a T is essentially unique up to anisomorphism over the set of labels that preserves the label 0 and the order of labels.5. ConstraintsIn this se tion, we develop the rst of our algorithms. Algorithm solve onstraints testsa olle tion of onstraints of the form \\a is mu h loser to b than is to d,\" for onsis-ten y. If the set is onsistent, then the algorithm returns a luster tree that satis es the onstraints. The algorithm builds the luster tree from top to bottom dealing rst with thelarge distan es, and then pro eeding to smaller and smaller distan es.Let S be a system of onstraints of the form od(a; b) od( ; d); and let T be a lustertree. We will say that T`S (read \\T satis es S\") if every instantiation of T satis es S. Inthis se tion, we develop an algorithm for nding a luster tree that satis es a given set of onstraints.The algorithm works along the following lines: Suppose we have a solution satisfying S.Let D be the diameter of the solution. If S ontains a onstraint od(a; b) od( ; d) then,sin e od( ; d) is ertainly no more than D, it follows that od(a; b) is mu h smaller than D.We label ab as a \\short\" edge.If two points u and v are onne ted by a path of short edges, then by the triangleinequality the edge uv is also short (i.e. mu h shorter than D). Thus, if we ompute the onne ted omponents H of all the edges that have been labelled short, then all these edgesin H an likewise be labelled short. For example, in table 3, edges vz, wx, and xy an allbe labelled \\short\".On the other hand, as we shall prove below, if an edge is not in the set H, then there isno reason to believe that it is mu h shorter than D. We an, in fa t, safely posit that it isthe same o.m. as D. We label all su h edges \\long\".We an now assume that any onne ted omponent of points onne ted by short edgesis a luster, and a hild of the root of the luster tree. The root of the luster tree is thengiven the largest label. Its hildren will be given smaller labels. Ea h \\long\" edge now9\nDavis onne ts symbols in two di erent hildren of the root. Hen e, any instantiation of the treewill make any long edge longer than any short edge.If no edges are labelled \\long\" | that is, if H ontains the omplete graph over thesymbols | then there is an in onsisten y; all edges are mu h shorter than the longest edge.For instan e, in table 4, sin e vw, wx, and xy are all mu h smaller than zy, it followsby the triangle inequality that vy is mu h smaller than zy. But sin e we also have the onstraints that zy is mu h smaller than vz and that vz is mu h smaller than vy, we havean in onsisten y.The algorithm then iterates, at the next smaller s ale. Sin e we have now taken are ofall the onstraints od(a; b) od( ; d), where d was labelled \\long\", we an drop all thosefrom S. Let D now be the greatest length of all the edges that remain in S. If a onstraintod(a; b) od( ; d) is in the new S, then we know that od(a; b) is mu h shorter than D, andwe label it \\short\". We ontinue as above. The algorithm halts when all the onstraints inS have been satis ed, and S is therefore empty; or when we en ounter a ontradi tion, asabove.We now give the formal statement of this algorithm. The algorithm uses an undire tedgraph over the variable symbols in S. Given su h a graph G, and a onstraint C of theform od(a; b) od( ; d), we will refer to the edge ab as the \\short\" of C, and to the edge d as the \\long\" of C. The shorts of the system S is the set of all shorts of the onstraintsof S and the longs of S is the set of all the longs of the onstraints. An edge may be both ashort and a long of S if it appears on one side in one onstraint and on the other in another onstraint.pro edure solve onstraints(in S: a system of onstraints of the form od(a; b) od( ; d))return either a luster tree T satisfying S if S is onsistent;or false if S is in onsistent.type: A node N of the luster tree ontainspointers to the parent and hildren of N ;the eld N.label, holding the integer label;and the eld N.symbols, holding the list of symbols in the leaves of N .variables: m is an integer;C is a onstraint in S;H; I are undire ted graphs;N;M are nodes of T ;begin if S ontains any onstraint of the form, \\od(a; b) od( ; )\" then return false;m := the number of variables in S;initialize T to onsist of a single node N ;N .symbols:= the variables in S;repeat H := the onne ted omponents of the shorts of S;if H ontains all the edges in S then return(false) endif;for ea h leaf N of T doif not all verti es of N are onne ted in H thenN .label := m;for ea h onne ted omponent I of N .symbols in H do10\nOrder of Magnitude Comparisons of Distan e onstru t node M as a new hild of N in T ;M .symbols:= the verti es of I ;endfor endif endforS := the subset of onstraints in S whose long is in H ;m := m 1;until S is empty;for ea h leaf N of TN .label := 0;if N .symbols has more than one symbolthen reate a leaf of N for ea h symbol in N .symbols;label ea h su h leaf 0;endif endfor end solve onstraints.Tables 3 and 4 give two examples of the working of pro edure solve onstraints. Table3 shows how the pro edure an be used to establish that the following onstraints are onsistent:The Empire State Building (x) is mu h loser to the Washington Monument (w)than to Notre Dame Cathedral (v).Bunker Hill (y) is mu h loser to the Empire State Building than to the Ei elTower (z).The distan e from the Ei el Tower to Notre Dame is mu h less than the distan efrom the Washington Monument to Bunker Hill.Table 4 shows that the following inferen e an be justi ed:Given: The distan es from the Statue of Liberty (v) to the World Trade Center(w), from the World Trade Center to the Empire State Building (x), and fromthe Empire State Building to the Chrysler Building (y) are all mu h less thanthe distan e from the Chrysler Building to the Washington Monument (z).Infer: The Washington Monument is not mu h nearer to the Chrysler Buildingthan to the Statue of Liberty.This inferen e is arried out by asserting the negation of the onsequent, \\The Washing-ton Monument is mu h nearer to the Chrysler Building than to the Statue of Liberty,\" andshowing that that olle tion of onstraints is in onsistent. Note that if we hange \\mu hless\" and \\mu h nearer\" in this example to \\less\" and \\nearer\", then the inferen e no longervalid.Theorem 1 states the orre tness of algorithm solve onstraints. The proof is given inthe appendix.Theorem 1: The algorithm solve onstraints(S) returns a luster tree satisfying S if S is onsistent, and returns false if S is in onsistent.There may be many luster trees that satisfy a given set of onstraints. Among these,the luster tree returned by the algorithm solve onstraints has an important property: ithas the fewest possible labels onsistent with the onstraints. In other words, it uses theminimum number of di erent orders of magnitude of any solution. Therefore, the algorithm an be used to he k the satis ability of a set of onstraints in an om-spa e that violates11\nDavis S ontains the onstraints1. od(w; x) od(x; v).2. od(x; y) od(y; z).3. od(v; z) od(w; y).The algorithm pro eeds as follows:Initialization:The tree is initializes to a single node with n1.n1.symbols := f v; w; x; y; z g.First iteration:The shorts of S are f wx; xy; vz g.Computing the onne ted omponents, H is set to f wx; xy;wy; vz g.n1.label := 5;Two hildren of n1 are reated:n11.symbols := w; x; y;n12.symbols := v; z;As xv is not in H, delete onstraint #1 from S.As yz is not in H, delete onstraint #2 from S.S now ontains just onstraint #3.Se ond iteration:The shorts of S are f vz g.The onne ted omponents H is just fvzg.n11.label := 4;Three hildren of n11 are reated:n111.symbols := w;n112.symbols := x;n113.symbols := z;As wy is not in H, delete onstraint #3 from S.S is now empty.Cleanup:n12.label := 0;Two hildren of n12 are reated:n121.symbols := v;n122.symbols := z;(See Figure 2.) Table 1: Example of omputing a luster tree12\nOrder of Magnitude Comparisons of Distan e\nn15n11 n12v,w,x,y,zw,x,y v,zn154n11 n12v,w,x,y,z v,zw,x,yw yx n15\nn1v,w,x,y,z0th iteration\n4n11 n12v,w,x,y,zw,x,yw yx v,zv z0\n1st iteration 2nd iteration Cleanup\nFigure 2: Building a luster tree\n13\nDavisS ontains the onstraintsod(v; w) od(z; y).od(w; x) od(z; y).od(x; y) od(z; y).od(z; y) od(v; z).The algorithm pro eeds as follows:Initialization:The tree is initializes to a single node with n1.n1.symbols := f v; w; x; y; z g.First iteration:The shorts of S are f vw;wx; xy; zy; vz g.H is set to its onne ted omponents, whi h is the omplete graph over v; w; x; y; z.The algorithm exits returning falseTable 2: Example of determining in onsisten yaxiom A.7 and has only nitely many di erent orders of magnitude. If the algorithm returnsT and T has no more di erent labels than the number of di erent orders of magnitude inthe spa e, then the onstraints are satis able. If T uses more labels than the spa e hasorders of magnitude, then the onstraints are unsatis able.The proof is easier to present if we rewrite algorithm solve onstraints in the followingform, whi h returns only the number of di erent non-zero labels used, but does not a tually onstru t the luster tree.1fun tion num labels(S);if S is empty then return(0)else return(1 + num labels(redu e onstraints(S)))fun tion redu e onstraints(S)H := onne ted omponents of the shorts of S;if H ontains all the edges in S then return(false) to top-levelelse return(the set of onstraints in S whose long is in H)It is easily veri ed that the sequen e of values of S in su essive re ursive alls tonum labels is the same as the sequen e of values of S in the main loop of solve onstraints.Therefore num labels returns the number of di erent non-zero labels in the tree onstru tedby solve onstraints.1. The reader may wonder why this simpler algorithm was not presented before the more ompli atedalgorithm solve onstraints. The reason is that the only proof we have found that the system of on-straints is onsistent if num labels does not return false relies on the relation between num labels andthe onstru tive solve onstraints. 14\nOrder of Magnitude Comparisons of Distan eTheorem 2: Out of all solutions to the set of onstraints S, the instantiations ofsolve onstraints(S) have the fewest number of di erent values of od(a; b), where a; b rangeover the symbols in S. This number is given by num labels(S).The proof is given in the appendix.6. Extensions and Consequen esWe next present a number of modi ations of the algorithm solve onstraints. The rstis a more eÆ ient implementation. The se ond extends the algorithm to handle non-stri t omparisons. The third extend the algorithm to handle a ombination of order-of-magnitude omparisons on distan e with order omparisons, in a one-dimensional spa e.6.1 An EÆ ient Implementation of Solve onstraintsIt is possible to implement algorithm solve onstraints somewhat more eÆ iently than thenaive en oding of the above des ription. The key is to observe that the graphH of onne ted omponents does not have to be omputed expli itly; it suÆ es to ompute it impli itly usingmerge- nd sets (union- nd sets). Combining this with suitable ba k pointers from edges to onstraints, we an formulate a more eÆ ient version of the algorithm.We use the following data stru tures and subroutines: Ea h node N of the luster tree ontains pointers to its parents and hildren; a eldN .label, holding the integer label; a eld N .symbols, holding the list of symbols inthe leaves of N ; and a eld N .mfsets, holding a list of the onne ted omponents ofthe symbols in N . As des ribed below, ea h onne ted omponent is implemented asan merge- nd set (MFSET). An edge E in the graph over symbols ontains its two endpoints, ea h of whi h is asymbol; a eld E.shorts, a list of the onstraints in whi h E appears as a short; anda eld E.longs, a list of the onstraints in whi h E appears as a long. A onstraint C has two elds, C.short and C.long, both of them edges. It also haspointers into the lists C.short.shorts and C.long.longs, enabling C to be removed in onstant time from the onstraint lists asso iated with the individual edges. We will use the disjoint-set forest implementation of MFSETs (Cormen, Leiserson,and Rivest, 1990, p. 448) with merging smaller sets into larger and path- ompression.Thus, ea h MFSET is a upward-pointing tree of symbols, ea h node of the tree beinga symbol. The tree as a whole is represented by the symbol at the root. A symbol Ahas then the following elds:{ A.parent is a pointer to the parent in the MFSET tree.{ A. luster leaf is a pointer to the leaf in the luster tree ontaining A.{ If A is the root of the MFSET then A.size holds the size of the MFSET.{ If A is the root of the MFSET, then A.symbols holds all the elements of theMFSET. 15\nDavis{ If A is the root of the MFSET then A.leaf ptr holds a pointer to the pointer toA in N .mfsets where N = A. luster leaf.We an now des ribe the algorithm.pro edure solve onstraints1(in S: a system of onstraints of the form od(a; b) od( ; d)).return either a luster tree T satisfying S if S is onsistent;or false if S is in onsistent.variables: m is an integer;a; b are symbols;C is a onstraint in S;H is an undire ted graph;E;F are edges;P is an MFSET;N;M are nodes of T ;0. begin if S ontains any onstraint of the form, \\od(a; b) od( ; )\" then return false;1. H := ;;2. for ea h onstraint C in S with short E and long F do3. add E and F to H ;4. add C to E.shorts and to F .longs endfor;5. m := the number of variables in S;6. initialize T to ontain the root N ;7. N .symbols := the variables in S;8. repeat for ea h leaf N of T , INITIALIZE MFSETS(N);9. for ea h edge E = ab in H do10. if E.shorts is non-empty and FIND(a) 6= FIND(b) then11. MERGE(FIND(a), FIND(b)) endif endfor12. if every edge E = ab in H satis es FIND(a) = FIND(b)13. then return(false) endif14. for ea h urrent leaf N of T do15. if N .mfsets has more than one element then16. for ea h mfset P in N .mfsets do17. onstru t node M as a new hild of N in T ;18. M .symbols:= P .symbols;19. endfor endif endfor20. for ea h edge E = ab in H do21. if FIND(a) 6= FIND(b) then22. for ea h onstraint C in E.longs do23. delete C from S;24. delete C from E.longs;25. delete C from C.short.shorts endfor26. delete E from H endif endfor27. m := m 1;28. until S is empty;29. for ea h leaf N of T30. N .label := 0;31. if N .symbols has more than one symbol16\nOrder of Magnitude Comparisons of Distan e32. then reate a leaf of N with label 0 for ea h symbol in N .symbols;33. endif endfor end solve onstraints1.pro edure INITIALIZE MFSETS(N : node)var A : symbol;N .mfsets := ;;for A in N .symbols doA.parent := null;A. luster leaf := N ;A.symbols := fAg;A.size := 1;N .mfsets := ons(A,N .mfsets);A.leaf ptr := N .mfsets;endfor end INITIALIZE MFSETS.pro edure MERGE(in A;B : symbol)if A.size > B.size then swap(A;B);A.parent := B;B.size := B.size + A.size;B.symbols := B.symbols [ A.symbols;Using A.leaf ptr, delete A from A. luster leaf.mfsets;end MERGE.pro edure FIND(in A : symbol) return symbol;var R : symbol;if A.parent = null then return Aelse R := FIND(A.parent);A.parent := R; /* Path ompression */return(R)end FIND.Let n be the number of symbols in S; let e be the number of edges; and let s be thenumber of onstraints. Note that n=2 e n(n 1)=2 and that e=2 s e(e 1)=2.The running time of solve onstraints1 an be omputed as follows. As ea h iteration of themain loop 8-28 splits at least one of the onne ted omponents of H, there an be at mostn 1 iterations. The MERGE-FIND operations in the for loop 9-11 take together timeat most O(max(n (n); e)) where (n) is the inverse A kermann's fun tion. Ea h iterationof the inner for loop lines 16-18 reates one node M of the tree. Therefore, there areonly O(n) iterations of this loop over the entire algorithm. Lines 14, 15 of the outer forloop require at most n iterations in ea h iteration of the main loop. The for loop 22-26is exe uted exa tly on e in the ourse of the entire exe ution of the algorithm for ea h onstraint C, and hen e takes at most time O(s) over the entire algorithm. Steps 20-21require time O(e) in ea h iteration of the main loop. It is easily veri ed that the remainingoperations in the algorithm take no more time than these. Hen e the overall running timeis O(max(n2 (n); ne; s)). 17\nDavis6.2 Adding Non-stri t ComparisonsThe algorithm solve onstraints an be modi ed to deal with non-stri t omparisons of theform od(a; b) od( ; d) by, intuitively, marking the edge ab as \\short\" on ea h iteration ifthe edge d has been found to be short.Spe i ally, in algorithm solve onstraints, we make the following two hanges. First,the revised algorithm takes two parameters: S, the set of stri t onstraints, and W, the setof non-stri t onstraints. Se ond, we repla e the lineH := the onne ted omponents of the shorts of Swith the following ode:1. H := the shorts of S;2. repeat H := the onne ted omponents of H ;3. for ea h weak onstraint od(a; b) od( ; d)4. if d is in H then add ab to H endif endfor5. until no hange has been made to H in the last iteration.The proof that the revised algorithm is orre t is only a slight extension of the proof oftheorem 1 and is given in the appendix.Optimizing this algorithm for eÆ ien y is a little involved, not only be ause of the newoperations that must be in luded, but also be ause there are now four parameters | n, thenumber of symbols; e, the number of edges mentioned; s, the number of stri t omparison;and w, the number of non-stri t omparisons | and the optimal implementation variesdepending on their relative sizes. In parti ular, either s or w, though not both, may bemu h smaller than n, and ea h of these ases requires spe ial treatment for optimal eÆ ien y.The best implementation we have found for the ase where both s and w are (n) has arunning time of O(max(n3; nw; s)). The details of the implementation are straightforwardand not of suÆ ient interest to be worth elaborating here.An immediate onsequen e of this result is that a ouple of problems of inferen e areeasily omputed: To determine whether a onstraint C is the onsequen e of a set of onstraints S,form the set S [ :C and he k for onsisten y. If S [ :C is in onsistent then Sj=C.Note that the negation of the onstraint od(a; b) od( ; d) is the onstraintod( ; d) od(a; b). To determine whether two sets of onstraints are logi ally equivalent, he k that ea h onstraint in the rst is a onsequen e of the se ond, and vi e versa.6.3 Adding Order ConstraintsExample 3 of Se tion 2 involves a ombination of order-of-magnitude onstraints on dis-tan es together with simple ordering on points, where the points lie on a one-dimensionalline. We next show how to extend algorithm solve onstraints to deal with this more om-plex situation. 18\nOrder of Magnitude Comparisons of Distan eIn terms of the axiomati s, adding an ordering on points involves positing that therelation p < q is a total ordering and that the ordering of points is related to order ofmagnitude omparisons of distan es through the following axiom.A.9 For points a; b; 2 P, if a < b < then od(a; b) od(a; ).The following rule is easily dedu ed: If C and D are disjoint lusters, then either everypoint in C is less than all the points in D, or vi e versa.In extending our algorithm, we begin by de ning an ordered luster tree to be a lustertree where, for every internal node N , there is a partial order on the hildren of N . If Aand B are hildren of N and A is ordered before B, then in an instantiation of the tree,every leaf of A must pre ede every leaf of B. Pro edure instantiate1 an then be modi edto deal with ordered luster trees as follows:instantiate1(in N : a node in a luster tree; : an om-spa e; Æ1 : : : Æk : orders of magnitude;in out G : array of points indexed on the nodes of T )if N is not a leaf thenlet C1 : : : Cp be the hildren of N in topologi ally sorted order;x0 := G[N ℄;q := N .label;pi k points x1 : : : xp in in reasing order su h thatfor all i; j 2 0 : : : p, if i 6= j then od(xi; xj) = Æq;/* Su h points an be hosen by virtue of axiom A.8 */for i = 1 : : : p doG[Ci℄ := xi;instantiate1(Ci; ; Æ1 : : : Æk; G)endforendif end instantiate1.Algorithm solve onstraints is modi ed as follows:pro edure solve onstraints2(in S: a system of onstraints of the form od(a; b) od( ; d) ;fNEWg O : a system of onstraints of the form a < b)return either an ordered luster tree T satisfying Sif S is onsistent;or false if S is in onsistent.variables: m is an integer;C is a onstraint in S;H; I are undire ted graphs;M;N;P are nodes of T ;a; b; ; d are symbols;begin if S ontains any onstraint of the form, \\od(a; b) od( ; )\"then return false;fNEWg if O is internally in onsistent ( ontains a y le) then return false;m := the number of variables in S;initialize T to onsist of a single node N ;N .symbols:= the variables in S;repeat H := the onne ted omponent of the shorts of S;19\nDavisfNEWg H := in orporate order(H;O);if H ontains all the edges in S then return falsefor ea h leaf N of T doif not all verti es of N are onne ted in H thenN .label := m;for ea h onne ted omponent I of N .symbols in H do onstru t node M as a new hild of N in T ;M .symbols:= the verti es of I ;endfor endiffNEWg for ea h onstraint a < b 2 OfNEWg if a is in M .symbols and b is in P .symbolsfNEWg where M and P are di erent hildren of NfNEWg then add an ordering ar from M to P ;fNEWg endif endforendforS := the subset of onstraints in S whose long is in H ;m := m 1;until S is empty;for ea h leaf N of TN .label := 0;if N .symbols has more than one symbolthen reate a leaf of N for ea h symbol in N .symbols;label ea h su h leaf 0;endif endforend solve onstraints2.fNEWgfun tion in orporate order(in H : undire ted graph;O : a system of onstraints of the form a < b)return undire ted graph;variables: G : dire ted graph;a; b : verti es in H ;A;B : onne ted omponents of H ;V [A℄ : array of verti es of G indexed on onne ted omponents of H ;I : subset of verti es of G;for ea h onne ted omponent A of H reate a vertex V [A℄ in G;for ea h onstraint a < b 2 Olet A and B be the onne ted omponents of H ontaining a and b respe tively;if A 6= B then add an ar in G from V [A℄ to V [B℄ endif endfor;for ea h strongly onne ted omponent I of G dofor ea h pair of distin t verti es V [A℄; V [B℄ 2 I dofor ea h a 2 A and b 2 B add the edge ab to H endfor endforendfor 20\nOrder of Magnitude Comparisons of Distan eend in orporate order.Fun tion in orporate order serves the following purpose. Suppose that we are in themidst of the main loop of solve onstraints2, we have a partially onstru ted luster tree,and we are urrently working on nding the sub- lusters of a node N . As in the originalform of solve onstraints, we nd the onne ted omponents of the shorts of the order-of-magnitude onstraints. Let these be C1 : : : Cq; then we know that the diameter of ea h Ciis mu h smaller than the diameter of N . Now, suppose, for example, that we have in O the onstraints a1 < a5; b5 < b2; 2 < 1, where a1; 1 2 C1; b2; 2 2 C2; and a5; b5 2 C5. Thenit follows from axiom A.9 that C1, C2, and C5 must all be merged into a single luster,whose diameter will be less than the diameter of N . Pro edure in orporate order nds allsu h loops by onstru ting a graph G whose verti es are the onne ted omponents of Hand whose ar s are the ordering relations in O and then omputing the strongly onne ted omponents of G. (Re all that two verti es u; v in a dire ted graph are in the same strongly onne ted omponent if there is a y le from u to v to u.) It then merges together all ofthe onne ted omponents of H that lie in a single strongly onne ted omponent of G.The proof of the orre tness of algorithm solve onstraints2 is again analogous in stru -ture to the proof of theorem 1, and is given in the appendix.By implementing this in the manner of Se tion 6.1, the algorithm an be made to runin time O(max(n2 (n); ne; no; s)), where o is the number of onstraints in O.7. Finite order of magnitude omparisonIn this se tion, it is demonstrated that algorithm solve onstraints an be applied to systemsof onstraints of the form \\dist(a; b) < dist( ; d) / B\" for nite B in ordinary Eu lideanspa e as long as the number of symbols in the onstraint network is smaller than B.We ould be sure immediately that some su h result must apply for nite B. It isa fundamental property of the non-standard real line that any senten e in the rst-ordertheory of the reals that holds for all in nite values holds for any suÆ iently large nitevalue, and that any senten e that holds for some in nite value holds for arbitrarily large nite values. Hen e, sin e the answer given by algorithm solve onstraints works over aset of onstraints S when the onstraint \\od(a; b) od( ; d)\" is interpreted as \\od(a; b)< od( ; d)/B for in nite B\", the same answer must be valid for suÆ iently large nite B.What is interesting is that we an nd a simple hara terization of B in terms of S; namely,that B is larger than the number of symbols in S.We begin by modifying the form of the onstraints, and the interpretation of a lustertree. First, to avoid onfusion, we will use a four-pla e predi ate \\mu h loser(a; b; ; d)\"rather than the form \\od(a; b) od( ; d)\" as we are not going to give an interpretation to\\od\" as a fun tion. We x a nite value B > 1, and interpret \\mu h loser(a; b; ; d)\" tomean \\dist(a; b) < dist( ; d) / B.\"We next rede ne what it means for a valuation to instantiate a luster tree:De nition 6: Let T be a luster tree and let be a valuation on the symbols in T . We saythat `T if the following holds: For any symbols a; b; ; d in T , let M be the least ommonan estor of a; b and let N be the least ommon an estor of ; d. If M .label < N .label thenmu h loser(a; b; ; d). 21\nDavisPro edure \\instantiate\", whi h generates an instantiation of a luster tree, is modi edas follows:pro edure instantiate(in T : luster tree; : Eu lidean spa e; B : real);return : array of points indexed on the symbols of T ;Let n be the number of nodes in T ; := 2 + 2n+Bn;Choose Æ1; Æ2 : : : Æn su h that Æi < Æi+1= ;pi k a point x 2 ;G[T ℄ := x;instantiate1(T; ; Æ1 : : : Æn; G);return the restri tion of G to the symbols of T .end instantiate.instantiate1(in N : a node in a luster tree; : a Eu lidean spa e;Æ1 : : : Æn : orders of magnitude;in out G : array of points indexed on the nodes of T )if N is not a leaf thenlet C1 : : : Cp be the hildren of N ;x1 := G[N ℄;q := N .label;pi k points x2 : : : xp su h thatfor all i; j 2 1 : : : p, if i 6= j then Æq dist(xi; xj) < nÆq/* This is possible sin e p n. */for i = 1 : : : p doG[Ci℄ := xi;instantiate1(Ci; ; Æ1 : : : Æn; G)endforendif end instantiate1.The analogue of lemma 2 holds for the revised algorithm:Lemma 22: Any luster tree T has an instantiation in Eu lidean spa e <m of any dimen-sionality m.We an now state theorem 3, whi h asserts the orre tness of algorithm \\solve onstraints\"in this new setting:Theorem 3: Let S be a set of onstraints over n variables of the form \\dist(a; b) <dist( ; d) / B\", where B > n. The algorithm solve onstraints(S) returns a luster treesatisfying S if S is onsistent over Eu lidean spa e, and returns false if S is in onsistent.The proofs of lemma 22 and theorem 3 are given in the appendix.An examination of the proof of lemma 22 shows that this result does not depend onany relation between n and B. Therefore, if solve onstraints(S) returns a tree T , then Sis onsistent and T satis es S regardless of the relation between n and B. However, it ispossible for S to be onsistent and solve onstraints(S) to return false if n B. On theother hand, one an see from the proof of theorem 3 (parti ularly lemma 23) that if B > nand solve onstraints(S) returns false then S is in onsistent in any metri spa e. However,there are metri spa es other than <m in whi h the luster tree returned by solve onstraintsmay have no instantiation. 22\nOrder of Magnitude Comparisons of Distan e8. The rst-order theoryOur nal result asserts that if the om-spa e is ri h enough then the full rst-order languageof order-of-magnitude distan e omparisons is de idable. Spe i ally, if the olle tion oforders of magnitude is dense and unbounded above, then there is a de ision algorithm for rst-order senten es over the formula, \\od(W;X) od(Y;Z)\" that runs in time O(4n(n!)2s)where n is the number of variables in the senten e and s is the length of the senten e.The basi reason for this is the following: As we have observed in orollary 4, a lustertree T determines the truth value of all onstraints of the form \\od(a; b) od( ; d)\" wherea; b; ; d are symbols in the tree. That is, any two instantiations of T in any two om-spa es agree on any su h onstraint. If we further require that the om-spa es are denseand unbounded, then a mu h stronger statement holds: Any two instantiations of T oversu h om-spa es agree on any rst-order formula free in the symbols of T over the relation\\od(W;X) od(Y;Z)\". Hen e, it suÆ es to he k the truth of a senten e over all possible luster trees on the variables in the senten e. Sin e there are only nitely many lustertrees over a xed set of variables (taking into a ount only the relative order of the labelsand not their numeri values), this is a de idable pro edure.Let L be the rst-order language with equality with no onstant or fun tion symbols,and the single predi ate symbol \\mu h loser(a; b; ; d)\". It is easily shown that L is asexpressive as the language with the fun tion symbol \\od\" and the relation symbol .De nition 7: An om-spa e with orders of magnitude D is dense if it satis es thefollowing axiom:A.9 For all orders of magnitude Æ1 Æ3 in D, there exists a order of magnitude Æ2 in Dsu h that Æ1 Æ2 Æ3. is unbounded above if it satis es the following:A.10 For every order of magnitude Æ1 in D there exists Æ2 in D su h that Æ1 Æ2.If D is the olle tion of orders of magnitude in the hyperreal line, then both of theseare satis ed. In axiom [A.9℄, if 0 Æ1 Æ3, hoose Æ2 = pÆ1Æ3, the geometri mean.If 0 = Æ1 Æ3, hoose Æ2 = Æ3Æ where Æ 1. In axiom [A.10℄ hoose Æ2 = Æ1=Æ where0 < Æ 1.De nition 8: Let T be a luster tree. Let l0 = 0; l1; l2 : : : lk be the distin t labels in Tin as ending order. An extending label for T is either (a) li for some i; (b) lk +1 (note thatlk is the label of the root); ( ) (li 1 + li)=2 for some i between 1 and k.Note that if T has k distin t non-zero labels, then there are 2k + 2 di erent extendinglabels for T .De nition 9: Let T be a luster tree. Let x be a symbol not in T . The luster treeT 0 extends T with x if T 0 is formed from T by applying one of the following operations (asingle appli ation of a single operation).1. T is the null tree and T 0 is the tree ontaining the single node x.23\nDavis2. T onsists of the single node for symbol y. Make a new node M , make both x and y hildren of M , and set the label of M to be either 0 or 1.3. For any internal node N of T (in luding the root), make x a hild of N .4. Let y be a symbol in T , and let N be its father. If N .label 6= 0, reate a new node Mwith an extending label for T su h that M .label < N .label. Make M a hild of N ,and make x and y hildren of M .5. Let C be an internal node of T other than the root, and let N be its father. Createa new node M with an extending label for T su h that C.label < M .label < N .label.Make M a hild of N and make x and C hildren of M .6. Let R be the root of T . Create a new nodeM su h thatM .label = R.label + 1. MakeR and x hildren of M . Thus M is the root of the new tree T 0.(See Figure 3.)Note that if T is a tree of n symbols and at most n 1 internal nodes then There are n 1 ways to arry out step 3. There are n possible ways to hoose symbol y in step 4, and at most 2n 2 for thelabel on M in ea h. There are at most n 2 di erent hoi es for C in step 5, and at most 2n 3 hoi esfor the label on M in ea h. There is only one way to arry out step 6.Hen e, there are less than 4n2 di erent extensions of T by x. (This is almost ertainlyan overestimate by at least a fa tor of 2, but the nal algorithm is so entirely impra ti althat it is not worthwhile being more pre ise.)De nition 10: Let T be a luster tree, and let be a formula of L open in the variablesof T . T satis es if every instantiation of T satis es .Theorem 4: Let T be a luster tree. Let be an open formula in L, whose free variablesare the symbols of T . Let be an om-spa e that is dense and unbounded above. Algorithmde ide(T; ) returns true if T satis es and false otherwise.fun tion de ide(T : luster tree; : formula) return boolean onvert to an equivalent form in whi h the only logi al symbols in are: (not), ^ (and), 9 (exists), = (equals) and variable names,and the only non-logi al symbol is the predi ate \\mu h loser\". ase has form X = Y : return (distan e(X;Y; T ) = 0); has form \\mu h loser(W;X; Y; Z)\": return distan e(W;X; T ) < distan e(Y; Z; T )); has form : : return not(de ide(T; )) has form ^ : return(de ide(T; ) and de ide(T; )) has form 9X ; 24\nDavisif for some extension T 0 of T by X , de ide(T 0; ) = truethen return trueelse return false endif end aseend de idefun tion distan e(X;Y : symbol; T : luster tree) return integerN := the ommon an estor of X and Y in T ;return(N .label)end distan eThe proof of theorem 4 is given in the appendix.Running time: As we have remarked above, for a tree T of size k there are at most 4k2extensions of T to be onsidered. The total number of luster trees onsidered is thereforebounded by nk=14k2 = 4n(n!)2. It is easily veri ed that the logi al operators other thanquanti ers add at most a fa tor of s where s is the length of the senten e. Hen e the runningtime is bounded by O(4n(n!)2s).A key lemma, of interest in itself, states the following:Lemma 28: Let T be a luster tree. Let be an open formula in L, whose free variablesare the symbols of T . Let be an om-spa e that is dense and unbounded above. If oneinstantiation of T in satis es then every instantiation of T in satis es .That is, either is true for all instantiations of T or for none. The proof is given in theappendix.It should be observed that the above onditions on in lemma 28 are ne essary, andthat the statement is false otherwise. For example, let be the om-spa e des ribed inexample I, Se tion 3, of polynomials over an in nitesimal Æ. Then is not unboundedabove; there is a maximum order-of-magnitude O(1). Let T be the starting tree of Figure3 (upper-left orner). Let be the formula \\9X od(V;W ) od(W;X)\", free in V and W .Then the valuation fU ! Æ; V ! 0;W ! 1g satis es T but not , whereas the valuationfU ! Æ2; V ! 2Æ2;W ! Æg satis es both T and .9. Con lusionsThe appli ations of the spe i algorithms above are undoubtedly limited; we are not awareof any pra ti al problems where solving systems of order-of-magnitude relations on distan esis the entral problem. However, the potential appli ations of order-of-magnitude reasoninggenerally are very widespread. Ordinary ommonsense reasoning involves distan es span-ning a ratio of about 108, from a fra tion of an in h to thousands of miles, and durationsspanning a ratio of about 1010, from a fra tion of a se ond to a human lifetime. S ienti reasoning spans mu h greater ranges. Explaining the dynami s of a star ombines reasoningabout nu lear rea tions with reasoning about the star as a whole; these di er by a ratioof about 1057. The te hniques needed to ompute with quantities of su h vastly di eringsizes are quite di erent from the te hniques needed to ompute with quantities all of similarsizes. This paper is a small step in the development and analysis of su h omputationalte hniques.The above results are also signi ant in the en ouragement that they give to the hopethat order-of-magnitude reasoning spe i ally, and qualitative reasoning generally, may lead26\nOrder of Magnitude Comparisons of Distan eto useful qui k reasoning strategies in a broader range of problems. It has been often foundin AI that moving from greater to lesser pre ision in the mode of inferen e or type ofknowledge does not lead to qui k and dirty heuristi te hniques, but rather to slow anddirty te hniques. Nonmonotoni reasoning is the most notorious example of this, but itarises as well in many other types of automated reasoning, in luding qualitative spatial andphysi al reasoning. The algorithms developed in this paper are a wel ome ex eption tothis rule. We are urrently studying algorithmi te hniques for other order-of-magnitudeproblems, and are optimisti of nding similar favorable results.A knowledgementsThis resear h has been supported by NSF grant #IRI-9625859. Thanks to Ji-Ae Shin,Andrew Gelsey, and the reviewers for helpful omments.Appendix A. ProofsIn this appendix, we give the proofs of the various results asserted in the body of the paper.Proof of Lemma 2Lemma 2: If T is a luster tree and is an om-spa e, then instantiate(T; ) returns aninstantiation of T .Proof: Let Æ0 = 0. For any node N , if i=N .label, we de ne (N) = Æi. The proof thenpro eeds in the following steps:i. For any nodes M ,N , if M is a des endant of N in T then od(G[M ℄; G[N ℄) (N).Proof: If M is a hild of N , then this is immediate from the onstru tion of x2 : : : xpin instantiate1. Else, let N = N1; N2 : : : Nq = M be the path from N to M throughT . By the de nition of a luster tree, it follows that Ni.label < N .label, for i > 1 andtherefore (Ni) (N). Thus od(G[M ℄; G[N ℄) (by the o.m.-triangle inequality)maxi=1:::q 1(od(G[Ni+1℄; G[Ni℄)) maxi=1:::q 1( (Ni)) (sin e Ni+1 is the hild ofNi) (N).ii. Let N be a node in T ; let C1 and C2 be two distin t hildren of N ; and let M1and M2 be des endants of C1 and C2 respe tively. Then od(G[M1℄; G[M2℄) = (N).Proof: By the onstru tion of x2 : : : xp in instantiate1(N), od(G[C1℄; G[C2℄) = (N).By part (i.), od(G[M1℄; G[C1℄) (C1) (N) and likewise od(G[M2℄; G[C2℄) (N). Hen e, by axiom A.6, od(G[M1℄; G[M2℄) = (N).iii. Let a and b be any two leaves in T , and let N be the least ommon an estor in T ofa and b. Then od(G[a℄; G[b℄) = (N). Proof: Immediate from (ii).iv. For any node N , odiam( (N)) = (N). Proof: From (iii), any two leaves des endingfrom di erent hildren of N are at a distan e of order (N), and no two leaves of Nare at a distan e of order greater than (N).27\nDavisv. For any node N , (N) is a luster of (T ). Proof: Let a and b be leaves of N ,and let be a leaf of T N . Let I be the ommon an estor of a and b in T andlet J be the ommon an estor of a and . Then I is either N or a des endant of Nand J is a proper an estor of N . Therefore by part (i), (I) (J). But by (iii),od( (a); (b)) = (I) (J) = od( (a); ( )).vi. For any internal nodesN;M ifM .label< N .label then odiam( (M)) odiam( (N)).Proof: Immediate from (iv) and the onstru tion of .vii. If C is a luster of (T ) then there is a node N in T su h that C = (N). Proof: LetS be the set of symbols orresponding to C and let N be the least ommon an estorof all of S. Let a and b be two symbols in S that are in di erent subtrees of N . Thenby (iii), od(G[a℄; G[b℄) = (N). Let x be any symbol in N .symbols. Then by (iii)od(G[a℄; G[x℄) (N). Hen e G[x℄ 2 C.2Proof of Theorem 1We here prove the orre tness of algorithm solve onstraints. We will assume throughoutthat the two variables in the long of any onstraint in S are distin t.Lemma 3: Let T be a luster tree and let be an instantiation of T . Let a and b besymbols of T . Let N be the least ommon an estor of a and b in T . Then od( (a); (b)) =odiam( (N)).Proof: Sin e (a) and (b) are elements of (N), it follows from the de nition of odiam thatod( (a); (b)) odiam( (N)). Suppose the inequality were stri t; that is, od( (a); (b)) odiam( (N)). Then let C be the set of all the symbols of T su h that od( (a); ( )) od( (a); (b)). Then odiam( (C)) = od( (a); (b)) odiam( (N)). It is easily shownthat (C) is a luster in (T ). Therefore, by property (ii) of de nition 5, there must bea node M su h that M .symbols = C. Now, M is ertainly not an an estor of N , sin eodiam( (M)) odiam( (N)) but M .symbols ontains both a and b. But this ontradi tsthe assumption that N was the least ommon an estor of a and b. 2Corollary 4: Let T be a luster tree and let be an instantiation of T . Let a; b; ; d besymbols of T . Let N be the least ommon an estor of and d in T , and let M be theleast ommon an estor of a and b in T . Then od( (a); (b)) od( ( ); (d)) if and only ifM .label < N .label.Proof: Immediate from lemma 3 and property (iii) of de nition 5 of instantiation. 2Lemma 5: Let S be any set of onstraints of the form od(a; b) od( ; d). Let H be the onne ted omponents of the shorts of S. If S is onsistent, then not every edge of S is inH.Proof: Let be a valuation satisfying S. Find an edge pq in S for whi h od( (p); (q)) ismaximal. Now, if ab is a short of S | that is, there is a onstraint od(a; b) od( ; d) inS | then od( (a); (b)) od( ( ); (d)) od( (p); (q)).28\nOrder of Magnitude Comparisons of Distan eNow, let ab be any edge in H, the onne ted omponents of the shorts of S. Then thereis a path a1 = a; a2 : : : ak = b su h that the edge aiai+1 is a short of S for i = 1 : : : k 1.Thus, by the om-triangle inequality, od( (a); (b)) maxi=1::k 1(od( (ai); (ai+1))) od( (p); (q)). Hen e pq 6= ab, so pq is not in H. 2Lemma 6: The values of S and H in any iteration are supersets of their values in any lateriteration.Proof: S is reset to a subset of itself at the end of ea h iteration. H is de ned in terms ofS in a monotoni manner. 2Lemma 7: S annot be the same in two su essive iterations of the main loop.Proof: by ontradi tion. Suppose that S is the same in two su essive iterations. Then Hwill be the same, sin e it is de ned in terms of S. H is onstru ted to ontain all the shortsof S, Sin e the resetting of S at the end of the rst iteration does not hange S, H must ontain all the longs as well. Thus, H ontains all the edges in S. But that being the ase,the algorithm should have terminated with failure at the beginning of the rst iteration. 2Lemma 8: Algorithm solve onstraints always terminates.Proof: By lemma 7, if the algorithm does not exit with failure, then on ea h iteration some onstraints are removed from S. Hen e, the number of iterations of the main loop is atmost the original size of S. Everything else in the algorithm is learly bounded. (Note thatthis bound on the number of iterations is improved in Se tion 6.1 to n 1, where n is thenumber of symbols.) 2Lemma 9: If algorithm solve onstraints returns false, then S is in onsistent.Proof: If the algorithm returns false, then the transitive losure of the shorts of S ontainsall the edges in S. By lemma 5, S is in onsistent.Lemma 10: If onstraint C of form od(a; b) od( ; d) is in the initial value of S, andedge d is in H in some parti ular iteration, then onstraint C is in S at the start of thatiteration.Proof: Suppose that C is deleted from S on some parti ular iteration. Then edge d, thelong of C, annot be in H in that iteration. That is, it is not possible for edge d to persistin H in an iteration after C has been deleted from S. Note that, by lemma 6, on e d iseliminated from H, it remains out of H. 2Lemma 11: The following loop invariant holds: At the end of ea h loop iteration, thevalues of L.symbols, where L is a leaf in the urrent state of the tree, are exa tly the onne ted omponents of H.Proof: In the rst iteration, T is initially just the root R, ontaining all the symbols, anda hild of R is reated for ea h onne ted omponent of H.Let Ti and Hi be the values of T and H at the end of the ith iteration. Suppose thatthe invariant holds at the end of the kth iteration. By lemma 6, Hk+1 is a subset of Hk.Hen e, ea h onne ted omponent of Hk+1 is a subset of a onne ted omponent of Hk.29\nDavisMoreover, ea h onne ted omponent J of Hk is either a onne ted omponent of Hk+1 oris partitioned into several onne ted omponents of Hk+1. In the former ase, the leaf ofTk orresponding to J is un hanged and remains a leaf in Tk+1. In the latter ase, the leaf orresponding to J gets assigned one hild for ea h onne ted omponent of Hk+1 that is asubset of J . Thus, the onne ted omponents of Hk+1 orrespond to the leaves of Tk+1. 2Lemma 12: If pro edure solve onstraints does not return false, then it returns a well-formed luster tree T .Proof: Using lemma 11, and the leanup se tion of solve onstraints whi h reates the nalleaves for symbols, it follows that every symbol in S ends up in a single leaf of T . As m isde remented on ea h iteration, and as no iteration adds both a new node and hildren ofthat node, it follows that the label of ea h internal node is less than the label of its father.Hen e the onstraints on luster trees (de nition 3) are satis ed. 2Lemma 13: Let a; b be two distin t symbols in S and let T be the luster tree returnedby solve onstraints for S. Let N be the least ommon an estor of a; b in T . Then either Nis assigned its label on the rst iteration when the edge ab is not in H, or the edge ab is inthe nal value of H when the loop is exited and N is assigned its label in the nal leanupse tion.Proof: As above, let Hi be the value of H in the ith iteration.If N is the root, then it is assigned its label in the rst iteration. Clearly, a and b, beingin di erent subtrees of N , must be in di erent onne ted omponents of H1.Suppose N is assigned its label in the kth iteration of the loop for k > 1. By lemma 11,at the end of the previous iteration, N .symbols was a onne ted omponent of Hk 1, and ittherefore ontained the edge ab. Sin e N is the least ommon an estor of a; b, it follows thata and b are pla ed in two di erent hildren of N ; hen e, they are in two di erent onne ted omponents of Hk. Thus the edge ab annot be in Hk.Suppose N is assigned its label in the leanup se tion of the algorithm. Then by lemma11, N .symbols is a onne ted omponent of the nal value of H. Hen e the edge ab was inthe nal value of H. 2Lemma 14: Let S initially ontain onstraint C of form od(a; b) od( ; d). Suppose thatsolve onstraints(S) returns a luster tree T . Let M be the least ommon an estor of a; bin T and let N be the least ommon an estor of ; d. Then M .label < N .label.Proof: Suppose N is given a label in a given iteration. By lemma 13, d is eliminatedfrom H in that same iteration. By lemma 10, onstraint C must be in S at the start of theiteration. Hen e ab is a short of S in the iteration, and is therefore in H. Hen e M is notgiven a label until a later iteration, and therefore is given a lower label.It is easily seen that d annot be in H in the nal iteration of the loop, and hen e Nis not assigned its label in the leanup se tion. 2Lemma 15: Suppose that solve onstraints(S) returns a luster tree T . Then any instan-tiation of T satis es the onstraints S.Proof: Immediate from lemma 14 and orollary 4.30\nOrder of Magnitude Comparisons of Distan eTheorem 1: The algorithm solve onstraints(S) returns a luster tree satisfying S if S is onsistent, and returns false if S is in onsistent.Proof: If solve onstraints(S) returns false, then it is in onsistent (lemma 9). If it doesnot return false, then it returns a luster tree T (lemma 12). Sin e T has an instantiation(lemma 2) and sin e every instantiation of T is a solution of S (lemma 15), it follows thatS is onsistent and T satis es S. 2Proof of Theorem 2Lemma 16: If S1 and S2 are onsistent sets of onstraints, and S1 S2 thenredu e onstraints(S1) redu e onstraints(S2).Proof: Immediate by onstru tion. The value ofH in the ase of S1 is a superset of its valuein the ase of S2, and hen e redu e onstraints(S1) is a superset of redu e onstraints(S2).Lemma 17: If S1 and S2 are onsistent sets of onstraints, and S1 S2 then num labels(S1) num labels(S2).Proof by indu tion on num labels(S2). If num labels(S2) = 0, the statement is trivial.Suppose that the statement holds for all S 0, where num labels(S 0) = k.Let num labels(S2) = k + 1.Then k + 1 = num labels(S2) = 1 + num labels(redu e onstraints(S2)), sok =num labels(redu e onstraints(S2)). Now, suppose S1 S2. By lemma 16redu e onstraints(S1) redu e onstraints(S2). But then by the indu tive hypothesisnum labels(redu e onstraints(S1)) num labels(redu e onstraints(S2)), sonum labels(S1) num labels(S2). 2Lemma 18: Let S be a set of onstraints, and let be a solution of S. For any graph Gover the symbols of S, let nd(G; ) be the number of di erent non-zero values of od(a; b)where edge ab is in G. Let edges(S) be the set of edges in S. Then nd(edges(S), ) num labels(S).Proof: by indu tion on num labels(S). If num labels(S) = 0, then the statement is trivial.Suppose for some k, the statement holds for all S 0 where num labels(S 0) = k, and supposenum labels(S) = k+1. Let pq be the edge in S of maximal length. For any set of edges E,let small-edges(E; ) be the set of all edges ab in E for whi hod( (a); (b)) od( (p); (q)). Sin e small-edges(E) ontains edges of every order ofmagnitude in E ex ept the order of magnitude of pq, it follows thatnd(small-edges(E; ), ) = nd(E; ) 1. Let G be the omplete graph over all the symbolsin S. By the same argument as in lemma 5, small-edges(G; ) H, whereH is the onne ted omponents of the shorts of S, as omputed in redu e onstraints(S). Let S 0 be the set of onstraints whose longs are in small-edges(G; ). It follows that S 0 redu e onstraints(S).Now small-edges(G; ) edges(S 0) edges(redu e onstraints(S)).Hen e nd(edges(S), ) = nd(G; ) = nd(small-edges(G; ), ) + 1 nd(edges(redu e onstraints(S))) + 1 (by the indu tive hypothesis)num labels(redu e onstraints(S)) + 1 = num labels(S). 231\nDavisTheorem 2: Out of all solutions to the set of onstraints S, the instantiations ofsolve onstraints(S) have the fewest number of di erent values of od(a; b), where a; b rangeover the symbols in S. This number is given by num labels(S).Proof: Immediate from lemma 18.Corollary 19: Let have all the properties of an om-spa e ex ept that it has only kdi erent orders of magnitude. A system of onstraints S has a solution in if and only ifthe tree returned by solve onstraints(S) uses no more than k di erent labels.Proof: Immediate from theorems 1 and 2. 2Proof of Algorithm for Non-stri t ComparisonsWe now prove that the revised algorithm presented in Se tion 6.2 for non-stri t omparisonsis orre t. The proof is only a slight extension of the proof of theorem 1, given above.Re all that the revised algorithm in Se tion 6.2 repla es the line of solve onstraintsH := the onne ted omponents of the shorts of Swith the following ode:1. H := the shorts of S;2. repeat H := the onne ted omponents of H ;3. for ea h weak onstraint od(a; b) od( ; d)4. if d is in H then add ab to H endif endfor5. until no hange has been made to H in the last iteration.We need the following new lemmas and proofs:Lemma 20: Let S be a set of stri t omparisons, and let W be a set of non-stri t om-parisons. Let H be the set of edges output by the above ode. If S [W is onsistent, thenthere is an edge in S that is not in H.Proof: As in the proof of lemma 5, let be a valuation satisfying S [ W and let pq bean edge in S su h that od( (p); (q)) is maximal. We wish to show that, for every edgeab 2 H, od( (a); (b)) od( (p); (q)), and hen e ab 6= pq. Proof by indu tion: supposethat this holds for all the edges in H at some point in the ode, and that ab is now to beadded to H. There are three ases to onsider. ab is added in step [1℄. Then, as in lemma 5, there is a onstraint od(a; b) od( ; d)in S. Hen e od( (a); (b)) od( ( ); (d)) od( (p); (q)). ab is added in step [2℄. Then there is a path a1 = a; a2 : : : ak = b su h that the edgeaiai+1 is in H for i = 1 : : : k 1. By the indu tive hypothesis, od( (ai); (ai+1)) od( (p); (q)). By the om-triangle inequality,od( (a); (b)) maxi=1::k 1(od( (ai); (ai+1))) od( (p); (q)). ab is added in step [4℄. Then there is a onstraint od(a; b) od( ; d) in W su h that d is in H. By the indu tive hypothesis, od( ( ); (d)) od( (p); (q)).32\nOrder of Magnitude Comparisons of Distan e2Lemma 21: Let W ontain the onstraint od(a; b) od( ; d). Suppose that the algorithmreturns a luster tree T . Let M be the least ommon an estor of a and b in T , and let Nbe the least ommon an estor of and d. Then M .label N .label.Proof: By lemma 13, N is assigned a label in the rst iteration where H does not in ludethe edge d. In all previous iterations, sin e d is in H, ab will likewise be put into H.Hen e M does not get assigned a label before N , so M .label N .label.The remainder of the proof of the orre tness of the revised algorithm is exa tly thesame as the proof of theorem 1.Validation of Algorithm Solve onstraints2The proof of the orre tness of algorithm solve onstraints2 is again analogous in stru tureto the proof of theorem 1. We sket h it below: the details are not diÆ ult to ll in.1. (Analogue of lemma 2:) If T is an ordered luster tree, then the revised version ofinstantiate(T ) returns an instantiation of T . The proof is exa tly the same as lemma2, with the additional veri ation that instantiate2 preserves the orderings in T .2. (Analogue of lemma 5:) Let S be a set of order-of-magnitude onstraints on distan es,and let O be a set of ordering onstraints on points. Let H be the graph given by thetwo statementsH := the onne ted omponents of the shorts of S;H := in orporate order(H;O);If S and O are onsistent, then H does not ontain all the edges of S.Proof: As in the proof of lemma 5, hoose a valuation satisfying S;O and let pq bean edge in S for whi h od( (p); (q)) is maximal. Following the informal argumentpresented in Se tion 6.3, it is easily shown that pq is longer than any of the edgesadded in these two statements, and hen e it is not in H.3. (Analogue of lemma 9:) If solve onstraints2 returns false, then S;O is in onsistent.Proof: Immediate from (2).4. (Analogue of lemma 12:) If solve onstraints2(S;O) does not return false, then itreturns a well-formed ordered luster tree.Proof: By merging the strongly onne ted omponents ofG, in orporate order alwaysensures that the ordering ar s between onne ted omponents ofH form a DAG. Thesear s are pre isely the same ones that are later added among the hildren of node N asordering ar s. Thus, the ordering ar s over the hildren of a node in the luster treeform a DAG. Otherwise, the onstru tion of the tree T is the same as in lemma 12.The remainder of the proof is the same as the proof of theorem 1.33\nDavisProof of Theorem 3We begin by proving lemma 22, that the revised version of \\instantiate\", given in Se tion6.3, gives an instantiation of a luster tree in Eu lidean spa e.Lemma 22: Any luster tree T has an instantiation in Eu lidean spa e <m of any dimen-sionality m.The proof is essentially the same as the proof of Lemma 2, ex ept that we now haveto keep tra k of real quantities. For any node N , if i=N .label, we de ne (N) = Æi. Theproof then pro eeds in the following steps:i. For any i < j, Æi < Æj= j i. Immediate by onstru tion.ii. For any nodes M ,C, if M is a des endant of C in T thendist(G[M ℄; G[C℄) < n (C)=( 1).Proof: Let C = C0; C1 : : : Cr =M be the path from C to M through T . Thendist(G[M ℄; G[C℄) (by the triangle inequality) Pr 1i=0dist(G[Ci+1℄; G[Ci℄) Pr 1i=0 (n (C)= i) < ( =( 1))(n (C)).iii. Let N be a node in T ; let C1 and C2 be two hildren of N ; and let M1 and M2 bedes endants of C1 and C2 respe tively. Then (N)(1 2n=( 1)) < dist(G[M1℄; G[M2℄) < n (N)(1 + 2=( 1))Proof: By the triangle inequality,dist(G[C1℄; G[C2℄) dist(G[C1℄; G[M1℄) + dist(G[M1℄; G[M2℄) + dist(G[M2℄; G[C2℄).Thus, dist(G[C1℄; G[C2℄) dist(G[C1℄; G[M1℄) dist(G[M2℄; G[C2℄) dist(G[M1℄; G[M2℄).Also, by the triangle inequality,dist(G[M1℄; G[M2℄) dist(G[C1℄; G[C2℄) + dist(G[C1℄; G[M1℄) + dist(G[M2℄; G[C2℄).By onstru tion, (N) dist(G[C1℄; G[C2℄) < n (N),and by part (ii), for i = 1; 2, dist(G[Mi℄; G[Ci℄) < n (C)=( 1) < n (N)=( 1)as (C) < (N)= .iv. For any symbols a; b; ; d in T , let P be the least ommon an estor of a; b and let Nbe the least ommon an estor of ; d. If P .label < N .label thenmu h loser(G[a℄; G[b℄; G[ ℄; G[d℄).Proof: By part (iii), dist(G[a℄; G[b℄) < n (P )(1 + 2=( 1))and dist(G[ ℄; G[d℄) > (N)(1 2n=( 1)). Sin e (P ) < (N)= and sin e = 2 + 2n+Bn, it follows by straightforward algebra thatdist(G[a℄; G[b℄) < dist(G[ ℄; G[d℄) / B.2 We next prove the analogue of lemma 5.Lemma 23: Let S be a set of onstraints over n variables of the form\\dist(a; b) < dist( ; d) / B\", where B > n. If S is onsistent, then there is some edge in Swhi h is not in the onne ted omponents of the shorts of S.Proof: Let be a valuation satisfying S. Let pq be the edge in S for whi h dist( (p); (q))is maximal. Now, if ab is a short of S | that is, there is a onstraint mu h loser(a; b; ; d)in S | then dist( (a); (b)) < dist( ( ); (d))/B dist( (p); (q))/B.34\nOrder of Magnitude Comparisons of Distan eNow, let ab be any edge in H, the onne ted omponents of the shorts of S. Thenthere is a simple path a1 = a; a2 : : : ak = b su h that the edge aiai+1 is a short of S fori = 1 : : : k 1. Note that k n. Then, by the triangle inequality,dist( (a); (b)) dist( (a1); (a2)) + dist( (a2); (a3)) + . . . + dist( (ak 1); (ak)) (k 1)dist( (p); (q)) / B < dist( (p); (q))Hen e pq 6= ab, so pq is not in H. 2Theorem 3: Let S be a set of onstraints over n variables of the form \\dist(a; b) < dist( ; d)/ B\", where B > n. The algorithm solve onstraints(S) returns a luster tree satisfying Sif S is onsistent over Eu lidean spa e, and returns false if S is in onsistent.Proof: Note that the semanti s of the onstraints \\mu h loser(a; b; ; d)\" enters into theproof of Theorem 1 only in lemmas 2 and 5. The remainder of the proof of Theorem 1 has todo purely with the relation between the stru ture of S and the stru ture of the tree. Hen e,sin e we have shown that the analogues of lemmas 2 and 5 hold in a set of onstraints ofthis kind, the same proof an be ompleted in exa tly the same way. 2Proof of Theorem 4Lemma 24: Let T be a luster tree and let be a valuation over om-spa e satisfying T .Let x be a symbol not in T , let a be a point in , and let 0 be the valuation [ fx! ag.Then there exists an extension T 0 of T by x su h that 0 satis es T 0.Proof: If T is the empty tree, the statement is trivial. If T ontains the single symbol y,then if a = (y) then operation (2) applies with M .label=0; if a 6= (y) then operation (2)applies with M .label=1.Otherwise, let y be the symbol in T su h that od( (y); a) is minimal. (We will dealwith the ase of ties in step (D) below.) Let F be the father of y in T .Let D=od( (y); a). Let V be the set of all orders of magnitude od( (p); (q)), wherep and q range over symbols in T . We de ne L to be the suitable label for D as follows: IfD 2 V , then L is the label in T orresponding to D. If D is larger than any value in Vthen L is the label of the root of T plus 1. If D 62 V , but some value in V is larger than D,then let D1 be the largest value in V less than D; let D2 be the smallest value in V greaterthan D; let L1, L2 be the labels in T orresponding to D1, D2; and let L = (L1 + L2)=2.One of the following must hold:A. (y) = a, and F .label=0. Then apply operation (3) with N = F .B. (y) = a and F .label 6= 0. Then apply operation (4) with M .label = 0.C. (y) 6= a, but od( (y); a) is less than od( (z); a) for any other symbol z 6= y in T .Apply operation (4) with M .label set to the suitable value for D in T .D. There is more than one value y1 : : : yk for whi h od( (yi); a) = D. It is easily shownthat in this ase there is an internal node Q su h that y1 : : : yk is just the set of symbolsin the subtree of Q. There are three ases to onsider:35\nDavisD.i D=odiam( (Q.symbols)). Then apply operation (3) with N = Q.D.ii D > odiam( (Q.symbols)), and Q is not the root. Then apply operation (5)with C = Q. Set M .label to be the suitable value for D. (It is easily shown thatD < odiam( (N .symbols)), where N is the father of Q.)D.iii D > odiam( (Q.symbols)), and Q is the root. Apply operation (6).2Lemma 25: Let A = fa1 : : : akg be a nite set of points whose diameter has order-of-magnitude D. Then there exists a point u su h that, for i = 1 : : : k, od(u; ai) = D.Proof: Let b1 = a1. By axiom A.8 there exists an in nite olle tion of points b2; b3 : : :su h that od(bi; bj) = D for i 6= j. Now, for any value ai there an be at most one value bjsu h that od(ai; bj) D; if there were two su h values bj1 and bj2, then by the om-triangleinequality, od(bj1; bj2) D. Hen e, all but k di erent values of bj are at least D from anyof the ai. Let u be any of these values of bj. Then sin e od(u; a1) = D and od(a1; ai) Dfor all i, it follows that od(u; ai) D for all ai. Thus, sin e od(u; ai) D but not od(u; ai) D, it follows that od(u; ai) = D. 2Lemma 26: Let T be a luster tree; let be a valuation over om-spa e satisfying T ;and let T 0 be an extension of T by x. If is dense and unbounded above, then there is avalue a su h that the valuation [ fx! ag satis es T 0.Proof: For operations (1) and (2) the statement is trivial.Otherwise, let L be an extending label of T . If L = 0, then set D = 0. If L is in T ,then let D be the order of magnitude orresponding to L in T under . If L1 < L < L2where L1 and L2 are labels of onse utive values in T , then let D1 and D2 be the orders ofmagnitude orresponding to L1, L2 in T under . Let D be hosen so that D1 D D2.If L is greater than any label in the tree, then hoose D to be greater than the diameter ofthe tree under .If T 0 is formed from T by operation (3), then using lemma 25 let a be a point su h thatod(a; (y)) = odiam(N) for all y in N .symbols.If T 0 is formed from T by operation (4), then let a be a point su h that od(a; (y)) =D. If T 0 is formed from T by operation (5), then let a be a point su h that od(a; (y)) =D for all y in C.symbols. (Note that, sin e M .label < N .label, D < odiam(N .symbols).)If T 0 is formed from T by operation (6), then let a be a point su h that od(a; (y)) =D for all y in R.symbols.In ea h of these ases, it is straightforward to verify that [ fx! ag satis es T 0. 2As we observed in Se tion 8 regarding lemma 28, the onditions on in lemma 26are ne essary, and the statement is false otherwise. For example, let be the om-spa edes ribed in example I, Se tion 3, of polynomials over an in nitesimal Æ. Then is notunbounded above; there is a maximum order-of-magnitude O(1). Let T be the starting treeof Figure 3 (upper-left orner), and let T 0 be the result of applying operation 6 (middlebottom). Let be the valuation fu! Æ; v ! 2Æ; w ! 1g. Then satis es T , but it annotbe extended to a valuation that satis es T 0, as that would require x to be given a valuesu h that od(v; w) od(x;w), and no su h value exists within . The point of the lemma36\nOrder of Magnitude Comparisons of Distan eis that, if is required to be both dense and unbounded above, then we annot get \\stu k\"in this way.Lemma 27: Let T be a luster tree. Let X be a variable not among the symbols of T .Let be an open formula in L, whose free variables are the symbols of T and the variableX. Let be the formula 9X . Let be an om-spa e that is dense and unbounded above.Then there exists an instantiation of T in that satis es if and only if there exists anextension T 0 of T and an instantiation 0 of T 0 that extends and satis es .Proof: Suppose that there exists an instantiation of T that satis es 9X . Then, byde nition, there is a point a in su h that satis es (X=a). That is, the instantiation [ fX ! ag satis es . Let 0 = [ fX ! ag. By lemma 24, the luster tree T 0 orresponding to 0 is an extension of T .Conversely, suppose that there exists an extension T 0 of T and an instantiation 0 of T 0satisfying . Let be the restri tion of 0 to the symbols of T . Then learly satis es theformula 9X . 2Lemma 28: Let T be a luster tree. Let be an open formula in L, whose free variablesare the symbols of T . Let be an om-spa e that is dense and unbounded above. If oneinstantiation of T in satis es then every instantiation of T in satis es .Proof: We an assume without loss of generality that the only logi al symbols in are :(not), ^ (and), 9 (exists), = (equals) and variables names, and that the only non-logi alsymbol is the predi ate \\mu h loser\". We now pro eed using stru tural indu tion on theform of . Note that an equivalent statement of the indu tive hypothesis is, \\For any formula , either is true under every instantiation of T , or is false under every instantiation ofT .\"Base ase: If is an atomi formula \\X = Y \" or \\mu h loser(W;X; Y; Z)\" then thisfollows immediately from orollary 4.Let have the form : . If is true under , then is false under . By the in-du tive hypothesis, is false under every instantiation of T . Hen e is true under everyinstantiation of T .Let have the form ^ . If is true under then both and are true under . Bythe indu tive hypothesis, both and are true under every instantiation of T . Hen e istrue under every instantiation of T .Let have the form 9X . If is true under then by lemma 27, there exists anextension T 0 of T and a instantiation 0 of T 0 su h that is true under 0. By the indu tivehypothesis, is true under every instantiation of T 0. Now, if 0 is an instantiation of T 0that satis es , and is the restri tion of 0 to the variables in T , then learly satis es9X . But by lemma 26, every instantiation of T an be extended to an instantiation 0of T 0. Therefore, every instantiation of T satis es . 2Theorem 4: Let T be a luster tree. Let be an open formula in L, whose free variablesare the symbols of T . Let be an om-spa e that is dense and unbounded above. Algorithmde ide(T; ) returns true if T satis es and false otherwise.Proof: Immediate from the proof of lemma 28. 237\nDavisReferen esCormen, T.H., Leiserson, C.E., and Rivest. R.L. (1990). Introdu tion to Algorithms. Cam-bridge, MA: MIT PressDavis, E. (1990). Order of Magnitude Reasoning in Qualitative Di erential Equations. InD. Weld and J. de Kleer (Eds.) Readings in Qualitative Reasoning about Physi al Systems.San Mateo, CA: Morgan Kaufmann. 422-434.Keisler, J. (1976). Foundations of In nitesimal Cal ulus. Boston, MA: Prindle, Webber,and S hmidt.Mavrovouniotis, M. and Stephanopoulos, G. (1990). \\Formal Order-of-Magnitude Reason-ing in Pro ess Engineering.\" In D. Weld and J. de Kleer (Eds.) Readings in QualitativeReasoning about Physi al Systems. San Mateo, CA: Morgan Kaufmann. 323-336.Raiman, O. (1990). \\Order of Magnitude Reasoning.\" In D. Weld and J. de Kleer (Eds.)Readings in Qualitative Reasoning about Physi al Systems. San Mateo, CA: Morgan Kauf-mann. 318-322.Robinson, A. (1965). Non-Standard Analysis. Amsterdam: North-Holland Publishing Co.Weld, D. (1990). \\Exaggeration.\" In D. Weld and J. de Kleer (Eds.) Readings in QualitativeReasoning about Physi al Systems. San Mateo, CA: Morgan Kaufmann. 417-421.\n38"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2011,
    "abstractText" : null,
    "creator" : "dvips(k) 5.78 Copyright 1998 Radical Eye Software (www.radicaleye.com)"
  }
}