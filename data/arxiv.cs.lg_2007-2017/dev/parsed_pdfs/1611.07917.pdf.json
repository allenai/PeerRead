{
  "name" : "1611.07917.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Deep Restricted Boltzmann Networks",
    "authors" : [ "Hengyuan Hu", "Lisheng Gao", "Quanbin Ma" ],
    "emails" : [ "hengyuanhu@cmu.edu", "lishengg@andrew.cmu.edu", "quanbinm@andrew.cmu.edu" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Boltzmann machine (BM) is a family of bidirectionally connected neural network models designed to learn unknown probabilistic distributions [2]. The original Boltzmann machine, however, is seldom useful as its lateral connections among both visible and hidden units make it computationally impossible to train. Restricted Boltzmann machine (RBM) [5] is proposed to address this problem, where the connection pattern in a Boltzmann machine is restricted such that no lateral connections are allowed. This makes the learning procedure much more efficient while still maintains enough representation power to be a useful generative\n∗Equal contribution.\nmodel [16]. Several deeper architectures are later invented to tackle the problem that one layer RBMs fail to model complicated probabilistic distributions in practice. Two of the most successful ones are deep belief network (DBN) [6, 7] and deep Boltzmann machine (DBM) [15]. Deep belief network consists of multiple layers of RBMs trained in a greedy, layer-by-layer way. The resulted model is a hybrid generative model where only the top layer remains an undirected RBM while the rest become directed sigmoid belief network. Deep Boltzmann machine, on the other hand, can be viewed as a less-restricted RBM where connections between hidden units are allowed but restricted to form a multi-layer structure in which there is no intra-layer connection between hidden units. The resulted model is thus still a bipartite graph so that efficient learning can be conducted [15, 14]. The learning procedure is often layer-wise pretrain followed by joint training of the entire DBM.\nIn this paper, we present a new way to compose RBMs to form a deep undirected architecture together with a learning algorithm that trains all layers jointly from scratch. We call the composed architecture deep restricted Boltzmann network (DRBN) because each layer consists of one RBM, and the semantic of our architecture is more similar to a multilayer neural network than a deep Boltzmann machine. We also show that our model can be extended with convolutional RBMs for better scalability."
    }, {
      "heading" : "2. Background",
      "text" : "In this section we will review restricted Boltzmann machine and its two major multi-layer extensions, i.e. deep belief network and deep Boltzmann machine. Those three models are the foundations and inspirations of our new model. Therefore, it is crucial to understand them in order to identify the differences and advantages of our new deep restricted Boltzmann networks."
    }, {
      "heading" : "2.1. Restricted Boltzmann Machine",
      "text" : "A restricted Boltzmann machine is an energy based model that can be viewed as a single layer undirected neural network. It contains a set of visible units v ∈ {0, 1}D, hidden units h ∈ {0, 1}P , where D and P are the numbers\nar X\niv :1\n61 1.\n07 91\n7v 1\n[ cs\n.L G\n] 1\n5 N\nov 2\n01 6\nof visible and hidden units respectively. The parameters involved are θ = {W , b, c}, denoting the mutual weights, visible units’ biases and hidden units’ biases. The energy of a given state (v,h) is defined as:\nE(v,h; θ) = −bTv − cTh− vTWh (1) = − ∑ i=1 bivi − ∑ j=1 cjhj − ∑ i,j viWijhj .\nThe probability of a particular configuration of visible state v in the model is\np(v; θ) = 1\nZ(θ) ∑ h e−E(v,h;θ), (2)\nZ(θ) = ∑ v,h e−E(v,h;θ), (3)\nwhereZ(θ) is the partition function. Because RBM restricts the connections in the graph such that there is no link among visible units or among hidden units, the hidden units pj become conditionally independent given the visible state v, and vice versa. Hence, the conditional probability of a unit has the following simple form:\np(hj = 1|v) = σ ∑ i viWij + cj  , (4) p(vi = 1|h) = σ\n∑ j hjWij + bi  , (5) where σ(x) = 1/(1 + exp(−x)) is the sigmoid function. This property allows efficient parallel block Gibbs sampling alternating between v and h, and thus makes the learning process faster.\nThe learning algorithm for RBM is conceptually simple. With the probability of visible state defined in Equation 2, we can perform gradient descent to maximize p(v). The update rule for parameters can then be derived by computing the derivative of the negative log-likelihood function with regard to each parameter. However, in order to facilitate later discussion, we take a detour to derive the learning rule under a more general energy based model (EBM) framework.\nFirst we define the free energy of a visible state v as F(v) = − log ∑ h e−E(v,h). (6)\nAlgorithm 1 PCD(k, N)\n1: Randomly initialize N particles v(1)0 ,v (2) 0 , . . . ,v (N) 0 . 2: for t = 1 to NUM ITERATION do 3: for all v(j)t , j = 1, 2, . . . , N do 4: Do k Gibbs sampling iterations to get v(j)t,k . 5: end for 6: v\n(j) t+1 ← v (j) t,k .\n7: Use v(j)t+1s and Eq. 10 to compute gradients. 8: Update parameters with the gradients. 9: end for\nAlthough this is a sum of exponential amount of terms, it can be easily computed for RBM with binary hidden units. It can be proved that F(v) can be rewritten as\nF(v) = − ∑ i bivi − ∑ j log ∑ hj ehj(ci+ ∑ i viWij). (7)\nWith free energy, the probability of a given visible state in Equation 2 can be simplified as\np(v; θ) = 1\nZ e−F(v) = e−F(v)∑ x e −F(x) . (8)\nWe then derive the derivatives as\n∂ − log p(v(i)) ∂θ = ∂F(v(i)) ∂θ − ∑ j p(v(j)) ∂F(v(j)) ∂θ (9)\nwhere v(i)s are the current training data, v(j)s are all the possible outputs of visible units that can be generated by the model.\nWhile the first term in the equation, often noted as the data-dependent term, can be computed directly given training data, the second term, often noted as the modeldependent term, is almost impossible to compute as the number of possible v(j)s is exponential to the input size. Persistent contrastive divergence (PCD) [18, 11] has been widely employed to estimate the second term. The algorithm works as shown in Algorithm 1, where N , the chain size, denotes the number of PCD particles used. Using PCD algorithm to approximate the model-dependent term, Equation 9 becomes\n∂ − log p(v(i)) ∂θ = ∂F(v(i)) ∂θ − 1 N ∑ j ∂F(v(j)) ∂θ . (10)\nThis will be a key equation for parameter updates in later sections."
    }, {
      "heading" : "2.2. Deep Belief Network",
      "text" : "Deep belief network, as shown in Figure 2a, is a deep architecture built upon RBM to increase its representation\npower by increasing depth. In a DBN, two adjacent layers are connected in the same way as in RBM. The network is trained in a greedy, layer-by-layer manner [6], where the bottom layer is trained alone as an RBM, and then fixed to train the next layer. After all layers are pretrained, the resulted network contains one RBM at the top layer while the rest layers form a directed neural network. There is no joint training for all layers in DBN. To generate images, we need to first run Gibbs sampling in the top RBM till convergence and then propagate it down to the bottom layer. DBN has also been extended to use convolutional RBMs for better scalability and higher quality features [10]."
    }, {
      "heading" : "2.3. Deep Boltzmann Machine",
      "text" : "Deep Boltzmann machine [15], as shown in Figure 2b, is another special model in the Boltzmann machine family. Different from RBM which allows no connections between hidden units, DBM introduces additional connections between latent variables to form a multi-layer structure in the hidden part of Boltzmann machine. The energy of a DBM is defined as\nE(v,h1,h2; θ) = −bTv − c(1)Th(1) − c(2)Th(2)\n− vTW (1)h(1) − h(1)TW (2)h(2). (11)\nGiven the energy function, the conditional distributions of each layers can be derived as:\np(h (2) j = 1|h (1)) = σ (∑ i h (1) i W (2) ij + c (2) j ) , (12)\np(h (1) j = 1|h (2),v) = σ (∑ i h (2) i W (2) j,i\n+ ∑ k vkW (1) k,j + c (1) j\n) , (13)\np(vi = 1|h(1)) = σ ∑ j h (1) j W (1) ij + b (1) i  . (14)\nNote that the equation for the middle layer is different because it depends on both its adjacent neighbors. Block Gibbs sampling can still be performed by alternating between odd and even layers, which makes efficient learning possible. Further more, mean-field method and persistent contrastive divergence [18, 11] are employed to make the learning tractable [15, 14]. Note that DBM also needs greedy layer-wise pretraining to reach its best performance when the number of hidden layers is greater than 2."
    }, {
      "heading" : "3. Deep Restricted Boltzmann Network",
      "text" : "Both deep belief network and deep Boltzmann machine are rich models with enhanced representation power over the simplest RBM but more tractable learning rule over the original BM. However, it is interesting to see whether we can devise a new rule to stack the simplest RBMs together such that the resulted model can both generate better images and extract higher quality features. In this section, we will introduce the architecture of deep restricted Boltzmann network and its training method. In addition, we will further extend our architecture to support both RBMs and convolutional RBMs."
    }, {
      "heading" : "3.1. Architecture",
      "text" : "Deep restricted Boltzmann network is a multi-layer neural network where each layer is a strictly restricted Boltzmann machine. As shown in Figure 3a, each RBM’s hidden units pass their values directly to the visible units of next layer. Now, hidden units at each layer are in fact also the visible units in the next layer, so we will not differentiate between v and h, while only use x(l) to denote the state of the l-th layer for simplicity of notation. In other words, h(i) and v(i+1) are unified as x(i+1) in the following discussion because they essentially hold the same value. Naturally, x(0) denotes the input layer of the entire network. Because each layer is viewed as a standalone RBM instead of part of a DBM, the energy is thus defined on each layer, i.e. each RBM, instead of the entire network. Therefore, the l-th layer, we have:\nE(x(l),x(l+1); θ(l))\n=− b(l)Tx(l) − c(l)Tx(l+1) − x(l)TW (l)x(l+1). (15)\nIn addition, the computation of probabilities for each layer during the upward and downward pass is exactly the same as that in RBM:\np(x (l+1) j = 1|x (l)) = σ (∑ i x (l) i W (l) ij + c (l) j ) , (16)\np(x (l) i = 1|x (l+1)) = σ ∑ j x (l) j W (l) ij + b (l) i  . (17)\nOne full iteration of Gibbs sampling in a deep restricted Boltzmann network is illustrated as one up-and-down cycle in Figure 3b. It is similar to a forward-backward pass happens in the neural network. Given the input visible state x(0), we compute upward layer-by-layer using Equation 16 until we reach the top x(L). Then we compute downward following Equation 17 to obtain a new sample. From the sampling process, we can also clearly see the difference between our model and existing deep models such as DBN and DBM."
    }, {
      "heading" : "3.2. Training DRBN",
      "text" : "All RBMs in the network are trained jointly with persistent contrastive divergence. Starting with input visible x(0), the model would first do a upward pass following Equation 16 with Bernoulli sampling at each layer. The results obtained in this pass are denoted as {x(l)|l = 0, 1, 2, ..., L}, and will later be used to calculate the datadependent term. Then k upward-downward passes are performed on the PCD particles. The values of these particles at each layer during the last downward pass are obtained as {x(l)pcd|l = 0, 1, 2, ..., L}1, which are then used to approximate the model-dependent term. These two processes are illustrated in Figure 3b. After obtaining x(l)s and x(l)pcds, we can compute the gradient for each layer separately using the approximation in Equation 10. Parameters θ(l) of all layers are then updated simultaneously.\nThis learning rule further enforces our assumption that each RBM in the network are treated separately since all the information required to compute free energy F and gradients is contained locally in every RBM. An intuition behind such training method is that each layer tries to decrease the free energy of training examples while increase the free energy of the invalid examples generated at its own level.\n1Note that this diverges from our previous notation for RBM, where the superscript now identifies the layer instead of the particle."
    }, {
      "heading" : "3.3. Extension with Convolutional RBM",
      "text" : "The original RBM operates in a fully connected way, which means that it takes the entire input image as a one dimensional array and ignores locality. Inspired by the huge success of convolutional neural network in computer vision [9, 4], we extend our method to utilize convolutional RBM under the same composition framework. Convolutional RBM [10, 13] is conceptually the same as RBM, but shares weights (filters) among all location on the input image and replaces the matrix multiplications happen during the upward-downward computation with convolutions. For notation simplicity, let’s assume the visible units are of shape (Nv, Nv) with 1 channel, the hidden units are of the shape (Nh, Nh) with C channels, and the convolution uses filter of size (Nw, Nw) with stride 1 and no padding. Similar formulae can be derived for all other valid settings for convolution in the same way. We use f(x,W ) and fT (x,W ) to denote convolution and transposed convolution between input x and filters W . The energy E(v,h) can then be defined as\nE(v,h) =− C∑ k=1 Nh∑ i,j=1 Nw∑ r,s=1 hki,jW k r,svi+r−1,j+s−1\n− C∑ k=1 ck Nh∑ i,j=1 hki,j − b Nv∑ i,j=1 vi,j . (18)\nSimilar to Equation 4 and 5, the conditional probabilities that are used for block Gibbs sampling are\np(hkij = 1|v) = σ ( f(v,W )ki,j + ck ) , (19)\np(vi = 1|h) = σ ( fT (h,W )i,j + b ) . (20)\nAnd the free energy for convolutional RBM is F(v) = − log ∑ h e−E(v,h) (21)\n= −b ∑ i,j vij − ∑ k,i,j log ( 1 + eα k ij ) , (22)\nαkij = Nw∑ r,s Wr,svr+i−1,s+j−1 + c k. (23)\nWith the formula of free energy, the gradient can be computed easily by plugging this new F into Equation 10.\nPreviously, convolutional RBM has been studied in [10, 12], but with the focus on feature extraction instead of image generation. Empirically, we find that unlike RBM, convolutional RBM itself cannot generate meaningful images after trained on dataset like MNIST. This may be caused by the fact that one layer convolution handles only local information and lack connections between different receptive fields and feature channels. Therefore the generated images\nhave no global coherence. With our composition framework, however, several convolutional RBMs and normal RMBs can be connected together to form a convolutional deep restricted Boltzmann network, just like using convolution layers and fully connected layers to form a convolutional neural network. The resulted architecture, as later shown in the experiment section, can generate reasonable images."
    }, {
      "heading" : "4. Experiments",
      "text" : "We implement our model in Tensorflow [1]. With the help of its auto-differentiation functionality, we can simply define the loss function for each RBM as\nLoss(θ(l)) = 1\nM ∑ i F(x(l)i )− 1 N ∑ j F(x(l)j ) (24)\nand let the auto-diff and gradient based optimizers take care of the rest. The M , N in the previous equation denote the size of the minibatch and the number of PCD particles, respectively. In all the following experiments, we run PCD for 5 iterations between each update and set the number of PCD particles to 100, i.e. PCD(5, 100) in Algorithm 1. The generated images are the probabilities of the binary visible units, i.e. no sampling are performed in the first layer during the last downward pass. The code to reproduce our experiment results will be released."
    }, {
      "heading" : "4.1. MNIST",
      "text" : "The MNIST digit dataset contains 50,000 training, 10,000 validation and 10,000 test images of ten handwritten digits (0 to 9), each with a resolution of 28 × 28 pixels. To test the capacity of deep restricted Boltzmann networks in generating images, we trained two fully-connected DRBN and an experimental convolutional version. We compare the images generated with a plain RBM. We also tested these models in a semi-supervised context.\nThe structures of the two fully-connected DBRN are as follows: one with two hidden layers (500 and 1000 hidden units; 0.9 million parameters), and the other with three hidden layers (500, 500 and 1000 hidden units; 1.15 million parameters). During the training process, all of 50,000 training images of MNIST are used and both the size of minibatch and size of PCD particles are set to 100. The initial states are uniform random noise and we run Gibbs sampler 10,000 times to produce the output.\nThe results are compared with the images generated by RBM with a hidden layer of size 1000. Figure 4 shows the randomly-selected generated images by the three models respectively. We can observe that all of them are capable of generating rather recognizable digits. The images generated by plain RBM are noisy, blurred at boundaries and occasionally broken. The results of DRBN, however, have much less noise, sharper boundaries and smoother strokes. Furthermore, 3-layer model performs better in this case in terms of image quality than its shallower alternative.\nWe also explore the possibilities of generalizing the architecture to support convolution layers as discussed in Section 3.3. It is worth noting that during our experiments, several key settings have been critical for generating reasonable results. First, a rather large filter size has to be chosen for the first convolution layer, otherwise the generated digits will look scattered and have extremely bumpy edges. Second, we fail to produce any meaningful result if a stride of 1 is used. The reason would be that if the filters are densely applied, each visible unit will receive inputs from many filters during the downward computation and those values are hard to coordinate, making the model difficult to train. That being said, it is still essential for the filters to overlap each other, otherwise the generated images will be discontinuous. These properties are different from those of convolution layers in discriminative models [17, 4] where performance generally benefits from smaller and denser filters. Third, as mentioned in Section 3.3, the fully-connected layer at the top plays an important role and distinguishes\nour model from traditional convolutional RBM, which can hardly generate any meaningful images.\nUnder such design guidelines, we will use a three-layer convolutional DRBM for subsequent comparisons. The first layer consists of 64 filters of size 12 × 12, and the second layer has 128 filters of size 5 × 5. Both layers use a stride of 2. The outputs units are then flattened and connected to an RBM with 512 units. In total the model uses around 0.6 million parameters. The generated images are also shown in Figure 4.\nThese digits look indeed legit, which alone is much better than traditional convolutional RBM. Arguably, these generated digits are not as clear and coherent as fullyconnected ones, which is probably due to the loss of information through the process of convolution. When it comes to generative tasks, the locational invariance of convolution does not come in so handy as they were in classification and feature extraction, especially during the reconstruction phase, where the relative locality actually matters.\nIt is common for an image dataset to have only a small proportion manually labeled, while the remaining majority of raw data are of unknown categories. Therefore, it is worth exploring the performance of our model under such semi-supervised learning scenario to see whether the DRBN and convolutional DRBN can extract useful features. To convert our models for discriminative task, we add a fully connected layer with ten neurons using softmax activation to the pretrained model, mapping the values in the top hidden units in the original DRBN to a ten-dimensional vector. We evaluate the performance of different setups of DRBNs and compare their results with RBM, together with a plain fully-connected classifier trained from the scratch using the limited training data.\nWe carry out the experiments in two different phases. In the first phase, we keep the previously learnt DRBN parameters fixed while only training parameters in the new softmax layer. The purpose is to compare the quality of features extracted by different architectures and verify that a deeper model can indeed extract better features due to multiple layers of hierarchy. Table 1 shows the results of different models trained on 600, 3000 and 6000 images (1/10 of the set used for previous unsupervised learning) randomly drawn from the dataset, and evaluated on the entire test set containing 10,000 images. We used Adam [8] with the default parameters to perform gradient descent. We can conclude that both RBM and DRBN can extract useful features that help the classification when labeled data is scarce, and our DRBN models outperform normal RBM by a large margin. As expected, our convolutional DRBN prove to work better than fully-connected ones in this case, as we only need to do a one-way upward pass for feature extraction.\nTo further examine the quality of features extracted by DRBN, we take the trained models in the previous phase\nand fine tune all the layers together using the same amount of training data but with a smaller learning rate, to see how much increase we can get by allowing the feature extractors to adjust themselves. As shown in Table 2, the increment in the performance is quite small, especially when the data is rare. This proves that the original DRBNs have already extracted nearly optimal features, which makes further finetuning redundant when the data is scarce.\nThe numbers seem to still have plenty of space for improvement, but it is important to keep in mind that they are obtained under the assumption of scarce labeled data. As we can imagine, if we supply the whole 60,000 MNIST training and validation set to the network, we could definitely get a better result, but then we would be just training a traditional neural network."
    }, {
      "heading" : "4.2. Weizmann Horses",
      "text" : "We further test our model on the Weizmann Horse dataset [3], which includes 328 binary horse figures segmented from real world photos, with quite a variety of different postures. The images also have a high variance especially due to its abundant details regarding the necks, feet and tails of horses under the states of resting, running and eating, as will be shown later in Figure 5c. The high variety and low volume of the dataset make it a challenging task for the model to generate realistic horses with various postures. The original images come in varying resolutions, so we crop the horses to the center and reshape them to 32×32 pixels. Now the dataset resembles the taste of MNIST, only\nmuch smaller.\nSimilar to the experiments in MNIST, We build a fullyconnected DRBN and a convolutional DBRN to learn from this dataset, and then generate horse images using Gibbs sampling with random noise initialization. For the fullyconnected model, we choose a 2-layer structure with the number of hidden units being 500 and 1000 respectively. For the convolutional model, we keep the same structure we have used for MNIST. We train these two model using all pre-processed images. The results are shown in Figure 5 together with the original dataset. Those generated by fully-connected DRBN tend to have better clarity and smoother strokes along the boundaries, but the image would look blurred as a whole. Sometimes we could also identify two generated images that look very alike. Those generated by the convolutional DRBN, on the other hand, have shown greater variety of general postures and details in legs, though at the price of more noise.\nAgain, for the convolutional DRBN, we cannot generate descent images if the first layer uses a filter as small as 5 × 5. Such pattern for model selection is also reflected in ShapeBM [13], whose implementation of deep Boltzmann machine on similar 32×32 horse images is equivalent to using 500 filters of size 18×18 with stride 14 in the first layer. This agrees with our analysis above that such locality has to be captured, and later combined by the fully-connected layers for a successful reconstruction.\nWe also compare our generated images with the architecture introduced by ShapeBM. As shown in Figure 6, both models are able to generate reasonable horses. Most of the images generated by ShapeBM share the same posture, though they do have abundant details regarding the legs. Our models, on the other hand, can generate horses with a wider range of variety in general. It is also worth noting that the model of ShapeBM requires layer-wise pretraining, as does deep Boltzmann machine, in order to generate mean-\ningful images, while our DBRN models do not require such procedure and thus can be train directly."
    }, {
      "heading" : "5. Conclusion",
      "text" : "In this paper, we proposed a new way to compose restricted Boltzmann machine and convolutional restricted Boltzmann machine, forming a deep network to improve its performance in terms of both image generation and feature extraction. We also provided a simple and intuitive training method that jointly optimize all RBMs in the network, which turns out to work well in practice. Our experiments on MNIST and Weizmann Horse datasets show that such composite architectures are good generative models and can extract useful features to facilitate supervised learning task like classification. In the future, it would be interesting to see whether this architecture can be used on real-scaled images and whether it can be generalized to use other Boltzmann machines, e.g. deep Boltzmann machine, as its basic unit for each layer."
    } ],
    "references" : [ {
      "title" : "Software available from tensorflow.org",
      "author" : [ "M. Abadi", "A. Agarwal", "P. Barham", "E. Brevdo", "Z. Chen", "C. Citro", "G.S. Corrado", "A. Davis", "J. Dean", "M. Devin", "S. Ghemawat", "I. Goodfellow", "A. Harp", "G. Irving", "M. Isard", "Y. Jia", "R. Jozefowicz", "L. Kaiser", "M. Kudlur", "J. Levenberg", "D. Mané", "R. Monga", "S. Moore", "D. Murray", "C. Olah", "M. Schuster", "J. Shlens", "B. Steiner", "I. Sutskever", "K. Talwar", "P. Tucker", "V. Vanhoucke", "V. Vasudevan", "F. Viégas", "O. Vinyals", "P. Warden", "M. Wattenberg", "M. Wicke", "Y. Yu", "X. Zheng" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2015
    }, {
      "title" : "Connectionist models and their implications: Readings from cognitive science. chapter A Learning Algorithm for Boltzmann Machines, pages 285–307",
      "author" : [ "D.H. Ackley", "G.E. Hinton", "T.J. Sejnowski" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1988
    }, {
      "title" : "Combining topdown and bottom-up segmentation",
      "author" : [ "E. Borenstein", "E. Sharon", "S. Ullman" ],
      "venue" : "In Proceedings of the 2004 Conference on Computer Vision and Pattern Recognition Workshop (CVPRW’04) Volume 4 - Volume 04,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2004
    }, {
      "title" : "Deep residual learning for image recognition",
      "author" : [ "K. He", "X. Zhang", "S. Ren", "J. Sun" ],
      "venue" : "CoRR, abs/1512.03385,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2015
    }, {
      "title" : "Training products of experts by minimizing contrastive divergence",
      "author" : [ "G.E. Hinton" ],
      "venue" : "Neural Comput.,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2002
    }, {
      "title" : "A fast learning algorithm for deep belief nets",
      "author" : [ "G.E. Hinton", "S. Osindero", "Y.-W. Teh" ],
      "venue" : "Neural Comput.,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2006
    }, {
      "title" : "Reducing the dimensionality of data with neural networks",
      "author" : [ "G.E. Hinton", "R.R. Salakhutdinov" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2006
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "D.P. Kingma", "J. Ba" ],
      "venue" : "CoRR, abs/1412.6980,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2014
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevsky", "I. Sutskever", "G.E. Hinton" ],
      "venue" : "Advances in Neural Information Processing Systems",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2012
    }, {
      "title" : "Convolutional deep belief networks for scalable unsupervised learning of hierarchical representations",
      "author" : [ "H. Lee", "R. Grosse", "R. Ranganath", "A.Y. Ng" ],
      "venue" : "In Proceedings of the 26th Annual International Conference on Machine Learning,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2009
    }, {
      "title" : "Connectionist learning of belief networks",
      "author" : [ "R.M. Neal" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1992
    }, {
      "title" : "The shape boltzmann machine: a strong model of object shape",
      "author" : [ "J.W.J.W.S.M. Eslami", "N. Heess" ],
      "venue" : "In Proc. Conf. Computer Vision and Pattern Recognition (to appear),",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2012
    }, {
      "title" : "An efficient learning procedure for deep boltzmann machines",
      "author" : [ "R. Salakhutdinov", "G. Hinton" ],
      "venue" : "Neural Comput.,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2012
    }, {
      "title" : "Deep boltzmann machines",
      "author" : [ "R. Salakhutdinov", "G.E. Hinton" ],
      "venue" : "In Proceedings of the Twelfth International Conference on Artificial Intelligence and Statistics,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2009
    }, {
      "title" : "Restricted boltzmann machines for collaborative filtering",
      "author" : [ "R. Salakhutdinov", "A. Mnih", "G. Hinton" ],
      "venue" : "In Proceedings of the 24th International Conference on Machine Learning,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2007
    }, {
      "title" : "Very deep convolutional networks for large-scale image recognition",
      "author" : [ "K. Simonyan", "A. Zisserman" ],
      "venue" : "CoRR, abs/1409.1556,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2014
    }, {
      "title" : "Training restricted boltzmann machines using approximations to the likelihood gradient",
      "author" : [ "T. Tieleman" ],
      "venue" : "In Proceedings of the 25th International Conference on Machine Learning,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "Restricted Boltzmann machine (RBM) [5] is one of such models that is simple but powerful.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 5,
      "context" : "The most famous ones among them are deep belief network [6], which stacks multiple layer-wise pretrained RBMs to form a hybrid model, and deep Boltzmann machine [15], which allows connections between hidden units to form a multi-layer structure.",
      "startOffset" : 56,
      "endOffset" : 59
    }, {
      "referenceID" : 13,
      "context" : "The most famous ones among them are deep belief network [6], which stacks multiple layer-wise pretrained RBMs to form a hybrid model, and deep Boltzmann machine [15], which allows connections between hidden units to form a multi-layer structure.",
      "startOffset" : 161,
      "endOffset" : 165
    }, {
      "referenceID" : 1,
      "context" : "Boltzmann machine (BM) is a family of bidirectionally connected neural network models designed to learn unknown probabilistic distributions [2].",
      "startOffset" : 140,
      "endOffset" : 143
    }, {
      "referenceID" : 4,
      "context" : "Restricted Boltzmann machine (RBM) [5] is proposed to address this problem, where the connection pattern in a Boltzmann machine is restricted such that no lateral connections are allowed.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 14,
      "context" : "model [16].",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 5,
      "context" : "Two of the most successful ones are deep belief network (DBN) [6, 7] and deep Boltzmann machine (DBM) [15].",
      "startOffset" : 62,
      "endOffset" : 68
    }, {
      "referenceID" : 6,
      "context" : "Two of the most successful ones are deep belief network (DBN) [6, 7] and deep Boltzmann machine (DBM) [15].",
      "startOffset" : 62,
      "endOffset" : 68
    }, {
      "referenceID" : 13,
      "context" : "Two of the most successful ones are deep belief network (DBN) [6, 7] and deep Boltzmann machine (DBM) [15].",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 13,
      "context" : "The resulted model is thus still a bipartite graph so that efficient learning can be conducted [15, 14].",
      "startOffset" : 95,
      "endOffset" : 103
    }, {
      "referenceID" : 12,
      "context" : "The resulted model is thus still a bipartite graph so that efficient learning can be conducted [15, 14].",
      "startOffset" : 95,
      "endOffset" : 103
    }, {
      "referenceID" : 16,
      "context" : "Persistent contrastive divergence (PCD) [18, 11] has been widely employed to estimate the second term.",
      "startOffset" : 40,
      "endOffset" : 48
    }, {
      "referenceID" : 10,
      "context" : "Persistent contrastive divergence (PCD) [18, 11] has been widely employed to estimate the second term.",
      "startOffset" : 40,
      "endOffset" : 48
    }, {
      "referenceID" : 5,
      "context" : "The network is trained in a greedy, layer-by-layer manner [6], where the bottom layer is trained alone as an RBM, and then fixed to train the next layer.",
      "startOffset" : 58,
      "endOffset" : 61
    }, {
      "referenceID" : 9,
      "context" : "DBN has also been extended to use convolutional RBMs for better scalability and higher quality features [10].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 13,
      "context" : "Deep Boltzmann machine [15], as shown in Figure 2b, is another special model in the Boltzmann machine family.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 16,
      "context" : "Further more, mean-field method and persistent contrastive divergence [18, 11] are employed to make the learning tractable [15, 14].",
      "startOffset" : 70,
      "endOffset" : 78
    }, {
      "referenceID" : 10,
      "context" : "Further more, mean-field method and persistent contrastive divergence [18, 11] are employed to make the learning tractable [15, 14].",
      "startOffset" : 70,
      "endOffset" : 78
    }, {
      "referenceID" : 13,
      "context" : "Further more, mean-field method and persistent contrastive divergence [18, 11] are employed to make the learning tractable [15, 14].",
      "startOffset" : 123,
      "endOffset" : 131
    }, {
      "referenceID" : 12,
      "context" : "Further more, mean-field method and persistent contrastive divergence [18, 11] are employed to make the learning tractable [15, 14].",
      "startOffset" : 123,
      "endOffset" : 131
    }, {
      "referenceID" : 8,
      "context" : "Inspired by the huge success of convolutional neural network in computer vision [9, 4], we extend our method to utilize convolutional RBM under the same composition framework.",
      "startOffset" : 80,
      "endOffset" : 86
    }, {
      "referenceID" : 3,
      "context" : "Inspired by the huge success of convolutional neural network in computer vision [9, 4], we extend our method to utilize convolutional RBM under the same composition framework.",
      "startOffset" : 80,
      "endOffset" : 86
    }, {
      "referenceID" : 9,
      "context" : "Convolutional RBM [10, 13] is conceptually the same as RBM, but shares weights (filters) among all location on the input image and replaces the matrix multiplications happen during the upward-downward computation with convolutions.",
      "startOffset" : 18,
      "endOffset" : 26
    }, {
      "referenceID" : 11,
      "context" : "Convolutional RBM [10, 13] is conceptually the same as RBM, but shares weights (filters) among all location on the input image and replaces the matrix multiplications happen during the upward-downward computation with convolutions.",
      "startOffset" : 18,
      "endOffset" : 26
    }, {
      "referenceID" : 9,
      "context" : "Previously, convolutional RBM has been studied in [10, 12], but with the focus on feature extraction instead of image generation.",
      "startOffset" : 50,
      "endOffset" : 58
    }, {
      "referenceID" : 0,
      "context" : "We implement our model in Tensorflow [1].",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 15,
      "context" : "These properties are different from those of convolution layers in discriminative models [17, 4] where performance generally benefits from smaller and denser filters.",
      "startOffset" : 89,
      "endOffset" : 96
    }, {
      "referenceID" : 3,
      "context" : "These properties are different from those of convolution layers in discriminative models [17, 4] where performance generally benefits from smaller and denser filters.",
      "startOffset" : 89,
      "endOffset" : 96
    }, {
      "referenceID" : 7,
      "context" : "We used Adam [8] with the default parameters to perform gradient descent.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 2,
      "context" : "We further test our model on the Weizmann Horse dataset [3], which includes 328 binary horse figures segmented from real world photos, with quite a variety of different postures.",
      "startOffset" : 56,
      "endOffset" : 59
    }, {
      "referenceID" : 11,
      "context" : "Such pattern for model selection is also reflected in ShapeBM [13], whose implementation of deep Boltzmann machine on similar 32×32 horse images is equivalent to using 500 filters of size 18×18 with stride 14 in the first layer.",
      "startOffset" : 62,
      "endOffset" : 66
    } ],
    "year" : 2016,
    "abstractText" : "Building a good generative model for image has long been an important topic in computer vision and machine learning. Restricted Boltzmann machine (RBM) [5] is one of such models that is simple but powerful. However, its restricted form also has placed heavy constraints on the model’s representation power and scalability. Many extensions have been invented based on RBM in order to produce deeper architectures with greater power. The most famous ones among them are deep belief network [6], which stacks multiple layer-wise pretrained RBMs to form a hybrid model, and deep Boltzmann machine [15], which allows connections between hidden units to form a multi-layer structure. In this paper, we present a new method to compose RBMs to form a multi-layer network style architecture and a training method that trains all layers/RBMs jointly. We call the resulted structure deep restricted Boltzmann network. We further explore the combination of convolutional RBM with the normal fully connected RBM, which is made trivial under our composition framework. Experiments show that our model can generate descent images and outperform the normal RBM significantly in terms of image quality and feature quality, without losing much efficiency for training.",
    "creator" : "LaTeX with hyperref package"
  }
}