{
  "name" : "1401.8074.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Empirically Evaluating Multiagent Learning Algorithms",
    "authors" : [ "Erik Zawadzki", "Asher Lipson", "Kevin Leyton-Brown" ],
    "emails" : [ "kevinlb}@cs.ubc.ca" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 1.\n80 74\nv1 [\ncs .G\nT ]\n3 1\nJa n\n20 14\nKeywords: Game theory, multiagent systems, reinforcement learning, empirical algorithmics"
    }, {
      "heading" : "1. Introduction",
      "text" : "Urban road networks, hospital systems and commodity markets are all examples of complicated multiagent systems that are essential to everyday life. Indeed, any social interaction can be seen as a multiagent problem. As a result of the prominence of multiagent systems, a lot of attention has been paid to designing and analyzing learning algorithms for multiagent environments. A multitude of different algorithms exist for a variety of different settings. Some prominent examples include algorithms by Littman (1994), Singh et al. (2000), Hu and Wellman (2003), Greenwald and Hall (2003), Bowling (2004a), Powers and Shoham (2005), Banerjee and Peng (2006), and Conitzer and Sandholm (2007).\nWe take the position that the best multiagent learning (MAL) algorithm is the one that achieves the highest possible average reward.1 Under this view, the problem faced by the designer of a MAL algorithm is qualitatively the same as the problem faced by the designer of a single-agent reinforcement learning algorithm. However, there is a fundamental difference between the two settings. In the stationary environment faced by classical reinforcement learners, the concept of an optimal policy is well defined, and hence learning algorithms can attempt to identify this policy. In a multiagent environment, the best policy to follow depends on the actions taken by the opponent, and thus on the ways in which the opponent’s future behavior will be affected by the learner’s\n1 For alternatives, see Shoham et al. (2007)—who called the approach that we espouse the “prescriptive, noncooperative agenda”—or Sandholm (2007).\n2 present actions. The best policy depends on the opponent’s strategy, and so there can be no global “optimum.”\nIt is this added conceptual complexity that makes MAL problems interesting; however, it has also made them harder to analyze. Theoretical claims about MAL algorithms generally do not speak directly about average reward. Instead, they tend to describe alternative aspects of the algorithm’s performance that are intended to ‘stand in’ for reward. Some work has insisted that algorithms should converge to stage-game Nash equilibria, or should do so at least in the case of “self play.” Others have insisted on other sorts of convergence properties or on regret bounds. Still others have offered different guarantees for performance against different classes of opponents.\nBecause many MAL algorithms are incomparable on the basis of their theoretical properties, and further because the extent to which these various properties correlate with an algorithm’s ability to achieve high average reward in practice is unclear, it is generally argued that MAL algorithms should be compared empirically. Many such experimental comparisons have been performed in the literature (see, e.g., (Nudelman et al., 2004; Powers and Shoham, 2005)). However, for the most part these experiments have been designed to advocate for a newly-designed algorithm rather than to survey the whole landscape. As a consequence, most of these experiments have been small in terms of the number of game instances and opposing algorithms considered. Furthermore, different experiments have in many cases measured performance in different ways, making it difficult to compare their results and draw an overall conclusion. There is therefore considerable opportunity to expand our understanding of how existing MAL techniques compare in practice.\nPart of the reason for the relative paucity of large-scale empirical work is that neither a centralized algorithm repository nor a standardized test setup exists. This is unfortunate, not only because considerable work has to be invested in designing one-off testbeds and reimplementing algorithms, but also because centralized and public repositories increase reproducibility and decrease the danger that different experiments will achieve different results because of differences in implementations. Publicly available and scrutinized implementations offer the promise of experiments that are easier to run, reproduce, and compare.\nIn this article we make two main contributions. First, we describe the design and implementation of a platform for running MAL experiments (§3). This platform offers several advantages over one-off setups. We hope that it will facilitate new and larger-scale empirical work.\nOur second main contribution is the analysis of such an empirical study. This experiment is, to our knowledge, unprecedented in terms of scale. We make suggestions about how empirical MAL performance data should be analyzed (§4), and offer a detailed discussion of different algorithms’ average reward in practice (§5). Furthermore, we draw connections between different performance metrics that have been explored in theoretical work (§6), and show that some of the least sophisticated algorithms achieve extremely competitive performance."
    }, {
      "heading" : "2. Algorithms and Past Experimental Work",
      "text" : "MAL algorithms have been studied for over half a century. This rich investigation has produced not only a profusion of competing algorithms but also various distinct problem formulations. Does an algorithm know the game’s reward functions before the game starts, or do reward functions need\n3 to be learned? How many opponents can an algorithm face? What signals about the opponent’s actions can an algorithm observe? Can an algorithm rely on being able to determine stage-game Nash equilibria or other computationally-expensive game properties? Each of these assumptions changes the learning problem.\nIn this section we describe the algorithms we study in this paper, and also survey past experimental evaluations of MAL algorithms. The creators of the algorithms that we describe answered the above questions in different ways, reflecting the community’s broader disagreement about precisely what problem MAL algorithms should aim to solve. In order to permit the study of a broad range of algorithms, we have answered the above questions permissively: we allow algorithms access to the reward functions, to signals about the opponent’s actions, and to computationally-costly game properties. Thus, we are able to compare algorithms that require this information to others that are capable of learning it.\nThe other important experimental choice we faced was the class of games upon which to evaluate algorithms. We chose to restrict ourselves to 2-player repeated games. (Note, however, that we do not restrict the number of actions in the repeated game.) We chose this setting instead of n-player repeated games or either 2- or n-player stochastic games for two reasons. First, the case of two-player repeated games has received the most past study (though see e.g., (Vu et al., 2005)). Second, considerably more work has been done to identify experimentally-interesting test data for this case. We restricted our attention to algorithms that can play two-player games of any size and with any payoff structure. We thus did not make use of work that insists (e.g.) on two-action games (Singh et al., 2000) or constant-sum games (Littman, 1994). We also mention as an aside that MAL experiments have been conducted in settings that are neither generalizations nor restrictions of our setting, such as the population-based work by Axelrod (1987) and Airiau et al. (2007)."
    }, {
      "heading" : "2.1. FICTITIOUS PLAY",
      "text" : "Fictitious play (Brown, 1951) is probably the earliest example of a learning algorithm for two-player games repeated games. Essentially, fictitious play assumes that the opponent is playing an unknown and potentially mixed stationary strategy, and tries to estimate this strategy from the opponent’s empirical distribution of actions—the frequency counts for each of its actions normalized to be probabilities. Clearly, in order to collect the frequency counts fictitious playmust be able to observe the opponent’s actions. The algorithm then, at each iteration, best responds to this estimated strategy. Because fictitious play needs to calculate a best response, it also assumes complete knowledge of its own payoffs.\nFictitious play is guaranteed to converge to a Nash equilibrium in self play for a restricted set of games. These games are said to have the fictitious play property (see, for instance Monderer and Shapley (1996); for an example of a simple 2 × 2 game without this property see Monderer and Sela (1996)). Fictitious play will also eventually best respond to any stationary strategy. This algorithm’s general structure has been extended in a number of ways, including smooth fictitious play (Fudenberg and Kreps, 1993), and we will see later that fictitious play provides the foundation for several more modern algorithms.\nFictitious play is known to be subject to miscoordination problems, particularly in self play, and particularly in games that reward asymmetric coordination (e.g., dispersion games). There\n4 are some clever measures that can be taken to avoid some of these kinds of problems (e.g., best response tie-breaking rules and randomization), but miscoordination remains a general problem for the fictitious play approach."
    }, {
      "heading" : "2.2. DETERMINED",
      "text" : "Determined or ‘bully’ (see, for example, Powers and Shoham (2005)) is an algorithm that solves the multiagent learning problem by ignoring it. MAL algorithms typically change their behavior by adapting to signals about the game. However, determined, as its name suggests, simply relies on other algorithms to adapt their strategies to it.\nDetermined enumerates the stage-game Nash equilibria and selects the one that maximizes its personal reward in equilibrium; then, it plays its corresponding action forever.2 Certainly, determined can lead to some obvious problems. For instance, in self play two determined agents can stubbornly play actions from different equilibria, leading to sub-equilibrium average reward. Additionally, enumerating all the Nash equilibria not only requires complete knowledge of every agents’ reward function, but is also computationally costly, limiting the use of this strategy to relatively small stage games. All the same, determined serves as a useful baseline for comparison. Also, slight variations of this algorithm are, like fictitious play, at the heart of some more modern algorithms."
    }, {
      "heading" : "2.3. TARGETED ALGORITHMS",
      "text" : "We next focus on two so-called targeted algorithms, which focus on playing against particular classes of opponents. Both these algorithms are based around identifying what the opponent is doing (with particular attention paid to stationarity and Nash equilibrium), and then updating their behavior based on this assessment.\nAWESOME (Conitzer and Sandholm, 2003; Conitzer and Sandholm, 2007) tracks the opponent’s behavior in different periods of play and tries to maintain hypotheses about its play. For example, AWESOME attempts to determine whether the other algorithm is playing a particular stage-game Nash equilibrium. If it is, AWESOME responds with its own component of that special equilibrium. This special equilibrium is known in advance by all implementations of AWESOME to avoid equilibrium selection issues in self play. There are other situations where it acts in a similar fashion to fictitious play, and there are still other discrete modes of play that it engages in depending on its beliefs.\nMeta (Powers and Shoham, 2005) switches between three simpler strategies: a strategy similar to fictitious play, a determined-style algorithm that stubbornly plays a Nash equilibrium, and the maxmin strategy. Strategy selection depends on the recorded history of average reward and the empirical distribution of the opponent’s actions across different periods of play.\n2 We can imagine variations on the determined idea that do not play an action from a Nash equilibrium. For example, a variant could instead choose the action whose best response yields the algorithm the highest payoff. Note that this differs from a stage-game Nash equilibrium because this determined-like algorithm need not itself play a best response. Such an outcome amounts to an equilibrium of the Stackelberg version of the stage game. That is, we can change the game so that instead of the two players moving simultaneously, the determined-like agent moves first.\n5 Meta was shown both theoretically and empirically to be nearly optimal against itself, close to the best response against stationary agents, and to approach (or exceed) the security level of the game in all cases.\nBecause both of these algorithms switch between simpler strategies depending on the situation, they can be viewed as portfolio algorithms. Note that both manage similar portfolios that include a determined-style algorithm and a fictitious play algorithm."
    }, {
      "heading" : "2.4. Q-LEARNING ALGORITHMS",
      "text" : "A broad family of MAL algorithms are based on Q-learning (Watkins and Dayan, 1992), which is a algorithm for finding the optimal policy in Markov Decision Processes (MDPs). This family of MAL algorithms does not explicitly model the opponent’s strategy choices. They instead settle for learning the expected discounted reward for taking an action and then following a stationary policy encoded in the Q-function. In order to learn the Q-function, algorithms typically take random exploratory steps with a small (possibly decaying) probability.\nEach algorithm in this family has a different way of selecting its strategy based on this Qfunction. For instance, one could try a straightforward adaptation of single-agent Q-learning to the multiagent setting by ignoring the impact that the opponent’s action makes on the protagonist’s payoffs. The algorithm simply updates its reward function whenever a new reward observation is made, where the new estimate is a convex combination of the old estimate and the new information:\nQ(ai) = (1− αt)Q(ai) + αt\n[\nr + γmax a\nQ(a) ] . (1)\nThis algorithm essentially considers the opponent’s behavior to be an unremarkable part of a noisy and non-stationary environment. The non-stationarity of the environment makes learning difficult but this idea is not entirely without merit: Q-learning has been shown to work in other nonstationary environments (see, for instance, Sutton and Barto (1999)).\nMinimax-Q (Littman, 1994) is one of the first explicitly multiagent applications of the Qlearning idea. The Q-function that it learns is based on the action profile and not just the protagonist’s action: it learns Q(ai, a−i). Minimax-Q uses the mixed maxmin strategy calculated from the Q-function as its strategy:\nQ(ai, a−i) = (1− αt)Q(ai, a−i) + αt\n[\nr + γ max σi∈ ∏ (Ai)\n[\nmin a−i∈A−i\n∑\nai\nσi(ai)Q(ai, a−i)\n]]\n. (2)\nSuch a strategy is sensible to the extent that the protagonist believes that the opponent aims to minimize his payoff, or that the protagonist cares about worst-case guarantees. It should be noted that since its maxmin strategies are calculated from learned Q-values, they may not be the game’s actual maxmin strategies and thus fail to reflect the security value. Like Q-learning, minimax-Q also takes the occasional exploration step.\nThere are further modifications to this general scheme. Nash-Q (Hu and Wellman, 2003) learns different Q-functions for itself and its opponents and plays a stage-game Nash equilibrium strategy for the game induced by these Q-values. Correlated-Q (Greenwald and Hall, 2003) does\n6 something similar except that it chooses from the set of correlated equilibria using a variety of different selection methods. Both of these algorithms assume that they are able to observe not only the opponents’ actions but also their rewards, and additionally that they have the computational wherewithal to compute the necessary solution concept."
    }, {
      "heading" : "2.5. GRADIENT ALGORITHMS",
      "text" : "Gradient ascent algorithms, such as GIGA-WoLF (Bowling, 2004a) and RVσ(t) (Banerjee and Peng, 2006), maintain a mixed strategy that is updated in the direction of the payoff gradient. The specific details of this updating process depend on the individual algorithms, but the common feature is that they increase the probability of actions with high reward and decrease the probability of unpromising actions. This family of algorithms is similar to Q-learning because they do not explicitly model their opponent’s strategies and instead treat them as part of a non-stationarity environment.\nGIGA-WoLF is the latest algorithm in a line of gradient learners that started with IGA (Singh et al., 2000). GIGA-WoLF uses an adaptive step length that makes it more or less aggressive about changing its strategy. It compares its strategy to a baseline strategy and makes the update larger if it is performing worse than the baseline. GIGA-WoLF guarantees non-positive regret in the limit (regret is discussed in greater detail in §6.1) and strategic convergence to a Nash equilibrium when playing against GIGA (Zinkevich, 2003) in two-player two-action games.\nThere are two versions of GIGA-WoLF. The first version assumes prior knowledge of personal reward and the ability to observe the opponent’s action—this is the version used in the proofs for GIGA-WoLF’s no-regret and convergence guarantees. There is also a second version—on which all the experiments were based—that makes limited assumptions about payoff knowledge and computational power. Instead, like Q-learning, it merely assumes that it is able to observe its own reward.\nRVσ(t) (Banerjee and Peng, 2006) belongs to a second line of gradient algorithms that started with ReDVaLeR (Banerjee and Peng, 2004). This algorithm also uses an adaptive step size when following the payoff gradient, like GIGA-WoLF, but does so on an action-by-action basis. This means that, unlike GIGA-WoLF, RVσ(t) can be aggressive in updating some actions while being cautious about updating others. These updates are performed by comparing current reward to the reward at a Nash equilibrium. Therefore, RVσ(t) requires complete information about the game and sufficient computational power to discover at least one stage-game Nash equilibrium. RVσ(t) also guarantees no-regret in the limit and additionally provides some convergence results for self play in a restricted class of games.\nGIGA-WoLF and RVσ(t) differ in the way that they ensure that their updated strategies remain valid probability distributions. GIGA-WoLF retracts: it maps an unconstrained vector to the vector on the probability simplex that is closest in ℓ2 distance. This approach has a tenancy to map vectors to extreme points of the simplex, reducing some action probabilities to zero. RVσ(t) normalizes, which is less prone to removing actions from its support.\n7"
    }, {
      "heading" : "2.6. PREVIOUS EXPERIMENTAL RESULTS",
      "text" : "As discussed in the introduction, surprisingly little past work has aimed primarily to use large-scale experiments to compare the performance of MAL algorithms. Nevertheless, a considerable number of papers from the literature describe experimental comparisons, often in the context of arguing for a particular MAL algorithm or approach. We briefly survey that literature here.\nSetting up a general-sum repeated two-player game experiment requires a number of design choices. What set of algorithms should be considered? On what set of games should these algorithms be run? If one is dealing with randomized algorithms (which includes any algorithm that is able to submit a mixed strategy), how many different runs should be simulated? For a particular game, for how many iterations should a simulation be run? As can be seen in Table I, experiments from the literature varied in all of these dimensions. Additionally, some papers do not describe all experimental parameters, making it difficult to compare results.\nOverall, most of the tests performed in these papers considered few algorithms. In most cases, a newly proposed algorithm was evaluated by playing against one or two opponents. Some papers superficially appear to have used many algorithms, but in fact considered algorithms that varied only in small details. For example, in Littman (1994) two versions of minimax-Q and two versions of Q-learning were tested, with each version differing only in its training regime. In Greenwald and Hall (2003), four versions of Correlated-Qwere tested against Q-learning and Friend-Q and Foe-Q (Littman, 2001). Foe-Q is the same as minimax-Q.\nTo our knowledge, the experiment that considered the greatest variety of algorithms was Powers and Shoham (2005). While four of the eleven algorithms tested in this study were simple stationary-strategy baselines, the remaining seven were MAL algorithms including Hyper-Q (Tesauro, 2004), WoLF-PHC (Bowling and Veloso, 2002), and a joint action learner (Claus and Boutilier, 1997).\n8 Previous experiments have tended to investigate only small numbers of game instances, and these instances have tended to come from an even smaller number of game distributions. For example, Banerjee and Peng (2006) used only a single 3 × 3 action “simple coordination game” and Littman (1994) probed algorithm behavior with a single grid-world version of soccer. Initially, this limitation was partly due to the difficulty of creating a large number of diverse game instances. However with the creation of GAMUT (Nudelman et al., 2004), a suite of game generators, generating large game sets is now easy. Indeed, Nudelman et al. (2004) also performed one of the largest previous MAL experiments, using three MAL algorithms (minimax-Q, WoLF (Bowling and Veloso, 2001), and Q-learning) on 100 game instances from each of thirteen distributions. Some recent papers have also leveraged GAMUT, such as Powers and Shoham (2005).\nFinally, previous experiments have differed substantially in the number of iterations considered, ranging from 50 (Claus and Boutilier, 1997) to 1 × 106 (Bowling, 2004b). Iterations in a repeated game are typically divided into “settling in” (also called a “burn-in” period) and “recording” phases, allowing the algorithms time to converge to stable behavior before results are recorded. Powers and Shoham (2005) recorded the final 20 000 of 200 000 iterations and Nudelman et al. (2004) used the final 10 000 of 100 000 iterations."
    }, {
      "heading" : "3. Platform",
      "text" : "The empirical experiments just described were generally conducted using one-off code tailored to the investigation of a particular feature of a given algorithm. This experimental design has a number of negative consequences. First, it decreases the reproducibility of experiments by, for instance, obscuring the details of algorithm implementation. Even when source code for the original experiment is available, its special-purpose nature can make it difficult to repurpose for follow-on studies or new experiments. Finally, rewriting similar code again and again wastes time that could be spent running more comprehensive experiments.\nIn this section, we describe our solution to this problem: an open and reusable platform called MALT (MultiAgent Learning Testbed) 2.0. It is available for free download at http://www.cs.ubc.ca/˜kevinlb/malt This platform is designed for running two-player, general-sum, repeated-game MAL experiments. Basic visualization and analysis features are also included, as is support for running experiments using a computer cluster. Version 1.0 of MALT was introduced by Lipson (2005); the version described here is a complete reimplementation of that work in a faster programming language (Java vs. Matlab), offering a wide variety of new features, bug fixes, and efficiency gains. Overall, we hope that other researchers will see MALT not as a finished product, but as a growing repository of tools, algorithms and experimental settings, and that they will use it as a base upon which to build (e.g., for the study of N -player repeated games or stochastic games). We have worked hard to make MALT easily extensible. For example, adding a new algorithm to the MALT GUI is as simple as providing a text file with a list of parameters, and adding an algorithm to the engine requires very little coding beyond the implementation of the algorithm itself.\n9"
    }, {
      "heading" : "3.1. DEFINITIONS",
      "text" : "We now define some terms. An ordered pair of two algorithms is a pairing. This pair is ordered because many two-player games are asymmetric: the payoff structure for the row player is different than the payoff structure for the column player. The case where an algorithm is paired with a copy of itself (but with different internal states and independent random seeds) is called self play.\nWe concentrate on drawing games from distributions called game generators. A particular sample from a game generator is a game instance. Prisoner’s Dilemma is a game generator and an example game instance is a particular set of payoffs that obey the Prisoner’s Dilemma preference ordering. Other game generators are more heterogeneous; for example, one that we will discuss later samples from the space of all strategically distinct 2× 2 games.\nA pairing and a game instance, taken together, are called a match. A match with one of the algorithms in the pairing left unspecified is a partially specified match (PSM). If two algorithms play the same PSM, we conclude that any differences between their performances are due to the algorithms themselves (including any internal randomization) because all else is held constant.\nA particular simulation of a match is called a run or trial. For pairs of deterministic algorithms, a single run is sufficient to characterize a match; for randomized algorithms (including any algorithm that plays a mixed strategy) multiple runs may each yield different behavior. In such cases, the match must be characterized by a solution quality distribution (SQD)—the empirical distribution of a performance metric.3 Each run consists of a number of iterations. In each iteration, the algorithms select strategies and then receive some feedback: e.g., their reward; the action choice of their opponent. Algorithms are allowed to select mixed strategies; in this case, a single action is sampled from the mixing distribution by the game. The iterations are separated into settling-in iterations and recorded iterations."
    }, {
      "heading" : "3.2. PLATFORM STRUCTURE",
      "text" : "In this section we give an overview of the structure of the platform. The five steps for running an experiment with the platform are summarized in Figure 1. There are three major components to this platform: the configuration GUI, the experiment engine (the piece that simulates the repeated games) and the visualization GUI. We describe each in turn.\nThe first step is to set up the experiment. First, a group of algorithms must be picked and algorithm parameters set. Second, a set of GAMUT game distributions must be selected and parameters for these games chosen. Third, general experimental parameters must be established, such as the number of iterations for each simulation. These decisions are encoded in human-readable text files, and can either be generated using a provided GUI or using batch scripts.\nThe second step is to generate a job file for each desired match. Each job file references the agent, game, equilibrium, and maxmin-strategy files. These files are referenced, making altering the job files simple even after they have been generated.\n3 We use the term SQD because it is standard in the empirical study of algorithms. We note nevertheless that in MAL there is no clear notion of a game having a ‘solution’, and that these distributions might be more meaningfully called ‘metric distributions’.\n10\nThe third step is to run the jobs. This primarily involves running the MALT “engine”; however, MALT calls GAMBIT’s (McKelvey et al., 2004) implementation of Lemke-Howson (Lemke and Howson, 1964) when an algorithm needs to find the set of Nash equilibria for a game instance, and CPLEX when an algorithm needs a maxmin strategy. Jobs may be run in several ways. The most basic is to run them in a batch job on a single machine. However, for large experiments this can be prohibitively expensive. Because each job is independent, it is straightforward to use a compute cluster. To facilitate such parallelization, each job creates an individual data file upon completion that records the history of play. For each recorded iteration and for each agent in the pair, the strategy, sampled action, reward received, and beliefs about the opponents are recorded.\nStep four is to compute performance metrics based on these data files. A plain-text file specifies the metrics to be calculated, based on an extensible library of available metrics. As above, metrics can be computed in a batch or can be distributed across a cluster.\nFinally, step five is to analyze and visualize these results. To make this task easier, MALT includes some basic analysis tools and a visualization GUI."
    }, {
      "heading" : "3.3. ALGORITHM IMPLEMENTATIONS",
      "text" : "To carry out this study, we selected and implemented eleven MAL algorithms, most of which we discussed previously in §2.6. In cases where reference code was available, we performed extensive validation experiments to ensure that our implementation was correct.\n3.3.1. Fictitious play Parameters for fictitious play are given in Table II. We note that the initial action frequencies were set to one for each action, which is a uniform and easily overwhelmed prior. Actions were selected from non-singleton best-response sets by favoring an action that was played in the previous iteration if present, and selecting uniformly at random otherwise.\n11\n3.3.2. Determined Our implementation of determined (see Table III) repeatedly plays the Nash equilibrium that obtains the highest personal reward, but if there are multiple equilibria with the same protagonist reward, then the equilibrium with the highest opponent reward is selected. If there are any equilibria that are still tied we use the one found first by GAMBIT’s implementation of Lemke-Howson.\n3.3.3. AWESOME AWESOME is implemented according to the pseudo-code in Conitzer and Sandholm (2007), and largely uses the parameter settings given there; see Table IV. Previous work on AWESOME assumed that the games that it encountered had a single Nash equilibrium. However, the games that we examine in this paper may have multiple equilibrium, so we needed to decide how our implementation of AWESOME would single out a special equilibrium for convergence in self-play. In our implementation the special equilibrium is the first equilibrium found by GAMBIT’s implementation of Lemke-Howson. It would be interesting to compare our implementation of AWESOME to one that used the more computationally-expensive approach of picking, say, a socially optimal equilibrium.4\n3.3.4. Meta Meta is implemented according to the pseudo-code in Powers and Shoham (2005). The Powers and Shoham (2005) implementation of meta used a distance measure based on the Hoeffding Inequality, even though the pseudo-code called for using an ℓ2 norm. We follow the pseudo-code and use the ℓ2 norm. We do not adjust the default threshold level (ǫ3) for distance, leaving it at the original value. All parameters for meta are summarized in Table V.\n4 In our validation experiments we observed a small but statistically significant difference between the behavior of our implementation of AWESOME and the original implementation from Conitzer and Sandholm (2007). (The original implementation was in C and MALT 2.0 is written in Java, so the original implementation could not be used directly.) Specifically, a test involving ten different game instances and 100 runs against the random agent showed a significant difference between solution quality distributions on three instances. We used a two-sample Kolmogorov-Smirnov independence test (see §4.2) with α = 0.05 to check for significance. For these three game instances, our implementation probabilistically dominated (see §4.5) the original implementation in terms of reward (i.e., every reward quantile was higher for our implementation). We were not able to track down the source of this behavior difference; however, we spent a considerable amount of time verifying our implementation against the pseudo-code in the paper and were unable to find any difference.\n12\nTable V. Design decisions for meta\nDesign Decision Setting\nSecurity threshold (ǫ0) 0.01 Bully threshold (ǫ1) 0.01 “Generous” BR parameter (ǫ2) 0.005 Stationarity threshold (ǫ3) 0.025 Coordination/exploration period (τ0) 90 000 Initial period (τ1) 10 000 Secondary period (τ2) 80 000 Security check period (τ3) 1 000 Switching probability (p) 0.00005\nWindow (H) 1 000 ‖·‖ ℓ2\n3.3.5. Gradient Algorithms Our implementation of GIGA-WoLF follows the original pseudo-code and uses the learning rate and step size schedules from the original experiments by Bowling (2004a) as defaults; see Table VI. We note, however, that these step sizes were set for drawing smooth trajectories and may not necessarily yield strong performance, and furthermore that the original experiments for GIGA-WoLF involved more iterations than we simulated (106 as compared to 105). For GIGA-WoLF’s retraction map operation (the function that maps an arbitrary vector in ℜn to the closest probability vector in terms of ℓ2 distance) we used an algorithm based on the method described in Govindan and Wilson (2003). GIGA-WoLF has two variants: in one it assumes that it can counterfactually determine the reward for playing an arbitrary action in the previous iteration, and in the other it only knows the reward for the the action that it played and has to approximate the rewards for the other actions. We implemented the latter approach, as all of GIGA-WoLF’s experimental results are produced by this version. The formula for the approximation is given by\n∀ȧ ∈ Ai r̂ (t+1) ȧ = (1− α)r (t) Iȧ=a(t) + α(r̂ (t) ȧ ). (3)\nIn this equation, r(t) is the reward that the algorithm experienced while playing action a(t) in iteration t. The vector r̂(t) is an |Ai|-dimensional vector that reflects the algorithm’s beliefs about rewards.\nWe also tested the Global Stochastic Approximation algorithm, GSA, of Spall (2003); see Table VII. To our knowledge we were the first to suggest its use in a MAL setting (Lipson, 2005). This algorithm is a stochastic optimization method that resembles GIGA, but takes a noisy, rather than deterministic, step. The GSA strategy is updated as\nx(t+1) = P (x(t) + η(t)r(t) + λ(t)ζ(t)), (4)\n13\nTable VI. Design decisions for GIGA-WoLF.\nDesign Decision Setting\nLearning rate (α(t)) 1√ t\n10 +100\nStep size (η(t)) 1√ 104t+108\nTable VII. Design decisions for GSA.\nDesign Decision Setting\nLearning rate (α(t)) 1√ t\n10 +100\nStep size (η(t)) 1√ 104t+108 Noise Weight (λ(t)) 1√ 105t+108\nTable IX. Design decisions for Q-learning.\nDesign Decision Setting\nLearning rate (α(t)) ( 1− 1 2000 )t Exploration rate (ǫ(t)) 1 5 ( 1− 1 500 )t Future discount factor (γ) 0.9\nwhere xt is the previous mixed strategy, rt is the reward vector, ζt is a vector where each component is sampled from the standard normal distribution (with variance controlled by the parameter λ(t)), and P (·) is the same retraction function used for GIGA-WoLF.\nRVσ(t) is a implementation of the algorithm given in Banerjee and Peng (2006). Some initial experiments showed that the settings of the algorithm used in the paper performed very poorly, and so we used some hand-picked parameter settings that were more aggressive and seemed to perform better. These are given in Table VIII.\n3.3.6. Q-Learning Our implementation of Q-learning is very basic; see Table IX. Since in a repeated game there is only one ‘state’, Q-learning essentially keeps track of Q-values for each of its actions. We use an ǫ-greedy exploration policy (perform a random action with probability ǫ) with a decaying ǫ. 400 exploration steps are expected for this ǫ-schedule, and ǫ drops below a probability of 0.05 at approximately iteration 2800. It is negligible at the end of the settling-in period (less than 3E−9). The learning rate (α) decays to 0.01 at the end of the settling in period. The discount factor of γ = 0.9 was set rather arbitrarily. There is no need to trade off current reward with future reward: all actions take the algorithm back to the same state.\n3.3.7. Minimax-Q and Minimax-Q-IDR For minimax-Q, we solved a linear program to find the mixed maxmin strategy based on the Q-values. This program was\nMaximize U1 subject to ∑\nj∈A1 u1(a j 1, a k 2) · σ j 1 ≥ U1 ∀k ∈ A2\n∑ σj1 = 1 σj1 ≥ 0 ∀j ∈ A1\n14\n(see, for example, Shoham and Leyton-Brown (2008)). We also considered a variant of minimax-Q in which iterative domination removal (IDR) is used as a preprocessing step. To our knowledge, we were the first to propose this algorithm in Lipson (2005); we dubbed it minimax-Q-IDR. In each step of the iterative IDR algorithm mixed-strategy domination is checked using a linear program (see, for example, Shoham and Leyton-Brown (2008)). Both LPs are solved with CPLEX 10.1.1. For both minimax-Q and minimax-Q-IDR, the learning rate, exploration rate, and future discount factor were set as in Q-learning; see Table IX.\n3.3.8. Random The final algorithm, random, is an simple baseline that uniformly mixes over the available actions. Specifically, it submits a mixed strategy σ where ∀a ∈ A, σ(a) = 1|A| ."
    }, {
      "heading" : "4. Experimental Setup and Statistical Methods",
      "text" : "As described in the preamble, this paper makes two main contributions. The first is the MALT platform, which we have now explained. The second is a demonstration of what MALT can do. Specifically, we conducted an large-scale experiment with the goal of investigating the empirical relationship between average reward and other performance metrics (e.g., equilibrium convergence; regret) that have been considered in the literature. In this section we describe the setup of this experiment and some of the statistical tools we used in our analysis.\nWe studied all eleven of the algorithms described in §3.3, and set their parameters as described there. We note in passing that this choice was important, as some algorithms are very sensitive to parameter settings. Nevertheless, we considered the issue of parameter optimization to be beyond the scope of our study, and took parameter settings largely from the literature as given.\nWe selected thirteen game generators from the GAMUT game collection; these are summarized in Table X. Details of each generator are available in GAMUT’s online documentation; see gamut.stanford.edu. We normalized the rewards of all game instances to the [0, 1] interval in order to make the results more interpretable and comparable. We generated a total of 600 different game instances. Specifically, we generated games of five different sizes: 2× 2, 4× 4, 6× 6, 8× 8 and 10 × 10. For each size, we generated 100 game instances, drawing uniformly from the first twelve generators. We drew an additional 100 instances from the last distribution, D13, which spans all strategically distinct 2× 2 games (Rapoport et al., 1976). We call the distribution induced by mixing over all 13 GAMUT generators the grand distribution.\nWith eleven algorithms and 600 game instances there were 11 × 11 × 600 = 72 600 matches. We ran each match once5 for 100 000 iterations, recording the last 10 000 iterations. This generated\n5 We note that each match could have been run multiple times instead of just once, and indeed that doing so would have been essential if we wanted to understand the behavior of randomized algorithms in individual matches. However, holding CPU time constant, conducting more runs per match would have meant either experimenting with fewer games or with fewer algorithms. Indeed, we show in Appendix A that not stratifying (holding one experimental variable fixed while varying another; as opposed to varying both) on game instances reduces variance for sample estimates of summary statistics like mean and median. Thus, we ran each match only once, and therefore use the terms ‘run’ and ‘PSM’ interchangeably in what follows.\n15\n143GB of data and took about a third of a CPU-year to run. In order to interpret the results we relied upon a variety of different empirical methods. We briefly describe some of them below."
    }, {
      "heading" : "4.1. BOOTSTRAPPING",
      "text" : "If we conduct an experiment where two algorithms are run on a number of PSMs then a natural way to compare their performance is to compare the sample means of some measure of their performance (average reward, for example). However, if we have the conclusion that ‘the sample mean of algorithm A is higher than the sample mean of algorithm B’, how robust is this claim? If we ran this experiment again are we confident that it would support the same conclusion?\nA good way to check the results of an experiment is to run it multiple times. For example, imagine that we ran an experiment 100 times and found that 95 of the experiments had a sample mean for algorithm A of between [a, a], and that 95 of the experiments had a sample mean for algorithm B of between [b, b]. If a > b (the lower bound of A’s interval was greater than the upper bound of B’s) then we can be confident that A is significantly better in terms of mean. (Specifically, these intervals are the 95% percent confidence intervals of the sample mean distribution, and the fact that they do not overlap serves as sufficient evidence that there is a significant relationship between the means.)\nWhile such repeated experimentation can be used to ensure that results are significant, it is also expensive. To verify the summary statistics from one experiment, we had to run many more. This is not always possible (e.g., our experiments took 7 days on a large computer cluster, so to rerun them a hundred more times would have taken the better part of two years). Bootstrapping is a technique that allows us to use the data from a single experiment to construct confidence intervals of summary statistics. Given an experiment with m data points, we can ‘virtually’ rerun the the experiment by subsampling from the empirical distribution defined by those m points. For example, if we have a\n16\nsample with 100 data points, we could subsample 50 data points (with replacement) from these 100 and look at the statistic for this subsample. We can cheaply repeat this procedure as many times as we like, creating a distribution for each estimated statistic. From these bootstrapped estimator distributions we can form bootstrapped confidence intervals and check for overlap.\nThere are two parameters that control the bootstrapped distribution: we form the distribution by subsampling l points from the original m, and we repeat this process k times. For our analysis we chose l to be ⌊m/2⌉ and k to be around 2 500. These particular parameters were chosen to ensure that there would be diversity among the subsamples (this explains the moderate size of l) and that the empirical distributions would be relatively smooth (this explains the large k)."
    }, {
      "heading" : "4.2. KOLMOGOROV-SMIRNOV TEST",
      "text" : "While bootstrapping is useful for seeing if summary statistics are significantly different, we will also want to check if two distributions are themselves significantly different. A beta distribution and a Gaussian distribution might coincidentally have the same mean, but are nevertheless different distributions. We use the KolmogorovSmirnov (KS) test for determining whether two distributions are different. This test is nonparametric, meaning that it does not assume that the underlying data is drawn from a known (e.g., normal) probability distribution. The KS test works by examining the maximum vertical distance between two CDFs . Two distributions are considered significantly different if this maximum vertical distance exceeds a given significance level, α. In our analysis we use the standard α = 0.05 unless otherwise noted."
    }, {
      "heading" : "4.3. SPEARMAN’S RANK CORRELATION TEST",
      "text" : "Spearman’s rank correlation test is a way to establish whether or not there is a significant monotonic relationship between two paired variables. For example, we might want to show that there is some significant monotonic relationship between the size of a game’s action set size and an agent’s average reward. Like the KS test, the Spearman’s rank correlation test is non-parametric. The relationship between the two variables can be positive (high values of one variable are correlated with high values of the other variable) or negative (high values of one variable are correlated with low values of the other)."
    }, {
      "heading" : "4.4. ASSESSING CONVERGENCE",
      "text" : "We are interested in studying the convergence behavior of MAL algorithms. One issue in doing so based on empirical data is dealing with runs that appear “not quite” to have converged because of random fluctuations in the empirical action frequency. A natural solution to this problem is to perform a statistical test to determine whether one part of the run exhibits the same action distribution as a later part. For example, we might check whether a later empirical action distribution was drawn from the same distribution as an earlier sample (establishing that empirical mixed strategies were stationary) or that an empirical action distribution profile was drawn from a given mixed-strategy profile (establishing convergence to a Nash equilibrium).\nTwo obvious candidates for such a test are the Fisher exact test (FET) and Pearson’s χ2-test, which can be used for checking whether two multinomial samples are drawn from a distribution.\n17\nHowever, each test was unfortunately inappropriate for our problem. The χ2 test does not handle situations where some of the actions are rare or not present. The FET is very computationally expensive, and the implementation of it that we used (R Development Core Team, 2006) failed on some of the larger and more balanced action vectors (typically in the 10× 10 case).\nInstead, we used the incomplete set of FET results to calibrate a threshold based on vector distance, where we considered any two action distribution vectors that were closer than the threshold θ to be the same. We calibrated θ using a receiver operating characteristic (ROC) curve. We used the incomplete FET results as ground truth, and plotted the change in true positive rate and false positive rate as we varied θ. We picked the threshold that led to an equal number of false positives and false negatives. Based on this ROC analysis, we picked a θ of 0.02."
    }, {
      "heading" : "4.5. PROBABILISTIC DOMINATION",
      "text" : "The concept of probabilistic domination can be used to argue that one distribution should be preferred to another in terms of a given performance metric. Specifically, a solution quality distribution (SQD) A dominates another SQD B if ∀q ∈ [0, 1], the q-quantile of A is higher than the q-quantile of B. If there are two algorithms, A and B, that are trying to maximize reward, and A’s SQD probabilistically dominates B then regardless of the reward value r, there are more runs of A than of B that attain a reward of at least r. Probabilistic domination is stronger than a claim about the mean of the distributions: domination implies higher means.\nChecking for probabilistic domination between two samples can be performed visually. If one of the CDF curves is below the other curve everywhere, than the former dominates the latter. Intuitively, this is because the better SQD has less probability mass on low solution qualities, and more mass on higher solution qualities; better distributions are right-shifted."
    }, {
      "heading" : "5. Empirical Evaluation of MAL Algorithms: Average Reward",
      "text" : "As we discussed at the beginning of this paper, we consider average reward to be the most fundamental metric for assessing the performance of a MAL algorithm. We take the average with respect to the sampled actions rather than the submitted mixed strategy. Formally, where the iterations 1 to T refer to the 10 000 iterations we recorded, we define the average reward an algorithm i obtains in a single match as r̄(T )i = 1 T ∑T t=1 r (t) i .\nIn this section, we investigate the average reward metric in detail. We begin in §5.1 by comparing algorithms according to their “raw” average reward, averaging not only over iterations but also across both generators and opponents . Next, we investigate each of these dimensions separately. In §5.2 we explore algorithm performance across different generators, and also examine the effect of game size. In §5.3 we explore algorithm performance across different opponents, and also analyze the equilibria of the “algorithm game”, in which available actions are different choices of MAL algorithms. §5.4 investigates probabilistic domination relationships between different algorithms and §5.5 considers each algorithm’s performance in self play. Finally, §5.6 explores similarities between different algorithms.\n18"
    }, {
      "heading" : "5.1. “RAW” AVERAGE REWARD",
      "text" : "First we consider each algorithm’s “raw” average performance, averaged across the number of iterations, games and opponents.\nOBSERVATION 1. Q-Learning and RVσ(t) attained the highest rewards on the grand distribution.\nQ-learning had the highest mean reward at 0.714, although RVσ(t) was close with an average of 0.710 (see Figure 2). We noticed considerable variation within the reward data, and all of the other algorithms’ sample means still were within one standard deviation of Q-learning, including random (which obtained a sample mean of 0.480).\nThese rankings were not all significant. The slight difference in means between Q-learning and RVσ(t) does not in fact indicate that Q-learning was a better algorithm (in terms of means) on the grand distribution of games and opponents. However, these two algorithms attained significantly higher reward than any other algorithm. We determined this by examining the 95% percentile intervals on bootstrapped mean estimator distributions (see §4.1) and seeing which intervals overlapped (see Figure 3). We obtained the distributions by subsampling 2 500 times, where each subsample consisted of 6 600 runs (half as many as the 13 200 runs that each algorithm participated in).\nThe distribution of reward was not symmetric, and specifically tended to exhibit negative skewness, indicating that the proportion of runs that attained high reward was larger than the proportion of runs that attained low reward. (Random was the only exception.) Q-learning’s distribution had the highest skewness, −0.720, so was the best algorithm in this respect.\n19"
    }, {
      "heading" : "5.2. PER-GENERATOR AVERAGE REWARD AND THE EFFECT OF GAME SIZE",
      "text" : "Now we go beyond performance on the grand distribution. First we consider each algorithm’s performance across individual game distributions. As can be seen in Figure 4, every algorithm’s performance varies considerably across the different game generators. However, this figure makes it difficult to determine the best algorithm for generators that all algorithms found challenging. Thus, we also present a normalized version of these per-generator reward results, obtained by dividing the results for each algorithm on a particular generator by the maximum reward attained by any algorithm (Figure 5). We can see that minimax-Q, minimax-Q-IDR and random were all worse than the other algorithms across a broad range of generators, and Q-learning and RVσ(t) tended to do well.\nOBSERVATION 2. Q-Learning was the best or one of the best algorithms to use for most generators.\nWe define the set of best algorithms for a generator as the set of algorithms whose bootstrapped mean estimator 95% percentile intervals overlapped with the algorithm with the best sample mean. Q-Learning was the unique best algorithm or was one of the best algorithms for 10 of our 13 generators (see Table XI). It was the only algorithm that was the unique best choice for any generator, taking this role for generators D1, D4, and D9. Furthermore, Q-learning also belonged to the set of best algorithms for generators D2, D3, D7, D10, D11, D12 and D13. While Q-learning most frequently was a member of a generator’s best algorithm set, fictitious play and determinedwere also frequently in these sets (6 and 7 generators respectively).\nThe gradient algorithms were especially strong on D7; indeed, this was the only generator for which all three gradient algorithms were in the best algorithm set. D5, D6, and D8 were interesting\n20\nTable XI. The set of best algorithms for each generator.\nGen Set of Best Algorithms\nD1 Q-learning\nD2 Q-learning, RVσ(t) D3 AWESOME, determined, fictitious play, GSA, meta, Q-learning, RVσ(t) D4 Q-learning\nD5 determined, fictitious play\nD6 AWESOME, determined, fictitious play\nD7 GSA, Q-learning, RVσ(t) D8 determined, fictitious play, meta\nD9 Q-learning\nD10 fictitious play, Q-learning\nD11 determined, fictitious play, meta, Q-learning\nD12 determined, Q-learning\nD13 AWESOME, determined, GSA, Q-learning, RVσ(t)\nx x x x\nx x x x x\nx x x x\nx x x x x\nx x x x x\nx x x x x x\nx x x\nx x\nx x x\nx x x x\nx x x x\nCorrelation Between Size and Reward\nGenerator\nA lg\nor ith\nm\nD1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11 D12\nfict\ndet\nmeta\nawe\nq\nrvs\ngsa\ngiga\nmini\nmin\nrand\nFigure 6: A heatmap summarizing the correlations between size and reward for different agents on different generators. A white cell indicates positive correlation, a black cell indicates negative correlation, and a gray cell with an ‘x’ indicated an insignificant result.\ndistributions for AWESOME and meta. In D5, neither AWESOME nor meta managed to be one of the best algorithms despite the fact that both fictitious play and determined—two of the algorithms that they manage—were. In D6, AWESOME joined fictitious play and determined but meta did not, and in D8 the reverse happened: meta, fictitious play and determined were the three best algorithms. These three generators illustrate situations where portfolio algorithms failed to capitalize on one of their managed algorithms. It would be interesting to run further experiments to determine why this occurred and if it could be remedied.\nFor all but one of our generators (D13: 2 × 2 games) we generated games of varying sizes. Now we consider how the size of a game’s action set affected performance. Our hypothesis was that larger action spaces raise the possibility of more complicated game dynamics, and that such complex dynamics can slow learning. Thus, we expected to see average reward decreasing as the size of the game grew.\nOBSERVATION 3. There was no general relationship between game size and reward: for some generators, algorithms achieved higher rewards on larger games, and for other generators algorithms achieved higher rewards on smaller games.\nOur experiment showed that this intuition did not always hold. First, for many algorithms on many generators we could not reject the null hypothesis of the Spearman rank correlation test—that there was no significant correlation between size and performance—at a significance level of α = 0.05. For instance, in D7 only GSA and GIGA-WoLF had significant trends (both exhibited negative correlation; reward was lower in larger games). Second, even when a significant correlation did\n21\nexist, it was not always negative. We did observe that for most distributions, significant correlations were either entirely negative or entirely positive. For D2, D7, D8, D9, and D11 the correlation was negative; for D3, D4, D5, D10, and D12 it was positive. D1 and D6 exhibited both kinds of correlation for different algorithms.\nOverall, the relationship between game size and reward appears to depend strongly on the choice of generator. It could be the case that when the action spaces increase in size, important game features tied with high reward become more common, or it could be that larger action spaces make it easier for MAL algorithms to miscoordinate, which is desirable for some games. Indeed, D4— Dispersion Games— show positive correlation between the number of actions and reward, and this is a game where agents need to miscoordinate to do well.\nAs Figure 6 shows, D2 and D12 were the only two distributions on which we could reject the null hypothesis for all algorithms, and they supported opposite conclusions. On instances from D2, correlation was completely and strongly negative: the larger the game, the worse every algorithm performed. The least correlated algorithm was random with a Spearman’s coefficient of correlation ρ = −0.329. Correlation was entirely positive for D11, but some of the coefficients were smaller. Fictitious play was the least sensitive to size (ρ = 0.07), but it was anomalous. The algorithm with the next smallest coefficient was GIGA-WoLF, with ρ = 0.267."
    }, {
      "heading" : "5.3. PER-OPPONENT AVERAGE REWARD AND THE ALGORITHM GAME",
      "text" : "We now consider each algorithm’s average reward on a per-opponent basis.\nOBSERVATION 4. Algorithm performance depended substantially on which opponent was played.\nFigure 7 shows the mean reward achieved by each algorithm against every possible opponent. One striking feature of this figure is that minimax-Q, minimax-Q-IDR and random were all relatively weak against a broad range of opponents. We also observe that fictitious play and determined tended to get lower reward in self play and against each other than against other opponents. Meta—an algorithm that manages a profile of algorithms including fictitious play and determined—also appear to have inherited these performances issues, while AWESOME—the other portfolio algorithm—substantially avoided them.\nIf we know what algorithm the opponent is using, which algorithm should we use? We constructed “best-response sets” for each possible opponent using bootstrapped percentile intervals. We call the algorithm with the highest mean against a particular opponent a best response, but also assign any algorithm with an overlapping bootstrapped 95% percentile interval to the set—we cannot claim that these algorithms do significantly worse than the apparent best algorithm. These best response sets are summarized in Table XII. Q-learning and RVσ(t) were most frequently best responses, while fictitious play, meta, minimax-Q, minimax-Q and random were never best responses.\nOne interesting way to interpret these best response results is to consider the one-shot “algorithm game”: a single-shot normal-form game in which the actions correspond to our 11 algorithms and the payoff for using algorithm A against algorithm B is the mean reward that algorithm A attained against B. There were three algorithms that were strictly dominated in this grand distribution algorithm game: minimax-Q,minimax-Q-IDR and random. Strict domination of algorithm A′ by\n22\nA means that regardless of what algorithm the opponent selects, A is always a better choice than A′. As with best responses, we required domination to be significant: we wanted to be confident that if the experiment were repeated, we would get a similar result. We used bootstrapping to check this, subsampling 6 600 PSMs 10 000 times and from these forming 10 000 ‘subsampled’ games. We checked for strict domination in each game, and considered an algorithm dominated if it was dominated in at least 95% of the subsampled games. The proportion of subsampled algorithm games in which each algorithm was dominated is shown in Table XIII; we also distinguish strict domination from weak domination.\nOBSERVATION 5. Determined and Q-learning were the only algorithms to participate in pure-strategy Nash equilibria of the algorithm game.\nOnly two pure-strategy Nash equilibria ever occurred in the subsampled games for the grand distribution: Q-learning in self play, and Q-learning against determined. The Q-learning–Q-learning equilibrium is particularly convincing because it is symmetric and so does not require that the players coordinate to playing different strategies, and furthermore because it occurred in 90.2% of the subsampled games. The other equilibrium occurred in the remaining 9.8% of games. (Because both equilibria involved Q-learning, we did not observe them together in the same subsampled games.)\nWe looked more deeply into the algorithm games by restricting attention to individual generators. The generators varied substantially in their pure-strategy Nash equilibria. Overall, Determined in self play constituted the most common symmetric pure-strategy Nash equilibrium. It was a significant Nash equilibrium for seven of the generators. (That is, determined in self play\n23\nTable XII. The different algorithms and their best-response sets\nOpponent Best-Response Set\nAWESOME GIGA-WoLF, GSA RVσ(t) Determined AWESOME, GIGA-WoLF, GSA,\nQ-learning RVσ(t) Fictitious play GSA, Q-learning RVσ(t)\nGIGA-WoLF determined, Q-learning RVσ(t) GSA determined, Q-learning RVσ(t) Meta determined, GIGA-WoLF, GSA RVσ(t) Minimax-Q Q-learning\nMinimax-Q-IDR Q-learning\nQ-Learning determined, Q-learning RVσ(t) Random determined, Q-learning RVσ(t) RVσ(t) determined\nTable XIII. The proportion of subsampled algorithm games in which each algorithm was strictly dominated (SD) or weakly dominated (WD).\nAlgorithm SD WD\nAWESOME 10.8% 11.7%\nDetermined 0.0% 0.0%\nFictitious play 35.9% 36.4%\nGIGA-WoLF 54.1% 55.1%\nGSA 0.4% 0.4%\nMeta 28.8% 28.2%\nMinimax-Q 100.0% 100.0%\nMinimax-Q-IDR 100.0% 100.0%\nQ-Learning 0.0% 0.0%\nRandom 100.0% 100.0%\nRVσ(t) 0.0% 0.0%\nwas a pure-strategy Nash equilibrium in more than 95% of the subsampled games for each of these generators.) Q-Learning in self play was the second most common symmetric pure-strategy Nash equilibrium, arising in the algorithm games for four generators.\nGenerators also differed substantially in their number of pure-strategy Nash equilibria. For instance D1 (A Game with Normal Covariant Payoffs) had no significant pure-strategy Nash equilibrium. D4 (Dispersion Game), at the other extreme, had 22 pure-strategy Nash equilibria (see Figure 9). Part of the reason for the large number of equilibria in D4 was that a majority of runs for many of the algorithms yielded a reward of 1 (e.g., 84.6% of AWESOME’s runs yielded a reward of 1). This meant that in many of the subsampled games, the majority of payoffs were exactly 1 and so there were many weak Nash equilibria. For example, both RVσ(t) and Q-learning attained a reward of 1 against fictitious play, and fictitious play itself attained a reward of 1 against RVσ(t) and fictitious play. Therefore both RVσ(t)–fictitious play and Q-learning–fictitious play were pure Nash equilibria."
    }, {
      "heading" : "5.4. PROBABILISTIC DOMINATION OF ONE ALGORITHM BY ANOTHER",
      "text" : "Now we consider the following question: given a fixed opponent, is a given algorithm probabilistically dominated by any alternative algorithm in terms of average reward?\nOBSERVATION 6. Q-Learning was the only algorithm that was never probabilistically dominated by any other algorithm when playing any opponent.\nQ-Learning had the best performance in terms of probabilistic domination. Determined and RVσ(t) were the next-least-dominated algorithms: determined was only probabilistically dominated by AWESOME against a fictitious play opponent, which was in turn dominated\n24\nby Q-learning; RVσ(t) was dominated by Q-learning when playing against the minimax-Q variants, and also by determined when playing against RVσ(t). On the whole, domination by another algorithm in self play was a common trend; only AWESOME, determined and Q-learning avoided being dominated by another algorithm when playing themselves. It is interesting that determined was not dominated: we see this as a property of the specific game distributions that we studied.\nOverall, while we observed some strong domination relationships, these were the exceptions while ambiguity was the rule. For most algorithm pairs against most opponents, no probabilistic domination relationship existed (see Figure 10). Furthermore, there was no opponent for which one algorithm probabilistically dominated all others."
    }, {
      "heading" : "5.5. SELF PLAY",
      "text" : "We have already seen evidence that self-play was challenging for many algorithms (e.g., see the tendency towards ‘cool’ cells on the main diagonal of Figure 7). A closer analysis shows that for most algorithms there was indeed a significant relationship between self play and low reward.\nOBSERVATION 7. Most algorithms attained lower average reward in self play.\nThe distributions of reward in self-play runs for AWESOME, determined, fictitious play and meta were probabilistically dominated by the distribution of reward in non-self-play runs. While the same was not true for the gradient algorithms (they achieved fewer low-reward runs in self play), their self-play means were nevertheless significantly lower than their non-selfplay means. We verified this by looking at the 95% bootstrapped percentile intervals. There was no significant relationship for minimax-Q and minimax-Q-IDR, and this self-play trend was\n25\nreversed for Q-learning: its self-play runs probabilistically dominated its non-self-play runs. Furthermore, Q-learning achieved a higher mean reward in self play than any other algorithm (see Figure 11).\nInterestingly, AWESOME was one of the algorithms with poorer self-play runs, despite its machinery for converging to a special equilibrium in self play. We wondered whether this occurred because AWESOME did not converge due to an overly-conservative threshold for detecting whether its opponent was playing part of an equilibrium, or because AWESOME did converge to the special equilibrium, but that equilibrium did not offer high reward. (Note that our implementation of AWESOME coordinates to the first Nash equilibrium found by GAMBIT’s implementation of Lemke-Howson.) At the risk of keeping the reader in suspense, we defer the answer to §6.3, in which we examine equilibrium convergence results."
    }, {
      "heading" : "5.6. ALGORITHM SIMILARITY",
      "text" : "Finally, we investigate similarities between algorithms’ abilities to achieve high reward. We can assign some of our algorithms to one of three major blocks. First, AWESOME and meta are similar because they both manage portfolios incorporating fictitious play and determined; likewise, we expect them to be similar to the fictitious play and determined algorithms themselves. Second, GIGA-WoLF, GSA and RVσ(t) are similar because they all follow a reward gradient. Finally, minimax-Q and minimax-Q-IDR are similar because the latter is the same as the former except for the addition of an IDR preprocessing step. We call these the portfolio, gradient, and minimax blocks. We also might suspect that Q-learning, an algorithm that does\n26\nnot explicitly model the opponent, might be similar to the gradient algorithms. Nevertheless, we do not assign Q-learning to a block; likewise, we leave random unassigned.\nWe tested all pairs of algorithms for similarity by comparing their average reward distributions for all generator–opponent pairs. Thus, we tested each algorithm pair 13 × 11 = 143 times— every algorithm is of course similar to itself and so we did not check these cases. Failing to reject the null hypothesis of the KS test (that both samples were drawn from the same population) is some evidence for the samples being similar. This rough-and-ready approach does not establish significant similarity and is merely suggestive of similarity; failing to reject a null hypothesis is not the same as having shown that the null hypothesis is true. However, with this caveat in mind, we observed some interesting trends.\nOBSERVATION 8. Similar algorithms tended to exhibit similar performance.\nAll three predicted blocks emerge, as can be seen in Figure 12. First, meta, AWESOME, fictitious play and determinedwere all similar to each other on a large number of opponent– generator pairs. Both meta and AWESOME were similar in more cases to determined than to fictitious play. For instance, AWESOME was similar to determined in 101 out of 130 cases while similar to fictitious play in only 81 cases. Meta and AWESOME were also quite similar to each other (88 cases). Q-learning was similar to the algorithms in this block, especially determined and AWESOME, which we had not expected. AWESOME was more similar to Q-learning than to any other algorithm: they were similar in 103 cases, while even determined and AWESOME were only similar in 101 cases.\nThe block of algorithms consisting of RVσ(t), GIGA-WoLF and GSA were all similar in a large number of cases, with a particularly tight relationship evident between GIGA-WoLF and GSA (similar in 111 cases). Q-Learning also bore similarities to the gradient-algorithm block. These algorithms also showed somewhat weaker similarity to determined and AWESOME.\nThe connection between minimax-Q and minimax-Q-IDRwas particularly strong (similar in 118 cases). These were also the algorithms most similar to random—indeed, similar almost twice as often as the next-most-similar algorithm (AWESOME: it was similar to random in 11 cases, as compared to minimax-Q’s 21 cases)."
    }, {
      "heading" : "6. Empirical Evaluation of MAL Algorithms: Other Metrics",
      "text" : "So far, all of our experimental discussion has concerned the average reward metric. However, a wide variety of other metrics have also been proposed and studied in the literature. Here we consider many of the most prominent. This allows us to understand our experimental results in different ways, and furthermore sheds light on the extent to which each metric correlates with high reward in practice. In §6.1 we investigate regret, specifically considering mean regret, probabilistic domination of one algorithm by another, and the relationship to reward. In §6.2 we assess algorithms’ tendencies to converge to stationary strategies. §6.3 considers convergence to Nash equilibrium of the stage game, and relates this metric to reward. In §6.4 we consider algorithms’ abilities to achieve at least their maxmin payoffs, and consider both per-opponent maxmin performance and\n27\nthe relationship to reward. Finally, in §6.5, we measure algorithms’ tendency to converge to payoff profiles consistent with Nash equilibria of the infinitely-repeated stage game."
    }, {
      "heading" : "6.1. REGRET",
      "text" : "Regret is the difference between the reward that an algorithm could have received by playing the best static pure strategy and the reward that it did receive:\nRegret(~σi,~a−i) = max a∈Ai\nT ∑\nt=1\n[\nr(a, a (t) −i)− E\n[\nr(σ (t) i , a (t) −i)\n]]\n. (5)\nThe best static pure strategy is determined after the run, based on the assumption that the opponent’s strategy in each round would not change. We use the strategy formulation of regret—as opposed to one that uses the sampled actions that the algorithm played—following Bowling (2004a). Rather than looking at the total sum of regret over all 10 000 recorded iterations, we will discuss the mean regret over these iterations. Since player payoffs are restricted to the [0, 1] interval, mean regret can give a better sense of the magnitude of regret with respect to possible reward.\nRegret has been suggested as a measure of how exploitable an algorithm is. If an agent accrues significant regret one possible explanation is that it did the wrong thing. However, in some games (e.g., the Traveler’s dilemma) ignoring regret can lead to greater long-term reward.\nSome algorithms, including GIGA-WoLF and RVσ(t), are no-regret learners: they come with the guarantee that they will always approach zero regret as the number of iterations approaches infinity. However, to our knowledge it has not been shown experimentally how the regret achieved by these algorithms compares to the regret achieved by other algorithms that lack such a guarantee; nor has it been demonstrated whether these algorithms achieve better than zero regret in practice.\nOBSERVATION 9. Q-Learning best minimized regret. GIGA-WoLF most frequently achieved negative-regret runs.\nIn our experiment, all algorithms achieved positive mean regret (Figure 13), though they differed substantially in the fraction of their matches in which they achieved positive regret (Figure 14). All the means were significantly different, based on overlaps in the 95% percentile intervals (there was none). Of these, Q-learning had the lowest regret, at 0.008. The gradient algorithms— GIGA-WoLF, GSA and RVσ(t)—had the next lowest mean regret after Q-learning. Among the gradient algorithms, GSA achieved the lowest mean regret, followed by RVσ(t) and then by GIGA-WoLF. These empirical results are concordant with GIGA-WoLF and RVσ(t)’s theoretical no-regret guarantees—not only are these algorithms guaranteed zero regret in the limit, but they also achieved low regret in practice. At the same time, it is interesting that the algorithm with the best results, Q-learning, comes with no such guarantee.\nConsidering only mean regret masks an interesting difference between Q-learning and the gradient algorithms: they achieve low mean regret in different ways (see Figures 14 and 15). Q-Learning achieved low mean regret by attaining zero regret in most (89.5%) of its runs. It had the fewest positive-regret runs (10.4%; the next lowest was AWESOME at 18.2%), and also had\n28\nthe second-fewest negative-regret runs (0.1%; only fictitious play had (slightly) fewer). On the other hand, the gradient algorithms rarely achieved zero regret (the algorithms with the fewest zero runs were GSAwith 2.49%, RVσ(t)with 2.58%, random with 4.29% and GIGA-WoLFwith 11.10) but often achieved negative regret (the three algorithms with the most negative regret runs were GIGA-WoLF (5.8%), RVσ(t) (3.2%) and GSA (3.0%)).\nOverall, no algorithm achieved less than very slightly negative regret: the run with the smallest regret had an average regret of −2 × 10−6. The converse was not true for positive regret: in 440\n29\ndifferent runs some algorithm attained average regret of 1, meaning that it took precisely the wrong action in every round. 48.6% of these runs involved fictitious play or one of the algorithms that wrap around fictitious play (AWESOME or meta) in self play, and were on generator D4 (Dispersion Games), which reward miscoordination. We can conclude that in these cases fictitious play became stuck in pathological cycling between the symmetric outcomes (where both agents play the same action), which yield zero reward. Such cycling is a well-known problem with fictitious play; based on claims in the literature, a judicious application of noise to the algorithm would have broken the cycle and improved fictitious play’s performance.\nConsidering regret on a per-generator basis, Q-learning achieved the lowest mean regret on every generator except for D13 (strategically distinct 2 × 2 games), on which RVσ(t) was the best. Q-learning was also the best algorithm to use against almost every opponent. There were only two exceptions: RVσ(t) was better against Q-learning and AWESOME was better against itself. Another interesting pairing was when Q-learning played against fictitious play: Q-learning attained zero regret in every single game. This indicates that Q-learning (uniquely among our algorithms) converged to a pure-strategy best response in every game against fictitious play.\n6.1.1. Probabilistic Domination of One Algorithm by Another When we consider regret distributions on a per-opponent basis, some strong probabilistic dominance trends emerge.\nOBSERVATION 10. On a per-opponent basis, Q-learning, GIGA-WoLF, GSA and RVσ(t) were rarely probabilistically dominated in terms of regret.\nFirst, say that algorithm A dominates B k times if there are k opponents C such that A’s regret distribution for matches against C probabilistically dominates B’s regret distribution for matches against C . Under this notion of domination, we found that the gradient algorithms were never dominated by any other algorithm (Figure 17). Q-learning was only dominated once, by AWESOME in the case of an AWESOME opponent. We were not surprised by this, since AWESOME has special machinery for converging to a stage-game Nash equilibrium in self play. (In a Nash equilibrium, of course, both agents play best responses to each other and hence both accrue zero regret.) On the other hand, fictitious play was frequently dominated, especially by AWESOME, determined, Q-learning and to a lesser degree meta. Both determined and Q-learning dominated fictitious play against 10 opponents (Q-learning was the exception for determined and vice versa), and AWESOME dominated fictitious play on 9 opponents (GIGA-WoLF and meta were the only opponents for which AWESOME did not dominate fictitious play).\nWe can also define probabilistic domination in another way, saying that algorithm A dominates B k times if there are k generators G such that A’s regret distribution on games from G probabilistically dominates B’s regret distribution on games from G. Considering domination in this sense, we can draw similar conclusions (Figure 18). Q-Learning dominated other algorithms frequently—particularly fictitious play (on 9 generators), meta (8 generators), and\n30\nAWESOME (on 8 generators)—while avoiding domination by any other algorithm. Fictitious play was dominated frequently: by Q-learning (9 generators), determined (6), AWESOME (6) and meta (4).\n6.1.2. Links Between Regret and Reward What is the connection between regret and reward? We expected that high reward should be correlated with low regret, and vice versa. This intuition was largely supported by our experimental data. Regret and reward were negatively correlated for all algorithms (Spearman’s rank correlation test; α = 0.05): high reward was linked with low regret. On a per-generator basis, we observed that D10 (Traveler’s Dilemma) induced positive correlation between regret and reward for all algorithms except determined (Figure 19). This makes sense: in this game, algorithms do better when they do not play best responses, and indeed the unique Nash equilibrium is one of the worst outcomes of the game.\nWe compared the average reward each algorithm obtained in positive-regret runs and nonpositive-regret runs. For most of the algorithms, the distribution of average reward obtained in non-positive-regret runs probabilistically dominated the distribution of average reward obtained in positive regret runs. There were some exceptions. For example, Q-learning exhibited a relatively minor crossover. The same phenomenon occurred with GIGA-WoLF, but in a more pronounced fashion: runs that attained positive regret less often attained zero reward (Figure 20). Even more dramatically, the positive-regret run distributions probabilistically dominated the nonpositive run distributions for GSA and RVσ(t). These two (gradient) algorithms exhibited behavior different from the other nine: runs with positive regret had better reward characteristics than runs with zero or negative regret. This phenomenon did not seem to arise in the context of a single\n31\ngenerator or opponent. However, we did note that the probabilistic domination seemed the weakest when PSMs involving Traveler’s Dilemma were omitted."
    }, {
      "heading" : "6.2. STRATEGIC STATIONARITY",
      "text" : "All of the metrics we have discussed so far have been based on reward. We now consider several that are based on empirical frequency of action, and that ask whether these frequencies converge. The first—and weakest—notion of convergence that we consider measures whether or not an algorithm converges to a stationary strategy profile. This is interesting in its own right, and is also a necessary condition for stronger forms of convergence.\nWe consider a run to have been stable if the joint distribution of actions was the same in the first and second halves of the recorded iterations, tested according to the threshold criterion described in §4.4 and using ℓ∞-distance. Stability is a property of a run rather than a single algorithm’s play in a run, so even algorithms that always play stationary strategies can still participate in unstable runs.\nTo check how successful our threshold criterion was at detecting stationarity, we began by examining the results for our two algorithms that always play stationary strategies. Our criterion found determined to be stable in 99.5% of self-play matches and random to be stable in 92.0% of self-play matches. When playing each other, they were found to be stable 94.8% of the time. The differences between these cases are likely because determined tends to adopt mixed strategies with smaller supports than randomdoes, and such a mixed strategy is more likely to yield an empirical action distribution that closely resembles it.6\n6 We note that a false positive rate of between 0.5% and 8% is larger than might be hoped, but nevertheless defer consideration of improved criteria for measuring empirical convergence to future work.\n32\nWe found GIGA-WoLF and GSA to be the least likely to be stable—particularly in self play, against each other, or against meta (see Figure 21). Their striking instability with meta was potentially because they tripped meta’s internal stability test and changed its behavior. However, AWESOME also has a similar internal check, but the stability of GIGA-WoLF and GSA were not noticeably different between matches with AWESOME and with Q-learning (which has no such check). RVσ(t), the other gradient algorithm, was more stable than GIGA-WoLF and GSA. This might be because RVσ(t) had a more aggressive step length: the parameters used in this experiment for GIGA-WoLF and GSA were taken from Bowling (2004a), who indicated that these parameters were intended to produce smooth trajectories rather than fast convergence.\nMeta,determined,fictitious play and AWESOMEwere, for the most part, quite good at achieving stationarity. Meta and fictitious play were particularly strong against each other, and always reached a stationary strategy profile. The only exception to the rule of stability in this group was AWESOME vs. meta; this pairing was unstable in 10.3% of runs. We are not sure why this occurred, but conjecture that it arose because of the discrete behavioral changes that both algorithms undergo when their internal states are updated.\nThere were a number of problem generators for the different algorithms (see Figure 22). For example: generators D1, D2, and D10 created instances that were particularly difficult for the gradient algorithm in terms of strategic stability; Q-Learning was weak on both D5 and D7; and meta tended to be unstable on D5, D7 and D10. However these unstable instances were rare regardless of the algorithm pairing. The vast majority of runs found a stationary strategy profile. Even GIGA-WoLF, which was the algorithm least likely to stabilize, found stationarity in 87.0% of its runs (see Figure 23).\n33"
    }, {
      "heading" : "6.3. CONVERGENCE TO STAGE-GAME NASH EQUILIBRIUM",
      "text" : "Stable runs are those that converged to any strategy; we now consider which of these selected a (possibly mixed-strategy) stage-game Nash equilibrium. For some algorithms, Nash equilibrium convergence was reasonably common. AWESOME converged in 54.3% of its runs, and determined converged in 53.1% of its runs. Determined was better than AWESOME at converging to a Pareto-optimal Nash equilibrium (a Nash equilibrium that was not Pareto-dominated by any other Nash equilibrium). AWESOMEmost frequently converged to a Pareto-dominated equilibrium. This was likely influenced by the way that our implementation of AWESOME picked its ‘special’ equilibrium:7 the first equilibrium found by the Lemke-Howson algorithm, without attention to whether it was, e.g., Pareto-dominated. AWESOME also tended to attain lower reward when it converged to a Pareto-dominated Nash equilibrium than when it did not converge or converged to a non-dominated Nash equilibrium.\nFigure 24 shows the extent to which each algorithm converged to a stage-game Nash equilibrium in self play. Notice how often determined converged: this indicates that the games we studied often possessed one Nash equilibrium that was the best for both agents. Indeed, we can see that a surprisingly high number of games had a unique stage-game Nash equilibrium (58.5%). We expect that convergence results would look qualitatively different with generators that were much less likely to produce games with unique equilibria.\nObserve that AWESOME nearly always converged. Recall that we previously found that AWESOME received lower average reward in self-play than non-self-play runs (§ 5.5). Now we can conclude that this failure to achieve high rewards was not due to a failure to reach equilibrium. An interesting modification of the AWESOME algorithm would be to use its self-play machinery to converge to stable strategies that are not stage-game Nash equilibria, such as the socially-optimal\n7 The original paper, Conitzer and Sandholm (2007), left the method of picking the ‘special’ equilibrium unspecified.\n34\noutcome or the Stackelberg game equilibrium. The aim of this adjustment would be to improve selfplay reward results while maintaining AWESOME’s resistance to exploitation by other algorithms.\n6.3.1. Links Between Nash Equilibrium Convergence and Reward Much work in the literature has aimed at MAL algorithms that converge to a stage-game Nash equilibrium. However, if the goal is high average reward, is such convergence desirable? More generally, is proximity to stage-game Nash equilibrium correlated with obtaining high reward?\nOBSERVATION 11. Strategic proximity to stage-game Nash equilibrium was correlated with average reward for all algorithms and most algorithm–generator pairs.\nFor all algorithms, reward was negatively correlated with ℓ∞-distance to the closest Nash equilibrium (Spearman’s rank correlation test; α = 0.05). Furthermore, most algorithms were negatively correlated even on a per-generator basis (Figure 25). The most notable exceptions were D6, D12, and (especially) D10, where we saw positive correlations between distance and reward."
    }, {
      "heading" : "6.4. MAXMIN DISTANCE",
      "text" : "An agent’s maxmin value is the largest amount that it can guarantee itself regardless of its opponent’s behavior. Thus, achieving average reward of at least this amount is widely seen as a necessary condition for sensible MAL behavior. Furthermore, the famous Folk Theorem of game theory demonstrates that enforceable payoffs (those with non-negative maxmin distances) are precisely those payoffs that can be achieved in equilibrium of an infinitely repeated game. We build on\n35\nour results here to investigate this notion of convergence in §6.5. In this section we consider the difference between average reward and the maxmin value of the underlying game instance:\nMaxminDistance(~ri) =\n∑T t=1 r (t) i\nT − max σi∈ ∏ Ai min σ−i∈ ∏ A−i u(ai, a−i). (6)\nWe call this difference maxmin distance, noting that it can be negative.\nOBSERVATION 12. Q-Learning attained an enforceable payoff more frequently than any other algorithm.\nQ-Learningmost frequently attained an enforceable payoff, with a negative maxmin distance in only 1.8% of its runs (Figure 26 and Figure 27). As can be seen in Figure 28, the runs on which Q-learning failed to attain an enforceable payoff mostly came from either D4 (Dispersion Game; 37.6% of Q-learning’s unenforceable runs) or D13 (Two by Two Game; 33.3%). They also occurred predominantly against random (29% of the unenforceable runs), minimax-Q (17.3%) and minimax-Q-IDR (16.0%). The next-best algorithm, AWESOME, attained enforceable payoffs considerably less often, with a negative maxmin distance in 7.4% of its runs.\nAfter random, Minimax-Q and minimax-Q-IDR were the least likely to attain enforceable payoffs, failing to do so in 28.9% and 27.7% of their runs respectively. This is interesting because these algorithms explicitly attempt to do well against adversarial opponents. One possible explanation is that they may have trouble learning accurate payoffs , leading them to have difficulty obtaining their maxmin values.\nMinimax-Q and minimax-Q-IDRwere especially poor in self play, where conservative play can impair payoff learning. There is also a greater proportion of enforceable runs on 2 × 2 games (75.2%) than on 10 × 10 games (68.5%)—larger games have more payoffs to learn. Working on a more sophisticated exploration scheme looks like an especially promising place to improve our implementation of minimax-Q and its variant.\n36\nWhile Q-learningwas successful against a broad range of opponents, some other algorithms were less consistent. For example, meta was quite good against all opponents except for fictitious play, determined, AWESOME and itself. Meta was especially bad against fictitious play; in this pairing only 68.0% of meta’s runs were enforceable. Compare this to meta’s excellent performance against Q-learning, where it attained enforceable payoffs in 97.7% of it runs. Fictitious play also had trouble playing against meta, determined and itself. On the other hand, neither AWESOME nor determined shared this problem.\nRVσ(t) had problems attaining enforceable runs too, and although it received payoffs well above the maxmin value frequently (it had the second highest proportion of runs with strictly positive distances at 68.8%) there were also a large number of instances where RVσ(t)’s maxmin distance was close to, but below zero. This contrasts with GIGA-WoLF, which had fewer non-enforceable runs with greater negative minimax distance (see Figure 29). We conjecture that this phenomenon occurred because RVσ(t) maintains a small amount of probability mass on all of its actions, causing it to ‘tremble’. More specifically, RVσ(t), like all gradient algorithms, updates its mixed strategy by moving along the reward gradient. When the updated vector does not sum to one, it must be mapped back to the probability simplex. RVσ(t) does this by normalizing the updated vector, while GSA and GIGA-WoLF use a retraction operator that tends to drop actions from the mixed strategy’s support (see § 2.5). We conjecture that modifying RVσ(t) to use GIGA-WoLF’s retraction operator would improve RVσ(t)’s ability to achieve enforceable payoffs.\n6.4.1. Links Between Maxmin Distance and Reward Is there a connection between enforceable runs and high average rewards? It would be strange if some such relationship did not exist, since enforceability implies reward higher than the maxmin value. Indeed, we did observe that for all algorithms, maxmin distance was positively correlated with average reward. (Spearman’s rank correlation test (§4.3); α = 0.05 significance level). On a per-generator basis, we again largely observed significant positive correlations. There were two\n37\ndeviations from this pattern. First, we found no significant correlation for half of the algorithms on D11, and for minimax-Q on D3. Second, there was a significant negative correlation for minimax-Q on D11, though minimax-Q-IDR still exhibited significant positive correlation."
    }, {
      "heading" : "6.5. CONVERGENCE TO REPEATED-GAME NASH EQUILIBRIUM",
      "text" : "In §6.3 we considered algorithms’ tendencies to converge to equilibria of the stage game. The algorithms actually played a repeated game, however. We now turn to analyzing this repeated game’s properties. The payoff profiles achievable in Nash equilibrium of a repeated game are precisely the enforceable profiles (see, e.g., Osborne and Rubinstein (1994)). In order to determine whether a given strategy profile is an equilibrium of a repeated game, it is also necessary to consider how these strategies behave off the equilibrium path (e.g., how they punish deviations by the other agent). While the algorithms that we studied lack punishment mechanisms, it is still meaningful to assess how frequently they converged to payoff profiles consistent with repeated game Nash equilibria. We therefore build on the results from § 6.4, asking how often both algorithms achieved enforceable payoffs.\nOBSERVATION 13. Q-Learning was involved in matches whose payoff profiles were consistent with a repeated game Nash equilibrium more often than any other algorithm.\nOf the algorithms that we examined, Q-learningmost frequently had runs that were consistent with a repeated game Nash equilibrium (Figure 30). It was consistent with a repeated game equilibrium in 76.8% of its runs. Determined and AWESOME were the next most frequently consistent (75.0% and 73.8% of their runs respectively). Overall, consistency with a repeated game Nash equilibrium was common, but not universal. It is worth emphasizing that an enforceable payoff profile depends on both agents’ actions, and so the behavior of weak agents like random lowered the scores for stronger opponents."
    }, {
      "heading" : "7. Discussion and Conclusion",
      "text" : "In this article we described MALT, a standardized testbed for multiagent experimentation. This testbed allows researchers to focus on experimental design and analysis instead of implementation. We also presented an in-depth analysis of a large experiment we conducted ourselves using MALT.\nThe most striking conclusion from our experiment was that Q-learning achieved consistently excellent results, in many senses outperforming algorithms based on deeper insights about the multiagent setting (e.g., GIGA-WoLF, AWESOME, and meta). We were surprised by this finding, since we had taken for granted the idea that modern, multiagent algorithms would do better in a repeated-game environment than a classical, single-agent algorithm. The evidence we have shown to the contrary suggests that it should be possible to considerably improve the empirical performance of MAL algorithms. We suggest four areas in which efforts could be worthwhile.\nFirst, a more experimentally-driven focus seems crucial. Our experiment was large, but there are many empirical questions that it does not answer. Some promising future directions include:\n38\n− More examination of the relationship between performance and game properties like size; − More detailed investigation of algorithm behavior on instances from single generators; − Investigation of additional algorithms like Hyper-Q (Tesauro, 2004) and Nash-Q (Hu and Wellman, 1998); − Study of N -player repeated games and stochastic games (along the lines of Vu et al. (2005)).\nSecond, the more sophisticated algorithms have many tunable parameters. Finding optimal settings for them was beyond the scope of our paper, and we instead relied on published parameter settings. Nevertheless, it is possible that some algorithms would have performed considerably better if they had been configured differently. Indeed, Q-learning had only three parameters and all were easy to set, which might partly explain its strong performance. Tuning the other algorithms would require considerable experimental effort; hopefully MALT will be of assistance. There are some interesting questions to ask:\n− Is one parameter setting good for many problems, or is it the case that some parameter settings are effective on some matches and poor on others?\n− Which of an algorithm’s (e.g., meta’s) parameters are the most important? − Does AWESOME’s performance change radically when it selects the socially optimal Nash\nequilibrium as its special equilibrium? How about the ‘Stackelberg’ equilibrium? − For gradient algorithms, is it better to perform retraction or normalization? − Do parameter settings that yield high reward also yield low regret?\nThird, we presented two different tweaks to existing algorithms: minimax-Q-IDR and GSA. These algorithms offered several improvements over their “parent” algorithms, and in many cases probabilistically dominated them. It would be interesting to explore similar modifications of other existing algorithms.\nFinally, managing a portfolio of existing algorithms seems like a promising approach for designing algorithms with good empirical properties. AWESOME and meta can both be seen as portfolio algorithms: they switch between different components based on the opponent’s behavior. Much remains to be learned about the best framework for building portfolio algorithms, especially if we insist on frameworks that do not require hand-construction of a portfolio. Again, this direction of research invites a host of empirical questions. What features of a game and of game play should a portfolio track? In what situations does adding an algorithm to a portfolio improve performance?"
    }, {
      "heading" : "Acknowledgements",
      "text" : "Thanks to Nando de Freitas for his involvement in the early stages of this project, and for helping us to develop the argument in Appendix A. Thanks to Holger H. Hoos and Yevgeniy Vorobeychik for feedback on drafts, and to anonymous reviewers at MLJ for helpful suggestions, and to David Ludgate for help with coding. Finally, thanks to Vincent Conitzer for providing us with code for AWESOME and helping us to use it.\n39"
    }, {
      "heading" : "Appendix A. Independent vs. Stratified Sampling",
      "text" : "For all of the experiments described in this article, we were concerned with the expected performance of a match, denoted by f(µ, ζ). Here, f is some metric function, µ ∼ M is a match, and ζ ∼ Z is a random seed that completely determined any non-deterministic behavior in both algorithms. The game instance/seed pairing uniquely define a run. When designing our experiment, we needed to choose whether to stratify runs based on the match. For instance, if we had enough time to run 100 simulations, we could either have sampled a single run on 100 matches, or 10 runs on 10 matches. Stratification clearly yields more detailed data about the role that randomization plays in each match. However, for estimating common summary statistics—means and quantiles—stratification should be avoided.\nFormally, consider two schemes of sampling from M and Z . Under independent sampling, M and Z are sampled separately each time, yielding a set of samples {(M1, Z1), . . . , (Mn, Zn)}. Under stratified sampling, k samples are taken from M and for each sample of M , Z is sampled si times, yielding a set of samples {(M1, Z1,1), . . . , (M1, Z1,s1), . . . , (Mk, Zk,sk)}. In both schemes, the sample mean is used as an estimate for the population mean. Since M and Z are sampled independently, both schemes yield unbiased estimators. However, the following result shows that the schemes differ in terms of variance.\nLEMMA 7.1. Independent sampling yields a lower-variance estimate of E [ f(M,Z) ]\nthan stratified sampling.\nProof First, independent random variables have no covariance.\nCov [f(Mi, Zi), f(Mj , Zj)] = Cov [f(Mk, Zk,l), f(Mm, Zm,n)] (7)\nOn the other hand, if two samples share the same stratum (the same sample µ ∼ M ) then they have weakly higher covariance.\nCov [f(Mk, Zk,l), f(Mk, Zk,m)] ≥ Cov [f(Mi, Zi), f(Mj , Zj)] (8)\nUsing Equations (7) and (8) we can write\nV ar\n[\n∑\ni\nf(Mi, Zi)\n]\n= ∑\ni,j\nCov [f(Mi, Zi), f(Mj , Zj)]\n≤ ∑\nk,l,m,n\nCov [f(Mk, Zk,l), f(Mm, Zm,n)]\n= V ar\n\n\n∑\nk,l\nf(Mk, Zk,l)\n\n . 2\nWe also claimed that stratifying increases the variance of quantile point estimation. This result can be found (albeit without proof) in Heidelberger and Lewis (1984).\n40"
    } ],
    "references" : [ {
      "title" : "Evolutionary Tournament-Based Comparison of Learning and Non-Learning",
      "author" : [ "S. Airiau", "S. Saha", "S. Sen" ],
      "venue" : null,
      "citeRegEx" : "Airiau et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Airiau et al\\.",
      "year" : 2007
    }, {
      "title" : "Algorithms and Simulated Annealing",
      "author" : [ "B. Banerjee", "J. Peng" ],
      "venue" : "AAAI 11. Banerjee, B. and J. Peng:",
      "citeRegEx" : "Banerjee and Peng,? \\Q2004\\E",
      "shortCiteRegEx" : "Banerjee and Peng",
      "year" : 2004
    }, {
      "title" : "Rational and convergent learning in stochastic games",
      "author" : [ "M. Alberta. Bowling", "M. Veloso" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "Bowling and Veloso,? \\Q2001\\E",
      "shortCiteRegEx" : "Bowling and Veloso",
      "year" : 2001
    }, {
      "title" : "Iterative solution of games by ficticious play",
      "author" : [ "G. Brown" ],
      "venue" : null,
      "citeRegEx" : "Brown,? \\Q1951\\E",
      "shortCiteRegEx" : "Brown",
      "year" : 1951
    }, {
      "title" : "The dynamics of reinforcement learning in cooperative multiagent systems",
      "author" : [ "C. New York. Claus", "C. Boutilier" ],
      "venue" : null,
      "citeRegEx" : "Claus and Boutilier,? \\Q1997\\E",
      "shortCiteRegEx" : "Claus and Boutilier",
      "year" : 1997
    }, {
      "title" : "AWESOME: A General Multiagent Learning Algorithm that Converges",
      "author" : [ "V. Conitzer", "T. Sandholm" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2003
    }, {
      "title" : "Correlated-Q learning",
      "author" : [ "A. Greenwald", "K. Hall" ],
      "venue" : "Operations Research",
      "citeRegEx" : "Greenwald and Hall,? \\Q2003\\E",
      "shortCiteRegEx" : "Greenwald and Hall",
      "year" : 2003
    }, {
      "title" : "Nash Q-learning for general-sum stochastic games",
      "author" : [ "J. Hu", "M.P. Wellman" ],
      "venue" : "Journal of Machine Learning",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2003
    }, {
      "title" : "Markov games as a framework for multi-agent reinforcement learning",
      "author" : [ "Columbia", "Vancouver", "M. Canada. Littman" ],
      "venue" : "ICML",
      "citeRegEx" : "Columbia et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Columbia et al\\.",
      "year" : 1994
    }, {
      "title" : "A 2× 2 game without the fictitious play property",
      "author" : [ "A. Sela" ],
      "venue" : "Games and Economic Behavior",
      "citeRegEx" : "Monderer and Sela,? \\Q1996\\E",
      "shortCiteRegEx" : "Monderer and Sela",
      "year" : 1996
    }, {
      "title" : "Fictitious play property for games with identical interests",
      "author" : [ "D. Monderer", "L. Shapley" ],
      "venue" : "Journal of Economic",
      "citeRegEx" : "Monderer and Shapley,? \\Q1996\\E",
      "shortCiteRegEx" : "Monderer and Shapley",
      "year" : 1996
    }, {
      "title" : "Run the GAMUT: a comprehensive approach",
      "author" : [ "E. Nudelman", "J. Wortman", "K. Leyton-Brown", "Y. Shoham" ],
      "venue" : null,
      "citeRegEx" : "Nudelman et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Nudelman et al\\.",
      "year" : 2004
    }, {
      "title" : "evaluating game-theoretic algorithms",
      "author" : [ "M. Osborne", "A. Rubinstein" ],
      "venue" : null,
      "citeRegEx" : "Osborne and Rubinstein,? \\Q1994\\E",
      "shortCiteRegEx" : "Osborne and Rubinstein",
      "year" : 1994
    }, {
      "title" : "The 2x2 Game",
      "author" : [ "Computing", "Vienna", "A. Austria. Rapoport", "M. Guyer", "D. Gordon" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "Computing et al\\.,? \\Q1976\\E",
      "shortCiteRegEx" : "Computing et al\\.",
      "year" : 1976
    }, {
      "title" : "If multi-agent learning is the answer, what is the question?",
      "author" : [ "Y. Press. Shoham", "R. Powers", "T. Grenager" ],
      "venue" : null,
      "citeRegEx" : "Shoham et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Shoham et al\\.",
      "year" : 2007
    }, {
      "title" : "Nash convergence of gradient dynamics in general-sum games",
      "author" : [ "S. Singh", "M. Kearns", "Y. Mansour" ],
      "venue" : null,
      "citeRegEx" : "Singh et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Singh et al\\.",
      "year" : 2000
    }, {
      "title" : "Introduction to Stochastic Search and Optimization: Estimation, Simulation and Control",
      "author" : [ "J.C. Spall" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2003
    }, {
      "title" : "Reinforcement Learning, An Introduction",
      "author" : [ "New Jersey: John Wiley", "R. Sons. Sutton", "A. Barto" ],
      "venue" : "Machine Learning",
      "citeRegEx" : "Wiley et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Wiley et al\\.",
      "year" : 1999
    }, {
      "title" : "Online convex programming and generalized infinitesimal gradient ascent",
      "author" : [ "M. Zinkevich" ],
      "venue" : null,
      "citeRegEx" : "Zinkevich,? \\Q2003\\E",
      "shortCiteRegEx" : "Zinkevich",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "Some prominent examples include algorithms by Littman (1994), Singh et al. (2000), Hu and Wellman (2003), Greenwald and Hall (2003), Bowling (2004a), Powers and Shoham (2005), Banerjee and Peng (2006), and Conitzer and Sandholm (2007).",
      "startOffset" : 58,
      "endOffset" : 82
    }, {
      "referenceID" : 4,
      "context" : "Some prominent examples include algorithms by Littman (1994), Singh et al. (2000), Hu and Wellman (2003), Greenwald and Hall (2003), Bowling (2004a), Powers and Shoham (2005), Banerjee and Peng (2006), and Conitzer and Sandholm (2007).",
      "startOffset" : 58,
      "endOffset" : 105
    }, {
      "referenceID" : 4,
      "context" : "Some prominent examples include algorithms by Littman (1994), Singh et al. (2000), Hu and Wellman (2003), Greenwald and Hall (2003), Bowling (2004a), Powers and Shoham (2005), Banerjee and Peng (2006), and Conitzer and Sandholm (2007).",
      "startOffset" : 58,
      "endOffset" : 132
    }, {
      "referenceID" : 4,
      "context" : "Some prominent examples include algorithms by Littman (1994), Singh et al. (2000), Hu and Wellman (2003), Greenwald and Hall (2003), Bowling (2004a), Powers and Shoham (2005), Banerjee and Peng (2006), and Conitzer and Sandholm (2007).",
      "startOffset" : 58,
      "endOffset" : 149
    }, {
      "referenceID" : 4,
      "context" : "Some prominent examples include algorithms by Littman (1994), Singh et al. (2000), Hu and Wellman (2003), Greenwald and Hall (2003), Bowling (2004a), Powers and Shoham (2005), Banerjee and Peng (2006), and Conitzer and Sandholm (2007).",
      "startOffset" : 58,
      "endOffset" : 175
    }, {
      "referenceID" : 1,
      "context" : "(2000), Hu and Wellman (2003), Greenwald and Hall (2003), Bowling (2004a), Powers and Shoham (2005), Banerjee and Peng (2006), and Conitzer and Sandholm (2007).",
      "startOffset" : 101,
      "endOffset" : 126
    }, {
      "referenceID" : 1,
      "context" : "(2000), Hu and Wellman (2003), Greenwald and Hall (2003), Bowling (2004a), Powers and Shoham (2005), Banerjee and Peng (2006), and Conitzer and Sandholm (2007). We take the position that the best multiagent learning (MAL) algorithm is the one that achieves the highest possible average reward.",
      "startOffset" : 101,
      "endOffset" : 160
    }, {
      "referenceID" : 1,
      "context" : "(2000), Hu and Wellman (2003), Greenwald and Hall (2003), Bowling (2004a), Powers and Shoham (2005), Banerjee and Peng (2006), and Conitzer and Sandholm (2007). We take the position that the best multiagent learning (MAL) algorithm is the one that achieves the highest possible average reward.1 Under this view, the problem faced by the designer of a MAL algorithm is qualitatively the same as the problem faced by the designer of a single-agent reinforcement learning algorithm. However, there is a fundamental difference between the two settings. In the stationary environment faced by classical reinforcement learners, the concept of an optimal policy is well defined, and hence learning algorithms can attempt to identify this policy. In a multiagent environment, the best policy to follow depends on the actions taken by the opponent, and thus on the ways in which the opponent’s future behavior will be affected by the learner’s 1 For alternatives, see Shoham et al. (2007)—who called the approach that we espouse the “prescriptive, noncooperative agenda”—or Sandholm (2007).",
      "startOffset" : 101,
      "endOffset" : 980
    }, {
      "referenceID" : 1,
      "context" : "(2000), Hu and Wellman (2003), Greenwald and Hall (2003), Bowling (2004a), Powers and Shoham (2005), Banerjee and Peng (2006), and Conitzer and Sandholm (2007). We take the position that the best multiagent learning (MAL) algorithm is the one that achieves the highest possible average reward.1 Under this view, the problem faced by the designer of a MAL algorithm is qualitatively the same as the problem faced by the designer of a single-agent reinforcement learning algorithm. However, there is a fundamental difference between the two settings. In the stationary environment faced by classical reinforcement learners, the concept of an optimal policy is well defined, and hence learning algorithms can attempt to identify this policy. In a multiagent environment, the best policy to follow depends on the actions taken by the opponent, and thus on the ways in which the opponent’s future behavior will be affected by the learner’s 1 For alternatives, see Shoham et al. (2007)—who called the approach that we espouse the “prescriptive, noncooperative agenda”—or Sandholm (2007).",
      "startOffset" : 101,
      "endOffset" : 1081
    }, {
      "referenceID" : 11,
      "context" : ", (Nudelman et al., 2004; Powers and Shoham, 2005)).",
      "startOffset" : 2,
      "endOffset" : 50
    }, {
      "referenceID" : 15,
      "context" : ") on two-action games (Singh et al., 2000) or constant-sum games (Littman, 1994).",
      "startOffset" : 22,
      "endOffset" : 42
    }, {
      "referenceID" : 4,
      "context" : ", 2000) or constant-sum games (Littman, 1994). We also mention as an aside that MAL experiments have been conducted in settings that are neither generalizations nor restrictions of our setting, such as the population-based work by Axelrod (1987) and Airiau et al.",
      "startOffset" : 43,
      "endOffset" : 246
    }, {
      "referenceID" : 0,
      "context" : "We also mention as an aside that MAL experiments have been conducted in settings that are neither generalizations nor restrictions of our setting, such as the population-based work by Axelrod (1987) and Airiau et al. (2007).",
      "startOffset" : 203,
      "endOffset" : 224
    }, {
      "referenceID" : 3,
      "context" : "Fictitious play (Brown, 1951) is probably the earliest example of a learning algorithm for two-player games repeated games.",
      "startOffset" : 16,
      "endOffset" : 29
    }, {
      "referenceID" : 3,
      "context" : "Fictitious play (Brown, 1951) is probably the earliest example of a learning algorithm for two-player games repeated games. Essentially, fictitious play assumes that the opponent is playing an unknown and potentially mixed stationary strategy, and tries to estimate this strategy from the opponent’s empirical distribution of actions—the frequency counts for each of its actions normalized to be probabilities. Clearly, in order to collect the frequency counts fictitious playmust be able to observe the opponent’s actions. The algorithm then, at each iteration, best responds to this estimated strategy. Because fictitious play needs to calculate a best response, it also assumes complete knowledge of its own payoffs. Fictitious play is guaranteed to converge to a Nash equilibrium in self play for a restricted set of games. These games are said to have the fictitious play property (see, for instance Monderer and Shapley (1996); for an example of a simple 2 × 2 game without this property see Monderer and Sela (1996)).",
      "startOffset" : 17,
      "endOffset" : 933
    }, {
      "referenceID" : 3,
      "context" : "Fictitious play (Brown, 1951) is probably the earliest example of a learning algorithm for two-player games repeated games. Essentially, fictitious play assumes that the opponent is playing an unknown and potentially mixed stationary strategy, and tries to estimate this strategy from the opponent’s empirical distribution of actions—the frequency counts for each of its actions normalized to be probabilities. Clearly, in order to collect the frequency counts fictitious playmust be able to observe the opponent’s actions. The algorithm then, at each iteration, best responds to this estimated strategy. Because fictitious play needs to calculate a best response, it also assumes complete knowledge of its own payoffs. Fictitious play is guaranteed to converge to a Nash equilibrium in self play for a restricted set of games. These games are said to have the fictitious play property (see, for instance Monderer and Shapley (1996); for an example of a simple 2 × 2 game without this property see Monderer and Sela (1996)).",
      "startOffset" : 17,
      "endOffset" : 1023
    }, {
      "referenceID" : 6,
      "context" : "Correlated-Q (Greenwald and Hall, 2003) does",
      "startOffset" : 13,
      "endOffset" : 39
    }, {
      "referenceID" : 15,
      "context" : "GIGA-WoLF is the latest algorithm in a line of gradient learners that started with IGA (Singh et al., 2000).",
      "startOffset" : 87,
      "endOffset" : 107
    }, {
      "referenceID" : 18,
      "context" : "1) and strategic convergence to a Nash equilibrium when playing against GIGA (Zinkevich, 2003) in two-player two-action games.",
      "startOffset" : 77,
      "endOffset" : 94
    }, {
      "referenceID" : 1,
      "context" : "RVσ(t) (Banerjee and Peng, 2006) belongs to a second line of gradient algorithms that started with ReDVaLeR (Banerjee and Peng, 2004).",
      "startOffset" : 108,
      "endOffset" : 133
    }, {
      "referenceID" : 3,
      "context" : "Littman (1994) 6 1 1 3 1× 10 Claus and Boutilier (1997) 2 3 1 - 100 1 - 100 50-2500 Greenwald and Hall (2003) 7 5 1 2500 - 3333 1× 10 Bowling (2004b) 2 6 1 ? 1× 10 Nudelman et al.",
      "startOffset" : 29,
      "endOffset" : 56
    }, {
      "referenceID" : 3,
      "context" : "Littman (1994) 6 1 1 3 1× 10 Claus and Boutilier (1997) 2 3 1 - 100 1 - 100 50-2500 Greenwald and Hall (2003) 7 5 1 2500 - 3333 1× 10 Bowling (2004b) 2 6 1 ? 1× 10 Nudelman et al.",
      "startOffset" : 29,
      "endOffset" : 110
    }, {
      "referenceID" : 3,
      "context" : "Littman (1994) 6 1 1 3 1× 10 Claus and Boutilier (1997) 2 3 1 - 100 1 - 100 50-2500 Greenwald and Hall (2003) 7 5 1 2500 - 3333 1× 10 Bowling (2004b) 2 6 1 ? 1× 10 Nudelman et al.",
      "startOffset" : 29,
      "endOffset" : 150
    }, {
      "referenceID" : 3,
      "context" : "Littman (1994) 6 1 1 3 1× 10 Claus and Boutilier (1997) 2 3 1 - 100 1 - 100 50-2500 Greenwald and Hall (2003) 7 5 1 2500 - 3333 1× 10 Bowling (2004b) 2 6 1 ? 1× 10 Nudelman et al. (2004) 3 13 100 10 1× 10 Powers and Shoham (2005) 11 21 ? ? 2× 10 Banerjee and Peng (2006) 2 1 1 1 16000 Conitzer and Sandholm (2007) 3 2 1 1 2500",
      "startOffset" : 29,
      "endOffset" : 187
    }, {
      "referenceID" : 3,
      "context" : "Littman (1994) 6 1 1 3 1× 10 Claus and Boutilier (1997) 2 3 1 - 100 1 - 100 50-2500 Greenwald and Hall (2003) 7 5 1 2500 - 3333 1× 10 Bowling (2004b) 2 6 1 ? 1× 10 Nudelman et al. (2004) 3 13 100 10 1× 10 Powers and Shoham (2005) 11 21 ? ? 2× 10 Banerjee and Peng (2006) 2 1 1 1 16000 Conitzer and Sandholm (2007) 3 2 1 1 2500",
      "startOffset" : 29,
      "endOffset" : 230
    }, {
      "referenceID" : 1,
      "context" : "(2004) 3 13 100 10 1× 10 Powers and Shoham (2005) 11 21 ? ? 2× 10 Banerjee and Peng (2006) 2 1 1 1 16000 Conitzer and Sandholm (2007) 3 2 1 1 2500",
      "startOffset" : 66,
      "endOffset" : 91
    }, {
      "referenceID" : 1,
      "context" : "(2004) 3 13 100 10 1× 10 Powers and Shoham (2005) 11 21 ? ? 2× 10 Banerjee and Peng (2006) 2 1 1 1 16000 Conitzer and Sandholm (2007) 3 2 1 1 2500",
      "startOffset" : 66,
      "endOffset" : 134
    }, {
      "referenceID" : 4,
      "context" : "While four of the eleven algorithms tested in this study were simple stationary-strategy baselines, the remaining seven were MAL algorithms including Hyper-Q (Tesauro, 2004), WoLF-PHC (Bowling and Veloso, 2002), and a joint action learner (Claus and Boutilier, 1997).",
      "startOffset" : 239,
      "endOffset" : 266
    }, {
      "referenceID" : 3,
      "context" : "For example, in Littman (1994) two versions of minimax-Q and two versions of Q-learning were tested, with each version differing only in its training regime. In Greenwald and Hall (2003), four versions of Correlated-Qwere tested against Q-learning and Friend-Q and Foe-Q (Littman, 2001).",
      "startOffset" : 28,
      "endOffset" : 187
    }, {
      "referenceID" : 3,
      "context" : "For example, in Littman (1994) two versions of minimax-Q and two versions of Q-learning were tested, with each version differing only in its training regime. In Greenwald and Hall (2003), four versions of Correlated-Qwere tested against Q-learning and Friend-Q and Foe-Q (Littman, 2001). Foe-Q is the same as minimax-Q. To our knowledge, the experiment that considered the greatest variety of algorithms was Powers and Shoham (2005). While four of the eleven algorithms tested in this study were simple stationary-strategy baselines, the remaining seven were MAL algorithms including Hyper-Q (Tesauro, 2004), WoLF-PHC (Bowling and Veloso, 2002), and a joint action learner (Claus and Boutilier, 1997).",
      "startOffset" : 28,
      "endOffset" : 433
    }, {
      "referenceID" : 11,
      "context" : "However with the creation of GAMUT (Nudelman et al., 2004), a suite of game generators, generating large game sets is now easy.",
      "startOffset" : 35,
      "endOffset" : 58
    }, {
      "referenceID" : 2,
      "context" : "(2004) also performed one of the largest previous MAL experiments, using three MAL algorithms (minimax-Q, WoLF (Bowling and Veloso, 2001), and Q-learning) on 100 game instances from each of thirteen distributions.",
      "startOffset" : 111,
      "endOffset" : 137
    }, {
      "referenceID" : 4,
      "context" : "Finally, previous experiments have differed substantially in the number of iterations considered, ranging from 50 (Claus and Boutilier, 1997) to 1 × 106 (Bowling, 2004b).",
      "startOffset" : 114,
      "endOffset" : 141
    }, {
      "referenceID" : 1,
      "context" : "For example, Banerjee and Peng (2006) used only a single 3 × 3 action “simple coordination game” and Littman (1994) probed algorithm behavior with a single grid-world version of soccer.",
      "startOffset" : 13,
      "endOffset" : 38
    }, {
      "referenceID" : 1,
      "context" : "For example, Banerjee and Peng (2006) used only a single 3 × 3 action “simple coordination game” and Littman (1994) probed algorithm behavior with a single grid-world version of soccer.",
      "startOffset" : 13,
      "endOffset" : 116
    }, {
      "referenceID" : 1,
      "context" : "For example, Banerjee and Peng (2006) used only a single 3 × 3 action “simple coordination game” and Littman (1994) probed algorithm behavior with a single grid-world version of soccer. Initially, this limitation was partly due to the difficulty of creating a large number of diverse game instances. However with the creation of GAMUT (Nudelman et al., 2004), a suite of game generators, generating large game sets is now easy. Indeed, Nudelman et al. (2004) also performed one of the largest previous MAL experiments, using three MAL algorithms (minimax-Q, WoLF (Bowling and Veloso, 2001), and Q-learning) on 100 game instances from each of thirteen distributions.",
      "startOffset" : 13,
      "endOffset" : 459
    }, {
      "referenceID" : 1,
      "context" : "For example, Banerjee and Peng (2006) used only a single 3 × 3 action “simple coordination game” and Littman (1994) probed algorithm behavior with a single grid-world version of soccer. Initially, this limitation was partly due to the difficulty of creating a large number of diverse game instances. However with the creation of GAMUT (Nudelman et al., 2004), a suite of game generators, generating large game sets is now easy. Indeed, Nudelman et al. (2004) also performed one of the largest previous MAL experiments, using three MAL algorithms (minimax-Q, WoLF (Bowling and Veloso, 2001), and Q-learning) on 100 game instances from each of thirteen distributions. Some recent papers have also leveraged GAMUT, such as Powers and Shoham (2005). Finally, previous experiments have differed substantially in the number of iterations considered, ranging from 50 (Claus and Boutilier, 1997) to 1 × 106 (Bowling, 2004b).",
      "startOffset" : 13,
      "endOffset" : 745
    }, {
      "referenceID" : 1,
      "context" : "For example, Banerjee and Peng (2006) used only a single 3 × 3 action “simple coordination game” and Littman (1994) probed algorithm behavior with a single grid-world version of soccer. Initially, this limitation was partly due to the difficulty of creating a large number of diverse game instances. However with the creation of GAMUT (Nudelman et al., 2004), a suite of game generators, generating large game sets is now easy. Indeed, Nudelman et al. (2004) also performed one of the largest previous MAL experiments, using three MAL algorithms (minimax-Q, WoLF (Bowling and Veloso, 2001), and Q-learning) on 100 game instances from each of thirteen distributions. Some recent papers have also leveraged GAMUT, such as Powers and Shoham (2005). Finally, previous experiments have differed substantially in the number of iterations considered, ranging from 50 (Claus and Boutilier, 1997) to 1 × 106 (Bowling, 2004b). Iterations in a repeated game are typically divided into “settling in” (also called a “burn-in” period) and “recording” phases, allowing the algorithms time to converge to stable behavior before results are recorded. Powers and Shoham (2005) recorded the final 20 000 of 200 000 iterations and Nudelman et al.",
      "startOffset" : 13,
      "endOffset" : 1159
    }, {
      "referenceID" : 1,
      "context" : "For example, Banerjee and Peng (2006) used only a single 3 × 3 action “simple coordination game” and Littman (1994) probed algorithm behavior with a single grid-world version of soccer. Initially, this limitation was partly due to the difficulty of creating a large number of diverse game instances. However with the creation of GAMUT (Nudelman et al., 2004), a suite of game generators, generating large game sets is now easy. Indeed, Nudelman et al. (2004) also performed one of the largest previous MAL experiments, using three MAL algorithms (minimax-Q, WoLF (Bowling and Veloso, 2001), and Q-learning) on 100 game instances from each of thirteen distributions. Some recent papers have also leveraged GAMUT, such as Powers and Shoham (2005). Finally, previous experiments have differed substantially in the number of iterations considered, ranging from 50 (Claus and Boutilier, 1997) to 1 × 106 (Bowling, 2004b). Iterations in a repeated game are typically divided into “settling in” (also called a “burn-in” period) and “recording” phases, allowing the algorithms time to converge to stable behavior before results are recorded. Powers and Shoham (2005) recorded the final 20 000 of 200 000 iterations and Nudelman et al. (2004) used the final 10 000 of 100 000 iterations.",
      "startOffset" : 13,
      "endOffset" : 1234
    }, {
      "referenceID" : 5,
      "context" : "4. Meta Meta is implemented according to the pseudo-code in Powers and Shoham (2005). The Powers and Shoham (2005) implementation of meta used a distance measure based on the Hoeffding Inequality, even though the pseudo-code called for using an l2 norm.",
      "startOffset" : 0,
      "endOffset" : 85
    }, {
      "referenceID" : 5,
      "context" : "4. Meta Meta is implemented according to the pseudo-code in Powers and Shoham (2005). The Powers and Shoham (2005) implementation of meta used a distance measure based on the Hoeffding Inequality, even though the pseudo-code called for using an l2 norm.",
      "startOffset" : 0,
      "endOffset" : 115
    }, {
      "referenceID" : 5,
      "context" : "Gradient Algorithms Our implementation of GIGA-WoLF follows the original pseudo-code and uses the learning rate and step size schedules from the original experiments by Bowling (2004a) as defaults; see Table VI. We note, however, that these step sizes were set for drawing smooth trajectories and may not necessarily yield strong performance, and furthermore that the original experiments for GIGA-WoLF involved more iterations than we simulated (106 as compared to 105). For GIGA-WoLF’s retraction map operation (the function that maps an arbitrary vector in R to the closest probability vector in terms of l2 distance) we used an algorithm based on the method described in Govindan and Wilson (2003). GIGA-WoLF has two variants: in one it assumes that it can counterfactually determine the reward for playing an arbitrary action in the previous iteration, and in the other it only knows the reward for the the action that it played and has to approximate the rewards for the other actions.",
      "startOffset" : 181,
      "endOffset" : 702
    }, {
      "referenceID" : 1,
      "context" : "RVσ(t) is a implementation of the algorithm given in Banerjee and Peng (2006). Some initial experiments showed that the settings of the algorithm used in the paper performed very poorly, and so we used some hand-picked parameter settings that were more aggressive and seemed to perform better.",
      "startOffset" : 53,
      "endOffset" : 78
    }, {
      "referenceID" : 3,
      "context" : "14 (see, for example, Shoham and Leyton-Brown (2008)).",
      "startOffset" : 40,
      "endOffset" : 53
    }, {
      "referenceID" : 3,
      "context" : "14 (see, for example, Shoham and Leyton-Brown (2008)). We also considered a variant of minimax-Q in which iterative domination removal (IDR) is used as a preprocessing step. To our knowledge, we were the first to propose this algorithm in Lipson (2005); we dubbed it minimax-Q-IDR.",
      "startOffset" : 40,
      "endOffset" : 253
    }, {
      "referenceID" : 3,
      "context" : "14 (see, for example, Shoham and Leyton-Brown (2008)). We also considered a variant of minimax-Q in which iterative domination removal (IDR) is used as a preprocessing step. To our knowledge, we were the first to propose this algorithm in Lipson (2005); we dubbed it minimax-Q-IDR. In each step of the iterative IDR algorithm mixed-strategy domination is checked using a linear program (see, for example, Shoham and Leyton-Brown (2008)).",
      "startOffset" : 40,
      "endOffset" : 436
    }, {
      "referenceID" : 5,
      "context" : "AWESOME converged in 54.3% of its runs, and determined converged in 53.1% of its runs. Determined was better than AWESOME at converging to a Pareto-optimal Nash equilibrium (a Nash equilibrium that was not Pareto-dominated by any other Nash equilibrium). AWESOMEmost frequently converged to a Pareto-dominated equilibrium. This was likely influenced by the way that our implementation of AWESOME picked its ‘special’ equilibrium:7 the first equilibrium found by the Lemke-Howson algorithm, without attention to whether it was, e.g., Pareto-dominated. AWESOME also tended to attain lower reward when it converged to a Pareto-dominated Nash equilibrium than when it did not converge or converged to a non-dominated Nash equilibrium. Figure 24 shows the extent to which each algorithm converged to a stage-game Nash equilibrium in self play. Notice how often determined converged: this indicates that the games we studied often possessed one Nash equilibrium that was the best for both agents. Indeed, we can see that a surprisingly high number of games had a unique stage-game Nash equilibrium (58.5%). We expect that convergence results would look qualitatively different with generators that were much less likely to produce games with unique equilibria. Observe that AWESOME nearly always converged. Recall that we previously found that AWESOME received lower average reward in self-play than non-self-play runs (§ 5.5). Now we can conclude that this failure to achieve high rewards was not due to a failure to reach equilibrium. An interesting modification of the AWESOME algorithm would be to use its self-play machinery to converge to stable strategies that are not stage-game Nash equilibria, such as the socially-optimal 7 The original paper, Conitzer and Sandholm (2007), left the method of picking the ‘special’ equilibrium unspecified.",
      "startOffset" : 22,
      "endOffset" : 1778
    }, {
      "referenceID" : 11,
      "context" : ", Osborne and Rubinstein (1994)).",
      "startOffset" : 2,
      "endOffset" : 32
    }, {
      "referenceID" : 5,
      "context" : "38 − More examination of the relationship between performance and game properties like size; − More detailed investigation of algorithm behavior on instances from single generators; − Investigation of additional algorithms like Hyper-Q (Tesauro, 2004) and Nash-Q (Hu and Wellman, 1998); − Study of N -player repeated games and stochastic games (along the lines of Vu et al. (2005)).",
      "startOffset" : 249,
      "endOffset" : 381
    } ],
    "year" : 2014,
    "abstractText" : "Abstract. There exist many algorithms for learning how to play repeated bimatrix games. Most of these algorithms are justified in terms of some sort of theoretical guarantee. On the other hand, little is known about the empirical performance of these algorithms. Most such claims in the literature are based on small experiments, which has hampered understanding as well as the development of new multiagent learning (MAL) algorithms. We have developed a new suite of tools for running multiagent experiments: the MultiAgent Learning Testbed (MALT). These tools are designed to facilitate larger and more comprehensive experiments by removing the need to build one-off experimental code. MALT also provides baseline implementations of many MAL algorithms, hopefully eliminating or reducing differences between algorithm implementations and increasing the reproducibility of results. Using this test suite, we ran an experiment unprecedented in size. We analyzed the results according to a variety of performance metrics including reward, maxmin distance, regret, and several notions of equilibrium convergence. We confirmed several pieces of conventional wisdom, but also discovered some surprising results. For example, we found that single-agent Q-learning outperformed many more complicated and more modern MAL algorithms.",
    "creator" : "LaTeX with hyperref package"
  }
}