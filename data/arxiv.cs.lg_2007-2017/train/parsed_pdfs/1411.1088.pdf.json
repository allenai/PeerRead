{
  "name" : "1411.1088.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Expectation-Maximization for Learning Determinantal Point Processes",
    "authors" : [ "Jennifer Gillenwater", "Alex Kulesza" ],
    "emails" : [ "jengi@cis.upenn.edu", "kulesza@umich.edu", "ebfox@stat.washington.edu", "taskar@cs.washington.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Subset selection is a core task in many real-world applications. For example, in product recommendation we typically want to choose a small set of products from a large collection; many other examples of subset selection tasks turn up in domains like document summarization [4, 5], sensor placement [6, 7], image search [3, 8], and auction revenue maximization [9], to name a few. In these applications, a good subset is often one whose individual items are all high-quality, but also all distinct. For instance, recommended products should be popular, but they should also be diverse to increase the chance that a user finds at least one of them interesting. Determinantal point processes (DPPs) offer one way to model this tradeoff; a DPP defines a distribution over all possible subsets of a ground set, and the mass it assigns to any given set is a balanced measure of that set’s quality and diversity.\nOriginally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20]. They offer attractive computational properties, including exact and efficient normalization, marginalization, conditioning, and sampling [21]. These properties arise in part from the fact that a DPP can be compactly param-\nar X\niv :1\n41 1.\n10 88\nv1 [\nst at\n.M L\neterized by an N × N positive semi-definite matrix L. Unfortunately, though, learning L from example subsets by maximizing likelihood is conjectured to be NP-hard [1, Conjecture 4.1]. While gradient ascent can be applied in an attempt to approximately optimize the likelihood objective, we show later that it requires a projection step that often produces degenerate results.\nFor this reason, in most previous work only partial learning of L has been attempted. [2] showed that the problem of learning a scalar weight for each row of L is a convex optimization problem. This amounts to learning what makes an item high-quality, but does not address the issue of what makes two items similar. [3] explored a different direction, learning weights for a linear combination of DPPs with fixed Ls. This works well in a limited setting, but requires storing a potentially large set of kernel matrices, and the final distribution is no longer a DPP, which means that many attractive computational properties are lost. [8] proposed as an alternative that one first assume L takes on a particular parametric form, and then sample from the posterior distribution over kernel parameters using Bayesian methods. This overcomes some of the disadvantages of [3]’s L-ensemble method, but does not allow for learning an unconstrained, non-parametric L.\nThe learning method we propose in this paper differs from those of prior work in that it does not assume fixed values or restrictive parameterizations forL, and exploits the eigendecomposition ofL. Many properties of a DPP can be simply characterized in terms of the eigenvalues and eigenvectors of L, and working with this decomposition allows us to develop an expectation-maximization (EM) style optimization algorithm. This algorithm negates the need for the problematic projection step that is required for naive gradient ascent to maintain positive semi-definiteness of L. As the experiments show, a projection step can sometimes lead to learning a nearly diagonal L, which fails to model the negative interactions between items. These interactions are vital, as they lead to the diversityseeking nature of a DPP. The proposed EM algorithm overcomes this failing, making it more robust to initialization and dataset changes. It is also asymptotically faster than gradient ascent."
    }, {
      "heading" : "2 Background",
      "text" : "Formally, a DPP P on a ground set of items Y = {1, . . . , N} is a probability measure on 2Y , the set of all subsets of Y . For every Y ⊆ Y we have P(Y ) ∝ det(LY ), where L is a positive semi-definite (PSD) matrix. The subscript LY ≡ [Lij ]i,j∈Y denotes the restriction of L to the entries indexed by elements of Y , and we have det(L∅) ≡ 1. Notice that the restriction to PSD matrices ensures that all principal minors of L are non-negative, so that det(LY ) ≥ 0 as required for a proper probability distribution. The normalization constant for the distribution can be computed explicitly thanks to the fact that ∑ Y det(LY ) = det(L + I), where I is the N × N identity matrix. Intuitively, we can think of a diagonal entry Lii as capturing the quality of item i, while an off-diagonal entry Lij measures the similarity between items i and j.\nAn alternative representation of a DPP is given by the marginal kernel: K = L(L + I)−1. The L-K relationship can also be written in terms of their eigendecompositons. L and K share the same eigenvectors v, and an eigenvalue λi of K corresponds to an eigenvalue λi/(1− λi) of L:\nK = N∑ j=1 λjvjv > j ⇔ L = N∑ j=1 λj 1− λj vjv > j . (1)\nClearly, if L if PSD then K is as well, and the above equations also imply that the eigenvalues of K are further restricted to be ≤ 1. K is called the marginal kernel because, for any set Y ∼ P and for every A ⊆ Y:\nP(A ⊆ Y ) = det(KA) . (2)\nWe can also write the exact (non-marginal, normalized) probability of a set Y ∼ P in terms of K:\nP(Y ) = det(LY ) det(L+ I) = |det(K − IY )| , (3)\nwhere IY is the identity matrix with entry (i, i) zeroed for items i ∈ Y [1, Equation 3.69]. In what follows we use the K-based formula for P(Y ) and learn the marginal kernel K. This is equivalent to learning L, as Equation (1) can be applied to convert from K to L."
    }, {
      "heading" : "3 Learning algorithms",
      "text" : "In our learning setting the input consists of n example subsets, {Y1, . . . , Yn}, where Yi ⊆ {1, . . . , N} for all i. Our goal is to maximize the likelihood of these example sets. We first describe in Section 3.1 a naive optimization procedure: projected gradient ascent on the entries of the marginal matrix K, which will serve as a baseline in our experiments. We then develop an EM method: Section 3.2 changes variables from kernel entries to eigenvalues and eigenvectors (introducing a hidden variable in the process), Section 3.3 applies Jensen’s inequality to lower-bound the objective, and Sections 3.4 and 3.5 outline a coordinate ascent procedure on this lower bound."
    }, {
      "heading" : "3.1 Projected gradient ascent",
      "text" : "The log-likelihood maximization problem, based on Equation (3), is:\nmax K n∑ i=1 log ( |det(K − IY i)| ) s.t. K 0, I −K 0 (4)\nwhere the first constraint ensures that K is PSD and the second puts an upper limit of 1 on its eigenvalues. Let L(K) represent this log-likelihood objective. Its partial derivative with respect to K is easy to compute by applying a standard matrix derivative rule [22, Equation 57]:\n∂L(K) ∂K = n∑ i=1 (K − IY i) −1 . (5)\nThus, projected gradient ascent [23] is a viable, simple optimization technique. Algorithm 1 outlines this method, which we refer to as K-Ascent (KA). The initial K supplied as input to the algorithm can be any PSD matrix with eigenvalues ≤ 1. The first part of the projection step, max(λ, 0), chooses the closest (in Frobenius norm) PSD matrix to Q [24, Equation 1]. The second part, min(λ, 1), caps the eigenvalues at 1. (Notice that only the eigenvalues have to be projected; K remains symmetric after the gradient step, so its eigenvectors are already guaranteed to be real.)\nUnfortunately, the projection can take us to a poor local optima. To see this, consider the case where the starting kernel K is a poor fit to the data. In this case, a large initial step size η will probably be accepted; even though such a step will likely result in the truncation of many eigenvalues at 0, the resulting matrix will still be an improvement over the poor initial K. However, with many zero eigenvalues, the new K will be near-diagonal, and, unfortunately, Equation (5) dictates that if the current K is diagonal, then its gradient is as well. Thus, the KA algorithm cannot easily move to any highly non-diagonal matrix. It is possible that employing more complex step-size selection mechanisms could alleviate this problem, but the EM algorithm we develop in the next section will negate the need for these entirely.\nThe EM algorithm we develop also has an advantage in terms of asymptotic runtime. The computational complexity of KA is dominated by the matrix inverses of the L derivative, each of which requires O(N3) operations, and by the eigendecomposition needed for the projection, also O(N3). The overall runtime of KA, assuming T1 iterations until convergence and an average of T2 iterations to find a step size, is O(T1nN3 + T1T2N3). As we will show in the following sections, the overall runtime of the EM algorithm isO(T1nNk2 +T1T2N3), which can be substantially better than KA’s runtime for k N ."
    }, {
      "heading" : "3.2 Eigendecomposing",
      "text" : "Eigendecomposition is key to many core DPP algorithms such as sampling and marginalization. This is because the eigendecomposition provides an alternative view of the DPP as a generative process, which often leads to more efficient algorithms. Specifically, sampling a set Y can be broken down into a two-step process, the first of which involves generating a hidden variable J ⊆ {1, . . . , N} that codes for a particular set of K’s eigenvectors. We review this process below, then exploit it to develop an EM optimization scheme.\nSupposeK = V ΛV > is an eigendecomposition ofK. Let V J denote the submatrix of V containing only the columns corresponding to the indices in a set J ⊆ {1, . . . , N}. Consider the corresponding\nAlgorithm 1 K-Ascent (KA) Input: K, {Y1, . . . , Yn}, c repeat G← ∂L(K)∂K (Eq. 5) η ← 1 repeat Q← K + ηG Eigendecompose Q into V,λ λ← min(max(λ, 0), 1) Q← V diag(λ)V > η ← η2\nuntil L(Q) > L(K) δ ← L(Q)− L(K) K ← Q\nuntil δ < c Output: K\nAlgorithm 2 Expectation-Maximization (EM) Input: K, {Y1, . . . , Yn}, c Eigendecompose K into V,λ repeat\nfor j = 1, . . . , N do λ′j ← 1n ∑ i pK(j ∈ J | Yi) (Eq. 19) G← ∂F (V,λ ′)\n∂V (Eq. 20) η ← 1 repeat V ′ ← V exp[η ( V >G−G>V ) ]\nη ← η2 until L(V ′,λ′) > L(V,λ′) δ ← F (V ′,λ′)− F (V,λ) λ← λ′, V ← V ′, η ← 2η\nuntil δ < c Output: K\nmarginal kernel, with all selected eigenvalues set to 1:\nKV J = ∑ j∈J vjv > j = V J(V J)> . (6)\nAny such kernel whose eigenvalues are all 1 is called an elementary DPP. According to [21, Theorem 7], a DPP with marginal kernel K is a mixture of all 2N possible elementary DPPs:\nP(Y ) = ∑\nJ⊆{1,...,N}\nPV J (Y ) ∏ j∈J λj ∏ j /∈J (1− λj) , PV J (Y ) = 1(|Y | = |J |) det(KV J Y ) . (7)\nThis perspective leads to an efficient DPP sampling algorithm, where a set J is first chosen according to its mixture weight in Equation (7), and then a simple algorithm is used to sample from PV J\n[5, Algorithm 1]. In this sense, the index set J is an intermediate hidden variable in the process for generating a sample Y .\nWe can exploit this hidden variable J to develop an EM algorithm for learning K. Re-writing the data log-likelihood to make the hidden variable explicit:\nL(K) = L(Λ, V ) = n∑ i=1 log (∑ J pK(J, Yi) ) = n∑ i=1 log (∑ J pK(Yi | J)pK(J) ) , where (8)\npK(J) = ∏ j∈J λj ∏ j /∈J (1− λj) , pK(Yi | J) =1(|Yi| = |J |) det([V J(V J)>]Yi) . (9)\nThese equations follow directly from Equations (6) and (7)."
    }, {
      "heading" : "3.3 Lower bounding the objective",
      "text" : "We now introduce an auxiliary distribution, q(J | Yi), and deploy it with Jensen’s inequality to lower-bound the likelihood objective. This is a standard technique for developing EM schemes for dealing with hidden variables [25]. Proceeding in this direction: L(V,Λ) = n∑ i=1 log (∑ J q(J | Yi) pK(J, Yi) q(J | Yi) ) ≥ n∑ i=1 ∑ J q(J | Yi) log ( pK(J, Yi) q(J | Yi) ) ≡ F (q, V,Λ) .\n(10)\nThe function F (q, V,Λ) can be expressed in either of the following two forms:\nF (q, V,Λ) = n∑ i=1 −KL(q(J | Yi) ‖ pK(J | Yi)) + L(V,Λ) (11)\n= n∑ i=1 Eq[log pK(J, Yi)] +H(q) (12)\nwhere H is entropy. Consider optimizing this new objective by coordinate ascent. From Equation (11) it is clear that, holding V,Λ constant, F is concave in q. This follows from the concavity of KL divergence. Holding q constant in Equation (12) yields the following function:\nF (V,Λ) = n∑ i=1 ∑ J q(J | Yi) [log pK(J) + log pK(Yi | J)] . (13)\nThis expression is concave in λj , since log is concave. However, it is not concave in V due to the non-convex V >V = I constraint. We describe in Section 3.5 one way to handle this.\nTo summarize, coordinate ascent on F (q, V,Λ) alternates the following “expectation” and “maximization” steps; the first is concave in q, and the second is concave in the eigenvalues:\nE-step: min q n∑ i=1 KL(q(J | Yi) ‖ pK(J | Yi)) (14)\nM-step: max V,Λ n∑ i=1 Eq[log pK(J, Yi)] s.t. 0 ≤ λ ≤ 1, V >V = I (15)"
    }, {
      "heading" : "3.4 E-step",
      "text" : "The E-step is easily solved by setting q(J | Yi) = pK(J | Yi), which minimizes the KL divergence. Interestingly, we can show that this distribution is itself a conditional DPP, and hence can be compactly described by an N ×N kernel matrix. Thus, to complete the E-step, we simply need to construct this kernel. Lemma 1 (see Appendix A for a proof) gives an explicit formula. Note that q’s probability mass is restricted to sets of a particular size k, and hence we call it a k-DPP. A k-DPP is a variant of DPP that can also be efficiently sampled from and marginalized, via modifications of the standard DPP algorithms. (See Appendix A and [3] for more on k-DPPs.) Lemma 1. At the completion of the E-step, q(J | Yi) with |Yi| = k is a k-DPP with (non-marginal) kernel QYi :\nQYi = RZYiR, and q(J | Yi) ∝ 1(|Yi| = |J |) det(QYiJ ) , where (16) U = V >, ZYi = UYi(UYi)>, and R = diag (√ λ/(1− λ) ) . (17)"
    }, {
      "heading" : "3.5 M-step",
      "text" : "The M-step update for the eigenvalues is a closed-form expression with no need for projection. Taking the derivative of Equation (13) with respect to λj , setting it equal to zero, and solving for λj :\nλj = 1\nn n∑ i=1 ∑ J:j∈J q(J | Yi) . (18)\nThe exponential-sized sum here is impractical, but we can eliminate it. Recall from Lemma 1 that q(J | Yi) is a k-DPP with kernel QYi . Thus, we can use k-DPP marginalization algorithms to efficiently compute the sum over J . More concretely, let V̂ represent the eigenvectors of QYi , with v̂r(j) indicating the jth element of the rth eigenvector. Then the marginals are:∑\nJ:j∈J q(J | Yi) = q(j ∈ J | Yi) = N∑ r=1 v̂r(j) 2 , (19)\nwhich allows us to compute the eigenvalue updates in time O(nNk2), for k = maxi |Yi|. (See Appendix B for the derivation of Equation (19) and its computational complexity.) Note that this update is self-normalizing, so explicit enforcement of the 0 ≤ λj ≤ 1 constraint is unnecessary. There is one small caveat: the QYi matrix will be infinite if any λj is exactly equal to 1 (due to R in Equation (17)). In practice, we simply tighten the constraint on λ to keep it slightly below 1.\nTurning now to the M-step update for the eigenvectors, the derivative of Equation (13) with respect to V involves an exponential-size sum over J similar to that of the eigenvalue derivative. However, the terms of the sum in this case depend on V as well as on q(J | Yi), making it hard to simplify. Yet, for the particular case of the initial gradient, where we have q = p, simplification is possible:\n∂F (V,Λ)\n∂V = n∑ i=1 2BYi(H Yi)−1VYiR 2 (20)\nwhereHYi is the |Yi|×|Yi|matrix VYiR2V >Yi and VYi = (U Yi)>. BYi is aN×|Yi|matrix containing the columns of the N × N identity corresponding to items in Yi; BYi simply serves to map the gradients with respect to VYi into the proper positions in V . This formula allows us to compute the eigenvector derivatives in time O(nNk2), where again k = maxi |Yi|. (See Appendix C for the derivation of Equation (20) and its computational complexity.)\nEquation (20) is only valid for the first gradient step, so in practice we do not bother to fully optimize V in each M-step; we simply take a single gradient step on V . Ideally we would repeatedly evaluate the M-step objective, Equation (13), with various step sizes to find the optimal one. However, the M-step objective is intractable to evaluate exactly, as it is an expectation with respect to an exponential-size distribution. In practice, we solve this issue by performing an E-step for each trial step size. That is, we update q’s distribution to match the updated V and Λ that define pK , and then determine if the current step size is good by checking for improvement in the likelihood L. There is also the issue of enforcing the non-convex constraint V >V = I . We could project V to ensure this constraint, but, as previously discussed for eigenvalues, projection steps often lead to poor local optima. Thankfully, for the particular constraint associated with V , more sophisticated update techniques exist: the constraint V >V = I corresponds to optimization over a Stiefel manifold, so the algorithm from [26, Page 326] can be employed. In practice, we simplify this algorithm by negelecting second-order information (the Hessian) and using the fact that the V in our application is full-rank. With these simplifications, the following multiplicative update is all that is needed:\nV ← V exp [ η ( V > ∂L ∂V − ( ∂L ∂V )> V )] , (21)\nwhere exp denotes the matrix exponential and η is the step size. Algorithm 2 summarizes the overall EM method. As previously mentioned, assuming T1 iterations until convergence and an average of T2 iterations to find a step size, its overall runtime is O(T1nNk2 + T1T2N3). The first term in this complexity comes from the eigenvalue updates, Equation (19), and the eigenvector derivative computation, Equation (20). The second term comes from repeatedly computing the Stiefel manifold update of V , Equation (21), during the step size search."
    }, {
      "heading" : "4 Experiments",
      "text" : "We test the proposed EM learning method (Algorithm 2) by comparing it to K-Ascent (KA, Algorithm 1)1. Both methods require a starting marginal kernel K̃. Note that neither EM nor KA can deal well with starting from a kernel with too many zeros. For example, starting from a diagonal kernel, both gradients, Equations (5) and (20), will be diagonal, resulting in no modeling of diversity. Thus, the two initialization options that we explore have non-trivial off-diagonals. The first of these options is relatively naive, while the other incorporates statistics from the data.\nFor the first initialization type, we use a Wishart distribution with N degrees of freedom and an identity covariance matrix to draw L̃ ∼ WN (N, I). The Wishart distribution is relatively unassuming: in terms of eigenvectors, it spreads its mass uniformly over all unitary matrices [27]. We make\n1Code and data for all experiments can be downloaded from https://code.google.com/p/em-for-dpps\njust one simple modification to its output to make it a better fit for practical data: we re-scale the resulting matrix by 1/N so that the corresponding DPP will place a non-trivial amount of probability mass on small sets. (The Wishart’s mean is NI , so it tends to over-emphasize larger sets unless we re-scale.) We then convert L̃ to K̃ via Equation (1).\nFor the second initialization type, we employ a form of moment matching. Letmi andmij represent the normalized frequencies of single items and pairs of items in the training data:\nmi = 1\nn n∑ `=1 1(i ∈ Y`), mij = 1 n n∑ `=1 1(i ∈ Y` ∧ j ∈ Y`) . (22)\nRecalling Equation (2), we attempt to match the first and second order moments by choosing K̃ as:\nK̃ii = mi, K̃ij =\n√ max ( K̃iiK̃jj −mij , 0 ) . (23)\nTo ensure a valid starting kernel, we then project K̃ by clipping its eigenvalues at 0 and 1."
    }, {
      "heading" : "4.1 Baby registry tests",
      "text" : "Consider a product recommendation task, where the ground set comprises N products that can be added to a particular category (e.g., toys or safety) in a baby registry. A very simple recommendation system might suggest products that are popular with other consumers; however, this does not account for negative interactions: if a consumer has already chosen a carseat, they most likely will not choose an additional carseat, no matter how popular it is with other consumers. DPPs are ideal for capturing such negative interactions. A learned DPP could be used to populate an initial, basic registry, as well as to provide live updates of product recommendations as a consumer builds their registry.\nTo test our DPP learning algorithms, we collected a dataset consisting of 29,632 baby registries from Amazon.com, filtering out those listing fewer than 5 or more than 100 products. Amazon characterizes each product in a baby registry as belonging to one of 18 categories, such as “toys” and“safety”. For each registry, we created sub-registries by splitting it according to these categories. (A registry with 5 toy items and 10 safety items produces two sub-registries.) For each category, we then filtered down to its top 100 most frequent items, and removed any product that did not occur in at least 100 sub-registries. We discarded categories with N < 25 or fewer than 2N remaining (non-empty) sub-registries for training. The resulting 13 categories have an average inventory size of N = 71 products and an average number of sub-registries n = 8,585. We used 70% of the data for training and 30% for testing. Note that categories such as “carseats” contain more diverse items than just their namesake; for instance, “carseats” also contains items such as seat back kick protectors and rear-facing baby view mirrors. See Appendix D for more dataset details and for quartile numbers for all of the experiments.\nFigure 1a shows the relative test log-likelihood differences of EM and KA when starting from a Wishart initialization. These numbers are the medians from 25 trials (draws from the Wishart). EM\nTuesday, August 5, 14\ng in an average of 3.7%, but has a much greater advantage for some categories than for others. Speculating that EM has more of an advantage when the off-diagonal components of K are truly important—when products exhibit strong negative interactions—we created a matrix M for each category with the true data marginals from Equation (22) as its entries. We then checked the value of d = 1N ||M ||F ||diag(M)||2 . This value correlates well with the relative gains for EM: the 4 categories for which EM has the largest gains (safety, furniture, carseats, and strollers) all exhibit d > 0.025, while categories such as feeding and gear have d < 0.012. Investigating further, we found that, as foreshadowed in Section 3.1, KA performs particularly poorly in the high-d setting because of its projection step—projection can result in KA learning a near-diagonal matrix.\nIf instead of the Wishart initialization we use the moments-matching initializer, this alleviates KA’s projection problem, as it provides a starting point closer to the true kernel. With this initializer, KA and EM have comparable test log-likelihoods (average EM gain of 0.4%). However, the momentsmatching initializer is not a perfect fix for the KA algorithm in all settings. For instance, consider a data-poor setting, where for each category we have only n = 2N training examples. In this case, even with the moments-matching initializer EM has a significant edge over KA, as shown in Figure 1b: EM gains an average of 4.5%, with a maximum gain of 16.5% for the safety category.\nTo give a concrete example of the advantages of EM training, Figure 2a shows a greedy approximation [28, Section 4] to the most-likely ten-item registry in the category “safety”, according to a Wishart-initialized EM model. The corresponding KA selection differs from Figure 2a in that it replaces the lens filters and the head support with two additional baby monitors: “Motorola MBP36 Remote Wireless Video Baby Monitor”, and “Summer Infant Baby Touch Digital Color Video Monitor”. It seems unlikely that many consumers would select three different brands of video monitor.\nHaving established that EM is more robust than KA, we conclude with an analysis of runtimes. Figure 2b shows the ratio of KA’s runtime to EM’s for each category. As discussed earlier, EM is asymptotically faster than KA, and we see this borne out in practice even for the moderate values of N and n that occur in our registries dataset: on average, EM is 2.1 times faster than KA."
    }, {
      "heading" : "5 Conclusion",
      "text" : "We have explored learning DPPs in a setting where the kernel K is not assumed to have fixed values or a restrictive parametric form. By exploiting K’s eigendecomposition, we were able to develop a novel EM learning algorithm. On a product recommendation task, we have shown EM to be faster and more robust than the naive approach of maximizing likelihood by projected gradient. In other applications for which modeling negative interactions between items is important, we anticipate that EM will similarly have a significant advantage."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work was supported in part by ONR Grant N00014-10-1-0746."
    }, {
      "heading" : "A Proof of Lemma 1",
      "text" : "Lemma 1 gives the exact form of q’s kernel. Before giving the proof, we briefly note that q differs slightly from the typical DPPs we have seen thus far, in its conditional nature. More precisely, for a set Yi of size k, q qualifies as a k-DPP, a DPP conditioned on sets of size k. Formally, a k-DPP with (non-marginal) kernel L assigns probability ∝ det(LY ) for |Y | = k, and probability zero for |Y | 6= k. As for regular DPPs, a k-DPP can be efficiently sampled from and marginalized, via modifications of the standard DPP algorithms. For example, the normalization constant for a k-DPP is given by the identity ∑ Y :|Y |=k det(LY ) = e N k (L), where e N k (L) represents the kth-order elementary symmetric polynomial on the eigenvalues of L [3]. [29]’s “summation algorithm” computes eNk (L) in O(Nk) time. In short k-DPPs enjoy many of the advantages of DPPs. Their identical parameterization, in terms of a single kernel, makes our E-step simple, and their normalization and marginalization properties are useful for the M-step updates.\nProof. Since the E-step is an unconstrained KL divergence minimization, we have:\nq(J | Yi) = pK(J | Yi) = pK(J, Yi)\npK(Yi) ∝ pK(J, Yi) = pK(J)pK(Yi | J) (24)\nwhere the proportionality follows because Yi is held constant in the conditional q distribution. Recalling Equation (9), notice that pK(Yi | J) can be re-expressed as follows:\npK(Yi | J) = 1(|Yi| = |J |) det([V J(V J)>]Yi) = 1(|Yi| = |J |) det([UYi(UYi)>]J) . (25)\nThis follows from the identity det(AA>) = det(A>A), for any full-rank square matrixA. The subsequent swapping of J and Yi, once V > is re-written as U , does not change the indexed submatrix.\nPlugging this back into Equation (24):\nq(J | Yi) ∝ pK(J)1(|Yi| = |J |) det([UYi(UYi)>]J) = pK(J)1(|Yi| = |J |)PU Yi (J) (26)\nwhere PU Yi represents an elementary DPP, just as in Equation (6), but over J rather than Y . Multiplying this expression by a term that is constant for all J maintains proportionality and allows us to simplify the the pK(J) term. Taking the definition of pK(J) from Equation (9):\nq(J | Yi) ∝  N∏ j=1 1 1− λj 1(|Yi| = |J |)PUYi (J)∏ j∈J λj ∏ j /∈J (1− λj) (27)\n= 1(|Yi| = |J |)PU Yi (J) ∏ j∈J λj 1− λj\n(28)\nHaving eliminated all dependence on j /∈ J , it is now possible to express q(J | Yi) as the J principal minor of a PSD kernel matrix (see QYi in the statement of the lemma). Thus, q is a k-DPP."
    }, {
      "heading" : "B M-Step eigenvalue updates",
      "text" : "We can exploit standard k-DPP marginalization formulas to efficiently compute the eigenvalue updates for EM. Specifically, the exponential-size sum over J from Equation (18) can be reduced to the computation of an eigendecomposition and several elementary symmetric polynomials on the resulting eigenvalues. Let e−jk−1(Q\nYi) be the (k − 1)-order elementary symmetric polynomial over all eigenvalues of QYi except for the jth one. Then, by direct application of [5, Equation 205], q’s singleton marginals are:\n∑ J:j∈J q(J | Yi) = q(j ∈ J | Yi) = 1 eN|Yi|(Q Yi) N∑ r=1 v̂r(j) 2λ̂re −r |Yi|−1(Q Yi) . (29)\nAs previously noted, elementary symmetric polynomials can be efficiently computed using [29]’s “summation algorithm”.\nWe can further reduce the complexity of this formula by noting that rank of the N × N matrix QYi = RZYiR is at most |Yi|. Because QYi only has |Yi| non-zero eigenvalues, it is the case that, for all r:\nλ̂re −r |Yi|−1(Q Yi) = eN|Yi|(Q Yi) . (30)\nRecalling that the eigenvectors and eigenvalues of QYi are denoted V̂ , Λ̂, the computation of the singleton marginals of q that are necessary for the M-step eigenvalue updates can be written as follows:\nq(j ∈ J | Yi) = 1\neN|Yi|(Q Yi) N∑ r=1 v̂r(j) 2λ̂re −r |Yi|−1(Q Yi) = |Yi|∑ r=1 v̂r(j) 2 . (31)\nThis simplified formula is dominated by the O(N3) cost of the eigendecompositon required to find V̂ . This cost can be further reduced, to O(Nk2), by eigendecomposing a related matrix instead of QYi . Specifically, consider the |Yi| × |Yi| matrix HYi = VYiR2V >Yi . Let Ṽ and Λ̃ be the eigenvectors and eigenvalues of HYi . This Λ̃ is identical to the non-zero eigenvalues of QYi , Λ̂, and its eigenvectors are related as follows:\nV̂ = RV >Yi Ṽ diag ( 1√ λ̃ ) . (32)\nGetting V̂ via Equation (32) is anO(N |Yi|2) operation, given the eigendecomposition ofHYi . Since this eigendecomposition is an O(|Yi|3) operation, it is dominated by the O(N |Yi|2). To compute Equation (31) for all j and requires only O(Nk) time, given V̂ . Thus, letting k = maxi |Yi|, the size of the largest example set, the overall complexity of the eigenvalue updates is O(nNk2)."
    }, {
      "heading" : "C M-Step eigenvector gradient",
      "text" : "Recall that the M-step objective is:\nF (V,Λ) = n∑ i=1 ∑ J q(J | Yi) [log pK(J) + log pK(Yi | J)] . (33)\nThe pK(J) term does not depend on the eigenvectors, so we only have to be concerned with the pK(Yi | J) term when computing the eigenvector derivatives. Recall that this term is defined as follows:\npK(Yi | J) = 1(|Yi| = |J |) det ([ V J(V J)> ] Yi ) . (34)\nApplying standard matrix derivative rules such as [22, Equation 55], the gradient of the M-step objective with respect to entry (a, b) of V is:\n∂F (V,Λ)\n∂[V ]ab = n∑ i=1 ∑ J q(J | Yi)1(a ∈ Yi ∧ b ∈ J)2[(W JYi) −1]gYi (a) · vb(Yi) (35)\nwhere W JYi = [V J(V J)T ]Yi and the subscript gYi(a) indicates the index of a in Yi. The [(W JYi) −1]gYi (a) indicates the corresponding row in W J Yi\n, and vb(Yi) is eigenvector b restricted to Yi. Based on this, we can more simply express the derivative with respect to the entire V matrix:\n∂F (V,Λ)\n∂V = n∑ i=1 ∑ J 2q(J | Yi)(Ẇ JYi) −1V̇ (36)\nwhere the V̇ = diag(1Yi)V diag(1J) is equal to V with the rows ` /∈ Y and the columns j /∈ J zeroed. Similarly, the other half of the expression represents (W JYi)\n−1 sorted such that gYi(`) = ` and expanded with zero rows for all ` /∈ Yi and zero columns for all ` /∈ Yi. The exponential-size sum over J could be approximated by drawing a sufficient number of samples from q, but in practice that proves somewhat slow. It turns out that it is possible, by exploiting the relationship between Z and V , to perform the first gradient step on V without needing to sample q.\nC.1 Exact computation of the first gradient\nRecall that ZYi is defined to be UYi(UYi)>, where U = V >. The pK(Yi | J) portion of the M-step objective, Equation (34), can be re-written in terms of ZYi :\npK(Yi | J) = 1(|Yi| = |J |) det ( ZYiJ ) . (37)\nTaking the gradient of the M-step objective with respect to ZYi :\n∂F (V,Λ) ∂ZYi = ∑ J q(J | Yi)(ZYiJ ) −1 . (38)\nPlugging in the k-DPP form of q(J | Yi) derived in the main body of the paper:\n∂F (V,Λ)\n∂ZYi =\n1\neN|Yi|(Q Yi) ∑ J:|J|=|Yi| det(QYiJ )(Z Yi J ) −1 . (39)\nRecall from the background section the identity used to normalize a k-DPP, and consider taking its derivative with respect to ZYi :∑\nJ:|J|=k\ndet(QYiJ ) = e N k (Q Yi) =⇒ derivative wrt ZYi ∑ J:|J|=k det(QYiJ )(Z Yi J ) −1 = ∂eNk (Q Yi) ∂ZYi (40)\nNote that this relationship is only true at the start of the M-step, before V (and hence Z) undergoes any gradient updates; a gradient step for V would mean that QYi , which remains fixed during the M-step, could no longer can be expressed as RZYiR. Thus, the formula we develop in this section is only valid for the first gradient step.\nPlugging Equation (40) back into Equation (39):\n∂F (V,Λ)\n∂ZYi =\n1\neN|Yi|(Q Yi)\n∂eN|Yi|(Q Yi)\n∂ZYi . (41)\nMultiplying this by the derivative of ZYi with respect to V and summing over i gives the final form of the gradient with respect to V . Thus, we can compute the value of the first gradient on V exactly in polynomial time.\nC.2 Faster computation of the first gradient\nRecall from Appendix B that the rank of the N ×N matrix QYi = RZYiR is at most |Yi| and that its non-zero eigenvalues are identical to those of the |Yi| × |Yi| matrix HYi = VYiR2V >Yi . Since the elementary symmetric polynomial eNk depends only on the eigenvalues of its argument, this means HYi can substitute for QYi in Equation (41), if we change variables back from Z to V :\n∂F (V,Λ)\n∂V = n∑ i=1\n1\neN|Yi|(H Yi)\n∂eN|Yi|(H Yi)\n∂V (42)\nwhere the i-th term in the sum is assumed to index into the Yi rows of the V derivative. Further, because H is only size |Yi| × |Yi|:\neN|Yi|(H Yi) = e |Yi| |Yi|(H Yi) = det(HYi) . (43)\nPlugging this back into Equation (42) and applying standard matrix derivative rules:\n∂F (V,Λ)\n∂V = n∑ i=1\n1\ndet(HYi)\n∂ det(HYi)\n∂V = n∑ i=1 2(HYi)−1VYiR 2 . (44)\nThus, the initial M-step derivative with respect to V can be more efficiently computed via the above equation. Specifically, the matrix HYi can be computed in time O(N |Yi|2), since R is a diagonal matrix. It can be inverted in time O(|Yi|3), which is dominated by O(N |Yi|2). Thus, letting k = maxi |Yi|, the size of the largest example set, the overall complexity of computing the eigenvector gradient in Equation (44) is O(nNk2)."
    }, {
      "heading" : "D Baby registry details",
      "text" : "Figure 3a and Figure 3b contain details, referred to in the main body of the paper paper, about the baby registry dataset and the learning methods’ performance on it."
    } ],
    "references" : [ {
      "title" : "Learning with Determinantal Point Processes",
      "author" : [ "A. Kulesza" ],
      "venue" : "PhD thesis, University of Pennsylvania,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2012
    }, {
      "title" : "Learning Determinantal Point Processes",
      "author" : [ "A. Kulesza", "B. Taskar" ],
      "venue" : "In Conference on Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2011
    }, {
      "title" : "k-DPPs: Fixed-Size Determinantal Point Processes",
      "author" : [ "A. Kulesza", "B. Taskar" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2011
    }, {
      "title" : "Learning Mixtures of Submodular Shells with Application to Document Summarization",
      "author" : [ "H. Lin", "J. Bilmes" ],
      "venue" : "In Conference on Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2012
    }, {
      "title" : "Determinantal Point Processes for Machine Learning",
      "author" : [ "A. Kulesza", "B. Taskar" ],
      "venue" : "Foundations and Trends in Machine Learning,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2012
    }, {
      "title" : "Near-Optimal Sensor Placements in Gaussian Processes: Theory, Efficient Algorithms, and Empirical Studies",
      "author" : [ "A. Krause", "A. Singh", "C. Guestrin" ],
      "venue" : "Journal of Machine Learning Research (JMLR),",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2008
    }, {
      "title" : "Near-Optimal Non-Myopic Value of Information in Graphical Models",
      "author" : [ "A. Krause", "C. Guestrin" ],
      "venue" : "In Conference on Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2005
    }, {
      "title" : "Learning the Parameters of Determinantal Point Process Kernels",
      "author" : [ "R. Affandi", "E. Fox", "R. Adams", "B. Taskar" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2014
    }, {
      "title" : "Revenue Submodularity",
      "author" : [ "S. Dughmi", "T. Roughgarden", "M. Sundararajan" ],
      "venue" : "In Electronic Commerce,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2009
    }, {
      "title" : "The Coincidence Approach to Stochastic Point Processes",
      "author" : [ "O. Macchi" ],
      "venue" : "Advances in Applied Probability,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1975
    }, {
      "title" : "A Determinantal Point Process Latent Variable Model for Inhibition in Neural Spiking Data",
      "author" : [ "J. Snoek", "R. Zemel", "R. Adams" ],
      "venue" : "In Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2013
    }, {
      "title" : "Fast Determinantal Point Process Sampling with Application to Clustering",
      "author" : [ "B. Kang" ],
      "venue" : "In Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2013
    }, {
      "title" : "Approximate Inference in Continuous Determinantal Point Processes",
      "author" : [ "R. Affandi", "E. Fox", "B. Taskar" ],
      "venue" : "In Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2013
    }, {
      "title" : "Determinantal Clustering Process — A Nonparametric Bayesian Approach to Kernel Based Semi-Supervised Clustering",
      "author" : [ "A. Shah", "Z. Ghahramani" ],
      "venue" : "In Conference on Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2013
    }, {
      "title" : "Nyström Approximation for Large-Scale Determinantal Processes",
      "author" : [ "R. Affandi", "A. Kulesza", "E. Fox", "B. Taskar" ],
      "venue" : "In Conference on Artificial Intelligence and Statistics (AIStats),",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2013
    }, {
      "title" : "Near-Optimal MAP Inference for Determinantal Point Processes",
      "author" : [ "J. Gillenwater", "A. Kulesza", "B. Taskar" ],
      "venue" : "In Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2012
    }, {
      "title" : "Priors for Diversity in Generative Latent Variable Models",
      "author" : [ "J. Zou", "R. Adams" ],
      "venue" : "In Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2013
    }, {
      "title" : "Markov Determinantal Point Processes",
      "author" : [ "R. Affandi", "A. Kulesza", "E. Fox" ],
      "venue" : "In Conference on Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2012
    }, {
      "title" : "Discovering Diverse and Salient Threads in Document Collections",
      "author" : [ "J. Gillenwater", "A. Kulesza", "B. Taskar" ],
      "venue" : "In Empirical Methods in Natural Language Processing (EMNLP),",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2012
    }, {
      "title" : "Structured Determinantal Point Processes",
      "author" : [ "A. Kulesza", "B. Taskar" ],
      "venue" : "In Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2010
    }, {
      "title" : "Determinantal Processes and Independence",
      "author" : [ "J. Hough", "M. Krishnapur", "Y. Peres", "B. Virág" ],
      "venue" : "Probability Surveys,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2006
    }, {
      "title" : "The Matrix Cookbook",
      "author" : [ "K. Petersen", "M. Pedersen" ],
      "venue" : "Technical report, University of Denmark,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2012
    }, {
      "title" : "Constrained Minimization Methods",
      "author" : [ "E. Levitin", "B. Polyak" ],
      "venue" : "USSR Computational Mathematics and Mathematical Physics,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1966
    }, {
      "title" : "Projection Methods for Conic Feasibility Problems",
      "author" : [ "D. Henrion", "J. Malick" ],
      "venue" : "Optimization Methods and Software,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2011
    }, {
      "title" : "A New View of the EM Algorithm that Justies Incremental, Sparse and Other Variants",
      "author" : [ "R. Neal", "G. Hinton" ],
      "venue" : "Learning in Graphical Models,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1998
    }, {
      "title" : "The Geometry of Algorithms with Orthogonality Constraints",
      "author" : [ "A. Edelman", "T. Arias", "S. Smith" ],
      "venue" : "SIAM Journal on Matrix Analysis and Applications (SIMAX),",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1998
    }, {
      "title" : "Distributions of Matrix Variates and Latent Roots Derived from Normal Samples",
      "author" : [ "A. James" ],
      "venue" : "Annals of Mathematical Statistics,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 1964
    }, {
      "title" : "An Analysis of Approximations for Maximizing Submodular Set Functions I",
      "author" : [ "G. Nemhauser", "L. Wolsey", "M. Fisher" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 1978
    }, {
      "title" : "Computing Elementary Symmetric Functions and Their Derivatives: A Didactic",
      "author" : [ "F. Baker", "M. Harwell" ],
      "venue" : "Applied Psychological Measurement,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 1996
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "However, log-likelihood is non-convex in the entries of the kernel matrix, and this learning problem is conjectured to be NP-hard [1].",
      "startOffset" : 130,
      "endOffset" : 133
    }, {
      "referenceID" : 1,
      "context" : "Thus, previous work has instead focused on more restricted convex learning settings: learning only a single weight for each row of the kernel matrix [2], or learning weights for a linear combination of DPPs with fixed kernel matrices [3].",
      "startOffset" : 149,
      "endOffset" : 152
    }, {
      "referenceID" : 2,
      "context" : "Thus, previous work has instead focused on more restricted convex learning settings: learning only a single weight for each row of the kernel matrix [2], or learning weights for a linear combination of DPPs with fixed kernel matrices [3].",
      "startOffset" : 234,
      "endOffset" : 237
    }, {
      "referenceID" : 3,
      "context" : "For example, in product recommendation we typically want to choose a small set of products from a large collection; many other examples of subset selection tasks turn up in domains like document summarization [4, 5], sensor placement [6, 7], image search [3, 8], and auction revenue maximization [9], to name a few.",
      "startOffset" : 209,
      "endOffset" : 215
    }, {
      "referenceID" : 4,
      "context" : "For example, in product recommendation we typically want to choose a small set of products from a large collection; many other examples of subset selection tasks turn up in domains like document summarization [4, 5], sensor placement [6, 7], image search [3, 8], and auction revenue maximization [9], to name a few.",
      "startOffset" : 209,
      "endOffset" : 215
    }, {
      "referenceID" : 5,
      "context" : "For example, in product recommendation we typically want to choose a small set of products from a large collection; many other examples of subset selection tasks turn up in domains like document summarization [4, 5], sensor placement [6, 7], image search [3, 8], and auction revenue maximization [9], to name a few.",
      "startOffset" : 234,
      "endOffset" : 240
    }, {
      "referenceID" : 6,
      "context" : "For example, in product recommendation we typically want to choose a small set of products from a large collection; many other examples of subset selection tasks turn up in domains like document summarization [4, 5], sensor placement [6, 7], image search [3, 8], and auction revenue maximization [9], to name a few.",
      "startOffset" : 234,
      "endOffset" : 240
    }, {
      "referenceID" : 2,
      "context" : "For example, in product recommendation we typically want to choose a small set of products from a large collection; many other examples of subset selection tasks turn up in domains like document summarization [4, 5], sensor placement [6, 7], image search [3, 8], and auction revenue maximization [9], to name a few.",
      "startOffset" : 255,
      "endOffset" : 261
    }, {
      "referenceID" : 7,
      "context" : "For example, in product recommendation we typically want to choose a small set of products from a large collection; many other examples of subset selection tasks turn up in domains like document summarization [4, 5], sensor placement [6, 7], image search [3, 8], and auction revenue maximization [9], to name a few.",
      "startOffset" : 255,
      "endOffset" : 261
    }, {
      "referenceID" : 8,
      "context" : "For example, in product recommendation we typically want to choose a small set of products from a large collection; many other examples of subset selection tasks turn up in domains like document summarization [4, 5], sensor placement [6, 7], image search [3, 8], and auction revenue maximization [9], to name a few.",
      "startOffset" : 296,
      "endOffset" : 299
    }, {
      "referenceID" : 9,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 7,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 10,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 11,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 12,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 13,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 14,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 15,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 16,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 17,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 18,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 1,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 2,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 19,
      "context" : "Originally discovered as models of fermions [10], DPPs have recently been effectively adapted for a variety of machine learning tasks [8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 20].",
      "startOffset" : 134,
      "endOffset" : 183
    }, {
      "referenceID" : 20,
      "context" : "They offer attractive computational properties, including exact and efficient normalization, marginalization, conditioning, and sampling [21].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 1,
      "context" : "[2] showed that the problem of learning a scalar weight for each row of L is a convex optimization problem.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[3] explored a different direction, learning weights for a linear combination of DPPs with fixed Ls.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[8] proposed as an alternative that one first assume L takes on a particular parametric form, and then sample from the posterior distribution over kernel parameters using Bayesian methods.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "This overcomes some of the disadvantages of [3]’s L-ensemble method, but does not allow for learning an unconstrained, non-parametric L.",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 22,
      "context" : "Thus, projected gradient ascent [23] is a viable, simple optimization technique.",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 24,
      "context" : "This is a standard technique for developing EM schemes for dealing with hidden variables [25].",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 2,
      "context" : "(See Appendix A and [3] for more on k-DPPs.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 26,
      "context" : "The Wishart distribution is relatively unassuming: in terms of eigenvectors, it spreads its mass uniformly over all unitary matrices [27].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 2,
      "context" : "For example, the normalization constant for a k-DPP is given by the identity ∑ Y :|Y |=k det(LY ) = e N k (L), where e N k (L) represents the kth-order elementary symmetric polynomial on the eigenvalues of L [3].",
      "startOffset" : 208,
      "endOffset" : 211
    }, {
      "referenceID" : 28,
      "context" : "[29]’s “summation algorithm” computes ek (L) in O(Nk) time.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "As previously noted, elementary symmetric polynomials can be efficiently computed using [29]’s “summation algorithm”.",
      "startOffset" : 88,
      "endOffset" : 92
    } ],
    "year" : 2014,
    "abstractText" : "A determinantal point process (DPP) is a probabilistic model of set diversity compactly parameterized by a positive semi-definite kernel matrix. To fit a DPP to a given task, we would like to learn the entries of its kernel matrix by maximizing the log-likelihood of the available data. However, log-likelihood is non-convex in the entries of the kernel matrix, and this learning problem is conjectured to be NP-hard [1]. Thus, previous work has instead focused on more restricted convex learning settings: learning only a single weight for each row of the kernel matrix [2], or learning weights for a linear combination of DPPs with fixed kernel matrices [3]. In this work we propose a novel algorithm for learning the full kernel matrix. By changing the kernel parameterization from matrix entries to eigenvalues and eigenvectors, and then lower-bounding the likelihood in the manner of expectation-maximization algorithms, we obtain an effective optimization procedure. We test our method on a real-world product recommendation task, and achieve relative gains of up to 16.5% in test log-likelihood compared to the naive approach of maximizing likelihood by projected gradient ascent on the entries of the kernel matrix.",
    "creator" : "LaTeX with hyperref package"
  }
}