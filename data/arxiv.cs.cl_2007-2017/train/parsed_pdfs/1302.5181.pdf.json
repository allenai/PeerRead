{
  "name" : "1302.5181.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Basic Classes of Grammars with Prohibition",
    "authors" : [ "Mark Burgin" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "A practical tool for natural language modeling and development of human-machine interaction is developed in the context of formal grammars and languages. A new type of formal grammars, called grammars with prohibition, is introduced. Grammars with prohibition provide more powerful tools for natural language generation and better describe processes of language learning than the conventional formal grammars. Here we study relations between languages generated by different grammars with prohibition based on conventional types of formal grammars such as context-free or context sensitive grammars. Besides, we compare languages generated by different grammars with prohibition and languages generated by conventional formal grammars. In particular, it is demonstrated that they have essentially higher computational power and expressive possibilities in comparison with the conventional formal grammars. Thus, while conventional formal grammars are recursive and subrecursive algorithms, many classes of grammars with prohibition are superrecursive algorithms. Results presented in this work are aimed at the development of human-machine interaction, modeling natural languages, empowerment of programming languages, computer simulation, better software systems, and theory of recursion.\nKeywords: formal grammar, formal language, grammar with prohibition, human-computer interaction, hierarchy, natural language, programming language"
    }, {
      "heading" : "1. Introduction",
      "text" : "An important problem of computer technology is organization of convenient, flexible and efficient interaction with computers. It is important for many types of software systems in different areas: computer simulation, learning, decision-making, etc. Natural language is a tool for human-machine interaction that has several desirable properties. First, it provides an immediate vocabulary for talking about the contents of the computer. Second, it gives means of accessing information in the computer independently of its structure and encoding. Third, it shields the user from the formal access language of the underlying system. Fourth, it is available with a minimum of training. This is especially important for business and industry where natural language is the most preferable. As a result natural language comprehension and modeling is one of the central problems in artificial intelligence. Researchers have developed a quantity of different techniques to solve this problem.\nFormal grammars were introduced by Chomsky (1956) in his paper on the syntactic structure of a natural language to the goal of representing natural languages by formal structures. In verbal communication, an utterance is characterized by the surface manifestation of a \"deeper\" structure representing \"meaning\" of the utterance. The deep structure can undergo a variety of transformations of form (e.g., changes of the word order, of endings, etc.) on its way up, while retaining its essential meaning. These transformations are performed by transformational grammars, which work with syntax. They have three components. The first component is a phrase-structure grammar generating strings of morphemes representing simple, declarative, active sentences, each with an associated phrase marker or derivation tree. The second component is a set of transformational rules for rearranging these strings and adding or deleting morphemes to form correct representations of the full variety of authorized sentences. Finally, a sequence of morphophonemic rules maps each sentence representation to a string of phonemes. Formal grammars are capable of describing much of the grammar, or syntax, of natural languages such as English or Spanish (Martin, 1991).\nLater formal grammars were used to describe programming languages and build compilers. In this area, formal grammars became even more useful than in the province of natural languages. For instance, most of the syntax of such popular programming language as Pascal is described by Backus-Naur forms (Backus, 1959), which are equivalent to context-\nfree grammars. Thus, formal grammars have played a central role in compiler technology and parser design since 1960’s. More recently, these grammars have been intensively used to describe document formats for information exchange on the Web.\nFormal grammars proved to be very efficient for generating various linguistic structures, but only for modeling small fragments of natural languages. Their generative and expressive power appeared insufficient for large linguistic systems, not speaking about such developed natural languages as English or Spanish. As Martin (1991) writes, it is unrealistic to expect to arrive at a complete description of natural languages using these grammars. As a result, the principal limitation of existing programs that perform natural language generation is that they fail to realize a sufficiently broad range of requirements to demonstrate convincing linguistic capability (Jacobs, 1986). All this brings us to the problem of achieving higher efficiency for formal grammars.\nIn this work, we further develop a new approach to this problem based on formal grammars with prohibition introduced and studied in (Burgin, 2005a; 2005b). Here we study relations between languages generated by different grammars with prohibition based on conventional types of grammars such as context-free or context sensitive grammars. Besides, we compare languages generated by different grammars with prohibition and languages generated by conventional formal grammars. In particular, it is demonstrated (cf., for example, Theorems 4, 6 and Corollary 2) that they have essentially higher computational power and expressive possibilities in comparison with the conventional formal grammars. As a result, they provide more means for human-machine interaction, modeling natural languages, empowerment of programming languages, computer simulation, developing better software, and theory of recursion.\nThe obtained results are summarized in the tables given in the Appendix, which represent relations between classes of languages generated by grammars with prohibition, as well as between languages generated by different grammars with prohibition and languages generated by conventional formal grammars.\nIt is necessary to remark that grammars with prohibition.were also studied by Carlucci,\nCase and Jain (2007), who called them correction grammars and used for learning in the limit of classes of recursively enumerable languages. Case and Jain (2011) proved the Rice and Rice-Shapiro theorems for transfinite correction grammars."
    }, {
      "heading" : "2. Grammars with Prohibition",
      "text" : "To define formal grammars with prohibition, we fix some alphabet Σ and consider\nlanguages and formal grammars that use only this alphabet.\nDefinition 1. A formal grammar G with prohibition consists of rules that are divided into\ntwo parts: positive PG and negative NG.\nThese rules generate in a conventional manner, i.e., by derivation or recursive inference\n(cf., for example, (Hopcroft et al, 2001)), two languages L(PG) and L(NG).\nRemark 1. It is usually assumed that alphabet Σ and systems of rules are finite.\nDefinition 2. We define the language of the grammar G with prohibition as L(G) =\nL(PG) \\ L(NG).\nPositive rules are used for generation (acceptation) words from the language, while\nnegative rules are used for exclusion of incorrect forms.\nRemark 2. When there are no negative rules, we obtain conventional formal grammars\nand their languages.\nConstruction of languages by means of grammars with prohibition correlates with the technique used by people for natural language text generation. At first, general rules for generating words and texts are given. Then exclusions from these general rules are described. Such exclusions mean prohibition of application of definite general rules in some cases. For instance, one of the simplest forms of a basic English sentence is\n<subject> <verb> <object>\nwhich is illustrated by the example\nSam wears a shirt.\nHowever, there is a prohibition to use\nA shirt wears Sam.\nIn some cases, it is possible to give all possible kinds of permitted sentences by positive rules. Yet often this becomes inefficient and it is more potent not to give all cases when a general rule may be applied, but to present those instances when application of the rule is prohibited. The same is true for generation of words. Irregular verbs give an example of such situation. Verbs in English and in many other languages come in two groups. Regular verbs\nsuch as “adopt”, “behave”, and “call” form their simple past tense and its past participle forms by adding the inflectional ending -ed (or in some cases -d or -t); this means that the past tense and the past participle of regular verbs are always identical in form. English has thousand of existing regular verbs, and new ones are being added all the time. The number of the irregular verbs is much smaller. About 180 verbs are irregular in standard English, and there have not been any recent new ones. In contrast to the regular verbs, past forms of the irregular verbs are unpredictable and demand remembering. Nevertheless, they have some patterns such as: “keep, kept”, sleep, slept”, “feel, felt”, and “dream, dreamed”; “wear, wore”, “bear, bore”, “tear, tore”, and “swear, swore”; “string, strung”, “swing, swung”, “sting, stung”, and “fling, flung”.\nAs the number of the irregular verbs is much smaller than the number of the regular verbs, it is much more efficient to keep in mind exclusion (or prohibition) rules for irregular verbs than to remember all regular verbs. In a formal way, at first all regular forms are generated for all verbs. Then these forms for irregular verbs are excluded from the language by negative rules. After this specific rules for irregular verbs fill the gap.\nConstruction of languages by means of grammars with prohibition is also adequate to learning processes. When an individual, a child or adult, learns some natural language, she/he receives information not only what is possible to do with words, but also what operations and constructions are forbidden. This situation is partially reflected in the general learning theory by the concept of co-learning (cf., for example, (Freivalds et al, 1994)) and learning with positive and negative examples. Procedures of co-learning are described by such grammars with prohibition in which positive rules generate the set of all words in the given alphabet, while negative rules allow one in an inductive mode (Burgin, 2003) to get the solution of the problem, i.e., to learn a given computable function.\nHere, we consider classes of grammars with prohibition related to the Chomsky hierarchy\n(Chomsky, 1956; 1959)."
    }, {
      "heading" : "3. Chomsky hierarchy of grammars and languages",
      "text" : "The Chomsky hierarchy consists of the following levels:\n1. Type-0 grammars (unrestricted or phrase structure grammars) include all conventional\nformal grammars and generate recursively enumerable languages, i.e., languages that are\naccepted by a Turing machine. We denote the class of unrestricted grammars by G0 and the class of corresponding languages by L(G0), i.e., of languages generated (computed or recognized) by grammars from G0 . 2. Type-1 grammars (context-sensitive grammars) generate the context-sensitive languages,\nwhich are exactly all languages that are accepted by a non-deterministic Turing machine whose tape is bounded by a constant times the length of the input. We denote the class of context-sensitive grammars by G1 and the class of corresponding languages by L(G1). 3. Type-2 grammars (context-free grammars) generate the context-free languages, which are\nexactly all languages that are accepted by a non-deterministic pushdown automaton. Context free languages are the theoretical basis for the syntax of most programming languages. We denote the class of context-free grammars by G2 and the class of corresponding languages by L(G2). 4. Type-3 grammars (regular grammars) generate the regular languages, which are exactly\nall languages that can be decided by a finite state automaton. Additionally, this family of formal languages can be obtained by regular expressions. Regular languages are commonly used to define search patterns and the lexical structure of programming languages. We denote the class of regular grammars by G3 and the class of corresponding languages by L(G3). Every regular language is context-free, every context-free language is context-sensitive\nand every context-sensitive language is recursively enumerable. All inclusions are proper."
    }, {
      "heading" : "4. Grammars with prohibition related to Chomsky hierarchy",
      "text" : "The class of grammars with prohibition in which the poitive grammar belongs to the class Gi and the negaitive grammar belongs to the class Gj is denoted by Gij , while the class of corresponding languages, i.e., languages generated (computed or recognized) by grammars from Gij , is denoted by L(Gij).\nThus, four types of conventional formal grammars give us 16 types of formal grammars with prohibition: G00, G01, G02, G03, G10, G11, G12, G13, G20, G21, G22, G23, G30, G31, G32, G33 . This gives us 16 classes of formal languages: L(G00), L(G01), L(G02), L(G03), L(G10), L(G11), L(G12), L(G13), L(G20), L(G21), L(G22), L(G23), L(G30), L(G31), L(G32), L(G33) . For\ninstance, L(G03) consists of all formal languages that have the form L1 \\ L2 where L1 is an arbitrary recursively enumerable language and L2 is an arbitrary regular language. A grammar G that belongs to G03 is called unrestricted\\regular grammar and the corresponding language L(G) is called enumerable\\regular language. A grammar G that belongs to G12 is called context-sensitive\\context-free grammar and the corresponding language L(G) is called context-sensitive\\context-free language. Our goal is to find relations between these classes.\nTheorem 1. a) For all i, j ∈ {0, 1, 2, 3}, we have L(Gij) ⊇ L(Gi).\nb) If k > i , then L(Gij) ⊇ L(Gkj) and L(Gji) ⊇ L(Gjk).\nCorollary 1. For all i ∈ {0, 1, 2, 3}, we have L(Gii) ⊇ L(Gi).\nMany of these inclusions are proper (cf., Theorem 7) but not all.\nTheorem 2. L(G33) = L(G3).\nTo describe and compare expresional power of grammars with prohibition, we use\narithmetical hierarchy (Rogers, 1987). In it, the lowest level Σ0 = Π0 consists of all recursively decidable (recursive) formal languages (sets). The next level has two parts: Σ1 consists of all recursively computable (recursively enumerable) formal languages (sets) and\nΠ1 consists of all complements of recursively computable (recursively enumerable) formal languages (sets).\nLemma 1. If LD is a decidable and LE is an enumerable language, then L = LD \\ LE is a\ncomplement to an enumerable language.\nIndeed, by properties of set-theoretical operations, L = LD \\ LE = Σ* \\ ((Σ* \\ LD) ∪ LE ). Then L1 = Σ* \\ LD is a decidable language and the union of two enumerable languages is an enumerable language, i.e. L2 = (Σ* \\ LD) ∪ LE is an enumerable language. Thus, L = Σ* \\ L2 is a complement to the enumerable language L2.\nLemma 2. If LD is a decidable and LE is an enumerable language, then L = LE \\ LD is an\nenumerable language.\nProof is similar to the proof of Lemma1.\nTheorem 3. L(G03) = Σ1 . Proof is based on Lemma 2.\nTheorem 4. L(G30) = Π1 . Proof is based on Lemma 1. This result shows that in contrast to conventional formal grammars, formal grammars with prohibition can generate non-enumerable languages. Thus, the class G30 and as we see below, G20, G10, and G00 are classes of super-recursive algorithms (Burgin, 2005).\nTheorems 1, 3, and 4 imply the following result.\nCorollary 2. L(G00) = Σ1 ∪ Π1 .\nThis result shows that formal grammars with prohibition have higher expressive (generative) power than conventional formal grammars and Turing machines. However, inductive Turing machines (Burgin, 2005) can compute or accept any language generated by a grammar with prohibition.\nCorollary 3. L(G00) = L(G03) ∪ L(G30).\nCorollary 4. L(G01) ∪ L(G10) = L(G02) ∪ L(G20) = L(G03) ∪ L(G30) .\nTheorem 5. L(G01) = Σ1 .\nProof is based on Lemma 2 as all context-sensitive languages are decidable. Theorems 1 and 5 imply the following result.\nCorollary 5. L(G02) = L(G01) = L(G03) = L(G0) = Σ1.\nTheorem 6. L(G10) = Π1 .\nProof is based on Lemma 1 as all context-sensitive languages are decidable..\nTheorems 1 and 6 imply the following result.\nCorollary 5. L(G20) = L(G10) = L(G30) = Π1 .\nTheorem 7. a) L(G00) ⊃ L(G0), L(G10) ≠ L(G0), L(G20) ≠ L(G0) and L(G30) ≠ L(G0);\nb) L(G10) ≠ L(G1), L(G20) ≠ L(G2), and L(G30) ≠ L(G3); c) L(G32) ≠ L(G2), L(G22) ≠ L(G2), and L(G12) ≠ L(G2);\nIndeed, inequalities and inclusions from parts a and b follow from previous results and relations between classes from the arithmetical hierarchy (Rogers, 1987). For c), we have\nL(G32) ⊃ Σ* \\ L(G2) and the class L(G2) of context-free languages is not closed under operation of difference.\nAt the same time, as the class L(G1) of context-sensitive languages is closed under\noperations of complement and intersection (Du and Ko, 2001), we have the following result.\nTheorem 8. L(G11) = L(G1).\nTheorem 9. L(G23) = L(G2).\nIndeed, if LCF is a context-free and LR is a regular language, then L = LCF \\ LR = LCF ∩ (Σ* \\ LR). Here (Σ* \\ LR) is a regular language and the class L(G2) of context-free languages is closed under operation of intersection with regular languages (Hopcroft, et al, 2001).\nProposition 1. L(G32) is the complement of L(G2). Proof. Let LCF be a context-free and LR be a regular language. For a subset X of Σ*, its complement is denoted by CX. Then L = LR \\ LCF = LR ∩ (Σ* \\ LCF) = (Σ* \\ CLR ) ∩ (Σ* \\ LCF) = C(C(Σ* \\ CLR ) ∪ C(Σ* \\ LCF)) = C(LR ∪ LCF) = Σ* \\ L1 where L1 is a context-free language because the class L(G2) of context-free languages is closed under operation of union (Du and Ko, 2001).\nProposition 1 is proved.\nTheorem 2. L(G32) ≠ L(G1). Proof. Let us assume that an arbitrary context-sensitive language LCS is equal to a complement CLCF of some context-free language LCF . Then LCF = CLCS . However, CLCS is also a context-sensitive language as the class L(G1) of context-free languages is closed under operation of complement (Du and Ko, 2001). Moreover, as LCS is an arbitrary contextsensitive language, CLCS is also an arbitrary context-sensitive language. As there are contextsensitive languages that are not context-free, our assumption is false and theorem is proved.\nConclusion We have considered grammars with prohibition that work with conventional data – strings of symbols or words – and generate traditional formal languages. Relations between classes of languages generated by grammars with prohibition obtained in this work, as well\nas relations between classes of languages generated by grammars with prohibition and classes of languages generated by conventional formal grammars are summarized in the tables from the Appendix.\nHowever, grammars that work with more general objects than strings of symbols have been studied and found useful. For instance in (Murata, et al, 2001), grammars that work with trees are studied and applied to formal description of XML scheme languages. Formal grammars can work with arbitrary graphs and even with such complex objects as Kolmogorov complexes (Kolmogorov, 1953). Thus, it is interesting to investigate the following problem.\nProblem 1. Consider grammars with prohibition that work with objects that are not\nstrings and study their generative and expressive power.\nAn important peculiarity of formal grammars is that there is a correspondence between definite classes of grammars and types of abstract automata. For instance, regular grammars correspond to finite automata as they generate the class of languages. Context-free grammars correspond to pushdown automata, while unrestricted or phrase structure grammars correspond to Turing machines. This brings us to the following problem.\nProblem 2. Develop correspondence between classes of grammars with prohibition and\nclasses of automata.\nWhen classes of languages are studied and used, it is useful to know their closure properties, i.e., with respect to what operations with languages they are closed and with respect to what operations with languages they are not closed. This brings us to the following problem.for grammars with prohibition.\nProblem 3. Study closure properties of grammars with prohibition.\nBesides, utilization of languages usually demands solving different algorithmic problems, e.g., whther the given language is empty or if the given word belong to the given language. This brings us to the following problem.for grammars with prohibition.\nProblem 4. Study algorithmic problems of grammars with prohibition.\nHere we considered only grammars with prohibition that correspond to the Chomsky\nhierarchy. However, there are many other types and kinds of formal grammars.\nProblem 5. Study other types of grammars with prohibition, i.e., when positive and/or\nnegative part of the grammar with prohibition does not belong to the Chomsky hierarchy.\nFor instance, the most noteworthy class of grammars lying properly between context-free and context-sensitive grammars is the class of indexed grammars (Aho, 1968; Parchmann and Duske, 1986). Consequently, the languages describable by indexed grammars - namely, the indexed languages - are a natural class of formal languages that form a proper superset of the context-free languages and a proper subset of the context-sensitive languages. Thus, we have the following problem.\nProblem 6. Study grammars with prohibition when positive and/or negative part of the\ngrammar with prohibition is an indexed grammar.\nIt is interesting to find, in particular whether the set of all indexed\\indexed languages\ncoincides with the set of all context-sensitive languages.\nIt would be also appealing to consider grammars and languages with prohibition when, at\nleast, one of the grammars is a determistic context-free grammar (Hopcroft, et al, 2001).\nAnother popular class consists of programmed grammars. When a programmed grammar is used to derive a string, rule order is intrinsically predetermined by the availability of variables in the string under derivation. This process is generally non-deterministic because there may be several candidate rules. The idea of a programmed grammar is to impose an extrinsic ordering of rules reflecting a certain manner in which the generation process is envisaged by the composer. Thus, we have the following problem.\nProblem 7. Study grammars with prohibition when positive and/or negative part of the\ngrammar with prohibition is a programmed grammar.\nAn important class of formal grammars is formed by Boolean grammars and their\ngeneralizations (Okhotin, 2004). Thus, we have the following problem.\nProblem 8. Study grammars with prohibition when positive and/or negative part of the\ngrammar with prohibition is a Boolean grammar.\nTables in the Appendix, which represent relations between classes of languages generated\nby grammars with prohibition, leave two open problems.\nProblem 9. Is the equality L(G22) = L(G11) true?\nProblem 10. Is the equality L(G22) = L(G1) true?"
    } ],
    "references" : [ {
      "title" : "Indexed Grammars",
      "author" : [ "A. Aho" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1968
    }, {
      "title" : "The Syntax and Semantics of the Proposed International Algebraic Language",
      "author" : [ "J.W. Backus" ],
      "venue" : "Proceedings of the International Conference on Information Processing,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1959
    }, {
      "title" : "Nonlinear Phenomena in Spaces of Algorithms, International",
      "author" : [ "M. Burgin" ],
      "venue" : "Journal of Computer Mathematics,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2003
    }, {
      "title" : "Super-recursive Algorithms, Springer, New York/Heidelberg/Berlin",
      "author" : [ "M. Burgin" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2005
    }, {
      "title" : "Grammars with Prohibition and Human-Computer Interaction, in Proceedings of the Business and Industry Simulation Symposium, Society for Modeling and Simulation International",
      "author" : [ "M. Burgin" ],
      "venue" : null,
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2005
    }, {
      "title" : "Complexity of grammars with prohibition, Abstracts of papers presented to the American",
      "author" : [ "M. Burgin" ],
      "venue" : "Mathematical Society, v.26,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2005
    }, {
      "title" : "Rice and Rice-Shapiro Theorems for Transfinite Correction Grammars",
      "author" : [ "J. Case", "S. Jain" ],
      "venue" : "Mathematical Logic Quarterly,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2011
    }, {
      "title" : "Three models for the description of language",
      "author" : [ "N. Chomsky" ],
      "venue" : "IRE Transactions on Information Theory, v",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1956
    }, {
      "title" : "On certain formal properties of grammars",
      "author" : [ "N. Chomsky" ],
      "venue" : "Information and Control,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1959
    }, {
      "title" : "Problem Solving in Automata, Languages, and Complexity, John Wiley&Sons",
      "author" : [ "Du", "D.-Z", "Ko", "K.-I" ],
      "venue" : "New York/Singapore/Toronto,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2001
    }, {
      "title" : "Introduction to Automata Theory, Languages, and Computation, Addison Wesley, Boston/San",
      "author" : [ "J.E. Hopcroft", "R. Motwani", "J.D. Ullman" ],
      "venue" : "Francisco/New York,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2001
    }, {
      "title" : "Knowledge structures for natural language generation",
      "author" : [ "P.S. Jacobs" ],
      "venue" : "Proceedings of the 11th Conference on Computational Linguistics, Bonn, Germany, pp",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1986
    }, {
      "title" : "On the Concept of Algorithm, Russian",
      "author" : [ "A.N. Kolmogorov" ],
      "venue" : "Mathematical Surveys,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1953
    }, {
      "title" : "Introduction to Languages and the Theory of Computation, McGrow Hill, New York/San Francisco/London",
      "author" : [ "J.C. Martin" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1991
    }, {
      "title" : "Taxonomy of XML Schema Languages using Formal Language Theory, in Extreme Markup Languages",
      "author" : [ "M. Murata", "D. Lee", "M. Mani" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2001
    }, {
      "title" : "Computational and Evolutionary Aspects of Language, Nature, v",
      "author" : [ "M. Nowak", "N. Komarova", "P. Niogi" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2002
    }, {
      "title" : "Self-Embedding Indexed Grammars",
      "author" : [ "R. Parchmann", "J. Duske" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1986
    }, {
      "title" : "Theory of Recursive Functions and Effective Computability",
      "author" : [ "H. Rogers" ],
      "venue" : null,
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1987
    } ],
    "referenceMentions" : [ ],
    "year" : 2013,
    "abstractText" : "A practical tool for natural language modeling and development of human-machine interaction is developed in the context of formal grammars and languages. A new type of formal grammars, called grammars with prohibition, is introduced. Grammars with prohibition provide more powerful tools for natural language generation and better describe processes of language learning than the conventional formal grammars. Here we study relations between languages generated by different grammars with prohibition based on conventional types of formal grammars such as context-free or context sensitive grammars. Besides, we compare languages generated by different grammars with prohibition and languages generated by conventional formal grammars. In particular, it is demonstrated that they have essentially higher computational power and expressive possibilities in comparison with the conventional formal grammars. Thus, while conventional formal grammars are recursive and subrecursive algorithms, many classes of grammars with prohibition are superrecursive algorithms. Results presented in this work are aimed at the development of human-machine interaction, modeling natural languages, empowerment of programming languages, computer simulation, better software systems, and theory of recursion.",
    "creator" : "PScript5.dll Version 5.2.2"
  }
}