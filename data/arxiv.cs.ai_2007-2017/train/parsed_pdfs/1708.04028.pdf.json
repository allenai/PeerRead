{
  "name" : "1708.04028.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Rodrigo F. Araújo", "Alexandre Ribeiro", "Iury V. Bessa", "Lucas C. Cordeiro", "João E. C. Filho" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 8.\n04 02\n8v 1\n[ cs\n.R O\n] 1\n4 A\nug 2\nIndex Terms—optimization, satisfiability modulo theory, path planning, mobile robots.\nI. INTRODUCTION\nRecently, mobile robots have been employed for various tasks, replacing humans in dangerous and monotonous tasks with a certain degree of efficiency and safety [1]–[3]. For this specific reason, robot mobile navigation, and in particular, path planning has become an important research topic in recent days. The basic path planning problem can be described as the computation of robot positions and motions, which allow the robot to autonomously move from one starting point to a final desired position, performing a specific task and avoiding possible obstacles [4].\nThere are several methods in the literature that are usually employed for path planning [5]–[11]. For instance, Yang et al. [12] classify the path planning method in five main categories: sampling-based, node-based optimal, mathematical model-based, bioinspired, and multifusion-based algorithms. Additionally, path planning strategies can be classified in two categories: on-line and off-line. In on-line mode, the path planning can be performed during the robot movement, while in off-line mode, the robot movement path planning is performed in advance (i.e., before the movement).\nPath planning task is often modeled as an optimization problem, where a decision variable represents a given path, i.e., the sequence of points (or movements) by which the robot must move; the cost function is a certain criteria or metric whose value is optimized (e.g., distance, energy consumption, and execution time). Thus, various optimization techniques have been applied to solve path planning problems, e.g., genetic algorithm (GA) [5]–[7], A* [8], particle swarm optimization (PSO) [9], nonlinear programming (NLP) [10],\nand ant colony [11]. However, these optimization techniques are unable to ensure the global optimality of the robot path, although they are able to provide results sufficiently fast for on-line path planning applications.\nWe describe and evaluate a novel off-line path planning algorithm based on the counterexample guided inductive optimization (CEGIO) technique described by Araujo et al. [13], [14], which is a Boolean Satisfiability (SAT) and Satisfiability Modulo Theories (SMT) based optimization algorithm that executes iteratively to achieve global optimization via counterexamples produced by SAT and SMT solvers. Previous studies [13], [14], showed that CEGIO is able to ensure the global optimization of various non-trivial functions classes (e.g., convex, nonlinear, and nonlinear functions), with an accuracy rate better than traditional optimization techniques (e.g., GA, PSO, and NLP). Therefore, the main original contributions of this paper are:\n• Apply the CEGIO algorithm to obtain optimal two-\ndimensional paths for autonomous mobile robots.\n• Evaluate the effect of the minimum improvement (step)\non the cost function at each iteration of the CEGIO algorithm.\nOutline: Section II provides a brief background about optimization problems, path planning for mobile robots, software model checking, and CEGIO. Section III describes the proposed methodology steps for efficiently solving optimization problems using the CEGIO approach. Section IV presents the objectives and experimental results of the proposed algorithm if applied to the path planning problem in bi-dimensional space for mobile robots. Finally, Section V presents the conclusions of this work and outlines future studies."
    }, {
      "heading" : "II. BACKGROUND",
      "text" : "A. Optimization Problems\nLet f :X →R be a cost function, such that X ∈Rn represents the decision variables vector x1,x2, ...,xn and f (x1,x2, ...,xn)≡ f (x). Let Ω ⊂ X be a subset settled by a set of constraints.\nDefinition 1. A multi-variable optimization problem consists in finding an optimal vector x, which minimizes f in Ω.\nAccording to Definition 1, an optimization problem can be\nwritten as min x\nf (x),\ns.t. x ∈ Ω. (1)\nIn particular, this optimization problem can be classified in different ways with respect to constraints, decision variables domain, and nature of cost function f . All optimization problems considered here are constrained, i.e., decision variables are constrained by the subset Ω. The optimization problem domain X that contains Ω can be the set of N, Z, Q, or R. Depending on the domain and constraints, the optimization search-space can be small or large, which influence the optimization algorithm performance.\nThe cost function can be classified as linear or non-linear; continuous, discontinuous or discrete; convex or non-convex. Depending on the cost function nature, the optimization problem can be difficult to solve, given the time and memory constraints [15], even if we use SAT and SMT solvers [16]. Particularly, non-convex optimization problems are the most difficult ones with respect to the cost function nature. A non-convex cost function is a function whose epigraph is a non-convex set and consequently presents various inflexion points that can trap the optimization algorithm to a suboptimal solution. A non-convex problem is necessarily a nonlinear problem and it can also be discontinuous. Depending on that classification, some optimization techniques are unable to solve the optimization problem, and some algorithms usually point to suboptimal solutions, i.e., a solution that is not a global minimum of f , but it only locally minimizes f . Global optimal solutions of the function f , aforementioned, can be defined as:\nDefinition 2. A vector x∗ ∈ Ω ia a global optimal solution of f in Ω iff f (x∗)≤ f (x), ∀x ∈ Ω.\nB. Path Planning for Mobile Robots\nPath planning is one of the main robot navigation steps in which the robot must determine a safe and a collision free path from one starting point to a target point. Such path is a curve without time continuous consideration and it is composed of various segments, usually called by trajectories [12].\nDefinition 3. A path is a set of straight segments successively connected to guide the mobile robot from one initial point to a target point.\nA path planning algorithm can be evaluated, given some properties, e.g., completeness, optimally, correctness, robustness, and computational complexity [4]. In particular, path planning algorithms often seek to obtain not only a correct path, i.e., a safe path that meets the path specification (e.g., obstacle avoidance), but also an optimal path [12].\nDefinition 4. An optimal path is a set of straight segments successively connected to guide the mobile robot from one initial point to a target point, which minimizes a cost function related to that path.\nThus, the main path planning algorithm objective is to find the n points, which form the path that connects the initial and target points of the mission, generating smallest displacement cost, i.e., the path planning is essentially a trajectory optimization problem. In the present work, this problem is restricted to the bi-dimensional environment.\nC. Model Checking\nModel checking is an automated verification procedure to exhaustively check all (reachable) systems states [17]. The model checking procedure typically consists of three steps: modeling, specification, and verification.\nModeling is the first step, where it converts the system to a formalism that is accepted by a verifier. The second step is the specification, which describes the systems behavior and the property to be checked. Model checking provides ways to check whether a given specification satisfies a system property, but it is difficult to determine whether such specification covers all properties in which the system should satisfy. Finally, the verification step checks whether a given property is satisfied with respect to a given model, i.e., all relevant system states are checked to search for any state that violates the verified property. In case of a property violation, the verifier reports the system execution trace (counterexample), which contains all steps from the initial state to the bad state that leads to the property violation.\n1) Bounded Model Checking (BMC): BMC is an important verification technique, which is based on SAT [18] or SMT [19] solvers. BMC has been successfully applied to verify single- and multi-threaded programs [20]–[23]. It checks the negation of a given property at a given depth over a transition system M.\nDefinition 5. Given a transition system M, a property φ , and a bound k; BMC unrolls the system k times and translates it into a verification condition (VC) ψ , which is satisfiable iff φ has a counterexample of depth less than or equal to k [18].\nIn BMC, the associated problem is formulated by construct-\ning the following logical formula\nψk = I(S0)∧ k ∨\ni=0\ni−1 ∧\nj=0\n( γ(s j ,s j+1)∧¬φ(si) ) , (2)\nwhere φ is a property and S0 is a set of initial states of M, and γ(s j ,s j+1) is the transition relation of M between time steps j and j+ 1. Hence, I(S0)∧ ∧i−1 j=0 γ(s j,s j+1) represents the executions of a transition system M of length i. The above VC ψk can be satisfied if and only if, for some i ≤ k there exists a reachable state at time step i in which φ is violated. If the logical formula (2) is satisfiable (i.e., returns true), then the SMT solver provides a satisfying assignment (counterexample).\nDefinition 6. A counterexample for a property φ is a sequence of states s0,s1, ...,sk with s0 ∈ S0, sk ∈ Sk, and γ(si,si+1) for 0 ≤ i ≤ k that makes Eq. (2) satisfiable. If it is unsatisfiable\n(i.e., returns false), then we can conclude that there is no error state in k steps or less.\nD. Counterexample Guided Inductive Optimization\nThis section presents a novel class of search-based optimization algorithm that employs non-deterministic representation of decision variables and constrains the state-space search based on counterexamples produced by a SAT or SMT solver, in order to ensure the complete global optimization without employing randomness. This class of techniques is defined here as counterexample guided inductive optimization (CEGIO), which is inspired by the syntax-guided synthesis (SyGuS) to perform inductive generalization based on counterexamples provided by a verification oracle [24].\nIn particular, CEGIO relies on iterative executions to constrain a verification procedure, in order to perform inductive generalization, based on counterexamples extracted from SAT and SMT solvers. CEGIO is able to successfully optimize a wide range of functions, including non-linear and non-convex optimization problems based on SAT and SMT solvers, in which data provided by counterexamples are employed to guide the verification engine, thus reducing the optimization domain [13]. The function evaluation and the search for the optimal solution are performed by means of an iterative execution of successive verifications based on counterexamples extracted from SAT and SMT solvers. The counterexample provides new domain boundaries and new optimal candidates. In contrast to other heuristic methods (e.g., genetic algorithms), which are usually employed for optimizing this class of function, the present approach always finds the global optimal point."
    }, {
      "heading" : "III. CEGIO-BASED PATH PLANNING",
      "text" : "In this section, a novel optimization method to solve the path planning problem of autonomous mobile robots is described. The main objective of a path planning algorithm is to generate points needed to guide the mobile robot in a environment with obstacles. As observed by other researchers, it is a challenge to find the optimal path in a region, since the number of activities and obstacles types in the environment can substantially increase the path planning problem complexity [4]. In most cases, it requires substantial processing time, especially if there are many points to visit. Therefore, there is a growing need for developing techniques for optimal path planning, considering trajectory length and system energy consumption.\nFor the path planning method proposed here, the following two steps are applied: (1) encode the environment, movement space, and static obstacles (i.e., the environment is assumed to be known and contains only static obstacles); (2) use a path search method that consists of points in the space and its respective orientations, to find a path that satisfies the constraints given by the problem.\nAraújo et al. [14] proposed three different algorithm types based on CEGIO, which are suitable for different situations: the Generalized Algorithm (CEGIO-G), the Simplified Algorithm (CEGIO-S), and the Fast Algorithm (CEGIO-F). CEGIO-G can to be applied to any function class (i.e., convex\nand non-convex ones). CEGIO-S is suitable for functions about which we have some prior knowledge (e.g., semi- and positivedefinite functions). Finally, CEGIO-F can be applied to convex functions and uses its properties to restrict the associated statespace, according to the results presented by Araújo et al. [14], which show considerable improvement regarding optimization times. The proposed method consists of modeling the path planning as an optimization problem and solving it by a CEGIO-F based algorithm.\nA. Optimization Problem Formulation\nFor a complete path planning problem formulation as an optimization problem, the cost function and problem constraints must be defined.\n1) Cost Function: Given the starting point (S) and the target point (T) defined as S= P1 and T = Pn, the objective is to find a decision variables matrix, L= [P1,P2, ...,Pn−1,Pn], such that, J(L) is the length function. The cost function is defined by Eq. (3) as\nJ(L) = n−1\n∑ i=1 ‖Pi+1−Pi‖2 , (3)\nwhere n is the number of points that compose the path and for the bi-dimensional case, Pi = (xi,yi) is a path vertex.\nWe can see that the bi-dimensional path planning optimization problem is an optimization problem in 2n− 4-th dimension. Note that, if n → ∞, the path will be a smooth trajectory; furthermore, the optimization problem dimension will also tend to infinity. However, the trajectory smoothness should be provided by a trajectory planning algorithm, which uses the results of the path planning algorithm (the scope of this paper).\n2) Constraints: According to Definition 3, the path is formed by n−1 straight segments, which connect the n points such that the i-th straight segment is built from Pi to Pi+1. Thus, constraints are about each point piλ that composes the i-th straight segments, in such way that the i-th must not intercept any obstacle. From Definition 1 and Eq. (3), the path planning optimization problem can be written as\nmin L\nJ(L),\npiλ (L) /∈O s.t. piλ (L) ∈ E\ni= 1, ...,n− 1,\n(4)\nwhereO is the set of points defined by obstacles; E is the set of points defined by environment limits; n is the number of points that compose the path; and piλ (L) is all points belonging to the i-th straight segment of the path defined by vector L, each piλ (L) point is defined by Eq. (5) as\npiλ (L) = (1−λ )Pi+λPi+1,∀λ ∈ [0,1]. (5)\n3) Environmental Modeling: Although the optimization problem is defined by Eq. (4), it is still necessary to model the environment of movement (E) and obstacles (O) in it. For simplicity, the movement environment is modeled as a\nrectangle, which is defined by lower and upper limits and constrains the value that each coordinate can assume.\nObstacles can be modeled by means of circles, such that the geometric center of the real obstacle shape defines the center of the circle; the circle radius is such that every point of the real obstacle shape is inside the circle. The constraints of the optimization problem (4) ensure that there is no intersection between the path segments and the obstacle. This constrained is described by Eq. (6).\n(xiλ − x0) 2+(yiλ − y0) 2 ≥ (r+σ)2 (6)\nwhere piλ = (xiλ ,yiλ ), and σ is a safety margin.\nB. Path Planning Algorithm\nThere are two code directive in C/C++ programming language, which can be used to model and control the verification process: ASSUME and ASSERT. The ASSUME directive is able to define constraints over (non-deterministic) variables, and the ASSERT directive is used to check system correctness with respect to a given property. Using these two directives, any off-the-shelf C/C++ model checker could be applied to check specific constraints in optimization problems.\nThe verification process consists of three steps: modeling, especification, and verification [13]. Thus, the optimization problem described in section III-A is encoded as shown in Figure 1. This C code checks whether the literal Joptimal given by Eq. 7 is satisfied for value Jc that is a candidate to optimal, such that Jc is randomly initialized with high values.\nJoptimal ⇐⇒ J(L)> Jc (7)\nA function rest_points inserts the constraints on n−1 path straight segments, in such way that they satisfy the conditions discussed in the previous section; for this purpose, the ASSUME directive is used. Note that rest_points must be executed for each obstacle. Figure 2 illustrates the rest_points ANSI-C code.\nIf the code shown in Figure 1 returns false, i.e., the negation of Joptimal is satisfiable, then there is a L (i) for which J(L(i)) < Jc. Thus, the optimal candidate, Jc, can be updated with the returned value, Jc = J(L\n(i)), for the new code instance execution; otherwise, Joptimal is unsatisfiable, i.e., J(L\n(i−1)) is the optimal value for a given precision p. Furthermore, the counterexample returns the matrix L that defines the optimal path with n points between start and target points.\nThe number of points is automatically increased if it is not possible to find an optimal path, i.e., Joptimal is unsatisfiable. If Joptimal is repeatedly unsatisfiable, then the precision must be improved. The precision p defines the path points coordinate precision, such that:\nk > logp, (8)\nwhere k is the number of decimal places of the points coordinate values. The precision p is initialized by one, i.e., k= 0 and coordinates are considered to be integers. The precision is increased by multiplying p by 10, i.e., by adding one decimal place in the coordinate values.\nThe optimization problem (4) is solved by executing the code in Figure 1 iteratively, according to precision values and number of points that compose the path. Algorithm 1 summarizes the aforementioned steps of the proposed bi-dimensional path planning methodology. The algorithm is inspired by CEGIO-F algorithm presented by Araújo et al. [14], since the cost function is convex.\nThe algorithm efficiency depends on the number of points in the path n. Naturally, a large value of n will generate smooth paths, but it will increase the complexity of the optimization problem, leading to a large execution time. The smoothness is not required from the path planning algorithm, but it is provided by a trajectory planning algorithm that computes the curves between the points of the path, i.e., a trajectory planning\nAlgorithm 1: Path planning algorithm based on satisfiability.\ninput : Cost function J(L), is a set of obstacles constraints O and a set of environment constraints E, which define Ω and a desired precision η output: The optimal path L∗ and the optimal cost function value J(L∗)\n1 Initialize J(L(0)) randomly; 2 Initialize precision variable with p= 1, k = 0 e i= 1; 3 Initialize number of points, n= 1; 4 Declare decision variables vector Li as non-deterministic integer variables; 5 while k≤ η do 6 Define upper and lower limits of L with directive ASSUME, such as L ∈ Ωk; 7 Describe the objective function model J(L); 8 do 9 do\n10 Define the constraint J(L(i))< J(L(i−1)) with directive ASSUME; 11 Verify the satisfiability of Joptimal given by Eq. (7); 12 Update L∗ = L(i) e J(L∗) = J(L(i)) based on the counterexample; 13 Do i= i+1; 14 while ¬Joptimal is satisfiable; 15 if ¬Joptimal is not consecutively satisfiable then 16 break 17 end 18 else 19 Update the number of points, n; 20 end 21 while TRUE; 22 Do k = k+1; 23 Update the set Ωk; 24 Update the precision variable, p; 25 end 26 L ∗ = L(i) e J(L∗) = J(L(i)); 27 return L∗ e J(L∗);\nalgorithm is responsible for interpolating the points found by the path planning."
    }, {
      "heading" : "IV. EXPERIMENTAL EVALUATION",
      "text" : "A. Experimental Objectives and Description\nThe path planning algorithm described in section III is suitable for a general autonomous vehicle, and the goal is to find points which compose the path. Two experiments were designed and executed to evaluate the application of the CEGIO-based path planning algorithm for an autonomous vehicle.\nThe first experiment is performed with Setting 1, in which the autonomous vehicle is inserted in a bi-dimensional space with the goal of avoiding a single obstacle, as shown in Figure 3(a). The second experiment, with Setting 2, is similar to the first one, except that now there are two obstacles, as illustrated in Figure 3(b).\nThe objective in both experiments is to compute a path from S to T. The precision on the points location that form the path is 10cm. In Setting 1, the obstacle is centered in O(x0,y0) = (5,5) and its radius is r = 2.5. In Setting 2, the obstacles are centered in O1(x0,y0)= (2,4) and O2(x0,y0)= (7,8), and their radius are r1 = 1 r2 = 1.5, respectively. The safety margin for both settings is σ = 0.5. All previous distances are measured in meters. The maximum algorithm execution time for both employed verifiers CBMC1 and ESBMC2 is set to three days for Setting 1 and one week for Setting 2.\nB. Experimental Setup\nAll experiments were conducted on an otherwise idle Intel Core i7− 4790 3.60 GHz processor, with 16 GB of RAM, running Ubuntu 14.10 64-bits. Additionally, the time presented here is related to the average of 10 executions for each benchmark; the measuring unit is always in seconds based on the CPU time; we did not restrict the memory consumption for the experiments. The employed software verifiers versions are: CBMC v4.5 with support to the MiniSAT v2.2.0 solver and ESBMC v3.1.0 with support to the MathSAT v5.3.13 solver.\nC. Experimental Results\nThe paths obtained in Algorithm 1 for both settings and also using the SAT and SMT solvers are illustrated in Figure 4. For Setting 1, a path with only five points was obtained (n = 5), and for Setting 2, the obtained path has six points (n= 6); both scenarios suffered the timeout of three days and one week, respectively.\nFigure 5 shows the cost function convergence trajectories to obtain those paths shown in Figure 4. Note that the cost function value always decreases at each iteration and converges to the optimal solution. However, it does not reach\n1http://www.cprover.org/cbmc/ 2http://esbmc.org/\nthe optimal value due to the timeout previously defined. SAT and SMT solvers obtained very similar solutions with the same number of points and even timeout; however, the SAT solver converges more quickly to the optimal solution if the number of points increases, as shown in Figure 5(b).\nThe timeout for both settings occurred due to the cost function step being 10−4, which is the precision of values returned from the counterexamples. Thus, the proposed algorithm requires more iterations to converge to the optimal solution and as much close to that, each iteration does not significantly improve the value of the cost function, which substantially increases the convergence time.\nA solution to this problem is to increase this step, whereby the value of the cost function decreases. Thus, in order to evaluate the step influence in the execution time, the step was fixed to 10−2, i.e., Jc = J(L (i))− 10−2, a hundred times larger than the previous step, and the Setting 1 experiment is repeated. However, the found solution will not be the best, but it will be at a distance of 10−2 from it and for most problems, it is still a satisfactory solution.\nFigure 6 shows a comparison between the obtained paths and the convergence trajectory of cost function for Setting 1, considering the steps previously mentioned, 10−4, and the step fixed in 10−2. Only the SAT solver was used to perform this\nspecific experiment.\nThe obtained path, considering the new step, has more points, n= 6; additionally, it was found in a much shorter time than the previous configuration, i.e., only four hours, which represents 5.5% of the previous time, 72 hours, although it took more iterations. This step can be further increased such that satisfactory solutions can be obtained in a shorter time. However, there is no guarantee that the optimal solution is found, as previously mentioned, it is only guaranteed that the solution found is at a distance relative to the chosen step of the optimal solution."
    }, {
      "heading" : "V. CONCLUSION",
      "text" : "We have presented a novel path planning algorithm for mobile robots, where the optimal path planning problem is solved by the application of the CEGIO-F algorithm. The experimental results indicate that CEGIO is able to provide optimal paths for mobile robots. However, the cumulative execution time is still high, if compared to traditional optimization-based path planning algorithms. Future studies consist in applying the CEGIO-based algorithm to tridimensional environments and in the context of the trajectory planning in order to obtain a smooth trajectory."
    } ],
    "references" : [ {
      "title" : "Use of unmanned vehicles in search and rescue operations in forest fires: Advantages and limitations observed in a field trial",
      "author" : [ "S. Karma", "E. Zorba", "G. Pallis", "G. Statheropoulos", "I. Balta", "K. Mikedi", "J. Vamvakari", "A. Pappa", "M. Chalaris", "G. Xanthopoulos", "M. Statheropoulos" ],
      "venue" : "International Journal of Disaster Risk Reduction, vol. 13, pp. 307 – 312, 2015.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Autonomous UAV based search operations using constrained sampling evolutionary algorithms",
      "author" : [ "G. Varela", "P. Caamao", "F. Orjales", "lvaro Deibe", "F. Lpez-Pea", "R.J. Duro" ],
      "venue" : "Neurocomputing, vol. 132, pp. 54 – 67, 2014.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Development of an UAV for search & rescue applications",
      "author" : [ "Y. Naidoo", "R. Stopforth", "G. Bright" ],
      "venue" : "AFRICON, Sept 2011, pp. 1–6.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Motion planning for mobile robots: A method for the selection of a combination of motion-planning algorithms",
      "author" : [ "J.J.M. Lunenburg", "S.A.M. Coenen", "G.J.L. Naus", "M.J.G. van de Molengraft", "M. Steinbuch" ],
      "venue" : "IEEE Robotics Automation Magazine, vol. 23, no. 4, pp. 107–117, Dec 2016.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Optimal path planning and execution for mobile robots using genetic algorithm and adaptive fuzzy-logic control",
      "author" : [ "A. Bakdi", "A. Hentout", "H. Boutami", "A. Maoudj", "O. Hachour", "B. Bouzouia" ],
      "venue" : "Robotics and Autonomous Systems, vol. 89, pp. 95 – 109, 2017.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2017
    }, {
      "title" : "Intelligent motion planning and control for a simulated mobile robot",
      "author" : [ "A.V. Topalov", "D.D. Tsankova", "M.G. Petrov", "T.P. Proychev" ],
      "venue" : "{IFAC} Proceedings Volumes, vol. 30, no. 21, pp. 351 – 356, 1997, 2nd {IFAC} Workshop on New Trends in Design of Control Systems 1997, Smolenice, Slovak Republic, 7-10 September.",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Heuristic and genetic algorithm approaches for UAV path planning under critical situation",
      "author" : [ "J. Da Silva Arantes", "M. Da Silva Arantes", "C. Toledo", "O. Jnior", "B. Williams" ],
      "venue" : "International Journal on Artificial Intelligence Tools, vol. 26, no. 1, 2017.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2017
    }, {
      "title" : "Mobile robot path planning with surrounding point set and path improvement",
      "author" : [ "J. Han", "Y. Seo" ],
      "venue" : "Applied Soft Computing Journal, vol. 57, pp. 35–47, 2017.",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2017
    }, {
      "title" : "Online path planning for surface vehicles exposed to unknown ocean currents using pseudospectral optimal control",
      "author" : [ "A.M. Lekkas", "A.L. Roald", "M. Breivik" ],
      "venue" : "IFAC-PapersOnLine, vol. 49, no. 23, pp. 1 – 7, 2016, 10th IFAC Conference on Control Applications in Marine SystemsCAMS 2016.",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "The free step length ant colony algorithm in mobile robot path planning",
      "author" : [ "M.-R. Zeng", "L. Xi", "A.-M. Xiao" ],
      "venue" : "Advanced Robotics, vol. 30, no. 23, pp. 1509–1514, 2016.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Survey of robot 3D path planning algorithms",
      "author" : [ "L. Yang", "J. Qi", "D. Song", "J. Xiao", "J. Han", "Y. Xia" ],
      "venue" : "Journal of Control Science and Engineering, vol. 2016, 2016.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "SMT-based verification applied to non-convex optimization problems",
      "author" : [ "R. Arajo", "I. Bessa", "L.C. Cordeiro", "J.E.C. Filho" ],
      "venue" : "2016 VI Brazilian Symposium on Computing Systems Engineering (SBESC), Nov 2016, pp. 1–8.",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Counterexample guided inductive optimization",
      "author" : [ "R. Araújo", "I. Bessa", "L. Cordeiro", "J.E.C. Filho" ],
      "venue" : "arXiv:1704.03738 [cs.AI], April 2017, pp. 1–32. [Online]. Available: http://arxiv.org/abs/1704.03738",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2017
    }, {
      "title" : "Problem-method classification in optimization and control",
      "author" : [ "E.A. Galperin" ],
      "venue" : "Computers and Mathematics with Applications, vol. 21, no. 6, pp. 1 – 6, 1991.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Applying smt-based verification to hardware/software partitioning in embedded systems",
      "author" : [ "A. Trindade", "L.C. Cordeiro" ],
      "venue" : "Design Autom. for Emb. Sys., vol. 20, no. 1, pp. 1–19, 2016. [Online]. Available: https://doi.org/10.1007/s10617-015-9163-z",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Principles of model checking",
      "author" : [ "C. Baier", "J. Katoen" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2008
    }, {
      "title" : "Bounded model checking",
      "author" : [ "A. Biere" ],
      "venue" : "Handbook of Satisfiability. IOS Press, 2009, pp. 457–481.",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Satisfiability modulo theories",
      "author" : [ "C.W. Barrett", "R. Sebastiani", "S.A. Seshia", "C. Tinelli" ],
      "venue" : "Handbook of Satisfiability. IOS Press, 2009, p. 825?885.",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "SMT-based bounded model checking for embedded ANSI-C software",
      "author" : [ "L. Cordeiro", "B. Fischer", "J. Marques-Silva" ],
      "venue" : "IEEE Transactions on Software Engineering, vol. 38, no. 4, pp. 957–974, July 2012.",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Handling loops in bounded model checking of C programs via k-induction",
      "author" : [ "M.Y.R. Gadelha", "H.I. Ismail", "L.C. Cordeiro" ],
      "venue" : "STTT, vol. 19, no. 1, pp. 97–114, 2017. [Online]. Available: https://doi.org/10.1007/s10009-015-0407-9",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2017
    }, {
      "title" : "Bounded model checking of C++ programs based on the qt crossplatform framework",
      "author" : [ "F.R. Monteiro", "M. Garcia", "L.C. Cordeiro", "E.B. de Lima Filho" ],
      "venue" : "Softw. Test., Verif. Reliab., vol. 27, no. 3, 2017. [Online]. Available: https://doi.org/10.1002/stvr.1632",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2017
    }, {
      "title" : "SMT-based bounded model checking of multithreaded software in embedded systems",
      "author" : [ "L.C. Cordeiro" ],
      "venue" : "Ph.D. dissertation, University of Southampton, UK, 2011. [Online]. Available: http://eprints.soton.ac.uk/186011/",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Syntaxguided synthesis",
      "author" : [ "R. Alur", "R. Bodik", "G. Juniwal", "M.M.K. Martin", "M. Raghothaman", "S.A. Seshia", "R. Singh", "A. Solar-Lezama", "E. Torlak", "A. Udupa" ],
      "venue" : "Formal Methods in Computer-Aided Design, 2013, pp. 1–8.",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Recently, mobile robots have been employed for various tasks, replacing humans in dangerous and monotonous tasks with a certain degree of efficiency and safety [1]–[3].",
      "startOffset" : 160,
      "endOffset" : 163
    }, {
      "referenceID" : 2,
      "context" : "Recently, mobile robots have been employed for various tasks, replacing humans in dangerous and monotonous tasks with a certain degree of efficiency and safety [1]–[3].",
      "startOffset" : 164,
      "endOffset" : 167
    }, {
      "referenceID" : 3,
      "context" : "The basic path planning problem can be described as the computation of robot positions and motions, which allow the robot to autonomously move from one starting point to a final desired position, performing a specific task and avoiding possible obstacles [4].",
      "startOffset" : 255,
      "endOffset" : 258
    }, {
      "referenceID" : 4,
      "context" : "There are several methods in the literature that are usually employed for path planning [5]–[11].",
      "startOffset" : 88,
      "endOffset" : 91
    }, {
      "referenceID" : 9,
      "context" : "There are several methods in the literature that are usually employed for path planning [5]–[11].",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 10,
      "context" : "[12] classify the path planning method in five main categories: sampling-based, node-based optimal, mathematical model-based, bioinspired, and multifusion-based algorithms.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : ", genetic algorithm (GA) [5]–[7], A* [8], particle swarm optimization (PSO) [9], nonlinear programming (NLP) [10], and ant colony [11].",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 6,
      "context" : ", genetic algorithm (GA) [5]–[7], A* [8], particle swarm optimization (PSO) [9], nonlinear programming (NLP) [10], and ant colony [11].",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 7,
      "context" : ", genetic algorithm (GA) [5]–[7], A* [8], particle swarm optimization (PSO) [9], nonlinear programming (NLP) [10], and ant colony [11].",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 8,
      "context" : ", genetic algorithm (GA) [5]–[7], A* [8], particle swarm optimization (PSO) [9], nonlinear programming (NLP) [10], and ant colony [11].",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 9,
      "context" : ", genetic algorithm (GA) [5]–[7], A* [8], particle swarm optimization (PSO) [9], nonlinear programming (NLP) [10], and ant colony [11].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 11,
      "context" : "[13], [14], which is a Boolean Satisfiability (SAT) and Satisfiability Modulo Theories (SMT) based optimization algorithm that executes iteratively to achieve global optimization via counterexamples produced by SAT and SMT solvers.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[13], [14], which is a Boolean Satisfiability (SAT) and Satisfiability Modulo Theories (SMT) based optimization algorithm that executes iteratively to achieve global optimization via counterexamples produced by SAT and SMT solvers.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 11,
      "context" : "Previous studies [13], [14], showed that CEGIO is able to ensure the global optimization of various non-trivial functions classes (e.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 12,
      "context" : "Previous studies [13], [14], showed that CEGIO is able to ensure the global optimization of various non-trivial functions classes (e.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 13,
      "context" : "Depending on the cost function nature, the optimization problem can be difficult to solve, given the time and memory constraints [15], even if we use SAT and SMT solvers [16].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 14,
      "context" : "Depending on the cost function nature, the optimization problem can be difficult to solve, given the time and memory constraints [15], even if we use SAT and SMT solvers [16].",
      "startOffset" : 170,
      "endOffset" : 174
    }, {
      "referenceID" : 10,
      "context" : "Such path is a curve without time continuous consideration and it is composed of various segments, usually called by trajectories [12].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 3,
      "context" : ", completeness, optimally, correctness, robustness, and computational complexity [4].",
      "startOffset" : 81,
      "endOffset" : 84
    }, {
      "referenceID" : 10,
      "context" : ", obstacle avoidance), but also an optimal path [12].",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 15,
      "context" : "Model checking is an automated verification procedure to exhaustively check all (reachable) systems states [17].",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 16,
      "context" : "1) Bounded Model Checking (BMC): BMC is an important verification technique, which is based on SAT [18] or SMT [19] solvers.",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 17,
      "context" : "1) Bounded Model Checking (BMC): BMC is an important verification technique, which is based on SAT [18] or SMT [19] solvers.",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 18,
      "context" : "BMC has been successfully applied to verify single- and multi-threaded programs [20]–[23].",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 21,
      "context" : "BMC has been successfully applied to verify single- and multi-threaded programs [20]–[23].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 16,
      "context" : "has a counterexample of depth less than or equal to k [18].",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 22,
      "context" : "This class of techniques is defined here as counterexample guided inductive optimization (CEGIO), which is inspired by the syntax-guided synthesis (SyGuS) to perform inductive generalization based on counterexamples provided by a verification oracle [24].",
      "startOffset" : 250,
      "endOffset" : 254
    }, {
      "referenceID" : 11,
      "context" : "CEGIO is able to successfully optimize a wide range of functions, including non-linear and non-convex optimization problems based on SAT and SMT solvers, in which data provided by counterexamples are employed to guide the verification engine, thus reducing the optimization domain [13].",
      "startOffset" : 281,
      "endOffset" : 285
    }, {
      "referenceID" : 3,
      "context" : "As observed by other researchers, it is a challenge to find the optimal path in a region, since the number of activities and obstacles types in the environment can substantially increase the path planning problem complexity [4].",
      "startOffset" : 224,
      "endOffset" : 227
    }, {
      "referenceID" : 12,
      "context" : "[14] proposed three different algorithm types based on CEGIO, which are suitable for different situations: the Generalized Algorithm (CEGIO-G), the Simplified Algorithm (CEGIO-S), and the Fast Algorithm (CEGIO-F).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[14], which show considerable improvement regarding optimization times.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "piλ (L) = (1−λ )Pi+λPi+1,∀λ ∈ [0,1].",
      "startOffset" : 30,
      "endOffset" : 35
    }, {
      "referenceID" : 11,
      "context" : "The verification process consists of three steps: modeling, especification, and verification [13].",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 1,
      "context" : "5} ; / / o b s t a c l e s r a d i u s i n t main ( ) { i n t i , j ; i n t A [DIM] = {1∗p , 1∗p} ; / / s t a r t p o i n t i n t B [DIM] = {9∗p , 9∗p} ; / / t a r g e t p o i n t / / e n v i r onmen t a l l i m i t s i n t l im [DIM] [ 2 ] = { 0∗p , 10∗p , 0∗p , 10∗p} ; / / s t a t e s d e c l a r a t i o n , x=x [ i ] [ 0 ] and y=x [ i ] [ 1 ] / / as non−d e t e r m i n i s t i c f o r ( i =0 ; i<n ; i ++) f o r ( j =0 ; j<DIM; j ++) x [ i ] [ j ] = n o n d e t i n t ( ) ; / / c o n s t r a i n t s on env i r onmen t l i m i t s and o b s t a c l e s f o r ( i =0 ; i<n ; i ++) { ESBMC assume ( x [ i ] [ 0 ] >= l im [ 0 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 0 ] <= l im [ 0 ] [ 1 ] ) ; ESBMC assume ( x [ i ] [ 1 ] >= l im [ 1 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 1 ] <= l im [ 1 ] [ 1 ] ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (A, 0 , x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; f o r ( i =1 ; i<n ; i ++) { f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s ( x [ i −1] , i , x0 [ j ]∗p , y0 [ j ]∗p , r [ j ]∗ p ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (B , n−1,x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; / / compute t h e c o s t f u n c t i o n f l o a t Aux1 [DIM] , Aux2 [DIM ] ; f l o a t J = 0 .",
      "startOffset" : 235,
      "endOffset" : 240
    }, {
      "referenceID" : 0,
      "context" : "5} ; / / o b s t a c l e s r a d i u s i n t main ( ) { i n t i , j ; i n t A [DIM] = {1∗p , 1∗p} ; / / s t a r t p o i n t i n t B [DIM] = {9∗p , 9∗p} ; / / t a r g e t p o i n t / / e n v i r onmen t a l l i m i t s i n t l im [DIM] [ 2 ] = { 0∗p , 10∗p , 0∗p , 10∗p} ; / / s t a t e s d e c l a r a t i o n , x=x [ i ] [ 0 ] and y=x [ i ] [ 1 ] / / as non−d e t e r m i n i s t i c f o r ( i =0 ; i<n ; i ++) f o r ( j =0 ; j<DIM; j ++) x [ i ] [ j ] = n o n d e t i n t ( ) ; / / c o n s t r a i n t s on env i r onmen t l i m i t s and o b s t a c l e s f o r ( i =0 ; i<n ; i ++) { ESBMC assume ( x [ i ] [ 0 ] >= l im [ 0 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 0 ] <= l im [ 0 ] [ 1 ] ) ; ESBMC assume ( x [ i ] [ 1 ] >= l im [ 1 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 1 ] <= l im [ 1 ] [ 1 ] ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (A, 0 , x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; f o r ( i =1 ; i<n ; i ++) { f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s ( x [ i −1] , i , x0 [ j ]∗p , y0 [ j ]∗p , r [ j ]∗ p ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (B , n−1,x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; / / compute t h e c o s t f u n c t i o n f l o a t Aux1 [DIM] , Aux2 [DIM ] ; f l o a t J = 0 .",
      "startOffset" : 342,
      "endOffset" : 347
    }, {
      "referenceID" : 0,
      "context" : "5} ; / / o b s t a c l e s r a d i u s i n t main ( ) { i n t i , j ; i n t A [DIM] = {1∗p , 1∗p} ; / / s t a r t p o i n t i n t B [DIM] = {9∗p , 9∗p} ; / / t a r g e t p o i n t / / e n v i r onmen t a l l i m i t s i n t l im [DIM] [ 2 ] = { 0∗p , 10∗p , 0∗p , 10∗p} ; / / s t a t e s d e c l a r a t i o n , x=x [ i ] [ 0 ] and y=x [ i ] [ 1 ] / / as non−d e t e r m i n i s t i c f o r ( i =0 ; i<n ; i ++) f o r ( j =0 ; j<DIM; j ++) x [ i ] [ j ] = n o n d e t i n t ( ) ; / / c o n s t r a i n t s on env i r onmen t l i m i t s and o b s t a c l e s f o r ( i =0 ; i<n ; i ++) { ESBMC assume ( x [ i ] [ 0 ] >= l im [ 0 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 0 ] <= l im [ 0 ] [ 1 ] ) ; ESBMC assume ( x [ i ] [ 1 ] >= l im [ 1 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 1 ] <= l im [ 1 ] [ 1 ] ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (A, 0 , x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; f o r ( i =1 ; i<n ; i ++) { f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s ( x [ i −1] , i , x0 [ j ]∗p , y0 [ j ]∗p , r [ j ]∗ p ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (B , n−1,x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; / / compute t h e c o s t f u n c t i o n f l o a t Aux1 [DIM] , Aux2 [DIM ] ; f l o a t J = 0 .",
      "startOffset" : 684,
      "endOffset" : 689
    }, {
      "referenceID" : 0,
      "context" : "5} ; / / o b s t a c l e s r a d i u s i n t main ( ) { i n t i , j ; i n t A [DIM] = {1∗p , 1∗p} ; / / s t a r t p o i n t i n t B [DIM] = {9∗p , 9∗p} ; / / t a r g e t p o i n t / / e n v i r onmen t a l l i m i t s i n t l im [DIM] [ 2 ] = { 0∗p , 10∗p , 0∗p , 10∗p} ; / / s t a t e s d e c l a r a t i o n , x=x [ i ] [ 0 ] and y=x [ i ] [ 1 ] / / as non−d e t e r m i n i s t i c f o r ( i =0 ; i<n ; i ++) f o r ( j =0 ; j<DIM; j ++) x [ i ] [ j ] = n o n d e t i n t ( ) ; / / c o n s t r a i n t s on env i r onmen t l i m i t s and o b s t a c l e s f o r ( i =0 ; i<n ; i ++) { ESBMC assume ( x [ i ] [ 0 ] >= l im [ 0 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 0 ] <= l im [ 0 ] [ 1 ] ) ; ESBMC assume ( x [ i ] [ 1 ] >= l im [ 1 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 1 ] <= l im [ 1 ] [ 1 ] ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (A, 0 , x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; f o r ( i =1 ; i<n ; i ++) { f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s ( x [ i −1] , i , x0 [ j ]∗p , y0 [ j ]∗p , r [ j ]∗ p ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (B , n−1,x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; / / compute t h e c o s t f u n c t i o n f l o a t Aux1 [DIM] , Aux2 [DIM ] ; f l o a t J = 0 .",
      "startOffset" : 717,
      "endOffset" : 722
    }, {
      "referenceID" : 0,
      "context" : "5} ; / / o b s t a c l e s r a d i u s i n t main ( ) { i n t i , j ; i n t A [DIM] = {1∗p , 1∗p} ; / / s t a r t p o i n t i n t B [DIM] = {9∗p , 9∗p} ; / / t a r g e t p o i n t / / e n v i r onmen t a l l i m i t s i n t l im [DIM] [ 2 ] = { 0∗p , 10∗p , 0∗p , 10∗p} ; / / s t a t e s d e c l a r a t i o n , x=x [ i ] [ 0 ] and y=x [ i ] [ 1 ] / / as non−d e t e r m i n i s t i c f o r ( i =0 ; i<n ; i ++) f o r ( j =0 ; j<DIM; j ++) x [ i ] [ j ] = n o n d e t i n t ( ) ; / / c o n s t r a i n t s on env i r onmen t l i m i t s and o b s t a c l e s f o r ( i =0 ; i<n ; i ++) { ESBMC assume ( x [ i ] [ 0 ] >= l im [ 0 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 0 ] <= l im [ 0 ] [ 1 ] ) ; ESBMC assume ( x [ i ] [ 1 ] >= l im [ 1 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 1 ] <= l im [ 1 ] [ 1 ] ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (A, 0 , x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; f o r ( i =1 ; i<n ; i ++) { f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s ( x [ i −1] , i , x0 [ j ]∗p , y0 [ j ]∗p , r [ j ]∗ p ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (B , n−1,x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; / / compute t h e c o s t f u n c t i o n f l o a t Aux1 [DIM] , Aux2 [DIM ] ; f l o a t J = 0 .",
      "startOffset" : 731,
      "endOffset" : 736
    }, {
      "referenceID" : 0,
      "context" : "5} ; / / o b s t a c l e s r a d i u s i n t main ( ) { i n t i , j ; i n t A [DIM] = {1∗p , 1∗p} ; / / s t a r t p o i n t i n t B [DIM] = {9∗p , 9∗p} ; / / t a r g e t p o i n t / / e n v i r onmen t a l l i m i t s i n t l im [DIM] [ 2 ] = { 0∗p , 10∗p , 0∗p , 10∗p} ; / / s t a t e s d e c l a r a t i o n , x=x [ i ] [ 0 ] and y=x [ i ] [ 1 ] / / as non−d e t e r m i n i s t i c f o r ( i =0 ; i<n ; i ++) f o r ( j =0 ; j<DIM; j ++) x [ i ] [ j ] = n o n d e t i n t ( ) ; / / c o n s t r a i n t s on env i r onmen t l i m i t s and o b s t a c l e s f o r ( i =0 ; i<n ; i ++) { ESBMC assume ( x [ i ] [ 0 ] >= l im [ 0 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 0 ] <= l im [ 0 ] [ 1 ] ) ; ESBMC assume ( x [ i ] [ 1 ] >= l im [ 1 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 1 ] <= l im [ 1 ] [ 1 ] ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (A, 0 , x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; f o r ( i =1 ; i<n ; i ++) { f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s ( x [ i −1] , i , x0 [ j ]∗p , y0 [ j ]∗p , r [ j ]∗ p ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (B , n−1,x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; / / compute t h e c o s t f u n c t i o n f l o a t Aux1 [DIM] , Aux2 [DIM ] ; f l o a t J = 0 .",
      "startOffset" : 770,
      "endOffset" : 775
    }, {
      "referenceID" : 0,
      "context" : "5} ; / / o b s t a c l e s r a d i u s i n t main ( ) { i n t i , j ; i n t A [DIM] = {1∗p , 1∗p} ; / / s t a r t p o i n t i n t B [DIM] = {9∗p , 9∗p} ; / / t a r g e t p o i n t / / e n v i r onmen t a l l i m i t s i n t l im [DIM] [ 2 ] = { 0∗p , 10∗p , 0∗p , 10∗p} ; / / s t a t e s d e c l a r a t i o n , x=x [ i ] [ 0 ] and y=x [ i ] [ 1 ] / / as non−d e t e r m i n i s t i c f o r ( i =0 ; i<n ; i ++) f o r ( j =0 ; j<DIM; j ++) x [ i ] [ j ] = n o n d e t i n t ( ) ; / / c o n s t r a i n t s on env i r onmen t l i m i t s and o b s t a c l e s f o r ( i =0 ; i<n ; i ++) { ESBMC assume ( x [ i ] [ 0 ] >= l im [ 0 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 0 ] <= l im [ 0 ] [ 1 ] ) ; ESBMC assume ( x [ i ] [ 1 ] >= l im [ 1 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 1 ] <= l im [ 1 ] [ 1 ] ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (A, 0 , x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; f o r ( i =1 ; i<n ; i ++) { f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s ( x [ i −1] , i , x0 [ j ]∗p , y0 [ j ]∗p , r [ j ]∗ p ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (B , n−1,x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; / / compute t h e c o s t f u n c t i o n f l o a t Aux1 [DIM] , Aux2 [DIM ] ; f l o a t J = 0 .",
      "startOffset" : 784,
      "endOffset" : 789
    }, {
      "referenceID" : 0,
      "context" : "5} ; / / o b s t a c l e s r a d i u s i n t main ( ) { i n t i , j ; i n t A [DIM] = {1∗p , 1∗p} ; / / s t a r t p o i n t i n t B [DIM] = {9∗p , 9∗p} ; / / t a r g e t p o i n t / / e n v i r onmen t a l l i m i t s i n t l im [DIM] [ 2 ] = { 0∗p , 10∗p , 0∗p , 10∗p} ; / / s t a t e s d e c l a r a t i o n , x=x [ i ] [ 0 ] and y=x [ i ] [ 1 ] / / as non−d e t e r m i n i s t i c f o r ( i =0 ; i<n ; i ++) f o r ( j =0 ; j<DIM; j ++) x [ i ] [ j ] = n o n d e t i n t ( ) ; / / c o n s t r a i n t s on env i r onmen t l i m i t s and o b s t a c l e s f o r ( i =0 ; i<n ; i ++) { ESBMC assume ( x [ i ] [ 0 ] >= l im [ 0 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 0 ] <= l im [ 0 ] [ 1 ] ) ; ESBMC assume ( x [ i ] [ 1 ] >= l im [ 1 ] [ 0 ] ) ; ESBMC assume ( x [ i ] [ 1 ] <= l im [ 1 ] [ 1 ] ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (A, 0 , x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; f o r ( i =1 ; i<n ; i ++) { f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s ( x [ i −1] , i , x0 [ j ]∗p , y0 [ j ]∗p , r [ j ]∗ p ) ; } f o r ( j =0 ; j<no ; j ++) r e s t p o i n t s (B , n−1,x0 [ j ]∗ p , y0 [ j ]∗p , r [ j ]∗ p ) ; / / compute t h e c o s t f u n c t i o n f l o a t Aux1 [DIM] , Aux2 [DIM ] ; f l o a t J = 0 .",
      "startOffset" : 790,
      "endOffset" : 795
    }, {
      "referenceID" : 12,
      "context" : "[14], since the cost function is convex.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 257,
      "endOffset" : 260
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 269,
      "endOffset" : 274
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 347,
      "endOffset" : 352
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 431,
      "endOffset" : 436
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 445,
      "endOffset" : 448
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 458,
      "endOffset" : 462
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 487,
      "endOffset" : 492
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 501,
      "endOffset" : 504
    }, {
      "referenceID" : 0,
      "context" : "( 6 ) ESBMC assume ( ( x [ i ][0]− x0 )∗ ( x [ i ][0]− x0 ) + ( x [ i ][1]− y0 )∗ ( x [ i ][1]− y0 ) > ( r +s igma )∗ ( r +s igma ) ) ; f l o a t a , b , c ; i f ( P1[0]− x [ i ] [ 0 ]==0 ){ a = 1 ; b = 0 ; c = −P1 [ 0 ] ; } e l s e{ a = ( f l o a t ) ( P1 [1]−x [ i ] [ 1 ] ) / ( P1[0]− x [ i ] [ 0 ] ) ; b = −1; c = ( f l o a t ) −a∗P1 [0 ]+ P1 [ 1 ] ; } f l o a t Py = ( a∗a∗y0−a∗b∗x0−b∗c ) / ( a∗a+b∗b ) ; i f ( ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [1 ] )>=0) && ( ( Py−x [ i ] [ 1 ] ) / ( P1[1]− x [ i ] [ 1 ] ) <=1 ) ) ) { f l o a t d=( f l o a t ) abs2 ( a∗x0+b∗y0+c ) / s q r t 2 ( a∗a+b∗b ) ; ESBMC assume ( d > r ) ; } }",
      "startOffset" : 514,
      "endOffset" : 519
    } ],
    "year" : 2017,
    "abstractText" : "We describe and evaluate a novel optimization-based off-line path planning algorithm for mobile robots based on the Counterexample-Guided Inductive Optimization (CEGIO) technique. CEGIO iteratively employs counterexamples generated from Boolean Satisfiability (SAT) and Satisfiability Modulo Theories (SMT) solvers, in order to guide the optimization process and to ensure global optimization. This paper marks the first application of those solvers for planning mobile robot path. In particular, CEGIO has been successfully applied to obtain optimal two-dimensional paths for autonomous mobile robots using off-the-shelf SAT and SMT solvers.",
    "creator" : "LaTeX with hyperref package"
  }
}