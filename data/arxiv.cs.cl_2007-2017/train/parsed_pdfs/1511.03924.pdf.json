{
  "name" : "1511.03924.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Multilingual FrameNet-based Grammar and Lexicon for Controlled Natural Language",
    "authors" : [ "Normunds Gruzitis", "Dana Dannélls" ],
    "emails" : [ "normunds.gruzitis@cse.gu.se,", "normunds.gruzitis@lu.lv" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n51 1.\n03 92\n4v 1\n[ cs\n.C L\n] 1\nKeywords FrameNet · Grammatical Framework · Multilinguality · Natural Language Generation · Controlled Natural Language\nThis work has been supported by the Swedish Research Council under Grant No. 2012-5746 (Reliable Multilingual Digital Communication: Methods and Applications) and by the Centre for Language Technology in Gothenburg. The research leading to these results has received funding also from the Latvian State Research Programme NexIT (Project No. 1).\nN. Gruzitis University of Gothenburg, Department of Computer Science and Engineering University of Latvia, Institute of Mathematics and Computer Science E-mail: normunds.gruzitis@cse.gu.se, normunds.gruzitis@lu.lv\nD. Dannélls University of Gothenburg, Department of Swedish"
    }, {
      "heading" : "1 Introduction",
      "text" : "Kuhn (2014) defines Controlled Natural Language (CNL) as “a constructed language that is based on a certain natural language, being more restrictive concerning lexicon, syntax, and/or semantics, while preserving most of its natural properties.” In our work, we deviate from this definition in two aspects. First, our intention is to produce a reusable grammar that covers a restricted subset of a natural language instead of a grammar of a predefined constructed language. Second, we produce a currently bilingual but potentially multilingual grammar library which is therefore not based on exactly one natural language but has a shared semantic abstract syntax. Thus, we do not provide a CNL as such but a high-level API (application programming interface) for the facilitation of the development of CNL grammars, making them more flexible – easier to modify and extend. In a sense, we aim at bridging the gap between controlled and natural language.\nA more general aim of this research is to make existing FrameNet (FN) resources uniformly and computationally accessible for multilingual natural language generation (NLG) and controlled semantic parsing via a shared semanticosyntactic grammar and lexicon API. We particularly consider the development of CNL interfaces to knowledge bases for authoring and verbalizing facts in a specific domain. For example, Figure 1 illustrates a predictive multilingual CNL editor for authoring object descriptions in the cultural heritage domain. The detailed syntactic constructors for building the verb phrases and clauses have been manually specified for each language. The FN-based API aims to diminish the manual efforts by providing more abstract – frame semantic – constructors, e.g. Create physical artwork that takes arguments Representation and Creator, and a target verb. The future potential of our approach is to provide a means for multilingual verbalization of FN-annotated knowledge bases that have been populated by FN-based information extraction systems (Das et al, 2014) and that could be automatically mapped to the appropriate frame constructors, similarly as sketched by Barzdins (2014).\nAt the CNL 2012 workshop, we proposed a conception of a general-purpose semantic grammar based on FrameNet (Gruzitis et al, 2012). The proposed approach builds on the technology of Grammatical Framework (GF). GF (Ranta, 2004), a type-theoretical grammar formalism and a toolkit, offers a wide-coverage resource grammar library (RGL) for currently 30 languages which implement a shared syntactic API (Ranta, 2009). The idea behind the FrameNet-based grammar is to provide a frame semantic abstraction layer, a shared semantic API, over the syntactic API of GF RGL.\nFollowing this conception, we successfully extracted a shared abstract syntax of wide-coverage English and Swedish grammars from FN-annotated corpora (Dannélls and Gruzitis, 2014a). Soon after, we presented a more elaborated approach to automatic extraction and generation of both the shared abstract syntax and the concrete syntaxes of the proposed grammar (Dannélls and Gruzitis, 2014b). In this article, we give an extended and updated presentation of the work published in the previous two papers. Additionally, we provide the design and implementation details of FN-based lexicons for English and Swedish that are also extracted from the annotated corpora. The experiments and tests presented here are based on the Berkeley FrameNet release 1.5 which is available as of September 2010,1 and a snapshot of the Swedish FrameNet development version taken in December 2014.2\nOur approach is outlined in Figure 2. From the linguistic point of view, the particular characteristic is that we focus on the core argument structures (according to FrameNet), the arguments are combined compositionally, a verb is expected as the target word, and the word order is controlled according to the dominant corpus evidence. Although we focus on English and Swedish, the same approach is intended to be applicable to other languages as well. As a side result, we suggest a unified method for comparing and mapping semantic and syntactic valence patterns and lexical units across framenets.\nThe structure of this article is as follows. In Section 2, we provide background information about FrameNet and Grammatical Framework. Details of the FN-\n1 https://framenet.icsi.berkeley.edu/fndrupal/framenet_data 2 http://remu.grammaticalframework.org/framenet/SweFN_2014-12-03.zip\nbased approach, the experiment series and the implementation of the grammar are given in Section 3. The FN-based lexicon is further detailed in Section 4. These are followed by an illustration of the use of the FN-based API in two multilingual CNL applications in Section 5. We provide an evaluation of our method in Section 6 followed by a discussion in Section 7. Previous approaches to semantic multilingual CNL grammars are briefly discussed in Section 8. We conclude the article in Section 9."
    }, {
      "heading" : "2 Background",
      "text" : "2.1 Berkeley FrameNet (BFN)\nBerkeley FrameNet (Fillmore et al, 2003) is a lexico-semantic resource based on the theory of frame semantics (Fillmore, 1985).3 According to this theory, a semantic frame representing a cognitive scenario is characterized in terms of frame elements (FE) and is evoked by target words called lexical units (LU).\nFEs are classified in four groups: core, core unexpressed, peripheral and extrathematic (Ruppenhofer et al, 2010). A set of core FE instantiates the conceptually necessary components of a frame, and uniquely characterizes the frame, making it different from other frames. Core unexpressed FEs are core FEs that may not be used in descendant frames. FEs, such as Time, Place, Manner, that do not uniquely characterize a frame, and can be instantiated in any semantically appropriate frame are classified as peripheral. Extra-thematic FEs do not have a frame-specific understanding, unlike core and peripheral FEs.\nIn our work, we distinguish two classes of FEs: core that includes core unexpressed, and non-core that includes peripheral and extra-thematic. Core FEs syntactically tend to correspond to verb arguments, in contrast to non-core FEs that typically are adjuncts.\nAs an example, consider the frame Desiring given in Table 1 where we find: (i) the definition of the frame, a lexicographic description of the scenario it represents, and (ii) lists of core and non-core FEs, the semantic roles.\nAn LU entry is a pairing of a lemma and a frame, and it carries both the semantic and the syntactic valence information about the possible realizations of the FEs participating in the frame. The syntactic valence is language-specific, and the valence patterns are derived from FN-annotated corpora. The syntactic constituents of the example sentences are annotated according to COMLEX Syntax\n3 https://framenet.icsi.berkeley.edu/\n(Meyers et al, 1995). To take an example, consider the valence patterns for the verb want given in Table 2.\nThere have been also experiments on automatic alignment of LUs in BFN to synsets in Princeton WordNet (Ferrández et al, 2010), a complementary resource that would help to extend the coverage of BFN, and link LUs across languages. These links, however, are not available as a part of the FrameNet data release.\nThe FrameNet approach to frame semantics, approbated in BFN, provides a benchmark for representing large amounts of word senses and word usage patterns through the linguistic annotation of corpus examples, therefore the exploitation of FN-like resources has been appealing for a range of advanced NLP applications such as semantic parsing (Das et al, 2014), information extraction (Moschitti et al, 2003) and natural language generation (Roth and Frank, 2009). There are FNs available for German, Japanese, Spanish (Boas, 2009) and Swedish (Borin et al, 2010). More initiatives exist for other languages. In this article, we consider Berkeley FrameNet and Swedish FrameNet.\n2.2 Swedish FrameNet (SweFN)\nSwedish FrameNet has been developed within the Swedish FrameNet++ project at Spr̊akbanken (Borin et al, 2010).4 One of the aims of the project was to integrate a number of existing Swedish lexical resources and harmonize the information they contain. All the integrated resources are linked to the lexical entries of SALDO (Borin et al, 2013), an association lexicon which contains morphological and lexical-semantic information for more than 125,000 Swedish words of which 13,000 are verbs.5 SALDO is therefore considered as the pivot of these integrated Swedish lexical resources.\nIntegrated lexical resources linked to one pivot lexicon have the advantage of yielding large amount of information. Some of the information we gain access to is syntactic valence information for verbs from SIMPLE and PAROLE lexicons (Lenci et al, 2000), and synsets and senses from WordNet.6\nThe SweFN resource has been expanded from BFN, which means it follows the same structure and theoretical principles that have been taken in BFN. For example, the description of the frame Desiring shown in Table 1 is the same\n4 http://spraakbanken.gu.se/swefn/ 5 http://spraakbanken.gu.se/saldo 6 http://spraakbanken.gu.se/swe/resurs/wordnet-saldo\nalso in SweFN. This is the language independent aspect. Regarding the language dependent aspect, there are other, more practical differences between the resources. These differences concern the content of the frames including: lexical units from SALDO, compound pattern analysis and examples, syntactic annotations of the example sentences, and domain specification of frames.\nSome of the LUs, e.g. the SALDO entries, that evoke the frame Desiring are: känna för.vb.1 ‘to feel like’, längta.vb.1 ‘to yearn’, vilja.vb.1 ‘to want’, åtr̊a.vb.1 ‘to desire’, begärelse.nn.1 ‘wish’, åtr̊a.nn.2 ‘desire’. The number indicates SALDO’s sense identifier, ‘vb’ and ‘nn’ indicate the part-of-speech (POS) tags.\nAll example sentences in SweFN are syntactically annotated with the Swedish version of MaltParser for depedency structures (Nivre et al, 2004). The annotation scheme is based on KORP, Spr̊akbanken’s corpus infrastructure, part-of-speech and morphosyntactic markup tag sets (Borin et al, 2012).7 Table 3 shows some semantic valence patterns and their syntactic realizations for the verb känna för ‘to feel like’.\nAs we mentioned, SweFN mostly uses the BFN frame inventory, however, around 50 additional frames are introduced in SweFN, and around 15 BFN frames have been modified. What characterizes the modified frames is change of core FEs and change of the frame content that is either more specific or less specific.\n2.3 Grammatical Framework (GF)\nThe presented grammar is implemented in GF, a categorial grammar formalism specialized for multilingual (parallel) grammars (Ranta, 2004). One of the key features of GF grammars is the separation between an abstract syntax and concrete syntaxes. The abstract syntax defines the language-independent structure, the semantics of a domain-specific application grammar or a general-purpose grammar library, while the concrete syntaxes define the language-specific syntactic and lexical realization of the abstract syntax.\nRemarkably, GF is not only a grammar formalism or a programming language. It also provides a reusable general-purpose resource grammar library (RGL) for currently 30 languages that implement the same abstract syntax, a shared syntactic API (Ranta, 2009). The grammars implement common syntactic constructions and describe the inflectional morphology of a language. The use of the shared syntactic types and functions allows for rapid and rather flexible development of multilingual application grammars without the need of specifying low-level details\n7 http://spraakbanken.gu.se/eng/korp-info\nlike inflectional paradigms, syntactic agreement and word order. In order to hide the low-level details, RGL has a high-level interface that provides constructors like mkCl : NP → VP → Cl for building a clause from a NP and a VP.8"
    }, {
      "heading" : "3 FrameNet-Based Grammar",
      "text" : "The language-independent layer of FrameNet, i.e. frames and FEs – the semantic valence – is defined in the abstract syntax of the proposed multilingual grammar library, while the language-specific layers, i.e. the surface realization of frames and LUs – the syntactic valence – is defined in concrete syntaxes.9 The syntactic API of GF RGL is used for generalizing and unifying the grammatical types and constructions used in different framenets, which facilitates porting the implementation to other languages. The FrameNet-based grammar, in turn, provides a frame semantic abstraction layer to RGL, so that the application grammar developer can primarily manipulate with plain semantic constructors in combination with some simple syntactic constructors instead of comparatively complex syntactic constructors for building verb phrases (VP). Moreover, the frame constructors can be typically specified for all languages at once in the shared concrete syntax (functor) of an application grammar.\nIn this research, we consider only those frames for which there is at least one corpus example where the frame is evoked by a verb. In addition, we consider only core FEs which uniquely characterize the frame.\nBFN version 1.5 defines 1,020 frames, of which, according to our calculations, 559 are evoked by 3,254 verb LUs in 69,260 annotated sentences. As of December 2014, the SweFN development version covers 995 frames of which 660 are evoked by 2,887 verb LUs in 4,400 annotated sentences.\n3.1 Abstract Syntax\nTo acquire a common abstract syntax, a common semantic API,10 we have extracted a set of shared semantico-syntactic frame valence patterns from the annotated sentences in BFN and SweFN. For instance, the shared valence patterns for the frame Desiring are:\nDesiring/VAct Experiencer/NPnsubj Focal participant/Adv Desiring/V2Act Experiencer/NPnsubj Focal participant/NPdobj Desiring/VVAct Event/VP Experiencer/NPnsubj\nwhich correspond, for instance, to the following annotated examples in BFN:\n[Dexter ]Experiencer/NP [YEARNED ]V [for a cigarette]Focal participant/Adv [she]Experiencer/NP [WANTS ]V2 [a protector ]Focal participant/NP [I ]Experiencer/NP would n’t [WANT ]VV [to know ]Event/VP\n8 http://www.grammaticalframework.org/lib/doc/synopsis.html 9 https://github.com/GrammaticalFramework/gf-contrib/tree/master/framenet\n(The acquired grammar and lexicon; version 0.9.7 at the time of writing.) 10 http://www.grammaticalframework.org/framenet/\nThe actual BFN phrase types (NP, various subtypes of VP, PP and its subtypes, etc.) are generalized to the RGL types NP, VP, Adv, S and QS.11 Verb types (V, V2, V3, VV, VS, VQ, V2V, V2S and V2Q12) are inferred from the syntactic valence of LUs in the respective examples.\nIn addition to phrase types, the extracted valence patterns also specify inferred grammatical relations of NP-typed FEs: nsubj (subject), nsubjpass (passive subject), dobj (direct object) and iobj (indirect object) that correspond to the universal dependency relations (de Marneffe et al, 2014). Therefore, we also include the grammatical voice (Act/Pass13) in the pattern comparison and in pattern identifiers used in the abstract syntax. It is not necessary, however, to reflect the grammatical relations in the abstract syntax; this knowledge is taken into account in the pattern comparison and while generating the concrete syntaxes, but it is not required in order to use the resulting grammar as an API."
    }, {
      "heading" : "3.1.1 Sentence patterns versus normalized valence patterns",
      "text" : "The first step in the extraction of shared valence patterns is to convert the annotated corpus examples into more general and uniform sentence patterns – valence patterns that preserve the word-order (the order of FEs in a particular sentence), subcategorize FEs by the grammatical RGL types and include the universal grammatical relations of NP-typed FEs (both inferred from the particular sentence), include prepositions or cases that are used to realize Adv-typed FEs (for deciding on LU-specific or even frame-specific default values in the future), and include references to the target verbs (LUs). Duplicate sentence patterns are kept in the output for frequency counts.\nThe conversion process is language- and framenet-specific because there is no unified annotation model used across framenets. BFN and SweFN use not only different XML schemas and POS tagsets; they also use different approaches for annotating the syntactic structure of a sentence.\nIn BFN, a phrase-structure approach is used, which is complemented by few shallow grammatical relations: an external argument (a phrase outside the VP of the target verb), the first object in the active voice (either direct or indirect), and a general dependent. A simplified excerpt from the BFN corpus for the verb want evoking the frame Desiring is:\n<sentence>\n<text>Traders in the city want a change.</text> <annotationSet>\n<layer rank=\"1\" name=\"BNC\">\n<label start=\"0\" end=\"6\" name=\"NP0\"/> <label start=\"20\" end=\"23\" name=\"VVB\"/> <label start=\"25\" end=\"25\" name=\"AT0\"/>\n</layer>\n11 Where Adv is a VP-modifying adverb, S – an embedded declarative sentence, and QS – an embedded question. 12 Where V is a one-place verb, V2 – a two-place verb, V3 – a three-place verb, VV – a VP-complement verb, VS – an S-complement verb, VQ – a QS-complement verb, V2V – a verb with NP and VP complements, V2S – a verb with NP and S complements, and V2Q – a verb with NP and QS complements. 13 http://universaldependencies.github.io/docs/u/feat/Voice.html\n</annotationSet> <annotationSet status=\"MANUAL\">\n<layer rank=\"1\" name=\"FE\">\n<label start=\"0\" end=\"18\" name=\"Experiencer\"/> <label start=\"25\" end=\"32\" name=\"Event\"/>\n</layer> <layer rank=\"1\" name=\"GF\">\n<label start=\"0\" end=\"18\" name=\"Ext\"/> <label start=\"25\" end=\"32\" name=\"Obj\"/>\n</layer> <layer rank=\"1\" name=\"PT\">\n<label start=\"0\" end=\"18\" name=\"NP\"/> <label start=\"25\" end=\"32\" name=\"NP\"/>\n</layer> <layer rank=\"1\" name=\"Target\">\n<label start=\"20\" end=\"23\" name=\"Target\"/>\n</layer>\n</annotationSet>\n</sentence>\nIn SweFN, a dependency approach is used. A simplified excerpt from the SweFN corpus for the verb vilja ‘want’ evoking the frame Desiring is:14\n<sentence>\n<w pos=\"JJ\" ref=\"1\" dephead=\"2\" deprel=\"DT\">Nästa </w> <w pos=\"NN\" ref=\"2\" dephead=\"3\" deprel=\"TA\">gång </w> <w pos=\"VB\" ref=\"3\" deprel=\"ROOT\">skulle </w> <element name=\"Experiencer\">\n<w pos=\"PN\" ref=\"4\" dephead=\"3\" deprel=\"SS\">jag </w>\n</element> <element name=\"LU\">\n<w msd=\"VB.AKT\" ref=\"5\" dephead=\"3\" deprel=\"VG\">vilja </w>\n</element> <element name=\"Event\">\n<w msd=\"VB.INF\" ref=\"6\" dephead=\"5\" deprel=\"VG\">ha </w> <w pos=\"RG\" ref=\"7\" dephead=\"8\" deprel=\"DT\">sju </w> <w pos=\"NN\" ref=\"8\" dephead=\"6\" deprel=\"OO\">sångare </w>\n</element>\n</sentence>\nIt should be noted that a characteristic of BFN is that FEs which are missing in the sentence are still annotated if the grammar allows or requires the omission, or the identity/type of an FE is understood from the context (Ruppenhofer et al, 2010). Such FEs would be potentially interesting to consider, however, we ignore them as they have no grammatical annotations.\nBecause of the partial and often erroneous grammatical annotations, various framenet-specific rules and heuristics are applied for generalizing to RGL types, for inferring the grammatical voice and relations, and for partially correcting the automatic annotation errors.\nWhen the uniform sentence patterns are acquired for all languages, a common language- and framenet-independent processor is used in all the remaining steps, including the generation of the abstract and concrete syntaxes and lexicons.\n14 SweFN tags are described at http://stp.lingfil.uu.se/~nivre/swedish_treebank/\nSentence patterns are summarized and grouped into normalized valence patterns ignoring the word order and prepositions (or cases). As an example, a partial summary of patterns for the frame Desiring in BFN is:\nAct : 275\nEvent/VP Experiencer/NP.nsubj : 61\nExperiencer/NP.nsubj Event/VP : 59 Event/VP Experiencer/NP.nsubj : 2\nExperiencer/NP.nsubj Focal_participant/NP.dobj : 61\nExperiencer/NP.nsubj Focal_participant/NP.dobj : 55 Focal_participant/NP.dobj Experiencer/NP.nsubj : 6\nExperiencer/NP.nsubj Focal_participant/Adv : 43\nExperiencer/NP.nsubj Focal_participant/Adv[for ] : 26 Experiencer/NP.nsubj Focal_participant/Adv[after ] : 7 Experiencer/NP.nsubj Focal_participant/Adv : 2 ...\n...\nPass : 13\nExperiencer/NP.dobj Focal_participant/NP.nsubjpass : 5\nFocal_participant/NP.nsubjpass Experiencer/NP.dobj : 5\n...\nFor generating the abstract syntax, we consider only the normalized valence patterns. The most frequent sentence pattern of each normalized pattern contains sufficient information for generating the concrete syntax for the respective language."
    }, {
      "heading" : "3.1.2 Experiment series",
      "text" : "To roughly estimate the impact of certain decisions that have been made in the automatic extraction of the semantico-syntactic valence patterns, we have run a series of experiments with various settings:\n0.0 Extract sentence patterns using the framenet-specific grammatical types (baseline). 1.0 In addition to 0.0, skip examples containing currently unconsidered realizations of FEs, namely quotation and few subtypes of S (3.4% of BFN examples; no SweFN examples).15 2.0 In addition to 1.0, generalize the grammatical types according to GF RGL. 3.0 In addition to 2.0, skip once-used valence patterns (if the frame has at\nleast one pattern that is used more than once).\nwhere each series include two subseries:\nx.A Skip repeated FEs (mostly due to coordination, wh-words making discontinuous PPs, and anchors of relative clauses).16 x.B Skip non-core FEs and repeated FEs.\n15 Additionally, more than 100 examples are skipped in both corpora due to inconsistent semantico-syntactic annotations that were not fixed by the current heuristics. 16 If repeated FEs are of different RGL types, the whole example is currently skipped.\nThe results are summarized in Tables 4 and 5. We are primarily interested in Settings 2.B and 3.B which seem to be optimal for SweFN and BFN respectively: the number of covered frames slightly decreases, but it makes the resulting patterns more prototypical and significantly reduces the potential number of API functions to be generated in the abstract syntax. For a large corpus like BFN, skipping once-used valence patterns helps to reduce the propagation of annotation errors, but, for a relatively small corpus like SweFN, it is not reasonable. In the future, it would be reasonable, however, to include typical non-core FEs in the resulting valence patterns: this would slightly increase the average number of FEs from 2 to 3."
    }, {
      "heading" : "3.1.3 Shared valence patterns",
      "text" : "The extracted sets of semantico-syntactic valence patterns can vary across languages depending on corpora. Having multilingual applications in mind, we are primarily interested in valence patterns whose implementation can be generated, based on corpus evidence, for all considered languages. Thus, we focus on valence patterns that are shared between framenets. The multilingual criterion also helps in reducing the number of incorrectly derived patterns due to annotation errors introduced by the automatic POS tagging and syntactic parsing applied in both\nBFN and SweFN corpora. Frequent patterns that are not verified across framenets could be separated into language-specific extra modules of the library (in a similar way as it is done with some language-specific syntactic phenomena in RGL).\nTo find a representative yet condensed set of shared valence patterns, we compare the extracted normalized patterns by subsumption instead of equivalence. Pattern A subsumes pattern B if:\n1. A.frame = B.frame 2. A.verbType = B.verbType 3. A.grammaticalVoice = B.grammaticalVoice 4. B.FEs ⊆ A.FEs17\nIf A subsumes B and B subsumes A then A equals B. If a pattern of FN1 is subsumed by a pattern of FN2, it is added to the shared set (and vice versa). In the final shared set, patterns which are subsumed by other patterns in the set are removed. For instance, in the following example, P1 is subsumed by P2, P3 is subsumed by P1 and P2, P1 and P3 are to be removed:\nP1: Apply heat/V2Act Cook/NPnsubj Food/NPdobj P2: Apply heat/V2Act Container/Adv Cook/NPnsubj Food/NPdobj P3: Apply heat/V2Act Food/NPdobj\nThis approach is supported by the design of the FrameNet-based grammar which accepts an empty phrase as an argument to a frame building function if the corresponding FE is not expressed in the sentence.\nThe comparison is first done between BFN and SweFN sets of verb frames (Table 6) and then between sets of valence patterns that belong to the shared set (intersection) of verb frames (Table 7). For a number of shared frames, no shared valence patterns are found, therefore the final set of shared frames is smaller (Table 7). Intuitively, this is partly because of the size of SweFN (about 6 examples per frame in SweFN versus more than 115 examples per frame in BFN) and partly because of non-compositionality across languages.\nIn the result, from around 64,000 annotated sentences in BFN (Settings 3.B) and around 4,200 annotated sentences in SweFN (Settings 2.B), we have extracted\n17 Taking into account the grammatical types and relations.\na set of 869 shared valence patterns covering 483 frames. The result is a proper subset of what would be acquired if Settings 2.B were applied to BFN.\nThe 869 valence patterns reuse 541 semantico-syntactic types: 339 FEs of type NP, 159 FEs of type Adv, 17 FEs of type VP, 17 FEs of type S and 9 FEs of type QS. If considering only the semantic types, there are 429 different FEs."
    }, {
      "heading" : "3.1.4 Implementation",
      "text" : "The shared valence patterns are declared as frame building functions (henceforth called frame functions) that take one or more core FEs and one target verb as arguments. FEs are expected in the alphabetical order while the verb is always the last argument. The language-specific word order is specified in the concrete syntaxes.\nFor each frame, the set of core FEs is often split into several alternative functions according to the corpus evidence.18 Different subsets of core FEs may require different types of target verbs. We also differentiate between functions that return clauses in the passive voice from functions that return active voice clauses because the subject and object FEs swap their grammatical relations and/or the order19 that is not reflected in the abstract syntax. The verb type is always added as a suffix to the function name, and the voice tag is appended in the case of the passive voice. If this is not sufficient to make the function name unique, a discriminative number is appended as well. For instance, consider the following abstract functions derived from the extracted valence patterns given at the beginning of Section 3.1:\nfun Desiring V : Experiencer NP → Focal participant Adv → V → Clause fun Desiring VV : Event VP → Experiencer NP → VV → Clause fun Desiring V2 : Experiencer NP → Focal participant NP → V2 → Clause fun Desiring V2 Pass : Experiencer NP → Focal participant NP → V2 → Clause20\nIn GF, constituents and features of phrases are stored in objects of record types, and functions are applied to such objects to construct phrase trees. In the abstract syntax, both argument types and the value type of a function are separated by right associative arrows, i.e. all functions are curried. Arguments of a frame function are combined into an object of type Clause that differs from the RGL type Cl. A Clause whose linearization type is {np : NP; vp : VP} comprises two constituents of RGL types. It is a deconstructed Cl where the subject NP is separated from the rest of the clause. The motivation for this is to allow for nested frames (see Section 5.1) and for adding non-core FEs before combining the NP and VP parts into a clause (see Section 5.2).\nThe RGL-subcategorized FEs of the shared valence patterns are declared as common semantic types (categories). Although the conception of BFN states that\n18 It is often practically impossible or uncommon that all core FEs are used in the same sentence. For instance, Area is mutually exclusive with five other core FEs in the frame Motion, and these five other Adv-typed FEs normally are not used altogether. 19 E.g. in a highly inflected language. 20 Desiring V2 Pass is included for illustration but is not directly acquired from a shared pattern. Missing passive or active voice patterns could be acquired implicitly – deriving them from the corresponding active or passive voice patterns. However, for now we are strictly following the corpus evidence.\ncore FEs are unique to the frame, even though their names are not unique across frames, we do not make such a distinction at the level of types; they are implicitly made frame-specific by the frame functions. The only distinction is based on the syntactic realization.\nIn order to keep the FE names unique, the RGL types are added as suffixes:\ncat Event VP cat Experiencer NP cat Focal participant Adv cat Focal participant NP\nNote that the Focal participant is typically realized as a noun phrase, but some intransitive Desiring verbs require it as a prepositional phrase (PP), hence this FE is subcategorized using the RGL types NP and Adv (adverbial modifier). In GF, the type Adv covers both adverbs and PPs, and there is no separate type for PPs. Also note that all FEs are specified as optional arguments in the concrete syntaxes, i.e. any FE can be an empty phrase if it is not expressed in the sentence.\nThe frame-evoking target verb is always expected as the last, mandatory argument. We assume that verbs of the same type evoking the same frame share, in general, a subset of normalized semantico-syntactic valence patterns of that frame. Patterns requiring, for instance, a transitive verb cannot be evoked by an intransitive verb. Otherwise, the current approach does not limit the set of verbs that can evoke a frame, and the set of prepositions that can be used for an FE if it is realized as a PP. We expect that appropriate verbs and prepositions are specified by the application grammar that uses the FrameNet-based grammar as an API. Hence, this approach allows evoking a frame by a metaphor, i.e. an LU that normally evokes another frame.\nThe design and implementation of the abstract and concrete syntaxes of lexical entries is described in Section 4.\n3.2 Concrete Syntaxes\nThe exact behaviour (linearization) of types and functions declared in the abstract syntax is defined in the concrete syntax of each language.\nThe mapping from the semantic BFN types (FEs) to the syntactic RGL types is straightforward and is shared for all languages in a functor, for instance:\nlincat Event VP = Maybe VP lincat Focal participant NP = Maybe NP lincat Focal participant Adv = Maybe Adv\nTo allow for optional FEs (verb arguments that might not be expressed in the sentence), all linearization types are of type Maybe whose behaviour is similar to the analogous type in Haskell: a value of type Maybe x either contains a value of type x (represented as Just x ), or it is not provided (represented as Nothing).\nTo implement the frame functions, particularly, to fill the verb phrase part of Clause objects, RGL constructors are applied to the arguments depending on their grammatical types and relations, and the grammatical voice. The implementation of functions declared in Section 3.1.4 is systematically generated for English and Swedish as follows:\nlin Desiring V experiencer np focal participant adv v = { np = fromMaybe NP emptyNP experiencer np ; vp = mkVP (mkVP v) (fromMaybe Adv emptyAdv focal participant adv) }\nlin Desiring VV event vp experiencer np vv = { np = fromMaybe NP emptyNP experiencer np ; vp = mkVP vv (fromMaybe VP emptyVP event vp) }\nlin Desiring V2 experiencer np focal participant np v2 = { np = fromMaybe NP emptyNP experiencer np ; vp = mkVP v2 (fromMaybe NP emptyNP focal participant np) }\nlin Desiring V2 Pass experiencer np focal participant np v2 = { np = fromMaybe NP emptyNP focal participant np ; vp = mkVP\n(passiveVP v2) (mkAdv by8agent Prep (fromMaybe NP emptyNP experiencer np)) }\nTo the NP field of a Clause object, either the value of the corresponding NPnsubj or NPnsubjpass argument, or an empty string of type NP is assigned. This choice is handled by the helper function Maybe.fromMaybe that takes a Maybe value and returns a predefined empty phrase of the respective type if the Maybe value is not provided (Nothing); otherwise it returns the provided value. Optional verb complements are handled similarly.\nIn order to produce a value of the VP field, RGL constructorsmkVP, passiveVP, mkAdv etc. and RGL structural words by8agent Prep (prepositions by and av in English and Swedish respectively) etc. are applied, for instance:21\nmkVP : V → VP mkVP : V2 → NP → VP mkVP : VV → VP → VP mkVP : VP → Adv → VP\nThe RGL-based code templates used to implement the above functions can be systematically reused for many other frame functions. Given the set of shared valence patterns, there are only 32 syntactic patterns that cover all 869 semanticosyntactic patterns (Table 8). By syntactic valence patterns we mean patterns that specify only the grammatical types and relations of FEs, and the grammatical voice. As Table 8 shows, the syntactic patterns underlying functions Desiring V2, Desiring V, Desiring VV and Desiring V2 Pass already cover more that 54% of all the shared frame functions. For the same verb types (V, V2, VV), other syntactic patterns cover another 39% of frame functions for which the code templates are derived in several ways:\n– complements of Adv type are added by recursively applying the respective mkVP constructor, or they are eliminated at all;22 – the NP field of Clause is fixed to the empty string if the valence pattern does not include the subject FE (e.g. due to examples only in the imperative mood);23 – the agent FE that would be the subject in the active voice but is missing in the passive voice is fixed to the empty string.\nThe remaining less than 7% of the shared frame functions represent the use of other verb types – VS, VQ, V2V, V3 and V2S – for which the respective RGL constructors are applied:\nmkVP : VS → S → VP [I ]Cognizer/NP do [REMEMBER]VS [we did a few gigs]Content/S\nmkVP : VQ → QS → VP [he]Cognizer/NP [RECOGNIZED ]VS [where he was]Phenomenon/QS\nmkVP : V2V → NP → VP → VP [you]Speaker/NP specifically [REQUEST ]V2V [me]Addressee/NP [to do so]Message/VP\nmkVP : V3 → NP → NP → VP [you]Agent/NP [DENIED ]V3 [her ]Protagonist/NP [any life of her own]State of affairs/NP\nmkVP : V2S → NP → S → VP [he]Speaker/NP [PERSUADED ]V2S [himself ]Addressee/NP [that they helped ]Content/S\nNote that the type S, an embedded declarative sentence, is used only if the subclause can be paraphrased using the subjunction (Subj) that ; otherwise such FEs are subcategorized as Adv, and the application grammar has to specify the subjunction by applying the RGL constructor mkAdv : Subj → S → Adv.\nAlso note that FEs of type VP, S and QS, and Adv encapsulating S represent nested frames. We use the types S and QS instead of Cl and QCl to allow for specifying sentence level parameters like tense, anteriority and polarity of the nested frames.\nThe implementation of frame functions, although currently kept separate for each language, mostly could be shared in a functor thanks to the syntactic abstraction provided by RGL. In general, however, the order of Adv FEs differ across languages.\n21 http://www.grammaticalframework.org/lib/doc/synopsis.html 22 The order of Adv complements is based on the most frequent sentence pattern. 23 A missing subject FE, however, could be often automatically inferred and added."
    }, {
      "heading" : "4 FrameNet-Based Lexicon",
      "text" : "In GF, there is no formal distinction between syntactic rules and lexical entries. Lexical entries are represented by functions that normally take no arguments and usually but not necessarily return values of lexical categories (e.g. V versus VP).\nLUs between BFN and SweFN (and other framenets) are not explicitly aligned, therefore we first extract and generate a framenet-specific lexicon for each language. Second, we have conducted an experiment to automatically produce a shared lexicon by partially aligning LUs between BFN and SweFN.\n4.1 Abstract Syntaxes\nFollowing the design of the FrameNet-based grammar, LUs in our approach are subcategorized by GF RGL verb types, therefore for each LU there is one or more lexical entry in the lexicon.\nThe abstract lexical identifiers (function names) start with the language-specific base form of the verb. To distinguish between different types and senses of LUs, the verb type and the frame name is appended to the identifiers as illustrated in Tables 9 and 10.\nThe generation of the abstract language-specific lexicons is straightforward. Given the set of 869 shared valence patterns (Section 3.1.3), we select all the distinct target verbs from the sentence patterns (Section 3.1.1) that belong to the shared patterns. Then we append the corresponding verb type and frame name to the base form of the target verb and declare all the resulting identifiers as nullary functions returning verbs of the respective types.\nFrom the BFN corpus, we have extracted 2,831 LUs resulting in 3,432 lexical entries (due to alternative verb types). For Swedish, the numbers are 1,844 and 1,899 respectively. The ratio of lexical entries per LU is considerably smaller for Swedish (1.03 versus 1.21) because of the small number of SweFN examples per LU (around 1.5 versus around 20 in BFN; see Tables 4 and 5 in Section 3.1.2).\n4.2 Concrete Syntaxes\nIn order to generate concrete lexicons, first, we have to specify an appropriate inflectional paradigm for each verb independently of its potential senses (frames) and valence types. Inflectional paradigms are represented by language-specific constructors provided in the RGL ParadigmsL modules. Each constructor, which can be overloaded, expects specific verb forms as arguments from which all forms of the verb can be generated, for instance:\nirregV “feel” “felt” “felt” regV “want” mkV “yearn” “yearns” “yearned” “yearned” “yearning”\nirregV “känna” “kände” “känt” mkV “längtar” mkV “vilja” “vill” “vilj” “ville” “velat” “velad”\nThe first argument usually is the base form, but it can be another form from which the base form can be straightforwardly derived (e.g. längtar ‘[one] longs’).\nWe extract such verb-constructor pairs from the existing monolingual and multilingual RGL dictionaries and other modules (in the reverse order of preference):\n1. L /DictL (6,034 pairs for English, 7,324 for Swedish) 2. translator/DictionaryL (6,037 pairs for English, 2,430 for Swedish) 3. L /LexiconL (98 pairs for English, 96 for Swedish) 4. L /IrregL (173 pairs for English, 182 for Swedish) 5. L /StructuralL (2 pairs for English, 4 for Swedish)\nIn total, we have extracted constructors for 6,040 English verbs and 7,492 Swedish verbs. Still, 59 BFN verbs and 28 SweFN verbs are out-of-vocabulary.24\nSecond, for each lexical entry, we generate its linearization rule based on (i) the corresponding verb constructor, (ii) particles and reflexive pronouns, if any, that constitute the LU and (iii) the verb type of the lexical entry, for instance:\nlin want V2 Desiring = mkV2 (regV “want”)\nlin känna för VV Desiring = mkVV (partV (irregV “känna” “kände” “känt”) “för”) lin känna sig V Feeling = reflV (irregV “känna” “kände” “känt”)\nIn the result, we were able to generate linearization rules for currently 3,350 (98%) out of 3,432 BFN entries and for 1,789 (94%) out of 1,899 SweFN entries.\nAt this point, it should be noted that each sentence pattern (Section 3.1.1) includes not only a reference to the LU but also a morphological description of the\n24 The RGL modules DictL , DictionaryL , LexiconL , IrregL and StructuralL are a subject to change independently. We have used an RGL snapshot of December 2014.\nLU constituents, which is important in the case of multi-word expressions (MWE), e.g. feel like, känna för, känna sig etc. Moreover, the morphological descriptions are unified across languages according to the universal POS tags25 and features26 allowing for a common generator of concrete lexicons. The current approach to the FrameNet-based grammar and lexicon supports linearization of relatively simple MWEs that, apart from the main verb, include particles (constructor partV) and reflexive pronouns (constructor reflV) in any combination.\nConsidering only the shared frame valence patterns, we have extracted 98 such lexical entries for English, which is about 3% of all entries extracted from BFN and about 84% of all MWE entries extracted from BFN. All these entries correspond to the same morphological pattern:\nVERB.Fin ADP\nwhere ADP (adposition) represents a particle. For Swedish, we have extracted 465 such entries, which is about 25% of all entries and about 85% of all MWE entries extracted from SweFN. In addition to the MWE pattern found in BFN, SweFN covers several other patterns of simple MWEs:\nVERB.Fin ADP ADP VERB.Fin ADP PRON.Reflex VERB.Fin PRON.Reflex VERB.Fin PRON.Reflex ADP\nPatterns of currently unsupported, more complex MWEs are summarized in Table 11. This leads to 19 MWE entries in the English lexicon and 82 MWE entries in the Swedish lexicon having no linearization.\nTo address this issue, we could include lexical entries of type VP implying a similar syntactic valence as for verbs of type V. However, this would require to introduce separate frame functions. An alternative approach would be to extend the notion and support of particle verbs in RGL so that “particles” could be involved in the syntactic agreement.\n25 http://universaldependencies.github.io/docs/u/pos/ 26 http://universaldependencies.github.io/docs/u/feat/\n4.3 Aligning Lexical Units Across Languages\nThe multilingual RGL lexicons – the large translation dictionary (modules DictionaryL ) and the small lexicon of frequently used words (modules LexiconL ) – can be used not only for the extraction of verb constructors but also for aligning LUs (i.e. lexical entries) across languages.\nLet us consider the following example. For the frame Desiring, we have extracted several lexical entries of type VV as shown in Table 9 for English and in Table 10 for Swedish.\nIf we search for the English verbs feel, want and yearn, and for the Swedish verbs känna and vilja in the RGL modules DictionaryEng and DictionarySwe respectively, we find these mappings (among others):\nDictionaryEng: lin feel V = IrregEng.feel V DictionarySwe: lin feel V = mkV “känna” “kände” “känt”\nDictionaryEng: lin want V2 = mkV2 (mkV “want”) DictionarySwe: lin want V2 = mkV2 IrregSwe.vilja V\nDictionaryEng: lin yearn V = mkV “yearn” “yearns” “yearned” ... DictionarySwe: lin yearn V = mkV “trängtar”\nsuggesting the following alignment between the framenet-specific lexicons:\nfeel like VV Desiring = känna för VV Desiring want VV Desiring = vilja VV Desiring\nWe have collected all such suggestions in a separate shared lexicon where BNF identifiers are used as interlingua symbols in the abstract syntax, and the framenetspecific lexicons are used as resource libraries to implement the concrete syntaxes.\nThe generation of the concrete English lexicon is trivial, for instance:\nlin want VV Desiring = want VV Desiring\nThe concrete Swedish lexicon is generated as illustrated in the alignment example above, and it can include alternative variants, for instance:\nlin know V2 Familiarity = variants {känna V2 Familiarity | känna till V2 Familiarity}\nmeaning that all variants will be considered while parsing a sentence, but only the first variant will be used for linearization. Currently, variants are ordered so that MWEs follow simple verbs, otherwise they are given in the alphabetical order; however, they should be ordered at least by frequency.\nIn the case of MWEs, we search for alignment variants based on the main verb if there is no match for the whole MWE. This improves the coverage (as it is illustrated with feel like above) but sometimes leads to incorrect alignments, for instance, exhale has been aligned with andas in ‘inhale’:\nlin exhale V2 Breathing = andas in V2 Breathing\nIn the result, we have aligned 703 BFN entries (21%) with 900 SweFN entires (47%). This approach is still promising, and there is a clear space for improvement:\n1. The alignment procedure failed for about 30% of BFN entries because of missing linearization for nearly 800 DictionarySwe entries. 2. For nearly half of BFN entries, alignment was not found because no match was found among SwFN entries of the same type belonging to the same frame, which is a consequence of the comparatively small size of SweFN (2.2 SweFN entries versus 4 BFN entries per shared valence pattern)."
    }, {
      "heading" : "5 Case Studies",
      "text" : "We illustrate the use of the FrameNet-based API to GF RGL by re-engineering two existing multilingual CNL grammars: one for translating standard tourist phrases (Ranta et al, 2010) and another for generating descriptions of paintings (Dannélls et al, 2012), both developed in the MOLTO project.27 In both cases, we preserve the original functionality, and we do not make any changes in the application abstract syntax. Changes affect only the concrete syntaxes of English and Swedish.\n5.1 Phrasebook\nAlthough the Phrasebook grammar covers many idiomatic expressions that cannot be translated using the same frame or for which our approach would not be suitable as such, it includes around 20 complex clause-building functions that can be handled by the FN-based grammar. To illustrate the use of the FN-based grammar as a semantic API, we re-implement the following Phrasebook functions:\nALive : Person -> Country -> Action -- e.g. ‘we live in Sweden’ AWant : Person -> Object -> Action -- e.g. ‘I want a pizza’ AWantGo : Person -> Place -> Action -- e.g. ‘I want to go to a museum’\nby applying the frame functions Desiring V2 Act and Desiring VV introduced in Section 3, and some additional functions:\nMotion_V_2 : Goal_Adv -> Source_Adv -> Theme_NP -> V -> Clause Possession_V2 : Owner_NP -> Possession_NP -> V2 -> Clause Residence_V : Location_Adv -> Resident_NP -> V -> Clause\nBy using RGL constructors, ALive is implemented for English, Swedish and other languages in the same way, except that different verbs are used:\nALive p co = mkCl p.name (mkVP (mkVP (mkV \"live\")) (mkAdv in_Prep co)) ALive p co = mkCl p.name (mkVP (mkVP (mkV \"bo\")) (mkAdv in_Prep co))\nFirst, the language-specific verbs can be factored out by introducing a shared abstract verb in the domain lexicon (e.g. live V that links live V Residence and bo V Residence). Second, the implementation of ALive can be done in a shared functor by using the FN-based API:\n27 http://www.molto-project.eu/\nALive p co = let cl : Clause =\nResidence_V (Just Adv (mkAdv in_Prep co)) (Just NP p.name) live_V\nin mkCl cl.np cl.vp\nFor AWant, neither the original RGL-based nor the current FN-based implementation can be done in the functor because, in Swedish, the verb vilja ‘to want’ evoking Desiring V2 Act requires the auxiliary verb ha ‘to have’. This can be seen as a nested auxiliary frame Possession:\nAWant p obj = mkCl p.name (mkV2 (mkV \"want\")) obj -- Eng Desiring_V2_Act (Just NP p.name) (Just NP obj) want_V2\nAWant p obj = mkCl p.name want_VV (mkVP L.have_V2 obj) -- Swe Desiring_VV\n(Just VP (Possession_V2 (Nothing NP) (Just NP obj) have_V2).vp) (Just NP p.name) want_VV\nAssuming that the auxiliary verb can be optionally used also with other Swedish verbs when applying this frame function, the nested frame could be hidden in the Swedish implementation of Desiring V2 Act. This, however, is not the case with AWantGo which in both languages requires a main nested frame and, thus, can be put in the functor:\nAWantGo p place = mkCl p.name want_VV (mkVP (mkVP go_V) place.to)\nDesiring_VV (Just VP\n(Motion_V_2 (Just Adv place.to) (Nothing Adv) (Nothing NP) go_V).vp) (Just NP p.name) want_VV\nAt the first gleam, the new code might look more complex, however, it does not specify how the verb phrases are built, and the same uniform code template is used in all cases.\nThe re-implemented version of Phrasebook accepts and generates the same set of sentences as before.28\n5.2 Paintings\nThe painting grammar is a part of a large-scale controlled NLG grammar developed for the cultural heritage domain in order to verbalize data about museum objects stored in an RDF-based ontology (Dannélls et al, 2012). A set of RDF triples (subject-predicate-object expressions) forms the input to the application. As an example, a simplified set of triples representing information about the artwork Bacchus is given below:\n<Bacchus> <createdBy> <Leonardo_da_Vinci> <Bacchus> <hasDimension> <Bacchus_ImageDimesion> <Bacchus> <hasCreationDate> <Bacchus_CreationDate> <Bacchus> <hasCurrentLocation> <Musee_du_Louvre> <Bacchus_ImageDimesion> <lengthValue> 115 <Bacchus_ImageDimesion> <heightValue> 177 <Bacchus_CreationDate> <timePeriodValue> 1510\n28 http://www.grammaticalframework.org/demos/phrasebook/\nThis information is combined by the grammar to generate a coherent text. A simplified abstract function that combines the triples is\nDPainting : Painting -> Painter -> Year -> Size -> Museum -> Description\nEach argument of the function corresponds to a class in the ontology. In Figure 3, we show how the arguments are linearized in the original concrete syntax for English and how this syntax has been adapted to generate descriptions via the FN-based grammar. To adapt the original grammar, we first identified the frames that match the target verbs in the linearization rules. Then we matched the core FEs of the identified frames with the verb arguments.\nSince the FN-based grammar currently does not cover non-core FEs, the adjunct Year is associated with no FE in Create physical artwork. Instead, it is attached to the corresponding clause in the final linearization rule (mkText), illustrating how non-core FEs can be incorporated.\nThe grammar exploits patterns of frames Create physical artwork, Dimension and Placing:\nCreate_physical_artwork_V2_Pass :\nCreator_NP -> Representation_NP -> V2 -> Clause\nDimension_V2 : Measurement_NP -> Object_NP -> V2 -> Clause Placing_V2_Pass : Goal_Adv -> Theme_NP -> V2 -> Clause\nAlternatively, we could easily change the frame Placing with Being located evoked by the one-place verb hang in the active voice, which would preserve the meaning but alter the linearization.\nThe Swedish syntax was adapted in the same way. Descriptions generated by the new versions of DPainting are virtually equivalent to the descriptions produced by the original grammar.29 The only difference in comparison to the original grammar is that in Swedish we have imposed the use of the main verb mäta ‘to measure’ instead of the copula:\nEng: Bacchus was painted by Leonardo da Vinci in 1510. It measures 115 by 177 cm. This work is displayed at the Musée du Louvre. Swe: Bacchus m̊alades av Leonardo da Vinci år 1510. Den mäter 115 g̊anger"
    }, {
      "heading" : "177 cm. Det här verket är utställt p̊a Louvren.",
      "text" : ""
    }, {
      "heading" : "6 Evaluation",
      "text" : "We have conducted a simple intrinsic and extrinsic evaluation of the acquired FN-based grammar and lexicon. For an initial intrinsic evaluation, we count the number of examples in the source corpora that belong to the set of shared frames and that are covered by the shared semantico-syntactic valence patterns. Corpus examples are judged by the sentence patterns that represent them, disregarding non-core FEs, concrete prepositions and the word order, but including syntactic roles and the grammatical voice. This means that the original sentences are, in general, covered by paraphrasing.\nWe have extracted 57,615 examples from BFN and 3,348 examples from SweFN that belong to the shared set of 483 frames. For both BFN and SweFN, the concise set of 869 patterns covers 77.5% of those examples. This indicates that the set of shared patterns includes the most frequently used ones despite the modest amount of the annotated example sentences in SweFN.\nBased on the FN-annotated sentences covered by the shared valence patterns, and the GF RGL type system for verbs, we have extracted 3,432 lexical entries (subcategorized LUs) from BFN, and 1,899 entries form SweFN. LUs between BFN and SweFN are not directly aligned, therefore a specific lexicon is generated for each language. However, a partial shared lexicon has been automatically derived on top of the language-specific lexicons, currently providing a mapping between 703 LUs in BFN and 900 LUs in SweFN. The shared lexicon covers 25.1% (11,223) of BFN sentences and 35.8% (928) of SweFN sentences, counting only those sentences which are represented by the shared valence patterns.\nFor an initial extrinsic evaluation, we compare the original application grammars with their FN-based counterparts in terms of code complexity. Since we do not modify the abstract syntax of application grammars, the amount of linearization rules remains the same. Therefore we count the number of constructors used to linearize the functions. In the painting application, the number of constructors is considerably reduced from 21 to 13. In the case of Phrasebook, the number is slightly reduced from 10 in English and 11 in Swedish to 8 in both languages.\n29 http://museum.ontotext.com/\nAnother aspect of the evaluation with regard to the original application grammars is the large number of accurate high-level frame constructors which are available to the CNL application developers. Instead of having to search for typical and valid syntactic patterns in a corpus to match the semantic representations of the application and domain, and to implement them, developers can choose among the abstract but still corpus-based semantico-syntactic patterns. The frame semantics is consistent and can be mapped to the semantic representations of various applications in various domains having different levels of expressiveness."
    }, {
      "heading" : "7 Discussion",
      "text" : "The presented approach is based on several assumptions that limit the scope of the shared grammar and lexicon. The first difficulty is the low amount of annotated example sentences in SweFN. The differences between the amounts of examples has become noticeable in the set of extracted shared valence patterns. Without going into further methodological details, we should note that the approach taken in the development of SweFN was more lexicographically focused, putting emphasis on enhancing frames with LUs rather than supplementing each LU with example sentences. One way of adding more valence patterns for verbs is from the morpho-syntactic descriptions provided in the SIMPLE/PAROLE lexicons that are a part of the larger SweFN++ project. These lexicons contain descriptive linguistic analysis for around 3,000 Swedish verbs. Adding this information can yield a larger, more representative set of shared valence patterns additionally to the FN-annotated examples.\nFurthermore, the extraction of verb valence patterns practically assumes varied semantic descriptions, as well as large amounts of sentence examples that are representative for the language in question. While the BFN approach is likely to suggest frequent patterns and more general linguistic descriptions, the SweFN approach is more likely to cover the linguistic variation for each verb. The question of how to balance between the two approaches has to be dealt with.\nAnother difficulty is selecting shared patterns in case of more than two languages. Alternatives are: (1) an intersection of all languages, which means that the set of shared patterns inevitably gets smaller by adding each new language, but the intersection becomes more and more prototypical, provided that the corpora are of a reasonable size and coverage; (2) a union of intersections of language pairs, which, on the one hand, would lead to functions temporary having no linearization in the one or the other language, but which, on the other hand, would be an efficient way to reveal non-compositional constructions and provide cross-lingual hints to the FN annotators and lexicographers.\nNon-compositional translation equivalents, when verb types differ or when verbs do not have any counterpart in the other language, is yet another issue. In SweFN, we find a range of verbs that lack an exact translation in English such as: vabba ‘to stay home because of a sick child’, heta ‘be named’, duka ‘to make the table’, diska ‘to wash the dishes’, bädda ‘to make the bed’. A related question here is to what extent can these be represented in the grammar and how can we represent them automatically. One possible solution is the reuse of the GF RGL monolingual and multilingual dictionaries. Another solution is finding\ncomplementary resources for constructing the FN-based lexicons, for example by using WordNet for linking LUs.\nFor non-shared patterns and non-compositional translation equivalents, language specific extra modules can be introduced. This will increase the coverage not only in monolingual applications but also in multilingual applications; however, it would require a manual, application-specific mapping between different frames.\nThe presented approach has some advantages with regard to GF RGL. It can potentially provide feedback to the RGL monolingual and multilingual dictionaries, yielding mutual benefits, such as: (1) verification of verb types; (2) verification of particle verbs; and (3) suggestion of new entries."
    }, {
      "heading" : "8 Related Work",
      "text" : "The main difference between this work and the previous approaches to CNL grammars is that we present an effort to exploit a robust and well established semantic model in the grammar development. Our approach can be compared with the work on multilingual verbalization of modular ontologies using GF and lemon (Davis et al, 2012), the Lexicon Model for Ontologies. We use additional lexical information about syntactic arguments for building the concrete syntax.\nThe grounding of NLG using the frame semantics theory has been addressed in the work on text-to-scene generation (Coyne et al, 2011) and in the work on text generation for navigational tasks (Roth and Frank, 2010). In that research, the content of frames is utilized through alignment between the frame-semantic structure and the domain-semantic representation. Discourse is supported by applying aggregation and pronominalization techniques. In the cultural heritage use case, we also show how an application which utilizes the FN-based grammar can become more discourse-oriented; something that is necessary in actual NLG applications and that has been demonstrated in GF before (Dannélls, 2010). In our current approach, the semantic representation of the domain and the linguistic structures of the grammar are based on FN-annotated data.\nAs suggested before (Gruzitis and Barzdins, 2010), a FN-like approach can be used to deal with polysemy in CNL texts. Although we consider lexicalisation alternatives and restrictions for LUs and FEs, we do not address the problem of selectional restrictions and word sense disambiguation in general."
    }, {
      "heading" : "9 Conclusion",
      "text" : "In this article, we presented a computational approach to multilingual grammar and lexicon extraction and generation from FN-annotated corpora. The methodology for constructing the grammars and the lexicons was evaluated in a series of experiments. The results show that we are able to generalize over a set of valence patterns to capture the semantics and the syntax of two languages having a shared FN-based abstract syntax. We discussed a number of potential improvements to achieve better results that would lead to a larger coverage, however, the current coverage is already of practical use. We have tested the feasibility of the generated grammar library as a semantic API for developing CNL applications in GF. The\nmajor advantage is that language-dependent clause-level specifications to a large extent are hidden by the semantic API, making the application grammars more robust and flexible."
    } ],
    "references" : [ {
      "title" : "FrameNet CNL: A knowledge representation and information extraction language. In: Controlled Natural Language, Springer, Lecture",
      "author" : [ "G Barzdins" ],
      "venue" : "Notes in Computer Science,",
      "citeRegEx" : "Barzdins,? \\Q2014\\E",
      "shortCiteRegEx" : "Barzdins",
      "year" : 2014
    }, {
      "title" : "Multilingual FrameNets in Computational Lexicography: Methods and Applications",
      "author" : [ "HC Boas" ],
      "venue" : "Mouton de Gruyter",
      "citeRegEx" : "Boas,? \\Q2009\\E",
      "shortCiteRegEx" : "Boas",
      "year" : 2009
    }, {
      "title" : "The past meets the present in Swedish FrameNet++",
      "author" : [ "L Borin", "D Dannélls", "M Forsberg", "M Toporowska Gronostaj", "D Kokkinakis" ],
      "venue" : "Proceedings of the 14th EURALEX International Congress,",
      "citeRegEx" : "Borin et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Borin et al\\.",
      "year" : 2010
    }, {
      "title" : "Korp – the corpus infrastructure of Spr̊akbanken",
      "author" : [ "L Borin", "M Forsberg", "J Roxendal" ],
      "venue" : "Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC),",
      "citeRegEx" : "Borin et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Borin et al\\.",
      "year" : 2012
    }, {
      "title" : "SALDO: a touch of yin to WordNet’s yang. Language Resources and Evaluation",
      "author" : [ "L Borin", "M Forsberg", "L Lönngren" ],
      "venue" : null,
      "citeRegEx" : "Borin et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Borin et al\\.",
      "year" : 2013
    }, {
      "title" : "VigNet: Grounding language in graphics using frame semantics",
      "author" : [ "B Coyne", "D Bauer", "O Rambow" ],
      "venue" : "Proceedings of the ACL Workshop on Relational Models of Semantics,",
      "citeRegEx" : "Coyne et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Coyne et al\\.",
      "year" : 2011
    }, {
      "title" : "Discourse generation from formal specifications using the Grammatical Framework, GF",
      "author" : [ "D Dannélls" ],
      "venue" : "Special issue of Research in Computing Science",
      "citeRegEx" : "Dannélls,? \\Q2010\\E",
      "shortCiteRegEx" : "Dannélls",
      "year" : 2010
    }, {
      "title" : "Extracting a bilingual semantic grammar from FrameNet-annotated corpora",
      "author" : [ "D Dannélls", "N Gruzitis" ],
      "venue" : "Proceedings of the 9th International Language Resources and Evaluation Conference (LREC),",
      "citeRegEx" : "Dannélls and Gruzitis,? \\Q2014\\E",
      "shortCiteRegEx" : "Dannélls and Gruzitis",
      "year" : 2014
    }, {
      "title" : "Controlled natural language generation from a multilingual FrameNet-based grammar",
      "author" : [ "D Dannélls", "N Gruzitis" ],
      "venue" : "Controlled Natural Language, Springer, Lecture Notes in Computer Science,",
      "citeRegEx" : "Dannélls and Gruzitis,? \\Q2014\\E",
      "shortCiteRegEx" : "Dannélls and Gruzitis",
      "year" : 2014
    }, {
      "title" : "Multilingual online generation from Semantic Web ontologies",
      "author" : [ "D Dannélls", "R Enache", "M Damova", "M Chechev" ],
      "venue" : "Proceedings of the 21st International World Wide Web Conference, European Project Track,",
      "citeRegEx" : "Dannélls et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Dannélls et al\\.",
      "year" : 2012
    }, {
      "title" : "Multilingual verbalisation of modular ontologies using GF and LEMON",
      "author" : [ "B Davis", "R Enache", "J van Grondelle", "L Pretorius" ],
      "venue" : "Controlled Natural Language, Springer, Lecture Notes in Computer Science,",
      "citeRegEx" : "Davis et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Davis et al\\.",
      "year" : 2012
    }, {
      "title" : "Aligning FrameNet and WordNet based on semantic neighborhoods",
      "author" : [ "Ó Ferrández", "M Ellsworth", "R Muñoz", "CF Baker" ],
      "venue" : "Proceedings of the 7th International Language Resources and Evaluation Conference (LREC),",
      "citeRegEx" : "Ferrández et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Ferrández et al\\.",
      "year" : 2010
    }, {
      "title" : "Frames and the semantics of understanding",
      "author" : [ "CJ Fillmore" ],
      "venue" : "Quaderni di Semantica",
      "citeRegEx" : "Fillmore,? \\Q1985\\E",
      "shortCiteRegEx" : "Fillmore",
      "year" : 1985
    }, {
      "title" : "Polysemy in controlled natural language texts. In: Controlled Natural Language, Springer, Lecture",
      "author" : [ "N Gruzitis", "G Barzdins" ],
      "venue" : "Notes in Computer Science,",
      "citeRegEx" : "Gruzitis and Barzdins,? \\Q2010\\E",
      "shortCiteRegEx" : "Gruzitis and Barzdins",
      "year" : 2010
    }, {
      "title" : "FrameNet resource grammar library for GF",
      "author" : [ "N Gruzitis", "P Paikens", "G Barzdins" ],
      "venue" : "Controlled Natural Language, Springer, Lecture Notes in Computer Science,",
      "citeRegEx" : "Gruzitis et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Gruzitis et al\\.",
      "year" : 2012
    }, {
      "title" : "A survey and classification of controlled natural languages",
      "author" : [ "T Kuhn" ],
      "venue" : "Computational Linguistics",
      "citeRegEx" : "Kuhn,? \\Q2014\\E",
      "shortCiteRegEx" : "Kuhn",
      "year" : 2014
    }, {
      "title" : "Universal Stanford Dependencies: A cross-linguistic typology",
      "author" : [ "MC de Marneffe", "T Dozat", "N Silveira", "K Haverinen", "F Ginter", "J Nivre", "CD Manning" ],
      "venue" : "Proceedings of the 9th International Language Resources and Evaluation Conference (LREC),",
      "citeRegEx" : "Marneffe et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Marneffe et al\\.",
      "year" : 2014
    }, {
      "title" : "COMLEX Syntax 2.0 manual for tagged entries",
      "author" : [ "A Meyers", "C Macleod", "R Grishman" ],
      "venue" : null,
      "citeRegEx" : "Meyers et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Meyers et al\\.",
      "year" : 1995
    }, {
      "title" : "Open domain information extraction via automatic semantic labeling",
      "author" : [ "A Moschitti", "P Morarescu", "SM Harabagiu" ],
      "venue" : "Proceedings of the 16th International FLAIRS Conference,",
      "citeRegEx" : "Moschitti et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Moschitti et al\\.",
      "year" : 2003
    }, {
      "title" : "Memory-based dependency parsing",
      "author" : [ "J Nivre", "J Hall", "J Nilsson" ],
      "venue" : "Proceedings of the 8th Conference on Computational Natural Language Learning (CoNLL),",
      "citeRegEx" : "Nivre et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Nivre et al\\.",
      "year" : 2004
    }, {
      "title" : "Controlled language for everyday use: The MOLTO Phrasebook",
      "author" : [ "A Ranta", "R Enache", "G Détrez" ],
      "venue" : "Controlled Natural Language, Springer, Lecture Notes in Computer Science,",
      "citeRegEx" : "Ranta et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Ranta et al\\.",
      "year" : 2010
    }, {
      "title" : "A NLG-based application for walking directions",
      "author" : [ "M Roth", "A Frank" ],
      "venue" : "Proceedings of the 47th ACL and the 4th IJCNLP Conference,",
      "citeRegEx" : "Roth and Frank,? \\Q2009\\E",
      "shortCiteRegEx" : "Roth and Frank",
      "year" : 2009
    }, {
      "title" : "Computing EM-based alignments of routes and route directions as a basis for natural language generation",
      "author" : [ "M Roth", "A Frank" ],
      "venue" : "Proceedings of the 23rd International Conference on Computational Linguistics (COLING),",
      "citeRegEx" : "Roth and Frank,? \\Q2010\\E",
      "shortCiteRegEx" : "Roth and Frank",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "The future potential of our approach is to provide a means for multilingual verbalization of FN-annotated knowledge bases that have been populated by FN-based information extraction systems (Das et al, 2014) and that could be automatically mapped to the appropriate frame constructors, similarly as sketched by Barzdins (2014).",
      "startOffset" : 311,
      "endOffset" : 327
    }, {
      "referenceID" : 12,
      "context" : "Berkeley FrameNet (Fillmore et al, 2003) is a lexico-semantic resource based on the theory of frame semantics (Fillmore, 1985).",
      "startOffset" : 110,
      "endOffset" : 126
    }, {
      "referenceID" : 21,
      "context" : "The FrameNet approach to frame semantics, approbated in BFN, provides a benchmark for representing large amounts of word senses and word usage patterns through the linguistic annotation of corpus examples, therefore the exploitation of FN-like resources has been appealing for a range of advanced NLP applications such as semantic parsing (Das et al, 2014), information extraction (Moschitti et al, 2003) and natural language generation (Roth and Frank, 2009).",
      "startOffset" : 437,
      "endOffset" : 459
    }, {
      "referenceID" : 1,
      "context" : "There are FNs available for German, Japanese, Spanish (Boas, 2009) and Swedish (Borin et al, 2010).",
      "startOffset" : 54,
      "endOffset" : 66
    }, {
      "referenceID" : 22,
      "context" : "The grounding of NLG using the frame semantics theory has been addressed in the work on text-to-scene generation (Coyne et al, 2011) and in the work on text generation for navigational tasks (Roth and Frank, 2010).",
      "startOffset" : 191,
      "endOffset" : 213
    }, {
      "referenceID" : 6,
      "context" : "In the cultural heritage use case, we also show how an application which utilizes the FN-based grammar can become more discourse-oriented; something that is necessary in actual NLG applications and that has been demonstrated in GF before (Dannélls, 2010).",
      "startOffset" : 238,
      "endOffset" : 254
    }, {
      "referenceID" : 13,
      "context" : "As suggested before (Gruzitis and Barzdins, 2010), a FN-like approach can be used to deal with polysemy in CNL texts.",
      "startOffset" : 20,
      "endOffset" : 49
    } ],
    "year" : 2015,
    "abstractText" : "Berkeley FrameNet is a lexico-semantic resource for English based on the theory of frame semantics. It has been exploited in a range of natural language processing applications and has inspired the development of framenets for many languages. We present a methodological approach to the extraction and generation of a computational multilingual FrameNet-based grammar and lexicon. The approach leverages FrameNet-annotated corpora to automatically extract a set of cross-lingual semantico-syntactic valence patterns. Based on data from Berkeley FrameNet and Swedish FrameNet, the proposed approach has been implemented in Grammatical Framework (GF), a categorial grammar formalism specialized for multilingual grammars. The implementation of the grammar and lexicon is supported by the design of FrameNet, providing a frame semantic abstraction layer, an interlingual semantic API (application programming interface), over the interlingual syntactic API already provided by GF Resource Grammar Library. The evaluation of the acquired grammar and lexicon shows the feasibility of the approach. Additionally, we illustrate how the FrameNet-based grammar and lexicon are exploited in two distinct multilingual controlled natural language applications. The produced resources are available under an open source license.",
    "creator" : "LaTeX with hyperref package"
  }
}