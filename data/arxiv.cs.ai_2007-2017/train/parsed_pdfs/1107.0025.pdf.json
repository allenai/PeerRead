{
  "name" : "1107.0025.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Taming Numbers and Durations in the Model Checking Integrated Planning System",
    "authors" : [ "Stefan Edelkamp" ],
    "emails" : [ "stefan.edelkamp@cs.uni-dortmund.de" ],
    "sections" : [ {
      "heading" : null,
      "text" : "MIPS has shown distinguished performance in the last two international planning competitions. In the last event the description language was extended from pure propositional planning to include numerical state variables, action durations, and plan quality objective functions. Plans were no longer sequences of actions but time-stamped schedules.\nAs a participant of the fully automated track of the competition, MIPS has proven to be a general system; in each track and every benchmark domain it efficiently computed plans of remarkable quality. This article introduces and analyzes the most important algorithmic novelties that were necessary to tackle the new layers of expressiveness in the benchmark problems and to achieve a high level of performance.\nThe extensions include critical path analysis of sequentially generated plans to generate corresponding optimal parallel plans. The linear time algorithm to compute the parallel plan bypasses known NP hardness results for partial ordering by scheduling plans with respect to the set of actions and the imposed precedence relations. The efficiency of this algorithm also allows us to improve the exploration guidance: for each encountered planning state the corresponding approximate sequential plan is scheduled.\nOne major strength of MIPS is its static analysis phase that grounds and simplifies parameterized predicates, functions and operators, that infers knowledge to minimize the state description length, and that detects domain object symmetries. The latter aspect is analyzed in detail.\nMIPS has been developed to serve as a complete and optimal state space planner, with admissible estimates, exploration engines and branching cuts. In the competition version, however, certain performance compromises had to be made, including floating point arithmetic, weighted heuristic search exploration according to an inadmissible estimate and parameterized optimization."
    }, {
      "heading" : "1. Introduction",
      "text" : "Practical action planning and model checking appear to be closely related. The MIPS project targets the integration of model checking techniques into a domain-independent action planner. With the HSF-Spin experimental model checker (Edelkamp, Leue, & LluchLafuente, 2003) we are looking towards the integration of planning technology into an\nc©2003 AI Access Foundation. All rights reserved.\nexisting model checker. Additional synergies are exploited in the automated compilation of protocol software model checking problems into planner inputs (Edelkamp, 2003).\nModel checking (Clarke, Grumberg, & Peled, 1999) is the automated process to verify if a formal model of a system satisfies a specified temporal property or not. As an illustrative example, take an elevator control system together with a correctness property that requires an elevator to eventually stop on every call of a passenger or that guarantees that the door is closed, while the elevator is moving. Although the success in checking correctness is limited, model checkers have found many errors in current hardware and software designs. Models often consist of many concurrent sub-systems. Their combination is either synchronous, as often seen in hardware design verification, or asynchronous, as frequently given in communication and security protocols, or in multi-threaded programming languages like Java.\nModel checking requires the exploration of very large state spaces containing all reachable system states. This problem is known as the state explosion problem and occurs even when the sets of generated states is much smaller than the set of all reachable states.\nAn error that shows a safety property violation, like a deadlock or a failed assertion, corresponds to one of a set of target nodes in the state space graph. Roughly speaking, something bad has occured. A liveness property violation refers to a (seeded) cycle in the graph. Roughly speaking, something good will never occur. For the case of the elevator example, eventually reaching a target state where a request button was pressed is a liveness property, while certifying closed doors refers to a safety property.\nThe two main validation processes in model checking are explicit and symbolic search. In explicit-state model checking each state refers to a fixed memory location and the state space graph is implicitly generated by successive expansions of state.\nIn symbolic model checking (McMillan, 1993; Clarke, McMillan, Dill, & Hwang, 1992), (fixed-length) binary encodings of system states are used, so that each state can be represented by its characteristic function representation. This function evaluates to true if and only if all Boolean state variables are assigned to bit values with respect to the binary encoding of the system state. Subsequently, the characteristic function is a conjunction of literals with a plain variable for a 1 in the encoding and a negated variable for a 0. Sets of states are expressed as the disjunction of all individual characteristic functions.\nThe unique symbolic representation of sets of states as Boolean formulae through binary decision diagrams (BDDs) (Bryant, 1992) is often much smaller than the explicit one. BDDs are (ordered) read-once branching programs with nodes corresponding to variables, edges corresponding to variable outcomes, and each path corresponding to an assignment to the variables with the resulting evaluation at the leaves. One reason for the succinctness of BDDs is that directed acyclic graphs may express exponentially many paths. The transition relation is defined on two state variable sets. It evaluates to true, if and only if an operator exists that transforms a state into a valid successor. In some sense, BDDs exploit regularities of the state set and often appear well suited to regular hardware systems. In contrast, many software systems inherit a highly asynchronous and irregular structure, so that the use of BDDs with a fixed variable ordering is generally not flexible enough.\nFor symbolic exploration, a set of states is combined with the transition relation to compute the set of all possible successor states, i.e. the image. Starting with the initial state, iteration of image computations eventually explores the entire reachable state space.\nTo improve the efficiency of image computations, transition relations are often provided in partitioned form.\nThe correspondence between action and model checking (Giunchiglia & Traverso, 1999) can be roughly characterized as follows. Similar to model checkers, action planners implicitly generate large state spaces, and both exploration approaches are based on applying operators to the current state. States spaces in model checking and in planning problems are often modelled as Kripke structures, i.e. state space graphs with states labelled by propositional predicates. The satisfaction of a specified property on the one side corresponds to a complete exploration, and an unsolvable problem on the other side. In this respect, the goal in action planning can be cast as an error with the corresponding trail interpreted as a plan. In the elevator example, the goal of a planning task is to reach a state, in which the doors are open and the elevator is moving. Action planning refers to safety properties only, since goal achievement in traditional and competition planning problems have not yet been extended with temporal properties. However, temporally extended goals are of increasing research interest (Kabanza, Barbeau, & St-Denis, 1997; Pistore & Traverso, 2001; Lago, Pistore, & Traverso, 2002).\nIn contrast to model checkers that perform either symbolic or explicit exploration, MIPS features both. Moreover, it combines symbolic and explicit search planning in the form of symbolic pattern databases (Edelkamp, 2002b). The planner MIPS implements heuristic search algorithms like A* (Pearl, 1985) and IDA* (Korf, 1985) for exploration, which include state-to-goal approximation into the search process to rank the states to be expanded next. Heuristic search has brought considerable gains to both planning (Bonet & Geffner, 2001; Refanidis & Vlahavas, 2000; Hoffmann & Nebel, 2001; Bertoli, Cimatti, & Roveri, 2001a; Jensen, Bryant, & Veloso, 2002; Feng & Hansen, 2002) and model checking (Yang & Dill, 1998; Edelkamp et al., 2003; Groce & Visser, 2002; Bloem, Ravi, & Somenzi, 2000; Ruys, 2003).\nIncluding resource variables, like the fuel level of a vehicle or the distance between two different locations, as well as action duration are relatively new aspects for competitive planning (Fox & Long, 2003). The input format PDDL2.1 is not restricted to variables of finite domain, but also includes rational (floating-point) variables in both precondition and effects. Similar to a set of atoms described by a propositional predicate, a set of numerical quantities can be described by a set of parameters. Through the notation of PDDL2.1, we refer to parameterized numerical quantities as functions. For example, the fuel level might be parameterized by the vehicle that is present in the problem instance file description.\nIn the competition, domains were provided in different tracks according to different layers of language expressiveness: i) pure propositional planning, ii) planning with numerical resources, iii) planning with numerical resources and constant action duration, iv) planning with numerical resources and variable action duration, and, in some cases, v) complex problems usually combining time and numbers in more interesting ways. MIPS competed as a fully automated system and performed remarkably well in all five tracks; it solved a large number of problems and was the only fully automated planner that produced solutions in each track of every benchmark domain.\nIn this paper the main algorithmic techniques for taming rational numbers, objective functions, and action duration are described. The article is structured as follows. First, we review the development of the MIPS system and assert its main contributions. Then\nwe address the object-oriented heuristic search framework of the system. Subsequently, we introduce some terminology that allows us to give a formal definition of the syntax and the semantics of a grounded mixed numerical and propositional planning problem instance. We then introduce the core contributions: critical path scheduling for concurrent plans, and efficient methods for detecting and using symmetry cuts. PERT scheduling produces optimal parallel plans in linear time given a sequence of operators and a precedence relation among them. The paper discusses pruning anomalies and the effect of different optimization criteria. We analyze the correctness and efficiency of symmetry detection in detail. The article closes with related work and concluding remarks."
    }, {
      "heading" : "2. The Development of MIPS",
      "text" : "The competition version of MIPS refers to initial work (Edelkamp & Reffel, 1999a) in heuristic symbolic exploration of planning domains with the µcke model checker (Biere, 1997). This approach was effective in sample puzzle solving (Edelkamp & Reffel, 1998) and in hardware verification problems (Reffel & Edelkamp, 1999).\nFor implementing a propositional planner, we first used our own BDD library called StaticBdd, in which large node tables are allocated prior to their use. During the implementation process we changed the BDD representation mainly to improve performance for small planning problems. We selected the public domain c++ BDD package Buddy (LindNielsen, 1999), which is more flexible. The planning process was semi-automated (Edelkamp & Reffel, 1999b); variable encodings were provided by hand, while the representations of all operators were established by enumerating all possible parameter instances. Once the state space encoding and action transition relation were fixed, exploration in the form of a symbolic breadth-first search of the state-space could be executed. At that time, we were not aware of any other work in BDD-based planning such as the work of Cimatti et al. (1997), which is likely the first link to planning via symbolic model checking. The team used the model checker (nu)SMV as the basis with an atom-to-variable planning state encoding scheme on top of it.\nLater on, we developed a parser and a static analyzer to automate the inference of state encodings, the generation of the transition relations, and the extraction of solution paths. In order to minimize the length of the state encoding, the new analyzer clustered atoms into groups (Edelkamp & Helmert, 1999). As confirmed by other attempts (Weismüller, 1998), who started experimenting with PDDL specification in µcke, state minimization is in fact crucial. The simple encoding using one variable for each atom appears not to be competitive with respect to Graphplan-based (Blum & Furst, 1995) and SAT-plan based planners (Kautz & Selman, 1996). Subsequently, MIPS was the first fully automated planning system based on symbolic model checking technology that could deal with large domain descriptions.\nIn the second international planning competition MIPS (Edelkamp & Helmert, 2001) could handle the STRIPS (Fikes & Nilsson, 1971) subset of the PDDL language (McDermott, 2000) and some additional features from ADL (Pednault, 1989), namely negative preconditions and (universal) conditional effects. MIPS was one of five planning systems to be awarded for “Distinguished Performance” in the fully automated track. The competition version (Edelkamp & Helmert, 2000) already included explicit heuristic search algorithms based on a bit-vector state representation and the relaxed planning heuristic (RPH) (Hoff-\nmann & Nebel, 2001) as well as symbolic heuristic search based on the HSP heuristic (Bonet & Geffner, 2001) and a one-to-one atom derivative of RPH. In the competition, we used breadth-first bi-directional symbolic search whenever the single state heuristic search engine got stuck in its exploration.\nIn between the planning competitions, explicit (Edelkamp, 2001c) and symbolic pattern databases (Edelkamp, 2002b) were proposed as off-line estimators for completely explored problem abstractions. Roughly speaking, pattern database abstractions slice the state vector of fluents into pieces and adjust the operators accordingly. The completely explored subspaces then serve as admissible estimates for the overall search and are competitive with the relaxed planning heuristic in several benchmark domains.\nFor the third planning competition new levels of the planning domain description language (PDDL) were designed. Level 1 considers pure propositional planning. Level 2 also includes numerical resources and objective functions to be minimized. Level 3 additionally allows the specification of actions with durations. Consequently, MIPS has been extended to cope with these new forms of expressiveness.\nFirst results of MIPS in planning PDDL2.1 problems are presented in (Edelkamp, 2001b). The preliminary treatment illustrates the parsing process in two simple benchmark domains. Moreover, propositional heuristics and manual branching cuts were applied to accelerate sequential plan generation. This work was extended in (Edelkamp, 2002a), where we presented two approximate exploration techniques to bound and to fix numerical domains, first results on symmetry detection based on fact groups, critical path scheduling, an any-time wrapper to produce optimal plans, and a numerical extension to RPH."
    }, {
      "heading" : "3. Architecture of MIPS",
      "text" : "Figure 1 shows the main components of MIPS and the data flow from the input definition of the domain and the problem instance to the resulting temporal plan in the output. As shown shaded in light gray, MIPS is divided into four parts: pre-compilation, heuristics, search algorithms, and post-compilation (scheduling). Henceforth, the planning process will be coarsely grouped into three stages, pre-compilation, heuristic search planning, and the construction of temporal plans. The problem and domain description files are fed into the system, analyzed and grounded. This fixes the state space problem to be solved. The intermediate result is implicit, but can be saved in a file for use by other planners and model checkers. The basics of pre-compilation are covered in Section 3.2.\nThe next stage defines the planning process. The object-oriented workbench design of the planner allows different heuristic estimates to be combined with different search strategies and access data structures. Possible choices are listed in Sections 3.3 and 3.4. Temporal planning is based on (PERT) scheduling. This issue of rearranging sequential (relaxed) plans is addressed in detail in Section 4.3.\nThe planning system was developed in the spirit of the heuristic search framework, HSF for short (Edelkamp, 1999), which allows attachment of newly implemented problem (puzzle) domains to an already compiled system. Similar to the approach that we took in model checking within HSF-Spin, we kept the extensible and general design. In fact we characterized both action planning and protocol validation as single-agent challenges. In contrast to the model checking approach, for planning we devised a hierarchy of system\nstates: the implementation for numerical states is a derived class of the one for propositional states.\nSimilarily, the heuristic search algorithms are all based on an abstract search class. The main procedures that have to be provided to the search algorithm are a state expansion procedure, and a heuristic search evaluation function, both located in one of the hierarchically organized heuristic estimator classes. In this sense, algorithms in MIPS are general node expanding schemes that can be adapted to very different problems. Additional data structures for the horizon list Open and the visited list Closed are constructed as parameters of the appropriate search algorithms. As a result, the implementations of the heuristic search algorithms and the associated data structures in the planner MIPS almost match those in our model checker."
    }, {
      "heading" : "3.1 Example Problem",
      "text" : "The running example for the paper is an instance of a rather simple PDDL2.1 problem in Zeno-Travel. It is illustrated in Figure 2. The initial configuration is drawn to the left of\nthe figure and the goal configuration to its right. Some global and local numeric variable assignments are not shown.\nFigures 3 and 4 provide the domain and problem specifications1. The instance asks for a temporal plan to fly passengers (dan, scott, and ernie) located somewhere on a small map (including the cities city-a, city-b, city-c, and city-d) with an aircraft (plane) to their respective target destinations. Boarding and debarking take a constant amount of time. The plane has a fixed fuel capacity. Fuel and time are consumed according to the distances between the cities and the travel speed. Fuel can be restored by refueling the aircraft. As a result, the total amount of fuel is also maintained as a numerical quantity."
    }, {
      "heading" : "3.2 Precompiler",
      "text" : "The static analyzer takes the domain and problem instance as an input, grounds its propositional state information and infers different forms of planner independent static information.\nParsing Our simple Lisp parser generates a tree of Lisp entities. It reads the input files and recognizes the domain and problem name. To cope with variable typing, we temporarily assert constant typed predicates to be removed together with other constant predicates in a further pre-compilation step. Thereby, we infer a type hierarchy and an associated mapping of objects to types.\nIndexing Based on the number of counted objects, indices for the grounded predicates, functions and actions are devised. Since in our example problem we have eight objects and the predicates at and in have two parameters, we reserve 2 · 8 · 8 = 128 index positions. Similarly, the function distance consumes 64 indices, while fuel,\n1. [...] denotes that source fragments were omitted for the sake of brevity. In the given example these are the action definitions for passenger debarking and flying the airplane.\nslow-speed, fast-speed, slow-burn, fast-burn, capacity, and refuel-rate each reserve eight index positions. For the quantities total-fuel-used, boarding-time, debarking-time only a single fact identifier is needed. Last but not least we model duration as an additional quantity total-time. This special variable is the only one that is overwritten in the least commitment planning approach when scheduling plans as described in Section 4.\nFlattening Temporal Identifiers We interpret each action as an integral entity, so that all timed propositional and numerical preconditions can be merged. Similarly, all effects are merged, independent of time at which they happen. Invariant conditions like (over all (at ?a ?c)) in the action board are added into the precondition set. We discuss the rationale for this step in Section 4.1.\nGrounding Propositions Fact-space exploration is a relaxed enumeration of the planning problem to determine a superset of all reachable facts. Algorithmically, a FIFO fact queue is compiled. Successively extracted facts at the front of the queue are matched to the operators. Each time all preconditions of an operator are fulfilled, the resulting atoms according to the positive effect (add) list are determined and enqueued. This allows us to separate off constant facts from fluents, since only the latter are reached by exploration.\nClustering Atoms For a concise encoding of the propositional part we separate fluents into groups, so that each state in the planning space can be expressed as a conjunction of (possibly trivial) facts drawn from each fact group (Edelkamp & Helmert, 1999). More precisely, let #pi(o1, . . . , oi−1, oi+1, . . . , on) be the number of objects oi for which the fact (p o1 . . . on) is true. We establish a single-valued invariant at i if #pi(o1, . . . , oi−1, oi+1, . . . , on) = 1. To allow for a better encoding, some predicates like at and in are merged. In the example, three groups determine the unique position of the persons (one of five) and one group determines the position of the plane (one of four). Therefore, 3 · ⌈log 5⌉ + 1 · ⌈log 4⌉ = 11 bits suffice to encode the total of 19 fluents.\nGrounding Actions Fact-space exploration also determines all grounded operators. Once all preconditions are met and grounded, the symbolic effect lists are instantiated. In our case we determine 98 instantiated operators, which, by some further simplifications that eliminate duplicates and trivial operators (no-ops), are reduced to 43.\nGrounding Functions Simultanous to fact space exploration of the propositional part of the problem, all heads of the numerical formulae in the effect lists are grounded. In the example case only three instantiated formulae are fluent (vary with time): (fuel plane) with initial value 750 as well as total-fuel-used and total-time both initialized with zero. All other numerical predicates are in fact constants that can be substituted in the formula-bodies. In the example, the effect in (board dan city-a) reduces to (increase (total-time) 30), while (zoom plane city-a city-b) has the numerical effects (increase (total-time) 150),(increase (total-fuel-used) 300)), and (decrease (fuel plane) 300). Refuelling, however, does not reduce to a single rational number, for example the effects in (refuel plane city-a) only simplify to (increase (total-time) (/ (- (750 (fuel plane)) / 12.5))) and (assign (fuel plane) 750). To evaluate the former assignment especially for a forward chaining planner, the variable (total-time) has to be instantiated on-the-fly. This is due to the fact that the value of the quantity (fuel plane) is not constant and itself changes over time.\nSymmetry Detection Regularities of the planning problem with respect to the transposition of domain objects is partially determined in the static analyzer and is addressed in detail in Section 5.\nThe intermediate textual format of the static analyzer in annotated grounded PDDLlike representation serves as an interface for other planners or model checkers, and as an additional resource for plan visualization. Figures 5 and 6 show parts of the intermediate representation as inferred in the Zeno-Travel example."
    }, {
      "heading" : "3.3 Heuristics",
      "text" : "MIPS incorporates the following heuristic estimates.\nRelaxed planning heuristic (RPH) Approximation of the number of planning steps needed to solve the propositional planning problem with all delete effects removed (Hoffmann & Nebel, 2001). The heuristic is constructive, that is it returns the set of operators that appear in the relaxed plan.\nNumerical relaxed planning heuristic (numerical RPH) Our extension to RPH to deal with with numbers is a combined propositional and numerical approximation scheme allowing multiple operator application.\nPattern database heuristic (explicit PDB) Different planning space abstractions are found in a greedy manner, yielding a selection of pattern databases that fit into main memory. In contrast to RPH, pattern database can be designed to be disjoint yielding an admissible estimate as needed for optimal planning in A* (Edelkamp, 2001c).\nSymbolic pattern database heuristic (symbolic PDB) Symbolic PDBs apply to explicit and symbolic heuristic search engines (Edelkamp, 2002b). Due to the succinct BDD-representation of sets of states, symbolic PDBs are often orders of magnitudes larger than explicit ones.\nScheduling relaxed plan heuristic (scheduling RPH) Critical-path analysis through scheduling guide the plan finding phase. Like RPH, which computes the length of the greedily extracted sequential plan, scheduling RPH also takes the relaxed sequence of operators into account, but searches for a suitable parallel arrangement, which in turn defines the estimator function."
    }, {
      "heading" : "3.4 Exploration Algorithms",
      "text" : "The algorithm portfolio includes three main explicit heuristic search algorithms.\nA* The A* algorithm (Hart, Nilsson, & Raphael, 1968) is a variant of Dijkstra’s singlesource shortest path exploration scheme executed on a re-weighted state space graph. For lower bound heuristics, A* can be shown to generate optimal plans (Pearl, 1985). Weighting the influence of the heuristic estimate may accelerate solution finding, but also affects optimality (Pohl, 1977).\nIterative-Deepening A* (IDA*) The memory-limited variant of A* is suited to large exploration problems with evaluation functions of small integer range and low time complexity (Korf, 1985). IDA* can be extended with bit-state hashing (Edelkamp & Meyer, 2001) to improve duplicate detection with respect to ordinary transposition tables (Reinefeld & Marsland, 1994).\n(Enforced) Hill Climbing (HC) The approach is another compromise between exploration and exploitation. Enforced HC searches with an improved evaluation in a breadth-first manner and commits established action selections as final (Hoffmann, 2000). Enforced HC is complete in undirected problem graphs.\nMIPS also features the following two symbolic search algorithms2.\n2. For non-deterministic domains, we have started implementing the weak, strong and strong cyclic exploration algorithms of (Cimatti, Roveri, & Traverso, 1998).\nBidirectional Symbolic Breadth-First-Search (BDD-BFS) The implementation performs bidirectional blind symbolic search, choosing the next search direction to favor the faster execution from the previous iterations (Edelkamp & Helmert, 1999).\nSymbolic A* (BDDA*) The algorithm (Edelkamp & Reffel, 1998) performs guided symbolic search and takes a (possibly partitioned) symbolic representation of the heuristic as an additional input."
    }, {
      "heading" : "3.5 Composition of the Competition Version",
      "text" : "In Figure 1 we have shaded the parts that were actually used in the competition version of MIPS in dark gray. We used the relaxed planning heuristic for sequential plan generation. The scheduling relaxed planning heuristic was used in temporal domains. Only in Level 2 problems did we use the numerically extended RPH, since it was added to the system in the final weeks of the competition. We experimented with (symbolic) pattern databases with mixed results. Since pattern databases are purely propositional in our implementation and do not provide the retrieval of operators in the optimal abstract plan, we did not include them in the competition version.\nOur approach to extend the relaxed planning heuristic with numerical information helps to find plans in challenging numerical domains like Settlers and was influenced by Hoffmann’s work on his competing planner Metric-FF (Hoffmann, 2002a). It builds a relaxed planning graph by computing a fixed-point of a state vector restricted to monotonically increasing propositional and numerical variables. Our version for integrating numbers into the relaxed planning heuristic is not as general as Hoffmann’s contribution: it is restricted to variable-to-constant comparisons and lacks the ability to simplify linear constraints. Therefore, we omit the algorithmic details in this paper.\nWe decided not to employ (enforced) hill climbing for explicit plan generation as is done in Metric-FF and probably LPG. Instead we applied A* with weight 2, that is the merit for all states S ∈ S was fixed as f(S) = g(S)+2 ·h(S). The more conservative plan generation engine was chosen to avoid unrecognized dead-ends, which we expected to be present in benchmark problems. Our objective was that, at least, completeness should be preserved. We also avoided known incomplete pruning rules, like action relevance cuts (Hoffmann & Nebel, 2001) and goal ordering cuts (Koehler & Hoffmann, 2000).\nIn MIPS, (weighted) A* accesses both a Dial and a Weak-Heap priority queue data structure. The former is used for propositional planning only, while the latter applies to general planning with scheduling estimates. A Dial priority queue (Dial, 1969) has linear run time behavior, if the maximal value w(u, v) + h(v) − h(u) of all edges (u, v) in the weighted state space graph (labelled with heuristic h) is bounded by a constant. WeakHeaps (Edelkamp & Stiegeler, 2002) are simple and efficient relaxations to ordinary heaps. Priority queues have been implemented as dynamic tables that double their sizes if they become filled. Moreover, MIPS stores all generated and expanded states in a hash table with chaining 3. As a further compression of the planning state space, all variables that appear in the objective function are neglected from hash address calculations and state\n3. An alternative storage structure is a collection of persistent trees (Bacchus & Kabanza, 2000), one for each predicate. In the best case, queries and update times for the structure are logarithmic in the number of represented atoms.\ncomparisons. In general, this may lead to a sub-optimal pruning of duplicates. However, for most benchmark domains this will not destroy optimality, since variables addressed in the objective function are frequently monotonic and synonyms found later in the search refer to worse solutions.\nThe price to be paid for selecting A*, especially in planning problems with large branching factors, is that storing all frontier nodes is space consuming. Recent techniques for partial expansion of the horizon list (Yoshizumi, Miura, & Ishida, 2000) or reduced storage of the visited list (Korf & Zhang, 2000; Zhou & Hansen, 2003) have not been included to the system. In most cases, the number of expanded nodes was often not that large, while computing the relaxed planning estimate appeared to be the computational bottleneck. In retrospect, in the domains that were chosen, dead-ends were not central, so that hill climbers appeared to be more effective at finding solutions.\nIn temporal domains we introduced an additional parameter δ to scale the influence between propositional estimates (fp(S) = gp(S) + 2 · hp(S)) and scheduled ones (fs(S) = gs(S)+2 ·hs(S)). More precisely, we altered the comparison function for the priority queue, so that a comparison of parallel length priorities was invoked if the propositional difference of values was not larger than δ ∈ IN0. A higher value of δ refers to a higher influence of the scheduling RPH, while δ = 0 indicates no scheduling at all. In the competition we produced data with δ = 0 (pure MIPS), and δ = 2 (optimized MIPS). In most comparisons of MIPS to other planners the plain version is used, since it produces more solutions.\nIn (Edelkamp, 2002a) we experimented with an enumeration approach to fix numerical variables to a finite domain, and with an any-time wrapper for optimization of objective functions. These options were excluded from the competition version because of their unpredictable impact on the planner’s performance."
    }, {
      "heading" : "3.6 Visualization",
      "text" : "Visualization is important to ease plan understanding and to quickly detect inefficiencies in the plan generation module. For visualization of plans with MIPS we extended the animation system Vega (Hipke, 2000); a Client-Server architecture that runs an annotated algorithm on the server side, which is visualized on the client side in a Java frontend. The main purpose of the server is to make algorithms accessible through TCP/IP. It is able to receive commands from multiple clients at the same time. We have extended Vega in two ways (cf. Figures 7 and 8).\nGannt Chart Visualization Gannt Charts are representations for schedules, in which horizontal bars are drawn for each activity, indicating estimated duration/cost. The user selects any planner to be executed and the domain and problem file, which are interpreted as command line options. Alternatively, established plans can be sent directly to the visualizer with a void planner that merely mirrors the solution file.\nBenchmark Visualization The second extension is a program suite to visualize all competition domains. At the moment, only sequential plans are shown. For temporal plans, a refined simulation is required, like the one produced by the PDDL2.1 plan validator. Fortunately, in MIPS each temporal plan is a rescheduling of a sequential one.\nThe images that represent domain objects were collected with an image web search engine4. To generalize from specific instances, we advised the MIPS planner to export propositional and numeric state infomation of an established plan in c-like syntax, which in turn is included as a header by the domain visualizer."
    }, {
      "heading" : "4. PDDL2.1 Planning",
      "text" : "In this section we elaborate on metric and temporal planning in MIPS. We give a formal description on grounded planning instances and introduce the temporal model that we have\n4. We used Google (cf. www.google.de) and searched for small GIFs\nchosen. Next we look at operator dependency and the resulting action precedence relation. We discuss optimality of the approach and some anomalies that can occur during state space pruning. Last but not least, we turn to the treatment of arbitrary plan objective functions.\nTable 1 displays the basic terminology for sets used in this paper. As in most currently successful planning system, MIPS grounds parameterized information present in the domain description. For each set we infer a suitable index set, indicated by a bijective mapping φ from each set to a finite domain. This embedding is important to deal with unique identifiers of entities instead of their textual or internal representation. The arrays containing the corresponding information can then be accessed in constant time.\nConsequently, like several other planning systems, MIPS refers to grounded planning problem representations.\nDefinition 1 (Grounded Planning Instance) A grounded planning instance is a quadruple P = 〈S,I,O,G〉, where S is the set of planning states, I ∈ S is the initial state, G ⊆ S is the set of goal states. In a mixed propositional and numerical planning problem the state space S is given by\nS ⊆ 2F × IR|V|,\nwhere 2F is the power set of F . Therefore, a state S ∈ S is a pair (Sp, Sn) with propositional part Sp ∈ 2 F and numerical part Sn ∈ IR |V|.\nFor the sake of brevity, we assume the operators are in normal form, which means that propositional parts (preconditions and effects) satisfy standard STRIPS notation (Fikes & Nilsson, 1971) and numerical parts are given in the form of arithmetic trees t taken from the set of all trees T with arithmetic operations in the nodes and numerical variables and evaluated constants in the leaves. However, there is no fundamental difference for a more general representation of preconditions and effects. The current implementation in MIPS simplifies ADL expressions in the preconditions and takes generic precondition trees for the numerical parts, thereby including comparison symbols, logical operators and arithmetic subtrees5.\nDefinition 2 (Syntax of Grounded Planning Operators) An operator o ∈ O in normal form o = (α, β, γ, δ) has propositional preconditions α ⊆ F , propositional effects β = (βa, βd) ⊆ F2 with add list βa and delete list βd, numerical preconditions γ, and numerical effects δ. A numerical precondition c ∈ γ is a triple c = (hc,⊗, tc), where hc ∈ V, ⊗ ∈ {≤, <,=, >,≥}, and tc ∈ T , where T is an arithmetic tree. A numerical effect m ∈ δ is a triple m = (hm,⊕, tm), where hm ∈ V, ⊕ ∈ {←, ↑, ↓} and tm ∈ T . In this case, we call hm the head of the numerical effect.\n5. In newer versions of MIPS mixing numerical and logical preconditions of the form (or P (< F 3)), with P ∈ F and F ∈ V is in fact feasible. Boolean expressions are put into negational normal form and a disjunction in the precondition will produce different action instantiations.\nObviously, ⊗ ∈ {≤, <,=, >,≥} represents the associated comparison relation, ← denotes an assignment to a variable, while ↑ and ↓ indicate a respective increase or decrease operation.\nDefinition 3 (Constraint Satisfaction and Modifier Update) Let φ be the index mapping for variables. A vector Sn = (S1, . . . , S|V|) of numerical variables satisfies a numerical constraint c = (hc,⊗, tc) ∈ γ if Sφ(hc) ⊗ eval(Sn, tc) is true, where eval(Sn, tc) ∈ IR is obtained by substituting all v ∈ V in tc by Sφ(hc) followed by a simplification of tc.\nA vector Sn = (S1, . . . , S|V|) is updated to the vector S ′ n = (S ′ 1, . . . , S ′ |V|) by modifier\nm = (hm,⊕, tm) ∈ δ, if\n• S′φ(hm) = eval(Sn, tm) for ⊕ = ←,\n• S′φ(hm) = Sφ(hm) + eval(Sn, tm) for ⊕ = ↑, and\n• S′φ(hm) = Sφ(hm) − eval(Sn, tm) for ⊕ = ↓.\nWe next formalize the application of planning operators to a given state.\nDefinition 4 (Semantics of Grounded Planning Operator Application) An operator o = (α, β, γ, δ) ∈ O applied to a state S = (Sp, Sn), Sp ∈ 2 F and Sn ∈ IR |V|, yields a successor state S′ = (S′p, S ′ n) ∈ 2 F × IR|V| as follows.\nIf α ⊆ Sp and Sn satisfies all c ∈ γ then S ′ p = (Sp \\βd)∪βa and the vector Sn is updated\nfor all m ∈ δ .\nThe propositional update S′p = (Sd \\ βd) ∪ βa is defined as in standard STRIPS. As an example take the state S = (Sp, Sn) with\nSp ={(at ernie city-d), (at plane city-a), (at scott city-d), (in dan plane)}\nSn ={(fuel plane) : 83.3333, (total-fuel-used) : 1666.6667, (total-time) : 710}.\nThe successor S′n = (S ′ p, S ′ n) of S due to action (debark dan plane city-a) with\nS′p ={(at dan city-a), (at ernie city-d), (at plane city-a), (at scott city-d)} S′n ={(fuel plane) : 83.3333, (total-fuel-used) : 1666.6667, (total-time) : 730}.\nIn some effect lists the order of update operations is important. For example when refuelling the aircraft in ZenoTravel, cf. Figure 6, the fuel level has to be reset after variable total-time is updated.\nThe set of goal states G is often given as G = (Gp,Gn) with a partial propositional state description Gp ⊂ F , and Gn as a set of numerical conditions c = (hc,⊗, tc). Moreover, the arithmetic trees tc usually collapses to simple leaves labelled with numerical constants. Hence, only for the sake of simplifying the complexity analysis for object symmetry we might assume that |Gn| ≤ |V|. Complex goal description are no limitation to the planner, since they can easily transformed to preconditions of an goal-enabling opererator."
    }, {
      "heading" : "4.1 Temporal Model",
      "text" : "The simplest approach for solving a temporal planning problem is to generate a sequential plan. Of course, this option assumes that the temporal structure contributes only to the value of the plan and not to its correctness. That is, it assumes that there is no necessary concurrency in a valid plan. In cases in which actions achieve conditions at their start points and delete them at their end points, for example, concurrency can be a necessary part of the structure of a valid plan.\nDefinition 5 (Sequential Plan) A solution to a planning problem P = 〈S,I,O,G〉 in the form of a sequential plan πs is an ordered sequence of operators Oi ∈ O, i ∈ {1, . . . , k}, that transforms the initial state I into one of the goal states G ∈ G, i.e., there exists a sequence of states Si ∈ S, i ∈ {0, . . . , k}, with S0 = I, Sk = G such that Si is the outcome of applying Oi to Si−1, i ∈ {1, . . . , k}.\nThe time stamp ti for a durational operator Oi, i ∈ {1, . . . , k} is its starting time. If d(Oi) is the duration of operator Oi, then ti = ∑i−1 j=1 d(Oj).\nFor sequential plans, time stamps are calculated in MIPS using the extra variable total-time. This variable is updated when scheduling operators. An example of a sequential plan with time stamps is shown in Figure 12.\nMinimizing sequential plan length was the only objective in the first and second planning competitions. Since Graphplan-like planners (Blum & Furst, 1995) like IPP (Koehler, Nebel, & Dimopoulos, 1997) and STAN (Long & Fox, 1998) already produced parallel plans (assuming action duration 1), this was indeed a limiting factor in evaluating plan quality. The most important reason for this artificial restriction was that total-ordered plans were easier to automatically validate, a necessity for checking correctness in a competition.\nPDDL 2.1 domain descriptions include temporal modifiers at start, over all, and at end, where the label at start denotes the preconditions and effects at invocation time of the action, over all refers to an invariance condition and at end to the finalization conditions and consequences of the action.\nIn Figure 9 we show two different options for flattening this information to simple preconditions and effects in order to derive the semantic for sequential plans. In the first case (top right), the compound operator is split into three smaller parts, one for action invocation, one for invariance maintenance, and one for action termination. This is the semantics suggested by (Fox & Long, 2003).\nIn PDDL2.1 there are no effects in the invariance pattern, i.e. B′ = ∅. As in action board, it is quite natural to code invariance in the form of conditions (B) that perform no actual status change: when a person boards an aircraft in a city the aircraft is required to remain at the city throughout the action. When moving through a corridor, the status of being in the corridor that could be encoded in the invariant would change at the starting time of the action execution.\nMoreover, we found that in the benchmarks it is uncommon that new effects in at-start are preconditioned for termination control or invariance maintenance, i.e. A′ ∩ (B ∪ C) = ∅. Even though the intersection of conditions and effects are not formally defined yet, this can be interpreted as executing one construct does not interfere with the other one. This reflects\na possible partition of an operator into sub-operators A, B, C, A′, B′, and C ′. Dependence and transposition of such separated conditions and effects are considered in Section 4.2.\nIf we consider the example problem once more, we observe, that in the action board, A′ consists of the at (person airplane) predicate. As seen above, B requires the plane to stay at the city of boarding, while C is empty. In action zoom, A′ contains the effect that the plane is no longer at the location where the flight started, and B and C are both empty. In all cases we have A′ ∩ (B ∪ C) = ∅.\nIf B′ = ∅ and A′ ∩ (B ∪ C) = ∅ then the sequential execution of the sequence of sub-operators (A,A′, B,B′, C,C ′) is equal to the execution sequence (A,B,C,A′, B′, C ′). The reasoning is as follows. Since B′ = ∅ we have (A,A′, B,B′, C,C ′) = (A,A′, B,C,C ′). Conditions A′ ∩ B = ∅ and A′ ∩ C = ∅ allows us to exchange the order of the corresponding items, so that (A,A′, B,C,C ′) = (A,B,C,A′, C ′). Once more, we apply B′ = ∅ to derive (A,B,C,A′, C ′) = (A,B,C,A′, B′, C ′). The consequence remains valid if the condition B′ = ∅ is weakened to B′ ∩ C = ∅.\nIn MIPS the operator representation at the bottom right of Figure 9 was chosen. Note that the intermediate format of the example problem in Figures 5 and 6 implicitly assumed this temporal model. For sequential planning in the competition benchmark domains we have not observed many deficiencies with this model6.\nHowever, the applicability of the model for exploiting parallelism is limited. For example consider two people that lift a table from two sides at once, which could not be done with just one person alone. In this case we have a parallel execution of a set of actions that cannot be totally ordered. This is not allowed in MIPS. It may be argued that defining such an action that requires two different persons to be at a certain place would require the equality construct in PDDL or some form of numerical maintenance of the number of people in the room, but we found another (artificial) example of a planning problem with no total order. Consider the simple STRIPS planning problem domain with I = {B}, G = {{A,C}}, and O = {({B}, {A}, {B}), ({B}, {C}, {B})}. Obviously, both operators are needed for goal achievement, but there is no sequential plan of length 2, since B is deleted in both operators. However, a parallel plan could be devised, since all precondition are fulfilled at the first time step.\n6. In current versions of MIPS we have refined the model, where at-start, over all, and at-end information is preserved through the grounding process and is attached to each action. The approach does allow dependent operators to overlap and minimizes the number of ǫ gaps, between start-start, start-end and end-end exclusions. In some of the domains, this improvement yields much better solutions."
    }, {
      "heading" : "4.2 Operator Dependency",
      "text" : "The definition of operator dependency enables computing optimal schedules of sequential plans with respect to the generated action sequence and its causal operator dependency structure. If all operators are dependent (or void with respect to the optimizer function), the problem is inherently sequential and no schedule leads to any improvement.\nDefinition 6 (Dependency/Mutex Relation) Let L(t) denote the set of all leaf variables in the tree t ∈ T . Two grounded operators O = (α, β, γ, δ) and O′ = (α′, β′, γ′, δ′) in O are dependent/mutex, if one of the following three conflicts hold.\nPropositional conflict The propositional precondition set of one operator has a nonempty intersection with the add or the delete list of the other, i.e., α ∩ (β′a ∪ β ′ d) 6= ∅\nor (βa ∪ βd) ∩ α ′ 6= ∅.\nDirect numerical conflict The head of a numerical modifier of one operator is contained in some condition of the other one, i.e. there exists a c′ = (h′c,⊗, t ′ c) ∈ γ\n′ and an m = (hm,⊕, tm) ∈ δ with hm ∈ L(t ′ c) ∪ {h ′ c} or there exists a c = (hc,⊗, tc) ∈ γ and an m′ = (h′m,⊕, t ′ m) ∈ δ ′ with h′m ∈ L(tc) ∪ {hc}.\nIndirect numerical conflict The head of the numerical modifier of one operator is contained in the formula body of the modifier of the other one, i.e., there exists an m = (hm,⊕, tm) ∈ δ and m ′ = (h′m,⊕, t ′ m) ∈ δ ′ with hm ∈ L(t ′ m) or h ′ m ∈ L(tm).\nAs an example, the operators (board scott plan city-a) and (fly plane city-a city-c) have a propositional conflict on the fluent (at plane city-a), while (refuel plane-a city-a) and (fly plane city-a city-c) have a direct numerical conflict on the variable (fuel plane). Indirect conflicts are more subtle, and do not appear in the example problem.\nWe will use dependency to find an optimal concurrent arrangement of the operators in the sequential plan. If O2 is dependent on O1 and O1 appears before O2 in the sequential plan, O1 has to be invoked before O2 starts. The dependence relation is reflexive, i.e. if O is in conflict with O′ then O′ is in conflict with O. Moreover, it appears restrictive when compared to the PDDL 2.1 guidelines for mutual exclusion (Fox & Long, 2003), which allows operators to be partially overlapping even if they are dependent.\nHowever, it is possible to generalize our approach. If, according to the model of Fox and Long, the two actions Oi are represented as (Ai, A ′ i, Bi, B ′ i, Ci, C ′ i), i ∈ {1, 2}, the dependency violation between O1 and O2 can be located by identifying the sub-operators that interact. In fact we may identify eight possible refined conflicts in which (A1 ∪ A ′ 1) interacts with (A2 ∪ A ′ 2), (A1 ∪ A ′ 1) interacts with (B2 ∪ B ′ 2), (A1 ∪ A ′ 1) interacts with (C2 ∪C ′ 2), (B1 ∪B ′ 1) interacts with (A2 ∪A ′ 2), (B1 ∪B ′ 1) interacts with (C2 ∪C ′ 2), (C1 ∪C ′ 1) interacts with (A2 ∪ A ′ 2), (C1 ∪ C ′ 1) interacts with (A2 ∪ A ′ 2), or (C1 ∪ C ′ 1) interacts with (A2∪A ′ 2). By asserting duration zero for the pair (Ai, A ′ i), d(A) for (Bi, B ′ i), and again zero for the pair (Ci, C ′ i), one can fix the earliest start and end time of O2 with respect to O1.\nIn the competition version of MIPS, we stick to the simplified temporal model. For the competition domains, improving sequential plans according to this dependency relation turned out to produce plans of sufficient quality.\nIn our implementation, the dependence relation is computed beforehand and tabulated for constant time access. To improve the efficiency of pre-computation, the set of leaf variables is maintained in an array, once the grounded operator is constructed.\nThe original Graphplan definition of the propositional mutex relation is close to ours. It fixes interference as β′d ∩ (βa ∪ α) 6= ∅ and (β ′ a ∪ α ′) ∩ βd 6= ∅.\nLemma 1 If βd ⊆ α and β ′ d ⊆ α ′, operator inference in the Graphplan model is implied by the propositional MIPS model of dependence.\nProof: If βd ⊆ α and β ′ d ⊆ α ′, for two independent operators o = (α, β) and o′ = (α′, β′): α∩ (β′a ∪β ′ d) = ∅ implies βd ∩ (β ′ a∪β ′ d) = ∅, which in turn yields βa ∩β ′ d = ∅. The condition β′a ∩ βd = ∅ is inferred analogously.\nThe notion of dependency is also related to partial order reduction in explicit-state model checking (Clarke et al., 1999), where two operators O1 and O2 are independent if for each state S ∈ S the following two properties hold:\n1. Neither O1 or O2 disable the execution of the other.\n2. O1 and O2 are commutative, i.e. O1(O2(S)) = O2(O1(S)) for all S.\nThe next result indicates that both state space enumeration approaches refer to the same property.\nTheorem 1 (Commutativity) Two independent (STRIPS) operators O = (α, β) and O′ = (α′, β′) with βd ⊆ α and β ′ d ⊆ α\n′ are commutative and preserve the enabled property (i.e. if O and O′ are enabled in S then O is enabled in O′(S) and O′ is enabled in O(S)).\nProof: Since βd ⊆ α and β ′ d ⊆ α ′, we have βa∩β ′ d = ∅ and β ′ a∩βd = ∅ by Lemma 1. Let\nS′ be the state ((S \\βd)∪βa) and let S ′′ be the state ((S \\β′d)∪β ′ a). Since (β ′ a∪β ′ d)∩α = ∅, O is enabled in S′′, and since (βa ∪ βd) ∩ α ′ = ∅, O′ is enabled in S′. Moreover,\nO(O′(S)) = (((S \\ β′d) ∪ β ′ a) \\ βd) ∪ βa\n= (((S \\ β′d) \\ βd) ∪ β ′ a) ∪ βa = S \\ (β′d ∪ βd) ∪ (β ′ a ∪ βa) = S \\ (βd ∪ β ′ d) ∪ (βa ∪ β ′ a) = (((S \\ βd) \\ β ′ d) ∪ βa) ∪ β ′ a = (((S \\ βd) ∪ βa) \\ β ′ d) ∪ β ′ a = O ′(O(S)).\nAs a consequence, operator independence indicates possible transpositions of two operators O1 and O2 to prune exploration in sequential plan generation. A less restrictive notion of independence, in which several actions may occur at the same time even if one deletes an add-effect of another is provided in (Knoblock, 1994). To detect domains for which parallelization leads to no improvement, we utilize the following sufficient criterion.\nDefinition 7 (Inherent Sequential Domains) A planning domain is said to be inherently sequential if each operator in any sequential plan is either instantaneous (i.e. with zero duration) or dependent on its immediate predecessor.\nThe static analyzer checks this by testing each operator pair. While some benchmark domains like DesertRats and Jugs-and-Water are inherently sequential, others like ZenoTravel and Taxi are not.\nDefinition 8 (Parallel Plan) A solution to a planning problem P = 〈S,I,O,G〉 in the form of a parallel plan πc = ((O1, t1), . . . , (Ok, tk)) is an arrangement of operators Oi ∈ O, i ∈ {1, . . . , k}, that transforms the initial state I into one of the goal states G ∈ G, where Oi is executed at time ti ∈ IR ≥0.\nAn example of a parallel plan for the ZenoTravel problem is depicted in Figure 12. Backstöm (1998) clearly distinguishes partially ordered plans (O1, . . . , Ok, ), with the relation ⊆ {O1, . . . , Ok} 2 being a partial order (reflexive, transitive, and antisymmetric), from parallel plans (O1, . . . , Ok, ,#), with # ⊆ ( ∪ −1) (irreflexive, symmetric) expressing, which actions must not be executed in parallel.\nDefinition 9 (Precedence Ordering) An ordering d induced by the operators O1, . . . , Ok is defined by"
    }, {
      "heading" : "Oi d Oj : ⇐⇒ Oi and Oj are dependent and 1 ≤ i < j ≤ k.",
      "text" : "Precedence is not a partial ordering, since it is neither reflexive nor transitive. By computing the transitive closure of the relation, however, precedence could be extended to a partial ordering. A sequential plan O1, . . . , Ok produces an acyclic set of precedence constraints Oi d Oj, 1 ≤ i < j ≤ k, on the set of operators. It is also important to observe, that the constraints are already topologically sorted according to d with the index order 1, . . . , k.\nDefinition 10 (Respecting Precedence Ordering in Parallel Plan) For O ∈ O let d(O) ∈ IR≥0 be the duration of operator O in a sequential plan. In a parallel plan πc = ((O1, t1), . . . , (Ok, tk)) that respects d, we have ti + d(Oi) ≤ tj for Oi d Oj , 1 ≤ i < j ≤ k.\nFor optimizing plans (Bäckström, 1998) defines parallel execution time as max{ti + d(Oi) | Oi ∈ {O1, . . . , Ok}}, so that if Oi Oj, then ti + d(Oi) ≤ tj, and if Oi#Oj , then either ti + d(Oi) ≤ tj or tj + d(Oj) ≤ ti. These two possible choices in # are actually not apparent in our approach, since we already have a precedence relation at hand and just seek the optimal arrangement of operators. Consequently we assert that only one option, namely ti + d(Oi) ≤ tj can be true, reducing # to d. In order to find optimal schedules of sequential plans an approach similar to (Bäckström, 1998) would be necessary. This would dramatically increase the computational complexity, since optimal scheduling of a set of fixed-timed operators is NP-hard. Therefore, we decided to restrict the dependency relation to d.\nDefinition 11 (Optimal Parallel Plan) An optimal parallel plan with respect to a sequence of operators O1, . . . , Ok and precedence ordering d is a plan π\n∗ = ((O1, t1), . . . , (Ok, tk)) with minimal parallel execution time OPT = max{ti + d(Oi) | Oi ∈ {O1, . . . , Ok}} among all parallel plans πc = ((O1, t ′ 1), . . . , (Ok, t ′ k)) that respect d.\nMany algorithms have been suggested to convert sequential plans into partially ordered ones (Pednault, 1986; Regnier & Fade, 1991; Veloso, Pérez, & Carbonell, 1990). Most of them interpret a totally ordered plan as a maximal constrained partial ordering = {(Oi, Oj) | 1 ≤ i < j ≤ k} and search for less constrained plans. However, the problem of minimum constraint “deordering” has also been proven to be NP-hard, unless the so-called validity check is polynomial (Bäckström, 1998), where deordering maintains validity of the plan by lessening its constrainedness, i.e. ′⊆ for a new ordering ′.\nSince we have an explicit model of dependency and time, optimal parallel plans will not change the ordering relation d at all."
    }, {
      "heading" : "4.3 Critical Path Analysis",
      "text" : "The Project Evaluation and Review Technique (PERT) is a critical path analysis algorithm usually applied to project management problems. A critical path is a sequence of activities such that the total time for activities on this path is greater than or equal to any other path of operators. A delay in any tasks on the critical path leads to a delay in the project. The heart of PERT is a network of tasks needed to complete a project, showing the order in which the tasks need to be completed and the dependencies between them.\nAs shown in Figure 10, PERT scheduling reduces to a variant of Dijkstra’s shortest path algorithm in acyclic graphs (Cormen, Leiserson, & Rivest, 1990). As a matter of fact, the algorithm returns the length of the critical path and not the inferred partially ordered plan. However, obtaining the temporal plan is easy. In the algorithm, e(Oi) is the tentative earliest end time of operator Oi, i ∈ {1, . . . , k}, while the earliest starting times ti for all operators in the optimal plan are given by ti = e(Oi)− d(Oi).\nTheorem 2 (PERT Scheduling) Given a sequence of operators O1, . . . , Ok and a precedence ordering d, an optimal parallel plan π\n∗ = ((O1, t1), . . . , (Ok, tk)) can be computed in optimal time O(k + | d |).\nProof: The proof is by induction on i ∈ {1, . . . , k}. The induction hypothesis is that after iteration i the value e(Oi) is correct, e.g. e(Oi) is the earliest end time of operator\nOi. This is clearly true for i = 1, since e(O1) = d(O1). We now assume that the hypothesis is true 1 ≤ j < i and look at iteration i. There are two choices. Either there is a j ∈ {1, . . . , i − 1} with Oj d Oi. For this case after the inner loop is completed, e(Oi) is set to max{e(Oj) + d(Oj) | Oj d Oi, j ∈ {1, . . . , i − 1}}. On the other hand, e(Oi) is optimal, since Oi cannot start earlier than max{e(Oj) | Oj d Oi, j ∈ {1, . . . , i− 1}}, since all values e(Oj) are already the smallest possible by the induction hypothesis. If there is no j ∈ {1, . . . , i − 1} with Oj d Oi, then e(Oi) = d(Oi) as in the base case. Therefore, at the end, max1≤i≤k e(Oi) is the optimal parallel path length.\nThe time and space complexity of the algorithm Critical-Path are clearly in O(k2), where k is the length of the sequential plan. Using an adjacency list representation these efforts can be reduced to time and space proportional to the number of vertices and edges in the dependence graph, which are of size O(k + | d |). The bound is optimal, since the input consists of Θ(k) operators and Θ(| d |) dependencies among them.\nCan we apply critical path scheduling, even if we consider the temporal model of Fox and Long, allowing overlapping operator execution of dependent operators? The answer is yes. We have already seen that when considering two dependent operators Oi and Oj in the Fox and Long model, we can determine the earliest start (and end) time of Oj with respect to the fixed start time of Oi. This is all that we need. The proof of Theorem 2 shows that we can determine the earliest end time for the operators sequentially."
    }, {
      "heading" : "4.4 On the Optimality of MIPS",
      "text" : "Since MIPS optimally schedules sequential plans, the question remains, will the system eventually find an optimal plan? In the competition, the system terminates when the first sequential plan is found. Since the relaxed planning heuristic is not admissible, all A* variants cannot guarantee optimal (sequential or parallel) plans. However, computing optimal plans is desirable, even if – due to limited computational resources – finding optimal plans is hard.\nAccording to our temporal model, in an optimal parallel plan, each operator either starts or ends at the start or end time of another operator. Therefore, at least for a finite number of actions in the optimal plan, we have a possibly exponential but finite number of possible parallel plans.\nThis immediately leads to the following naive plan enumeration algorithm: For all |O|i operator sequences of length i, i ∈ IN, generate all possible parallel plans, check for each individual schedule if it transforms the initial state into one of the goals, and take the sequence with smallest parallel plan length. Since all parallel plans are computed, this yields a complete and optimal algorithm. As seen in the example of two persons lifting a table, this approach can be more expressive than applying any algorithm that finds sequential plans first. However, the algorithm is very inefficient.\nIn practice, the natural assumption is that each parallel plan corresponds to at least one (possible many) sequential one(s). Conversely, each partially ordered plan can be established by generating a totally ordered plan first and then applying a scheduling algorithm to it to find its best partial-order.\nThe algorithm in the Figure 11 indicates how to wrap a forward chaining planner so that it has any-time performance and gradually improves plan quality. The general state\nexpanding scheme maintains the search horizon in the list Open. For simplicity the maintenance of stored nodes in the list Closed is not shown. In the algorithm, the current best critical path cost α bounds the upcoming exploration process. In turn α is updated each time a plan is found with a shorter critical path.\nAs in the CriticalPath procedure above, the algorithm returns the execution time only, and not the established plan. To compute the plan that meets the returned value α, we also store the schedule of the generating sequence path(S′) in a global record. In most cases, storing S′ is sufficient, since the path and its PERT scheduling can be restored by calling procedure CriticalPath at the end of the procedure.\nAssuming that each optimal parallel plan is a schedule of a sequential plan and the state space is finite, the any-time extension for a cycle-avoiding enumeration strategy is indeed complete and optimal. The reason for completeness in finite graphs is that the number of acyclic paths in G is finite and with every node expansion, such an algorithm adds new links to its traversal tree. Each newly added link represents a new acyclic path, so that, eventually, the reservoir of paths must be exhausted.\nAre there also valid parallel plans that cannot be produced by PERT scheduling of a sequential plan? The answer is no. If a partial ordering algorithm terminates with an optimal schedule, we can generate a corresponding sequential plan while preserving the dependency structure. Optimal PERT-scheduling of this plan with respect to the set of operators and the imposed precedence relation will yield the optimal parallel plan. If all sequential plans are eventually generated, the optimal parallel plan will also be found by PERT scheduling.\nThe problem of enumeration in infinite state spaces is that there can be infinite plateaus where the plan objective function has a constant value. Normally increasing the length of a plan increases the cost. However, this is not true in all benchmark problems, since there\nmay be an infinite sequence of events that do not contribute to the plan objective. For example, loading and unloading tanks in the pre-competition test domain DesertRats does not affect total-fuel consumption, which has to be minimized in one of the instances.\nEnumeration schemes do not contradict known undecidability results in numerical planning (Helmert, 2002). If we have no additional information like a bound on the maximal number of actions in a plan or on the number of actions that can be executed in parallel, we cannot decide whether a cycle-free enumeration will terminate or not. On the other hand if there is a solution, the any-time algorithm will eventually find it."
    }, {
      "heading" : "4.5 Pruning Anomalies",
      "text" : "Acceleration techniques like duplicate detection in sequential plan generation have to be chosen carefully to maintain parallel plan length optimality. This approach does affect parallel optimality, as the following example shows. In the ZenoTravel problem consider the sequences\n(zoom city-a city-c plane), (board dan plane city-c), (refuel plane city-c), (zoom city-c city-a plane), (board scott plane city-a), (debark dan plane city-a), (refuel plane city-a),\nand\n(board scott plane city-a), (zoom city-a city-c plane), (board dan plane city-c), (refuel plane city-c), (zoom city-c city-a plane), (debark dan plane city-a), (refuel plane city-a)\nThe two sets of operators are the same and so are the resulting (sequentially generated) states. However, the PERT schedule for the first sequence is shorter than the schedule for the second one, because boarding scott can be done in parallel with the final two actions in the plan.\nFor small problems, such anomalies can be avoided by omitting duplicate pruning. As an example Figure 12 depicts a sequential plan for the example problem instance and its PERT schedule, which turns out to be the overall optimal parallel plan. Another option is to store the resulting parallel plan for state caching instead of the sequential one. Note that in order to ease generation of sequential solutions for large planning problem instances, in the competition version of MIPS we used sequential state pruning."
    }, {
      "heading" : "4.6 Heuristic Search",
      "text" : "The main drawback of blind path enumeration is that it is seemingly too slow for practical planning. Heuristic search algorithms like A* and IDA* reorder the traversal of states, and (assuming no state caching) do not affect completeness and optimality of the anytime wrapper. The efficiency of the wrapper directly depends on the quality of the path enumeration. In the competition version of MIPS we omitted any-time wrapping, since optimal solutions were not required and the practical run-time behavior is poor.\nInstead we used an A* search engine, that terminates on the first established solution. The question remains: is there still hope of finding near optimal parallel plans? A general result also applicable for infinite graphs was established by (Pearl, 1985): If the cost of every\ninfinite path is unbounded, A*’s cost function f = g + h will preserve optimality. This is additional rationale for choosing an A*-like exploration in MIPS instead of hill climbing or best-first. As in breadth-first search, the rising influence of the g-value is crucial.\nTo find an adequate heuristic estimate for parallel plans is not easy. In fact we have not established a competitive and admissible heuristic, which is required for optimal plan finding in A*. Our choice was a scheduling extension to RPH. In contrast to the RPH, the new heuristic takes the relaxed sequence of operators and searches for a suitable parallel arrangement, which in turn defines the estimator function.\nWe found that adding PERT-schedules for the path to a state and for the sequence of actions in the relaxed plan is not as accurate as the PERT-schedule of the combined paths. Therefore, the classical merit function of A*-like search engines f = g+h of generating path length g and heuristic estimate h has no immediate correspondence for parallel planning. Consequently, we define the heuristic value of scheduling RPH as the parallel plan length of the combined path minus the parallel plan length of the generating path."
    }, {
      "heading" : "4.7 Arbitrary Plan Objectives",
      "text" : "In PDDL 2.1 plan metrics other than minimizing total (parallel) execution time can be specified. This influences the inferred solutions. In Figure 13 we depict two plans found by MIPS for the objective functions of minimizing total-fuel-used, and minimizing the compound (+ (* 10 (total-time)) (* 1 (total-fuel-used))).\nFor the first case we computed an optimal value of 1,333.33, while for the second case we established 7,666.67 as the optimized merit. When optimizing time, the ordering of board and zoom actions is important. When optimizing total-fuel we reduce speed to save fuel consumption to 333.33 per flight but we may board the first passenger immediately. We also save two refuel actions with respect to the first case.\nWhen increasing the importance of time we can trade refueling actions for time, so that both zooming and flight actions are chosen for the complex minimization criterion.\nThe first attempt to include arbitrary plan objectives was to alter the PERT scheduling process. However, the results did not match the ones produced by the validator (Long &\nFox, 2001), in which the final time is substituted in the objective function after the plan has been built.\nThe way MIPS evaluates objective functions with time is as follows. First it schedules the (relaxed or final) sequential plan. Variable total-time is temporarily substituted for the critical path value and the objective formula is evaluated. To avoid conflicts in subsequent expansions, afterwards value total-time is set back to the optimal one in the sequential plan."
    }, {
      "heading" : "5. Object Symmetries",
      "text" : "An important feature of parameterized predicates, functions and action descriptions in the domain specification file is that actions are transparent to different bindings of parameters to objects. Disambiguating information is only present in the problem instance file.\nIn the case of typed domains, many planners, including MIPS, compile all type information into additional predicates, attach additional preconditions to actions and enrich the initial states by suitable object-to-type atoms.\nAs a consequence, a symmetry is viewed as a permutation of objects that are present in the current state, in the goal representation, and transparent to the set of operators.\nThere are n!, n = |OBJ |, possible permutations of the set of objects. Taking into account all type information reduces the number of all possible permutation to\n(\nn\nt1, t2, . . . , tk\n)\n= n!\nt1!t2! . . . tk! .\nwhere ti is the number of objects with type i, i ∈ {1, . . . , k}. In a moderate sized logistic domain with 10 cities, 10 trucks, 5 airplanes, and 15 packages, this results in 40!/(10! · 10! · 5! · 15!) ≥ 1020 permutations.\nTo reduce the number of potential symmetries to a tractable size we restrict symmetries to object transpositions, for which we have at most n(n− 1)/2 ∈ O(n2) candidates. Using type information this number reduces to\nk ∑\ni=1\n(\nti 2\n)\n= k ∑\ni=1\nti(ti − 1)/2.\nIn the following, the set of typed object transpositions is denoted by SYMM. For the Logistics example, we have |SYMM| = 45 + 45 + 10 + 105 = 205."
    }, {
      "heading" : "5.1 Generating Object Symmetries for Planning Problems",
      "text" : "In this section we compute the subset of SYMM that includes all object pairs for which the entire planning problem is symmetric. We start with object transpositions for the smallest entities of a planning problem.\nDefinition 12 (Object Transpositions for Fluents, Variables, and Operators) A transposition of objects (o, o′) ∈ SYMM applied to a fluent f = (p o1, . . . , ok(p)) ∈ F , written as f [o ↔ o′], is defined as (p o′1, . . . , o ′ k(p)), with o ′ i = oi if oi /∈ {o, o ′}, oi = o ′ if oi = o, and oi = o if oi = o ′, i ∈ {1, . . . , k(p)}. Object transpositions [o ↔ o′] applied to a variable v = (f o1, . . . , ok(f)) ∈ V or to an operator O = (a o1, . . . , ok(a)) ∈ O are defined analogously.\nFor example, in the ZenoTravel problem we have (at scott city-a)[scott ↔ dan] = (at dan city-a).\nLemma 2 For all f ∈ F , v ∈ V, O ∈ O, and (o, o′) ∈ SYMM: f [o ↔ o′] = f [o′ ↔ o], v[o ↔ o′] = v[o′ ↔ o], and O[o ↔ o′] = O[o′ ↔ o], as well as f [o ↔ o′][o ↔ o′] = f , v[o ↔ o′][o ↔ o′] = v, and O[o ↔ o′][o ↔ o′] = O.\nThe brute-force time complexity for computing f [o ↔ o′] ∈ F is of order O(k(p)), where k(p) is the number of object parameters in p. However, by pre-computing a O(|SYMM| · |F|) sized lookup table, containing the index of f ′ = f [o ↔ o′] for all (o, o′) ∈ SYMM, this time complexity can be reduced to O(1).\nDefinition 13 (Object Transpositions for States) Let φ be the mapping from set T to {1, . . . , |T |}. An object transposition [o ↔ o′] applied to state S = (Sp, Sn) ∈ S with Sn = (v1, . . . , vk), k = |V|, written as S[o ↔ o ′], is equal to (Sp[o ↔ o ′], Sn[o ↔ o ′]) with\nSp[o ↔ o ′] = {f ′ ∈ F | f ∈ Sp ∧ f ′ = f [o ↔ o′]}\nand Sn[o ↔ o ′] = (v′1, . . . , v ′ k) with vi = v ′ j if φ −1(i)[o ↔ o′] = φ−1(j) for i, j ∈ {1, . . . , k}.\nIn the initial state of the example problem we have I[dan↔ ernie] = I. The definition for variables is slightly more difficult than for predicates, since, in this case, the variable contents, not just their availability, must match.\nThe time complexity to compute Sn[o ↔ o ′] is O(k), since testing φ−1(i)[o ↔ o′] = φ−1(j) is available in time O(1) by building another O(|SYMM| · |V|) sized pre-computed look-up table. Note that these times are worst-case. We can terminate the computation of an object symmetry if a fluent or variable is contradictory. We summarize the complexity results as follows.\nLemma 3 The worst-case time complexity to compute S[o ↔ o′] for state S = (Sp, Sn) ∈ S and (o, o′) ∈ SYMM is O(|Sp|+ |V|) using O(|SYMM| · (|F|+ |V|)) space.\nThe next step is to lift the concept of object transposition to planning problems.\nDefinition 14 (Object Transpositions for Domains) A planning problem P = 〈S,O,I,G〉 is symmetric with respect to the object transposition [o ↔ o′], abbreviated as P[o ↔ o′], if I[o ↔ o′] = I and ∀ G ∈ G: G[o ↔ o′] ∈ G.\nSince goal descriptions are partial, we prefer writing G[o ↔ o′] ∈ G instead of ∀ G ∈ G: G[o ↔ o′] ∈ G. Moreover, we assume the goal description complexity for G to be bounded by O(|Gp|+ |V|).\nFor the ZenoTravel problem, the goal descriptor is purely propositional, containing three facts for the target location of dan, ernie, and scott. In the initial state of the running example the planning problem contains no object symmetry, since I[scott ↔ ernie] 6= I and G[dan ↔ ernie] 6= G.\nApplying Lemma 3 for all (o, o′) ∈ SYMM yields the time complexity needed to establish all object symmetries.\nTheorem 3 (Time Complexity for Object Symmetry Detection) The worst-case run-time to determine the set of all object transpositions for which a planning problem P = 〈S,O,I,G〉 is symmetric is O(|SYMM| · (|Gp|+ |Ip|+ |V|))."
    }, {
      "heading" : "5.2 Including Goal Symmetry Conditions",
      "text" : "Symmetries that are present in the initial state may vanish or reappear during exploration in a forward chaining planner like MIPS. In the DesertRats domain, for example, the initial set of supply tanks is indistinguishable so that only one should be loaded into the truck. Once the fuel levels of the supply tanks decrease or tanks are transported to another location, previously existing symmetries are broken. However, when two tanks in one location become empty, they can once again be considered symmetric.\nGoal conditions, however, do not change over time, only the initial state I transforms into the current state C. Therefore, in a pre-compiling phase we refine the set SYMM to\nSYMM′ ← { (o, o′) ∈ SYMM | G[o ↔ o′] = G } .\nUsually, |SYMM′| is much smaller than |SYMM|. For the ZenoTravel problem instance, the only object symmetry left in SYMM′ is the transposition of scott and ernie.\nTherefore, we can efficiently compute the set\nSYMM′′(C) ← {(o, o′) ∈ SYMM′ | C[o ↔ o′] = C}\nof symmetries that are present in the current state. In the initial state I of the example problem of Zeno-Travel we have SYMM′′(I) = ∅, but once scott and ernie share the same location in a state C this object pair would be included in SYMM′′(C).\nThe definition requires C[o ↔ o′] = C. This does not include symmetric paths from different states. Let C = {(at ernie city-c), (at scott city-d)}. It is possible that there is a symmetric plan for {(at ernie city-d), (at scott city-c)} to a common goal. Viewed differently, complex object symmetries of the form [o1 ↔ o ′ 1][o2 ↔ o ′ 2] are not detected. For the example we observe C[scott ↔ ernie][city-c ↔ city-d] = C. With respect to Theorem 3 this additional restriction reduces the time complexity to detect all remaining object symmetries to O(|SYMM′| · (|Cp|+ |V|))."
    }, {
      "heading" : "5.3 Pruning Operators",
      "text" : "If a planning problem with current state C ∈ S is symmetric with respect to the operator transposition [o ↔ o′] then either the application of operator O ∈ O or the application of operator O[o ↔ o′] is neglected, significantly reducing the branching factor. Lemma 4 indicates how symmetry is used to reduce exploration.\nLemma 4 If operator O is applicable in S and S = S[o ↔ o′] then O[o ↔ o′] is applicable in S and\nO(S)[o ↔ o′] = O[o ↔ o′](S).\nProof: If O is applicable in S then O[o ← o′] is applicable in S[o ← o′]. Since S = S[o ↔ o′], O[o ↔ o′] is applicable in S, and\nO[o ↔ o′](S) = O[o ↔ o′](S[o ↔ o′]) = O(S)[o ↔ o′].\nBy pre-computing an O(|SYMM| · |O|) sized table the index φ(O′) of operator O′ = O[o ↔ o′] can be determined in time O(1) for each (o, o′) ∈ SYMM′.\nDefinition 15 (Pruning Set) Let φ be the index mapping from set T to {1, . . . , |T |} and let Γ(C) be the set of operators that are applicable in state C ∈ S. The pruning set ∆(C) ⊂ Γ(C) is defined as the set of all operators that have a symmetric counterpart and that are not of minimal index. The symmetry reduction Γ′(C) ⊆ Γ(C) is defined as Γ(C) \\∆(C).\nTheorem 4 (Correctness of Operator Pruning) Reducing the operator set Γ(C) to Γ′(C) during the exploration of planning problem P = 〈S,O,I,G〉 preserves completeness7.\nProof: Suppose that for some expanded state C, reducing the operator set Γ(C) to Γ′(C) during the exploration of planning problem P = 〈S,O,I,G〉 does not preserve completeness. Furthermore, let C be the state with this property that is maximal in the exploration order.\nThen there is a sequential plan π = (O1 . . . , Ok) in PC = 〈S,O, C,G〉 with associated state sequence (S0 = C, . . . , Sk ⊆ G). Obviously, Oi ∈ Γ(Si−1), i ∈ {1, . . . , k}. By the choice of C we have O1 ∈ Γ(S0) \\ Γ\n′(S0) = ∆(S0). By the definition of the pruning set ∆(S0) there exists O ′ 1 = O1[o ↔ o\n′] of minimal index that is applicable in S0. Since PC = 〈S,O, C,G〉 = PC [o ↔ o\n′] = 〈S,O, C[o ↔ o′] = C,G[o ↔ o′] = G〉 , we have a sequential plan O1[o ↔ o ′], . . . , Ok[o ↔ o ′] with state sequence (S0[o ↔ o\n′] = S0, S1[o ↔ o′], . . . , Sk[o ↔ o\n′] = Sk) that reaches the goal G. This contradicts the assumption that reducing the operator set Γ(C) to Γ′(C) does not preserve completeness for all C.\nSince the plan objective refers to instantiated predicates and objects, similar to the initial and goal state, it can be symmetry breaking. In order to preserve optimality, one has to additionally check, to see if the object exchange will influence the plan objective. In practice, objective functions are often based on non-parameterized predicates, in which case an optimal planning algorithm will not be affected by symmetry cuts.\n7. Generally completeness means that a planner can find any legal plan. This is not what is intended here. We use completeness here in terms of discarding legal plans in favor to equally good symmetric plans."
    }, {
      "heading" : "5.4 Symmetry Reduction in MIPS",
      "text" : "The main purpose of the restricted implementation in MIPS is to further reduce the run time for object symmetry detection by losing some but not all of its effectiveness. Especially the impact of quantity O(|SYMM′| · |Cp|) for the running time can be considerable.\nThe key observation is that symmetries are also present in fact groups according to their group representatives. As shown in Figure 5, the fact group of dan consists of the facts (at dan city-a), (at dan city-b), (at dan city-c), (at dan city-d), and (in dan plane). Similarily, ernie’s group has facts (at ernie city-a), (at ernie city-b), (at ernie city-c), (at ernie city-d), and (in ernie plane). The ordering of the facts in the groups can be chosen in a way that, except for the change in the group representative, corresponding facts match. Together with the facts in the groups, the operators that change facts of the groups, are stored in an efficient dictionary.\nTherefore, we restrict object transpositions to group representatives. This reduces the set of objects OBJ that MIPS considers to a considerably smaller subset OBJ ′. In the example problem we have |OBJ | = 7, and |OBJ ′| = 4. Many objects, e.g. the objects of type city in ZenoTravel, were not selected as representatives for a single attribute invariance to build a group.\nThe idea is to obtain a possible transposition of fact group representatives, followed by looking at the respective fact positions of the current and goal state. It may happen, that more than one group has fixed representative o ∈ OBJ ′. In this case, we link groups that have representative o in common. For symmetry detection we test the group chains of both objects for a matching current and goal position.\nAs above, symmetries based on non-matching goal predicates can be excluded beforehand. Let RSYMM be the number of remaining symmetries of object representatives. Assume that one representative per group yields a running time for propositional object symmetry detection in state C of O(RSYMM+ |Cp|). The remaining comparisons of variables v ∈ V are implemented as described in the previous section, but are to be performed only for those object pairs that pass the propositional check.\nFor pruning operators, MIPS marks all groups that correspond to an object symmetry and that have larger index as visited. This guarantees that an operator of at least one group is executed. For each expanded state S and each matching operator O ∈ Γ(S) the algorithm checks, whether an applied operator is present in a visited group, in which case it is pruned. The time complexity is O(|Γ(S)|), since operator group containment can be preprocessed and checked in constant time.\nFigure 14 shows the effectiveness of symmetry reduction of the planner MIPS in the DesertRats domain, which scales with respect to the total distance d, d ∈ {300, 400, 500, 600}, that has to be passed (x-axis). In the y direction, the number of expanded states in an A* search of MIPS with object symmetry reduction (right bars) and without symmetry reduction (left bars) is shown on a logarithmic scale. As expected, for larger problems symmetry reduction yields performance gains of more than one order magnitude (d = 500). It also yields solutions to problems where all algorithms without symmetry reduction fail due to memory restrictions (d = 600)8.\n8. The memory bound we used for this example was set to 1/2 GByte."
    }, {
      "heading" : "6. Related Work",
      "text" : "STRIPS problems have been tackled with different planning techniques, most notably by SAT-planning (Kautz & Selman, 1996), IP-planning (Kautz & Walser, 1999), CSPplanning (Rintanen & Jungholt, 1999), graph relaxation (Blum & Furst, 1995), and heuristic search planning (Bonet & Geffner, 2001).\nSolving planning problems with numerical preconditions and effects as allowed in Level 2 and Level 3 problems is undecidable in general (Helmert, 2002). However, the structures of the provided benchmark problems are simpler than the general problem class, so these problems are in fact solvable."
    }, {
      "heading" : "6.1 Temporal Planning Approaches",
      "text" : "The system Metric-FF (Hoffmann, 2002a) extends FF (Hoffmann & Nebel, 2001) as a forward chaining heuristic state space planner for Level 2 problems. Although, MIPS’ plan generator shares several ideas with Metric-FF, Hoffmann’s system has not yet been extended to deal with temporal domains.\nPlanner TP4 (Haslum & Geffner, 2001) is in fact a scheduling system based on grounded problem instances. For these cases all formula trees in numerical conditions and assignments reduce to constants. Utilizing admissible heuristics, TP4 minimizes the plan objective of optimal parallel plan length. Our planner has some distinctive advantages: it handles numerical preconditions, instantiates numerical conditions on the fly and can cope with complex objective functions. Besides its input restriction, in the competition, TP4 was somewhat limited by its focus on producing only optimal solutions.\nThe SAPA system (Do & Kambhampati, 2001) is a domain-independent time and resource planner that can cope with metrics and concurrent actions. SAPA’s general expressivity can be judged to be close to that of MIPS. It adapts the forward chaining algorithm of (Bacchus & Ady, 2001). Both planning approaches instantiate actions on the fly and\ncan therefore, in principle, be adapted to handle flexible mixed propositional and numerical planning problems. The search algorithm in SAPA extends partial concurrent plans instead of parallelizing sequential plans. It uses a relaxed temporal planning graph for the yet unplanned events for different heuristic evaluation functions. As an additional feature, SAPA provides the option of specifying deadlines.\nThe planner LPG (Gerevini & Serina, 2002) is based on local search in planning graphs. It uses a variant of the FF planner for grounding and initial plans are generated through random walk. The subsequent search space of LPG consists of so-called action graphs (Gerevini & Serina, 1999). The temporal module performs action graph modifications transforming an action graph into another one. The fast plan generation algorithm in LPG seems to be the best explanation for the speed advantage that LPG has with respect to MIPS, and the higher number of problems LPG solved in some domains. Optimization in LPG is governed by Lagrange multipliers. In temporal domains, actions are ordered using a precedence graph that is maintained during search, which uses a more refined dependency relation than ours. This may partly explain why plan quality was in fact consistently better than in MIPS.\nIxTeT (Laborie & Ghallab, 1995) is a general constraint-based planning system with its own input format. The planner searches in the space of partial plans and allows general resource and temporal constraints to be posed. The internal representation consists of chronicles, with time as a linearly ordered discrete set of instants, and multi-valued state variables that are either rigid or flexible (contingent, controllable, resources), predicates as temporally qualified expressions (events, assertions, resources), and temporal and atemporal constraints. It is not clear how to compare the expressivity of chronicles with PDDL2.1 constructs. This makes it difficult to link the different temporal models and to determine if the technique of critical path scheduling will be applicable to IxTeT or not. In our opinion this is unlikely, since IxTeT is partial-order. Note that IxTeT further allows conjunction of predicates, subtasks, constraints and conditional expressions, which are not available in PDDL2.1. The analysis of partial plans that drives the planning process is divided into three different modules: feasibility, satisfiability and resource conflict resolution. In the competition domains IxTeT was not able to compete with local search and heuristic search planners.\nHSTS (Muscettola, 1994) is a constraint-based planning system based on temporal activity networks, written in LISP and CRL. At NASA it has been used in many projects like Deep-Space One. It can already represent and reason about metric resources, parallel activities, and general constraints. As in IxTeT the input format is significantly different from PDDL2.1. HSTS has not yet been adapted to represent or reason with conditional branches. However experiences with the HSTS planner showed partial-order planning to be attractive for metric/temporal problems, but with a need for better search control.\nAlthough the PDDL2.1 guidelines in fact do allow infinite branching, the 2002 competition consisted only of finite branching problems. As we indicated earlier, this paper also concentrates on finite branching problems. With finite branching, execution time of an action is fixed, while with infinite branching, a continous range of actions is available.\nThese problems have been confronted by (real-time) model checking for a long time. Some subclasses of infinite branching problems like timed automata exhibit a finite partitioning through a symbolic representation of states (Pettersson, 1999). By the technique of shortest-path reduction a unique and reduced normal form can be obtained. We have\nimplemented this temporal network structure, since this is the main data structure when exploring timed automata as done by the model checker Uppaal (Pettersson, 1999). For this to work, all constraints must have the form xi − xj ≤ c or xi ≤ c. For example, the set of constraints x4 − x0 ≤ −1, x3 − x1 ≤ 2, x0 − x1 ≤ 1, x5 − x2 ≤ −8, x1 − x2 ≤ 2, x4−x3 ≤ 3, x0−x3 ≤ −4, x1−x4 ≤ 7, x2−x5 ≤ 10, and x1−x5 ≤ 5 has the shortest-path reduction x4−x0 ≤ −1, x3−x1 ≤ 2, x5−x2 ≤ −8, x0−x3 ≤ −4, x1−x4 ≤ 7, x2−x5 ≤ 10, and x1 − x5 ≤ 5. If the constraint set is over-constrained, the algorithm will determine unsolvability, otherwise a feasible solution is returned.\nCritical path analysis for timed precedence networks is one of the simpler cases for scheduling. We have achieved a simplification by solving the sequential path problem first. Note that many other scheduling techniques apply the presented critical path analysis as a subcomponent (Syslo, Deo, & Kowalik, 1983)."
    }, {
      "heading" : "6.2 Symmetry Detection in Planning and Model Checkers",
      "text" : "Most previous results in symmetry reduction in planning, e.g. (Guéré & Alami, 2001), neglect the combinatorial explosion of possible symmetries or at least assume that the information on existing symmetries in the domain is supplied by the user.\nIn contrast, our work shares similarities with the approach of Fox & Long (1999,2002) in inferring object symmetry information fully automatically. Fox and Long’s work is based on similarities established by the TIM inference module (Fox & Long, 1998). During the search additional information on the current symmetry level in the form of an object transposition matrix is stored and updated together with each state. Our approach is different in the sense that it efficiently computes object symmetries for each state from scratch and it consumes no extra space per node expansion.\nModel checking research has a long tradition in symmetry reduction (Clarke et al., 1999). In recent work, Rintanen (2003) connects symmetry detection in planning to model checking approaches for transition systems and SAT solving. Experiments are provided for SAT encodings of the Gripper domain; a prototypical example for symmetry detection. In (LluchLafuente, 2003), our model checker HSF-Spin is extended to effectively combine heuristic search with symmetry detection. It also reflects the fact that (HSF-)Spin’s exploration can be modelled using (labelled) transition systems. Positive empirical results are given for non-trivial examples like Peterson’s mutual exclusion algorithm and the Database Manager protocol.\nWe briefly review the fundamental difference between object symmetries (as considered here) and state space symmetries (as considered in model checking).\nThe latter approach constructs a quotient state space problem (P/∼) based on a congruence relation, where an equivalence relation ∼ of S is called a congruence if for all s1, s2, s1 ∈ S with s1 ∼ s2 and operator O ∈ O with O(s1) = s ′ 1 there is an s ′ 2 ∈ S with s′1 ∼ s ′ 2 and an operator O ′ ∈ O with O′(s2) = s ′ 2. We have [O][s] = [s\n′] if and only if there is an operator O ∈ O mapping s to s′ so that s ∈ [s] and s′ ∈ [s′].\nA bijection φ : S → S is said to be a symmetry if φ(I) = I, φ(G) ∈ G for all G ∈ G and for any s, s′ ∈ S with transition from s to s′ there exist a transition from φ(s) to φ(s′). Any set A of symmetries generates a subgroup g(A) called a symmetry group. The subgroup g(A) induces an equivalence relation ∼A on states, defined as s ∼A s ′ if and only\nif φ(s) = s′ and φ ∈ g(A). Such an equivalence relation is called a symmetry relation on P induced by A. The equivalence class of s is called the orbit of s, denoted as [s]A. Any symmetry relation on P is a congruence on P. Moreover, s is reachable if and only if [s]A is reachable from [I]A. This reduces the search for goal G ∈ G to finding state [G].\nTo explore a state space with respect to a state (space) symmetry, a function Canonicalize is needed. Each time a new successor node is generated, it determines a representative element for each equivalence class. Fixing the canonical element is not trivial, so that many systems approximate this normal form. Automatically finding symmetries in this setting is also difficult and can be cast as a computationally hard graph isomorphism problem. Therefore all approaches expect information on the kind of symmetry that is present in the state space graph. One example is a rotational symmetry, defined by a right shift of variables in the state vector."
    }, {
      "heading" : "6.3 Model Checking Planners",
      "text" : "In the 2000 competition, two other symbolic planners took part: PropPlan (Fourman, 2000), and BDDPlan (Hölldobler & Stör, 2000). Although they did not receive any awards for performance, they show interesting properties. PropPlan performs symbolic forward breadth first search to explore propositional planning problems with propositions for generalized action preconditions and generalized action effects. It performed well in the full ADL Miconic-10 elevator domain (Koehler, 2000). ProbPlan is written in the Poly/ML implementation of SML. BDD-Plan is based on solving the entailment problem in the fluent calculus with BDDs. At that time the authors acknowledged that the concise domain encoding and symbolic heuristic search used in MIPS were improvements.\nIn the Model-Based Planner MBP the paradigm of planning as symbolic model checking (Giunchiglia & Traverso, 1999) has been implemented for non-deterministic planning domains (Cimatti et al., 1998), which can be classified into weak, strong, and strong-cyclic planning, with plans that are represented as state-action tables. For partially observable planning, a system is faced with exploring the space of belief states; the power set of the original planning space. Therefore, in contrast to the successor set generation based on action application, observations introduce “And” nodes into the search tree (Bertoli, Cimatti, Roveri, & Traverso, 2001b). Since the approach is a hybrid of symbolic representation of belief states and explicit search within the “And”-“Or” search tree, simple heuristics have been applied to guide the search. The need for heuristics that trade information gain for exploration effort is also apparent in conformant planning (Bertoli et al., 2001a). Recent work (Bertoli & Cimatti, 2002) proposes improved heuristics for belief space planning.\nThe UMOP system parses a non-deterministic agent domain language that explicitly defines a controllable system in an uncontrollable environment (Jensen & Veloso, 2000). The planner also applies BDD refinement techniques such as automated transition function partitioning. New results for the UMOP system extend weak, strong and strong cyclic planning to adversarial planning, in which the environment actively influences the outcome of actions. In fact, the proposed algorithm combines aspects of both symbolic search and game playing. UMOP has not yet participated in a planning competition.\nMore recent developments in symbolic exploration are expected to influence automated planning in the near future. With SetA*, (Jensen et al., 2002) provide an improved imple-\nmentation of the symbolic heuristic search algorithm BDDA* (Edelkamp & Reffel, 1998) and Weighted BDDA* (Edelkamp, 2001a). One improvement is that SetA* maintains finer grained sets of states in the search horizon. These are kept in a matrix according to matching g- and h- values. This contrasts with the plain bucket representation of the priority queue based on f -values. The heuristic function is implicitly encoded with value differences of grounded actions. Since sets of states are to be evaluated and some heuristics are state rather than operator dependent it remains to be shown how general this approach is. As above, the planning benchmarks considered are seemingly simple for single-state heuristic search exploration (Hoffmann, 2002b; Helmert, 2001). (Hansen, Zhou, & Feng, 2002) also re-implemented BDDA* and suggest that symbolic search heuristics and exploration algorithms are probably better implemented with algebraic decision diagrams (ADDs). Although the authors achieved no improvement to (Edelkamp & Reffel, 1998) in solving the (n2 − 1)-Puzzle, the established generalization to guide a symbolic version of the LAO* exploration algorithm (Hansen & Zilberstein, 2001) for probabilistic (MDP) planning results in a remarkable improvement in the state-of-the-art (Feng & Hansen, 2002)."
    }, {
      "heading" : "7. Conclusions",
      "text" : "With the competition planning system MIPS, we have contributed a flexible system for a heuristic forward chaining, explicit and symbolic search planner that finds plans in finitebranching numerical problems. The planner parses, pre-compiles, solves, and schedules problem instances, including complex ones with duration, resource variables and different objective functions. The main contributions of the planner are\n• The object-oriented workbench architecture to choose and combine different heuristics with different search algorithms and storage structures. The design includes the static analyzer that applies efficient fact-space exploration to distinguish constant from fluent quantities, that clusters facts into groups, and that infers static object symmetries. The static analyzer produces the intermediate format of grounded and simplified planning domain instances.\n• Optimal temporal planning enumeration algorithms, based on a precedence relation and PERT scheduling of sequentially generated plans together with a concise analysis of correctness and optimality, as well as the integration of PERT scheduling in MIPS for computing a refined heuristic estimate. This guides the search phase, favoring states with smaller parallel plan length. MIPS instantiates numerical pre- and postconditions on-the-fly and produces optimized parallel plans.\n• The detection of dynamic object symmetries, the integration of different pruning methods such as hash and transposition cuts, as well as different strategies for optimizing objective functions and further implementation tricks that made the system efficient.\nThe paper analyzes theoretical properties of the contributions, sometimes by slightly abstracting from the actual implementation.\nEssentially planning with numerical quantities and durative actions is planning with resources and time. The given framework of mixed propositional and numerical planning\nproblems and the presented intermediate format can be seen as a normal form for temporal and metric planning. The paper presents a novel temporal planning scheme that generates sequential (totally ordered) plans and efficiently schedules them with respect to the set of actions and the imposed causal structure, without falling into known NP-hardness traps for optimized partial-ordering of sequentially generated plans. For smaller problems the complete enumeration approach guarantees optimal solutions. To improve solution quality in approximate enumeration, the (numerical) estimate for the number of operators is replaced by scheduling the relaxed plan in each state. We addressed completeness and optimality of different forms of exploration. A novel study of the time and space complexity of dynamic object symmetry detection is given.\nModel checking has always influenced the development of MIPS, e.g in the static analysis to minimize the state description length, in symbolic exploration and plan extraction, in the dependence relation for PERT schedules according to a given partial order, in bit-state hashing for IDA*, in the importance of symmetry detection, an so forth. Moreover, the successes of planning with MIPS can be exported back to model checking, as the development of heuristic search state model checkers and parsing of Promela protocol specifications indicate."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The author would like to thank Derek Long and Maria Fox for helpful discussions concerning this paper and Malte Helmert for his cooperation in the second planning competition. The list of editor’s and anonymous reviewers’ comments helped a lot to improve the text.\nThe work is supported by Deutsche Forschungsgemeinschaft (DFG) in the projects Heuristic Search (Ed 74/3) and Directed Model Checking (Ed 74/2)."
    } ],
    "references" : [ {
      "title" : "Planning with resources and concurrency: A forward chaning approach",
      "author" : [ "F. Bacchus", "M. Ady" ],
      "venue" : "In Proceedings of IJCAI-01,",
      "citeRegEx" : "Bacchus and Ady,? \\Q2001\\E",
      "shortCiteRegEx" : "Bacchus and Ady",
      "year" : 2001
    }, {
      "title" : "Using temporal logics to express search control knowledge for planning",
      "author" : [ "F. Bacchus", "F. Kabanza" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Bacchus and Kabanza,? \\Q2000\\E",
      "shortCiteRegEx" : "Bacchus and Kabanza",
      "year" : 2000
    }, {
      "title" : "Computational aspects of reordering plans",
      "author" : [ "C. Bäckström" ],
      "venue" : "Journal of Artificial Intelligence Research, 9, 99–137.",
      "citeRegEx" : "Bäckström,? 1998",
      "shortCiteRegEx" : "Bäckström",
      "year" : 1998
    }, {
      "title" : "Improving heuristics for planning as search in belief space",
      "author" : [ "P. Bertoli", "A. Cimatti" ],
      "venue" : "In Proceedings of AIPS-02,",
      "citeRegEx" : "Bertoli and Cimatti,? \\Q2002\\E",
      "shortCiteRegEx" : "Bertoli and Cimatti",
      "year" : 2002
    }, {
      "title" : "Heuristic search symbolic model checking = efficient conformant planning",
      "author" : [ "P. Bertoli", "A. Cimatti", "M. Roveri" ],
      "venue" : "In Proceedings of IJCAI-01,",
      "citeRegEx" : "Bertoli et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Bertoli et al\\.",
      "year" : 2001
    }, {
      "title" : "Planning in nondeterministic domains under partial observability via symbolic model checking",
      "author" : [ "P. Bertoli", "A. Cimatti", "M. Roveri", "P. Traverso" ],
      "venue" : "In Proceedings of IJCAI-01,",
      "citeRegEx" : "Bertoli et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Bertoli et al\\.",
      "year" : 2001
    }, {
      "title" : "μcke - efficient μ-calculus model checking",
      "author" : [ "A. Biere" ],
      "venue" : "Proceedings of CAV-97, pp. 468–471.",
      "citeRegEx" : "Biere,? 1997",
      "shortCiteRegEx" : "Biere",
      "year" : 1997
    }, {
      "title" : "Symbolic guided search for CTL model checking",
      "author" : [ "R. Bloem", "K. Ravi", "F. Somenzi" ],
      "venue" : "In Proceedings of DAC-00,",
      "citeRegEx" : "Bloem et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Bloem et al\\.",
      "year" : 2000
    }, {
      "title" : "Fast planning through planning graph analysis",
      "author" : [ "A. Blum", "M.L. Furst" ],
      "venue" : "In Proceedings of IJCAI-95,",
      "citeRegEx" : "Blum and Furst,? \\Q1995\\E",
      "shortCiteRegEx" : "Blum and Furst",
      "year" : 1995
    }, {
      "title" : "Planning as heuristic search",
      "author" : [ "B. Bonet", "H. Geffner" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Bonet and Geffner,? \\Q2001\\E",
      "shortCiteRegEx" : "Bonet and Geffner",
      "year" : 2001
    }, {
      "title" : "Symbolic boolean manipulation with ordered binary-decision diagrams",
      "author" : [ "R.E. Bryant" ],
      "venue" : "ACM Computing Surveys, 24 (3), 142–170.",
      "citeRegEx" : "Bryant,? 1992",
      "shortCiteRegEx" : "Bryant",
      "year" : 1992
    }, {
      "title" : "Planning via model checking: A decision procedure for AR",
      "author" : [ "A. Cimatti", "E. Giunchiglia", "F. Giunchiglia", "P. Traverso" ],
      "venue" : "In Proceedings of ECP-97,",
      "citeRegEx" : "Cimatti et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Cimatti et al\\.",
      "year" : 1997
    }, {
      "title" : "Automatic OBDD-based generation of universal plans in non-deterministic domains",
      "author" : [ "A. Cimatti", "M. Roveri", "P. Traverso" ],
      "venue" : "In Proceedings of AAAI-98,",
      "citeRegEx" : "Cimatti et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Cimatti et al\\.",
      "year" : 1998
    }, {
      "title" : "Symbolic model checking: 1020 states and beyond",
      "author" : [ "E.M. Clarke", "K.L. McMillan", "D.L. Dill", "L.J. Hwang" ],
      "venue" : "Information and Computation,",
      "citeRegEx" : "Clarke et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Clarke et al\\.",
      "year" : 1992
    }, {
      "title" : "Introduction to Algorithms",
      "author" : [ "T.H. Cormen", "C.E. Leiserson", "R.L. Rivest" ],
      "venue" : null,
      "citeRegEx" : "Cormen et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "Cormen et al\\.",
      "year" : 1990
    }, {
      "title" : "Shortest-path forest with topological ordering",
      "author" : [ "R.B. Dial" ],
      "venue" : "Communication of the ACM, 12 (11), 632–633.",
      "citeRegEx" : "Dial,? 1969",
      "shortCiteRegEx" : "Dial",
      "year" : 1969
    }, {
      "title" : "Sapa: a domain-independent heuristic metric temporal planner",
      "author" : [ "M.B. Do", "S. Kambhampati" ],
      "venue" : "In Proceedings of ECP-01,",
      "citeRegEx" : "Do and Kambhampati,? \\Q2001\\E",
      "shortCiteRegEx" : "Do and Kambhampati",
      "year" : 2001
    }, {
      "title" : "Datenstrukturen und Lernverfahren in der Zustandsraumsuche",
      "author" : [ "S. Edelkamp" ],
      "venue" : "Ph.D. thesis, University of Freiburg. DISKI, Infix.",
      "citeRegEx" : "Edelkamp,? 1999",
      "shortCiteRegEx" : "Edelkamp",
      "year" : 1999
    }, {
      "title" : "Directed symbolic exploration and its application to AI-planning",
      "author" : [ "S. Edelkamp" ],
      "venue" : "Proceedings of AAAI-01 Spring Symposium on Model-based Validation of Intelligence, pp. 84–92.",
      "citeRegEx" : "Edelkamp,? 2001a",
      "shortCiteRegEx" : "Edelkamp",
      "year" : 2001
    }, {
      "title" : "First solutions to PDDL+ planning problems",
      "author" : [ "S. Edelkamp" ],
      "venue" : "Proceedings of PlanSIG-01, pp. 75–88.",
      "citeRegEx" : "Edelkamp,? 2001b",
      "shortCiteRegEx" : "Edelkamp",
      "year" : 2001
    }, {
      "title" : "Planning with pattern databases",
      "author" : [ "S. Edelkamp" ],
      "venue" : "Proceedings of ECP-01, pp. 13–24.",
      "citeRegEx" : "Edelkamp,? 2001c",
      "shortCiteRegEx" : "Edelkamp",
      "year" : 2001
    }, {
      "title" : "Mixed propositional and numerical planning in the model checking integrated planning system",
      "author" : [ "S. Edelkamp" ],
      "venue" : "Proceeding of AIPS-02 Workshop on Temporal Planning, pp. 47–55.",
      "citeRegEx" : "Edelkamp,? 2002a",
      "shortCiteRegEx" : "Edelkamp",
      "year" : 2002
    }, {
      "title" : "Symbolic pattern databases in heuristic search planning",
      "author" : [ "S. Edelkamp" ],
      "venue" : "Proceedings of AIPS-02, pp. 274–283.",
      "citeRegEx" : "Edelkamp,? 2002b",
      "shortCiteRegEx" : "Edelkamp",
      "year" : 2002
    }, {
      "title" : "Promela planning",
      "author" : [ "S. Edelkamp" ],
      "venue" : "Proceedings of SPIN-03, pp. 197–212.",
      "citeRegEx" : "Edelkamp,? 2003",
      "shortCiteRegEx" : "Edelkamp",
      "year" : 2003
    }, {
      "title" : "Exhibiting knowledge in planning problems to minimize state encoding length",
      "author" : [ "S. Edelkamp", "M. Helmert" ],
      "venue" : "In Proceeding of ECP-99,",
      "citeRegEx" : "Edelkamp and Helmert,? \\Q1999\\E",
      "shortCiteRegEx" : "Edelkamp and Helmert",
      "year" : 1999
    }, {
      "title" : "On the implementation of MIPS",
      "author" : [ "S. Edelkamp", "M. Helmert" ],
      "venue" : "In Proceedings of AIPS-00 Workshop on Model Theoretic Approaches to Planning,",
      "citeRegEx" : "Edelkamp and Helmert,? \\Q2000\\E",
      "shortCiteRegEx" : "Edelkamp and Helmert",
      "year" : 2000
    }, {
      "title" : "The model checking integrated planning system MIPS",
      "author" : [ "S. Edelkamp", "M. Helmert" ],
      "venue" : "AI-Magazine,",
      "citeRegEx" : "Edelkamp and Helmert,? \\Q2001\\E",
      "shortCiteRegEx" : "Edelkamp and Helmert",
      "year" : 2001
    }, {
      "title" : "Directed explicit-state model checking in the validation of communication",
      "author" : [ "S. Edelkamp", "S. Leue", "A. Lluch-Lafuente" ],
      "venue" : "protocols. International Journal on Software Tools for Technology (STTT),",
      "citeRegEx" : "Edelkamp et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Edelkamp et al\\.",
      "year" : 2003
    }, {
      "title" : "Theory and practice of time-space trade-offs in memory limited search",
      "author" : [ "S. Edelkamp", "U. Meyer" ],
      "venue" : "In Proceedings of KI-01, Lecture Notes in Computer Science,",
      "citeRegEx" : "Edelkamp and Meyer,? \\Q2001\\E",
      "shortCiteRegEx" : "Edelkamp and Meyer",
      "year" : 2001
    }, {
      "title" : "OBDDs in heuristic search",
      "author" : [ "S. Edelkamp", "F. Reffel" ],
      "venue" : "In Proceedings of KI-98,",
      "citeRegEx" : "Edelkamp and Reffel,? \\Q1998\\E",
      "shortCiteRegEx" : "Edelkamp and Reffel",
      "year" : 1998
    }, {
      "title" : "Deterministic state space planning with BDDs",
      "author" : [ "S. Edelkamp", "F. Reffel" ],
      "venue" : "In Proceedings of ECP-99,",
      "citeRegEx" : "Edelkamp and Reffel,? \\Q1999\\E",
      "shortCiteRegEx" : "Edelkamp and Reffel",
      "year" : 1999
    }, {
      "title" : "Deterministic state space planning with BDDs",
      "author" : [ "S. Edelkamp", "F. Reffel" ],
      "venue" : "Tech. rep. 121,",
      "citeRegEx" : "Edelkamp and Reffel,? \\Q1999\\E",
      "shortCiteRegEx" : "Edelkamp and Reffel",
      "year" : 1999
    }, {
      "title" : "Implementing HEAPSORT with n log n − 0.9n and QUICKSORT with n log n + 0.2n comparisons",
      "author" : [ "S. Edelkamp", "P. Stiegeler" ],
      "venue" : "ACM Journal of Experimental Algorithms,",
      "citeRegEx" : "Edelkamp and Stiegeler,? \\Q2002\\E",
      "shortCiteRegEx" : "Edelkamp and Stiegeler",
      "year" : 2002
    }, {
      "title" : "Symbolic heuristic search for factored markov decision processes",
      "author" : [ "Z. Feng", "E. Hansen" ],
      "venue" : "In Proceedings of AAAI-02",
      "citeRegEx" : "Feng and Hansen,? \\Q2002\\E",
      "shortCiteRegEx" : "Feng and Hansen",
      "year" : 2002
    }, {
      "title" : "Strips: A new approach to the application of theorem proving to problem solving",
      "author" : [ "R. Fikes", "N. Nilsson" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Fikes and Nilsson,? \\Q1971\\E",
      "shortCiteRegEx" : "Fikes and Nilsson",
      "year" : 1971
    }, {
      "title" : "Propositional planning",
      "author" : [ "M.P. Fourman" ],
      "venue" : "Proceedings of AIPS-00 Workshop on Model-Theoretic Approaches to Planning, pp. 10–17.",
      "citeRegEx" : "Fourman,? 2000",
      "shortCiteRegEx" : "Fourman",
      "year" : 2000
    }, {
      "title" : "The automatic inference of state invariants in TIM",
      "author" : [ "M. Fox", "D. Long" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Fox and Long,? \\Q1998\\E",
      "shortCiteRegEx" : "Fox and Long",
      "year" : 1998
    }, {
      "title" : "The detection and exploration of symmetry in planning problems",
      "author" : [ "M. Fox", "D. Long" ],
      "venue" : "In Proceedings of IJCAI-99,",
      "citeRegEx" : "Fox and Long,? \\Q1999\\E",
      "shortCiteRegEx" : "Fox and Long",
      "year" : 1999
    }, {
      "title" : "Extending the exploitation of symmetries in planning",
      "author" : [ "M. Fox", "D. Long" ],
      "venue" : "In Proceedings of AIPS-02",
      "citeRegEx" : "Fox and Long,? \\Q2002\\E",
      "shortCiteRegEx" : "Fox and Long",
      "year" : 2002
    }, {
      "title" : "PDDL2.1: An extension to PDDL for expressing temporal planning domains",
      "author" : [ "M. Fox", "D. Long" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Fox and Long,? \\Q2003\\E",
      "shortCiteRegEx" : "Fox and Long",
      "year" : 2003
    }, {
      "title" : "Fast planning through greedy action graphs",
      "author" : [ "A. Gerevini", "I. Serina" ],
      "venue" : "In Proceedings of AAAI-00",
      "citeRegEx" : "Gerevini and Serina,? \\Q1999\\E",
      "shortCiteRegEx" : "Gerevini and Serina",
      "year" : 1999
    }, {
      "title" : "LPG: a planner based on local search for planning graphs with action costs",
      "author" : [ "A. Gerevini", "I. Serina" ],
      "venue" : "In Proceedings of AIPS-02",
      "citeRegEx" : "Gerevini and Serina,? \\Q2002\\E",
      "shortCiteRegEx" : "Gerevini and Serina",
      "year" : 2002
    }, {
      "title" : "Planning as model checking",
      "author" : [ "F. Giunchiglia", "P. Traverso" ],
      "venue" : "In Proceedings of ECP-99,",
      "citeRegEx" : "Giunchiglia and Traverso,? \\Q1999\\E",
      "shortCiteRegEx" : "Giunchiglia and Traverso",
      "year" : 1999
    }, {
      "title" : "Model checking Java programs using structural heuristics",
      "author" : [ "A. Groce", "W. Visser" ],
      "venue" : "In Proceedings of ISSTA-02",
      "citeRegEx" : "Groce and Visser,? \\Q2002\\E",
      "shortCiteRegEx" : "Groce and Visser",
      "year" : 2002
    }, {
      "title" : "One action is enough to plan",
      "author" : [ "E. Guéré", "R. Alami" ],
      "venue" : "In Proceedings of IJCAI-01",
      "citeRegEx" : "Guéré and Alami,? \\Q2001\\E",
      "shortCiteRegEx" : "Guéré and Alami",
      "year" : 2001
    }, {
      "title" : "LAO*: A heuristic search algorithm that finds solutions with loops",
      "author" : [ "E. Hansen", "S. Zilberstein" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Hansen and Zilberstein,? \\Q2001\\E",
      "shortCiteRegEx" : "Hansen and Zilberstein",
      "year" : 2001
    }, {
      "title" : "Symbolic heuristic search using decision diagrams",
      "author" : [ "E.A. Hansen", "R. Zhou", "Z. Feng" ],
      "venue" : "In Proceedings of SARA-02",
      "citeRegEx" : "Hansen et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Hansen et al\\.",
      "year" : 2002
    }, {
      "title" : "A formal basis for heuristic determination of minimum path cost",
      "author" : [ "P.E. Hart", "N.J. Nilsson", "B. Raphael" ],
      "venue" : "IEEE Transactions on on Systems Science and Cybernetics,",
      "citeRegEx" : "Hart et al\\.,? \\Q1968\\E",
      "shortCiteRegEx" : "Hart et al\\.",
      "year" : 1968
    }, {
      "title" : "Heuristic planning with time and resources",
      "author" : [ "P. Haslum", "H. Geffner" ],
      "venue" : "In Proceedings of ECP-01,",
      "citeRegEx" : "Haslum and Geffner,? \\Q2001\\E",
      "shortCiteRegEx" : "Haslum and Geffner",
      "year" : 2001
    }, {
      "title" : "On the complexity of planning in transportation domains",
      "author" : [ "M. Helmert" ],
      "venue" : "Proceedings of ECP-01, pp. 349–360.",
      "citeRegEx" : "Helmert,? 2001",
      "shortCiteRegEx" : "Helmert",
      "year" : 2001
    }, {
      "title" : "Decidability and undecidability results for planning with numerical state variables",
      "author" : [ "M. Helmert" ],
      "venue" : "Proceedings of AIPS-02, pp. 44–53.",
      "citeRegEx" : "Helmert,? 2002",
      "shortCiteRegEx" : "Helmert",
      "year" : 2002
    }, {
      "title" : "Verteilte Visualisierung von Geometrischen Algorithmen",
      "author" : [ "C.A. Hipke" ],
      "venue" : "Ph.D. thesis, University of Freiburg.",
      "citeRegEx" : "Hipke,? 2000",
      "shortCiteRegEx" : "Hipke",
      "year" : 2000
    }, {
      "title" : "A heuristic for domain independent planning and its use in an enforced hill climbing algorithm",
      "author" : [ "J. Hoffmann" ],
      "venue" : "Proceedings of ISMIS-00, pp. 216–227.",
      "citeRegEx" : "Hoffmann,? 2000",
      "shortCiteRegEx" : "Hoffmann",
      "year" : 2000
    }, {
      "title" : "Extending FF to numerical state variables",
      "author" : [ "J. Hoffmann" ],
      "venue" : "Proceedings of ECAI-",
      "citeRegEx" : "Hoffmann,? 2002a",
      "shortCiteRegEx" : "Hoffmann",
      "year" : 2002
    }, {
      "title" : "Local search topology in planning benchmarks: A theoretical analysis",
      "author" : [ "J. Hoffmann" ],
      "venue" : "Proceedings of AIPS-02, pp. 92–100.",
      "citeRegEx" : "Hoffmann,? 2002b",
      "shortCiteRegEx" : "Hoffmann",
      "year" : 2002
    }, {
      "title" : "Fast plan generation through heuristic search",
      "author" : [ "J. Hoffmann", "B. Nebel" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Hoffmann and Nebel,? \\Q2001\\E",
      "shortCiteRegEx" : "Hoffmann and Nebel",
      "year" : 2001
    }, {
      "title" : "Solving the entailment problem in the fluent calculus using binary decision diagrams",
      "author" : [ "S. Hölldobler", "Stör", "H.-P" ],
      "venue" : "In Proceedings of AIPS-00 Workshop on ModelTheoretic Approaches to Planning,",
      "citeRegEx" : "Hölldobler et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Hölldobler et al\\.",
      "year" : 2000
    }, {
      "title" : "SetA*: An efficient BDD-based heuristic search algorithm",
      "author" : [ "R.M. Jensen", "R.E. Bryant", "M.M. Veloso" ],
      "venue" : "In Proceedings of AAAI-02",
      "citeRegEx" : "Jensen et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Jensen et al\\.",
      "year" : 2002
    }, {
      "title" : "OBDD-based universal planning for synchronized agents in non-deterministic domains",
      "author" : [ "R. Jensen", "M.M. Veloso" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Jensen and Veloso,? \\Q2000\\E",
      "shortCiteRegEx" : "Jensen and Veloso",
      "year" : 2000
    }, {
      "title" : "Planning control rules for reactive agents",
      "author" : [ "F. Kabanza", "M. Barbeau", "R. St-Denis" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Kabanza et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Kabanza et al\\.",
      "year" : 1997
    }, {
      "title" : "Pushing the envelope: Planning, propositional logic, and stochastic search",
      "author" : [ "H. Kautz", "B. Selman" ],
      "venue" : "In Proceedings of AAAI-96,",
      "citeRegEx" : "Kautz and Selman,? \\Q1996\\E",
      "shortCiteRegEx" : "Kautz and Selman",
      "year" : 1996
    }, {
      "title" : "State-space planning by integer optimization",
      "author" : [ "H. Kautz", "J. Walser" ],
      "venue" : "In Proceedings of AAAI-99",
      "citeRegEx" : "Kautz and Walser,? \\Q1999\\E",
      "shortCiteRegEx" : "Kautz and Walser",
      "year" : 1999
    }, {
      "title" : "Generating parallel execution plans with a partial order planner",
      "author" : [ "C. Knoblock" ],
      "venue" : "Proceedings of AIPS-94, pp. 98–103.",
      "citeRegEx" : "Knoblock,? 1994",
      "shortCiteRegEx" : "Knoblock",
      "year" : 1994
    }, {
      "title" : "Elevator control as a planning problem",
      "author" : [ "J. Koehler" ],
      "venue" : "Proceedings of AIPS-00, pp. 331–338.",
      "citeRegEx" : "Koehler,? 2000",
      "shortCiteRegEx" : "Koehler",
      "year" : 2000
    }, {
      "title" : "On reasonable and forced goal orderings and their use in an agenda-driven planning algorithm",
      "author" : [ "J. Koehler", "J. Hoffmann" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Koehler and Hoffmann,? \\Q2000\\E",
      "shortCiteRegEx" : "Koehler and Hoffmann",
      "year" : 2000
    }, {
      "title" : "Extending planning graphs to an ADL subset",
      "author" : [ "J. Koehler", "B. Nebel", "Y. Dimopoulos" ],
      "venue" : "In Proceedings of ECP-97,",
      "citeRegEx" : "Koehler et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Koehler et al\\.",
      "year" : 1997
    }, {
      "title" : "Depth-first iterative-deepening: An optimal admissible tree search",
      "author" : [ "R.E. Korf" ],
      "venue" : "Artificial Intelligence, 27 (1), 97–109.",
      "citeRegEx" : "Korf,? 1985",
      "shortCiteRegEx" : "Korf",
      "year" : 1985
    }, {
      "title" : "Divide-and-conquer frontier search applied to optimal sequence alignment",
      "author" : [ "R.E. Korf", "W. Zhang" ],
      "venue" : "In Proceedings of AAAI-00,",
      "citeRegEx" : "Korf and Zhang,? \\Q2000\\E",
      "shortCiteRegEx" : "Korf and Zhang",
      "year" : 2000
    }, {
      "title" : "Planning with sharable resources constraints",
      "author" : [ "P. Laborie", "M. Ghallab" ],
      "venue" : "In Proceedings of IJCAI-95,",
      "citeRegEx" : "Laborie and Ghallab,? \\Q1995\\E",
      "shortCiteRegEx" : "Laborie and Ghallab",
      "year" : 1995
    }, {
      "title" : "Planning with a language for extended goals",
      "author" : [ "U.D. Lago", "M. Pistore", "P. Traverso" ],
      "venue" : "In Proceedings of AAAI-02",
      "citeRegEx" : "Lago et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Lago et al\\.",
      "year" : 2002
    }, {
      "title" : "Buddy: Binary decision diagram package, release 1.7",
      "author" : [ "J. Lind-Nielsen" ],
      "venue" : "Technical Univeristy of Denmark. Available from jln@itu.dk",
      "citeRegEx" : "Lind.Nielsen,? \\Q1999\\E",
      "shortCiteRegEx" : "Lind.Nielsen",
      "year" : 1999
    }, {
      "title" : "Symmetry reduction and heuristic search for error detection in model checking",
      "author" : [ "A. Lluch-Lafuente" ],
      "venue" : "Proceedings of the Workshop on Model Checking and Artificial Intelligence (MoChart).",
      "citeRegEx" : "Lluch.Lafuente,? 2003",
      "shortCiteRegEx" : "Lluch.Lafuente",
      "year" : 2003
    }, {
      "title" : "Efficient implementation of the plan graph in STAN",
      "author" : [ "D. Long", "M. Fox" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Long and Fox,? \\Q1998\\E",
      "shortCiteRegEx" : "Long and Fox",
      "year" : 1998
    }, {
      "title" : "Encoding temporal planning domains and validating temporal plans. In Workshop of the UK Planning and Scheduling Special Interest Group (PlanSIG)",
      "author" : [ "D. Long", "M. Fox" ],
      "venue" : null,
      "citeRegEx" : "Long and Fox,? \\Q2001\\E",
      "shortCiteRegEx" : "Long and Fox",
      "year" : 2001
    }, {
      "title" : "The 1998 AI Planning Competition",
      "author" : [ "D. McDermott" ],
      "venue" : "AI Magazine, 21 (2).",
      "citeRegEx" : "McDermott,? 2000",
      "shortCiteRegEx" : "McDermott",
      "year" : 2000
    }, {
      "title" : "Symbolic Model Checking",
      "author" : [ "K.L. McMillan" ],
      "venue" : "Kluwer Academic Press.",
      "citeRegEx" : "McMillan,? 1993",
      "shortCiteRegEx" : "McMillan",
      "year" : 1993
    }, {
      "title" : "HSTS: integrating planning and scheduling",
      "author" : [ "N. Muscettola" ],
      "venue" : "Zweben, M., & Fox, M. S. (Eds.), Intelligent Scheduling, pp. 168–212. Morgan Kaufmann.",
      "citeRegEx" : "Muscettola,? 1994",
      "shortCiteRegEx" : "Muscettola",
      "year" : 1994
    }, {
      "title" : "Heuristics",
      "author" : [ "J. Pearl" ],
      "venue" : "Addison-Wesley.",
      "citeRegEx" : "Pearl,? 1985",
      "shortCiteRegEx" : "Pearl",
      "year" : 1985
    }, {
      "title" : "Formulating multiagend, dynamic-world problems in the classical framework",
      "author" : [ "E. Pednault" ],
      "venue" : "Reasoning about Action and Plans, pp. 47–82. Morgan Kaufmann.",
      "citeRegEx" : "Pednault,? 1986",
      "shortCiteRegEx" : "Pednault",
      "year" : 1986
    }, {
      "title" : "ADL: Exploring the middleground between Strips and situation calculus",
      "author" : [ "E. Pednault" ],
      "venue" : "Proceedings of KR-89, pp. 324–332. Morgan Kaufman.",
      "citeRegEx" : "Pednault,? 1989",
      "shortCiteRegEx" : "Pednault",
      "year" : 1989
    }, {
      "title" : "Modelling and Verification of Real-Time Systems Using Timed Automata: Theory and Practice",
      "author" : [ "P. Pettersson" ],
      "venue" : "Ph.D. thesis, Department of Computer Systems, Uppsala University.",
      "citeRegEx" : "Pettersson,? 1999",
      "shortCiteRegEx" : "Pettersson",
      "year" : 1999
    }, {
      "title" : "Planning as model checking for extended goals in nondeterministic domains",
      "author" : [ "M. Pistore", "P. Traverso" ],
      "venue" : "In Proceedings of IJCAI-01",
      "citeRegEx" : "Pistore and Traverso,? \\Q2001\\E",
      "shortCiteRegEx" : "Pistore and Traverso",
      "year" : 2001
    }, {
      "title" : "Practical and theoretical considerations in heuristic search algorithms",
      "author" : [ "I. Pohl" ],
      "venue" : "Machine Intelligence, 8, 55–72.",
      "citeRegEx" : "Pohl,? 1977",
      "shortCiteRegEx" : "Pohl",
      "year" : 1977
    }, {
      "title" : "Heuristic planning with ressources",
      "author" : [ "I. Refanidis", "I. Vlahavas" ],
      "venue" : "In Proceedings of ECAI-00,",
      "citeRegEx" : "Refanidis and Vlahavas,? \\Q2000\\E",
      "shortCiteRegEx" : "Refanidis and Vlahavas",
      "year" : 2000
    }, {
      "title" : "Error detection with directed symbolic model checking",
      "author" : [ "F. Reffel", "S. Edelkamp" ],
      "venue" : "In Proceedings of FM-99,",
      "citeRegEx" : "Reffel and Edelkamp,? \\Q1999\\E",
      "shortCiteRegEx" : "Reffel and Edelkamp",
      "year" : 1999
    }, {
      "title" : "Détermination du parallélisme maximal et optimisation temporelle dans les plans d’actions linéaires",
      "author" : [ "P. Regnier", "B. Fade" ],
      "venue" : "Revue d’Intelligence Artificielle,",
      "citeRegEx" : "Regnier and Fade,? \\Q1991\\E",
      "shortCiteRegEx" : "Regnier and Fade",
      "year" : 1991
    }, {
      "title" : "Enhanced iterative-deepening search",
      "author" : [ "A. Reinefeld", "T. Marsland" ],
      "venue" : "IEEE Transactions on Pattern Analysis and Machine Intelligence,",
      "citeRegEx" : "Reinefeld and Marsland,? \\Q1994\\E",
      "shortCiteRegEx" : "Reinefeld and Marsland",
      "year" : 1994
    }, {
      "title" : "Symmetry reduction for SAT representations of transition systems",
      "author" : [ "J. Rintanen" ],
      "venue" : "Proceedings of ICAPS-03.",
      "citeRegEx" : "Rintanen,? 2003",
      "shortCiteRegEx" : "Rintanen",
      "year" : 2003
    }, {
      "title" : "Numeric state variables in constraint-based planning",
      "author" : [ "J. Rintanen", "H. Jungholt" ],
      "venue" : "In Proceedings of ECP-99,",
      "citeRegEx" : "Rintanen and Jungholt,? \\Q1999\\E",
      "shortCiteRegEx" : "Rintanen and Jungholt",
      "year" : 1999
    }, {
      "title" : "Optimal scheduling using branch and bound with SPIN 4.0",
      "author" : [ "T.C. Ruys" ],
      "venue" : "In Proceedings of SPIN-03,",
      "citeRegEx" : "Ruys,? \\Q2003\\E",
      "shortCiteRegEx" : "Ruys",
      "year" : 2003
    }, {
      "title" : "Discrete Optimization Algorithms with Pascal Programs",
      "author" : [ "M.M. Syslo", "N. Deo", "J.S. Kowalik" ],
      "venue" : null,
      "citeRegEx" : "Syslo et al\\.,? \\Q1983\\E",
      "shortCiteRegEx" : "Syslo et al\\.",
      "year" : 1983
    }, {
      "title" : "Nonlinear planning with parallel resource allocation",
      "author" : [ "M.M. Veloso", "M.A. Pérez", "J.G. Carbonell" ],
      "venue" : "In Innovative Approaches to Planning, Scheduling and Control,",
      "citeRegEx" : "Veloso et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "Veloso et al\\.",
      "year" : 1990
    }, {
      "title" : "Planen mit einem Modellprüfer im μ-Kalkül",
      "author" : [ "M. Weismüller" ],
      "venue" : "Master’s thesis, Universität Ulm.",
      "citeRegEx" : "Weismüller,? 1998",
      "shortCiteRegEx" : "Weismüller",
      "year" : 1998
    }, {
      "title" : "Validation with guided search of the state space",
      "author" : [ "C.H. Yang", "D.L. Dill" ],
      "venue" : "In Proceedings of DAC-98,",
      "citeRegEx" : "Yang and Dill,? \\Q1998\\E",
      "shortCiteRegEx" : "Yang and Dill",
      "year" : 1998
    }, {
      "title" : "A* with partial expansion for large branching factor problems",
      "author" : [ "T. Yoshizumi", "T. Miura", "T. Ishida" ],
      "venue" : "In Proceedings of AAAI-00,",
      "citeRegEx" : "Yoshizumi et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Yoshizumi et al\\.",
      "year" : 2000
    }, {
      "title" : "Sparse-memory graph search",
      "author" : [ "R. Zhou", "E. Hansen" ],
      "venue" : "In Proceedings of IJCAI-03",
      "citeRegEx" : "Zhou and Hansen,? \\Q2003\\E",
      "shortCiteRegEx" : "Zhou and Hansen",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 23,
      "context" : "Additional synergies are exploited in the automated compilation of protocol software model checking problems into planner inputs (Edelkamp, 2003).",
      "startOffset" : 129,
      "endOffset" : 145
    }, {
      "referenceID" : 75,
      "context" : "In symbolic model checking (McMillan, 1993; Clarke, McMillan, Dill, & Hwang, 1992), (fixed-length) binary encodings of system states are used, so that each state can be represented by its characteristic function representation.",
      "startOffset" : 27,
      "endOffset" : 82
    }, {
      "referenceID" : 10,
      "context" : "The unique symbolic representation of sets of states as Boolean formulae through binary decision diagrams (BDDs) (Bryant, 1992) is often much smaller than the explicit one.",
      "startOffset" : 113,
      "endOffset" : 127
    }, {
      "referenceID" : 22,
      "context" : "Moreover, it combines symbolic and explicit search planning in the form of symbolic pattern databases (Edelkamp, 2002b).",
      "startOffset" : 102,
      "endOffset" : 119
    }, {
      "referenceID" : 77,
      "context" : "The planner MIPS implements heuristic search algorithms like A* (Pearl, 1985) and IDA* (Korf, 1985) for exploration, which include state-to-goal approximation into the search process to rank the states to be expanded next.",
      "startOffset" : 64,
      "endOffset" : 77
    }, {
      "referenceID" : 66,
      "context" : "The planner MIPS implements heuristic search algorithms like A* (Pearl, 1985) and IDA* (Korf, 1985) for exploration, which include state-to-goal approximation into the search process to rank the states to be expanded next.",
      "startOffset" : 87,
      "endOffset" : 99
    }, {
      "referenceID" : 27,
      "context" : "Heuristic search has brought considerable gains to both planning (Bonet & Geffner, 2001; Refanidis & Vlahavas, 2000; Hoffmann & Nebel, 2001; Bertoli, Cimatti, & Roveri, 2001a; Jensen, Bryant, & Veloso, 2002; Feng & Hansen, 2002) and model checking (Yang & Dill, 1998; Edelkamp et al., 2003; Groce & Visser, 2002; Bloem, Ravi, & Somenzi, 2000; Ruys, 2003).",
      "startOffset" : 248,
      "endOffset" : 354
    }, {
      "referenceID" : 89,
      "context" : "Heuristic search has brought considerable gains to both planning (Bonet & Geffner, 2001; Refanidis & Vlahavas, 2000; Hoffmann & Nebel, 2001; Bertoli, Cimatti, & Roveri, 2001a; Jensen, Bryant, & Veloso, 2002; Feng & Hansen, 2002) and model checking (Yang & Dill, 1998; Edelkamp et al., 2003; Groce & Visser, 2002; Bloem, Ravi, & Somenzi, 2000; Ruys, 2003).",
      "startOffset" : 248,
      "endOffset" : 354
    }, {
      "referenceID" : 6,
      "context" : "The competition version of MIPS refers to initial work (Edelkamp & Reffel, 1999a) in heuristic symbolic exploration of planning domains with the μcke model checker (Biere, 1997).",
      "startOffset" : 164,
      "endOffset" : 177
    }, {
      "referenceID" : 92,
      "context" : "As confirmed by other attempts (Weismüller, 1998), who started experimenting with PDDL specification in μcke, state minimization is in fact crucial.",
      "startOffset" : 31,
      "endOffset" : 49
    }, {
      "referenceID" : 74,
      "context" : "In the second international planning competition MIPS (Edelkamp & Helmert, 2001) could handle the STRIPS (Fikes & Nilsson, 1971) subset of the PDDL language (McDermott, 2000) and some additional features from ADL (Pednault, 1989), namely negative preconditions and (universal) conditional effects.",
      "startOffset" : 157,
      "endOffset" : 174
    }, {
      "referenceID" : 79,
      "context" : "In the second international planning competition MIPS (Edelkamp & Helmert, 2001) could handle the STRIPS (Fikes & Nilsson, 1971) subset of the PDDL language (McDermott, 2000) and some additional features from ADL (Pednault, 1989), namely negative preconditions and (universal) conditional effects.",
      "startOffset" : 213,
      "endOffset" : 229
    }, {
      "referenceID" : 6,
      "context" : "The competition version of MIPS refers to initial work (Edelkamp & Reffel, 1999a) in heuristic symbolic exploration of planning domains with the μcke model checker (Biere, 1997). This approach was effective in sample puzzle solving (Edelkamp & Reffel, 1998) and in hardware verification problems (Reffel & Edelkamp, 1999). For implementing a propositional planner, we first used our own BDD library called StaticBdd, in which large node tables are allocated prior to their use. During the implementation process we changed the BDD representation mainly to improve performance for small planning problems. We selected the public domain c++ BDD package Buddy (LindNielsen, 1999), which is more flexible. The planning process was semi-automated (Edelkamp & Reffel, 1999b); variable encodings were provided by hand, while the representations of all operators were established by enumerating all possible parameter instances. Once the state space encoding and action transition relation were fixed, exploration in the form of a symbolic breadth-first search of the state-space could be executed. At that time, we were not aware of any other work in BDD-based planning such as the work of Cimatti et al. (1997), which is likely the first link to planning via symbolic model checking.",
      "startOffset" : 165,
      "endOffset" : 1205
    }, {
      "referenceID" : 20,
      "context" : "In between the planning competitions, explicit (Edelkamp, 2001c) and symbolic pattern databases (Edelkamp, 2002b) were proposed as off-line estimators for completely explored problem abstractions.",
      "startOffset" : 47,
      "endOffset" : 64
    }, {
      "referenceID" : 22,
      "context" : "In between the planning competitions, explicit (Edelkamp, 2001c) and symbolic pattern databases (Edelkamp, 2002b) were proposed as off-line estimators for completely explored problem abstractions.",
      "startOffset" : 96,
      "endOffset" : 113
    }, {
      "referenceID" : 19,
      "context" : "1 problems are presented in (Edelkamp, 2001b).",
      "startOffset" : 28,
      "endOffset" : 45
    }, {
      "referenceID" : 21,
      "context" : "This work was extended in (Edelkamp, 2002a), where we presented two approximate exploration techniques to bound and to fix numerical domains, first results on symmetry detection based on fact groups, critical path scheduling, an any-time wrapper to produce optimal plans, and a numerical extension to RPH.",
      "startOffset" : 26,
      "endOffset" : 43
    }, {
      "referenceID" : 17,
      "context" : "The planning system was developed in the spirit of the heuristic search framework, HSF for short (Edelkamp, 1999), which allows attachment of newly implemented problem (puzzle) domains to an already compiled system.",
      "startOffset" : 97,
      "endOffset" : 113
    }, {
      "referenceID" : 20,
      "context" : "In contrast to RPH, pattern database can be designed to be disjoint yielding an admissible estimate as needed for optimal planning in A* (Edelkamp, 2001c).",
      "startOffset" : 137,
      "endOffset" : 154
    }, {
      "referenceID" : 22,
      "context" : "Symbolic pattern database heuristic (symbolic PDB) Symbolic PDBs apply to explicit and symbolic heuristic search engines (Edelkamp, 2002b).",
      "startOffset" : 121,
      "endOffset" : 138
    }, {
      "referenceID" : 77,
      "context" : "For lower bound heuristics, A* can be shown to generate optimal plans (Pearl, 1985).",
      "startOffset" : 70,
      "endOffset" : 83
    }, {
      "referenceID" : 82,
      "context" : "Weighting the influence of the heuristic estimate may accelerate solution finding, but also affects optimality (Pohl, 1977).",
      "startOffset" : 111,
      "endOffset" : 123
    }, {
      "referenceID" : 66,
      "context" : "Iterative-Deepening A* (IDA*) The memory-limited variant of A* is suited to large exploration problems with evaluation functions of small integer range and low time complexity (Korf, 1985).",
      "startOffset" : 176,
      "endOffset" : 188
    }, {
      "referenceID" : 52,
      "context" : "Enforced HC searches with an improved evaluation in a breadth-first manner and commits established action selections as final (Hoffmann, 2000).",
      "startOffset" : 126,
      "endOffset" : 142
    }, {
      "referenceID" : 53,
      "context" : "Our approach to extend the relaxed planning heuristic with numerical information helps to find plans in challenging numerical domains like Settlers and was influenced by Hoffmann’s work on his competing planner Metric-FF (Hoffmann, 2002a).",
      "startOffset" : 221,
      "endOffset" : 238
    }, {
      "referenceID" : 15,
      "context" : "A Dial priority queue (Dial, 1969) has linear run time behavior, if the maximal value w(u, v) + h(v) − h(u) of all edges (u, v) in the weighted state space graph (labelled with heuristic h) is bounded by a constant.",
      "startOffset" : 22,
      "endOffset" : 34
    }, {
      "referenceID" : 21,
      "context" : "In (Edelkamp, 2002a) we experimented with an enumeration approach to fix numerical variables to a finite domain, and with an any-time wrapper for optimization of objective functions.",
      "startOffset" : 3,
      "endOffset" : 20
    }, {
      "referenceID" : 51,
      "context" : "For visualization of plans with MIPS we extended the animation system Vega (Hipke, 2000); a Client-Server architecture that runs an annotated algorithm on the server side, which is visualized on the client side in a Java frontend.",
      "startOffset" : 75,
      "endOffset" : 88
    }, {
      "referenceID" : 62,
      "context" : "A less restrictive notion of independence, in which several actions may occur at the same time even if one deletes an add-effect of another is provided in (Knoblock, 1994).",
      "startOffset" : 155,
      "endOffset" : 171
    }, {
      "referenceID" : 2,
      "context" : "For optimizing plans (Bäckström, 1998) defines parallel execution time as max{ti + d(Oi) | Oi ∈ {O1, .",
      "startOffset" : 21,
      "endOffset" : 38
    }, {
      "referenceID" : 2,
      "context" : "In order to find optimal schedules of sequential plans an approach similar to (Bäckström, 1998) would be necessary.",
      "startOffset" : 78,
      "endOffset" : 95
    }, {
      "referenceID" : 78,
      "context" : "Many algorithms have been suggested to convert sequential plans into partially ordered ones (Pednault, 1986; Regnier & Fade, 1991; Veloso, Pérez, & Carbonell, 1990).",
      "startOffset" : 92,
      "endOffset" : 164
    }, {
      "referenceID" : 2,
      "context" : "However, the problem of minimum constraint “deordering” has also been proven to be NP-hard, unless the so-called validity check is polynomial (Bäckström, 1998), where deordering maintains validity of the plan by lessening its constrainedness, i.",
      "startOffset" : 142,
      "endOffset" : 159
    }, {
      "referenceID" : 50,
      "context" : "Enumeration schemes do not contradict known undecidability results in numerical planning (Helmert, 2002).",
      "startOffset" : 89,
      "endOffset" : 104
    }, {
      "referenceID" : 77,
      "context" : "The question remains: is there still hope of finding near optimal parallel plans? A general result also applicable for infinite graphs was established by (Pearl, 1985): If the cost of every",
      "startOffset" : 154,
      "endOffset" : 167
    }, {
      "referenceID" : 50,
      "context" : "Solving planning problems with numerical preconditions and effects as allowed in Level 2 and Level 3 problems is undecidable in general (Helmert, 2002).",
      "startOffset" : 136,
      "endOffset" : 151
    }, {
      "referenceID" : 53,
      "context" : "The system Metric-FF (Hoffmann, 2002a) extends FF (Hoffmann & Nebel, 2001) as a forward chaining heuristic state space planner for Level 2 problems.",
      "startOffset" : 21,
      "endOffset" : 38
    }, {
      "referenceID" : 76,
      "context" : "HSTS (Muscettola, 1994) is a constraint-based planning system based on temporal activity networks, written in LISP and CRL.",
      "startOffset" : 5,
      "endOffset" : 23
    }, {
      "referenceID" : 80,
      "context" : "Some subclasses of infinite branching problems like timed automata exhibit a finite partitioning through a symbolic representation of states (Pettersson, 1999).",
      "startOffset" : 141,
      "endOffset" : 159
    }, {
      "referenceID" : 80,
      "context" : "implemented this temporal network structure, since this is the main data structure when exploring timed automata as done by the model checker Uppaal (Pettersson, 1999).",
      "startOffset" : 149,
      "endOffset" : 167
    }, {
      "referenceID" : 13,
      "context" : "Model checking research has a long tradition in symmetry reduction (Clarke et al., 1999). In recent work, Rintanen (2003) connects symmetry detection in planning to model checking approaches for transition systems and SAT solving.",
      "startOffset" : 68,
      "endOffset" : 122
    }, {
      "referenceID" : 35,
      "context" : "In the 2000 competition, two other symbolic planners took part: PropPlan (Fourman, 2000), and BDDPlan (Hölldobler & Stör, 2000).",
      "startOffset" : 73,
      "endOffset" : 88
    }, {
      "referenceID" : 63,
      "context" : "It performed well in the full ADL Miconic-10 elevator domain (Koehler, 2000).",
      "startOffset" : 61,
      "endOffset" : 76
    }, {
      "referenceID" : 12,
      "context" : "In the Model-Based Planner MBP the paradigm of planning as symbolic model checking (Giunchiglia & Traverso, 1999) has been implemented for non-deterministic planning domains (Cimatti et al., 1998), which can be classified into weak, strong, and strong-cyclic planning, with plans that are represented as state-action tables.",
      "startOffset" : 174,
      "endOffset" : 196
    }, {
      "referenceID" : 57,
      "context" : "With SetA*, (Jensen et al., 2002) provide an improved imple-",
      "startOffset" : 12,
      "endOffset" : 33
    }, {
      "referenceID" : 18,
      "context" : "mentation of the symbolic heuristic search algorithm BDDA* (Edelkamp & Reffel, 1998) and Weighted BDDA* (Edelkamp, 2001a).",
      "startOffset" : 104,
      "endOffset" : 121
    }, {
      "referenceID" : 54,
      "context" : "As above, the planning benchmarks considered are seemingly simple for single-state heuristic search exploration (Hoffmann, 2002b; Helmert, 2001).",
      "startOffset" : 112,
      "endOffset" : 144
    }, {
      "referenceID" : 49,
      "context" : "As above, the planning benchmarks considered are seemingly simple for single-state heuristic search exploration (Hoffmann, 2002b; Helmert, 2001).",
      "startOffset" : 112,
      "endOffset" : 144
    } ],
    "year" : 2011,
    "abstractText" : "The Model Checking Integrated Planning System (MIPS) is a temporal least commitment heuristic search planner based on a flexible object-oriented workbench architecture. Its design clearly separates explicit and symbolic directed exploration algorithms from the set of on-line and off-line computed estimates and associated data structures. MIPS has shown distinguished performance in the last two international planning competitions. In the last event the description language was extended from pure propositional planning to include numerical state variables, action durations, and plan quality objective functions. Plans were no longer sequences of actions but time-stamped schedules. As a participant of the fully automated track of the competition, MIPS has proven to be a general system; in each track and every benchmark domain it efficiently computed plans of remarkable quality. This article introduces and analyzes the most important algorithmic novelties that were necessary to tackle the new layers of expressiveness in the benchmark problems and to achieve a high level of performance. The extensions include critical path analysis of sequentially generated plans to generate corresponding optimal parallel plans. The linear time algorithm to compute the parallel plan bypasses known NP hardness results for partial ordering by scheduling plans with respect to the set of actions and the imposed precedence relations. The efficiency of this algorithm also allows us to improve the exploration guidance: for each encountered planning state the corresponding approximate sequential plan is scheduled. One major strength of MIPS is its static analysis phase that grounds and simplifies parameterized predicates, functions and operators, that infers knowledge to minimize the state description length, and that detects domain object symmetries. The latter aspect is analyzed in detail. MIPS has been developed to serve as a complete and optimal state space planner, with admissible estimates, exploration engines and branching cuts. In the competition version, however, certain performance compromises had to be made, including floating point arithmetic, weighted heuristic search exploration according to an inadmissible estimate and parameterized optimization.",
    "creator" : "dvips(k) 5.90a Copyright 2002 Radical Eye Software"
  }
}