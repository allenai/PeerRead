{
  "name" : "1610.09716.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Doubly Convolutional Neural Networks",
    "authors" : [ "Shuangfei Zhai", "Yu Cheng" ],
    "emails" : [ "szhai2@binghamton.edu", "chengyu@us.ibm.com", "luwn14@mails.tsinghua.edu.cn", "zhongfei@cs.binghamton.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "In recent years, convolutional neural networks (CNNs) have achieved great success to solve many problems in machine learning and computer vision. CNNs are extremely parameter efficient due to exploring the translation invariant property of images, which is the key to training very deep models without severe overfitting. While considerable progresses have been achieved by aggressively exploring deeper architectures [1, 2, 3, 4] or novel regularization techniques [5, 6] with the standard \"convolution + pooling\" recipe, we contribute from a different view by providing an alternative to the default convolution module, which can lead to models with even better generalization abilities and/or parameter efficiency.\nOur intuition originates from observing well trained CNNs where many of the learned filters are the slightly translated versions of each other. To quantify this in a more formal fashion, we define the k-translation correlation between two convolutional filters within a same layer Wi,Wj as:\nρk(Wi,Wj) = max x,y∈{−k,...,k},(x,y) 6=(0,0) <Wi, T (Wj , x, y) >f ‖Wi‖2‖Wj‖2 , (1)\nwhere T (·, x, y) denotes the translation of the first operand by (x, y) along its spatial dimensions, with proper zero padding at borders to maintain the shape; < ·, · >f denotes the flattened inner\n30th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n61 0.\n09 71\n6v 1\n[ cs\n.L G\n] 3\n0 O\nproduct, where the two operands are flattened into column vectors before taking the standard inner product; ‖ · ‖2 denotes the `2 norm of its flattened operand. In other words, the k-translation correlation between a pair of filters indicates the maximum correlation achieved by translating one filter up to k steps along any spatial dimension. As a concrete example, Figure 1 demonstrates the 3-translation correlation of the first layer filters learned by the AlexNet [1], with the weights obtained from the Caffe model zoo [7]. In each column, we show a filter in the first row and its three most 3-translation-correlated filters (that is, filters with the highest 3-translation correlations) in the second to fourth row. Only the first 32 filters are shown for brevity. It is interesting to see for most filters, there exist several filters that are roughly its translated versions.\nIn addition to the convenient visualization of the first layers, we further study this property at higher layers and/or in deeper models. To this end, we define the averaged maximum k-translation correlation of a layer W as ρ̄k(W) = 1N ∑N i=1 max N j=1,j 6=i ρk(Wi,Wj), where N is the number of filters. Intuitively, the ρ̄k of a convolutional layer characterizes the average level of translation correlation among the filters within it. We then load the weights of all the convolutional layers of AlexNet as well as the 19-layer VGGNet [2] from the Caffe model zoo, and report the averaged maximum 1-translation correlation of each layer in Figure 2. In each graph, the height of the red bars indicates the ρ̄1 calculated with the weights of the corresponding layer. As a comparison, for each layer we have also generated a filter bank with the same shape but filled with standard Gaussian samples, whose ρ̄1 are shown as the blue bars. We clearly see that all the layers in both models demonstrate averaged maximum translation correlations that are significantly higher than their random counterparts. In addition, it appears that lower convolutional layers generally have higher translation correlations, although this does not strictly hold (e.g., conv3_4 in VGGNet).\nMotivated by the evidence shown above, we propose the doubly convolutional layer (with the double convolution operation), which can be plugged in place of a convolutional layer in CNNs, yielding the doubly convolutional neural networks (DCNNs). The idea of double convolution is to learn groups filters where filters within each group are translated versions of each other. To achieve this, a doubly convolutional layer allocates a set of meta filters which has filter sizes that are larger than the effective filter size. Effective filters can be then extracted from each meta filter, which corresponds to convolving the meta filters with an identity kernel. All the extracted filters are then concatenated, and convolved with the input. Optionally, one can also choose to pool along activations produced by filters from the same meta filter, in a similar spirit to the maxout networks [8]. We also show that double convolution can be easily implemented with available deep learning libraries by utilizing the efficient\ns ) 2 times more channels for the output image, with s× s being the pooling size.\nconvolutional kernel. In our experiments, we show that the additional level of parameter sharing by double convolution allows one to build DCNNs that yield an excellent performance on several popular image classification benchmarks, consistently outperforming all the competing architectures with a margin. We have also confirmed that replacing a convolutional layer with a doubly convolutional layer consistently improves the performance, regardless of the depth of the layer. Last but not least, we show that one is able to balance the trade off between performance and parameter efficiency by leveraging the architecture of a DCNN."
    }, {
      "heading" : "2 Model",
      "text" : ""
    }, {
      "heading" : "2.1 Convolution",
      "text" : "We define an image I ∈ Rc×w×h as a real-valued 3D tensor, where c is the number of channels; w, h are the width and height, respectively. We define the convolution operation, denoted by I`+1 = I` ∗W`, as follows:\nI`+1k,i,j = ∑\nc′∈[1,c],i′∈[1,z],j′∈[1,z]\nW`k,c′,i′,j′I`c′,i+i′−1,j+j′−1,\nk ∈ [1, c`+1], i ∈ [1, w`+1], j ∈ [1, h`+1]. (2)\nHere I` ∈ Rc`×w`×h` is the input image; W` ∈ Rc`+1×c`×z×z is a set of c`+1 filters, with each filter of shape c` × z × z; I`+1 ∈ Rc`+1×w`+1×h`+1 is the output image. The spatial dimensions of the output image w`+1, h`+1 are by default w` + z − 1 and h` + z − 1, respectively (aka, valid convolution), but one can also pad a number of zeros at the borders of I` to achieve different output spatial dimensions (e.g., keeping the spatial dimensions unchanged). In this paper, we use a loose notation by freely allowing both the LHS and RHS of ∗ to be either a single image (filter) or a set of images (filters), with proper convolution along the non-spatial dimensions.\nA convolutional layer can thus be implemented with a convolution operation followed by a nonlinearity function such as ReLU, and a convolutional neural network (CNN) is constructed by interweaving several convolutoinal and spatial pooling layers."
    }, {
      "heading" : "2.2 Double convolution",
      "text" : "We next introduce and define the double convolution operation, denoted by I`+1 = I` ⊗W`, as follows:\nO`+1i,j,k = W ` k ∗ I`:,i:(i+z−1),j:(j+z−1),\nI`+1(nk+1):n(k+1),i,j = pools(O `+1 i,j,k), n = ( z′ − z + 1 s )2, k ∈ [1, c`+1], i ∈ [1, w`+1], j ∈ [1, h`+1].\n(3)\nHere I` ∈ Rc`×w`×h` and I`+1 ∈ Rnc`+1×w`+1×h`+1 are the input and output image, respectively. W` ∈ Rc`+1×c`×z′×z′ are a set of c`+1 meta filters, with filter size z′ × z′, z′ > z; O`+1i,j,k ∈ R(z\n′−z+1)×(z′−z+1) is the intermediate output of double convolution; pools(·) defines a spatial pooling function with pooling size s × s (and optionally reshaping the output to a column vector, inferred from the context); ∗ is the convolution operator defined previously in Equation 2. In words, a double convolution applies a set of c`+1 meta filters with spatial dimensions z′ × z′, which are larger than the effective filter size z × z. Image patches of size z × z at each location (i, j) of the input image, denoted by I`:,i:(i+z−1),j:(j+z−1), are then convolved with each meta filter, resulting an output of size z′ − z + 1× z′ − z + 1, for each (i, j). A spatial pooling of size s× s is then applied along this resulting output map, whose output is flattened into a column vector. This produces an output feature map with nc`+1 channels. The above procedure can be viewed as a two step convolution, where image patches are first convolved with meta filters, and the meta filters then slide across and convolve with the image, hence the name double convolution.\nA doubly convolutional layer is by analogy defined as a double convolution followed by a nonlinearity; and substituting the convolutional layers in a CNN with doubly convolutional layers yields a doubly convolutional neural network (DCNN). In Figure 3 we have illustrated the difference between a convolutional layer and a doubly convolutional layer. It is possible to vary the combination of z, z′, s for each doubly convolutional layer of a DCNN to yield different variants, among which three extreme cases are:\n(1) CNN: Setting z′ = z recovers the standard CNN; hence, DCNN is a generalization of CNN.\n(2) ConcatDCNN: Setting s = 1 produces a DCNN variant that is maximally parameter efficient. This corresponds to extracting all sub-regions of size z × z from a z′ × z′ sized meta filter, which are then stacked to form a set of (z′ − z + 1)2 filters with size z × z. With the same amount of parameters, this produces (z\n′−z+1)2z2 (z′)2 times more channels for a single layer.\n(3) MaxoutDCNN: Setting s = z′− z+ 1, i.e., applying global pooling onO`+1, produces a DCNN variant where the output image channel size is equal to the number of the meta filters. Interestingly, this yields a parameter efficient implementation of the maxout network [8]. To be concrete, the maxout units in a maxout network are equivalent to pooling along the channel (feature) dimension, where each channel corresponds to a distinct filter. MaxoutDCNN, on the other hand, pools along channels which are produced by the filters that are translated versions of each other. Besides the obvious advantage of reducing the number of parameters required, this also acts as an effective regularizer, which is verified later in the experiments at Section 4.\nImplementing a double convolution is also readily supported by most main stream GPU-compatible deep learning libraries (e.g., Theano which is used in our experiments), which we have summarized in Algorithm 1. In particular, we are able to perform double convolution by two steps of convolution, corresponding to line 4 and line 6, together with proper reshaping and pooling operations. The first convolution extracts overlapping patches of size z× z from the meta filters, which are then convolved with the input image. Although it is possible to further reduce the time complexity by designing a specialized double convolution module, we find that Algorithm 1 scales well to deep DCNNs, and large datasets such as ImageNet."
    }, {
      "heading" : "3 Related work",
      "text" : "The spirit of DCNNs is to further push the idea of parameter sharing of the convolutional layers, which is shared by several recent efforts. [9] explores the rotation symmetry of certain classes of images, and hence proposes to rotate each filter (or alternatively, the input) by a multiplication of 90◦ which produces four times filters with the same amount of parameters for a single layer. [10] observes that filters learned by ReLU CNNs often contain pairs with opposite phases in the lower layers. The authors accordingly propose the concatenated ReLU where the linear activations are concatenated with their negations and then passed to ReLU, which effectively doubles the number of filters. [11] proposes the dilated convolutions, where additional filters with larger sizes are generated by dilating the base convolutional filters, which is shown to be effective in dense prediction tasks such as image segmentation. [12] proposes a multi-bias activation scheme where k, k ≤ 1, bias terms are learned for each filter, which produces a k times channel size for the convolution output.\nAlgorithm 1: Implementation of double convolution with convolution.\nInput: Input image I` ∈ Rc `×w`×h` , meta filters W` ∈ Rc `+1×z′×z′ , effective filter size z × z, pooling size s× s. Output: Output image I`+1 ∈ Rnc `+1×w`+1×h`+1 , with n = (z\n′−z+1)2 s2\n. 1 begin 2 I` ← IdentityMatrix (c`z2) ; 3 Reorganize I` to shape c`z2 × c` × z × z; 4 W̃` ←W` ∗ I` ; /* output shape: c`+1 × c`z2 × (z′ − z + 1)× (z′ − z + 1) */ 5 Reorganize W̃` to shape c`+1(z′ − z + 1)2 × c` × z × z; 6 O`+1 ← I` ∗ W̃` ; /* output shape: c`+1(z′ − z + 1)2 × w`+1 × h`+1 */ 7 Reorganize O`+1 to shape c`+1w`+1h`+1 × (z′ − z + 1)× (z′ − z + 1) ; 8 I`+1 ← pools(O`+1) ; /* output shape: c`+1w`+1h`+1 × z ′−z+1 s × z ′−z+1 s\n*/ 9 Reorganize I`+1 to shape c`+1( z\n′−z+1 s )2 × w`+1 × h`+1 ;\nAdditionally, [13, 14] have investigated the combination of more than one transformations of filters, such as rotation, flipping and distortion. Note that all the aforementioned approaches are orthogonal to DCNNs and can theoretically be combined in a single model. The need of correlated filters in CNNs is also studied in [15], where similar filters are explicitly learned and grouped with a group sparsity penalty.\nWhile DCNNs are designed with better performance and generalization ability in mind, they are also closely related to the thread of work on parameter reduction in deep neural networks. The work of Vikas and Tara [16] addresses the problem of compressing deep networks by applying structured transforms. [17] exploits the redundancy in the parametrization of deep architectures by imposing a circulant structure on the projection matrix, while allowing the use of FFT for faster computations. [18] attempts to obtain the compression of the fully-connected layers of the AlexNettype network with the Fastfood method. Novikov et al. [19] use a multi-linear transform (Tensor-Train decomposition) to attain reduction of the number of parameters in the linear layers of CNNs. These work differ from DCNNs as most of their focuses are on the fully connected layers, which often accounts for most of the memory consumption. DCNNs, on the other hand, apply directly to the convolutional layers, which provides a complementary view to the same problem."
    }, {
      "heading" : "4 Experiments",
      "text" : ""
    }, {
      "heading" : "4.1 Datasets",
      "text" : "We conduct several sets of experiments with DCNN on three image classification benchmarks: CIFAR-10, CIFAR-100, and ImageNet. CIFAR-10 and CIFAR-100 both contain 50,000 training and 10,000 testing 32× 32 sized RGB images, evenly drawn from 10 and 100 classes, respectively. ImageNet is the dataset used in the ILSVRC-2012 challenge, which consists of about 1.2 million images for training and 50,000 images for validation, sampled from 1,000 classes."
    }, {
      "heading" : "4.2 Is DCNN an effective architecture?",
      "text" : ""
    }, {
      "heading" : "4.2.1 Model specifications",
      "text" : "In the first set of experiments, we study the effectiveness of DCNN compared with two different CNN designs. The three types of architectures subject to evaluation are:\n(1) CNN: This corresponds to models using the standard convolutional layers. A convolutional layer is denoted as C-<c>-<z>, where c, z are the number of filters and the filter size, respectively.\n(2) MaxoutCNN: This corresponds to the maxout convolutional networks [8], which uses the maxout unit to pool along the channel (feature) dimensions with a stride k. A maxout convolutional layer is denoted as MC-<c>-<z>-<k>, where c, z, k are the number of filters, the filter size, and the feature pooling stride, respectively.\n(3) DCNN: This corresponds to using the doubly convolutional layers. We denote a doubly convolutional layer with c filters as DC-<c>-<z′>-<z>-<s>, where z′, z, s are the meta filter size, effective filter size and pooling size, respectively, as in Equation 3. In this set of experiments, we use the MaxoutDCNN variant, whose layers are readily represented as DC-<c>-<z′>-<z>-<z′ − z + 1>. We denote a spatial max pooling layer as P-<s> with s as the pooling size. For all the models, we apply batch normalization [6] immediately after each convolution layer, after which ReLU is used as the nonlinearity (including MaxoutCNN, which makes out implementation slightly different from [8]). Our model design is similar to VGGNet [2] where 3× 3 filter sizes are used, as well as Network in Network [20] where fully connected layers are completely eliminated. Zero padding is used before each convolutional layer to maintain the spatial dimensions unchanged after convolution. Dropout is applied after each pooling layer. Global average pooling is applied on top of the last convolutional layer, which is fed to a Softmax layer with a proper number of outputs.\nAll the three models on each dataset are of the same architecture w.r.t. the number of layers and the number of units per layer. The only difference thus resides in the choice of the convolutional layers. Note that the architecture we have used on the ImageNet dataset resembles the 16-layer VGGNet [2], but without the fully connected layers. The full specification of the model architectures is shown in Table 1."
    }, {
      "heading" : "4.2.2 Training protocols",
      "text" : "We preprocess all the datasets by extracting the mean for each pixel and each channel, calculated on the training sets. All the models are trained with Adadelta [21] on NVIDIA K40 GPUs. Bath size is set as 200 for CIFAR-10 and CIFAR-100, and 128 for ImageNet.\nData augmentation has also been explored. On CIFAR-10 and CIFAR-100, We follow the simple data augmentation as in [2]. For training, 4 pixels are padded on each side of the images, from which 32× 32 crops are sampled with random horizontal flipping. For testing, only the original 32× 32 images are used. On ImageNet, 224× 224 crops are sampled with random horizontal flipping; the standard color augmentation and the 10-crop testing are also applied as in AlexNet [1]."
    }, {
      "heading" : "4.2.3 Results",
      "text" : "The test errors are summarized in Table 2 and Table 3, where the relative # parameters of DCNN and MaxoutCNN compared with the standard CNN are also shown. On the moderately-sized datasets CIFAR-10 and CIFAR-100, DCNN achieves the best results of the three control experiments, with and without data augmentation. Notably, DCNN consistently improves over the standard CNN with a margin. More remarkably, DCNN also consistently outperforms MaxoutCNN, with 2.25 times less parameters. This on the one hand proves that the doubly convolutional layers greatly improves the model capacity, and on the other hand verifies our hypothesis that the parameter sharing introduced by double convolution indeed acts as a very effective regularizer. The results achieved by DCNN on the two datasets are also among the best published results compared with [20, 22, 23, 24].\nBesides, we also note that DCNN does not have difficulty scaling up to a large dataset as ImageNet, where consistent performance gains over the other baseline architectures are again observed. Compared with the results of the 16-layer VGGNet in [2] with multiscale evaluation, our DCNN implementation achieves comparable results, with significantly less parameters."
    }, {
      "heading" : "4.3 Does double convolution contribute to every layer?",
      "text" : "In the next set of experiments, we study the effect of applying double convolution to layers at various depths. To this end, we replace the convolutional layers at each level of the standard CNN defined in 4.2.1 with a doubly convolutional layer counterpart (e.g., replacing a C-128-3 layer with a DC-128-4-3-2 layer). We hence define DCNN[i-j] as the network resulted from replacing the i− jth convolutional layer of a CNN with its doubly convolutional layer counterpart, and train {DCNN[1-2], DCNN[3-4], DCNN[5-6], DCNN[7-8]} on CIFAR-10 and CIFAR-100 following the same protocol as that in Section 4.2.2. The results are shown in Table 4. Interestingly, the doubly convolutional layer is able to consistently improve the performance over that of the standard CNN regardless of the depth with which it is plugged in. Also, it seems that applying double convolution at lower layers contributes more to the performance, which is consistent with the trend of translation correlation observed in Figure 2.\n4.4 Performance vs. parameter efficiency\nIn the last set of experiments, we study the behavior of DCNNs under various combinations of its hyper-parameters, z′, z, s. To this end, we train three more DCNNs on CIFAR-10 and CIFAR-100, namely {DCNN-32-6-3-2, DCNN-16-6-3-1, DCNN-4-10-3-1}. Here we have overloaded the notation for a doubly convolutional layer to denote a DCNN which contains correspondingly shaped doubly convolutional layers (the DCNN in Table 1 thus corresponds to DCNN-128-4-3-2). In particular, DCNN-32-6-3-2 produces a DCNN with the exact same shape and number of parameters of those of the reference CNN; DCNN-16-6-3-1, DCNN-4-10-3-1 are two ConcatDCNN instances from Section 2.2, which produce larger sized models with same or less amount of parameters. The results, together with the effective layer size and the relative number of parameters, are listed in Table 5. We see that all the variants of DCNN consistently outperform the standard CNN, even when fewer parameters are used (DCNN-4-10-3-1). This verifies that DCNN is a flexible framework which allows one to either maximize the performance with a fixed memory budget, or on the other hand, minimize the memory footprint without sacrificing the accuracy. One can choose the best suitable architecture of a DCNN by balancing the trade off between performance and the memory footprint."
    }, {
      "heading" : "5 Conclusion",
      "text" : "We have proposed the doubly convolutional neural networks (DCNNs), which utilize a novel double convolution operation to provide an additional level of parameter sharing over CNNs. We show that DCNNs generalize standard CNNs, and relate to several recent proposals that explore parameter redundancy in CNNs. A DCNN can be easily implemented by modern deep learning libraries by reusing the efficient convolution module. DCNNs can be used to serve the dual purpose of 1) improving the classification accuracy as a regularized version of maxout networks, and 2) being parameter efficient by flexibly varying their architectures. In the extensive experiments on CIFAR-10, CIFAR-100, and ImageNet datasets, we have shown that DCNNs significantly improves over other architecture counterparts. In addition, we have shown that introducing the doubly convolutional layer to any layer of a CNN improves its performance. We have also experimented with various configurations of DCNNs, all of which are able to outperform the CNN counterpart with the same or fewer number of parameters."
    } ],
    "references" : [ {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "Alex Krizhevsky", "Ilya Sutskever", "Geoffrey E Hinton" ],
      "venue" : "In Advances in neural information processing systems,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2012
    }, {
      "title" : "Very deep convolutional networks for large-scale image recognition",
      "author" : [ "Karen Simonyan", "Andrew Zisserman" ],
      "venue" : "arXiv preprint arXiv:1409.1556,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2014
    }, {
      "title" : "Going deeper with convolutions",
      "author" : [ "Christian Szegedy", "Wei Liu", "Yangqing Jia", "Pierre Sermanet", "Scott Reed", "Dragomir Anguelov", "Dumitru Erhan", "Vincent Vanhoucke", "Andrew Rabinovich" ],
      "venue" : "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2015
    }, {
      "title" : "Deep residual learning for image recognition",
      "author" : [ "Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun" ],
      "venue" : "arXiv preprint arXiv:1512.03385,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2015
    }, {
      "title" : "Dropout: A simple way to prevent neural networks from overfitting",
      "author" : [ "Nitish Srivastava", "Geoffrey Hinton", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1929
    }, {
      "title" : "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
      "author" : [ "Sergey Ioffe", "Christian Szegedy" ],
      "venue" : "arXiv preprint arXiv:1502.03167,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2015
    }, {
      "title" : "Caffe: Convolutional architecture for fast feature embedding",
      "author" : [ "Yangqing Jia", "Evan Shelhamer", "Jeff Donahue", "Sergey Karayev", "Jonathan Long", "Ross Girshick", "Sergio Guadarrama", "Trevor Darrell" ],
      "venue" : "In Proceedings of the ACM International Conference on Multimedia,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2014
    }, {
      "title" : "Exploiting cyclic symmetry in convolutional neural networks",
      "author" : [ "Sander Dieleman", "Jeffrey De Fauw", "Koray Kavukcuoglu" ],
      "venue" : "arXiv preprint arXiv:1602.02660,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2016
    }, {
      "title" : "Understanding and improving convolutional neural networks via concatenated rectified linear units",
      "author" : [ "Wenling Shang", "Kihyuk Sohn", "Diogo Almeida", "Honglak Lee" ],
      "venue" : "arXiv preprint arXiv:1603.05201,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2016
    }, {
      "title" : "Multi-scale context aggregation by dilated convolutions",
      "author" : [ "Fisher Yu", "Vladlen Koltun" ],
      "venue" : "arXiv preprint arXiv:1511.07122,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2015
    }, {
      "title" : "Multi-bias non-linear activation in deep neural networks",
      "author" : [ "Hongyang Li", "Wanli Ouyang", "Xiaogang Wang" ],
      "venue" : "arXiv preprint arXiv:1604.00676,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2016
    }, {
      "title" : "Deep symmetry networks",
      "author" : [ "Robert Gens", "Pedro M Domingos" ],
      "venue" : "In Advances in neural information processing systems,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2014
    }, {
      "title" : "Group equivariant convolutional networks",
      "author" : [ "Taco S Cohen", "Max Welling" ],
      "venue" : "arXiv preprint arXiv:1602.07576,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2016
    }, {
      "title" : "Learning invariant features through topographic filter maps",
      "author" : [ "Koray Kavukcuoglu", "Rob Fergus", "Yann LeCun" ],
      "venue" : "In Computer Vision and Pattern Recognition,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2009
    }, {
      "title" : "Structured transforms for small-footprint deep learning",
      "author" : [ "Vikas Sindhwani", "Tara Sainath", "Sanjiv Kumar" ],
      "venue" : "Advances in Neural Information Processing Systems",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2015
    }, {
      "title" : "An exploration of parameter redundancy in deep networks with circulant projections",
      "author" : [ "Yu Cheng", "Felix X. Yu", "Rogerio Feris", "Sanjiv Kumar", "Shih-Fu Chang" ],
      "venue" : "In International Conference on Computer Vision (ICCV),",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2015
    }, {
      "title" : "Deep fried convnets",
      "author" : [ "Zichao Yang", "Marcin Moczulski", "Misha Denil", "Nando de Freitas", "Alex Smola", "Le Song", "Ziyu Wang" ],
      "venue" : "In International Conference on Computer Vision (ICCV),",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2015
    }, {
      "title" : "Tensorizing neural networks",
      "author" : [ "Alexander Novikov", "Dmitry Podoprikhin", "Anton Osokin", "Dmitry Vetrov" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2015
    }, {
      "title" : "Adadelta: an adaptive learning rate method",
      "author" : [ "Matthew D Zeiler" ],
      "venue" : "arXiv preprint arXiv:1212.5701,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2012
    }, {
      "title" : "Learning activation functions to improve deep neural networks",
      "author" : [ "Forest Agostinelli", "Matthew Hoffman", "Peter J. Sadowski", "Pierre Baldi" ],
      "venue" : "CoRR, abs/1412.6830,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2014
    }, {
      "title" : "Fast and accurate deep network learning by exponential linear units (elus)",
      "author" : [ "Djork-Arné Clevert", "Thomas Unterthiner", "Sepp Hochreiter" ],
      "venue" : "arXiv preprint arXiv:1511.07289,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "While considerable progresses have been achieved by aggressively exploring deeper architectures [1, 2, 3, 4] or novel regularization techniques [5, 6] with the standard \"convolution + pooling\" recipe, we contribute from a different view by providing an alternative to the default convolution module, which can lead to models with even better generalization abilities and/or parameter efficiency.",
      "startOffset" : 96,
      "endOffset" : 108
    }, {
      "referenceID" : 1,
      "context" : "While considerable progresses have been achieved by aggressively exploring deeper architectures [1, 2, 3, 4] or novel regularization techniques [5, 6] with the standard \"convolution + pooling\" recipe, we contribute from a different view by providing an alternative to the default convolution module, which can lead to models with even better generalization abilities and/or parameter efficiency.",
      "startOffset" : 96,
      "endOffset" : 108
    }, {
      "referenceID" : 2,
      "context" : "While considerable progresses have been achieved by aggressively exploring deeper architectures [1, 2, 3, 4] or novel regularization techniques [5, 6] with the standard \"convolution + pooling\" recipe, we contribute from a different view by providing an alternative to the default convolution module, which can lead to models with even better generalization abilities and/or parameter efficiency.",
      "startOffset" : 96,
      "endOffset" : 108
    }, {
      "referenceID" : 3,
      "context" : "While considerable progresses have been achieved by aggressively exploring deeper architectures [1, 2, 3, 4] or novel regularization techniques [5, 6] with the standard \"convolution + pooling\" recipe, we contribute from a different view by providing an alternative to the default convolution module, which can lead to models with even better generalization abilities and/or parameter efficiency.",
      "startOffset" : 96,
      "endOffset" : 108
    }, {
      "referenceID" : 4,
      "context" : "While considerable progresses have been achieved by aggressively exploring deeper architectures [1, 2, 3, 4] or novel regularization techniques [5, 6] with the standard \"convolution + pooling\" recipe, we contribute from a different view by providing an alternative to the default convolution module, which can lead to models with even better generalization abilities and/or parameter efficiency.",
      "startOffset" : 144,
      "endOffset" : 150
    }, {
      "referenceID" : 5,
      "context" : "While considerable progresses have been achieved by aggressively exploring deeper architectures [1, 2, 3, 4] or novel regularization techniques [5, 6] with the standard \"convolution + pooling\" recipe, we contribute from a different view by providing an alternative to the default convolution module, which can lead to models with even better generalization abilities and/or parameter efficiency.",
      "startOffset" : 144,
      "endOffset" : 150
    }, {
      "referenceID" : 0,
      "context" : "Figure 1: Visualization of the 11× 11 sized first layer filters learned by AlexNet [1].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 0,
      "context" : "Figure 2: Illustration of the averaged maximum 1-translation correlation, together with the standard deviation, of each convolutional layer for AlexNet [1] (left), and the 19-layer VGGNet [2] (right), respectively.",
      "startOffset" : 152,
      "endOffset" : 155
    }, {
      "referenceID" : 1,
      "context" : "Figure 2: Illustration of the averaged maximum 1-translation correlation, together with the standard deviation, of each convolutional layer for AlexNet [1] (left), and the 19-layer VGGNet [2] (right), respectively.",
      "startOffset" : 188,
      "endOffset" : 191
    }, {
      "referenceID" : 0,
      "context" : "As a concrete example, Figure 1 demonstrates the 3-translation correlation of the first layer filters learned by the AlexNet [1], with the weights obtained from the Caffe model zoo [7].",
      "startOffset" : 125,
      "endOffset" : 128
    }, {
      "referenceID" : 6,
      "context" : "As a concrete example, Figure 1 demonstrates the 3-translation correlation of the first layer filters learned by the AlexNet [1], with the weights obtained from the Caffe model zoo [7].",
      "startOffset" : 181,
      "endOffset" : 184
    }, {
      "referenceID" : 1,
      "context" : "We then load the weights of all the convolutional layers of AlexNet as well as the 19-layer VGGNet [2] from the Caffe model zoo, and report the averaged maximum 1-translation correlation of each layer in Figure 2.",
      "startOffset" : 99,
      "endOffset" : 102
    }, {
      "referenceID" : 7,
      "context" : "[9] explores the rotation symmetry of certain classes of images, and hence proposes to rotate each filter (or alternatively, the input) by a multiplication of 90◦ which produces four times filters with the same amount of parameters for a single layer.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[10] observes that filters learned by ReLU CNNs often contain pairs with opposite phases in the lower layers.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 9,
      "context" : "[11] proposes the dilated convolutions, where additional filters with larger sizes are generated by dilating the base convolutional filters, which is shown to be effective in dense prediction tasks such as image segmentation.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[12] proposes a multi-bias activation scheme where k, k ≤ 1, bias terms are learned for each filter, which produces a k times channel size for the convolution output.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "Additionally, [13, 14] have investigated the combination of more than one transformations of filters, such as rotation, flipping and distortion.",
      "startOffset" : 14,
      "endOffset" : 22
    }, {
      "referenceID" : 12,
      "context" : "Additionally, [13, 14] have investigated the combination of more than one transformations of filters, such as rotation, flipping and distortion.",
      "startOffset" : 14,
      "endOffset" : 22
    }, {
      "referenceID" : 13,
      "context" : "The need of correlated filters in CNNs is also studied in [15], where similar filters are explicitly learned and grouped with a group sparsity penalty.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 14,
      "context" : "The work of Vikas and Tara [16] addresses the problem of compressing deep networks by applying structured transforms.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 15,
      "context" : "[17] exploits the redundancy in the parametrization of deep architectures by imposing a circulant structure on the projection matrix, while allowing the use of FFT for faster computations.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "[18] attempts to obtain the compression of the fully-connected layers of the AlexNettype network with the Fastfood method.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 17,
      "context" : "[19] use a multi-linear transform (Tensor-Train decomposition) to attain reduction of the number of parameters in the linear layers of CNNs.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 1,
      "context" : "The architectures on the ImageNet dataset are variants of the 16-layer VGGNet [2] (right).",
      "startOffset" : 78,
      "endOffset" : 81
    }, {
      "referenceID" : 5,
      "context" : "For all the models, we apply batch normalization [6] immediately after each convolution layer, after which ReLU is used as the nonlinearity (including MaxoutCNN, which makes out implementation slightly different from [8]).",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 1,
      "context" : "Our model design is similar to VGGNet [2] where 3× 3 filter sizes are used, as well as Network in Network [20] where fully connected layers are completely eliminated.",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 1,
      "context" : "Note that the architecture we have used on the ImageNet dataset resembles the 16-layer VGGNet [2], but without the fully connected layers.",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 18,
      "context" : "All the models are trained with Adadelta [21] on NVIDIA K40 GPUs.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 1,
      "context" : "On CIFAR-10 and CIFAR-100, We follow the simple data augmentation as in [2].",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 0,
      "context" : "On ImageNet, 224× 224 crops are sampled with random horizontal flipping; the standard color augmentation and the 10-crop testing are also applied as in AlexNet [1].",
      "startOffset" : 160,
      "endOffset" : 163
    }, {
      "referenceID" : 19,
      "context" : "The results achieved by DCNN on the two datasets are also among the best published results compared with [20, 22, 23, 24].",
      "startOffset" : 105,
      "endOffset" : 121
    }, {
      "referenceID" : 20,
      "context" : "The results achieved by DCNN on the two datasets are also among the best published results compared with [20, 22, 23, 24].",
      "startOffset" : 105,
      "endOffset" : 121
    }, {
      "referenceID" : 1,
      "context" : "Compared with the results of the 16-layer VGGNet in [2] with multiscale evaluation, our DCNN implementation achieves comparable results, with significantly less parameters.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 19,
      "context" : "22% APL [23] 9.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 20,
      "context" : "83% ELU [24] 6.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 0,
      "context" : "We hence define DCNN[i-j] as the network resulted from replacing the i− jth convolutional layer of a CNN with its doubly convolutional layer counterpart, and train {DCNN[1-2], DCNN[3-4], DCNN[5-6], DCNN[7-8]} on CIFAR-10 and CIFAR-100 following the same protocol as that in Section 4.",
      "startOffset" : 169,
      "endOffset" : 174
    }, {
      "referenceID" : 1,
      "context" : "We hence define DCNN[i-j] as the network resulted from replacing the i− jth convolutional layer of a CNN with its doubly convolutional layer counterpart, and train {DCNN[1-2], DCNN[3-4], DCNN[5-6], DCNN[7-8]} on CIFAR-10 and CIFAR-100 following the same protocol as that in Section 4.",
      "startOffset" : 169,
      "endOffset" : 174
    }, {
      "referenceID" : 2,
      "context" : "We hence define DCNN[i-j] as the network resulted from replacing the i− jth convolutional layer of a CNN with its doubly convolutional layer counterpart, and train {DCNN[1-2], DCNN[3-4], DCNN[5-6], DCNN[7-8]} on CIFAR-10 and CIFAR-100 following the same protocol as that in Section 4.",
      "startOffset" : 180,
      "endOffset" : 185
    }, {
      "referenceID" : 3,
      "context" : "We hence define DCNN[i-j] as the network resulted from replacing the i− jth convolutional layer of a CNN with its doubly convolutional layer counterpart, and train {DCNN[1-2], DCNN[3-4], DCNN[5-6], DCNN[7-8]} on CIFAR-10 and CIFAR-100 following the same protocol as that in Section 4.",
      "startOffset" : 180,
      "endOffset" : 185
    }, {
      "referenceID" : 4,
      "context" : "We hence define DCNN[i-j] as the network resulted from replacing the i− jth convolutional layer of a CNN with its doubly convolutional layer counterpart, and train {DCNN[1-2], DCNN[3-4], DCNN[5-6], DCNN[7-8]} on CIFAR-10 and CIFAR-100 following the same protocol as that in Section 4.",
      "startOffset" : 191,
      "endOffset" : 196
    }, {
      "referenceID" : 5,
      "context" : "We hence define DCNN[i-j] as the network resulted from replacing the i− jth convolutional layer of a CNN with its doubly convolutional layer counterpart, and train {DCNN[1-2], DCNN[3-4], DCNN[5-6], DCNN[7-8]} on CIFAR-10 and CIFAR-100 following the same protocol as that in Section 4.",
      "startOffset" : 191,
      "endOffset" : 196
    }, {
      "referenceID" : 6,
      "context" : "We hence define DCNN[i-j] as the network resulted from replacing the i− jth convolutional layer of a CNN with its doubly convolutional layer counterpart, and train {DCNN[1-2], DCNN[3-4], DCNN[5-6], DCNN[7-8]} on CIFAR-10 and CIFAR-100 following the same protocol as that in Section 4.",
      "startOffset" : 202,
      "endOffset" : 207
    }, {
      "referenceID" : 1,
      "context" : "78 VGG-16 [2] 7.",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 3,
      "context" : "3 ResNet-152 [4] 5.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 2,
      "context" : "1 GoogLeNet [3] 7.",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 0,
      "context" : "26% DCNN[1-2] 9.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 1,
      "context" : "26% DCNN[1-2] 9.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 2,
      "context" : "91% DCNN[3-4] 9.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 3,
      "context" : "91% DCNN[3-4] 9.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 4,
      "context" : "27% DCNN[5-6] 9.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 5,
      "context" : "27% DCNN[5-6] 9.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 6,
      "context" : "58% DCNN[7-8] 9.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 0,
      "context" : "72% DCNN[1-8] 8.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 1,
      "context" : "72% DCNN[1-8] 8.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 2,
      "context" : "72% DCNN[1-8] 8.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 3,
      "context" : "72% DCNN[1-8] 8.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 4,
      "context" : "72% DCNN[1-8] 8.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 5,
      "context" : "72% DCNN[1-8] 8.",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 6,
      "context" : "72% DCNN[1-8] 8.",
      "startOffset" : 8,
      "endOffset" : 13
    } ],
    "year" : 2016,
    "abstractText" : "Building large models with parameter sharing accounts for most of the success of deep convolutional neural networks (CNNs). In this paper, we propose doubly convolutional neural networks (DCNNs), which significantly improve the performance of CNNs by further exploring this idea. In stead of allocating a set of convolutional filters that are independently learned, a DCNN maintains groups of filters where filters within each group are translated versions of each other. Practically, a DCNN can be easily implemented by a two-step convolution procedure, which is supported by most modern deep learning libraries. We perform extensive experiments on three image classification benchmarks: CIFAR-10, CIFAR-100 and ImageNet, and show that DCNNs consistently outperform other competing architectures. We have also verified that replacing a convolutional layer with a doubly convolutional layer at any depth of a CNN can improve its performance. Moreover, various design choices of DCNNs are demonstrated, which shows that DCNN can serve the dual purpose of building more accurate models and/or reducing the memory footprint without sacrificing the accuracy.",
    "creator" : "LaTeX with hyperref package"
  }
}