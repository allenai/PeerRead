{
  "name" : "1102.2125.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Improving DPLL Solver Performance with Domain-Specific Heuristics: the ASP Case",
    "authors" : [ "Marcello Balduccini" ],
    "emails" : [ "marcello.balduccini@gmail.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n10 2.\n21 25\nv1 [\ncs .A\nI] 1\n0 Fe"
    }, {
      "heading" : "1 Introduction",
      "text" : "In recent years, solvers based on the DPLL procedure [1,2] have become amazingly fast. Mostly, that is due to good heuristics that direct the search toward the most promising areas of the search space, and to learning algorithms that discover features of the search space on-the-fly. Unfortunately, when the search space is sufficiently large, it is still possible for the search algorithm to mistakenly focus on areas of the search space that contain no solutions or very few. When that happens, performance degrades substantially, even to the point that the solver may need to be terminated before returning an answer. This prospect is a real concern when one is considering using such a solver in an industrial application, in which the solver will act as part of a black-box from which users typically expect consistent performance. It should be noted that the phenomenon of performance degradation is often due to the fact that the heuristics used in choice-point selection are general-purpose, and thus may not fit well a given domain.\nVarious methods have been proposed in the literature to improve solver stability. A basic technique involves using parametrized general-purpose heuristics, for which the user can manually specify parameter values that are suitable for the domain of interest. An interesting step in that direction is provided by CLASPFOLIO [3], which makes\nuse of different configurations of the CLASP solver [4]. The program in input is automatically analyzed, and the most promising configuration of CLASP is selected accordingly. A different approach consists in having the solver adapt to the problem in input at run-time by means of learning. This is the case of the clause learning and conflict learning techniques that have recently become very popular especially in SAT and ASP solvers (see e.g. [5,4]), and have brought about substantial performance improvements. The idea behind these learning techniques is to record information about the conflicts that are detected during the exploration of the search space, and to use the information to avoid descending similar branches later. Hence, the basic heuristic is still generalpurpose, but it is adjusted, during execution, depending on the features of the problem in input. One drawback of this approach is that the learning is limited to the current program, and the information that has been learned in one run cannot be used in later runs of the solver.\nIn this paper we propose a framework, called DORS, which instead allows learning and using domain-specific heuristics in solvers based on the DPLL procedure. The results of learning are retained and can be used in later runs. In fact, the learning technique relies on the availability of information from multiple runs of the solver. Although here we focus on solvers for Answer Set Programming (ASP) [6,7], the DORS framework can be applied to any solver based on the DPLL procedure, including SAT and constraint solvers. Furthermore, the current framework is aimed at improving the efficiency of the computation of one model of consistent programs, but could be extended further. The learning is done off-line, on representative instances from the target domain. The particular learning technique used here is intendedly extremely simple, but already shows remarkable performance improvements. In experimental evaluation, the use of our technique improved performance on hard instances by up to 3 orders of magnitude (and 2 on average on industrial problems), nearly completely eliminating the situations in which the solver had to be terminated because the wait for an answer had become unacceptable.\nThis paper is organized as follows. In the next section we give some background on ASP. Next, we discuss the basic search algorithm used in most ASP solvers. Then, in Section 4, we present the DORS framework. Experimental results are discussed in Section 5. Finally, in Section 6, we draw conclusions."
    }, {
      "heading" : "2 Answer Set Programming",
      "text" : "We define the syntax of the language precisely, but only give its informal semantics in order to save space. We refer the reader to [6,8] for a specification of the formal semantics. Let Σ be a signature containing constant, function and predicate symbols. Terms and atoms are formed as usual in first-order logic. A (basic) literal is either an atom a or its strong (also called classical or epistemic) negation ¬a. The set of literals formed from Σ is denoted by lit(Σ). A rule is a statement of the form:\nh1 ∨ . . . ∨ hk ← l1, . . . , lm, not lm+1, . . . , not ln\nwhere hi’s and li’s are ground literals and not is the so-called default negation. The intuitive meaning of the rule is that a reasoner who believes {l1, . . . , lm} and has no\nreason to believe {lm+1, . . . , ln}, has to believe one of hi’s. The part of the statement to the left of ← is called head; the part to its right is called body. Symbol ← can be omitted if no li’s are specified. Often, rules of the form h ← not h, l1, . . . , not ln are abbreviated into ← l1, . . . , not ln, and called constraints. The intuitive meaning of a constraint is that its body must not be satisfied. A rule containing variables is interpreted as the shorthand for the set of rules obtained by replacing the variables with all the possible ground terms (called grounding of the rule). A program is a pair 〈Σ,Π〉, where Σ is a signature and Π is a set of rules over Σ. We often denote programs just by the second element of the pair, and let the signature be defined implicitly. In that case, the signature of Π is denoted by Σ(Π). Finally, an answer set (or model) of a programΠ is a collection of its consequences under the answer set semantics. Because a convenient representation of alternatives is often important in the formalization of knowledge, the language of ASP has been extended with constraint literals [8], which are expressions of the form m{l1, l2, . . . , lk}n, where m and n are arithmetic expressions and li’s are basic literals as defined above. A constraint literal is satisfied whenever the number of literals that hold from {l1, . . . , lk} is between m and n, inclusive. Using constraint literals, the choice between p and q, under some set of conditions Γ , can be compactly encoded by the rule 1{p, q}1 ← Γ . A rule of this form is called choice rule. When solving sets of problems from a given domain of interest, ASP programs are often divided into a domain description and a problem instance. Intuitively, the domain description encodes a description of the problem domain and of the solutions, while each problem instance encodes a different problem from the domain."
    }, {
      "heading" : "3 Search in ASP Solvers",
      "text" : "The search algorithm used by many ASP solvers (e.g. SMODELS [9], DLV [10]) is based on the DPLL procedure [1,2]. The basic algorithm for the computation of a single answer set, which we will later refer to as standard algorithm, is show in Figure 1. The\nalgorithm is based on the idea of growing a particular set of (ground) literals, often called partial answer set, until it is either shown to be an answer set of the program, or it becomes inconsistent. To achieve this, guesses have to be made as to which literals may be in the answer set. Let us now describe the algorithm more precisely. By extended literal we mean a literal l or the expression not l, intuitively meaning that l is\nknown not to hold in the answer set (but its complement, l, may or may not hold). Given an extended literal e, not(e) denotes the expression not l if e = l and it denotes l if e = not l. Algorithm solve takes as input program,Π , and partial answer set, A, which is a set of extended literals. A is initially empty. Function expand [9] is then used to add to the partial answer set all the literals that must hold given Π and A. If the result of expand is an answer set of Π , the algorithm returns it (and terminates). If instead a contradiction is discovered, then the algorithm returns no model (⊥). In all other cases, the partial answer set is still incomplete but consistent. Then, function choose literal selects an extended literal e such that neither e nor not(e) occur in B. This is called the choice literal or choice point. The algorithm then calls itself recursively in order to find an answer set of Π from the partial answer set B ∪ {e}. If one such answer set is found, then the algorithm returns it. If instead no answer set is found, then the algorithm attempts to find an answer set of Π that contains B∪{not(e)}. If the attempt succeeds, the answer set is returned. Otherwise, the algorithm returns no model (⊥).\nIt is not difficult to see how the choices made by choose literal greatly influence the number of choice points picked by the algorithm, and ultimately its performance. Consider for example the program:\nP1 =\n\n      \n       \np ← not q. q ← not p.\nr. ← p, r. ← q, not s.\nu(X) ← t(X), not v(X). v(X) ← t(X), not u(X).\nt(0). t(1). . . . t(1000).\nThe program is clearly inconsistent. In fact, the first two rules force either p or q to hold, but the next three rules forbid p and q from holding. So, if the first call to choose literal were to select e.g. not p, then the following call to expand would conclude that q must hold, and that inconsistency follows (since s is not defined by any rule and thus the body of the corresponding constraint is satisfied). The algorithm would then backtrack and select p. This time, expand would derive inconsistency from the fact that the body of the first constraint is satisfied. Hence, the algorithm would return ⊥ (no model). However, consider what would happen if choose literal were to select u(0) instead of not p. Function expand would derive the consequence not v(0) and fail to reach inconsistency. Then, the algorithm would recurse, and possibly select say u(1). As before, expand would not detect any inconsistency, and allow the algorithm to recurse again. Suppose now choose literal were to pick not p. Following the same steps outlined earlier, the algorithm would derive inconsistency. Upon backtracking, the algorithm would also derive inconsistency from the selection of p. However, the finding would only affect the current branch of the search stemming from the selection of u(1), and the algorithm would then backtrack, select not u(1), and recurse. At this point, the algorithm would be again free to select any of the remaining u(X) literals, which from an intuitive point of view means going in the wrong direction. Even if the algorithm were to select not p right away, it would still have to backtrack over the choice of u(0) and explore the corresponding branch of the search tree that starts from not u(0) before finally concluding that the program is inconsistent. The reader can imagine the effect\non the algorithm’s performance if choose literal were to choose not p at an even later point in the search process.\nIn order to reduce the chances of choose literal making “wrong” selections, modern solvers base literal selection on carefully designed heuristics. For example, in SMODELS the selection is roughly based on maximizing the number of consequences that can be derived after selecting the given extended literal [9]. These techniques work well in a number of cases, but not always. In fact, particular features of the program can confuse the heuristics. When that happens at an early stage of the search process, the effect is often disastrous, causing the solver to fail to return an answer in an acceptable amount of time. Particularly frustrating is the fact that the efficiency of the heuristics may change largely in correspondence of small elaborations of the program in input. For example, the choose literal heuristics may make good selections for one problem instance, while they may cause the search to take an unacceptable amount of time for a not-too-different problem instance.\nAs we mentioned in the introduction, one way to limit the effect of wrong selections by choose literal is that of allowing the solver to learn about relevant conflicts at runtime. Once learned, the information about conflicts can be used for the early pruning of other branches of the search space (e.g. [5,4]). Although this technique has proven to be extremely effective, it does not address directly the issue of choose literal making wrong choices, but rather curbs the problem by making some of those choices impossible after learning has taken place, or by allowing to quickly backtrack after a wrong choice has been made. Furthermore, because the learning occurs at run-time, during the initial phase of the computation in which learning has not yet occurred, choose literal may once again affect efficiency negatively by taking the search process in the wrong direction. Finally, whatever has been learned in one execution of the algorithm is discarded upon termination, and cannot be used in later runs.\nIn the next section, we describe a different approach, aimed at improving directly the selections made by choose literal and at retaining what the algorithm has learned."
    }, {
      "heading" : "4 The DORS Framework",
      "text" : "Our technique for learning domain-specific heuristics and using them for literal selection applies to the situation in which one is interested in solving a number of problem instances from a given problem domain. Such situations are very common in the ASP community – see e.g. the Second Answer Set Programming Competition [11]. Moreover, this is particularly the case in industrial applications, where the application contains the domain description, and the user describes the instance using some interface (refer e.g. to [12]), which then automatically encodes the problem instance.\nProgram P1, shown earlier, can be viewed as consisting of a domain description and a problem instance: the first 7 rules constitute the former, while the definition of predicate t is the problem instance. A different problem instance might then define t as {t(5), t(6), t(7)}. In this case, it is obvious that a good strategy for the selection of the literals consists in first choosing among {p, not p, q, not q} and only later (if necessary) considering the extended literals formed by u and v.\nIn general, the domain-specific heuristics for choose literal will be learned – rather than manually specified – by analyzing the choices made by the standard solver solve when solving representative problem instances from the domain. This approach is particularly useful in applications in which a number of problem instances from the same class of problems will have to be solved over time – for example, in the setting of an industrial application, or in a programming/solver competition in which benchmarking is involved – and computational power is available off-line to allow learning the domain-specific heuristics (e.g. before deploying the application, or before submitting the solver or solutions to a competition).\nNext, we discuss how choices made in previous runs of the algorithm can be extracted and combined for future use. The final result will be the learning of a policy (see e.g. [13] for a comprehensive introduction on the topic), that is, in general terms, of a mapping from states to probabilities of selecting each available action. To achieve this, the algorithm from Figure 1 is modified to maintain a record of the choice points selected, and to return the list of such choice points together with the answer set, when one is found. The modified algorithm is shown in Figure 2. In the algorithm, the list of\nchoice points is stored in variable S. Symbol ◦ represents concatenation. When solvecp is initially invoked, S is the empty list.\nNow we turn our attention to combining the information collected by solvecp into a domain-specific heuristics. Given the domain description M and a problem instance I that is to be used to learn the domain-specific heuristics, the decision-sequence of I (denoted by d(I)) is ⊥ if solvecp(I∪M, ∅, ∅) = ⊥ and S if solvecp(I∪M, ∅, ∅) = 〈A,S〉 for some A. From now on, given a decision-sequence d, we denote its nth element by dn. Moreover, given an extended literal e, level(e, d) denotes the index i such that di = e (e is guaranteed not to occur at more than one position by construction of the decision-sequence in solvecp). Intuitively, level(e, d) represents the level in the decision tree at which e was selected. Notice that, by construction of the sequence of choice points in solvecp, if d(I) 6= ⊥, then d(I) only enumerates the choice points that led directly to the answer sets. All the choice points that did not lead directly to it, in the sense that they were later backtracked upon, are in fact discarded every time the algorithm backtracks.\nIn order to improve the quality of the learned heuristics, we divide the class of problem instances in subclasses, and associate with each problem instance I an expression\nσ denoting the subclass it belongs to. The intuition is that using subclasses allows to further tailor the literal selection heuristics to the particular features of the problem instances. For example, in a planning domain, σ might be the maximum length of the plan (often called lasttime or maxtime in ASP-based planning). The subclass of a problem instance I is denoted by σ(I).\nLet I denote the set of all problem instances that will be used for the learning of the domain-specific heuristics. Next, we specify a way to determine how many times an extended literal e was selected at a certain level of the decision-sequences for the problem instances in I. More precisely, given a positive integer δ, called the scaling factor, and subclass σ, the occurrence count of an extended literal e w.r.t. a level l and set of instances I is\noδ,σ(e, l, I) = | { I | I ∈ I ∧ σ(I) = σ ∧ d(I) 6= ⊥ ∧ l − δ/2 ≤ index(e, d(I)) < l + δ/2 } |.\nThe scaling factor δ allows taking into account all the occurrences of e at a level in the interval [l − δ/2, l + δ/2). If δ = 1, then only the occurrences of e with level equal to l are considered. Values of δ greater than 1 can be useful in those cases in which all or most permutations of a subsequence of choice points lead to an answer set.\nLet now E = {e1, e2, . . . , ek} be a set of extended literals, representing possible choice points at some level l of the decision tree. The set of best choice points among E is:\nbestδ(l, E, σ, I) = {e | e ∈ E ∧ ∀e ′ ∈ E oδ,σ(e, l, I) ≥ oδ,σ(e ′, l, I)}.\nIntuitively, bestδ(l, E, σ, I) returns the choice points that, if taken at level l, are most likely to lead to an answer set without backtracking, based on the information collected about the instances of subclass σ in I. Algorithms for the computation of bestδ(l, E, σ, I) and oδ,σ(e, l, I) are simple and are omitted to save space.\nFunction bestδ(l, E, σ, I) encodes the essence of the domain-specific heuristics, or, more precisely, the policy1 for the selection of choice points. Algorithm choose literal can now be extended to perform literal selection guided by the domain-specific heuristics. The modified algorithm, choose literal dspec, is shown in Figure 3. In choose literal dspec, argument T is the set of extended literals that have previously been selected by choose literal dspec. If bestδ(level, E′, σ(I), I) is the empty set, then choose literal dspec falls back to performing standard extended literal selection via choose literal. This is for instances in which the learned heuristics do not prescribe any extended literal for the current decision level, or in which all the extended literals that the learned heuristics prescribed have already been tried. Modifying the standard solver’s algorithm in order to use the domain-specific heuristics for choice-point selection is rather straightforward. A simple version, which for the most part follows the well-known iterative version of the SMODELS algorithm, is shown in Figure 4.\nNext, we describe how grounding is handled in the DORS framework. The discussion is based on the architecture of the LPARSE+SMODELS system but can be extended to other ASP systems as well. ASP solvers typically expect in input ground\n1 We assume uniform probability of selection among the elements of the set returned by bestδ(l, E, σ, I).\n(i.e. variable-free) programs. Because however using variables in ASP programs is convenient, programs are first pre-processed by a grounder (LPARSE and GRINGO in the systems considered here), which replaces each non-ground rule by the set of its ground instances. The main difficulty in implementing our technique in state-of-the-art ASP systems is that their grounders often introduce “unnamed atoms” during the grounding process. An unnamed atom is an atom that does not occur in the original program, and is used internally by the ASP system. Because of their local use, unnamed atoms are assigned identifiers that are only valid for the current run of the system. There is no guarantee that unnamed atoms will be assigned the same identifiers when the system is run on a different problem instance. Because nothing prevents unnamed atoms from being used as choice points by the solver, one needs to ensure that unnamed atoms are given a unique, known identifier, so that choice-point information regarding them can be properly handled. One possible solution is to modify the ASP grounders so that unnamed atoms are given identifiers that remain valid across multiple executions. Although conceptually simple, this solution requires modifying each grounder that one is interested in using. In this paper we present instead a relatively simple, indirect method that consists of a pre-processing phase and a post-processing phase, and does not involve modifications to the grounders.\nIn LPARSE and GRINGO, unnamed atoms are introduced during the grounding of rules containing certain constraint literals, in order to simplify their structure.2 For example, the choice rule in the program:\n{\np(1). p(2). p(3). 1{a(X) : p(X)}2.\nis translated by the grounder as: \n \n  {a(1), a(2), a(3)}. ← µ1. µ1 ← 3{not a(1), not a(2), not a(3)}. ← µ0. µ0 ← 3{a(3), a(2), a(1)}.\n2 A thorough explanation of the process is beyond the scope of this paper. We refer the interested reader to e.g. [8].\nwhere µ0 and µ1 are unnamed atoms. As we mentioned above, no assumptions can be made about which identifiers are used for the unnamed atoms. If we were for example to add to the program a second choice rule3, the grounding of the new program could use some new identifiers µ2, µ3 for the above translation. On the other hand, because of the structure of the grounding algorithm, the relative order of the rules belonging to the grounding of the choice rule is independent from the changes made to the rest of the program. Moreover, whenever multiple unnamed atoms occur in the body of a rule, their relative order is independent of changes made to the rest of the program. We will make use of these two properties later.\nIn the pre-processing phase, the user specifies a name for each rule whose grounding may cause the introduction of unnamed atoms. Because we want to avoid modifications to the grounder, we cannot extend the syntax of rules to allow specifying a name explicitly.4 Therefore, the name of the rule is rather specified in the body of the rule, using a\n3 Or if the number of ground instances of the choice rule of our example were to change because of changes in the problem instance. 4 However, a pre-processor can be used, as discussed later.\nspecial relation ν.5 So, the choice rule above can be written as:\n1{a(X) : p(X)}2 ← ν(r1). (1)\nGenerally speaking, given a list, X , of all the free variables in the rule, and some fresh constant ρ, the name is specified by the atom ν(ρ,X). A rule whose name is specified as above is called an augmented rule.\nTo ensure that the meaning of a rule is not altered by the augmentation, a definition of atom ν(·) must also be provided (otherwise the body of the augmented rule is never satisfied). Because state-of-the-art grounders usually drop trivially-true atoms from the body of the rules, we define the new atom by a choice rule with no bounds and suitable domain predicates for the arguments of relation ν, such as { ν(r1) }. (The choice rule will be removed later, to avoid affecting the performance of the solver.) When processing (1), the grounder produces:\n\n \n  {a(1), a(2), a(3)} ← ν(r1). ← µ1, ν(r1). µ1 ← 3{not a(1), not a(2), not a(3)}. ← µ0, ν(r1). µ0 ← 3{a(3), a(2), a(1)}.\nNotice how the unnamed atoms co-occur with the ν(·) atom in the body of some of the rules. Because of the structure of the grounding algorithm, this is the case for the grounding of any rule that introduces unnamed atoms. The reader should also notice that the addition of ν(·) atoms to the program can be easily automated. A user could then specify a name for the rule using a more convenient syntax, and have a simple pre-processor introduce the ν(·) atoms in the program as shown above.\nThe post-processing phase is based on the algorithm shown in Figure 5. The al-\ngorithm works as follows. First, the ground rules are scanned for co-occurrences of\n5 Notice that the specification of the name of the rule in the body is purely a technical device, and should not be intended to convey any semantic information.\nunnamed atoms and ν atoms. The goal is to use the information provided by the ν atoms to give a name to the unnamed atoms they co-occur with. The association of names to unnamed atoms is stored in variable Assoc. Because multiple unnamed atoms may be introduced by the grounding of a single rule, an extra integer argument is added to relation ν when naming unnamed atoms. Values for that argument are assigned on a first-come, first-serve basis. Because, as we noted above, the relative order of unnamed atoms in the ground rules does not change, we are guaranteed that the naming of unnamed atoms will be consistent throughout multiple runs of the grounder with different input programs (as long as the domain description remains the same). In the next for loop, all ν atoms and their definitions are removed from the program. Finally, the unnamed atoms are renamed according to the associations encoded by variable Assoc."
    }, {
      "heading" : "5 Experimental Evaluation",
      "text" : "In this section we discuss an experimental evaluation of the DORS framework. To ensure applicability to a wider variety of cases, we have tested our implementation on both abstract problems and on problems from industrial applications of ASP. Here we show the results of testing on the 15 puzzle problem and on the task of planning for the Reaction Control System of the Space Shuttle.\nThe solver used in the experiments is SMODELS, which we modified to obtain implementations of algorithms solvecp and solve dspec. It should be noted that we did not use CLASP for our experiments. In fact, extending the DORS framework to CLASP is complicated by the fact that this solver is based on conflict-driven clause learning (CDCL) (e.g. [5]) rather than DPLL. Although we believe that certain similarities between DPLL and CDCL make it technically possible to extend the DORS framework to CDCL-based systems, work on implementing the DORS framework within CLASP is still in the early stages and results will be discussed in a later paper.\nIn the rest of the discussion, we refer to the implementation of solve dspec within SMODELS as DSPEC. The grounders used were GRINGO for the 15 puzzle (because the original solution of the puzzle used some features specific of GRINGO’s language) and LPARSE for the Reaction Control System. It is important to note that this interchangeable use of grounders is only possible because of the grounding technique we described in the previous section.\nThe 15 puzzle problem was one of the benchmarks used for the Second ASP Programming Competition [11]. The description of the puzzle, taken from the competition’s web site, is shown in Figure 6a. The goal configuration used in the competition is shown in Figure 6b. For the domain description, we have used the program published on the competition’s web site 6, modified to provide names of select rules, as explained earlier. Next, for every value of k ranging between 10 and 30, we have generated 100 random problem instances that can be solved with k moves or less. The subclass that a problem instance belongs to is identified by the value of k (i.e. the maximum allowed length of a plan for that instance, called maxtime in the original encoding). Next, we ran all the instances in each subclass with a timeout value of 6000 sec. The instances\n6 The collection is available from http://www.cs.kuleuven.be/∼dtai/events/ ASP-competition/problem instances.tar.gz.\nthat took more than a time threshold tk were then used to learn the domain-specific heuristics, while the remaining instances – called hard instances – were used for the evaluation phase. In the evaluation phase, we have run the hard instances using the learned domain-specific heuristics. The scaling factor δ (discussed earlier) was set to 1. Figure 7 compares the performance of SMODELS and DSPEC for the subclass with maxtime = 28, where we set the threshold tk to 70 seconds (selected to have a sufficient number of samples for learning). The domain-specific heuristics gave an average speedup of 6.4 times7 over the standard solver, with a maximum speedup of more than 24. What’s more important, out of 11 instances for which the standard solver timed out, all were solved within the time limit by DSPEC, substantiating our claim that the use of domain-specific heuristics helps to make solver’s performance more consistent. (Similar performance was obtained on other subclasses. We omit the results to save space.)\n7 This is just the lower bound of the estimate, since SMODELS timed out several times.\nThe second problem domain for which we report experimental results is that of planning for the Reaction Control System (RCS) of the Space Shuttle. As described in e.g. [14,12], the RCS is the Shuttle’s system that has primary responsibility for maneuvering the Shuttle while it is in space. It consists of fuel and oxidizer tanks, valves, and other plumbing needed to provide propellant to the maneuvering jets of the Shuttle. The RCS also includes electronic circuitry, both to control the valves in the fuel lines and to prepare the jets to receive firing commands. In order to configure the Shuttle for an orbital maneuver, the RCS must be configured by opening and closing appropriate valves. This is accomplished by either changing the position of the associated switches, or by issuing computer commands. In normal conditions, the procedures for the configuration of the RCS for a given maneuver are known in advance by the astronauts. However, if components of the RCS are faulty, then the standard procedures may not be applicable. Moreover, because of the amount of possible combinations of faults, it is impossible to prepare in advance a set of configuration procedures for faulty situations. In those cases, ground control needs to carefully examine the problem and manually come up with a configuration procedure. The system described in [14,12] uses a model of the RCS, as well as ASP-based reasoning algorithms, to provide ground control with a decision-support system that automatically generates configuration procedures for the RCS and that can be used when faulty components are present (incidentally, the system can also perform diagnostic reasoning [12]).\nA collection of problem instances from the domain of the RCS is publicly available, together with the ASP encoding of the model of the RCS.8 The interested reader may refer to [14] for a description of the instances. For our testing, we have selected a set of 425 instances from the collection, corresponding to the public instances with no electrical faults and 3, 8, and 10 mechanical faults respectively, for which a plan of length 6 or less (determined by parameter lasttime) was found in the experiments discussed in [14,12], and we have analyzed the performance of the solver on planning with maximum lengths ranging between 6 and 10.\nAs before, first we ran all the instances with the standard solver and a timeout of 6000 sec. Of those, the instances that took less than 50 sec were used to learn the domain-specific heuristics, while the remaining “hard instances” were used for the evaluation phase. The problem subclasses were defined by the pair 〈lasttime,maneuver〉, where lasttime specifies the maximum plan length and maneuver is the maneuver that the RCS must be configured for (in our experiments, using the maneuver in the subclass definition substantially improved the performance of the learned heuristics). Figure 8 shows the results of the comparison for the 91 hard instances with 8 and 10 mechanical faults and values of lasttime of 9 and 10. We believe the speedup obtained with the domain-specific heuristics is remarkable. First of all, out of 53 instances for which the standard solver timed out before finding a solution, in 48 cases the domainspecific heuristics allowed to find a solution within the time limit, and in some cases in under 10 seconds. The average speedup is 259.2, with a peak of 1253.1 for an in-\n8 The files are available from http://www.krlab.cs.ttu.edu/Software/Download/.\nstance for which SMODELS timed out9, and a peak of 544.5 for an instance for which SMODELS did not time out. In 6 cases (out of 91) DSPEC performed worse than the standard solver. We believe that these outliers can be eliminated if more samples are made available for learning."
    }, {
      "heading" : "6 Conclusions",
      "text" : "In this paper we have described a framework that allows learning and using domainspecific heuristics for choice-point selection, and we have demonstrated its application\n9 The actual speedup could in fact be higher, since SMODELS timed out. As a test, we have let SMODELS run on some of these instances for over 60, 000 seconds (16 hours) without getting a solution.\nto ASP. Our experimental evaluation has shown that domain-specific heuristics can give remarkable speedups, and allow to find answers that cannot otherwise be computed in a reasonable amount of time. In the case of the RCS domain, a large number of the instances for which the standard solver timed out, could be solver in a matter of seconds using the domain-specific heuristics, with an average speedup of more than 2 orders of magnitude and peaks of more than 3. This is the type of consistent performance that makes a solver viable for industrial applications. We believe that an appealing feature of the DORS framework is that in principle it can be applied to any solver based on the DPLL procedure. Hence, it is possible to extend the approach shown here to other ASP solvers, or even to e.g. constraint solvers. Work is also ongoing on extending the DORS framework to solvers based on conflict-driven clause learning, such as CLASP. As a final note, we would like to point out that the method used here to learn the domain-specific heuristics is a very simple instance of policy learning. It will be interesting to investigate how more sophisticated techniques from reinforcement learning, but also from machine learning and data mining, can be applied within the DORS framework. We expect that doing so will allow to improve performance of the solvers even further."
    } ],
    "references" : [ {
      "title" : "A Computing Procedure for Quantification Theory",
      "author" : [ "M. Davis", "H. Putnam" ],
      "venue" : "Communications of the ACM 7",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1960
    }, {
      "title" : "A Machine program for theorem proving",
      "author" : [ "M. Davis", "G. Logemann", "D. Loveland" ],
      "venue" : "Communications of the ACM 5(7)",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1962
    }, {
      "title" : "The Conflict-Driven Answer Set Solver clasp: Progress Report",
      "author" : [ "M. Gebser", "B. Kaufmann", "T. Schaub" ],
      "venue" : "10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR09).",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Conflict-driven answer set solving",
      "author" : [ "M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub" ],
      "venue" : "In Veloso, M.M., ed.: Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI’07), MIT Press",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "BerkMin: A Fast and Robust Sat-Solver",
      "author" : [ "E. Goldberg", "Y. Novikov" ],
      "venue" : "Proceedings of Design, Automation and Test in Europe Conference (DATE-2002).",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V.W. Marek", "M. Truszczynski" ],
      "venue" : "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, Berlin",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Extending the Smodels System with Cardinality and Weight Constraints",
      "author" : [ "I. Niemela", "P. Simons" ],
      "venue" : "Logic-Based Artificial Intelligence. Kluwer Academic Publishers",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "I. Niemela", "P. Simons", "T. Soininen" ],
      "venue" : "Artificial Intelligence 138(1–2)",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "The DLV System for Knowledge Representation and Reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic 7(3)",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "The Second Answer Set Programming Competition",
      "author" : [ "M. Denecker", "J. Vennekens", "S. Bond", "M. Gebser", "M. Truszczynski" ],
      "venue" : "10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR09).",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Answer Set Based Design of Knowledge Systems",
      "author" : [ "M. Balduccini", "M. Gelfond", "M. Nogueira" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Reinforcement learning: an introduction",
      "author" : [ "A.G. Barto", "R.S. Sutton" ],
      "venue" : "MIT Press",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Building Knowledge Systems in A-Prolog",
      "author" : [ "M. Nogueira" ],
      "venue" : "PhD thesis, University of Texas at El Paso",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "In recent years, solvers based on the DPLL procedure [1,2] have become amazingly fast.",
      "startOffset" : 53,
      "endOffset" : 58
    }, {
      "referenceID" : 1,
      "context" : "In recent years, solvers based on the DPLL procedure [1,2] have become amazingly fast.",
      "startOffset" : 53,
      "endOffset" : 58
    }, {
      "referenceID" : 2,
      "context" : "An interesting step in that direction is provided by CLASPFOLIO [3], which makes",
      "startOffset" : 64,
      "endOffset" : 67
    }, {
      "referenceID" : 3,
      "context" : "use of different configurations of the CLASP solver [4].",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 4,
      "context" : "[5,4]), and have brought about substantial performance improvements.",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 3,
      "context" : "[5,4]), and have brought about substantial performance improvements.",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 5,
      "context" : "Although here we focus on solvers for Answer Set Programming (ASP) [6,7], the DORS framework can be applied to any solver based on the DPLL procedure, including SAT and constraint solvers.",
      "startOffset" : 67,
      "endOffset" : 72
    }, {
      "referenceID" : 6,
      "context" : "Although here we focus on solvers for Answer Set Programming (ASP) [6,7], the DORS framework can be applied to any solver based on the DPLL procedure, including SAT and constraint solvers.",
      "startOffset" : 67,
      "endOffset" : 72
    }, {
      "referenceID" : 5,
      "context" : "We refer the reader to [6,8] for a specification of the formal semantics.",
      "startOffset" : 23,
      "endOffset" : 28
    }, {
      "referenceID" : 7,
      "context" : "We refer the reader to [6,8] for a specification of the formal semantics.",
      "startOffset" : 23,
      "endOffset" : 28
    }, {
      "referenceID" : 7,
      "context" : "Because a convenient representation of alternatives is often important in the formalization of knowledge, the language of ASP has been extended with constraint literals [8], which are expressions of the form m{l1, l2, .",
      "startOffset" : 169,
      "endOffset" : 172
    }, {
      "referenceID" : 8,
      "context" : "SMODELS [9], DLV [10]) is based on the DPLL procedure [1,2].",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 9,
      "context" : "SMODELS [9], DLV [10]) is based on the DPLL procedure [1,2].",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 0,
      "context" : "SMODELS [9], DLV [10]) is based on the DPLL procedure [1,2].",
      "startOffset" : 54,
      "endOffset" : 59
    }, {
      "referenceID" : 1,
      "context" : "SMODELS [9], DLV [10]) is based on the DPLL procedure [1,2].",
      "startOffset" : 54,
      "endOffset" : 59
    }, {
      "referenceID" : 8,
      "context" : "Function expand [9] is then used to add to the partial answer set all the literals that must hold given Π and A.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 8,
      "context" : "For example, in SMODELS the selection is roughly based on maximizing the number of consequences that can be derived after selecting the given extended literal [9].",
      "startOffset" : 159,
      "endOffset" : 162
    }, {
      "referenceID" : 4,
      "context" : "[5,4]).",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 3,
      "context" : "[5,4]).",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 10,
      "context" : "the Second Answer Set Programming Competition [11].",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 11,
      "context" : "to [12]), which then automatically encodes the problem instance.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 12,
      "context" : "[13] for a comprehensive introduction on the topic), that is, in general terms, of a mapping from states to probabilities of selecting each available action.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "[8].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5]) rather than DPLL.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 10,
      "context" : "The 15 puzzle problem was one of the benchmarks used for the Second ASP Programming Competition [11].",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 13,
      "context" : "[14,12], the RCS is the Shuttle’s system that has primary responsibility for maneuvering the Shuttle while it is in space.",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 11,
      "context" : "[14,12], the RCS is the Shuttle’s system that has primary responsibility for maneuvering the Shuttle while it is in space.",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 13,
      "context" : "The system described in [14,12] uses a model of the RCS, as well as ASP-based reasoning algorithms, to provide ground control with a decision-support system that automatically generates configuration procedures for the RCS and that can be used when faulty components are present (incidentally, the system can also perform diagnostic reasoning [12]).",
      "startOffset" : 24,
      "endOffset" : 31
    }, {
      "referenceID" : 11,
      "context" : "The system described in [14,12] uses a model of the RCS, as well as ASP-based reasoning algorithms, to provide ground control with a decision-support system that automatically generates configuration procedures for the RCS and that can be used when faulty components are present (incidentally, the system can also perform diagnostic reasoning [12]).",
      "startOffset" : 24,
      "endOffset" : 31
    }, {
      "referenceID" : 11,
      "context" : "The system described in [14,12] uses a model of the RCS, as well as ASP-based reasoning algorithms, to provide ground control with a decision-support system that automatically generates configuration procedures for the RCS and that can be used when faulty components are present (incidentally, the system can also perform diagnostic reasoning [12]).",
      "startOffset" : 343,
      "endOffset" : 347
    }, {
      "referenceID" : 13,
      "context" : "8 The interested reader may refer to [14] for a description of the instances.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 13,
      "context" : "For our testing, we have selected a set of 425 instances from the collection, corresponding to the public instances with no electrical faults and 3, 8, and 10 mechanical faults respectively, for which a plan of length 6 or less (determined by parameter lasttime) was found in the experiments discussed in [14,12], and we have analyzed the performance of the solver on planning with maximum lengths ranging between 6 and 10.",
      "startOffset" : 305,
      "endOffset" : 312
    }, {
      "referenceID" : 11,
      "context" : "For our testing, we have selected a set of 425 instances from the collection, corresponding to the public instances with no electrical faults and 3, 8, and 10 mechanical faults respectively, for which a plan of length 6 or less (determined by parameter lasttime) was found in the experiments discussed in [14,12], and we have analyzed the performance of the solver on planning with maximum lengths ranging between 6 and 10.",
      "startOffset" : 305,
      "endOffset" : 312
    } ],
    "year" : 2013,
    "abstractText" : "In spite of the recent improvements in the performance of the solvers based on the DPLL procedure, it is still possible for the search algorithm to focus on the wrong areas of the search space, preventing the solver from returning a solution in an acceptable amount of time. This prospect is a real concern e.g. in an industrial setting, where users typically expect consistent performance. To overcome this problem, we propose a framework that allows learning and using domain-specific heuristics in solvers based on the DPLL procedure. The learning is done off-line, on representative instances from the target domain, and the learned heuristics are then used for choice-point selection. In this paper we focus on Answer Set Programming (ASP) solvers. In our experiments, the introduction of domain-specific heuristics improved performance on hard instances by up to 3 orders of magnitude (and 2 on average), nearly completely eliminating the cases in which the solver had to be terminated because the wait for an answer had become unacceptable.",
    "creator" : "LaTeX with hyperref package"
  }
}