{
  "name" : "1401.3450.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Completeness and Performance of the APO Algorithm",
    "authors" : [ "Tal Grinshpoun", "Amnon Meisels" ],
    "emails" : [ "grinshpo@cs.bgu.ac.il", "am@cs.bgu.ac.il" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Algorithms that solve Distributed Constraint Satisfaction Problems (DisCSPs) attempt to achieve concurrency during problem solving in order to utilize the distributed nature of these problems. Distributed backtracking, which forms the majority of DisCSP algorithms, can take many forms. Asynchronous Backtracking (ABT) (Yokoo, Durfee, Ishida, & Kuwabara, 1998; Yokoo & Hirayama, 2000), Asynchronous Forward-Checking (AFC) (Meisels & Zivan, 2007), and Concurrent Dynamic Backtracking (ConcDB) (Zivan & Meisels, 2006a) are representative examples of the family of distributed backtracking algorithms. All of these algorithms maintain one or more partial solutions of the DisCSP and attempt to extend the partial solution into a complete one. The ABT algorithm attempts to achieve concurrency by asynchronously assigning values to the variables. The AFC algorithm performs value assignments synchronously, but achieves its concurrency by performing asynchronous computation in the form of forward checking. The ConcDB algorithm concurrently attempts to extend multiple partial solutions, scanning different parts of the search space.\nA completely different approach to achieve concurrency can be by the merging of partial solutions into a complete one. The inherent concurrency of merging partial solutions makes it a fascinating paradigm for solving DisCSPs. However, such an approach is prone to many errors – deadlocks could prevent termination, and failures could occur in the attempt to merge all of the partial solutions. Consequently, it is hard to develop such an algorithm\nc©2008 AI Access Foundation. All rights reserved.\nthat is both correct and well performing. A recently published algorithm, Asynchronous Partial Overlay (APO) (Mailler, 2004; Mailler & Lesser, 2006), attempts to solve DisCSPs by merging partial solutions. It uses the concept of mediation to centralize the search procedure in different parts of the DisCSP. Due to its unique approach, several researchers have already proposed changes and modifications to the APO algorithm (Benisch & Sadeh, 2006; Semnani & Zamanifar, 2007). Unfortunately, none of these studies has examined the completeness of APO. Additionally, the distinctive behavior of the APO algorithm calls for a thorough experimental evaluation. The present paper presents an in-depth investigation of the completeness and termination of the APO algorithm, constructs a correct version of the algorithm – CompAPO – and goes on to present extensive experimental evaluation of the complete APO algorithm.\nThe APO algorithm partitions the agents into groups that attempt to find consistent partial solutions. The partition mechanism is dynamic during search and enables a dynamic change of groups. The key factor in the termination (and consequently the completeness) of the APO algorithm as presented in the original correctness proof (Mailler & Lesser, 2006) is the monotonic growth of initially partitioned groups during search. This growth arises because the subproblems overlap, allowing agents to increase the size of the subproblems they solve. We have discovered that this expected growth of groups does not occur in some situations, leading to a termination problem of the APO algorithm. Nevertheless, the unique way in which APO attempts to solve DisCSPs has encouraged us to try and fix it.\nThe termination problem of the APO algorithm is shown in section 4 by constructing a scenario that leads to an infinite loop of the algorithm’s run (Grinshpoun, Zazon, Binshtok, & Meisels, 2007). Such a running example is essential to the understanding of APO’s completeness problem, since the algorithm is very complex. To help understand the problem, a full pseudo-code of APO that follows closely the original presentation of the algorithm (Mailler & Lesser, 2006) is given. The erroneous part in the proof of APO’s completeness as presented by Mailler and Lesser (2006) is shown and the problematic parts in the algorithm that interfere with its completeness are identified. Necessary modifications to the algorithm are proposed, in order to fix these problematic parts. The resulting version of the algorithm ensures its completeness, and is termed Complete Asynchronous Partial Overlay (CompAPO) (Grinshpoun & Meisels, 2007). Formal proofs for the soundness and completeness of CompAPO are presented.\nThe modifications of CompAPO may potentially affect the performance of the algorithm. Also, in the evaluation of the original APO algorithm (Mailler & Lesser, 2006), it was compared to the AWC algorithm (Yokoo, 1995), which is not an efficient DisCSP solver (Zivan, Zazone, & Meisels, 2007). Moreover, the tests in the work of Mailler and Lesser (2006) were only performed on relatively sparse problems, and the comparison with AWC was made by the use of some problematic measures. An extensive experimental evaluation of CompAPO compares its performance with other DisCSP search algorithms on randomly generated DisCSPs. Our experiments show that CompAPO performs significantly different than other DisCSP algorithms, which is not surprising considering its singular way of problem solving.\nAsynchronous Partial Overlay is actually a family of algorithms. The completeness and termination problems that are presented and corrected in the present study apply to all the members of the family. The OptAPO algorithm (Mailler & Lesser, 2004; Mailler, 2004) is\nan optimization version of APO that solves Distributed Constraint Optimization Problems (DisCOPs). The present paper proposes similar modifications to those of APO in order to achieve completeness for OptAPO. The resulting CompOptAPO algorithm is evaluated extensively on randomly generated DisCOPs.\nThe plan of the paper is as follows. DisCSPs are presented briefly in section 2. Section 3, gives a short description of the APO algorithm along with its pseudo-code. An infinite loop scenario for APO is described in detail in section 4 and the problems that lead to the infinite looping are analyzed in section 5. Section 6 presents a detailed solution to the problem that forms the CompAPO version of the algorithm, followed by proofs for the soundness and completeness of CompAPO (section 7). An optimization version of the algorithm, CompOptAPO, is presented and discussed in section 8. An extensive performance evaluation of CompAPO and CompOptAPO is in section 9. Our conclusions are summarized in section 10."
    }, {
      "heading" : "2. Distributed Constraint Satisfaction",
      "text" : "A distributed constraints satisfaction problem – DisCSP, is composed of a set of k agents A1, A2, ..., Ak. Each agent Ai contains a set of constrained variables xi1 , xi2 , ..., xini . Constraints or relations R are subsets of the Cartesian product of the domains of the constrained variables. For a set of constrained variables xik , xjl , ..., xmn , with domains of values for each variable Dik , Djl , ..., Dmn , the constraint is defined as R ⊆ Dik × Djl × ... × Dmn . A binary constraint Rij between any two variables xj and xi is a subset of the Cartesian product of their domains – Rij ⊆ Dj ×Di. In a distributed constraint satisfaction problem (DisCSP), the agents are connected by constraints between variables that belong to different agents (Yokoo et al., 1998). In addition, each agent has a set of constrained variables, i.e. a local constraint network.\nAn assignment (or a label) is a pair < var, val >, where var is a variable of some agent and val is a value from var ‘s domain that is assigned to it. A compound label is a set of assignments of values to a set of variables. A solution s to a DisCSP is a compound label that includes all variables of all agents, which satisfies all the constraints. Agents check assignments of values against non-local constraints by communicating with other agents through sending and receiving messages.\nCurrent studies of DisCSPs follow the assumption that all agents hold exactly one variable (Yokoo & Hirayama, 2000; Bessiere, Maestre, Brito, & Meseguer, 2005). Accordingly, the present study often uses the variable’s name xi to represent the agent it belongs to (Ai). In addition, the following common assumptions are used in the present study:\n• The amount of time that passes between the sending and the receiving of a message is finite. • Messages sent by agent Ai to agent Aj are received by Aj in the order they were sent."
    }, {
      "heading" : "3. Asynchronous Partial Overlay",
      "text" : "Asynchronous Partial Overlay (APO) is an algorithm for solving DisCSPs that applies cooperative mediation. The pseudo-code in Algorithms 1, 2, and 3 follows closely the presentation of APO in the work of Mailler and Lesser (2006).\nAlgorithm 1 APO procedures for initialization and local resolution.\nprocedure initialize 1: di ← random d ∈ Di; 2: pi ← sizeof(neighbors) + 1; 3: mi ← true; 4: mediate ← false; 5: add xi to the good list ; 6: send (init, (xi, pi, di, mi, Di, Ci)) to neighbors; 7: init list ← neighbors;\nwhen received (init, (xj , pj , dj , mj , Dj , Cj)) do 1: add (xj , pj , dj , mj , Dj , Cj) to agent view ; 2: if xj is a neighbor of some xk ∈ good list do 3: add xj to the good list ; 4: add all xl ∈ agent view ∧ xl /∈ good list that can now be connected to the good list ; 5: pi ← sizeof(good list); 6: if xj /∈ init list do 7: send (init, (xi, pi, di, mi, Di, Ci)) to xj ; 8: else 9: remove xj from init list ; 10: check agent view;\nwhen received (ok?, (xj , pj , dj , mj)) do 1: update agent view with (xj , pj , dj , mj); 2: check agent view;\nprocedure check agent view 1: if init list 6= ∅ or mediate 6= false do 2: return; 3: m′i ← hasConflict(xi); 4: if m′i and ¬∃j(pj > pi ∧ mj == true) do 5: if ∃(d′i ∈ Di)(d ′ i∪agent view does not conflict) and di conflicts exclusively with lower\npriority neighbors do 6: di ← d ′ i; 7: send (ok?, (xi, pi, di, mi)) to all xj ∈ agent view; 8: else 9: mediate;\n10: else if mi 6= m ′ i do 11: mi ← m ′ i; 12: send (ok?, (xi, pi, di, mi)) to all xj ∈ agent view;\nAlgorithm 2 Procedures for mediating an APO session and for choosing a solution during an APO mediation. procedure mediate 1: preferences ← ∅; 2: counter ← 0; 3: for each xj ∈ good list do 4: send (evaluate?, (xi, pi)) to xj ; 5: counter ← counter + 1; 6: mediate ← true;\nwhen received (wait!, (xj , pj)) do 1: update agent view with (xj , pj); 2: counter ← counter − 1; 3: if counter == 0 do choose solution;\nwhen received (evaluate!, (xj , pj , labeled Dj)) do 1: record (xj , labeled Dj) in preferences; 2: update agent view with (xj , pj); 3: counter ← counter − 1; 4: if counter == 0 do choose solution;\nprocedure choose solution 1: select a solution s using a Branch and Bound search that: 2: 1. satisfies the constraints between agents in the good list 3: 2. minimizes the violations for agents outside of the session 4: if ¬∃s that satisfies the constraints do 5: broadcast no solution; 6: for each xj ∈ agent view do 7: if xj ∈ preferences do 8: if d′j ∈ s violates an xk and xk /∈ agent view do 9: send (init, (xi, pi, di, mi, Di, Ci)) to xk; 10: add xk to init list ; 11: send (accept!, (d′j , xi, pi, di, mi)) to xj ; 12: update agent view for xj ; 13: else 14: send (ok?, (xi, pi, di, mi)) to xj ; 15: mediate ← false; 16: check agent view;\nAlgorithm 3 Procedures for receiving an APO session.\nwhen received (evaluate?, (xj , pj)) do 1: mj ← true; 2: if mediate == true or ∃k(pk > pj ∧ mk == true) do 3: send (wait!, (xi, pi)) to xj ; 4: else 5: mediate ← true; 6: label each d ∈ Di with the names of the agents that would be violated by setting\ndi ← d; 7: send (evaluate!, (xi, pi, labeled Di)) to xj ;\nwhen received (accept!, (d, xj , pj , dj , mj)) do 1: di ← d; 2: mediate ← false; 3: send (ok?, (xi, pi, di, mi)) to all xj ∈ agent view; 4: update agent view with (xj , pj , dj , mj); 5: check agent view;\nAt the beginning of its problem solving, the APO algorithm performs an initialization phase, in which neighboring agents exchange data through init messages (procedure initialize in Algorithm 1). Following that, agents check their agent view to identify conflicts between themselves and their neighbors (procedure check agent view in Algorithm 1). If during this check, an agent finds a conflict with one of its neighbors, it expresses desire to act as a mediator. In case the agent does not have any neighbors that wish to mediate and have a wider view of the constraint graph than itself, the agent successfully assumes the role of mediator.\nUsing mediation (Algorithms 2, and 3), agents can solve subproblems of the DisCSP by conducting an internal Branch and Bound search (procedure choose solution in Algorithm 2). For a complete solution of the DisCSP, the solutions of the subproblems must be compatible. When solutions of overlapping subproblems have conflicts, the solving agents increase the size of the subproblems that they work on. The original paper (Mailler & Lesser, 2006) uses the term preferences to describe potential conflicts between solutions of overlapping subproblems. In the present paper we use the term external constraints to describe such conflicts. A detailed description of the APO algorithm can be found in the work of Mailler and Lesser (2006)."
    }, {
      "heading" : "4. An Infinite Loop Scenario",
      "text" : "Consider the 3-coloring problem presented in Figure 1 by the solid lines. Each agent can assign one of the three available colors Red, Green, or Blue. To the standard inequality constraints that the solid lines represent, four weaker constraints (diagonal dashed lines) are added. The dashed lines represent constraints that do not allow only the combinations (Green,Green) and (Blue,Blue) to be assigned by the agents. Ties in the priorities of agents are broken using an anti-lexicographic ordering of their names.\nThe initial selection of values by all agents is depicted in Figure 1. In the initial state, two constraints are violated – (A1, A2) and (A5, A6). Assume that agents A3, A4, A7, and A8 are the first to complete their initialization phase by exchanging init messages with all their neighbors (procedure initialize in Algorithm 1). These agents do not have conflicts, therefore they set mi←false and send ok? messages to their neighbors when each of them runs the check agent view procedure (Algorithm 1). Only after the arrival of the ok? messages from agents A3, A4, A7, and A8, do agents A1, A2, A5, and A6 accept the last init messages from their other neighbors and complete the initialization phase. Agents A2 and A6 have conflicts, but they complete the check agent view procedure without mediating or changing their state. This is true, because in the agent views of A2 and A6, m1 = true and m5 = true, respectively. These neighbors have higher priority than agents A2 and A6 respectively. We denote by configuration 1 the states of all the agents at this point of the processing and present the configuration in Table 1.\nAfter all agents complete their initializations, agents A1 and A5 detect that they have conflicts, and that they have no neighbor with a higher priority that wants to mediate. Consequently, agents A1 and A5 start mediation sessions, since they cannot change their own color to a consistent state with their neighbors.\nLet us first observe A1’s mediation session. A1 sends evaluate? messages to its neighbors A2, A3, A7, and A8 (procedure mediate in Algorithm 2). All these agents reply with evaluate! messages (Algorithm 3). A1 conducts a Branch and Bound search to find a solution that satisfies all the constraints between A1, A2, A3, A7, and A8, and also minimizes external constraints (procedure choose solution in Algorithm 2). In our example, A1 finds the solution (A1 ←Green, A2 ←Blue, A3 ←Red, A7 ←Blue, A8 ←Red), which satisfies the internal constraints, and minimizes to zero the external constraints. A1 sends accept! messages to its neighbors, informing them of its solution. A2, A3, A7, and A8 receive the accept! messages and send ok? messages with their new states to their neighbors (Algorithm 3). However, the ok? messages from A8 to A7 and from A3 to A4 and to A5 are delayed. Observe that the algorithm is asynchronous and naturally deals with such scenarios.\nConcurrently with the above mediation session of A1, agent A5 starts its own mediation session. A5 sends evaluate? messages to its neighbors A3, A4, A6, and A7. Let us assume that the message to A7 is delayed. A4 and A6 receive the evaluate? messages and reply with evaluate!, since they do not know any agents of higher priority than A5 that want to mediate. A3, is in A1’s mediation session, so it replies with wait!. We denote by configuration 2 the states of all the agents at this point of the processing (see Table 2).\nOnly after A1’s mediation session is over, A7 receives the delayed evaluate? message from A5. Since A7 is no longer in a mediation session, nor does it expect a mediation session from a node of higher priority than A5 (see A7’s view in Table 2), agent A7 replies with evaluate!. Notice that A7’s view of d8 is obsolete (the ok? message from A8 to A7 is still delayed). When agent A5 receives the evaluate! message from A7, it can continue the mediation session involving agents A4, A5, A6, and A7. Since the ok? messages from A3 to A4 and A5 are also delayed, agent A5 starts its mediation session with knowledge about agents A3 and A8 that is not updated (see bold-faced data in Table 2).\nAgent A5 conducts a Branch and Bound search to find a solution that satisfies all the constraints between A4, A5, A6, and A7, that also minimizes external constraints. In our example, A5 finds the solution (A4 ←Red, A5 ←Green, A6 ←Blue, A7 ←Red), which satisfies the internal constraints, and minimizes to zero the external constraints (remember that A5 has wrong data about the assignments of A3 and A8). A5 sends accept! messages to A4, A6, and A7, informing them of its solution. The agents receive these messages and send ok? messages with their new states to their neighbors. By now, all the delayed\nmessages get to their destinations, and two constraints are violated – (A3,A4) and (A7,A8). Consequently, agents A3, A4, A7, and A8 want to mediate, whereas agents A1, A2, A5, and A6 do not wish to mediate, since they do not have any conflicts. We denote by configuration 3 the states of all the agents after A5’s solution has been assigned and all delayed messages arrived at their destinations (see Figure 2 and Table 3).\nUntil now, we have shown a series of steps that led from configuration 1 to configuration 3. A careful look at Figures 1 and 2 reveals that these configurations are actually isomorphic. Consequently, we will next show a very similar series of steps that will lead us right back to configuration 1.\nAgents A3 and A7 detect that they have conflicts and that they have no neighbor with a higher priority that wants to mediate. Consequently, agents A3 and A7 start mediation sessions, since they cannot change their own color to a consistent state with their neighbors.\nWe will first observe A3’s mediation session. A3 sends evaluate? messages to its neighbors A1, A2, A4, and A5. All these agents reply with evaluate! messages. A3 conducts a Branch and Bound search to find a solution that satisfies all the constraints between A1, A2, A3, A4, and A5, and also minimizes external constraints. Agent A3 finds the solution (A1 ←Green, A2 ←Red, A3 ←Blue, A4 ←Green, A5 ←Red), which satisfies\nthe internal constraints, and minimizes to zero the external constraints. A3 sends accept! messages to its neighbors, informing them of its solution. A1, A2, A4, and A5 receive the accept! messages and send ok? messages with their new states to their neighbors. However, the ok? messages from A2 to A1 and from A5 to A6 and to A7 are delayed.\nConcurrently with the above mediation session of A3, agent A7 starts its own mediation session. A7 sends evaluate? messages to its neighbors A1, A5, A6, and A8. Let us assume that the message to A1 is delayed. A6 and A8 receive the evaluate? messages and reply with evaluate!, since they do not know any agents of higher priority than A7 that want to mediate. A5, is in A3’s mediation session, so it replies with wait!. We denote by configuration 4 the states of all the agents at this point of the processing (see Table 4).\nOnly after A3’s mediation session is over, A1 receives the delayed evaluate? message from A7. Since A1 is no longer in a mediation session, nor does it expect a mediation session from a node of higher priority than A7 (see A1’s view in Table 4), agent A1 replies with evaluate!. Notice that A1’s view of d2 is obsolete (the ok? message from A2 to A1 is still delayed). When agent A7 receives the evaluate! message from A1, it can continue the mediation session involving agents A1, A6, A7, and A8. Since the ok? messages from A5 to A6 and A7 are also delayed, agent A7 starts its mediation session with knowledge about agents A2 and A5 that is not updated (see bold-faced data in Table 4).\nAgent A7 conducts a Branch and Bound search to find a solution that satisfies all the constraints between A1, A6, A7, and A8, that also minimizes external constraints. In our example, A7 finds the solution (A1 ←Red, A6 ←Red, A7 ←Blue, A8 ←Green), which satisfies the internal constraints, and minimizes to zero the external constraints (remember that A7 has wrong data about A2 and A5). A7 sends accept! messages to A1, A6, and A8, informing them of its solution. The agents receive these messages and send ok? messages with their new states to their neighbors. By now, all the delayed messages get to their destination, and two constraints are violated – (A1,A2) and (A5,A6). Consequently, agents A1, A2, A5, and A6 want to mediate, whereas agents A3, A4, A7, and A8 do not wish to mediate, since they do not have any conflicts. Notice that all the agents have returned to the exact states they were in configuration 1 (see Figure 1 and Table 1).\nThe cycle that we have just shown between configuration 1 and configuration 3 can continue indefinitely. This example contradicts the termination and completeness of the APO algorithm.\nIt should be noted that we did not mention all the messages passed in the running of our example. We mentioned only those messages that are important for the understanding of the example, since the example is complicated enough. For instance, after agent A1 completes its mediation session (before configuration 2 ), there is some straightforward exchange of messages between agents, before the mj values of all the agents become correct (as presented in Table 2)."
    }, {
      "heading" : "5. Analyzing the Problems",
      "text" : "In the previous section a termination problem of the APO algorithm was described by constructing a scenario that leads to an infinite loop of the algorithm’s run. To better understand the completeness problem of APO, one must refer to the completeness proof of the APO algorithm as given by Mailler and Lesser (2006). The proof is based on the incorrect assertion that when a mediation session terminates it has three possible outcomes:\n1. A solution with no external conflicts. 2. No solution exists. 3. A solution with at least one external violated constraint.\nIn the first case, the mediator presumably finds a solution to the subproblem. In the second case, the mediator discovers that the overall problem is unsolvable. In the third case, the mediator adds the agent (or agents) with whom the external conflicts were found to its good list, which is used to define future mediations. In this way, either a solution or no solution is found (first two cases), or the good list grows, consequently bringing the problem solving closer to a centralized solution (third case).\nHowever, the infinite loop scenario in section 4 shows that the assertion claiming that these three cases cover all the possible outcomes of a mediation session is incorrect. There are two possible reasons for this incorrectness. The first reason is the possibility that a mediator initiates a partial mediation session without obtaining a lock on all the agents in its good list. The second reason is incorrect information about external constraints when neighboring mediation sessions are performed concurrently. Both reasons relate to the concurrency of mediation sessions."
    }, {
      "heading" : "5.1 Partial Mediation Sessions",
      "text" : "The first reason for the incorrectness of the ”always growth” assertion is the possibility that a mediator initiates a partial mediation session without obtaining a lock on all the agents in its good list. This possibility can occur because of earlier engagements of some of its good list ’s members with other mediation sessions. In APO’s code, these agents send a wait! message.\nLet us consider some partial mediation session. Assume that the mediator finds a solution to the subproblem, but such that has external conflicts with agents outside the mediation session. Assume also that all these conflicts are with agents that are already in the mediator’s good list. Notice that this is possible, since these agents can be engaged in other mediation sessions and have earlier sent wait! messages to the mediator. The present mediation session falls into case 3 of the original proof. However, it is apparent that no new agents will be added to the good list – contradicting the assertion.\nAnother possible outcome of partial mediation sessions is a situation in which an agent or several agents that have the entire graph in their good list try to mediate, but fail to get a lock on all the agents in their good list. Consequently, the situation in which a single agent holds the entire constraint graph, does not necessarily lead to a solution, due to an oscillation."
    }, {
      "heading" : "5.2 Neighboring Mediation Sessions",
      "text" : "The second reason for the incorrectness of the assertion in the original proof (Mailler & Lesser, 2006) is the potential existence of obsolete information of external constraints. This reason involves a scenario in which two neighboring mediation sessions are performed concurrently. Both the mediation sessions in the scenario end with finding a solution that presumably has no external conflicts, but the combination of both solutions causes new conflicts. This was the case with the mediation sessions of agents A1 and A5 in the example of section 4. Such a scenario seemingly fits the first case in the assertion, in which no external conflicts are found by each of the mediation sessions. Consequently, no externalconflict-free partial solution is found – contradicting the assertion. Furthermore, none of the mediators increase their good list. This enables the occurrence of an infinite loop, as displayed in section 4."
    }, {
      "heading" : "6. Complete Asynchronous Partial Overlay",
      "text" : "A two-part solution that solves the completeness problem of APO is presented. The first part of the solution insures that the first reason for the incorrectness of the assertion (see section 5.1) could not occur. This is achieved by preventing partial mediation sessions that go on without the participation of the entire mediator’s good list. The second part of the solution addresses the scenario in which two neighboring mediation sessions are performed concurrently. In such a scenario, the results of the mediation sessions can create new conflicts. In order to ensure that good lists grow and rule out an infinite loop, the second part of the solution makes sure that at least one of the good lists grows. Combined with the first part that insures that mediation sessions will involve the entire good lists of the mediators, the completeness of APO is secured."
    }, {
      "heading" : "6.1 Preventing Partial Mediation Sessions",
      "text" : "Our proposed algorithm disables the initiation of partial mediation sessions by making the mediator wait until it obtains a lock on all the agents in its good list. Algorithm 4 presents the changes and additions to APO that are needed for preventing partial mediation sessions.\nWhen the mediator receives a wait! message from at least one of the agents in its good list, it simply cancels the mediation session (wait!, line 2) and sets the counter to a special value of -1 (wait!, line 3). To notify the other participants of the canceled mediation session, the mediator sends a cancel! message to each of the participants (wait!, line 4). Upon receiving a cancel! message, the receiving agent updates its agent view (cancel!, line 1) and frees itself from the mediator’s lock (cancel!, line 2). However, the agent is still\nAlgorithm 4 Preventing partial mediation sessions.\nwhen received (wait!, (xj , pj)) do 1: update agent view with (xj , pj); 2: mediate ← false; 3: counter ← −1; 4: send (cancel!, (xi, pi)) to all xj ∈ good list; 5: check agent view;\nwhen received (evaluate!, (xj , pj , labeledDj)) do 1: update agent view with (xj , pj); 2: if counter 6= −1 do 3: record (xj , labeledDj) in preferences; 4: counter ← counter − 1; 5: if counter = 0 do choose solution;\nwhen received (cancel!, (xj , pj)) do 1: update agent view with (xj , pj); 2: mediate ← false; 3: check agent view;\naware of the mediator’s willingness to mediate. Consequently, it will not join a mediation session of a lower priority agent. The special value of counter is used by the mediator to disregard evaluate! messages that arrive after a wait! message (that causes a cancellation) due to asynchronous message passing (evaluate!, line 2).\nThe cancellation of a mediation session upon receiving a single wait! message introduces a need for a unique identification for mediation sessions. Consider a wait! message that a mediator receives. Upon receiving the message, the mediator cancels the mediation session and calls check agent view. It may decide to initiate a new mediation session. However, it might receive a wait! message from another agent corresponding to the previous, already cancelled, mediation session. Consequently, the new mediation session would be mistakenly cancelled too. To prevent the occurrence of such a problem, a unique id has to be added to each mediation session. This way, a mediator could disregard obsolete wait! and evaluate! messages. The unique identification of mediation sessions is removed from the pseudo-code in order to keep it as simple as possible.\nThis approach may imply some kind of a live-lock, where repeatedly no agent succeeds at initiating a mediation sessions. However, such a live-lock cannot occur due to the priorities of the agents. Consider agent xp that has the highest priority among all the agents that wish to mediate. In case agent xp obtains a lock on all the agents in its good list, it can initiate a mediation session and there is no live-lock. The interesting situation is when agent xp fails to get a lock on all the agents in its good list (receives at least one wait! message). Even in this case agent xp will eventually succeed at initiating a mediation session, since all the agents in its good list are aware of its willingness to mediate. The agents that are at the moment locked by other mediators (both initiated mediation sessions and mediation\nsessions that are to be canceled) will eventually be freed by either cancel! or accept! messages. Since these agents are all aware of agent xp’s willingness to mediate, they will not join any mediation session other than agent xp’s (unless xp informs them that it no longer wishes to mediate). Consequently, agent xp will eventually obtain a lock on all the agents in its good list – contradicting the implied live-lock."
    }, {
      "heading" : "6.2 Neighboring Mediation Sessions",
      "text" : "Sequential and concurrent neighboring mediation sessions may result in new conflicts being created without any of the good lists growing. Such mediation sessions may lead to an infinite loop as depicted in section 4. A7 in configuration 2 is an example of an agent that participates in sequential neighboring mediation sessions (of the mediators A1 and A5). On the other hand, A3 in configuration 2 is an example of an agent whose neighbors have an incorrect view of, due to concurrent mediation sessions.\nA solution to the problem of subsequent neighboring mediation sessions could be obtained if an agent (for example, A7 in configuration 2 ) would agree to participate in a new mediation session only when its agent view is updated with all the changes of the previous mediation session. This is achieved by the mediator sending its entire solution s in the accept! messages, instead of just specific d′j ’s. Therefore, the sending of accept! messages (choose solution, line 11) in Algorithm 2 is changed to the following:\nsend (accept!, (s, xi, pi, di, mi)) to xj ;\nUpon receiving the revised accept! message (Algorithm 5), agent i now updates all the dk’s in the received solution s accept for dk’s that are not in i’s agent view (accept!, lines 1-3). Notice that agent i still has to send ok? messages to its neighbors (accept!, line 7), since not all of its neighbors were necessarily involved in the mediation session.\nA solution to the problem of concurrent neighboring mediation sessions could be obtained if the mediator is informed post factum that a new conflict has been created due to concurrent mediation sessions. In this manner, the mediator can add the new conflicting agent to its good list. Algorithm 5 presents the changes and additions to APO that are needed for handling concurrent neighboring mediation sessions.\nWhen an agent xi participating in a mediation session receives the accept! message from its mediator, it keeps a list of all its neighbors (in the constraint graph) that are not included in the accept! message (not part of the mediation session), each associated with the mediator (accept!, lines 4-5). The list is named conc list, since it contains agents that are potentially involved in concurrent mediation sessions.\nUpon receiving an ok? message from an agent xj belonging to the conc list (ok?, line 2), agent xi checks if the data from the received ok? message generates a new conflict with xj (ok?, line 3). If no new conflict was generated, agent xj is just removed from the conc list (ok?, line 6). However, in case a conflict was generated (ok?, lines 3-5), agent xi perceives that agent xj and itself have been involved in concurrent mediation sessions that created new conflicts. In this case, agent xi’s mediator should add agent xj to its agent view and good list. Hence, agent xi sends a new add! message to the mediator (associated with agent xj in the conc list). When the mediator receives the add! message it adds agent xj to its agent view and its good list (add!, lines 1-2).\nAlgorithm 5 Handling neighboring mediation sessions.\nwhen received (accept!, (s, xj , pj , dj , mj)) do 1: for each xk ∈ agent view (starting with xi) do 2: if xk ∈ s do 3: update agent view with (xk, dk); 4: else if di does not generate a conflict with the existing dk do 5: add (xk, xj) to conc list ; 6: mediate ← false; 7: send (ok?, (xi, pi, di, mi)) to all xj ∈ agent view; 8: update agent view with (xj , pj , dj , mj); 9: check agent view;\nwhen received (ok?, (xj , pj , dj , mj)) do 1: update agent view with (xj , pj , dj , mj); 2: if xj ∈ conc list do 3: if dj generates a conflict with di do 4: for each tuple (xj , xk) in conc list do 5: send (add!, (xj)) to xk; 6: remove all tuples (xj , xk) from conc list ; 7: check agent view;\nwhen received (add!, (xj)) do 1: send (init, (xi, pi, di, mi, Di, Ci)) to xj ; 2: add xj to init list ;\nThere is a slight problem with this solution, since it may push the problem solving process to become centralized. This may happen because an ok? message from agent xj that generates a new conflict may actually have been the result of a later mediation session that agent xj was involved in. In such a case, xj ’s mediator already added agent xi to its good list. Adding agent xj to the good list of xi’s mediator is not necessary for the completeness of the algorithm. It does lead to a faster convergence of the problem into a centralized one. Nevertheless, experiments show that the effect of such growth of good lists is negligible (see section 9.3)."
    }, {
      "heading" : "6.3 Preventing Busy-Waiting",
      "text" : "To insure that partial mediation sessions do not occur, a wait! message received by a mediator (Algorithm 4) causes it to cancel the mediation session (section 6.1). The cancellation of the session is immediately followed by a call to check agent view (wait!, line 5). Such a call will most likely result in an additional attempt by the agent to start a mediation session, due to the high probability that the agent’s view did not change since its previous mediation attempt. The reasons that failed the previous mediation attempt may very well cause the new mediation session not to succeed also. Such subsequent mediation attempts may occur several times before the mediation session succeeds or the mediator decides to\nstop its attempts. As a matter of fact, the mediator remains in a busy-waiting mode, until either its view changes, or the reasons for the mediation session’s failure are no longer valid. The latter case enables the mediation session to take place.\nSuch a state of busy-waiting adds unnecessary overhead to the computation load of the problem solving. In particular, it increases the number of sent messages. To prevent this overhead, the mediating agent xm has to work in an interrupt-based manner rather than a busy-waiting manner. In an interrupt-based approach the mediator is notified (interrupted) when the reason for the previous mediation session’s failure is no longer valid. This is done by an ok? message that is sent to the mediator by the agent xw that sent the preceding wait! message, which caused the mediation session to fail. The agent xw will send such an ok? message only when the reason that caused it to send the wait! message becomes obsolete. Namely, when one of the following occurs:\n• The mediation session that xw was involved in is over. • An agent with a higher priority than xm no longer wants to mediate. • The init list of xw has been emptied out.\nIn order to remember which agents have to be notified (interrupted) when one of the above instances occurs, an agent maintains a list of pending mediators called wait list. Each time an agent sends a wait! message to a mediator, it adds that mediator to its wait list. Whenever an agent sends ok? messages, it clears its wait list.\nA few changes to the pseudo-code must be applied in order to use the interrupt-based method. To maintain the wait list, the following line has to be added to Algorithm 3 after line 3 in evaluate? (inside the if statement):\nadd xj to wait list ;\nAlso, after sending ok? messages to the entire agent view, as done for example in procedure check agent view line 7 (Algorithm 1), the following line should be added:\nempty wait list ;\nFinally, there is need to interrupt pending mediators whenever the reason for their mediation session’s failure may be no longer valid. For example, when an agent is removed from the init list (init, line 9) in Algorithm 1, the following lines need to be added (inside the else statement):\nif init list == ∅ do send (ok?, (xi, pi, di, mi)) to all xw ∈ wait list; empty wait list ;\nThese lines handle the case when the init list has been emptied out. Similar additions must be applied to deal with the other mentioned cases. Applying this interrupt-based method rules out the need for busy-waiting. Thus, the call for check agent view (wait!, line 5) can be discarded."
    }, {
      "heading" : "7. Soundness and Completeness",
      "text" : "In this section we will show that CompAPO is both sound and complete. Our proofs follow the basic structure and assumptions of the original APO proofs (Mailler & Lesser, 2006). The original completeness proof was incorrect because of the incompleteness of the original algorithm. Consequently, we will not use the assertion that was discussed in detail in section 3 and that played a key role in the original (and incorrect) proof of completeness (Mailler & Lesser, 2006). The following lemmas are needed for the proofs of soundness and completeness.\nLemma 1 Links are bidirectional. i.e. if xi has xj in its agent view then eventually xj will have xi in its agent view.\nProof (as appears in the work of Mailler and Lesser, 2006): Assume that xi has xj in its agent view and that xi is not in the agent view of xj . In order for xi to have xj in its agent view, xi must have received an init message at some point from xj . There are two cases.\nCase 1: xj is in the init list of xi. In this case, xi must have sent xj an init message first, meaning that xj received an init message and therefore has xi in its agent view – a contradiction.\nCase 2: xj is not in the init list of xi. In this case, when xi receives the init message from xj , it responds with an init message. That means that if the reliable communication assumption holds, eventually xj will receive xi’s init message and add xi to its agent view – also a contradiction.\nDefinition 1 An agent is considered to be in a stable state if it is waiting for messages, but no message will ever reach it.\nDefinition 2 A deadlock is a state in which an agent that has conflicts and desires to mediate enters a stable state.\nLemma 2 A deadlock cannot occur in the CompAPO algorithm."
    }, {
      "heading" : "Proof:",
      "text" : "Assume that agent xi enters a deadlock. This means that agent xi desires to mediate, but is in a stable state. The consequence of this is that agent xi would not be able to get a lock on all the agents in its good list.\nOne possibility is that xi already invited the members in its good list to join its mediation session by sending evaluate? messages. After a finite time it will receive either evaluate! or wait! messages from all the agents in its good list. Depending on the replies, xi either initiates a mediation session or cancels it. Either way, xi is not in a stable state – contradicting the assumption.\nThe other possibility is that xi did not reach the stage in which it invites other agents to join its mediation session. This can only happen, if there exists at least one agent xj that in xi’s point of view both desires to mediate (m ′ j = true) and has a higher priority than xi (p′j > pi). There are two cases in which xj would not mediate a session that included xi, when xi was expecting it to:\nCase 1: xi has m ′ j = true in its agent view when the actual value should be false. Assume that xi has m ′ j = true in its agent view when actually mj = false. This would mean that at some point xj changed the value of mj to false without informing xi about it. There is only one place in which xj changes the value of mj – the check agent view procedure. Note that in this procedure, whenever the flag changes from true to false, the agent sends ok? messages to all the agents in its agent view. Since by Lemma 1 we know that xi is in the agent view of xj , agent xi must have eventually received the message informing it that mj = false, contradicting the assumption.\nCase 2: xj believes that xi should be mediating when xi does not believe it should be. In xj ’s point of view, m ′ i = true and p ′ i > pj . By the previous case, we know that if xj believes that mi is true (m ′ i = true) then this must be the case. We only need to show that the condition p′i > pj is impossible. Assume that xj believes that p ′ i > pj when in fact pi < pj . This means that at some point xi sent a message to xj informing it that its current priority was p′i. Since we know that priorities only increase over time (all the good lists can only get larger), we know that p′i ≤ pi (xj always has the correct value or an underestimate of pi). Since pi < pj and p ′ i ≤ pi then p ′ i < pj – a contradiction to the assumption.\nDefinition 3 The algorithm is considered to be in a stable state when all the agents are in a stable state.\nTheorem 1 The CompAPO algorithm is sound. i.e., it reaches a stable state only if it has either found an answer or no solution exists."
    }, {
      "heading" : "Proof:",
      "text" : "We assume that all the agents reach a stable state, and consider all the cases in which this can happen.\nCase 1: No agent has conflicts. In this case, all the agents are in a stable state and with no conflicts. This means that the current value that each agent has for its variable satisfies all its constraints. Consequently, the current values are a valid solution to the overall problem, and the CompAPO algorithm has found an answer.\nCase 2: A no solution message has been broadcast. In this case, at least one agent found out that some subproblem has no solution, and informed all the agents about it by broadcasting a no solution message. Consequently, each agent that receives this message (all the agents) stops its run and reports that no solution exists.\nCase 3: Some agents have conflicts. Let us consider some agent xi that has a conflict. Since it has a conflict, xi desires to mediate. If it is able to perform a mediation session then it is not in a stable state in contradiction to the assumption. Therefore, the only condition in which xi can remain in a stable state is if it is expecting a mediation request from a higher priority agent xj that does not send it – in other words, when it is deadlocked. By Lemma 2 this cannot happen.\nSince only cases 1 and 2 can occur, the CompAPO algorithm reaches a stable state only if it has either found an answer or no solution exists. Consequently, the CompAPO algorithm is sound. ¤\nLemma 3 If there exist agents that hold the entire graph in their good list and desire to mediate, then one of these agents will perform a mediation session."
    }, {
      "heading" : "Proof:",
      "text" : "We shall consider two cases – when there is only one such agent that holds the entire graph in its good list and desires to mediate, and when there are several such agents. Case 1: Consider agent xi to be the only agent that holds the entire graph in its good list and desires to mediate. Since xi has the entire graph in its good list it has the highest possible priority. Moreover, all of the agents are aware of xi’s priority (pi) and desire to mediate (mi) due to ok? messages they received from xi containing this information (xi sent ok? messages to all the agents in its agent view, which holds the entire graph). Consequently, no agent will engage from this point on, in any mediation session other than xi’s. Since all mediation sessions are finite and no new mediation sessions will occur, agent xi will eventually get a lock on all the agents and will perform a mediation session.\nCase 2: If several such agents exist, then the tie in the priorities is broken by the agents’ index. Consider xi to be the one with the highest index out of these agents, and apply the same proof of case 1.\nLemma 4 If an agent holding the entire graph in its good list performs a mediation session, the algorithm reaches a stable state."
    }, {
      "heading" : "Proof:",
      "text" : "Consider the mediator to be agent xi. Following the first part of CompAPO’s solution (section 6.1), an agent can perform a mediation session only if it received evaluate! messages from all the agents in its good list. Since xi holds the entire graph in its good list, it means that all the agents in the graph have sent evaluate! messages to xi and set their mediate flags to be true. This means that until xi completes its search and returns accept! messages with its solution, no agent can change its assignment. Assuming that the centralized internal solver that xi uses is sound and complete, it will find a solution to the entire problem if such a solution exists, or alternatively conclude that no solution exists. If no solution exists, then xi informs all the agents about this and the problem solving terminates. Otherwise, each agent receives the accept! message from xi that contains the solution to the entire problem. Consequently, no agent has any conflicts and the algorithm reaches a stable state.\nLemma 5 Infinite value changes without any mediation sessions cannot occur."
    }, {
      "heading" : "Proof:",
      "text" : "The proof will focus on line 6 of the check agent view procedure, the only place in the code in which a value is changed without a mediation session. As a reminder, notice that all the agents in the graph are ordered by their priority (ties are broken by the IDs of the agents).\nConsider the agent with the lowest priority (xp1). Agent xp1 cannot change its own value, since line 5 in the check agent view procedure states that in order to reach the value change in line 6, the current value must conflict exclusively with lower priority agents. Clearly this is impossible for agent xp1 , which has the lowest priority in the graph.\nNow, consider the next agent in the ordering, xp2 . Agent xp2 can change its current value when it is in conflict exclusively with lower priority agents. The only lower priority agent in this case is xp1 . If xp1 and xp2 are not neighbors, then agent xp2 cannot change its own value for the same reason as agent xp1 . Otherwise, agent xp2 will know the upto-date value of agent xp1 in finite time (any previously sent updates regarding xp1 ’s value will eventually reach agent xp2), since we proved that the value of xp1 cannot be changed without a mediation session. After xp2 has the up-to-date value of all its lower priority neighbors (only xp1), it can change its own value at most once without a mediation session. Eventually, all the neighbors of xp2 will be updated with the final change of its value.\nIn general, any agent xpi (including the highest priority agent) will in finite time have the up-to-date values of all its lower priority agents. When this happens, it can change its own value at most once without a mediation session. Eventually, all the neighbors of xpi will be updated with the final change of its value. Thus, infinite value changes without any mediation sessions cannot occur.\nThis proof implicitly relies on the fact that the ordering of agents does not change. However, the priority of an agent may change in time. Nevertheless, the priorities are bounded by the size of the graph, so the number of priority changes is finite. This proves that value changes cannot indefinitely occur without any mediation sessions.\nLemma 6 If from this point on no agent will mediate or desire to mediate, the algorithm will reach a stable state."
    }, {
      "heading" : "Proof:",
      "text" : "We shall consider two cases – when there are no messages that have not yet arrived to their destinations, and when there are such messages. Case 1: Consider the case when there are no messages that have not yet arrived to their destination. If no agent desires to mediate, then all the mi’s are false, meaning that no agent in the graph has conflicts. Consequently, the current state of the graph is a solution that satisfies all the constraints, and the algorithm reaches a stable state.\nCase 2: Consider the case when there are some messages that have not yet arrived to their destinations. Eventually these messages will arrive. According to the assumption of the lemma, the arrival of these messages will not make any of the agents desire to mediate. Next, we consider the arrival of each type of message and show that it cannot lead to infinite exchange of messages:\n• evaluate?, evaluate!, wait!, cancel!: These messages must belong to an obsolete mediation session, or otherwise contradict the assumption of the lemma. Accordingly, they may result in some limited exchange of messages (e.g., sending wait! in line 3 of evaluate?). Some of these messages may lead to a call to the check agent view procedure. • accept!: This message cannot be received without contradicting the assumption, since the receiving agent has to be in an active mediation session when receiving an accept! message. • init: This message is part of a handshake between two agents. Consequently, at most a single additional init message will be sent. This leads to a call to the check agent view procedure by each of the involved agents.\n• add!: This message results in the sending of a single init message. • ok?: This message may result in the sending of a finite number of add! messages. It\nalso leads to a call to the check agent view procedure.\nBy examining all the types of messages, we conclude that each message can at most lead to a finite exchange of messages, and to a finite number of calls to the check agent view procedure. We only need to show that a call to check agent view cannot lead to infinite exchange of messages.\nThe check agent view procedure has 4 possible outcomes. It may simply return (line 2), change the value of the variable (lines 6-7), mediate (line 9), or update its desire to mediate (lines 11-12). According to the assumption of the lemma, it cannot mediate. An update of its desire to mediate, means that the value of mi was true, or will be updated to true. Either way, this is again in contradiction to the assumption of the lemma. Consequently, the only possibilities are a simple return, or a change in the value of its own variable. According to Lemma 5, such value changes cannot indefinitely occur without any mediation sessions. Consequently, the final messages will eventually arrive to their destinations, and the first case of the proof will hold.\nDefinition 4 One says that the algorithm advances if at least one of the good lists grows.\nLemma 7 After every n mediation sessions, the algorithm either advances or reaches a stable state."
    }, {
      "heading" : "Proof:",
      "text" : "Consider a mediation session of agent xi. The mediation session has three possible outcomes – no solution satisfying the constraints within the good list, a solution satisfying the constraints within the good list but with violations of external constraints, and a solution satisfying all the constraints within the good list and all the external constraints.\nCase 1: No solution that satisfies the constraints within xi’s good list exists, therefore the entire problem is unsatisfiable. In this case, xi informs all the agents about this and the problem solving terminates.\nCase 2: xi finds a solution that satisfies the constraints within its good list but violates external constraints. In this case, xi adds the agents with whom there are external conflicts to its good list. These agents were not already in xi’s good list, since the mediation session included the entire good list of xi (according to section 6.1). Consequently, xi’s good list grows and the algorithm advances.\nCase 3: xi finds a solution that satisfies the constraints within its good list and all the external constraints. Following the second part of CompAPO’s solution (section 6.2), agents from xi’s good list maintain a conc list, and would notify xi to add agents to its good list in case they experience new conflicts due to concurrent mediation sessions. In such a case, xi would be notified, its good list would grow and the algorithm would advance.\nThe only situation in which the algorithm does not advance or reach a stable state, is when all the mediation sessions experience case 3, and no concurrent mediation sessions create new conflicts. In that case, after at most n mediation sessions (equal to the overall number of agents), all the agents would have no desire to mediate. According to Lemma 6, the algorithm reaches a stable state.\nLemma 8 If there exists a group of agents that desire to mediate, a mediation session will eventually occur."
    }, {
      "heading" : "Proof:",
      "text" : "No agent will manage to get a lock on all the agents in its good list (essential for a mediation session to occur) only if all the agents in the group that sent evaluate? messages got at least one wait! message each. If this is the case, consider xi to be the highest priority agent among this group.\nEach wait! message that agent xi received is either from an agent that is a member of the group or from an agent outside the group, currently involved in another mediation session. In case this agent (xj) belongs to the group, xj also got some wait! message (clearly, this wait! message arrived after xj sent wait! to xi). xj will therefore cancel its mediation session, and will wait for xi’s next evaluate? message (since xj is now aware of xi’s desire to mediate and pi is the highest priority among the agents that currently desire to mediate). In case xj does not belong to the group, the mediation session that xj is involved in will eventually terminate, and xi will get the lock, unless xj has a higher priority than xi (pj > pi) and also xj desires to mediate when the session terminates. If this is the case, xj will eventually get the lock for the same reasons.\nTheorem 2 The CompAPO algorithm is complete. i.e., if a solution exists, the algorithm will find it, and if a solution does not exist, the algorithm will report that fact."
    }, {
      "heading" : "Proof:",
      "text" : "Since we have shown in Theorem 1 that whenever the algorithm reaches a stable state, the problem is solved and that when it finds a subset of variables that is unsatisfiable it terminates, we only need to show that it always reaches one of these two states in a finite time.\nAccording to Lemma 6, if from some point in time no agent will mediate or desire to mediate, the algorithm will reach a stable state. According to Lemma 8 if there exist agents that desire to mediate, eventually a mediation session will occur. From Lemmas 6 and 8 we conclude that the only possibility for the algorithm not to reach a stable state is by continuous occurrences of mediation sessions. According to Lemma 7, after every n mediation sessions, the algorithm either advances or reaches a stable state. Consequently, the algorithm either reaches a stable state or continuously advances.\nIn case the algorithm continuously advances, the good lists continuously grow. At some point, some agents (eventually all the agents) will hold the entire graph in their good list. One of these agents will eventually desire to mediate (if not, then according to Lemma 6, the algorithm reaches a stable state). According to Lemma 3, one of these agents will perform a mediation session. According to Lemma 4, the algorithm reaches a stable state. ¤"
    }, {
      "heading" : "8. OptAPO – an Optimizing APO",
      "text" : "Distributed Constraint Optimization Problems (DisCOPs) are a version of distributed constraint problems, in which the goal is to find an optimal solution to the problem, rather than a satisfying one. In an optimization problem, an agent associates a cost with violated constraints and maintains bounds on these costs in order to reach an optimal solution that minimizes the number of violated constraints.\nA number of algorithms were proposed in the last few years for solving DisCOPs. The simplest algorithm of these is Synchronous Branch and Bound (SyncBB) (Hirayama & Yokoo, 1997), which is a distributed version of the well-known centralized Branch and Bound algorithm. Another algorithm which uses a Branch and Bound scheme is Asynchronous Forward Bounding (AFB) (Gershman, Meisels, & Zivan, 2006), in which agents perform sequential assignments which are propagated for bounds checking and early detection of a need to backtrack. A number of algorithms use a pseudo-tree which is derived from the structure of the DisCOP in order to improve the process of acquiring a solution for the optimization problem. ADOPT (Modi, Shen, Tambe, & Yokoo, 2005) is such an asynchronous algorithm in which assignments are passed down the pseudo-tree. Agents compute upper and lower bounds for possible assignments and send costs up to their parents in the pseudo-tree. These costs are eventually accumulated by the root agent. Another algorithm which exploits a pseudo tree is DPOP (Petcu & Faltings, 2005). In DPOP, each agent receives from the agents which are its sons in the pseudo-tree, all the combinations of partial solutions in their sub-tree and their corresponding costs. The agent calculates and generates all the possible partial solutions which include the partial solutions it received from its sons and its own assignments and sends the resulting combinations up the pseudotree. Once the root agent receives all the information from its sons, it produces the optimal solution and propagates it down the pseudo-tree to the rest of the agents.\nAnother very different approach was implemented in the Optimal Asynchronous Partial Mediation (OptAPO) (Mailler & Lesser, 2004; Mailler, 2004) algorithm, which is an optimization version of the APO algorithm. Differently to APO, the OptAPO algorithm introduces a second type of mediation sessions called passive mediation sessions. The goal of the passive sessions is to update the bounds on the costs without changing the values of variables. These sessions add parallelism to the algorithm and accelerate the distribution of information. This might solve many problems that result from incorrect information, which is discussed in section 5.2. However, active mediation sessions also occur in OptAPO. The active sessions may consist of parts of the good list (partial mediation sessions), and as a result lead to the problems described in section 5.1. Moreover, a satisfiable problem should also be solved by OptAPO, returning a zero optimal cost. Therefore, the infinite loop scenario described in section 4 will also occur in OptAPO, which behaves like APO when the problem is satisfiable.\nThe OptAPO algorithm must be corrected in order for the aforementioned problems to be solved. In section 6 several modifications to the APO algorithm are proposed. These changes turn APO into a complete search algorithm – CompAPO. Equivalent modifications must also be applied to the OptAPO algorithm in order to ensure its correctness. Interestingly, these modifications to APO are to procedures that are similar in APO and OptAPO. The main differences between APO and OptAPO are in the addition of passive mediation sessions (procedure check agent view) to OptAPO, and in the internal search that mediators perform (procedure choose solution). However, neither of these procedures is effected by the modifications of CompAPO. Thus, the pseudo-code of the changes that must be applied to OptAPO is very similar to the modifications of CompAPO, and is therefore omitted from this paper. The performance of the resulting algorithm – CompOptAPO – is evaluated in section 9.5. The full pseudo-code of the original OptAPO algorithm can be found in the work of Mailler and Lesser (2004)."
    }, {
      "heading" : "9. Experimental Evaluation",
      "text" : "The original (and incomplete) version of the APO algorithm was evaluated by Mailler and Lesser (2006). It was compared to the AWC algorithm (Yokoo, 1995), which is not an efficient DisCSP solver (Zivan et al., 2007). The experiments were performed on 3-coloring problems, which are a subclass of uniform random constraints problems. These problems are characterized by a small domain size, low constraints density, and fixed constraints tightness (for the characterization of random CSPs see the works of Prosser, 1996 and Smith, 1996). The comparison between APO and AWC (Mailler & Lesser, 2006) was made with respect to three measures – the number of sent messages, the number of cycles, and the serial runtime. While the number of sent messages is a very important and widely accepted measure, the other measures are problematic. During a cycle, incoming messages are delivered, the agent is allowed to process the information, and any messages that were created during the processing are added to the outgoing queue to be delivered at the beginning of the next cycle. The meaning of such a cycle in APO is that a mediation session that possibly involves the entire graph takes just a single cycle. Such a measure is clearly problematic, since every centralized algorithm solves a problem in just one cycle. Measuring the serial runtime is also not adequate for distributed CSPs, since it does not take into account any concurrent computations during the problem solving. In order to measure the concurrent runtime of DisCSP algorithms in an implementation independent way, one needs to count non-concurrent constraint checks (NCCCs) (Meisels, Razgon, Kaplansky, & Zivan, 2002). This measure has gained global agreement in the DisCSP and DisCOP community (Bessiere et al., 2005; Zivan & Meisels, 2006b) and will be used in the present evaluation.\nThe modifications of CompAPO, and especially the prevention of partial mediation sessions (section 6.1) add synchronization to the algorithm, which may tax heavily the performance of the algorithm. Thus, it is important to evaluate the effect of these changes by comparing CompAPO to other (incomplete) versions of the APO algorithm. Additionally, we evaluate the effectiveness of the interrupt-based method compared to busy-waiting."
    }, {
      "heading" : "9.1 Experimental Setup",
      "text" : "In all our experiments we use a simulator in which agents are simulated by threads, which do not hold any shared memory and communicate only through message passing. The network of constraints, in each of our experiments, is generated randomly by selecting the probability p1 of a constraint among any pair of variables and the probability p2, for the occurrence of a violation among two assignments of values to a constrained pair of variables. Such uniform random constraints networks of n variables, k values in each domain, a constraints density of p1 and tightness p2 are commonly used in experimental evaluations of CSP algorithms (Prosser, 1996; Smith, 1996).\nExperiments were conducted for several density values. Our setup included problems generated with 15 agents (n = 15) and 10 values (k = 10). We drew 100 different instances for each combination of p1 and p2. Through all our experiments each agent holds a single variable."
    }, {
      "heading" : "9.2 Comparison to Other Algorithms",
      "text" : "The performance of CompAPO is compared to three asynchronous search algorithms – the well known Asynchronous Backtracking (ABT) (Yokoo et al., 1998; Yokoo & Hirayama, 2000), the extremely efficient Asynchronous Forward-Checking with Backjumping (AFCCBJ) (Meisels & Zivan, 2007), and to Asynchronous Weak Commitment (AWC) (Yokoo, 1995), which was used in the original APO evaluation (Mailler & Lesser, 2006).\nResults are presented for three sets of tests with different values of problem density – sparse (p1 = 0.1), medium (p1 = 0.4), and dense (p1 = 0.7). In all the sets the value of p2 varies between 0.1 and 0.9, to cover all ranges of problem difficulty.\nIn order to evaluate the performance of the algorithms, two independent measures of performance are used – search effort in the form of NCCCs and communication load in the form of the total number of messages sent. Figures 3, 4, and 5 present the number of NCCCs performed by CompAPO while solving problems with different densities. Figure 6 shows the total number of messages sent during the problem solving process. All figures exhibit the phase-transition phenomenon – for increasing values of the tightness, p2, problem difficulty increases, reaches a maximum, and then drops back to a low value. This is termed the easy-hard-easy transition of hard problems (Prosser, 1996), and was observed for DisCSPs (Meisels & Zivan, 2007; Bessiere et al., 2005).\nThe performance of CompAPO in NCCCs turns out to be very poor in the phase transition region compared to other asynchronous search algorithms. The worst results are when the problems are relatively sparse (Figures 3 and 4). However, even for dense problems both ABT and AFC-CBJ clearly outperform CompAPO (Figure 5). When comparing CompAPO to AWC, the results are significantly different. AWC is known to perform best in sparse problems. Thus, like ABT and AFC-CBJ it clearly outperforms CompAPO for such problems (Figure 3). For medium density problems, AWC still performs better than CompAPO but the difference between the performances of these algorithms is much smaller (Figure 4). For dense problems, AWC performs extremely bad with about ten times more NCCCs than CompAPO. The results of AWC are omitted from Figure 5, since it did not finish running this set of tests in a reasonable time and we had to stop its run after 40 hours.\nNotice that the scale in Figure 4 is different than in Figures 3 and 5. This is due to especially poor performance of APO around the phase transition of medium density problems. Such behavior is untypical, since most DisCSP algorithm suffer from their worst performance around the phase transition of high density problems (Figure 5). The fact that the performance of CompAPO is better on high density problems than on medium density ones can be explained by the faster convergence to a centralized solution in dense problems. In problems around the phase transition, the CompAPO algorithm frequently reaches full centralization anyway. Thus, the faster convergence to a centralized solution actually improves the performance of the algorithm.\nWhile the search effort performed by the agents running CompAPO is extremely high, the communication load on the system remains particularly low. This can be seen in Figure 6, for medium density problems. Similar results were achieved for sparse and dense problems. This is not surprising, since the major part of the search effort is carried out by agents performing mediation sessions without the need for an extensive exchange of messages."
    }, {
      "heading" : "9.3 Comparison to Other Versions of APO",
      "text" : "Several versions of the APO algorithm were proposed by Benisch and Sadeh (2006). One of these versions (APO-BT) uses simple backtracking as its mediation procedure, instead of the Branch and Bound that was originally proposed with APO (APO-BB). The performance of CompAPO is compared to these two incomplete versions of the algorithm.\nThe modifications of CompAPO, and especially the prevention of partial mediation sessions (section 6.1) add synchronization to the algorithm. A potential partial mediation session must wait for other sessions to end until the mediator is able to get a lock on its entire good list. Such synchronization may tax the performance of the algorithm. Nevertheless, our experiments show that CompAPO actually performs slightly better than APO-BB as measured by NCCCs (Figures 7 and 8). The improved performance can be explained by the better distribution of data when the entire solution is sent with the accept! message (section 6.2). Figure 9 shows that the effect of CompAPO’s modifications is even greater on the communication load. This substantial advantage of CompAPO may be explained by the use of the interrupt-based approach (section 6.3) that helps performance by eliminating the unnecessary overhead of busy-waiting.\nFigure 10 presents the mean size of the largest mediation session occurring during search, for medium density problems (p1 = 0.4) with 15 variables. The average size of the largest mediation session is around 12 (out of a maximum of 15). It occurs for problems in the phase transition region when p2 is 0.5 and 0.6. Although this number is not very far from the maximum of 15, it does suggest that a considerable portion of the hard problems are solved without reaching a full centralization.\nThe part of the code of CompAPO that solves the neighboring mediation sessions problem (section 6.2) implies a potential additional growth to good lists (ok?, line 5), which may result in a faster centralization during problem solving. Nevertheless, Figure 10 clearly shows that CompAPO does not centralize faster than the original version of APO (APOBB), except for very tight, unsolvable problems.\nOur experiments show that in medium density problems, the APO-BT version performs poorly with respect to both NCCCs and the number of sent messages in comparison to APO-BB and CompAPO (Figures 7 and 9). The reason for ABO-BT’s poor performance can be easily explained by its frequent convergence to full centralization as shown in Figure 10. Nevertheless, APO-BT has a lower communication load than APO-BB in the phase transition. The reason for this is actually the same reason that leads to APO-BT’s extensive search effort. A prompt convergence to full centralization yields a high search effort (NCCCs), but at the same time may reduce the communication load.\nFigure 8 shows that on dense problems APO-BT performs better than APO-BB and almost the same as CompAPO. This supports the results reported by Benisch and Sadeh (2006) for dense random DisCSPs. The same paper also presents the results for structured\n3-coloring problems, in which APO-BT is outperformed by APO-BB. Similar behavior is observed in the experiments that we conducted on sparser problems (Figure 7), which suggests that the variance in APO-BT’s performance has more to do with the density of the problem than with its structure.\nBenisch and Sadeh propose an additional version to the APO algorithm, in which the mediation session selection rule is the inverse of the original selection rule (Benisch & Sadeh, 2006). The version called IAPO instructs agents to choose the smallest mediation session rather than the largest one. It is not clear that IAPO can be turned into a correct algorithm, since the correctness proofs presented in section 7 rely on the fact that the largest mediation sessions are chosen. Consequently, the evaluation of IAPO is omitted from this paper."
    }, {
      "heading" : "9.4 Interrupt-Based Versus Busy-Waiting",
      "text" : "Figures 11 and 12 present two measures of performance comparing different methods for synchronization that is needed in order to avoid conflicts between concurrent mediation sessions – interrupt-based and busy-waiting (section 6.3). The interrupt-based method clearly outperforms busy-waiting for harder problem instances. Predictably, the difference in performance is more pronounced when measuring the number of messages (Figure 12)."
    }, {
      "heading" : "9.5 Evaluation of CompOptAPO",
      "text" : "The original (and incomplete) version of the OptAPO algorithm was evaluated by Mailler and Lesser (2004). It was compared to the ADOPT algorithm (Modi et al., 2005), which is not the best DisCOP solver. Similarly to the original results of APO (Mailler & Lesser, 2006), the comparison between OptAPO and ADOPT (Mailler & Lesser, 2004) was made with respect to three measures – the number of sent messages, the number of cycles, and the serial runtime. For the same reasons as in DisCSP algorithms, cycles and serial runtime are also problematic for measuring the performance of DisCOP algorithms. As was the case\nwith CompAPO, the CompOptAPO algorithm will also be evaluated by counting NCCCs and the number of sent messages.\nThe Distributed Optimization problems used in the following experiments are random Max-DisCSPs. Max-DisCSP is a subclass of DisCOP in which all constraint costs (weights) are equal to one (Modi et al., 2005). This feature simplifies the task of generating random problems, since by using Max-DisCSPs one does not have to decide on the costs of the constraints. Max-CSPs are commonly used in experimental evaluations of constraint optimization problems (COPs) (Larrosa & Schiex, 2004). Other experimental evaluations of DisCOPs include graph coloring problems (Modi et al., 2005; Zhang, Xing, Wang, & Wittenburg, 2005), which are a subclass of Max-DisCSP. The advantage of using random Max-DisCSP problems is the fact that they create an evaluation framework that is known to exhibit the phase-transition phenomenon in centralized COPs. This is important when evaluating algorithms for solving DisCOPs, enabling a known analogy with behavior of centralized algorithms as the problem difficulty changes. The problems solved in this section are randomly generated Max-DisCSP with 10 agents (n = 10) and 10 values (k = 10), constraint density of either p1 = 0.4 or p1 = 0.7, and varying constraint tightness 0.4 ≤ p2 < 1.\nThe performance of CompOptAPO is compared to three search algorithms – Synchronous Branch and Bound (SyncBB) (Hirayama & Yokoo, 1997), AFB (Gershman et al., 2006), and ADOPT (Modi et al., 2005). ADOPT was used in the original OptAPO evaluation (Mailler & Lesser, 2004).\nIt must be noted that in our experiments with the original OptAPO algorithm, we have experienced several runs in which the algorithm failed to advance and did not reach a solution. This shows that the termination problem of OptAPO occurs in practice and not just in theory, for a scenario that involves particular message delays as the one presented in section 4 for the APO algorithm. Additionally, we discovered that OptAPO may not always be able to report the optimal cost (i.e., the number of broken constraints in our MaxDisCSP experiments). To understand how this can happen consider an ”almost” disjoint\ngraph, such as the one depicted in Figure 13. In this example we assume that agents A1 and A2 do not have any conflicts. Consequently, the knowledge regarding the cost F is not exchanged between the two groups, and no agent holds the correct overall cost of the problem (F = 3). Nevertheless, when the OptAPO algorithm terminates, it does so with the optimal solution. Thus, the optimal value can be derived upon termination by summing the number of broken constraints of all of the agents. The result must be divided by two to account for broken constraints being counted by each of the involved agents.\nThe performance of CompOptAPO in NCCCs is comparable with other DisCOP algorithms when the problems are relatively loose (low p2 value), with only the ADOPT algorithm performing slightly better. This is the case for both sparse and dense problems (Figures 14 and 15, respectively). As the problems become tighter, CompOptAPO clearly outperforms both ADOPT and SyncBB. In fact, the ADOPT algorithm failed to terminate in reasonable time for tight problems (p2 > 0.8 in Figure 14 and p2 > 0.6 in Figure 15). However, on tight problems the AFB algorithm is much faster than CompOptAPO. Actually, AFB was the only algorithm in our experiments that managed to terminate in reasonable time for problems that are both dense (p1 = 0.7) and tight (p2 = 0.9).\nSimilarly to CompAPO, the communication load on the system remains particularly low when running the CompOptAPO algorithm. This can be seen in Figure 16 for dense problems. Similar results are observed for sparse problems. This is not surprising, since the major part of the search effort is carried out by agents performing mediation sessions without the need for an extensive exchange of messages."
    }, {
      "heading" : "10. Conclusions",
      "text" : "The APO search algorithm is an asynchronous distributed algorithm for DisCSPs. The algorithm partitions the search into different subproblems. Each subproblem is solved by a selected agent – the mediator. When conflicts arise between a solution to a subproblem and its neighboring agents, the conflicting agents are added to the subproblem. Ideally, the algorithm either leads to compatible solutions of constraining subproblems, or to the growth of subproblems whose solution is incompatible with neighboring agents. This twooption situation was used in the original APO paper (Mailler & Lesser, 2006) to prove the termination and completeness of the algorithm.\nThe proof of completeness of the APO algorithm as presented by Mailler and Lesser (2006) is based on the growth of the size of the subproblems. It turns out that this expected growth of groups does not occur in some situations, leading to a termination problem of the algorithm. The present paper demonstrates this problem by following an example that does not terminate. Furthermore, the paper identifies the problematic parts in the original algorithm that interfere with its completeness and applies modifications that solve the problematic parts. The resulting CompAPO algorithm ensures the completeness of the search. Formal proofs for the soundness and completeness of CompAPO are presented.\nThe CompAPO algorithm forms a class by itself of DisCSP search algorithms. In contrast to backtracking or concurrent search processes, it achieves concurrency by solving subproblems concurrently. It is therefore both interesting and important to evaluate the performance of CompAPO and to compare it to other DisCSP search algorithms.\nAsynchronous Partial Overlay is actually a family of algorithms. The completeness and termination problems that are presented and corrected in the present study apply to all the members of the family. The OptAPO algorithm (Mailler & Lesser, 2004; Mailler, 2004) is an optimization version of APO that solves Distributed Constraint Optimization Problems (DisCOPs). The present paper shows that similar modification to the ones made to the APO algorithm must also be applied to OptAPO in order to ensure its correctness. These changes call for performance evaluation of the resulting CompOptAPO algorithm.\nThe experimental evaluation that was presented in section 9 demonstrates that the performance of CompAPO is poor compared to other asynchronous search algorithms. On randomly generated DisCSPs the runtime of APO, as measured by NCCCs, is longer by up to two orders of magnitude than that of ABT (Yokoo et al., 1998; Yokoo & Hirayama, 2000) and AFC-CBJ (Meisels & Zivan, 2007).\nThe total number of messages sent by CompAPO is considerably smaller than the corresponding number for ABT or AFC-CBJ. This is a clear result of the fact that hard problem instances tend to be solved by a small number of mediators in a semi-centralized manner.\nThe runtime performance of CompOptAPO is better than that of ADOPT (Modi et al., 2005) and SyncBB (Hirayama & Yokoo, 1997) for hard instances of randomly generated DisCOPs. Similarly to the DisCSP case, the total number of messages sent by CompOptAPO is considerably smaller than the corresponding number for other DisCOP algorithms. However, in the phase-transition region of randomly generated DisCOPs, the runtime of CompOptAPO is longer by more than an order of magnitude than that of AFB (Gershman et al., 2006)."
    } ],
    "references" : [ {
      "title" : "Examining DCSP coordination tradeoffs",
      "author" : [ "M. Benisch", "N. Sadeh" ],
      "venue" : "In Proceedings of the Fifth International Joint Conference on Autonomous Agents and Multiagent Systems",
      "citeRegEx" : "Benisch and Sadeh,? \\Q2006\\E",
      "shortCiteRegEx" : "Benisch and Sadeh",
      "year" : 2006
    }, {
      "title" : "Asynchronous backtracking without adding links: a new member in the ABT family",
      "author" : [ "C. Bessiere", "A. Maestre", "I. Brito", "P. Meseguer" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Bessiere et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Bessiere et al\\.",
      "year" : 2005
    }, {
      "title" : "Asynchronous forward-bounding for distributed constraints optimization",
      "author" : [ "A. Gershman", "A. Meisels", "R. Zivan" ],
      "venue" : "In Proc. ECAI-06,",
      "citeRegEx" : "Gershman et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Gershman et al\\.",
      "year" : 2006
    }, {
      "title" : "CompAPO: A complete version of the APO algorithm",
      "author" : [ "T. Grinshpoun", "A. Meisels" ],
      "venue" : "In Proceedings of the 2007 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT",
      "citeRegEx" : "Grinshpoun and Meisels,? \\Q2007\\E",
      "shortCiteRegEx" : "Grinshpoun and Meisels",
      "year" : 2007
    }, {
      "title" : "Termination problem of the APO algorithm",
      "author" : [ "T. Grinshpoun", "M. Zazon", "M. Binshtok", "A. Meisels" ],
      "venue" : "In Proceedings of the Eighth International Workshop on Distributed Constraint Reasoning",
      "citeRegEx" : "Grinshpoun et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Grinshpoun et al\\.",
      "year" : 2007
    }, {
      "title" : "Distributed partial constraint satisfaction problem",
      "author" : [ "K. Hirayama", "M. Yokoo" ],
      "venue" : "In Proceedings of the Third International Conference on Principles and Practice of Constraint Programming",
      "citeRegEx" : "Hirayama and Yokoo,? \\Q1997\\E",
      "shortCiteRegEx" : "Hirayama and Yokoo",
      "year" : 1997
    }, {
      "title" : "Solving weighted csp by maintaining arc consistency",
      "author" : [ "J. Larrosa", "T. Schiex" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Larrosa and Schiex,? \\Q2004\\E",
      "shortCiteRegEx" : "Larrosa and Schiex",
      "year" : 2004
    }, {
      "title" : "A mediation-based approach to cooperative, distributed problem solving",
      "author" : [ "R. Mailler" ],
      "venue" : "Ph.D. thesis, University of Massachusetts",
      "citeRegEx" : "Mailler,? \\Q2004\\E",
      "shortCiteRegEx" : "Mailler",
      "year" : 2004
    }, {
      "title" : "Solving distributed constraint optimization problems using cooperative mediation",
      "author" : [ "R. Mailler", "V. Lesser" ],
      "venue" : "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems",
      "citeRegEx" : "Mailler and Lesser,? \\Q2004\\E",
      "shortCiteRegEx" : "Mailler and Lesser",
      "year" : 2004
    }, {
      "title" : "Asynchronous partial overlay: A new algorithm for solving distributed constraint satisfaction problems",
      "author" : [ "R. Mailler", "V. Lesser" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR),",
      "citeRegEx" : "Mailler and Lesser,? \\Q2006\\E",
      "shortCiteRegEx" : "Mailler and Lesser",
      "year" : 2006
    }, {
      "title" : "Comparing performance of distributed constraints processing algorithms",
      "author" : [ "A. Meisels", "I. Razgon", "E. Kaplansky", "R. Zivan" ],
      "venue" : "In Proc. AAMAS-2002 Workshop on Distributed Constraint Reasoning DCR,",
      "citeRegEx" : "Meisels et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Meisels et al\\.",
      "year" : 2002
    }, {
      "title" : "Adopt: asynchronous distributed constraints optimization with quality guarantees",
      "author" : [ "P.J. Modi", "W. Shen", "M. Tambe", "M. Yokoo" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Modi et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Modi et al\\.",
      "year" : 2005
    }, {
      "title" : "A scalable method for multiagent constraint optimization",
      "author" : [ "A. Petcu", "B. Faltings" ],
      "venue" : "In Proceedings of the International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Petcu and Faltings,? \\Q2005\\E",
      "shortCiteRegEx" : "Petcu and Faltings",
      "year" : 2005
    }, {
      "title" : "An empirical study of phase transitions in binary constraint satisfaction problems",
      "author" : [ "P. Prosser" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Prosser,? \\Q1996\\E",
      "shortCiteRegEx" : "Prosser",
      "year" : 1996
    }, {
      "title" : "MaxCAPO: A new expansion of APO to solve distributed constraint satisfaction problems",
      "author" : [ "S.H. Semnani", "K. Zamanifar" ],
      "venue" : "In Proceedings of the International Conference on Artificial Intelligence and Soft Computing (ASC",
      "citeRegEx" : "Semnani and Zamanifar,? \\Q2007\\E",
      "shortCiteRegEx" : "Semnani and Zamanifar",
      "year" : 2007
    }, {
      "title" : "Locating the phase transition in binary constraint satisfaction problems",
      "author" : [ "B.M. Smith" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Smith,? \\Q1996\\E",
      "shortCiteRegEx" : "Smith",
      "year" : 1996
    }, {
      "title" : "Asynchronous weak-commitment search for solving distributed constraint satisfaction problems",
      "author" : [ "M. Yokoo" ],
      "venue" : "In Proceedings of the First International Conference on Principles and Practice of Constraint Programming",
      "citeRegEx" : "Yokoo,? \\Q1995\\E",
      "shortCiteRegEx" : "Yokoo",
      "year" : 1995
    }, {
      "title" : "Distributed constraint satisfaction problem: Formalization and algorithms",
      "author" : [ "M. Yokoo", "E.H. Durfee", "T. Ishida", "K. Kuwabara" ],
      "venue" : "IEEE Trans. on Data and Kn. Eng.,",
      "citeRegEx" : "Yokoo et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Yokoo et al\\.",
      "year" : 1998
    }, {
      "title" : "Algorithms for distributed constraint satisfaction: A review",
      "author" : [ "M. Yokoo", "K. Hirayama" ],
      "venue" : "Autonomous Agents and Multi-Agent Systems,",
      "citeRegEx" : "Yokoo and Hirayama,? \\Q2000\\E",
      "shortCiteRegEx" : "Yokoo and Hirayama",
      "year" : 2000
    }, {
      "title" : "Distributed stochastic search and distributed breakout: properties, comparison and applications to constraints optimization problems in sensor networks",
      "author" : [ "W. Zhang", "Z. Xing", "G. Wang", "L. Wittenburg" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Zhang et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2005
    }, {
      "title" : "Concurrent search for distributed CSPs",
      "author" : [ "R. Zivan", "A. Meisels" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Zivan and Meisels,? \\Q2006\\E",
      "shortCiteRegEx" : "Zivan and Meisels",
      "year" : 2006
    }, {
      "title" : "Message delay and DisCSP search algorithms",
      "author" : [ "R. Zivan", "A. Meisels" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence(AMAI),",
      "citeRegEx" : "Zivan and Meisels,? \\Q2006\\E",
      "shortCiteRegEx" : "Zivan and Meisels",
      "year" : 2006
    }, {
      "title" : "Min-domain ordering for asynchronous backtracking",
      "author" : [ "R. Zivan", "M. Zazone", "A. Meisels" ],
      "venue" : "In Proceedings of the 13th International Conference on Principles and Practice of Constraint Programming",
      "citeRegEx" : "Zivan et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Zivan et al\\.",
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "A recently published algorithm, Asynchronous Partial Overlay (APO) (Mailler, 2004; Mailler & Lesser, 2006), attempts to solve DisCSPs by merging partial solutions.",
      "startOffset" : 67,
      "endOffset" : 106
    }, {
      "referenceID" : 7,
      "context" : "To help understand the problem, a full pseudo-code of APO that follows closely the original presentation of the algorithm (Mailler & Lesser, 2006) is given. The erroneous part in the proof of APO’s completeness as presented by Mailler and Lesser (2006) is shown and the problematic parts in the algorithm that interfere with its completeness are identified.",
      "startOffset" : 123,
      "endOffset" : 253
    }, {
      "referenceID" : 16,
      "context" : "Also, in the evaluation of the original APO algorithm (Mailler & Lesser, 2006), it was compared to the AWC algorithm (Yokoo, 1995), which is not an efficient DisCSP solver (Zivan, Zazone, & Meisels, 2007).",
      "startOffset" : 117,
      "endOffset" : 130
    }, {
      "referenceID" : 7,
      "context" : "Also, in the evaluation of the original APO algorithm (Mailler & Lesser, 2006), it was compared to the AWC algorithm (Yokoo, 1995), which is not an efficient DisCSP solver (Zivan, Zazone, & Meisels, 2007). Moreover, the tests in the work of Mailler and Lesser (2006) were only performed on relatively sparse problems, and the comparison with AWC was made by the use of some problematic measures.",
      "startOffset" : 55,
      "endOffset" : 267
    }, {
      "referenceID" : 7,
      "context" : "The OptAPO algorithm (Mailler & Lesser, 2004; Mailler, 2004) is",
      "startOffset" : 21,
      "endOffset" : 60
    }, {
      "referenceID" : 17,
      "context" : "In a distributed constraint satisfaction problem (DisCSP), the agents are connected by constraints between variables that belong to different agents (Yokoo et al., 1998).",
      "startOffset" : 149,
      "endOffset" : 169
    }, {
      "referenceID" : 7,
      "context" : "The pseudo-code in Algorithms 1, 2, and 3 follows closely the presentation of APO in the work of Mailler and Lesser (2006).",
      "startOffset" : 97,
      "endOffset" : 123
    }, {
      "referenceID" : 7,
      "context" : "The original paper (Mailler & Lesser, 2006) uses the term preferences to describe potential conflicts between solutions of overlapping subproblems. In the present paper we use the term external constraints to describe such conflicts. A detailed description of the APO algorithm can be found in the work of Mailler and Lesser (2006).",
      "startOffset" : 20,
      "endOffset" : 332
    }, {
      "referenceID" : 7,
      "context" : "To better understand the completeness problem of APO, one must refer to the completeness proof of the APO algorithm as given by Mailler and Lesser (2006). The proof is based on the incorrect assertion that when a mediation session terminates it has three possible outcomes:",
      "startOffset" : 128,
      "endOffset" : 154
    }, {
      "referenceID" : 7,
      "context" : "Another very different approach was implemented in the Optimal Asynchronous Partial Mediation (OptAPO) (Mailler & Lesser, 2004; Mailler, 2004) algorithm, which is an optimization version of the APO algorithm.",
      "startOffset" : 103,
      "endOffset" : 142
    }, {
      "referenceID" : 7,
      "context" : "The full pseudo-code of the original OptAPO algorithm can be found in the work of Mailler and Lesser (2004).",
      "startOffset" : 82,
      "endOffset" : 108
    }, {
      "referenceID" : 16,
      "context" : "It was compared to the AWC algorithm (Yokoo, 1995), which is not an efficient DisCSP solver (Zivan et al.",
      "startOffset" : 37,
      "endOffset" : 50
    }, {
      "referenceID" : 22,
      "context" : "It was compared to the AWC algorithm (Yokoo, 1995), which is not an efficient DisCSP solver (Zivan et al., 2007).",
      "startOffset" : 92,
      "endOffset" : 112
    }, {
      "referenceID" : 1,
      "context" : "This measure has gained global agreement in the DisCSP and DisCOP community (Bessiere et al., 2005; Zivan & Meisels, 2006b) and will be used in the present evaluation.",
      "startOffset" : 76,
      "endOffset" : 123
    }, {
      "referenceID" : 6,
      "context" : "The original (and incomplete) version of the APO algorithm was evaluated by Mailler and Lesser (2006). It was compared to the AWC algorithm (Yokoo, 1995), which is not an efficient DisCSP solver (Zivan et al.",
      "startOffset" : 76,
      "endOffset" : 102
    }, {
      "referenceID" : 13,
      "context" : "Such uniform random constraints networks of n variables, k values in each domain, a constraints density of p1 and tightness p2 are commonly used in experimental evaluations of CSP algorithms (Prosser, 1996; Smith, 1996).",
      "startOffset" : 191,
      "endOffset" : 219
    }, {
      "referenceID" : 15,
      "context" : "Such uniform random constraints networks of n variables, k values in each domain, a constraints density of p1 and tightness p2 are commonly used in experimental evaluations of CSP algorithms (Prosser, 1996; Smith, 1996).",
      "startOffset" : 191,
      "endOffset" : 219
    }, {
      "referenceID" : 17,
      "context" : "The performance of CompAPO is compared to three asynchronous search algorithms – the well known Asynchronous Backtracking (ABT) (Yokoo et al., 1998; Yokoo & Hirayama, 2000), the extremely efficient Asynchronous Forward-Checking with Backjumping (AFCCBJ) (Meisels & Zivan, 2007), and to Asynchronous Weak Commitment (AWC) (Yokoo, 1995), which was used in the original APO evaluation (Mailler & Lesser, 2006).",
      "startOffset" : 128,
      "endOffset" : 172
    }, {
      "referenceID" : 16,
      "context" : ", 1998; Yokoo & Hirayama, 2000), the extremely efficient Asynchronous Forward-Checking with Backjumping (AFCCBJ) (Meisels & Zivan, 2007), and to Asynchronous Weak Commitment (AWC) (Yokoo, 1995), which was used in the original APO evaluation (Mailler & Lesser, 2006).",
      "startOffset" : 180,
      "endOffset" : 193
    }, {
      "referenceID" : 13,
      "context" : "This is termed the easy-hard-easy transition of hard problems (Prosser, 1996), and was observed for DisCSPs (Meisels & Zivan, 2007; Bessiere et al.",
      "startOffset" : 62,
      "endOffset" : 77
    }, {
      "referenceID" : 1,
      "context" : "This is termed the easy-hard-easy transition of hard problems (Prosser, 1996), and was observed for DisCSPs (Meisels & Zivan, 2007; Bessiere et al., 2005).",
      "startOffset" : 108,
      "endOffset" : 154
    }, {
      "referenceID" : 0,
      "context" : "Several versions of the APO algorithm were proposed by Benisch and Sadeh (2006). One of these versions (APO-BT) uses simple backtracking as its mediation procedure, instead of the Branch and Bound that was originally proposed with APO (APO-BB).",
      "startOffset" : 55,
      "endOffset" : 80
    }, {
      "referenceID" : 0,
      "context" : "This supports the results reported by Benisch and Sadeh (2006) for dense random DisCSPs.",
      "startOffset" : 38,
      "endOffset" : 63
    }, {
      "referenceID" : 11,
      "context" : "It was compared to the ADOPT algorithm (Modi et al., 2005), which is not the best DisCOP solver.",
      "startOffset" : 39,
      "endOffset" : 58
    }, {
      "referenceID" : 7,
      "context" : "The original (and incomplete) version of the OptAPO algorithm was evaluated by Mailler and Lesser (2004). It was compared to the ADOPT algorithm (Modi et al.",
      "startOffset" : 79,
      "endOffset" : 105
    }, {
      "referenceID" : 11,
      "context" : "Max-DisCSP is a subclass of DisCOP in which all constraint costs (weights) are equal to one (Modi et al., 2005).",
      "startOffset" : 92,
      "endOffset" : 111
    }, {
      "referenceID" : 11,
      "context" : "Other experimental evaluations of DisCOPs include graph coloring problems (Modi et al., 2005; Zhang, Xing, Wang, & Wittenburg, 2005), which are a subclass of Max-DisCSP.",
      "startOffset" : 74,
      "endOffset" : 132
    }, {
      "referenceID" : 2,
      "context" : "The performance of CompOptAPO is compared to three search algorithms – Synchronous Branch and Bound (SyncBB) (Hirayama & Yokoo, 1997), AFB (Gershman et al., 2006), and ADOPT (Modi et al.",
      "startOffset" : 139,
      "endOffset" : 162
    }, {
      "referenceID" : 11,
      "context" : ", 2006), and ADOPT (Modi et al., 2005).",
      "startOffset" : 19,
      "endOffset" : 38
    }, {
      "referenceID" : 7,
      "context" : "The proof of completeness of the APO algorithm as presented by Mailler and Lesser (2006) is based on the growth of the size of the subproblems.",
      "startOffset" : 63,
      "endOffset" : 89
    }, {
      "referenceID" : 7,
      "context" : "The OptAPO algorithm (Mailler & Lesser, 2004; Mailler, 2004) is an optimization version of APO that solves Distributed Constraint Optimization Problems (DisCOPs).",
      "startOffset" : 21,
      "endOffset" : 60
    }, {
      "referenceID" : 17,
      "context" : "On randomly generated DisCSPs the runtime of APO, as measured by NCCCs, is longer by up to two orders of magnitude than that of ABT (Yokoo et al., 1998; Yokoo & Hirayama, 2000) and AFC-CBJ (Meisels & Zivan, 2007).",
      "startOffset" : 132,
      "endOffset" : 176
    }, {
      "referenceID" : 11,
      "context" : "The runtime performance of CompOptAPO is better than that of ADOPT (Modi et al., 2005) and SyncBB (Hirayama & Yokoo, 1997) for hard instances of randomly generated DisCOPs.",
      "startOffset" : 67,
      "endOffset" : 86
    }, {
      "referenceID" : 2,
      "context" : "However, in the phase-transition region of randomly generated DisCOPs, the runtime of CompOptAPO is longer by more than an order of magnitude than that of AFB (Gershman et al., 2006).",
      "startOffset" : 159,
      "endOffset" : 182
    } ],
    "year" : 2008,
    "abstractText" : "Asynchronous Partial Overlay (APO) is a search algorithm that uses cooperative mediation to solve Distributed Constraint Satisfaction Problems (DisCSPs). The algorithm partitions the search into different subproblems of the DisCSP. The original proof of completeness of the APO algorithm is based on the growth of the size of the subproblems. The present paper demonstrates that this expected growth of subproblems does not occur in some situations, leading to a termination problem of the algorithm. The problematic parts in the APO algorithm that interfere with its completeness are identified and necessary modifications to the algorithm that fix these problematic parts are given. The resulting version of the algorithm, Complete Asynchronous Partial Overlay (CompAPO), ensures its completeness. Formal proofs for the soundness and completeness of CompAPO are given. A detailed performance evaluation of CompAPO comparing it to other DisCSP algorithms is presented, along with an extensive experimental evaluation of the algorithm’s unique behavior. Additionally, an optimization version of the algorithm, CompOptAPO, is presented, discussed, and evaluated.",
    "creator" : "dvips(k) 5.94a Copyright 2003 Radical Eye Software"
  }
}