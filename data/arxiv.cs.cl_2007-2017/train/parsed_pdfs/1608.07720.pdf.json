{
  "name" : "1608.07720.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Bi-LSTM-RNN Model for Relation Classification Using Low-Cost Sequence Features",
    "authors" : [ "Fei Li", "Meishan Zhang", "Guohong Fu", "Tao Qian", "Donghong Ji" ],
    "emails" : [ "dhji}@whu.edu.cn" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 8.\n07 72\n0v 1\n[ cs\n.C L\n] 2\n7 A"
    }, {
      "heading" : "1. Introduction",
      "text" : "Relation classification is associated with many potential applications in the artificial intelligence area such as information extraction, question answering and\nsemantic network construction. In the natural language processing (NLP) community, there are a number of evaluation tasks [1], [2], [3], [4] about relation classification. They aim to classify the relations between two target entities into some predefined relation types. For example, “burst” and “pressure” have a “CauseEffect” relation in the sentence “The burst has been caused by water hammer pressure.”.\nEarly studies [5], [6], [7], [8] mainly focused on feature-based or kernel-based approaches to solve this problem, but they need to pay much attention on feature engineering or kernel design. Recently, the approaches based on deep neural networks such as convolutional neural networks (CNNs) [9], recursive neural networks (RecursiveNNs) [10] and recurrent neural networks (RNNs) [11] have become increasingly popular in order to reduce manual intervention. In these approaches, structure features (e.g., syntactic or dependency features) are usually effective, since they can help models to remove less relevant noise and get more compact representations.\nHowever, structure features may cause some problems: on the one hand, the high cost for parsing sentences makes such approaches inconvenient to be directly used; on the other hand, syntactic or dependency parsers are probably domain-dependent. For example, a parser trained in news corpora may be imprecise when it is used in biomedical text, which will unavoidably hurt the performance of models using structure features.\nThis paper proposes a Bi-LSTM-RNN model based on low-cost sequence features to address relation classification. Our motivation is that the relation between two target entities can be represented by the entities and contexts surrounding them. Therefore, the Bi-LSTM-RNN model firstly performs bi-directional recurrent computation along all the tokens of the\nsentences which the relation spans. Then, the sequence of token representations, which are generated in the previous step, is divided into five parts according to the order that tokens occur in these sentences:\n• before context, which consists of the tokens before the former target entity; • former entity, which consists of the tokens in the former target entity; • middle context, which consists of the tokens between two target entities; • latter entity, which consists of the tokens in the latter target entity; • after context, which consists of the tokens after the latter target entity.\nSome relation examples are shown as below.\n• Message-Topic: [In this comprehensive]before [guide]former [, over 850]middle [roses]latter [are described, illustrated, and arranged by group.]after • Lives-In: [ ]before [Vibrio salmonicida]former [was detected in sediment samples from diseased farms. It was also detected in a]middle [sediment sample from a disease-free fish farm]latter [.]after\nAfter the sequence of token representations has been divided, standard pooling functions are applied over the token representations of each part, and we obtain five representations corresponding to the five parts. Lastly, they are concatenated and fed into a softmax layer for relation classification. To avoid the need of structure features, our model uses low-cost sequence features such as words and part-of-speech (POS) tags. Moreover, LSTMs [12] are used to attenuate the gradient vanishing problem when two target entities are distant in text.\nWe evaluate our model on two standard benchmark datasets in different domains, namely SemEval-2010 Task 8 [2] and BioNLP-ST 2016 Task BB3 [4]. Experimental results in the former dataset show that our model achieves comparable performance compared with other models that use sequence features. In the latter dataset, our model obtains the third best results compared with other models in the official evaluation. In addition, we evaluate the contributions of three contexts, and find that the middle context plays the most important role in relation classification. Furthermore, statistic experiments show that the middle context can be used as an approximate replacement of the shortest dependency path when dependency parsing is not used. Our model is implemented using LibN3L [13], and the code is publicly available under GPL at: http://xxxxx."
    }, {
      "heading" : "2. Related Work",
      "text" : "Early approaches for relation classification are usually feature/kernel-based. Feature-based approaches [6], [7] design a great number of lexical, syntactic or semantic features and use classifiers such as support vector machines (SVMs) to classify relations. The problem may be that handcrafted features are laborconsuming and time-costing. Kernel-based approaches [5], [14] do not need much effort on feature engineering, but well-designed kernel functions, which are usually based on syntactic or dependency structures, are crucial for relation classification.\nRecently, the approaches based on deep neural networks become new research hotspots for relation classification, since they can achieve promising results with less manual intervention. RecursiveNNs [10], [15] are firstly used for this task to learn sentence representations along syntactic or dependency structures. Liu et al. [16] combine RecursiveNNs and CNNs to capture features of the shortest dependency path and its attached subtree. Zeng et al. [9] leverage CNNs to classify relations with lexical, sentence and word position features. Based on CNNs, dos Santos et al. [17] propose a novel ranking loss function for special treatment of the noisy Other class. Xu et al. [18] leverage CNNs to learn representations from shortest dependency paths, and address the relation directionality by special treatment on sampling. Yu et al. [19] propose a factor-based embedding model to decompose sentences into factors based on linguistic annotations, extract features and combine them via sum-pooling. Xu et al. [11] use multi-channel RNNs along the shortest dependency path between two target entities, and they obtain the best result without any special treatment. Most of the approaches above use structure features. In this paper, we follow the line of RNNs, but not use structure features.\nSince some classical work was published [20], [21], deep neural networks have received increasing research attention in the NLP community. They have been successfully applied into many other NLP tasks, such as sentiment analysis [22], [23], parsing [24], [25] and machine translation [26], [27]. To tackle different problems, prior work used various networks such as CNNs [28] or RNNs [29], and some optimization technologies [30]. Recently, some researchers turn their attention to new unsupervised learning technologies and the ability of deep models to generalize well from small datasets [31]. However, non-neural approaches are still important and attract considerable research attention, since neural networks seem not to outperform other approaches in all the tasks."
    }, {
      "heading" : "3. Our Bi-LSTM-RNN Model",
      "text" : "Our model has several characters: relation classification is modeled based on entity and context representations learned from LSTM-RNNs; only lowcost sequence features are used to avoid the problems of structure features; features are extracted from bidirectional RNNs using simple pooling technologies; relations between entities that occur in different sentences can also be classified."
    }, {
      "heading" : "3.1. Long Short Term Memory (LSTM)",
      "text" : "LSTMs [12] aim to facilitate the training of RNNs by solving the diminishing and exploding gradient problems in the deep or long structures. It can be defined as below: given an input sequence x = {x1, x2, ..., xn}, LSTMs associate each of them with an input gate (it), a forget gate (f t), an output gate (ot), a candidate cell state (c̃t), a cell state (ct) and a hidden state (ht). it decides what new information will be stored in the current cell state ct. f t decides what information is going to be thrown away from the previous cell state ct−1. ot decides what information will be output to the current hidden state ht (n(lstm) dimension), which is computed by\nit = σ( W (i) · ( ht−1 ⊕ xt ) + b (i)), ft = σ( W (f) · ( ht−1 ⊕ xt ) + b (f)),\not = σ( W (o) · ( ht−1 ⊕ xt ) + b (o)), c̃t = tanh( W (c) · ( ht−1 ⊕ xt ) + b (c)),\nct = ft × ct−1 + it × c̃t,\nht = ot × tanh( ct ),\n(1)\nwhere σ denotes the sigmoid function. + and × denote the element-wise addition and product operations,\nrespectively. ⊕ denotes the vector concatenation. The input, forget, output gate and candidate cell state are associated with their own weight matrices W and bias vectors b, which are learned."
    }, {
      "heading" : "3.2. Bi-LSTM-RNN",
      "text" : "The framework of our Bi-LSTM-RNN model is shown in Figure 1. The given sentence or text segment can be considered as a token sequence s = {s1, s2, ..., sn}. A LSTM unit takes the embedding xt of each token st as input and outputs a hidden state h′t computed by Equation 1. Then we will get a hidden state sequence h′ = {h′1, h ′ 2, ..., h ′ n} after the LSTM unit has finished recurrent computation along all the tokens from left to right. Here h′t does not only capture the information of token st, but also that of its predecessors. To capture the information of its successors, a counterpart h′′t of h ′ t is also generated by another LSTM unit computing in the reverse direction. The final representation sequence of all the tokens, namely h = {h1, h2, ..., hn}, is generated by concatenating h′t and h ′′ t at first, and then using a compositional operation to reduce the dimension to n(h). This procedure can be formulated as\nht = tanh( W1 · ( h ′ t ⊕ h ′′ t ) + b1). (2)\nIn the following step, we divide the token representation sequence h into five parts, namely before, former, middle, latter and after according to the boundaries of target entities. Four standard pooling functions (i.e., max, min, avg, std) are respectively applied over the token representations of each part and we obtain five representations corresponding to the five parts. For example, the former entity representation rformer can\nbe computed by\nrmaxj = max 16k6K hkj ,\nrminj = min 16k6K hkj , ravgj = 1\nK\n∑\n16k6K\nhkj ,\nrstdj =\n√\n∑\n16k6K\nh2kj ,\n(3)\nrformer = rmax ⊕ rmin ⊕ ravg ⊕ rstd, (4)\nwhere the former entity is assumed to start at the 1st token and end at the K-th token. hkj denotes the j-th component of the k-th token representation vector. rmaxj , rminj , ravgj and rstdj denote the j-th components of representation vectors generated by the corresponding pooling functions.\nThe penultimate layer of our Bi-LSTM-RNN model consists of the concatenation of five representations corresponding to entities and their contexts, which can be formulated by\nxpenul = rbefore⊕ rformer⊕ rmiddle⊕ rlatter ⊕ rafter. (5)\nFinally, the output layer calculates the probabilities of all relation types, so that the one with the maximum probability is selected. The probability of the i-th relation type Ri is computed by\np( Ri ) = softmax( Ri ) = ew2i · xpenul\n∑|R| j=1 e\nw2j · xpenul ,\n(6) where w2i denotes the i-th row of parameter matrix W2 in the output layer."
    }, {
      "heading" : "3.3. Training",
      "text" : "Given a set of annotated training examples, the training objective of our model is to minimize the cross-entropy loss, with a L2 regularization term, given by\nL( θ ) = − ∑\ni\nlog pgi + β\n2 ‖ θ ‖22, (7)\nwhere θ denotes all the parameters of the model. pgi indicates the probability of the gold relation type of the i-th training example as given by the model. β is the regularization parameter.\nWe employ standard training frameworks for the model, namely stochastic gradient decent using AdaGrad [30]. Derivatives are calculated from standard back-propagation [32]. More details will be further described in Section 4."
    }, {
      "heading" : "3.4. Features",
      "text" : "Motivated by prior work [11], [24], other features can also be represented as fixed-length embeddings besides words. We explore five kinds of features in our model, namely pre-trained word features, random word features, character features, POS features and WordNet hypernym features. As shown in Figure 2a, given a token “dog”, its pre-trained word, random word, character, POS and WordNet hypernym features are “dog”, “dog”, “d,o,g”, “NN” and “animal”, respectively. n(pre), n(ran), n(pos) and n(wnh)-dimensional feature embeddings, namely rpre, rran, rpos and rwnh, are directly taken from their corresponding lookup tables, namely Epre, Eran, Epos and Ewnh. Since the character number of a word is variable, character features are transformed into a n(char)-dimensional embedding rchar using another Bi-LSTM network as shown in Figure 2b. l2r denotes the last output generated by a LSTM unit computing from left to right, and r2l denotes the last output generated by another LSTM unit computing in the reverse direction. The embedding rchar of character features is computed by\nrchar = l2r ⊕ r2l. (8)\nFinally, we concatenate five kinds of feature embeddings as a composite embedding x, given by\nx = rpre ⊕ rran ⊕ rchar ⊕ rpos ⊕ rwnh. (9)\nPre-trained word features indicate the word features whose embeddings are trained by tools such as word2vec [33] in a great number of external corpora. Most of neural network systems use pre-trained word embeddings to initialize their own word features and tune them in a supervised way during training. Instead, we select pre-trained word embeddings whose domain is consistent with the specific task, and not tune them during training. We believe that pre-trained word embeddings capture global knowledge, which do not need to be adjusted.\nRandom word features indicate the word features whose embeddings are randomly initialized. By tuning them during training, local knowledge with respect to the specific task can be learned. In our model, both pre-trained and random word features are used, since we believe that they are complementary to each other.\nCharacter features have some distinct characteristics compared with word features. For instance, they can alleviate the out-of-vocabulary problem or capture prefix and suffix information.\nPOS features are used based on the intuition that the importance of a word for relation classification does not only depend on the word itself, but also its\nPOS tag. For instance, given a “Cause-Effect” relation sentence “The burst has been caused by water hammer pressure.”, the verb “caused” plays more important role than other words in relation classification. By contrast, the preposition “in” is an obvious mark to identify the “Component-Whole” relation, given a sentence “The introduction in the book is a summary of what is in the text.”. In this paper, we utilize Stanford CoreNLP toolkit [34] for POS tagging.\nWordNet hypernym features come from WordNet [35], which includes more than 90,000 word senses called synsets. Each noun, verb or adjective synset is associated with one of about 47 broad semantic categories called supersenses (a.k.a., WordNet hypernyms) [10]. For example, given a sentence “My dog ate a bag full of dog treats on Tuesday”, its WordNet hypernym annotations will be “Myo dogn.animal atev.consumption ao bagn.artifact fulla.all ofo dogn.animal treatsv.body ono Tuesdayn.time”. n, v, a and o indicate noun, verb, adjective and other, respectively. WordNet hypernym features are proved to be effective since they reflect word senses, which may be helpful for semantic relation classification [10]. In this paper, we utilize sst-light [36] for WordNet hypernym tagging."
    }, {
      "heading" : "4. Experiments",
      "text" : ""
    }, {
      "heading" : "4.1. SemEval-2010 Task 8",
      "text" : ""
    }, {
      "heading" : "Data and Evaluation Metrics",
      "text" : "This dataset [2] defines 9 directed relation types between two target entities and one undirected Other type when two target entities have none of these relations. We treat each directed relation type as two relation types, so there are totally 19 relation types in our model. The dataset consists of 8,000 training and 2,717 test sentences, and each sentence is annotated with one relation type. Following previous work [2], [10], the official macro-averaged F1-score (F1) is used to evaluate performance of different models."
    }, {
      "heading" : "Parameter Settings",
      "text" : "Parameters are tuned based on the development set, which includes 800 sentences selected from the training set randomly. As it is infeasible to perform full search for all the parameters, some of the values are chosen empirically following prior work [9], [10], [11]. The initial AdaGrad learning rate α is set as 0.01 and L2 regularization parameter β is set as 10−8. The dimension of pre-trained word embeddings, n(pre) is set as 200. The dimensions of other feature embeddings, namely n(ran), n(pos), n(wnh) and n(char), are set as 50. The dimensions of LSTM hidden state (n(lstm)) and token representation (n(h)) are set as 200.\nThe weight matrices W, bias vectors b and embedding lookup tables Eran, Echar, Epos, Ewnh, are randomly initialized in the range (-0.01, 0.01) with a uniform distribution. As for the pre-trained word lookup table Epre, we train embeddings to initialize it via the snapshot of English Wikipedia1 in April, 2016 and word2vec [33] with the skip-gram architecture. The Wikipedia text is preprocessed in the following steps: non-English characters or words are removed; a sentence is removed if it is too short; text is tokenized and all the tokens are transformed into their lowercase forms. Feature embeddings are tuned during training except pre-trained word embeddings."
    }, {
      "heading" : "Results",
      "text" : "The experimental results on the test set are shown in Table 1. MVRNN [10], C-RNN [15] and DepNN [16] are based on RecursiveNNs, but DepNN also combines CNNs to capture features of the shortest dependency paths and further improves the result to 83.6%. FCM [19] achieves a comparable result by\n1. https://dumps.wikimedia.org/enwiki/\ndecomposing sentences into factors, extracting features and combining them via sum-pooling. CNN-based depLCNN [18] and RNN-based SDP-LSTM [11] classify relations using the shortest dependency paths between two entities and obtain similar results. After taking the relation directionality into consideration by a negative sampling strategy, depLCNN achieves state-of-the-art performance (85.6%). Inspired by [37], we also experiment with dependency features, and the best result of our model can be 83.1%. The models mentioned above use structure features, while CNN [9] and CR-CNN [17] only use sequence features such as words and word positions. CR-CNN can achieve 84.1% in F1 with special treatment for noisy Other class, but its F1 is 82.7% without such special treatment. Our model obtains slightly lower but comparable performance compared with them.\nAny kind of models is not absolutely superior to others since they use different features or special treatment. However, the models using structure features usually obtain better performance. This may be because structure features can help removing less relevant noise and providing more compact representations for models. Meanwhile, the shortest dependency paths can take relation directionality into consideration, which may meet the characteristics of this task.\nTable 2 shows the contributions of different features in our model. By using only pre-trained word features, our model can achieve 78.8% in F1. WordNet hypernym features are the most effective features, improving F1 from 78.8% to 79.8%. Character features are less effective than others, improving F1 by 0.5%."
    }, {
      "heading" : "4.2. BioNLP-ST 2016 Task BB3",
      "text" : "Although structure features are useful for relation classification, they are probably domain-dependent. Moreover, there are about 26% relations between entities that occur in different sentences based on our statistics for BioNLP-ST 2016 Task BB3 [4]. Structure features are not easy to be directly used since they are designed for using inside one sentence. We experiment on this dataset to prove that our model is still effective even if the problems above exist."
    }, {
      "heading" : "Data and Evaluation Metrics",
      "text" : "This task includes several subtasks and we focus on the relation classification subtask. The subtask considers one relation type, namely Lives In, which indicates that bacteria live in a habitat. The dataset consists of 61, 34 and 51 documents for training, development and test, respectively. There are 1080, 730, 1093 entities and 327, 223, 340 relations in the training, development, test sets. We use the official evaluation service2 to evaluate our model. The evaluation metrics are standard precision (P), recall (R) and F1-score (F1)."
    }, {
      "heading" : "Parameter Settings",
      "text" : "Parameters are tuned based on the official development set with 34 documents. The dimensions of pre-trained word embeddings (n(pre) ) and random word embeddings (n(ran)) are set as 200. The dimensions of other feature embeddings, namely n(pos), n(wnh) and n(char), are set as 50. The dimensions of LSTM hidden state (n(lstm)) and token representation (n(h)) are set as 200. Other parameter settings are similar to those in the previous task.\nThe weight matrices W, bias vectors b and embedding lookup tables Eran, Echar, Epos, Ewnh, are randomly initialized in the range (-0.01, 0.01). We use biomedical word embeddings [38] trained from\n2. http://bibliome.jouy.inra.fr/demo/BioNLP-ST-2016Evaluation/index.html\nPubMed text to initialize our pre-trained word lookup table Epre. Feature embeddings are tuned during training except pre-trained word embeddings."
    }, {
      "heading" : "Results",
      "text" : "The experimental results on the test set are shown in Table 3. VERSE obtains state-of-the-art F1 (55.8%) in the official evaluation. TurkuNLP and LIMSI achieve the best precision and recall, respectively. When our model considers relations between bacteria/habitat entities that occur in the same sentence, it can obtain better F1 than that of LIMSI. When our model considers relations between bacteria/habitat entities that occur in two continuous sentences, F1 increases from 49.8% to 51.3%. If the sentence window is further enlarged, F1 goes down. This may be because most bacteria/habitat entity pairs spanning more than two sentences have no Lives In relations, the numbers of positive (15%) and negative (85%) examples for training the model become very imbalanced.\nFeature contributions are shown in Table 4. Our model obtains 41.3% in F1 using only pre-trained word features. WordNet hypernym features are the most effective features, improving F1 from 41.3% to 44.8%. Random word features are more helpful than character features. POS features are less effective than any other kind of features, improving F1 by 0.6%."
    }, {
      "heading" : "5. Discussion",
      "text" : ""
    }, {
      "heading" : "5.1. Which context contributes the most?",
      "text" : "We evaluate contributions of the before, middle and after contexts for relation classification between two target entities. As shown in Table 5, the middle context plays the most important role. Our model can obtain F1 81.1% and 47.1% using only the middle context in SemEval-2010 Task 8 and BioNLP-ST 2016 Task BB3, respectively. The effects of before and after contexts are almost the same in two datasets, but they are less helpful than the middle context. This is consistent with linguistic intuition, since key words or phrases for relation classification are often located in the middle context. By contrast, the before context often consists of pronouns, articles or modal verbs, and the after context often consists of punctuations or complement constituents. More noise in the before and after contexts lead them to be less helpful for relation classification.\nIn SemEval-2010 Task 8, the contribution differences between the middle and other contexts are more obvious than those in BioNLP-ST 2016 Task BB3. This may be because the middle context of a sentence in SemEval-2010 Task 8 is usually much longer than the other two contexts and key words or phrases for relation classification often occur in the middle context. By contrast, since the dataset of BioNLP-ST 2016 Task BB3 comes from biomedical publications, there are less key words or phrases to indicate relations obviously and relations are usually implicit in all the contexts.\n5.2. What does the middle context capture?\nPrior work [11], [15], [16], [18] has proved that the shortest dependency path (SDP) between two target entities is effective for semantic relation classification, since the words along the SDP concentrate on most relevant information while diminishing less relevant noise. In this subsection, we investigate the relevance between the middle context and SDP. A case study is illustrated in Figure 3. The middle context consists of five words, namely “was carefully wrapped into the”. By contrast, the SDP between two target entities in the dependency tree, consists of only two words, namely “wrapped into”. The middle context captures the information of SDP but also includes some noise.\nTo further prove this, we performs some statistic experiments to count the numbers of words in the middle contexts, in the SDPs and occurring in both of them. The experimental steps in SemEval-2010 Task 8 are as follows. First of all, we use Stanford CoreNLP toolkit [34] to perform dependency parsing for all the 8,000 sentences in the training set. Secondly, the SDP between two target entities is built for each sentence. Lastly, we count the numbers of words in the middle contexts (26940 words), in the SDPs (13360 words) and occurring in both of them (11054 words). As shown in Figure 4a, about 82% words in the SDPs occur in the middle contexts at the same time.\nThe experimental steps in BioNLP-ST 2016 Task BB3 are similar. We also use Stanford CoreNLP toolkit [34] to perform dependency parsing for all the 61 documents in the training set. However, there are some differences due to the characteristics of this dataset. Since entities may have more than one words, we use the last words of two target entities to find the SDP\nin the dependency tree. In addition, only a relation between two target entities that occur in the same sentence, is taken into account, since a dependency tree derives from only one sentence. The numbers of words in the middle contexts, in the SDPs and occurring in both of them are 1537, 769 and 466, respectively. As shown in Figure 4b, although the proportion is lower than that in SemEval-2010 Task 8, there are still more than half (61%) of words in the SDPs occurring in the middle contexts at the same time. In this dataset, the middle contexts include more words which are not in the SDPs. This may be because the dataset comes from biomedical publications, whose text is often very long with many symbols and numbers.\nFrom the statistic results of our experiments, we believe that the middle context captures most of information in the SDP. This suggests that the middle context can be used as an approximate replacement of SDP when high-cost dependency parsing is not used."
    }, {
      "heading" : "6. Conclusion",
      "text" : "We propose a Bi-LSTM-RNN model based on lowcost sequence features to address relation classification. Our motivation is that the relation between two target entities can be represented by the entities and contexts surrounding them. We avoid using structure features\nto make the model adapt for more domains. Experimental results on two benchmark datasets prove the effectiveness of our model, and its performance gets close to that of state-of-the-art models. By evaluating the contributions of different contexts, we find that the middle context plays the most important role in relation classification. Moreover, we also find that the middle context can replace the shortest dependency path approximately when dependency parsing is not used. In future work, how to reduce noisy information in contexts is worth studying."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "Relation classification is associated with many potential applications in the artificial intelligence area. Recent approaches usually leverage neural networks based on structure features such as syntactic or dependency features to solve this problem. However, high-cost structure features make such approaches inconvenient to be directly used. In addition, structure features are probably domaindependent. Therefore, this paper proposes a bidirectional long-short-term-memory recurrent-neuralnetwork (Bi-LSTM-RNN) model based on low-cost sequence features to address relation classification. This model divides a sentence or text segment into five parts, namely two target entities and their three contexts. It learns the representations of entities and their contexts, and uses them to classify relations. We evaluate our model on two standard benchmark datasets in different domains, namely SemEval-2010 Task 8 and BioNLP-ST 2016 Task BB3. In the former dataset, our model achieves comparable performance compared with other models using sequence features. In the latter dataset, our model obtains the third best results compared with other models in the official evaluation. Moreover, we find that the context between two target entities plays the most important role in relation classification. Furthermore, statistic experiments show that the context between two target entities can be used as an approximate replacement of the shortest dependency path when dependency parsing is not used.",
    "creator" : "LaTeX with hyperref package"
  }
}