{
  "name" : "1601.03754.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Dual-tree k-means with bounded iteration runtime",
    "authors" : [ "Ryan R. Curtin" ],
    "emails" : [ "ryan@ratml.org" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 1.\n03 75\n4v 1\n[ cs\n.D S]\n1 4\nJa n\n20 16"
    }, {
      "heading" : "1. Introduction",
      "text" : "Of all the clustering algorithms in use today, among the simplest and most utilized is the venerated kmeans clustering algorithm, usually implemented via Lloyd’s algorithm: given a dataset S, repeat the following two steps (a ‘Lloyd iteration’) until the centroids of each of the k clusters converge:\n1. Assign each point pi ∈ S to the cluster with nearest centroid.\n2. Recalculate the centroids for each cluster using the assignments of each point in S.\nClearly, a simple implementation of this algorithm will take O(kN) time where N = |S|. However, the number of iterations is not bounded unless the practitioner manually sets a maximum, and k-means is not guaranteed to converge to the global best clustering. Despite these shortcomings, in practice k-means tends to quickly converge to reasonable solutions. Even"
    }, {
      "heading" : "Submitted to the 33 rd International Conference on Machine",
      "text" : "Learning (ICML ’16). Copyright 2016 by the author.\nso, there is no shortage of techniques for improving the clusters k-means converges to: refinement of initial centroids (Bradley & Fayyad, 1998) and weighted sampling of initial centroids (Arthur & Vassilvitskii, 2007) are just two of many popular existing strategies.\nThere are also a number of methods for accelerating the runtime of a single iteration of k-means. In general, these ideas use the triangle inequality to prune work during the assignments step. Algorithms of this sort include the work of Pelleg and Moore (1999), Elkan (2003), Hamerly (2010), and Ding et al. (2015). However, the scaling of these algorithms can make them problematic for the case of large k and large N .\nIn this paper, we describe a dual-tree k-means algorithm tailored to the large k and largeN case that outperforms all competing algorithms in that setting; this dual-tree algorithm also has bounded single-iteration runtime in some situations (see Section 6). This algorithm, which is our main contribution, has several appealing aspects:\n• Empirical efficiency. In the large k and large N setting for which this algorithm is designed, it outperforms all other alternatives, and scales better to larger datasets. The algorithm is especially efficient in low dimensionality.\n• Runtime guarantees. Using adaptive runtime analysis techniques, we bound the single-iteration runtime of our algorithm with respect to the intrinsic dimensionality of the centroids and data, when cover trees are used. This gives theoretical support for the use of our algorithm in large data settings. In addition, the bound is dependent on the intrinsic dimensionality, not the extrinsic dimensionality.\n• Generalizability. We develop our algorithm using a tree-independent dual-tree algorithm abstraction (Curtin et al., 2013b); this means that our algorithm may be used with any type of valid tree. This includes not just kd-trees but also metric trees, cone trees, octrees, and others. Different trees may be suited to different types of data, and since our algorithm is general, one may use any type of tree as a plug-and-play parameter.\n• Separation of concerns. The abstraction we use to develop our algorithm allows us to focus on and formalize each of the pruning rules individually (Section 4). This aids understanding of the algorithm and eases insertion of future improvements and better pruning rules.\nSection 2 shows the relevance of the large k case; then, in Section 3, we show that we can build a tree on the k clusters, and then a dual-tree algorithm (Curtin et al., 2013b) can be used to efficiently perform an exact single iteration of k-means clustering. Section 4 details the four pruning strategies used in our algorithm, and Section 5 introduces the algorithm itself. Sections 6 and 7 show the theoretical and empirical results for the algorithm, and finally Section 8 concludes the paper and paints directions for future improvements.\n2. Scaling k-means\nAlthough the original publications on k-means only applied the algorithm to a maximum dataset size of 760 points, the half-century of relentless progress since then has seen dataset sizes scale into billions. Due to its simplicity, though, k-means has remained relevant, and is still applied in many large-scale applications.\nIn cases where N scales but k remains small, a good choice of algorithm is a sampling algorithm, which will return an approximate clustering. One sampling technique, coresets, can produce good clusterings for n in the millions using several hundred or a few thousand points (Frahling & Sohler, 2008). However, for large k, the number of samples required to produce good clusterings can become prohibitive.\nFor large k, then, we turn to an alternative approach: accelerating exact Lloyd iterations. Existing techniques include the brute-force implementation, the blacklist algorithm (Pelleg & Moore, 1999), Elkan’s algorithm (2003), and Hamerly’s algorithm (2010), as well as the recent Yinyang k-means algorithm (Ding et al., 2015). The blacklist algorithm builds a kd-tree on the dataset and, while the tree is traversed, blacklists individual clusters that cannot be the closest cluster (the owner) of any descendant points of a node. Elkan’s algorithm maintains\nan upper bound and a lower bound on the distance between each point and centroid; Hamerly’s algorithm is a memory-efficient simplification of this technique. The Yinyang algorithm organizes the centroids into groups of about 10 (depending on algorithm parameters) using 5 iterations of k-means on the centroids followed by a single iteration of standard k-means on the points. Once groups are built, the Yinyang algorithm attempts to prune groups of centroids at a time using rules similar to Elkan and Hamerly’s algorithms.\nOf these algorithms, only Yinyang k-means considers centroids in groups at all, but it does not consider points in groups. On the other hand, the blacklist algorithm is the only algorithm that builds a tree on the points and is able to assign multiple points to a single cluster at once. So, although each algorithm has its own useful region, none of the four we have considered here are particularly suited to the case of large N and large k.\nTable 1 shows setup costs, worst-case per-iteration runtimes, and memory usage of each of these algorithms as well as the proposed dual-tree algorithm1. The expected runtime of the blacklist algorithm is, under some assumptions, O(k+k logN+N) per iteration. The expected runtime of Hamerly’s and Elkan’s algorithm is O(k2+αN) time, where α is the expected number of clusters visited by each point (in both Elkan and Hamerly’s results, α seems to be small).\nHowever, none of these algorithms are specifically tailored to the large k case, and the large k case is common. Pelleg and Moore (1999) report several hundred clusters in a subset of 800k objects from the SDSS dataset. Clusterings for n-body simulations on astronomical data often involve several thousand clusters (Kwon et al., 2010). Csurka et al. (2004) extract vocabularies from image sets using k-means with k ∼ 1000. Coates et al. (2011) show that k-means can work surprisingly well for unsupervised feature learning for images, using k as large as 4000 on 50000 images. Also, in text mining, datasets can have up to\n1The dual-tree algorithm worst-case runtime bound also depends on some assumptions on dataset-dependent constants. This is detailed further in Section 6.\n18000 unique labels (Bengio et al., 2010). Can and Ozkarahan (1990) suggest that the number of clusters in text data is directly related to the size of the vocabulary, suggesting k ∼ mN/t where m is the vocabulary size, n is the number of documents, and t is the number of nonzero entries in the term matrix. Thus, it is important to have an algorithm with favorable scaling properties for both large k and N ."
    }, {
      "heading" : "3. Tree-based algorithms",
      "text" : "The blacklist algorithm is an example of a single-tree algorithm: one tree (the reference tree) is built on the dataset, and then that tree is traversed. This approach is applicable to a surprising variety of other problems, too (Bentley, 1975; Moore, 1999; Curtin et al., 2013c). Following the blacklist algorithm, then, it is only natural to build a tree on the data points. Tree-building is (generally) a one-time O(N logN) cost and for largeN or k, the cost of tree building is often negligible compared to the time it takes to perform the clustering.\nThe speedup of the blacklist algorithm comes from the hierarchical nature of trees: during the algorithm, we may rule out a cluster centroid for many points at once. The same reason is responsible for the impressive speedups obtained for other single-tree algorithms, such as nearest neighbor search (Bentley, 1975; Liu et al., 2004). But for nearest neighbor search, the nearest neighbor is often required not just for a query point but instead a query set. This observation motivated the development of dual-tree algorithms, which also build a tree on the query set (the query tree) in order to share work across query points. Both trees are recursed in such a way that combinations of query nodes and reference nodes are visited. Pruning criteria are applied to these node combinations, and if a combination may be pruned, then the recursion does not continue in that direction.\nThis approach is applicable to k-means with large k: we may build a tree on the k cluster centroids, as well as a tree on the data points, and then we may rule out many centroids for many points at once.\nA recent result generalizes the class of dual-tree algorithms, simplifying their expression and development (Curtin et al., 2013b). Any dual-tree algorithm can be decomposed into three parts: a type of space tree, a pruning dual-tree traversal, and a point-to-point BaseCase() function and node-to-node Score() function that determines when pruning is possible. Precise definitions and details of the abstraction are given by Curtin et al. (2013b), but for our purposes, this means that we can describe a dual-tree k-means algorithm entirely with a straightforward BaseCase() function and\nScore() function. Any tree and any traversal can then be used to create a working dual-tree algorithm.\nThe two types of trees we will explicitly consider in this paper are the kd-tree and the cover tree (Beygelzimer et al., 2006), but it should be remembered that the algorithm as provided is sufficiently general to work with any other type of tree. Therefore, we standardize notation for trees: a tree is denoted with T , and a node in the tree is denoted by N . Each node in a tree may have children; the set of children of Ni is denoted Ci. In addition, each node may hold some points; this set of points is denoted Pi. Lastly, the set of descendant points of a node Ni is denoted Dpi . The descendant points are all points held by descendant nodes, and it is important to note that the set Pi is not equivalent to D p i . This notation is taken from Curtin et al. (2013b) and is detailed more comprehensively there. Lastly, we say that a centroid c owns a point p if c is the closest centroid to p."
    }, {
      "heading" : "4. Pruning strategies",
      "text" : "All of the existing accelerated k-means algorithms operate by avoiding unnecessary work via the use of pruning strategies. Thus, we will pursue four pruning strategies, each based on or related to earlier work (Pelleg & Moore, 1999; Elkan, 2003; Hamerly, 2010).\nThese pruning strategies are meant to be used during the dual-tree traversal, for which we have built a query tree Tq on the points and a reference tree Tr on the centroids. Therefore, these pruning strategies consider not just combinations of single points and centroid pq and ci, but the combination of sets of points and sets of centroids, represented by a query tree node Nq and a centroid tree node Nr. This allows us to prune many centroids for many points simultaneously.\nStrategy one. When visiting a particular combination (Nq,Nr) (with Nq holding points in the dataset and Nr holding centroids), the combination should be pruned if every descendant centroid in Nr can be shown to own none of the points in Nq. If we have cached an upper bound ub(Nq) on the distance between any descendant point of Nq and its nearest cluster centroid that satisfies\nub(Nq) ≥ max pq∈D p q d(pq, cq) (1)\nwhere cq is the cluster centroid nearest to point pq, then the node Nr can contain no centroids that own any descendant points of Nq if\ndmin(Nq,Nr) > ub(Nq). (2)\nThis relation bears similarity to the pruning rules\nfor nearest neighbor search (Curtin et al., 2013b) and max-kernel search (Curtin & Ram, 2014). Figure 1a shows a situation where Nr can be pruned; in this case, ball-shaped tree nodes are used, and the upper bound ub(Nq) is set to dmax(Nq,Nr2).\nStrategy two. The recursion down a particular branch of the query tree should terminate early if we can determine that only one cluster can possibly own all of the descendant points of that branch. This is related to the first strategy. If we have been caching the number of pruned centroids (call this pruned(Nq)), as well as the identity of any arbitrary non-pruned centroid (call this closest(Nq)), then if pruned(Nq) = k − 1, we may conclude that the centroid closest(Nq) is the owner of all descendant points of Nq, and there is no need for further recursion in Nq.\nStrategy three. The traversal should not visit nodes whose owner could not have possibly changed between iterations; that is, the tree should be coalesced to include only nodes whose owners may have changed.\nThere are two easy ways to use the triangle inequality to show that the owner of a point cannot change between iterations. Figures 1b and 1c show the first: we have a point pq with owner cj and second-closest centroid ck. Between iterations, each centroid will move when it is recalculated; define the distance that centroid ci has moved asmi. Then we bound the distances for the next iteration: d(pq, cj)+mj is an upper bound on the distance from pq to its owner next iteration, and d(pq, ck) − maxi mi is a lower bound on the distance from pq to its second closest centroid next iteration. We may use these bounds to conclude that if\nd(pq, cj) +mj < d(pq, ck)−max i mi, (3)\nthen the owner of pq next iteration must be cj . Generalizing from individual points pq to tree nodes Nq is easy. This pruning strategy can only be used when all descendant points of Nq are owned by a single centroid, and in order to perform the prune, we need to establish a lower bound on the distance between any descendant point of the node Nq and the second closest centroid. Call this bound lb(Nq). Remember that ub(Nq) provides an upper bound on the distance between any descendant point of Nq and its nearest centroid. Then, if all descendant points of Nq are owned\nby some cluster cj in one iteration, and\nub(Nq) +mj < lb(Nq)−max i mi, (4)\nthen Nq is owned by cluster cj in the next iteration. Implementationally, it is convenient to have lb(Nq) store a lower bound on the distance between any descendant point of Nq and the nearest pruned centroid. Then, if Nr is entirely owned by one cluster, all other centroids are pruned, and lb(Nq) holds the necessary lower bound for pruning according to the rule above.\nThe second way to use the triangle inequality to show that an owner cannot change depends on the distances between centroids. Suppose that pq is owned by cj at the current iteration; then, if\nd(pq, cj)−mj < 2\n(\nmin ci∈C,ci 6=cj d(ci, cj)\n)\n(5)\nthen cj will own pq next iteration (Elkan, 2003). We may adapt this rule to tree nodes Nq in the same way as the previous rule; if Nq is owned by cluster cj during this iteration and\nub(Nq) +mj < 2\n(\nmin ci∈C,ci 6=cj d(ci, cj)\n)\n(6)\nthen Nq is owned by cluster cj in the next iteration. Note that the above rules do work with individual points pq instead of nodes Nq if we have a valid upper bound ub(pq) and a valid lower bound lb(pq). Any nodes or points that satisfy the above conditions do not need to be visited during the next iteration, and can be removed from the tree for the next iteration.\nStrategy four. The traversal should use bounding information from previous iterations; for instance, ub(Nq) should not be reset to ∞ at the beginning of each iteration. Between iterations, we may update ub(Nq), ub(pq), lb(Nq), and lb(pq) according to the following rules:\nub(Nq) ←\n\n   \n   \nub(Nq) +mj if Nq is\nowned by a single cluster cj\nub(Nq) + maximi if Nq is\nnot owned by a single cluster,\n(7)\nub(pq) ← ub(pq) +mj , (8)\nlb(Nq) ← lb(Nq)−max i mi, (9)\nlb(pq) ← lb(pq)−max i mi. (10)\nSpecial handling is required when descendant points of Nq are not owned by a single centroid (Equation 7). It is also true that for a child node Nc of Nq, ub(Nq) is a valid upper bound for Nc and lb(Nq) is a valid lower bound for Nc: that is, the upper and lower bounds may be taken from a parent, and they are still valid.\n5. The dual-tree k-means algorithm\nThese four pruning strategies lead to a high-level kmeans algorithm, described in Algorithm 1. During the course of this algorithm, to implement each of our pruning strategies, we will need to maintain the following quantities:\n• ub(Nq): an upper bound on the distance between any descendant point of a node Nq and the nearest centroid to that point.\n• lb(Nq): a lower bound on the distance between any descendant point of a node Nq and the nearest pruned centroid.\n• pruned(Nq): the number of centroids pruned during traversal for Nq.\n• closest(Nq): if pruned(Nq) = k−1, this holds the owner of all descendant points of Nq.\n• canchange(Nq): whether or not Nq can change owners next iteration.\n• ub(pq): an upper bound on the distance between point pq and its nearest centroid.\n• lb(pq): a lower bound on the distance between point pq and its second nearest centroid.\n• closest(pq): the closest centroid to pq (this is also the owner of pq).\n• canchange(pq): whether or not pq can change owners next iteration.\nAt the beginning of the algorithm, each upper bound is initialized to ∞, each lower bound is initialized to ∞, pruned(·) is initialized to 0 for each node, and closest(·) is initialized to an invalid centroid for each node and point. canchange(·) is set to true for each node and point. Thus line 6 does nothing on the first iteration.\nFirst, consider the dual-tree algorithm called on line 9. As detailed earlier, we can describe a dual-tree algorithm as a combination of tree type, traversal, and point-to-point BaseCase() and node-to-node Score() functions. Thus, we need only present BaseCase() (Algorithm 2) and Score() (Algorithm 3)2.\n2In these algorithms, we assume that any point present in a node Ni will also be present in at least one child Nc ∈ Ci. It is possible to fully generalize to any tree type, but the exposition is significantly more complex, and our assumption covers most standard tree types anyway.\nAlgorithm 1 High-level outline of dual-tree k-means.\n1: Input: dataset S ∈ RN×d, initial centroids C ∈ Rk×d. 2: Output: converged centroids C.\n3: T ← a tree built on S 4: while centroids C not converged do 5: {Remove nodes in the tree if possible.} 6: T ← CoalesceNodes(T ) 7: Tc ← a tree built on C\n8: {Call dual-tree algorithm.} 9: Perform a dual-tree recursion with T , Tc,\nBaseCase(), and Score().\n10: {Restore the tree to its non-coalesced form.} 11: T ← DecoalesceNodes(T )\n12: {Update centroids and bounding information.} 13: C ← UpdateCentroids(T ) 14: T ← UpdateTree(T ) 15: return C\nThe BaseCase() function is simple: given a point pq and a centroid cr, the distance d(pq, cr) is calculated; ub(pq), lb(pq), and closest(pq) are updated if needed.\nScore() is more complex. The first stanza (lines 4–6) takes the values of pruned(·) and lb(·) from the parent node of Nq; this is necessary to prevent pruned(·) from undercounting. Next, we prune if the owner of Nq is already known (line 7). If the minimum distance between any descendant point of Nq and any descendant centroid of Nr is greater than ub(Nq), then we may prune the combination (line 16). In that case we may also improve the lower bound (line 14). Note the special handling in line 15: our definition of tree allows points to be held in more than one node; thus, we must avoid double-counting clusters that we prune.3. If the node combination cannot be pruned in this way, an attempt is made to update the upper bound (lines 17–20). Instead of using dmax(Nq,Nr), we may use a tighter upper bound: select any descendant centroid c from Nr and use dmax(Nq, c). This still provides a valid upper bound, and in practice is generally smaller than dmax(Nq,Nr). We simply set closest(Nq) to c (line 20); closest(Nq) only holds the owner of Nq if all centroids except one are pruned—in which case the owner must be c.\nThus, at the end of the dual-tree algorithm, we know the owner of every node (if it exists) via closest(·) and pruned(·), and we know the owner of every point\n3For trees like the kd-tree and the metric tree, which do not hold points in more than one node, no special handling is required: we will never prune a cluster twice for a given query node Nq .\nAlgorithm 2 BaseCase() for dual-tree k-means.\n1: Input: query point pq, reference centroid cr 2: Output: distance between pq and cr\n3: if d(pq, cr) < ub(pq) then 4: lb(pq) ← ub(pq) 5: ub(pq) ← d(pq, cr) 6: closest(pq) ← cr 7: else if d(pq, cr) < lb(pq) then 8: lb(pq) ← d(pq, cr)\n9: return d(pq, cr)\nAlgorithm 3 Score() for dual-tree k-means.\n1: Input: query node Nq, reference node Nr 2: Output: score for node combination (Nq,Nr), or\n∞ if the combination can be pruned\n3: {Update the number of pruned nodes, if needed.} 4: if Nq not yet visited and is not the root node then 5: pruned(Nq) ← parent(Nq) 6: lb(Nq) ← lb(parent(Nq)) 7: if pruned(Nq) = k − 1 then return ∞\n8: s ← dmin(Nq,Nr) 9: c ← any descendant cluster centroid ofNr\n10: if dmin(Nq,Nr) > ub(Nq) then 11: {This cluster node owns no descendant points.} 12: if dmin(Nq,Nr) < lb(Nq) then 13: {Improve the lower bound for pruned nodes.} 14: lb(Nq) ← dmin(Nq,Nr) 15: pruned(Nq) += |D p r \\ {clusters not pruned}|"
    }, {
      "heading" : "16: s ← ∞",
      "text" : "17: else if dmax(Nq, c) < ub(Nq) then 18: {We may improve the upper bound.} 19: ub(Nq) ← dmax(Nq,Nr) 20: closest(Nq) ← c\n21: {Check if all clusters (except one) are pruned.} 22: if pruned(Nq) = k − 1 then return ∞\n23: return s\nvia closest(·). A simple algorithm to do this is given here as Algorithm 4 (UpdateCentroids()); it is a depth-first recursion through the tree that terminates a branch when a node is owned by a single cluster.\nNext is updating the bounds in the tree and determining if nodes and points can change owners next iteration; this work is encapsulated in the UpdateTree() algorithm, which is an implementation of strategies 3 and 4 (see the appendix for details). Once UpdateTree() sets the correct value of canchange(·) for every point and node, we coalesce the tree for the next iteration with the CoalesceTree() function. Coalescing the tree is straightforward: we simply re-\nAlgorithm 4 UpdateCentroids().\n1: Input: tree T built on dataset S 2: Output: new centroids C\n3: C := {c0, . . . , ck−1} ← 0 k×d; n = 0k\n4: {s is a stack.} 5: s ← {root(T )} 6: while |s| > 0 do 7: Ni ← s.pop() 8: if pruned(Ni) = k − 1 then 9: {The node is entirely owned by a cluster.}\n10: j ← index of closest(Ni) 11: cj ← cj + |D p i | centroid(Ni) 12: nj ← nj + |D p i | 13: else 14: {The node is not entirely owned by a cluster.} 15: if |Ci| > 0 then s.push(Ci) 16: else 17: for pi ∈ Pi not yet considered 18: j ← index of closest(pi) 19: cj ← cj + pi; nj ← nj + 1\n20: for ci ∈ C, if ni > 0 then ci ← ci/ni 21: return C\nmove any nodes from the tree where canchange(·) is false. This leaves a smaller tree with no nodes where canchange(·) is false. Decoalescing the tree (DecoalesceTree()) is done by restoring the tree to its original state. See the appendix for more details."
    }, {
      "heading" : "6. Theoretical results",
      "text" : "Space constraints allow us to only provide proof sketches for the first two theorems here. Detailed proofs are given in the appendix.\nTheorem 1. A single iteration of dual-tree k-means as given in Algorithm 1 will produce exactly the same results as the brute-force O(kN) implementation.\nProof. (Sketch.) First, we show that the dual-tree algorithm (line 9) produces correct results for ub(·), lb(·), pruned(·), and closest(·) for every point and node. Next, we show that UpdateTree() maintains the correctness of those four quantities and only marks canchange(·) to false when the node or point truly cannot change owner. Next, it is easily shown that CoalesceTree() and DecoalesceTree() do not affect the results of the dual-tree algorithm because the only nodes and points removed are those where canchange(·) = false. Lastly, we show that UpdateCentroids() produces centroids correctly.\nNext, we consider the runtime of the algorithm. Our results are with respect to the expansion constant ck of the centroids (Beygelzimer et al., 2006), which is a measure of intrinsic dimension. cqk is a related quan-\ntity: the largest expansion constant of C plus any point in the dataset. Our results also depend on the imbalance of the tree it(T ), which in practice generally scales linearly in N (Curtin et al., 2015). As with the other theoretical results, more detail on each of these quantities is available in the appendix.\nTheorem 2. When cover trees are used, a single iteration of dual-tree k-means as in Algorithm 1 can be performed in O(c4kc 5 qk(N + it(T )) + c 9 kk log k) time.\nProof. (Sketch.) Cover trees have O(N) nodes (Beygelzimer et al., 2006); because CoalesceTree(), DecoalesceTree(), UpdateCentroids(), and UpdateTree() can be performed in one pass of the tree, these steps may each be completed in O(N) time. Building a tree on the centroids takes O(c6kk log k) time, where ck is the expansion constant of the centroids. Recent results show that dual-tree algorithms that use the cover tree may have their runtime easily bounded (Curtin et al., 2015). We may observe that our pruning rules are at least as tight as nearest neighbor search; this means that the dual-tree algorithm (line 11) may be performed in O(c9kr(N + it(T ))) time. Also, we must perform nearest neighbor search on the centroids, which costs O(c9k(k + it(T))) time. This gives a total per-iteration runtime of O(c9kr(N + it(T )) + c 6 kk log k + c 9 kit(Tk)). This result holds intuitively. By building a tree on the centroids, we are able to prune many centroids at once, and as a result the amortized cost of finding the nearest centroid to a point is O(1). This meshes with earlier theoretical results (Beygelzimer et al., 2006; Curtin et al., 2015; Ram et al., 2009a) and earlier empirical results (Gray & Moore, 2003; 2001) that suggest that an answer can be obtained for a single query point in O(1) time. Note that this worst-case bound depends on the intrinsic dimension (the expansion constant) of the centroids, ck, and the related quantity cqk. If the intrinsic dimension of the centroids is low— that is, if the centroids are distributed favorably—the dual-tree algorithm will be more efficient.\nHowever, this bound is generally quite loose in practice. First, runtime bounds for cover trees are known to be loose (Curtin et al., 2015). Second, this particular bound does not consider the effect of coalescing the tree. In any given iteration, especially toward the end of the k-means clustering, most points will have canchange(·) = false and thus the coalesced tree will be far smaller than the full tree built on all N points.\nTheorem 3. Algorithm 1 uses no more than O(N+k) memory when cover trees are used.\nProof. This proof is straightforward. A cover tree on N points takes O(N) space. So the trees and asso-\nciated bounds take O(N) and O(k) space. Also, the dataset and centroids take O(N) and O(k) space."
    }, {
      "heading" : "7. Experiments",
      "text" : "The next thing to consider is the empirical performance of the algorithm. We use the publicly available kmeans program in mlpack (Curtin et al., 2013a); in our experiments, we run it as follows:\n$ kmeans -i dataset.csv -I centroids.csv -c\n$k -v -e -a $algorithm\nwhere $k is the number of clusters and $algorithm is the algorithm to be used. Each algorithm is implemented in C++. For the yinyang algorithm, we use the authors’ implementation. We use a variety of k values on mostly real-world datasets; details are shown in Table 2 (Lichman, 2013; Zhang et al., 1997; Lupton et al., 2001). The table also contains the time taken to build a kd-tree (for blacklist and dualtree-kd) and a cover tree (for dualtree-ct). Cover trees are far more complex to build than kdtrees; this explains the long cover tree build time. Even so, the tree only needs to be built once during the kmeans run. If results are required for multiple values of k—such as in the X-means algorithm (Pelleg & Moore, 2000)—then the tree built on the points may be reused.\nClusters were initialized using the Bradley-Fayyad refined start procedure (1998); however, this was too slow for the very large datasets, so in those cases points were randomly sampled as the initial centroids. kmeans was then run until convergence on each dataset. These simulations were performed on a modest consumer desktop with an Intel i5 with 16GB RAM, using mlpack’s benchmarking system (Edel et al., 2014).\nAverage runtime per iteration results are shown in Table 3. The amount of work that is being pruned away is somewhat unclear from the runtime results, because the elkan and hamerly algorithms access points linearly and thus benefit from cache effects; this is not true of the tree-based algorithms. Therefore, the average number of distance calculations per iteration are also included in the results.\nIt is immediately clear that for large datasets, dualtree-kd is fastest, and dualtree-ct is almost as fast. The elkan algorithm, because it holds kN bounds, is able to prune away a huge amount of work and is very fast for small datasets; however, maintaining all of these bounds becomes prohibitive with large k and the algorithm exhausts all available memory. The blacklist algorithm has the same issue: on the largest datasets, with the largest k values, the space required to maintain all the blacklists is too much. This is also true of the yinyang algorithm, which must maintain bounds between each point and each group of centroids. For large k, this burden becomes too much and the algorithm fails. The hamerly and dual-tree algorithms, on the other hand, are the best-behaved with memory usage and do not have any issues with large N or large k; however, the hamerly algorithm is very slow on large datasets because it is not able to prune many points at once.\nSimilar to the observations about the blacklist algorithm, the tree-based approaches are less effective in higher dimensions (Pelleg & Moore, 1999). This is an important point: the performance of tree-based approaches suffer in high dimensions in part because the bound dmin(·, ·) generally becomes looser as dimension increases. This is partly because the volume of nodes in high dimensions is much higher; consider that a ball has volume that is exponential in the dimension.\nEven so, in our results, we see speedup in reasonable dimensions (for example, the phy dataset has 78 dimensions). Further, because our algorithm is treeindependent, we may use tree structures that are tailored to high-dimensional data (Arya et al., 1998)—\nincluding ones that have not yet been developed. From our results we believe as a rule of thumb that the dualtree k-means algorithm can be effective up to a hundred dimensions or more.\nAnother clear observation is that when k is scaled on a single dataset, the dualtree-kd and dualtree-ct algorithms nearly always scale better (in terms of runtime) than the other algorithms. These results show that our algorithm satisfies its original goals: to be able to scale effectively to large k and N ."
    }, {
      "heading" : "8. Conclusion and future directions",
      "text" : "Using four pruning strategies, we have developed a flexible, tree-independent dual-tree k-means algorithm that is the best-performing algorithm for large datasets and large k in small-to-medium dimensions. It is theoretically favorable, has a small memory footprint, and may be used in conjunction with initial point selection and approximation schemes for additional speedup.\nThere are still interesting future directions to pursue, though. The first direction is parallelism: because our dual-tree algorithm is agnostic to the type of traversal used, we may use a parallel traversal (Curtin et al., 2013b), such as an adapted version of a recent parallel dual-tree algorithm (Lee et al., 2012). The second direction is kernel k-means and other spectral clustering techniques: our algorithm may be merged with the ideas of Curtin & Ram (2014) to perform kernel k-means. The third direction is theoretical. Recently, more general notions of intrinsic dimensionality have been proposed (Houle, 2013; Amsaleg et al., 2015); these may enable tighter and more descriptive runtime bounds. Our work thus provides a useful and\nfast k-means algorithm and also opens promising avenues to further accelerated clustering algorithms."
    }, {
      "heading" : "A. Supplementary material",
      "text" : "Unfortunately, space constraints prevent adequate explanation of each of the points in the main paper. This supplementary material is meant to clarify all of the parts of the dual-tree k-means algorithm that space did not permit in the main paper."
    }, {
      "heading" : "A.1. Updating the tree",
      "text" : "In addition to updating the centroids, the bounding information contained within the tree must be updated according to pruning strategies 3 and 4. Unfortunately, this yields a particularly complex recursive algorithm, given in Algorithm 5.\nThe first if statement (lines 4–10) catches the case where the parent cannot change owner next iteration; in this case, the parent’s upper bound and lower bound can be taken as valid bounds. In addition, the upper and lower bounds are adjusted to account for cluster movement between iterations, so that the bounds are valid for next iteration.\nIf the node Ni has an owner, the algorithm then attempts to use the pruning rules established in Equations 4 and 6 in the main paper, to determine if the owner of Ni can change next iteration. If not, canchange(Ni) is set to false (line 18). On the other hand, if the pruning check fails, the upper bound is tightened and the pruning check is performed a second time. It is worth noting that dmax(Ni, cj) may not actually be less than the current value of ub(Ni), which is why the min is necessary.\nAfter recursing into the children of Ni, if Ni could have an owner change, each point is individually checked using the same approach (lines 31–45). However, there\nAlgorithm 5 UpdateTree() for dual-tree k-means.\n1: Input: node Ni, ub(·), lb(·), pruned(·), closest(·), canchange(·), centroid movements m 2: Output: updated ub(·), lb(·), pruned(·), canchange(·)\n3: canchange(Ni) ← true 4: if Ni has a parent and canchange(parent(Ni)) = false then 5: {Use the parent’s bounds.} 6: closest(Ni) ← closest(parent(Ni)) 7: j ← index of closest(Ni) 8: ub(Ni) ← ub(Ni) +mj 9: lb(Ni) ← lb(Ni) + maximi\n10: canchange(Ni) ← false 11: else if pruned(Ni) = k − 1 then 12: {Ni is owned by a single cluster. Can that owner change next iteration?} 13: j ← index of closest(Ni) 14: ub(Ni) ← ub(Ni) +mj 15: lb(Ni) ← max (lb(Ni)−maxi mi,mink 6=j d(ck, cj)/2) 16: if ub(Ni) < lb(Ni) then 17: {The owner cannot change next iteration.} 18: canchange(Ni) ← false 19: else 20: {Tighten the upper bound and try to prune again.} 21: ub(Ni) ← min (ub(Ni), dmax(Ni, cj)) 22: if ub(Ni) < lb(Ni) then canchange(Ni) ← false 23: else 24: j ← index of closest(Ni) 25: ub(Ni) ← ub(Ni) +mj 26: lb(Ni) ← lb(Ni)−maxk mk 27: {Recurse into each child.} 28: for each child Nc of Ni, call UpdateTree(Nc) 29: {Try to determine points whose owner cannot change if Ni can change owners.} 30: if canchange(Ni) = true then 31: for pi ∈ Pi do 32: j ← index of closest(pi) 33: ub(pi) ← ub(pi) +mj 34: lb(pi) ← min (lb(pi)−maxk mk,mink 6=j d(ck, cj)/2) 35: if ub(pi) < lb(pi) then 36: canchange(pi) ← false 37: else 38: {Tighten the upper bound and try again.} 39: ub(pi) ← min (ub(pi), d(pi, cj)) 40: if ub(pi) < lb(pi) then 41: canchange(pi) ← false 42: else 43: {Point cannot be pruned.} 44: ub(pi) ← ∞ 45: lb(pi) ← ∞ 46: else 47: for pi ∈ Pi where canchange(pi) = false do 48: {Maintain upper and lower bounds for points whose owner cannot change.} 49: j ← index of closest(pi) 50: ub(pi) ← ub(pi) +mj 51: lb(pi) ← lb(pi)−maxk mk 52: if canchange(·) = false for all children Nc of Ni and all points pi ∈ Pi then 53: canchange(Ni) ← false 54: if canchange(Ni) = true then 55: pruned(Ni) ← 0\nAlgorithm 6 CoalesceTree() for dual-tree k-means.\n1: Input: tree T 2: Output: coalesced tree T\n3: {A depth-first recursion to hide nodes where canchange(·) is false.} 4: s ← {root(T )} 5: while |s| > 0 do 6: Ni ← s.pop()\n7: {Special handling is required for leaf nodes and the root node.} 8: if |Ci| = 0 then 9: continue\n10: else if Ni is the root node then 11: for Nc ∈ Ci do 12: s.push(Nc)\n13: {See if children can be removed.} 14: for Nc ∈ Ci do 15: if canchange(Nc) = false then 16: remove child Nc 17: else 18: s.push(Nc)\n19: {If only one child is left, then this node is unnecessary.} 20: if |Ci| = 1 then 21: add child to parent(Ni) 22: remove Ni from parent(Ni)’s children\n23: return T\nis a slight difference: if a point’s owner can change, the upper and lower bounds must be set to ∞ (lines 44– 45). This is only necessary with points; BaseCase() does not take bounding information from previous iterations into account, because no work can be avoided in that way.\nThen, we may set canchange(Ni) to false if every point in Ni and every child of Ni cannot change owners (and the points and nodes do not necessarily have to have the same owner). Otherwise, we must set pruned(Ni) to 0 for the next iteration."
    }, {
      "heading" : "A.2. Coalescing the tree",
      "text" : "After UpdateTree() is called, the tree must be coalesced to remove any nodes where canchange(·) = false. This can be accomplished via a single pass over the tree. A simple implementation is given in Algorithm 6. DecoalesceTree() may be implemented by simply restoring a pristine copy of the tree which was cached right before CoalesceTree() is called."
    }, {
      "heading" : "A.3. Correctness proof",
      "text" : "As mentioned in the main document, a correctness proof is possible but difficult. We will individually prove the correctness of various pieces of the dual-tree k-means algorithm, and then we will prove the main correctness result. For precision, we must introduce the exact definition of a space tree and a pruning dualtree traversal, as given by Curtin et al. (Curtin et al., 2013b).\nDefinition 1. A space tree on a dataset S ∈ ℜN×D is an undirected, connected, acyclic, rooted simple graph with the following properties:\n• Each node (or vertex), holds a number of points (possibly zero) and is connected to one parent node and a number of child nodes (possibly zero).\n• There is one node in every space tree with no parent; this is the root node of the tree.\n• Each point in S is contained in at least one node.\n• Each node N has a convex subset of ℜD containing each point in that node and also the convex subsets represented by each child of the node.\nDefinition 2. A pruning dual-tree traversal is a process that, given two space trees Tq (the query tree, built on the query set Sq) and Tr (the reference tree, built on the reference set Sr), will visit combinations of nodes (Nq,Nr) such that Nq ∈ Tq and Nr ∈ Tr no more than once, and call a function Score(Nq, Nr) to assign a score to that node. If the score is ∞ (or above some bound), the combination is pruned and no combinations (Nqc, Nrc) such that Nqc ∈ D n q and Nrc ∈ D n r are visited. Otherwise, for every combination of points (pq, pr) such that pq ∈ Pq and pr ∈ Pr, a function BaseCase(pq, pr) is called. If no node combinations are pruned during the traversal, BaseCase(pq, pr) is called at least once on each combination of pq ∈ Sq and pr ∈ Sr.\nFor more description and clarity on these definitions, refer to (Curtin et al., 2013b).\nLemma 1. A pruning dual-tree traversal which uses BaseCase() as given in Algorithm 2 in the main paper and Score() as given in Algorithm 3 in the main paper which starts with valid ub(·), lb(·), pruned(·), and closest(·) for each node Ni ∈ T , and ub(pq) = lb(pq) = ∞ for each point pq ∈ S, will satisfy the following conditions upon completion:\n• For every pq ∈ S that is a descendant of a node Ni that has been pruned (pruned(Ni) = k − 1), ub(Ni) is an upper bound on the distance between\npq and its closest centroid, and closest(Ni) is the owner of pq.\n• For every pq ∈ S that is not a descendant of any node that has been pruned, ub(pq) is an upper bound on the distance between pq and its closest centroid, and closest(pq) is the owner of pq.\n• For every pq ∈ S that is a descendant of a node Ni that has been pruned (pruned(Ni) = k − 1), lb(Ni) is a lower bound on the distance between pq and its second closest centroid.\n• For every pq ∈ S that is not a descendant of any node that has been pruned, min(lb(pq), lb(Nq)) where Nq is a node such that pq ∈ Pq is a lower bound on the distance between pq and its second closest centroid.\nProof. It is easiest to consider each condition individually. Thus, we will first consider the upper bound on the distance to the closest cluster centroid. Consider some pq and suppose that the closest cluster centroid to pq is c ∗.\nNow, suppose first that the point pq is a descendant point of a node Nq that has been pruned. We must show, then, that c∗ is closest(Nq). Take R = {Nr0,Nr1, . . . ,Nrj} to be the set of reference nodes visited during the traversal with Nq as a query node; that is, the combinations (Nq,Nri) were visited for all Nri ∈ R. Any Nri is pruned only if\ndmin(Nq,Nri) > ub(Ni) (11)\naccording to line 10 of Score(). Thus, as long as ub(Ni) is a valid upper bound on the closest cluster distance for every descendant point in Nq, then no nodes are incorrectly pruned. It is easy to see that the upper bound is valid: initially, it is valid by assumption; each time the bound is updated with some node Nri (on lines 19 and 20), it is set to dmax(Ni, c) where c is some descendant centroid of Nri. This is clearly a valid upper bound, since c cannot be any closer to any descendant point of Ni than c\n∗. We may thus conclude that no node is incorrectly pruned from R; we may apply this reasoning recursively to the Nq’s ancestors to see that no reference node is incorrectly pruned.\nWhen a node is pruned from R, the number of pruned clusters for Nq is updated: the count of all clusters not previously pruned by Nq (or its ancestors) is added. We cannot double-count the pruning of a cluster; thus the only way that pruned(Nq) can be equal to k − 1 is if every centroid except one is pruned. The centroid\nwhich is not pruned will be the nearest centroid c∗, regardless of if closest(Nq) was set during this traversal or still holds its initial value, and therefore it must be true that ub(Nq) is an upper bound on the distance between pq and c ∗, and closest(Nq) = c ∗.\nThis allows us to finally conclude that if pq is a descendant of a node Nq that has been pruned, then ub(Nq) contains a valid upper bound on the distance between pq and its closest cluster centroid, and closest(Nq) is that closest cluster centroid.\nNow, consider the other case, where pq is not a descendant of any node that has been pruned. Take Ni to be any node containing pq\n4. We have already reasoned that any cluster centroid node that could possibly contain the closest cluster centroid to pq cannot have been pruned; therefore, by the definition of pruning dualtree traversal, we are guaranteed that BaseCase() will be called with pq as the query point and the closest cluster centroid as the reference point. This will then cause ub(pq) to hold the distance to the closest cluster centroid—assuming ub(pq) is always valid, which it is even at the beginning of the traversal because it is initialized to ∞—and closest(pq) to hold the closest cluster centroid.\nTherefore, the first two conditions are proven. The third and fourth conditions, for the lower bounds, require a slightly different strategy.\nThere are two ways lb(Nq) is modified: first, at line 14, when a node combination is pruned, and second, at line 6 when the lower bound is taken from the parent. Again, consider the set R = {Nr0,Nr1, . . . ,Nrj} which is the set of reference nodes visited during the traversal with Nq as a query node. Call the set of reference nodes that were pruned Rp. At the end of the traversal, then,\nlb(Nq) ≤ min Nri∈Rp dmin(Nq,Nri) (12)\n≤ min ck∈Cp dmin(Nq, ck) (13)\nwhere Cp is the set of centroids that are descendants of nodes in Rp. Applying this reasoning recursively to the ancestors of Nq shows that at the end of the dual-tree traversal, lb(Nq) will contain a lower bound on the distance between any descendant point of Nq and any pruned centroid. Thus, if pruned(Nq) = k−1, then lb(Nq) will contain a lower bound on the distance between any descendant point in Nq and its second closest centroid. So if we consider some point pq which\n4Note that the meaning here is not that pq is a descendant of Ni (pi ∈ D p\ni ), but instead that pq is held directly in Ni: pq ∈ Pi.\nis a descendant of Nq and Nq is pruned (pruned(Nq) = k − 1), then lb(Nq) is indeed a lower bound on the distance between pq and its second closest centroid.\nNow, consider the case where pq is not a descendant of any node that has been pruned, and take Nq to be some node that owns pq (that is, pq ∈ Pq). In this case, BaseCase() will be called with every centroid that has not been pruned. So lb(Nq) is a lower bound on the distance between pq and every pruned centroid, and lb(pq) will be a lower bound on the distance between pq and the second-closest non-pruned centroid, due to the structure of the BaseCase() function. Therefore, min(lb(pq), lb(Nq)) must be a lower bound on the distance between pq and its second closest centroid.\nFinally, we may conclude that each item in the theorem holds.\nNext, we must prove that UpdateTree() functions correctly.\nLemma 2. In the context of Algorithm 1 in the main paper, given a tree T with all associated bounds ub(·) and lb(·) and information pruned(·), closest(·), and canchange(·), a run of UpdateTree() as given in Algorithm 5 will have the following effects:\n• For every node Ni, ub(Ni) will be a valid upper bound on the distance between any descendant point of Ni and its nearest centroid next iteration.\n• For every node Ni, lb(Ni) will be a valid lower bound on the distance between any descendant point of Ni and any pruned centroid next iteration.\n• A node Ni will only have canchange(Ni) = false if the owner of any descendant point of Ni cannot change next iteration.\n• A point pi will only have canchange(pi) = false if the owner of pi cannot change next iteration.\n• Any point pi with canchange(pi) = true that does not belong to any node Ni with canchange(Ni) = false will have ub(pi) = lb(pi) = ∞, as required by the dual-tree traversal.\n• Any node Ni with canchange(Ni) = false at the end of UpdateTree() will have pruned(Ni) = 0.\nProof. Each point is best considered individually. It is important to remember during this proof that the centroids have been updated, but the bounds have not.\nSo any cluster centroid ci is already set for next iteration. Take cli to mean the cluster centroid ci before adjustment (that is, the old centroid). Also take ubl(·), lbl(·), prunedl(·), and canchangel(·) to be the values at the time UpdateTree() is called, before any of those values are changed. Due to the assumptions in the statement of the lemma, each of these quantities is valid.\nSuppose that for some node Ni, closest(Ni) is some cluster cj . For ub(Ni) to be valid for next iteration, we must guarantee that ub(Ni) ≥ maxpq∈Dpq d(pq, cj) at the end of UpdateTree(). There are four ways ub(Ni) is updated: it may be taken from the parent and adjusted (line 8), it may be adjusted before a prune attempt (line 14), it may be tightened after a failed prune attempt (line 21), or it may be adjusted without a prune attempt (line 25). If we can show that each of these four ways always results in ub(Ni) being valid, then the first condition of the theorem holds.\nIf ub(Ni) is adjusted in line 14 or 25, the resulting value of ub(Ni), assuming closest(Ni) = cj , is\nub(Ni) = ub l(Ni) +mj (14)\n≥ max pq∈D p q\nd(pq, c l j) +mj (15)\n≥ max pq∈D p q d(pq, cj) (16)\nwhere the last step follows by the triangle inequality: d(cj , c l j) = mj . Therefore those two updates to ub(Ni) result in valid upper bounds for next iteration. If ub(Ni) is recalculated, in line 21, then we are guaranteed that ub(Ni) is valid because\ndmax(Ni, cj) ≥ max pq∈D p q d(pq, cj). (17)\nWe may therefore conclude that ub(Ni) is correct for the root of the tree, because line 8 can never be reached. Reasoning recursively, we can see that any upper bound passed from the parent must be valid. Therefore, the first item of the lemma holds.\nNext, we will consider the lower bound, using a similar strategy. We must show that\nlb(Ni) ≤ min pq∈D p q min cp∈Cp d(pq, cp) (18)\nwhere Cp is the set of centroids pruned by Ni and ancestors during the last dual-tree traversal. The lower bound can be taken from the parent in line 9 and adjusted, it can be adjusted before a prune attempt in line 15 or in a similar way without a prune attempt in line 26. The last adjustment can easily be shown to be valid:\nlb(Ni) = lb l(Ni)−max\nk mk (19)\n≤\n(\nmin pq∈D p q min cp∈Cp\nd(pq, c l p)\n)\n−max k mk(20)\n≤ min pq∈D p q min cp∈Cp d(pq, cp) (21)\nwhich follows by the triangle inequality: d(clp, cp) ≤ maxk mk. Line 15 is slightly more complex; we must also consider the term mink 6=j d(ck, cj)/2. Suppose that\nmin k 6=j\nd(ck, cj)/2 > lb l(Ni) + max\nk mk. (22)\nWe may use the triangle inequality (d(pq, ck) ≤ d(cj , ck) + d(pq, cj)) to show that if this is true, the second closest centroid ck is such that d(pq, ck) > 2d(ck, cj) and therefore mink 6=j d(ck, cj)/2 is also a valid lower bound. We can lastly use the same recursive argument from the upper bound case to show that the second item of the lemma holds.\nShowing the correctness of canchange(Ni) is straightforward: we know that ub(Ni) and lb(Ni) are valid for next iteration by the time any checks to set canchange(Ni) to false happens, due to the discussion above. The situations where canchange(Ni) is set to false, in line 18 and 22, are simply applications of Equations 4 and 6 in the main paper, and are therefore valid. There are two other ways canchange(Ni) can be set to false. The first is on line 10, and this is easily shown to be valid: if a parent’s owner cannot change, then a child’s owner cannot change either. The other way to set canchange(Ni) to false is in line 53. This is only possible if all points in Pi and all children of Ni have canchange(·) set to false; thus, no descendant point of Ni can change owner next iteration, and we may set canchange(Ni) to false.\nNext, we must show that canchange(pi) = false only if the owner of pi cannot change next iteration. If canchangel(pi) = true, then due to Lemma 1, ub\nl(pi) and lbl(pi) will be valid bounds. In this case, we may use similar reasoning to show that ub(pi) and lb(pi) are valid, and then we may see that the pruning attempts at line 35 and 40 are valid. Now, consider the other case, where canchangel(pi) = false. Then, ub\nl(pi) and lbl(pi) will not have been modified by the dual-tree traversal, and will hold the values set in the previous run of UpdateTree(). As long as those values are valid, then the fourth item holds.\nThe checks to see if canchange(pi) can be set to false (from lines 31 to 45) are only reached if canchange(Ni)\nis true. We already have shown that ub(pi) and lb(pi) are set correctly in that stanza. The other case is if canchange(Ni) is false. In this case, lines 47 to 51 are reached. It is easy to see using similar reasoning to all previous cases that these lines result in valid ub(pi) and lb(pi). Therefore, the fourth item does hold.\nThe fifth item is taken care of in line 44 and 45. Given some point pi with canchange(pi) = true, and where pi does not belong to any node Ni where canchange(Ni) = false, these two lines must be reached, and therefore the fifth item holds.\nThe last item holds trivially—any node Ni where canchange(Ni) = true has pruned(Ni) set to 0 on line 55.\nShowing that CoalesceTree(), DecoalesceTree(), and UpdateCentroids() function correctly follows directly from the algorithm descriptions. Therefore, we are ready to show the main correctness result.\nTheorem 4. A single iteration of dual-tree k-means as given in Algorithm 1 in the main paper will produce exactly the same results as the standard bruteforce O(kN) implementation.\nProof. We may use the previous lemmas to flesh out our earlier proof sketch.\nFirst, we know that the dual-tree algorithm (line 9) produces correct results for ub(·), lb(·), pruned(·), and closest(·) for every point and node, due to Lemma 1. Next, we know that UpdateTree() maintains the correctness of those four quantities and only marks canchange(·) to false when the node or point truly cannot change owner, due to Lemma 2. Next, we know from earlier discussion that CoalesceTree() and DecoalesceTree() do not affect the results of the dual-tree algorithm because the only nodes and points removed are those where canchange(·) = false. We also know that UpdateCentroids() produces centroids correctly. Therefore, the results from Algorithm 1 in the main paper are identical to those of a bruteforce O(kN) k-means implementation.\nA.4. Runtime bound proof\nWe can use adaptive algorithm analysis techniques in order to bound the running time of Algorithm 1 in the main paper, based on (Curtin et al., 2015) and (Beygelzimer et al., 2006). This analysis depends on the expansion constant, which is a measure of intrinsic dimension defined below, originally from (Karger & Ruhl, 2002).\nDefinition 3. Let BS(p,∆) be the set of points in S\nwithin a closed ball of radius ∆ around some p ∈ S with respect to a metric d:\nBS(p,∆) = {r ∈ S : d(p, r) ≤ ∆}. (23)\nThen, the expansion constant of S with respect to the metric d is the smallest c ≥ 2 such that\n|BS(p, 2∆)| ≤ c|BS(p,∆)| ∀ p ∈ S, ∀ ∆ > 0. (24)\nThe expansion constant is a bound on the number of points which fall into balls of increasing sizes. A low expansion constant generally means that search tasks like nearest neighbor search can be performed quickly with trees, whereas a high expansion constant implies a difficult dataset. Thus, if we assume a bounded expansion constant like in previous theoretical works (Beygelzimer et al., 2006; Ram et al., 2009a; Karger & Ruhl, 2002; Curtin & Ram, 2014; Curtin et al., 2015), we may assemble a runtime bound that reflects the difficulty of the dataset.\nOur theoretical analysis will concern the cover tree in particular. The cover tree is a complex data structure with appealing theoretical properties. We will only summarize the relevant properties here. Interested readers should consult the original cover tree paper (Beygelzimer et al., 2006) and later analyses (Ram et al., 2009a; Curtin et al., 2015) for a complete understanding.\nA cover tree is a leveled tree; that is, each cover tree node Ni is associated with an integer scale si. The node with largest scale is the root of the tree; each node’s scale is greater than its children’s. Each node Ni holds one point pi, and every descendant point of Ni is contained in the ball centered at pi with radius 2sr+1. Further, every cover tree satisfies the following three invariants (Beygelzimer et al., 2006):\n• (Nesting.) When a point pi is held in a node at some scale si, then each smaller scale will also have a node containing pi.\n• (Covering tree.) For every point pi held in a node Ni at scale si, there exists a node with point pj and scale si + 1 which is the parent of Ni, and d(pi, pj) < 2 si+1.\n• (Separation.) Given distinct nodes Ni holding pi and Nj holding pj both at scale si, d(pi, pj) > 2 si .\nA useful result shows there are O(N) points in a cover tree (Theorem 1, (Beygelzimer et al., 2006)). Another measure of importance of a cover tree is the cover tree\nimbalance, which aims to capture how well the data is distributed throughout the cover tree. For instance, consider a tree where the root, with scale sr, has two nodes; one node corresponds to a single point and has scale −∞, and the other node has scale sr−1 and contains every other point in the dataset as a descendant. This is very imbalanced, and a tree with many situations like this will not perform well for search tasks. Below, we reiterate the definition of cover tree imbalance from (Curtin et al., 2015).\nDefinition 4. The cover node imbalance in(Ni) for a cover tree node Ni with scale si in the cover tree T is defined as the cumulative number of missing levels between the node and its parent Np (which has scale sp). If the node is a leaf child (that is, si = −∞), then number of missing levels is defined as the difference between sp and smin−1 where smin is the smallest scale of a non-leaf node in T . If Ni is the root of the tree, then the cover node imbalance is 0. Explicitly written, this calculation is\nin(Ni) =\n\n      \n     \nsp − si − 1 if Ni is not a\nleaf and not\nthe root node\nmax(sp − smin − 1, 0) if Ni is a leaf\n0 if Ni is the root. (25)\nThis simple definition of cover node imbalance is easy to calculate, and using it, we can generalize to a measure of imbalance for the full tree.\nDefinition 5. The cover tree imbalance it(T ) for a cover tree T is defined as the cumulative number of missing levels in the tree. This can be expressed as a function of cover node imbalances easily:\nit(T ) = ∑\nNi∈T\nin(Ni). (26)\nBounding it(T ) is non-trivial, but empirical results suggest that imbalance scales linearly with the size of the dataset, when the expansion constant is wellbehaved. A bound on it(T ) is still an open problem at the time of this writing.\nWith these terms introduced, we may introduce a slightly adapted result from (Curtin et al., 2015), which bounds the running time of nearest neighbor search.\nTheorem 5. (Theorem 2, (Curtin et al., 2015).) Using cover trees, the standard cover tree pruning dual-tree traversal, and the nearest neighbor search\nBaseCase() and Score() as given in Algorithms 2 and 3 of (Curtin et al., 2015), respectively, and also given a reference set Sr with expansion constant cr, and a query set Sq, where the range of pairwise distances in Sr is completely contained in the range of pairwise distances in Sq, the running time of nearest neighbor search is bounded by O(c4rc 5 qr(N + it(Tq))), where cqr = max((maxpq∈Sq c ′ r), cr), where c ′ r is the expansion constant of the set Sr ∪ {pq}.\nNow, we may adapt this result slightly.\nTheorem 6. The dual-tree k-means algorithm with BaseCase() as in Algorithm 2 in the main paper and Score() as in Algorithm 3 in the main paper, with a point set Sq that has expansion constant cq and size N , and k centroids C with expansion constant ck, takes no more than O(c4kc 5 qk(N + it(Tq))) time.\nProof. Both Score() and BaseCase() for dual-tree kmeans can be performed in O(1) time. In addition, the pruning of Score() for dual-tree k-means is at least as tight as Score() for nearest neighbor search: the pruning rule in Equation 2 in the main paper is equivalent to the pruning rule for nearest neighbor search. Therefore, dual-tree k-means can visit no more nodes than nearest neighbor search would with query set Sq and reference set C. Lastly, note that the range of pairwise distances of C will be entirely contained in the range of pairwise distances in Sq, to see that we can use the result of Theorem 5. Adapting that result, then, yields the statement of the algorithm.\nThe expansion constant of the centroids, ck, may be understood as the intrinsic dimensionality of the centroids C. During each iteration, the centroids change, so those iterations that have centroids with high intrinsic dimensionality cannot be bounded as tightly. More general measures of intrinsic dimensionality, such as those recently proposed by Houle (Houle, 2013), may make the connection between cq and ck clear.\nNext, we turn to bounding the entire algorithm.\nTheorem 7. A single iteration of the dual-tree kmeans algorithm on a dataset Sq using the cover tree T , the standard cover tree pruning dual-tree traversal, BaseCase() as given in Algorithm 2 in the main paper, Score() as given in Algorithm 3 in the main paper, will take no more than\nO(c4kc 5 qk(N + it(T )) + c 9 kk log k) (27)\ntime, where ck is the expansion constant of the centroids, cqk is defined as in Theorem 6, and it(T ) is the imbalance of the tree as defined in Definition 5.\nProof. Consider each of the steps of the algorithm individually:\n• CoalesceNodes() can be performed in a single pass of the cover tree N , which takes O(N) time.\n• Building a tree on the centroids (Tc) takes O(c6kk log k) time due to the result for cover tree construction time (Beygelzimer et al., 2006).\n• The dual-tree algorithm takes O(c4kc 5 qk(N +\nit(T ))) time due to Theorem 6.\n• DecoalesceNodes() can be performed in a single pass of the cover tree N , which takes O(N) time.\n• UpdateCentroids() can be performed in a single pass of the cover tree N , so it also takes O(N) time.\n• UpdateTree() depends on the calculation of how much each centroid has moved; this costs O(k) time. In addition, we must find the nearest centroid of every centroid; this is nearest neighbor search, and we may use the runtime bound for monochromatic nearest neighbor search for cover trees from (Ram et al., 2009a), so this costs O(c9kk) time. Lastly, the actual tree update visits each node once and iterates over each point in the node. Cover tree nodes only hold one point, so each visit costs O(1) time, and with O(N) nodes, the entire update process costs O(N) time. When we consider the preprocessing cost too, the total cost of UpdateTree() per iteration is O(c9kk+N).\nWe may combine these into a final result:\nO(N) +O(c6kk log k) +O(c 4 kc 5 qk(N + it(T ))) +\nO(N) +O(N) +O(c9kk +N) (28)\nand after simplification, we get the statement of the theorem:\nO(c4kc 5 qk(N + it(T )) + c 9 kk log k). (29)\nTherefore, we see that under some assumptions on the data, we can bound the runtime of the dual-tree k-means algorithm to something tighter than O(kN) per iteration. As expected, we are able to amortize the cost of k across all N nodes, giving amortized O(1) search for the nearest centroid per point in the dataset. This is similar to the results for nearest neighbor search, which obtain amortized O(1) search for a\nsingle query point. Also similar to the results for nearest neighbor search is that the search time may, in the worst case, degenerate to O(kN + k2) when the assumptions on the dataset are not satisfied. However, empirical results (Ram et al., 2009b; Gray & Moore, 2001; March et al., 2010; Beygelzimer et al., 2006) show that well-behaved datasets are common in the real world, and thus degeneracy of the search time is uncommon.\nComparing this bound with the bounds for other algorithms is somewhat difficult; first, none of the other algorithms have bounds which are adaptive to the characteristics of the dataset. It is possible that the blacklist algorithm could be refactored to use the cover tree, but even if that was done it is not completely clear how the running time could be bounded. How to apply the expansion constant to an analysis of Hamerly’s algorithm and Elkan’s algorithm is also unclear at the time of this writing.\nLastly, the bound we have shown above is potentially loose. We have reduced dual-tree k-means to the problem of nearest neighbor search, but our pruning rules are tighter. Dual-tree nearest neighbor search assumes that every query node will be visited (this is where the O(N) in the bound comes from), but dual-tree kmeans can prune a query node entirely if all but one cluster is pruned (Strategy 2). These bounds do not take this pruning strategy into account, and they also do not consider the fact that coalescing the tree can greatly reduce its size. These would be interesting directions for future theoretical work."
    } ],
    "references" : [ {
      "title" : "k-means++: The advantages of careful seeding",
      "author" : [ "D. Arthur", "S. Vassilvitskii" ],
      "venue" : "In Proceedings of the 18th Annual ACM-SIAM Symposium on Discrete Algorithms,",
      "citeRegEx" : "Arthur and Vassilvitskii,? \\Q2007\\E",
      "shortCiteRegEx" : "Arthur and Vassilvitskii",
      "year" : 2007
    }, {
      "title" : "An optimal algorithm for approximate nearest neighbor searching in fixed dimensions",
      "author" : [ "S. Arya", "D.M. Mount", "N.S. Netanyahu", "R. Silverman", "A.Y. Wu" ],
      "venue" : "Journal of the ACM (JACM),",
      "citeRegEx" : "Arya et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Arya et al\\.",
      "year" : 1998
    }, {
      "title" : "Label embedding trees for large multi-class tasks",
      "author" : [ "S. Bengio", "J. Weston", "D. Grangier" ],
      "venue" : "In Advances in Neural Information Processing Systems 23 (NIPS ’10),",
      "citeRegEx" : "Bengio et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Bengio et al\\.",
      "year" : 2010
    }, {
      "title" : "Multidimensional binary search trees used for associative searching",
      "author" : [ "J.L. Bentley" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "Bentley,? \\Q1975\\E",
      "shortCiteRegEx" : "Bentley",
      "year" : 1975
    }, {
      "title" : "Cover trees for nearest neighbor",
      "author" : [ "A. Beygelzimer", "S.M. Kakade", "J. Langford" ],
      "venue" : "In Proceedings of the 23rd International Conference on Machine Learning (ICML",
      "citeRegEx" : "Beygelzimer et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Beygelzimer et al\\.",
      "year" : 2006
    }, {
      "title" : "Refining initial points for k-means clustering",
      "author" : [ "P.S. Bradley", "U.M. Fayyad" ],
      "venue" : "In Proceedings of the 15th International Conference on Machine Learning (ICML",
      "citeRegEx" : "Bradley and Fayyad,? \\Q1998\\E",
      "shortCiteRegEx" : "Bradley and Fayyad",
      "year" : 1998
    }, {
      "title" : "Concepts and effectiveness of the cover-coefficient-based clustering methodology for text databases",
      "author" : [ "F. Can", "E.A. Ozkarahan" ],
      "venue" : "ACM Transactions on Database Systems,",
      "citeRegEx" : "Can and Ozkarahan,? \\Q1990\\E",
      "shortCiteRegEx" : "Can and Ozkarahan",
      "year" : 1990
    }, {
      "title" : "An analysis of single-layer networks in unsupervised feature learning",
      "author" : [ "A. Coates", "A.Y. Ng", "H. Lee" ],
      "venue" : "In Proceedings of AISTATS,",
      "citeRegEx" : "Coates et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Coates et al\\.",
      "year" : 2011
    }, {
      "title" : "Visual categorization with bags of keypoints",
      "author" : [ "G. Csurka", "C. Dance", "L. Fan", "J. Willamowski", "C. Bray" ],
      "venue" : "InWorkshop on Statistical Learning in Computer Vision, ECCV,",
      "citeRegEx" : "Csurka et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Csurka et al\\.",
      "year" : 2004
    }, {
      "title" : "Dual-tree fast exact max-kernel search",
      "author" : [ "R.R. Curtin", "P. Ram" ],
      "venue" : "Statistical Analysis and Data Mining,",
      "citeRegEx" : "Curtin and Ram,? \\Q2014\\E",
      "shortCiteRegEx" : "Curtin and Ram",
      "year" : 2014
    }, {
      "title" : "MLPACK: A scalable C++ machine learning library",
      "author" : [ "R.R. Curtin", "J.R. Cline", "N.P. Slagle", "W.B. March", "P. Ram", "N.A. Mehta", "A.G. Gray" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Curtin et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Curtin et al\\.",
      "year" : 2013
    }, {
      "title" : "Tree-independent dual-tree algorithms",
      "author" : [ "R.R. Curtin", "W.B. March", "P. Ram", "D.V. Anderson", "A.G. Gray", "C.L. Isbell Jr." ],
      "venue" : "In Proceedings of the 30th International Conference on Machine Learning (ICML",
      "citeRegEx" : "Curtin et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Curtin et al\\.",
      "year" : 2013
    }, {
      "title" : "Fast exact max-kernel search",
      "author" : [ "R.R. Curtin", "P. Ram", "A.G. Gray" ],
      "venue" : "In Proceedings of SIAM International Conference on Data Mining 2013 (SDM",
      "citeRegEx" : "Curtin et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Curtin et al\\.",
      "year" : 2013
    }, {
      "title" : "Plug-and-play dual-tree algorithm runtime analysis",
      "author" : [ "R.R. Curtin", "D. Lee", "W.B. March", "P. Ram" ],
      "venue" : "arXiv preprint arXiv:1501.05222,",
      "citeRegEx" : "Curtin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Curtin et al\\.",
      "year" : 2015
    }, {
      "title" : "An automatic benchmarking system",
      "author" : [ "M. Edel", "A. Soni", "R.R. Curtin" ],
      "venue" : "In Proceedings of the NIPS 2014 Workshop on Software Engineering for Machine Learning,",
      "citeRegEx" : "Edel et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Edel et al\\.",
      "year" : 2014
    }, {
      "title" : "Using the triangle inequality to accelerate k-means",
      "author" : [ "C. Elkan" ],
      "venue" : "In Proceedings of the 20th International Conference on Machine Learning (ICML ’03),",
      "citeRegEx" : "Elkan,? \\Q2003\\E",
      "shortCiteRegEx" : "Elkan",
      "year" : 2003
    }, {
      "title" : "A fast k-means implementation using coresets",
      "author" : [ "G. Frahling", "C. Sohler" ],
      "venue" : "International Journal of Computational Geometry & Applications,",
      "citeRegEx" : "Frahling and Sohler,? \\Q2008\\E",
      "shortCiteRegEx" : "Frahling and Sohler",
      "year" : 2008
    }, {
      "title" : "N-Body’ problems in statistical learning",
      "author" : [ "A.G. Gray", "A.W. Moore" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Gray and Moore,? \\Q2001\\E",
      "shortCiteRegEx" : "Gray and Moore",
      "year" : 2001
    }, {
      "title" : "Nonparametric density estimation: Toward computational tractability",
      "author" : [ "A.G. Gray", "A.W. Moore" ],
      "venue" : "In SIAM International Conference on Data Mining (SDM),",
      "citeRegEx" : "Gray and Moore,? \\Q2003\\E",
      "shortCiteRegEx" : "Gray and Moore",
      "year" : 2003
    }, {
      "title" : "Making k-means even faster",
      "author" : [ "G. Hamerly" ],
      "venue" : "In Proceedings of the 2010 SIAM International Conference on Data Mining, pp",
      "citeRegEx" : "Hamerly,? \\Q2010\\E",
      "shortCiteRegEx" : "Hamerly",
      "year" : 2010
    }, {
      "title" : "Dimensionality, discriminability, density and distance distributions",
      "author" : [ "M.E. Houle" ],
      "venue" : "IEEE 13th International Conference on Data Mining Workshops (ICDMW),",
      "citeRegEx" : "Houle,? \\Q2013\\E",
      "shortCiteRegEx" : "Houle",
      "year" : 2013
    }, {
      "title" : "Finding nearest neighbors in growth-restricted metrics",
      "author" : [ "D.R. Karger", "M. Ruhl" ],
      "venue" : "In Proceedings of the Thirty-Fourth Annual ACM Symposium on Theory of Computing (STOC",
      "citeRegEx" : "Karger and Ruhl,? \\Q2002\\E",
      "shortCiteRegEx" : "Karger and Ruhl",
      "year" : 2002
    }, {
      "title" : "Scalable clustering algorithm for n-body simulations in a shared-nothing cluster",
      "author" : [ "Y.C. Kwon", "D. Nunley", "J.P. Gardner", "M. Balazinska", "B. Howe", "S. Loebman" ],
      "venue" : "In Scientific and Statistical Database Management,",
      "citeRegEx" : "Kwon et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kwon et al\\.",
      "year" : 2010
    }, {
      "title" : "A distributed kernel summation framework for general-dimension machine learning",
      "author" : [ "D. Lee", "R.W. Vuduc", "A.G. Gray" ],
      "venue" : "In Proceedings of the 2012 SIAM International Conference on Data Mining (SDM",
      "citeRegEx" : "Lee et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2012
    }, {
      "title" : "An investigation of practical approximate nearest neighbor algorithms",
      "author" : [ "T. Liu", "A.W. Moore", "K. Yang", "A.G. Gray" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Liu et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Liu et al\\.",
      "year" : 2004
    }, {
      "title" : "The SDSS imaging pipelines",
      "author" : [ "R. Lupton", "J.E. Gunn", "Z. Ivezic", "G.R. Knapp", "S. Kent" ],
      "venue" : "In Astronomical Data Analysis Software and Systems X,",
      "citeRegEx" : "Lupton et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Lupton et al\\.",
      "year" : 2001
    }, {
      "title" : "Very fast em-based mixture model clustering using multiresolution kd-trees",
      "author" : [ "A.W. Moore" ],
      "venue" : "Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Moore,? \\Q1999\\E",
      "shortCiteRegEx" : "Moore",
      "year" : 1999
    }, {
      "title" : "Accelerating exact kmeans algorithms with geometric reasoning",
      "author" : [ "D. Pelleg", "A.W. Moore" ],
      "venue" : "In Proceedings of KDD",
      "citeRegEx" : "Pelleg and Moore,? \\Q1999\\E",
      "shortCiteRegEx" : "Pelleg and Moore",
      "year" : 1999
    } ],
    "referenceMentions" : [ {
      "referenceID" : 24,
      "context" : "Algorithms of this sort include the work of Pelleg and Moore (1999), Elkan (2003), Hamerly (2010), and Ding et al.",
      "startOffset" : 55,
      "endOffset" : 68
    }, {
      "referenceID" : 15,
      "context" : "Algorithms of this sort include the work of Pelleg and Moore (1999), Elkan (2003), Hamerly (2010), and Ding et al.",
      "startOffset" : 69,
      "endOffset" : 82
    }, {
      "referenceID" : 15,
      "context" : "Algorithms of this sort include the work of Pelleg and Moore (1999), Elkan (2003), Hamerly (2010), and Ding et al.",
      "startOffset" : 69,
      "endOffset" : 98
    }, {
      "referenceID" : 15,
      "context" : "Algorithms of this sort include the work of Pelleg and Moore (1999), Elkan (2003), Hamerly (2010), and Ding et al. (2015). However, the scaling of these algorithms can make them problematic for the case of large k and large N .",
      "startOffset" : 69,
      "endOffset" : 122
    }, {
      "referenceID" : 15,
      "context" : "Existing techniques include the brute-force implementation, the blacklist algorithm (Pelleg & Moore, 1999), Elkan’s algorithm (2003), and Hamerly’s algorithm (2010), as well as the recent Yinyang k-means algorithm (Ding et al.",
      "startOffset" : 108,
      "endOffset" : 133
    }, {
      "referenceID" : 15,
      "context" : "Existing techniques include the brute-force implementation, the blacklist algorithm (Pelleg & Moore, 1999), Elkan’s algorithm (2003), and Hamerly’s algorithm (2010), as well as the recent Yinyang k-means algorithm (Ding et al.",
      "startOffset" : 108,
      "endOffset" : 165
    }, {
      "referenceID" : 22,
      "context" : "Clusterings for n-body simulations on astronomical data often involve several thousand clusters (Kwon et al., 2010).",
      "startOffset" : 96,
      "endOffset" : 115
    }, {
      "referenceID" : 23,
      "context" : "Pelleg and Moore (1999) report several hundred clusters in a subset of 800k objects from the SDSS dataset.",
      "startOffset" : 11,
      "endOffset" : 24
    }, {
      "referenceID" : 7,
      "context" : "Csurka et al. (2004) extract vocabularies from image sets using k-means with k ∼ 1000.",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 7,
      "context" : "Coates et al. (2011) show that k-means can work surprisingly well for unsupervised feature learning for images, using k as large as 4000 on 50000 images.",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 2,
      "context" : "18000 unique labels (Bengio et al., 2010).",
      "startOffset" : 20,
      "endOffset" : 41
    }, {
      "referenceID" : 2,
      "context" : "18000 unique labels (Bengio et al., 2010). Can and Ozkarahan (1990) suggest that the number of clusters in text data is directly related to the size of the vocabulary, suggesting k ∼ mN/t where m is the vocabulary size, n is the number of documents, and t is the number of nonzero entries in the term matrix.",
      "startOffset" : 21,
      "endOffset" : 68
    }, {
      "referenceID" : 3,
      "context" : "This approach is applicable to a surprising variety of other problems, too (Bentley, 1975; Moore, 1999; Curtin et al., 2013c).",
      "startOffset" : 75,
      "endOffset" : 125
    }, {
      "referenceID" : 26,
      "context" : "This approach is applicable to a surprising variety of other problems, too (Bentley, 1975; Moore, 1999; Curtin et al., 2013c).",
      "startOffset" : 75,
      "endOffset" : 125
    }, {
      "referenceID" : 3,
      "context" : "The same reason is responsible for the impressive speedups obtained for other single-tree algorithms, such as nearest neighbor search (Bentley, 1975; Liu et al., 2004).",
      "startOffset" : 134,
      "endOffset" : 167
    }, {
      "referenceID" : 24,
      "context" : "The same reason is responsible for the impressive speedups obtained for other single-tree algorithms, such as nearest neighbor search (Bentley, 1975; Liu et al., 2004).",
      "startOffset" : 134,
      "endOffset" : 167
    }, {
      "referenceID" : 10,
      "context" : "A recent result generalizes the class of dual-tree algorithms, simplifying their expression and development (Curtin et al., 2013b). Any dual-tree algorithm can be decomposed into three parts: a type of space tree, a pruning dual-tree traversal, and a point-to-point BaseCase() function and node-to-node Score() function that determines when pruning is possible. Precise definitions and details of the abstraction are given by Curtin et al. (2013b), but for our purposes, this means that we can describe a dual-tree k-means algorithm entirely with a straightforward BaseCase() function and Score() function.",
      "startOffset" : 109,
      "endOffset" : 448
    }, {
      "referenceID" : 4,
      "context" : "The two types of trees we will explicitly consider in this paper are the kd-tree and the cover tree (Beygelzimer et al., 2006), but it should be remembered that the algorithm as provided is sufficiently general to work with any other type of tree.",
      "startOffset" : 100,
      "endOffset" : 126
    }, {
      "referenceID" : 4,
      "context" : "The two types of trees we will explicitly consider in this paper are the kd-tree and the cover tree (Beygelzimer et al., 2006), but it should be remembered that the algorithm as provided is sufficiently general to work with any other type of tree. Therefore, we standardize notation for trees: a tree is denoted with T , and a node in the tree is denoted by N . Each node in a tree may have children; the set of children of Ni is denoted Ci. In addition, each node may hold some points; this set of points is denoted Pi. Lastly, the set of descendant points of a node Ni is denoted D i . The descendant points are all points held by descendant nodes, and it is important to note that the set Pi is not equivalent to D p i . This notation is taken from Curtin et al. (2013b) and is detailed more comprehensively there.",
      "startOffset" : 101,
      "endOffset" : 774
    }, {
      "referenceID" : 15,
      "context" : "Thus, we will pursue four pruning strategies, each based on or related to earlier work (Pelleg & Moore, 1999; Elkan, 2003; Hamerly, 2010).",
      "startOffset" : 87,
      "endOffset" : 137
    }, {
      "referenceID" : 19,
      "context" : "Thus, we will pursue four pruning strategies, each based on or related to earlier work (Pelleg & Moore, 1999; Elkan, 2003; Hamerly, 2010).",
      "startOffset" : 87,
      "endOffset" : 137
    }, {
      "referenceID" : 15,
      "context" : "then cj will own pq next iteration (Elkan, 2003).",
      "startOffset" : 35,
      "endOffset" : 48
    }, {
      "referenceID" : 4,
      "context" : "Our results are with respect to the expansion constant ck of the centroids (Beygelzimer et al., 2006), which is a measure of intrinsic dimension.",
      "startOffset" : 75,
      "endOffset" : 101
    }, {
      "referenceID" : 13,
      "context" : "Our results also depend on the imbalance of the tree it(T ), which in practice generally scales linearly in N (Curtin et al., 2015).",
      "startOffset" : 110,
      "endOffset" : 131
    }, {
      "referenceID" : 4,
      "context" : ") Cover trees have O(N) nodes (Beygelzimer et al., 2006); because CoalesceTree(), DecoalesceTree(), UpdateCentroids(), and UpdateTree() can be performed in one pass of the tree, these steps may each be completed in O(N) time.",
      "startOffset" : 30,
      "endOffset" : 56
    }, {
      "referenceID" : 13,
      "context" : "Recent results show that dual-tree algorithms that use the cover tree may have their runtime easily bounded (Curtin et al., 2015).",
      "startOffset" : 108,
      "endOffset" : 129
    }, {
      "referenceID" : 4,
      "context" : "This meshes with earlier theoretical results (Beygelzimer et al., 2006; Curtin et al., 2015; Ram et al., 2009a) and earlier empirical results (Gray & Moore, 2003; 2001) that suggest that an answer can be obtained for a single query point in O(1) time.",
      "startOffset" : 45,
      "endOffset" : 111
    }, {
      "referenceID" : 13,
      "context" : "This meshes with earlier theoretical results (Beygelzimer et al., 2006; Curtin et al., 2015; Ram et al., 2009a) and earlier empirical results (Gray & Moore, 2003; 2001) that suggest that an answer can be obtained for a single query point in O(1) time.",
      "startOffset" : 45,
      "endOffset" : 111
    }, {
      "referenceID" : 13,
      "context" : "First, runtime bounds for cover trees are known to be loose (Curtin et al., 2015).",
      "startOffset" : 60,
      "endOffset" : 81
    }, {
      "referenceID" : 25,
      "context" : "We use a variety of k values on mostly real-world datasets; details are shown in Table 2 (Lichman, 2013; Zhang et al., 1997; Lupton et al., 2001).",
      "startOffset" : 89,
      "endOffset" : 145
    }, {
      "referenceID" : 14,
      "context" : "These simulations were performed on a modest consumer desktop with an Intel i5 with 16GB RAM, using mlpack’s benchmarking system (Edel et al., 2014).",
      "startOffset" : 129,
      "endOffset" : 148
    }, {
      "referenceID" : 1,
      "context" : "Further, because our algorithm is treeindependent, we may use tree structures that are tailored to high-dimensional data (Arya et al., 1998)— including ones that have not yet been developed.",
      "startOffset" : 121,
      "endOffset" : 140
    }, {
      "referenceID" : 23,
      "context" : ", 2013b), such as an adapted version of a recent parallel dual-tree algorithm (Lee et al., 2012).",
      "startOffset" : 78,
      "endOffset" : 96
    }, {
      "referenceID" : 20,
      "context" : "Recently, more general notions of intrinsic dimensionality have been proposed (Houle, 2013; Amsaleg et al., 2015); these may enable tighter and more descriptive runtime bounds.",
      "startOffset" : 78,
      "endOffset" : 113
    }, {
      "referenceID" : 10,
      "context" : "The first direction is parallelism: because our dual-tree algorithm is agnostic to the type of traversal used, we may use a parallel traversal (Curtin et al., 2013b), such as an adapted version of a recent parallel dual-tree algorithm (Lee et al., 2012). The second direction is kernel k-means and other spectral clustering techniques: our algorithm may be merged with the ideas of Curtin & Ram (2014) to perform kernel k-means.",
      "startOffset" : 144,
      "endOffset" : 402
    } ],
    "year" : 2016,
    "abstractText" : "k-means is a widely used clustering algorithm, but for k clusters and a dataset size of N , each iteration of Lloyd’s algorithm costs O(kN) time. Although there are existing techniques to accelerate single Lloyd iterations, none of these are tailored to the case of large k, which is increasingly common as dataset sizes grow. We propose a dual-tree algorithm that gives the exact same results as standard k-means; when using cover trees, we use adaptive analysis techniques to, under some assumptions, bound the single-iteration runtime of the algorithm as O(N + k log k). To our knowledge these are the first subO(kN) bounds for exact Lloyd iterations. We then show that this theoretically favorable algorithm performs competitively in practice, especially for large N and k in low dimensions. Further, the algorithm is treeindependent, so any type of tree may be used.",
    "creator" : "LaTeX with hyperref package"
  }
}