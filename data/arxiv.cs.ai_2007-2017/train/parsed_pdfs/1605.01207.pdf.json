{
  "name" : "1605.01207.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Ontology-Mediated Queries: Combined Complexity and Succinctness of Rewritings via Circuit Complexity",
    "authors" : [ "MEGHYN BIENVENU", "MICHAEL ZAKHARYASCHEV" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 5.\n01 20\n7v 1\n[ cs\n.D B\n] 4\nM ay\n2 01\nKeywords: Ontology-Based Data Access, Description Logic, Ontology-Mediated Query, Query Rewriting, Succinctness, Computational Complexity, Circuit Complexity."
    }, {
      "heading" : "1 Introduction",
      "text" : ""
    }, {
      "heading" : "1.1 Ontology-based data access",
      "text" : "Ontology-based data access (OBDA) via query rewriting was proposed by Poggi et al. [62] with the aim of facilitating query answering over complex, possibly incomplete and heterogeneous data sources. In an OBDA system (see Fig. 1), the user does not have to be aware of the structure of data sources, which can be relational databases, spreadsheets, RDF triplestores, etc. Instead, the system provides the user with an ontology that serves as a high-level conceptual view of the data, gives a convenient vocabulary for user queries, and enriches incomplete data with background knowledge. A snippet, T , of such an ontology is shown below in the syntax of first-order (FO) logic:\n∀x ( ProjectManager(x) → ∃y (isAssistedBy(x, y) ∧ PA(y)) ) , ∀x ( ∃ymanagesProject(x, y) → ProjectManager(x) ) , ∀x ( ProjectManager(x) → Staff(x) ) , ∀x ( PA(x) → Secretary(x) ) .\nUser queries are formulated in the signature of the ontology. For example, the conjunctive query (CQ)\nq(x) = ∃y (Staff(x) ∧ isAssistedBy(x, y) ∧ Secretary(y)))\nis supposed to find the staff assisted by secretaries. The ontology signature and data schemas are related by mappings designed by the ontology engineer and invisible to the user. The mappings allow the system to view the data sources as a single RDF graph (a finite set of unary and binary atoms), A, in the signature of the ontology. For example, the global-as-view (GAV) mappings\n∀x, y, z ( PROJECT(x, y, z) → managesProject(x, z) ) , ∀x, y ( STAFF(x, y) ∧ (y = 2) → ProjectManager(x) )\npopulate the ontology predicates managesProject and ProjectManager with values from the database relations PROJECT and STAFF. In the query rewriting approach of Poggi et al. [62], the OBDA system employs the ontology and mappings in order to transform the user query into a query over the data sources, and then delegates the actual query evaluation to the underlying database engines and triplestores.\nFor example, the first-order query\nq′(x) = ∃y [ Staff(x) ∧ isAssistedBy(x, y) ∧ (Secretary(y) ∨ PA(y)) ] ∨\nProjectManager(x) ∨ ∃zmanagesProject(x, z)\nis an FO-rewriting of the ontology-mediated query (OMQ) Q = (T , q) over any RDF graph A in the sense that a is an answer to q′(x) over A iff q(a) is a logical consequence of T and A. As the system is not supposed to materialise A, it uses the mappings to unfold the rewriting q′ into an SQL (or SPARQL) query over the data sources. Ontology languages suitable for OBDA via query rewriting have been identified by the Description Logic, Semantic Web, and Database/Datalog communities. The DL-Lite family of description logics, first proposed by Calvanese et al. [20] and later extended by Artale et al. [4], was specifically designed to ensure the existence of FO-rewritings for all conjunctive queries (CQs). Based on this family, the W3C defined a profile OWL2QL1 of the Web Ontology Language OWL2 ‘so that data [. . . ] stored in a standard relational database system can be queried through an ontology via a simple rewriting mechanism.’ Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24]. We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54]. SPARQL 1.1, the standard query language for RDF graphs, contains negation, aggregation and other features beyond first-order logic. The entailment regimes of SPARQL 1.12 also bring inferencing capabilities in the setting, which are, however, necessarily limited for efficient implementations.\nBy reducing OMQ answering to standard database query evaluation, which is generally regarded to be very efficient, OBDA via query rewriting has quickly become a hot topic in both theory and practice. A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]). A\n1 http://www.w3.org/TR/owl2-overview/#Profiles 2 http://www.w3.org/TR/2013/REC-sparql11-entailment-20130321\nfew mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53]. By providing a semantic end-to-end connection between users and multiple distributed data sources (and thus making the IT expert middleman redundant), OBDA has attracted the attention of industry, with companies such as Siemens [46] and Statoil [45] experimenting with OBDA technologies to streamline the process of data access for their engineers.3"
    }, {
      "heading" : "1.2 Succinctness and complexity",
      "text" : "In this paper, our concern is two fundamental theoretical problems whose solutions will elucidate the computational costs required for answering OMQs with OWL2QL ontologies. The succinctness problem for FO-rewritings is to understand how difficult it is to construct FOrewritings for OMQs in a given class and, in particular, to determine whether OMQs in the class have polynomial-size FO rewritings or not. In other words, the succinctness problem clarifies the computational costs of the reduction of OMQ answering to database query evaluation. On the other hand, it is also important to measure the resources required to answer OMQs by a best possible algorithm, not necessarily a reduction to database query evaluation. Thus, we are interested in the combined complexity of the OMQ answering problem: given an OMQ Q = (T , q(x)) from a certain class, a data instance A and a tuple a of constants from A, decide whether T ,A |= q(a). The combined complexity of CQ evaluation has been thoroughly investigated in database theory; cf. [36, 56] and references therein. To slightly simplify the setting for our problems, we assume that data is given in the form of an RDF graph and leave mappings out of the picture (in fact, GAV mappings only polynomially increase the size of FO-rewritings over RDF graphs).\nWe suggest a ‘two-dimensional’ classification of OMQs. One dimension takes account of the shape of the CQs in OMQs by quantifying their treewidth (as in classical database theory) and the number of leaves in tree-shaped CQs. Note that, in SPARQL 1.1, the sub-queries that require rewriting under the OWL2QL entailment regime are always tree-shaped (they are, in essence, complex class expressions). The second dimension is the existential depth of ontologies, that is, the length of the longest chain of labelled nulls in the chase on any data. Thus, the NPD FactPages ontology,4 which was designed to facilitate querying the datasets of the Norwegian Petroleum Directorate,5 is of depth 5. A typical example of an ontology axiom causing infinite depth is ∀x ( Person(x) → ∃y (ancestor(y, x) ∧ Person(y)) ) .\n3 See, e.g., http://optique-project.eu. 4 http://sws.ifi.uio.no/project/npd-v2/ 5 http://factpages.npd.no/factpages/"
    }, {
      "heading" : "1.3 Results",
      "text" : "The results of our investigation are summarised in the succinctness and complexity landscapes of Fig. 2. In what follows, we discuss these results in more detail.\nThe succinctness problem we consider can be formalised as follows: given a sequence Qn (n < ω) of OMQs whose size is polynomial in n, determine whether the size of minimal rewritings of Qn can be bounded by a polynomial function in n. We distinguish between three types of rewritings: arbitrary FO-rewritings, positive existential (PE-) rewritings (in which only ∧, ∨ and ∃ are allowed), and non-recursive datalog (NDL-) rewritings.6 This succinctness problem was first considered by Kikot et al. [47] and Gottlob and Schwentick [35]. The former constructed a sequence Qn of OMQs (with tree-shaped CQs) whose PE- and NDL-rewritings are of exponential size, while FO-rewritings are superpolynomial unless NP ⊆ P/poly. Gottlob and Schwentick [35] and Gottlob et al. [31] showed that PE- (and so all other) ‘rewritings’ can be made polynomial under the condition that all relevant data instances contain two special constants. The ‘succinctification’ trick involves polynomially many extra existential quantifiers over these constants to guess a derivation of the given CQ in the chase, which makes such rewritings impractical (cf. NFAs vs DFAs, and [6]). In this paper, we stay within the classical OBDA setting that does not impose any extra conditions on the data and does not allow any special constants in rewritings.\nFigure 2 (a) gives a summary of the succinctness results obtained in this paper. It turns out that polynomial-size PE-rewritings are guaranteed to exist—in fact, can be constructed in polynomial time—only for the class of OMQs with ontologies of depth 1 and CQs of bounded treewidth; moreover, tree-shaped OMQs have polynomial-size Π4-PE-rewritings (with matrices of the form ∧∨∧∨). Polynomial-size NDL-rewritings can be efficiently constructed for all treeshaped OMQs with a bounded number of leaves, all OMQs with ontologies of bounded depth and CQs of bounded treewidth, and all OMQs with ontologies of depth 1. For OMQs with ontologies of depth 2 and arbitrary CQs, and OMQs with arbitrary ontologies and tree-shaped CQs, we have an exponential lower bound on the size of NDL- (and so PE-) rewritings. The existence of polynomial-size FO rewritings for all OMQs in each of these classes (save the first one) turns out to be equivalent to one of the major open problems in computational complexity such as NC1 = NP/poly.7\nWe obtain these results by establishing a connection between succinctness of rewritings and circuit complexity, a branch of computational complexity theory that classifies Boolean functions according to the size of circuits computing them. Our starting point is the observation that the tree-witness PE-rewriting of an OMQ Q = (T , q) introduced by [49] defines a hypergraph whose vertices are the atoms in q and whose hyperedges correspond to connected sub-queries of q that can be homomorphically mapped to labelled nulls of some chases for T . Based on this observation, we introduce a new computational model for Boolean functions by treating any hypergraphH , whose vertices are labelled by (possibly negated) Boolean variables or constants 0 and 1, as a program computing a Boolean function fH that returns 1 on a valuation for the variables iff there is an independent subset of hyperedges covering all vertices labelled by 0 (under the valuation). We show that constructing short FO- (respectively, PE- and NDL-) rewritings of Q is (nearly) equivalent to finding short Boolean formulas (respectively, monotone formulas and monotone circuits) computing the hypergraph function for Q.\nFor each of the OMQ classes in Fig. 2 (a), we characterise the computational power of the corresponding hypergraph programs and employ results from circuit complexity to identify the size of rewritings. For example, we show that OMQs with ontologies of depth 1 correspond to hypergraph programs of degree ≤ 2 (in which every vertex belongs to at most two hyperedges), and that the latter are polynomially equivalent to nondeterministic branching programs (NBPs). Since NBPs compute the Boolean functions in the class NL/poly ⊆ P/poly, the tree-witness rewritings for OMQs with ontologies of depth 1 can be equivalently transformed into polynomialsize NDL-rewritings. On the other hand, there exist monotone Boolean functions computable by polynomial-size NBPs but not by polynomial-size monotone Boolean formulas, which establishes\n6 Domain-independent FO-rewritings correspond to SQL queries, PE-rewritings to Select-ProjectJoin-Union (or SPJU) queries, and NDL-rewritings to SPJU queries with views; see also Remark 1. 7 C/poly is the non-uniform analogue of a complexity class C.\na superpolynomial lower bound for PE-rewritings. It also follows that all such OMQs have polynomial-size FO-rewritings iff NC1 = NL/poly.\nThe succinctness results in Fig. 2 (a), characterising the complexity of the reduction to plain database query evaluation, are complemented by the combined complexity results in Fig. 2 (b). Combined complexity measures the time and space required for a best possible algorithm to answer an OMQ Q = (T , q) from the given class over a data instance A, as a function of the size of Q and A. It is known [20, 4] that the general OMQ answering problem is NP-complete for combined complexity—that is, of the same complexity as standard CQ evaluation in databases. However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32]. Here, we prove that, surprisingly, answering OMQs with ontologies of bounded depth and CQs of bounded treewidth is no harder than evaluating CQs of bounded treewidth, that is, LOGCFL-complete. By restricting further the class of CQs to trees with a bounded number of leaves, we obtain an even better NL-completeness result, which matches the complexity of evaluating the underlying CQs. If we consider bounded-leaf tree-shaped CQs coupled with arbitrary OWL2QL ontologies, then the OMQ answering problem remains tractable, LOGCFL-complete to be more precise.\nThe plan of the paper is as follows. Section 2 gives formal definitions of OWL2QL, OMQs and rewritings. Section 3 defines the tree-witness rewriting. Section 4 reduces the succinctness problem for OMQ rewritings to the succinctness problem for hypergraph Boolean functions associated with tree-witness rewritings, and introduces hypergraph programs for computing these functions. Section 5 establishes a correspondence between the OMQ classes in Fig. 2 and the structure of the corresponding hypergraph functions and programs. Section 6 characterises the computational power of hypergraph programs in these classes by relating them to standard models of computation for Boolean functions. Section 7 uses the results of the previous three sections and some known facts from circuit complexity to obtain the upper and lower bounds on the size of PE-, NDL- and FO-rewritings in Fig. 2 (a). Section 8 establishes the combined complexity results in Fig. 2 (b). We conclude in Section 9 by discussing the obtained succinctness and complexity results and formulating a few open problems. All omitted proofs can be found in the appendix.\n2 OWL2QL ontology-mediated queries and first-order rewritability\nIn first-order logic, any OWL2QL ontology (or TBox in description logic parlance), T , can be given as a finite set of sentences (often called axioms) of the following forms\n∀x ( τ(x) → τ ′(x) ) , ∀x ( τ(x) ∧ τ ′(x) → ⊥ ) , ∀x, y ( ̺(x, y) → ̺′(x, y) ) , ∀x, y ( ̺(x, y) ∧ ̺′(x, y) → ⊥ ) , ∀x ̺(x, x), ∀x ( ̺(x, x) → ⊥ ) ,\nwhere the formulas τ(x) (called classes or concepts) and ̺(x, y) (called properties or roles) are defined, using unary predicates A and binary predicates P , by the grammars\nτ(x) ::= ⊤ | A(x) | ∃y ̺(x, y) and ̺(x, y) ::= ⊤ | P (x, y) | P (y, x). (1)\n(Strictly speaking, OWL2QL ontologies can also contain inequalities a 6= b, for constants a and b. However, they do not have any impact on the problems considered in this paper, and so will be ignored.)\nExample 1. To illustrate, we show a snippet of the NPD FactPages ontology:\n∀x (GasPipeline(x) → Pipeline(x)),\n∀x (FieldOwner(x) ↔ ∃y ownerForField(x, y)),\n∀y (∃x ownerForField(x, y) → Field(y)),\n∀x, y (shallowWellboreForField(x, y) → wellboreForField(x, y)),\n∀x, y (isGeometryOfFeature(x, y) ↔ hasGeometry(y, x)).\nTo simplify presentation, in our ontologies we also use sentences of the form\n∀x ( τ(x) → ζ(x) ) , (2)\nwhere ζ(x) ::= τ(x) | ζ1(x) ∧ ζ2(x) | ∃y ( ̺1(x, y) ∧ · · · ∧ ̺k(x, y) ∧ ζ(y) ) .\nIt is readily seen that such sentences are just syntactic sugar and can be eliminated by means of polynomially many fresh predicates. Indeed, any axiom of the form (2) with\nζ(x) = ∃y ( ̺1(x, y) ∧ · · · ∧ ̺k(x, y) ∧ ζ ′(y) )\ncan be (recursively) replaced by the following axioms, for a fresh Pζ and i = 1, . . . , k:\n∀x ( τ(x) → ∃y Pζ(x, y) ) , ∀x, y ( Pζ(x, y) → ̺i(x, y) ) , ∀y ( ∃xPζ(x, y) → ζ ′(y) )\n(3)\nbecause any first-order structure is a model of (2) iff it is a restriction of some model of (3) to the signature of (2). The result of eliminating the syntactic sugar from an ontology T is called the normalisation of T . We always assume that all of our ontologies are normalised even though this is not done explicitly; however, we stipulate (without loss of generality) that the normalisation predicates Pζ never occur in the data.\nWhen writing ontology axioms, we usually omit the universal quantifiers. We typically use the characters P , R to denote binary predicates, A, B, C for unary predicates, and S for either of them. For a binary predicate P , we write P− to denote its inverse; that is, P (x, y) = P−(y, x), for any x and y, and P−− = P .\nA conjunctive query (CQ) q(x) is a formula of the form ∃y ϕ(x,y), where ϕ is a conjunction of atoms S(z) all of whose variables are among x, y.\nExample 2. Here is a (fragment of a) typical CQ from the NPD FactPages:\nq(x1, x2, x3) = ∃y, z [ ProductionLicence(x1) ∧ ProductionLicenceOperator(y) ∧\ndateOperatorValidFrom(y, x2) ∧ licenceOperatorCompany(y, z) ∧\nname(z, x3) ∧ operatorForLicence(y, x1) ] .\nTo simplify presentation and without loss of generality, we assume that CQs do not contain constants. Where convenient, we regard a CQ as the set of its atoms; in particular, |q| is the size of q. The variables in x are called the answer variables of a CQ q(x). A CQ without answer variables is called Boolean. With every CQ q, we associate its Gaifman graph Gq whose vertices are the variables of q and whose edges are the pairs {u, v} such that P (u, v) ∈ q, for some P . A CQ q is connected if the graph Gq is connected. We call q tree-shaped if Gq is a tree\n8, and if Gq is a tree with at most two leaves, then q is said to be linear.\nAn OWL2QL ontology-mediated query (OMQ) is a pair Q(x) = (T , q(x)), where T is an OWL2QL ontology and q(x) a CQ. The size of Q is defined as |Q| = |T | + |q|, where |T | is the number of symbols in T .\nA data instance, A, is a finite set of unary or binary ground atoms (called an ABox in description logic). We denote by ind(A) the set of individual constants in A. Given an OMQ Q(x) and a data instance A, a tuple a of constants from ind(A) of length |x| is called a certain answer to Q(x) over A if I |= q(a) for all models I of T ∪A; in this case we write T ,A |= q(a). If q(x) is Boolean, a certain answer to Q over A is ‘yes’ if T ,A |= q, and ‘no’ otherwise. We remind the reader [56] that, for any CQ q(x) = ∃y ϕ(x,y), any first-order structure I and any tuple a from its domain ∆, we have I |= q(a) iff there is a map h : x ∪ y → ∆ such that (i) if S(z) ∈ q then I |= S(h(z)), and (ii) h(x) = a. If (i) is satisfied then h is called a homomorphism from q to I, and we write h : q → I; if (ii) also holds, we write h : q(a) → I.\nCentral to OBDA is the notion of OMQ rewriting that reduces the problem of finding certain answers to standard query evaluation. More precisely, an FO-formula q′(x), possibly with equality, =, is an FO-rewriting of an OMQ Q(x) = (T , q(x)) if, for any data instance A (without the normalisation predicates for T ) and any tuple a in ind(A),\nT ,A |= q(a) iff IA |= q ′(a), (4)\n8 Tree-shaped CQs also go by the name of acyclic queries [77, 11].\nwhere IA is the first-order structure over the domain ind(A) such that IA |= S(a) iff S(a) ∈ A, for any ground atom S(a). As A is arbitrary, this definition implies, in particular, that the rewriting must be constant-free. If q′(x) is a positive existential formula—that is, q′(x) = ∃y ϕ(x,y) with ϕ constructed from atoms (possibly with equality) using ∧ and ∨ only—we call it a PE-rewriting of Q(x). A PE-rewriting whose matrix ϕ is a disjunction of conjunctions is known as a UCQ-rewriting; if ϕ takes the form ∧∨∧∨ we call it a Π4-rewriting. The size |q′| of q′ is the number of symbols in it.\nWe also consider rewritings in the form of nonrecursive datalog queries. Recall [1] that a datalog program, Π , is a finite set of Horn clauses ∀x (γ1 ∧ · · · ∧ γm → γ0), where each γi is an atom P (x1, . . . , xl) with xi ∈ x. The atom γ0 is the head of the clause, and γ1, . . . , γm its (possibly empty) body. A predicate S depends on S′ in Π if Π has a clause with S in the head and S′ in the body; Π is nonrecursive if this dependence relation is acyclic.\nLet Q = (T , q(x)) be an OMQ, Π a constant-free nonrecursive program, and G(x) a predicate. The pair q′(x) = (Π,G(x)) is an NDL-rewriting of Q if, for any data instance A and any tuple a in ind(A), we have T ,A |= q(a) iff Π(IA) |= G(a), where Π(IA) is the structure with domain ind(A) obtained by closing IA under the clauses in Π . Every PE-rewriting can clearly be represented as an NDL-rewriting of linear size.\nRemark 1. As defined, FO- and PE-rewritings are not necessarily domain-independent queries, while NDL-rewritings are not necessarily safe [1]. For example, (x = x) is a PE-rewriting of the OMQ ({∀xP (x, x)}, P (x, x)), and the program ({⊤ → A(x)}, A(x)) is an NDL-rewriting of the OMQ ({⊤ → A(x)}, A(x)). Rewritings can easily be made domain-independent and safe by relativising their variables to the predicates in the data signature (relational schema). For instance, if this signature is {A,P}, then a domain-independent relativisation of (x = x) is the PE-rewriting ( A(x)∨∃y P (x, y)∨∃y P (y, x) ) ∧ (x = x). Note that if we exclude from OWL2QL reflexivity statements and axioms with ⊤ on the left-hand side, then rewritings are guaranteed to be domain-independent, and no relativisation is required. In any case, rewritings are always interpreted under the active domain semantics adopted in databases; see (4).\nAs mentioned in the introduction, the OWL2QL profile of OWL2 was designed to ensure FO-rewritability of all OMQs with ontologies in the profile or, equivalently, OMQ answering in AC0 for data complexity. It should be clear, however, that for the OBDA approach to work in practice, the rewritings of OMQs must be of ‘reasonable shape and size’. Indeed, it was observed experimentally [19] and also established theoretically [47] that sometimes the rewritings are prohibitively large—exponentially-large in the size of the original CQ, to be more precise. These facts imply that, in the context of OBDA, we should actually be interested not in arbitrary but in polynomial-size rewritings. In complexity-theoretic terms, the focus should not only be on the data complexity of OMQ answering, which is an appropriate measure for database query evaluation (where queries are indeed usually small) [74], but also on the combined complexity that takes into account the contribution of ontologies and queries."
    }, {
      "heading" : "3 Tree-Witness Rewriting",
      "text" : "Now we define one particular rewriting of OWL2QL OMQs that will play a key role in the succinctness and complexity analysis later on in the paper. This rewriting is a modification of the tree-witness PE-rewriting originally introduced by Kikot et al. [49] (cf. [57, 52, 51] for rewritings based on similar ideas).\nWe begin with two simple observations that will help us remove unneeded clutter from the definitions. Every OWL2QL ontology T consists of two parts: T −, which contains all the sentences with ⊥, and the remainder, T +, which is consistent with every data instance. For any ψ(z) → ⊥ in T −, consider the Boolean CQ ∃z ψ(z). It is not hard to see that, for any OMQ (T , q(x)) and data instance A, a tuple a is a certain answer to (T , q(x)) over A iff either T +,A |= q(a) or T +,A |= ∃z ψ(z), for some ψ(z) → ⊥ in T −; see [17] for more details. Thus, from now on we will assume that, in all our ontologies T , the ‘negative’ part T − is empty, and so they are consistent with all data instances.\nThe second observation will allow us to restrict the class of data instances we need to consider when rewriting OMQs. In general, if we only require condition (4) to hold for any data instance\nA from some class A, then we call q′(x) a rewriting of Q(x) over A. Such classes of data instances can be defined, for example, by the integrity constraints in the database schema and the mapping [67]. We say that a data instance A is complete9 for an ontology T if T ,A |= S(a) implies S(a) ∈ A, for any ground atom S(a) with a from ind(A). The following proposition means that from now on we will only consider rewritings over complete data instances.\nProposition 1. If q′(x) is an NDL-rewriting of Q(x) = (T , q(x)) over complete data instances, then there is an NDL-rewriting q′′(x) of Q(x) over arbitrary data instances with |q′′| ≤ |q′| · |T |."
    }, {
      "heading" : "A similar result holds for PE- and FO-rewritings.",
      "text" : "Proof. Let (Π,G(x)) be an NDL-rewriting of Q(x) over complete data instances. Denote by Π∗ the result of replacing each predicate S in Π with a fresh predicate S∗. Define Π ′ to be the union of Π∗ and the following clauses for predicates in Π :\nτ(x) → A∗(x), if T |= τ(x) → A(x),\n̺(x, y) → P ∗(x, y), if T |= ̺(x, y) → P (x, y),\n⊤ → P ∗(x, x), if T |= P (x, x)\n(the empty body is denoted by ⊤). It is readily seen that (Π ′, G∗(x)) is an NDL-rewriting of Q(x) over arbitrary data instances. The cases of PE- and FO-rewritings are similar except that we replace A(x) and P (x, y) with\n∨\nT |=τ(x)→A(x) τ(x) and\n∨\nT |=̺(x,y)→P (x,y) ̺(x, y) ∨\n∨\nT |=P (x,x) (x = y),\nrespectively (the empty disjunction is, by definition, ⊥).\nAs is well-known [1], every pair (T ,A) of an ontology T and data instance A possesses a canonical model (or chase) CT ,A such that T ,A |= q(a) iff CT ,A |= q(a), for all CQs q(x) and a in ind(A). In our proofs, we use the following definition of CT ,A, where without loss of generality we assume that T does not contain binary predicates P such that T |= ∀x, y P (x, y). Indeed, occurrences of such P in T can be replaced by ⊤ and occurrences of P (x, y) in CQs can simply be removed without changing certain answers over any data instance (provided that x and y occur in the remainder of the query).\nThe domain ∆CT ,A of the canonical model CT ,A consists of ind(A) and the witnesses, or labelled nulls, introduced by the existential quantifiers in (the normalisation of) T . More precisely, the labelled nulls in CT ,A are finite words of the form w = a̺1 . . . ̺n (n ≥ 1) such that\n– a ∈ ind(A) and T ,A |= ∃y ̺1(a, y), but T ,A 6|= ̺1(a, b) for any b ∈ ind(A); – T 6|= ̺i(x, x) for 1 ≤ i ≤ n; – T |= ∃x ̺i(x, y) → ∃z ̺i+1(y, z) and T 6|= ̺i(y, x) → ̺i+1(x, y) for 1 ≤ i < n.\nEvery individual name a ∈ ind(A) is interpreted in CT ,A by itself, and unary and binary predicates are interpreted as follows: for any u, v ∈ ∆CT ,A ,\n– CT ,A |= A(u) iff either u ∈ ind(A) and T ,A |= A(u), or u = w̺, for some w and ̺ with T |= ∃y ̺(y, x) → A(x);\n– CT ,A |= P (u, v) iff one of the following holds: (i) u, v ∈ ind(A) and T ,A |= P (u, v); (ii) u = v and T |= P (x, x); (iii) v = u̺ and T |= ̺(x, y) → P (x, y); (iv) u = v̺− and T |= ̺(x, y) → P (x, y).\nExample 3. Consider the following ontologies:\nT1 = { A(x) → ∃y ( R(x, y) ∧Q(y, x) ) },\nT2 = { A(x) → ∃y R(x, y), ∃xR(x, y) → ∃z Q(z, y) },\nT3 = { A(x) → ∃y R(x, y), ∃xR(x, y) → ∃z R(y, z) }.\nThe canonical models of (Ti,A), for A = {A(a)}, i = 1, 2, 3, are shown in Fig. 3, where ζ(x) = ∃y (R(x, y) ∧ Q(y, x)) and Pζ is the corresponding normalisation predicate. When depicting canonical models, we use for constants and for labelled nulls.\n9 Rodriguez-Muro et al. [67] used the term ‘H-completeness’; see also [50].\nFor any ontology T and any formula τ(x) given by (1), we denote by Cτ(a)T the canonical model of (T ∪{A(x) → τ(x)}, {A(a)}), for a fresh unary predicate A. We say that T is of depth k, 1 ≤ k < ω, if (i) there is no ̺ with T |= ̺(x, x), (ii) at least one of the Cτ(a)T contains a word a̺1 . . . ̺k, but (iii) none of the Cτ(a)T has such a word of greater length. Thus, T1 in Example 3 is of depth 1, T2 of depth 2, while T3 is not of any finite depth.\nOntologies of infinite depth generate infinite canonical models. However, OWL2QL has the polynomial derivation depth property (PDDP) in the sense that there is a polynomial p such that, for any OMQ Q(x) = (T , q(x)), data instance A and a in ind(A), we have T ,A |= q(a) iff q(a) holds in the sub-model of CT ,A whose domain consists of words of the form a̺1 . . . ̺n with n ≤ p(|Q|) [41, 17]. (In general, the bounded derivation depth property of an ontology language is a necessary and sufficient condition of FO-rewritability [31].)\nWe call a set ΩQ of words of the form w = ̺1 . . . ̺n fundamental for Q if, for any A and a in ind(A), we have T ,A |= q(a) iff q(a) holds in the sub-model of CT ,A with the domain {aw | a ∈ ind(A), w ∈ ΩQ}. We say that a class Q of OMQs has the polynomial fundamental set property (PFSP) if there is a polynomial p such that every Q ∈ Q has a fundamental set ΩQ with |ΩQ| ≤ p(|Q|). The class of all OMQs (even with ontologies of finite depth and tree-shaped CQs) does not have the PFSP [47]. On the other hand, it should be clear that the class of OMQs with ontologies of bounded depth does enjoy the PFSP. A less trivial example is given by the following theorem, which is an immediate consequence of Theorem 3 below:\nTheorem 1. The class of OMQs whose ontologies do not contain axioms of the form ̺(x, y) → ̺′(x, y) (and syntactic sugar (2)) enjoys the PFSP.\nWe are now in a position to define the tree-witness PE-rewriting of OWL2QL OMQs. Suppose we are given an OMQ Q(x) = (T , q(x)) with q(x) = ∃y ϕ(x,y). For a pair t = (tr, ti) of disjoint sets of variables in q, with ti ⊆ y10 and ti 6= ∅ (tr can be empty), set\nq t = { S(z) ∈ q | z ⊆ tr ∪ ti and z 6⊆ tr } .\nIf q t is a minimal subset of q for which there is a homomorphism h : q t → Cτ(a)T such that tr = h −1(a) and q t contains every atom of q with at least one variable from ti, then we call t = (tr, ti) a tree witness for Q generated by τ (and induced by h). Observe that if tr = ∅ then q t is a connected component of q; in this case we call t detached. Note also that the same tree witness t = (tr, ti) can be generated by different τ . Now, we set\ntwt(tr) = ∃z (∧\nx∈tr (x = z) ∧\n∨\nt generated by τ\nτ(z) ) . (5)\nThe variables in ti do not occur in twt and are called internal. The variables in tr, if any, are called root variables. Note that no answer variable in q(x) can be internal. The length |twt| of twt is O(|Q|). Tree witnesses t and t ′ are conflicting if q t ∩q\nt′ 6= ∅. Denote by ΘQ the set of tree witnesses for Q(x). A subset Θ ⊆ ΘQ is independent if no pair of distinct tree witnesses in it is conflicting. Let qΘ = ⋃\nt∈Θ qt. The following PE-formula is called the tree-witness rewriting of Q(x) over complete data instances :\nqtw(x) = ∨\nΘ⊆ΘQ independent ∃y\n( ∧\nS(z)∈q\\qΘ\nS(z) ∧ ∧\nt∈Θ twt(tr)\n) . (6)\n10 We (ab)use set-theoretic notation for lists and, for example, write ti ⊆ y to say that every element of ti is an element of y.\nRemark 2. As the normalisation predicates Pζ cannot occur in data instances, we can omit from (5) all the disjuncts with Pζ . For the same reason, the tree witnesses generated only by concepts with normalisation predicates will be ignored in the sequel.\nExample 4. Consider the OMQ Q(x1, x2) = (T , q(x1, x2)) with\nT = { A1(x) → ∃y ( R1(x, y) ∧Q(x, y) )\n︸ ︷︷ ︸\nζ1(x)\n, A2(x) → ∃y ( R2(x, y) ∧Q(y, x) )\n︸ ︷︷ ︸\nζ2(x)\n} ,\nq(x1, x2) = ∃y1, y2 ( R1(x1, y1) ∧Q(y2, y1) ∧R2(x2, y2) ) .\nThe CQ q is shown in Fig. 4 alongside CA1(a)T and C A2(a) T . When depicting CQs, we use for answer variables and for existentially quantified variables. There are two tree witnesses, t1 and t 2, for Q with\nq t1 = { R1(x1, y1), Q(y2, y1) } and q t2 = { Q(y2, y1), R2(x2, y2) }\nshown in Fig. 4 by the dark and light shading, respectively. The tree witness t1 = (t1r , t 1 i ) with t1r = {x1, y2} and t 1 i = {y1} is generated by A1(x), which gives\ntwt1(x1, y2) = ∃z ( A1(z) ∧ (x1 = z) ∧ (y2 = z) ) .\n(Recall that although t1 is also generated by ∃y Pζ1(y, z), we do not include it in the disjunction in twt1 because Pζ1 cannot occur in data instances.) Symmetrically, the tree witness t 2 gives\ntwt2(x2, y1) = ∃z ( A2(z) ∧ (x2 = z) ∧ (y1 = z) ) .\nAs t1 and t2 are conflicting, ΘQ contains three independent subsets: ∅, {t1} and {t2}. Thus, we obtain the following tree-witness rewriting qtw(x1, x2) of Q over complete data instances:\n∃y1, y2 [( R1(x1, y1) ∧Q(y2, y1) ∧R2(x2, y2) ) ∨ ( twt1 ∧R2(x2, y2) ) ∨ ( R1(x1, y1) ∧ twt2 )] .\nTheorem 2 ([49]). For any OMQ Q(x) = (T , q(x)), any data instance A, which is complete for T , and any tuple a from ind(A), we have T ,A |= q(a) iff IA |= qtw(a). In other words, qtw is a rewriting of Q(x) over complete data instances.\nIntuitively, for every homomorphism h : q(a) → CT ,A, the sub-CQs of q mapped by h to submodels of the form Cτ(a)T define an independent set Θ of tree witnesses; see Fig. 5. Conversely, if Θ is such a set, then the homomorphisms corresponding to the tree witnesses in Θ can be pieced together into a homomorphism from q(a) to CT ,A—provided that the S(z) from q \\ qΘ and the twt(tr) for t ∈ Θ hold in IA.\nThe size of the tree-witness PE-rewriting qtw depends on the number of tree witnesses in the given OMQ Q = (T , q) and, more importantly, on the cardinality of ΘQ as we have |qtw| = O(2 |ΘQ| · |Q|2) with |ΘQ| ≤ 3|q|.\nTheorem 3. OMQs Q = (T , q), in which T does not contain axioms of the form ̺(x, y) → ̺′(x, y) (and syntax sugar (2)), have at most 3|q| tree witnesses.\nProof. As observed above, there can be only one detached tree witness for each connected component of q. As T has no axioms of the form ̺(x, y) → ̺′(x, y), any two points in Cτ(a)T can be R-related for at most one R, and so no point can have more than one R-successor, for any R. It follows that, for every atom P (x, y) in q, there can be at most one tree witness t = (tr, ti) with P (x, y) ∈ q\nt , x ∈ tr and y ∈ ti (P−(y, x) may give another tree witness).\nOMQs with arbitrary axioms can have exponentially many tree witnesses:\nExample 5. Consider the OMQ Qn = (T , qn(x 0)), where\nT = { A(x) → ∃y ( R(y, x) ∧ ∃z (R(y, z) ∧B(z)) )} ,\nqn(x 0) = ∃y,y1,x1,y2\n( B(y) ∧\n∧\n1≤k≤n\n( R(y1k, y) ∧R(y 1 k, x 1 k) ∧R(y 2 k, x 1 k) ∧R(y 2 k, x 0 k) ))\nand xi and yi denote vectors of n variables xik and y i k, for 1 ≤ k ≤ n, respectively. The CQ is shown in Fig. 6 alongside the canonical model CA(a)T . OMQ Qn has at least 2 n tree witnesses: for any α = (α1, . . . , αn) ∈ {0, 1}n, there is a tree witness (tαr , t α i ) with tαr = {x αk k | 1 ≤ k ≤ n}. Note, however, that the tree-witness rewriting of Qn can be equivalently transformed into the following polynomial-size PE-rewriting:\nqn(x 0) ∨ ∃z\n[ A(z) ∧\n∧\n1≤i≤n\n( (x0i = z) ∨ ∃y (R(y, x 0 i ) ∧R(y, z)) )] .\nIf any two tree witnesses for an OMQ Q are compatible in the sense that either they are non-conflicting or one is included in the other, then qtw can be equivalently transformed to the PE-rewriting\n∃y ∧\nS(z)∈q\n( S(z) ∨\n∨\nt∈ΘQ with S(z)∈qt\ntwt(tr) )\nof size O(|ΘQ| · |Q| 2).\nWe now analyse transformations of this kind in the setting of Boolean functions."
    }, {
      "heading" : "4 OMQ Rewritings as Boolean Functions",
      "text" : "For any OMQ Q(x) = (T , q(x)), we define Boolean functions f▽Q and f △ Q such that:\n– if f▽Q is computed by a Boolean formula (monotone formula or monotone circuit) Φ, then Q has an FO- (respectively, PE- or NDL-) rewriting of size O(|Φ| · |Q|);\n– if q′ is an FO- (PE- or NDL-) rewriting of Q, then f△Q is computed by a Boolean formula (respectively, monotone formula or monotone circuit) of size O(|q′|).\nWe remind the reader (for details see, e.g., [3, 42]) that an n-ary Boolean function, for n ≥ 1, is any function from {0, 1}n to {0, 1}. A Boolean function f is monotone if f(α) ≤ f(β) for all α ≤ β, where ≤ is the component-wise ≤ on vectors of {0, 1}. A Boolean circuit, C, is a directed acyclic graph whose vertices are called gates. Each gate is labelled with a propositional variable, a constant 0 or 1, or with not, and or or. Gates labelled with variables and constants have in-degree 0 and are called inputs ; not-gates have in-degree 1, while and- and or-gates have\nin-degree 2 (unless otherwise specified). One of the gates in C is distinguished as the output gate. Given an assignment α ∈ {0, 1}n to the variables, we compute the value of each gate in C under α as usual in Boolean logic. The output C(α) of C on α ∈ {0, 1}n is the value of the output gate. We usually assume that the gates g1, . . . , gm of C are ordered in such a way that g1, . . . , gn are input gates; each gate gi, for i ≥ n, gets inputs from gates gj1 , . . . , gjk with j1, . . . , jk < i, and gm is the output gate. We say that C computes an n-ary Boolean function f if C(α) = f(α) for all α ∈ {0, 1}n. The size |C| of C is the number of gates in C. A circuit is monotone if it contains only inputs, and- and or-gates. Boolean formulas can be thought of as circuits in which every logic gate has at most one outgoing edge. Any monotone circuit computes a monotone function, and any monotone Boolean function can be computed by a monotone circuit."
    }, {
      "heading" : "4.1 Hypergraph Functions",
      "text" : "Let H = (V,E) be a hypergraph with vertices v ∈ V and hyperedges e ∈ E ⊆ 2V . A subset E′ ⊆ E is said to be independent if e ∩ e′ = ∅, for any distinct e, e′ ∈ E′. The set of vertices that occur in the hyperedges of E′ is denoted by VE′ . For each vertex v ∈ V and each hyperedge e ∈ E, we take propositional variables pv and pe, respectively. The hypergraph function fH for H is given by the monotone Boolean formula\nfH = ∨\nE′ independent\n( ∧\nv∈V \\VE′ pv ∧\n∧\ne∈E′ pe\n)\n. (7)\nThe tree-witness PE-rewriting qtw of any OMQ Q(x) = (T , q(x)) defines a hypergraph whose vertices are the atoms of q and hyperedges are the sets q\nt , where t is a tree witness for\nQ. We denote this hypergraph by H(Q) and call fH(Q) the tree-witness hypergraph function for Q. To simplify notation, we write f▽Q instead of fH(Q). Note that formula (7) defining f ▽ Q is obtained from rewriting (6) by regarding the atoms S(z) in q and tree-witness formulas twt as propositional variables. We denote these variables by pS(z) and pt (rather than pv and pe), respectively.\nExample 6. For the OMQ Q in Example 4, the hypergraph H(Q) has 3 vertices (one for each atom in the query) and 2 hyperedges (one for each tree witness) shown in Fig. 7. The tree-witness hypergraph function for Q is as follows:\nf▽Q = ( pR1(x1,y1) ∧ pQ(y2,y1) ∧ pR2(x2,y2) ) ∨ ( pt1 ∧ pR2(x2,y2) ) ∨ ( pR1(x1,y1) ∧ pt2 ) .\nSuppose the function f▽Q for an OMQ Q(x) is computed by a Boolean formula Φ. Consider the first-order formula Φ∗(x) obtained by replacing each pS(z) in Φ with S(z), each pt with twt, and adding the appropriate prefix ∃y. By comparing (7) and (6), we see that Φ∗(x) is an FO-rewriting of Q(x) over data instances that are complete over T . This gives claim (i) of the following theorem:\nTheorem 4. (i) If f▽Q is computed by a (monotone) Boolean formula Φ, then there is a (PE-) FO-rewriting of Q(x) of size O(|Φ| · |Q|).\n(ii) If f▽Q is computed by a monotone Boolean circuit C, then there is an NDL-rewriting of Q(x) of size O(|C | · |Q|).\nProof. (ii) Let t1, . . . , tl be tree witnesses for Q(x) = (T , q(x)), where q(x) = ∃y ∧n\ni=1 Si(zi). We assume that the gates g1, . . . , gn of C are the inputs pS1(z1), . . . , pSn(zn) for the atoms, the gates gn+1, . . . , gn+l are the inputs pt1 , . . . , ptl for the tree witnesses and gn+l+1, . . . , gm are andand or-gates. Denote by Π the following NDL-program, where z = x ∪ y:\n– Si(zi) → Gi(z), for 0 < i ≤ n; – τ(u) → Gi+m(z[tjr /u]), for 0 < j ≤ l and τ generating t\nj, where z[tjr /u] is the result of replacing each z ∈ tjr in z with u;\n–\n{\nGj(z) ∧Gk(z) → Gi(z), if gi = gj ∧ gk, Gj(z) → Gi(z) and Gk(z) → Gi(z), if gi = gj ∨ gk, for n+ l < i ≤ m;\n– Gm(z) → G(x).\nIt is not hard to see that (Π,G(x)) is an NDL-rewriting of Q(x).\nThus, the problem of constructing polynomial-size rewritings of OMQs reduces to finding polynomial-size (monotone) formulas or monotone circuits for the corresponding functions f▽Q. Note, however, that f▽Q contains a variable pt for every tree witness t, which makes this reduction useless for OMQs with exponentially many tree witnesses. To be able to deal with such OMQs, we slightly modify the tree-witness rewriting.\nSuppose t = (tr, ti) is a tree witness for Q = (T , q) induced by a homomorphism h : qt → C τ(a) T . We say that t is ̺-initiated if h(z) is of the form a̺w, for every (equivalently, some) variable z ∈ ti. For such ̺, we define a formula ̺∗(x) by taking the disjunction of τ(x) with T |= τ(x) → ∃y ̺(x, y). Again, the disjunction includes only those τ(x) that do not contain normalisation predicates (even though ̺ itself can be one).\nExample 7. Consider the OMQ Q(x) = (T , q(x)) with\nT = { ∃y Q(x, y) → ∃y P (x, y), P (x, y) → R(x, y) } and q(x) = ∃y R(x, y).\nAs shown in Fig. 8, the tree witness t = ({x}, {y}) forQ(x) is generated by ∃y Q(x, y), ∃y P (x, y) and ∃y R(x, y); it is also P - and R-initiated, but not Q-initiated. We have:\nP ∗(x) = ∃y Q(x, y) ∨ ∃y P (x, y) and R∗(x) = ∃y Q(x, y) ∨ ∃y P (x, y) ∨ ∃y R(x, y).\nThe modified tree-witness rewriting for Q(x) = (T , q(x)), denoted q′tw(x), is obtained by replacing (5) in (6) with the formula\ntw′ t (tr, ti) =\n∧\nR(z,z′)∈q t\n(z = z′) ∧ ∨\nt is ̺-initiated\n∧\nz∈tr∪ti ̺∗(z). (5′)\nNote that unlike (5), this formula contains the variables in both ti and tr, which must be equal under every satisfying assignment. We associate with q′tw(x) the monotone Boolean function f H Q given by the formula obtained from (7) by replacing each variable pv with the respective pS(z), for S(z) ∈ q, and each variable pe with the formula\n∧\nR(z,z′)∈q t\npz=z′ ∧ ∨\nt is ̺-initiated\n∧\nz∈tr∪ti p̺∗(z), (8)\nfor the respective tree witness t = (tr, ti) for Q(x), where pz=z′ and p̺∗(z) are propositional variables. Clearly, the number of variables in fHQ is polynomial in |Q|.\nExample 8. For the OMQ Q(x) in the Example 4, we have:\nfHQ = ( pR1(x1,y1) ∧ pQ(y2,y1) ∧ pR2(x2,y2) ) ∨\n(( px1=y1∧ py2=y1 ∧\n∧\nz∈{x1,y1,y2} pP∗ ζ1 (z)\n) ∧ pR2(x2,y2) ) ∨\n( pR1(x1,y1) ∧ ( py2=y1∧ px2=y2 ∧\n∧\nz∈{y1,y2,x2} pP∗ ζ2 (z)\n)) .\nThe proof of the following theorem is given in Appendix A:\nTheorem 5. (i) For any OMQ Q(x), the formulas qtw(x) and q ′ tw(x) are equivalent, and so q′tw(x) is a PE-rewriting of Q(x) over complete data instances. (ii) Theorem 4 continues to hold for f▽Q replaced by f H Q.\nFinally, we observe that although f▽Q and f H Q are defined by exponential-size formulas, each of these functions can be computed by a nondeterministic polynomial algorithm (in the number of propositional variables). Indeed, given truth-values for the pS(z) and pt in f ▽\nQ, guess a set Θ of at most |q| tree witnesses and check whether (i) Θ is independent, (ii) pt = 1 for all t ∈ Θ, and (iii) every S(z) with pS(z) = 0 belongs to some t ∈ Θ. The function f H\nQ is computed similarly except that, in (ii), we check whether the polynomial-size formula (8) is true under the given truth-values for every t ∈ Θ."
    }, {
      "heading" : "4.2 Primitive Evaluation Functions",
      "text" : "To obtain lower bounds on the size of rewritings, we associate with every OMQ Q a third Boolean function f△Q that describes the result of evaluating Q on data instances with a single individual constant. Let γ ∈ {0, 1}n be a vector assigning the truth-value γ(Si) to each unary or binary predicate Si in Q. We associate with γ the data instance\nA(γ) = { Ai(a) | γ(Ai) = 1 } ∪ { Pi(a, a) | γ(Pi) = 1 }\nand set f△Q(γ) = 1 iff T ,A(γ) |= q(a), where a is the |x|-tuple of as. We call f △ Q the primitive evaluation function for Q. Theorem 6. (i) If q′ is a (PE-) FO-rewriting of Q, then f△Q can be computed by a (monotone) Boolean formula of size O(|q′|).\n(ii) If q′ is an NDL-rewriting of Q, then f△Q can be computed by a monotone Boolean circuit of size O(|q′|).\nProof. (i) Let q′ be an FO-rewriting of Q. We eliminate the quantifiers in q′ by replacing each subformula of the form ∃xψ(x) and ∀xψ(x) in q′ with ψ(a). We then replace each a = a with ⊤ and each atom of the form A(a) and P (a, a) with the corresponding propositional variable. The resulting Boolean formula clearly computes f△Q. If q\n′ is a PE-rewriting of Q, then the result is a monotone Boolean formula computing f△Q.\n(ii) If (Π,G) is an NDL-rewriting of Q, then we replace all variables in Π with a and then perform the replacement described in (i). We now turn the resulting propositional NDL-program Π ′ into a monotone circuit computing f△Q. For every (propositional) variable p occurring in the head of a rule in Π ′, we take an appropriate number of or-gates whose output is p and inputs are the bodies of the rules with head p; for every such body, we introduce an appropriate number of and-gates whose inputs are the propositional variables in the body, or, if the body is empty, we take the gate for constant 1."
    }, {
      "heading" : "4.3 Hypergraph Programs",
      "text" : "We introduced hypergraph functions as Boolean abstractions of the tree-witness rewritings. Our next aim is to define a model of computation for these functions.\nA hypergraph program (HGP) P is a hypergraphH = (V,E) each of whose vertices is labelled by 0, 1 or a literal over a list p1, . . . , pn of propositional variables. (As usual, a literal, l, is a propositional variable or its negation.) An input for P is a tuple α ∈ {0, 1}n, which is regarded as a valuation for p1, . . . , pn. The output P (α) of P on α is 1 iff there is an independent subset of E that covers all zeros—that is, contains every vertex in V whose label evaluates to 0 under α. We say that P computes an n-ary Boolean function f if f(α) = P (α), for all α ∈ {0, 1}n. An HGP is monotone if its vertex labels do not have negated variables. The size |P | of an HGP P is the size |H | of the underlying hypergraph H = (V,E), which is |V |+ |E|.\nThe following observation shows that monotone HGPs capture the computational power of hypergraph functions. We remind the reader that a subfunction of a Boolean function f is obtained from f using two operations: (1) fixing some of its variables to 0 or 1, and (2) renaming (in particular, identifying) some of the variables in f . A hypergraph H is said to be of degree at most d if every vertex in it belongs to at most d hyperedges; H is of degree d if every vertex in it belongs to exactly d hyperedges.\nProposition 2. (i) Any monotone HGP based on a hypergraph H computes a subfunction of the hypergraph function fH .\n(ii) For any hypergraph H of degree at most d, there is a monotone HGP of size O(|H |) that computes fH and such that its hypergraph is of degree at most max(2, d).\nProof. To show (i), it is enough to replace the vertex variables pv in fH by the corresponding vertex labels of the given HGP and fix all the edge variables pe to 1.\nFor (ii), given a hypergraph H = (V,E), we label each v ∈ V by the variable pv. For each e ∈ E, we add a fresh vertex ae labelled by 1 and a fresh vertex be labelled by pe; then we create a new hyperedge e′ = {ae, be} and add ae to the hyperedge e. We claim that the resulting HGP P computes fH . Indeed, for any input α with α(pe) = 0, we have to include the edge e\n′ into the cover, and so cannot include the edge e itself. Thus, P (α) = 1 iff there is an independent set E of hyperedges with α(pe) = 1, for all e ∈ E, covering all zeros of the variables pv.\nIn some cases, it will be convenient to use generalised HGPs that allow hypergraph vertices to be labelled by conjunctions ∧\ni li of literals li. The following proposition shows that this generalisation does not increase the computational power of HGPs.\nProposition 3. For every generalised HGP P over n variables, there is an HGP P ′ computing the same function and such that |P ′| ≤ n · |P |.\nProof. To construct P ′, we split every vertex v of P labelled with ∧k\ni=1 li into k new vertices v1, . . . , vk and label vi with li, for 1 ≤ i ≤ k (without loss of generality, we can assume that li and lj have distinct variables for i 6= j); each hyperedge containing v will now contain all the vi. It is easy to see that P (α) = P ′(α), for any input α. Since k ≤ n, we have |P ′| ≤ n · |P |."
    }, {
      "heading" : "5 OMQs, hypergraphs and monotone hypergraph programs",
      "text" : "We now establish a correspondence between the structure of OMQs and hypergraphs."
    }, {
      "heading" : "5.1 OMQs with ontologies of depth 2",
      "text" : "To begin with, we show that every hypergraph H = (V,E) can be represented by a polynomialsize OMQ QH = (T , q) with T of depth 2. With every vertex v ∈ V we associate a unary predicate Av, and with every hyperedge e ∈ E a unary predicate Be and a binary predicate Re. We define T to be the set of the following axioms, for e ∈ E:\nBe(x) → ∃y [ ∧\ne∩e′ 6=∅, e6=e′ Re′(x, y) ∧\n∧ v∈e Av(y) ∧ ∃z Re(z, y) ] .\nClearly, T is of depth 2. We also take the Boolean CQ q with variables yv, for v ∈ V , and ze, for e ∈ E:\nq = { Av(yv) | v ∈ V } ∪ { Re(ze, yv) | v ∈ e, for v ∈ V and e ∈ E } .\nExample 9. Consider again the hypergraph from Example 6, which we now denote byH = (V,E) with V = {v1, v2, v3}, E = {e1, e2}, e1 = {v1, v2} and e2 = {v2, v3}. The CQ q and the canonical models C Bei (a) T , for i = 1, 2, are shown in Fig. 9 along with four tree witnesses for QH (as explained in Remark 2, we ignore the two extra tree witnesses generated only by normalisation predicates).\nIt is not hard to see that the number of tree witnesses for QH does not exceed |H |. Indeed, all the tree witnesses for QH fall into two types:\ntv = (ti, tr) with tr = {ze | v ∈ e} and ti = {yv}, for v ∈ V that belong to a single e ∈ E; te = (ti, tr) with tr = {ze′ | e ∩ e ′ 6= ∅, e 6= e′} and ti = {ze} ∪ {yv | v ∈ e}, for e ∈ E.\nWe call a hypergraph H ′ a subgraph of a hypergraph H = (V,E) if H ′ can be obtained from H by (i) removing some of its hyperedges and (ii) removing some of its vertices from both V and the hyperedges in E.\nTheorem 7. (i) Any hypergraph H is isomorphic to a subgraph of H(QH). (ii) Any monotone HGP P based on a hypergraph H computes a subfunction of the primitive evaluation function f△QH .\nProof. (i) An isomorphism between H and a subgraph of H(QH) can be established by the map v 7→ Av(yv), for v ∈ V , and e 7→ qte , for e ∈ E.\n(ii) Suppose that P is based on a hypergraph H = (V,E). Given an input α for P , we define an assignment γ for the predicates in QH = (T , q) by taking γ(Av) to be the value of the label of v under α, γ(Be) = 1, γ(Re) = 1 (and of course γ(Pζ) = 0, for all normalisation predicates Pζ). By the definition of T , for each e ∈ E, the canonical model CT ,A(γ) contains labelled nulls we and w ′ e such that\nCT ,A(γ) |= ∧\ne∩e′ 6=∅, e6=e′ Re′(a, we) ∧\n∧ v∈e Av(we) ∧ Re(w ′ e, we).\nWe now show that P (α) = 1 iff f△QH (γ) = 1 (iff T ,A(γ) |= q). Suppose P (α) = 1, that is, there is an independent subset E′ ⊆ E such that the label of each v /∈ ⋃ E′ evaluates to 1 under α. Then the map h : q → CT ,A(γ) defined by taking\nh(ze) =\n{\nw′e, if e ∈ E ′, a, otherwise, h(yv) =\n{\nwe, if v ∈ e ∈ E′,\na, otherwise\nis a homomorphism witnessing CT ,A(γ) |= q, whence f △ QH (γ) = 1.\nConversely, if f△QH (γ) = 1 then there is a homomorphism h : q → CT ,A(γ). For any hyperedge e ∈ E, there are only two options for h(ze): either a or w′e. It follows that the set E\n′ = {e ∈ E | h(ze) = w ′ e} is independent and covers all zeros. Indeed, if v /∈ ⋃ E′ then h(yv) = a, and so the label of v evaluates to 1 under α because Av(yv) ∈ q.\nNext, we establish a tight correspondence between hypergraphs of degree at most 2 and OMQs with ontologies of depth 1."
    }, {
      "heading" : "5.2 Hypergraphs of Degree 2 and OMQs with Ontologies of Depth 1",
      "text" : "Theorem 8. For any OMQ Q = (T , q) with T of depth 1, the hypergraph H(Q) is of degree at most 2 and |H(Q)| ≤ 2|q|.\nProof. We have to show that every atom in q belongs to at most two q t , t ∈ ΘQ. Suppose t = (tr, ti) is a tree witness for Q and y ∈ ti. Since T is of depth 1, ti = {y} and tr consists of all the variables in q adjacent to y in the Gaifman graph Gq of q. Thus, different tree witnesses have different internal variables y. An atom of the form A(u) ∈ q is in q\nt iff u = y. An atom\nof the form P (u, v) ∈ q is in q t iff either u = y or v = y. Therefore, P (u, v) ∈ q can only be covered by the tree witness with internal u and by the tree witness with internal v.\nConversely, we show now that any hypergraph H of degree 2 is isomorphic to H(SH), for some OMQ SH = (T , q) with T of depth 1. We can assume that H = (V,E) comes with two fixed maps i1, i2 : V → E such that for every v ∈ V , we have i1(v) 6= i2(v), v ∈ i1(v) and v ∈ i2(v). For any v ∈ V , we fix a binary predicate Rv, and let the ontology T in SH contain the following axioms, for e ∈ E:\nAe(x) → ∃y [ ∧\nv∈V i1(v)=e\nRv(y, x) ∧ ∧\nv∈V i2(v)=e\nRv(x, y) ] .\nClearly, T is of depth 1. The Boolean CQ q contains variables ze, for e ∈ E, and is defined by taking\nq = { Rv(zi1(v), zi2(v)) | v ∈ V } .\nExample 10. Suppose that H = (V,E), where V = {v1, v2, v3, v4}, E = {e1, e2, e3} and e1 = {v1, v2, v3}, e2 = {v3, v4}, e3 = {v1, v2, v4}. Let\ni1 : v1 7→ e1, v2 7→ e3, v3 7→ e1, v4 7→ e2,\ni2 : v1 7→ e3, v2 7→ e1, v3 7→ e2, v4 7→ e3.\nThe hypergraph H and the query q are shown in Fig. 10: each Rvk is represented by an edge, i1(vk) is indicated by the circle-shaped end of the edge and i2(vk) by the diamond-shaped end of the edge; the ej are shown as large grey squares. In this case,\nq = ∃ze1 , ze2 , ze3 ( Rv1(ze1 , ze3) ∧Rv2(ze3 , ze1) ∧Rv3(ze1 , ze2) ∧Rv4(ze2 , ze3) )\nand T consists of the following axioms:\nAe1(x) → ∃y [ Rv1(y, x) ∧Rv2(x, y) ∧Rv3(y, x) ] , Ae2(x) → ∃y [ Rv3(x, y) ∧Rv4(y, x) ] , Ae3(x) → ∃y [ Rv1(x, y) ∧Rv2(y, x) ∧Rv4(x, y) ] .\nThe canonical model C Ae1 (a) T is shown on the right-hand side of Fig. 10. Note that each ze determines the tree witness te with q te = {Rv(zi1(v), zi2(v)) | v ∈ e}; distinct t e and te ′\nare conflicting iff e ∩ e′ 6= ∅. It follows that H is isomorphic to H(SH).\nTheorem 9. (i) Any hypergraph H of degree 2 is isomorphic to H(SH). (ii) Any monotone HGP P based on a hypergraph H of degree 2 computes a subfunction of the primitive evaluation function f△SH .\nProof. (i) We show that the map g : v 7→ Rv(zi1(v), zi2(v)) is an isomorphism between H and H(SH). By the definition of SH , g is a bijection between V and the atoms of q. For any e ∈ E, there is a tree witness te = (ter , t e i ) generated by Ae(x) with t e i = {ze} and ter = {ze′ | e ∩ e\n′ 6= ∅, e 6= e′}, and q\nte consists of the g(v), for v ∈ e. Conversely, every tree witness t for SH contains\nze ∈ ti, for some e ∈ E, and so qt = {g(v) | v ∈ e}.\n(ii) By Proposition 2 (i), P computes a subfunction of fH . Thus, it suffices to show that fH is a subfunction of f△SH . Let H = (V,E) be a hypergraph of degree 2. For any α ∈ {0, 1}\n|H|, we define γ by taking γ(Rv) = α(pv) for v ∈ V , γ(Ae) = α(pe) for e ∈ E (and γ(Pζ) = 0 for all normalisation predicates Pζ). We prove that fH(α) = 1 iff T ,A(γ) |= q. By the definition of T , for each e ∈ E with Ae(a) ∈ A(γ) or, equivalently, α(pe) = 1, the canonical model CT ,A(γ) contains a labelled null we such that\nCT ,A(γ) |= ∧\nv∈V i1(v)=e\nRv(we, a) ∧ ∧\nv∈V i2(v)=e\nRv(a, we).\n(⇒) Let E′ be an independent subset of E such that ∧ v∈V \\VE′ pv ∧ ∧\ne∈E′ pe is true on α. Define h : q → CT ,A(γ) by taking h(ze) = a if e /∈ E\n′ and h(ze) = we otherwise. One can check that h is a homomorphism, and so T ,A(γ) |= q.\n(⇐) Given a homomorphism h : q → CT ,A(γ), we show that E ′ = {e ∈ E | h(ze) 6= a} is independent. Indeed, if e, e′ ∈ E′ and v ∈ e ∩ e′, then h sends one variable of the Rv-atom to the labelled null we and the other end to we′ , which is impossible. We claim that fH(α) = 1. Indeed, for each v ∈ V \\ VE′ , h sends both ends of the Rv-atom to a, and so α(pv) = 1. For each e ∈ E′, we must have h(ze) = we because h(ze) 6= a, and so α(pe) = 1. It follows that fH(α) = 1."
    }, {
      "heading" : "5.3 Tree-Shaped OMQs and Tree Hypergraphs",
      "text" : "We call an OMQ Q = (T , q) tree-shaped if the CQ q is tree-shaped. We now establish a close correspondence between tree-shaped OMQs and tree hypergraphs that are defined as follows.11\nSuppose T = (VT , ET ) is an (undirected) tree. A leaf is a vertex of degree 1. A subtree T ′ = (V ′T , E ′ T ) of T is said to be convex if, for any non-leaf vertex u in the subtree T\n′, we have {u, v} ∈ E′T whenever {u, v} ∈ ET . A hypergraph H = (V,E) is called a tree hypergraph if there is a tree T = (VT , ET ) such that V = ET and every hyperedge e ∈ E induces a convex subtree Te of T . In this case, we call T the underlying tree of H . The boundary of a hyperedge e consists of all leaves of Te; the interior of e is the set of non-leaves of Te. A tree hypergraph program (THGP) is an HGP based on a tree hypergraph.\nExample 11. Let T be the tree shown in Fig. 11. Any tree hypergraph with underlying tree T has the set of vertices {{1, 2}, {2, 3}, {2, 6}, {3, 4}, {4, 5}} (each vertex is an edge of T ), and its hyperedges may include {{1, 2}, {2, 3}, {2, 6}} as the subtree of T induced by these edges is convex, but not {{1, 2}, {2, 3}}.\nTheorem 10. If an OMQ Q = (T , q) is tree-shaped, then H(Q) is isomorphic to a tree hypergraph. Furthermore, if q has at least one binary atom, then the number of leaves in the tree underlying H(Q) is the same as the number of leaves in q."
    }, {
      "heading" : "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka",
      "text" : "hypertree) from graph theory [28, 15, 16].\nProof. The case when q has no binary atoms is trivial. Otherwise, let Gq be the Gaifman graph of q whose vertices u are labelled with the unary atoms ξ(u) in q of the form A(u) and P (u, u), and whose edges {u, v} are labelled with the atoms of the form P (u, v) and P ′(v, u) in q. We replace every edge {u, v} labelled with P1(u′1, v ′ 1), . . . , Pn(u ′ n, v ′ n), for n ≥ 2, by a sequence of n edges forming a path from u to v and label them with P1(u ′ 1, v ′ 1), . . . , Pn(u ′ n, v ′ n), respectively. In the resulting tree, for every vertex u labelled with n unary atoms ξ1(u), . . . , ξn(u), for n ≥ 1, we pick an edge {u, v} labelled with some P (u′, v′) and replace it by a sequence of n+ 1 edges forming a path from u to v and label them with ξ1(u), . . . , ξn(u), P (u\n′, v′), respectively. The resulting tree T has the same number of leaves as q. It is readily checked that, for any tree witness t for Q, the set of edges in T labelled with atoms in q\nt forms a convex subtree of T ,\nwhich gives a tree hypergraph isomorphic to H(Q).\nSuppose H = (V,E) is a tree hypergraph whose underlying tree T = (VT , ET ) has vertices VT = {1, . . . , n}, for n > 1, and 1 is a leaf of T . Let T 1 = (VT , E1T ) be the directed tree obtained from T by fixing 1 as the root and orienting the edges away from 1. We associate with H a tree-shaped OMQ TH = (T , q), in which q is the Boolean CQ\nq = { Rij(zi, yij), Sij(yij , zj) | (i, j) ∈ E 1 T } ,\nwhere the zi, for i ∈ VT , are the variables for vertices of the tree and the yij , for (i, j) ∈ E 1 T , are the variables for the edges of the tree. To define T , suppose a hyperedge e ∈ E induces a convex directed subtree Te = (Ve, Ee) of T\n1 with root re ∈ Ve and leaves Le ⊆ Ve. Denote by T the ontology that contains the following axiom, for each e ∈ E:\nAe(x) → ∃y [ ∧\n(i,j)∈Ee, i=re Rrej(x, y) ∧\n∧\n(i,j)∈Ee, j∈Le Sij(y, x) ∧\n∃z ( ∧\n(i,j)∈Ee, i6=re Rij(z, y) ∧\n∧\n(i,j)∈Ee, j /∈Le Sij(y, z)\n)] .\nSince Te is convex, its root, re, has only one outgoing edge, (r e, j), for some j, and so the first conjunct above contains a single atom, Rrej(x, y). These axioms (together with convexity of hyperedges) ensure that TH has a tree witness t e = (ter , t e i ), for e ∈ E, with\nt e r = { zi | i is on the boundary of e }, t e i = { zi | i is in the interior of e } ∪ { yij | (i, j) ∈ e }.\nNote that T is of depth 2, and TH is of polynomial size in |H |.\nExample 12. Let H be the tree hypergraph whose underlying tree is as in Example 11 with fixed root 1 and whose only hyperedge is e = {{1, 2}, {2, 3}, {3, 4}, {2, 6}}. The CQ q and the canonical model CAe(a)T for this H are shown in Fig. 12. Note the homomorphism from qte into CAe(a)T .\nThe proofs of the following results (which are THGP analogues of Theorem 7 and Propositions 2 (ii) and 3, respectively) are given in Appendices B and C:\nTheorem 11. (i) Any tree hypergraph H is isomorphic to a subgraph of H(TH). (ii) Any monotone THGP based on a tree hypergraph H computes a subfunction of the primitive evaluation function f△TH .\nProposition 4. (i) For any tree hypergraph H of degree at most d, there is a monotone THGP of size O(|H |) that computes fH and such that its hypergraph is of degree at most max(2, d).\n(ii) For every generalised THGP P over n variables, there is a THGP P ′ such that |P ′| ≤ n · |P | and P ′ has the same degree and number of leaves as P and computes the same function."
    }, {
      "heading" : "5.4 OMQs with Bounded Treewidth CQs and Bounded Depth Ontologies",
      "text" : "Recall (see, e.g., [29]) that a tree decomposition of an undirected graph G = (V,E) is a pair (T, λ), where T is an (undirected) tree and λ a function from the set of nodes of T to 2V such that\n– for every v ∈ V , there exists a node N with v ∈ λ(N);\n– for every e ∈ E, there exists a node N with e ⊆ λ(N);\n– for every v ∈ V , the nodes {N | v ∈ λ(N)} induce a (connected) subtree of T .\nWe call the set λ(N) ⊆ V a bag for N . The width of a tree decomposition (T, λ) is the size of its largest bag minus one. The treewidth of G is the minimum width over all tree decompositions of G. The treewidth of a CQ q is the treewidth of its Gaifman graph Gq.\nExample 13. The Boolean CQ q = { R(y2, y1), R(y4, y1), S1(y3, y4), S2(y2, y4) } and its tree decomposition (T, λ) of width 2 are shown in Fig. 13, where T has two nodes, N1 and N2, connected by an edge, with bags λ(N1) = {y1, y2, y4} and λ(N2) = {y2, y3, y4}.\nOur aim in this section is to show that, for any OMQ Q(x) = (T , q(x)) with q of bounded treewidth and a finite fundamental set ΩQ, the modified tree-witness hypergraph function f H\nQ\ncan be computed using a monotone THGP of size bounded by a polynomial in |q| and |ΩQ|. Let (T, λ) be a tree decomposition of Gq of width m− 1. In order to refer to the variables of q, for each bag λ(N), we fix an order of variables in the bag and define a injection νN : λ(N) → {1, . . . ,m} that gives the index of each z in λ(N). A (bag) type is an m-tuple of the form w = (w[1], . . . ,w[m]), where each w[i] ∈ ΩQ. Intuitively, the ith component w[i] of w indicates that the ith variable in the bag is mapped to a domain element of the form aw[i] in the canonical model CT ,A. We say that a type w is compatible with a node N of T if the following conditions hold, for all z, z′ ∈ λ(N):\n(1) if A(z) ∈ q and w[νN (z)] 6= ε, then w[νN (z)] = w̺ and T |= ∃y ̺(y, x) → A(x); (2) if P (z, z′) ∈ q and either w[νN (z)] 6= ε or w[νN (z′)] 6= ε, then\n– w[νN (z)] = w[νN (z ′)] and T |= P (x, x), or – w[νN (z ′)] = w[νN (z)]̺ and T |= ̺(x, y) → P (x, y), or\n– w[νN (z)] = w[νN (z ′)]̺− and T |= ̺(x, y) → P (y, x).\nClearly, the type with all components equal to ε is compatible with any node N and corresponds to mapping all variables in λ(N) to individuals in ind(A).\nExample 14. Suppose T = {A(x) → ∃y R(x, y) } and q is the same as in Example 13. Let νN1 and νN2 respect the order of the variables in the bags shown in Fig. 13. The only types compatible with N1 are (ε, ε, ε) and (R, ε, ε), whereas the only type compatible with N2 is (ε, ε, ε).\nLet w1, . . . ,wM be all the bag types for ΩQ (M = |ΩQ|m). Denote by T ′ the tree obtained from T by replacing every edge {Ni, Nj} with the following sequence of edges:\n{Ni, u 1 ij}, {u k ij , v k ij} and {v k ij , u k+1 ij }, for 1 ≤ k < M, {u M ij , v M ij }, {v M ij , v M ji },\n{vMji , u M ji }, {u k+1 ji , v k ji} and {v k ji, u k ji}, for 1 ≤ k < M, {u 1 ji, Nj},\nfor some fresh nodes ukij , v k ij , u k ji and v k ji. We now define a generalised monotone THGP PQ based on a hypergraph with the underlying tree T ′. Denote by [L] the set of nodes of the minimal convex subtree of T ′ containing all nodes of L. The hypergraph has the following hyperedges:\n– Eki = [Ni, u k ij1 , . . . , u k ijn ] if Nj1 , . . . , Njn are the neighbours of Ni in T and wk is compatible\nwith Ni; – Ekℓij = [v k ij , v ℓ ji] if {Ni, Nj} is an edge in T and (wk,wℓ) is compatible with (Ni, Nj) in the\nsense that wk[νNi(z)] = wℓ[νNj (z)], for all z ∈ λ(Ni) ∩ λ(Nj).\nWe label the vertices of the hypergraph—that is, the edges of T ′—in the following way. The edges {Ni, u1ij}, {v k ij , u k+1 ij } and {v M ij , v M ji } are labelled with 0, and every edge {u k ij , v k ij} is labelled with the conjunction of the following variables:\n– pS(z), whenever S(z) ∈ q, z ⊆ λ(Ni) and wk[νNi(z)] = ε, for all z ∈ z; – p̺∗(z), whenever A(z) ∈ q, z ∈ λ(Ni) and wk[νNi(z)] = ̺w; – p̺∗(z), p̺∗(z′) and pz=z′ , whenever R(z, z\n′) ∈ q (possibly with z = z′), z, z′ ∈ λ(Ni), and either wk[νNi(z)] = ̺w or wk[νNi(z ′)] = ̺w.\nThe following result is proved in Appendix D:\nTheorem 12. For every OMQ Q = (T , q) with a fundamental set ΩQ and with q of treewidth t, the generalised monotone THGP PQ computes f H Q and is of size polynomial in |q| and |ΩQ| t.\nExample 15. Let Q = (T , q) be the OMQ from Example 14. As we have seen, there are only two types compatible with nodes in T : w1 = (ε, ε, ε) and w2 = (R, ε, ε). This gives us the generalised THGP PQ shown in Fig. 14, where the omitted labels are all 0. To explain the meaning of PQ, suppose T ,A |= q, for some data instance A. Then there is a homomorphism h : q → CT ,A. This homomorphism defines the type of bag N1, which can be either w1 (if h(z) ∈ ind(A) for all z ∈ λ(N1)) or w2 (if h(y1) = aR for some a ∈ ind(A)). These two cases are represented by the hyperedges E11 = [N1, u 1 12] and E 2 1 = [N1, u 2 12]. Since {N1, u 1 12} is labelled with 0, exactly one of them must be chosen to construct an independent subset of hyperedges covering all zeros. In contrast to that, there is no hyperedge E22 because w2 is not compatible with N2, and so E 1 2 = [u 1 21, N2] must be present in every covering of all zeros. Both (w1,w1) and (w2,w1) are compatible with (N1, N2), which gives E 11 12 = [v 1 12, v 1 21] and E 21 12 = [v 2 12, v 1 21]. Thus, if N1 is of type w1, then we include E 1 1 and E 11 12 in the covering of all zeros, and so pR(y4,y1) ∧ pR(y2,y1) should hold. If N1 is of type w2, then instead of E 11 12 , we take E 21 12 , and so py4=y1 ∧ py2=y1 ∧ pR∗(y1) ∧ pR∗(y2) ∧ pR∗(y4) should be true. Finally, since {v 1 21, u 1 21} does not belong to any hyperedge, pS1(y4,y3) ∧ pS2(y2,y3) must hold in either case."
    }, {
      "heading" : "5.5 Summary",
      "text" : "In Tables 1 and 2, we summarise the results of Section 5 that will be used in Section 7 to obtain lower and upper bounds for the size of OMQ rewritings. Table 1 shows how Theorems 8 and 10 (on the shape of tree-witness hypergraphs) combined with Proposition 2 (ii), as well as Theorem 12 provide us with hypergraph programs computing tree-witness hypergraph functions for OMQs. Table 2 contains the representation results of Theorems 7, 9 and 11 that show how abstract hypergraphs can be embedded into tree-witness hypergraphs of OMQs."
    }, {
      "heading" : "6 Hypergraph Programs and Circuit Complexity",
      "text" : "In the previous section, we saw how different classes of OMQs gave rise to different classes of monotone HGPs. Here we characterise the computational power of HGPs in these classes by relating them to standard models of computation for Boolean functions. Table 3 shows some of the obtained results. For example, its first row says that any Boolean function computable by a polynomial-size nondeterministic circuit can also be computed by a polynomial-size HGP of degree at most 3, and the other way round.\nWe remind the reader that the complexity classes in the table form the chain\nΠ3 $ AC 0 $ NC1 ⊆ NL/poly ⊆ LOGCFL/poly ⊆ P/poly ⊆ NP/poly (9)\nand that whether any of the non-strict inclusions is actually strict remains a major open problem in complexity theory; see, e.g., [3, 42]. All these classes are non-uniform in the sense that they are defined in terms of polynomial-size non-uniform sequences of Boolean circuits of certain shape and depth. The suffix ‘/poly’ comes from an alternative definition of C/poly in terms of Turing machines for the class C with an additional advice input of polynomial size.\nWhen talking about complexity classes, instead of individual Boolean functions, we consider sequences of functions f = {fn}n<ω with fn : {0, 1}n → {0, 1}. The same concerns circuits, HGPs and the other models of computation we deal with. For example, we say that a circuit C = {Cn}n<ω computes a function f = {fn}n<ω if Cn computes fn for every n < ω. (It will always be clear from context whether f , C, etc. denote an individual function, circuit, etc. or a sequence thereof.) A circuit C is said to be polynomial if there is a polynomial p : N → N such that |Cn| ≤ p(n), for every n < ω. The depth of Cn is the length of the longest directed path from an input to the output of Cn.\nThe complexity class P/poly can be defined as comprising those Boolean functions that are computed by polynomial circuits, and NC1 consists of functions computed by polynomial formulas (that is, circuits every logic gate in which has at most one output). Alternatively, a Boolean function is in NC1 iff it can be computed by a polynomial-size circuit of logarithmic depth, whose and- and or-gates have two inputs.\nLOGCFL/poly (also known as SAC1) is the class of Boolean functions computable by polynomialsize and logarithmic-depth circuits in which and-gates have two inputs but or-gates can have arbitrarily many inputs (unbounded fan-in) and not-gates can only be applied to inputs of the circuit [76]. AC0 is the class of functions computable by polynomial-size circuits of constant depth with and- and or-gates of unbounded fan-in and not-gates only at the inputs; Π3 is the subclass of AC0 that only allows circuits of depth 3 (not counting the not-gates) with an output and-gate.\nFinally, a Boolean function f = {fn}n<ω is in the class NP/poly if there is a polynomial p and a polynomial circuit C = {Cn+p(n)}n<ω such that, for any n and α ∈ {0, 1} n,\nfn(α) = 1 iff there is β ∈ {0, 1} p(n) such that Cn+p(n)(α,β) = 1 (10)\n(the β-inputs are sometimes called certificate inputs). By allowing only monotone circuits or formulas in the definitions of the complexity classes, we obtain their monotone variants: for example, the monotone variant of NP/poly is denoted by mNP/poly and defined by restricting the use of not-gates in the circuits to the certificate inputs only. We note in passing that the monotone variants of the classes in (9) also form a chain [64,"
    }, {
      "heading" : "2, 44]:",
      "text" : "mΠ3 $ mAC 0 $ mNC1 $ mNL/poly ⊆ mLOGCFL/poly $ mP/poly $ mNP/poly. (11)\nWhether the inclusion mNL/poly ⊆ mLOGCFL/poly is proper remains an open problem. We use these facts in the next section to show lower bounds on the size of OMQ rewritings.\n6.1 NP/poly and HGP3\nOur first result shows that NP/poly and mNP/poly coincide with the classes HGP3 and mHGP3 of Boolean functions computable by polynomial-size (sequences of) HGPs and monotone HGPs of degree at most 3, respectively.\nTheorem 13. NP/poly = HGP = HGP3 and mNP/poly = mHGP = mHGP3.\nProof. Suppose P is a (monotone) HGP. We construct a non-deterministic circuit C of size polynomial in |P |, whose input variables are the same as the variables in P , certificate inputs correspond to the hyperedges of P , and such that C(α,β) = 1 iff {ei | β(ei) = 1} is an independent set of hyperedges covering all zeros under α. It will then follow that\nP (α) = 1 iff there is β such that C(α,β) = 1. (12)\nFirst, for each pair of intersecting hyperedges ei, ej in P , we take the disjunction ¬ei ∨ ¬ej , and, for each vertex in P labelled with a literal l (that is, p or ¬p) and the hyperedges ei1 , . . . , eik incident to it, we take the disjunction l∨ei1 ∨· · ·∨eik . The circuit C is then a conjunction of all such disjunctions. Note that if P is monotone, then ¬ is only applied to the certificate inputs, e, in C.\nConversely, let C be a circuit with certificate inputs. We construct an HGP P of degree at most 3 satisfying (12) as follows. For each gate gi in C, the HGP contains a vertex gi labelled with 0 and a pair of hyperedges ēi and ei, both containing gi. No other hyperedge contains gi, and so either ēi or ei should be present in any cover of zeros. To ensure this property, for each gate gi, we add the following vertices and hyperedges to P (see Fig. 15):\n– if gi is an input p, then we add a vertex labelled with ¬p to ei and a vertex labelled with p to ēi; – if gi is a certificate input, then no additional vertices and hyperedges are added; – if gi = ¬gj , then we add a vertex labelled with 1 to hyperedges ei and ēj, and a vertex labelled with 1 to hyperedges ēi and ej; – if gi = gj ∨ gk, then we add a vertex labelled with 1 to hyperedges ej and ēi, add a vertex labelled with 1 to ek and ēi; then, we add vertices vj and vk labelled with 1 to ēj and ēk, respectively, and a vertex ui labelled with 0 to ēi; finally, we add hyperedges {vj , ui} and {vk, ui} to P ; – if gi = gj ∧ gk, then we add the pattern dual to the case of gi = gj ∨ gk: we add a vertex labelled with 1 to ēj and ei, a vertex labelled with 1 to ēk and ei; then, we add vertices vj and vk labelled with 1 to ej and ek, respectively, and a vertex ui labelled with 0 to ei; finally, we add hyperedges {vj, ui} and {vk, ui} to P .\nFinally, we add one more vertex labelled with 0 to em for the output gate gm of C, which ensures that em must be included the cover. It is easily verified that the constructed HGP is of degree at most 3. One can establish (12) by induction on the structure of C. We illustrate the proof of the inductive step for the case of gi = gj ∨ gk: we show that ei is in the cover iff it contains either ej or ek. Suppose the cover contains ej. Then it cannot contain ēi, and so it contains ei. The vertex ui in this case can be covered by {vj , ui} since ēj is not in the cover. Conversely, if neither ej nor ek is in the cover, then it must contain both ēj and ēk, and so neither {vj, ui} nor {vk, ui} can belong to the cover, and thus we will have to include ēi to the cover.\nIf C is monotone, then we remove from P all vertices labelled with ¬p, for an input p, and denote the resulting program by P ′. We claim that, for any α, we have P ′(α) = 1 iff there is β such that C(α,β) = 1. The implication (⇐) is trivial: if C(α,β) = 1 then, by the argument above, P (α) = 1 and, clearly, P ′(α) = 1. Conversely, suppose P ′(α) = 1. Each of the vertices gi in P\n′ corresponding to the inputs is covered by one of the hyperdges ei or ēi. Let α′ be the vector corresponding to these hyperedges; clearly, α′ ≤ α. This cover of vertices of P ′ gives us P (α′) = 1. Thus, by the argument above, there is β such that C(α′,β) = 1. Since C is monotone, C(α,β) = 1.\n6.2 NL/poly and HGP2\nA Boolean function belongs to the class NL/poly iff it can be computed by a polynomial-size nondeterministic branching program (NBP). We remind the reader (consult [42] for more details)\nthat an NBP B is a directed graph G = (V,E), whose arcs are labelled with the Boolean constants 0 and 1, propositional variables p1, . . . , pn or their negations, and which distinguishes two vertices s, t ∈ V . Given an assignment α to variables p1, . . . , pn, we write s →α t if there is a path in G from s to t all of whose labels evaluate to 1 under α. We say that an NBP B computes a Boolean function f if f(α) = 1 iff s →α t, for any α ∈ {0, 1}n. The size |B| of B is the size of the underlying graph, |V |+ |E|. An NBP is monotone if there are no negated variables among its labels. The class of Boolean functions computable by polynomial-size monotone NBPs is denoted by mNL/poly; the class of functions f whose duals f∗(p1, . . . , pn) = ¬f(¬p1, . . . ,¬pn) are in mNL/poly is denoted by co-mNL/poly.\nTheorem 14. NL/poly = HGP2 and co-mNL/poly = mHGP2.\nProof. As follows from [73, 40], if a function f is computable by a polynomial-size NBP, then ¬f is also computable by a polynomial-size NBP. So suppose ¬f is computed by an NBP B. We construct an HGP P computing f of degree at most 2 and polynomial size in |B| as follows (see Fig. 16). For each arc e in B, the HGP P has two vertices e0 and e1, which represent the beginning and the end of e, respectively. The vertex e0 is labelled with the negated label of e in B and e1 with 1. For each arc e in B, the HGP P has an e-hyperedge {e0, e1}. For each vertex v in B but s and t, the HGP P has a v-hyperedge comprising all vertices e1 for the arcs e leading to v, and all vertices e0 for the arcs e leaving v. We also add to the HGP P a vertex w labelled with 0 and a hyperedge, ēw, that consists of w and all vertices e\n1 for the arcs e in B leading to t. We claim that the constructed HGP P computes f . Indeed, if s 6→α t then the following subset of hyperedges is independent and covers all zeros: all e-hyperedges, for the arcs e reachable from s and labelled with 1 under α, and all v-hyperedges with s 6→α v (including ēw). Conversely, if s →α t then one can show by induction that, for each arc e of the path, the e-hyperedge must be in the cover of all zeros. Thus, no independent set can cover w, which is labelled with 0.\nConversely, suppose f is computed by an HGP P of degree 2 with hyperedges e1, . . . , ek. We first provide a graph-theoretic characterisation of independent sets covering all zeros based on the implication graph [5]. With every hyperedge ei we associate a propositional variable ui and with every assignment α we associate the following set Φα of propositional binary clauses:\n¬ui ∨ ¬uj , if ei ∩ ej 6= ∅,\nui ∨ uj, if there is v ∈ ei ∩ ej with α(v) = 0.\nInformally, the former means that intersecting hyperedges cannot be chosen at the same time and the latter that all zeros must be covered; note that all vertices have at most two incident edges. By definition, X is an independent set covering all zeros iff X = {ei | γ(ui) = 1}, for some assignment γ satisfying Φα. Let Cα = (V,Eα) be the implication graph of Φα, that is, a directed graph with\nV = { ui, ūi | 1 ≤ i ≤ k } ,\nEα = { (ui, ūj) | ei ∩ ej 6= ∅ } ∪ { (ūi, uj) | there is v ∈ ei ∩ ej with α(v) = 0 } .\n(V is the set of all ‘literals’ for the variables of Φα and Eα is the arcs for the implicational form of the clauses of Φα.) Note that ¬ui∨¬uj gives rise to two implications, ui → ¬uj and uj → ¬ui, and so to two arcs in the graph; similarly, for ui∨uj. By [5, Theorem 1], Φα is satisfiable iff there\nis no ui with a (directed) cycle going through ui and ūi. It will be convenient for us to regard the Cα, for assignments α, as a single labelled directed graph C with arcs of the form (ui, ūj) labelled with 1 and arcs of the form (ūi, uj) labelled with the negation of the literal labelling the uniquely defined v ∈ ei ∩ ej (recall that the hypergraph of P is of degree 2). It should be clear that Cα has a cycle going through ui and ūi iff we have both ūi →α ui and ui →α ūi in C. The required NBP B contains distinguished vertices s and t, and, for each hyperedge ei in P , two copies, C0i and C 1 i , of C with additional arcs from s to the ūi vertex of C 0 i , from the ui vertex of C0i to the ui vertex of C 1 i , and from the ūi vertex of C 1 i to t; see Fig. 17. By construction, s →α t iff there is a hyperedge ei in P such that Cα contains a cycle going through ui and ūi. We have thus constructed a polynomial-size NBP B computing ¬f , and thus f must also be computable by a polynomial-size NBP.\nAs to co-mNL/poly = mHGP2, observe that the first construction, if applied to a monotone NBP for f∗, produces a polynomial-size HGP of degree 2 computing ¬f∗, all of whose labels are negative. By removing negations from labels, we obtain a monotone HGP computing f . The second construction allows us to transform a monotone HGP of degree 2 for f into an NBP with only negative literals that computes ¬f . By changing the polarity of the literals in the labels, we obtain a monotone NBP computing f∗."
    }, {
      "heading" : "6.3 NL/poly and THGP(ℓ)",
      "text" : "For any natural ℓ ≥ 2, we denote by THGP(ℓ) and mTHGP(ℓ) the classes of Boolean functions computable by (sequences of) polynomial-size THGPs and, respectively, monotone THGPs whose underlying trees have at most ℓ leaves.\nTheorem 15. NL/poly = THGP(ℓ) and mNL/poly = mTHGP(ℓ), for any ℓ ≥ 2.\nProof. Suppose a polynomial-size THGP P computes a Boolean function f . For simplicity, we consider only ℓ = 2 here and prove the general case in Appendix E. Thus, we can assume that the vertices v1, . . . , vn of P are consecutive edges of the path graph underlying P , and therefore, every hyperedge in P is of the form [vi, vi+m] = {vi, . . . , vi+m}, for somem ≥ 0. We add to P two extra vertices, v0 and vn+1 (thereby extending the underlying 2-leaf tree to v0, v1, . . . , vn, vn+1) and label them with 0; we also add two hyperedges s = {v0} and t = {vn+1} to P . Clearly, the resulting THGP P ′ computes the same f . To construct a polynomial-size NBP B computing f , we take a directed graph whose vertices are hyperedges of P ′ and which contains an arc from ei = [vi1 , vi2 ] to ej = [vj1 , vj2 ] iff i2 < j1; we label this arc with ∧ i2<k<j1 lk, where lk is the label of vk in HGP P . It is not hard to see that a path from s to t evaluated to 1 under given assignment α corresponds to a cover of zeros in P ′ under α. Finally, to get rid of conjunctive labels on edges, we replace every arc with a label li1∧· · ·∧lik by a sequence of k arcs consequently labelled with li1 , . . . , lik .\nConversely, suppose a Boolean function f is computed by an NBP B based on a directed graph with vertices V = {v1, . . . , vn}, edges E = {e1, . . . , em}, s = v1 and t = vn. Without loss of generality, we assume that em is a loop from t to t labelled with 1. Thus, if there is a path from s to t whose labels evaluate to 1, then there is such a path of length n − 1. We now construct a polynomial-size THGP computing f whose underlying tree T has two leaves. The vertices of the tree T are arranged into n vertex blocks and n − 1 edge blocks, which alternate. The kth vertex (edge) block contains two copies vki , v̄ k i (respectively, e k i , ē k i ) of every vi ∈ V (respectively, ei ∈ E):\nv11 , v̄ 1 1 , v 1 2 , v̄ 1 2 , . . . , v 1 n, v̄ 1 n, ︸ ︷︷ ︸\n1st vertex block\ne11, ē 1 1, e 1 2, ē 1 2, . . . , e 1 m, ē 1 m, ︸ ︷︷ ︸\n1st edge block\nv21 , v̄ 2 1 , v 2 2 , v̄ 2 2 , . . . , v 2 n, v̄ 2 n, ︸ ︷︷ ︸\n2nd vertex block\n. . .\nen−11 , ē n−1 1 , e n−1 2 , ē n−1 2 , . . . , e n−1 m , ē n−1 m , ︸ ︷︷ ︸\n(n − 1)th edge block\nvn1 , v̄ n 1 , v n 2 , v̄ n 2 , . . . , v n n , v̄ n n ︸ ︷︷ ︸\nnth vertex block\n.\nWe remove the first, v11 , and last vertex, v̄ n n (shown in grey in the formula above), and connect the adjacent vertices by edges to construct the undirected tree T . Consider now a hypergraph H whose vertices are the edges of T and hyperedges are of the form hki = [v̄ k j , e k i ] and g k i = [ē k i , v k+1 j′ ], for ei = (vj , vj′ ) ∈ E and 1 ≤ k < n. The vertices of H of the form {eki , ē k i }, which separate hyperedges hki and g k i , are labelled with the label of ei in the given NBP B, and all other vertices of H with 0. We show now that the constructed THGP P computes f . Indeed, if f(α) = 1, then there is a path ei1 , . . . , ein−1 from v1 to vn whose labels evaluate to 1 under α. It follows that {hkik , g k ik\n| 1 ≤ k < n} is an independent set in H covering all zeros. Conversely, if E′ is an independent set in H and covers all zeros under α, then it must contain exactly one pair of hyperedges hkik and g k ik for every k with 1 ≤ k < n, and the corresponding sequence of edges ei1 , . . . , ein−1 defines a path from v1 to vn. Moreover, since E ′ does not cover vertices {ekik , ē k ik }, for 1 ≤ k < n, their labels (that is, the labels of the eik in B) evaluate to 1 under α.\nTo prove Theorem 25 below, we shall require a somewhat different variant of Theorem 15. The proof of the following result is given in Appendix E:\nTheorem 16. Fix ℓ ≥ 2. For any tree hypergraph H based on a tree with at most ℓ leaves, the function fH can be computed by an NBP of size polynomial in |H |.\nNote that Theorem 16 does not immediately follow from Theorem 15 and Proposition 4 (i) because the transformation of H into a monotone HGP computing fH given in the proof of Proposition 4 (i) does not preserve the number of leaves."
    }, {
      "heading" : "6.4 LOGCFL/poly and THGP",
      "text" : "THGP and mTHGP are the classes of functions computable by polynomial-size THGPs and, respectively, monotone THGPs.\nTheorem 17. LOGCFL/poly = THGP and mLOGCFL/poly = mTHGP.\nProof. To show LOGCFL/poly ⊆ THGP, consider a SAC1-circuit C of depth d ≤ log |C|. It will be convenient to think of C as containing no not-gates but having literals as inputs. By the and-depth of a gate g in C we mean the maximal number of and-gates in a path from an input of C to g (it does not exceed d). Let Sn be the set of and-gates in C of and-depth n. We denote\nby left(g) and right(g) the sub-circuits of C computing the left and right inputs of an and-gate g, respectively. Without loss of generality (see Lemma 2 in Appendix F) we can assume that, for any n ≤ d,\n⋃\ng∈Sn left(g) ∩\n⋃\ng∈Sn right(g) = ∅.\nOur aim is to transform C into a polynomial-size THGP P . We construct its underlying tree T by associating with each gate gi three vertices ui, vi, wi and arranging them into a tree as shown in Fig. 18. More precisely, we first arrange the vertices associated with the gates of maximal and-depth, n, into a path following the order of the gates in C and the alphabetic order for ui, vi, wi. Then we fork the path into two branches one of which is associated with the sub-circuit⋃\ng∈Sn left(g) and the other with ⋃\ng∈Sn right(g), and so forth. We obtain the tree T by removing the vertex wm from the result, where m = |C| and gm is the output gate of C; it has vm as its root and contains 3|C| − 1 vertices. The THGP P is based on the hypergraph whose vertices are the edges of T and whose hyperedges comprise the following (see Fig. 18):\n– [wi, ui], for each i < m (pairs of edges in each triple of vertices in Fig. 18); – [vj , vk, vi], for each gi = gj ∧ gk (shown in Fig. 18 by shading); – [vj1 , vi], . . . , [vjk , vi], for each gi = gj1 ∨ · · · ∨ gjk ,\nwhere [L] is the minimal convex subtree of T containing the vertices in L. Finally, if an input gate gi is a literal l, we label the edge {ui, vi} with l; we label all other {uj, vj}- and {wj, vj}-edges with 0, and the remaining ones with 1. Clearly, the size of P is polynomial in |C|. By Lemma 3, for any input α, the output of gi is 1 iff the subtree with root vi can be covered, i.e., there is an independent set of hyperedges wholly inside and covering all zeros. Thus, P computes the same function as C.\nTo show THGP ⊆ LOGCFL/poly, suppose a THGP P is based on a hypergraph H with an underlying tree T . By a subtree of T we understand a (possibly empty) connected subset of edges in T . Given an input α for P and a nonempty subtree D of T , we set coverD true iff there exists an independent subset of hyperedges in H that lie in D and cover all zeros in D. We also set cover∅ true. Note that, for any edge e of T , cover{e} is true if {e} is a hyperedge of H ; otherwise cover{e} is the value of e’s label in P under α.\nOur aim is to construct recursively a polynomial-size SAC1-circuit C computing the function coverT . Observe that, if D is a subtree of T and a vertex v splits D into subtrees D1, . . . , Dk, then\ncoverD = ∧\n1≤j≤k coverDj ∨\n∨\nv∈h⊆D\n∧\n1≤j≤kh coverDh j , (13)\nwhere h ranges over the hyperedges in H , and Dh1 , . . . , D h kh\nare the maximal convex subtrees of T that lie in D \\ h. We call a vertex v of D boundary if T has an edge {v, u} with u not in D, and define the degree deg(D) of D to be the number of its boundary vertices. Note that T itself is the only subtree of T of degree 0. The following lemma shows that to compute coverT we only need subtrees of degree 1 and 2 and the depth of recursion O(log |P |).\nLemma 1. Let D be a subtree of T with m vertices and deg(D) ≤ 2. If deg(D) ≤ 1, then there is a vertex v splitting D into subtrees of size at most m/2 + 1 and degree at most 2. If deg(D) = 2, then there is v splitting D into subtrees of size at most m/2+ 1 and degree at most"
    }, {
      "heading" : "2 and, possibly, one subtree of size less than m and degree 1.",
      "text" : "Proof. Let deg(D) ≤ 1. Suppose some vertex v1 splits D into subtrees one of which, say D1, is larger than m/2 + 1. Let v2 be the (unique) vertex in D1 adjacent to v1. The splitting of D by v2 consists of the subtree D2 = (D \\D1)∪ {v1, v2} of size at most m/2 and some other subtrees lying inside D1; all of them are of degree at most 2. We repeat this process until the size of the largest subtree becomes at most m/2 + 1.\nLet deg(D) = 2, with b1 and b2 being the boundary vertices. We proceed as above starting from v1 = b1, but stop when either the largest subtree has ≤ m/2 + 1 vertices or vi+1 leaves the path between b1 and b2, in which case vi splits D into subtrees of degree at most 2 and one subtree of degree 1 with more than m/2 + 1 vertices.\nBy applying (13) to T recursively and choosing the splitting vertices v as prescribed by Lemma 1, we obtain a circuit C whose inputs are the labels of some vertices of H . Since any tree has polynomially many subtrees of degree 1 or 2, the size of C is polynomial in |P |. We now show how to make the depth of C logarithmic in |P |.\nSuppose D is a subtree with m edges constructed on the recursion step i. To compute coverD using (13), we need one or-gate of unbounded fan-in and a number of and-gates of fan-in 2. We show by induction that we can make the and-depth of these and-gates at most logm + i. Suppose Dj in (13) has mj edges, and som = m1+· · ·+mk. By the induction hypothesis, we can compute each coverDj within the and-depth at most logmj+i−1. Assign the probability mj/m to Dj. As shown by Huffman [39], there is a prefix binary code such that each Dj is encoded by a word of length ⌈log(m/mj)⌉. This encoding can be represented as a binary tree whose leaves are labelled with the Dj so that the length of the branch ending at Dj is ⌈log(m/mj)⌉. By replacing each non-leaf vertex of the tree with an and-gate, we obtain a circuit for the first conjunction in (13) whose depth does not exceed\nmax j {logmj + (i− 1) + log(m/mj) + 1} = logm+ i.\nThe second conjunction is considered analogously. ⊓⊔\n6.5 NC1, Π3 and THGP d\nThe proof of the following theorem, given in Appendix F, is a simplified version of the proof of Theorem 17:\nTheorem 18. NC1 = THGPd and mNC1 = mTHGPd, for any d ≥ 3.\nTHGPs of degree 2 turn out to be less expressive:\nTheorem 19. Π3 = THGP 2 = THGP2(2) and mΠ3 = mTHGP 2 = mTHGP2(2).\nProof. To show THGP2 ⊆ Π3, take a THGP P of degree 2. Without loss of generality we can assume that it contains no hyperedges e, e′ with e ⊆ e′, for otherwise the vertices in e would not be covered by any other hyperedges, and so could be removed from P together with e.\nConsider the graph D whose vertices are the hyperedges of P , with two vertices being connected if the corresponding hyperedges intersect. Clearly, D is a forest. We label an edge {e1, e2} with the conjunction of the labels of the vertices in e1 ∩ e2, and label a vertex e with the conjunction of the labels of the vertices in P contained exclusively in e. It is easy to see that, for any given input, an independent cover of zeros in P corresponds to an independent set in D covering all zeros in the vertices and such that each edge labelled with 0 has precisely one endpoint in that independent set.\nWe claim that there is no such an independent set I in D iff there is a path e0, e1, . . . , ek in D with odd k (in particular, k = 1) such that e0 and ek are labelled with 0 and ‘even’ edges {ei−1, ei} with even i are labelled with 0. To see (⇐), observe that we have to include e0 and ek in I. Then, the edge {e1, e2} labelled with 0 makes us to include e2 to I (e1 is adjacent to e and cannot be included in I). Next, the edge {e3, e4} makes us to include e4 in I and so on. In the end we will have to include ek−1 to I and, since ek is also in I, this gives a contradiction with independence of I.\nTo show (⇒), suppose there is no such a pair of vertices. Then we can construct a desired independent set I. Add to I all vertices labelled with 0. If there is a triple of consecutive vertices e, e1, e2 in D such that e is already in I and an edge {e1, e2} is labelled with 0, then we add e2 to I. Note that, if we have add some vertex e\n′ to e in this process, then there is a path e = e0, e1, . . . , ek = e\n′ with even k such that vertex e is labelled with 0 and every edge {ei−1, ei} for even i in this path is labelled with 0.\nIn this process we never add two connected vertices e and e′ of D to I, for otherwise the union of the paths described above for these two vertices would result in a path of odd length with endpoints labelled with 0 and with every second edge labelled with 0. This directly contradicts our assumption.\nIf there are still edges labelled with 0 in D with no endpoints in I, then add any endpoint of such an edge to I and repeat the process above. This also will not lead to a pair of connected vertices in I. Indeed, if as a result we add to I a vertex e1 connected to a vertex e which was added to I previously, then there is an edge {e2, e1} labelled with 0 (that was the reason for adding e1 to I), and so we should have added e2 to I before. By repeating this process, we obtain an independent set I covering all vertices and edges labelled with 0.\nThe established claim means that an independent set I in D exists iff, for any simple path e0, e1, . . . , ek with an odd k, the label of e0 or ek evaluates to 1, or the label of at least one {ei−1, ei}, for even i, evaluates to 1. This property is computed by a Π3-circuit where, for each simple path e0, e1, . . . , ek with an odd k, we take (k + 3)/2-many and-gates whose inputs are the literals in the labels of e0, ek and the {ei−1, ei} for even i; then we send the outputs of those and-gates to an or-gate; and, finally, we collect the outputs of all the or-gates as inputs to an and-gate.\nTo show Π3 ⊆ THGP 2(2), suppose we are given a Π3-circuit C. We can assume C to be a conjunction of DNFs. So, we first construct a generalised HGP P from THGP2(2) computing the same function as C. Denote the or-gates of C by g1, . . . , gk and the inputs of gi by hi1, . . . , h i li , where each hij is an and-gate. Now, we define a tree hypergraph whose underlying path graph has the following edges (in the given order)\nv10 , . . . , v 1 2l1−2, v 2 0 , . . . , v 2 2l2−2, . . . , v k 0 , . . . , v k 2lk−2\nand whose hyperedges are of the form {vij , v i j+1}. We label v i 2m with a conjunction of the inputs of him+1 and the remaining vertices with 0. By the previous analysis for a given i and an input for C, we can cover all zeros among vi0, . . . , v i 2li−2 with an independent set of hyperedges iff at least one of the gates hi1, . . . , h i li outputs 1. For different i, the corresponding vi0, . . . , v i 2li−2 are covered independently. Thus, P computes the same function as C. We convert P to a THGP from THGP2(2) using Proposition 4 (ii)."
    }, {
      "heading" : "7 The Size of OMQ Rewritings",
      "text" : "In this section, by an OMQ Q = (T , q) we mean a sequence {Qn = (Tn, qn)}n<ω of OMQs whose size is polynomial in n; by a rewriting q′ of Q we mean a sequence {q′n}n<ω, where each q′n is a rewriting of Qn, for n < ω.\nBy putting together the results of the previous three sections and some known facts from circuit complexity, we obtain the upper and lower bounds on the size of PE-, NDL- and FOrewritings for various OMQ classes that are collected in Table 4, where exp means an exponential\nlower bound, > poly a superpolynomial lower bound, poly a polynomial upper bound, poly-Π4 a polynomial-size Π4-rewriting (that is, a PE-rewriting with the matrix of the form ∧∨∧∨), and ℓ and t are any fixed constants. It is to be noted that, in case of polynomial upper bounds, we actually provide polynomial algorithms for constructing rewritings."
    }, {
      "heading" : "7.1 Rewritings for OMQs with ontologies of depth 2",
      "text" : "By Theorem 13, OMQs with ontologies of depth 2 can compute any NP-complete monotone Boolean function, in particular, the function Clique with n(n − 1)/2 variables ejj′ , 1 ≤ j < j′ ≤ n, that returns 1 iff the graph with vertices {1, . . . , n} and edges {{j, j′} | ejj′ = 1} contains a k-clique, for some fixed k. A series of papers, started by Razborov [64], gave an exponential lower bound for the size of monotone circuits computing Clique, namely, 2Ω( √ k) for k ≤ 14 (n/ logn) 2/3 [2]. For monotone formulas, an even better lower bound is known: 2Ω(k) for k = 2n/3 [63]. Thus, we obtain:\nTheorem 20. There is an OMQ with ontologies of depth 2, any PE- and NDL-rewritings of which are of exponential size, while any FO-rewriting is of superpolynomial size unless NP ⊆ P/poly.\nProof. In view of Clique ∈ NP ⊆ NP/poly and Theorem 13, there is a polynomial-size monotone HGP P computing Clique. Suppose P is based on a hypergraph H and QH is the OMQ for H constructed in Section 5.1. By Theorem 7 (ii), Clique is a subfunction of the primitive evaluation function f△QH . By Theorem 6, if q ′ is a PE- or NDL-rewriting of QH , then f △ QH —and so Clique—can be computed by a monotone formula or, respectively, circuit of size O(|q′|). Thus, q′ must be of exponential size. If q′ is an FO-rewriting ofQH then, by Theorem 6, Clique is computable by a Boolean formula of size O(|q′|). If NP 6⊆ P/poly then Clique cannot be computed by a polynomial circuit, and so q′ must be of superpolynomial size.\nOur next theorem gives a complexity-theoretic characterisation of the existence of FOrewritings for OMQs with ontologies of depth 2.\nTheorem 21. The following conditions are equivalent :\n(1) all OMQs with ontologies of depth 2 have polynomial-size FO-rewritings ; (2) all OMQs with ontologies of depth 2 and polynomially many tree witnesses have polynomial-\nsize FO-rewritings ; (3) NP/poly ⊆ NC1.\nProof. The implication (1) ⇒ (2) is obvious. To show that (2) ⇒ (3), suppose there is a polynomial-size FO-rewriting for the OMQ QH from the proof of Theorem 20, which has polynomially many tree witnesses. Then Clique is computed by a polynomial-size Boolean formula. Since Clique is NP/poly-complete under NC1-reductions, we have NP/poly ⊆ NC1. Finally, to prove (3) ⇒ (1), assume NP/poly ⊆ NC1. Let Q be an arbitrary OMQ with ontologies of depth 2. As observed in Section 4.1, the function fHQ is in NP ⊆ NP/poly. Therefore, by our assumption, fHQ can be computed by a polynomial-size formula, and so, by Theorem 5, Q has a polynomial-size FO-rewriting."
    }, {
      "heading" : "7.2 Rewritings for OMQs with ontologies of depth 1",
      "text" : "Theorem 22. Any OMQ Q with ontologies of depth 1 has a polynomial-size NDL-rewriting.\nProof. By Theorem 8, the hypergraphH(Q) is of degree at most 2, and so, by Proposition 2 (ii), there is a polynomial-size monotone HGP of degree at most 2 computing f▽Q. By Theorem 14, co-mNL/poly = mHGP2, and so we have a polynomial-size monotone NBP computing the dual f▽Q ∗ of f▽Q. Since mNL/poly ⊆ mP/poly, we also have a polynomial-size monotone Boolean circuit that computes f▽Q ∗ . By swapping and- and or-gates in that circuit, we obtain a polynomial-size monotone circuit computing f▽Q. It remains to apply Theorem 4 (ii).\nHowever, this upper bound cannot be extended to PE-rewritings:\nTheorem 23. There is an OMQ Q with ontologies of depth 1, any PE-rewriting of which is of superpolynomial size (nΩ(log n), to be more precise).\nProof. Consider the monotone function Reachability that takes the adjacency matrix of a directed graph G with two distinguished vertices s and t and returns 1 iff the graph G contains a directed path from s to t. It is known [44, 42] that Reachability is computable by a polynomial-size monotone NBP (that is, belongs to mNL/poly), but any monotone Boolean formula for Reachability is of size nΩ(logn). Let f = Reachability. By Theorem 14, there is a polynomial-size monotone HGP that is based on a hypergraph H of degree 2 and computes the dual f∗ of f . Consider now the OMQ SH for H defined in Section 5.2. By Theorem 9 (ii), f∗ is a subfunction of f△SH . By Theorem 6 (i), no PE-rewriting of the OMQ SH can be shorter than nΩ(logn).\nTheorem 24. All OMQs with ontologies of depth 1 have polynomial-size FO-rewritings iff NL/poly ⊆ NC1.\nProof. Suppose NL/poly ⊆ NC1. Let Q be an OMQ with ontologies of depth 1. By Theorem 8, its hypergraphH(Q) is of degree 2 and polynomial size. By Proposition 2 (ii), there is a polynomialsize HGP of degree 2 that computes f▽Q. By Theorem 14, f ▽\nQ ∈ NL/poly. Therefore, by our assumption, f▽Q can be computed by a polynomial-size Boolean formula. Finally, Theorem 4 (i) gives a polynomial-size FO-rewriting of Q.\nConversely, suppose there is a polynomial-size FO-rewriting for any OMQ with ontologies of depth 1. Let f = Reachability. Since f ∈ NL ⊆ NL/poly, by Theorem 14, we obtain a polynomial-size HGP computing f and based on a hypergraph H of degree 2. Consider the OMQ SH with ontologies of depth 1 defined in Section 5.2. By Theorem 9 (ii), f a subfunction of f△SH . By our assumption, SH has a polynomial-size FO-rewriting; hence, by Theorem 6 (i), f△SH (and so f) are computed by polynomial-size Boolean formulas. Since f is NL/poly-complete under NC1-reductions [65], we obtain NL/poly ⊆ NC1."
    }, {
      "heading" : "7.3 Rewritings for tree-shaped OMQs with a bounded number of leaves",
      "text" : "Since, by Theorem 16, the hypergraph function of a leaf-bounded OMQ can be computed by a polynomial-size NBP, we have:\nTheorem 25. For any fixed ℓ ≥ 2, all tree-shaped OMQs with at most ℓ leaves have polynomialsize NDL-rewritings.\nThe superpolynomial lower bound below is proved in exactly the same way as Theorem 23 using Theorems 15 and 11 instead of Theorems 14 and 9.\nTheorem 26. There is an OMQ with ontologies of depth 2 and linear CQs any PE-rewriting of which is of superpolynomial size (nΩ(logn), to be more precise).\nOur next result is similar to Theorem 24:\nTheorem 27. The following are equivalent :\n(1) there exist polynomial-size FO-rewritings for all OMQs with linear CQs and ontologies of depth 2; (2) for any fixed ℓ, there exist polynomial-size FO-rewritings for all tree-shaped OMQs with at most ℓ leaves ; (3) NL/poly ⊆ NC1.\nProof. (1) ⇒ (3) Suppose every OMQ Q = (T , q) with linear q and T of depth 2 has an FO-rewriting of size p(|Q|), for some fixed polynomial p. Consider f = Reachability. As f is monotone and f ∈ NL, we have f ∈ mNL/poly. Thus, Theorem 15 gives us an HGP P from mTHGP(2) that computes f . Let P be based on a hypergraph H , and let TH be the OMQ with a linear CQ and an ontology of depth 2 constructed in Section 5.3. By Theorem 11 (ii), f is a subfunction of f△TH . By our assumption, however, TH has a polynomial-size FO-rewriting, and so, by Theorem 6 (i), it is computed by a polynomial-size Boolean formula. Since f is NL/polycomplete under NC1-reductions [65], we obtain NL/poly ⊆ NC1. The implication (3) ⇒ (2) follows from Theorems 16 and 4 (i), and (2) ⇒ (1) is trivial."
    }, {
      "heading" : "7.4 Rewritings for OMQs with PFSP and bounded treewidth",
      "text" : "Since OMQs with the polynomial fundamental set property (PFSP, see Section 3) and CQs of bounded treewidth can be polynomially translated into monotone THGPs and mTHGP = mLOGCFL/poly ⊆ mP/poly, we obtain:\nTheorem 28. For any fixed t > 0, all OMQs with the PFSP and CQs of treewidth at most t have polynomial-size NDL-rewritings.\nUsing Theorem 1 and the fact that OMQs with ontologies of bounded depth enjoy the PFSP, we obtain:\nCorollary 1. The following OMQs have polynomial-size NDL-rewritings :\n– OMQs with ontologies of bounded depth and CQs of bounded treewidth; – OMQs with ontologies not containing axioms of the form ̺(x, y) → ̺′(x, y) (and (2)) and CQs of bounded treewidth.\nWhether all OMQs without axioms of the form ̺(x, y) → ̺′(x, y) have polynomial-size rewritings remains open.12\nTheorem 29. The following are equivalent :\n(1) there exist polynomial-size FO-rewritings for all tree-shaped OMQs with ontologies of depth 2 ; (2) there exist polynomial-size FO-rewritings for all OMQs with the PFSP and CQs of treewidth at most t (for any fixed t); (3) LOGCFL/poly ⊆ NC1.\nProof. The implication (2) ⇒ (1) is trivial, and (1) ⇒ (3) is proved similarly to the corresponding case of Theorem 27 using Theorems 17, 11 and 6. (3) ⇒ (2) follows from Theorems 12, 17 and 5."
    }, {
      "heading" : "7.5 Rewritings for OMQs with ontologies of depth 1 and CQs of bounded treewidth",
      "text" : "We show finally that polynomial PE-rewritings are guaranteed to exist for OMQs with ontologies of depth 1 and CQs of bounded treewidth. By Theorem 18, it suffices to show that fHQ is computable by a THGP of bounded degree. However, since tree witnesses can be initiated by multiple roles, the THGPs constructed in Section 5.4 do not enjoy this property and require a minor modification.\nLet Q = (T , q) be an OMQ with T of depth 1. For every tree witness t = (tr, ti), we take a fresh binary predicate Pt (which cannot occur in any data instance) and extend T with the following axioms:\nτ(x) → ∃y Pt(x, y), if τ generates t,\nPt(x, y) → ̺(x, y), if ̺(u, v) ∈ qt, u ∈ tr and v ∈ ti.\nDenote the resulting ontology by T ′ and set Q′ = (T ′, q). By Theorem 8, the number of tree witnesses for Q does not exceed |q|, and so the size of Q′ is polynomial in |Q|. It is easy to see that any rewriting of Q′ (with Pt replaced by ⊥) is also a rewriting for Q. Thus, it suffices to consider OMQs of the form Q′, which will be called explicit.\nGiven an explicit OMQ Q = (T , q), we construct a THGP P ′Q in the same way as PQ in Section 5.4 except that in the definition of Eki , instead of considering all types wk of Ni, we only use wk = (w[1], . . . ,w[m]) in which w[j] is either ε or Pt for the unique tree witness t = (tr, ti) with ti = {λj(Ni)}. (Since T is of depth 1, every tree witness t has ti = {z}, for some variable z, and ti 6= t ′ i whenever t 6= t′.) This modification guarantees that, for every i, the number of distinct Eki is bounded by 2 m. It follows that the hypergraph of P ′Q is of bounded degree, 2m + 22m to be more precise. To establish the correctness of the modified construction, we can\n12 A positive answer to this question given by Kikot et al. [48] is based on a flawed proof.\nprove an analogue of Theorem 12, in which the original THGP PQ is replaced by P ′ Q, and the function fHQ is replaced by\nfH′Q = ∨\nΘ⊆ΘQ independent\n( ∧\nS(z)∈q\\qΘ\npS(z) ∧ ∧\nt∈Θ\n( ∧\nR(z,z′)∈q t\npz=z′ ∧ ∧\nz∈tr∪ti p∃yPt(z,y)\n))\n(which is obtained from fHQ by always choosing Pt as the predicate that initiates t). It is easy to see that Theorem 4 holds also for fH′Q (with explicit Q), which gives us:\nTheorem 30. For any fixed t > 0, all OMQs with ontologies of depth 1 and CQs of treewidth at most t have polynomial-size PE-rewritings.\nFor tree-shaped OMQs, we obtain an even better result. Indeed, by Theorem 10, H(Q) is a tree hypergraph; by Theorem 8, it is of degree at most 2, and so, by Theorem 19, f▽Q is computed by a polynomial-size Π3-circuit (which is monotone by definition). Thus, Theorem 4 (i) gives us the following (Π3 turns into Π4 because of the disjunction in the formula twt):\nTheorem 31. All tree-shaped OMQs with ontologies of depth 1 have polynomial-size Π4-rewritings."
    }, {
      "heading" : "8 Combined Complexity of OMQ answering",
      "text" : "The size of OMQ rewritings we investigated so far is crucial for classical OBDA, which relies upon a reduction to standard database query evaluation (under the assumption that it is efficient in real-world applications). However, this way of answering OMQs may not be optimal, and so understanding the size of OMQ rewritings does not shed much light on how hard OMQ answering actually is. For example, answering the OMQs from the proof of Theorem 23 via PE-rewriting requires superpolynomial time, while the graph reachability problem encoded by those OMQs is NL-complete. On the other hand, the existence of a short rewriting does not obviously imply tractability.\nIn this section, we analyse the combined complexity of answering OMQs classified according to the depth of ontologies and the shape of CQs. More precisely, our concern is the following decision problem: given an OMQQ(x) = (T , q(x)), a data instance A and a tuple a from ind(A) (of the same length as x), decide whether T ,A |= q(a). Recall from Section 3 that T ,A |= q(a) iff CT ,A |= q(a) iff there exists a homomorphism from q(a) to CT ,A.\nThe combined complexity of CQ evaluation has been thoroughly investigated in relational database theory. In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]—LOGCFL-complete, to be more precise [33].\nThe emerging combined complexity landscape for OMQ answering is summarised in Fig. 2 (b) in Section 1.3. The NP and LOGCFL lower bounds for arbitrary OMQs and tree-shaped OMQs with ontologies of bounded depth are inherited from the corresponding CQ evaluation problems. The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31]. By reduction of the reachability problem for directed graphs, one can easily show that evaluation of tree-shaped CQs with a bounded number of leaves (as well as answering OMQs with unary predicates only) is NL-hard. We now establish the remaining results."
    }, {
      "heading" : "8.1 OMQs with bounded-depth ontologies",
      "text" : "We begin by showing that the LOGCFL upper bound for CQs of bounded treewidth [33] is preserved even in the presence of ontologies of bounded depth.\nTheorem 32. For any fixed d ≥ 0 and t > 0, answering OMQs with ontologies of depth at most d and CQs of treewidth at most t is LOGCFL-complete.\nProof. LetQ(x) = (T , q(x)) be an OMQ with T of depth at most d and q of treewidth at most t. As T is of finite depth, CT ,A is finite for anyA. As LOGCFL is closed under LLOGCFL reductions [32] and evaluation of CQs of bounded treewidth is LOGCFL-complete, it suffices to show that CT ,A can be computed by an LLOGCFL-transducer (a deterministic logspace Turing machine with a LOGCFL oracle). Clearly, we need only logarithmic space to represent any predicate name or individual constant from T and A, as well as any word aw ∈ ∆CT ,A (since |w| ≤ d and d is fixed). Finally, as entailment in OWL2QL is in NL [4], each of the following problems can be decided by making a call to an NL (hence LOGCFL) oracle:\n– decide whether a̺1 . . . ̺n ∈ ∆CT ,A , for any n ≤ d and roles ̺i from T ; – decide whether u ∈ ∆CT ,A belongs to ACT ,A , for a unary A from T and A; – decide whether (u1, u2) ∈ ∆ CT ,A ×∆CT ,A is in P CT ,A , for a binary P from T and A. ⊓⊔\nIf we restrict the number of leaves in tree-shaped OMQs, then the LOGCFL upper bound can be reduced to NL:\nTheorem 33. For any fixed d ≥ 0 and ℓ ≥ 2, answering OMQs with ontologies of depth at most d and tree-shaped CQs with at most ℓ leaves is NL-complete.\nProof. Algorithm 1 defines a non-deterministic procedure TreeQuery for deciding whether a tuple a is a certain answer to a tree-shaped OMQ (T , q(x)) over A. The procedure views q as a directed tree (we pick one of its variables z0 as a root) and constructs a homomorphism from q(x) to CT ,A on-the-fly by traversing the tree from root to leaves. The set frontier is initialised with a pair z0 7→ u0 representing the choice of where to map z0. The possible choices for z0 include ind(A) and aw ∈ ∆CT ,A such that |w| ≤ 2|T |+ |q|, which are enough to find a homomorphism if it exists [4]. This set of possible choices is denoted by U in Algorithm 1. Note that U occurs only in statements of the form ‘guess u ∈ U ’ and need not be materialised. Instead, we assume that the sequence u is guessed element-by-element and the condition u ∈ U is verified along the sequence of guesses. We use the subroutine call canMap(z0, u0) to check whether the guessed u0 is compatible with z0.\n13 It first ensures that, if z0 is an answer variable of q(x), then u0 is the individual constant corresponding to z0 in a. Next, if z0 ∈ ind(A), then it verifies that u0 satisfies all atoms in q(x) that involve only z0. If u0 6∈ ind(A), then u0 must take the form aw̺ and the subroutine checks whether T |= ∃y ̺(y, x) → A(x) (equivalently, aw̺ ∈ ACT ,A) for every A(z0) ∈ q and whether T |= P (x, x) for every P (z0, z0) ∈ q. The remainder of the algorithm consists of a while loop, in which we remove z 7→ u from frontier, and if z is not a leaf node, guess where to map its children. We must then check that the guessed element u′ for child z′ is compatible with (i) the binary atoms linking z to z′ and (ii) the atoms that involve only z′; the latter is done by canMap(z′, u′). If the check succeeds, we add z′ 7→ u′ to frontier, for each child z′ of z; otherwise, false is returned. We exit the while loop when frontier is empty, i.e., when an element of CT ,A has been assigned to each variable in q(x).\nCorrectness and termination of the algorithm are straightforward and hold for tree-shaped OMQs with arbitrary ontologies. Membership in NL for bounded-depth ontologies and boundedleaf queries follows from the fact that the number of leaves of q does not exceed ℓ, in which case the cardinality of frontier is bounded by ℓ, and the fact that the depth of T does not exceed d, in which case every element of U requires only a fixed amount of space to store. So, since each variable z can be stored in logarithmic space, the set frontier can also be stored in logarithmic space. Finally, it should be clear that the subroutine canMap(z, u) can also be implemented in"
    }, {
      "heading" : "NL [4].",
      "text" : ""
    }, {
      "heading" : "8.2 OMQs with bounded-leaf CQs",
      "text" : "It remains to settle the complexity of answering OMQs with arbitrary ontologies and boundedleaf CQs, for which neither the upper bounds from the preceding subsection nor the NP lower bound by [48] are applicable.\nTheorem 34. For any fixed ℓ ≥ 2, answering OMQs with tree-shaped CQs having at most ℓ leaves is LOGCFL-complete.\n13 The operator check immediately returns false if the condition is not satisfied.\nALGORITHM 1: Non-deterministic procedure TreeQuery for answering tree-shaped OMQs\nData: a tree-shaped OMQ (T , q(x)), a data instance A and a tuple a from ind(A) Result: true if T ,A |= q(a) and false otherwise\nfix a directed tree T compatible with the Gaifman graph of q and let z0 be its root; let U = { aw ∈ ∆CT ,A | a ∈ ind(A) and |w| ≤ 2|T |+ |q| }\n; /* not computed */ guess u0 ∈ U ; /* use the definition of U to check whether the guess is allowed */ check canMap(z0,u0); frontier ←− {z0 7→ u0}; while frontier 6= ∅ do\nremove some z 7→ u from frontier; foreach child z′ of z in T do\nguess u′ ∈ U ; /* use the def. of U to check whether the guess is allowed */ check (u, u′) ∈ P CT ,A , for all P (z, z′) ∈ q, and canMap(z′,u′); frontier ←− frontier ∪ {z′ 7→ u′}\nreturn true;\nFunction canMap(z, u) if z is the ith answer variable and u 6= ai then return false; if u = aw̺ then /* the element u is in the tree part of the canonical model */\ncheck T |= ∃y ̺(y, x) → A(x), for all A(z) ∈ q, and T |= P (x, x), for all P (z, z) ∈ q else /* otherwise, u ∈ ind(A) */\ncheck u ∈ ACT ,A , for all A(z) ∈ q, and (u, u) ∈ P CT ,A , for all P (z, z) ∈ q\nreturn true;\nProof. First, we establish the upper bound using a characterisation of the class LOGCFL in terms of non-deterministic auxiliary pushdown automata (NAuxPDAs). An NAuxPDA [26] is a non-deterministic Turing machine with an additional work tape constrained to operate as a pushdown store. [72] showed that LOGCFL coincides with the class of problems that can be solved by NAuxPDAs running in logarithmic space and polynomial time (note that the space on the pushdown tape is not subject to the logarithmic space bound). Algorithms 2 and 3 give a procedure BLQuery for answering OMQs with bounded-leaf CQs that can be implemented by an NAuxPDA.\nSimilarly to TreeQuery, the idea is to view the input CQ q(x) as a tree and iteratively construct a homomorphism from q(x) to CT ,A, working from root to leaves. We begin by guessing an element a0w to which the root variable z0 is mapped and checking that a0w is compatible with z0. However, instead of storing directly a0w in frontier, we guess it element-by-element and push the word w onto the stack, stack. We assume that we have access to the top of the stack, denoted by top(stack), and the call top(stack) on empty stack returns ε. During execution of BLQuery, the height of the stack will never exceed 2|T | + |q|, and so we assume that the height of the stack, denoted by |stack|, is also available as, for example, a variable whose value is updated by the push and pop operations on stack.\nAfter having guessed a0w, we check that z0 can be mapped to it, which is done by calling canMapTail(z0, a0, top(stack)). If the check succeeds, we initialise frontier to the set of 4-tuples of the form (z0 7→ (a0, |stack|), zi), for all children zi of z0 in T . Intuitively, a tuple (z 7→ (a, n), z′) records that the variable z is mapped to the element a stack≤n and that the child z′ of z remains to be mapped (in the explanations we use stack≤n to refer to the word comprising the first n symbols of stack; the algorithm, however, cannot make use of it).\nIn the main loop, we remove one or more tuples from frontier, choose where to map the variables and update frontier and stack accordingly. There are four options. Option 1 is used for tuples (z 7→ (a, 0), z′) where both z and z′ are mapped to individual constants, Option 2 (Option 3) for tuples (z 7→ (a, n), z′) in which we map z′ to a child (respectively, parent) of the image of z in CT ,A, while Option 4 applies when z and z′ are mapped to the same element (which is possible if P (z, z′) ∈ q, for some P that is reflexive according to T ). Crucially, however, the order in which tuples are treated matters due to the fact that several tuples ‘share’ the single stack. Indeed, when applying Option 3, we pop a symbol from stack, and may therefore lose\nALGORITHM 2: Non-deterministic procedure BLQuery for answering bounded-leaf OMQs.\nData: a bounded-leaf OMQ (T , q(x)), a data instance A and a tuple a from ind(A) Result: true if T ,A |= q(a) and false otherwise\nfix a directed tree T compatible with the Gaifman graph of q and let z0 be its root; guess a0 ∈ ind(A); /* guess the ABox element */ guess n0 < 2|T |+ |q|; /* maximum distance from ABox of relevant elements */ foreach n in 1, . . . , n0 do /* guess the initial element in a step-by-step fashion */\nguess a role ̺ in T such that isGenerated(̺, a0, top(stack)); push ̺ on stack\ncheck canMapTail(z0, a0, top(stack)); frontier ←− { (z0 7→ (a0, |stack|), zi) | zi is a child of z0 in T }\n; while frontier 6= ∅ do\nguess one of the 4 options; if Option 1 then /* take a step in ind(A) */\nremove some (z 7→ (a, 0), z′) from frontier; guess a′ ∈ ind(A); check (a, a′) ∈ P CT ,A , for all P (z, z′) ∈ q, and canMapTail(z′, a′, ε); frontier ←− frontier ∪ {(z′ 7→ (a′, 0), z′i) | z ′ i is a child of z\n′ in T} else if Option 2 and |stack| < 2|T |+ |q| then /* a step ‘forward’ in the tree part */\nremove some (z 7→ (a, |stack|), z′) from frontier; guess a role ̺ in T such that isGenerated(̺, a, top(stack)); push ̺ on stack; check T |= ̺(x, y) → P (x, y), for all P (z, z′) ∈ q, and canMapTail(z′, a, top(stack)); frontier ←− frontier ∪ {(z′ 7→ (a, |stack|), z′i) | z ′ i is a child of z\n′ in T} else if Option 3 and |stack| > 0 then /* take a step ‘backward’ in the tree part */\nlet deepest = {(z 7→ (a, n), z′) ∈ frontier | n = |stack|}; /* may be empty */ remove all deepest from frontier; pop ̺ from stack; foreach (z 7→ (a, n), z′) ∈ deepest do\ncheck T |= ̺(x, y) → P (x, y), for all P (z′, z) ∈ q, and canMapTail(z′, a, top(stack)); frontier ←− frontier ∪ {(z′ 7→ (a, |stack|), z′i) | z ′ i is a child of z ′ in T}\nelse if Option 4 then /* take a ‘loop’-step in the tree part of CT ,A */ remove some (z 7→ (a, |stack|), z′) from frontier; check T |= P (x, x), for all P (z, z′) ∈ q, and canMapTail(z′, a, top(stack)); frontier ←− frontier ∪ {(z′ 7→ (a, |stack|), z′i) | z ′ i is a child of z\n′ in T} else return false;\nreturn true;\nsome information that is needed for processing other tuples. To avoid this, Option 3 may only be applied to tuples (z 7→ (a, n), z′) with maximal n, and it must be applied to all such tuples at the same time. For Option 2, we require that the selected tuple (z 7→ (a, n), z′) is such that n = |stack|: since z′ is being mapped to an element a stack≤n ̺, we need to access the nth symbol in stack to determine the possible choices for ̺ and to record the symbol chosen by pushing it onto stack.\nThe procedure terminates and returns true when frontier is empty, meaning that we have successfully constructed a homomorphism witnessing that the input tuple is an answer. Conversely, given a homomorphism from q(a) to CT ,A, we can define a successful execution of BLQuery. We prove in Appendix H that BLQuery terminates (Proposition 5), is correct (Proposition 6) and can be implemented by an NAuxPDA (Proposition 7). The following example illustrates the construction.\nExample 16. Suppose T has the following axioms:\nA(x) → ∃y P (x, y), P (x, y) → U(y, x),\n∃y P (y, x) → ∃y S(x, y), ∃y S(y, x) → ∃y T (y, x), ∃y P (y, x) → B(x).\nthe query is as follows:\nALGORITHM 3: Subroutines for BLQuery.\nFunction canMapTail(z, a, σ) if z is the ith answer variable and either a 6= ai or σ 6= ε then return false; if σ 6= ε then /* an element of the form a . . . σ in the tree part */\ncheck T |= ∃y σ(y, x) → A(x), for all A(z) ∈ q, and T |= P (x, x), for all P (z, z) ∈ q else /* otherwise, in ind(A) */\ncheck a ∈ ACT ,A , for all A(z) ∈ q, and (a, a) ∈ P CT ,A , for all P (z, z) ∈ q\nreturn true;\nFunction isGenerated(̺, a, σ) if σ 6= ε then /* an element of the form a . . . σ in the tree part */\ncheck T |= ∃y σ(y, x) → ∃y ̺(x, y) else /* otherwise, in ind(A) */\ncheck (a, b) ∈ ̺(x, y)CT ,A , for some b ∈ ∆CT ,A \\ ind(A)\nreturn true;\nq(x1, x2) = ∃y1y2y3y4y5 ( R(y2, x1) ∧ P (y2, y1) ∧ S(y1, y3) ∧\nT (y5, y3) ∧ S(y4, y3) ∧ U(y4, x2) )\nand A = {A(a), R(a, c)}. Observe that CT ,A |= q(c, a). We show how to define an execution of BLQuery that returns true on ((T , q),A, q, (c, a)) and the homomorphism it induces. We fix some variable, say y1, as the root of the query tree. We then guess the constant a and the word P , push P onto stack and check using canMapTail(y1, a, P) that our choice is compatible with y1. At the start of the while loop, we have\nfrontier = {(y1 7→ (a, 1), y2), (y1 7→ (a, 1), y3)} and stack = P, (w-1)\nwhere the first tuple, for example, records that y1 has been mapped to a stack≤1 = aP and y2 remains to be mapped. We are going to use Option 3 for (y1 7→ (a, 1), y2) and Option 2 for (y1 7→ (a, 1), y3). We (have to) start with Option 2 though: we remove (y1 7→ (a, 1), y3) from frontier, guess S, push it onto stack, and add (y3 7→ (a, 2), y4) and (y3 7→ (a, 2), y5) to frontier. Note that the tuples in frontier allow us to read off the elements a stack≤1 and a stack≤2 to which y1 and y3 are mapped. Thus,\nfrontier = {(y1 7→ (a, 1), y2), (y3 7→ (a, 2), y4), (y3 7→ (a, 2), y5)} and stack = PS (w-2)\nat the start of the second iteration of the while loop. We are going to use Option 3 for (y3 7→ (a, 2), y4) and Option 2 for (y3 7→ (a, 2), y5). Again, we have to start with Option 2: we remove (y3 7→ (a, 2), y5) from frontier, and guess T− and push it onto stack. As y5 has no children, we leave frontier unchanged. At the start of the third iteration,\nfrontier = {(y1 7→ (a, 1), y2), (y3 7→ (a, 2), y4)} and stack = PST −; (w-3)\nsee Fig. 19 (a). We apply Option 3 and, since deepest = ∅, we pop T− from stack but make no other changes. In the fourth iteration, we again apply Option 3. Since deepest = {(y3 7→ (a, 2), y4)}, we remove this tuple from frontier and pop S from stack. As the checks succeed for S, we add (y4 7→ (a, 1), x2) to frontier. Before the fifth iteration,\nfrontier = {(y1 7→ (a, 1), y2), (y4 7→ (a, 1), x2)} and stack = P ; (w-5)\nsee Fig. 19 (b). We apply Option 3 with deepest = {(y1 7→ (a, 1), y2), (y4 7→ (a, 1), x2)}. This leads to both tuples being removed from frontier and P popped from stack. We next perform the required checks and, in particular, verify that the choice of where to map the answer variable x2 agrees with the input vector (c, a) (which is indeed the case). Then, we add (y2 7→ (a, 0), x1) to frontier. The final, sixth, iteration begins with\nfrontier = {(y2 7→ (a, 0), x1)} and stack = ε; (w-6)\nsee Fig. 19 (c). We choose Option 1, remove (y2 7→ (a, 0), x1) from frontier, guess c, and perform the required compatibility checks. As x1 is a leaf, no new tuples are added to frontier; see Fig. 19 (d). We are thus left with frontier = ∅, and return true.\nThe proof of LOGCFL-hardness is by reduction of the following problem: decide whether an input of length n is accepted by the nth circuit of a logspace-uniform family of SAC1 circuits, which is known to be LOGCFL-hard [75]. This problem was used by [33] to show LOGCFLhardness of evaluating tree-shaped CQs. We follow a similar approach, but with one crucial difference: using an ontology, we ‘unravel’ the circuit into a tree, which allows us to replace tree-shaped CQs by linear ones. Following [33], we assume without loss of generality that the considered SAC1 circuits adhere to the following normal form:\n– fan-in of all and-gates is 2;\n– nodes are assigned to levels, with gates on level i only receiving inputs from gates on level i− 1, the input gates on level 1 and the output gate on the greatest level;\n– the number of levels is odd, all even-level gates are or-gates, and all odd-level non-input gates are and-gates.\nIt is well known [33, 75] that a circuit in normal form accepts an input α iff there is a labelled rooted tree (called a proof tree) such that\n– the root node is labelled with the output and-gate;\n– if a node is labelled with an and-gate gi and gi = gj ∧ gk, then it has two children labelled with gj and gk, respectively; – if a node is labelled with an or-gate gi and gi = gj1 ∨ . . . ∨ gjk , then it has a unique child that is labelled with one of gj1 , . . . , gjk ; – every leaf node is labelled with an input gate whose literal evaluates to 1 under α.\nFor example, the circuit in Fig. 20 (a) accepts (1, 0, 0, 0, 1), as witnessed by the proof tree in Fig. 20 (b). While a circuit-input pair may admit multiple proof trees, they are all isomorphic modulo the labelling. Thus, with every circuit C, we can associate a skeleton proof tree T such that C accepts α iff some labelling of T is a proof tree for C and α. Note that T depends only on the number of levels in C. The reduction [33], which is for presentation purposes reproduced here with minor modifications, encodes C and α in the database and uses a Boolean tree-shaped CQ based on the skeleton proof tree. Specifically, the database D(α) uses the gates of C as constants and consists of the following facts:\nL(gj , gi) and R(gk, gi), for every and-gate gi with gi = gj ∧ gk;\nU(gj1 , gi), . . . , U(gjk , gi), for every or-gate gi with gi = gj1 ∨ · · · ∨ gjk ;\nA(gi), for every input gate gi whose value is 1 under α.\nThe CQ q uses the nodes of T as variables, has an atom U(zj, zi) (L(zj, zi), R(zj , zi)) for every node zi with unique (left, right) child zj , and has an atom A(zi) for every leaf node zi. These definitions guarantee that D(α) |= q iff C accepts α; moreover, both q and D(α) can be constructed by logspace transducers.\nTo adapt this reduction to our setting, we replace q by a linear CQ q′, which is obtained by a depth-first traversal of q. When evaluated on D(α), the CQs q′ and q may give different answers, but the answers coincide if the CQs are evaluated on the unravelling of D(α) into a tree. Thus, we define (Tα,A) whose canonical model induces a tree isomorphic to the unravelling of D(α). To formally introduce q′, consider the sequence of words defined inductively as follows:\nw0 = ε and wj+1 = L − U− wj U LR − U−wj U R, for j > 0.\nSuppose C has 2d+ 1 levels, d ≥ 0. Consider the dth word wd = ̺1̺2 . . . ̺k and take\nq′(y0) = ∃y1, . . . , yk [ k∧\ni=1\n̺i(yi−1, yi) ∧ ∧\n̺i̺i+1=U− U\nA(yi) ] ;\nsee Fig. 20 (c). We now define (Tα,A). Suppose C has gates g1, . . . , gm, with gm the output gate. In addition to predicates U , L, R, A, we introduce a unary predicate Gi for each gate gi. We set A = {Gm(a)} and include the following axioms in Tα:\nGi(x) → ∃y ( S(x, y) ∧Gj(y) ) , for every S(gj , gi) ∈ D(α), S ∈ {U,L,R},\nGi(x) → A(x), for every A(gi) ∈ D(α);\nsee Fig. 20 (d) for an illustration. When restricted to predicates U , L, R, A, the canonical model of (Tα,A) is isomorphic to the unravelling of D(α) starting from gm.\nWe show in Appendix I that q′ and (Tα,A) can be constructed by logspace transducers (Proposition 8), and that C accepts α iff Tα,A |= q ′(a) (Proposition 9)."
    }, {
      "heading" : "9 Conclusions and open problems",
      "text" : "Our aim in this work was to understand how the size of OMQ rewritings and the combined complexity of OMQ answering depend on (i) the existential depth of OWL2QL ontologies, (ii) the treewidth of CQs or the number of leaves in tree-shaped CQs, and (iii) the type of rewriting: PE, NDL or arbitrary FO.\nWe tackled the succinctness problem by representing OMQ rewritings as (Boolean) hypergraph functions and establishing an unexpectedly tight correspondence between the size of OMQ rewritings and the size of various computational models for computing these functions. It turned out that polynomial-size PE-rewritings can only be constructed for OMQs with ontologies of depth 1 and CQs of bounded treewidth. Ontologies of larger depth require, in general, PErewritings of super-polynomial size. The good and surprising news, however, is that, for classes of OMQs with ontologies of bounded depth and CQs of bounded treewidth, we can always (efficiently) construct polynomial-size NDL-rewritings. The same holds if we consider OMQs obtained by pairing ontologies of depth 1 with arbitrary CQs or coupling arbitrary ontologies with bounded-leaf queries; see Fig. 2 for details. The existence of polynomial-size FO-rewritings for different classes of OMQs was shown to be equivalent to major open problems in computational and circuit complexity such as ‘NL/poly ⊆ NC1?’, ‘LOGCFL/poly ⊆ NC1?’ and ‘NP/poly ⊆ NC1?’\nWe also determined the combined complexity of answering OMQs from the considered classes. In particular, we showed that OMQ answering is tractable—either NL- or LOGCFL-complete— for bounded-depth ontologies coupled with bounded treewidth CQs, as well as for arbitrary ontologies paired with tree-shaped queries with a bounded number of leaves. We point out that membership in LOGCFL implies that answering OMQs from the identified tractable classes can be ‘profitably parallelised’ (for details, consult [33]).\nComparing the two sides of Fig. 2, we remark that the class of tractable OMQs nearly coincides with the OMQs admitting polynomial-size NDL-rewritings (the only exception being OMQs with ontologies of depth 1 and arbitrary CQs). However, the LOGCFL and NLmembership results cannot be immediately inferred from the existence of polynomial-size NDL-rewritings, since evaluating polynomial-size NDL-queries is a PSpace-complete problem in general. In fact, much more work is required to construct NDL-rewritings that can be evaluated in LOGCFL and NL, which will be done in a follow-up publication; see technical report [8].\nAlthough the present work gives comprehensive solutions to the succinctness and combined complexity problems formulated in Section 1, it also raises some interesting and challenging questions:\n(1) What is the size of rewritings of OMQs with a fixed ontology? (2) What is the size of rewritings of OMQs with ontologies in a fixed signature? (3) Is answering OMQs with CQs of bounded treewidth and ontologies of finite depth fixed-\nparameter tractable if the ontology depth is the parameter? (4) What is the size of rewritings for OMQs whose ontologies do not contain role inclusions,\nthat is, axioms of the form ̺(x, y) → ̺′(x, y)?\nAnswering these questions would provide further insight into the difficulty of OBDA and could lead to the identification of new classes of well-behaved OMQs.\nAs far as practical OBDA is concerned, our experience with the query answering engine Ontop [67, 53], which employs the tree-witness rewriting, shows that mappings and database constraints together with semantic query optimisation techniques can drastically reduce the size of rewritings and produce efficient SQL queries over the data. The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.\nFinally, the focus of this paper was on the ontology language OWL2QL that has been designed specifically for OBDA via query rewriting. However, in practice ontology designers often require constructs that are not available in OWL2QL. Typical examples are axioms such as A(x) → B(x)∨C(x) and P (x, y)∧A(y) → B(x). The former is a standard covering constraint in conceptual modelling, while the latter occurs in ontologies such as SNOMED CT. There are at least two ways of extending the applicability of rewriting techniques to a wider class of ontology languages. A first approach relies upon the observation that although many ontology languages\ndo not guarantee the existence of rewritings for all ontology-query pairs, it may still be the case that the queries and ontologies typically encountered in practice do admit rewritings. This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38]. A second approach consists in replacing an ontology formulated in a complex ontology language (which lacks efficient query answering algorithms) by an ontology written in a simpler language, for which query rewriting methods can be employed. Ideally, one would show that the simpler ontology is equivalent to the original with regards to query answering [14], and thus provides the exact set of answers. Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78])."
    }, {
      "heading" : "A Proof of Theorem 5",
      "text" : "Theorem 5 (i) For any OMQ Q(x), the formulas qtw(x) and q ′ tw(x) are equivalent, and\nso q′tw(x) is a PE-rewriting of Q(x) over complete data instances. (ii) Theorem 4 continues to hold for f▽Q replaced by f H Q.\nProof. Let Q(x) = (T , q(x)) and q(x) = ∃y ϕ(x,y). We begin by showing that for every tree witness t for Q(x), we have the following chain of equivalences:\n∧\nR(z,z′)∈q t\n(z = z′) ∧ ∨\nt is ̺-initiated\n∧\nz∈tr∪ti ̺∗(z) ≡\n∧\nz,z′∈tr∪ti (z = z′) ∧\n∨\nt is ̺-initiated\n∧\nz∈tr∪ti ̺∗(z)\n≡ ∃z0 ( ∧\nz∈tr∪ti (z = z0) ∧\n∨\nt is ̺-initiated\n̺∗(z0) ) ≡ ∃z0 ( ∧\nz∈tr∪ti (z = z0) ∧\n∨\nt generated by τ\nτ(z0) ) ,\nwhere z0 is a fresh variable. The first equivalence follows from the transitivity of equality and the fact that every pair of variables z, z′ in a tree witness must be linked by a sequence of binary atoms. The following equivalence can be readily verified using first-order semantics. For the final equivalence, we use the fact that if t is ̺-initiated and T |= τ(x) → ∃y ̺(x, y), then t is generated by τ , and conversely, if t is generated by τ , then there is some ̺ that initiates t and is such that T |= τ(x) → ∃y ̺(x, y).\nBy the above equivalences, the query q′tw(x) can be equivalently expressed as follows:\n∃y ∨\nΘ⊆ΘQ independent\n( ∧\nS(z)∈q\\qΘ\nS(z) ∧ ∧\nt∈Θ\n( ∃z0 (\n∧\nz∈tr∪ti (z = z0) ∧\n∨\nt is generated by τ\nτ(z0)) )) .\nFinally, we observe that, for every independent Θ ⊆ ΘQ, the variables that occur in some ti, for t ∈ Θ, do not occur in t′\ni for any other t′ ∈ Θ. It follows that if z ∈ ti and t ∈ Θ, then the only\noccurrence of z in the disjunct for Θ is in the equality atom z = z0. We can thus drop all such atoms, while preserving equivalence, which gives us precisely the tree-witness rewriting qtw(x). In particular, this means that q′tw(x) is a rewriting of Q(x) over complete data instances.\nTo establish the second statement, let Φ be a Boolean formula that computes\nfHQ = ∨\nΘ⊆ΘQ independent\n( ∧\nS(z)∈q\\qΘ\npS(z) ∧ ∧\nt∈Θ\n( ∧\nR(z,z′)∈q t\npz=z′ ∧ ∨\nt is ̺-initiated\n∧\nz∈tr∪ti p̺∗(z)\n))\n,\nand let q′(x) be the FO-formula obtained by replacing each pz=z′ in Φ with z = z′, each pS(z) with S(z), each p̺∗(z) with ∨\nT |=τ(x)→∃y ̺(x,y) τ(z), and prefixing the result with ∃y. Recall that the modified rewriting q′tw(x) was obtained by applying this same transformation to the original monotone Boolean formula for fHQ. Since Φ computes f H Q, q ′(x) and q′tw(x) are equivalent FOformulas. As we have already established that q′tw(x) is a rewriting of Q(x), the same must be true of q′(x). The statement regarding NDL-rewritings can be proved similarly to the proof of Theorem 4 (ii)."
    }, {
      "heading" : "B Proof of Theorem 11",
      "text" : "Theorem 11 (i) Any tree hypergraph H is isomorphic to a subgraph of H(TH). (ii) Any monotone THGP based on a tree hypergraph H computes a subfunction of the\nprimitive evaluation function f△TH .\nProof. (i) Fix a tree hypergraph H = (V,E) whose underlying tree T = (VT , ET ) has vertices VT = {1, . . . , n}, for n > 1, and 1 is a leaf of T . The directed tree obtained from T by fixing 1 as the root and orienting the edges away from 1 is denoted by T 1 = (VT , E 1 T ). By definition, each e ∈ E induces a convex subtree T e = (Ve, Ee) of T 1. Since, for each subtree T e, the OMQ TH has a tree-witness te with\nt e r = { zi | i in on the boundary of e }, t e i = { zi | i is in the interior of e } ∪ { yij | (i, j) ∈ e },\nit follows that H is isomorphic to the subgraph of H(TH) obtained by removing all superfluous hyperedges and all vertices corresponding to atoms with Sij .\n(ii) Suppose that P is bssed on a tree hypergraph H . Given an input α for P , we define an assignment γ for the predicates in TH = (T , q) by taking each γ(Rij) and γ(Sij) to be the value of the label of (i, j) ∈ E1T under α and γ(Ae) = 1 for all e ∈ E (γ(Rζ) = 0, for all normalisation predicates Rζ). We show that for all α we have\nP (α) = 1 iff f△TH (γ) = 1.\nObserve that the canonical model CT ,A(γ) contains two labelled nulls, we and w ′ e, for each e ∈ E, satisfying\nCT ,A(γ) |= ∧\n(i,j)∈Ee, i=re Rrej(a, we) ∧\n∧\n(i,j)∈Ee, j∈Le Sij(we, a) ∧\n∧\n(i,j)∈Ee, i6=re Rij(w\n′ e, we) ∧\n∧\n(i,j)∈Ee, j /∈Le\nSij(we, w ′ e).\n(⇒) Suppose that P (α) = 1. Then there exists an independent E′ ⊆ E that covers all zeros of α. We show T ,A(γ) |= q (that is, f△TH (γ) = 1). Define a mapping h as follows:\nh(zi) =\n{\nw′e, if i is in the interior of e ∈ E ′, a, otherwise, h(yij) =\n{\nwe, if (i, j) ∈ e ∈ E′,\na otherwise.\nNote that h is well-defined: since E′ is independent, its hyperedges share no interior, and there can be at most one hyperedge e ∈ E′ containing any given vertex (i, j).\nIt remains to show that h is a homomorphism from q to CT ,A(γ). Consider a pair of atoms Rij(zi, yij) and Sij(yij , zj) in q. Then (i, j) ∈ E1T . If there is e ∈ E\n′ with(i, j) ∈ e then there are four possibilities to consider:\n– if neither i nor j is in the interior then, since Te is a tree and (i, j) is its edge, the only possibility is e = {(i, j)}, whence h(zi) = h(zj) = a and h(yij) = we; – i is on the boundary and j is internal, then h(zi) = a, h(yij) = we, and h(zj) = w ′ e; – if j is on the boundary and i is internal, then this case is the mirror image; – if both i and j are in the interior, then h(zi) = h(zj) = w ′ e and h(yij) = we.\nOtherwise, the label of (i, j) must evaluate to 1 under α, whence A(γ) contains Rij(a, a) and Sij(a, a) and we set h(zi) = h(yij) = h(zj) = a. In all cases, h preserves the atoms Rij(zi, yij) and Sij(yij , zj), and so h is indeed a homomorphism.\n(⇒) Suppose that f△TH (γ) = 1. Then T ,A(γ) |= q, and so there is a homomorphism h : q → CT ,A(γ). We show that there is an independent E ′ ⊆ E that covers all zeros of α. Let E′ be the\nset of all e ∈ E such that h−1(we) 6= ∅ (that is, we is in the image of h). To show that E′ is independent, we need the following claim:\nClaim. If h−1(we) 6= ∅, then h(yij) = we for all (i, j) ∈ e. Proof of claim. Let re be the root of T e and Le its leaves. Pick some variable z ∈ h−1(we) such that there is no z′ ∈ h−1(we) higher than z in q (we use the ordering of variables induced by the tree T 1). Observe that z cannot be of the form zj , because then q would contain some atom Rjℓ(zj , yjℓ) or Sℓj(yℓj, zj), but we has no outgoing Rjℓ or S − ℓj arcs in CT ,A(γ). It follows that z is of the form yjℓ, for some j, ℓ. By considering the available arcs leaving we again, we conclude that (j, ℓ) ∈ e. We next show that j = re. Suppose that this is not the case. Then, there must be (p, j) ∈ e with (p, j) ∈ T 1. A simple examination of the axioms in T shows that the only way for h to satisfy the atom Rjℓ(zj , yjℓ) is to map zj to w ′ e. It follows that to satisfy the atom Spj(ypj , zj), we must put h(ypj) = we contrary to the assumption that z = yjℓ was a highest vertex in h−1(we). Thus, j = re. Now, using a simple inductive argument on the distance from zre , and considering the possible ways of mapping the atoms of q, we can show that h(yij) = we for every (i, j) ∈ e. (end proof of claim)\nSuppose that there are two distinct hyperedges e, e′ ∈ E′ that have a non-empty intersection: (i, j) ∈ e∩ e′. We know that either yij or yji occurs in q, and we can assume the former without loss of generality. By the claim, we obtain h(yij) = we = we′ , a contradiction. Therefore, E\n′ is independent. We now show that it covers all zeros. Let (i, j) be such that its label evaluates to 0 under α, and assume again without loss of generality that yij occurs in q. Then A(γ) does not contain Rij(a, a), so the only way h can satisfy the atom Rij(zi, yij) is by mapping yij to some we with (i, j) ∈ e. It follows that there is an e ∈ E′ such that (i, j) ∈ e, so all zeros of α are covered by E′. We have thus shown that E′ is an independent subset of E that covers all zeros of α, and hence, P (α) = 1."
    }, {
      "heading" : "C Proof of Proposition 4",
      "text" : "Proposition 4. (i) For any tree hypergraph H of degree ≤ d, there is a monotone THGP of size O(|H |) that computes fH and such that its hypergraph is of degree ≤ max(2, d).\n(ii) For every generalised THGP P over n variables, there is a THGP P ′ computing the same function and such that |P ′| ≤ n · |P |.\nProof. (i) Consider a hypergraph H = (V,E) based on a tree T = (VT , ET ) with V = ET . We label each v ∈ V with a variable pv and, for each e ∈ E, we choose some ve ∈ ⋃ e, add fresh vertices ae and be with edges {ve, ae} and {ae, be} to T as well as a new hyperedge e′ = [ve, be] to E. We label the segment [ve, ae] with 1 and the segment [ae, be] with pe. We also extend e to include the segment [ve, ae]. We claim that the resulting THGP P computes fH . Indeed, for any input α with α(pe) = 0, we have to include the edge e\n′ into the cover, and so cannot include the edge e itself. Thus, P (α) = 1 iff there is an independent set E of hyperedges with α(pe) = 1, for all e ∈ E, covering all zeros of the variables pv. It follows that P computes fH .\n(ii) Let P be a generalised THGP based on a hypergraph H = (V,E) with the underlying tree T = (VT , ET ) such that V = ET . To construct P\n′, we split every vertex v ∈ V (which is an edge of T ) labelled with\n∧k i=1 li into k new edges v1, . . . , vk and label vi with li, for 1 ≤ i ≤ k;\neach hyperedge containing v will now contain all the vi. It is easy to see that P (α) = P ′(α), for any valuation α. Since k ≤ n, we have |P ′| ≤ n · |P |. It should be clear that the degree of P ′ and the number of leaves in it are the same as in P ."
    }, {
      "heading" : "D Proof of Theorem 12",
      "text" : "Theorem 12. For every OMQ Q(x) = (T , q(x)) with a fundamental set ΩQ and with q of treewidth t, the generalised monotone THGP PQ computes f H Q and is of size polynomial in |q| and |ΩQ|t.\nProof. By [29, Lemma 11.9], we can assume that the tree T in the tree decomposition of q has at most N , N ≤ |q|, nodes. Recall that M = |ΩQ|t is the number of bag types. We claim that PQ\n– contains at most (2M + 1)N vertices and at most N(M +M2) hyperedges;\n– and has labels with at most 3|q| conjuncts.\nThe vertices of the hypergraph of PQ correspond to the edges of T ′, and there can be at most N · (2M + 1) of them, because there can be no more than N edges in T , and each is replaced by a sequence of 2M + 1 new edges. The hyperedges are of two types: Eki (where 1 ≤ i ≤ N and 1 ≤ k ≤ M) and Ekℓij (where (i, j) correspond to an edge in T and 1 ≤ k, ℓ ≤ M). It follows that the total number of hyperedges cannot exceed N(M +M2). Finally, a simple examination of the labelling function shows that there can be at most 3|q| conjuncts in each label. Indeed, given i, j and k, each atom S(z) with z ⊆ λ(Ni) generates either 1 or 3 propositional variables in the label of {ukij , v k ij}, and |q| is the upper bound for the number of such atoms.\nTo complete the proof, we show that PQ computes f H Q: for any valuation α,\nfHQ(α) = 1 iff PQ(α) = 1.\n(⇒) Let α be such that fHQ(α) = 1. Then we can find an independent Θ ⊆ ΘQ such that α satisfies the corresponding disjunct of fHQ:\n∧\nS(z)∈q\\qΘ\npS(z) ∧ ∧\nt∈Θ\n( ∧\nR(z,z′)∈q t\npz=z′ ∧ ∨\nt is ̺-initiated\n∧\nz∈tr∪ti p̺∗(z)\n)\n. (14)\nFor every t ∈ Θ, let ̺t be a role that makes the disjunction hold. Since t is ̺t-initiated, we can choose a homomorphism ht : qt → C ̺t(a) T such that, for every z ∈ ti, ht(z) is of the form a̺tw, for some w . With each node N in the tree decomposition (T, λ) we associate the type w of N by taking, for all z ∈ λ(N):\nw[νN (z)] =\n{\nw, if z ∈ ti and ht(z) = aw, for some t ∈ Θ,\nε, otherwise.\nObserve that w is well-defined since the independence of Θ guarantees that every variable in q can appear in ti for at most one t ∈ Θ. We show that w is compatible with N . Consider a unary atom A(z) ∈ q such that z ∈ λ(N) and w[νN (z)] 6= ε. Then there must be t ∈ Θ such that z ∈ ti, in which case ht(z) = aw[νN (z)]. Let ̺ be the final symbol in ht(z). Since ht : qt → C ∃y̺t(a,y) T is a homomorphism, we have T |= ∃y ̺(y, x) → A(x). Consider now a binary atom P (z, z′) ∈ q such that z, z′ ∈ λ(N) and either w[νN (z)] 6= ε or w[νN (z′)] 6= ε. We assume w.l.o.g. that the former is true (the other case is handled analogously). By definition, there is t ∈ Θ such that z ∈ ti and ht(z) = aw[νN (z)]. Since z ∈ ti and P (z, z′) ∈ q, by the definition of tree witnesses, z′ ∈ tr ∪ ti. Since ht : qt → C ∃y̺t(a,y) T is a homomorphism, one of the following holds:\n– w[νN (z ′)] = w[νN (z)] and T |= P (x, x); – w[νN (z)] = w[νN (z ′)] · ̺ for some ̺ with T |= ̺(y, x) → P (x, y); – w[νN (z ′)] = w[νN (z)] · ̺ for some ̺ with T |= ̺(x, y) → P (x, y).\nThis establishes the second part of the compatibility condition. Next, we show that the pairs associated with different nodes in T are compatible. Consider a pair of nodes N and N ′ and their typesw andw′. It is clear that, by construction,w[νN (z)] = w′[νN ′(z)], for all z ∈ λ(N)∩λ(N ′).\nLet w1, . . . ,wM be all the bag types. Consider now the tree hypergraph PQ, and let E ′ be\nthe set consisting of the following hyperedges:\n– for every Ni in T , the hyperedge E k i = [Ni, u k ij1 , . . . , ukijn ], where k is such that wk is the type of Ni, and Nj1 , . . . , Njn are the neighbours of Ni; – for every pair of adjacent nodes Ni, Nj in T , the hyperedge E kℓ ij = [v k ij , v ℓ ji], where k and ℓ\nare such that wk and wℓ are the types of Ni and Nj, respectively.\nNote that all these hyperedges are present in the hypergraph of PQ because we have shown that the type of each node Ni is compatible with it and that the pairs of types of Ni and Nj are compatible with the pair (Ni, Nj). It is easy to see that E\n′ is independent, since whenever we include Eki or E kℓ ij , we do not include any E k′ i or E k′ℓ ij for k\n′ 6= k. It remains to show that every vertex of the hypergraph of PQ that is not covered by E\n′ evaluates to 1 under α. Observe first that most of the vertices are covered by E′. Specifically:\n– {Ni, u1ij} is covered by E k i ; – {vkij , u k+1 ij } is covered either by E n i (if n ≤ k + 1) or by E nℓ ij (if n > k + 1); – {vMij , v M ji } is covered by E kℓ ij ; – {ukij, v k ij} is covered by E n i if k < n, and by E nℓ ij if n > k.\nThus, the only type of vertex not covered by E′ is of the form {ukij, v k ij}, where wk is the type of Ni. In this case, by definition, {ukij , v k ij} is labelled by the following variables:\n– pS(z), if S(z) ∈ q, z ⊆ λ(Ni) and wk[νNi(z)] = ε, for all z ∈ z; – p̺∗(z), if A(z) ∈ q, z ∈ λ(Ni) and wk[νNi(z)] = ̺w; – p̺∗(z), p̺∗(z′) and pz=z′ , if S(z, z\n′) ∈ q (possibly with z = z′), z, z′ ∈ λ(Ni) and either wk[νNi(z)] = ̺w or wk[νNi(z ′)] = ̺w.\nFirst suppose that pS(z) appears in the label of {u k ij , v k ij}. Then wk[νNi(z)] = ε, for all z ∈ z, and hence there is no variable in S(z) that belongs to any ti for t ∈ Θ. It follows that S(z) ∈ q \\qΘ, and since (14) is satisfied, the variable pS(z) evaluates to 1 under α. Next suppose that one of p̺∗(z), p̺∗(z′) and pz=z′ is part of the label. We focus on the case where these variables came from a binary atom (third item above), but the proof is similar for the case of a unary atom (second item above). We know that there is some atom S(z, z′) ∈ q with z, z′ ∈ λ(Ni) and either wk[νNi(z)] = ̺w or wk[νNi ] = ̺w. It follows that there is a tree witness t ∈ Θ such that z, z′ ∈ tr ∪ ti. This means that the atom pz=z′ is a conjunct of (14), and so it is satisfied under α. Also, either wk[νNi(z)] = ht(z) or wk[νNi(z\n′)] = ht(z′) is of the form ̺w, and, since all non-empty words in the image of ht begin by ̺t, we obtain ̺ = ̺t. Since ̺t was chosen so that ∧\nz∈tr∪ti p̺∗(z) is satisfied under α, both p̺∗(z) and p̺∗(z′) evaluate to 1 under α. Therefore, E′ is independent and covers all zeros under α, which means that PQ(α) = 1.\n(⇐) Suppose PQ(α) = 1, i.e., there is an independent subset E′ of the hyperedges in PQ that covers all vertices evaluated to 0 under α. It is clear from the construction of PQ that E ′ contains exactly one hyperedge of the form Eki for every node Ni in T , and so we can associate with every node Ni the unique index µ(Ni) = k. We also know that E\n′ contains exactly one hyperedge of the form Ekℓij for every edge {Ni, Nj} in T . Moreover, if we have hyperedges E k i and Ek ′ℓ\nij (respectively, E ℓ j and E\nkℓ′ ij ), then k = k ′ (respectively, ℓ = ℓ′). It also follows from\nthe definition of PQ that every wµ(Ni) is compatible with Ni, and pairs (wµ(Nj),wµ(Nj)) are compatible for adjacent nodes Ni, Nj . Using the compatibility properties and the connectedness condition of tree decompositions, we can conclude that the pairs assigned to any two nodes Ni and Nj in T are compatible. Since every variable must appear in at least one node label, it follows that we can associate a unique word wz with every variable z in q.\nSince all zeros are covered by E′, we know that for every node Ni, the following variables are assigned to 1 by α:\n– pS(z), if S(z) ∈ q, z ⊆ λ(Ni) and wz = ε, for z ∈ z; – p̺∗(z), if A(z) ∈ q, z ∈ λ(Ni), and wz = ̺w; (⋆) – p̺∗(z), p̺(z′) and pz=z′ , if S(z, z\n′) ∈ q (possibly with z = z′), z, z′ ∈ λ(Ni) and either wz = ̺w or wz′ = ̺w.\nNow let ≡ be the smallest equivalence relation on the atoms of q that satisfies the following condition, for every variable z in q,\nif wz 6= ε and z occurs in both S1(z1) and S2(z2), then S1(z1) ≡ S2(z2).\nLet q1, . . . , qn be the subqueries corresponding to the equivalence classes of ≡. It is easily verified that the qi are pairwise disjoint. Moreover, if qi contains only variables z with wz = ε, then qi consists of a single atom. We can show that the remaining qi correspond to tree witnesses.\nClaim. For every qi that contains a variable z with wz 6= ε:\n(1) there is a role ̺i such that every wz 6= ε (with z a variable in qi) begins by ̺i; (2) there is a homomorphism hi : qi → C ∃y̺i(a,y) T such that hi(z) = awz for every variable z in\nqi; (3) there is a tree witness ti for Q that is ̺i-initiated and such that qi = qti\nProof of claim. By the definition of qi, there exists a sequence Q0, . . . , Qn of subsets of q such that Q0 = {S0(z0)} ⊆ qi contains a variable z0 with wz0 6= ε, Qn = qi, and for every 0 ≤ ℓ < n, Qℓ+1 is obtained from Qℓ by adding an atom that contains a variable z that appears in Qℓ and is such that wz 6= ε. By construction, every atom in qi contains a variable z with wz 6= ε. Let ̺i be the first letter of the word wz0 , and for every 0 ≤ ℓ ≤ n, let hℓ be the function that maps every variable z in Qℓ to awz .\nStatements 1 and 2 can be shown by induction. The base case is trivial. For the induction step, suppose that at stage ℓ, we know that every variable z in Qℓ with wz 6= ε begins by ̺i, and that hℓ is a homomorphism of Qℓ into the canonical model C ∃y̺i(a,y) T that satisfies hℓ(y) = awz . We let S(z) be the unique atom in Qℓ+1\\Qℓ. Then S(z) contains a variable z that appears in Qℓ and is such that wz 6= ε. If S(z) = B(z) or S(z) = R(z, z), then Statement 1 for wz is immediate. For Statement 2, we let N be a node in T such that z ∈ λ(N). Since wN is compatible with N , it follows that, if S(z) = B(z), then wz ends by a role ̺ with T |= ∃y ̺(y, x) → B(x), and, if S(z) = R(z, z), then T |= R(x, x), which proves Statement 2. Next, consider the case when S(z) contains two variables, that is, it is of the form R(z, z′) or R(z, z′). We give the argument for the former (the the latter is analogous). Let N be a node in T such that {z, z′} ⊆ λ(N). Since wN is compatible with N , either\n– wz′ = wz̺ with T |= ̺(x, y) → R(x, y), or – wz = wz′̺ with T |= ̺(y, x) → R(x, y).\nSince wz begins with ̺i, the same holds for wz′ unless wz′ = ε, which proves Statement 1. It is also clear from the way we defined hℓ+1 that it is homomorphism from Qℓ+1 to C ∃y̺i(a,y) T , so Statement 2 holds. Statement 3 now follows from Statements 1 and 2, the definition of qi and the definition of tree witnesses. (end proof of claim)\nLet Θ consist of all the tree witnesses ti obtained in the claim. As the qi are disjoint, the set {q\nti | ti ∈ Θ} is independent. We show that α satisfies the disjunct of fHQ that corresponds\nto Θ; cf. (14). First, consider some S(z) ∈ q \\ qΘ. Then, for every variable z in S(z), we have wz = ε. Let N be a node in T such that z ⊆ λ(N). Then wz = ε, for all z ∈ z. It follows from (⋆) that α(pS(z)) = 1. Next, consider a variable pz=z′ such that there is an atom S(z) ∈ qti with z = {z, z′}. Since S(z) ∈ qi, either wz 6= ε or wz′ 6= ε. It follows from (⋆) that α(pz=z′) = 1. Finally, let us consider a tree witness ti ∈ Θ, and let ̺i be the role from the claim. We show that p̺∗i (z) = 1 for every variable z in t i, which will imply that the final disjunction is satisfied by α. Consider a variable z in ti. By the construction of the query qi = qti , it contains a binary atom S(z) with z, z′ ∈ z and either wz 6= ε or wz′ 6= ε. By the definition of tree decompositions, there is a node N in T with z, z′ ∈ λ(N). Then, by Statement 1 of the claim, either wz = ̺iw or wz′ = ̺iw. Now we can apply (⋆) to obtain p̺∗\ni (z) = 1, as required."
    }, {
      "heading" : "E Proofs of Theorems 15 and 16",
      "text" : "Theorem 15 (general case). NL/poly = THGP(ℓ) and mNL/poly = mTHGP(ℓ), for any ℓ ≥ 2.\nProof. Suppose a polynomial-size THGP P based on a tree hypergraph H with at most ℓ leaves computes a Boolean function f . We show how to construct a polynomial-size NBP that computes the same f . By Theorem 16 (to be proved below), fH can be computed by a polynomial-size NBP B. We replace the vertex variables pv in labels of B by the corresponding vertex labels in P and fix all the edge variables pe to 1; see the proof of Proposition 2 (i). Clearly, the resulting NBP B′ is as required.\nThe converse direction is given in Section 6.3.\nTheorem 16. Fix ℓ ≥ 2. For any tree hypergraph H based on a tree with at most ℓ leaves, the function fH can be computed by an NBP of size polynomial in |H |.\nProof. Let H = (V,E) be a tree hypergraph and T = (VT , ET ) its underlying tree (V = ET and each e ∈ E induces a convex subtree Te of T ). Pick some vertex r ∈ VT and fix it as a root of T . We call an independent subset F ⊆ E of hyperedges flat if every simple path in T with endpoint r intersects at most one of Te, for e ∈ F . Note that every flat subset can contain at most ℓ hyperedges, so the number of flat subsets is bounded by a polynomial in |H |. We denote by [F ] the union of subtrees Te, for all e ∈ F ([F ] is a possibly disconnected subgraph of T ). Flat subsets can be partially ordered by taking F F ′ if every simple path between the root r and a vertex of [F ′] intersects [F ]. As usual, F ≺ F ′ if F F ′ but F 6= F ′.\nThe required NBP P is based on the graph G = (VP , EP ) with\nVP = { uF , ūF | F is flat } ∪ { s, t } , EP = { (s, uF ), (ūF , t), (uF , ūF ) | F is flat } ∪ { (ūF , uF ′) | F, F ′ are flat and F ≺ F ′ } .\nTo define labels, we introduce some notation first for sets of edges of T (which are sets of vertices of H). For a flat F , let before(F ) be the edges of T that lie outside [F ] and are accessible from the root r via paths not passing through [F ]; we denote by after(F ) the edges of T outside [F ] that are accessible from r only via paths passing through [F ]. Finally, for flat F and F ′ with F ≺ F ′, we denote by between(F, F ′) the set of edges in T ‘between’ [F ] and [F ′], that is those edges of T outside [F ] and [F ′] that are accessible from [F ] via paths not passing through [F ′] but are not accessible from the root r via a path not passing through [F ]; see Fig. 21. Now we are ready to define the labelling for edges of G:\n– each (uF , ūF ) is labelled with the conjunction of pe for e ∈ F ; – each (s, uF ) is labelled with the conjunction of pv for v ∈ before(F ); – each (ūF , uF ′) is labelled with the conjunction of pv for v ∈ between(F, F ′); – each (ūF , t) is labelled with the conjunction of pv for v ∈ after(F ).\nWe claim that under any valuation α of pe and pv, there is a path from s to t in G all of whose labels evaluate to 1 under α iff fH(α) = 1, that is, iff there is an independent (not necessarily flat) subset E′ ⊆ E such that α(pe) = 1 for all e ∈ E′ and α(pv) = 1 for all v ∈ V \\VE′ . Indeed, any such E′ splits into flat ‘layers’ F 1, F 2, . . . Fm that form a path\ns → uF 1 → ūF 1 → uF 2 → · · · → ūFm → t\nin G and whose edge labels evaluate to 1: take F 1 to be the set of all hyperedges from E′ that are accessible from r via paths which do not cross (that is come in and go out) any hyperedge of E′; take F 2 to be the set of all edges from E′ \\ F 1 that are accessible from r via paths that do not cross any hyperedge of E′ \\F 1, and so on. Conversely, any path leading from s to t gives us a covering E′, which is the union of all flat sets that occur in the subscripts of vertices on this path."
    }, {
      "heading" : "F Proof of Theorems 17 and 18",
      "text" : "Lemma 2. Any semi-unbounded fan-in circuit C of and-depth d is equivalent to a semiunbounded fan-in circuit C ′ of size 2d|C| and and-depth d such that, for each n ≤ d, C ′ satisfies ⋃\ng∈Sn left(g) ∩\n⋃\ng∈Sn right(g) = ∅.\nProof. We show by induction on n that we can reconstruct the circuit in such a way that the property holds for all i ≤ n, the and-depth of the circuit does not change and the size of the circuit increases at most by the factor of 2n.\nConsider a subcircuit ⋃ g∈Sn left(g) of C, take its copy C ′′ and feed the outputs of C′′ as left inputs to and-gates in Sn. This at most doubles the size of the circuit and ensures the property for Sn. Now apply the induction hypothesis to both C ′′ and ⋃\ng∈Sn right(g) (which do\nnot intersect). The size of the resulting circuit will increase at most by the factor of 2n−1 and the property for Si for i < n will be ensured. ⊓⊔\nLet gi be a gate in C. We denote by Ti the subtree of T with the root vi and, given an input α, we say that Ti can be covered under α if the hypergraph with the underlying tree Ti has an independent subset of hyperedges that are wholly in Ti and cover all zeros under α.\nLemma 3. For a given input α and any i, the gate gi outputs 1 iff Ti can be covered.\nProof. We prove the claim by induction on i. If gi is an input gate and outputs 1, then the label of the edge {vi, ui} is evaluated into 1 under α, and the remainder of Ti can be covered by a set of [wj , uj ]-hyperedges. Conversely, if an input gate gi outputs 0, then no hyperedge can cover {vi, ui}.\nIf gi = gj ∧ gk is an and-gate and outputs 1, then both its inputs output 1. We cover both subtrees corresponding to the inputs (by induction hypothesis) and add to the covering the hyperedge [vi, vj , vk], which covers Ti. Conversely, any covering of zeros in Ti must include the hyperedge [vi, vj , vk], and so the subtrees Tj and Tk must be covered. Thus, by the induction hypothesis, gj and gk should output 1, and so does gi.\nIf gi = gj1 ∨ · · · ∨ gjk is an or-gate and outputs 1, then one of its inputs, say, gj , is 1. By the induction hypothesis, we cover its subtree and add the hyperedge [vi, vj ], which forms a covering of Ti. Conversely, since {vi, ui} is labelled by 0, any covering of Ti must include a hyperedge of the form [vi, vj ] for some j ∈ {j1, . . . , jk}. Thus Tj must also be covered. By the induction hypothesis, gj outputs 1 and so does gi. ⊓⊔\nTheorem 18.NC1 = THGPd and mNC1 = mTHGPd, for any d ≥ 3.\nProof. To prove NC1 ⊆ THGP3, consider a polynomial-size formula C, which we represent as a tree of gates g1, . . . , gm enumerated so that j < i whenever gj is an input of gi. We assume that C has negated variables in place of not-gates. We now construct the tree, T , underlying the THGP P we are after: T contains triples of vertices ui, vi, wi partially ordered in the same way as the gi in C. We then remove vertex wm and make vm the root of T . The THGP P is based on the hypergraph whose vertices are the edges of T and whose hyperedges comprise the following:\n– [ui, uj], for each i < m, where j < i and gj is the input of gi; – [vi, vj , vk], for each gi = gj ∧ gk; – [vi, vj , wk], [vi, wj , vj ], for each gi = gj ∨ gk.\nFinally, if an input gate gi is a literal l, we label the edge {ui, vi} with l; we label all other edges with 0. It is not hard to check that P is of degree 3, has size polynomial in |C|, and computes the same function as C.\nThe inclusion NC1 ⊇ THGPd follows from the proof of LOGCFL/poly ⊆ THGP in Theorem 17. Indeed, if the degree of the THGP is at most d, then the disjunction in (13) has at most d + 1 disjuncts, and so the constructed circuit has depth O(log s)."
    }, {
      "heading" : "G Proofs for Section 7",
      "text" : "Theorem 25. For any fixed ℓ ≥ 2, all tree-shaped OMQs with at most ℓ leaves have polynomial-size NDL-rewritings.\nProof. Fix ℓ ≥ 2 and let Q be a tree-shaped OMQ with at most ℓ leaves. By Theorem 10, H(Q) is a tree hypergraph whose underlying tree has at most ℓ leaves. By Theorem 16, f▽Q is computable by a polynomial-size monotone NBP, and so, since mNL/poly ⊆ mP/poly, f▽Q can be computed by a polynomial-size monotone Boolean circuit. It remains to apply Theorem 4 (ii).\nTheorem 26. There is an OMQ with ontologies of depth 2 and linear CQs any PE-rewriting of which is of superpolynomial size nΩ(logn).\nProof. We consider the function f = Reachability. Since f ∈ mNL/poly, by Theorem 15, there is a polynomial-size monotone HGP that is based on a hypergraph H with underlying tree with 2 leaves and computes f . Consider now the OMQ TH for H defined in Section 5.3, which has an ontology of depth 2. By Theorem 11 (ii), f is a subfunction of f△TH . By Theorem 6 (i), no PE-rewriting of the OMQ TH can be shorter than n Ω(logn). ⊓⊔\nTheorem 28. For any fixed t > 0, all OMQs with the PFSP and CQs of treewidth at most t have polynomial-size NDL-rewritings.\nProof. Fix a t > 0 and a class of OMQs with PFSP. Take an OMQ Q of treewidth at most t from the class. By Theorem 12, there is a polynomial-size monotone THGP that computes fHQ. Since mTHGP ⊆ mLOGCFL/poly ⊆ mP/poly (Theorem 17), fHQ can be computed by a polynomial-size monotone Boolean circuit. It remains to apply Theorem 5 (ii).\nTheorem 30. For any fixed t > 0, all OMQs with ontologies of depth 1 and CQs of treewidth at most t have polynomial-size PE-rewritings.\nThe main argument underlying Theorem 30 was given in the body of the paper. To complete the proof, we give the following two lemmas, which are the modified versions of Theorems 4 and 12 mentioned in the body.\nLemma 4. Theorem 4 continues to hold if f▽Q is replaced by f H′ Q .\nProof. The proof proceeds similarly to the proof of Theorem 5. The key step in the proof is showing that the FO-formula\n∃y ∨\nΘ⊆ΘQ independent\n( ∧\nS(z)∈q\\qΘ\nS(z) ∧ ∧\nt∈Θ\n( ∧\nR(z,z′)∈q t\nz = z′ ∧ ∧\nz∈tr∪ti\n∨\nt generated by τ\nτ(z) ))\nobtained from fH′Q by replacing variables pS(z), pz=z′ , and p∃yPt(z,y) by S(z), z = z ′, and ∨\nt generated by τ τ(z) respectively is equivalent the tree-witness rewriting qtw.\nLemma 5. In the setting of Section 7.5, for the modified hypergraph program P ′Q we still have fP ′ Q (v) = fH′Q (v).\nProof. The proof closely follows that of Theorem 12. For the first direction of the proof, the only notable difference is that instead of selecting a role ̺t that satisfies the disjunct corresponding to the tree witness t, we must take the special role Pt. For the second direction, we use the assumption that T is of depth 1 to show that every query qj (constructed according to the equivalence relation) has a single variable vj such that wvj 6= ε. This allows us to prove a stronger version of the claim in which qj = qtj , with t j the unique tree witness with tj i = {vj}, and the selected role ̺j is equal to the special predicate Ptj associated with t j .\nTheorem 31. All tree-shaped OMQs with ontologies of depth 1 have polynomial-size Π4rewritings.\nProof. Take an OMQ Q = (T , q) with T of depth 1 and a tree-shaped q. By Theorems 8 and 10, H(Q) is a polynomial-size tree hypergraph of degree at most 2. By Proposition 4 (i), f▽Q can be computed by a polynomial-size THGP P of degree at most 2. By Theorem 19, there is a polynomial-size monotone Π3-circuit computing f ▽\nQ. By a simple unravelling argument, it follows that there is polynomial-size monotone Boolean formula computing f▽Q. It remains to apply Theorem 4 (i) and conclude that there is a polynomial-size positive existential Π4-rewriting for Q."
    }, {
      "heading" : "H Proof of LOGCFL membership in Theorem 34",
      "text" : "We say that an iteration of the while loop is successful if the procedure BLQuery does not return false; in particular, if none of the check operations returns false. The following properties can be easily seen to hold by examination of BLQuery and straightforward induction:\nFor every tuple (z 7→ (a, n), z′) ∈ frontier, z′ is a child of z in T. (15) For every tuple (z 7→ (a, n), z′) ∈ frontier, we have n ≤ |stack|. (16) All tuples (z 7→ (a, n), z′) ∈ frontier with n > 0 share the same a. (17) Once (z 7→ (a, n), z′) is added to frontier, no tuple of the form (z 7→ (a′, n′), z′) (18) can ever be added to frontier.\nIn every successful iteration, either at least one tuple is removed from frontier (19) or frontier is unchanged but one ̺ is popped from the stack. If (z 7→ (a, n), z′) is removed from frontier in a successful iteration, (20) then a tuple of the form (z′ 7→ (a′, n′), z′′) is added to frontier,\nfor every child z′′ of z′ in T.\nProposition 5. Every execution of BLQuery terminates.\nProof. A simple examination of BLQuery shows that the only possible source of non-termination is the while loop, which continues as long as frontier is non-empty. By (15) and (18), the total number of tuples that may appear in frontier at any point cannot exceed the number of edges in T , which is itself bounded by |q|. By (18) and (19), every tuple is added at most once and is eventually removed from frontier. Thus, either the algorithm will exit thewhile loop by returning false (if one of the check operations fails), or it will eventually exit the loop after reaching an empty frontier.\nProposition 6. There exists an execution of BLQuery that returns true on input ((T , q),A,a) if and only if T ,A |= q(a).\nProof. (⇐) Suppose that T ,A |= q(a). Then there exists a homomorphism h : q → CT ,A such that h(x) = a. Without loss of generality we may choose h so that the image of h consists of elements aw with |w| ≤ 2|T |+ |q| [4]. We use h to specify an execution of BLQuery((T , q),A,a) that returns true. First, we fix an arbitrary variable z0 as root, and then, we choose the element h(z0) = a0w0. Since h defines a homomorphism of q(a) into CT ,A, the call canMapTail(z0, a0, top(stack)) returns true. We initialise stack to w0 and frontier to {(z0 7→ (a0, |stack|), vi | vi is a child of v0}. Next, we enter the while loop. Our aim is to make the non-deterministic choices to satisfy the following invariant:\nIf (z 7→ (a,m), z′) ∈ frontier, then h(z) = a stack≤m. (21)\nRecall that stack≤m denotes the word obtained by concatenating the first m symbols of stack. Observe that before the while loop, property (21) is satisfied. At the start of each iteration of the while loop, we proceed as follows.\n[Case 1.] If frontier contains (z 7→ (a, 0), z′) such that h(z′) ∈ ind(A), then we choose Option 1. We remove the tuple from frontier and choose the individual a′ = h(z′) for the guess. As a = h(z) (by (21)) and h is a homomorphism, we have (a, a′) ∈ P CT ,A , for all P (z, z′) ∈ q, and the call\ncanMapTail(z′, a′, ε) returns true. We thus add (z′ 7→ (a′, 0), z′′) to frontier for every child z′′ of z′ in T . These additions to frontier clearly preserve the invariant.\n[Case 2.] If Case 1 does not apply and frontier contains (z 7→ (a, |stack|), z′) such that h(z′) = h(z), then we choose Option 4 and remove the tuple from frontier. Since h is homomorphism, we have T |= P (x, x), for all P (z, z′) ∈ q, and canMapTail(z′, a, top(stack)) returns true. Then, for every child z′′ of z′ in T , we add (z′ 7→ (a, |stack|), z′′) to frontier. Observe that since h(z) = h(z′) and (21) holds for z, property (21) also holds for the newly added tuples.\n[Case 3.] If neither Case 1 nor Case 2 applies and frontier contains (z 7→ (a, |stack|), z′) such that h(z′) = h(z)̺, then we choose Option 2 and remove the tuple from frontier. Note that in this case, |stack| < 2|T | + |q| since (i) by (21), h(z) = aw, for w = stack≤|stack|, and (ii) by the choice of homomorphism h, we have |w̺| ≤ 2|T | + |q|. So, we continue and choose ̺ for the guess. By (21), since h is a homomorphism and h(z′) = h(z)̺, the call isGenerated(̺, a, top(stack)) returns true, T |= ̺(x, y) → P (x, y), for all P (z, z′) ∈ q and the call canMapTail(z′, a, top(stack)) returns true. So, we push ̺ onto stack and add (z′ 7→ (a, |stack|), z′′) to frontier for every child z′′ of z′ in T . As stack contains the word component of h(z′), invariant (21) holds for the newly added tuples.\n[Case 4.] If none of Case 1, Case 2 or Case 3 is applicable, then we choose Option 3 and remove all elements in deepest = {(z 7→ (a, n), z′) ∈ frontier | n = |stack|} from frontier. Since neither Case 1 nor Case 3 applies, |stack| > 0. So, we pop the top symbol ̺ from stack. Suppose first that deepest 6= ∅. By (17), all tuples in deepest share the same individual a. By (21), every tuple (z 7→ (a, n), z′) ∈ deepest is such that h(z) = aw̺, where w = stack≤|stack|. Moreover, since Case 3 is not applicable, for every such tuple (z 7→ (a, n), z′), we have h(z′) = aw. Using the fact that h is a homomorphism, one can show that T |= ̺(x, y) → P (x, y), for all P (z′, z) ∈ q, and canMapTail(z′, a, top(stack)) returns true. So, we add to frontier all tuples (z′ 7→ (a, |stack|), z′′), a child z′′ of z′ in T . Note that invariant (21) is satisfied by all the new tuples. Moreover, since we only removed the last symbol in stack, all the remaining tuples in frontier continue to satisfy (21). Finally, if deepest was empty, then we do nothing but the tuples in frontier continue to satisfy (21).\nIt is easily verified that so long as frontier is non-empty, one of these four cases applies. Since we have shown how to make the non-deterministic choices in the while loop without returning false, by Proposition 5, the procedure eventually leaves the while loop and returns true.\n(⇒) Consider an execution of BLQuery((T , q),A,a) that returns true. It follows that the while loop is successfully exited after reaching an empty frontier. Let L be the total number of iterations of the while loop. We inductively define a sequence h0, h1, . . . , hL of partial functions from the variables of q to∆CT ,A by considering the guesses made during the different iterations of the while loop. The domain of hi will be denoted by dom(hi). We will ensure that the following properties hold for every 0 ≤ i < L:\nIf i > 0, then dom(hi−1) ⊆ dom(hi), and hi(z) = hi−1(z), for z ∈ dom(hi−1). (22) If (z 7→ (a, n), z′) ∈ frontier at the end of iteration i, then (23)\nhi(z) = aw, where w = stack≤n, (23a) and neither z′ nor any of its descendants belongs to dom(hi). (23b)\nhi is a homomorphism qi → CT ,A, where qi is the restriction of q to dom(hi). (24)\nWe begin by setting h0(z0) = a0w0, where w0 is the word in stack (and leaving h0 undefined for all other variables). Property (22) is vacuously satisfied. Property (23) holds because of the initial values of frontier and stack because only z0 ∈ dom(h0), and z0 cannot be its own child (hence, it cannot appear in the last component of a tuple in frontier). To see why (24) is satisfied, first suppose that w0 = ε and so a0w0 ∈ ind(A). Then, the call canMapTail(z0, a0, top(stack)) returns true. It follows that\nif z0 is the jth answer variable then a0 = aj ; a0 ∈ A CT ,A , for each A(z0) ∈ q, and (a0, a0) ∈ P CT ,A , for each P (z0, z0) ∈ q;\nand hence, h0 defines a homomorphism of q0 into CT ,A. Otherwise, w0 is non-empty and w0 = w′0̺. It follows that\nz0 is not an answer variable of q;\nT |= ∃y ̺(y, x) → A(x), for each A(z0) ∈ q, and T |= P (x, x), for each P (z0, z0) ∈ q;\nand hence h0 homomorphically maps all atoms of q0 into CT ,A. Thus, the initial partial function h0 satisfies (22)–(24).\nNext we show how to inductively define hi from hi−1 while preserving (22)–(24). The variables that belong to dom(hi) \\ dom(hi−1) are precisely those variables that appear in the last position of tuples removed from frontier during iteration i (since these are the variables for which we guess a domain element). The choice of where to map these variables depends on which of the four options was selected. In what follows, we will use stacki to denote the contents of stack at the end of iteration i.\nOption 1: we remove a tuple (z 7→ (a, 0), z′) and guess a′ ∈ ind(A). So, we set hi(z′) = a′ and hi(v) = hi−1(v) for all v ∈ dom(hi−1) (all other variables remain undefined). Property (22) is by definition. For property (23), consider a tuple τ = (v 7→ (c,m), v′) that belongs to frontier at the end of iteration i. Suppose first τ was added to frontier during iteration i, in which case τ = (z′ 7→ (a′, 0), z′′) for some child z′′ of z′. Property (23a) is satisfied because stacki≤0 = ε. Since hi−1 satisfies (23), z′′ (a descendant of z′) is not in dom(hi−1), which satisfies (23b). The remaining possibility is that τ was already in frontier at the beginning of iteration i. Since hi−1 satisfies (23), we have hi−1(v) = cw for w = stack i−1 ≤n and neither v ′ nor any of its descendants belongs to dom(hi−1). Since stack i = stacki−1 and hi(v) = hi−1(v), property (23a) holds for τ . Moreover, as τ was not removed from frontier during iteration i, we have τ 6= (z 7→ (a, 0), z′), and so, by (18), v′ 6= z′. Thus, neither v′ nor any of its descendants is in dom(hi).\nFor property (24), we first note that since hi agrees with hi−1 on dom(hi) and hi−1 satisfies (24), it is only necessary to consider the atoms in qi that do not belong to qi−1. There are three kinds of such atoms:\n– if A(z′) ∈ qi, then, since canMapTail(z ′, a′, ε) returns true, hi(z′) = a′ ∈ ACT ,A ; – if P (z′, z′) ∈ qi, then, again, since canMapTail(z ′, a′, ε) returns true, we have (hi(z′), hi(z′)) =\n(a′, a′) ∈ P CT ,A ; – if P (z′, v) ∈ qi with v 6= z ′, then v ∈ dom(hi), so v must coincide with z, the parent of z′\n(rather than being one of the children of z′); the check operation in the algorithm then guarantees (hi(z ′), hi(v)) = (a′, a) ∈ P CT ,A .\nThus, (24) holds for hi. Option 2: a tuple (z 7→ (a, n), z′) was removed from frontier, n = |stack| and a role ̺ was guessed. We set hi(z\n′) = hi−1(z)̺. By (23), hi−1(z) is defined. Moreover, the call isGenerated(̺, a, top(stack)) ensures that hi−1(z)̺ ∈ ∆CT ,A . We also set hi(v) = hi−1(v) for all v ∈ dom(hi−1) and leave the remaining variables undefined. Property (22) is immediate from the definition of hi, and (23b) can be shown exactly as for Option 1. To show (23a), consider a tuple τ = (v 7→ (c,m), v′) that belongs to frontier at the end of iteration i. Suppose first that τ was added to frontier during iteration i, in which case τ = (z′ 7→ (a, n+1), z′′) for some child z′′ of z′. Since hi−1 satisfies (23), hi−1(z) = a stack i−1 ≤n . Property (23a) follows then from hi(z ′) = hi−1(z)̺ and stacki = stacki−1 ̺. The other possibility is that τ was present in frontier at the beginning of iteration i. Since hi−1 satisfies (23), we have hi−1(v) = a stack i−1 ≤m. Property (23a) continues to hold for τ because stacki = stacki−1 ̺ and m ≤ |stacki−1| and hi(v) = hi−1(v). We now turn to property (24). As explained in the proof for Option 1, it is sufficient to consider the atoms in qi \\ qi−1, which can be of three types:\n– if A(z′) ∈ qi, then, since canMapTail(z ′, a, ̺) returns true, we have T |= ∃y ̺(y, x) → A(x),\nhence hi(z ′) = hi−1(z)̺ ∈ ACT ,A .\n– if P (z′, z′) ∈ qi, then, again, since canMapTail(z ′, a, ̺) returns true, we have T |= P (x, x),\nhence (hi(z ′), hi(z′)) ∈ P CT ,A .\n– if P (z′, v) ∈ qi with v 6= z ′ then v = z (see Option 1); so, T |= ̺(x, y) → P (y, x), whence\n(hi(z ′), hi(v)) = (hi−1(z)̺, hi−1(z)) ∈ P CT ,A .\nTherefore, hi is a homomorphism from qi into CT ,A, which is required by (24). Option 3: tuples in deepest = {(z 7→ (a, n), z′) ∈ frontier | n = |stack|} are removed from frontier, and role ̺ is popped from stack. By (17), all tuples in deepest share the same individual a. Let V = {z′ | (z 7→ (a, n), z′) ∈ deepest}. For every v ∈ V , we set hi(v) = a stack\ni; we also set hi(v) = hi−1(v) for all v ∈ dom(hi−1) and leave the remaining variables undefined. Property (22) is again immediate, and the argument for (23b) is the same as in Option 1. For property (23a), take any tuple τ = (v 7→ (c,m), v′) in frontier at the end of iteration i. If the tuple was added to frontier during this iteration, then v ∈ V , a = c, m = |stacki|, and hi(v) = a stack\ni, whence (23a). The other possibility is that τ was present in frontier at the beginning of iteration i. Then hi−1(v) = c stack i−1 ≤m and m < |stack i−1|. Since stacki is obtained from stacki−1 by popping one role, we have m ≤ |stacki|, and so (23a) holds for τ . For property (24), the argument is similar to Options 1 and 2 and involves considering the different types of atoms that may appear in qi \\ qi−1:\n– if A(z′) ∈ qi with z ′ ∈ V then, since canMapTail(z′, a, top(stack)) returns true, we have\nhi(z ′) ∈ ACT ,A (see Options 1 and 2);\n– if P (z′, z′) ∈ qi with z ′ ∈ V then, since canMapTail(z′, a, top(stack)) returns true, we have\n(hi(z ′), hi(z′)) = (a, a) ∈ P CT ,A ;\n– if P (z′, v) ∈ qi with v 6= z ′ and z′ ∈ V , then v is the parent of z (see Option 1) and, since\nT |= ̺(y, x) → P (x, y), we obtain (hi(z′), hi(v)) = (a stack i, a stacki ̺) ∈ P CT ,A .\nThus, (24) holds for hi.\nOption 4: a tuple (z 7→ (a, n), z′) was removed from frontier with n = |stack|. We set hi(z′) = hi(z), hi(v) = hi−1(v) for every v ∈ dom(hi−1), and leave all other variables unmapped. Again, it is easy to see that properties (22) and (23b) are satisfied by hi. For property (23a), let τ = (v 7→ (c,m), v′) be a tuple in frontier at the end of iteration i. If the tuple was added during iteration i, then v = z′, a = c, and m = n. Since (z 7→ (a, n), z′) was present at the end of iteration i − 1 and stacki = stacki−1, we have hi(z′) = a stack i−1 ≤n , hence hi(z) = c stack i ≤m. As hi(z ′) = hi(z), we have hi(z′) = a stack i ≤m, so τ satisfies (23a). If τ was already present at the beginning of iteration i, then we can use the fact that stacki = stacki−1 and all tuples in frontier satisfy (23a).\nTo show (24), we consider the three types of atoms that may appear in qi \\ qi−1:\n– ifA(z′) ∈ qi then, since canMapTail(z ′, a, top(stack)) returns true, then T |= ∃y ̺(y, x) → A(x),\nwhere ̺ = top(stack), and so hi(z ′) ∈ ACT ,A ;\n– if P (z′, z′) ∈ qi then, since canMapTail(z ′, a, top(stack)) returns true, then T |= P (x, x),\nand so (hi(z ′), h(z′)) ∈ P CT ,A ;\n– if P (z′, v) ∈ qi with v 6= z ′, then v = z (see Option 1), and so, since T |= P (x, x), we have\n(hi(z ′), hi(z)) ∈ P CT ,A .\nWe claim that the final partial function hL is a homomorphism of q to CT ,A. Since hL is a homomorphism of qL into CT ,A, it suffices to show that q = qL, or equivalently, that all variables of q are in dom(hL). This follows from the tree-shapedness of q (which in particular means that q is connected), invariants (15), and (20), and the fact that dom(hi+1) = dom(hi) ∪ {z\n′ | (z 7→ (a, n), z′) is removed from frontier during iteration i}.\nProposition 7. BLQuery can be implemented by an NAuxPDA.\nProof. It suffices to show that BLQuery runs in non-deterministic logarithmic space and polynomial time (the size of stack does not have to be bounded).\nFirst, we non-deterministically fix a root variable z0, but do not actually need to store the induced directed tree T in memory. Instead, it suffices to decide, given two variables z and z′, whether z′ is a child of z in T , which clearly belongs to NL.\nNext, we need only logarithmic space to store the individual a0. The initial word w0 = ̺1 . . . ̺n0 is guessed symbol by symbol and pushed onto stack. We note that both subroutines, isGenerated and canMapTail, can be made to run in non-deterministic logarithmic space. Then, since the children of a node in T can be identified in NL, we can decide in non-deterministic\nlogarithmic space whether a tuple (z0 7→ (a0, |stack|, zi) should be included in frontier. Moreover, since the input query q is a tree-shaped query with a bounded number of leaves, we know that only constantly many tuples can be added to frontier by each such operation. Moreover, it is clear that every tuple can be stored using in logarithmic space. More generally, by (15) and (18), one can show that |frontier| is bounded by a constant throughout the execution of the procedure, and the tuples added during the while loop can also be stored in logarithmically space.\nNext observe that every iteration of the while loop involves a polynomial number of the following elementary operations such as\n– remove a tuple from frontier, or add a tuple to frontier;\n– pop a role from stack, or push a role onto stack;\n– guess a single individual constant or symbol;\n– identify the children of a given variable;\n– test whether T |= α, for some inclusion α involving symbols from T ; – make a call to one of the subroutines isGenerated or canMapTail.\nFor each of the above operations, it is either easy to see, or has already been explained, that the operation can be performed in non-deterministic logarithmic space.\nTo complete the proof, observe that, by (19), each iteration of the while loop involves removing a tuple from frontier or popping a role from stack. By (15) every tuple in frontier corresponds to an edge in T , and, by (18), we create at most one tuple per edge. Thus, there can be at most |q| iterations involving the removal of a tuple. The total number of roles added to stack is bounded by at most ≤ 2|T | + |q| roles in the initial stack, plus the at most |q| roles added in later iterations, yielding at most 2|T | + 2|q| iterations involving only the popping of a role. Thus, the total number of iterations of the while loop cannot exceed can 2|T |+ 3|q|."
    }, {
      "heading" : "I Proof of LOGCFL-hardness in Theorem 34",
      "text" : "Proposition 8. The query q′ and KB (Tα,A) can be computed from C by logspace transducers.\nProof. Consider a circuit C in normal form with 2d + 1 layers of gates, where d is logarithmic in number of its inputs n. We show that (Tα,A) and q′ can be constructed using O(log(n)) worktape memory.\nTo produce the query q′, we can generate the word wd letter-by-letter and insert the corresponding variables. This can be done by a simple recursive procedure of depth d, using the worktape to remember the current position in the recursion tree as well as the index of the current variable yi. Note that |wd| (hence the largest index of the query variables) may be exponential in d, but is only polynomial in n, and so we need only logarithmic space to store the index of the current variable.\nThe ontology Tα is obtained by making a single pass over a (graph representation) of the circuit and generating the axioms that correspond to the gates of C and the links between them. To decide which axioms of the form Gi(x) → A(x) to include, we must also look up the value of the variables associated to the input gates under the valuation α. Finally, A consists of a single constant atom.\nProposition 9. C accepts α iff Tα,A |= q′(a).\nProof. Denote by e the natural homomorphism from q′ to q, and by e′ the natural homomorphism from CTα,A to D(α). Since C accepts input α iff there is a homomorphism h from q to D(α) [33], it suffices to show that there exists a homomorphism f from q′ to CTα,A iff there is a homomorphism h from q to D(α):\n(a) q′\nq D(α)\nCTα,A\ne e′\nh\nh′\nf (b) q′\nq D(α)\nCTα,A\ne e′\nf\nf ′\nh\n(⇒) Suppose that h is a homomorphism from q toD(α). We define a homomorphism h′ : q → CTα,A inductively moving from the root n1 of q to its leaves. For the basis of induction, we set h′(n1) = a; note that CTα,A |= Gm(a). For the inductive step, suppose that nj is a child of ni, h′(ni) is defined, CTα,A |= Gi′ (h(ni)) and h(nj) = gj′ . In this case, we set h ′(nj) = h′(ni)P − i′j′ . It follows from the definition of Tα that CTα,A |= Gj′ (h ′(nj)), which enables us to continue the induction. It should be clear that h′ is indeed a homomorphism from q into CTα,A. The desired homomorphism f : q′ → CTα,A can be obtained as the composition of e and h\n′, as illustrated in diagram (a).\n(⇐) Suppose that f is a homomorphism from q′ to CTα,A. We prove, by induction on |j− i|, that for all its variables yi, yj,\ne(yi) = e(yj) implies f(yi) = f(yj). (25)\nThe base case (|j − i| = 0) is trivial. For the inductive step, we may assume without loss of generality that i < j and between yi and yj there is no intermediate variable yk with e(yi) = e(yk) = e(yj) (otherwise, we can simply use the induction hypothesis together with the transitivity of equality). It follows that e(yi+1) = e(yj−1), and the atom between yj−1 and yj is oriented from yj−1 towards yj, while the atom between yi and yi+1 goes from yi+1 to yi. Indeed, this holds if the node n = e(yi) = e(yj) is an or-node since there are exactly two variables in q′ which are mapped to n, and they bound the subtree in q generated by n. For an and-node, this also holds because of our assumption about intermediate variables. By the induction hypothesis, we have f(yi+1) = f(yj−1) = aw̺ for some word aw̺. Since the only parent of aw̺ in CTα,A is aw, all arrows in relations U , L and R are oriented towards the root, and f is known to be a homomorphism, it follows that f(yi) = f(yj) = aw. This concludes the inductive argument.\nNext, we define f ′ : q → CTα,A by setting f ′(x) = f(y), where y is such that e(y) = x. By (25), f ′ is well-defined, and because f is a homomorphism, the same holds for f ′. To obtain the desired homomorphism h : q → D(α), it suffices to consider the composition of f ′ and e′; see diagram (b)."
    }, {
      "heading" : "13. M. Bienvenu, B. ten Cate, C. Lutz, and F. Wolter. Ontology-based data access: A study through",
      "text" : "disjunctive datalog, csp, and MMSNP. ACM Transasctions on Database Systems, 39(4):33:1–44, 2014. 14. E. Botoeva, D. Calvanese, V. Santarelli, D. F. Savo, A. Solimando, and G. Xiao. Beyond OWL 2 QL in OBDA: rewritings and approximations. In Proc. of the AAAI Conf. on Artificial Intelligence (AAAI 2016). AAAI, 2016. 15. A. Brandstädt, V. B. Le, and J. P. Spinrad. Graph Classes: A Survey. SIAM, Philadelphia, PA, USA, 1999. 16. A. Bretto. Hypergraph Theory: An Introduction. Springer, 2013. 17. A. Cal̀ı, G. Gottlob, and T. Lukasiewicz. A general datalog-based framework for tractable query\nanswering over ontologies. Journal of Web Semantics, 14:57–83, 2012.\n18. A. Cal̀ı, G. Gottlob, and A. Pieris. Towards more expressive ontology languages: The query answering problem. Artificial Intelligence, 193:87–128, 2012. 19. D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, A. Poggi, M. Rodriguez-Muro, R. Rosati, M. Ruzzi, and D. F. Savo. The MASTRO system for ontology-based data access. Semantic Web, 2(1):43–53, 2011. 20. D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, and R. Rosati. Tractable reasoning and efficient query answering in description logics: the DL-Lite family. Journal of Automated Reasoning, 39(3):385–429, 2007. 21. A. Chandra and P. Merlin. Optimal implementation of conjunctive queries in relational data bases. In Conference Record of the 9th Annual ACM Symposium on Theory of Computing (STOC’77), pages 77–90. ACM, 1977. 22. C. Chekuri and A. Rajaraman. Conjunctive query containment revisited. Theoretical Computer Science, 239(2):211–229, 2000. 23. A. Chortaras, D. Trivela, and G. Stamou. Optimized query rewriting for OWL 2 QL. In Proc. of CADE-23, volume 6803 of LNCS, pages 192–206. Springer, 2011. 24. C. Civili and R. Rosati. A broad class of first-order rewritable tuple-generating dependencies. In Proc. of the 2nd Int. Datalog 2.0 Workshop, volume 7494 of Lecture Notes in Computer Science, pages 68–80. Springer, 2012. 25. M. Console, J. Mora, R. Rosati, V. Santarelli, and D. F. Savo. Effective computation of maximal sound approximations of description logic ontologies. In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part II, volume 8797 of Lecture Notes in Computer Science, pages 164–179. Springer, 2014. 26. S. A. Cook. Characterizations of pushdown machines in terms of time-bounded computers. Journal of the ACM, 18(1):4–18, 1971. 27. T. Eiter, M. Ortiz, M. Šimkus, T.-K. Tran, and G. Xiao. Query rewriting for Horn-SHIQ plus rules. In Proc. of the 26th AAAI Conf. on Artificial Intelligence (AAAI 2012), pages 726–733. AAAI, 2012. 28. C. Flament. Hypergraphes arborés. Discrete Mathematics, 21(3):223–227, 1978. 29. J. Flum and M. Grohe. Parameterized Complexity Theory. Texts in Theoretical Computer Science.\nAn EATCS Series. Springer, 2006.\n30. M. Giese, A. Soylu, G. Vega-Gorgojo, A. Waaler, P. Haase, E. Jiménez-Ruiz, D. Lanti, M. Rezk, G. Xiao, Ö. Özçep, and R. Rosati. Optique: Zooming in on big data. IEEE Computer, 48(3):60–67, 2015. 31. G. Gottlob, S. Kikot, R. Kontchakov, V. V. Podolskii, T. Schwentick, and M. Zakharyaschev. The price of query rewriting in ontology-based data access. Artificial Intelligence, 213:42–59, 2014. 32. G. Gottlob, N. Leone, and F. Scarcello. Computing LOGCFL certificates. In Proc. of the 26th Int. Colloquium on Automata, Languages and Programming (ICALP-99), volume 1644 of Lecture Notes in Computer Science, pages 361–371. Springer, 1999. 33. G. Gottlob, N. Leone, and F. Scarcello. The complexity of acyclic conjunctive queries. Journal of the ACM, 48(3):431–498, 2001. 34. G. Gottlob, G. Orsi, and A. Pieris. Ontological queries: Rewriting and optimization. In Proc. of ICDE 2011, pages 2–13. IEEE Computer Society, 2011. 35. G. Gottlob and T. Schwentick. Rewriting ontological queries into small nonrecursive datalog programs. In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 254–263. AAAI, 2012. 36. M. Grohe, T. Schwentick, and L. Segoufin. When is the evaluation of conjunctive queries tractable? In Proc. of the 33rd Annual ACM Symposium on Theory of Computing (STOC 2001), pages 657– 666. ACM, 2001. 37. V. Gutiérrez-Basulto, Y. Ibáñez-Garćıa, R. Kontchakov, and E. V. Kostylev. Queries with negation and inequalities over lightweight ontologies. J. Web Sem., 35:184–202, 2015."
    }, {
      "heading" : "38. P. Hansen, C. Lutz, I. Seylan, and F. Wolter. Efficient query rewriting in the description logic EL",
      "text" : "and beyond. In Proc. of the 24th Int. Joint Conf. on Artificial Intelligence (IJCAI 2015), pages 3034–3040. AAAI, 2015. 39. D. A. Huffman. A method for the construction of minimum-redundancy codes. Proceedings of the Institute of Radio Engineers, 40(9):1098–1101, 1952. 40. N. Immerman. Nondeterministic space is closed under complementation. SIAM J. Comput., 17(5):935–938, 1988. 41. D. S. Johnson and A. C. Klug. Testing containment of conjunctive queries under functional and inclusion dependencies. In Proc. of the ACM Symposium on Principles of Database Systems (PODS), pages 164–169. ACM, 1982. 42. S. Jukna. Boolean Function Complexity — Advances and Frontiers, volume 27 of Algorithms and combinatorics. Springer, 2012. 43. M. Kaminski, Y. Nenov, and B. Cuenca Grau. Datalog rewritability of disjunctive datalog programs and its applications to ontology reasoning. In Proc. of the 28th AAAI Conference on Artificial Intelligence (AAAI 2014), pages 1077–1083. AAAI, 2014. 44. M. Karchmer and A.Wigderson. Monotone circuits for connectivity require super-logarithmic depth. In Proc. of the 20th Annual ACM Symposium on Theory of Computing (STOC ’88), pages 539–550. ACM, 1988. 45. E. Kharlamov, D. Hovland, E. Jiménez-Ruiz, D. Lanti, H. Lie, C. Pinkel, M. Rezk, M. G. Skjæveland, E. Thorstensen, G. Xiao, D. Zheleznyakov, and I. Horrocks. Ontology based access to exploration data at Statoil. In Proc. of the 14th Int. Semantic Web Conf. (ISWC 2015), Part II, volume 9367 of Lecture Notes in Computer Science, pages 93–112. Springer, 2015. 46. E. Kharlamov, N. Solomakhina, Ö. L. Özçep, D. Zheleznyakov, T. Hubauer, S. Lamparter, M. Roshchin, A. Soylu, and S. Watson. How semantic technologies can enhance data access at Siemens Energy. In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 601–619. Springer, 2014. 47. S. Kikot, R. Kontchakov, V. V. Podolskii, and M. Zakharyaschev. Exponential lower bounds and separation for query rewriting. In Proc. of the 39th Int. Colloquium on Automata, Languages and Programming (ICALP 2012), volume 7392 of Lecture Notes in Computer Science, pages 263–274. Springer, 2012. 48. S. Kikot, R. Kontchakov, and M. Zakharyaschev. On (in)tractability of OBDA with OWL 2 QL. In Proc. of the 24th Int. Workshop on Description Logics (DL 2011), volume 745, pages 224–234. CEUR-WS, 2011. 49. S. Kikot, R. Kontchakov, and M. Zakharyaschev. Conjunctive query answering with OWL 2 QL. In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 275–285. AAAI, 2012. 50. M. König, M. Leclère, and M.-L. Mugnier. Query rewriting for existential rules with compiled preorder. In Proc. of the 24th Int. Joint Conf. on Artificial Intelligence (IJCAI 2015), pages 3106– 3112. AAAI Press, 2015. 51. M. König, M. Leclère, M.-L. Mugnier, and M. Thomazo. Sound, complete and minimal ucq-rewriting for existential rules. Semantic Web, 6(5):451–475, 2015. 52. R. Kontchakov, C. Lutz, D. Toman, F. Wolter, and M. Zakharyaschev. The combined approach to query answering in DL-Lite. In Principles of Knowledge Representation and Reasoning: Proceedings of the 12th Int. Conf. KR 2010, pages 247–257. AAAI Press, 2010. 53. R. Kontchakov, M. Rezk, M. Rodriguez-Muro, G. Xiao, and M. Zakharyaschev. Answering SPARQL queries over databases under OWL 2 QL entailment regime. In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 552–567. Springer, 2014. 54. E. V. Kostylev, J. L. Reutter, and D. Vrgoc. XPath for DL ontologies. In Proc. of the 29th AAAI Conference on Artificial Intelligence (AAAI 2015), pages 1525–1531. AAAI, 2015. 55. D. Lembo, J. Mora, R. Rosati, D. F. Savo, and E. Thorstensen. Mapping analysis in ontology-based data access: Algorithms and complexity. In Proc. of the 14th Int. Semantic Web Conf. (ISWC 2015), volume 9366 of Lecture Notes in Computer Science, pages 217–234. Springer, 2015. 56. L. Libkin. Elements Of Finite Model Theory. Springer, 2004. 57. C. Lutz. The complexity of conjunctive query answering in expressive description logics. In Proc.\nof the 4th Int. Joint Conf. on Automated Reasoning (IJCAR 2008), number 5195 in LNAI, pages 179–193. Springer, 2008. 58. C. Lutz, R. Piro, and F. Wolter. Description logic tboxes: Model-theoretic characterizations and rewritability. In Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2011), pages 983–988. IJCAI/AAAI, 2011. 59. J. Mora, R. Rosati, and Ó. Corcho. Kyrie2: query rewriting under extensional constraints in ELHIO. In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), volume 8796 of Lecture Notes in Computer Science, pages 568–583. Springer, 2014.\n60. H. Pérez-Urbina, B. Motik, and I. Horrocks. A comparison of query rewriting techniques for DLlite. In Proc. of the 22nd Inte. Workshop on Description Logics (DL 2009), volume 477 of CEUR Workshop Proceedings. CEUR-WS, 2009. 61. H. Pérez-Urbina, E. Rodŕıguez-Dı́az, M. Grove, G. Konstantinidis, and E. Sirin. Evaluation of query rewriting approaches for OWL 2. In Proc. of SSWS+HPCSW 2012, volume 943 of CEUR Workshop Proceedings. CEUR-WS, 2012. 62. A. Poggi, D. Lembo, D. Calvanese, G. De Giacomo, M. Lenzerini, and R. Rosati. Linking data to ontologies. Journal on Data Semantics, X:133–173, 2008. 63. R. Raz and A. Wigderson. Monotone circuits for matching require linear depth. Journal of the ACM, 39(3):736–744, 1992. 64. A. Razborov. Lower bounds for the monotone complexity of some Boolean functions. Dokl. Akad. Nauk SSSR, 281(4):798–801, 1985. 65. A. A. Razborov. Lower bounds for deterministic and nondeterministic branching programs. In Proc. of the 8th Int. Symposium on Fundamentals of Computation Theory (FCT’91), volume 529 of Lecture Notes in Computer Science, pages 47–60. Springer, 1991. 66. M. Rodriguez-Muro and D. Calvanese. High performance query answering over DL-Lite ontologies. In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 308–318. AAAI, 2012. 67. M. Rodriguez-Muro, R. Kontchakov, and M. Zakharyaschev. Ontology-based data access: Ontop of databases. In Proc. of the 12th Int. Semantic Web Conf. (ISWC 2013), volume 8218 of Lecture Notes in Computer Science, pages 558–573. Springer, 2013. 68. R. Rosati. The limits of querying ontologies. In Proc. of the 11th Int. Conf. on Database Theory (ICDT 2007), volume 4353 of Lecture Notes in Computer Science, pages 164–178. Springer, 2007. 69. R. Rosati. Prexto: Query rewriting under extensional constraints in DL-Lite. In Proc. of the 9th Extended Semantic Web Conf. (EWSC 2012), volume 7295 of Lecture Notes in Computer Science, pages 360–374. Springer, 2012. 70. R. Rosati and A. Almatelli. Improving query answering over DL-Lite ontologies. In Proc. of the 12th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2010), pages 290–300. AAAI Press, 2010. 71. J. F. Sequeda, M. Arenas, and D. P. Miranker. OBDA: query rewriting or materialization? in practice, both! In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 535–551. Springer, 2014. 72. I. H. Sudborough. On the tape complexity of deterministic context-free languages. Journal of the ACM, 25(3):405–414, 1978. 73. R. Szelepcsényi. The method of forced enumeration for nondeterministic automata. Acta Informatica, 26(3):279–284, 1988. 74. M. Vardi. The complexity of relational query languages (extended abstract). In Proc. of the 14th ACM SIGACT Symp. on Theory of Computing (STOC’82), pages 137–146. ACM, 1982. 75. H. Venkateswaran. Properties that characterize LOGCFL. Journal of Computer and System Sciences, 43(2):380–404, 1991. 76. H. Vollmer. Introduction to Circuit Complexity: A Uniform Approach. Springer, 1999. 77. M. Yannakakis. Algorithms for acyclic database schemes. In Proc. of the 7th Int. Conf. on Very\nLarge Data Bases (VLDB), pages 82–94. IEEE Computer Society, 1981. 78. Y. Zhou, B. Cuenca Grau, Y. Nenov, M. Kaminski, and I. Horrocks. Pagoda: Pay-as-you-go ontology\nquery answering using a datalog reasoner. Journal of Artificial Intelligence Research (JAIR), 54:309– 367, 2015."
    } ],
    "references" : [ {
      "title" : "Foundations of Databases",
      "author" : [ "S. Abiteboul", "R. Hull", "V. Vianu" ],
      "venue" : "Addison-Wesley,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "The monotone circuit complexity of boolean functions",
      "author" : [ "N. Alon", "R. Boppana" ],
      "venue" : "Combinatorica, 7(1):1–22,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Computational Complexity: A Modern Approach",
      "author" : [ "S. Arora", "B. Barak" ],
      "venue" : "Cambridge University Press, New York, NY, USA, 1st edition,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "The DL-Lite family and relations",
      "author" : [ "A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR), 36:1–69,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "A linear-time algorithm for testing the truth of certain quantified boolean formulas",
      "author" : [ "B. Aspvall", "M. Plass", "R. Tarjan" ],
      "venue" : "Information Processing Letters, 8(3):121–123,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "Eliminating definitions and Skolem functions in first-order logic",
      "author" : [ "J. Avigad" ],
      "venue" : "ACM Transactions on Computational Logic, 4(3):402–415,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "On rules with existential variables: Walking the decidability line",
      "author" : [ "J.-F. Baget", "M. Leclère", "M.-L. Mugnier", "E. Salvat" ],
      "venue" : "Artificial Intelligence, 175(9–10):1620–1654,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Theoretically optimal datalog rewritings for owl 2 ql ontology-mediated queries",
      "author" : [ "M. Bienvenu", "S. Kikot", "R. Kontchakov", "V. Podolskii", "M. Zakharyaschev" ],
      "venue" : "CoRR, abs/1604.05258,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "First-order rewritability of atomic queries in horn description logics",
      "author" : [ "M. Bienvenu", "C. Lutz", "F. Wolter" ],
      "venue" : "In Proc. of the 23nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2013), pages 754–760. IJCAI/AAAI,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Regular path queries in lightweight description logics: Complexity and algorithms",
      "author" : [ "M. Bienvenu", "M. Ortiz", "M. Simkus" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR), 53:315–374,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Tractable queries for lightweight description logics",
      "author" : [ "M. Bienvenu", "M. Ortiz", "M. Simkus", "G. Xiao" ],
      "venue" : "In Proc. of the 23nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2013), pages 768–774. IJCAI/AAAI,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Query-based comparison of OBDA specifications",
      "author" : [ "M. Bienvenu", "R. Rosati" ],
      "venue" : "In Proc. of the 28th International Workshop on Description Logics (DL 2015), volume 1350 of CEUR Workshop Proceedings, pages 55–66. CEUR-WS,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "B",
      "author" : [ "M. Bienvenu" ],
      "venue" : "ten Cate, C. Lutz, and F. Wolter. Ontology-based data access: A study through disjunctive datalog, csp, and MMSNP. ACM Transasctions on Database Systems, 39(4):33:1–44,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Beyond OWL 2 QL in OBDA: rewritings and approximations",
      "author" : [ "E. Botoeva", "D. Calvanese", "V. Santarelli", "D.F. Savo", "A. Solimando", "G. Xiao" ],
      "venue" : "In Proc. of the AAAI Conf. on Artificial Intelligence (AAAI 2016). AAAI,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Graph Classes: A Survey",
      "author" : [ "A. Brandstädt", "V.B. Le", "J.P. Spinrad" ],
      "venue" : "SIAM, Philadelphia, PA, USA,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Hypergraph Theory: An Introduction",
      "author" : [ "A. Bretto" ],
      "venue" : "Springer,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "A general datalog-based framework for tractable query answering over ontologies",
      "author" : [ "A. Cal̀ı", "G. Gottlob", "T. Lukasiewicz" ],
      "venue" : "Journal of Web Semantics,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2012
    }, {
      "title" : "Towards more expressive ontology languages: The query answering problem",
      "author" : [ "A. Cal̀ı", "G. Gottlob", "A. Pieris" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2012
    }, {
      "title" : "The MASTRO system for ontology-based data access",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "A. Poggi", "M. Rodriguez-Muro", "R. Rosati", "M. Ruzzi", "D.F. Savo" ],
      "venue" : "Semantic Web, 2(1):43–53,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Tractable reasoning and efficient query answering in description logics: the DL-Lite family",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Journal of Automated Reasoning, 39(3):385–429,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Optimal implementation of conjunctive queries in relational data bases",
      "author" : [ "A. Chandra", "P. Merlin" ],
      "venue" : "In Conference Record of the 9th Annual ACM Symposium on Theory of Computing (STOC’77), pages 77–90. ACM,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 1977
    }, {
      "title" : "Conjunctive query containment revisited",
      "author" : [ "C. Chekuri", "A. Rajaraman" ],
      "venue" : "Theoretical Computer Science, 239(2):211–229,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Optimized query rewriting for OWL 2 QL",
      "author" : [ "A. Chortaras", "D. Trivela", "G. Stamou" ],
      "venue" : "In Proc. of CADE-23, volume 6803 of LNCS, pages 192–206. Springer,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A broad class of first-order rewritable tuple-generating dependencies",
      "author" : [ "C. Civili", "R. Rosati" ],
      "venue" : "In Proc. of the 2nd Int. Datalog 2.0 Workshop, volume 7494 of Lecture Notes in Computer Science, pages 68–80. Springer,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Effective computation of maximal sound approximations of description logic ontologies",
      "author" : [ "M. Console", "J. Mora", "R. Rosati", "V. Santarelli", "D.F. Savo" ],
      "venue" : "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part II, volume 8797 of Lecture Notes in Computer Science, pages 164–179. Springer,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Characterizations of pushdown machines in terms of time-bounded computers",
      "author" : [ "S.A. Cook" ],
      "venue" : "Journal of the ACM, 18(1):4–18,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 1971
    }, {
      "title" : "Query rewriting for Horn-SHIQ plus rules",
      "author" : [ "T. Eiter", "M. Ortiz", "M. Šimkus", "T.-K. Tran", "G. Xiao" ],
      "venue" : "In Proc. of the 26th AAAI Conf. on Artificial Intelligence (AAAI 2012), pages 726–733. AAAI,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Hypergraphes arborés",
      "author" : [ "C. Flament" ],
      "venue" : "Discrete Mathematics, 21(3):223–227,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "Parameterized Complexity Theory",
      "author" : [ "J. Flum", "M. Grohe" ],
      "venue" : "Texts in Theoretical Computer Science. An EATCS Series. Springer,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Optique: Zooming in on big data",
      "author" : [ "M. Giese", "A. Soylu", "G. Vega-Gorgojo", "A. Waaler", "P. Haase", "E. Jiménez-Ruiz", "D. Lanti", "M. Rezk", "G. Xiao", "Ö. Özçep", "R. Rosati" ],
      "venue" : "IEEE Computer, 48(3):60–67,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "The price of query rewriting in ontology-based data access",
      "author" : [ "G. Gottlob", "S. Kikot", "R. Kontchakov", "V.V. Podolskii", "T. Schwentick", "M. Zakharyaschev" ],
      "venue" : "Artificial Intelligence, 213:42–59,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Computing LOGCFL certificates",
      "author" : [ "G. Gottlob", "N. Leone", "F. Scarcello" ],
      "venue" : "In Proc. of the 26th Int. Colloquium on Automata, Languages and Programming (ICALP-99), volume 1644 of Lecture Notes in Computer Science, pages 361–371. Springer,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "The complexity of acyclic conjunctive queries",
      "author" : [ "G. Gottlob", "N. Leone", "F. Scarcello" ],
      "venue" : "Journal of the ACM, 48(3):431–498,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Ontological queries: Rewriting and optimization",
      "author" : [ "G. Gottlob", "G. Orsi", "A. Pieris" ],
      "venue" : "In Proc. of ICDE 2011, pages 2–13. IEEE Computer Society,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Rewriting ontological queries into small nonrecursive datalog programs",
      "author" : [ "G. Gottlob", "T. Schwentick" ],
      "venue" : "In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 254–263. AAAI,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "When is the evaluation of conjunctive queries tractable? In Proc",
      "author" : [ "M. Grohe", "T. Schwentick", "L. Segoufin" ],
      "venue" : "of the 33rd Annual ACM Symposium on Theory of Computing (STOC 2001), pages 657– 666. ACM,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Queries with negation and inequalities over lightweight ontologies",
      "author" : [ "V. Gutiérrez-Basulto", "Y. Ibáñez-Garćıa", "R. Kontchakov", "E.V. Kostylev" ],
      "venue" : "J. Web Sem., 35:184–202,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Efficient query rewriting in the description logic EL and beyond",
      "author" : [ "P. Hansen", "C. Lutz", "I. Seylan", "F. Wolter" ],
      "venue" : "In Proc. of the 24th Int. Joint Conf. on Artificial Intelligence (IJCAI 2015), pages 3034–3040. AAAI,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "A method for the construction of minimum-redundancy codes",
      "author" : [ "D.A. Huffman" ],
      "venue" : "Proceedings of the Institute of Radio Engineers, 40(9):1098–1101,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 1952
    }, {
      "title" : "Nondeterministic space is closed under complementation",
      "author" : [ "N. Immerman" ],
      "venue" : "SIAM J. Comput., 17(5):935–938,",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Testing containment of conjunctive queries under functional and inclusion dependencies",
      "author" : [ "D.S. Johnson", "A.C. Klug" ],
      "venue" : "In Proc. of the ACM Symposium on Principles of Database Systems (PODS), pages 164–169. ACM,",
      "citeRegEx" : "41",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "Boolean Function Complexity — Advances and Frontiers, volume 27 of Algorithms and combinatorics",
      "author" : [ "S. Jukna" ],
      "venue" : "Springer,",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Datalog rewritability of disjunctive datalog programs and its applications to ontology reasoning",
      "author" : [ "M. Kaminski", "Y. Nenov", "B. Cuenca Grau" ],
      "venue" : "In Proc. of the 28th AAAI Conference on Artificial Intelligence (AAAI 2014), pages 1077–1083. AAAI,",
      "citeRegEx" : "43",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Monotone circuits for connectivity require super-logarithmic depth",
      "author" : [ "M. Karchmer", "A.Wigderson" ],
      "venue" : "In Proc. of the 20th Annual ACM Symposium on Theory of Computing (STOC",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 1988
    }, {
      "title" : "Ontology based access to exploration data at Statoil",
      "author" : [ "E. Kharlamov", "D. Hovland", "E. Jiménez-Ruiz", "D. Lanti", "H. Lie", "C. Pinkel", "M. Rezk", "M.G. Skjæveland", "E. Thorstensen", "G. Xiao", "D. Zheleznyakov", "I. Horrocks" ],
      "venue" : "In Proc. of the 14th Int. Semantic Web Conf. (ISWC 2015), Part II, volume 9367 of Lecture Notes in Computer Science, pages 93–112. Springer,",
      "citeRegEx" : "45",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "How semantic technologies can enhance data access at Siemens Energy",
      "author" : [ "E. Kharlamov", "N. Solomakhina", "Ö.L. Özçep", "D. Zheleznyakov", "T. Hubauer", "S. Lamparter", "M. Roshchin", "A. Soylu", "S. Watson" ],
      "venue" : "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 601–619. Springer,",
      "citeRegEx" : "46",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Exponential lower bounds and separation for query rewriting",
      "author" : [ "S. Kikot", "R. Kontchakov", "V.V. Podolskii", "M. Zakharyaschev" ],
      "venue" : "In Proc. of the 39th Int. Colloquium on Automata, Languages and Programming (ICALP 2012), volume 7392 of Lecture Notes in Computer Science, pages 263–274. Springer,",
      "citeRegEx" : "47",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "On (in)tractability of OBDA with OWL 2 QL",
      "author" : [ "S. Kikot", "R. Kontchakov", "M. Zakharyaschev" ],
      "venue" : "In Proc. of the 24th Int. Workshop on Description Logics (DL 2011), volume 745, pages 224–234. CEUR-WS,",
      "citeRegEx" : "48",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Conjunctive query answering with OWL 2 QL",
      "author" : [ "S. Kikot", "R. Kontchakov", "M. Zakharyaschev" ],
      "venue" : "In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 275–285. AAAI,",
      "citeRegEx" : "49",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Query rewriting for existential rules with compiled preorder",
      "author" : [ "M. König", "M. Leclère", "M.-L. Mugnier" ],
      "venue" : "In Proc. of the 24th Int. Joint Conf. on Artificial Intelligence (IJCAI 2015), pages 3106– 3112. AAAI Press,",
      "citeRegEx" : "50",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Sound, complete and minimal ucq-rewriting for existential rules",
      "author" : [ "M. König", "M. Leclère", "M.-L. Mugnier", "M. Thomazo" ],
      "venue" : "Semantic Web, 6(5):451–475,",
      "citeRegEx" : "51",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "The combined approach to query answering in DL-Lite",
      "author" : [ "R. Kontchakov", "C. Lutz", "D. Toman", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "In Principles of Knowledge Representation and Reasoning: Proceedings of the 12th Int. Conf. KR 2010, pages 247–257. AAAI Press,",
      "citeRegEx" : "52",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Answering SPARQL queries over databases under OWL 2 QL entailment regime",
      "author" : [ "R. Kontchakov", "M. Rezk", "M. Rodriguez-Muro", "G. Xiao", "M. Zakharyaschev" ],
      "venue" : "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 552–567. Springer,",
      "citeRegEx" : "53",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "XPath for DL ontologies",
      "author" : [ "E.V. Kostylev", "J.L. Reutter", "D. Vrgoc" ],
      "venue" : "In Proc. of the 29th AAAI Conference on Artificial Intelligence (AAAI 2015), pages 1525–1531. AAAI,",
      "citeRegEx" : "54",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Mapping analysis in ontology-based data access: Algorithms and complexity",
      "author" : [ "D. Lembo", "J. Mora", "R. Rosati", "D.F. Savo", "E. Thorstensen" ],
      "venue" : "In Proc. of the 14th Int. Semantic Web Conf. (ISWC 2015), volume 9366 of Lecture Notes in Computer Science, pages 217–234. Springer,",
      "citeRegEx" : "55",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Elements Of Finite Model Theory",
      "author" : [ "L. Libkin" ],
      "venue" : "Springer,",
      "citeRegEx" : "56",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "The complexity of conjunctive query answering in expressive description logics",
      "author" : [ "C. Lutz" ],
      "venue" : "In Proc. of the 4th Int. Joint Conf. on Automated Reasoning (IJCAR 2008), number 5195 in LNAI, pages 179–193. Springer,",
      "citeRegEx" : "57",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Description logic tboxes: Model-theoretic characterizations and rewritability",
      "author" : [ "C. Lutz", "R. Piro", "F. Wolter" ],
      "venue" : "In Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2011), pages 983–988. IJCAI/AAAI,",
      "citeRegEx" : "58",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Kyrie2: query rewriting under extensional constraints in ELHIO",
      "author" : [ "J. Mora", "R. Rosati", "Ó. Corcho" ],
      "venue" : "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), volume 8796 of Lecture Notes in Computer Science, pages 568–583. Springer,",
      "citeRegEx" : "59",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "A comparison of query rewriting techniques for DLlite",
      "author" : [ "H. Pérez-Urbina", "B. Motik", "I. Horrocks" ],
      "venue" : "In Proc. of the 22nd Inte. Workshop on Description Logics (DL 2009), volume 477 of CEUR Workshop Proceedings. CEUR-WS,",
      "citeRegEx" : "60",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "E",
      "author" : [ "H. Pérez-Urbina" ],
      "venue" : "Rodŕıguez-Dı́az, M. Grove, G. Konstantinidis, and E. Sirin. Evaluation of query rewriting approaches for OWL 2. In Proc. of SSWS+HPCSW 2012, volume 943 of CEUR Workshop Proceedings. CEUR-WS,",
      "citeRegEx" : "61",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Linking data to ontologies",
      "author" : [ "A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Journal on Data Semantics, X:133–173,",
      "citeRegEx" : "62",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Monotone circuits for matching require linear depth",
      "author" : [ "R. Raz", "A. Wigderson" ],
      "venue" : "Journal of the ACM, 39(3):736–744,",
      "citeRegEx" : "63",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "Lower bounds for the monotone complexity of some Boolean functions",
      "author" : [ "A. Razborov" ],
      "venue" : "Dokl. Akad. Nauk SSSR, 281(4):798–801,",
      "citeRegEx" : "64",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "Lower bounds for deterministic and nondeterministic branching programs",
      "author" : [ "A.A. Razborov" ],
      "venue" : "In Proc. of the 8th Int. Symposium on Fundamentals of Computation Theory (FCT’91), volume 529 of Lecture Notes in Computer Science, pages 47–60. Springer,",
      "citeRegEx" : "65",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "High performance query answering over DL-Lite ontologies",
      "author" : [ "M. Rodriguez-Muro", "D. Calvanese" ],
      "venue" : "In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 308–318. AAAI,",
      "citeRegEx" : "66",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Ontology-based data access: Ontop of databases",
      "author" : [ "M. Rodriguez-Muro", "R. Kontchakov", "M. Zakharyaschev" ],
      "venue" : "In Proc. of the 12th Int. Semantic Web Conf. (ISWC 2013), volume 8218 of Lecture Notes in Computer Science, pages 558–573. Springer,",
      "citeRegEx" : "67",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "The limits of querying ontologies",
      "author" : [ "R. Rosati" ],
      "venue" : "In Proc. of the 11th Int. Conf. on Database Theory (ICDT 2007), volume 4353 of Lecture Notes in Computer Science, pages 164–178. Springer,",
      "citeRegEx" : "68",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Prexto: Query rewriting under extensional constraints in DL-Lite",
      "author" : [ "R. Rosati" ],
      "venue" : "In Proc. of the 9th Extended Semantic Web Conf. (EWSC 2012), volume 7295 of Lecture Notes in Computer Science, pages 360–374. Springer,",
      "citeRegEx" : "69",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Improving query answering over DL-Lite ontologies",
      "author" : [ "R. Rosati", "A. Almatelli" ],
      "venue" : "In Proc. of the 12th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2010), pages 290–300. AAAI Press,",
      "citeRegEx" : "70",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "OBDA: query rewriting or materialization? in practice, both! In Proc",
      "author" : [ "J.F. Sequeda", "M. Arenas", "D.P. Miranker" ],
      "venue" : "of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 535–551. Springer,",
      "citeRegEx" : "71",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "On the tape complexity of deterministic context-free languages",
      "author" : [ "I.H. Sudborough" ],
      "venue" : "Journal of the ACM, 25(3):405–414,",
      "citeRegEx" : "72",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "The method of forced enumeration for nondeterministic automata",
      "author" : [ "R. Szelepcsényi" ],
      "venue" : "Acta Informatica, 26(3):279–284,",
      "citeRegEx" : "73",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "The complexity of relational query languages (extended abstract)",
      "author" : [ "M. Vardi" ],
      "venue" : "In Proc. of the 14th ACM SIGACT Symp. on Theory of Computing (STOC’82), pages 137–146. ACM,",
      "citeRegEx" : "74",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "Properties that characterize LOGCFL",
      "author" : [ "H. Venkateswaran" ],
      "venue" : "Journal of Computer and System Sciences, 43(2):380–404,",
      "citeRegEx" : "75",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Introduction to Circuit Complexity: A Uniform Approach",
      "author" : [ "H. Vollmer" ],
      "venue" : "Springer,",
      "citeRegEx" : "76",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Algorithms for acyclic database schemes",
      "author" : [ "M. Yannakakis" ],
      "venue" : "In Proc. of the 7th Int. Conf. on Very Large Data Bases (VLDB), pages 82–94. IEEE Computer Society,",
      "citeRegEx" : "77",
      "shortCiteRegEx" : null,
      "year" : 1981
    }, {
      "title" : "Pagoda: Pay-as-you-go ontology query answering using a datalog reasoner",
      "author" : [ "Y. Zhou", "B. Cuenca Grau", "Y. Nenov", "M. Kaminski", "I. Horrocks" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR), 54:309– 367,",
      "citeRegEx" : "78",
      "shortCiteRegEx" : null,
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 61,
      "context" : "[62] with the aim of facilitating query answering over complex, possibly incomplete and heterogeneous data sources.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 61,
      "context" : "[62], the OBDA system employs the ontology and mappings in order to transform the user query into a query over the data sources, and then delegates the actual query evaluation to the underlying database engines and triplestores.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[20] and later extended by Artale et al.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 3,
      "context" : "[4], was specifically designed to ensure the existence of FO-rewritings for all conjunctive queries (CQs).",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "’ Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24].",
      "startOffset" : 135,
      "endOffset" : 146
    }, {
      "referenceID" : 17,
      "context" : "’ Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24].",
      "startOffset" : 135,
      "endOffset" : 146
    }, {
      "referenceID" : 23,
      "context" : "’ Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24].",
      "startOffset" : 135,
      "endOffset" : 146
    }, {
      "referenceID" : 67,
      "context" : "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].",
      "startOffset" : 228,
      "endOffset" : 244
    }, {
      "referenceID" : 36,
      "context" : "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].",
      "startOffset" : 228,
      "endOffset" : 244
    }, {
      "referenceID" : 9,
      "context" : "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].",
      "startOffset" : 228,
      "endOffset" : 244
    }, {
      "referenceID" : 53,
      "context" : "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].",
      "startOffset" : 228,
      "endOffset" : 244
    }, {
      "referenceID" : 61,
      "context" : "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 69,
      "context" : "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).",
      "startOffset" : 111,
      "endOffset" : 119
    }, {
      "referenceID" : 68,
      "context" : "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).",
      "startOffset" : 111,
      "endOffset" : 119
    }, {
      "referenceID" : 48,
      "context" : "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).",
      "startOffset" : 144,
      "endOffset" : 148
    }, {
      "referenceID" : 33,
      "context" : "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).",
      "startOffset" : 195,
      "endOffset" : 199
    }, {
      "referenceID" : 50,
      "context" : "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).",
      "startOffset" : 206,
      "endOffset" : 210
    }, {
      "referenceID" : 59,
      "context" : "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).",
      "startOffset" : 303,
      "endOffset" : 307
    }, {
      "referenceID" : 22,
      "context" : "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).",
      "startOffset" : 315,
      "endOffset" : 319
    }, {
      "referenceID" : 26,
      "context" : "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).",
      "startOffset" : 329,
      "endOffset" : 333
    }, {
      "referenceID" : 58,
      "context" : "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).",
      "startOffset" : 344,
      "endOffset" : 348
    }, {
      "referenceID" : 18,
      "context" : "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 60,
      "context" : "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].",
      "startOffset" : 95,
      "endOffset" : 99
    }, {
      "referenceID" : 70,
      "context" : "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 29,
      "context" : "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].",
      "startOffset" : 145,
      "endOffset" : 149
    }, {
      "referenceID" : 66,
      "context" : "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].",
      "startOffset" : 192,
      "endOffset" : 200
    }, {
      "referenceID" : 52,
      "context" : "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].",
      "startOffset" : 192,
      "endOffset" : 200
    }, {
      "referenceID" : 45,
      "context" : "By providing a semantic end-to-end connection between users and multiple distributed data sources (and thus making the IT expert middleman redundant), OBDA has attracted the attention of industry, with companies such as Siemens [46] and Statoil [45] experimenting with OBDA technologies to streamline the process of data access for their engineers.",
      "startOffset" : 228,
      "endOffset" : 232
    }, {
      "referenceID" : 44,
      "context" : "By providing a semantic end-to-end connection between users and multiple distributed data sources (and thus making the IT expert middleman redundant), OBDA has attracted the attention of industry, with companies such as Siemens [46] and Statoil [45] experimenting with OBDA technologies to streamline the process of data access for their engineers.",
      "startOffset" : 245,
      "endOffset" : 249
    }, {
      "referenceID" : 35,
      "context" : "[36, 56] and references therein.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 55,
      "context" : "[36, 56] and references therein.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 46,
      "context" : "[47] and Gottlob and Schwentick [35].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 34,
      "context" : "[47] and Gottlob and Schwentick [35].",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 34,
      "context" : "Gottlob and Schwentick [35] and Gottlob et al.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 30,
      "context" : "[31] showed that PE- (and so all other) ‘rewritings’ can be made polynomial under the condition that all relevant data instances contain two special constants.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 5,
      "context" : "NFAs vs DFAs, and [6]).",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 48,
      "context" : "Our starting point is the observation that the tree-witness PE-rewriting of an OMQ Q = (T , q) introduced by [49] defines a hypergraph whose vertices are the atoms in q and whose hyperedges correspond to connected sub-queries of q that can be homomorphically mapped to labelled nulls of some chases for T .",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 19,
      "context" : "It is known [20, 4] that the general OMQ answering problem is NP-complete for combined complexity—that is, of the same complexity as standard CQ evaluation in databases.",
      "startOffset" : 12,
      "endOffset" : 19
    }, {
      "referenceID" : 3,
      "context" : "It is known [20, 4] that the general OMQ answering problem is NP-complete for combined complexity—that is, of the same complexity as standard CQ evaluation in databases.",
      "startOffset" : 12,
      "endOffset" : 19
    }, {
      "referenceID" : 47,
      "context" : "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 76,
      "context" : "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].",
      "startOffset" : 159,
      "endOffset" : 171
    }, {
      "referenceID" : 21,
      "context" : "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].",
      "startOffset" : 159,
      "endOffset" : 171
    }, {
      "referenceID" : 31,
      "context" : "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].",
      "startOffset" : 159,
      "endOffset" : 171
    }, {
      "referenceID" : 55,
      "context" : "We remind the reader [56] that, for any CQ q(x) = ∃y φ(x,y), any first-order structure I and any tuple a from its domain ∆, we have I |= q(a) iff there is a map h : x ∪ y → ∆ such that (i) if S(z) ∈ q then I |= S(h(z)), and (ii) h(x) = a.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 76,
      "context" : "8 Tree-shaped CQs also go by the name of acyclic queries [77, 11].",
      "startOffset" : 57,
      "endOffset" : 65
    }, {
      "referenceID" : 10,
      "context" : "8 Tree-shaped CQs also go by the name of acyclic queries [77, 11].",
      "startOffset" : 57,
      "endOffset" : 65
    }, {
      "referenceID" : 0,
      "context" : "Recall [1] that a datalog program, Π , is a finite set of Horn clauses ∀x (γ1 ∧ · · · ∧ γm → γ0), where each γi is an atom P (x1, .",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 0,
      "context" : "As defined, FO- and PE-rewritings are not necessarily domain-independent queries, while NDL-rewritings are not necessarily safe [1].",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 18,
      "context" : "Indeed, it was observed experimentally [19] and also established theoretically [47] that sometimes the rewritings are prohibitively large—exponentially-large in the size of the original CQ, to be more precise.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 46,
      "context" : "Indeed, it was observed experimentally [19] and also established theoretically [47] that sometimes the rewritings are prohibitively large—exponentially-large in the size of the original CQ, to be more precise.",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 73,
      "context" : "In complexity-theoretic terms, the focus should not only be on the data complexity of OMQ answering, which is an appropriate measure for database query evaluation (where queries are indeed usually small) [74], but also on the combined complexity that takes into account the contribution of ontologies and queries.",
      "startOffset" : 204,
      "endOffset" : 208
    }, {
      "referenceID" : 48,
      "context" : "[49] (cf.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 56,
      "context" : "[57, 52, 51] for rewritings based on similar ideas).",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 51,
      "context" : "[57, 52, 51] for rewritings based on similar ideas).",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 50,
      "context" : "[57, 52, 51] for rewritings based on similar ideas).",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 16,
      "context" : "It is not hard to see that, for any OMQ (T , q(x)) and data instance A, a tuple a is a certain answer to (T , q(x)) over A iff either T ,A |= q(a) or T ,A |= ∃z ψ(z), for some ψ(z) → ⊥ in T −; see [17] for more details.",
      "startOffset" : 197,
      "endOffset" : 201
    }, {
      "referenceID" : 66,
      "context" : "Such classes of data instances can be defined, for example, by the integrity constraints in the database schema and the mapping [67].",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 0,
      "context" : "As is well-known [1], every pair (T ,A) of an ontology T and data instance A possesses a canonical model (or chase) CT ,A such that T ,A |= q(a) iff CT ,A |= q(a), for all CQs q(x) and a in ind(A).",
      "startOffset" : 17,
      "endOffset" : 20
    }, {
      "referenceID" : 66,
      "context" : "[67] used the term ‘H-completeness’; see also [50].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 49,
      "context" : "[67] used the term ‘H-completeness’; see also [50].",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 40,
      "context" : "̺n with n ≤ p(|Q|) [41, 17].",
      "startOffset" : 19,
      "endOffset" : 27
    }, {
      "referenceID" : 16,
      "context" : "̺n with n ≤ p(|Q|) [41, 17].",
      "startOffset" : 19,
      "endOffset" : 27
    }, {
      "referenceID" : 30,
      "context" : "(In general, the bounded derivation depth property of an ontology language is a necessary and sufficient condition of FO-rewritability [31].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 46,
      "context" : "The class of all OMQs (even with ontologies of finite depth and tree-shaped CQs) does not have the PFSP [47].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 48,
      "context" : "Theorem 2 ([49]).",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 2,
      "context" : ", [3, 42]) that an n-ary Boolean function, for n ≥ 1, is any function from {0, 1} to {0, 1}.",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 41,
      "context" : ", [3, 42]) that an n-ary Boolean function, for n ≥ 1, is any function from {0, 1} to {0, 1}.",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 27,
      "context" : "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka hypertree) from graph theory [28, 15, 16].",
      "startOffset" : 128,
      "endOffset" : 140
    }, {
      "referenceID" : 14,
      "context" : "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka hypertree) from graph theory [28, 15, 16].",
      "startOffset" : 128,
      "endOffset" : 140
    }, {
      "referenceID" : 15,
      "context" : "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka hypertree) from graph theory [28, 15, 16].",
      "startOffset" : 128,
      "endOffset" : 140
    }, {
      "referenceID" : 28,
      "context" : ", [29]) that a tree decomposition of an undirected graph G = (V,E) is a pair (T, λ), where T is an (undirected) tree and λ a function from the set of nodes of T to 2 such that – for every v ∈ V , there exists a node N with v ∈ λ(N); – for every e ∈ E, there exists a node N with e ⊆ λ(N); – for every v ∈ V , the nodes {N | v ∈ λ(N)} induce a (connected) subtree of T .",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 0,
      "context" : "A (bag) type is an m-tuple of the form w = (w[1], .",
      "startOffset" : 45,
      "endOffset" : 48
    }, {
      "referenceID" : 2,
      "context" : ", [3, 42].",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 41,
      "context" : ", [3, 42].",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 75,
      "context" : "LOGCFL/poly (also known as SAC) is the class of Boolean functions computable by polynomialsize and logarithmic-depth circuits in which and-gates have two inputs but or-gates can have arbitrarily many inputs (unbounded fan-in) and not-gates can only be applied to inputs of the circuit [76].",
      "startOffset" : 285,
      "endOffset" : 289
    }, {
      "referenceID" : 63,
      "context" : "We note in passing that the monotone variants of the classes in (9) also form a chain [64, 2, 44]:",
      "startOffset" : 86,
      "endOffset" : 97
    }, {
      "referenceID" : 1,
      "context" : "We note in passing that the monotone variants of the classes in (9) also form a chain [64, 2, 44]:",
      "startOffset" : 86,
      "endOffset" : 97
    }, {
      "referenceID" : 43,
      "context" : "We note in passing that the monotone variants of the classes in (9) also form a chain [64, 2, 44]:",
      "startOffset" : 86,
      "endOffset" : 97
    }, {
      "referenceID" : 41,
      "context" : "We remind the reader (consult [42] for more details)",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 72,
      "context" : "As follows from [73, 40], if a function f is computable by a polynomial-size NBP, then ¬f is also computable by a polynomial-size NBP.",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 39,
      "context" : "As follows from [73, 40], if a function f is computable by a polynomial-size NBP, then ¬f is also computable by a polynomial-size NBP.",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 4,
      "context" : "We first provide a graph-theoretic characterisation of independent sets covering all zeros based on the implication graph [5].",
      "startOffset" : 122,
      "endOffset" : 125
    }, {
      "referenceID" : 38,
      "context" : "As shown by Huffman [39], there is a prefix binary code such that each Dj is encoded by a word of length ⌈log(m/mj)⌉.",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 63,
      "context" : "A series of papers, started by Razborov [64], gave an exponential lower bound for the size of monotone circuits computing Clique, namely, 2 √ k)",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 1,
      "context" : "for k ≤ 14 (n/ logn) 2/3 [2].",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 62,
      "context" : "For monotone formulas, an even better lower bound is known: 2 for k = 2n/3 [63].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 43,
      "context" : "It is known [44, 42] that Reachability is computable by a polynomial-size monotone NBP (that is, belongs to mNL/poly), but any monotone Boolean formula for Reachability is of size n.",
      "startOffset" : 12,
      "endOffset" : 20
    }, {
      "referenceID" : 41,
      "context" : "It is known [44, 42] that Reachability is computable by a polynomial-size monotone NBP (that is, belongs to mNL/poly), but any monotone Boolean formula for Reachability is of size n.",
      "startOffset" : 12,
      "endOffset" : 20
    }, {
      "referenceID" : 64,
      "context" : "Since f is NL/poly-complete under NC-reductions [65], we obtain NL/poly ⊆ NC.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 64,
      "context" : "Since f is NL/polycomplete under NC-reductions [65], we obtain NL/poly ⊆ NC.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 0,
      "context" : "4 except that in the definition of E i , instead of considering all types wk of Ni, we only use wk = (w[1], .",
      "startOffset" : 103,
      "endOffset" : 106
    }, {
      "referenceID" : 47,
      "context" : "[48] is based on a flawed proof.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]—LOGCFL-complete, to be more precise [33].",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 76,
      "context" : "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]—LOGCFL-complete, to be more precise [33].",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 21,
      "context" : "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]—LOGCFL-complete, to be more precise [33].",
      "startOffset" : 121,
      "endOffset" : 129
    }, {
      "referenceID" : 35,
      "context" : "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]—LOGCFL-complete, to be more precise [33].",
      "startOffset" : 121,
      "endOffset" : 129
    }, {
      "referenceID" : 32,
      "context" : "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]—LOGCFL-complete, to be more precise [33].",
      "startOffset" : 166,
      "endOffset" : 170
    }, {
      "referenceID" : 19,
      "context" : "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 3,
      "context" : "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 47,
      "context" : "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 30,
      "context" : "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 32,
      "context" : "We begin by showing that the LOGCFL upper bound for CQs of bounded treewidth [33] is preserved even in the presence of ontologies of bounded depth.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 31,
      "context" : "As LOGCFL is closed under L reductions [32] and evaluation of CQs of bounded treewidth is LOGCFL-complete, it suffices to show that CT ,A can be computed by an L-transducer (a deterministic logspace Turing machine with a LOGCFL oracle).",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 3,
      "context" : "Finally, as entailment in OWL2QL is in NL [4], each of the following problems can be decided by making a call to an NL (hence LOGCFL) oracle: – decide whether a̺1 .",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 3,
      "context" : "The possible choices for z0 include ind(A) and aw ∈ ∆CT ,A such that |w| ≤ 2|T |+ |q|, which are enough to find a homomorphism if it exists [4].",
      "startOffset" : 140,
      "endOffset" : 143
    }, {
      "referenceID" : 3,
      "context" : "Finally, it should be clear that the subroutine canMap(z, u) can also be implemented in NL [4].",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 47,
      "context" : "It remains to settle the complexity of answering OMQs with arbitrary ontologies and boundedleaf CQs, for which neither the upper bounds from the preceding subsection nor the NP lower bound by [48] are applicable.",
      "startOffset" : 192,
      "endOffset" : 196
    }, {
      "referenceID" : 25,
      "context" : "An NAuxPDA [26] is a non-deterministic Turing machine with an additional work tape constrained to operate as a pushdown store.",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 71,
      "context" : "[72] showed that LOGCFL coincides with the class of problems that can be solved by NAuxPDAs running in logarithmic space and polynomial time (note that the space on the pushdown tape is not subject to the logarithmic space bound).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 74,
      "context" : "The proof of LOGCFL-hardness is by reduction of the following problem: decide whether an input of length n is accepted by the nth circuit of a logspace-uniform family of SAC circuits, which is known to be LOGCFL-hard [75].",
      "startOffset" : 217,
      "endOffset" : 221
    }, {
      "referenceID" : 32,
      "context" : "This problem was used by [33] to show LOGCFLhardness of evaluating tree-shaped CQs.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 32,
      "context" : "Following [33], we assume without loss of generality that the considered SAC circuits adhere to the following normal form: – fan-in of all and-gates is 2; – nodes are assigned to levels, with gates on level i only receiving inputs from gates on level i− 1, the input gates on level 1 and the output gate on the greatest level; – the number of levels is odd, all even-level gates are or-gates, and all odd-level non-input gates are and-gates.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 32,
      "context" : "It is well known [33, 75] that a circuit in normal form accepts an input α iff there is a labelled rooted tree (called a proof tree) such that – the root node is labelled with the output and-gate; – if a node is labelled with an and-gate gi and gi = gj ∧ gk, then it has two children labelled with gj and gk, respectively; – if a node is labelled with an or-gate gi and gi = gj1 ∨ .",
      "startOffset" : 17,
      "endOffset" : 25
    }, {
      "referenceID" : 74,
      "context" : "It is well known [33, 75] that a circuit in normal form accepts an input α iff there is a labelled rooted tree (called a proof tree) such that – the root node is labelled with the output and-gate; – if a node is labelled with an and-gate gi and gi = gj ∧ gk, then it has two children labelled with gj and gk, respectively; – if a node is labelled with an or-gate gi and gi = gj1 ∨ .",
      "startOffset" : 17,
      "endOffset" : 25
    }, {
      "referenceID" : 32,
      "context" : "The reduction [33], which is for presentation purposes reproduced here with minor modifications, encodes C and α in the database and uses a Boolean tree-shaped CQ based on the skeleton proof tree.",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 32,
      "context" : "We point out that membership in LOGCFL implies that answering OMQs from the identified tractable classes can be ‘profitably parallelised’ (for details, consult [33]).",
      "startOffset" : 160,
      "endOffset" : 164
    }, {
      "referenceID" : 7,
      "context" : "In fact, much more work is required to construct NDL-rewritings that can be evaluated in LOGCFL and NL, which will be done in a follow-up publication; see technical report [8].",
      "startOffset" : 172,
      "endOffset" : 175
    }, {
      "referenceID" : 66,
      "context" : "As far as practical OBDA is concerned, our experience with the query answering engine Ontop [67, 53], which employs the tree-witness rewriting, shows that mappings and database constraints together with semantic query optimisation techniques can drastically reduce the size of rewritings and produce efficient SQL queries over the data.",
      "startOffset" : 92,
      "endOffset" : 100
    }, {
      "referenceID" : 52,
      "context" : "As far as practical OBDA is concerned, our experience with the query answering engine Ontop [67, 53], which employs the tree-witness rewriting, shows that mappings and database constraints together with semantic query optimisation techniques can drastically reduce the size of rewritings and produce efficient SQL queries over the data.",
      "startOffset" : 92,
      "endOffset" : 100
    }, {
      "referenceID" : 65,
      "context" : "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.",
      "startOffset" : 82,
      "endOffset" : 98
    }, {
      "referenceID" : 68,
      "context" : "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.",
      "startOffset" : 82,
      "endOffset" : 98
    }, {
      "referenceID" : 54,
      "context" : "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.",
      "startOffset" : 82,
      "endOffset" : 98
    }, {
      "referenceID" : 11,
      "context" : "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.",
      "startOffset" : 82,
      "endOffset" : 98
    }, {
      "referenceID" : 57,
      "context" : "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].",
      "startOffset" : 153,
      "endOffset" : 172
    }, {
      "referenceID" : 8,
      "context" : "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].",
      "startOffset" : 153,
      "endOffset" : 172
    }, {
      "referenceID" : 12,
      "context" : "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].",
      "startOffset" : 153,
      "endOffset" : 172
    }, {
      "referenceID" : 42,
      "context" : "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].",
      "startOffset" : 153,
      "endOffset" : 172
    }, {
      "referenceID" : 37,
      "context" : "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].",
      "startOffset" : 153,
      "endOffset" : 172
    }, {
      "referenceID" : 13,
      "context" : "Ideally, one would show that the simpler ontology is equivalent to the original with regards to query answering [14], and thus provides the exact set of answers.",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 24,
      "context" : "Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78]).",
      "startOffset" : 90,
      "endOffset" : 98
    }, {
      "referenceID" : 13,
      "context" : "Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78]).",
      "startOffset" : 90,
      "endOffset" : 98
    }, {
      "referenceID" : 77,
      "context" : "Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78]).",
      "startOffset" : 208,
      "endOffset" : 212
    }, {
      "referenceID" : 3,
      "context" : "Without loss of generality we may choose h so that the image of h consists of elements aw with |w| ≤ 2|T |+ |q| [4].",
      "startOffset" : 112,
      "endOffset" : 115
    }, {
      "referenceID" : 32,
      "context" : "Since C accepts input α iff there is a homomorphism h from q to D(α) [33], it suffices to show that there exists a homomorphism f from q′ to CTα,A iff there is a homomorphism h from q to D(α):",
      "startOffset" : 69,
      "endOffset" : 73
    } ],
    "year" : 2016,
    "abstractText" : "We give solutions to two fundamental computational problems in ontologybased data access with the W3C standard ontology language OWL2QL: the succinctness problem for first-order rewritings of ontology-mediated queries (OMQs), and the complexity problem for OMQ answering. We classify OMQs according to the shape of their conjunctive queries (treewidth, the number of leaves) and the existential depth of their ontologies. For each of these classes, we determine the combined complexity of OMQ answering, and whether all OMQs in the class have polynomial-size first-order, positive existential, and nonrecursive datalog rewritings. We obtain the succinctness results using hypergraph programs, a new computational model for Boolean functions, which makes it possible to connect the size of OMQ rewritings and circuit complexity.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}