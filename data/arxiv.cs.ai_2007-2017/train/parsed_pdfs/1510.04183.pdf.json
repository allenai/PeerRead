{
  "name" : "1510.04183.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "MATHEMATICAL FOUNDATIONS FOR DESIGNING AND DEVELOPMENT OF INTELLIGENT SYSTEMS OF INFORMATION ANALYSIS",
    "authors" : [ "D.O. Terletskyi", "O.I. Provotar", "Taras Shevchenko" ],
    "emails" : [ "dmytro.terletskyi@gmail.com,", "aprowata@unicyb.kiev.ua" ],
    "sections" : [ {
      "heading" : null,
      "text" : "UDC 510.2:004.8"
    }, {
      "heading" : "MATHEMATICAL FOUNDATIONS FOR DESIGNING AND DEVELOPMENT OF INTELLIGENT SYSTEMS OF INFORMATION ANALYSIS",
      "text" : ""
    }, {
      "heading" : "D.O. Terletskyi1, O.I. Provotar2",
      "text" : "Taras Shevchenko National University of Kyiv, Cybernetics Faculty\n03680, Kyiv, Academician Glushkov Avenu 4d,\ndmytro.terletskyi@gmail.com1, aprowata@unicyb.kiev.ua2\nThis article is an attempt to combine different ways of working with sets of objects and their classes for designing and development of artificial intelligent systems (AIS) of analysis information, using object-oriented programming (OOP). This paper contains analysis of basic concepts of OOP and their relation with set theory and artificial intelligence (AI). Process of sets and multisets creation from different sides, in particular mathematical set theory, OOP and AI is considered. Definition of object and its properties, homogeneous and inhomogeneous classes of objects, set of objects, multiset of objects and constructive methods of their creation and classification are proposed. In addition, necessity of some extension of existing OOP tools for the purpose of practical implementation AIS of analysis information, using proposed approach, is shown.\nДана стаття є спробою поєднати різні підходи до роботи з множинами об’єктів та їхніми класами задля проектування і розробки систем штучного інтелекту (СШІ) для аналізу інформації, використовуючи об’єктно-орієнтоване програмування (ООП). Робота містить аналіз базових концепцій ООП і їхній зв'язок з теорією множин та штучним інтелектом (ШІ). Розглядається процес створення множин та мультимножин з різних сторін, зокрема з огляду на математичну теорію множин, ООП та ШІ. Запропоновані визначення об’єкту та його властивостей, однорідного та неоднорідного класу об’єктів, множини об’єктів, мультимножини об’єктів і конструктивні методи їх створення та класифікації. Окрім того, показана необхідність в деякому розширенні засобів ООП з метою практичної реалізації СШІ для аналізу інформації, використовуючи запропонований підхід."
    }, {
      "heading" : "Introduction",
      "text" : "Modern programming includes many different paradigms, approaches, techniques and programming languages. Object-Oriented Programming (OOP) is one of the famous and useful programming paradigm nowadays. Indeed, according to [1-3] the most popular programming languages are such languages, which support OOP.\nAs we know, object and class are the main concepts of OOP. According to [4], objects are the building blocks of\nan object-oriented program. We associate these blocks with the objects of real world, during developing programs. Concerning classes, they are blueprints, which we use as the basis for objects building. Every object is defined by two terms: attributes and behaviors. Attributes are properties of object, which describe it, and behaviors are procedures, functions (methods) which we can apply to this object and change its state, form and so on. According to [5], real world is created by objects, and OOP is the approach for description and simulation of this world or some his particular parts.\nIt is obvious, if person can develop the programs, which operate with models of objects of real world, their\nclasses and so on, then this person precisely knows how to operate with them using his mind (intellect). Of course, sometimes people do this consciously, sometimes not, but it is important that they do this, and simple proof of this fact is that people have invented OOP. However, real world is very complicated, and consists of huge number of objects of different classes, that is why formalization of objects of real world into OOP objects and classes sometimes is nontrivial. Despite this, programming, in particular OOP, is developing day by day. People are finding more and more new practical applications for programming, and such area as Artificial Intelligence (AI) is not exception.\nModern AI includes many directions as knowledge representation, automated planning and scheduling, machine\nlearning, robotics, computer vision, artificial creativity, natural language processing, and so on. Nevertheless, all these directions have something common among themselves. One of the main targets for all these directions is development of intelligent information systems (IIS) or artificial intelligent systems (AIS) for solving particular practical problems in these areas. Also very important aspect of AIS is intellectual analysis of information, in particular in real world or in some its parts. Ideologically this is very close to process of development of object-oriented programs. However, software development which is just tool for solving particular tasks, management by some process, etc. is easier then development of software which has some level of individuality and intellectuality and can do something bigger than just some computations. That is why questions about usability of development AIS using OOP approach appear.\nNowadays very often development of AIS is reduced to heuristic programming [6]. The advantage is that such\napproach gives an opportunity to solve corresponding practical problems, but the disadvantage is that partial solution does not guarantees general solution of corresponding problems. However, every AIS is based on some model of knowledge representation (KR). Nowadays, there is a variety of them. The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational\nKnowledge Discovery [11] are known. Furthermore, there are a few hybrid models of KR, in particular Brooks’ Subsumption Architecture and Copycat [10].\nEach of these models has own specifics and is useful in the particular domain. However, during developing\ncertain AIS we need to implement a model of KR. Therefore, in this case, we have at least two levels of our AIS, first of them is a level of KR model and second one is a level of its practical implementation. In some cases, implementation of particular KR model can cause additional problems and difficulties. That is why, sometimes it leads to development of new programming paradigms and languages, which are invented for effective implementations of particular KR model. One of such examples is programming language PROLOG, which is logical programming language and it gives us opportunities for implementations of different Logical models of KR.\nOne of the main postulates of OOP is that objects create world. Development of OO-programs is formal\ndescription of objects from some world and relations between them, etc. That is why we can conclude that OOP can be one of the KR models, which represents (describes) knowledge about objects. Such model is very close to human perception of real world, because a person perceives real world by objects of this world. This fact gives us an opportunity to combine level of KR model and level of its practical implementation, during AIS development. In addition, a person also uses concept of class and set of objects in the process of thinking. Really, we use classes and sets in our mental activity during perception, analysis, comparison, retrieval, classification every day. We create classes and sets consciously or subconsciously, operate with them and apply a variety of operations to them. Moreover, set is the central concept in set theory and one of the most important for mathematics in general. However, questions about the origin of specific sets are emerging while analyzing the definition of this term, which is given in [15]. We can conclude that the “new” set can be obtained by set-theoretic operations over “existing” sets, analyzing the different systems of set theory [16, 17], and it is really so. However, the questions about origin of these so-called “existing” sets, their number, their types and so on do not disappear. Our target is development of AIS for intellectual analysis of information, based on operating with sets of objects and their classes, using OOP. However, primarily we need to understand specifics of classes’ and sets creation from different sides, i.e. sets in the set theory, sets and classes in OOP and in the process of human thinking."
    }, {
      "heading" : "Objects and Classes",
      "text" : "Objects. We know that each set consists of elements, which form it. Everything, phenomena of our imagination or of our world can be the elements of the set. It is convenient for us to call them objects. Let consider such object as “natural number”. It is clear that every natural number must be integer and positive. These are characteristic properties of natural numbers. It is obvious, that 11 is really a natural number, but −16 and 9.52, for example, are not natural numbers. We can conclude that each object has certain properties, which define it as some essence while analyzing this fact. Usually in OOP [4, 5], we can consider properties of objects separately from objects. Such form of consideration is very close to concept of object-oriented class (OO class). Actually, objects and their properties cannot exist separately, because if we assume the opposite, we will have contradiction. On the one hand, object cannot exists separately from its properties, because without properties we cannot imagine and cannot describe it. On the other hand, object's properties cannot exist separately from object, because without object we cannot see and cannot perceive them. That is why, we cannot consider them separately, and there are few variants of the definitions order. It means that we cannot introduce definition of object without definition of its properties and vice versa. Therefore, we decided to introduce concept of object's properties firstly.\nGlobally we can divide properties of objects into two types – quantitative and qualitative. We will define these\ntwo types of object's properties formally, but their semantics has intuitive nature.\nDefinition 1. Quantitative property of object A is a tuple )))(()),((()( ApuApvAp iii  , where ni ,1 ,\n))(( Apv i is an quantitative value of )(Api , and ))(( Apu i are units of measure of quantitative value of )(Api .\nLet us consider some examples of quantitative properties of objects. Suppose we have an apple, and one of its\nproperties is weight. We can present this property as follows )))(()),((()( ApplepuApplepvApplep weigthweigthweigth  ,\nand if our apple has the weight of 0.2 kg, then property )(Applepweight will be the following ),2.0()( kgApplepweight  .\nSuppose we have a phone number, and one of its properties is sequence of odd numbers, which it comprises. We can\npresent this property as follows )))(()),((()( rPhoneNumbepurPhoneNumbepvrPhoneNumbep oddnumoddnumoddnum  ,\nand if your phone number includes following odd numbers 3,7,5, then property )( rPhoneNumbepoddnum will be the\nfollowing )),5,7,3(()( numbersrPhoneNumbepoddnum  .\nDefinition 2. Two quantitative properties )(Api and )(Bp j , where ni ,1 , mj ,1 , are equivalent, i.e.\n1))(),(( BpApEq ji , if and only if ))(())(( BpuApu ji  .\nDefinition 3. Qualitative property of object A is a verification function )()( AvfAp ii  , ni ,1 which defines\nas a mapping ]1,0[)(:)( ApAvf ii .\nLet us consider some examples of qualitative properties of objects. Suppose we have an integer number n , and\none of its properties is positivity. We can present this property as follows )()( nvfnp positivitypositivity  , where )(nvf is\nverification function of property )(nppositivity . In this case, function }1,0{)(:)( npnvf positivitypositivity , and it is a\nparticular case of verification function – predicate or Boolean-valued function.\nLet us consider such object as car, and one of its properties is “high speed”. Suppose that maximum speed of this\ncar is 200 km /hour. In this case we cannot precisely conclude about )(carvfhighspeed , because “high speed” is fuzzy\nconcept [18]. There are many ways to define value of )(carvfhighspeed , and everything depends on definition of high\nspeed. For example if high speed is 150 km/hour, then we can conclude that 1)/150( hourkmvfhighspeed , and\n0)/0( hourkmvfhighspeed . Based on this and using proportion we can conclude that 5.0)/75( hourkmvfhighspeed .\nWe can conclude that, such approach gives an opportunity to combine description of property and its verification\nin the one function, i.e. verification function is a verification function and a description of property at the same time. Therefore, different algorithms can be verifiers and descriptors of property simultaneously.\nDefinition 4. Two qualitative properties )(Api and )(Bp j , where ni ,1 , mj ,1 , are equivalent, i.e.\n1))(),(( BvfAvfEq ji , if and only if ))()(())()(( BvfBvfAvfAvf jiji  .\nDefinition 5. Specification of object A is a vector ))(),...,(()( 1 ApApAP n , where )(Api , ni ,1 is\nquantitative or qualitative property of object A .\nDefinition 6. Dimension of object A is number of properties of object A , i.e. )()( APAD  .\nNow, we can formulate the definition of “object”.\nDefinition 7. Object is a pair )(/ APA , where A is object’s identifier and )(AP – specification of object.\nEssentially, object is a carrier of some properties, which define it as some essence.\nDefinition 8. Two objects 1A and 2A are similar, if and only if )()( 21 APAP  . Classes of Objects. In general, we can divide objects on concrete and abstract, and does not matter when or how\nsomeone created each particular object. It is material implementation of its abstract image – a prototype. This prototype is essentially an abstract specification for creation the future real objects. Besides properties of objects, we should allocate operations (methods) which we can apply to objects, considering the features of their specifications. Really, we can apply some operations (methods) to objects for their changing and for operating with them. That is why, it will be useful to define concept of object's operation (method).\nDefinition 9. Operation (method) of object A is a function )(Af , which we can apply to object A considering\nthe features of its specification.\nFor example, for such objects as natural numbers n , m we can define operations “+” and “*”.\nIn OOP [4, 5, 19, 20], programmers operate with specifications and methods of objects without objects, and they\ncall it a type or a class of object. It consists of fields and methods. Fields of class, essentially, are specification of class. Methods are functions, which we can apply to objects of this class for their changing and for operating with them. Concept of OO class is similar to universal algebra [21, 22], where carrier of algebra consists of objects and signature consists of methods of objects. That is why, henceforth sometimes we will use title signature of class for methods of class. Let us define concept of object's signature.\nDefinition 10. Signature of object A is a vector ))(),...,(()( 1 AfAfAF m , where )(Afi , mi ,1 is an\noperation (method) of object A .\nGenerally, signature of particular object can consist of different quantity of operations, but in practice, especially\nin programming, usually we are considering finite signatures of objects.\nAccording to definition of object, every object has some specification, which defines it as some essence. There\nare some objects, which have similar specifications. It means that we can apply the same methods to them. Let us define similar objects. Definition 11. Objects \uD835\uDC34 and \uD835\uDC35 are similar objects, if and only if, when they have the same dimension and equivalent specifications.\nIf certain two objects are similar, we can conclude that these objects have the same type or class. Now we can\nintroduce concept of object's class.\nDefinition 12. Object’s class T is a tuple ))(),(( TFTPT  , where )(TP is abstract specification of some\nquantity of objects, and )(TF is their signature.\nWhen we talk about class of objects, we mean properties of these objects and methods, which we can apply to\nthem. Class of objects is a generalized form of consideration of objects and operations on them, without these objects.\nAs an example, let us describe type Int in programming language C++, using concept of similar objects and\nobject’s class. Let us set the next specification for class Int\n))(),(()( 21 IntpIntpIntP  ,\nwhere property )(1 Intp means “integer number”, property )(2 Intp means “number not bigger then 2147336147 and\nnot smaller then −2147336148”. It is obvious, that all numbers which have properties )(1 Intp and )(2 Intp are objects of class Int . Let define the methods of class Int in the following way:\n))(),(()( 21 IntfIntfIntF  ,\nwhere \"\")(1 Intf and \"*\")(2 Intf .\nLet us define concept of homogeneous class of objects. Definition 13. Homogeneous class of objects T is a class of objects, which contains only similar objects. Considering concept of OO class, we can conclude that class is a prototype for particular objects, and all objects\nof class are described by class description. It means that every particular object of the class has the same specification and signature. That in turn, imposes some constraints on description of objects from real world. There are many different objects of real world, which belong to different classes, and if we need to work with them, we can describe them, using new class for each new type of objects. Especially, if we work with not very big quantity of different types of objects, we can do it without any fears. However, if we need to work with huge quantity of different types, for example, with a few thousands of different types, just a process of description of such types is very complex and timeconsuming not to mention size of code and performance of such programs.\nAccording to definitions of object and object’s class, we can conclude two points. Firstly, every object is a\nmember of at least one class of objects, and secondly, objects and their classes cannot exist separately. Furthermore,\nsome objects are members of few classes simultaneously. For example, such objects as natural numbers nnn ,...,1 are members of such classes as natural numbers, integer numbers, rational numbers and real numbers, i.e.\nRQZNnn n ,...,1 . As we can see, class R has the biggest cardinality in this case; furthermore, it consists of groups of objects of different types. It contradicts concept of OO class, because different objects from one OO class cannot have different specifications and signatures. That is why we cannot describe such class of objects using OO class.\nLet consider the class of real numbers R , and describe it by the following specification\n),...)(),...,(()( 51 RpRpRP  , where )(1 Rp is “integer number”, )(2 Rp is “natural number”, )(3 Rp is “fractional\nnumber”, )(4 Rp is “negative integer”, )(5 Rp is “even number”. Let consider following numbers 3, 2.75, −16, 4, −7.48. It is obvious that they are objects of different types, but all of them are objects of class R . However, if these\nobjects belong to class R , they must conform to the specification )(RP . Clearly that they do so, but in different ways\n(see Table 1).\nIt is obvious, that mathematically all these numbers 3, 2.75, −16, 4, −7.48 are objects of the class R , but, as we can see, we really cannot describe them using one OO class. Of course, real numbers implemented for many program languages as one of the primitive types of data, which we can use without any descriptions, because it is built-in. However, it is one of the examples of inhomogeneous class of objects.\nAs we can see, there are two different types of object classes, that is why, let us define concept of\ninhomogeneous class of objects.\nDefinition 14. Inhomogeneous class of objects T is a tuple ))(),...,(),(( 11 nn AprAprTCoreT  , where\n))(),(()( TFTPTCore  is the core of class T , which includes properties and methods similar to specifications\n)(),...,( 1 nAPAP and signatures )(),...,( 1 nAFAF respectively, and where ))(),(()( iiii AFAPApr  , ni ,1 are\nprojections of objects nAA ,...,1 , which consist of properties and methods typical only for these objects."
    }, {
      "heading" : "Universal Operation on Objects and Runtime Class Generation",
      "text" : "One of the most important aspects of OOP is an opportunity to work only with classes, which are described before program execution. Of course, some programs provide us with a possibility to work with new classes, which we can obtained using basic classes. However, we cannot obtain new classes, which are not inheritors of basic classes, during program execution. In modern programming, this process is known as runtime class generation (RCG) or runtime class creation (RCC). Nowadays, there are some approaches for implementation of this task for some OOPlanguages, in particular for Java [24] and C# [25]. These tools based on manipulating with bytecode and implemented\nfor such platforms of programming as Java and .NET. However, now we will not discuss practical implementations of RCG for concrete platforms of programming, but will focus on specifics of this process.\nIt is known, that logic of program provides access and work with some classes of objects, during program\nexecution, depending on particular program scenario. Moreover, it can provide RCG, based on some constructors of classes. According to this, we will propose some constructors of classes, defining some universal operations on objects.\nAs it was mentioned before, in OOP, objects have methods. Usually they are functions, which we can execute\nfor these objects. We can divide methods of objects on two types, depending on character of their action. They are modifiers and exploiters. Modifiers are functions, which can change objects, in particular some fields of objects. Exploiters are functions, which use objects as arguments and cannot change them. However, majority of methods of objects are local with respect to objects, and cannot be applied to objects of different types. Of course, there are some methods, which we can apply to objects of different types, but usually we need to use overloading operator for this. Nevertheless, we will define some universal operations for objects, which can be applied to any objects. Let us do it using the concept of object and object’s class.\nDefinition 15. Union  of 2n arbitrary objects is a new set of objects S , which obtain in the following\nway )(/},...,{)(/...)(/ 111 STAAATAATAS nnn  , where nAA ,...,1 are objects, such that ji AA , , where\nnji ,1,  and ji  , 0),( ji AAEq , )( iAT , ni ,1 is a class of object iA and )(ST is a class of new set of objects S\nand n is its cardinality.\nLet us consider such geometrical objects as triangle, square and trapeze. It is obvious that these objects belong to\ndifferent classes of geometrical figures. Let us denote triangle as A , square as B , trapeze as C , and describe their\nclasses as follows ))(),...,(()( 41 ApApAP  , ))(),...,(()( 31 BpBpBP  , ))(),...,(()( 41 CpCpCP  ,\n))(),(()( 21 AfAfAF  , ))(),(()( 21 BfBfBF  and ))(),(()( 21 CfCfCF  . Properties )(1 Ap , )(1 Bp , )(1 Cp are\nquantities of sides of figures, properties )(2 Ap , )(2 Bp , )(2 Cp , are sizes of sides of figures, properties )(3 Ap ,\n)(3 Bp , are sizes of angles of figures, property )(4 Ap is triangle inequality and property )(4 Cp is parallelism of two\nsides of figure. Methods )(1 Af , )(1 Bf , )(1 Cf are functions of perimeter calculation of figures, and methods )(2 Af ,\n)(2 Bf , )(2 Cf are functions of area calculation of figures. Of course, specifications and signatures of these objects can\ninclude more properties and methods, than we presented in this example, everything depends on level of detail.\nLet us apply the union operation to these objects and create new set of objects.\n)(/},,{ STCBACBAS \nWe have obtained new set of objects S and new class of objects ))(),(),(),(()( 321 CprBprAprSCoreST  , where\n))(),(),(),(()( 1321 SfSpSpSpSCore  , property )(1 Sp is quantity of sides of figures, property )(2 Sp means sizes of\nsides of figures, )(3 Sp are sizes of angles of figures, method )(1 Sf is a function of perimeter calculation of figures,\n))(),(()( 241 AfApApr  , ))(()( 22 BfBpr  , ))(),(()( 243 CfCpCpr  . Essentially, set of objects S is the set of triangles of class )(AT , squares of class )(BT and trapezes of class )(CT . Concerning class of objects )(ST , it\ndescribes three types of geometrical figures )(AT , )(BT and )(CT .\nDefinition 16. Intersection  of two arbitrary objects 1A and 2A is a class of objects ))(),(()( AFAPAT  ,\nwhere 1))(),((|)()( 211 211  ApApEqApAP iii and 1))(),((|)()( 211 211  AfAfEqAfAF iii . Intersection of two arbitrary objects 1A and 2A does not exist, if and only if 0))(),(( 21 21 ApApEq ii for all 1i and 2i .\nLet us calculate intersection of triangle A and square B , which were described above.\n)( BATBA \nAs the result we have obtained new class of objects )( BAT  , which does not contain any projections of objects, i.e.\n)()( BACoreBAT  , where ))(),(),(),(()( 1321 BAfBApBApBApBACore  , property )(1 BAp  is\nquantity of sides of figure, property )(2 BAp  means sizes of sides of figure, )(3 BAp  are sizes of angles of figure,\n)(1 BAf  is a function of perimeter calculation of figure. As we can see, class )( BAT  is a class of objects, which describes some type of geometrical figures. However, we do not know exactly which type, even considering its specification and signature, because many of geometric figures have sides and angles. Nevertheless, it is a new type of objects, which we have obtained from intersection of two objects, which describe two determined types of geometric figures.\nDefinition 17. The difference \\ of two arbitrary objects 1A and 2A is a class of objects ))(),(()( AFAPAT  ,\nwhere 0))(),((|)()( 211 211  ApApEqApAP iii and 0))(),((|)()( 211 211  AfAfEqAfAF iii . Difference of two arbitrary objects 1A and 2A does not exist, if and only if 1))(),(( 21 21 ApApEq ii for all 1i and 2i .\nLet us calculate difference of triangle A and trapeze C , which were described above.\n)\\(\\ CATCA \nAs the result, we have obtained new class of objects )\\( CAT , which does not contain core, i.e. )\\()\\( 1 CAprCAT  ,\nwhere ))(),(()\\( 241 AfApCApr  . As in the case of intersection, we have obtained new class of objects, which describes some type of geometric figures, however, unlike the previous case we can say that this new type of geometric figures is a triangle, although it is described using smaller specification.\nDefinition 18. The symmetrical difference  of two arbitrary objects 1A and 2A is a class of objects\n))(),(()( AFAPAT  , where\n0))(),((|))(),(()( 2121 2121  ApApEqApApAP iiii , 0))(),((|))(),(()( 2121 2121  AfAfEqAfAfAF iiii .\nSymmetrical difference of two arbitrary objects 1A and 2A does not exist, if and only if 1))(),(( 21 21 ApApEq ii for all\n1i and 2i .\nLet us calculate symmetrical difference using the same figures, i.e. triangle A and trapeze C .\n)( CATCA \nAs the result, we have obtained new class of objects )( CAT  , which like the previous case, does not contain core, i.e.\n))(),(()( 21 CAprCAprCAT  , where ))(),(()( 241 AfApCApr  and ))(),(()( 242 CfCpCApr  . As in the case of difference, we have obtained new class of objects, which describes a type of geometric figures, however, as in the case of intersection, we do not know exactly which type of geometrical figures this class describes. Nevertheless, we can say that this class describes two types of geometrical figures, and one of them is triangle.\nDefinition 19. Clone of the arbitrary object A is an object )(/ APAA ii  , where )(AP is specification of\nobject A and i is a number of its clone.\nThis operation is similar to concept of copy constructor in C++ [8], and is an example of constructor of objects. As we can see, the majority of operations on objects that defined above are similar to set-theoretic operations in\nclassical set theory [23]. However, in contrast to them, operations on objects give us opportunities to create sets and classes of objects."
    }, {
      "heading" : "Sets of Objects and Inhomogeneous Classes",
      "text" : "Sets of Objects. There are a few ways to create set of objects. Firstly, we can obtain a set of objects using union operation to not less than two arbitrary objects. Secondly, we can do it using set-theoretic operations over sets of objects. Eventually, we can obtain a set of objects combining these two approaches, namely to use union operation to not less than two arbitrary objects and not less than one arbitrary set of objects. Let us define concept of set of objects, using these ideas, concepts of object and class of objects.\nDefinition 20. The set of objects S is a union, which satisfies one of the following schemes:\n);(/......)3\n);(/...)2\n);(/...)1\n11\n1\n1\nSTSSSOOS\nSTSSSS\nSTSOOS\nmn\nm\nn\n\n\n\nwhere nOO ,...,1 are arbitrary objects, mSS ,...,1 are arbitrary sets of objects, and )(ST is a class of new set of objects\nS .\nWe have defined union operation for scheme 1S , now let us do this for schemes 2S and 3S . As we know,\nscheme 2S is defined in classical set theory, and this operation is known as a union of sets [23]. However, that\ndefinition does not consider concept of class of objects, that is why we need to redefine this operation.\nDefinition 21. Union  of 2m arbitrary sets of objects is a new set of objects S , which obtains in the\nfollowing way )(/},...,{)(/...)(/ 111 STAASTSSTSS nmm  , where nAA ,...,1 , are such objects that ji AA , ,\nwhere nji ,1,  and ji  , 0),( ji AAEq , )( iST , mi ,1 is a class of set of object iS and )(ST is a class of new set\nof objects S and n is its cardinality.\nLet us consider two sets of objects },{1 BAS  , },{2 CAS  which consist of triangle A , square B and trapeze\nC , which were described above, and calculate their union.\n)(/},,{)(/},{)(/},{)(/)(/ 212211 STCBASTCASTBASTSSTSS \nAs we can see, we have obtained the same result, as in the case of union of objects A , B and C , which we considered before.\nNow, let us define union operations for scheme 3S .\nDefinition 22. Union  of 1n arbitrary objects and 1m arbitrary sets of objects is a new set of objects S ,\nwhich obtains in the following way\n)(/},...,{)(/...)(//...)(/ 11111 STAASTSSTSTAATAS kmmnn  ,\nwhere kAA ,...,1 , are such objects that ji AA , , where kji ,1,  and ji  , 0),( ji AAEq , )( pAT , np ,1 is a class\nof object pA , )( wST , mw ,1 is a class of set of object wS and )(ST is a class of new set of objects S and k is its\ncardinality.\nLet us consider objects A , B , C , and sets of objects 1S , 2S , which we used in the previous example, and\ncalculate their union.\n )(/)(/)(/)(/)(/ 2211 STSSTSCTCBTBATAS\n)(/},,{)(/},{)(/},{)(/)(/)(/ 21 STCBASTCASTBACTCBTBATA \nMultisets of Objects. As we know, a multiset is a generalization of the notion of set in which members are\nallowed to appear more than once [29-31]. Formally multiset can be defined as a 2-tuple ),( mA , where A is the set,\nand m is the function that puts a natural number in accordance to each element of the set A , which is called the multiplicity of the element, i.e. NAm : . However, this definition does not explain how to create the multiset of\nobjects that is why we are going to define multiset of objects using concept of set of objects.\nDefinition 23. The multiset of objects is a set of objects },...,{ 1 nAAS  , that ji AA , , nji ,1,  and ji  ,\n1),( ji AAEq .\nWe can obtain multiset of objects in the same way as set of objects. The example will be shown, using objects\nand sets of objects, which were mentioned previously.\nUnion of objects.\n)(/},,,,,{)(/)(/)(/)(/)(/)(/ STCCCBAACTCCTCCTCBTBATAATAS \nUnion of sets of objects.\n)(/},,,{)(/},{)(/},{)(/)(/ 212211 STCBAASTCASTBASTSSTSS \nUnion of objects and sets of objects.\n)(/},,,{)(/},{)(/)(/)(/)(/)(/ 111 STCBAASTBACTCATASTSCTCATAS \nAs we can see, creation of sets and multisets of objects entails creation of new classes of objects, in particular\ninhomogeneous, that causes some problems related to description of such classes in OOP. At first glance it may seems, that there is no necessity to work with such classes, and we can use just concept of homogeneous class, that implemented within OOP. However, if we analyze some aspects of human mind, especially mechanisms of its thinking and analysis, we can conclude that concept of set of objects is one of the basic and very important concepts for them. Really, let us consider situation, when you need to find some book among big amount of different books, which lying on the shelves of bookcase. If you know how exactly this book looks, you can imagine this book and you can distinguish it from other books in this bookcase. Finally, during searching for this book, you perform certain exhaustive search, and at the same time, you create set of books, which you have checked. Let us imagine another situation, when you need to count money, which you have in your wallet. During counting, you create at least two sets, set of banknotes and set of coins. In addition, we can consider situation when you want to play chess, and after opening the box with chess, you need to make initial arrangement of figures on the chessboard. During figures placement, you create set of white and set of black figures from set of all figures. These are just a few simple examples from our daily activity. Very often in such situations and similar to them we operate with sets of objects subconsciously, and as the result, we pay little attention to this, but it is happening permanently. That is why we can conclude that creation of sets and classes of objects is normal activity of our mind, and if we want to simulate and reproduce this process, using computer system, we need to have certain opportunities to work with sets of objects and inhomogeneous classes of objects. It means we need appropriate tools within certain OOP-language for working with such abstractions.\nNowadays, there are a few different implementations of tools for working with sets within some OOP-languages,\nin particular set in STL for C++ [26], HashSet in Java [20], HashSet, SortedSet and ISet in C# [27], set and frozenset in Python [28]. These tools allow sets creation, executing set-theoretic operations, membership checking, adding and removing of elements and checking of equivalence between sets, etc. However, we have not opportunities for working with classes of sets and multisets, and this is one of disadvantages of modern OOP."
    }, {
      "heading" : "Conclusions",
      "text" : "In this paper we analyzed such basic concepts of OOP as object and class and their relation with set theory and AI. According to this, definitions of object and its properties, homogeneous and inhomogeneous classes of objects were proposed. We defined such operations on objects as union, intersection, difference, symmetric difference and cloning. Besides, we considered process of runtime class generation and showed that intersection, difference, symmetric difference of objects are examples of classes’ generators.\nProcess of sets and multisets creation was considered in details from different sides, in particular mathematical\nset theory, OOP and AI. After that, constructive definition of set of objects, multiset of objects and methods of their creation were proposed. Relation between sets of objects and classes of objects was also shown. The proposed approach allows not only to create (generate) sets and multisets of objects, but also to classify them. It also allows considering the problem of object classification and identification in another way.\nBesides, we showed that, we could not operate with inhomogeneous classes of objects, classes of sets and\nmultisets of objects using existing OOP tools. In addition, we cannot create new classes of object using operations on objects, in particular in runtime. After all, we can conclude that we need some OOP extension for the purpose of design and developing AIS using proposed approach."
    } ],
    "references" : [ {
      "title" : "The Object-Oriented Thought Process",
      "author" : [ "M. Weisfeld" ],
      "venue" : "Third Edition. Addison-Wesley Professional,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "OOP – Learn Object Oriented Thinking and Programming",
      "author" : [ "R. Pecinovský" ],
      "venue" : "Tomáš Bruckner, Řepín-Živonín,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Artificial intelligence: The Heuristic Programming Approach",
      "author" : [ "J.R. Slagle" ],
      "venue" : "McGRAW-HILL Book Company,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1971
    }, {
      "title" : "Artificial intelligence illuminated",
      "author" : [ "B. Coppin" ],
      "venue" : "Jones and Bartlett Publishers, Inc.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Artificial Intelligence and Soft Computing",
      "author" : [ "A. Konar" ],
      "venue" : "Behavioral and Cognitive Modeling of the Human Brain. CRC Press LLC,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Encyclopedia of Artificial Intelligence",
      "author" : [ "J.R. Rabunal", "J. Dorado", "A. Pazos" ],
      "venue" : "Information Science Reference,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Artificial Intelligence",
      "author" : [ "G. F Luger" ],
      "venue" : "Structures and Strategies for Complex Problem Solving: 6-th edition. Addison-Wesley,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Artificial Intelligence: A Systems Approach",
      "author" : [ "M.T. Jones" ],
      "venue" : "Infinity Science Press LLC,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Universal Artificial Intelligence and Expert Systems",
      "author" : [ "V.N. Ruchkin", "V.A. Fulin" ],
      "venue" : "St. Petersburg: \"BHV-Petersburg\",",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2009
    }, {
      "title" : "Essentials of artificial intelligence",
      "author" : [ "M. Ginsberg" ],
      "venue" : "Morgan Kaufmann Publishers, Inc.,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Contributions to the Founding of the Theory of Transfinite Numbers",
      "author" : [ "G. Cantor" ],
      "venue" : "New York: Dover Publications, Inc.,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1915
    }, {
      "title" : "Les Systemes Axiomatiques de la Theorie des Ensembles",
      "author" : [ "H. Wang", "R.M. Naughton" ],
      "venue" : "Paris: Gauthier-Villars,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1953
    }, {
      "title" : "Mathematics in the alternative set theory",
      "author" : [ "P. Vopenka" ],
      "venue" : "Leipzig: BSB B.G. Teubner,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "Fuzzy sets",
      "author" : [ "L.A. Zadeh" ],
      "venue" : "Information and control. N 8,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1965
    }, {
      "title" : "The C++ Programming Language: Special Edition",
      "author" : [ "B. Stroustrup" ],
      "venue" : "Addison-Wesley Professional,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Thinking in Java: 4-th Edition",
      "author" : [ "B. Eckel" ],
      "venue" : "Prentice Hall,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Lectures on general algebra: Second Edition",
      "author" : [ "A.G. Kurosh" ],
      "venue" : "Moscow: Nauka,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1973
    }, {
      "title" : "Algebraic Aspects of Information Technology",
      "author" : [ "I.V. Serhienko", "S.L. Kryvyi", "O.I. Provotar" ],
      "venue" : "Kyiv: Naukova Dumka,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2011
    }, {
      "title" : "Sets, Logic and Axiomatic Theories: 2-nd edition",
      "author" : [ "R.R. Stoll" ],
      "venue" : "W.H. Freeman & Co Ltd.",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 1975
    }, {
      "title" : "STL Tutorial and Reference Guide: 2-nd edition",
      "author" : [ "D.R. Musser", "G.J. Derge", "A. Saini" ],
      "venue" : "C++ Programming with the Standard Template Library, Addison-Wesley Professional,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "NET 4.0 Generics: Beginner’s Guide",
      "author" : [ "S. Mukherjee" ],
      "venue" : "Packt Publishing Ltd",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2012
    }, {
      "title" : "Programming in Python 3",
      "author" : [ "M. Summerfield" ],
      "venue" : "A Complete Introduction to the Python Language: 2-nd edition. Pearson Education, Inc.",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Denumerations of rooted trees and multisets",
      "author" : [ "N.D. Bruijn" ],
      "venue" : "Discrete Applied Mathematics, vol. 6, no. 1, pp. 25-33,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1983
    }, {
      "title" : "Mathematics of multisets, in Proceedings of the Workshop on Multiset Processing: Multiset Processing, Mathematical, Computer Science, and Molecular Computing Points of View”, p",
      "author" : [ "A. Syropoulos" ],
      "venue" : "347-358, Springer-Verlag Berlin Heidelberg,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Spaces of sets and multisets",
      "author" : [ "A. Petrovskyi" ],
      "venue" : "M.: Editorial URSS,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "According to [4], objects are the building blocks of an object-oriented program.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 1,
      "context" : "According to [5], real world is created by objects, and OOP is the approach for description and simulation of this world or some his particular parts.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 2,
      "context" : "Nowadays very often development of AIS is reduced to heuristic programming [6].",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 3,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 4,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 5,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 6,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 7,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 8,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 5,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 79,
      "endOffset" : 85
    }, {
      "referenceID" : 6,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 79,
      "endOffset" : 85
    }, {
      "referenceID" : 7,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 79,
      "endOffset" : 85
    }, {
      "referenceID" : 8,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 79,
      "endOffset" : 85
    }, {
      "referenceID" : 9,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 79,
      "endOffset" : 85
    }, {
      "referenceID" : 4,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 99,
      "endOffset" : 105
    }, {
      "referenceID" : 5,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 99,
      "endOffset" : 105
    }, {
      "referenceID" : 6,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 99,
      "endOffset" : 105
    }, {
      "referenceID" : 4,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 129,
      "endOffset" : 136
    }, {
      "referenceID" : 6,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 129,
      "endOffset" : 136
    }, {
      "referenceID" : 3,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 166,
      "endOffset" : 169
    }, {
      "referenceID" : 4,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 182,
      "endOffset" : 185
    }, {
      "referenceID" : 5,
      "context" : "The most famous and common are Semantic Nets, Frames [7-13] and Logical Models [9-14] also Scripts [8-10], Conceptual Dependency [8, 10], Search Spaces, Search Trees [7], Petri Nets [8], K-Lines, Memory Organization Packets [9], Semantic WEB, Computational",
      "startOffset" : 224,
      "endOffset" : 227
    }, {
      "referenceID" : 7,
      "context" : "234 Knowledge Discovery [11] are known.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 6,
      "context" : "Furthermore, there are a few hybrid models of KR, in particular Brooks’ Subsumption Architecture and Copycat [10].",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 10,
      "context" : "However, questions about the origin of specific sets are emerging while analyzing the definition of this term, which is given in [15].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 11,
      "context" : "We can conclude that the “new” set can be obtained by set-theoretic operations over “existing” sets, analyzing the different systems of set theory [16, 17], and it is really so.",
      "startOffset" : 147,
      "endOffset" : 155
    }, {
      "referenceID" : 12,
      "context" : "We can conclude that the “new” set can be obtained by set-theoretic operations over “existing” sets, analyzing the different systems of set theory [16, 17], and it is really so.",
      "startOffset" : 147,
      "endOffset" : 155
    }, {
      "referenceID" : 0,
      "context" : "Usually in OOP [4, 5], we can consider properties of objects separately from objects.",
      "startOffset" : 15,
      "endOffset" : 21
    }, {
      "referenceID" : 1,
      "context" : "Usually in OOP [4, 5], we can consider properties of objects separately from objects.",
      "startOffset" : 15,
      "endOffset" : 21
    }, {
      "referenceID" : 13,
      "context" : "concept [18].",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 0,
      "context" : "In OOP [4, 5, 19, 20], programmers operate with specifications and methods of objects without objects, and they call it a type or a class of object.",
      "startOffset" : 7,
      "endOffset" : 21
    }, {
      "referenceID" : 1,
      "context" : "In OOP [4, 5, 19, 20], programmers operate with specifications and methods of objects without objects, and they call it a type or a class of object.",
      "startOffset" : 7,
      "endOffset" : 21
    }, {
      "referenceID" : 14,
      "context" : "In OOP [4, 5, 19, 20], programmers operate with specifications and methods of objects without objects, and they call it a type or a class of object.",
      "startOffset" : 7,
      "endOffset" : 21
    }, {
      "referenceID" : 15,
      "context" : "In OOP [4, 5, 19, 20], programmers operate with specifications and methods of objects without objects, and they call it a type or a class of object.",
      "startOffset" : 7,
      "endOffset" : 21
    }, {
      "referenceID" : 16,
      "context" : "Concept of OO class is similar to universal algebra [21, 22], where carrier of algebra consists of objects and signature consists of methods of objects.",
      "startOffset" : 52,
      "endOffset" : 60
    }, {
      "referenceID" : 17,
      "context" : "Concept of OO class is similar to universal algebra [21, 22], where carrier of algebra consists of objects and signature consists of methods of objects.",
      "startOffset" : 52,
      "endOffset" : 60
    }, {
      "referenceID" : 4,
      "context" : "This operation is similar to concept of copy constructor in C++ [8], and is an example of constructor of objects.",
      "startOffset" : 64,
      "endOffset" : 67
    }, {
      "referenceID" : 18,
      "context" : "As we can see, the majority of operations on objects that defined above are similar to set-theoretic operations in classical set theory [23].",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 18,
      "context" : "As we know, scheme 2 S is defined in classical set theory, and this operation is known as a union of sets [23].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 22,
      "context" : "As we know, a multiset is a generalization of the notion of set in which members are allowed to appear more than once [29-31].",
      "startOffset" : 118,
      "endOffset" : 125
    }, {
      "referenceID" : 23,
      "context" : "As we know, a multiset is a generalization of the notion of set in which members are allowed to appear more than once [29-31].",
      "startOffset" : 118,
      "endOffset" : 125
    }, {
      "referenceID" : 24,
      "context" : "As we know, a multiset is a generalization of the notion of set in which members are allowed to appear more than once [29-31].",
      "startOffset" : 118,
      "endOffset" : 125
    }, {
      "referenceID" : 19,
      "context" : "Nowadays, there are a few different implementations of tools for working with sets within some OOP-languages, in particular set in STL for C++ [26], HashSet in Java [20], HashSet, SortedSet and ISet in C# [27], set and frozenset in Python [28].",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 15,
      "context" : "Nowadays, there are a few different implementations of tools for working with sets within some OOP-languages, in particular set in STL for C++ [26], HashSet in Java [20], HashSet, SortedSet and ISet in C# [27], set and frozenset in Python [28].",
      "startOffset" : 165,
      "endOffset" : 169
    }, {
      "referenceID" : 20,
      "context" : "Nowadays, there are a few different implementations of tools for working with sets within some OOP-languages, in particular set in STL for C++ [26], HashSet in Java [20], HashSet, SortedSet and ISet in C# [27], set and frozenset in Python [28].",
      "startOffset" : 205,
      "endOffset" : 209
    }, {
      "referenceID" : 21,
      "context" : "Nowadays, there are a few different implementations of tools for working with sets within some OOP-languages, in particular set in STL for C++ [26], HashSet in Java [20], HashSet, SortedSet and ISet in C# [27], set and frozenset in Python [28].",
      "startOffset" : 239,
      "endOffset" : 243
    } ],
    "year" : 2015,
    "abstractText" : "This article is an attempt to combine different ways of working with sets of objects and their classes for designing and development of artificial intelligent systems (AIS) of analysis information, using object-oriented programming (OOP). This paper contains analysis of basic concepts of OOP and their relation with set theory and artificial intelligence (AI). Process of sets and multisets creation from different sides, in particular mathematical set theory, OOP and AI is considered. Definition of object and its properties, homogeneous and inhomogeneous classes of objects, set of objects, multiset of objects and constructive methods of their creation and classification are proposed. In addition, necessity of some extension of existing OOP tools for the purpose of practical implementation AIS of analysis information, using proposed approach, is shown.",
    "creator" : "Microsoft® Word 2013"
  }
}