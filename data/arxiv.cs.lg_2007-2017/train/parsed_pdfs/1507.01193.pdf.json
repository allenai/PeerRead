{
  "name" : "1507.01193.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Dependency Recurrent Neural Language Models for Sentence Completion",
    "authors" : [ "Piotr Mirowski", "Andreas Vlachos" ],
    "emails" : [ "piotr.mirowski@computer.org", "a.vlachos@cs.ucl.ac.uk" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Language Models (LM) are commonly used to score a sequence of tokens according to its probability of occurring in natural language. They are an essential building block in a variety of applications such as machine translation, speech recognition and grammatical error correction. The standard way of evaluating a language model has been to calculate its perplexity on a large corpus. However, this evaluation assumes the output of the language model to be probabilistic and it has been observed that perplexity does not always correlate with the downstream task performance.\nFor these reasons, Zweig and Burges (2012) proposed the Sentence Completion Challenge, in which the task is to pick the correct word to complete a sentence out of five candidates. Performance is evaluated by accuracy (how many sentences were completed correctly), thus both probabilistic and non-probabilistic models (e.g. Roark\net al. (2007)) can be compared. Recent approaches for this task include both neural and count-based language models (Zweig et al., 2012; Gubbins and Vlachos, 2013; Mnih and Kavukcuoglu, 2013; Mikolov et al., 2013).\nMost neural language models consider the tokens in a sentence in the order they appear, and the hidden state representation of the network is typically reset at the beginning of each sentence. In this work we propose a novel neural language model that learns a recurrent neural network (RNN) (Mikolov et al., 2010) on top of the syntactic dependency parse of a sentence. Syntactic dependencies bring relevant contexts closer to the word being predicted, thus enhancing performance as shown by Gubbins and Vlachos (2013) for count-based language models. Our Dependency RNN model is published simultaneously with another model, introduced in Tai et al. (2015), who extend the Long-Short Term Memory (LSTM) architecture to tree-structured network topologies and evaluate it at sentence-level sentiment classification and semantic relatedness tasks, but not as a language model.\nAdapting the RNN to use the syntactic dependency structure required to reset and run the network on all the paths in the dependency parse tree of a given sentence, while maintaining a count of how often each token appears in those paths. Furthermore, we explain how we can incorporate the dependency labels as features.\nOur results show that the dependency RNN language model proposed outperforms the RNN proposed by Mikolov et al. (2011) by about 10 points in accuracy. Furthermore, it improves upon the count-based dependency language model of Gubbins and Vlachos (2013), while achieving slightly worse than the recent state-of-the-art results by Mnih and Kavukcuoglu (2013). Finally, we make the code and preprocessed data available to facilitate comparisons with future work.\nar X\niv :1\n50 7.\n01 19\n3v 1\n[ cs\n.C L\n] 5\nJ ul\n2 01\n5"
    }, {
      "heading" : "2 Dependency Recurrent Neural Network",
      "text" : "Count-based language models operate by assigning probabilities to sentences by factorizing their likelihood into n-grams. Neural language models further embed each word w(t) into a lowdimensional vector representation (denoted by s(t)) 1.\nThese word representations are learned as the language model is trained (Bengio et al., 2003) and enable to define a word in relation to other words in a metric space.\nRecurrent Neural Network Mikolov et al. (2010) suggested the use of Recurrent Neural Networks (RNN) to model long-range dependencies between words as they are not restricted to a fixed context length, like the feedforward neural network (Bengio et al., 2003). The hidden representation s(t) for the word in position t of the sentence in the RNN follows a first order auto-regressive dynamic (Eq. 1), where W is the matrix connecting the hidden representation of the previous word s(t− 1) to the current one, w(t) is the one-hot index of the current word (in a vocabulary of size N words) and U is the matrix containing the embeddings for all the words in the vocabulary:\ns(t) = f (Ws(t− 1) +Uw(t)) (1)\nThe nonlinearity f is typically the logistic sigmoid function f(x) = 11+exp(−x) . At each time step, the RNN generates the word probability vector y(t) for the next word w(t+ 1), using the output word embedding matrix V and the softmax nonlinearity g(xi) =\nexp(xi)∑ i exp(xi) :\ny(t) = g (Vs(t)) (2)\nRNN with Maximum Entropy Model Mikolov et al. (2011) combined RNNs with a maximum entropy model, essentially adding a matrix that directly connects the input words’ n-gram context w(t − n + 1, . . . , t) to the output word probabilities. In practice, because of the large vocabulary size N , designing such a matrix is computationally prohibitive. Instead, a hash-based implementation is used, where the word context is fed\n1In our notation, we make a distinction between the word token w(t) at position t in the sentence and its one-hot vector representation w(t). We note wi the i-th word token on a breadth-first traversal of a dependency parse tree.\nthrough a hash function h that computes the index h(w(t − n + 1, . . . , t)) of the context words in a one-dimensional array d of size D (typically, D = 109). Array d is trained in the same way as the rest of the RNN model and contributes to the output word probabilities:\ny(t) = g ( Vs(t) + dh(w(t−n+1,...,t)) ) (3)\nAs we show in our experiments, this additional matrix is crucial to a good performance on word completion tasks.\nTraining RNNs RNNs are trained using maximum likelihood through gradient-based optimization, such as Stochastic Gradient Descent (SGD) with an annealed learning rate λ. The BackPropagation Through Time (BPTT) variant of SGD enables to sum-up gradients from consecutive time steps before updating the parameters of the RNN and to handle the long-range temporal dependencies in the hidden s and output y sequences. The loss function is the cross-entropy between the generated word distribution y(t) and the target one-hot word distribution w(t+ 1), and involves the log-likelihood terms log yw(t+1)(t).\nFor speed-up, the estimation of the output word probabilities is done using hierarchical softmax outputs, i.e., class-based factorization (Mikolov and Zweig, 2012). Each word wi is assigned to a class ci and the corresponding log-likelihood is effectively log ywi(t) = log yci(t) + log ywj (t), where j is the index of word wi among words belonging to class ci. In our experiments, we binned the words found in our training corpus into 250 classes according to frequency, roughly corresponding to the square root of the vocabulary size.\nDependency RNN RNNs are designed to process sequential data by iteratively presenting them with word w(t) and generating next word’s probability distribution y(t) at each time step. They can be reset at the beginning of a sentence by setting all the values of hidden vector s(t) to zero.\nDependency parsing (Nivre, 2005) generates, for each sentence (which we note {w(t)}Tt=0), a parse tree with a single root, many leaves and an unique path (also called unroll) from the root to each leaf, as illustrated on Figure 1. We now note {wi}i the set of word tokens appearing in the parse tree of a sentence. The order in the notation derives from the breadth-first traversal of that tree\n1\n(i.e., the root word is noted w0). Each of the unrolls can be seen as a different sequence of words {wi}, starting from the single rootw0, that are visited when one takes a specific path on the parse tree. We propose a simple transformation to the RNN algorithm so that it can process dependency parse trees. The RNN is reset and independently run on each such unroll. As detailed in the next paragraph, when evaluating the log-probability of the sentence, a word token wi can appear in multiple unrolls but its log-likelihood is counted only once. During training, and to avoid over-training the network on word tokens that appear in more than one unroll (words near the root appear in more unrolls than those nearer the leaves), each word token wi is given a weight discount αi = 1ni , based on the number ni of unrolls the token appears in. Since the RNN is optimized using SGD and updated at every time-step, the contribution of word token wi can be discounted by multiplying the learning rate by the discount factor: αiλ.\nSentence Probability in Dependency RNN Given a word wi, let us define the ancestor sequence A(wi) to be the subsequence of words, taken as a subset from {wk}i−1k=0 and describing the path from the root node w0 to the parent of wi. For example, in Figure 1, the ancestors A(very) of word token very are saw, binoculars and strong. Assuming that each word wi is conditionally independent of the words outside of its ancestor sequence, given its ancestor sequence A(wi), Gubbins and Vlachos (2013) showed that the probability of a sentence (i.e., the probability of a lexicalized tree ST given an unlexicalized tree T ) could be written as:\nP [ST |T ] = |S|∏ i=1 P [wi|A(wi)] (4)\nThis means that the conditional likelihood of a word given its ancestors needs to be counted only once in the calculation of the sentence likelihood, even though each word can appear in multiple unrolls. When modeling a sentence using an RNN,\nthe state sj that is used to generate the distribution of words wi (where j is the parent of i in the tree), represents the vector embedding of the history of the ancestor words A(wi). Therefore, we count the term P [wi|sj ] only once when computing the likelihood of the sentence."
    }, {
      "heading" : "3 Labelled Dependency RNN",
      "text" : "The model presented so far does not use dependency labels. For this purpose we adapted the context-dependent RNN (Mikolov and Zweig, 2012) to handle them as additional M - dimensional label input features f(t). These features require a matrix F that connects label features to word vectors, thus yielding a new dynamical model (Eq. 5) in the RNN, and a matrix G that connects label features to output word probabilities. The full model becomes as follows:\ns(t) = f (Ws(t− 1) +Uw(t) + Ff(t))(5) y(t) = g ( Vs(t) +Gf(t) + dh(wtt−n+1) ) (6)\nOn our training dataset, the dependency parsing model found M = 44 distinct labels (e.g., nsubj, det or prep). At each time step t, the context word w(t) is associated a single dependency label f(t) (a one-hot vector of dimension M ).\nLet G(w) be the sequence of grammatical relations (dependency tree labels) between successive elements of (A(w), w). The factorization of the sentence likelihood from Eq. 4 becomes:\nP [ST |T ] = |S|∏ i=1 P [wi|A(wi), G(wi)] (7)"
    }, {
      "heading" : "4 Implementation and Dataset",
      "text" : "We modified the Feature-Augmented RNN toolkit2 and adapted it to handle tree-structured data. Specifically, and instead of being run sequentially on the entire training corpus, the RNN is run on all the word tokens in all unrolls of all the sentences in all the books of the corpus. The RNN is reset at the beginning of each unroll of a sentence. When calculating the log-probability of a sentence, the contribution of each word token is counted only once (and stored in a hash-table specific for that sentence). Once all the unrolls of a sentence are processed, the log-probability of the sentence is the sum of the per-token logprobabilities in that hash-table. We also further\n2 http://research.microsoft.com/en-us/projects/rnn/\nenhanced the RNN library by replacing some large matrix multiplication routines by calls to the CBLAS library, thus yielding a two- to three-fold speed-up in the test and training time.3\nThe training corpus consists of 522 19th century novels from Project Gutenberg (Zweig and Burges, 2012). All processing (sentence-splitting, PoS tagging, syntactic parsing) was performed using the Stanford CoreNLP toolkit (Manning et al., 2014). The test set contains 1040 sentences to be completed. Each sentence consists of one ground truth and 4 impostor sentences where a specific word has been replaced with a syntactically correct but semantically incorrect impostor word. Dependency trees are generated for each sentence candidate. We split that set into two, using the first 520 sentences in the validation (development) set and the latter 520 sentences in the test set. During training, we start annealing the learning rate λ with decay factor 0.66 as soon as the classification error on the validation set starts to increase."
    }, {
      "heading" : "5 Results",
      "text" : "Table 1 shows the accuracy (validation and test sets) obtained using a simple RNN with 50, 100, 200 and 300-dimensional hidden word representation and 250 frequency-based word classes (vocabulary size N = 72846 words appearing at least 5 times in the training corpus). One notices that adding the direct word context to target word connections (using the additional matrix described in section 2), enables to jump from a poor performance of about 30% accuracy to about 40% test accuracy, essentially matching the 39% accuracy reported for Good-Turing n-gram language models in Zweig et al. (2012). Modelling 4-grams yields even better results, closer to the 45% accuracy reported for RNNs in (Zweig et al., 2012).4\nAs Table 2 shows, dependency RNNs (depRNN) enable about 10 point word accuracy improvement over sequential RNNs.\nThe best accuracy achieved by the depRNN on the combined development and test sets used to report results in previous work was 53.5%. The best reported results in the MSR sentence completion challenge have been achieved by Log-BiLinear Models (LBLs) (Mnih and Hinton, 2007), a vari-\n3Our code and our preprocessed datasets are available from: https://github.com/piotrmirowski/ DependencyTreeRnn\n4The paper did not provide details on the maximum entropy features or on class-based hierarchical softmax).\nant of neural language models with 54.7% to 55.5% accuracy (Mnih and Teh, 2012; Mnih and Kavukcuoglu, 2013). We conjecture that their superior performance might stem from the fact that LBLs, just like n-grams, take into account the order of the words in the context and can thus model higher-order Markovian dynamics than the simple first-order autoregressive dynamics in RNNs. The depRNN proposed ignores the left-to-right word order, thus it is likely that a combination of these approaches will result in even higher accuracies. Gubbins and Vlachos (2013) developed a countbased dependency language model achieving 50% accuracy. Finally, Mikolov et al. (2013) report that they achieved 55.4% accuracy with an ensemble of RNNs, without giving any other details."
    }, {
      "heading" : "6 Discussion",
      "text" : "Related work Mirowski et al. (2010) incorporated syntactic information into neural language models using PoS tags as additional input to LBLs but obtained only a small reduction of the word error rate in a speech recognition task. Similarly, Bian et al. (2014) enriched the Continuous Bag-of-\nWords (CBOW) model of Mikolov et al. (2013) by incorporating morphology, PoS tags and entity categories into 600-dimensional word embeddings trained on the Gutenberg dataset, increasing sentence completion accuracy from 41% to 44%. Other work on incorporating syntax into language modeling include Chelba et al. (1997) and Pauls and Klein (2012), however none of these approaches considered neural language models, only count-based ones. Levy and Goldberg (2014) and Zhao et al. (2014) proposed to train neural word embeddings using skip-grams and CBOWs on dependency parse trees, but did not extend their approach to actual language models such as LBL and RNN and did not evaluate the word embeddings on word completion tasks.\nNote that we assume that the dependency tree is supplied prior to running the RNN which limits the scope of the Dependency RNN to the scoring of complete sentences, not to next word prediction (unless a dependency tree parse for the sentence to be generated is provided). Nevertheless, it is common in speech recognition and machine translation to use a conventional decoder to produce an N-best list of the most likely candidate sentences and then re-score them with the language model. (Chelba et al., 1997; Pauls and Klein, 2011)\nTai et al. (2015) propose a similar approach to ours, learning Long Short-Term Memory (LSTM) (Hochreiter and Schmidhuber, 1997; Graves, 2012) RNNs on dependency parse tree network topologies. Their architectures is not designed to predict next-word probability distributions, as in a language model, but to classify the input words (sentiment analysis task) or to measure the similarity in hidden representations (semantic relatedness task). Their relative improvement in performance (tree LSTMs vs standard LSTMs) on these two tasks is smaller than ours, probably because the LSTMs are better than RNNs at storing long-term dependencies and thus do not benefit form the word ordering from dependency trees as much as RNNs. In a similar vein to ours, MiceliBarone and Attardi (2015) simply propose to enhance RNN-based machine translation by permuting the order of the words in the source sentence to match the order of the words in the target sentence, using a source-side dependency parsing.\nLimitations of RNNs for word completion Zweig et al. (2012) reported that RNNs achieve lower perplexity than n-grams but do not always\noutperform them on word completion tasks. As illustrated in Fig. 2, the validation set perplexity (comprising all 5 choices for each sentence) of the RNN keeps decreasing monotonically (once we start annealing the learning rate), whereas the validation accuracy rapidly reaches a plateau and oscillates. Our observation confirms that, once an RNN went through a few training epochs, change in perplexity is no longer a good predictor of change in word accuracy. We presume that the log-likelihood of word distribution is not a training objective crafted for precision@1, and that further perplexity reduction happens in the middle and tail of the word distribution."
    }, {
      "heading" : "7 Conclusions",
      "text" : "In this paper we proposed a novel language model, dependency RNN, which incorporates syntactic dependencies into the RNN formulation. We evaluated its performance on the MSR sentence completion task and showed that it improves over RNN by 10 points in accuracy, while achieving results comparable with the state-of-the-art. Further work will include extending the dependency tree language modeling to Long Short-Term Memory RNNs to handle longer syntactic dependencies."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank our anonymous reviewers for their valuable feedback. PM also thanks Geoffrey Zweig, Daniel Voinea, Francesco Nidito and Davide di Gennaro for sharing the original FeatureAugmented RNN toolkit on the Microsoft Research website and for insights about that code, as well as Bhaskar Mitra, Milad Shokouhi and Andriy Mnih for enlighting discussions about word embedding and sentence completion."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "Recent work on language modelling has shifted focus from count-based models to neural models. In these works, the words in each sentence are always considered in a left-to-right order. In this paper we show how we can improve the performance of the recurrent neural network (RNN) language model by incorporating the syntactic dependencies of a sentence, which have the effect of bringing relevant contexts closer to the word being predicted. We evaluate our approach on the Microsoft Research Sentence Completion Challenge and show that the dependency RNN proposed improves over the RNN by about 10 points in accuracy. Furthermore, we achieve results comparable with the stateof-the-art models on this task.",
    "creator" : "LaTeX with hyperref package"
  }
}