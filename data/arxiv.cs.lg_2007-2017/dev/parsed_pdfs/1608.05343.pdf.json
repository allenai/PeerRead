{
  "name" : "1608.05343.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Decoupled Neural Interfaces using Synthetic Gradients",
    "authors" : [ "Max Jaderberg", "Wojciech Marian Czarnecki", "Simon Osindero", "Oriol Vinyals", "Alex Graves", "Koray Kavukcuoglu" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Training directed neural networks typically requires forward-propagating data through a computation graph, followed by backpropagating error signal, to produce weight updates. All layers, or more generally, modules, of the network are therefore locked, in the sense that they must wait for the remainder of the network to execute forwards and propagate error backwards before they can be updated. In this work we break this constraint by decoupling modules by introducing a model of the future computation of the network graph. These models predict what the result of the modelled subgraph will produce using only local information. In particular we focus on modelling error gradients: by using the modelled synthetic gradient in place of true backpropagated error gradients we decouple subgraphs, and can update them independently and asynchronously i.e. we realise decoupled neural interfaces. We show results for feed-forward models, where every layer is trained asynchronously, recurrent neural networks (RNNs) where predicting one’s future gradient extends the time over which the RNN can effectively model, and also a hierarchical RNN system with ticking at different timescales. Finally, we demonstrate that in addition to predicting gradients, the same framework can be used to predict inputs, resulting in models which are decoupled in both the forward and backwards pass – amounting to independent networks which co-learn such that they can be composed into a single functioning corporation."
    }, {
      "heading" : "1 Introduction",
      "text" : "Each layer (or module) in a directed neural network can be considered a computation step, that transforms its incoming data. These modules are connected via directed edges, creating a forward processing graph which defines the flow of data from the network inputs, through each module, producing network outputs. Defining a loss on outputs allows errors to be generated, and propagated back through the network graph to provide a signal to update each module.\nThis process results in several forms of locking, namely: (i) Forward Locking – no module can process its incoming data before the previous nodes in the directed forward graph have executed; (ii) Update Locking – no module can be updated before all dependent modules have executed in forwards mode; also, in many credit-assignment algorithms (including backpropagation [18]) we have (iii) Backwards Locking – no module can be updated before all dependent modules have executed in both forwards mode and backwards mode.\nForwards, update, and backwards locking constrains us to running and updating neural networks in a sequential, synchronous manner. Though seemingly benign when training simple feed-forward nets, this poses problems when thinking about creating systems of networks acting in multiple environments at different and possibly irregular or asynchronous timescales. For example, in complex systems comprised of multiple asynchronous cooperative modules (or agents), it is undesirable and potentially unfeasible that all networks are update locked. Another example is a distributed model, where part of the model is shared and used by many downstream clients – all clients must be fully executed and pass error gradients back to the shared model before the model can update, meaning the system trains as fast as the slowest client. The possibility to parallelise training of currently sequential systems could hugely speed up computation time.\nThe goal of this work is to remove update locking for neural networks. This is achieved by removing backpropagation. To update weights θi of module i we drastically approximate the function implied by backpropagation:\nar X\niv :1\n60 8.\n05 34\n3v 1\n[ cs\n.L G\n] 1\n8 A\nug 2\n01 6\n∂L ∂θi = fBprop((hi, xi, yi, θi), (hi+1, xi+1, yi+1, θi+1), . . .) ∂hi ∂θi ' f̂Bprop(hi) ∂hi ∂θi\nwhere h are activations, x are inputs, y is supervision, and L is the overall loss to minimise. This leaves dependency only on hi – the information local to module i.\nThe premise of this method is based on a simple protocol for learnt communication, allowing neural network modules to interact and be trained without update locking. While the communication protocol is general with respect to the means of generating a training signal, here we focus on a specific implementation for networks trained with gradient descent – we replace a standard neural interface (a connection between two modules in a neural network) with a Decoupled Neural Interface (DNI). Most simply, when a module (e.g. a layer) sends a message (activations) to another module, there is an associated model which produces a predicted error gradient with respect to the message immediately. The predicted gradient is a function of the message alone; there is no dependence on downstream events, states or losses. The sender can then immediately use these synthetic gradients to get an update, without incurring any delay. And by removing update- and backwards locking in this way, we can train networks without a synchronous backward pass. We also show preliminary results that extend this idea to also remove forward locking – resulting in networks whose modules can also be trained without a synchronous forward pass. When applied to RNNs we show that using synthetic gradients allows RNNs to model much greater time horizons than the limit imposed by truncating backpropagation through time (BPTT). We also show that using DNI to decouple a system of two RNNs running at different timescales can greatly increase training speed of the faster RNN.\nOur synthetic gradient model is most analogous to a value function which is used for gradient ascent [2] or a value function used for bootstrapping. Most other works that aim to remove backpropagation do so with the goal of performing biologically plausible credit assignment, but this doesn’t eliminate update locking between layers. E.g. target propagation [3, 15] removes the reliance on passing gradients between layers, by instead generating target activations which should be fitted to. However these targets must still be generated sequentially, propagating backwards through the network and layers are therefore still update- and backwardslocked. Other algorithms remove the backwards locking by allowing loss or rewards to be broadcast directly to each layer – e.g. REINFORCE [21] (considering all activations are actions), Kickback [1], and Policy Gradient Coagent Networks [20] – but still remain update locked since they require rewards to be generated by an output (or a global critic). While Real-Time Recurrent Learning [22] or approximations such as [17] may seem a promising way to remove update locking, these methods require maintaining the full (or approximate) gradient of the current state with respect to the parameters. This is inherently not scalable and also requires the optimiser to have global knowledge of the network state. In contrast, by framing the interaction between layers as a local communication problem with DNI, we remove the need for global knowledge of the learning system. Other works such as [4, 19] allow training of layers in parallel without backpropagation, but in practice are not scalable to more complex and generic network architectures."
    }, {
      "heading" : "2 Decoupled Neural Interfaces",
      "text" : "We begin by describing the high-level communication protocol that is used to allow asynchronously learning agents to communicate.\nAs shown in Fig. 1 (a), Sender A sends a message hA to Receiver B. B has a model MB of the utility of the message hA. B’s model of utility MB is used to predict the feedback: an error signal δ̂A =MB(hA, sB , c) based on the message hA, the current state of B, sB , and potentially any other information, c, that this module is privy to during training such as the label information. The feedback δ̂A is sent back to A which allows A to be updated immediately. In time, B can fully evaluate the true utility δA of the message received from A, and so B’s utility model can be updated to fit the true utility, reducing the disparity between δ̂A and δA.\nThis protocol allows A to send messages to B in a way that A and B are update decoupled – A does not have to wait for B to evaluate the true utility before it can be updated – and A can learn to send messages of high utility to B.\nWe can apply this protocol to neural networks communicating, resulting in what we call Decoupled Neural Interfaces (DNI). For neural networks, the feedback error signal δ̂A can take different forms, e.g. gradients can be used as the error signal to work with backpropagation, target messages as the error signal to work with target propagation, or even a value (cumulative discounted future reward) to incorporate into a reinforcement learning framework. However, as a clear and easily analysable set of first steps into this important and mostly unexplored\nB A\nMA→B\nhA→B ̂A!B A!B\nSB\n̂A!B\nB\nA\nMA→B\nhA→B\n̂A!B A!B SB\n̂A!B\nB\nA\nMA→B\nhA→B\n̂A!B A!B\nSB\n̂A!B\nB\nA\nMA→B hA→B ̂A!B A!B SB\n̂A!B\nB\nA\nMA→B\nhA→B\n̂A!B A!B SB ̂A!B\nB\nA\nMA→B\nhA→B\n̂A!B A!B SB ̂A!B\nB MA→B hA→B A!B SB B\nA\nMA→B\nhA→B\nA!B SB B\nA\nMA→B\nhA→B\nA!B SB\ndomain, we concentrate our empirical study on differentiable networks trained with backpropagation and gradient-based updates. Therefore, we focus on producing error gradients as the feedback δ̂A which we dub synthetic gradients."
    }, {
      "heading" : "2.1 Synthetic Gradient for Feed-Forward Networks",
      "text" : "We now apply the above process to the case of a feed-forward neural net consisting of N layers fi, i ∈ {1, . . . , N}, each taking an input xi and producing an output hi = fi(xi). The layers are connected in a chain such that xi = hi−1, as illustrated in Fig. 1 (b). The full network can be denoted as as FN1 – the forward execution graph from layer 1 to layer N inclusive.\nDefine the loss imposed on the output of the network as L(hN ). Each layer fi has parameters θi that can be trained jointly to minimise L(hN ) with a gradient-based update rule\nθi ← θi − α δi ∂hi ∂θi ; δi = ∂L ∂hi (1)\nwhere α is the learning rate and ∂L∂hi is computed with backpropagation [18]. The reliance on δi means that the update to layer i can only occur after the remainder of the network, i.e. FNi+1 (the sub-network of layers between layer i+ 1 and layer N inclusive) has executed a full forward pass, generated the loss L(hN ), then backpropagated the gradient through every successor layer in reverse order. Layer i is therefore update locked to FNi+1. To remove the update locking of layer i to FNi+1 we can use the communication protocol described previously. Layer i sends hi to layer i + 1, which has a communication model Mi+1 that produces a synthetic error gradient δ̂i =Mi+1(hi), as shown in Fig. 1 (c), which can be used immediately to update layer i and all the other layers in F i1\nθn ← θn − α δ̂i ∂hi ∂θn , n ∈ {1, . . . , i}. (2)\nTo train the parameters φi+1 of the synthetic gradient model Mi+1 (which is also a neural network), we simply wait for the true error gradient δi to be computed (after a full forwards and backwards execution of FNi+1), and fit the synthetic gradient to the true gradients by minimising a loss Lδi = d(δ̂i, δi). In our experiments we found using L2 distance as a loss worked well. Note that Mi+1 is update locked to FNi+1, a favourable tradeoff to unlock F i1. Furthermore, for a feed-forward network, we can use synthetic gradients as communication feedback to decouple every layer in the network, as shown in Fig. 1 (d). The execution of this process is illustrated in Fig. 2. In this case, since the target error gradient δi is produced by backpropagating δ̂i+1 through layer i+ 1, δi is\n…\n…\n…\n…\n…\n…\nLt Lt+1 Lt+2̂t ̂t+1 ̂t+2 ̂t+3\n̂t+4 ̂t+5 ̂t+6\n… …\n…\n…\n…\n…\nLt+4 Lt+5Lt+3 Lt+6\n(b) ……\n…\n…\nnot the true error gradient, but an estimate bootstrapped from synthetic gradient models later in the network. Surprisingly, this does not cause errors to compound and learning remains stable even with many layers, as shown in Sect. 3.1.\nThis process allows each layer to be updated as soon as a forward pass has been executed. Additionally, if any supervision or context c is available at the time of synthetic gradient computation, the synthetic gradient model can take this as an extra input, δ̂i =Mi+1(hi, c)."
    }, {
      "heading" : "2.2 Synthetic Gradient for Recurrent Networks",
      "text" : "An RNN applied to infinite stream prediction can be viewed as an infinitely unrolled recurrent core module f with parameters θ, such that the forward graph is F∞1 = (fi)∞i=1 where fi = f ∀i and the core module propagates an output yi and state hi based on some input xi: yi, hi = fi(xi, hi−1).\nOf course, at some time t, one cannot compute an update of the form θ ← θ − α∑∞τ=t ∂Lτ∂θ due to the infinite future time dependency. Instead, generally one considers a tractable time horizon\nθ − α ∞∑ τ=t ∂Lτ ∂θ = θ − α ( t+T∑ τ=t ∂Lτ ∂θ + ( ∞∑ τ=T+1 ∂Lτ ∂hT ) ∂hT ∂θ ) = θ − α ( t+T∑ τ=t ∂Lτ ∂θ + δT ∂hT ∂θ ) (3)\n… …\n… …\n… … Lt Lt+1 Lt+2̂t ̂t+6 … … … … … … Lt+4 Lt+5Lt+3 Lt+6 …… … …\nand as in BPTT, calculates ∑t+T τ=t ∂Lτ ∂θ with backpropagation and approximates δT = 0. This limits the time horizon over which updates to θ can be learnt, effectively limiting the amount of temporal dependency an RNN can learn. However, using the Decoupled Neural Interfaces framework, we can approximate δT with a synthetic gradient model δ̂T =MT (hT ) as shown and described in Fig. 3 (a).\nThis amounts to taking the infinitely unrolled RNN as the full neural network F∞1 , and chunking it into an infinite number of sub-networks where the recurrent core is unrolled for T steps, giving F t+T−1t . Inserting DNI between two adjacent sub-networks F t+T−1t and F t+2T−1t+T allows the recurrent network to learn to communicate to its future self, without being update locked to its future self. From the view of the synthetic gradient model, the RNN is predicting its own error gradients.\nThis scheme can be implemented very efficiently by exploiting the recurrent nature of the network, as shown in Fig. 4. In Sect. 3.2 we show results on sequence-to-sequence tasks and language modelling.\nWe also propose an extension to aid learning of synthetic gradient models for RNNs, which is to introduce another auxiliary task from the RNN, described in Fig. 3 (b). This extra prediction problem is designed to promote coupling over the maximum time span possible, requiring the recurrent core to explicitly model short term and long term synthetic gradients, helping propagate gradient information backwards in time. This is also shown to further increase performance in Sect. 3.2.\nArbitrary Network Graphs Although we have explicitly described the application of DNI for communication between layers in feed-forward networks, and between recurrent cores in recurrent networks, there is nothing to restrict the use of DNI for arbitrary network graphs. The same procedure can be applied to any network or collection of networks, any number of times. An example is in Sect. 3.3 where we show communication between two RNNs, which tick at different rates, where the communication can be learnt by using DNI."
    }, {
      "heading" : "3 Experiments",
      "text" : ""
    }, {
      "heading" : "3.1 Feed-Forward Networks",
      "text" : "In this section we apply DNIs to feed-forward networks. As explained in Sect. 2.1 this allows layers to communicate with each other without being update locked. This simple scenario serves as a good way to test the learning dynamics of decoupled systems in a familiar setup.\nEvery layer DNI We first look at training an FCN for MNIST digit classification [14]. For an FCN, “layer” refers to a linear transformation followed by batch-normalisation [10] and a rectified linear non-linearity (ReLU) [6]. All hidden layers have the same number of units, 256. We use DNI as in the scenario illustrated in Fig. 1 (d), where DNIs are used between every layer in the network. E.g. for a four layer network (three hidden, one final classification) there will be three DNIs. In this scenario, every layer can be updated as soon as its activations have been computed and passed through the synthetic gradient model of the layer above, without waiting for any other layer to compute or loss to be generated. We perform experiments where we vary the depth of the model (between 3 and 6 layers), on MNIST digit classification and CIFAR-10 object recognition [12]. Full implementation details can be found in Sect. A.1.\nLooking at the results in Table 1 we can see that DNI does indeed work, successfully update-decoupling all layers at a small cost in accuracy, demonstrating that it is possible to produce effective gradients without either label or true gradient information. Further, once we condition the synthetic gradients on the labels, we can successfully train deep models with very little degradation in accuracy. For example, on CIFAR-10 we can train a 5 layer model, with backpropagation achieving 42% error, with DNI achieving 47% error, and when conditioning the synthetic gradient on the label (cDNI) get 44%. In fact, on MNIST we successfully trained up to 21 layer FCNs with cDNI to 2% error (the same as with using backpropagation).\nAs another baseline, we tried using historical, stale gradients with respect to activations, rather than synthetic gradients. We took an exponential average historical gradient, searching over the entire spectrum of decay rates and the best results attained on MNIST classification were 9.1%, 11.8%, 15.4%, 19.0% for 3 to 6 layer FCNs respectively – marginally better than using zero gradients (no backpropagation) and far worse than the associated cDNI results of 2.2%, 1.9%, 1.7%, 1.6%. Note that the experiment described above used stale gradients with respect to the activations which do not correspond to the same input example used to compute the activation. In the case of a fixed training dataset, one could use the stale gradient from the same input, but it would be stale by an entire epoch and contains no new information so would fail to improve the model. Thus, we believe that DNI, which uses a parametric approximation to the gradient with respect to activations, is the most desirable approach.\nThis framework can be easily applied to CNNs [13]. The spatial resolution of activations from layers in a CNN results in high dimensional activations, so we use synthetic gradient models which themselves are CNNs without pooling and with resolution-preserving zero-padding. For the full details of the CNN models please refer to Sect. A.1. The results of CNN models for MNIST and CIFAR-10 are also found in Table 1, where DNI and cDNI CNNs perform exceptionally well compared to true backpropagated gradient trained models – a three layer CNN on CIFAR-10 results in 17.9% error with backpropagation, 19.5% (DNI), and 19.0% (cDNI). Interestingly, the best results obtained with cDNI were with linear synthetic gradient models.\nSparse Updates To demonstrate the gains by decoupling layers given by DNI, we perform an experiment on a four layer FCN model on MNIST, where the backwards pass and update for every layer occurs in random order and only with some probability pupdate (i.e. a layer is only updated after its forward pass pupdate of the time). This completely breaks backpropagation, as for example the first layer would only receive error gradients with probability p3update and even then, the system would be constrained to be synchronous. However,\nfi\nfi+2\n…\n…\n……\nMi+1\n̂i\nMi+2\nwith DNI bridging the communication gap between each layer, the stochasticity of a layer’s update does not mean the layer below cannot update, as it uses synthetic gradients rather than backpropagated gradients. We ran 100 experiments with different values of pupdate uniformly sampled between 0 and 1. The results are shown in Fig. 5 (Left) for DNI with and without conditioning on the labels. With pupdate = 0.2 the network can still train to 2% accuracy. Incredibly, when the DNI is conditioned on the labels of the data (a reasonable assumption if training in a distributed fashion), the network trains perfectly with only 5% chance of an update, albeit just slower.\nComplete Unlock As a drastic extension, we look at making feed-forward networks completely asynchronous, by removing forward locking as well. In this scenario, every layer has a synthetic gradient model, but also a synthetic input model – given the data, the synthetic input model produces an approximation of what the input to the layer will be. This is illustrated in Fig. 6. Every layer can now be trained independently, with the synthetic gradient and input models trained to regress targets produced by neighbouring layers. The results on MNIST are shown in Fig. 5 (Right), and at least in this simple scenario, the completely asynchronous collection of layers train independently, but co-learn to reach 2% accuracy, only slightly slower. More details are given in Sect. A.2."
    }, {
      "heading" : "3.2 Recurrent Neural Networks",
      "text" : "We now turn our attention to experiments on the application of DNI to recurrent neural networks as discussed in Sect. 2.2. We test our models on the Copy task, Repeat Copy task, as well as character-level language modelling.\nFor all experiments we use an LSTM [9] of the form in [7], whose output is used for the task at hand, and additionally as input to the synthetic gradient model (which is shared over all timesteps). The LSTM is unrolled for T timesteps after which backpropagation through time (BPTT) is performed. We also look at incorporating an auxiliary task which predicts the output of the synthetic gradient model T steps in the future as explained in Sect. 2.2. The implementation details of the RNN models are given in Sect. A.3.\nCopy and Repeat Copy We first look at two synthetic tasks – Copy and Repeat Copy tasks from [8]. Copy involves reading in a sequence of N characters and after a stop character is encountered, must repeat the sequence of N characters in order and produce a final stop character. Repeat Copy must also read a sequence of N characters, but after the stop character, reads the number, R, which indicates the number of times it is required to copy the sequence, before outputting a final stop character. Each sequence of reading and copying is an episode, of length Ttask = N + 3 for Copy and Ttask = NR+ 3 for Repeat Copy.\nWhile normally the RNN would be unrolled for the length of the episode before BPTT is performed, T = Ttask, we wish to test the length of time the RNN is able to model with and without DNI bridging the BPTT limit. We train the RNN with truncated BPTT: T ∈ {2, 3, 4, 5} with and without DNI. For each problem, once the RNN has solved a task with a particular episode length (averaging below 0.15 bits error), the task is made harder by extending N for Copy and Repeat Copy, and also R for Repeat Copy.\nTable 2 gives the results by reporting the largest Ttask that is successfully solved by the model. The RNNs without DNI generally perform as expected, with longer BPTT resulting in being able to model longer time dependencies. However, by introducing DNI we can extend the time dependency that is able to be modelled by an RNN. The additional computational complexity is negligible but we require an additional recurrent core to be stored in memory (this is illustrated in Fig. 4). Because we can model larger time dependencies with a smaller T , our models become more data-efficient, learning faster and having to see less data samples to solve a task. Furthermore, when we include the extra task of predicting the synthetic gradient that will be produced T steps in the future (DNI + Aux), the RNNs with DNI are able to model even larger time dependencies. For example with T = 3 (i.e. performing BPTT across only three timesteps) on the Repeat Copy task, the DNI enabled RNN goes from being able to model 33 timesteps to 59 timesteps when using future synthetic gradient prediction as well. This is in contrast to without using DNI at all, where the RNN can only model 5 timesteps.\ncount(odd) = 2\ncount(odd) = 1 count(3s) = 2\nA A A\nA\nB\nB\nM\nt=1 t=2 t=3\nt=4\nM\nLanguage Modelling We also applied our DNI-enabled RNNs to the task of character-level language modelling, using the Penn Treebank dataset [16]. We use an LSTM with 1024 units, which at every timestep reads a character and must predict the next character in the sequence. We train with BPTT with and without DNI, as well as when using future synthetic gradient prediction (DNI + Aux), with T ∈ {2, 3, 4, 5, 8} as well as strong baselines with T = 20, 40. We measure error in bits per character (BPC) as in [7], perform early stopping based on validation set error, and for simplicity do not perform any learning rate decay. For full experimental details please refer to Sect. A.3.\nThe results are given in Table 2. Interestingly, with BPTT over only two timesteps (T = 2) an LSTM can get surprisingly good accuracy at next character prediction. As expected, increasing T results in increased accuracy of prediction. When adding DNI, we see an increase in speed of learning (learning curves can be found in Fig. 7 (Right) and Fig. 14), and models reaching greater accuracy (lower BPC) than their counterparts without DNI. As seen with the Copy and Repeat Copy task, future synthetic gradient prediction further increases the ability of the LSTM to model long range temporal dependencies – an LSTM unrolled 5 timesteps with DNI and future synthetic gradient prediction gives the same BPC as a vanilla LSTM unrolled 20 steps, only needs 58% of the data and is 2× faster in wall clock time to reach 1.35BPC. Although we report results only with LSTMs, we have found DNI to work similarly for vanilla RNNs and Leaky RNNs [17]."
    }, {
      "heading" : "3.3 Multi-Network System",
      "text" : "In this section, we explore the use of DNI for communication between arbitrary graphs of networks. As a simple proof-of-concept, we look at a system of two RNNs, Network A and Network B, where Network B is executed at a slower rate than Network A, and must use communication from Network A to complete its task. The experimental setup is illustrated and described in Fig. 8 (a). Full experimental details can be found in Sect. A.4.\nFirst, we test this system trained end-to-end, with full backpropagation through all connections, which requires the joint Network A-Network B system to be unrolled for T 2 timesteps before a single weight update to both Network A and Network B, as the communication between Network A to Network B causes Network A to be update locked to Network B. We the train the same system but using DNI to create a learnable bridge between Network A and Network B, thus decoupling Network A from Network B. This allows Network A to be updated T times more frequently, by using synthetic gradients in place of true gradients from Network B.\nFig. 8 (b) shows the results for T = 4. Looking at the test error during learning of Network A (Fig. 8 (b) Top), it is clear that being decoupled and therefore updated more frequently allows Network A to learn much quicker than when being locked to Network B, reaching final performance in under half the number of steps. Network B also trains faster with DNI (most likely due to the increased speed in learning of Network A), and reaches a similar final accuracy as with full backpropagation (Fig. 8 (b) Bottom). When the networks are decoupled but DNI is not used (i.e. no gradient is received by Network A from Network B), Network A receives no feedback from Network B, so cannot shape its representations and send a suitable message, meaning Network B cannot solve the problem."
    }, {
      "heading" : "4 Conclusion",
      "text" : "In this work we introduced a method, DNI using synthetic gradients, which allows decoupled communication between components, such that they can be indepedently updated. We demonstrated this in feed-forward nets with all layers decoupled – allowing them to be trained non-sequentially, without locking. We also showed large gains from the increased time horizon that DNI-enabled RNNs are able to model, as well as faster convergence. Finally we demonstrated application to a multi-network system: a communicating pair of fastand slow-ticking RNNs can be decoupled, greatly accelarating learning. To our knowledge this is the first time that neural net modules have been decoupled, and the update locking has been broken. This important result opens up exciting avenues of exploration – including improving the foundations laid out here, and application to modular, decoupled, and asynchronous model architectures."
    }, {
      "heading" : "A Appendix",
      "text" : ""
    }, {
      "heading" : "A.1 Feed-Forward Implementation Details",
      "text" : "In this section we give the implementation details of the experimental setup used in the experiments from Sect. 3.1.\nConditional DNI (cDNI) In order to provide DNI module with the label information in FCN, we simply concatenate the one-hot representation of a sample’s label to the input of the synthetic gradient model. Consequently for both MNIST and CIFAR-10 experiments, each cDNI module takes ten additional, binary inputs. For convolutional networks we add label information in the form of one-hot encoded channel masks, thus we simply concatenate ten additional channels to the activations, nine out of which are filled with zeros, and one (corresponding to sample’s label) is filled with ones.\nCommon Details All experiments are run for 500k iterations and optimised with Adam [11] with batch size of 256. The learning rate was initialised at 3× 10−5 and decreased by a factor of 10 at 300k and 400k steps. Note the number of iterations, learning rate, and learning rate schedule was not optimised. We perform a hyperparameter search over the number of hidden layers in the synthetic gradient model (from 0 to 2, where 0 means we use a linear model such that δ̂ = M(h) = φwh + φb) and select the best number of layers for each experiment type (given below) based on the final test performance. We used cross entropy loss for classification and L2 loss for synthetic gradient regression which was weighted by a factor of 1 with respect to the classification loss. All input data was scaled to [0, 1] interval. The final regression layer of all synthetic gradient models are initialised with zero weights and biases, so initially, zero synthetic gradient is produced.\nMNIST FCN Every hidden layer consists of fully-connected layers with 256 units, followed by batchnormalisation and ReLU non-linearity. The synthetic gradient models consists of two (DNI) or zero (cDNI) hidden layers and with 1024 units (linear, batch-normalisation, ReLU) followed by a final linear layer with 256 units.\nMNIST CNN The hidden layers are all convolutional layers with 64 5× 5 filters with resolution preserving padding, followed by batch-normalisation, ReLU and 3× 3 spatial max-pooling in the first layer and averagepooling in the remaining ones. The synthetic gradient model has two hidden layers with 64 5× 5 filters with resolution preserving padding, batch-normalisation and ReLU, followed by a final 64 5× 5 filter convolutional layer with resolution preserving padding.\nCIFAR-10 FCN Every hidden layer consists of fully-connected layers with 1000 units, followed by batchnormalisation and ReLU non-linearity. The synthetic gradient models consisted of one hidden layer with 4000 units (linear, batch-normalisation, ReLU) followed by a final linear layer with 1000 units.\nCIFAR-10 CNN The hidden layers are all convolutional layers with 128 5 × 5 filters with resolution preserving padding, followed by batch-normalisation, ReLU and 3× 3 spatial max-pooling in the first layer and avg-pooling in the remaining ones. The synthetic gradient model has two hidden layers with 128 5× 5 filters with resolution preserving padding, batch-normalisation and ReLU, followed by a final 128 5× 5 filter convolutional layer with resolution preserving padding.\nComplete Unlock. In the completely unlocked model, we use the identical architecture used for the synthetic gradient model, but for simplicity both synthetic gradient and synthetic input models use a single hidden layer (for both DNI and cDNI), and train it to produce synthetic inputs ĥi such that ĥi ' hi. The overall training setup is depicted in Fig. 6. During testing all layers are connected to each other for a forward pass, i.e. the synthetic inputs are not used."
    }, {
      "heading" : "A.2 Feed-Forward Additional Experiments",
      "text" : "Single DNI We look at training an FCN for MNIST digit classification using a network with 6 layers (5 hidden layers, one classification layer), but splitting the network into two unlocked sub-networks by inserting a single DNI at a variable position, as illustrated in Fig. 1 (c).\nFig. 9 (a) shows the results of varying the depth at which the DNI is inserted. When training this 6 layer FCN with vanilla backpropagation we attain 1.6% test error. Incorporating a single DNI between two layers results in between 1.8% and 3.4% error depending on whether the DNI is after the first layer or the penultimate layer\nrespectively. If we decouple the layers without DNI, by just not backpropagating any gradient between them, this results in bad performance – between 2.9% and 23.7% error for after layer 1 and layer 5 respectively.\nOne can also see from Fig. 9 (a) that as the DNI module is positioned closer to the classification layer (going up in layer hierarchy), the effectiveness of it degrades. This is expected since now a larger portion of the whole system never observes true gradient. However, as we show in Sect. 3.1, using extra label information in the DNI module almost completely alleviates this problem.\nWe also plot the synthetic gradient regression error (L2 distance), cosine distance, and the sign error (the number of times the sign of a gradient dimension is predicted incorrectly) compared to the true error gradient in Fig. 10. Looking at the L2 error, one can see that the error jumps initially as the layers start to train, and then the synthetic gradient model starts to fit the target gradients. The cosine similarity is on average very slightly positive, indicating that the direction of synthetic gradient is somewhat aligned with that of the target gradient, allowing the model to train. However, it is clear that the synthetic gradient is not tracking the true gradient very accurately, but this does not seem to impact the ability to train the classifiers."
    }, {
      "heading" : "A.2.1 Underfitting of Synthetic Gradient Models",
      "text" : "If one takes a closer look at learning curves for DNI model (see Fig. 13 for training error plot on CIFAR-10 with CNN model) it is easy to notice that the large test error (and its degradation with depth) is actually an effect of underfitting and not lack of ability to generalise or lack of convergence of learning process. One of the possible explanations is the fact that due to lack of label signal in the DNI module, the network is over-regularised as in each iteration DNI tries to model an expected gradient over the label distribution. This is obviously a harder problem than modelling actual gradient, and due to underfitting to this subproblem, the whole network also underfits to the problem at hand. Once label information is introduced in the cDNI model,\nthe network fits the training data much better, however using synthetic gradients still acts like a regulariser, which also translates to a reduced test error. This might also suggest, that the proposed method of conditioning on labels can be further modified to reduce the underfitting effect."
    }, {
      "heading" : "A.3 RNN Implementation Details",
      "text" : "Common Details All RNN experiments are performed with an LSTM recurrent core, where the output is used for a final linear layer to model the task. In the case of DNI and DNI+Aux, the output of the LSTM is also used as input to a single hidden layer synthetic gradient model with the same number of units as the LSTM, with a final linear projection to two times the number of units of the LSTM (to produce the synthetic gradient of the output and the cell state). The synthetic gradient is scaled by a factor of 0.1 when consumed by the model (we found that this reliably leads to stable training). We perform a hyperparameter search of whether or not to backpropagate synthetic gradient model error into the LSTM core (the model was not particularly sensitive to this, but occasionally backpropagating synthetic gradient model error resulted in more unstable training). The cost on the synthetic gradient regression loss and future synthetic gradient regression loss is simply weighted by a factor of 1.\nCopy and Repeat Copy Task In these tasks we use 256 LSTM units and the model was optimised with Adam with a learning rate of 7× 10−5 and a batch size of 256. The tasks were progressed to a longer episode length after a model gets below 0.15 bits error. The Copy task was progressed by incrementing N , the length of the sequence to copy, by one. The Repeat Copy task was progressed by alternating incrementing N by one and R, the number of times to repeat, by one.\nPenn Treebank The architecture used for Penn Treebank experiments consists of an LSTM with 1024 units trained on a character-level language modelling task. Learning is performed with the use of Adam with learning rate of 7× 10−5 (which we select to maximise the score of the baseline model through testing also 1× 10−4 and 1× 10−6) without any learning rate decay or additional regularisation. Each 5k iterations we record validation error (in terms of average bytes per character) and store the network which achieved the smallest one. Once validation error starts to increase we stop training and report test error using previously saved network. In other words, test error is reported for the model yielding minimum validation error measured with 5k iterations resolution. A single iteration consists of performing full BPTT over T steps with a batch of 256 samples."
    }, {
      "heading" : "A.4 Multi-Network Implementation Details",
      "text" : "The two RNNs in this experiment, Network A and Network B, are both LSTMs with 256 units which use batch-normalisation as described in [5]. Network A takes a 28× 28 MNIST digit as input and has a two layer FCN (each layer having 256 units and consisting of linear, batch-normalisation, and ReLU), the output of which is passed as input to its LSTM. The output of Network A’s LSTM is used by a linear classification layer to classify the number of odd numbers, as well as input to another linear layer with batch-normalisation which produces the message to send to Network B. Network B takes the message from Network A as input to its LSTM, and uses the output of its LSTM for a linear classifier to classify the number of 3’s seen in Network A’s datastream. The synthetic gradient model has a single hidden layer of size 256 followed by a linear layer which produces the 256-dimensional synthetic gradient as feedback to Network A’s message.\nAll networks are trained with Adam with a learning rate of 1× 10−5. We performed a hyperparameter search over the factor by which the synthetic gradient should by multiplied by before being backpropagated through Network A, which we selected as 10 by choosing the system with the lowest training error."
    } ],
    "references" : [ {
      "title" : "Kickback cuts backprop’s red-tape: Biologically plausible credit assignment in neural networks",
      "author" : [ "D. Balduzzi", "H. Vanchinathan", "J. Buhmann" ],
      "venue" : "arXiv preprint arXiv:1411.6191,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2014
    }, {
      "title" : "Direct gradient-based reinforcement learning",
      "author" : [ "J. Baxter", "P.L. Bartlett" ],
      "venue" : "In Circuits and Systems,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2000
    }, {
      "title" : "How auto-encoders could provide credit assignment in deep networks via target propagation",
      "author" : [ "Y. Bengio" ],
      "venue" : "arXiv preprint arXiv:1407.7906,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2014
    }, {
      "title" : "Distributed optimization of deeply nested systems",
      "author" : [ "M A Carreira-Perpinán", "W Wang" ],
      "venue" : "In AISTATS,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2014
    }, {
      "title" : "Recurrent batch normalization",
      "author" : [ "T. Cooijmans", "N. Ballas", "C. Laurent", "A. Courville" ],
      "venue" : "arXiv preprint arXiv:1603.09025,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2016
    }, {
      "title" : "Deep sparse rectifier neural networks",
      "author" : [ "X. Glorot", "A. Bordes", "Y. Bengio" ],
      "venue" : "In International Conference on Artificial Intelligence and Statistics,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2011
    }, {
      "title" : "Generating sequences with recurrent neural networks",
      "author" : [ "A. Graves" ],
      "venue" : "arXiv preprint arXiv:1308.0850,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2013
    }, {
      "title" : "Neural turing machines",
      "author" : [ "A. Graves", "G. Wayne", "I. Danihelka" ],
      "venue" : "arXiv preprint arXiv:1410.5401,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2014
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Sepp Hochreiter", "Jürgen Schmidhuber" ],
      "venue" : "Neural computation,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1997
    }, {
      "title" : "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
      "author" : [ "S. Ioffe", "C. Szegedy" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2015
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Diederik Kingma", "Jimmy Ba" ],
      "venue" : "arXiv preprint arXiv:1412.6980,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2014
    }, {
      "title" : "Learning multiple layers of features from tiny",
      "author" : [ "A. Krizhevsky", "G. Hinton" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2009
    }, {
      "title" : "Gradient-based learning applied to document recognition",
      "author" : [ "Y. LeCun", "L. Bottou", "Y. Bengio", "P. Haffner" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1998
    }, {
      "title" : "The mnist database of handwritten digits",
      "author" : [ "Y. LeCun", "C. Cortes", "C. Burges" ],
      "venue" : null,
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1998
    }, {
      "title" : "Difference target propagation",
      "author" : [ "D. Lee", "S. Zhang", "A. Fischer", "Y. Bengio" ],
      "venue" : "In Machine Learning and Knowledge Discovery in Databases,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2015
    }, {
      "title" : "Building a large annotated corpus of english: The penn treebank",
      "author" : [ "M.P. Marcus", "M.A. Marcinkiewicz", "B. Santorini" ],
      "venue" : "Computational linguistics,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1993
    }, {
      "title" : "Training recurrent networks online without backtracking",
      "author" : [ "Yann Ollivier", "Guillaume Charpiat" ],
      "venue" : "arXiv preprint arXiv:1507.07680,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2015
    }, {
      "title" : "Learning representations by back-propagating",
      "author" : [ "D.E. Rumelhart", "G.E. Hinton", "R.J. Williams" ],
      "venue" : "errors. Nature,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1986
    }, {
      "title" : "Training neural networks without gradients: A scalable admm approach",
      "author" : [ "G Taylor", "R Burmeister", "Z Xu", "B Singh", "A Patel", "T Goldstein" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2016
    }, {
      "title" : "Policy gradient coagent networks",
      "author" : [ "P.S. Thomas" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2011
    }, {
      "title" : "Simple statistical gradient-following algorithms for connectionist reinforcement learning",
      "author" : [ "R.J. Williams" ],
      "venue" : "Machine learning,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1992
    }, {
      "title" : "A learning algorithm for continually running fully recurrent neural networks",
      "author" : [ "R.J. Williams", "D. Zipser" ],
      "venue" : "Neural computation,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1989
    } ],
    "referenceMentions" : [ {
      "referenceID" : 17,
      "context" : "This process results in several forms of locking, namely: (i) Forward Locking – no module can process its incoming data before the previous nodes in the directed forward graph have executed; (ii) Update Locking – no module can be updated before all dependent modules have executed in forwards mode; also, in many credit-assignment algorithms (including backpropagation [18]) we have (iii) Backwards Locking – no module can be updated before all dependent modules have executed in both forwards mode and backwards mode.",
      "startOffset" : 369,
      "endOffset" : 373
    }, {
      "referenceID" : 1,
      "context" : "Our synthetic gradient model is most analogous to a value function which is used for gradient ascent [2] or a value function used for bootstrapping.",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 2,
      "context" : "target propagation [3, 15] removes the reliance on passing gradients between layers, by instead generating target activations which should be fitted to.",
      "startOffset" : 19,
      "endOffset" : 26
    }, {
      "referenceID" : 14,
      "context" : "target propagation [3, 15] removes the reliance on passing gradients between layers, by instead generating target activations which should be fitted to.",
      "startOffset" : 19,
      "endOffset" : 26
    }, {
      "referenceID" : 20,
      "context" : "REINFORCE [21] (considering all activations are actions), Kickback [1], and Policy Gradient Coagent Networks [20] – but still remain update locked since they require rewards to be generated by an output (or a global critic).",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 0,
      "context" : "REINFORCE [21] (considering all activations are actions), Kickback [1], and Policy Gradient Coagent Networks [20] – but still remain update locked since they require rewards to be generated by an output (or a global critic).",
      "startOffset" : 67,
      "endOffset" : 70
    }, {
      "referenceID" : 19,
      "context" : "REINFORCE [21] (considering all activations are actions), Kickback [1], and Policy Gradient Coagent Networks [20] – but still remain update locked since they require rewards to be generated by an output (or a global critic).",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 21,
      "context" : "While Real-Time Recurrent Learning [22] or approximations such as [17] may seem a promising way to remove update locking, these methods require maintaining the full (or approximate) gradient of the current state with respect to the parameters.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 16,
      "context" : "While Real-Time Recurrent Learning [22] or approximations such as [17] may seem a promising way to remove update locking, these methods require maintaining the full (or approximate) gradient of the current state with respect to the parameters.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 3,
      "context" : "Other works such as [4, 19] allow training of layers in parallel without backpropagation, but in practice are not scalable to more complex and generic network architectures.",
      "startOffset" : 20,
      "endOffset" : 27
    }, {
      "referenceID" : 18,
      "context" : "Other works such as [4, 19] allow training of layers in parallel without backpropagation, but in practice are not scalable to more complex and generic network architectures.",
      "startOffset" : 20,
      "endOffset" : 27
    }, {
      "referenceID" : 17,
      "context" : "Each layer fi has parameters θi that can be trained jointly to minimise L(hN ) with a gradient-based update rule θi ← θi − α δi ∂hi ∂θi ; δi = ∂L ∂hi (1) where α is the learning rate and ∂L ∂hi is computed with backpropagation [18].",
      "startOffset" : 227,
      "endOffset" : 231
    }, {
      "referenceID" : 21,
      "context" : "Note that the target gradient of the hidden state that is regressed to by the synthetic gradient model is slightly stale, a similar consequence of online training as seen in RTRL [22].",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 13,
      "context" : "Every layer DNI We first look at training an FCN for MNIST digit classification [14].",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 9,
      "context" : "For an FCN, “layer” refers to a linear transformation followed by batch-normalisation [10] and a rectified linear non-linearity (ReLU) [6].",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 5,
      "context" : "For an FCN, “layer” refers to a linear transformation followed by batch-normalisation [10] and a rectified linear non-linearity (ReLU) [6].",
      "startOffset" : 135,
      "endOffset" : 138
    }, {
      "referenceID" : 11,
      "context" : "We perform experiments where we vary the depth of the model (between 3 and 6 layers), on MNIST digit classification and CIFAR-10 object recognition [12].",
      "startOffset" : 148,
      "endOffset" : 152
    }, {
      "referenceID" : 12,
      "context" : "This framework can be easily applied to CNNs [13].",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 8,
      "context" : "For all experiments we use an LSTM [9] of the form in [7], whose output is used for the task at hand, and additionally as input to the synthetic gradient model (which is shared over all timesteps).",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 6,
      "context" : "For all experiments we use an LSTM [9] of the form in [7], whose output is used for the task at hand, and additionally as input to the synthetic gradient model (which is shared over all timesteps).",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 7,
      "context" : "Copy and Repeat Copy We first look at two synthetic tasks – Copy and Repeat Copy tasks from [8].",
      "startOffset" : 92,
      "endOffset" : 95
    } ],
    "year" : 2016,
    "abstractText" : "Training directed neural networks typically requires forward-propagating data through a computation graph, followed by backpropagating error signal, to produce weight updates. All layers, or more generally, modules, of the network are therefore locked, in the sense that they must wait for the remainder of the network to execute forwards and propagate error backwards before they can be updated. In this work we break this constraint by decoupling modules by introducing a model of the future computation of the network graph. These models predict what the result of the modelled subgraph will produce using only local information. In particular we focus on modelling error gradients: by using the modelled synthetic gradient in place of true backpropagated error gradients we decouple subgraphs, and can update them independently and asynchronously i.e. we realise decoupled neural interfaces. We show results for feed-forward models, where every layer is trained asynchronously, recurrent neural networks (RNNs) where predicting one’s future gradient extends the time over which the RNN can effectively model, and also a hierarchical RNN system with ticking at different timescales. Finally, we demonstrate that in addition to predicting gradients, the same framework can be used to predict inputs, resulting in models which are decoupled in both the forward and backwards pass – amounting to independent networks which co-learn such that they can be composed into a single functioning corporation.",
    "creator" : "LaTeX with hyperref package"
  }
}