{
  "name" : "1606.06900.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Inferring Logical Forms From Denotations",
    "authors" : [ "Panupong Pasupat", "Percy Liang" ],
    "emails" : [ "ppasupat@cs.stanford.edu", "pliang@cs.stanford.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Consider the task of learning to answer complex natural language questions (e.g., “Where did the last 1st place finish occur?”) using only question-answer pairs as supervision (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013). Semantic parsers map the question into a logical form (e.g., R[Venue].argmax(Position.1st, Index)) that can be executed on a knowledge source to obtain the answer (denotation). Logical forms are very expressive since they can be recursively composed, but this very expressivity makes it more\ndifficult to search over the space of logical forms. Previous work sidesteps this obstacle by restricting the set of possible logical form compositions, but this is limiting. For instance, for the system in Pasupat and Liang (2015), in only 53.5% of the examples was the correct logical form even in the set of generated logical forms.\nThe goal of this paper is to solve two main challenges that prevent us from generating more expressive logical forms. The first challenge is computational: the number of logical forms grows exponentially as their size increases. Directly enumerating over all logical forms becomes infeasible, and pruning techniques such as beam search can inadvertently prune out correct logical forms.\nThe second challenge is the large increase in spurious logical forms—those that do not reflect the semantics of the question but coincidentally execute to the correct denotation. For example, while logical forms z1, . . . , z5 in Figure 1 are all consistent (they execute to the correct answer y), the logical forms z4 and z5 are spurious and would give incorrect answers if the table were to change.\nWe address these two challenges by solving two interconnected tasks. The first task, which addresses the computational challenge, is to enumerate the set Z of all consistent logical forms given a question x, a knowledge source w (“world”), and the target denotation y (Section 4). Observing that the space of possible denotations grows much more slowly than the space of logical forms, we perform dynamic programming on denotations (DPD) to make search feasible. Our method is guaranteed to find all consistent logical forms up to some bounded size.\nGiven the set Z of consistent logical forms, the second task is to filter out spurious logical forms from Z (Section 5). Using the property that spurious logical forms ultimately give a wrong answer when the data in the world w changes, we create\nar X\niv :1\n60 6.\n06 90\n0v 1\n[ cs\n.C L\n] 2\n2 Ju\nn 20\n16\nfictitious worlds to test the denotations of the logical forms in Z. We use crowdsourcing to annotate the correct denotations on a subset of the generated worlds. To reduce the amount of annotation needed, we choose the subset that maximizes the expected information gain. The pruned set of logical forms would provide a stronger supervision signal for training a semantic parser.\nWe test our methods on the WIKITABLEQUESTIONS dataset of complex questions on Wikipedia tables. We define a simple, general set of deduction rules (Section 3), and use DPD to confirm that the rules generate a correct logical form in\n76% of the examples, up from the 53.5% in Pasupat and Liang (2015). Moreover, unlike beam search, DPD is guaranteed to find all consistent logical forms up to a bounded size. Finally, by using annotated data on fictitious worlds, we are able to prune out 92.1% of the spurious logical forms."
    }, {
      "heading" : "2 Setup",
      "text" : "The overarching motivation of this work is allowing people to ask questions involving computation on semi-structured knowledge sources such as tables from the Web. This section introduces how the knowledge source is represented, how the computation is carried out using logical forms, and our task of inferring correct logical forms.\nWorlds. We use the term world to refer to a collection of entities and relations between entities. One way to represent a world w is as a directed graph with nodes for entities and directed edges for relations. (For example, a world about geography would contain a node Europe with an edge Contains to another node Germany.)\nIn this paper, we use data tables from the Web as knowledge sources, such as the one in Figure 1. We follow the construction in Pasupat and Liang (2015) for converting a table into a directed graph (see Figure 2). Rows and cells become nodes (e.g., r0 = first row and Finland) while columns become labeled directed edges between them (e.g., Venue maps r1 to Finland). The graph is augmented with additional edges Next (from each\nrow to the next) and Index (from each row to its index number). In addition, we add normalization edges to cell nodes, including Number (from the cell to the first number in the cell), Num2 (the second number), Date (interpretation as a date), and Part (each list item if the cell represents a list). For example, a cell with content “3-4” has a Number edge to the integer 3, a Num2 edge to 4, and a Date edge to XX-03-04.\nLogical forms. We can perform computation on a world w using a logical form z, a small program that can be executed on the world, resulting in a denotation JzKw.\nWe use lambda DCS (Liang, 2013) as the language of logical forms. As a demonstration, we will use z1 in Figure 2 as an example. The smallest units of lambda DCS are entities (e.g., 1st) and relations (e.g., Position). Larger logical forms can be constructed using logical operations, and the denotation of the new logical form can be computed from denotations of its constituents. For example, applying the join operation on Position and 1st gives Position.1st, whose denotation is the set of entities with relation Position pointing to 1st. With the world in Figure 2, the denotation is JPosition.1stKw = {r1, r3}, which corresponds to the 2nd and 4th rows in the table. The partial logical form Position.1st is then used to construct argmax(Position.1st, Index), the denotation of which can be computed by mapping the entities in JPosition.1stKw = {r1, r3} using the relation Index ({r0 : 0, r1 : 1, . . . }), and then picking the one with the largest mapped value (r3, which is mapped to 3). The resulting logical form is finally combined with R[Venue] with another join operation. The relation R[Venue] is the reverse of Venue, which corresponds to traversing Venue edges in the reverse direction.\nSemantic parsing. A semantic parser maps a natural language utterance x (e.g., “Where did the last 1st place finish occur?”) into a logical form z. With denotations as supervision, a semantic parser is trained to put high probability on z’s that are consistent—logical forms that execute to the correct denotation y (e.g., Thailand). When the space of logical forms is large, searching for consistent logical forms z can become a challenge.\nAs illustrated in Figure 1, consistent logical forms can be divided into two groups: correct logical forms represent valid ways for computing the\nanswer, while spurious logical forms accidentally get the right answer for the wrong reasons (e.g., z4 picks the row with the maximum time but gets the correct answer anyway).\nTasks. Denote by Z and Zc the sets of all consistent and correct logical forms, respectively. The first task is to efficiently compute Z given an utterance x, a world w, and the correct denotation y (Section 4). With the set Z, the second task is to infer Zc by pruning spurious logical forms from Z (Section 5)."
    }, {
      "heading" : "3 Deduction rules",
      "text" : "The space of logical forms given an utterance x and a world w is defined recursively by a set of deduction rules (Table 1). In this setting, each constructed logical form belongs to a category (Set, Rel, or Map). These categories are used for type checking in a similar fashion to categories in syntactic parsing. Each deduction rule specifies the categories of the arguments, category of the resulting logical form, and how the logical form is constructed from the arguments.\nDeduction rules are divided into base rules and compositional rules. A base rule follows one of the following templates:\nTokenSpan[span]→ c [f(span)] (1) ∅ → c [f()] (2)\nA rule of Template 1 is triggered by a span of tokens from x (e.g., to construct z1 in Figure 2 from x in Figure 1, Rule B1 from Table 1 constructs 1st of category Set from the phrase “1st”). Meanwhile, a rule of Template 2 generates a logical form without any trigger (e.g., Rule B5 generates Position of category Rel from the graph edge Position without a specific trigger in x).\nCompositional rules then construct larger logical forms from smaller ones:\nc1 [z1] + c2 [z2]→ c [g(z1, z2)] (3) c1 [z1]→ c [g(z1)] (4)\nA rule of Template 3 combines partial logical forms z1 and z2 of categories c1 and c2 into g(z1, z2) of category c (e.g., Rule C1 uses 1st of category Set and Position of category Rel to construct Position.1st of category Set). Template 4 works similarly.\nMost rules construct logical forms without requiring a trigger from the utterance x. This is\ncrucial for generating implicit relations (e.g., generating Year from “what’s the venue in 2000?” without a trigger “year”), and generating operations without a lexicon (e.g., generating argmax from “where’s the longest competition”). However, the downside is that the space of possible logical forms becomes very large.\nThe Map category. The technique in this paper requires execution of partial logical forms. This poses a challenge for argmin and argmax operations, which take a set and a binary relation as arguments. The binary could be a complex function (e.g., in z3 from Figure 1). While it is possible to build the binary independently from the set, executing a complex binary is sometimes impossible (e.g., the denotation of λx.count(x) is impossible to write explicitly without knowledge of x).\nWe address this challenge with the Map category. A Map is a pair (u, b) of a finite set u (unary) and a binary relation b. The denotation of (u, b) is (JuKw, JbK′w) where the binary JbK′w is JbKw with the domain restricted to the set JuKw. For example, consider the construction of argmax(Position.1st, Index). After constructing Position.1st with denotation {r1, r3}, Rule M1 initializes (Position.1st, x) with denotation ({r1, r3}, {r1 : {r1}, r3 : {r3}}). Rule M2 is then applied to generate (Position.1st,R[Index].x) with denotation ({r1, r3}, {r1 : {1}, r3 : {3}}). Finally, Rule M6 converts the Map into the desired argmax logical form with denotation {r3}.\nGenerality of deduction rules. Using domain knowledge, previous work restricted the space of logical forms by manually defining the categories c or the semantic functions f and g to fit the domain. For example, the category Set might be divided into Records, Values, and Atomic when the knowledge source is a table (Pasupat and Liang, 2015). Another example is when a compositional rule g (e.g., sum(z1)) must be triggered by some phrase in a lexicon (e.g., words like “total” that align to sum in the training data). Such restrictions make search more tractable but greatly limit the scope of questions that can be answered.\nHere, we have increased the coverage of logical forms by making the deduction rules simple and general, essentially following the syntax of lambda DCS. The base rules only generates entities that approximately match the utterance, but all possible relations, and all possible further combinations.\nBeam search. Given the deduction rules, an utterance x and a worldw, we would like to generate all derived logical forms Z. We first present the floating parser (Pasupat and Liang, 2015), which uses beam search to generate Zb ⊆ Z, a usually incomplete subset. Intuitively, the algorithm first constructs base logical forms based on spans of the utterance, and then builds larger logical forms of increasing size in a “floating” fashion—without requiring a trigger from the utterance.\nFormally, partial logical forms with category c and size s are stored in a cell (c, s). The algorithm first generates base logical forms from base deduction rules and store them in cells (c, 0) (e.g., the cell (Set, 0) contains 1st, Type.Row, and so on). Then for each size s = 1, . . . , smax, we populate\nthe cells (c, s) by applying compositional rules on partial logical forms with size less than s. For instance, when s = 2, we can apply Rule C1 on logical forms Number.1 from cell (Set, s1 = 1) and Position from cell (Rel, s2 = 0) to create Position.Number.1 in cell (Set, s0+s1+1 = 2). After populating each cell (c, s), the list of logical forms in the cell is pruned based on the model scores to a fixed beam size in order to control the search space. Finally, the set Zb is formed by collecting logical forms from all cells (Set, s) for s = 1, . . . , smax.\nDue to the generality of our deduction rules, the number of logical forms grows quickly as the size s increases. As such, partial logical forms that are essential for building the desired logical forms might fall off the beam early on. In the next section, we present a new search method that compresses the search space using denotations."
    }, {
      "heading" : "4 Dynamic programming on denotations",
      "text" : "Our first step toward finding all correct logical forms is to represent all consistent logical forms (those that execute to the correct denotation). Formally, given x, w, and y, we wish to generate the set Z of all logical forms z such that JzKw = y.\nAs mentioned in the previous section, beam search does not recover the full set Z due to pruning. Our key observation is that while the number of logical forms explodes, the number of distinct denotations of those logical forms is much more controlled, as multiple logical forms can share the same denotation. So instead of directly enumerating logical forms, we use dynamic programming on denotations (DPD), which is inspired by similar methods from program induction (Lau et al.,\n2003; Liang et al., 2010; Gulwani, 2011). The main idea of DPD is to collapse logical forms with the same denotation together. Instead of using cells (c, s) as in beam search, we perform dynamic programming using cells (c, s, d) where d is a denotation. For instance, the logical form Position.Number.1 will now be stored in cell (Set, 2, {r1, r3}).\nFor DPD to work, each deduction rule must have a denotationally invariant semantic function g, meaning that the denotation of the resulting logical form g(z1, z2) only depends on the denotations of z1 and z2:\nJz1Kw = Jz′1Kw ∧ Jz2Kw = Jz′2Kw ⇒ Jg(z1, z2)Kw = Jg(z′1, z′2)Kw\nAll of our deduction rules in Table 1 are denotationally invariant, but a rule that, for instance, returns the argument with the larger logical form size would not be. Applying a denotationally invariant deduction rule on any pair of logical forms from (c1, s1, d1) and (c2, s2, d2) always results in a logical form with the same denotation d in the same cell (c, s1 + s2 + 1, d).1 (For example, the cell (Set, 4, {r3}) contains z1 := argmax(Position.1st, Index) and z′1 := argmin(Event.Relay, Index). Combining each of these with Venue using Rule C1 gives R[Venue].z1 and R[Venue].z′1, which belong to the same cell (Set, 5, {Thailand})).\nAlgorithm. DPD proceeds in two forward passes. The first pass finds the possible combinations of cells (c, s, d) that lead to the correct denotation y, while the second pass enumerates the logical forms in the cells found in the first pass. Figure 3 illustrates the DPD algorithm.\nIn the first pass, we are only concerned about finding relevant cell combinations and not the actual logical forms. Therefore, any logical form that belongs to a cell could be used as an argument of a deduction rule to generate further logical forms. Thus, we keep at most one logical form per cell; subsequent logical forms that are generated for that cell are discarded.\nAfter populating all cells up to size smax, we list all cells (Set, s, y) with the correct denotation y, and then note all possible rule combinations (cell1, rule) or (cell1, cell2, rule) that lead to those\n1Semantic functions f with one argument work similarly.\nfinal cells, including the combinations that yielded discarded logical forms.\nThe second pass retrieves the actual logical forms that yield the correct denotation. To do this, we simply populate the cells (c, s, d) with all logical forms, using only rule combinations that lead to final cells. This elimination of irrelevant rule combinations effectively reduces the search space. (In Section 6.2, we empirically show that the number of cells considered is reduced by 98.7%.)\nThe parsing chart is represented as a hypergraph as in Figure 3. After eliminating unused rule combinations, each of the remaining hyperpaths from base predicates to the target denotation corresponds to a single logical form. making the remaining parsing chart a compact implicit representation of all consistent logical forms. This representation is guaranteed to cover all possible logical forms under the size limit smax that can be constructed by the deduction rules.\nIn our experiments, we apply DPD on the deduction rules in Table 1 and explicitly enumerate the logical forms produced by the second pass. For efficiency, we prune logical forms that are clearly redundant (e.g., applying max on a set of size 1). We also restrict a few rules that might otherwise create too many denotations. For example, we restricted the union operation (t) except unions of two entities (e.g., we allow Germany t Finland but not Venue.Hungary t . . . ), subtraction when building a Map, and count on a set of size 1.2"
    }, {
      "heading" : "5 Fictitious worlds",
      "text" : "After finding the set Z of all consistent logical forms, we want to filter out spurious logical forms. To do so, we observe that semantically correct logical forms should also give the correct denotation in worlds w′ other than than w. In contrast, spurious logical forms will fail to produce the correct denotation on some other world.\nGenerating fictitious worlds. With the observation above, we generate fictitious worlds w1, w2, . . . , where each world wi is a slight alteration of w. As we will be executing logical forms z ∈ Z on wi, we should ensure that all entities and relations in z ∈ Z appear in the fictitious world wi (e.g., z1 in Figure 1 would be meaningless if the entity 1st does not appear in wi). To this end, we\n2While we technically can apply count on sets of size 1, the number of spurious logical forms explodes as there are too many sets of size 1 generated.\nimpose that all predicates present in the original world w should also be present in wi as well.\nIn our case where the world w comes from a data table t, we construct wi from a new table ti as follows: we go through each column of t and resample the cells in that column. The cells are sampled using random draws without replacement if the original cells are all distinct, and with replacement otherwise. Sorted columns are kept sorted. To ensure that predicates in w exist in wi, we use the same set of table columns and enforce that any entity fuzzily matching a span in the question x must be present in ti (e.g., for the example in Figure 1, the generated ti must contain “1st”). Figure 4 shows an example fictitious table generated from the table in Figure 1.\nFictitious worlds are similar to test suites for computer programs. However, unlike manually designed test suites, we do not yet know the correct answer for each fictitious world or whether a world is helpful for filtering out spurious logical forms. The next subsections introduce our method for choosing a subset of useful fictitious worlds to be annotated.\nEquivalence classes. Let W = (w1, . . . , wk) be the list of all possible fictitious worlds. For each z ∈ Z, we define the denotation tuple JzKW = (JzKw1 , . . . , JzKwk). We observe that some logical forms produce the same denotation across all\nfictitious worlds. This may be due to an algebraic equivalence in logical forms (e.g., z1 and z2 in Figure 1) or due to the constraints in the construction of fictitious worlds (e.g., z1 and z3 in Figure 1 are equivalent as long as the Year column is sorted). We group logical forms into equivalence classes based on their denotation tuples, as illustrated in Figure 5. When the question is unambiguous, we expect at most one equivalence class to contain correct logical forms.\nAnnotation. To pin down the correct equivalence class, we acquire the correct answers to the question x on some subset W ′ = (w′1, . . . , w ′ `) ⊆ W of ` fictitious worlds, as it is impractical to obtain annotations on all fictitious worlds in W . We compile equivalence classes that agree with the annotations into a set Zc of correct logical forms.\nWe want to choose W ′ that gives us the most information about the correct equivalence class as possible. This is analogous to standard practices in active learning (Settles, 2010).3 Let Q be the set of all equivalence classes q, and let JqKW ′ be the denotation tuple computed by executing an arbitrary z ∈ q on W ′. The subset W ′ divides Q into partitions Ft = {q ∈ Q : JqKW ′ = t} based on the denotation tuples t (e.g., from Figure 5, if W ′ contains just w2, then q2 and q3 will be in the same partition F(China)). The annotation t∗, which is also a denotation tuple, will mark one of these partitions Ft∗ as correct. Thus, to prune out many spurious equivalence classes, the partitions should be as numerous and as small as possible.\nMore formally, we choose a subset W ′ that maximizes the expected information gain (or equivalently, the reduction in entropy) about the correct equivalence class given the annotation. With random variables Q ∈ Q representing the correct equivalence class and T ∗W ′ for the annotation on worlds W ′, we seek to find argminW ′ H(Q | T ∗W ′). Assuming a uniform prior on Q (p(q) = 1/|Q|) and accurate annotation (p(t∗ | q) = I[q ∈ Ft∗ ]):\nH(Q | T ∗W ′) = ∑ q,t p(q, t) log p(t) p(q, t)\n= 1 |Q| ∑ t |Ft| log |Ft|. (*)\n3 The difference is that we are obtaining partial information about an individual example rather than partial information about the parameters.\nWe exhaustively search for W ′ that minimizes (*). The objective value follows our intuition since∑\nt |Ft| log |Ft| is small when the terms |Ft| are small and numerous.\nIn our experiments, we approximate the full set W of fictitious worlds by generating k = 30 worlds to compute equivalence classes. We choose a subset of ` = 5 worlds to be annotated."
    }, {
      "heading" : "6 Experiments",
      "text" : "For the experiments, we use the training portion of the WIKITABLEQUESTIONS dataset (Pasupat and Liang, 2015), which consists of 14,152 questions on 1,679 Wikipedia tables gathered by crowd workers. Answering these complex questions requires different types of operations. The same operation can be phrased in different ways (e.g., “best”, “top ranking”, or “lowest ranking number”) and the interpretation of some phrases depend on the context (e.g., “number of ” could be a table lookup or a count operation). The lexical content of the questions is also quite diverse: even excluding numbers and symbols, the 14,152 training examples contain 9,671 unique words, only 10% of which appear more than 10 times.\nWe attempted to manually annotate the first 300 examples with lambda DCS logical forms. We successfully constructed correct logical forms for 84% of these examples, which is a good number considering the questions were created by humans who could use the table however they wanted. The remaining 16% reflect limitations in our setup— for example, non-canonical table layouts, answers appearing in running text or images, and common sense reasoning (e.g., knowing that “Quarterfinal” is better than “Round of 16”)."
    }, {
      "heading" : "6.1 Generality of deduction rules",
      "text" : "We compare our set of deduction rules with the one given in Pasupat and Liang (2015) (henceforth PL15). PL15 reported generating the annotated logical form in 53.5% of the first 200 examples. With our more general deduction rules, we use DPD to verify that the rules are able to generate the annotated logical form in 76% of the first 300 examples, within the logical form size limit smax of 7. This is 90.5% of the examples that were successfully annotated. Figure 6 shows some examples of logical forms we cover that PL15 could not. Since DPD is guaranteed to find all consistent logical forms, we can be sure that the logical\nforms not covered are due to limitations of the deduction rules. Indeed, the remaining examples either have logical forms with size larger than 7 or require other operations such as addition, union of arbitrary sets, etc."
    }, {
      "heading" : "6.2 Dynamic programming on denotations",
      "text" : "Search space. To demonstrate the savings gained by collapsing logical forms with the same denotation, we track the growth of the number of unique logical forms and denotations as the logical form size increases. The plot in Figure 7 shows that the space of logical forms explodes much more quickly than the space of denotations.\nThe use of denotations also saves us from considering a significant amount of irrelevant partial logical forms. On average over 14,152 training examples, DPD generates approximately 25,000 consistent logical forms. The first pass of DPD generates ≈ 153,000 cells (c, s, d), while the second pass generates only ≈ 2,000 cells resulting from ≈ 8,000 rule combinations, resulting in a 98.7% reduction in the number of cells that have to be considered.\nComparison with beam search. We compare DPD to beam search on the ability to generate (but not rank) the annotated logical forms. We consider two settings: when the beam search parameters are uninitialized (i.e., the beams are pruned randomly), and when the parameters are trained using the system from PL15 (i.e., the beams are pruned based on model scores). The plot in Figure 8 shows that DPD generates more annotated logical forms (76%) compared to beam search (53.7%), even when beam search is guided heuristically by learned parameters. Note that DPD is an exact algorithm and does not require a heuristic."
    }, {
      "heading" : "6.3 Fictitious worlds",
      "text" : "We now explore how fictitious worlds divide the set of logical forms into equivalence classes, and how the annotated denotations on the chosen worlds help us prune spurious logical forms.\nEquivalence classes. Using 30 fictitious worlds per example, we produce an average of 1,237 equivalence classes. One possible concern with using a limited number of fictitious worlds is that we may fail to distinguish some pairs of nonequivalent logical forms. We verify the equivalence classes against the ones computed using 300 fictitious worlds. We found that only 5% of the logical forms are split from the original equivalence classes.\nIdeal Annotation. After computing equivalence classes, we choose a subset W ′ of 5 fictitious worlds to be annotated based on the informationtheoretic objective. For each of the 252 examples with an annotated logical form z∗, we use the denotation tuple t∗ = Jz∗KW ′ as the annotated answers on the chosen fictitious worlds. We are able to rule out 98.7% of the spurious equivalence classes and 98.3% of spurious logical forms. Furthermore, we are able to filter down to just one equivalence class in 32.7% of the examples, and\nat most three equivalence classes in 51.3% of the examples. If we choose 5 fictitious worlds randomly instead of maximizing information gain, then the above statistics are 22.6% and 36.5%, respectively. When more than one equivalence classes remain, usually only one class is a dominant class with many equivalent logical forms, while other classes are small and contain logical forms with unusual patterns (e.g., z5 in Figure 1).\nThe average size of the correct equivalence class is ≈ 3,000 with the standard deviation of ≈ 8,000. Because we have an expressive logical language, there are fundamentally many equivalent ways of computing the same quantity.\nCrowdsourced Annotation. Data from crowdsourcing is more susceptible to errors. From the 252 annotated examples, we use 177 examples where at least two crowd workers agree on the answer of the original world w. When the crowdsourced data is used to rule out spurious logical forms, the entire set Z of consistent logical forms is pruned out in 11.3% of the examples, and the correct equivalent class is removed in 9% of the examples. These issues are due to annotation errors, inconsistent data (e.g., having date of death before birth date), and different interpretations of the question on the fictitious worlds. For the remaining examples, we are able to prune out 92.1% of spurious logical forms (or 92.6% of spurious equivalence classes).\nTo prevent the entire Z from being pruned, we can relax our assumption and keep logical forms z that disagree with the annotation in at most 1 fictitious world. The number of times Z is pruned out is reduced to 3%, but the number of spurious logical forms pruned also decreases to 78%."
    }, {
      "heading" : "7 Related Work and Discussion",
      "text" : "This work evolved from a long tradition of learning executable semantic parsers, initially from annotated logical forms (Zelle and Mooney, 1996; Kate et al., 2005; Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Kwiatkowski et al., 2010), but more recently from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Kwiatkowski et al., 2013; Pasupat and Liang, 2015). A central challenge in learning from denotations is finding consistent logical forms (those that execute to a given denotation).\nAs Kwiatkowski et al. (2013) and Berant and Liang (2014) both noted, a chief difficulty\nwith executable semantic parsing is the “schema mismatch”—words in the utterance do not map cleanly onto the predicates in the logical form. This mismatch is especially pronounced in the WIKITABLEQUESTIONS of Pasupat and Liang (2015). In the second example of Figure 6, “how long” is realized by a logical form that computes a difference between two dates. The ramification of this mismatch is that finding consistent logical forms cannot solely proceed from the language side. This paper is about using annotated denotations to drive the search over logical forms.\nThis takes us into the realm of program induction, where the goal is to infer a program (logical form) from input-output pairs (for us, world-denotation pairs). Here, previous work has also leveraged the idea of dynamic programming on denotations (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011), though for more constrained spaces of programs. Continuing the program analogy, generating fictitious worlds is similar in spirit to fuzz testing for generating new test cases (Miller et al., 1990), but the goal there is coverage in a single program rather than identifying the correct (equivalence class of) programs. This connection can potentially improve the flow of ideas between the two fields.\nFinally, the effectiveness of dynamic programming on denotations relies on having a manageable set of denotations. For more complex logical forms and larger knowledge graphs, there are many possible angles worth exploring: performing abstract interpretation to collapse denotations into equivalence classes (Cousot and Cousot, 1977), relaxing the notion of getting the correct denotation (Steinhardt and Liang, 2015), or working in a continuous space and relying on gradient descent (Guu et al., 2015; Neelakantan et al., 2016; Yin et al., 2016; Reed and de Freitas, 2016). This paper, by virtue of exact dynamic programming, sets the standard.\nAcknowledgments. We gratefully acknowledge the support of the Google Natural Language Understanding Focused Program. In addition, we would like to thank anonymous reviewers for their helpful comments.\nReproducibility. Code and experiments for this paper are available on the CodaLab platform at https://worksheets.codalab.org/worksheets/ 0x47cc64d9c8ba4a878807c7c35bb22a42/."
    } ],
    "references" : [ {
      "title" : "UW SPF: The University of Washington semantic parsing framework",
      "author" : [ "Artzi", "Zettlemoyer2013] Y. Artzi", "L. Zettlemoyer" ],
      "venue" : "arXiv preprint arXiv:1311.3011",
      "citeRegEx" : "Artzi et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Artzi et al\\.",
      "year" : 2013
    }, {
      "title" : "Semantic parsing via paraphrasing. In Association for Computational Linguistics (ACL)",
      "author" : [ "Berant", "Liang2014] J. Berant", "P. Liang" ],
      "venue" : null,
      "citeRegEx" : "Berant et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Berant et al\\.",
      "year" : 2014
    }, {
      "title" : "Semantic parsing on Freebase from question-answer pairs. In Empirical Methods in Natural Language Processing (EMNLP)",
      "author" : [ "Berant et al.2013] J. Berant", "A. Chou", "R. Frostig", "P. Liang" ],
      "venue" : null,
      "citeRegEx" : "Berant et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Berant et al\\.",
      "year" : 2013
    }, {
      "title" : "Driving semantic parsing from the world’s response",
      "author" : [ "Clarke et al.2010] J. Clarke", "D. Goldwasser", "M. Chang", "D. Roth" ],
      "venue" : "In Computational Natural Language Learning (CoNLL),",
      "citeRegEx" : "Clarke et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Clarke et al\\.",
      "year" : 2010
    }, {
      "title" : "Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints",
      "author" : [ "Cousot", "Cousot1977] P. Cousot", "R. Cousot" ],
      "venue" : "In Principles of Programming Languages (POPL),",
      "citeRegEx" : "Cousot et al\\.,? \\Q1977\\E",
      "shortCiteRegEx" : "Cousot et al\\.",
      "year" : 1977
    }, {
      "title" : "Automating string processing in spreadsheets using input-output examples",
      "author" : [ "S. Gulwani" ],
      "venue" : "ACM SIGPLAN Notices,",
      "citeRegEx" : "Gulwani.,? \\Q2011\\E",
      "shortCiteRegEx" : "Gulwani.",
      "year" : 2011
    }, {
      "title" : "Traversing knowledge graphs in vector space. In Empirical Methods in Natural Language Processing (EMNLP)",
      "author" : [ "Guu et al.2015] K. Guu", "J. Miller", "P. Liang" ],
      "venue" : null,
      "citeRegEx" : "Guu et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Guu et al\\.",
      "year" : 2015
    }, {
      "title" : "Learning to transform natural to formal languages",
      "author" : [ "Kate et al.2005] R.J. Kate", "Y.W. Wong", "R.J. Mooney" ],
      "venue" : "In Association for the Advancement of Artificial Intelligence (AAAI),",
      "citeRegEx" : "Kate et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Kate et al\\.",
      "year" : 2005
    }, {
      "title" : "Inducing probabilistic CCG grammars from logical form with higher-order unification",
      "author" : [ "L. Zettlemoyer", "S. Goldwater", "M. Steedman" ],
      "venue" : "In Empirical Methods in Natural Language Processing",
      "citeRegEx" : "Kwiatkowski et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kwiatkowski et al\\.",
      "year" : 2010
    }, {
      "title" : "Scaling semantic parsers with on-the-fly ontology matching",
      "author" : [ "E. Choi", "Y. Artzi", "L. Zettlemoyer" ],
      "venue" : "In Empirical Methods in Natural Language Processing (EMNLP)",
      "citeRegEx" : "Kwiatkowski et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Kwiatkowski et al\\.",
      "year" : 2013
    }, {
      "title" : "Programming by demonstration using version space algebra",
      "author" : [ "T. Lau", "S. Wolfman", "P. Domingos", "D.S. Weld" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Lau et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Lau et al\\.",
      "year" : 2003
    }, {
      "title" : "Learning programs: A hierarchical Bayesian approach",
      "author" : [ "Liang et al.2010] P. Liang", "M.I. Jordan", "D. Klein" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Liang et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Liang et al\\.",
      "year" : 2010
    }, {
      "title" : "Learning dependency-based compositional semantics",
      "author" : [ "Liang et al.2011] P. Liang", "M.I. Jordan", "D. Klein" ],
      "venue" : "In Association for Computational Linguistics (ACL),",
      "citeRegEx" : "Liang et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Liang et al\\.",
      "year" : 2011
    }, {
      "title" : "Lambda dependencybased compositional semantics. arXiv",
      "author" : [ "P. Liang" ],
      "venue" : null,
      "citeRegEx" : "Liang.,? \\Q2013\\E",
      "shortCiteRegEx" : "Liang.",
      "year" : 2013
    }, {
      "title" : "An empirical study of the reliability of UNIX utilities",
      "author" : [ "B.P. Miller", "L. Fredriksen", "B. So" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "Miller et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "Miller et al\\.",
      "year" : 1990
    }, {
      "title" : "Neural programmer: Inducing latent programs with gradient descent",
      "author" : [ "Q.V. Le", "I. Sutskever" ],
      "venue" : "In International Conference on Learning Representations (ICLR)",
      "citeRegEx" : "Neelakantan et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Neelakantan et al\\.",
      "year" : 2016
    }, {
      "title" : "Compositional semantic parsing on semistructured tables. In Association for Computational Linguistics (ACL)",
      "author" : [ "Pasupat", "Liang2015] P. Pasupat", "P. Liang" ],
      "venue" : null,
      "citeRegEx" : "Pasupat et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Pasupat et al\\.",
      "year" : 2015
    }, {
      "title" : "Neural programmer-interpreters",
      "author" : [ "Reed", "de Freitas2016] S. Reed", "N. de Freitas" ],
      "venue" : "In International Conference on Learning Representations (ICLR)",
      "citeRegEx" : "Reed et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Reed et al\\.",
      "year" : 2016
    }, {
      "title" : "Active learning literature survey",
      "author" : [ "B. Settles" ],
      "venue" : "Technical report,",
      "citeRegEx" : "Settles.,? \\Q2010\\E",
      "shortCiteRegEx" : "Settles.",
      "year" : 2010
    }, {
      "title" : "Learning with relaxed supervision",
      "author" : [ "Steinhardt", "Liang2015] J. Steinhardt", "P. Liang" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS)",
      "citeRegEx" : "Steinhardt et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Steinhardt et al\\.",
      "year" : 2015
    }, {
      "title" : "Neural enquirer: Learning to query tables with natural language. arXiv",
      "author" : [ "Yin et al.2016] P. Yin", "Z. Lu", "H. Li", "B. Kao" ],
      "venue" : null,
      "citeRegEx" : "Yin et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Yin et al\\.",
      "year" : 2016
    }, {
      "title" : "Learning to parse database queries using inductive logic programming",
      "author" : [ "Zelle", "Mooney1996] M. Zelle", "R.J. Mooney" ],
      "venue" : "In Association for the Advancement of Artificial Intelligence (AAAI),",
      "citeRegEx" : "Zelle et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Zelle et al\\.",
      "year" : 1996
    }, {
      "title" : "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars",
      "author" : [ "Zettlemoyer", "Collins2005] L.S. Zettlemoyer", "M. Collins" ],
      "venue" : "In Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "Zettlemoyer et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Zettlemoyer et al\\.",
      "year" : 2005
    }, {
      "title" : "Online learning of relaxed CCG grammars for parsing to logical form",
      "author" : [ "Zettlemoyer", "Collins2007] L.S. Zettlemoyer", "M. Collins" ],
      "venue" : "In Empirical Methods in Natural Language Processing and Computational Natural Language Learning",
      "citeRegEx" : "Zettlemoyer et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Zettlemoyer et al\\.",
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : ", “Where did the last 1st place finish occur?”) using only question-answer pairs as supervision (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013).",
      "startOffset" : 96,
      "endOffset" : 187
    }, {
      "referenceID" : 12,
      "context" : ", “Where did the last 1st place finish occur?”) using only question-answer pairs as supervision (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013).",
      "startOffset" : 96,
      "endOffset" : 187
    }, {
      "referenceID" : 2,
      "context" : ", “Where did the last 1st place finish occur?”) using only question-answer pairs as supervision (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013).",
      "startOffset" : 96,
      "endOffset" : 187
    }, {
      "referenceID" : 1,
      "context" : ", 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013). Semantic parsers map the question into a logical form (e.g., R[Venue].argmax(Position.1st, Index)) that can be executed on a knowledge source to obtain the answer (denotation). Logical forms are very expressive since they can be recursively composed, but this very expressivity makes it more difficult to search over the space of logical forms. Previous work sidesteps this obstacle by restricting the set of possible logical form compositions, but this is limiting. For instance, for the system in Pasupat and Liang (2015), in only 53.",
      "startOffset" : 8,
      "endOffset" : 583
    }, {
      "referenceID" : 13,
      "context" : "5% in Pasupat and Liang (2015). Moreover, unlike beam search, DPD is guaranteed to find all consistent logical forms up to a bounded size.",
      "startOffset" : 18,
      "endOffset" : 31
    }, {
      "referenceID" : 13,
      "context" : "We follow the construction in Pasupat and Liang (2015) for converting a table into a directed graph (see Figure 2).",
      "startOffset" : 42,
      "endOffset" : 55
    }, {
      "referenceID" : 13,
      "context" : "We use lambda DCS (Liang, 2013) as the language of logical forms.",
      "startOffset" : 18,
      "endOffset" : 31
    }, {
      "referenceID" : 10,
      "context" : "So instead of directly enumerating logical forms, we use dynamic programming on denotations (DPD), which is inspired by similar methods from program induction (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011).",
      "startOffset" : 159,
      "endOffset" : 212
    }, {
      "referenceID" : 11,
      "context" : "So instead of directly enumerating logical forms, we use dynamic programming on denotations (DPD), which is inspired by similar methods from program induction (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011).",
      "startOffset" : 159,
      "endOffset" : 212
    }, {
      "referenceID" : 5,
      "context" : "So instead of directly enumerating logical forms, we use dynamic programming on denotations (DPD), which is inspired by similar methods from program induction (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011).",
      "startOffset" : 159,
      "endOffset" : 212
    }, {
      "referenceID" : 18,
      "context" : "This is analogous to standard practices in active learning (Settles, 2010).",
      "startOffset" : 59,
      "endOffset" : 74
    }, {
      "referenceID" : 13,
      "context" : "We compare our set of deduction rules with the one given in Pasupat and Liang (2015) (henceforth PL15).",
      "startOffset" : 72,
      "endOffset" : 85
    }, {
      "referenceID" : 7,
      "context" : "This work evolved from a long tradition of learning executable semantic parsers, initially from annotated logical forms (Zelle and Mooney, 1996; Kate et al., 2005; Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Kwiatkowski et al., 2010), but more recently from denotations (Clarke et al.",
      "startOffset" : 120,
      "endOffset" : 251
    }, {
      "referenceID" : 8,
      "context" : "This work evolved from a long tradition of learning executable semantic parsers, initially from annotated logical forms (Zelle and Mooney, 1996; Kate et al., 2005; Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Kwiatkowski et al., 2010), but more recently from denotations (Clarke et al.",
      "startOffset" : 120,
      "endOffset" : 251
    }, {
      "referenceID" : 3,
      "context" : ", 2010), but more recently from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Kwiatkowski et al., 2013; Pasupat and Liang, 2015).",
      "startOffset" : 44,
      "endOffset" : 157
    }, {
      "referenceID" : 12,
      "context" : ", 2010), but more recently from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Kwiatkowski et al., 2013; Pasupat and Liang, 2015).",
      "startOffset" : 44,
      "endOffset" : 157
    }, {
      "referenceID" : 2,
      "context" : ", 2010), but more recently from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Kwiatkowski et al., 2013; Pasupat and Liang, 2015).",
      "startOffset" : 44,
      "endOffset" : 157
    }, {
      "referenceID" : 9,
      "context" : ", 2010), but more recently from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Kwiatkowski et al., 2013; Pasupat and Liang, 2015).",
      "startOffset" : 44,
      "endOffset" : 157
    }, {
      "referenceID" : 8,
      "context" : "As Kwiatkowski et al. (2013) and Berant and Liang (2014) both noted, a chief difficulty with executable semantic parsing is the “schema mismatch”—words in the utterance do not map cleanly onto the predicates in the logical form.",
      "startOffset" : 3,
      "endOffset" : 29
    }, {
      "referenceID" : 8,
      "context" : "As Kwiatkowski et al. (2013) and Berant and Liang (2014) both noted, a chief difficulty with executable semantic parsing is the “schema mismatch”—words in the utterance do not map cleanly onto the predicates in the logical form.",
      "startOffset" : 3,
      "endOffset" : 57
    }, {
      "referenceID" : 8,
      "context" : "As Kwiatkowski et al. (2013) and Berant and Liang (2014) both noted, a chief difficulty with executable semantic parsing is the “schema mismatch”—words in the utterance do not map cleanly onto the predicates in the logical form. This mismatch is especially pronounced in the WIKITABLEQUESTIONS of Pasupat and Liang (2015). In the second example of Figure 6, “how long” is realized by a logical form that computes a difference between two dates.",
      "startOffset" : 3,
      "endOffset" : 322
    }, {
      "referenceID" : 10,
      "context" : "Here, previous work has also leveraged the idea of dynamic programming on denotations (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011), though for more constrained spaces of programs.",
      "startOffset" : 86,
      "endOffset" : 139
    }, {
      "referenceID" : 11,
      "context" : "Here, previous work has also leveraged the idea of dynamic programming on denotations (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011), though for more constrained spaces of programs.",
      "startOffset" : 86,
      "endOffset" : 139
    }, {
      "referenceID" : 5,
      "context" : "Here, previous work has also leveraged the idea of dynamic programming on denotations (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011), though for more constrained spaces of programs.",
      "startOffset" : 86,
      "endOffset" : 139
    }, {
      "referenceID" : 14,
      "context" : "Continuing the program analogy, generating fictitious worlds is similar in spirit to fuzz testing for generating new test cases (Miller et al., 1990), but the goal there is coverage in a single program rather than identifying the correct (equivalence class of) programs.",
      "startOffset" : 128,
      "endOffset" : 149
    }, {
      "referenceID" : 6,
      "context" : "For more complex logical forms and larger knowledge graphs, there are many possible angles worth exploring: performing abstract interpretation to collapse denotations into equivalence classes (Cousot and Cousot, 1977), relaxing the notion of getting the correct denotation (Steinhardt and Liang, 2015), or working in a continuous space and relying on gradient descent (Guu et al., 2015; Neelakantan et al., 2016; Yin et al., 2016; Reed and de Freitas, 2016).",
      "startOffset" : 368,
      "endOffset" : 457
    }, {
      "referenceID" : 15,
      "context" : "For more complex logical forms and larger knowledge graphs, there are many possible angles worth exploring: performing abstract interpretation to collapse denotations into equivalence classes (Cousot and Cousot, 1977), relaxing the notion of getting the correct denotation (Steinhardt and Liang, 2015), or working in a continuous space and relying on gradient descent (Guu et al., 2015; Neelakantan et al., 2016; Yin et al., 2016; Reed and de Freitas, 2016).",
      "startOffset" : 368,
      "endOffset" : 457
    }, {
      "referenceID" : 20,
      "context" : "For more complex logical forms and larger knowledge graphs, there are many possible angles worth exploring: performing abstract interpretation to collapse denotations into equivalence classes (Cousot and Cousot, 1977), relaxing the notion of getting the correct denotation (Steinhardt and Liang, 2015), or working in a continuous space and relying on gradient descent (Guu et al., 2015; Neelakantan et al., 2016; Yin et al., 2016; Reed and de Freitas, 2016).",
      "startOffset" : 368,
      "endOffset" : 457
    } ],
    "year" : 2017,
    "abstractText" : "A core problem in learning semantic parsers from denotations is picking out consistent logical forms—those that yield the correct denotation—from a combinatorially large space. To control the search space, previous work relied on restricted set of rules, which limits expressivity. In this paper, we consider a much more expressive class of logical forms, and show how to use dynamic programming to efficiently represent the complete set of consistent logical forms. Expressivity also introduces many more spurious logical forms which are consistent with the correct denotation but do not represent the meaning of the utterance. To address this, we generate fictitious worlds and use crowdsourced denotations on these worlds to filter out spurious logical forms. On the WIKITABLEQUESTIONS dataset, we increase the coverage of answerable questions from 53.5% to 76%, and the additional crowdsourced supervision lets us rule out 92.1% of spurious logical forms.",
    "creator" : "LaTeX with hyperref package"
  }
}