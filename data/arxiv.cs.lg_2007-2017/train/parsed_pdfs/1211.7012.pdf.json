{
  "name" : "1211.7012.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Cezary Kaliszyk", "Josef Urban" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n21 1.\n70 12\nv3 [\ncs .A\nI] 2\n6 O\nct 2\n01 4\nThe necessary work involves: (i) an implementation of sound translations of the HOL Light logic to ATP formalisms: untyped first-order, polymorphic typed firstorder, and typed higher-order, (ii) export of the dependency information from HOL Light and ATP proofs for the machine learners, and (iii) choice of suitable representations and methods for learning from previous proofs, and their integration as advisors with HOL Light. This work is described and discussed here, and an initial analysis of the body of proofs that were found fully automatically is provided.\nCezary Kaliszyk, supported by FWF grant P26201 University of Innsbruck, Austria\nJosef Urban, funded by NWO grant Knowledge-based Automated Reasoning Radboud University, Nijmegen."
    }, {
      "heading" : "1 Introduction and Motivation",
      "text" : "“It is the view of some of us that many people who could have easily contributed to project QED have been distracted away by the enticing lure of AI or AR.”\n– The QED Manifesto\n“So it will take 140 man-years to create a good basic library for formal mathematics.”\n– Freek Wiedijk [86]\n“We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris.”\n– Larry Wall, Programming Perl [83]\n“And in demonstration itself logic is not all. The true mathematical reasoning is a real induction [...]”\n– Henri Poincaré, Science and Method [63]\n1.1 Large-Theory Automated Reasoning and HOL Light\nUse of external first-order automated theorem provers (ATPs) like Vampire [46], E [67], SPASS [85], and recently also SMT (satisfiability modulo theories) solvers like Z3 [24] for (large-theory) formalization has been developed considerably in the recent decade. Particularly in the Isabelle community, the Sledgehammer [13,15] bridge to such external tools is getting increasingly popular. This helps to further develop various parts of the technology involved. ATPs have recently gained the ability to quickly load large theories over large signatures and work with them [38]. Methods for automated selection of relevant knowledge and for proof guidance are actively developed [76], together with specialized automated systems targeted at particular mathematical domains [2, 7, 64]. Formats and translation methods handling more formalization-friendly foundations are being defined [16,27,70], and metasystems that decide which ATP, translation method, strategy, parallelization, and premises to use to solve a given problem with limited resources are being designed [59, 80]. Cooperation of humans and computers over large corpora of formal knowledge is an interesting field, allowing exploration of new AI systems and combinations of different AI techniques that can attempt to encode concepts like analogy and intuition, and rigorously evaluate their usefulness. Perhaps not only Hilbert and Turing, but also the formality-opposing and intuition-oriented Poincaré1 [63] would have been interested to learn about the new “semantic AI paradise” of such large corpora of fully computer-understandable mathematics (from which we do not intend to be expelled).\nThe HOL Light [34] system is probably the first among the existing well-known interactive theorem provers (ITPs) which has integrated and extensively used a general ATP procedure, the MESON tactic [36]. Hurd has developed and benchmarked early bridges [39, 40] between HOL and external systems, and his Metis system [41] has also become a significant part of the Isabelle/Sledgehammer bridge\n1 2012 is not just the year of Turing [32], but also of Poincaré, whose ideas about creativity and invention involving random, intuition-guided exploration confirmed by critical evaluation quite correspond to what AI systems like MaLARea [80] try to emulate in large formal theories.\nto ATPs [60]. Using the very detailed Otter/Ivy [53] proof objects, Harrison also later implemented a bridge from HOL Light to Prover9 [52]. HOL Light however does not yet have a general bridge to large-theory ATP/AI (“hammer”2) methods, similar to Isabelle/Sledgehammer or MizAR [78, 79], which would attempt to automatically solve a new goal by selecting relevant knowledge from the large library and running (possibly customized/trained) external ATPs on such premise selections. HOL Light seems to be a natural candidate for adopting such methods, because of the amount of work already done in this direction mentioned above, and also thanks to HOL Light’s foundational closeness to Isabelle/HOL. Also, thanks to the Flyspeck project [31], HOL Light is becoming less of a “single, very knowledgable formalizer” tool, and is getting increasingly used as a “tool for interested mathematicians” (such as the Flyspeck team in Hanoi3) who may know the large libraries much less and have less experience with crafting their own proof tactics. For such ITP users it is good to provide a small number of strong methods that allow fast progress, which can perhaps also complement the declarative modes [87] pioneered by HOL Light [35] in the LCF world.\n1.2 Flyspeck as an Interesting Corpus for Semantic AI Methods\nThe purpose of the Flyspeck project is to produce a formal proof of the Kepler Conjecture [33,45]. The Flyspeck development (which in this paper always means also the required parts of the HOL Light library) is an interesting corpus for a number of reasons. First, it formalizes considerable parts of standard mathematics, and thus exposes a large body of interconnected mathematical reasoning to all kinds of semantic AI methods and experiments. Second, the formalization is done in a relatively directed way, with the final goal of the Kepler conjecture in mind. For example, in the Mizar library4 (and even more in other collections like the Coq contribs5), articles may be contributed as isolated developments, and only much later (or never) re-factored into a form that makes them work well with related developments. Such refactoring is often a nontrivial process [66]. In a directed development like Flyspeck, such integrity is a concern from the very beginning, and this concern should result in the theorems working better together to justify new conjectures that combine the areas covered by the development. Third, the language of HOL Light is in a certain sense simpler than the language of Mizar and Coq (and to a lesser extent also than Isabelle/HOL), where one typically first needs to set up the right syntactic/type-automation environment to be able to formulate new conjectures in advanced areas. This greater simplicity (which may come at a cost) makes it possible to write direct (yet advanced) queries to the AI/ATP (“hammer”) system in the original language, without much additional need for specifying the context of the query. This could make such “hammer” more easy to try for interested mathematicians, and allow them to explore formal mathematics and Flyspeck. And fourth, Flyspeck is accompanied with an informal (LATEX) text that is often cross-linked to the formal concepts and theorems developed in HOL Light. With sufficiently strong automated reasoning over the library,\n2 Larry Paulson is guilty of introducing this “striking” terminology. 3 http://weyl.math.pitt.edu/hanoi2009/Participants/ 4 www.mizar.org 5 http://coq.inria.fr/V8.2pl1/contribs/bycat.html\nthis cross-linking opens the way to experiments with alignment (and eventual semi-automated translation) between the informal and formal Flyspeck texts, using corpus-driven methods for language translation, assisted by such an AI/ATP “hammer” as an additional semantic filter/advisor.\n1.3 The Rest of the Paper\nThe work reported here makes several steps towards the above goals:\n1. Sound and efficient translations of the HOL Light formulas to several ATP (TPTP) formalisms are implemented (Section 2). This includes the untyped first-order (FOF) format [71], the polymorphic typed first-order (TFF1) format [16], and the typed higher-order (THF) format [27, 69]. 2. Dependency information is exported from the Flyspeck proofs (Section 3). This allows experiments with re-proving of theorems by 17 different ATPs/SMTs from their HOL Light dependencies, and provides an initial dataset for machine learning of premise selection from previous proofs. 3. Several feature representations characterizing HOL Light formulas are proposed, implemented, and used for machine-learning of premise selection. Several preprocessing methods are developed for the dependency data that are used for learning. The trained premise-selection systems are integrated as external advisors for HOL Light. A prototype system answering real-time mathematical queries by running various parallel combinations of the premise selectors and ATPs is built and made available as an online service. See Section 4.\nThe methods are evaluated in Section 5, and it is shown that by running in parallel the most complementary proof-producing methods on a 14-CPU workstation, one now has a 39% chance to prove the next Flyspeck theorem within 30 seconds in a fully automated push-button mode (without any high-level advice). 50% of the Flyspeck theorems can be re-proved within 30 seconds by a collection of 7 ATP methods (run in parallel) if the HOL Light proof dependencies are used. 56% of the theorems could be proved by the union of all methods tried in the evaluation. An initial analysis of these sets of proofs is given in Section 6. It is shown that the proofs produced by the learning-advised ATPs can occasionally develop ideas that are very different from the original HOL Light proofs, and that the learning-advised ATPs can sometimes produce simpler proofs and discover duplications in the library. Section 7 discusses related work and Section 8 suggests future directions.\n2 Translation of HOL Light Formulas to ATP formats\nThe HOL logic differs from the formalisms used by most of the existing ATP and SMT systems. The main differences to first-order logic are the use of the polymorphic type system, and higher-order features (guarded by the type system) such as quantification (abstraction) over higher-order objects and currying. On the other hand, the logic is made classical and comes with a straightforward intended interpretation in ZFC. Translation of this logic (and its type-class extension used by Isabelle/HOL) to ATP formalisms has been an active research topic started already in the 90s. Prominent techniques, such as lambda lifting, suitable type system\ntranslation methods, etc., have been described several times [12, 36, 39, 40, 56]. Therefore this section assumes familiarity with these techniques, and only briefly summarizes the logic and the translation approaches considered, and their particular suitability for the experiments over the HOL Light corpora. For a comprehensive recent overview and discussion of this topic and the issues related to the translation see Blanchette’s thesis [12]. In particular, it contains the arguments about the soundness and (in)completeness of the translation methods that we eventually chose.\n2.1 Summary of the HOL Logic\nHOL Light uses the HOL logic [62]: an extended variant of Church’s simple type theory [21]. Type variables (implicitly universally quantified) are explicitly added to the language (providing polymorphism), together with arbitrary type operators (constructors of compound types like ‘int list’ and ‘a set’). In the HOL logic, the terms and types are intended to have a standard set-theoretical interpretation in HOL universes. A HOL universe U is a set of non-empty sets, such that U is closed under non-empty subsets, finite products and powersets, an infinite set I ∈ U exists, and a choice function ch over U exists (i.e., ∀X ∈ U : ch(X) ∈ X) . The subsets, products, and powersets together also yield function spaces. A frequently considered example of a HOL universe is the set Vω+ω \\ {0},\n6 with ch being its (ZFC-guaranteed) selector, and I = ω. The standard U-interpretation of a monomorphic (i.e., free of type variables) type σ is a set JσK ∈ U , a polymorphic (i.e., containing type variables) type σ with n type variables is interpreted as a function JσK : Un → U , and the arrow operator observes the standard functionspace behavior (lifted to appropriate mappings for polymorphic types) on the type interpretations. The standard interpretation of a closed monomorphic term t : σ is an element of the set JσK ∈ U , and a closed polymorphic term (with n type variables) t : σ with JσK : Un → U is interpreted as a (dependently typed) function assigning to each n-tuple [X1, . . . , Xn] ∈ U\nn an element of JσK([X1, . . . , Xn]). The HOL logic’s type signature starts with the built-in nullary type constants ind, interpreted as the infinite set I, and bool (type of propositions), interpreted as a chosen two-element set in U (its existence follows from the properties of a HOL universe). The term signature initially contains the polymorphic constants =α→α→bool, and ǫ(α→bool)→α, interpreted as the equality and selector on each set in U . The inference mechanisms start with a set of standard primitive inference rules, later adding the axioms of functional extensionality, choice (implying the excluded middle in the HOL setting), and infinity. New type and term constructors can be introduced by simple definitional extension mechanisms, which are in HOL Light also used to introduce the standard logical connectives and quantifiers. The result is a classical logic system that is in practice quite close to set theory, differing from it mainly by the built-in type discipline (allowing also complete automation of abstraction) and by more frequent use of total functions to model mathematical objects. For example, predicates are modelled as total functions to bool on types, and sets are in HOL Light identified with (unary) predicates. The\n6 Vω+ω is the ω + ω-th set of von Neumann’s (cumulative) hierarchy of sets obtained by iterating the powerset operation starting with the empty set ω+ω times. This shows that the HOL logic is in general weaker than ZFC.\nmain issues for translation are the type system and the automated reification (abstraction) mechanisms that are not immediately available in first-order logic and may be encoded in more or less efficient and complete ways.\n2.2 The MESON Translation\nAn obvious first idea for generating FOL ATP problems from HOL Light problems was to re-use parts of the already implemented MESON tactic. This tactic tries to justify a given goal G with a supplied list of premises P1, ..., Pn by calling a customized first-order ATP implemented in HOL Light, which is based on the model elimination method invented by Loveland [49], later combined with a Prolog-like search tree [50]. The implementation of the MESON tactic in HOL Light first applies a number of standard translation techniques (such as β-reduction followed by lambda lifting, skolemization, introduction of the apply functor,7 etc.) that transform the HOL goal (together with the supplied premises) to a clausal FOL goal (or multiple goals). An interesting (and MESON-specific) part of the transformation is a rather exhaustive and heuristic instantiation of the (often polymorphic) premises (called POLY_ASSUME_TAC), described below. The clausal FOL goal is then passed to the core ATP. If the core ATP succeeds, it returns a proof, which is then translated into HOL Light proof steps. The transformation from HOL to FOL is heuristic, incomplete, and tuned for relatively small problems. An interesting feature of MESON is that the core ATP does not treat equality specially (as is quite common in tableau provers), which in turn allows using multiple instantiated versions of equality (e.g., on lists and on real numbers) inside one problem. Such equational separation, when combined with the heuristic instantiation of other polymorphic constants done by MESON, then prevents the core ATP from doing ill-typed inferences without the necessity for any additional type guards.\nThe most interesting part of the translation heuristically instantiates the (possibly polymorphic) premises P1, ..., Pn and adds them to the goal G. This is done iteratively, building a new temporary goal Gi (where G0 = G) from each premise Pi and the previous goal Gi−1 as follows. All (possibly polymorphic) constants are collected from Pi and Gi−1, and the set of all their pairs is created. When such a pair {cP , cG} consists of two (symbolically) equal constants, the type of cP is matched to the type of cG, and if a substitution σ exists (i.e., TypecP σ = TypecG), it is added to the resulting set Σi of type substitutions. Each type substitution from Σi is then applied to Pi, and all such resulting instances of Pi are added as assumptions to Gi−1, yielding Gi. The set of assumptions of the goal Gi is thus typically greater than that of Gi−1, and the same typically holds for the set of constants in Gi, which will be in turn used to instantiate Pi+1.\nThis procedure is quite effective for the small problems that MESON normally handles. However, for problems with many premises and many polymorphic constants this turns out to be very inefficient. While re-using MESON allowed the quick initial exploration of using external ATPs and advisors described in [44], this inefficiency practically excluded the (seemingly straightforward) use of the unmodified MESON procedure as an (at least basic) translation method for generating ATP\n7 Identity is used by MESON as the apply functor.\nproblems with many premises. This is why the experiments presented here use different translations, described below.\nCompleteness of the translation from HOL to FOL is in general hard to achieve in an efficient way. The MESON translation is incomplete in several ways. The goal’s proper assumptions are not monomorphised, and the free variables of polymorphic types are not used in the same way as the polymorphic constants. For example, given the premise:\n∀P : α → bool. ∀x : α. Px\nand a goal that does not mention α, the premise will never be instantiated to the type present in the goal, and thus will not be usable for MESON.\n2.3 Translation to the TFF1 and FOF Formats\nThere is a “simple” solution to the instantiation blow-up experienced with the MESON translation: avoid heuristic instantiation as a pre-processing step, and instead let the ATPs handle it as a part of the ATP problems. This technique is used in the Mizar/MPTP translation [72, 73, 75], where the (dependent and undecidable) soft type system cannot be separated from the core predicate logic. The relevant heuristics can instead be developed (and experimented with) on the level of ATPs. Indeed, for example the SPASS system includes a number of ATP techniques for both complete and incomplete work with (auto-detected) types [17,84]. This approach has been in the recent years facilitated by developing type-aware TPTP standards such as TFF0, TFF1, and THF, which – unlike related typeaware efforts like DFG [30] and KIF [28] – seem to be more successful in being adopted by ATP and tool developers. In the case of the recent TFF1 standard [16] adding HOL-like polymorphic types to first-order logic, a translation tool to the FOF and SMT formats has been developed in 2012 by Andrei Paskevich as part of the Why3 system [25], simplifying the first experiments with the non-instantiating translation.\nThe translation to TFF1 proceeds similarly to the MESON translation, but without applying the POLY_ASSUME_TAC. The problem formulas are β-reduced, the remaining lambda abstractions are again removed using lambda lifting, and the apply functor is heuristically introduced. The particular heuristic for this is the one used by Meng and Paulson, i.e., for each higher-order constant c the minimum arity nc with which it appears in a problem is computed, and the first nc arguments are always passed to c directly inside the problem. If the constant is also used with more arguments in the problem, apply is used. Blanchette [12] reports that this optimization works fairly well for Isabelle/Sledgehammer, and gives a simple example when it introduces incompleteness. As an example of the translation to the TFF1 format, consider the re-proving problem8 for the theorem Float.REAL_EQ_INV9\nproved as part of the Jordan curve theorem formalization,10 whose HOL Light proof is as follows:\n8 By a re-proving problem, we mean the ATP problem consisting of the translated HOL Light theorem together with the premises used in its original HOL Light proof.\n9 http://mws.cs.ru.nl/~mptp/hh1/OrigDepsProbs/i/p/09895.p 10 http://mws.cs.ru.nl/~mptp/hol-flyspeck/trunk/Jordan/float.html#REAL_EQ_INV\nlet REAL_EQ_INV = prove(‘∀x y. ((x:real = y) ⇐⇒ (inv(x) = inv (y)))‘, ((REPEAT GEN_TAC)) THEN (EQ_TAC) THENL [((DISCH_TAC THEN (ASM_REWRITE_TAC[]))); (* branch 2*) ((DISCH_TAC)) THEN ((ONCE_REWRITE_TAC [(GSYM REAL_INV_INV)])) THEN ((ASM_REWRITE_TAC[]))]);;\nThe dependency tracking (see Section 3.1.2) has found the following dependencies of the theorem:11\nAND_DEF FORALL_DEF IMP_DEF REAL_INV_INV REFL_CLAUSE TRUTH\nTactics_jordan.unify_exists_tac_example\nFrom these dependencies, only REAL_INV_INV has nontrivial first-order content (a list of the trivial facts has been collected and is used for such filtering). The problem creation additionally adds three facts encoding properties of (HOL) booleans, and also the functional extensionality axiom (EQ_EXT). In the original HOL Light syntax the re-proving problem looks as follows:\n% ORIGINAL: Float.REAL_EQ_INV\n% Assm: EQ_EXT: !f g. (!x. f x = g x) ==> f = g\n% Assm: BOOL_CASES_AX: !t. (t <=> T) \\/ (t <=> F)\n% Assm: NOT_CLAUSES_WEAK_conjunct1: ~F <=> T\n% Assm: REAL_INV_INV: !x. inv (inv x) = x\n% Assm: TRUTH: T\n% Goal: !x y. x = y <=> inv x = inv y\nAfter applying β-reduction, lambda lifting (none in the example), and introducing the apply functor (called here happ), this is transformed (still as HOL terms) into the following:\n% PROCESSED\n% Assm: !f g. (!x. happ f x = happ g x) ==> f = g\n% Assm: !t. (t <=> T) \\/ (t <=> F)\n% Assm: ~F <=> T\n% Assm: !x. inv (inv x) = x\n% Assm: T\n% Goal: !x y. x = y <=> inv x = inv y\nThe application functor happ was only used for the function variables in the extensionality axiom (EQ_EXT). The function inv is always used with one argument in the problem, so it is never wrapped with happ. Finally, the TFF1 TPTP export declares the signature of the symbols and type operators, and adds the corresponding guarded quantifications to the formulas. The apply functor is called i in the TFF1 export (for concise output in case of many applications in a goal), and it explicitly takes also the type arguments (A and B in aEQu_EXT). This (making the implicit type variables explicit) is in TFF1 done for any symbol that remains polymorphic. We reserve the predicate p for translation between Boolean terms and formulas. This is done in the same way as in [56].\n11 Tactics_jordan.unify_exists_tac_example is just ‘T=T‘. The name is accidental.\nHOL Light allows one identifier to denote several different underlying constants. In the running example, inv is such an overloaded identifier and denotes the inverse operations on several different types. To deal with such identifiers different names are used for each underlying constant separately in the TFF1 export signature, so that the identifiers can be printed using their non-overloaded names like real_inv.\n% TYPES\ntff(tbool, type, bool:$tType).\ntff(tfun, type, fn:($tType * $tType) > $tType).\ntff(treal, type, real:$tType).\n% CONSTS\ntff(cp, type, p : (bool > $o)).\ntff(chapp, type, i:!>[A:$tType,B:$tType]: ((fn(A,B) * A) > B)).\ntff(cF, type, f:bool).\ntff(crealu_inv, type, realu_inv:(real > real)).\ntff(cT, type, t:bool).\n% AXIOMS\ntff(aEQu_EXT, axiom, ![A : $tType,B : $tType]:\n![F:fn(A,B),G:fn(A,B)]:(![X:A]:i(A,B,F,X) = i(A,B,G,X) => F = G)).\ntff(aBOOLu_CASESu_AX, axiom, ![T:bool]:(T = t | T = f)).\ntff(aNOTu_CLAUSESu_WEAKu_conjunct1, axiom, (~ (p(f)) <=> p(t))).\ntff(aREALu_INVu_INV, axiom, ![X:real]:realu_inv(realu_inv(X)) = X).\ntff(aTRUTH, axiom, p(t)).\ntff(conjecture, conjecture, ![X:real,Y:real]:\n(X = Y <=> realu_inv(X) = realu_inv(Y))).\nProblems in this format can be already given to the Why3 tool, which can translate them for various SMT solvers and ATP systems, and call the systems on the translated form. This was initially used both for ATPs working with the FOF format and for the SMTs. Currently, we only use Why3 for preparing problems for Yices, CVC3, and AltErgo. The translation to the FOF format was later implemented independently of Why3, to avoid an additional translation layer for the strongest tools, and in particular to be able to run the ATPs with different parameters and in a proof-producing mode. The procedure is however the same as in Why3, and the resulting FOF form will be as follows.\n% Goal: !x y. x = y <=> inv x = inv y\nfof(aEQu_EXT, axiom, ![A,B]: ![F, G]:\n(![X]: s(B,i(s(fun(A,B),F),s(A,X))) = s(B,i(s(fun(A,B),G),s(A,X)))\n=> s(fun(A,B),F) = s(fun(A,B),G))).\nfof(aBOOLu_CASESu_AX, axiom,\n![T]: (s(bool,T) = s(bool,t) | s(bool,T) = s(bool,f))).\nfof(aNOTu_CLAUSESu_WEAKu_conjunct1, axiom,\n(~ (p(s(bool,f))) <=> p(s(bool,t)))).\nfof(aREALu_INVu_INV, axiom,\n![X]: s(real,realu_inv(s(real,realu_inv(s(real,X))))) = s(real,X)).\nfof(aTRUTH, axiom, p(s(bool,t))).\nfof(conjecture, conjecture, ![X, Y]: (s(real,X) = s(real,Y) <=>\ns(real,realu_inv(s(real,X))) = s(real,realu_inv(s(real,Y))))).\nThis translation uses the (possibly quadratic) tagging of terms with their types (with “s” as the tagging functor), used, e.g., in Hurd’s work.\n2.4 Translations to Higher-Order Formats\nThe recently developed TPTP THF standard can be used to encode problems in monomorphic higher-order logic. This allows experimenting with higher-order ATPs like LEO2 [9] and Satallax [19], in addition to the standard ATPs working in the first-order formalism. The translation to THF needs to perform only one step: monomorphisation. As explained in 2.2, this is however a nontrivial task, and the MESON tactic approach is already in practice too exhaustive for problems with many premises.\nAfter developing the TFF1 and FOF translation, some initial experiments were done to produce a monomorphisation heuristic that behaves reasonably on problems with many premises. This heuristic is now as follows. The constants that can be used to instantiate the premises are extracted only once from the goal at the start of the procedure. Every premise can be instantiated using these goal constants, but the premises themselves are not further used to grow this set. This means that the procedure is even less complete than MESON, however the procedure is linear in the number of premises, and it is therefore possible to use it even with large numbers of advised premises. In practice, it is rarely the case that a premise can be instantiated in more than one way. A simple example when this happens is in the THF problem12 created for the theorem I_O_ID,13 where the particular goal and premise (both properties of the identity function) are as follows:\nAssm: I_THM: !x. I x = x\nGoal: I_O_ID: !f. I o f = f /\\ f o I = f\nThe exact types inferred by the standard HOL (Hindley-Milner [37]) type inference for the goal are as follows:\n∀f : A → B. IB→B o f = f ∧ f o IA→A = f\nSince the identity function appears in the goal both with the type A→A and with the type B→B, the following two instances of the premise I_THM are created by the THF translation:\n% TYPES\nthf(ta, type, a : $tType).\nthf(tb, type, b : $tType).\nthf(ci0, type, i0 : (a > a)).\nthf(ci, type, i : (b > b)).\n% AXIOMS\nthf(aIu_THMu_monomorphized0, axiom, ![X:a]:((i0 @ X) = X)).\nthf(aIu_THMu_monomorphized1, axiom, ![X:b]:((i @ X) = X)).\nFinally, while there is no TPTP standard yet for the polymorphic HOL logic, this logic is shared by a number of systems in the HOL family of ITPs. For the experiments described in 5.1 Isabelle is used in its CASC 2012 THF mode, but it should be possible to pass the problems to Isabelle directly in some (not necessarily TPTP) polymorphic HOL encoding. This is has been tried only to a small extent, and is still future work.\n12 http://mws.cs.ru.nl/~mptp/hh1/OrigDepsProbs/i/h/00119.p 13 http://mws.cs.ru.nl/~mptp/hol-flyspeck/trunk/trivia.html#I_O_ID"
    }, {
      "heading" : "3 Exporting Theorem Problems for Re-proving with ATPs",
      "text" : "In our earlier initial experiments [44], it was found that the ATP problems created from the calls to the MESON tactic in the HOL Light and Flyspeck libraries are very easy for the state-of-the-art ATPs. Some of this easiness might have been caused by the (generally unsound) merging of different polymorphic versions of equality used by MESON into just one standard first-order equality.14 However, after a manual random inspection it still seemed that the ratio of such unsound proofs is low, and the MESON problems are just too easy. That is why only the set of problems on the theorem level is considered for experiments here. The theorem level seems to be quite similar in the major ITPs: theorem is typically not corresponding to what mathematicians call a theorem, but it is rather a self-sufficient lemma with a formal proof of several to dozens (exceptionally hundreds) lines that can be useful in other formal proofs and hence should be named and exported. Since the ITP proofs can be longer (i.e., they can contain a number of MESON and other subproblems), proving such theorems fully automatically is typically a challenge, which makes such problems suitable for ATP benchmarks, challenges, and competitions.\n3.1 Collecting Theorems and their Dependency Tracking\nIn Mizar/MPTP and in Isabelle (done by Blanchette in so far unpublished work) the ATP problems corresponding to theorems can be produced by collecting the dependencies (premises) from the proofs (by suitable tracking mechanisms), and then translating the Premises ⊢ Theorem problem using the methods described in Section 2. The recent work by Adams in exporting HOL Light to HOL Zero [1] (with cross-verification as the main motivation) was initially used to obtain the theorem dependencies for the first experiments with HOL Light in [44], and after that custom theorem-exporting and dependency-tracking mechanisms were implemented as described below."
    }, {
      "heading" : "3.1.1 Collecting and Naming of Theorems",
      "text" : "The first issue in implementing such mechanism is to decide what is considered to be a relevant theorem, and what should be its canonical name. In some ITPs, important statements have labels like lemma, theorem, corollary, etc. This is not the case in HOL Light, which is implemented in the OCaml toplevel. This means that every theorem or tactic is just an OCaml value. Some of those values are assigned names, while some are only created on the fly and immediately forgotten. In the relevant exporting work of Obua [57], every occurrence of the HOL Light command prove is replaced with a command that additionally records the name of the stored object. This strategy was used first, and extended to work with the whole Flyspeck library by also recording the names for the following commands: prove_by_refinement, new_definition, new_recursive_definition, new_specification, new_inductive_definition, define_type, and lift_theorem. This purely syntactic replacement method however turned out to be insufficient for a number of reasons. First, this method does not provide information about the\n14 Note that the typed translation that we use here prevents deriving ill-typed equalities [12].\nscope of names with respect to the OCaml modules. Second, it does not provide the information whether a name given to a theorem has been declared on the top level, or inline inside a function (which makes such theorem unusable for proving other theorems on the toplevel), or even within a function called multiple times with different arguments (in which case the same name would be assigned to a number of different theorems). Finally, certain theorems accessible on the top level are created using other OCaml mechanisms, for example mapping a decision procedure over a list of terms. Recognizing syntactically theorems created in this way turned out to be impractical.\nThat is why a more robust method has been eventually used, based on the update_database15 recording functionality by Harrison and Zumkeller. This code accesses the basic OCaml data structures and makes it possible to record the namevalue pairs for all OCaml values of the type theorem in a given OCaml state. Thus, it is sufficient to load the whole Flyspeck development, and then invoke this recording functionality.\nAfter some initial experiments with ATP re-proving of the translated problems, this method was however further modified to be able to keep finer track of the use of theorems that are conjunctions of multiple facts. Such (often large) conjunctive theorems are used quite frequently in HOL Light, typically to package together facts that are likely to jointly provide a useful method for dealing with certain concepts or certain kinds of problems. For example the theorem ARITH_EQ16 packages together ten facts about the equality of numerals as follows:\nlet ARITH_EQ = prove (‘(∀m n. (NUMERAL m = NUMERAL n) ⇐⇒ (m = n)) ∧\n((_0 = _0) ⇐⇒ T) ∧ (∀n. (BIT0 n = _0) ⇐⇒ (n = _0)) ∧ (∀n. (BIT1 n = _0) ⇐⇒ F) ∧ (∀n. (_0 = BIT0 n) ⇐⇒ (_0 = n)) ∧ (∀n. (_0 = BIT1 n) ⇐⇒ F) ∧ (∀m n. (BIT0 m = BIT0 n) ⇐⇒ (m = n)) ∧ (∀m n. (BIT0 m = BIT1 n) ⇐⇒ F) ∧ (∀m n. (BIT1 m = BIT0 n) ⇐⇒ F) ∧ (∀m n. (BIT1 m = BIT1 n) ⇐⇒ (m = n))‘, REWRITE_TAC[NUMERAL; GSYM LE_ANTISYM; ARITH_LE] THEN REWRITE_TAC[LET_ANTISYM; LTE_ANTISYM; DENUMERAL LE_0]);;\nAn even more extreme example is the ARITH theorem which conjoins together all the basic arithmetic facts (there are 108 of them in the current version of HOL Light). The conjuncts of such theorems are now also named (using a serial numbering of the form ARITH_EQ_conjunctN), so that the dependency tracking can later precisely record which of the conjuncts were used in a particular proof. This significantly prunes the search space for ATP re-proving of the theorems that previously depended on the large conjunctive dependencies, and also makes the learning data extracted from dependencies of such theorems more precise.\nThis method can however result in the introduction of multiple names for a single theorem (which is just a HOL Light term of type theorem). If that happens (for this or other reasons), the first name that was associated with the theorem during the Flyspeck processing is always consistently used, and the other alternative names\n15 http://mws.cs.ru.nl/~mptp/hol-flyspeck/trunk/Examples/update_database.html 16 http://mws.cs.ru.nl/~mptp/hol-flyspeck/trunk/calc_num.html#ARITH_EQ\nare never used. Such consistency is important for the performance of the machine learning on the recorded proof data.17 The list of all theorems and their names obtained in this way is saved in a file, and subsequently used in the dependency extraction and problem creation passes."
    }, {
      "heading" : "3.1.2 Dependency Recording",
      "text" : "After the detection and naming of theorems, the recording of proof dependencies is performed, by processing the whole library again with a patched version of the HOL Light kernel. This patched version is the proof-recording component of the new HOL-Import [43], a mechanism designed to transfer proofs from HOL Light to Isabelle/HOL in an efficient way allowing the export of big repositories like Flyspeck. The code for every HOL inference step is patched, to record the newly created theorems. Each theorem is assigned a unique integer counter, and for every new theorem its dependencies on other theorems (integers) are recorded and exported to a file. For every processed theorem it is also checked if it is one of the theorems named in the previous theorem-naming pass. If so, the association of this theorem’s name to its number is recorded, and again exported to a file.\nAfter this dependency-recording pass, the recorded information is further processed by an offline program to eliminate all unnamed dependencies (originating for example from having multiple names for a single theorem). For every named theorem its dependencies are inspected, and if a dependency D does not have a name, it is replaced by its own dependencies (there is no unnamed dependency that could not be further expanded). This is done recursively, until all unnamed dependencies are removed. This produces for each named theorem T a minimal (wrt. the original HOL Light proof) list of named theorems that are sufficient to prove T .\nThe numbering of theorems respects the order in which the theorems are processed in the Flyspeck development. This total ordering is compatible with (extends) the partial ordering induced by proof dependencies, and for the experiments conducted here it is assumed to be the chronological order in which the library was developed. The dependency information given in this chronological order for all 16082 named theorems (of which 1897 are (type) definitions, axioms, or their parts, and their dependencies are not exported) obtained by processing the Flyspeck library18 (and its HOL Light pre-requisites) is available online.19 Together with suitably chosen characterizations of the theorems (see Section 4.1), this constitutes an interesting new dataset for machine-learning techniques that attempt to predict the most useful premises from the formal library for proving the next conjecture.\n17 For example, the MaLARea system does such de-duplication as a useful preprocessing step before learning and theorem-proving is started on a large number of related problems. 18 Flyspeck SVN revision 2887 from 2012-06-26 and HOL Light SVN revision 146 from 2012- 06-02 are used for all experiments. 19 http://mws.cs.ru.nl/~mptp/hh1/deps.all\n3.2 The Data Set of ATP Re-proving Problems\nAnalogously to Mizar and Isabelle, the re-proving ATP problems for the collected named theorems are finally produced by translating the Dependencies ⊢ Theorem problem to the ATP formalisms using the methods described in Section 2, together with basic filtering of dependencies that have trivial first-order content. 1897 of the 16082 named theorems do not have a proof (those are definitions and axioms). For all the remaining 14185 named theorems the corresponding re-proving ATP problems were created, and are available online20 in the FOF, THF, and TFF1 formats. These problems are used for the ATP re-proving experiments described in Section 5.1. Smaller meaningful datasets will likely be created from this large dataset for ATP/AI competitions such as CASC LTB and Mizar@Turing21, analogously to the smaller MPTP207822 [4] ATP benchmark created from the ATPtranslated Mizar library (MML), and the Judgement Day benchmark [18] created by ATP translation of a subset of the Isabelle/HOL library.\nThe average, minimum, and maximum sizes of problems in these datasets are shown in Table 1, together with the corresponding statistics for the problems expressed in the original HOL formalism. It can be seen that the number of formulas\nin the translated problems is typically at most twice the number of the original HOL formulas, i.e., the translations are indeed efficient for all the problems. This was not the case (and became a bottleneck) in the initial experiments using the more prolific MESON translation. There is no increase in the number of formulas when translating from the original HOL-formulated problem to the FOF translation. For the TFF1 and THF translation, formulas declaring the types of the symbols appearing in the problems are added, and for the THF translation multiple instances of the premises can additionally appear. Table 2 shows the total times needed for the various exporting phases run over the whole Flyspeck as explained above. For completeness, the time needed to export characterizations of the theorems for external (e.g., machine-learning) tools is also included (see Section 4.1 for the description of the characterizations that are used)."
    }, {
      "heading" : "4 Premise Selection",
      "text" : "Given a large library like Flyspeck, the interesting ATP/AI task is to prove new theorems without having to manually select the relevant premises. In the past\n20 http://mws.cs.ru.nl/~mptp/hh1/OrigDepsProbs/co_i_f_p_h.tgz 21 http://www.cs.miami.edu/~tptp/CASC/J6/Design.html#CompetitionDivisions 22 http://wiki.mizar.org/twiki/bin/view/Mizar/MpTP2078\ndecade, a number of premise selection methods have been developed and experimented with over large theories like Mizar/MML, Isabelle/HOL, SUMO, and Cyc. See [48, 76] for recent overviews of such methods.\nATP problems of this kind are created for Mizar/MML by consistent translation of the whole MML to TPTP, and then letting external premise selection algorithms find the most relevant premises for a given theorem t from the large set of t-allowed premises (typically those theorems and definitions that were already available when t was being proved, expressed, e.g., as TPTP include files). For Isabelle/Sledgehammer, the default premise selection algorithm is implemented inside Isabelle, i.e., it is working on the native Isabelle symbols. Only after the Sledgehammer premise selection chooses the suitable set of premises, the problem is translated to a given ATP formalism using one of the several implemented translation methods. In general, the symbol naming is in Isabelle consistent only before the translation is applied, and a particular symbol in two translated problems can have different meanings.\nBoth the Mizar and the Isabelle approach have some advantages and disadvantages. Optimizing the translation (or using multiple translations) as done in Isabelle can improve the ultimate ATP performance once the premises have been selected. On the other hand, if the whole library is not translated in a consistent manner to a common ATP format such as TPTP, ATP-oriented external premise selection tools like SInE cannot be directly used on the whole library. It could be argued that the SInE algorithm is relatively close to the Sledgehammer premise selection algorithm, and can be easily implemented inside Isabelle. However there are useful premise selection methods for which this is not so straightforward. For example in the MaLARea system, evaluation of premises in a large common pool of finite first-order models is an additional semantic premise-characterization method that improves the overall precision quite significantly [80].23 For such a pool of firstorder models to be useful, the premises have to use symbols consistently also after the translation to first-order logic. Although various techniques can again be developed to lift this method to the current Sledgehammer translation setting, they seem less straightforward than for example a direct Isabelle implementation of SInE. This discussion currently applies also to the HOL Light ATP translations described in Section 2. For example, the problem-specific optimization of the arity of symbols\n23 Recent evidence for the usefulness of model-based selection methods is the difference (64% vs. 50% problems solved) between the (otherwise quite similar) systems MaLARea and PS-E (http://www.cs.ru.nl/~kuehlwein/CASC/PS-E.html) in the 2012 Mizar@Turing competition.\ndescribed in 2.3 will in general cause inconsistency on the symbol level between the FOF translations of two different HOL Light problems.\nThe procedure implemented for HOL Light is currently a combination of the external, internal, learning, and non-learning premise-selection approaches. This procedure assumes the common ITP situation of a large library of (also definitional) theorems Ti and their proofs Pi (for definitions the proof is empty), over which a new conjecture has to be proved. The proofs refer to other theorems, giving rise to a partial dependency ordering of the theorems extended into their total chronological ordering as described for Flyspeck in 3.1.2. For the experiments it will be assumed that the library was developed in this order. An overview of the procedure is as follows, and its details are explained in the following subsections.\n1. Suitable characterizations (see Section 4.1) of the theorems and their proof dependencies are exported from HOL Light in a simple format. 2. Additional dependency data are obtained by running ATPs on the ATP problems created from the HOL Light proof dependencies, i.e., the ATPs are run in the re-proving mode. Such data are often smaller and preferable [47]. These data are again exported using the same format as in (1). 3. The (global, first-stage) external premise selectors preprocess (typically train on) the theorem characterizations and the proof dependencies. Multiple characterizations and proof dependencies may be used. 4. When a new conjecture is stated in HOL Light, its characterization is extracted and sent to the (pre-trained) first-stage premise selectors. 5. The first-stage premise selectors work as rankers. For a given conjecture characterization they produce a ranking of the available theorems (premises) according to their (assumed) relevance for the conjecture. 6. The best-ranked premises are used inside HOL Light to produce ATP (FOF, TFF1, THF) problems. Typically several thresholds (8, 32, 128, 512, etc.) on the number of included premises are used, resulting in multiple versions of the ATP problems. 7. The ATPs are called on the problems. Some of the best ATPs run in a strategyscheduling mode combining multiple strategies. Some of the strategies always use the SInE (i.e., local, second-stage) premise selection (with different parameters), and some other strategies may decide to use SInE when the ATP problem is sufficiently large.\nLoop to improve (2) and (3): It is not an uncommon phenomenon that in the dataimproving step (2) (ATP re-proving from the HOL Light proof dependencies) an ATP proof could not be found for some theorem Ti, but an alternative proof of Ti can be found from some other theorems preceding Ti in the chronological order (which guards such alternative proofs against cycles). To achieve this, the trained premise selectors can be used also on all theorems that are already in the library, and the whole ATP/training process can be iterated several times to obtain as many ATP proofs as possible, and better (and differently) trained premise selectors for step (3). This is the same loop as in MaLARea.\n4.1 Formula Characterizations Used for Learning\nGiven a new conjecture C, how do mathematicians decide that certain previous knowledge will be relevant for proving C? The approach taken in practically all\nexisting premise-selection methods is to extract from such C a number of suitably defined features, and use them as the input to the premise selection for C. The most obvious characterization that already works well in large libraries is the (multi)set of symbols appearing in the conjecture. This can be further extended in many interesting ways, using various methods developed, e.g., in statistical machine translation and web search, but also by methods specific to the formal mathematical domain. In this work, characterization of HOL formulas by all their subterms (found useful inMaLARea) was used, and adapted to the typed HOL logic. For example, the latest version of the characterization algorithm would describe the HOL theorem DISCRETE_IMP_CLOSED:24\n∀s:real^N→bool e. &0 < e ∧ (∀x y. x IN s ∧ y IN s ∧ norm(y − x) < e =⇒ y = x) =⇒ closed s\nby the following set of strings:\n\"real\", \"num\", \"fun\", \"cart\", \"bool\", \"vector_sub\", \"vector_norm\", \"real_of_num\", \"real_lt\", \"closed\", \"_0\", \"NUMERAL\", \"IN\", \"=\", \"&0\", \"&0 < Areal\", \"0\", \"Areal\", \"Areal^A\", \"Areal^A - Areal^A\", \"Areal^A IN Areal^A->bool\", \" Areal^A->bool\", \"_0\", \"closed Areal^A->bool\", \"norm (Areal^A - Areal^A)\", \"norm (Areal^A - Areal^A) < Areal\"\nThis characterization is obtained by:\n1. Normalizing all type variables to just one variable A. 2. Replacing (normalizing) all term variables with their normalized type. 3. Collecting all (normalized) types and their component types recursively. 4. Collecting all (normalized) atomic formulas and their component terms recur-\nsively. 5. Including all “proper” term and type constructors (logic symbols like conjunc-\ntion are filtered out).\nIn the above example, real is a type constant, IN is a term constructor, Areal^A->bool is a normalized type, Areal^A its component type, norm (Areal^A - Areal^A) < Areal is an atomic formula, and Areal^A - Areal^A is its normalized subterm.\nThe normalization of variable names is an interesting topic. It is good if the premise selectors can notice some similarity between two terms with variables,25 which is hard (when using strings) if the variables have different names. On the other hand, total normalization to just one generic variable name removes also the information that the variables in a particular subterm were (not) equal. Also, terms with differently typed variables should be more distant from each other than those with the same variable types. In total, four versions of variable normalization were tested:\nsyms0: All free and bound variables are given the same name A0. This encoding is the most liberal, i.e., the resulting equality relation on the features is the coarsest one, allowing the premise selectors to see many similarities.\n24 http://mws.cs.ru.nl/~mptp/hol-flyspeck/trunk/Multivariate/topology.html# DISCRETE_IMP_CLOSED 25 One could require the similarity to also handle matching, etc. A simple way how to do it is to generate even more features. This is again left to further general research in this area.\nsyms: First the free variables are numbered consecutively (A0, A1, etc). Then the bound variables are named with the subsequent numbers. This results in a finer notion of similarity than in syms0. symst: Every variable is renamed to a textual representation of its type, for example Anum or Areal. This is again finer than syms0, but different from syms. This normalization is used in the above example, and also for most of the premise selection trainings. symsd: In one symst implementation, the internal HOL Light type variable numbering was accidentally used, thus making most of such term features disjoint between different theorems. The performance was lower, but the method produces some unique solutions and is included in the evaluation.\nIn addition to that, several feature exports included also logic symbols. Various feature characterizations can have different performance on different datasets, and such characterizations can be also combined together in interesting ways. This is a rather large research topic that is left as future work for this newly developed dataset, along with other large-theory datasets. Just including the features encoding the validity in finite models will be interesting.\n4.2 Machine Learning of Premise Selection\nAll the currently used first-stage premise selectors are machine learning algorithms trained in various ways on previous proofs. A number of machine learning algorithms can be experimented with today, and in particular kernel-based methods [4] and ensemble methods [48] have recently shown quite good performance on smaller datasets such as MPTP2078. However, scaling and tuning such methods to a large corpus like Flyspeck and to quite a large number of incremental training and testing experiments is not straightforward.26 That is why this work so far uses mostly the sparse implementation of a multiclass naive Bayes classifier provided by the SNoW system [20]. SNoW can incrementally train and produce predictions on the whole Flyspeck library presented in the chronological order in an hour (and often considerably faster on minimized data). I.e., one new prediction takes a fraction of a second. In addition to that, several other fast incremental (online) learning algorithms were briefly tried: the Perceptron and Winnow algorithms provided also by SNoW, and a custom implementation of the k-nearest neighbor (k-NN) algorithm. Only k-NN however produced enough additional prediction power. As already mentioned, the first-stage algorithms are often complemented by SInE as a second-stage premise selector when the ATP problem is written, and that is why some (in particular SInE-like) algorithmsmight look mostly redundant (in the overall ATP evaluation) when used at the first stage. This is obviously a consequence of the particular setup used here.\nTwo kinds of evaluation are possible in this setting and have been used several times for the Mizar data: a pure machine-learning evaluation comparing the predicted premises with the set of known sufficient premises, and an evaluation that actually runs an ATP on the predicted premises. While data are available\n26 Such scaling up for the large Mizar library is work in progress at the time of writing this article.\nalso for the former, in this paper only the second evaluation is presented, see Section 5.2. The main reason for this is that alternative proofs are quite common in large libraries, and they often obfuscate the link between the pure machinelearning performance and the final ATP performance. Measuring the final ATP performance is more costly, however it practically stopped being a problem with the recent arrival of low-cost workstations with dozens of CPUs.\nAt a given point during the library development, the training data available to the machine learners are the proofs of the previously proved theorems in the library. A frequently used approach to training premise selection is to characterize each proof Pi of theorem Ti as a (multi)set of theorems {Ti1 , ..., Tim |Tij used in Pi}. The training example will then consist of the input characterization (features) of Ti (see 4.1), and the output characterization (called also output targets, classes, or labels) will be the (multi)set {Ti} ∪ {Ti1 , ..., Tim |Tij used in Pi}. Such training examples can be tuned in various ways. For example the output theorems may be further recursively expanded with their own dependencies, the input features could be expanded with the features of their definitions, various weighting schemes and similarity clusterings can be tried, etc. This is also mostly left to future general research in premise-selection learning. Once the machine learner is trained on a particular development state of the library, it is tested on the next theorem T in the chronological order. The input features are extracted from T and given to the trained learner which then answers with a ranking of the available theorems. This ranking is given to HOL Light, which uses it to produce ATP problems for T with varied numbers of the best-ranked premises.\n4.3 Proof Data Used for Learning\nAn interesting problem is getting the most useful proof dependencies for learning. Many of the original Flyspeck dependencies are clearly unnecessary for first-order theorem provers. For example the definition of the ∧ connective (AND_DEF) is a dependency of 14122 theorems. Another example are proofs done by decision procedures, which typically first apply some normalization steps justified by some lemmas, and then may perform some standard algorithm, again based on a number of lemmas. Often only a few of such dependencies are needed (i.e., the proofs found by decision procedures are often unnecessarily “complicated”).\nSome obviously unhelpful dependencies were filtered manually, and this was complemented by using also the data obtained from ATP re-proving (see Section 5.1). Vampire, E, and Z3 can together re-prove 43.2% of the Flyspeck theorems (see Table 5), which is quite a high number, useful for trying to post-process automatically the remaining dependency data or even to completely disregard them. The following approaches to combining such ATP and HOL Light dependencies were initially tried, and combined with the various characterization methods to get the training data:\nminweight (default): Always prefer the minimal ATP proof if available. On the ATP re-proved theorems collect the statistics about how likely a dependency in the HOL Light proof is really going to be used by the ATP proof, and use this likelihood as a weight when ATP proof is not available. When the weight is 0, use (cautiously) a minimal weight (0.001 or 0.000001) instead.\nnominweight: As minweight, but without a minimal weight. Totally ignore ATPirrelevant HOL Light dependencies. v_pref (e_pref, z_pref): Instead of using the minimal ATP proof, always prefer the Vampire (E, Z3) proof. Can be combined with both weighting methods. symsonly: Ignore all proofs. Learn only on examples saying that a theorem is good for proving itself, i.e., for its feature characterization. The trained system will thus recommend theorems similar to the conjecture, but not the dependencies of such theorems. atponly: Use only the (minimal) ATP proofs for learning. Ignore the HOL Light proofs completely, and construct only the symsonly training examples for theorems that have no ATP proof. Can be combined with v_pref, e_pref, z_pref.\nAt some point, a pseudo-minimization procedure started to be applied first to the ATP proofs: each proof is re-run only with the premises needed for the proof, and if the number of needed premises decreases, this is repeated until the premise count stabilizes. Often this further removes unnecessary premises that appeared in the ATP proof, e.g., by performing unnecessary rewriting steps. This was later followed by adding cross-minimization: Each proof is re-run (pseudo-minimized) not just by the ATP that found the proof, but by all ATPs. This can further improve the training data, and also raise the number of proofs found by a particular ATP quite considerably, which in turn helps when proofs by a particular ATP are preferable for learning (see the v_pref approach above). Finally, the learning and proving can boost each other’s performance: the proofs obtained by using the advice of the first-generation premise selectors can be added to the training data obtained from re-proving, and used to train the second generation of premise selectors. This process can be iterated, but only one iteration was done so far (using two different prediction methods).\nThe summary of the training data obtained by these procedures from the proofs is given in Table 3. Each of the ATP-obtained dependency sets (2–6 in Table 3) could be complemented by the HOL Light dependencies (1) as described above, producing differently trained advisors. For example, the best advising method based on (4) was only using the ATP proofs for training (no adding of HOL Light dependencies when the ATP proof was missing), preferring proofs by E (e_pref), using the symst (types instead of variables) characterizations, and choosing the best 128 premises. The new ATP proofs found using this method were added to (4), resulting in the dataset (5). The next most complementary advising method to that (measured before (5) became available) was combining the ATP dependencies from (2) with the HOL Light dependencies (1) using the nominweight and v_pref techniques, also using the symst features, and choosing the best 512 premises. The new ATP proofs found using this method were added to (5), resulting in (6). The performance of various premise selection methods is discussed in Section 5.\n4.4 Communication with the Premise Advisors\nThere are several modes in which external premise selectors can be used. The main mode used here for experiments is the offline (batch) mode. In this mode, the premise selectors are incrementally trained and tested on the whole library dependencies presented as one file in the chronological order. Incremental training/testing means that the learning system reads the examples from the file one by one, for\nthm: Number of theorems proved by the given prover. dep ø: The average number of proof dependencies in the proofs found by the prover. (1) - HOL deps: Dependencies exported from HOL Light. (2),(3): Dependencies obtained from proofs by ATPs run on HOL deps. (4): Cross-minimization of (3). (5): Added dependencies from new proofs advised by the best learning method (using (4)). (5): Added dependencies from new proofs advised by the best complementary learning method\n(trained on (2) combined with (1)). (*): The 6161 count in (3) is higher than in the final 900s experiments shown in Table 5. This\nis due to a incorrect (cyclic) dependency export for about 60 early HOL Light theorems used for (2)–(4). For training premise selection the effect of this error is negligible.\neach theorem first producing an advice (ranking of previous theorems) based only on its features, and only after that learning on the theorem’s dependencies and proceeding to the next example. The rankings are then used in HOL Light to produce all ATP problems in batch mode. This mode is good for experiments, because the learning data can be analyzed and pre-processed in various ways described above. All communication is fully file-based.\nAnother mode is used for static online advice. In this mode an (offline) pretrained premise selector receives conjecture characterizations from HOL Light over a TCP socket, replies in real time with a ranking of theorems from which HOL Light produces the ATP problems and calls the ATPs to solve them. This mode has been initially implemented as a simple online service and can already be experimented with by interested readers.27\nFinally, in a dynamic online mode the premise selector receives also training data in real time, and updates itself. The currently used learning systems support this dynamic mode, however, in an online service this mode of interaction requires some implementation of access rights, user limits, cloning of developments and services, etc. This is still future work, close to the recent work on formal mathematical editors and wikis [3, 42]."
    }, {
      "heading" : "5 Experiments",
      "text" : "The main testing set in all scenarios is constructed from the 14185 Flyspeck theorems. To be able to explore as many approaches as possible, a smaller subset\n27 The service runs at colo12-c703.uibk.ac.at on port 8080, example queries are: echo \"CARD {3,4} = 2\" | nc colo12-c703.uibk.ac.at 8080 , echo \"(A DIFF B) INTER C = EMPTY <=> (A INTER C) SUBSET B\" | nc colo12-c703.uibk.ac.at 8080 .\nof 1419 theorems is often used. This subset is stable for all such experiments, and it is constructed by taking every tenth theorem (starting with 0-th) in the chronological ordering.\nA number of first- and higher-order ATPs and SMT solvers were tried on the problems. The most extensively used are Vampire 2.6 (called also V below), modified E 1.6, and Z3 4.0. Proofs are important in the ITP/learning scenarios, so Z3 and E are (unless otherwise noted) run in a proof-producing mode. In particular for Z3 this costs some performance. E 1.6 is not run in its standard auto-mode, but in a strategy-scheduling wrapper28 used by the MaLARea system in the Mizar@Turing large-theory competition.\nThis wrapper (called either Epar or just E in the tables below) subsequently tries 14 strategies provided by the second author. These strategies were developed on the 1000 problems allowed for training large-theory AI/ATP systems before the Mizar@Turing competition [77]. Some of these strategies have become available in E 1.6 when it was released after CASC 2012, but E’s auto mode is still tuned for the TPTP library, and by default it always uses only one “best” (heuristically chosen) strategy on a problem, shunning so far the temptations of strategy scheduling. Epar outperforms the old auto-mode of E 1.4 by over 20% on the Mizar@Turing training problems, and seems to be competitive with Vampire 2.6. Fifteen more systems (or their versions) were tried to a lesser extent (typically on the 1419-problem subset) in the experiments. Some of these systems perform very well, and might be used more extensively later. Sometimes an additional effort is needed to make systems really useful; for example, proof/premise output might be missing, or additional mapping to a system’s constructs needs to be done to take full advantage of the system’s features. In this work such customizations are avoided. All the systems used are alphabetically listed in Table 4.\nUnless specified otherwise, all systems are run with 30s time limit on a 48-core server with AMD Opteron 6174 2.2 GHz CPUs, 320 GB RAM, and 0.5 MB L2 cache per CPU. Each problem is always assigned one CPU. In the tables below, basic statistics are often computed about the population of the methods used: Unique solutions found by each method, and its State of the art contribution (SOTAC) as defined by CASC.30 A system’s CASC-defined SOTAC will be highest even if the system solved only one problem (which no other system solved). That is why also the Σ-SOTAC value is used: the sum of a system’s SOTAC over all problems attempted. These metrics often indicate how productive it is to add a particular system or its version to a population of systems. Often it is interesting to know the best joint performance when running N methods in parallel. Finding such a best combination is however an instance of the classical NP-hard Maximum Coverage problem. While it is often possible to use SAT solvers to get an optimal solution, a greedy algorithm is always consistently used to avoid problems when scaling to larger datasets. This also allows us to present this joint performance as a simple greedy (covering) sequence, i.e., a sequence that starts with the best system, and each next system in such sequence is the system that greedily adds most solutions to the union of solutions of the previous systems in the sequence.\n5.1 Using External ATPs to Prove Theorems from their HOL Light Dependencies\nTable 5 shows the results of running Vampire, Epar, Z3, and Paradox on the 14185 FOF problems constructed from the HOL Light proof dependencies. The ATP success rate measured on such problems is useful as an upper estimate for the ATP success rate on the (potentially much larger) problems where all premises from the whole previous library are allowed to be used. This success rate can be used later to evaluate the performance of the algorithms that select a smaller number of the most relevant premises. The time limit for Vampire, Epar and Z3 was relatively high (900s), because particularly Vampire benefits from higher time limits (compare with Table 7) and the ATP proofs found by re-proving turn out to be more useful for training premise selectors than the original HOL Light dependencies (see Section 5.2). Paradox was run for 30 seconds to get some measure of the incompleteness of the FOF translation. The systems in Table 5 are already ordered using the greedy covering sequence, i.e., the joint performance of the top two systems is 41.9%, etc. The counter-satisfiability detected by Paradox is not by default included in the greedy sequence, since its goal is to find the strongest combination of proof-finding systems. The Paradox results are however included in the SOTAC and Unique columns.\nTable 6 shows these results restricted to the 1419-problem subset. This provides some measure of the statistical error encountered when testing systems on the\n29 For the experiments that produce proof dependencies (useful, e.g., for learning), we have used the (so far experimental) version of LEO2 that fully reconstructs the original dependencies (the “po 2” option). For the rest of the experiments (where proofs are not needed), the standard version of LEO2 is used. This version is also proof-producing, but some additional work is still needed to extract the original proof dependencies. This work is currently being done by the LEO2 developers. The “po 1” version outperforms the “po 2” version. 30 For each problem solved by a system, its SOTAC for the problem is the inverse of the number of systems that solved the problem. A system’s overall SOTAC is the average SOTAC over the problems it solves.\nTheorem (%): Number and percentage of theorems proved by a system. Unique: Number of theorems proved only by this system. SOTAC, Σ-SOTAC: See the explanatory text for these metrics. CounterSat: Number of problems found counter-satisfiable (unprovable) by this system. Greedy (%): The joint coverage of all the previous systems and this one ordered in a greedy\nsequence (see the text).\nsmaller problem set, and also a comparison of the systems’ performance under high and low time limits used in Table 7.\nTable 7 shows all tested systems on the 1419-problem subset, ordered by their absolute performance, and Table 8 shows the corresponding greedy ordering. The tested systems include also SMT solvers that use the TFF1 encoding and higherorder provers using the THF encoding. This is why it is no longer possible to aggregate the counter-satisfiability results (particularly found by Paradox) with the theoremhood results, and all the derived statistics are only computed using the Theorem column. While Vampire does well with high time limits in Table 5, it is outperformed by Z3 and E-based systems (Epar, E 1.6, LEO2-po1) when using only 30 seconds (which seem more appropriate for interactive tools than 300 or even 900 seconds). This suggests that the strategy scheduling in Vampire might benefit from further tuning on the Flyspeck data. Z3 is not run in the proof-producing mode in this experiment, which improves its performance considerably. It is not very surprising (but still evidence of solid integration work) that Isabelle performs best, as it already combines a number of other systems; see its CASC 2012 description31 for details. An initial glimpse at Isabelle’s unique solutions also shows that 75% of them are found by the recent Isabelle-specific additions (such as hard sorts) to SPASS [17] and its tighter integration with Isabelle. This is an evidence that pushing such domain knowledge inside ATPs (as done recently also with the MaLeCoP prototype [82]) might be quite rewarding. The joint performance of all systems\n31 www.cs.miami.edu/~tptp/CASC/J6/SystemDescriptions.html#Isabelle---2012\ntested is 50.2% when Isabelle is included, and 47.4% when only the base systems are allowed. This is quite encouraging, and for example the counter-satisfiability results suggest that additional performance could be gained by further (possibly heuristic/learning) work on alternative translations. Pragmatically, the joint reproving performance also tells us that when used in the MESON-tactic mode with premises explicitly provided by the users, a parallel 9-CPU machine running the nine systems from Table 8 will within 30 seconds (of real time) prove half of the Flyspeck theorems without any further interaction.\n5.2 Using External ATPs to Prove Theorems with Premise Selection\nAs described in Section 4, there are a number of various approaches and parameters influencing the training of the premise selectors. These parameters were gradually (but not exhaustively) explored, typically on the 1419-problem subset. Several times the underlying training data changed quite significantly as a result of the data-improving passes described in Section 4.3. Some of these passes were evaluating the best prediction methods developed so far on all 14185 problems. All the experiments were limited to Vampire, Epar, and Z3. For most of the experiments (and unless otherwise noted) the first-stage premise selection is used to create problems with 8, 32, 128, and 512 premises. This slicing (i.e., taking the first N premises) can be later fine-tuned, as done below in Section 5.2.2 for the best premise selection method.\nTable 9 shows an initial evaluation of 16 different learning combinations trained on ATP proofs obtained in 300s, complemented by the HOL Light proof dependencies (the second and first pass in Table 3). The two exceptions are the symst+symsonly combination, which ignores all proofs, and the syms+old+000001 combination, which uses older ATP-re-proving data obtained by running each ATP only for 30s (about 700 ATP proofs less). Each row in Table 9 is a union of twelve 30s ATP runs: Vampire, Epar, and Z3 used on the 8, 32, 128, and 512 slices. After this initial evaluation, the symst (types instead of variables) characterization was preferred, trivial symbols were always pruned out, and Winnow and Perceptron were left behind. It is of course possible that some of these methods are useful as a complement of better methods. Preferring Vampire proofs helps the learning a bit, for reasons that are not yet understood. To get the joint 39.5% performance, in general 192-fold (= 16 × 12) parallelization is needed. This number could be reduced, but first better training methods were considered."
    }, {
      "heading" : "5.2.1 Further Premise Selection Improvements",
      "text" : "Complementing the ATP dependency data with the (possibly discounted) HOL Light dependencies seems to be a plausible method. Even if the HOL Light dependencies are very redundant, the redundancies should be weighted down by the information learned from the large number of ATP proofs, and the remaining HOL Light dependencies should be in general more useful than no information at all. A possible explanation of why this approach might still be quite suboptimal (in the ATP setting) is that the HOL Light proofs are often not a good guidance for the ATP proofs, and may push the machine learners in a direction that is ATPinfeasible. A small hint that this might be the case is the good performance of the nominweight method in Table 9. This method completely ignores all HOL Light dependencies that were never used in previous ATP proofs. This suggested to test the more radical atponly approach, in which only the ATP proofs are used for training. This approach improved the best method from 29.4% to 31.9%, and added 25 newly solved problems (1.8%) to those solved by the 16 methods in Table 9. These results motivated further work on getting as many (and as minimal) ATP proofs as possible, producing the methods tagged as m10, m10u and m10u2 in the tables below. These methods were trained on the proofs obtained by 10-minute (hence m10) ATP runs that were further upgraded by the advised proofs as described in Section 4.3. The best m10u2 method raised the performance by further 0.5%, and\nB,W,P: Naive Bayes, Winnow, Perceptron. triv: Logical (trivial) symbols like conjunction are included. old+000001: Using older 30-second ATP data, and a minimal weight of 0.000001 for irrelevant\nHOL dependencies (the default weight was 0.001).\nthe learning on the advised proofs in different ways made these methods again quite orthogonal to the previous ones.\nEven though Winnow and Perceptron performed poorly (as expected from earlier unpublished experiments with MML), they added some new solutions. This motivated one simple additional experiment with the classic k-nearest neighbor (kNN) learner, which computes for a new example (conjecture) the k nearest (in a given feature distance) previous examples and ranks premises by their frequency in these examples. This is a fast (“lazy” and trivially incremental) learning method that can be easily parameterized and might for some parameters behave quite differently from naive Bayes. For large datasets a basic implementation gets slow in the evaluation phase, but on the Flyspeck dataset this was not yet a problem and full training/evaluation processing took about the same time as naive Bayes. Table 10 shows the performance of three differently parameterized k-NN instances, and Table 11 shows 8 different k-NN-based methods that together prove 29% of the problems. As expected, k-NN performs worse than naive Bayes, but much better than Winnow and Perceptron. The 160-NN and 40-NN methods indeed produce somewhat different solutions, and they are sufficiently orthogonal to the previous methods and both contribute to the performance of the final best mix of 14 prediction/ATP methods."
    }, {
      "heading" : "5.2.2 Performance of different premise slices",
      "text" : "Fig. 1 shows how the ATP performance changes when using different numbers of the best-ranked premises. This is again evaluated in 30 seconds on the 1419- problem subset, i.e., Vampire’s performance is likely to be better (compared to\nEpar) if a higher time limit was used. To a certain extent this graph serves also as a comparison of the first-stage premise selection (in this case naive Bayes trained on the minimized proofs) with the second-stage premise selection (various SInE strategies tried by the ATPs). Z3 has no second-stage premise selection, and after 250 premises the performance drops quite quickly (12.4% with 256 premises vs. 6.2% with 740 premises). For Vampire this drop is more moderate (18.1% vs. 12.9%). Epar stays over 20% with 512 premises, and drops only to 15.6% with 2048 premises. Thus, 512 premises seems to be the current “margin of error” for the first-stage premise selection that can be (at least to some extent) offset by using SInE at the second stage.\nTable 12 shows for this premise selection method the joint performance (in greedy steps) of all premise slicings, when for each slice the union of all ATPs’ solutions is taken. Only 17 slices are necessary (when using the greedy approach); the remaining 8 slices do not contribute more solutions. In general, this union would take 3 ∗17 = 51 ATP runs, however only 28 ATP runs are actually required to achieve the maximum 36.4% performance. These runs are not shown in full here, and instead only the first 14 runs that yield 35% are shown in Table 13. Assuming a 14-CPU server, 35% is thus the 30-second performance when using only one (the best) premise selection method."
    }, {
      "heading" : "5.2.3 The Final Combination and Higher Time Limits",
      "text" : "It is clear that the whole learning/ATPAI system can (and will) be (self-)improved in various interesting ways and for long time.32 When the number of small-scale evaluations reached several hundred and the main initial issues seemed corrected,\n32 In 2008, new proofs were still discovered after a month of running MaLARea on the whole MML. Analyzing the proofs and improving such AI over an interesting corpus gets addictive.\nan overall evaluation of the (greedily) best combination of 14 methods was done on the whole set of 14185 Flyspeck problems using a 300s time limit. These 14 methods together prove 39% of the theorems when given 30 seconds in parallel (see Table 14), which is also how they are run in the online service. The large scale evaluation is shown in Table 15 and Table 16. Table 15 sorts the methods by their 300s performance, and Table 16 computes the corresponding greedy covering sequence. Comparison with Table 14 shows that raising the CPU time to 300s\nhelps the individual methods (2.7% for the best one), but not so much the final combination (only 0.3% improvement).\n5.3 Union of Everything\nTables 17 shows the “union of everything”, i.e., the union of problems (limited to the 1419-problem subset) that could either be proved by an ATP from the HOL Light dependencies or by the premise selection methods. Together with Table 7 and Table 8 this also shows how much the ATP proofs obtained by premise selection methods complement the ATP proofs based only on the HOL Light dependencies.\nThe methods’ running times are not comparable: the re-proving used 30s for each system, while the data for advised methods are aggregated across E, Vampire and Z3, and across the four premise slicing methods. This means that they in general run in 12×30 seconds (although typically only one or two slices are needed for the final joint performance). The number of Flyspeck theorems that were proved by any of the many experiments conducted is thus 56.5% when Isabelle is considered, and 54.7% otherwise."
    }, {
      "heading" : "6 Initial Comparison of the Advised and Original Proofs",
      "text" : "There are 6162 theorems that can be proved by either Vampire, Z3 or E from the original HOL dependencies. Their collection is denoted as Original. There are 5580 theorems (denoted as Advised) that can be proved by these ATPs from the premises advised automatically. It is interesting to see how these two sets of ATP proofs compare. In this section, a basic comparison in terms of the number of premises used for the ATP proofs is provided. A more involved comparison and research of the proofs using the proof-complexity metrics developed for MML in [5] is left as an interesting future work. The intersection of Original and Advised contains 4694 theorems. Both sets of proofs are already minimized as described in Section 4.3. The proof dependencies were extracted33 and the number of dependencies was compared. The complete results of this comparison are available online,34 sorted by the difference between the length of the Original proof and the Advised proof. To make it easier to explore the differences described in the next subsections, the Flyspeck and HOL Light Subversion repositories were merged into one (git) repository, and (quite imperfectly) HTML-ized35 by a simple heuristic Perl script. A simple CGI script36 can be used to compare the dependencies needed for the (minimized) advised ATP proof with the dependencies needed for the ATP proof from the original HOL Light premises, and also with the actual HOL Light proof.\n6.1 Theorems Proved Only with Advice\nThe list of 885 theorems proved only with advice is available online37 sorted by the number of necessary premises. The last theorem in this order (CROSS_BASIS_NONZERO)38 used 34 premises for the advised ATP proof, while its HOL Light proof is just a single invocation of the VEC3_TAC tactic39 (which however brings in 121 HOL Light dependencies, making re-proving difficult). The following two short examples show how the advice can sometimes get simpler proofs.\n1. Theorem FACE_OF_POLYHEDRON_POLYHEDRON states that a face of a polyhedron (defined in HOL Light generally as a finite intersection of half-spaces) is again a polyhedron:\n∀s:real^N→bool c. polyhedron s ∧ c face_of s =⇒ polyhedron c\nThe HOL Light proof40 takes 23 lines and could not be re-played by ATPs, but a much simpler proof was found by the AI/ATP automation, based on (a part\n33 See http://mws.cs.ru.nl/~mptp/hh1/ATPdeps/deps_of_atp_proofs_from_hol_deps.txt and http://mws.cs.ru.nl/~mptp/hh1/ATPdeps/deps_from_advised_atp_proofs.txt. 34 http://mws.cs.ru.nl/~mptp/hh1/ATPdeps/deps_comparison.txt 35 http://mws.cs.ru.nl/~mptp/hol-flyspeck/index.html 36 e.g., http://mws.cs.ru.nl/~mptp/cgi-bin/browseproofs.cgi?refs=COMPLEX_MUL_CNJ 37 http://mws.cs.ru.nl/~mptp/hh1/ATPdeps/aonly_by_length.txt 38 http://mws.cs.ru.nl/~mptp/cgi-bin/browseproofs.cgi?refs=CROSS_BASIS_NONZERO 39 An interesting future work is to integrate calls to such tactics into the learning/ATP framework, or even to learn their construction (from similar sequences of lemmas used on similar inputs). The former task is similar to optimizing SMT solvers and tools like MetiTarski. 40 http://mws.cs.ru.nl/~mptp/cgi-bin/browseproofs.cgi?refs=FACE_OF_POLYHEDRON_ POLYHEDRON\nof) the FACE_OF_STILLCONVEX theorem: a face t of any convex set s is equal to the intersection of s with the affine hull of t. To finish the proof, one needs just three “obvious” facts: Every polyhedron is convex (POLYHEDRON_IMP_CONVEX), the intersection of two polyhedra is again a polyhedron (POLYHEDRON_INTER), and affine hull is always a polyhedron (POLYHEDRON_AFFINE_HULL):\nFACE_OF_STILLCONVEX: ∀s t:real^N→bool. convex s =⇒ (t face_of s ⇐⇒ t SUBSET s ∧ convex(s DIFF t) ∧ t = (affine hull t) INTER s) POLYHEDRON_IMP_CONVEX: ∀s:real^N→bool. polyhedron s =⇒ convex s POLYHEDRON_INTER: ∀s t:real^N→bool. polyhedron s ∧ polyhedron t =⇒ polyhedron (s INTER t) POLYHEDRON_AFFINE_HULL: ∀s. polyhedron(affine hull s)\n2. Theorem FACE_OF_AFFINE_TRIVIAL states that faces of affine sets are trivial:\n∀s f:real^N→bool. affine s ∧ f face_of s =⇒ f = ∅ ∨ f = s The HOL Light proof41 takes 19 lines and could not be re-played by ATPs. The advised proof finds a simple path via previous theorem FACE_OF_DISJOINT_RELATIVE_INTERIOR saying that nontrivial faces are disjoint with the relative interior, and theorem RELATIVE_INTERIOR_UNIV saying that any affine hull is equal to its relative interior. The rest is again just use of several “basic facts” about the topic (skipped here):\nFACE_OF_DISJOINT_RELATIVE_INTERIOR:\n∀f s:real^N→bool. f face_of s ∧ ¬(f = s) =⇒ f INTER relative_interior s = ∅\nRELATIVE_INTERIOR_UNIV: ∀s. relative_interior(affine hull s) = affine hull s\n6.2 Examples of Different Proofs\nFinally, several examples are shown where the advised ATP proof differs from the ATP proof reconstructed from the original HOL Light dependencies.\n1. Theorems COMPLEX_MUL_CNJ42 and COMPLEX_NORM_POW_2 stating the equality of squared norm to multiplication with a complex conjugate follow easily from each other (together with the commutativity of complex multiplication COMPLEX_MUL_SYM). The proof of COMPLEX_MUL_CNJ in HOL Light (below) re-uses the longer proof of COMPLEX_NORM_POW_2. The advised ATP proof directly uses COMPLEX_NORM_POW_2, but (likely because COMPLEX_MUL_SYM was never used before) first unfolds the definition of complex conjugate and then applies commutativity of real multiplication.\nlet COMPLEX_MUL_CNJ = prove (‘∀z. cnj z * z = Cx(norm(z)) pow 2 ∧ z * cnj z = Cx(norm(z)) pow 2‘, GEN_TAC THEN REWRITE_TAC[COMPLEX_MUL_SYM] THEN\nREWRITE_TAC[cnj; complex_mul; RE; IM; GSYM CX_POW; COMPLEX_SQNORM] THEN REWRITE_TAC[CX_DEF] THEN AP_TERM_TAC THEN BINOP_TAC THEN CONV_TAC REAL_RING);;\nCOMPLEX_NORM_POW_2: ∀z. Cx(norm z) pow 2 = z * cnj z COMPLEX_MUL_SYM: ∀x y. x * y = y * x\n41 http://mws.cs.ru.nl/~mptp/cgi-bin/browseproofs.cgi?refs=FACE_OF_AFFINE_\nTRIVIAL 42 http://mws.cs.ru.nl/~mptp/cgi-bin/browseproofs.cgi?refs=COMPLEX_MUL_CNJ\n2. Theorem disjoint_line_interval43 states that the left endpoints of two unitlong integer-ended intervals on the real line have to coincide if the intervals share a point strictly inside them. This suggests case analysis, which is what the longer HOL Light proof (omitted here) seems to do. The advisor instead gets the proof in a single stroke by noticing a previous theorem saying that the left endpoint is the floor function which is constant for the points inside such intervals:\ndisjoint_line_interval: ∀(x:real) (y:real). integer x ∧ integer y ∧ (∃ (z:real). x < z ∧ z < x + &1 ∧ y < z ∧ z < y + &1) =⇒ x = y\nFLOOR_UNIQUE: ∀x a. integer(a) ∧ a ≤ x ∧ x < a + &1 ⇐⇒ (floor x = a)\n3. Theorem NEGLIGIBLE_CONVEX_HULL_344 states that the convex hull of three points in R3 is a negligible set. In HOL Light this is proved from the general theorem NEGLIGIBLE_CONVEX_HULL stating this property for any finite set of points in Rn with cardinality less or equal to n. Instead of justifying this precondition, a shorter proof is found by the advised ATP that saw an analogous theorem about the affine hull, the inclusion of the convex hull in the affine hull, and the preservation of negligibility under inclusion.\nlet NEGLIGIBLE_CONVEX_HULL_3 = prove (‘∀a b c:real^3. negligible (convex hull a,b,c)‘, REPEAT GEN_TAC THEN MATCH_MP_TAC NEGLIGIBLE_CONVEX_HULL THEN\nSIMP_TAC[FINITE_INSERT; CARD_CLAUSES; FINITE_EMPTY; DIMINDEX_3] THEN ARITH_TAC);;\nNEGLIGIBLE_CONVEX_HULL: ∀s:real^N→bool. FINITE s ∧ CARD(s) ≤ dimindex(:N) =⇒ negligible(convex hull s)\nNEGLIGIBLE_AFFINE_HULL_3: ∀a b c:real^3. negligible (affine hull a,b,c) CONVEX_HULL_SUBSET_AFFINE_HULL: ∀s. (convex hull s) SUBSET (affine hull s) NEGLIGIBLE_SUBSET:\n∀s:real^N→bool t:real^N→bool. negligible s ∧ t SUBSET s =⇒ negligible t\n4. Theorem BARV_CIRCUMCENTER_EXISTS45 says that under certain assumptions, a particular point (circumcenter) lies in a particular set (affine hull). The HOL Light proof unfolds some of the assumptions and takes 14 lines. The advisor just found a related theorem MHFTTZN3 which under the same assumptions states that the singleton containing the circumcenter is equal to the intersection of the affine hull with another set. The rest are two “obvious” facts about elements of intersections (IN_INTER) and elements of singletons (IN_SING):\n43 http://mws.cs.ru.nl/~mptp/cgi-bin/browseproofs.cgi?refs=Vol1.disjoint_line_\ninterval 44 http://mws.cs.ru.nl/~mptp/cgi-bin/browseproofs.cgi?refs=NEGLIGIBLE_CONVEX_ HULL_3 45 http://mws.cs.ru.nl/~mptp/cgi-bin/browseproofs.cgi?refs=Rogers.BARV_ CIRCUMCENTER_EXISTS\nBARV_CIRCUMCENTER_EXISTS: ∀V ul k. packing V ∧ barV V k ul =⇒ circumcenter (set_of_list ul) IN affine hull (set_of_list ul)\nMHFTTZN3: ∀V ul k. packing V ∧ barV V k ul =⇒ ((affine hull (voronoi_list V ul)) INTER (affine hull (set_of_list ul)) = circumcenter (set_of_list ul) )\nIN_SING: ∀x y. x IN y:A ⇐⇒ (x = y) IN_INTER: ∀s t (x:A). x IN (s INTER t) ⇐⇒ x IN s ∧ x IN t\n5. An example of the reverse phenomenon (i.e., the advised proof is more complicated than the original) is theorem BOUNDED_CLOSURE_EQ46 saying that a set in Rn is bounded iff its closure is bounded. The harder direction of the equivalence was already available as theorem BOUNDED_CLOSURE, and was used both by the HOL Light and the advised proof. The easier direction was in HOL Light proved by theorems CLOSURE_SUBSET and BOUNDED_SUBSET saying that any set is a subset of its closure and any subset of a bounded set is bounded. The advised proof instead went through a longer path based on theorems CLOSURE_APPROACHABLE, IN_BALL and CENTRE_IN_BALL to show that every element in a set is also in its closure, and then unfolded the definition of bounded and showed that the bound on the norms of closure elements can be used also for the original set.\nlet BOUNDED_CLOSURE_EQ = prove (‘∀s:real^N→bool. bounded(closure s) ⇐⇒ bounded s‘, GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[BOUNDED_CLOSURE] THEN\nMESON_TAC[BOUNDED_SUBSET; CLOSURE_SUBSET]);;\nBOUNDED_CLOSURE: ∀s:real^N→bool. bounded s =⇒ bounded(closure s) BOUNDED_SUBSET: ∀s t. bounded t ∧ s SUBSET t =⇒ bounded s CLOSURE_SUBSET: ∀s. s SUBSET (closure s)\nCLOSURE_APPROACHABLE:\n∀x s. x IN closure(s) ⇐⇒ ∀e. &0 < e =⇒ ∃y. y IN s ∧ dist(y,x) < e IN_BALL: ∀x y e. y IN ball(x,e) ⇐⇒ dist(x,y) < e CENTRE_IN_BALL: ∀x e. x IN ball(x,e) ⇐⇒ &0 < e bounded: bounded s ⇐⇒ ∃a. ∀x:real^N. x IN s =⇒ norm(x) ≤ a\n6.3 Remarks\nThe average number of HOL Light proof dependencies restricted to the set of theorems re-proved by ATPs is 34.54, i.e., there are on average about nine times more dependencies in a HOL Light proof than in the corresponding ATP proof (see Table 3). This perhaps casts some light on how learning-assisted ATP currently achieves its performance. A large human-constructed library like Flyspeck is often dense/redundant enough47 to allow short proofs under the assumption of perfect (and thus inhuman) premise selection. Such short proofs can be found even by the quite exhaustive methods employed by most of the existing ATPs. The smarter the premise selection and the stronger the search inside the ATPs, the greater the\n46 http://mws.cs.ru.nl/~mptp/cgi-bin/browseproofs.cgi?refs=BOUNDED_CLOSURE_EQ 47 As long as such libraries are human-constructed, they will remain imperfectly organized and redundant. No “software engineering” or other approach can prevent new shortcuts to be found in mathematics, unless an exhaustive (and infeasible) proof minimization is applied.\nchance that such proofs will end up inside the ATP’s time-limited search envelope. The outcome of using such advisors extensively could be “better-informed” mathematics that has shorter proofs which use a variety of lemmas much more than the basic definitions and theorems. Whether such mathematics is easier for human consumption is not clear. Already now mathematical texts sometimes optimize proof length by lemma re-use to an extent that may make the underlying ideas less visible. Perhaps this is just another case where the strong automation tools will eventually help to understand how human cognition works.\nThe ATP search is quite unlike the much less exhaustive search done by decision procedures, and also unlike the human proofs, where the global economy of dependencies is not so crucial once a fuzzy high-level path to the goal gets some credibility. Both the human and the decision-procedure proofs result in more redundant (“sloppier”) proofs, which can however be more involved (complicated) than what the ATPs can achieve even with optimal premise selection. Learning such (precise or fuzzy) high-level pathfinding is an interesting next challenge for large-theory AI/ATP systems. With the number of proofs and theory developments to learn from available now in the HOL/Flyspeck, Mizar/MML, and Isabelle corpora, and the already relatively strong performance of the “basic” AI/ATP methods that are presented in this paper, these next steps seem to be worth a try."
    }, {
      "heading" : "7 Related Work and Contributions",
      "text" : "Related work has been mentioned throughout the paper, and some of the papers cited provide recent overviews of various aspects of our work. In particular, Blanchette’s PhD thesis and [14] give a detailed overview of the translation methods for the (extended) HOL logic used in Isabelle. See [48, 76] for recent overviews of large-theory ATP methods, and [81] for a summary of the work done over MML and its AI aspects.\nAutomated theorem proving over large theories goes back at least to Quaife’s large developments [65] with Otter [54]48 (continued to some extent by Belinfante [8]). Most of the ATP/ITP combinations developed in 1990s used ATPs on user-restricted search space. Examples include the ATPs for HOL (Light) by Harrison and Hurd mentioned above, similar work for Isabelle by Paulson [58], integration of CLAM with HOL [68] and integration of ATPs with the Omega proof assistant [55]. Dahn, Wernhard and Byliński exported Mizar/MML into the ILF format [23], created (small) ATP problems from several Mizar articles, and researched ATP-friendly encodings of Mizar’s dependent and order-sorted type system [22]. Large-theory ATP reappeared in 2002 with Voronkov’s and Riazanov’s customized Vampire answering queries over the whole SUMO ontology [61], and Urban’s MoMM (modified E) authoring tool [74] using all MML lemmas for dependently-typed subsumption of new Mizar goals. Since 2003, experiments with (unmodified) ATPs over large libraries have been carried out for MML [73] (using machine learning for premise selection) and for Isabelle/HOL (using the symbol-based Sledgehammer heuristic for premise selection). A number of large-theory ATP methods and systems (e.g., SInE, MaLARea, goal-oriented heuristics inside ATPs) have been devel-\n48 An interesting case is McAllester’s Ontic [51]. The whole library is searched automatically, but the automation is fast and intentionally incomplete.\noped recently and evaluated over large-theory benchmarks and competitions like CASC LTB and Mizar@Turing. A comprehensive comparison of ATP and Mizar proofs was recently done in [5]. As here, the average number of Mizar proof dependencies is higher than the number of ATP dependencies, however, the difference is not as striking as for HOL Light (a very different method is used to get the Mizar dependencies).\nThe work described here adds HOL Light and Flyspeck to the pool of systems and corpora accessible to large-theory AI/ATP methods and experiments. A number of large-theory techniques are re-used, sometimes the Mizar, Isabelle and CASC LTB approaches are combined and adapted to the HOL Light setting, and some of the techniques are taken further. The theorem naming, dependency export, problem creation, and advising required newly implemented HOL Light functions. The machine learning adds k-nearest neighbor, and the feature characterization was improved by replacing variables in terms with their HOL types. A MaLARealike pass interleaving ATP with learning was used to obtain as many ATP proofs as possible, and the proofs were postprocessed by pseudo- and cross-minimization. Unlike in MaLARea, this was done in a scenario that emulates the growth of the library, i.e., no information about the proofs of later theorems was used to train premise selection for earlier theorems. Motivated by the recent experiments over the MPTP2078 benchmark, the machine learning was complemented by various SInE strategies used by E and Vampire. The strategy-scheduling version of E using the strategies developed for Mizar@Turing was tested for the first time in such large evaluation. A significant effort was spent to find the most orthogonal ingredients of the final mix of premise selectors and ATPs: in total 435 different combinations were tested. The resulting 39% chance of proving the next theorem without any user advice is a landmark for a library of this size. While a similar number was achieved in [48] on the much smaller MPTP2078 benchmark with a lower time limit, only 18% success rate was recently reported in [5] for the whole MML in this fully push-button mode.49 None of those evaluations however combined so many methods as here. The improvement over the best method (proving 24.1% theorems in 30s and 26.8% in 300s) shows that such combinations significantly improve the usability of large-theory ATP methods for the end users."
    }, {
      "heading" : "8 Future Work",
      "text" : "Stronger machine learning (kernel/ensemble, etc.) methods and more suitable characterizations (e.g., addition of model-evaluation features and more abstract features) are likely to further improve the performance. The prototype online service could be made customizable by learning from users’ own proofs. So far only three ATPs are used by the service, but many other systems can eventually be added, possibly with various custom mappings to their logics. The translation methods can be further experimented with: either to get a symbol-consistent first-order translation (to allow, e.g., the model-evaluation features), or to get less incomplete translations. Proof reconstruction is currently work in progress. A simple and obvious approach is to try MESON with the minimized set of dependencies.\n49 A similar large-scale evaluation for Isabelle would be interesting. It is not clear whether the current “Judgement Day” benchmark contains goals on the same (theorem) level of granularity.\nWhen it is ready, unsound translations can be added to the pool of methods as was originally done in Isabelle Isabelle [56]. Training ATP-internal guidance on the corpus for prototype learning/ATP systems like MaLeCoP will be interesting, and perhaps also further tuning of ATP strategies for systems like E.\nThe power of the combined system probably already now makes it interesting as a complementary semantic aid/filter for first experiments with statistical translation methods between the informal Flyspeck text and the Flyspeck formalization. The cases of machine translation (as in Google Translate) and natural-language query answering (as in IBM Watson) have recently demonstrated the power of large-corpus-driven methods to automatically learn such translation/understanding layers from uncurated imperfect resources such as Wikipedia. In other words, large bodies of mathematics (and exact science) such as arXiv.org are unlikely to become computer-understandable by the current painstaking human encoding efforts and additions of further and further logic complexity layers that increase the formalization barrier both for humans and AI systems. Large-scale (worldknowledge-scale) formalization for (mathematical) masses is hard to imagine as one large “perfectly engineered” knowledge base in which everyone will know perfectly well where their knowledge fits. Such attempts seem to be as doomed as the initial attempts (in the Stone Age of Internet) to manually organize the World Wide Web in one concise directory. Gradual world-scale formalization seems more likely to happen through simpler logics that can be reasonably crowd-sourced (e.g., as Wikipedia was), assisted by AI (learning/ATP) methods continuously training and self-improving on cross-linked formal/semiformal/informal corpora expressed in simple formalisms that can be reasonably explained to such automated/AI methods."
    }, {
      "heading" : "9 Acknowledgments",
      "text" : "Tom Hales helped to start the MESON exporting work at CICM 2011, and his interest as a leader of Flyspeck has motivated us. Thanks to John Harrison for discussing MESON and related topics. Mark Adams gave us his HOL Light proof export data for HOL Zero, which made it easy to start the initial re-proving and learning experiments. Piotr Rudnicki has made his Mizar workstation available for a number of experiments (and his enthusiasm and support will be sorely missed). Andrei Paskevich has implemented the Why3 bridge to the TFF1 format just in time for our experiments. Finally, this work stands on the shoulders of many ATP and ITP (in particular HOL and Isabelle) developers, and tireless ATP competition organizers and standards producers. We are thankful to the JAR referees, PAAR 2012 referees and also to Jasmin Blanchette for their extensive comments on the early versions of this paper."
    } ],
    "references" : [ {
      "title" : "Introducing HOL Zero - (extended abstract)",
      "author" : [ "Mark Adams" ],
      "venue" : "ICMS, volume 6327 of LNCS,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2010
    }, {
      "title" : "MetiTarski: An automatic theorem prover for real-valued special functions",
      "author" : [ "Behzad Akbarpour", "Lawrence C. Paulson" ],
      "venue" : "J. Autom. Reasoning,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2010
    }, {
      "title" : "Large formal wikis: Issues and solutions",
      "author" : [ "Jesse Alama", "Kasper Brink", "Lionel Mamane", "Josef Urban" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2011
    }, {
      "title" : "Premise selection for mathematics by corpus analysis and kernel methods",
      "author" : [ "Jesse Alama", "Tom Heskes", "Daniel Kühlwein", "Evgeni Tsivtsivadze", "Josef Urban" ],
      "venue" : "J. Autom. Reasoning,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2014
    }, {
      "title" : "Automated Reasoning, 4th International Joint Conference, IJCAR 2008, Sydney, Australia",
      "author" : [ "Alessandro Armando", "Peter Baumgartner", "Gilles Dowek", "editors" ],
      "venue" : "August 12-15,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2008
    }, {
      "title" : "Automatic derivation of the irrationality of e",
      "author" : [ "Michael Beeson" ],
      "venue" : "J. Symb. Comput.,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2001
    }, {
      "title" : "On computer-assisted proofs in ordinal number theory",
      "author" : [ "Johan G.F. Belinfante" ],
      "venue" : "J. Autom. Reasoning,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1999
    }, {
      "title" : "Automated Deduction CADE-23 - 23rd International Conference on Automated Deduction",
      "author" : [ "Nikolaj Bjørner", "Viorica Sofronie-Stokkermans", "editors" ],
      "venue" : "Wroc law, Poland, July 31 - August",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2011
    }, {
      "title" : "Logic for Programming, Artificial Intelligence, and Reasoning - 18th International Conference, LPAR-18, Mérida, Venezuela",
      "author" : [ "Nikolaj Bjørner", "Andrei Voronkov", "editors" ],
      "venue" : "March 11-15,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2012
    }, {
      "title" : "Automatic Proofs and Refutations for Higher-Order Logic",
      "author" : [ "Jasmin Christian Blanchette" ],
      "venue" : "PhD thesis, Fakultät für Informatik, Technische Universität München,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2012
    }, {
      "title" : "Encoding monomorphic and polymorphic types",
      "author" : [ "Jasmin Christian Blanchette", "Sascha Böhme", "Andrei Popescu", "Nicholas Smallbone" ],
      "venue" : "editors, TACAS,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2013
    }, {
      "title" : "Automatic proof and disproof in Isabelle/HOL",
      "author" : [ "Jasmin Christian Blanchette", "Lukas Bulwahn", "Tobias Nipkow" ],
      "venue" : "FroCoS, volume 6989 of LNCS,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2011
    }, {
      "title" : "TFF1: The TPTP typed first-order form with rank-1 polymorphism",
      "author" : [ "Jasmin Christian Blanchette", "Andrei Paskevich" ],
      "venue" : "editor, CADE,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2013
    }, {
      "title" : "More SPASS with Isabelle - superposition with hard sorts and configurable simplification",
      "author" : [ "Jasmin Christian Blanchette", "Andrei Popescu", "Daniel Wand", "Christoph Weidenbach" ],
      "venue" : "In Lennart Beringer and Amy P. Felty, editors, ITP,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2012
    }, {
      "title" : "Sledgehammer: Judgement Day",
      "author" : [ "Sascha Böhme", "Tobias Nipkow" ],
      "venue" : "editors, IJCAR,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2010
    }, {
      "title" : "The SNoW Learning Architecture",
      "author" : [ "Andy Carlson", "Chad Cumby", "Jeff Rosen", "Dan Roth" ],
      "venue" : "Technical Report UIUCDCS-R-99-2101, UIUC Computer Science Department,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1999
    }, {
      "title" : "A formulation of the simple theory of types",
      "author" : [ "Alonzo Church" ],
      "venue" : "Journal of Symbolic Logic,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1940
    }, {
      "title" : "Interpretation of a Mizar-like logic in first-order logic",
      "author" : [ "Ingo Dahn" ],
      "venue" : "FTP (LNCS Selection),",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1998
    }, {
      "title" : "First order proof problems extracted from an article in the MIZAR Mathematical Library",
      "author" : [ "Ingo Dahn", "Christoph Wernhard" ],
      "venue" : "Int. Workshop on First-Order Theorem Proving (FTP’97), RISC-Linz Report Series No",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1997
    }, {
      "title" : "An Efficient SMT Solver",
      "author" : [ "Leonardo Mendonça de Moura", "Nikolaj Bjørner. Z" ],
      "venue" : "editors, TACAS,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2008
    }, {
      "title" : "The Why/Krakatoa/Caduceus platform for deductive program verification",
      "author" : [ "Jean-Christophe Filliâtre", "Claude Marché" ],
      "venue" : null,
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2007
    }, {
      "title" : "Automated Reasoning, Third International Joint Conference, IJCAR",
      "author" : [ "Ulrich Furbach", "Natarajan Shankar", "editors" ],
      "venue" : "Proceedings, volume 4130 of LNCS. Springer,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2006
    }, {
      "title" : "Knowledge Interchange Format, Version 3.0 Reference Manual",
      "author" : [ "Michael R. Genesereth", "Richard E. Fikes" ],
      "venue" : "Technical Report Logic-92-1,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 1992
    }, {
      "title" : "Automated Reasoning - 6th International Joint Conference, IJCAR",
      "author" : [ "Bernhard Gramlich", "Dale Miller", "Uli Sattler", "editors" ],
      "venue" : null,
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2012
    }, {
      "title" : "Common syntax of the DFGSchwerpunktprogramm deduction",
      "author" : [ "Reiner Hähnle", "Manfred Kerber", "Christoph Weidenbach" ],
      "venue" : "Technical Report TR 10/96,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 1996
    }, {
      "title" : "Introduction to the Flyspeck project",
      "author" : [ "Thomas C. Hales" ],
      "venue" : "Dagstuhl Seminar Proceedings,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2006
    }, {
      "title" : "Mathematics in the age of the Turing machine",
      "author" : [ "Thomas C. Hales" ],
      "venue" : "Lecture Notes in Logic,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2012
    }, {
      "title" : "A revision of the proof of the Kepler Conjecture",
      "author" : [ "Thomas C. Hales", "John Harrison", "Sean McLaughlin", "Tobias Nipkow", "Steven Obua", "Roland Zumkeller" ],
      "venue" : "Discrete & Computational Geometry,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2010
    }, {
      "title" : "HOL Light: A tutorial introduction",
      "author" : [ "John Harrison" ],
      "venue" : "FMCAD, volume 1166 of LNCS,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 1996
    }, {
      "title" : "A Mizar mode for HOL",
      "author" : [ "John Harrison" ],
      "venue" : "TPHOLs, volume 1125 of LNCS,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 1996
    }, {
      "title" : "Optimizing Proof Search in Model Elimination",
      "author" : [ "John Harrison" ],
      "venue" : "Proceedings of the 13th International Conference on Automated Deduction,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 1996
    }, {
      "title" : "The principal type-scheme of an object in combinatory logic",
      "author" : [ "R. Hindley" ],
      "venue" : "Transactions of the American Mathematical Society,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 1969
    }, {
      "title" : "Integrating Gandalf and HOL",
      "author" : [ "Joe Hurd" ],
      "venue" : "TPHOLs, volume 1690 of LNCS,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 1999
    }, {
      "title" : "An LCF-style interface between HOL and first-order logic",
      "author" : [ "Joe Hurd" ],
      "venue" : "CADE, volume 2392 of Lecture Notes in Computer Science,",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2002
    }, {
      "title" : "First-order proof tactics in higher-order logic theorem provers",
      "author" : [ "Joe Hurd" ],
      "venue" : "Technical Reports,",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 2003
    }, {
      "title" : "Web interfaces for proof assistants",
      "author" : [ "Cezary Kaliszyk" ],
      "venue" : "Electr. Notes Theor. Comput. Sci.,",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 2007
    }, {
      "title" : "Scalable LCF-style proof translation",
      "author" : [ "Cezary Kaliszyk", "Alexander Krauss" ],
      "venue" : "Proc. of the 4th International Conference on Interactive Theorem Proving (ITP’13),",
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 2013
    }, {
      "title" : "Initial experiments with external provers and premise selection on HOL Light corpora",
      "author" : [ "Cezary Kaliszyk", "Josef Urban" ],
      "venue" : "EPiC Series,",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2013
    }, {
      "title" : "First-order theorem proving and Vampire",
      "author" : [ "Laura Kovács", "Andrei Voronkov" ],
      "venue" : "CAV, volume 8044 of Lecture Notes in Computer Science,",
      "citeRegEx" : "46",
      "shortCiteRegEx" : "46",
      "year" : 2013
    }, {
      "title" : "Learning from multiple proofs: First experiments",
      "author" : [ "Daniel Kuehlwein", "Josef Urban" ],
      "venue" : "editors, PAAR-2012,",
      "citeRegEx" : "47",
      "shortCiteRegEx" : "47",
      "year" : 2013
    }, {
      "title" : "Mechanical theorem proving by model elimination",
      "author" : [ "Donald W. Loveland" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "49",
      "shortCiteRegEx" : "49",
      "year" : 1968
    }, {
      "title" : "Automated Theorem Proving: A Logical Basis",
      "author" : [ "Donald W. Loveland" ],
      "venue" : null,
      "citeRegEx" : "50",
      "shortCiteRegEx" : "50",
      "year" : 1978
    }, {
      "title" : "Ontic: a knowledge representation system for mathematics",
      "author" : [ "David A. McAllester" ],
      "venue" : null,
      "citeRegEx" : "51",
      "shortCiteRegEx" : "51",
      "year" : 1989
    }, {
      "title" : "Prover9 and Mace4. http://www.cs.unm.edu/~mccune/prover9",
      "author" : [ "William McCune" ],
      "venue" : null,
      "citeRegEx" : "52",
      "shortCiteRegEx" : "52",
      "year" : 2005
    }, {
      "title" : "Ivy: A Preprocessor and Proof Checker for First-Order Logic",
      "author" : [ "William McCune", "Olga Shumsky Matlin" ],
      "venue" : null,
      "citeRegEx" : "53",
      "shortCiteRegEx" : "53",
      "year" : 2000
    }, {
      "title" : "System description: Tramp: Transformation of machine-found proofs into nd-proofs at the assertion level",
      "author" : [ "Andreas Meier" ],
      "venue" : "CADE, volume 1831 of LNCS,",
      "citeRegEx" : "55",
      "shortCiteRegEx" : "55",
      "year" : 2000
    }, {
      "title" : "Translating higher-order clauses to first-order clauses",
      "author" : [ "Jia Meng", "Lawrence C. Paulson" ],
      "venue" : "J. Autom. Reasoning,",
      "citeRegEx" : "56",
      "shortCiteRegEx" : "56",
      "year" : 2008
    }, {
      "title" : "A generic tableau prover and its integration with Isabelle",
      "author" : [ "Lawrence C. Paulson" ],
      "venue" : "J. UCS,",
      "citeRegEx" : "58",
      "shortCiteRegEx" : "58",
      "year" : 1999
    }, {
      "title" : "Three years of experience with Sledgehammer, a practical link between automated and interactive theorem provers",
      "author" : [ "Lawrence C. Paulson", "Jasmin Blanchette" ],
      "venue" : "IWIL,",
      "citeRegEx" : "59",
      "shortCiteRegEx" : "59",
      "year" : 2010
    }, {
      "title" : "Source-level proof reconstruction for interactive theorem proving",
      "author" : [ "Lawrence C. Paulson", "Kong Woei Susanto" ],
      "venue" : "TPHOLs, volume 4732 of LNCS,",
      "citeRegEx" : "60",
      "shortCiteRegEx" : "60",
      "year" : 2007
    }, {
      "title" : "First order reasoning on a large ontology",
      "author" : [ "Adam Pease", "Geoff Sutcliffe" ],
      "venue" : "CEUR Workshop Proceedings. CEUR-WS.org,",
      "citeRegEx" : "61",
      "shortCiteRegEx" : "61",
      "year" : 2007
    }, {
      "title" : "The HOL logic",
      "author" : [ "Andrew Pitts" ],
      "venue" : null,
      "citeRegEx" : "62",
      "shortCiteRegEx" : "62",
      "year" : 1993
    }, {
      "title" : "The foundations of science: Science and hypothesis, The value of science, Science and method",
      "author" : [ "Henri Poincaré" ],
      "venue" : null,
      "citeRegEx" : "63",
      "shortCiteRegEx" : "63",
      "year" : 1913
    }, {
      "title" : "Automated Development of Fundamental Mathematical Theories",
      "author" : [ "Art Quaife" ],
      "venue" : "Kluwer Academic Publishers,",
      "citeRegEx" : "65",
      "shortCiteRegEx" : "65",
      "year" : 1992
    }, {
      "title" : "On the integrity of a repository of formalized mathematics",
      "author" : [ "Piotr Rudnicki", "Andrzej Trybulec" ],
      "venue" : "MKM, volume 2594 of LNCS,",
      "citeRegEx" : "66",
      "shortCiteRegEx" : "66",
      "year" : 2003
    }, {
      "title" : "E - A Brainiac Theorem Prover",
      "author" : [ "Stephan Schulz" ],
      "venue" : "AI Commun.,",
      "citeRegEx" : "67",
      "shortCiteRegEx" : "67",
      "year" : 2002
    }, {
      "title" : "System description: An interface between CLAM and HOL",
      "author" : [ "Konrad Slind", "Michael J.C. Gordon", "Richard J. Boulton", "Alan Bundy" ],
      "venue" : null,
      "citeRegEx" : "68",
      "shortCiteRegEx" : "68",
      "year" : 1998
    }, {
      "title" : "Automated Reasoning in Higher-Order Logic using the TPTP THF Infrastructure",
      "author" : [ "Geoff Sutcliffe", "Christoph Benzmüller" ],
      "venue" : "Journal of Formalized Reasoning,",
      "citeRegEx" : "69",
      "shortCiteRegEx" : "69",
      "year" : 2010
    }, {
      "title" : "Translating Mizar for first order theorem provers",
      "author" : [ "Josef Urban" ],
      "venue" : "In MKM, volume 2594 of LNCS,",
      "citeRegEx" : "72",
      "shortCiteRegEx" : "72",
      "year" : 2003
    }, {
      "title" : "MPTP - Motivation, Implementation, First Experiments",
      "author" : [ "Josef Urban" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "73",
      "shortCiteRegEx" : "73",
      "year" : 2004
    }, {
      "title" : "MoMM - fast interreduction and retrieval in large libraries of formalized mathematics",
      "author" : [ "Josef Urban" ],
      "venue" : "Int. J. on Artificial Intelligence Tools,",
      "citeRegEx" : "74",
      "shortCiteRegEx" : "74",
      "year" : 2006
    }, {
      "title" : "MPTP 0.2: Design, implementation, and initial experiments",
      "author" : [ "Josef Urban" ],
      "venue" : "J. Autom. Reasoning,",
      "citeRegEx" : "75",
      "shortCiteRegEx" : "75",
      "year" : 2006
    }, {
      "title" : "An Overview of Methods for Large-Theory Automated Theorem Proving (Invited Paper)",
      "author" : [ "Josef Urban" ],
      "venue" : "ATE Workshop,",
      "citeRegEx" : "76",
      "shortCiteRegEx" : "76",
      "year" : 2011
    }, {
      "title" : "BliStr: The Blind Strategymaker",
      "author" : [ "Josef Urban" ],
      "venue" : "CoRR, abs/1301.2683,",
      "citeRegEx" : "77",
      "shortCiteRegEx" : "77",
      "year" : 2014
    }, {
      "title" : "ATP and presentation service for Mizar formalizations",
      "author" : [ "Josef Urban", "Piotr Rudnicki", "Geoff Sutcliffe" ],
      "venue" : "J. Autom. Reasoning,",
      "citeRegEx" : "78",
      "shortCiteRegEx" : "78",
      "year" : 2013
    }, {
      "title" : "Automated reasoning and presentation support for formalizing mathematics in Mizar",
      "author" : [ "Josef Urban", "Geoff Sutcliffe" ],
      "venue" : null,
      "citeRegEx" : "79",
      "shortCiteRegEx" : "79",
      "year" : 2010
    }, {
      "title" : "Theorem proving in large formal mathematics as an emerging AI field",
      "author" : [ "Josef Urban", "Jǐŕı Vyskočil" ],
      "venue" : "Automated Reasoning and Mathematics: Essays in Memory of William McCune, volume 7788 of LNAI,",
      "citeRegEx" : "81",
      "shortCiteRegEx" : "81",
      "year" : 2013
    }, {
      "title" : "MaLeCoP: Machine learning connection prover",
      "author" : [ "Josef Urban", "Jǐŕı Vyskočil", "Petr Štěpánek" ],
      "venue" : "editors, TABLEAUX,",
      "citeRegEx" : "82",
      "shortCiteRegEx" : "82",
      "year" : 2011
    }, {
      "title" : "System description: SPASS version 1.0.0",
      "author" : [ "Christoph Weidenbach", "Bijan Afshordel", "Uwe Brahm", "Christian Cohrs", "Thorsten Engel", "Enno Keen", "Christian Theobalt", "Dalibor Topić" ],
      "venue" : null,
      "citeRegEx" : "84",
      "shortCiteRegEx" : "84",
      "year" : 1999
    }, {
      "title" : "SPASS Version 3.5",
      "author" : [ "Christoph Weidenbach", "Dilyana Dimova", "Arnaud Fietzke", "Rohit Kumar", "Martin Suda", "Patrick Wischnewski" ],
      "venue" : "editor, CADE,",
      "citeRegEx" : "85",
      "shortCiteRegEx" : "85",
      "year" : 2009
    }, {
      "title" : "Estimating the cost of a standard library for a mathematical proof checker",
      "author" : [ "Freek Wiedijk" ],
      "venue" : null,
      "citeRegEx" : "86",
      "shortCiteRegEx" : "86",
      "year" : 2001
    }, {
      "title" : "A synthesis of the procedural and declarative styles of interactive theorem proving",
      "author" : [ "Freek Wiedijk" ],
      "venue" : "Logical Methods in Computer Science,",
      "citeRegEx" : "87",
      "shortCiteRegEx" : "87",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 70,
      "context" : "” – Freek Wiedijk [86]",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 52,
      "context" : "]” – Henri Poincaré, Science and Method [63]",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 38,
      "context" : "Use of external first-order automated theorem provers (ATPs) like Vampire [46], E [67], SPASS [85], and recently also SMT (satisfiability modulo theories) solvers like Z3 [24] for (large-theory) formalization has been developed considerably in the recent decade.",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 55,
      "context" : "Use of external first-order automated theorem provers (ATPs) like Vampire [46], E [67], SPASS [85], and recently also SMT (satisfiability modulo theories) solvers like Z3 [24] for (large-theory) formalization has been developed considerably in the recent decade.",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 69,
      "context" : "Use of external first-order automated theorem provers (ATPs) like Vampire [46], E [67], SPASS [85], and recently also SMT (satisfiability modulo theories) solvers like Z3 [24] for (large-theory) formalization has been developed considerably in the recent decade.",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 19,
      "context" : "Use of external first-order automated theorem provers (ATPs) like Vampire [46], E [67], SPASS [85], and recently also SMT (satisfiability modulo theories) solvers like Z3 [24] for (large-theory) formalization has been developed considerably in the recent decade.",
      "startOffset" : 171,
      "endOffset" : 175
    }, {
      "referenceID" : 11,
      "context" : "Particularly in the Isabelle community, the Sledgehammer [13,15] bridge to such external tools is getting increasingly popular.",
      "startOffset" : 57,
      "endOffset" : 64
    }, {
      "referenceID" : 62,
      "context" : "Methods for automated selection of relevant knowledge and for proof guidance are actively developed [76], together with specialized automated systems targeted at particular mathematical domains [2, 7, 64].",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 1,
      "context" : "Methods for automated selection of relevant knowledge and for proof guidance are actively developed [76], together with specialized automated systems targeted at particular mathematical domains [2, 7, 64].",
      "startOffset" : 194,
      "endOffset" : 204
    }, {
      "referenceID" : 5,
      "context" : "Methods for automated selection of relevant knowledge and for proof guidance are actively developed [76], together with specialized automated systems targeted at particular mathematical domains [2, 7, 64].",
      "startOffset" : 194,
      "endOffset" : 204
    }, {
      "referenceID" : 12,
      "context" : "Formats and translation methods handling more formalization-friendly foundations are being defined [16,27,70], and metasystems that decide which ATP, translation method, strategy, parallelization, and premises to use to solve a given problem with limited resources are being designed [59, 80].",
      "startOffset" : 99,
      "endOffset" : 109
    }, {
      "referenceID" : 48,
      "context" : "Formats and translation methods handling more formalization-friendly foundations are being defined [16,27,70], and metasystems that decide which ATP, translation method, strategy, parallelization, and premises to use to solve a given problem with limited resources are being designed [59, 80].",
      "startOffset" : 284,
      "endOffset" : 292
    }, {
      "referenceID" : 52,
      "context" : "Perhaps not only Hilbert and Turing, but also the formality-opposing and intuition-oriented Poincaré [63] would have been interested to learn about the new “semantic AI paradise” of such large corpora of fully computer-understandable mathematics (from which we do not intend to be expelled).",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 28,
      "context" : "The HOL Light [34] system is probably the first among the existing well-known interactive theorem provers (ITPs) which has integrated and extensively used a general ATP procedure, the MESON tactic [36].",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 30,
      "context" : "The HOL Light [34] system is probably the first among the existing well-known interactive theorem provers (ITPs) which has integrated and extensively used a general ATP procedure, the MESON tactic [36].",
      "startOffset" : 197,
      "endOffset" : 201
    }, {
      "referenceID" : 32,
      "context" : "Hurd has developed and benchmarked early bridges [39, 40] between HOL and external systems, and his Metis system [41] has also become a significant part of the Isabelle/Sledgehammer bridge",
      "startOffset" : 49,
      "endOffset" : 57
    }, {
      "referenceID" : 33,
      "context" : "Hurd has developed and benchmarked early bridges [39, 40] between HOL and external systems, and his Metis system [41] has also become a significant part of the Isabelle/Sledgehammer bridge",
      "startOffset" : 49,
      "endOffset" : 57
    }, {
      "referenceID" : 34,
      "context" : "Hurd has developed and benchmarked early bridges [39, 40] between HOL and external systems, and his Metis system [41] has also become a significant part of the Isabelle/Sledgehammer bridge",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 26,
      "context" : "1 2012 is not just the year of Turing [32], but also of Poincaré, whose ideas about creativity and invention involving random, intuition-guided exploration confirmed by critical evaluation quite correspond to what AI systems like MaLARea [80] try to emulate in large formal theories.",
      "startOffset" : 38,
      "endOffset" : 42
    }, {
      "referenceID" : 49,
      "context" : "to ATPs [60].",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 44,
      "context" : "Using the very detailed Otter/Ivy [53] proof objects, Harrison also later implemented a bridge from HOL Light to Prover9 [52].",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 43,
      "context" : "Using the very detailed Otter/Ivy [53] proof objects, Harrison also later implemented a bridge from HOL Light to Prover9 [52].",
      "startOffset" : 121,
      "endOffset" : 125
    }, {
      "referenceID" : 64,
      "context" : "HOL Light however does not yet have a general bridge to large-theory ATP/AI (“hammer”) methods, similar to Isabelle/Sledgehammer or MizAR [78, 79], which would attempt to automatically solve a new goal by selecting relevant knowledge from the large library and running (possibly customized/trained) external ATPs on such premise selections.",
      "startOffset" : 138,
      "endOffset" : 146
    }, {
      "referenceID" : 65,
      "context" : "HOL Light however does not yet have a general bridge to large-theory ATP/AI (“hammer”) methods, similar to Isabelle/Sledgehammer or MizAR [78, 79], which would attempt to automatically solve a new goal by selecting relevant knowledge from the large library and running (possibly customized/trained) external ATPs on such premise selections.",
      "startOffset" : 138,
      "endOffset" : 146
    }, {
      "referenceID" : 25,
      "context" : "Also, thanks to the Flyspeck project [31], HOL Light is becoming less of a “single, very knowledgable formalizer” tool, and is getting increasingly used as a “tool for interested mathematicians” (such as the Flyspeck team in Hanoi) who may know the large libraries much less and have less experience with crafting their own proof tactics.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 71,
      "context" : "For such ITP users it is good to provide a small number of strong methods that allow fast progress, which can perhaps also complement the declarative modes [87] pioneered by HOL Light [35] in the LCF world.",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 29,
      "context" : "For such ITP users it is good to provide a small number of strong methods that allow fast progress, which can perhaps also complement the declarative modes [87] pioneered by HOL Light [35] in the LCF world.",
      "startOffset" : 184,
      "endOffset" : 188
    }, {
      "referenceID" : 27,
      "context" : "The purpose of the Flyspeck project is to produce a formal proof of the Kepler Conjecture [33,45].",
      "startOffset" : 90,
      "endOffset" : 97
    }, {
      "referenceID" : 54,
      "context" : "Such refactoring is often a nontrivial process [66].",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 12,
      "context" : "This includes the untyped first-order (FOF) format [71], the polymorphic typed first-order (TFF1) format [16], and the typed higher-order (THF) format [27, 69].",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 57,
      "context" : "This includes the untyped first-order (FOF) format [71], the polymorphic typed first-order (TFF1) format [16], and the typed higher-order (THF) format [27, 69].",
      "startOffset" : 151,
      "endOffset" : 159
    }, {
      "referenceID" : 9,
      "context" : ", have been described several times [12, 36, 39, 40, 56].",
      "startOffset" : 36,
      "endOffset" : 56
    }, {
      "referenceID" : 30,
      "context" : ", have been described several times [12, 36, 39, 40, 56].",
      "startOffset" : 36,
      "endOffset" : 56
    }, {
      "referenceID" : 32,
      "context" : ", have been described several times [12, 36, 39, 40, 56].",
      "startOffset" : 36,
      "endOffset" : 56
    }, {
      "referenceID" : 33,
      "context" : ", have been described several times [12, 36, 39, 40, 56].",
      "startOffset" : 36,
      "endOffset" : 56
    }, {
      "referenceID" : 46,
      "context" : ", have been described several times [12, 36, 39, 40, 56].",
      "startOffset" : 36,
      "endOffset" : 56
    }, {
      "referenceID" : 9,
      "context" : "For a comprehensive recent overview and discussion of this topic and the issues related to the translation see Blanchette’s thesis [12].",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 51,
      "context" : "HOL Light uses the HOL logic [62]: an extended variant of Church’s simple type theory [21].",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 16,
      "context" : "HOL Light uses the HOL logic [62]: an extended variant of Church’s simple type theory [21].",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 40,
      "context" : ", Pn by calling a customized first-order ATP implemented in HOL Light, which is based on the model elimination method invented by Loveland [49], later combined with a Prolog-like search tree [50].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 41,
      "context" : ", Pn by calling a customized first-order ATP implemented in HOL Light, which is based on the model elimination method invented by Loveland [49], later combined with a Prolog-like search tree [50].",
      "startOffset" : 191,
      "endOffset" : 195
    }, {
      "referenceID" : 37,
      "context" : "While re-using MESON allowed the quick initial exploration of using external ATPs and advisors described in [44], this inefficiency practically excluded the (seemingly straightforward) use of the unmodified MESON procedure as an (at least basic) translation method for generating ATP",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 58,
      "context" : "This technique is used in the Mizar/MPTP translation [72, 73, 75], where the (dependent and undecidable) soft type system cannot be separated from the core predicate logic.",
      "startOffset" : 53,
      "endOffset" : 65
    }, {
      "referenceID" : 59,
      "context" : "This technique is used in the Mizar/MPTP translation [72, 73, 75], where the (dependent and undecidable) soft type system cannot be separated from the core predicate logic.",
      "startOffset" : 53,
      "endOffset" : 65
    }, {
      "referenceID" : 61,
      "context" : "This technique is used in the Mizar/MPTP translation [72, 73, 75], where the (dependent and undecidable) soft type system cannot be separated from the core predicate logic.",
      "startOffset" : 53,
      "endOffset" : 65
    }, {
      "referenceID" : 13,
      "context" : "Indeed, for example the SPASS system includes a number of ATP techniques for both complete and incomplete work with (auto-detected) types [17,84].",
      "startOffset" : 138,
      "endOffset" : 145
    }, {
      "referenceID" : 68,
      "context" : "Indeed, for example the SPASS system includes a number of ATP techniques for both complete and incomplete work with (auto-detected) types [17,84].",
      "startOffset" : 138,
      "endOffset" : 145
    }, {
      "referenceID" : 24,
      "context" : "This approach has been in the recent years facilitated by developing type-aware TPTP standards such as TFF0, TFF1, and THF, which – unlike related typeaware efforts like DFG [30] and KIF [28] – seem to be more successful in being adopted by ATP and tool developers.",
      "startOffset" : 174,
      "endOffset" : 178
    }, {
      "referenceID" : 22,
      "context" : "This approach has been in the recent years facilitated by developing type-aware TPTP standards such as TFF0, TFF1, and THF, which – unlike related typeaware efforts like DFG [30] and KIF [28] – seem to be more successful in being adopted by ATP and tool developers.",
      "startOffset" : 187,
      "endOffset" : 191
    }, {
      "referenceID" : 12,
      "context" : "In the case of the recent TFF1 standard [16] adding HOL-like polymorphic types to first-order logic, a translation tool to the FOF and SMT formats has been developed in 2012 by Andrei Paskevich as part of the Why3 system [25], simplifying the first experiments with the non-instantiating translation.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 20,
      "context" : "In the case of the recent TFF1 standard [16] adding HOL-like polymorphic types to first-order logic, a translation tool to the FOF and SMT formats has been developed in 2012 by Andrei Paskevich as part of the Why3 system [25], simplifying the first experiments with the non-instantiating translation.",
      "startOffset" : 221,
      "endOffset" : 225
    }, {
      "referenceID" : 9,
      "context" : "Blanchette [12] reports that this optimization works fairly well for Isabelle/Sledgehammer, and gives a simple example when it introduces incompleteness.",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 46,
      "context" : "This is done in the same way as in [56].",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 31,
      "context" : "The exact types inferred by the standard HOL (Hindley-Milner [37]) type inference for the goal are as follows:",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 37,
      "context" : "In our earlier initial experiments [44], it was found that the ATP problems created from the calls to the MESON tactic in the HOL Light and Flyspeck libraries are very easy for the state-of-the-art ATPs.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 0,
      "context" : "The recent work by Adams in exporting HOL Light to HOL Zero [1] (with cross-verification as the main motivation) was initially used to obtain the theorem dependencies for the first experiments with HOL Light in [44], and after that custom theorem-exporting and dependency-tracking mechanisms were implemented as described below.",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 37,
      "context" : "The recent work by Adams in exporting HOL Light to HOL Zero [1] (with cross-verification as the main motivation) was initially used to obtain the theorem dependencies for the first experiments with HOL Light in [44], and after that custom theorem-exporting and dependency-tracking mechanisms were implemented as described below.",
      "startOffset" : 211,
      "endOffset" : 215
    }, {
      "referenceID" : 9,
      "context" : "14 Note that the typed translation that we use here prevents deriving ill-typed equalities [12].",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 36,
      "context" : "This patched version is the proof-recording component of the new HOL-Import [43], a mechanism designed to transfer proofs from HOL Light to Isabelle/HOL in an efficient way allowing the export of big repositories like Flyspeck.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 3,
      "context" : "Smaller meaningful datasets will likely be created from this large dataset for ATP/AI competitions such as CASC LTB and Mizar@Turing, analogously to the smaller MPTP2078 [4] ATP benchmark created from the ATPtranslated Mizar library (MML), and the Judgement Day benchmark [18] created by ATP translation of a subset of the Isabelle/HOL library.",
      "startOffset" : 170,
      "endOffset" : 173
    }, {
      "referenceID" : 14,
      "context" : "Smaller meaningful datasets will likely be created from this large dataset for ATP/AI competitions such as CASC LTB and Mizar@Turing, analogously to the smaller MPTP2078 [4] ATP benchmark created from the ATPtranslated Mizar library (MML), and the Judgement Day benchmark [18] created by ATP translation of a subset of the Isabelle/HOL library.",
      "startOffset" : 272,
      "endOffset" : 276
    }, {
      "referenceID" : 62,
      "context" : "See [48, 76] for recent overviews of such methods.",
      "startOffset" : 4,
      "endOffset" : 12
    }, {
      "referenceID" : 39,
      "context" : "Such data are often smaller and preferable [47].",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 3,
      "context" : "A number of machine learning algorithms can be experimented with today, and in particular kernel-based methods [4] and ensemble methods [48] have recently shown quite good performance on smaller datasets such as MPTP2078.",
      "startOffset" : 111,
      "endOffset" : 114
    }, {
      "referenceID" : 15,
      "context" : "That is why this work so far uses mostly the sparse implementation of a multiclass naive Bayes classifier provided by the SNoW system [20].",
      "startOffset" : 134,
      "endOffset" : 138
    }, {
      "referenceID" : 2,
      "context" : "This is still future work, close to the recent work on formal mathematical editors and wikis [3, 42].",
      "startOffset" : 93,
      "endOffset" : 100
    }, {
      "referenceID" : 35,
      "context" : "This is still future work, close to the recent work on formal mathematical editors and wikis [3, 42].",
      "startOffset" : 93,
      "endOffset" : 100
    }, {
      "referenceID" : 63,
      "context" : "These strategies were developed on the 1000 problems allowed for training large-theory AI/ATP systems before the Mizar@Turing competition [77].",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 13,
      "context" : "An initial glimpse at Isabelle’s unique solutions also shows that 75% of them are found by the recent Isabelle-specific additions (such as hard sorts) to SPASS [17] and its tighter integration with Isabelle.",
      "startOffset" : 160,
      "endOffset" : 164
    }, {
      "referenceID" : 67,
      "context" : "This is an evidence that pushing such domain knowledge inside ATPs (as done recently also with the MaLeCoP prototype [82]) might be quite rewarding.",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 10,
      "context" : "In particular, Blanchette’s PhD thesis and [14] give a detailed overview of the translation methods for the (extended) HOL logic used in Isabelle.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 62,
      "context" : "See [48, 76] for recent overviews of large-theory ATP methods, and [81] for a summary of the work done over MML and its AI aspects.",
      "startOffset" : 4,
      "endOffset" : 12
    }, {
      "referenceID" : 66,
      "context" : "See [48, 76] for recent overviews of large-theory ATP methods, and [81] for a summary of the work done over MML and its AI aspects.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 53,
      "context" : "Automated theorem proving over large theories goes back at least to Quaife’s large developments [65] with Otter [54] (continued to some extent by Belinfante [8]).",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 6,
      "context" : "Automated theorem proving over large theories goes back at least to Quaife’s large developments [65] with Otter [54] (continued to some extent by Belinfante [8]).",
      "startOffset" : 157,
      "endOffset" : 160
    }, {
      "referenceID" : 47,
      "context" : "Examples include the ATPs for HOL (Light) by Harrison and Hurd mentioned above, similar work for Isabelle by Paulson [58], integration of CLAM with HOL [68] and integration of ATPs with the Omega proof assistant [55].",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 56,
      "context" : "Examples include the ATPs for HOL (Light) by Harrison and Hurd mentioned above, similar work for Isabelle by Paulson [58], integration of CLAM with HOL [68] and integration of ATPs with the Omega proof assistant [55].",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 45,
      "context" : "Examples include the ATPs for HOL (Light) by Harrison and Hurd mentioned above, similar work for Isabelle by Paulson [58], integration of CLAM with HOL [68] and integration of ATPs with the Omega proof assistant [55].",
      "startOffset" : 212,
      "endOffset" : 216
    }, {
      "referenceID" : 18,
      "context" : "Dahn, Wernhard and Byliński exported Mizar/MML into the ILF format [23], created (small) ATP problems from several Mizar articles, and researched ATP-friendly encodings of Mizar’s dependent and order-sorted type system [22].",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 17,
      "context" : "Dahn, Wernhard and Byliński exported Mizar/MML into the ILF format [23], created (small) ATP problems from several Mizar articles, and researched ATP-friendly encodings of Mizar’s dependent and order-sorted type system [22].",
      "startOffset" : 219,
      "endOffset" : 223
    }, {
      "referenceID" : 50,
      "context" : "Large-theory ATP reappeared in 2002 with Voronkov’s and Riazanov’s customized Vampire answering queries over the whole SUMO ontology [61], and Urban’s MoMM (modified E) authoring tool [74] using all MML lemmas for dependently-typed subsumption of new Mizar goals.",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 60,
      "context" : "Large-theory ATP reappeared in 2002 with Voronkov’s and Riazanov’s customized Vampire answering queries over the whole SUMO ontology [61], and Urban’s MoMM (modified E) authoring tool [74] using all MML lemmas for dependently-typed subsumption of new Mizar goals.",
      "startOffset" : 184,
      "endOffset" : 188
    }, {
      "referenceID" : 59,
      "context" : "Since 2003, experiments with (unmodified) ATPs over large libraries have been carried out for MML [73] (using machine learning for premise selection) and for Isabelle/HOL (using the symbol-based Sledgehammer heuristic for premise selection).",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 42,
      "context" : "48 An interesting case is McAllester’s Ontic [51].",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 46,
      "context" : "When it is ready, unsound translations can be added to the pool of methods as was originally done in Isabelle Isabelle [56].",
      "startOffset" : 119,
      "endOffset" : 123
    } ],
    "year" : 2014,
    "abstractText" : "The considerable mathematical knowledge encoded by the Flyspeck project is combined with external automated theorem provers (ATPs) and machine-learning premise selection methods trained on the Flyspeck proofs, producing an AI system capable of proving a wide range of mathematical conjectures automatically. The performance of this architecture is evaluated in a bootstrapping scenario emulating the development of Flyspeck from axioms to the last theorem, each time using only the previous theorems and proofs. It is shown that 39% of the 14185 theorems could be proved in a push-button mode (without any high-level advice and user interaction) in 30 seconds of real time on a fourteen-CPU workstation. The necessary work involves: (i) an implementation of sound translations of the HOL Light logic to ATP formalisms: untyped first-order, polymorphic typed firstorder, and typed higher-order, (ii) export of the dependency information from HOL Light and ATP proofs for the machine learners, and (iii) choice of suitable representations and methods for learning from previous proofs, and their integration as advisors with HOL Light. This work is described and discussed here, and an initial analysis of the body of proofs that were found fully automatically is provided. Cezary Kaliszyk, supported by FWF grant P26201 University of Innsbruck, Austria Josef Urban, funded by NWO grant Knowledge-based Automated Reasoning Radboud University, Nijmegen. 2 Cezary Kaliszyk, Josef Urban",
    "creator" : "LaTeX with hyperref package"
  }
}