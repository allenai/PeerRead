{
  "name" : "1401.5674.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Generalized Biwords for Bitext Compression and Translation Spotting",
    "authors" : [ "Felipe Sánchez-Mart́ınez", "Rafael C. Carrasco", "Miguel A. Mart́ınez-Prieto" ],
    "emails" : [ "fsanchez@dlsi.ua.es", "carrasco@dlsi.ua.es", "migumar2@infor.uva.es", "jadiego@infor.uva.es" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "The increasing availability of large collections of multilingual texts has fostered the development of natural-language processing applications that address multilingual tasks —such as corpus-based machine translation (Arnold, Balkan, Meijer, Humphreys, & Sadler, 1994; Lopez, 2008; Koehn, 2010; Carl & Way, 2003), cross-language information retrieval (Grossman & Frieder, 2004, Ch. 4), the automatic extraction of bilingual lexicons (Tufis, Barbu, & Ion, 2004), and translation spotting (Simard, 2003; Véronis & Langlais, 2000). Other applications, which are monolingual in nature —e.g., syntactic parsing (Carroll, 2003), or word sense disambiguation (Ide & Véronis, 1998)— can also exploit multilingual texts by projecting the linguistic knowledge available in one language into other languages (Mihalcea & Simard, 2005).\nA bilingual parallel corpus, or bitext, is a textual collection that contains pairs of documents which are translations of one another. The documents in a pair of this nature are\nc©2012 AI Access Foundation. All rights reserved.\nsometimes called the source text and the target text, respectively. However, whenever the information as to how the document was created is unknown or irrelevant, the documents are simply called the left text and right text. In the words of Melamed (2001, p. 1), “bitexts are one of the richest sources of linguistic knowledge because the translation of a text into another language can be viewed as a detailed annotation of what that text means”.\nBitexts are usually available in a compressed form in order to reduce storage requirements, to improve access times (Ziviani, Moura, Navarro, & Baeza-Yates, 2000), and to increase the efficiency of transmissions. However, the independent compression of the two texts of a bitext is clearly far from efficient because the information contained in both texts is redundant: in theory, one of the texts might be sufficient to generate a translated version if reliable machine translation systems were already available (Nevill-Manning & Bell, 1992). The improvement in compression performance obtained when taking advantage of the fact that the two texts in a bitext are mutual translations may be regarded as an indication of the quality of word alignments (Och & Ney, 2003). This indicator, which bounds the mutual information (Cover & Thomas, 1991) in the two texts of a bitext, does not require a manually-annotated corpus to evaluate the automatic alignment.\nThe first article dealing with the compression of bitexts was published by Nevill-Manning and Bell (1992). This approach compressed one of the texts in isolation, while the other was compressed by a general prediction by partial matching (PPM; Cleary & Witten, 1984) encoder based on a model that used the automatic translation of the left text to predict the words in the right text. This model exploited two types of relations —exact word matches and synonymy relationships provided by a thesaurus— and the relative weight of both predictions depended on the number of letters in the word that had been processed. This approach obtained better compression ratios than a standard PPM coder operating on the concatenated texts.\nIn contrast, Conley and Klein (2008) have proposed text alignment —that is, pairings between the words and phrases in one text and those in the other—, as the basis for multilingual text compression. Their algorithm extends the ideas of delta-encoding (Suel & Memon, 2003) to the case in which the right text R is a translated, automatically aligned, version of the source text L: L is compressed first, and each block in R is then encoded as a reference to the parallel block in L. This method requires the computation of wordand phrase-level alignments, together with the lemmatized forms of L and R. The translated text is retrieved from these references, using a bilingual glossary together with other linguistic resources: a lemmata dictionary of words in L, a dictionary with all the possible morphological variants of each word in R, and a bilingual glossary. The authors report slight improvements in the compression of the right text R in comparison to classical compression algorithms such as bzip21 or word-based Huffman (Moffat, 1989) (approximately 1% and 6%, respectively). However, the authors do not take into consideration the size of the auxiliary files needed for the retrieval of the right text.\nIn contrast to PPM, some text-compression methods use words rather than characters as input tokens (Moffat, 1989; Moffat & Isal, 2005). Analogously, Mart́ınez-Prieto, Adiego, Sánchez-Mart́ınez, de la Fuente, and Carrasco (2009), and Adiego and his colleagues (2009, 2010) propose the use of biwords —pairs of words, each one from a different text, with a high\n1. http://www.bzip.org\nprobability of co-occurrence— as input units for the compression of bitexts. This means that a biword-based intermediate representation of the bitext is obtained by exploiting alignments, and encoding unaligned words as pairs in which one component is the empty string. Significant spatial savings are achieved with this technique (Mart́ınez-Prieto et al., 2009), although the compression of biword sequences requires larger dictionaries than the traditional text compression methods.\nThe biword-based compression approach works as a simple processing pipeline consisting of two stages (see Figure 1). After a text alignment has been obtained without pre-existing linguistic resources, the first stage transforms the bitext into a biword sequence. The second stage then compresses this sequence. Decompression works in reverse order: the biword sequence representing the bitext is first generated from the compressed file, and the original texts are then restored from this sequence.\nA variation of the PPM algorithm that takes words rather than characters as input tokens and bytes rather than bits as minimal output units (Adiego & de la Fuente, 2006) can be directly applied in order to compress biword sequences. The bitext is thus compressed using a single probabilistic model for both texts —rather than the independent models used by older bitext-compression approaches (Nevill-Manning & Bell, 1992; Conley & Klein, 2008). The improvement over general-purpose compressors obtained with this approach depends on the language pair: for instance, a reduction in the output size of almost 11% is obtained for Spanish–Portuguese, and of about 2.5% for English–French (Mart́ınez-Prieto et al., 2009).\nA different biword-based scheme called 2lcab has recently been proposed (Adiego et al., 2009) which creates a two-level dictionary to store the biwords and compresses the biword sequence with End-Tagged Dense Code (ETDC; Brisaboa, Fariña, Navarro, & Paramá, 2007). The usage of ETDC permits both Boyer-Moore-type searching (Boyer & Moore, 1977), and random access to the compressed file. If 2lcab is used as a compression booster for a standard PPM coder, further improvements in compression are obtained, but it is no longer possible to directly search in the compressed files (Adiego et al., 2010).\nThe biword sequences obtained with the former biword-based compression methods contain a large fraction —between 10% and 60%, depending on the language pair— of unpaired words, that is, biwords of which one of the words in the pair is the empty word . The unpaired words are generated in three different cases:\n• The aligner is unable to connect a word with any of the words in the parallel text because, for example, infrequent idiomatic expressions or free translations have been found.\n• The aligner generates a one-to-many alignment because a word has been translated into a multiword expression. For instance, if the Spanish word volver is translated into English as to go back, the biword extractor has to select one of the links, build a pair of words from that link, and leave the other words unpaired.\n• The aligner generates some crossing alignments as a result of word reordering in the translation. For instance, in Figure 2, either the pair (verde, green) or the pair (casa,house) must be ignored by the biword extractor, thus leaving two unpaired words; otherwise, the information provided by the sequence will not be sufficient to retrieve both texts in the original order.\nThe last two sources of unpaired words are responsible for the different spatial savings reported by Mart́ınez-Prieto et al. (2009) for bitexts consisting of closely-related languages (e.g., Spanish and Portuguese) and for those involving divergent language pairs (e.g., French and English), in which word reorderings and multiword translations are frequent.\nIn this paper, we describe and evaluate the simple biword extraction approach, and compare it with other schemes used to generate generalized biword sequences that maintain all or part of the structural information provided by the aligner. A biword essentially becomes a left word connected with a variable number of right words plus additional information concerning the relative position of each right word with regard to the preceding one. The fraction of unpaired words is thus reduced, and better compression ratios can be obtained.\nWe also show that this generalization of biwords allows for the implementation of an efficient translation spotting (Simard, 2003; Véronis & Langlais, 2000) algorithm on the compressed bitext; a task that consists of identifying the words (or text segments) in the other text that are the translation of the words in the query. Indeed, generalized biword sequences contain all the information needed in order to retrieve connected passages.\nGeneralized biwords can also be used as an ingredient in the bilingual language model employed in some statistical machine translation systems (Koehn, 2010). For instance, Mariño et al. (2006) use bilingual n-grams and consider the translation as a bilingual decoding process. Casacuberta and Vidal (2004) also exploit bilingual n-grams but apply stochastic finite-state transducers to this task. In both cases, the local reordering of words is addressed by considering multiword segments of source and target words as the fundamental translation units. Some alternative approaches (Niehues, Herrmann, Vogel, & Waibel, 2011; Matusov, Zens, Vilar, Mauser, Popović, Hasan, & Ney, 2006; Hasan, Ganitkevitch,\nNey, & Andrés-Ferrer, 2008) integrate bilingual language models as an additional feature in the decoding function that drives the statistical translation process. However, none of the approaches mentioned includes the structural information provided by the aligners as part of the bilingual language model.\nThe remainder of the paper is organized as follows. The following section shows how a generalized biword sequence can represent a bitext. Section 3 describes two different methods that can be applied to compress a biword sequence. Section 4 introduces the resources used to evaluate different generalizations of the biwords, whereas Section 5 discusses the compression results obtained. Section 6 then describes some modifications to one of these compression techniques in order to allow the compressed bitext to be searched and presents efficient search and translation spotting algorithms. Finally, some concluding remarks are presented in Section 7."
    }, {
      "heading" : "2. Extraction of Biword Sequences",
      "text" : "Before extracting the sequence of biwords representing a bitext, the alignments between the words in the left text L = l1l2 · · · lM and the words in the right text R = r1r2 · · · rN must be established by the word aligner. Word aligners usually work after a sentence aligner has identified which pairs of sentences in the bitext are parallel, that is, a plausible mutual translation. Sentence alignment algorithms are often based on simple statistical models for the correlation between sentence lengths (Brown, Lai, & Mercer, 1991; Gale & Church, 1993).\nCurrent word aligners use word-based statistical machine translation models (Brown, Cocke, Pietra, Pietra, Jelinek, Lafferty, Mercer, & Roossin, 1990; Brown, Pietra, Pietra, & Mercer, 1993) to compute the most likely alignment between the words in two parallel sentences (Koehn, 2010, Ch. 4). In our case, word alignments are computed with the opensource Giza++ toolkit2 (Och & Ney, 2003) which implements a set of methods, including standard word-based statistical machine translation models (Brown et al., 1993) and a hidden-Markov-model-based alignment model (Vogel, Ney, & Tillmann, 1996). Giza++ produces alignments such as those depicted in Figure 2, in which a source word (here, a left word) can be aligned with many target words (here, right words), whereas a target word is aligned with, at most, one source word.\nThe result of word alignment is a bigraph G = {L,R,A} in which an edge {li, rj} ∈ A between word li ∈ L and word rj ∈ R signifies that they are mutual translations according to the translation model used by the aligner. These complex structures are processed by splitting the bigraph into connected components: each connected component is either an unpaired (right or left) word, or a left word σ aligned with a sequence ρ of (one or more) right words. As will be shown later, a connected component including the structural information needed to place all the words in their original positions in the bitext is what we term as a generalized biword.\nIn order to build a sequence B of generalized biwords, biwords will be sorted primarily according to their left component σ and, secondarily, by the head of their right component ρ. More precisely, if left(β) and right(β) denote the left word and the sequence of right\n2. http://code.google.com/p/giza-pp/\nwords respectively in a biword β, and represents the empty left or right component in unpaired words, then α precedes β if and only if:\n• left(α) 6= , left(β) 6= and left(α) precedes left(β) in L.\n• Either left(α) = or left(β) = , and right(α) 6= , right(β) 6= , and the initial word in right(α) precedes, in R, the initial word in right(β).\n• left(α) = , left(β) 6= and there is no biword γ such that β precedes γ and γ precedes α.\nEvery generalized biword β = (σ, ρ, ω) in the sequence B consists of:\n• a string σ in ΣL,\n• an array of strings ρ in ΣR, and\n• an integer array ω containing one offset for every string in ρ.\nHere, ΣL denotes the set of different words in L enhanced with the empty word , while ΣR denotes the set of subsequences in R and includes the empty subsequence, represented by (). The array of offsets ω stores the structural information needed to place each word in ρ in its original position.\nThe offset is a non-negative integer that specifies, for every word in ρ that is not the first one, the number of words in R located between this word and the preceding one in ρ, thus allowing the generation stage during decompression to keep track of the gaps in the subsequence ρ that will be filled in with a word from a posterior biword in B. The offset of the first word w in ρ 6= () is defined as the number of words in R located between w and the first available gap, that is, the first word in R that belongs to a biword that does not precede β = (σ, ρ, ω).\nThe combination of both types of offsets permits the encoding of translations with word reordering. Indeed, as can be seen in Figure 3, the offset in the biword (casa, (house),(1)) signifies that there is a one-word gap between house and the which is occupied by the word green with offset 0 in (verde,(green),(0)). The offsets in (vivimos, (we,live), (0,0)) indicate that we comes directly after the word house and live comes immediately after we. The pseudo-code of the procedure that extracts the sequence of generalized biwords and further details on its implementation can be found in Appendix A.\nHenceforth, we shall call biwords with shifts those biwords with at least one non-null offset (biwords without shifts, otherwise). We shall further differentiate between biwords with simple shifts, where only the first offset is non-null, and biwords with complex shifts, with non-consecutive words in R.\nGeneralized biwords are clearly more expressive, and the bitexts will therefore be mapped onto shorter sequences. However, the enhanced variety of biwords implies that the compression algorithms must use larger dictionaries. The global effect on the compression ratio must therefore be explored. It is also worth measuring the effect of ignoring certain infrequent alignments in order to avoid biwords with complex shifts. For example, the generalized biword sequence in Figure 3 contains one biword with complex shifts, (prefiero,(i,like),(0,1)) which can be split into smaller components, such as ( ,(i),\n(0)) and (prefiero,(like),(0)), so that the sequence only includes biwords with simple shifts. If only simple shifts are allowed, the compression algorithm needs to encode, at most, one non-null offset per biword.\nIn the experiments we shall compare the results obtained when the algorithms described in the next section (Tre and 2lcab) are used in combination with four different methods to extract a sequence of biwords:\n• 1:N Complex: the one-to-many word alignments generated by Giza++ are used to generate a sequence of generalized biwords.\n• 1:N Simple: the biwords with complex shifts generated by the one-to-many alignments provided by Giza++ are split into biwords with simple shifts plus unpaired words; the result is a sequence of biwords with simple shifts or without shifts. Biwords with complex shifts are split by ignoring the least frequent alignments so that the resulting biwords only contain simple shifts.\n• 1:1 Non-monotonic: one-to-one word alignments are obtained by computing the intersection of the alignments produced by Giza++ when the left and the right text are exchanged; the result is a sequence of biwords whose right component contains, at most, one word (and these biwords cannot, therefore, have complex shifts).\n• 1:1 Monotonic: the 1:1 non-monotonic sequence is transformed into a sequence of biwords without shifts by splitting biwords with shifts into unpaired words.\nThe last method, 1:1 Monotonic, does not use the enhancement provided by the generalization of biwords (i.e., the structural information), and is therefore equivalent to the basic procedures described earlier (Mart́ınez-Prieto et al., 2009; Adiego et al., 2009, 2010)."
    }, {
      "heading" : "3. Compression of Biword Sequences",
      "text" : "It is clearly possible to compress the intermediate representation introduced in the previous section via the application of a wide range of approaches. Here, we describe and evaluate two different encoding methods, namely Tre (Subsection 3.2) and 2lcab (Subsection 3.3), that apply a word-based implementation of Huffman coding (Moffat & Turpin, 1997; Turpin\n& Moffat, 2000) in which the input strings are mapped onto integers and then compressed with Huffman codewords (Huffman, 1952). Both methods encode the offsets as described below (Subsection 3.1) but differ in how they encode the lexical components of the biword sequence.\nThe use of Huffman codewords allows the two methods described here to achieve large spatial savings, but makes it inefficient to search in the compressed bitext and to retrieve matches. In Section 6 we shall describe a variant of the 2lcab compression algorithm (searchable 2lcab) which allows a sequence of words to be retrieved in the left text in addition to the parallel sequences (and their context) in the right text."
    }, {
      "heading" : "3.1 Structural Encoding",
      "text" : "Preliminary tests showed that the biword extraction algorithm was capable of generating sequences with a high number (usually above 70%) of biwords without shifts, and an array of null values can thus be considered as the default offset sequence. The offsets can therefore be encoded as two streams of integer values:\n• The positions P = (p1, p2, . . . , pN ) of the biwords with shifts in the sequence B. These positions can be expressed in relation to the previous biword with shifts in B; for example, the biwords with shifts in Figure 3 are at P = (1, 5, 2).\n• The offset values O for the biwords with shifts. In the example, the offsets are O = (0, 1, 1, 2); the first two offsets belong to the first biword with shifts whereas the following ones belong to the second and third biword with shifts, respectively.\nBoth streams are therefore encoded by using two independent sets of Huffman codewords."
    }, {
      "heading" : "3.2 The TRE Compressor",
      "text" : "The Translation Relationship-based Encoder (Tre) assigns codewords to the left word and to the sequences of right words in the biword through the use of two independent methods. The left text is encoded using word-based Huffman coding (Moffat, 1989). In contrast, the right text is encoded by using the left text as its context. To do this, Tre uses three dictionaries: one, ΣL, with the left words, a second one, ΣR, with the sequences of right words, and a third one, the translation dictionary τB, which maps each word σ ∈ ΣL onto a subset of entries in ΣR:\nτB(σ) = {ρ ∈ ΣR : ∃ω ∈ N∗ : (σ, ρ, ω) ∈ B}.\nFor every σ ∈ ΣL the sequences in τB(σ) are sorted by frequency and assigned an integer in the range [1, |τB(σ)|], thus signifying that the most frequent translations have the lowest values.\nAt the compression stage, the text in every biword (σ, ρ, ω) is mapped onto a pair of integers —a reference to the left word σ and the integer value assigned to the sequence of right words ρ by τB(σ)—, and both sequences of integers are then compressed using independent Huffman codewords. The compression efficiency is improved because the most frequent translations are all assigned low (and thus recurrent) integer values. Finally, the compressed file includes a header with:\n• The dictionaries ΣL and ΣR, which are independently encoded using PPM compression. A special character is used to separate consecutive entries in the dictionaries and white-space serves as the delimiter in word sequences.\n• The translation dictionary τB, that is, a Huffman-compressed sequence of integers (Moffat & Turpin, 1997) containing, for every entry σ ∈ ΣL, the size of τB(σ) and the references to the entries in ΣR that store every sequence in τB(σ).\n• The independent Huffman codewords used to compress the integer sequences of σreferences, and τB(σ) values."
    }, {
      "heading" : "3.3 The 2LCAB Compressor",
      "text" : "In contrast to Tre, the 2-Level Compressor for Aligned Bitexts (2lcab; Adiego et al., 2009) encodes every biword with a single codeword based on a two-level dictionary. The first level consists of two dictionaries, ΣL and ΣR, containing the left words and the sequences of right words, respectively, that appear in the biword sequence B. The second level dictionary ΣB stores the different biwords in B as an integer sequence of alternating references to the entries in ΣL and ΣR. The text in the sequence B can then be mapped onto a sequence of references to entries in ΣB.\nThe header includes ΣL and ΣR which are compressed, as in Tre, with a PPM algorithm (Cleary & Witten, 1984). It also contains the codewords (selected according to the Huffman compression procedure) for the integers in the sequence describing the dictionary ΣB, the encoded dictionary ΣB, and a second list of Huffman codewords used to encode the biword sequence B. This implementation of 2lcab employs (bit-oriented) Huffman coding, but the original work (Adiego et al., 2009), and the application described in Section 6 implement byte-oriented ETDC (Brisaboa et al., 2007). The bit-oriented approach is more effective, but ETDC permits faster searches on the compressed bitext."
    }, {
      "heading" : "4. Resources and Settings",
      "text" : "In order to evaluate the performance of the bitext compressors based on generalized biwords we have made use of the following bitext collections:\n• A 100 MB Spanish–Catalan (es-ca) bitext obtained from El Periódico de Catalunya,3 a daily newspaper published in Catalan and Spanish.\n• A 100 MB Welsh–English (cy-en) bitext from the Proceedings of the National Assembly for Wales (Jones & Eisele, 2006).4\n• Bitexts (100 MB each) from the European Parliament Proceedings Parallel Corpus (Europarl; Koehn, 2005) for seven different language pairs: German–English (de-en), Spanish–English (es-en), Spanish–French (es-fr), Spanish–Italian (es-it), Spanish– Portuguese (es-pt), French–English (fr-en), and Finnish–English (fi-en).\n3. Available on-line at http://www.elperiodico.com. 4. Available on-line at http://xixona.dlsi.ua.es/corpora/UAGT-PNAW/.\nAs is common in information retrieval applications, the texts were tokenized and converted to lowercase (Manning & Schütze, 1999, Ch. 4). The tokenization placed blank spaces before and after every punctuation mark, and a word was thus defined as being any sequence of alphanumeric characters delimited by blank spaces.\nWord alignments were computed with the Giza++ toolkit, with all parameters set to their default values, with the exception of the fertility which was set to 5 (the default being 9). The fertility is the maximum number of words with which a word can be aligned, and a low value moderates the number of right sequences with one single occurrence in the bitext."
    }, {
      "heading" : "5. Results and Discussion",
      "text" : "As a reference, Table 1 shows the compression ratio —defined as the quotient between the lengths of the output and the input texts (Ziv & Lempel, 1977)— achieved with the aforementioned bitexts when they are compressed with a variety of general-purpose compressors and with a word-based compressor operating on the concatenation of the two texts L and R. The other approaches quoted in the introduction could not be compared because either the code or the linguistic resources required were not publicly available. The compressors used as a reference are:\n• The bzip2 compressor,5 which splits the text into blocks (100-900 KB), then, applies the Burrows-Wheeler Transform (BWT; Burrows & Wheeler, 1994) followed by a moveto-front transformation and, finally, encodes the result with a Huffman encoder.\n• Two dictionary-based compressors built on different variants of the Ziv-Lempel’s LZ77 (Ziv & Lempel, 1977) algorithm. First, gzip,6 a classical compressor that combines LZ77-based modeling with Huffman coding (Huffman, 1952). Second, the modern p7zip7 compressor based on the Lempel-Ziv-Markov chain algorithm (Sa-\n5. http://www.bzip.org. Experiments run with version 1.0.5. 6. http://www.gzip.org. Experiments were carried out with version 1.3.12-6. 7. http://www.7zip.com. Experiments were carried out using version 4.58∼dfsg1.1.\nLang. 1:1 1:1 1:N 1:N\npair Monotonic Non-monotonic Simple Complex\nen-de 20.38% 20.06% 20.26% 21.22% es-en 19.63% 18.85% 18.69% 19.33% fr-es 19.07% 18.60% 18.78% 19.51% it-es 19.21% 18.86% 19.11% 20.00% pt-es 18.44% 18.06% 18.17% 18.79% fr-en 20.20% 19.30% 19.31% 20.06% es-ca 17.02% 16.95% 16.78% 16.86% en-fi 21.50% 20.82% 21.70% 22.24% cy-en 20.06% 18.69% 18.05% 18.22%\nAs can be seen in Table 1, the lowest compression ratios are obtained with ppmdi, except for the es-ca pair. The fact that the compression ratios depend only moderately on the languages involved suggests that these compressors do not benefit from the (variable) cross-language information provided by the translations.\nThese ratios must be compared with the performance of the two compressors described in this section and presented in Tables 2 and 3. Note that although all the bitexts were aligned in both translation directions, only the results obtained with the direction producing the best compression are reported here, since the effect of this choice on the compression ratio proved to be small (an average difference of 0.2 percentage points).\nThe comparison shows that both Tre and 2lcab outperform the general-purpose compressors in all cases but that of the en-fi pair. The best results are obtained in most of the cases when one-to-one alignments are used with both techniques. 2lcab achieves slightly better results than Tre for all language pairs with the exception of it-es and pt-es, although in these two cases the difference in performance is too small to be considered relevant. The low performance for en-fi is the consequence of the larger translation\n8. http://pizzachili.dcc.uchile.cl/utils/ppmdi.tar.gz\ndictionaries used by Tre, and the larger bilingual dictionary used by 2lcab, in comparison to the other language pairs. Furthermore, the percentage of unpaired words is also higher than that of the other language pairs as will be seen below.\nTable 4 summarizes the results obtained by the general-purpose compressors and by 2lcab, and the relative gains in compression performance with regard to the generalpurpose compressors performing best, and with regard to that of 2lcab when compressing the 1:1 Monotonic biword sequence. The greatest improvement, in comparison to the results obtained for the general-purpose compressors, is achieved for the language pair es-ca: instead of the 24.4% compression ratio obtained by p7zip, 2lcab achieves a compression ratio of 16.6% which represents a substantial spatial saving (32.04% relative improvement). This suggests that Tre and 2lcab take advantage of the fact that the texts contain the\nsame information but “encoded” in different languages, particularly in the case of highly parallel bitexts (en-cy) and languages with a high syntactic correlation (es-ca).\nThe generalization of biwords generates shorter biword sequences, essentially because the sequence extracted contains a lower fraction of unpaired words. Table 5 shows the fraction of biwords in which one component is the empty word (the other being an unpaired word). This number is obviously considerably reduced when offsets are used to encode the structural information implicit in the alignments. Of course, in the case of the 1:N Complex approach, the fraction coincides with that of the bigraph produced by the aligner.\nAs expected, the effect of the generalization on the percentage of biwords with an empty component depends on the languages involved, the reduction being smaller for pairs of closely-related languages (es-ca, pt-es, and it-es) than for pairs of languages with strong grammatical divergences (en-de, es-en, and fr-en) since, in the latter case, word reorderings and multiword expressions commonly appear in translations.\nIn order to gain some insight into the performance of the Tre and 2lcab compressors, it is interesting to make a separate examination of the contribution to the output size of the headers, the dictionaries and the codewords. In this respect, it is worth noting that:\n1. The number of entries in the left dictionary ΣL does not depend on the method used to extract the biword sequence.\n2. The number of entries in the right dictionary ΣR is identical for the two extraction methods based on one-to-one alignments because it consists of all the words found in the right text plus the empty word.\nTables 6 and 7 show the fraction of the output that corresponds to the encoded biword sequence (columns B), and to the translation dictionary or biword dictionary (columns D), depending on the compressor used. These numbers reveal that the more general the biwords used are, the more compact the encoded sequences are compared to the headers and dictionaries. In particular, the translation dictionary size (analogously, the biword dictionary size) does not differ much if non-monotonic alignments are used instead of the basic method. However, the usage of one-to-many alignments causes the size of the dictionary to grow considerably, particularly in the case of the biword dictionary ΣB used by 2lcab.\nThis, in most of the cases, causes 2lcab to perform worse than Tre with one-to-many word alignments.\nThe observation that a one-to-many alignment leads to larger dictionaries makes it worth exploring the effect on the compression ratio when very infrequent biwords are discarded. Tables 8 and 9 therefore show the compression ratios obtained by Tre and 2lcab, respectively, when infrequent biwords are split into smaller, more frequent, biwords. This split proceeds iteratively by removing the least frequent alignment in the biword (which produces a new unpaired word) until all biword frequencies are above a threshold δ or the biwords only contain unpaired words. The threshold is determined by means of a ternary search which optimizes the compression ratio. The tables also show the fraction of biwords\nthat remain in the dictionary after pruning, along with the new fraction of the output that corresponds to the translation or biword dictionary.\nAs can be seen in the tables, discarding the most infrequent biwords (about two thirds of them) usually leads to an improvement in the compression ratios, except in the case of very similar languages, such as Catalan and Spanish, in which the translation is highly parallel. This effect is more important in the case of 2lcab because the pruning leads to a large reduction in the size of the biword dictionary and this compensates the small increment in the total number of biwords needed to represent the bitext (between 5% and 10% of increment depending on the method used for its generation). With this filtering, 2lcab and Tre obtain the best results when extracting the biword sequence with method 1:N Simple."
    }, {
      "heading" : "6. Translation Spotting with Compressed Bitexts",
      "text" : "The exploitation of bitexts by computer-aided translation tools has evolved from simple bilingual concordancers (Barlow, 2004; Bowker & Barlow, 2004) to advanced translation search engines (Callison-Burch, Bannard, & Schroeder, 2005a; Bourdaillet, Huet, Langlais, & Lapalme, 2010). The standard translation unit processed by bilingual concordancers are sentences, and these concordancers can thus only provide a whole sentence as the result of a translation search. In contrast, translation search engines have translation spotting capabilities, i.e. they can retrieve parallel text segments in bitexts.\nIt would seem that existing translation search engines (Callison-Burch et al., 2005a; Bourdaillet et al., 2010) do not access bitexts in their compressed forms because storing the correspondences between the translated segments requires additional data structures such as word indexes or suffix arrays (Lopez, 2007; Callison-Burch, Bannard, & Schroeder, 2005b); suffix arrays typically require four times the size of the text (Manber & Myers, 1993). In contrast, the generalized biwords require much less space, they integrate the alignment information into the compressed bitext, and this information can be exploited to retrieve translation examples. In this section we describe some minor modifications that need to be done to the 2lcab compression algorithm before it can be applied to this task. We also describe a search algorithm on the compressed bitexts and evaluate the compression performance of the new 2lcab implementation (searchable 2lcab).\nThe application of the 2lcab compression technique to the direct search in compressed bitexts leads to certain challenges which are not present during the decompression process because:\n• Huffman and PPM compression hinder both direct searching and random access to the compressed text (Bell, Cleary, & Witten, 1990).\n• In a multilevel scheme such as 2lcab, whenever a matching string is found —for instance, in the biword dictionary ΣB— it is necessary to know the string’s codeword in order to search for the encoded string in the higher level —for example, the sequence of biwords B.\nThe differences induced in 2lcab are described as follows, and are summarized in Table 10."
    }, {
      "heading" : "6.1 Searchable 2LCAB Compression",
      "text" : "There are several alternative compression methods, such as ETDC, which allow direct searches in compressed text. In contrast to the output of the Huffman compression, the ETDC header only stores words, because each codeword can be derived from the word position —henceforth, its rank— if the words are sorted according to their relative frequencies in the document which is to be compressed. This means that there is always a mapping, denoted code(n), which provides the ETDC codeword for the n-th most frequent word, along with the corresponding reverse mapping.\nFor instance, if the b-th byte in the compressed bilingual dictionary ΣB matches a leftword code, its rank in ΣB determines which codeword must be looked for in B.9 Of course, this rank can be obtained by keeping a record of the number n of words in ΣB scanned so far, but the standard pattern matching algorithms —such as BM (Boyer & Moore, 1977) or KMP (Knuth, Morris, & Pratt, 1977)— are not well suited to this tracking. We therefore use a finite sequence of bits S = b1, b2, · · · , b|S| to retrieve the rank of the n-th byte βn in the encoded ΣB. This sequence has bn = 1 for every n such that βn is the final byte in a codeword and it can be built on the fly when ΣB is read from the compressed file.\nSuccinct data structures (Navarro & Mäkinen, 2007, Sec. 6), such as RG (González, Grabowski, Mäkinen, & Navarro, 2005) and RRR (Raman, Raman, & Rao, 2002), provide an effective way in which to represent a sequence of bits and recover the rank associated with every matching sequence, because they support a number of operations in the sequence of bits S in a time that is independent of its length (Clark, 1996):\n• The number of bits rankS(i) whose value is one in b1 · · · bi.\n• The position selectS(i) of the i-th bit in S whose value is one;\n• The value of the i-th bit in S, denoted as accessS(i) = bi.\nMoreover, the structural information in P describing which the biwords with shifts are also needs to be randomly accessed, and the succinct data structure RRR provides a compact alternative to the Huffman-based method used in 2lcab to compress P, the sequence of position increments. Indeed, the RRR encoding is especially compact when the information\n9. This rank can also be used to discard false matches originated by a coincidence with a right word in ΣB because, in such cases, the rank will be an even number.\nis unbalanced —for instance, above 80% of the bits show identical value—, as in this case in which the number of biwords with shifts is small. Therefore, the integer sequence P will instead be stored as a binary sequence P = p1, p2, . . . , pm such that pi = 1 if the n-th byte in B is the final byte in the codeword of a biword with shifts.\nFinally, the offsets stored in O will be compressed with directly addressable variablelength codes (DAC, Brisaboa, Ladra, & Navarro, 2009) which, in contrast to the Huffman compression, provide direct access to the n-th encoded element. Information associated with the n-th biword can thus be retrieved immediately, since DAC encoding does not require the preceding sequence to be decompressed from the beginning. As the biwords with complex shifts contain more than one offset, the access to O in these cases is indirect and provided through an auxiliary RG data structure. This structure builds a sequence of bits Q = q1, q2, · · · , q|Q| where |Q| is the total number of offsets stored in O. The sequence Q has qi = 1 if Oi is the first offset in the array ω of a biword (σ, ρ, ω), and qi = 0 otherwise.\nAs can be seen in Table 10, the searchable 2lcab method replaces the Huffman compression with ETDC and sorts some contents so that the higher-level ETDC compression does not need to store codewords in its header."
    }, {
      "heading" : "6.2 Translation Spotting",
      "text" : "The searchable 2lcab described above is complemented with a search algorithm which, given a single word w in the left text, proceeds as follows:\n1. The word w is looked for in ΣL —whose relatively small size permits an uncompressed copy to be stored in the memory— and its identifier n, given by the word position in ΣL, is used to obtain its ETDC codeword c = code(n).\n2. An exact pattern-matching algorithm (Knuth et al., 1977) identifies all the occurrences of the codeword c in the biword dictionary ΣB. If a match is found at the b-th byte and r = rankS(b) is odd (indicating a match with a ΣL-codeword, that is, a biword with a left component w), then, the biword with codeword code(r/2) is added to the search set Z.\n3. The multi-pattern matching algorithm Set-Horspool (Horspool, 1980; Navarro & Raffinot, 2002) locates all the codewords in the sequence of biwords B that match one of those contained in Z, and the matching positions are added to a new set M .\n4. For every match m ∈M , the adjacent right component is read from B and, whenever pm = 1 in P , the offsets are recovered from O and used to place the right words in the original order. In case the biwords can have complex shifts, the interval Oi · · · Oj containing the offsets ω starts at i = selectQ(r) and ends at j = selectQ(r + 1) − 1, with r = rankP (m).\nIn case the query consists of a sequence of words (w1, w2, · · ·wK) with K > 1, the Set-Horspool algorithm is executed only for the word wk in the sequence generating the smallest set of codewords to locate Zk, and the remaining words are then used to filter the results once the biword context has been retrieved.\nTable 11 shows an actual example of the output obtained for a multiple word query and a compressed biword sequence obtained with the 1:N Complex method. Note that the\nthird match shows a non-contiguous translation, a case which cannot be retrieved with the original 2lcab implementation (Adiego et al., 2009)."
    }, {
      "heading" : "6.3 Experimental Evaluation",
      "text" : "The compression ratios obtained with the searchable 2lcab are shown in Table 12. The algorithm is clearly not as effective as the 2lcab described in Section 3, leading to compression ratios which are slightly worse than those obtained with general purpose and word-based compressors. However, it is worth to mentioning that these compressed files include the information concerning the alignments between the words, information that is not included in the files compressed with the standard compressors but is necessary to perform translation spotting.\nTable 12 also shows that the 1:1 Monotonic method is in this case more effective than the 1:1 Non-monotonic method because the latter needs an additional data structure (the RRR bit sequence) in order to access the structural information. Moreover, the byte orientation of ETDC reduces the gain obtained by encoding a lower number of biwords.\nWe have studied how the time needed to process a query depends on the language pair and also on the number and frequencies of the words in the query. The average times over 100 different sequences and 10 runs are reported in Figures 4 and 5, in which process times were measured on an AMD Athlon Dual Core at 2 GHz with 2GB of RAM.\nFigure 4 presents the times for two different language pairs. The first one, en-fr, displays the typical behavior of all Europarl bitexts (Koehn, 2005), while the second one, en-fi, requires particularly longer times, especially for large queries. This divergent behavior seems to originate in the poor quality of the alignments between the words in this pair of languages. This often makes words participate in a large number of different biwords and this degrades the performance of the Set-Horspool algorithm. This language pair consistently leads to the worst compression ratios.\nFinally, Figure 5 shows the processing times for two language pairs (en-cy and es-ca) whose bitexts have been obtained from a totally different source. The processing times are considerably lower than those required by the Europarl corpus and a manual inspection of the bitexts revealed that they have a highly parallel structure. This implies that the words participate only in a small number of biwords and, not surprisingly, 2lcab achieves the lowest compression ratios with these language pairs."
    }, {
      "heading" : "7. Concluding Remarks",
      "text" : "We have introduced the concept of generalized biwords when applied to the compression of bitexts. Generalized biwords integrate the information concerning word reordering and multiword expressions in the translated text. We have described a procedure that transforms the bitext into a sequence of generalized biwords which can be used as an intermediate representation in the compression process. We have then extended the binary compression algorithm 2lcab and proposed a new one, called Tre, for the encoding of generalized biword sequences. We have also designed a variant of the 2lcab compression technique, and a companion algorithm which facilitates efficient searching and translation spotting on the compressed bitext.\nThe compression performance of 2lcab and Tre has been tested with four different schemes to extract the biword sequence, each of which uses biwords with different structural\ncomplexities. The simplest method uses biwords without shifts and is therefore equivalent to those approaches in which biwords are simple pairs and include no structural information. The other methods include offsets to integrate the structural information of the alignments.\nOur experiments show that generalized biwords lead to better compression ratios because the reduction in the sequences encoding the bitext compensates the larger dictionaries needed. The largest reduction in the compression ratios is obtained for pairs of divergent languages because, in these cases, biwords without shifts cannot tackle the frequent word reorderings and multiword translations.\nSince the enhanced variability of generalized biwords requires larger dictionaries that increase the header included in the compressed files, we have tested the effect of splitting infrequent biwords into smaller, more frequent biwords. This reduces the number of different biwords and allows the 2lcab compressor to obtain lower compression ratios. After this pruning, 2lcab provides the best results if biwords are obtained from one-to-many word alignments in which only simple shifts are allowed, that is, the target text is only split into segments of contiguous words. Both of the algorithms, Tre and 2lcab, provide better compression ratios than general purpose compressors, particularly in the case of pairs of languages that share a common language family (es-ca) or bitexts which are highly parallel (en-cy). The compression ratio can therefore be used to indirectly measure the quality of word alignment and the degree of parallelism of the bitext.\nSome modifications made to the 2lcab compressors allow the compressed bitext to be searched efficiently, although this adaptation leads to slightly worse compression ratios. However, the new compressed file includes the alignments between the words in the bitext and this additional information is needed in order to implement translation spotting.\nThe relatively small difference in the time needed to process a query by the 1:1 Monotonic method (the fastest one) and by the 1:N Complex method (the one conveying most information) makes the latter the preferable choice in translation spotting because it identifies a larger variety of translations in the bitext and provides richer examples.\nIn our future work we plan to study the effect on translation performance of the integration of generalized, biword-based bilingual language models into current state-of-the-art statistical machine translation systems."
    }, {
      "heading" : "Appendix A. Biword Extraction Algorithm",
      "text" : "Algorithm 1 shows the procedure used to obtain the sequence of generalized biwords B from a bitext with one-to-many word alignments. The main loop (lines 3–25) iterates over the words in the left and right texts while there are still words on both sides to be considered. Variables m and n point to the next left and right words, respectively, to be processed. Inside the main loop, the set A→m with the positions of the right words aligned with the left word lm, and the set A ← n with the positions of the left words aligned with the right word rn are first computed. As word alignments are one-to-many, A ← n contains, at most, one element.\nAfter every iteration, a single biword is produced. If A→m is empty, i.e., lm is not aligned, the next biword consists of the left word lm, an empty sequence of right words and an empty sequence of offsets (line 7). If A→m is not empty but A ← n is, the biword consists of the empty word, a sequence of right words containing only rn and a sequence of offsets containing only\nAlgorithm 1 GetBiwords extracts a biword sequence from a one-to-many word alignment between two texts. Input: Two word sequences L and R, and a one-to-many bigraph G = {L,R,A} Output: A sequence B of 3-tuples (word, sequence of words, sequence of offsets)\n1: B ← () . Create an empty sequence of 3-tuples 2: m← 1; n← 1 3: while (m ≤M) ∧ (n ≤ N) do 4: A→m ← {j : (lm, rj) ∈ A} 5: A←n ← {i : (li, rn) ∈ A} 6: if A→m = ∅ then 7: add (lm, (), ()) to B 8: m← m+ 1 9: else if A←n = ∅ then\n10: add ( , (rn), (0)) to B 11: n←NextRight(m,n,G) 12: else 13: ρ← (); ω ← () . Create empty sequences of words and offsets 14: k ← n 15: for all j ∈ A→m in ascending order do 16: add rj to ρ; add j − k to ω 17: k ← j + 1 18: if n = j then 19: n←NextRight(m,n,A) 20: end if 21: end for 22: add (lm, ρ, ω) to B 23: m← m+ 1 24: end if 25: end while 26: while m ≤M do 27: add (lm, (), ()) to B 28: m← m+ 1 29: end while 30: while n ≤ N do 31: A←n ← {i : (li, rn) ∈ A} 32: if A←n = ∅ then 33: add ( , (rn), (0)) to B 34: end if 35: n← n+ 1 36: end while 37: return B\nAlgorithm 2 NextRight\nInput: Integers m and n, one-to-many bigraph G = (L,R,A) Output: Index of the next right word paired with , with lm or posterior word in L 1: repeat 2: n← n+ 1 3: A←n ← {i : (li, rn) ∈ A} 4: until (n > N) ∨ (A←n = ∅) ∨ (min(A←n ) ≥ m) 5: return n\na null offset (line 10). Otherwise, the biword consists of lm, a sequence containing all the right words aligned with lm, and a sequence containing one offset for each right word. The first offset is relative to n, whereas the following ones are relative to the previous word in the sequence (see lines 15–21).\nIndex m is simply incremented every time a biword containing a left word is produced. The update of n is more subtle since some words in positions greater than n may have already been processed because they are aligned with a left word preceding lm. n is therefore assigned the value returned by function NextRight (depicted in Algorithm 2) which, given the current values of m and n, looks for the next n such that rm is paired either with the empty word or with a left word not preceding lm.\nFinally, two loops take care of the words that remain unprocessed after the main loop."
    }, {
      "heading" : "Appendix B. Bitext Restoration Algorithm",
      "text" : "Algorithm 3 provides the pseudo-code with which to restore the right text of the bitext from the biword representation obtained with Algorithm 1. Restoring the left text is straightforward since biwords are sorted by their left component.\nThe main loop in Algorithm 3 (lines 3–15) iterates over the sequence of biwords representing the bitext. Variables m and n point to the next biword to be processed, and to the next gap in R to be filled in with a word, respectively. It then iterates over the array of offsets ω = (w1, . . . , w|ω|) (lines 7–10) and places each word ρj in the sequence of right words ρ = (ρ1, . . . , ρ|ω|) in the right place. After each biword has been processed, m is updated to point to the next biword, and n to point to the next gap in R to be filled in (lines 12–14)."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work has been supported by the Spanish Government through projects TIN2009-14009C02-01 and TIN2009-14009-C02-02, and by the Millennium Institute for Cell Dynamics and Biotechnology (grant ICM P05-001-F). During the development of the work reported in this paper, Miguel A. Mart́ınez-Prieto was at the Department of Computer Science (University of Chile) on a post-doctoral stay. The authors thanks Nieves R. Brisaboa for her ideas and cooperation in the development of the initial version of 2lcab, Gonzalo Navarro for his inspiration for the Tre compression approach, the anonymous referees for suggesting significant improvements to this paper and Francis M. Tyers for proof-reading it.\nAlgorithm 3 GetRightText retrieves the right text from the biword representation of the bitext. Input: A sequence of biwords B = (β1, . . . , βM ) Output: The right text R = r1r2 · · · rN contained in the sequence B.\n1: m← 1 2: n← 1 3: while m ≤M do 4: k = n− 1 5: ω ← offset(βm) 6: ρ← right(βm) 7: for j = 1, . . . , |ω| do 8: k ← k + ωj + 1 9: rk ← ρj\n10: end for 11: m← m+ 1 12: while rn is not undefined do 13: n← n+ 1 14: end while 15: end while 16: return R"
    } ],
    "references" : [ {
      "title" : "A two-level structure for compressing aligned bitexts",
      "author" : [ "J. Adiego", "N.R. Brisaboa", "M.A. Mart́ınez-Prieto", "F. Sánchez-Mart́ınez" ],
      "venue" : "In Proceedings of the 16th String Processing and Information Retrieval Symposium,",
      "citeRegEx" : "Adiego et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Adiego et al\\.",
      "year" : 2009
    }, {
      "title" : "Mapping words into codewords on PPM",
      "author" : [ "J. Adiego", "P. de la Fuente" ],
      "venue" : "In Proceedings of the 13th String Processing and Information Retrieval Symposium,",
      "citeRegEx" : "Adiego and Fuente,? \\Q2006\\E",
      "shortCiteRegEx" : "Adiego and Fuente",
      "year" : 2006
    }, {
      "title" : "Modelling parallel texts for boosting compression",
      "author" : [ "J. Adiego", "M.A. Mart́ınez-Prieto", "J.E. Hoyos-Torio", "F. Sánchez-Mart́ınez" ],
      "venue" : "In Proceedings of the 2010 Data Compression Conference,",
      "citeRegEx" : "Adiego et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Adiego et al\\.",
      "year" : 2010
    }, {
      "title" : "Machine translation: An introductory guide",
      "author" : [ "D. Arnold", "L. Balkan", "S. Meijer", "R. Humphreys", "L. Sadler" ],
      "venue" : null,
      "citeRegEx" : "Arnold et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Arnold et al\\.",
      "year" : 1994
    }, {
      "title" : "Parallel concordancing and translation",
      "author" : [ "M. Barlow" ],
      "venue" : "Proceedings of ASLIB Translating and the Computer 26, London, UK.",
      "citeRegEx" : "Barlow,? 2004",
      "shortCiteRegEx" : "Barlow",
      "year" : 2004
    }, {
      "title" : "TransSearch: from a bilingual concordancer to a translation finder",
      "author" : [ "J. Bourdaillet", "S. Huet", "P. Langlais", "G. Lapalme" ],
      "venue" : "Machine Translation,",
      "citeRegEx" : "Bourdaillet et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Bourdaillet et al\\.",
      "year" : 2010
    }, {
      "title" : "Bilingual concordancers and translation memories: a comparative evaluation",
      "author" : [ "L. Bowker", "M. Barlow" ],
      "venue" : "In Proceedings of the Second International Workshop",
      "citeRegEx" : "Bowker and Barlow,? \\Q2004\\E",
      "shortCiteRegEx" : "Bowker and Barlow",
      "year" : 2004
    }, {
      "title" : "A fast string searching algorithm",
      "author" : [ "R. Boyer", "J.S. Moore" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "Boyer and Moore,? \\Q1977\\E",
      "shortCiteRegEx" : "Boyer and Moore",
      "year" : 1977
    }, {
      "title" : "Directly addressable variable-length codes",
      "author" : [ "N. Brisaboa", "S. Ladra", "G. Navarro" ],
      "venue" : "In Proceedings of the 16th String Processing and Information Retrieval Symposium,",
      "citeRegEx" : "Brisaboa et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Brisaboa et al\\.",
      "year" : 2009
    }, {
      "title" : "Lightweight natural language text compression",
      "author" : [ "N.R. Brisaboa", "A. Fariña", "G. Navarro", "J.R. Paramá" ],
      "venue" : "Information Retrieval,",
      "citeRegEx" : "Brisaboa et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Brisaboa et al\\.",
      "year" : 2007
    }, {
      "title" : "Aligning sentences in parallel corpora",
      "author" : [ "P. Brown", "J. Lai", "R. Mercer" ],
      "venue" : "In Proceedings of the 29th Annual Meeting of the Association for Computational Linguistics,",
      "citeRegEx" : "Brown et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Brown et al\\.",
      "year" : 1991
    }, {
      "title" : "A statistical approach to machine translation",
      "author" : [ "P.F. Brown", "J. Cocke", "S.A.D. Pietra", "V.J.D. Pietra", "F. Jelinek", "J.D. Lafferty", "R.L. Mercer", "P.S. Roossin" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Brown et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "Brown et al\\.",
      "year" : 1990
    }, {
      "title" : "The mathematics of statistical machine translation: Parameter estimation",
      "author" : [ "P.F. Brown", "S.A.D. Pietra", "V.J.D. Pietra", "R.L. Mercer" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Brown et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Brown et al\\.",
      "year" : 1993
    }, {
      "title" : "A block sorting lossless data compression algorithm",
      "author" : [ "M. Burrows", "D. Wheeler" ],
      "venue" : "Tech. rep. 124,",
      "citeRegEx" : "Burrows and Wheeler,? \\Q1994\\E",
      "shortCiteRegEx" : "Burrows and Wheeler",
      "year" : 1994
    }, {
      "title" : "A compact data structure for searchable translation memories",
      "author" : [ "C. Callison-Burch", "C. Bannard", "J. Schroeder" ],
      "venue" : "In Proceedings of the 10th European Association for Machine Translation Conference,",
      "citeRegEx" : "Callison.Burch et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Callison.Burch et al\\.",
      "year" : 2005
    }, {
      "title" : "Scaling phrase-based statistical machine translation to larger corpora and longer phrases",
      "author" : [ "C. Callison-Burch", "C. Bannard", "J. Schroeder" ],
      "venue" : "In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics,",
      "citeRegEx" : "Callison.Burch et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Callison.Burch et al\\.",
      "year" : 2005
    }, {
      "title" : "Recent Advances in Example-Based Machine Translation, Vol. 21 of Text, Speech and Language",
      "author" : [ "M. Carl", "A. Way" ],
      "venue" : null,
      "citeRegEx" : "Carl and Way,? \\Q2003\\E",
      "shortCiteRegEx" : "Carl and Way",
      "year" : 2003
    }, {
      "title" : "The Oxford Handbook of Computational Linguistics, chap",
      "author" : [ "J. Carroll" ],
      "venue" : "12 Parsing, pp. 233–248. Oxford University Press.",
      "citeRegEx" : "Carroll,? 2003",
      "shortCiteRegEx" : "Carroll",
      "year" : 2003
    }, {
      "title" : "Machine translation with inferred stochastic finite-state transducers",
      "author" : [ "F. Casacuberta", "E. Vidal" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Casacuberta and Vidal,? \\Q2004\\E",
      "shortCiteRegEx" : "Casacuberta and Vidal",
      "year" : 2004
    }, {
      "title" : "Compact PAT trees",
      "author" : [ "D. Clark" ],
      "venue" : "Ph.D. thesis, University of Waterloo, Warteloo, ON, Canada.",
      "citeRegEx" : "Clark,? 1996",
      "shortCiteRegEx" : "Clark",
      "year" : 1996
    }, {
      "title" : "Data compression using adaptive coding and partial string matching",
      "author" : [ "J.G. Cleary", "I.H. Witten" ],
      "venue" : "IEEE Transactions on Communications,",
      "citeRegEx" : "Cleary and Witten,? \\Q1984\\E",
      "shortCiteRegEx" : "Cleary and Witten",
      "year" : 1984
    }, {
      "title" : "Using alignment for multilingual text compression",
      "author" : [ "E. Conley", "S. Klein" ],
      "venue" : "International Journal of Foundations of Computer Science,",
      "citeRegEx" : "Conley and Klein,? \\Q2008\\E",
      "shortCiteRegEx" : "Conley and Klein",
      "year" : 2008
    }, {
      "title" : "A program for aligning sentences in bilingual corpora",
      "author" : [ "W.A. Gale", "K.W. Church" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Gale and Church,? \\Q1993\\E",
      "shortCiteRegEx" : "Gale and Church",
      "year" : 1993
    }, {
      "title" : "Practical implementation of rank and select queries",
      "author" : [ "R. González", "S. Grabowski", "V. Mäkinen", "G. Navarro" ],
      "venue" : "In Proceedings of the 4th International Workshop on Efficient and Experimental Algorithms,",
      "citeRegEx" : "González et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "González et al\\.",
      "year" : 2005
    }, {
      "title" : "Information Retrieval: Algorithms and Heuristics (2nd edition)., Vol. 15 of The Information Retrieval",
      "author" : [ "D.A. Grossman", "O. Frieder" ],
      "venue" : null,
      "citeRegEx" : "Grossman and Frieder,? \\Q2004\\E",
      "shortCiteRegEx" : "Grossman and Frieder",
      "year" : 2004
    }, {
      "title" : "Triplet lexicon models for statistical machine translation",
      "author" : [ "S. Hasan", "J. Ganitkevitch", "H. Ney", "J. Andrés-Ferrer" ],
      "venue" : "In Proceedings of the 2008 Conference on Empirical Methods on Natural Language Processing,",
      "citeRegEx" : "Hasan et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Hasan et al\\.",
      "year" : 2008
    }, {
      "title" : "Practical fast searching in strings",
      "author" : [ "R.N. Horspool" ],
      "venue" : "Software: Practice and Experience, 10 (6), 501–506.",
      "citeRegEx" : "Horspool,? 1980",
      "shortCiteRegEx" : "Horspool",
      "year" : 1980
    }, {
      "title" : "Practical implementations of arithmetic coding",
      "author" : [ "P. Howard", "J. Vitter" ],
      "venue" : "Image and Text Compression,",
      "citeRegEx" : "Howard and Vitter,? \\Q1992\\E",
      "shortCiteRegEx" : "Howard and Vitter",
      "year" : 1992
    }, {
      "title" : "A method for the construction of minimum-redundancy codes",
      "author" : [ "D. Huffman" ],
      "venue" : "Proceedings of the Institute of Radio Engineers, 40 (9), 1098–1101.",
      "citeRegEx" : "Huffman,? 1952",
      "shortCiteRegEx" : "Huffman",
      "year" : 1952
    }, {
      "title" : "Word sense disambiguation: The state of the art",
      "author" : [ "N. Ide", "J. Véronis" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Ide and Véronis,? \\Q1998\\E",
      "shortCiteRegEx" : "Ide and Véronis",
      "year" : 1998
    }, {
      "title" : "Phrase-based statistical machine translation between English and Welsh",
      "author" : [ "D. Jones", "A. Eisele" ],
      "venue" : "In Proceedings of the 5th SALTMIL Workshop on Minority Languages at the 5th International Conference on Language Resources and Evaluation,",
      "citeRegEx" : "Jones and Eisele,? \\Q2006\\E",
      "shortCiteRegEx" : "Jones and Eisele",
      "year" : 2006
    }, {
      "title" : "Fast pattern matching in strings",
      "author" : [ "D.E. Knuth", "J.H. Morris", "V. Pratt" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "Knuth et al\\.,? \\Q1977\\E",
      "shortCiteRegEx" : "Knuth et al\\.",
      "year" : 1977
    }, {
      "title" : "Europarl: A parallel corpus for statistical machine translation",
      "author" : [ "P. Koehn" ],
      "venue" : "Proceedings of the Tenth Machine Translation Summit, pp. 79–86, Phuket, Thailand.",
      "citeRegEx" : "Koehn,? 2005",
      "shortCiteRegEx" : "Koehn",
      "year" : 2005
    }, {
      "title" : "Statistical Machine Translation",
      "author" : [ "P. Koehn" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "Koehn,? 2010",
      "shortCiteRegEx" : "Koehn",
      "year" : 2010
    }, {
      "title" : "Hierarchical phrase-based translation with suffix arrays",
      "author" : [ "A. Lopez" ],
      "venue" : "Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pp. 976–985, Prague, Czech Republic.",
      "citeRegEx" : "Lopez,? 2007",
      "shortCiteRegEx" : "Lopez",
      "year" : 2007
    }, {
      "title" : "Statistical machine translation",
      "author" : [ "A. Lopez" ],
      "venue" : "ACM Computing Surveys, 40 (3), 1–49.",
      "citeRegEx" : "Lopez,? 2008",
      "shortCiteRegEx" : "Lopez",
      "year" : 2008
    }, {
      "title" : "Suffix arrays: a new method for on-line string searches",
      "author" : [ "U. Manber", "G. Myers" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "Manber and Myers,? \\Q1993\\E",
      "shortCiteRegEx" : "Manber and Myers",
      "year" : 1993
    }, {
      "title" : "Foundations of statistical natural language processing",
      "author" : [ "C.D. Manning", "H. Schütze" ],
      "venue" : null,
      "citeRegEx" : "Manning and Schütze,? \\Q1999\\E",
      "shortCiteRegEx" : "Manning and Schütze",
      "year" : 1999
    }, {
      "title" : "N-gram-based machine translation",
      "author" : [ "J. Mariño", "R.E. Banchs", "J.M. Crego", "A. de Gispert", "P. Lambert", "J.A.R. Fonollosa", "M.R. Costa-Jussà" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Mariño et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Mariño et al\\.",
      "year" : 2006
    }, {
      "title" : "Range encoding: an algorithm for removing redundancy from a digitized message",
      "author" : [ "G. Martin" ],
      "venue" : "Proceedings of Video and Data Recording Conference, Southampton, UK.",
      "citeRegEx" : "Martin,? 1979",
      "shortCiteRegEx" : "Martin",
      "year" : 1979
    }, {
      "title" : "On the use of word alignments to enhance bitext compression",
      "author" : [ "M.A. Mart́ınez-Prieto", "J. Adiego", "F. Sánchez-Mart́ınez", "P. de la Fuente", "R.C. Carrasco" ],
      "venue" : "In Proceedings of the 2009 Data Compression Conference,",
      "citeRegEx" : "Mart́ınez.Prieto et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Mart́ınez.Prieto et al\\.",
      "year" : 2009
    }, {
      "title" : "The RWTH machine translation system",
      "author" : [ "E. Matusov", "R. Zens", "D. Vilar", "A. Mauser", "M. Popović", "S. Hasan", "H. Ney" ],
      "venue" : "In Proceedings of the TC-STAR Workshop on Speech-to-Speech Translation,",
      "citeRegEx" : "Matusov et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Matusov et al\\.",
      "year" : 2006
    }, {
      "title" : "Emplirical methods for exploting parallel texts",
      "author" : [ "I.D. Melamed" ],
      "venue" : "MIT Press.",
      "citeRegEx" : "Melamed,? 2001",
      "shortCiteRegEx" : "Melamed",
      "year" : 2001
    }, {
      "title" : "Word-based text compression",
      "author" : [ "A. Moffat" ],
      "venue" : "Software: Practice and Experience, 19 (2), 185–198.",
      "citeRegEx" : "Moffat,? 1989",
      "shortCiteRegEx" : "Moffat",
      "year" : 1989
    }, {
      "title" : "Word-based text compression using the Burrows-Wheeler transform",
      "author" : [ "A. Moffat", "R.Y.K. Isal" ],
      "venue" : "Information Processing and Management,",
      "citeRegEx" : "Moffat and Isal,? \\Q2005\\E",
      "shortCiteRegEx" : "Moffat and Isal",
      "year" : 2005
    }, {
      "title" : "On the implementation of minimum redundancy prefix codes",
      "author" : [ "A. Moffat", "A. Turpin" ],
      "venue" : "IEEE Transactions on Communications,",
      "citeRegEx" : "Moffat and Turpin,? \\Q1997\\E",
      "shortCiteRegEx" : "Moffat and Turpin",
      "year" : 1997
    }, {
      "title" : "Compressed full-text indexes",
      "author" : [ "G. Navarro", "V. Mäkinen" ],
      "venue" : "ACM Computing Surveys,",
      "citeRegEx" : "Navarro and Mäkinen,? \\Q2007\\E",
      "shortCiteRegEx" : "Navarro and Mäkinen",
      "year" : 2007
    }, {
      "title" : "Flexible Pattern Matching in String: Practical on-line search algorithms for texts and biological sequences",
      "author" : [ "G. Navarro", "M. Raffinot" ],
      "venue" : null,
      "citeRegEx" : "Navarro and Raffinot,? \\Q2002\\E",
      "shortCiteRegEx" : "Navarro and Raffinot",
      "year" : 2002
    }, {
      "title" : "Compression of parallel texts",
      "author" : [ "C. Nevill-Manning", "T. Bell" ],
      "venue" : "Information Processing & Management,",
      "citeRegEx" : "Nevill.Manning and Bell,? \\Q1992\\E",
      "shortCiteRegEx" : "Nevill.Manning and Bell",
      "year" : 1992
    }, {
      "title" : "Wider context by using bilingual language models in machine translation",
      "author" : [ "J. Niehues", "T. Herrmann", "S. Vogel", "A. Waibel" ],
      "venue" : "In Proceedings of the 6th Workshop on Statistical Machine Translation,",
      "citeRegEx" : "Niehues et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Niehues et al\\.",
      "year" : 2011
    }, {
      "title" : "A systematic comparison of various statistical alignment models",
      "author" : [ "F.J. Och", "H. Ney" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Och and Ney,? \\Q2003\\E",
      "shortCiteRegEx" : "Och and Ney",
      "year" : 2003
    }, {
      "title" : "Succinct indexable dictionaries with applications to encoding k-ary trees and multisets",
      "author" : [ "R. Raman", "V. Raman", "S. Rao" ],
      "venue" : "In Proceedings of the 22nd Annual ACM-SIAM Symposium on Discrete Algorithms,",
      "citeRegEx" : "Raman et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Raman et al\\.",
      "year" : 2002
    }, {
      "title" : "Data compression",
      "author" : [ "D. Salomon" ],
      "venue" : "The complete reference (Fourth edition). Springer.",
      "citeRegEx" : "Salomon,? 2007",
      "shortCiteRegEx" : "Salomon",
      "year" : 2007
    }, {
      "title" : "PPM: One step to practicality",
      "author" : [ "D. Shkarin" ],
      "venue" : "Proceeding of the 2002 Data Compression Conference, pp. 202–211, Snowbird, USA.",
      "citeRegEx" : "Shkarin,? 2002",
      "shortCiteRegEx" : "Shkarin",
      "year" : 2002
    }, {
      "title" : "Translation spotting for translation memories",
      "author" : [ "M. Simard" ],
      "venue" : "Proceedings of NAACL 2003 Workshop on Building and Using Parallel Texts: Data Driven Machine Translation and Beyond, pp. 65–72, Edmonton, AB, Canada.",
      "citeRegEx" : "Simard,? 2003",
      "shortCiteRegEx" : "Simard",
      "year" : 2003
    }, {
      "title" : "Algorithms for delta compression and remote file synchronization",
      "author" : [ "T. Suel", "N. Memon" ],
      "venue" : "Lossless Compression Handbook,",
      "citeRegEx" : "Suel and Memon,? \\Q2003\\E",
      "shortCiteRegEx" : "Suel and Memon",
      "year" : 2003
    }, {
      "title" : "Extracting multilingual lexicons from parallel corpora",
      "author" : [ "D. Tufis", "Barbu", "A.-M", "R. Ion" ],
      "venue" : "Computers and the Humanities,",
      "citeRegEx" : "Tufis et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Tufis et al\\.",
      "year" : 2004
    }, {
      "title" : "Housekeeping for prefix coding",
      "author" : [ "A. Turpin", "A. Moffat" ],
      "venue" : "IEEE Transactions on Communications,",
      "citeRegEx" : "Turpin and Moffat,? \\Q2000\\E",
      "shortCiteRegEx" : "Turpin and Moffat",
      "year" : 2000
    }, {
      "title" : "Parallel text processing. Alignment and use of translation corpora, chap. Evaluation of Parallel Text Alignment Systems – The ARCADE Project",
      "author" : [ "J. Véronis", "P. Langlais" ],
      "venue" : null,
      "citeRegEx" : "Véronis and Langlais,? \\Q2000\\E",
      "shortCiteRegEx" : "Véronis and Langlais",
      "year" : 2000
    }, {
      "title" : "HMM-based word alignment in statistical translation",
      "author" : [ "S. Vogel", "H. Ney", "C. Tillmann" ],
      "venue" : "In Proceedings of the 16th International Conference on Computational Linguistics,",
      "citeRegEx" : "Vogel et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Vogel et al\\.",
      "year" : 1996
    }, {
      "title" : "An universal algorithm for sequential data compression",
      "author" : [ "J. Ziv", "A. Lempel" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "Ziv and Lempel,? \\Q1977\\E",
      "shortCiteRegEx" : "Ziv and Lempel",
      "year" : 1977
    }, {
      "title" : "Compression: A key for next-generation text retrieval systems",
      "author" : [ "N. Ziviani", "E. Moura", "G. Navarro", "R. Baeza-Yates" ],
      "venue" : "IEEE Computer,",
      "citeRegEx" : "Ziviani et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Ziviani et al\\.",
      "year" : 2000
    } ],
    "referenceMentions" : [ {
      "referenceID" : 35,
      "context" : "The increasing availability of large collections of multilingual texts has fostered the development of natural-language processing applications that address multilingual tasks —such as corpus-based machine translation (Arnold, Balkan, Meijer, Humphreys, & Sadler, 1994; Lopez, 2008; Koehn, 2010; Carl & Way, 2003), cross-language information retrieval (Grossman & Frieder, 2004, Ch.",
      "startOffset" : 218,
      "endOffset" : 313
    }, {
      "referenceID" : 33,
      "context" : "The increasing availability of large collections of multilingual texts has fostered the development of natural-language processing applications that address multilingual tasks —such as corpus-based machine translation (Arnold, Balkan, Meijer, Humphreys, & Sadler, 1994; Lopez, 2008; Koehn, 2010; Carl & Way, 2003), cross-language information retrieval (Grossman & Frieder, 2004, Ch.",
      "startOffset" : 218,
      "endOffset" : 313
    }, {
      "referenceID" : 54,
      "context" : "4), the automatic extraction of bilingual lexicons (Tufis, Barbu, & Ion, 2004), and translation spotting (Simard, 2003; Véronis & Langlais, 2000).",
      "startOffset" : 105,
      "endOffset" : 145
    }, {
      "referenceID" : 17,
      "context" : ", syntactic parsing (Carroll, 2003), or word sense disambiguation (Ide & Véronis, 1998)— can also exploit multilingual texts by projecting the linguistic knowledge available in one language into other languages (Mihalcea & Simard, 2005).",
      "startOffset" : 20,
      "endOffset" : 35
    }, {
      "referenceID" : 43,
      "context" : "The authors report slight improvements in the compression of the right text R in comparison to classical compression algorithms such as bzip21 or word-based Huffman (Moffat, 1989) (approximately 1% and 6%, respectively).",
      "startOffset" : 165,
      "endOffset" : 179
    }, {
      "referenceID" : 43,
      "context" : "In contrast to PPM, some text-compression methods use words rather than characters as input tokens (Moffat, 1989; Moffat & Isal, 2005).",
      "startOffset" : 99,
      "endOffset" : 134
    }, {
      "referenceID" : 40,
      "context" : "In the words of Melamed (2001, p. 1), “bitexts are one of the richest sources of linguistic knowledge because the translation of a text into another language can be viewed as a detailed annotation of what that text means”. Bitexts are usually available in a compressed form in order to reduce storage requirements, to improve access times (Ziviani, Moura, Navarro, & Baeza-Yates, 2000), and to increase the efficiency of transmissions. However, the independent compression of the two texts of a bitext is clearly far from efficient because the information contained in both texts is redundant: in theory, one of the texts might be sufficient to generate a translated version if reliable machine translation systems were already available (Nevill-Manning & Bell, 1992). The improvement in compression performance obtained when taking advantage of the fact that the two texts in a bitext are mutual translations may be regarded as an indication of the quality of word alignments (Och & Ney, 2003). This indicator, which bounds the mutual information (Cover & Thomas, 1991) in the two texts of a bitext, does not require a manually-annotated corpus to evaluate the automatic alignment. The first article dealing with the compression of bitexts was published by Nevill-Manning and Bell (1992). This approach compressed one of the texts in isolation, while the other was compressed by a general prediction by partial matching (PPM; Cleary & Witten, 1984) encoder based on a model that used the automatic translation of the left text to predict the words in the right text.",
      "startOffset" : 16,
      "endOffset" : 1289
    }, {
      "referenceID" : 21,
      "context" : "In contrast, Conley and Klein (2008) have proposed text alignment —that is, pairings between the words and phrases in one text and those in the other—, as the basis for multilingual text compression.",
      "startOffset" : 13,
      "endOffset" : 37
    }, {
      "referenceID" : 21,
      "context" : "In contrast, Conley and Klein (2008) have proposed text alignment —that is, pairings between the words and phrases in one text and those in the other—, as the basis for multilingual text compression. Their algorithm extends the ideas of delta-encoding (Suel & Memon, 2003) to the case in which the right text R is a translated, automatically aligned, version of the source text L: L is compressed first, and each block in R is then encoded as a reference to the parallel block in L. This method requires the computation of wordand phrase-level alignments, together with the lemmatized forms of L and R. The translated text is retrieved from these references, using a bilingual glossary together with other linguistic resources: a lemmata dictionary of words in L, a dictionary with all the possible morphological variants of each word in R, and a bilingual glossary. The authors report slight improvements in the compression of the right text R in comparison to classical compression algorithms such as bzip21 or word-based Huffman (Moffat, 1989) (approximately 1% and 6%, respectively). However, the authors do not take into consideration the size of the auxiliary files needed for the retrieval of the right text. In contrast to PPM, some text-compression methods use words rather than characters as input tokens (Moffat, 1989; Moffat & Isal, 2005). Analogously, Mart́ınez-Prieto, Adiego, Sánchez-Mart́ınez, de la Fuente, and Carrasco (2009), and Adiego and his colleagues (2009, 2010) propose the use of biwords —pairs of words, each one from a different text, with a high",
      "startOffset" : 13,
      "endOffset" : 1444
    }, {
      "referenceID" : 40,
      "context" : "Significant spatial savings are achieved with this technique (Mart́ınez-Prieto et al., 2009), although the compression of biword sequences requires larger dictionaries than the traditional text compression methods.",
      "startOffset" : 61,
      "endOffset" : 92
    }, {
      "referenceID" : 40,
      "context" : "5% for English–French (Mart́ınez-Prieto et al., 2009).",
      "startOffset" : 22,
      "endOffset" : 53
    }, {
      "referenceID" : 0,
      "context" : "A different biword-based scheme called 2lcab has recently been proposed (Adiego et al., 2009) which creates a two-level dictionary to store the biwords and compresses the biword sequence with End-Tagged Dense Code (ETDC; Brisaboa, Fariña, Navarro, & Paramá, 2007).",
      "startOffset" : 72,
      "endOffset" : 93
    }, {
      "referenceID" : 2,
      "context" : "If 2lcab is used as a compression booster for a standard PPM coder, further improvements in compression are obtained, but it is no longer possible to directly search in the compressed files (Adiego et al., 2010).",
      "startOffset" : 190,
      "endOffset" : 211
    }, {
      "referenceID" : 54,
      "context" : "We also show that this generalization of biwords allows for the implementation of an efficient translation spotting (Simard, 2003; Véronis & Langlais, 2000) algorithm on the compressed bitext; a task that consists of identifying the words (or text segments) in the other text that are the translation of the words in the query.",
      "startOffset" : 116,
      "endOffset" : 156
    }, {
      "referenceID" : 33,
      "context" : "Generalized biwords can also be used as an ingredient in the bilingual language model employed in some statistical machine translation systems (Koehn, 2010).",
      "startOffset" : 143,
      "endOffset" : 156
    }, {
      "referenceID" : 36,
      "context" : "The last two sources of unpaired words are responsible for the different spatial savings reported by Mart́ınez-Prieto et al. (2009) for bitexts consisting of closely-related languages (e.",
      "startOffset" : 101,
      "endOffset" : 132
    }, {
      "referenceID" : 31,
      "context" : "Generalized biwords can also be used as an ingredient in the bilingual language model employed in some statistical machine translation systems (Koehn, 2010). For instance, Mariño et al. (2006) use bilingual n-grams and consider the translation as a bilingual decoding process.",
      "startOffset" : 144,
      "endOffset" : 193
    }, {
      "referenceID" : 18,
      "context" : "Casacuberta and Vidal (2004) also exploit bilingual n-grams but apply stochastic finite-state transducers to this task.",
      "startOffset" : 0,
      "endOffset" : 29
    }, {
      "referenceID" : 12,
      "context" : "In our case, word alignments are computed with the opensource Giza++ toolkit2 (Och & Ney, 2003) which implements a set of methods, including standard word-based statistical machine translation models (Brown et al., 1993) and a hidden-Markov-model-based alignment model (Vogel, Ney, & Tillmann, 1996).",
      "startOffset" : 200,
      "endOffset" : 220
    }, {
      "referenceID" : 40,
      "context" : ", the structural information), and is therefore equivalent to the basic procedures described earlier (Mart́ınez-Prieto et al., 2009; Adiego et al., 2009, 2010).",
      "startOffset" : 101,
      "endOffset" : 159
    }, {
      "referenceID" : 28,
      "context" : "& Moffat, 2000) in which the input strings are mapped onto integers and then compressed with Huffman codewords (Huffman, 1952).",
      "startOffset" : 111,
      "endOffset" : 126
    }, {
      "referenceID" : 43,
      "context" : "The left text is encoded using word-based Huffman coding (Moffat, 1989).",
      "startOffset" : 57,
      "endOffset" : 71
    }, {
      "referenceID" : 0,
      "context" : "In contrast to Tre, the 2-Level Compressor for Aligned Bitexts (2lcab; Adiego et al., 2009) encodes every biword with a single codeword based on a two-level dictionary.",
      "startOffset" : 63,
      "endOffset" : 91
    }, {
      "referenceID" : 0,
      "context" : "This implementation of 2lcab employs (bit-oriented) Huffman coding, but the original work (Adiego et al., 2009), and the application described in Section 6 implement byte-oriented ETDC (Brisaboa et al.",
      "startOffset" : 90,
      "endOffset" : 111
    }, {
      "referenceID" : 9,
      "context" : ", 2009), and the application described in Section 6 implement byte-oriented ETDC (Brisaboa et al., 2007).",
      "startOffset" : 81,
      "endOffset" : 104
    }, {
      "referenceID" : 32,
      "context" : "• Bitexts (100 MB each) from the European Parliament Proceedings Parallel Corpus (Europarl; Koehn, 2005) for seven different language pairs: German–English (de-en), Spanish–English (es-en), Spanish–French (es-fr), Spanish–Italian (es-it), Spanish– Portuguese (es-pt), French–English (fr-en), and Finnish–English (fi-en).",
      "startOffset" : 81,
      "endOffset" : 104
    }, {
      "referenceID" : 28,
      "context" : "First, gzip,6 a classical compressor that combines LZ77-based modeling with Huffman coding (Huffman, 1952).",
      "startOffset" : 91,
      "endOffset" : 106
    }, {
      "referenceID" : 39,
      "context" : "24), an algorithm which improves LZ77 with a large dictionary (up to 4 GB) and range encoding (Martin, 1979).",
      "startOffset" : 94,
      "endOffset" : 108
    }, {
      "referenceID" : 53,
      "context" : "• ppmdi (Shkarin, 2002) as a representative of the Prediction by Partial Matching (PPM; Cleary & Witten, 1984) family of compressors.",
      "startOffset" : 8,
      "endOffset" : 23
    }, {
      "referenceID" : 43,
      "context" : "• A word-based Huffman compressor (Moffat, 1989) that maps the input strings to integers before encoding the values with Huffman codewords (Moffat & Turpin, 1997; Turpin & Moffat, 2000).",
      "startOffset" : 34,
      "endOffset" : 48
    }, {
      "referenceID" : 4,
      "context" : "The exploitation of bitexts by computer-aided translation tools has evolved from simple bilingual concordancers (Barlow, 2004; Bowker & Barlow, 2004) to advanced translation search engines (Callison-Burch, Bannard, & Schroeder, 2005a; Bourdaillet, Huet, Langlais, & Lapalme, 2010).",
      "startOffset" : 112,
      "endOffset" : 149
    }, {
      "referenceID" : 5,
      "context" : "It would seem that existing translation search engines (Callison-Burch et al., 2005a; Bourdaillet et al., 2010) do not access bitexts in their compressed forms because storing the correspondences between the translated segments requires additional data structures such as word indexes or suffix arrays (Lopez, 2007; Callison-Burch, Bannard, & Schroeder, 2005b); suffix arrays typically require four times the size of the text (Manber & Myers, 1993).",
      "startOffset" : 55,
      "endOffset" : 111
    }, {
      "referenceID" : 34,
      "context" : ", 2010) do not access bitexts in their compressed forms because storing the correspondences between the translated segments requires additional data structures such as word indexes or suffix arrays (Lopez, 2007; Callison-Burch, Bannard, & Schroeder, 2005b); suffix arrays typically require four times the size of the text (Manber & Myers, 1993).",
      "startOffset" : 198,
      "endOffset" : 256
    }, {
      "referenceID" : 19,
      "context" : "6), such as RG (González, Grabowski, Mäkinen, & Navarro, 2005) and RRR (Raman, Raman, & Rao, 2002), provide an effective way in which to represent a sequence of bits and recover the rank associated with every matching sequence, because they support a number of operations in the sequence of bits S in a time that is independent of its length (Clark, 1996):",
      "startOffset" : 342,
      "endOffset" : 355
    }, {
      "referenceID" : 31,
      "context" : "An exact pattern-matching algorithm (Knuth et al., 1977) identifies all the occurrences of the codeword c in the biword dictionary ΣB.",
      "startOffset" : 36,
      "endOffset" : 56
    }, {
      "referenceID" : 26,
      "context" : "The multi-pattern matching algorithm Set-Horspool (Horspool, 1980; Navarro & Raffinot, 2002) locates all the codewords in the sequence of biwords B that match one of those contained in Z, and the matching positions are added to a new set M .",
      "startOffset" : 50,
      "endOffset" : 92
    }, {
      "referenceID" : 0,
      "context" : "third match shows a non-contiguous translation, a case which cannot be retrieved with the original 2lcab implementation (Adiego et al., 2009).",
      "startOffset" : 120,
      "endOffset" : 141
    }, {
      "referenceID" : 32,
      "context" : "The first one, en-fr, displays the typical behavior of all Europarl bitexts (Koehn, 2005), while the second one, en-fi, requires particularly longer times, especially for large queries.",
      "startOffset" : 76,
      "endOffset" : 89
    } ],
    "year" : 2012,
    "abstractText" : "Large bilingual parallel texts (also known as bitexts) are usually stored in a compressed form, and previous work has shown that they can be more efficiently compressed if the fact that the two texts are mutual translations is exploited. For example, a bitext can be seen as a sequence of biwords —pairs of parallel words with a high probability of cooccurrence— that can be used as an intermediate representation in the compression process. However, the simple biword approach described in the literature can only exploit one-toone word alignments and cannot tackle the reordering of words. We therefore introduce a generalization of biwords which can describe multi-word expressions and reorderings. We also describe some methods for the binary compression of generalized biword sequences, and compare their performance when different schemes are applied to the extraction of the biword sequence. In addition, we show that this generalization of biwords allows for the implementation of an efficient algorithm to look on the compressed bitext for words or text segments in one of the texts and retrieve their counterpart translations in the other text —an application usually referred to as translation spotting— with only some minor modifications in the compression algorithm.",
    "creator" : "TeX"
  }
}