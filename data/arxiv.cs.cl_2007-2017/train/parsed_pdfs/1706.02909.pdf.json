{
  "name" : "1706.02909.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Deriving a Representative Vector for Ontology Classes with Instance Word Vector Embeddings",
    "authors" : [ "Vindula Jayawardana", "Dimuthu Lakmal", "Nisansa de Silva", "Amal Shehan Perera", "Keet Sugathadasa", "Buddhi Ayesha" ],
    "emails" : [ "vindula.13@cse.mrt.ac.lk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "keywords: Ontology, Word Embedding, Representative Vector, Neural Networks, word2vec\nI. INTRODUCTION\nSemantic models are used to present hierarchy and semantic meaning of concepts. Among them ontologies are a widely used superlative model extensively applied to many fields. As defined by Thomas R. Gruber [1], an ontology is a “formal and explicit specification of a shared conceptualization”. The use of ontologies is becoming increasingly involved in various computational tasks given the fact that ontologies can overcome limitations in traditional natural language processing methods in domains such as text classification [2], [3], word set expansions [4], linguistic information management [5]–[8], medical information management [9], [10], and Information Extraction [11], [12].\nHowever very few attempts have been made on representing ontology classes in different representations such as vector representations. The importance of having different representations for ontology classes is emphasized when it comes to ontology mapping, ontology merging, ontology integration, ontology alignment and semi automated ontology population [13]. However sophisticated researches on representing ontology classes in different representations is still an open ended question.\nIn this study we propose a novel way of deriving representative vectors for ontology classes. This is an important problem in the domain of automatic ontology population and automatic ontology class labeling. We use a distributed representation of words in a vector space grouped together [14], achieved by means of word vector embeddings to transform the word strings in instances and the class labels to the same\nvector space. For this task of word embedding, we chose the neural network based method: word2vec, proposed by Tomas Mikolov et al. [15], which is a model architecture for computing continuous vector representations of words from very large data sets.\nIn the proposed methodology we created an ontology in the domain of consumer protection law with the help of legal experts. The word2vec model was trained with the legal cases from FindLaw [16] online database. The word embedding vectors of the instances and the class labels in the created ontology were the obtained using the trained word2vec model. For each ontology class a number of candidate vectors were then calculated using the word embedding vectors of the instances. The candidate vectors and the class label vectors were then used to train a machine learning model to predict the best representative vector. We show that our proposed methodology outperforms the traditional average (mean) vector representation and median vector representation in all classes. On average, the distance of our representative vector to the class vector is 0.82, while the mean vector has a distance of 1.31 and the median vector has a distance of 1.51. Respectively, it is a 37% and 50% improvement.\nThe rest of this paper is organized as follows: In Section II we review previous studies related to this work. The details of our methodology for deriving a representative vector for ontology classes with instance word vector embeddings is introduced in Section III. In Section IV, we demonstrate that our proposed methodology produces superior results outperforming traditional approaches. At last, we conclude and discuss some future works in Section V."
    }, {
      "heading" : "II. BACKGROUND AND RELATED WORK",
      "text" : "This section discusses the background details of the techniques utilized in this study and related previous studies carried out by others in various areas relevant to this research. The following subsections given below cover important key areas of this study."
    }, {
      "heading" : "A. Ontologies",
      "text" : "In many areas, ontologies are used to organize information as a form of knowledge representation. An ontology may model either the world or a part of it as seen by the said area’s viewpoint [4].\nar X\niv :1\n70 6.\n02 90\n9v 1\n[ cs\n.C L\n] 8\nJ un\n2 01\n7\nIndividuals (instances) make up the ground level of an ontology. These can be either concrete objects or abstract objects. Individuals are then grouped into structures called classes. Depending on the domain on which the ontology is based, a class in an ontology can be referred to as a concept, type, category, or a kind. More often, the definition of a class and the role thereof is analogous to that of a collection of individuals with some additional properties that distinguish it from a mere set of objects. A class can either subsume, or be subsumed by, another class. This subsuming process give rise to the class hierarchy and the concept of super-classes (and sub-classes)."
    }, {
      "heading" : "B. Word set expansion",
      "text" : "In many Natural Language Processing (NLP) tasks, creating and maintaining word-lists is an integral part. The said wordlists usually contain words that are deemed to be homogeneous in the level of abstraction involved in the application. Thus, two words W1 and W2 might belong to a single word-list in one application but belong to different word-lists in another application. This fuzzy definition and usage is what makes creation and maintenance of these word-lists a complex task.\nFor the purpose of this study, we selected the algorithm presented in [4] which was built on the earlier algorithm described in [17]. The reason for this selection is: WordNet [5] based linguistic processes are reliable due to the fact that the WordNet lexicon was built on the knowledge of expert linguists."
    }, {
      "heading" : "C. Word Embedding",
      "text" : "Word embedding systems, are a set of natural language modeling and feature learning techniques, where words from a domain are mapped to vectors to create a model that has a distributed representation of words, first proposed by [14]. Each of the words in a text document is mapped to a vector space. In addition to that, word meanings and relationships between the words are also mapped to the same vector space. word2vec1 [15], GloVe [18], and Latent Dirichlet Allocation (LDA) [19] are leading Word Vector Embedding systems. Both Word2vec and GloVe use word to neighboring word mapping to learn dense embeddings. The difference is that Word2vec uses a neural network based approach while GloVe uses matrix factorization mechanism. LDA also has an approach that utilizes matrices but there the words are mapped with the relevant sets of documents. Due to the flexibility and ease of customization, we picked word2vec as the word embedding method for this study.\nWord2vec is used in sentiment analysis [20]–[23] and text classification [24]. In the ontology domain there are two main works that involve word2vec: Gerhard Wohlgenannt et al. [25]’s approach to emulate a simple ontology using word2vec and Harmen Prins [26]’s usage of word2vec extension: node2vec [27], to overcome the problems in vectorization of an ontology.\n1https://code.google.com/p/word2vec/"
    }, {
      "heading" : "D. Clustering",
      "text" : "Clustering is a seminal part in exploratory data mining and statistical data analysis. The objective of clustering is to group a set of items into separate sub-sets (clusters) where the items in a given cluster is more similar to each other than any of them is similar to an item from a different cluster. The used similarity measure and the desired number of clusters are application dependent. A clustering algorithm is inherently modeled as an iterative multi-objective optimization problem that involves trial and error which tries to move towards a state that exhibits the desired properties. Out of all the clustering methods available, we selected k-means clustering due to the easiness of implementation and configuration.\nArguably, k-means clustering was first proposed by Stuart Lloyd [28] as a method of vector quantization for pulsecode modulation in the domain of signal processing. The objective is to partition n observations into k clusters where each observation i belongs to the cluster with the mean m such that in the set of cluster means M , m is the closest to i when measured by a given vector distance measure. It is implicitly assumed that the cluster mean serves as the prototype of the cluster. This results in the vector space being partitioned into Voronoi cells."
    }, {
      "heading" : "E. Support Vector Machines",
      "text" : "Support Vector Machines [29] is a supervised learning model that is commonly used in machine learning tasks that analyze data for the propose of classification or regression analysis. The SVM algorithm works on a set of training examples where each example is tagged as to be belonging to one of two classes. The objective is to find a hyperplane dividing these two classes such that, the examples of the two classes are divided by a clear gap which is as wide as mathematically possible. Thus the process is a non-probabilistic binary linear classifier task. The aforementioned gap is margined by the instances that are named support vectors.\nThe idea of using SVMs for task pertaining ontologies are rather rare. However, a study by Jie Liu et al. [30] defined a similarity cube which consists of similarity vectors combining similar concepts, instances and structures of two ontologies and then processed it through SVM based mapping discovery function to map similarities between two ontologies. Further, another study by Jie Liu et al. [31] has proposed a method of similarity aggregation using SVM, to classify weighted similarity vectors which are calculated using concept name and properties of individuals of ontologies. Our usage of SVM in the ontology domain in this paper is different from their approach and hence entirely novel.\nIn Generic SVM, new examples that are introduced are then predicted to be falling into either class depending on the relationship between that new example and the hyperplane that is dividing the two classes. However, in this study we do not need to employ the new instance assignment. We are only interested in calculating the support vectors. The usage and rationalization of this is given in Section III-D"
    }, {
      "heading" : "III. METHODOLOGY",
      "text" : "We discuss the methodology that we used for deriving a vector representation for ontology classes using instance vector embeddings in this section. Each of the following subsections describe a step of our process. An overview of the methodology we propose in Sections III-A and III-B is illustrated in Fig. 1 and an overview of the methodology we propose from Section III-C to Section III-G is illustrated in Fig. 2."
    }, {
      "heading" : "A. Ontology Creation",
      "text" : "We created a legal ontology based on the consumer protection law, taking Findlaw [16] as the reference. After creating the ontology class hierarchy, we manually added seed instances for all the classes in the ontology. This was done based on manual inspection of the content of legal cases under consumer protection law in Findlaw. Next we used the algorithm proposed in [4] to expand the instance sets. The expanded lists were then pruned manually to prevent conceptual drift. This entire process was done under the supervision and guidance of experts from the legal domain."
    }, {
      "heading" : "B. Training word Embeddings",
      "text" : "The training of the word embeddings was the process of building a word2vec model using a large legal text corpus obtained from Findlaw [16]. The text corpus consisted of legal cases under 78 law categories. In creating the legal text corpus we used Stanford CoreNLP for preprocessing the text with tokenizing, sentence splitting, Part of Speech (PoS) tagging, and lemmatizing.\nThe motive behind using a pipeline that pre-processes text up to and including lemmatization instead of the traditional approach of training the word2vec model with just tokenized text [15], was to map all inflected forms of a given lemma to a single entity. In the traditional approach each inflected form of a lemma gets trained as a separate vector. This dilutes the values that is extracted from the context of that lemma between all inflected forms. Thus sometimes resulting in values not meeting the threshold when a test of significance is done. By having all inflicted forms to be reduced to the relevant lemma and train, we made sure that all the contributions of the context of a given lemma is collected at a single vector, thus making the system more accurate. Secondly, having a unique vector for each inflected form makes the model unnecessarily large and heavy. This results in difficulties at both training and testing. Our approach of lemmatizing the corpus first solves that problem as well. In addition to this, to reduce ambiguities caused by the case of the strings, we converted all strings to lowercase before training the word2vec model. This too is a divergence from the conventional approach."
    }, {
      "heading" : "C. Sub-Cluster Creation",
      "text" : "By definition, the instances in a given class of an ontology is more semantically similar to each other than instances in other classes. But no matter how coherent a set of items is, as long as that set contains more than one element, it is possible\nto create non-empty sub-sets that are proper subsets of the original set. This is the main motivation behind this step of our methodology. Following this rationale, it was decided that it is possible to find at least one main schism in the otherwise semantically coherent set of more than one instances.\nGiven that even then, the schisms would be fairly small by definition in comparison to the difference of instances in one class and the instances of another class, it was decided to stop the sub-set creation at 2. Which means we decided to divide the instances in a single class in to two sub-clusters. For this purpose, we use K-means clustering with K=2. For an example, we are subdividing the ”Judge” class using k-means to ”Judge1” and ”Judge2” and then use the support vectors between those two to predict the label of ”Judge”. The centers of these sub-clusters are two of the candidate vectors used in Section III-E."
    }, {
      "heading" : "D. Support Vector Calculation",
      "text" : "It is clear that the specification of the problem handled in this study is more close to a clustering task than a classification task. In addition to that, given the fact that each time we would be running the proposed algorithm, it would be for instances in a single class. That implies that, even if we are to assign class labels to the instances, to model it as a classification task, it would have been a futile effort because there exist only one class. Thus, having a classifying algorithm such as Support Vector Machines (SVM) as part of the process of this study might seem peculiar at the beginning. However, this problem is no longer an issue due to the steps that were taken in the Section III-C. Instead of the single unified cluster with the homogeneous class label, the previous step yielded two subclusters with two unique labels. Given that the whole premise of creating sub-clusters was based on the argument that there exists a schism in the individual vectors in the class, it is logical to have the next step to quantify that schism.\nFor this task we used an SVM. The SVM was given the individuals in the two sub-clusters as the two classes and was directed to discover the support vectors. This process found the support vectors to be on either side of the schism that was discussed in Section III-C.\nIn identifying the support vectors, we used the algorithm used by Edgar Osuna et al. [32] in training support vector machines and then performed certain modifications to output the support vectors."
    }, {
      "heading" : "E. Candidate Matrix Calculation",
      "text" : "With the above steps completed, in order to derive the vector representation for ontology classes, we calculated a number of candidate vectors for each class and then derived the candidate matrix from those candidate vectors. We describe the said candidate vectors below: • Average support vector (C1) • Average instance vector (C2) • Class Median vector (C3) • Sub-cluster average vectors (C4, C5)\nThe Class name Vector (C0) is obtained by performing word vectorization on the selected class’s class name and it was used as our desired output.\n1) Average support vector (C1): We identified the support vectors which mark the space around the hyperplane that divides the class into the two subclasses as mentioned in Section III-D. We take the average of the said support vectors as the first candidate vector. The rationale behind this idea is that as described in Section III-C, there exists a schism in between the two sub-classes. The support vectors mark the edges of that schism which means the average of the support vectors fall on the center of the said schism. Given that the schism is a representative property of the class, it is rational to consider this average support vector that falls in the middle of it as representative of the class. We averaged the instance vectors as shown in equation 1 to calculate the average support vector.\nC =\nN∑ i=1 aiVi\nN∑ i=1 ai\n(1)\nHere, N is the total number of vectors in the class. Vi represents instance vectors. ai is the support vector membership vector such that: if the ith vector is a support vector, ai is 1 and otherwise, it is 0. Here C is C1 which represents the average support vector candidate vector.\n2) Average instance vector (C2): This is by far the most commonly used class representation vector in other studies. We took all the instance vectors of the relevant class, and averaged them to come up with this candidate vector for the class. The Average instance vector was also calculated using the equation 1. However, this time all the ais were initiated to 1. In that case, C is C2 which represents the average instance vector.\n3) Class Median vector (C3): Out of the instance vectors of a class, we calculated the median vector of them and added it as a candidate vector for that class. The Class Median vector (C3) was calculated as shown in equation 2 where: V is the set of instance vectors in the class. vi is the ith instance vector. M is the number of dimensions in an instance vector. xavg,j\nis the jth element in the average instance vector C2 that was calculated above using equation 1.\nC3 = arg min vi∈V { M∑ j=1 (xi,j − xavg,j) 2 }\n(2)\n4) Sub-cluster average vectors (C4, C5): We took all the instance vectors of one sub-cluster and averaged them to calculate C4 and then did the same for the other sub-cluster to calculate C5. The rationale behind this step is the fact that as described in Section III-C, the two sub-clusters that we find are representative of the main division that exists in the class. Thus it is justifiable to consider the centroid of each of those sub-clusters.\nEach sub-cluster average instance vector was also calculated using the equation 1. However, this time all the ais in the first cluster was initiated to 1 and the ais in the second cluster was initiated to 0. In that case, C is C4 which represents the average instance vector for the first cluster. Next the same function was used with all the ais in the first cluster initiated to 0 and the ais in the second cluster initiated to 1 to calculate C which was assigned to C5.\n5) Candidate Matrix: Finally the candidate matrix Mcand for each class is made by concatenating the transposes of C1 though C5 as shown in equation 3.\nMcand = { CT1 , C T 2 , C T 3 , C T 4 , C T 5 } (3)"
    }, {
      "heading" : "F. Optimization Goal",
      "text" : "After calculating the candidate vectors, we proposed an optimal vector that represents the given class based on the optimization goal as follows:\nY =\nM∑ i=1 CiWi\nM∑ i=1 Wi\n(4)\nHere, Y is the predicted class vector for the given class. M is the number of candidate vectors for a given class. Ci and Wi represents the ith candidate vector and the associated\nweight of that candidate vector respectively. Here the Wi is calculated using the method described in Section III-G."
    }, {
      "heading" : "G. Machine Learning implementation for weight calculation",
      "text" : "The main motive behind adding a weight for each candidate vector is to account for the significance of the candidate vector towards the optimized class vector. We decided to use machine learning to calculate the weight vector. The machine learning method we used is a neural network.\nThe dataset is structured in the traditional (X,D) structure where X is the set of inputs and D is the set of outputs. An input tuple x (such that x ∈ X), has elements xi,j . The matching output tuple d (such that d ∈ D) has a single element.\nX and D is populated as follows: Take the ith row of the candidate matrix Mcand of the class as x and add it to X . Take the ith element of C0 of the class and add it to D. Once this is done for all the classes, we get the (X,D) set. It should be noted that since the weights are learned universally and not on a class by class basis, there will be one large dataset and not a number of small datasets made up of one per class. The reason for this is to make sure that the model does not overfit to one class and would instead generalize over all the data across the entire ontology. Because of this approach, we end up with a considerable amount of training data which again justifies our decision to use machine learning. For a word embedding vector length of N over M number of classes, this approach creates NM number of training examples."
    }, {
      "heading" : "IV. RESULTS",
      "text" : "We used a set of legal ontology classes seeded by the legal experts and then expanded by the set expansion [4] algorithm under the guidance of the same legal experts. We report our findings below in the table I and inFig.3 we show a visual comparison of the same data. We illustrate the results that we obtained pertaining to ten prominent legal concept\nclasses as well as the mean result across all the classes considered. We compare the representative vector proposed by us against the traditional representative vectors: average vector and median vector. All the results shown in the table are Euclidean distances obtained between the representative vector in question against the respective C0 vector.\nIt can be observed from the results that the traditional approach of taking the average vector as the representative vector of a class is outperforming the other traditional approach of using the median vector. However, our proposed method outperforms both the average and median vectors in all cases. For an example, considering the ”Judge” class, it can be seen that our model vector perform 47.8% better than the average vector where it is 53.8% better in the ”Complaint” class."
    }, {
      "heading" : "V. CONCLUSION AND FUTURE WORKS",
      "text" : "In this work, we have demonstrated that the proposed method works as a better representation for a set of instances that occupy an ontology class than the traditional methods of using the average vector or the median vector. This discovery will be helpful in mainly two important tasks in the ontology domain.\nThe first one is further populating an already seeded ontology. We, in this study used the algorithm proposed in [4] for this task to obtain a test dataset. However, that approach has the weakness of being dependent on the WordNet lexicon. A methodology built on the representative vector discovery algorithm proposed in this work will not have that weakness. This is because all the necessary vector representations are obtained from word vector embeddings done using a corpus relevant to the given domain. Thus all the unique jargon would be adequately covered without much of a threat of conceptual drift. As future work, we expect to take this idea forward for automatic ontology population.\nThe second important task in the ontology domain that this method will be important is, class labeling. In this study we have demonstrated that our method is capable in deriving the closest vector representation to the class label. Thus, the converse of that would be true as well. That would be a topic modeling [19] task. The idea is that if given an unlabeled class, the method proposed by this study can be used to derive the representative vector. Then by querying the word embedding vector space it is possible to obtain the most suitable class label (topic) candidate."
    } ],
    "references" : [ {
      "title" : "A translation approach to portable ontology specifications",
      "author" : [ "T.R. Gruber" ],
      "venue" : "Knowledge Acquisition, 5(2):199-220, 1993.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "The application of latent semantic indexing and ontology in text classification",
      "author" : [ "X.-Q. Yang", "N. Sun", "T.-L. Sun", "X.-Y. Cao", "X.-J. Zheng" ],
      "venue" : "International Journal of Innovative Computing, Information and Control, vol. 5, no. 12, pp. 4491–4499, 2009.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Safs3 algorithm: Frequency statistic and semantic similarity based semantic classification use case",
      "author" : [ "N. de Silva" ],
      "venue" : "Advances in ICT for Emerging Regions (ICTer), 2015 Fifteenth International Conference on, pp. 77–83, 2015.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Semi-supervised algorithm for concept ontology based word set expansion",
      "author" : [ "N. De Silva", "A. Perera", "M. Maldeniya" ],
      "venue" : "Advances in ICT for Emerging Regions (ICTer), 2013 International Conference on, pp. 125– 131, 2013.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Introduction to wordnet: An on-line lexical database",
      "author" : [ "G.A. Miller", "R. Beckwith", "C. Fellbaum", "D. Gross", "K.J. Miller" ],
      "venue" : "International journal of lexicography, vol. 3, no. 4, pp. 235–244, 1990.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Nouns in wordnet: a lexical inheritance system",
      "author" : [ "G.A. Miller" ],
      "venue" : "International journal of Lexicography, vol. 3, no. 4, pp. 245–264, 1990.",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Building a wordnet for sinhala",
      "author" : [ "I. Wijesiri", "M. Gallage", "B. Gunathilaka", "M. Lakjeewa", "D.C. Wimalasuriya", "G. Dias", "R. Paranavithana", "N. De Silva" ],
      "venue" : "Volume editors, p. 100, 2014.",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Omnisearch: a semantic search system based on the ontology for microrna target (omit) for microrna-target gene interaction data",
      "author" : [ "J. Huang", "F. Gutierrez", "H.J. Strachan", "D. Dou", "W. Huang", "B. Smith", "J.A. Blake", "K. Eilbeck", "D.A. Natale", "Y. Lin" ],
      "venue" : "Journal of biomedical semantics, vol. 7, no. 1, p. 1, 2016.",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "The development of non-coding rna ontology",
      "author" : [ "J. Huang", "K. Eilbeck", "B. Smith", "J.A. Blake", "D. Dou", "W. Huang", "D.A. Natale", "A. Ruttenberg", "J. Huan", "M.T. Zimmermann" ],
      "venue" : "International journal of data mining and bioinformatics, vol. 15, no. 3, pp. 214–232, 2016.",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Ontology-based information extraction: An introduction and a survey of current approaches",
      "author" : [ "D.C. Wimalasuriya", "D. Dou" ],
      "venue" : "Journal of Information Science, 2010.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Discovering inconsistencies in pubmed abstracts through ontology-based information extraction",
      "author" : [ "N. de Silva", "D. Dou", "J. Huang" ],
      "venue" : "ACM Conference on Bioinformatics, Computational Biology, and Health Informatics (ACM BCB), p. to appear, 2017.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2017
    }, {
      "title" : "A survey on ontology mapping",
      "author" : [ "N. Choi", "I.-Y. Song", "H. Han" ],
      "venue" : "ACM Sigmod Record, vol. 35, no. 3, pp. 34–41, 2006.",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Distributed representations of words and phrases and their compositionality",
      "author" : [ "T. Mikolov", "I. Sutskever", "K. Chen", "G.S. Corrado", "J. Dean" ],
      "venue" : "Advances in neural information processing systems, pp. 3111–3119, 2013.",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Efficient estimation of word representations in vector space",
      "author" : [ "T. Mikolov", "I. Sutskever", "K. Chen", "G. Corrado", "J. Dean" ],
      "venue" : "arXiv preprint arXiv:1301.3781, 2013.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Semap-mapping dependency relationships into semantic frame relationships",
      "author" : [ "N. de Silva", "C. Fernando", "M. Maldeniya", "D. Wijeratne", "A. Perera", "B. Goertzel" ],
      "venue" : "17th ERU Research Symposium, vol. 17. Faculty of Engineering, University of Moratuwa, Sri Lanka, 2011.",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Glove: Global vectors for word representation.",
      "author" : [ "J. Pennington", "R. Socher", "C.D. Manning" ],
      "venue" : "in EMNLP, vol",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2014
    }, {
      "title" : "Gaussian lda for topic models with word embeddings.",
      "author" : [ "R. Das", "M. Zaheer", "C. Dyer" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2015
    }, {
      "title" : "Learning sentiment-specific word embedding for twitter sentiment classification",
      "author" : [ "D. Tang", "F. Wei", "N. Yang", "M. Zhou", "T. Liu", "B. Qin" ],
      "venue" : "Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics, vol. 1, pp. 1555–1565, 2014.",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Study on sentiment computing and classification of sina weibo with word2vec",
      "author" : [ "B. Xue", "C. Fu", "Z. Shaobin" ],
      "venue" : "Big Data (BigData Congress), 2014 IEEE International Congress on. IEEE, pp. 358–363, 2014.",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Chinese comments sentiment classification based on word2vec and svm perf",
      "author" : [ "D. Zhang", "H. Xu", "Z. Su", "Y. Xu" ],
      "venue" : "Expert Systems with Applications, vol. 42, no. 4, pp. 1857–1863, 2015.",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 1857
    }, {
      "title" : "Sentiment analysis of citations using word2vec",
      "author" : [ "H. Liu" ],
      "venue" : "arXiv preprint arXiv:1704.00177, 2017.",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2017
    }, {
      "title" : "Support vector machines and word2vec for text classification with semantic features",
      "author" : [ "J. Lilleberg", "Y. Zhu", "Y. Zhang" ],
      "venue" : "Cognitive Informatics & Cognitive Computing (ICCI* CC), 2015 IEEE 14th International Conference on. IEEE, 2015, pp. 136–140.",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Using word2vec to build a simple ontology learning system",
      "author" : [ "G. Wohlgenannt", "F. Minic" ],
      "venue" : "Available at: http://ceur-ws.org/Vol-1690/ paper37.pdf",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2017
    }, {
      "title" : "node2vec: Scalable feature learning for networks",
      "author" : [ "A. Grover", "J. Leskovec" ],
      "venue" : "pp. 855–864, 2016.",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Least squares quantization in pcm",
      "author" : [ "S. Lloyd" ],
      "venue" : "IEEE transactions on information theory, vol. 28, no. 2, pp. 129–137, 1982.",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "Support-vector networks",
      "author" : [ "C. Cortes", "V. Vapnik" ],
      "venue" : "Machine learning, vol. 20, no. 3, pp. 273–297, 1995.",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Svm-based ontology matching approach",
      "author" : [ "L. Liu", "F. Yang", "P. Zhang", "J.-Y. Wu", "L. Hu" ],
      "venue" : "International Journal of Automation and Computing, vol. 9, no. 3, pp. 306–314, 2012.",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "An ontology mapping method based on support vector machine",
      "author" : [ "J. Liu", "L. Qin", "H. Wang" ],
      "venue" : "pp. 225–226, 2013.",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "An improved training algorithm for support vector machines",
      "author" : [ "E. Osuna", "R. Freund", "F. Girosi" ],
      "venue" : "pp. 276–285, 1997.",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Gruber [1], an ontology is a “formal and explicit specification of a shared conceptualization”.",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 1,
      "context" : "The use of ontologies is becoming increasingly involved in various computational tasks given the fact that ontologies can overcome limitations in traditional natural language processing methods in domains such as text classification [2], [3], word set expansions [4], linguistic information management [5]–[8], medical information management [9], [10], and Information Extraction [11], [12].",
      "startOffset" : 233,
      "endOffset" : 236
    }, {
      "referenceID" : 2,
      "context" : "The use of ontologies is becoming increasingly involved in various computational tasks given the fact that ontologies can overcome limitations in traditional natural language processing methods in domains such as text classification [2], [3], word set expansions [4], linguistic information management [5]–[8], medical information management [9], [10], and Information Extraction [11], [12].",
      "startOffset" : 238,
      "endOffset" : 241
    }, {
      "referenceID" : 3,
      "context" : "The use of ontologies is becoming increasingly involved in various computational tasks given the fact that ontologies can overcome limitations in traditional natural language processing methods in domains such as text classification [2], [3], word set expansions [4], linguistic information management [5]–[8], medical information management [9], [10], and Information Extraction [11], [12].",
      "startOffset" : 263,
      "endOffset" : 266
    }, {
      "referenceID" : 4,
      "context" : "The use of ontologies is becoming increasingly involved in various computational tasks given the fact that ontologies can overcome limitations in traditional natural language processing methods in domains such as text classification [2], [3], word set expansions [4], linguistic information management [5]–[8], medical information management [9], [10], and Information Extraction [11], [12].",
      "startOffset" : 302,
      "endOffset" : 305
    }, {
      "referenceID" : 6,
      "context" : "The use of ontologies is becoming increasingly involved in various computational tasks given the fact that ontologies can overcome limitations in traditional natural language processing methods in domains such as text classification [2], [3], word set expansions [4], linguistic information management [5]–[8], medical information management [9], [10], and Information Extraction [11], [12].",
      "startOffset" : 306,
      "endOffset" : 309
    }, {
      "referenceID" : 7,
      "context" : "The use of ontologies is becoming increasingly involved in various computational tasks given the fact that ontologies can overcome limitations in traditional natural language processing methods in domains such as text classification [2], [3], word set expansions [4], linguistic information management [5]–[8], medical information management [9], [10], and Information Extraction [11], [12].",
      "startOffset" : 342,
      "endOffset" : 345
    }, {
      "referenceID" : 8,
      "context" : "The use of ontologies is becoming increasingly involved in various computational tasks given the fact that ontologies can overcome limitations in traditional natural language processing methods in domains such as text classification [2], [3], word set expansions [4], linguistic information management [5]–[8], medical information management [9], [10], and Information Extraction [11], [12].",
      "startOffset" : 347,
      "endOffset" : 351
    }, {
      "referenceID" : 9,
      "context" : "The use of ontologies is becoming increasingly involved in various computational tasks given the fact that ontologies can overcome limitations in traditional natural language processing methods in domains such as text classification [2], [3], word set expansions [4], linguistic information management [5]–[8], medical information management [9], [10], and Information Extraction [11], [12].",
      "startOffset" : 380,
      "endOffset" : 384
    }, {
      "referenceID" : 10,
      "context" : "The use of ontologies is becoming increasingly involved in various computational tasks given the fact that ontologies can overcome limitations in traditional natural language processing methods in domains such as text classification [2], [3], word set expansions [4], linguistic information management [5]–[8], medical information management [9], [10], and Information Extraction [11], [12].",
      "startOffset" : 386,
      "endOffset" : 390
    }, {
      "referenceID" : 11,
      "context" : "ontology alignment and semi automated ontology population [13].",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 12,
      "context" : "We use a distributed representation of words in a vector space grouped together [14],",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 13,
      "context" : "[15], which is a model architecture for computing continuous vector representations of words from very large data sets.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 3,
      "context" : "An ontology may model either the world or a part of it as seen by the said area’s viewpoint [4].",
      "startOffset" : 92,
      "endOffset" : 95
    }, {
      "referenceID" : 3,
      "context" : "For the purpose of this study, we selected the algorithm presented in [4] which was built on the earlier algorithm described in [17].",
      "startOffset" : 70,
      "endOffset" : 73
    }, {
      "referenceID" : 14,
      "context" : "For the purpose of this study, we selected the algorithm presented in [4] which was built on the earlier algorithm described in [17].",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 4,
      "context" : "The reason for this selection is: WordNet [5] based linguistic processes are reliable due to the fact that the WordNet lexicon was built on the knowledge of expert linguists.",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 12,
      "context" : "Word embedding systems, are a set of natural language modeling and feature learning techniques, where words from a domain are mapped to vectors to create a model that has a distributed representation of words, first proposed by [14].",
      "startOffset" : 228,
      "endOffset" : 232
    }, {
      "referenceID" : 13,
      "context" : "word2vec1 [15], GloVe [18], and Latent Dirichlet Allocation (LDA) [19] are leading Word Vector Embedding systems.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 15,
      "context" : "word2vec1 [15], GloVe [18], and Latent Dirichlet Allocation (LDA) [19] are leading Word Vector Embedding systems.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 16,
      "context" : "word2vec1 [15], GloVe [18], and Latent Dirichlet Allocation (LDA) [19] are leading Word Vector Embedding systems.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 17,
      "context" : "Word2vec is used in sentiment analysis [20]–[23] and text classification [24].",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 20,
      "context" : "Word2vec is used in sentiment analysis [20]–[23] and text classification [24].",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 21,
      "context" : "Word2vec is used in sentiment analysis [20]–[23] and text classification [24].",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 22,
      "context" : "[25]’s approach to emulate a simple ontology using word2vec and Harmen Prins [26]’s usage of word2vec exten-",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "sion: node2vec [27], to overcome the problems in vectorization of an ontology.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 24,
      "context" : "Arguably, k-means clustering was first proposed by Stuart Lloyd [28] as a method of vector quantization for pulsecode modulation in the domain of signal processing.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 25,
      "context" : "Support Vector Machines [29] is a supervised learning model that is commonly used in machine learning tasks that analyze data for the propose of classification or regression analysis.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 26,
      "context" : "[30] defined a",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 27,
      "context" : "[31] has proposed a method of similarity aggregation using SVM, to classify weighted",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 3,
      "context" : "Next we used the algorithm proposed in [4] to expand the instance sets.",
      "startOffset" : 39,
      "endOffset" : 42
    }, {
      "referenceID" : 13,
      "context" : "The motive behind using a pipeline that pre-processes text up to and including lemmatization instead of the traditional approach of training the word2vec model with just tokenized text [15], was to map all inflected forms of a given lemma to a single entity.",
      "startOffset" : 185,
      "endOffset" : 189
    }, {
      "referenceID" : 28,
      "context" : "[32] in training support vector machines and then performed certain modifications to output the support vectors.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 3,
      "context" : "We used a set of legal ontology classes seeded by the legal experts and then expanded by the set expansion [4] algorithm under the guidance of the same legal experts.",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 3,
      "context" : "We, in this study used the algorithm proposed in [4] for this task to obtain a test dataset.",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 16,
      "context" : "That would be a topic modeling [19] task.",
      "startOffset" : 31,
      "endOffset" : 35
    } ],
    "year" : 2017,
    "abstractText" : "Selecting a representative vector for a set of vectors is a very common requirement in many algorithmic tasks. Traditionally, the mean or median vector is selected. Ontology classes are sets of homogeneous instance objects that can be converted to a vector space by word vector embeddings. This study proposes a methodology to derive a representative vector for ontology classes whose instances were converted to the vector space. We start by deriving five candidate vectors which are then used to train a machine learning model that would calculate a representative vector for the class. We show that our methodology out-performs the traditional mean and median vector representations. keywords: Ontology, Word Embedding, Representative Vector, Neural Networks, word2vec",
    "creator" : "LaTeX with hyperref package"
  }
}