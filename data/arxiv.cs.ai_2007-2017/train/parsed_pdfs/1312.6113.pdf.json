{
  "name" : "1312.6113.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Aspartame: Solving Constraint Satisfaction Problems with Answer Set Programming",
    "authors" : [ "M. Banbara" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Encoding finite linear Constraint Satisfaction Problems (CSPs; [1, 2]) as propositional formulas and solving them by using modern solvers for Satisfiability Testing (SAT; [3]) has proven to be a highly effective approach, as demonstrated by the award-winning sugar4 system. The CSP solver sugar reads a CSP instance and transforms it into a propositional formula in Conjunctive Normal Form (CNF). The translation relies on the order encoding [4, 5], and the resulting CNF formula can be solved by an off-theshelf SAT solver.\nIn what follows, we elaborate upon an alternative approach based on Answer Set Programming (ASP; [6]) and present the resulting CSP solver aspartame5. The major difference between sugar and aspartame rests upon the implementation of the translation of CSPs into Boolean constraint problems. While sugar implements a translation into CNF in the imperative programming language JAVA, aspartame starts with a translation into a set of facts.6 In turn, these facts are combined with a general-purpose ASP encoding for CSP solving (also based on the order encoding), which is subsequently instantiated by an off-the-shelf ASP grounder. The resulting propositional logic program is then solved by an off-the-shelf ASP solver.\n? Affiliated with the School of Computing Science at Simon Fraser University, Burnaby, Canada, and the Institute for Integrated and Intelligent Systems at Griffith University, Brisbane, Australia. 4 http://bach.istc.kobe-u.ac.jp/sugar 5 http://www.cs.uni-potsdam.de/wv/aspartame 6 In practice, aspartame re-uses sugar’s front-end for parsing and normalizing CSPs.\nar X\niv :1\n31 2.\n61 13\nv1 [\ncs .A\nI] 2\n0 D\nec 2\nThe high-level approach of ASP has obvious advantages. First, instantiation is done by general-purpose ASP grounders rather than dedicated implementations. Second, the elaboration tolerance of ASP allows for easy maintenance and modifications of encodings. And finally, it is easy to experiment with novel or heterogeneous encodings. However, the intruding question is whether the high-level approach of aspartame matches the performance of the more dedicated sugar system. We empirically address this question by contrasting the performance of both CSP solvers, while fixing the back-end solver to clasp, used as both a SAT and an ASP solver.\nFrom an ASP perspective, we gain insights into advanced modeling techniques for solving CSPs. The ASP encoding implementing CSP solving with aspartame has the following features:\n– usage of function terms to abbreviate structural subsums – avoidance of (artificial) intermediate Integer variables (to break sum expressions) – order encoding applied to structural subsum variables (as well as input variables) – encoding-wise filtering of relevant threshold values (no blind usage of domains) – customizable “pigeon-hole constraint” encoding for alldifferent constraints – “smart” encoding of table constraints, tracing admissible tuples along arguments\nIn the sequel, we assume some familiarity with ASP, its semantics as well as its basic language constructs. A comprehensive treatment of ASP can be found in [6], one oriented towards ASP solving is given in [7]. Our encodings are given in the language of gringo 3 [8]. Although we provide essential definitions of CSPs in the next section, we refer the reader to the literature [1, 2] for a broader perspective."
    }, {
      "heading" : "2 Background",
      "text" : "A Constraint Satisfaction Problem (CSP) is given by a pair (V, C) consisting of a set V of variables and a set C of constraint clauses. Every variable x ∈ V has an associated finite domain D(x) such that either D(x) = {>,⊥} or ∅ ⊂ D(x) ⊆ Z; x is a Boolean variable if D(x) = {>,⊥}, and an Integer variable otherwise. We denote the set of Boolean variables in V by B(V) and the set of Integer variables in V by I(V). A constraint clause C ∈ C is a set of literals over Boolean variables in B(V) as well as linear inequalities or global constraints on Integer variables in I(V). Any literal in C is of the form e or e, where e is either a Boolean variable in B(V), a linear inequality, or a global constraint. A linear inequality is an expression ∑ 1≤i≤n aixi ≤ m in which m as well as all ai for 1 ≤ i ≤ n are Integer constants and x1, . . . , xn are Integer variables in I(V). A global constraint (cf. [9]) is an arbitrary relation over Integer variables in I(V); we here restrict ourselves to table and alldifferent constraints over subsets {x1, . . . , xn} of the Integer variables in I(V), where a table constraint specifies tuples (d1, . . . , dn) ∈ D(x1) × · · · ×D(xn) of admitted value combinations and alldifferent applies if x1, . . . , xn are assigned to distinct values in their respective domains.7\n7 Linear inequalities relying on further comparison operators, such as <, >, ≥, =, and 6=, can be converted into the considered format via appropriate replacements [5]. Moreover, note that we here limit the consideration of global constraints to the ones that are directly, i.e., without normalization by sugar, supported in our prototypical ASP encodings shipped with aspartame.\nGiven a CSP (V, C), a variable assignment v is a (total) mapping v : V →⋃ x∈V D(x) such that v(x) ∈ D(x) for every x ∈ V . A Boolean variable x ∈ B(V)\nis satisfied w.r.t. v if v(x) = >. Likewise, a linear inequality ∑\n1≤i≤n aixi ≤ m is satisfied w.r.t. v if ∑ 1≤i≤n aiv(xi) ≤ m. Table constraints e ⊆ D(x1)× · · · ×D(xn) and alldifferent constraints over subsets {x1, . . . , xn} of I(V) are satisfied w.r.t. v if (v(x1), . . . , v(xn)) ∈ e or v(xi) 6= v(xj) for all 1 ≤ i < j ≤ n, respectively. Any Boolean variable, linear inequality, or global constraint that is not satisfied w.r.t. v is unsatisfied w.r.t. v. A constraint clause C ∈ C is satisfied w.r.t. v if there is some literal e ∈ C (or e ∈ C) such that e is satisfied (or unsatisfied) w.r.t. v. The assignment v is a solution for (V, C) if every C ∈ C is satisfied w.r.t. v.\nExample 1. Consider a CSP (V, C) with Boolean and Integer variables B(V) = {b} and I(V) = {x, y, z}, where D(x) = D(y) = D(z) = {1, 2, 3}, and constraint clauses C = {C1, C2, C3} as follows:\nC1 = {alldifferent(x, y, z)} (1) C2 = {b, 4x− 3y + z ≤ 0} (2) C3 = { b, (x, y) ∈ {(1, 3), (2, 2), (3, 1)} } (3)\nThe alldifferent constraint in C1 requires values assigned to x, y, and z to be mutually distinct. Respective assignments v satisfying the linear inequality 4x − 3y + z ≤ 0 in C2 include v(x) = 2, v(y) = 3, and v(z) = 1 or v(x) = 1, v(y) = 3, and v(z) = 2, while the table constraint in C3 is satisfied w.r.t. assignments v containing v(x) = 1, v(y) = 3, and v(z) = 2 or v(x) = 3, v(y) = 1, and v(z) = 2. In view of the Boolean variable b, whose value allows for “switching” between the linear inequality in C2 and the table constraint in C3, we obtain the following solutions v1, . . . , v4 for (V, C):\nb x y z\nv1 ⊥ 2 3 1 v2 ⊥ 1 3 2 v3 > 1 3 2 v4 > 3 1 2"
    }, {
      "heading" : "3 Approach",
      "text" : "The aspartame tool extends the SAT-based solver sugar by an output component to represent a CSP in terms of ASP facts. The generated facts can then, as usual, be combined with a first-order encoding processable with off-the-shelf ASP systems. In what follows, we describe the format of facts generated by aspartame, and we present a dedicated ASP encoding utilizing function terms to capture substructures in CSP instances."
    }, {
      "heading" : "3.1 Fact Format",
      "text" : "Facts express the variables and constraints of a CSP instance in the syntax of ASP grounders like gringo [8]. Their format is easiest explained on the CSP from Example 1, whose fact representation is shown in Listing 1. While facts of the predicate var/2\n1 var(bool,b). var(int,x;y;z,range(1,3)).\n3 constraint(1,global(alldifferent,arg(x,arg(y,arg(z,nil))))). 4 constraint(2,b). 5 constraint(2,op(le,op(add,op(add,op(mul,4,x),op(mul,-3,y)),op(mul,1,z)),0)). 6 constraint(3,op(neg,b)). 7 constraint(3,rel(r,arg(x,arg(y,nil)))).\n9 rel(r,2,3,supports). 10 tuple(r,1,1,1). tuple(r,1,2,3). 11 tuple(r,2,1,2). tuple(r,2,2,2). 12 tuple(r,3,1,3). tuple(r,3,2,1).\nListing 1. Facts representing the CSP from Example 1.\nprovide labels of Boolean variables like b, the predicate var/3 includes a third argument for declaring the domains of Integer variables like x, y, and z. Domain declarations rely on function terms range(l,u), standing for continuous Integer intervals [l, u]. While one term, range(1,3), suffices for the common domain {1, 2, 3} of x, y, and z, in general, several intervals can be specified (via separate facts) to form noncontinuous domains. Note that the interval format for Integer domains offers a compact fact representation of (continuous) domains; e.g., the single term range(1,10000) captures a domain with 10000 elements. Furthermore, the usage of meaningful function terms avoids any need for artificial labels to refer to domains or parts thereof.\nThe literals of constraint clauses are also represented by means of function terms. In fact, the second argument of constraint/2 in Line 3 of Listing 1 stands for alldifferent(x, y, z) from the constraint clause C1 in (1), which is identified via the first argument of constraint/2. Since every fact of the predicate constraint/2 is supposed to describe a single literal only, constraint clause identifiers establish the connection between individual literals of a clause. This can be observed on the facts in Line 4–7, specifying literals belonging to the binary constraint clauses C2 and C3 in (2) and (3). Here, the terms b and op(neg,b) refer to the literals b and b over Boolean variable b, where op(neg,e) is the general notation of e for all (supported) constraint expressions e. The more complex term of the form op(le,Σ,m) in Line 5 stands for a linear inequality Σ ≤ m. In particular, the inequality 4x − 3y + z ≤ 0 from C2 is represented by nested op(add,Σ,ax) terms whose last argument ax and deepest Σ part are of the form op(mul,a,x); such nesting corresponds to the precedence (((4∗x)+(−3∗y))+(1∗z)) ≤ 0. The representation by function terms captures linear inequalities of arbitrary arity and, as with Integer intervals, associates (sub)sums with canonical labels. Currently, the order of arguments ax is by variable labels x, while more “clever” orders may be established in the future.\nThe function terms expressing table and alldifferent constraints both include an argument list of the form arg(x1,arg(. . .,arg(xn,nil). . .)), in which x1, . . . , xn refer to Integer variables. In Line 3 of Listing 1, an alldifferent constraint over arguments x is declared via global(alldifferent,x); at present, alldifferent is a fixed keyword in facts generated by aspartame, but support for other kinds of global constraints can be added in the future. Beyond an argument list x, function terms of the form rel(r,x) also include an identifier r referring to a collection of table constraint tuples. For instance, the corresponding argument r in Line 7 ad-\ndresses the tuples specified by the facts in Line 9–12. Here, rel(r,2,3,supports) declares that r is of arity 2 and includes 3 tuples, provided as white list entries via facts of the form tuple(r,t,i,d). The latter include tuple and argument identifiers t and i along with a value d. Accordingly, the facts in Line 10, 11, and 12 specify the pairs (1, 3), (2, 2), and (3, 1) of values, which are the combinations admitted by the table constraint from C3 in (3). The application of the table constraint to variables x and y is expressed by the argument list in Line 7, so that tuple declarations can be re-used for other variables subject to a similar table constraint."
    }, {
      "heading" : "3.2 First-Order Encoding",
      "text" : "In addition to an output component extending sugar for generating ASP facts, aspartame comes along with alternative first-order ASP encodings of solutions for CSP instances. In the following, we sketch a dedicated encoding that, for one, relies on function terms to capture recurrences of similar structures and, for another, lifts the order encoding approach to structural subsum entities.\nStatic Extraction of Relevant Values To begin with, Listing 2 shows (relevant) instances of domain predicates, evaluated upon grounding, for the CSP from Example 1. While derived facts in Line 1 merely provide a projection of the predicate var/3 omitting associated domains, the instances of look/2 in Line 2 express that all values in the common domain {1, 2, 3} of x, y, and z shall be considered. In fact, domain predicates extract variable values that can be relevant for the satisfiability of a CSP instance, while discarding the rest. The respective static analysis consists of three stages: (i) isolation of threshold values relevant to linear inequalities; (ii) addition of missing values for variables occurring in alldifferent constraints; (iii) addition of white/black list values for table constraints.\nIn the first stage, we consider the domains of Integer variables x in terms of corresponding (non-overlapping) intervals I(x) = {[l1, u1], . . . , [lk, uk]}. These are extended to multiplications by Integer constants a according to the following scheme:\nI(ax) = { {[a ∗ l1, a ∗ u1], . . . , [a ∗ lk, a ∗ uk]} if 0 ≤ a {[a ∗ uk, a ∗ lk], . . . , [a ∗ u1, a ∗ l1]} if a < 0\nFor 4x− 3y+ z ≤ 0 from C2 in (2), we get I(4x) = {[4, 12]}, I(−3y) = {[−9,−3]}, and I(1z) = {[1, 3]}. Such intervals are used to retrieve bounds for (sub)sums:\n−→ l (ax) = min {l | [l, u] ∈ I(ax)} −→u (ax) = max {u | [l, u] ∈ I(ax)}\n−→ l (a1x1 + a2x2) = −→ l (a1x1) + −→ l (a2x2) −→u (a1x1 + a2x2) = −→u (a1x1) +−→u (a2x2)\nGiven −→ l (4x) = 4, −→u (4x) = 12, −→ l (−3y) = −9, −→u (−3y) = −3, −→ l (1z) = 1, and −→u (1z) = 3, we derive −→ l (4x− 3y) = −5, −→u (4x− 3y) = 9, −→ l (4x− 3y + z) = −4, and −→u (4x− 3y + z) = 12.\nIn view of the comparison with 0 in 4x−3y+z ≤ 0, we can now “push in” relevant thresholds via:\n←− l ( ∑ 1≤i≤naixi) = max{m, −→ l ( ∑ 1≤i≤naixi)} for ∑\n1≤i≤naixi ≤ m ←−u ( ∑ 1≤i≤naixi) = min{m, −→u ( ∑ 1≤i≤naixi)} for ∑\n1≤i≤naixi ≤ m ←− l ( ∑ 1≤i≤n−1aixi) = max{ ←− l ( ∑ 1≤i≤naixi)− −→u (anxn), −→ l ( ∑\n1≤i≤n−1aixi)} ←−u ( ∑ 1≤i≤n−1aixi) = min{ ←−u ( ∑ 1≤i≤naixi)− −→ l (anxn), −→u ( ∑ 1≤i≤n−1aixi)}\nSuch threshold analysis leads to ←− l (4x−3y+z) =←−u (4x−3y+z) = 0, ←− l (4x−3y) = −3,←−u (4x− 3y) = −1, ←− l (4x) = 4, and←−u (4x) = 8, telling us that subsums relevant for checking whether 4x−3y+z ≤ 0 satisfy−3 ≤ 4x−3y ≤ −1 and 4 ≤ 4x ≤ 8. Note that maxima (or minima) used to construct ←− l ( ∑ 1≤i≤n aixi) (or ←−u ( ∑\n1≤i≤n aixi)) serve two purposes. For one, they correct infeasible arithmetical thresholds to domain values; e.g., ←− l (4x−3y)−−→u (−3y) = −3+3 = 0 tells us that 0 would be the greatest lower bound to consider for 4x (since 4x − 3y + z ≤ 0 were necessarily satisfied when 4x ≤ 0), while the smallest possible value −→ l (4x) = 4 exceeds 0. For another, dominating values like 4x = 12 are discarded, given that 4x− 3y + z ≤ 0 cannot hold when 4x >←−u (4x− 3y)− −→ l (−3y) = −1 + 9 = 8.\nLetting ub(0) = {0}, the upper bounds for ∑\n1≤i≤n aixi that deserve further consideration are then obtained as follows:\nub( ∑ 1≤i≤naixi) = {max{j + an∗k, ←− l ( ∑ 1≤i≤naixi)} | j ∈ ub( ∑ 1≤i≤n−1aixi),\nk ∈ Z, [l, u] ∈ I(anxn), l ≤ an∗k ≤ min{u,←−u ( ∑ 1≤i≤naixi)− j}}\nStarting from the above thresholds, ub(4x) = {4, 8}, ub(4x − 3y) = {−3,−2,−1}, and ub(4x − 3y + z) = {0} indicate upper bounds for subsums that are of interest in evaluating 4x− 3y + z ≤ 0. Upper bounds in ub( ∑ 1≤i≤naixi) can in turn be related to “maximal” pairs of addends:\nS( ∑\n1≤i≤naixi) = {(j,max{an∗k | [l, u] ∈ I(anxn), l ≤ an∗k ≤ min{u, ub − j}, k ∈ Z}) | j ∈ ub( ∑ 1≤i≤n−1aixi), ub ∈ ub( ∑ 1≤i≤naixi), −→ l (anxn) ≤ ub − j}\nIn our example, we get S(4x) = {(0, 4), (0, 8)}, S(4x − 3y) = {(4,−9), (4,−6), (8,−9)}, and S(4x− 3y + z) = {(−3, 3), (−2, 2), (−1, 1)}.\nFinally, we associate each pair (j, an∗k) ∈ S( ∑\n1≤i≤naixi) of addends with the upper bound s(j, an∗k) = min{ub ∈ ub( ∑ 1≤i≤naixi) | j + an∗k ≤ ub}, thus obtaining s(0, 4) = 4, s(0, 8) = 8, s(4,−9) = −3, s(4,−6) = −2, s(8,−9) = −1, and s(−3, 3) = s(−2, 2) = s(−1, 1) = 0.\nThe described analysis of thresholds for subsums is implemented via deterministic domain predicates in our ASP encoding. Variables’ domain values underlying relevant addends are provided by the derived facts in Line 10–12 of Listing 2. Note that value 3 for x as well as 1 for y are ignored here, given that 4x = 12 and −3y = −3 do not admit 4x − 3y + z ≤ 0 to hold. The mapping of relevant addends to their associated\n1 var(int,x;y;z). 2 look(x;y;z,1;2;3).\n4 order(x;y;z,3,2). 5 order(x;y;z,2,1).\n7 order(op(add,op(mul,4,x),op(mul,-3,y)),-1,-2). 8 order(op(add,op(mul,4,x),op(mul,-3,y)),-2,-3).\n10 look(op(mul,4,x),1;2,1). 11 look(op(mul,-3,y),2;3,-1). 12 look(op(mul,1,z),1;2;3,1).\n14 look(op(add,op(mul,4,x),op(mul,-3,y)),4,-6,-2). 15 look(op(add,op(mul,4,x),op(mul,-3,y)),4,-9,-3). 16 look(op(add,op(mul,4,x),op(mul,-3,y)),8,-9,-1).\n18 look(op(add,op(add,op(mul,4,x),op(mul,-3,y)),op(mul,1,z)),-1,1,0). 19 look(op(add,op(add,op(mul,4,x),op(mul,-3,y)),op(mul,1,z)),-2,2,0). 20 look(op(add,op(add,op(mul,4,x),op(mul,-3,y)),op(mul,1,z)),-3,3,0).\n22 bound(op(add,op(add,op(mul,4,x),op(mul,-3,y)),op(mul,1,z)),12).\n24 difind(arg(x,arg(y,arg(z,nil))),x,1). 25 difind(arg(x,arg(y,arg(z,nil))),y,2). 26 difind(arg(x,arg(y,arg(z,nil))),z,3). 27 difmax(arg(x,arg(y,arg(z,nil))),3,1;2;3). 28 difall(arg(x,arg(y,arg(z,nil)))).\n30 relind(r,arg(x,arg(y,nil)),x,1). 31 relind(r,arg(x,arg(y,nil)),y,2).\nListing 2. Domain predicates derived via stratified rules (not shown) from facts in Listing 1.\nupper bound can be observed in Line 14–20 for the (sub)sums 4x − 3y and (4x − 3y) + z. The respective facts describe patterns for mapping assigned domain values to their multiplication results and then to upper bounds for subsums, which are eventually subject to a (non-trivial) comparison in some linear inequality. (Trivial comparisons are performed via the total upper bound for an addition result, as given in Line 22.) Notably, the static threshold analysis is implemented on terms representing the domains of variables, and outcomes are then mapped back to original variables. Thus, linear inequalities over different variables with the same domains are analyzed only once. The final function terms, however, mention the variables whose values are evaluated, where recurring substructures may share a common term with which all relevant threshold values are associated.\nAlthough the analysis of the linear inequality 4x − 3y + z ≤ 0 identifies the values 3 for x and 1 for y as redundant, the presence of alldifferent(x, y, z) leads to their “release” as relevant candidates for x and y. Accordingly, all values in the common domain {1, 2, 3} of x, y, and z are put into (decreasing) order, given by the derived facts in Line 4–5. Beyond that, the order among relevant upper bounds in ub(4x − 3y) = {−3,−2,−1} is reflected in Line 7–8; this is used to apply the order encoding to structural subsum variables (in addition to the input variables x, y, and z). The residual derived facts in Line 24–31 serve convenience by associating indexes to the arguments of alldifferent(x, y, z) as well as to x and y considered in (x, y) ∈ {(1, 3), (2, 2), (3, 1)}. Furthermore, the fact in Line 27 indicates the index 3 of variable z in alldifferent(x, y, z) as the final position at which either of the\n1 % generate variable assignment\n3 { less(V,E) : order(V,E,_) } :- var(int,V). 4 :- order(V,E1,E2), less(V,E2), not less(V,E1). 5 value(V,E) :- look(V,E), not less(V,E), less(V,EE) : order(V,EE,E).\n7 { value(V,true) } :- var(bool,V). 8 value(V,false) :- var(bool,V), not value(V,true).\n10 % evaluate linear inequalities\n12 leq(op(mul,F,V),F*E) :- look(op(mul,F,V),E,1), less(V,EE) : order(V,EE,E). 13 leq(op(mul,F,V),F*E) :- look(op(mul,F,V),E,-1), not less(V,E). 14 leq(op(add,S1,S2),E) :- look(op(add,S1,S2),E1,E2,E), leq(S1,E1;;S2,E2). 15 leq(op(add,S1,S2),E) :- order(op(add,S1,S2),E,EE), leq(op(add,S1,S2),EE).\n17 % evaluate alldifferent expressions\n19 seen(A,I,E) :- difind(A,V,I), value(V,E). 20 seen(A,I,E) :- difind(A,_,I), seen(A,I-1,E), not difmax(A,I-1,E).\n22 redo(A) :- difind(A,V,I), seen(A,I-1,E), value(V,E). 23 redo(A) :- difall(A), difmax(A,I,E), not seen(A,I,E).\n25 % evaluate table expressions\n27 rela(R,A,T,2) :- relind(R,A,V,1), tuple(R,T,1,E), value(V,E). 28 rela(R,A,T,I+1) :- relind(R,A,V,I), tuple(R,T,I,E), value(V,E), rela(R,A,T,I).\n30 rela(R,A,U) :- rela(R,A,_,I+1), rel(R,I,_,U).\n32 % check constraint clauses\n34 hold(C) :- constraint(C,V), value(V,true). 35 hold(C) :- constraint(C,op(neg,V)), value(V,false).\n37 hold(C) :- constraint(C,op(le,S,E)), bound(S,U), leq(S,E) : E < U. 38 hold(C) :- constraint(C,op(neg,op(le,S,E))), bound(S,U), E < U, not leq(S,E).\n40 hold(C) :- constraint(C,global(alldifferent,A)), not redo(A). 41 hold(C) :- constraint(C,op(neg,global(alldifferent,A))), redo(A).\n43 hold(C) :- constraint(C,rel(R,A)), not rela(R,A,conflicts), 44 rela(R,A,supports) : rel(R,_,_,supports). 45 hold(C) :- constraint(C,op(neg,rel(R,A))), not rela(R,A,supports), 46 rela(R,A,conflicts) : rel(R,_,_,conflicts).\n48 constraint(C) :- constraint(C,_). 49 :- constraint(C), not hold(C).\n51 % display variable assignment\n53 #hide. 54 #show value/2.\nListing 3. First-order encoding of solutions for finite linear CSPs.\nvalues 1, 2, or 3 can possibly be assigned, and the fact in Line 28 expresses that all three values in D(x) ∪ D(y) ∪ D(z) = {1, 2, 3} must be assigned in order to satisfy alldifferent(x, y, z).\nNon-deterministic Encoding Part With the described domain predicates at hand, the encoding part in Listing 3 implements the non-deterministic guessing of a variable as-\nsignment along with the evaluation of constraint clauses. Following the idea of order encodings in SAT [4, 5], the choice rule in Line 3 permits guessing less(V,E) for all but the smallest (relevant) value E in the domain of an Integer variable V, thus indicating that V is assigned to some smaller value than E. The consistency among guessed atoms is established by the integrity constraint in Line 4, requiring less(V,E1) to hold if less(V,E2) is true for the (immediate) predecessor value E2 of E1. The actual value assigned to V, given by the greatest E for which less(V,E) is false, is extracted in Line 5. For Boolean variables, the value true can be guessed unconditionally via the choice rule in Line 7, and false is derived otherwise via the rule in Line 8.\nThe dedicated extension of the order encoding idea to subsums of linear inequalities is implemented by means of the rules in Line 12–15 of Listing 3. To this end, upper bounds for singular multiplication results indicated as relevant by instances of look(op(mul,F,V),E,G) are directly derived from less/2. Thereby, the flag G = F/|F| provides the polarity of the actual coefficient F.8 If F is positive, i.e., G = 1, the upper bound F*E is established as soon as less(V,EE) holds for the immediate successor value EE of E (or if E is the greatest relevant value in the domain of V). On the other hand, if G = -1 indicates that F is negative, the upper bound F*E is derived from not less(V,E), which means that the value assigned to V is greater than or equal to E. Relevant upper bounds E for subsums rely on maximal pairs (E1,E2) of addends, identified via static threshold analysis and readily provided by instances of look(op(add,S1,S2),E1,E2,E). In fact, the rule in Line 14 derives leq(op(add,S1,S2),E), indicating that S1 + S2 ≤ E, from leq(S1,E1) and leq(S2,E2). Although an established upper bound inherently implies any greater (relevant) upper bound to hold as well w.r.t. a total variable assignment, ASP (and SAT) solvers are not committed to guessing “input variables” first. Rather, structural variables like the instances of leq(op(add,S1,S2),E) may be fixed upon solving, possibly in view of recorded conflict clauses, before a total assignment has been determined. In view of this, the additional rule in Line 15 makes sure that an established upper bound EE propagates to its immediate successor E (if there is any). For instance, (simplified) ground instances of the rule stemming from ub(4x− 3y) = {−3,−2,−1} include the following:\nleq(op(add,op(mul,4,x),op(mul,-3,y)),-1) :- leq(op(add,op(mul,4,x),op(mul,-3,y)),-2).\nleq(op(add,op(mul,4,x),op(mul,-3,y)),-2) :- leq(op(add,op(mul,4,x),op(mul,-3,y)),-3).\nUnlike with the domains of Integer variables, we rely on a rule, rather than an integrity constraint, to establish consistency among the bounds for structural subsums. The reason for this is that upper bounds for addends S1 and S2, contributing left and right justifications, may include divergent gaps, so that consistent value orderings for them are, in general, not guaranteed to immediately produce all relevant upper bounds for S1+ S2. Encoding variants resolving this issue and using integrity constraints like the one in Line 4 are a subject to future investigation.\nWhile linear inequalities can be evaluated by means of boundaries derived more or less directly from instances of less(V,E), the evaluation of alldifferent and table\n8 Coefficients given in facts generated by aspartame are distinct from 0.\nconstraints in Line 19–23 and Line 27–30 of Listing 3 relies on particular instances of value(V,E). The basic idea of checking whether an alldifferent constraint holds is to propagate assigned values along the indexes of participating variables. Then, a recurrence is detected when the value assigned to a variable with index I has been marked as already assigned, as determined from seen(A,I-1,E) in Line 22. Moreover, whenever difall(A) indicates that all domain values for the variables in argument list A must be assigned, the rule in Line 23 additionally derives a recurrence from some gap (a value that has not been assigned to the variable at the last possible index). Our full encoding further features so-called “pigeon-hole constraints” (cf. [10, 11]) to check that the smallest or greatest 1, . . . , n− 1 domain values for an alldifferent constraint with n variables are not populated by more than i variables for 1 ≤ i ≤ n−1. Such conditions can again be checked based on instances of less(V,E), and both counter-based (cf. [12]) as well as aggregate-based (cf. [13]) implementations are applicable in view of the native support of aggregates by ASP solvers like clasp (cf. [14]). In fact, the usage of rules to express redundant constraints, like the one in Line 23 or those for pigeon-hole constraints, as well as their ASP formulation provide various degrees of freedom, where comprehensive evaluation and configuration methods are subjects to future work.\nThe strategy for evaluating table constraints is closely related to the one for detecting value recurrences in alldifferent constraints. Based on the indexes of variables in a table constraint, tuples that are (still) admissible are forwarded via the rules in Line 27– 28. The inclusion of a full tuple in an assignment is detected by the rule in Line 30, checking whether the arity I of a table constraint has been reached for some tuple, where a value supports or conflicts for U additionally indicates whether the included tuple belongs to a white or black list, respectively. Note that this strategy avoids explicit references to variables whose values are responsible for the exclusion of tuples, given that lack of inclusion is detected from incomplete tuple traversals.\nFinally, the rules in Line 34–49 explore the values assigned to Boolean variables and the outcomes of evaluating particular kinds of constraints to derive hold(C) if and only if some positive or negative literal in C is satisfied or unsatisfied, respectively, w.r.t. the variable assignment represented by instances of value(V,E). Without going into details, let us still note that our full encoding also features linear inequalities relying on the comparison operators≥, =, and 6=, for which additional rules are included to derive hold(C), yet sticking to the principle of upper bound evaluation via leq/2. In fact, the general possibility of complemented constraint expressions as well as of disjunctions potentially admits unsatisfied constraint expressions w.r.t. solutions, and our encoding reflects this by separating the evaluation of particular constraint expressions in Line 12– 30 from further literal and clause evaluation in Line 34–49.\n4 The aspartame System\nThe architecture of the aspartame system is given in Figure 1. As mentioned, aspartame re-uses sugar’s front-end for parsing and normalizing CSPs. Hence, it accepts the same input formats, viz. XCSP9 and sugar’s native CSP format10. We then implemented an\n9 http://www.cril.univ-artois.fr/CPAI08/XCSP2 1.pdf 10 http://bach.istc.kobe-u.ac.jp/sugar/package/current/docs/syntax.html\noutput hook for sugar that provides us with the resulting CSP instance in the fact format described in Section 3.1. These facts are then used for grounding the (full version of the) dedicated ASP encoding in Listing 3 or an alternative one (discussed below). This is done by the ASP grounder gringo. In turn, the resulting propositional logic program is passed to the ASP solver clasp that returns an assignment, representing a solution to the original CSP instance.\nWe empirically access the performance of aspartame relative to two ASP encodings, the dedicated one described in Section 3.2 as well as a more direct encoding inspired by the original CNF construction of sugar [5], and additionally consider the SAT-based reference solver sugar (2.0.0). In either case, we use the combined ASP and SAT solver clasp (2.1.0), and ASP-based approaches further rely on gringo (3.0.5) for grounding ASP encodings on facts generated by aspartame. We selected 60 representative CSP instances (that are neither too easy nor too hard), consisting of intensional and global constraints, from the benchmarks of the 2009 CSP Competition11 for running systematic experiments on a cluster of Linux machines equipped with dual Xeon E5520 quad-core 2.26 GHz processors and 48 GB RAM. To get some first insights into suitable search options, we ran clasp with its default (berkmin-like) and the popular “vsids” decision heuristic; while SAT-based preprocessing (cf. [15]) is performed by default on CNF inputs, we optionally enabled it for (ground) ASP instances, leading to four combinations of clasp settings for ASP-based approaches and two for SAT-based sugar.\nTable 1 reports runtime results in seconds, separated into conversion time of aspartame from CSP instances to ASP facts (first “convert” column) and of sugar from CSP instances to CNF, gringo times for grounding ASP encodings relative to facts, and finally columns for the search times of clasp with the aforementioned options. Each computational phase was restricted to 600 seconds, and timeouts counted in the last row of Table 1 are taken as 600 seconds in the second last row providing average runtimes. Looking at these summary rows, we observe that our two ASP encodings are solved most effectively when vsids decision heuristic and SAT preprocessing are both enabled; unlike this, neither decision heuristic dominates the other on CNF input. Apparently, clasp on CNFs generated by sugar still has a significant edge on facts by aspartame combined with either ASP encoding. In particular, we observe drastic performance discrepancies on some instance families (especially “fischer” and “queensKnights”), where clasp performs stable on CNFs from sugar but runs into trouble on corresponding ASP instances. Given that aspartame and its ASP encodings are prototypes, such behavior does not disprove the basic approach, but rather motivates future\n11 http://www.cril.univ-artois.fr/CPAI09\ninvestigations of the reasons for performance discrepancies. For one, we conjecture that normalizations of global constraints that are not yet supported by aspartame are primarily responsible for large instance sizes and long search times on some instance families. For another, we suppose that both of our ASP encodings are still quite naive compared to years of expertise manifested in sugar’s CNF construction. However, the observation that our dedicated ASP encoding has on edge the SAT-inspired one and yields significant performance improvements on some instance families (“C2-3-15”–“C5-3-91” and “mps”) clearly encourages further investigations into ASP encodings of CSP instances."
    }, {
      "heading" : "5 Related Work",
      "text" : "Unlike approaches to constraint answer set solving, e.g., [10, 16–18], which aim at integrating CSP and ASP solving (engines), the focus of aspartame lies on pure CSP solving. In fact, aspartame’s approach can be regarded as a first-order alternative to SAT-based systems like sugar [5], where the performance of the underlying SAT solver is crucial. However, it is now becoming recognized that the SAT encoding to be used also plays an important role [19]. There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].\nThe order encoding, where Boolean variables represent whether x ≤ i holds for variables x and values i, showed good performance for a wide range of CSPs [4, 11, 27, 29–34]. Especially, the SAT-based constraint solver sugar became a winner in global constraint categories at the 2008 and 2009 CSP solver competitions [35]. Moreover, the SAT-based CSP solver BEE [36] and the CLP system B-Prolog [37] utilize the order encoding. In fact, the order encoding provides a compact translation of arithmetic constraints, while also maintaining bounds consistency by unit propagation. Interestingly, it has been shown that the order encoding is the only existing SAT encoding that can reduce tractable CSP to tractable SAT [38]."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We presented an alternative approach to solving finite linear CSPs based on ASP. The resulting system aspartame relies on high-level ASP encodings and delegates both the grounding and solving tasks to general-purpose ASP systems. We have contrasted aspartame with its SAT-based ancestor sugar, which delegates only the solving task to off-the-shelf SAT solvers, while using dedicated algorithms for constraint preprocessing. Although aspartame does not fully match the performance of sugar from a global perspective, the picture is fragmented and leaves room for further improvements. This is to say that different performances are observed on distinct classes of CSPs, comprising different types of constraints. Thus, it is an interesting topic of future research to devise more appropriate ASP encodings for such settings. Despite all this, aspartame demonstrates that ASP’s general-purpose technology allows to compete with state-of-the-art constraint solving techniques, not to mention that aspartame’s intelligence is driven by an ASP encoding of less than 100 code lines (for non-deterministic predicates subject\nto search). In fact, the high-level approach of ASP facilitates extensions and variations of first-order encodings for dealing with particular types of constraints. In the future, we thus aim at more exhaustive investigations of encoding variants, e.g., regarding alldifferent constraints, as well as support for additional kinds of global constraints.\nAcknowledgments This work was partially funded by the Japan Society for the Promotion of Science (JSPS) under grant KAKENHI 24300007 as well as the German Science Foundation (DFG) under grant SCHA 550/8-3 and SCHA 550/9-1. We are grateful to the anonymous reviewers for many helpful comments."
    } ],
    "references" : [ {
      "title" : "Constraint Processing",
      "author" : [ "R. Dechter" ],
      "venue" : "Morgan Kaufmann Publishers",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Handbook of Constraint Programming",
      "author" : [ "F. Rossi", "P. van Beek", "T. Walsh", "eds." ],
      "venue" : "Elsevier Science",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Handbook of Satisfiability",
      "author" : [ "A. Biere", "M. Heule", "H. van Maaren", "T. Walsh", "eds." ],
      "venue" : "IOS Press",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Experimental results on the application of satisfiability algorithms to scheduling problems",
      "author" : [ "J. Crawford", "A. Baker" ],
      "venue" : "In Hayes-Roth, B., and Korf, R., eds.: Proceedings of the Twelfth National Conference on Artificial Intelligence (AAAI’94), AAAI Press",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Compiling finite linear CSP into SAT",
      "author" : [ "N. Tamura", "A. Taga", "S. Kitagawa", "M. Banbara" ],
      "venue" : "Constraints 14(2)",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Knowledge Representation, Reasoning and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : "Cambridge University Press",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Answer Set Solving in Practice",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Morgan and Claypool Publishers",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A constraint seeker: Finding and ranking global constraints from examples",
      "author" : [ "N. Beldiceanu", "H. Simonis" ],
      "venue" : "In Lee, J., ed.: Proceedings of the Seventeenth International Conference on Principles and Practice of Constraint Programming (CP’11), Springer-Verlag",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A translational approach to constraint answer set solving",
      "author" : [ "C. Drescher", "T. Walsh" ],
      "venue" : "Theory and Practice of Logic Programming 10(4-6)",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Boolean equi-propagation for concise and efficient SAT encodings of combinatorial problems",
      "author" : [ "A. Metodi", "M. Codish", "P. Stuckey" ],
      "venue" : "Journal of Artificial Intelligence Research 46",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Towards an optimal CNF encoding of Boolean cardinality constraints",
      "author" : [ "C. Sinz" ],
      "venue" : "In van Beek, P., ed.: Proceedings of the Eleventh International Conference on Principles and Practice of Constraint Programming (CP’05), Springer-Verlag",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "P. Simons", "I. Niemelä", "T. Soininen" ],
      "venue" : "Artificial Intelligence 138(1-2)",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Effective preprocessing in SAT through variable and clause elimination",
      "author" : [ "N. Eén", "A. Biere" ],
      "venue" : "In Bacchus, F., Walsh, T., eds.: Proceedings of the Eighth International Conference on Theory and Applications of Satisfiability Testing (SAT’05), Springer-Verlag",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Representing constraint satisfaction problems in answer set programming",
      "author" : [ "M. Balduccini" ],
      "venue" : "In Faber, W., Lee, J., eds.: Proceedings of the Second Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP’09),",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "ASP modulo CSP: The clingcon system",
      "author" : [ "M. Ostrowski", "T. Schaub" ],
      "venue" : "Theory and Practice of Logic Programming 12(4-5)",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A comparison of ATMS and CSP techniques",
      "author" : [ "J. de Kleer" ],
      "venue" : "In Sridharan, N., ed.: Proceedings of the Eleventh International Joint Conference on Artificial Intelligence (IJCAI’89), Morgan Kaufmann Publishers",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "SAT v CSP",
      "author" : [ "T. Walsh" ],
      "venue" : "In Dechter, R., ed.: Proceedings of the Sixth International Conference on Principles and Practice of Constraint Programming (CP’00), Springer-Verlag",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "On the parallel complexity of discrete relaxation in constraint satisfaction networks",
      "author" : [ "S. Kasif" ],
      "venue" : "Artificial Intelligence 45(3)",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Arc consistency in SAT",
      "author" : [ "I. Gent" ],
      "venue" : "In van Harmelen, F., ed.: Proceedings of the Fifteenth European Conference on Artificial Intelligence (ECAI’02), IOS Press",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "SAT-variable complexity of hard combinatorial problems",
      "author" : [ "K. Iwama", "S. Miyazaki" ],
      "venue" : "In Pehrson, B., Simon, I., eds.: Proceedings of the Thirteenth IFIP World Computer Congress (WCC’94), North-Holland",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Another look at graph coloring via propositional satisfiability",
      "author" : [ "A. Van Gelder" ],
      "venue" : "Discrete Applied Mathematics 156(2)",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "The log-support encoding of CSP into SAT",
      "author" : [ "M. Gavanelli" ],
      "venue" : "In Bessiere, C., ed.: Proceedings of the Thirteenth International Conference on Principles and Practice of Constraint Programming (CP’07), Springer-Verlag",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Mapping problems with finite-domain variables into problems with Boolean variables",
      "author" : [ "C. Ansótegui", "F. Manyà" ],
      "venue" : "In Hoos, H., Mitchell, D., eds.: Proceedings of the Seventh International Conference on Theory and Applications of Satisfiability Testing (SAT’04), SpringerVerlag",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Azucar: A SAT-based CSP solver using compact order encoding (tool presentation)",
      "author" : [ "T. Tanjo", "N. Tamura", "M. Banbara" ],
      "venue" : "In Cimatti, A., Sebastiani, R., eds.: Proceedings of the Fifteenth International Conference on Theory and Applications of Satisfiability Testing (SAT’12), Springer-Verlag",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Efficient CNF encoding of Boolean cardinality constraints",
      "author" : [ "O. Bailleux", "Y. Boufkhad" ],
      "venue" : "In Rossi, F., ed.: Proceedings of the Ninth International Conference on Principles and Practice of Constraint Programming (CP’03), Springer-Verlag",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "A new encoding of AllDifferent into SAT",
      "author" : [ "I. Gent", "P. Nightingale" ],
      "venue" : "In Frisch, A., Miguel, I., eds.: Proceedings of the Third International Workshop on Modelling and Reformulating Constraint Satisfaction Problems (ModRef’04),",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "A competitive and cooperative approach to propositional satisfiability",
      "author" : [ "K. Inoue", "T. Soh", "S. Ueda", "Y. Sasaura", "M. Banbara", "N. Tamura" ],
      "venue" : "Discrete Applied Mathematics 154(16)",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A SAT-based method for solving the two-dimensional strip packing problem",
      "author" : [ "T. Soh", "K. Inoue", "N. Tamura", "M. Banbara", "H. Nabeshima" ],
      "venue" : "Fundamenta Informaticae 102(3-4)",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Propagation via lazy clause generation",
      "author" : [ "O. Ohrimenko", "P. Stuckey", "M. Codish" ],
      "venue" : "Constraints 14(3)",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Generating combinatorial test cases by efficient SAT encodings suitable for CDCL SAT solvers",
      "author" : [ "M. Banbara", "H. Matsunaka", "N. Tamura", "K. Inoue" ],
      "venue" : "In Fermüller, C., Voronkov, A., eds.: Proceedings of the Seventeenth International Conference on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR’10), Springer-Verlag",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Promoting robust black-box solvers through competitions",
      "author" : [ "C. Lecoutre", "O. Roussel", "M. van Dongen" ],
      "venue" : "Constraints 15(3)",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Compiling finite domain constraints to SAT with BEE",
      "author" : [ "A. Metodi", "M. Codish" ],
      "venue" : "Theory and Practice of Logic Programming 12(4-5)",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "The SAT compiler in B-prolog",
      "author" : [ "N. Zhou" ],
      "venue" : "The Association for Logic Programming Newsletter, March 2013",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "The order encoding: From tractable CSP to tractable SAT",
      "author" : [ "J. Petke", "P. Jeavons" ],
      "venue" : "In Sakallah, K., Simon, L., eds.: Proceedings of the Fourteenth International Conference on Theory and Applications of Satisfiability Testing (SAT’11), Springer-Verlag",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Encoding finite linear Constraint Satisfaction Problems (CSPs; [1, 2]) as propositional formulas and solving them by using modern solvers for Satisfiability Testing (SAT; [3]) has proven to be a highly effective approach, as demonstrated by the award-winning sugar4 system.",
      "startOffset" : 63,
      "endOffset" : 69
    }, {
      "referenceID" : 1,
      "context" : "Encoding finite linear Constraint Satisfaction Problems (CSPs; [1, 2]) as propositional formulas and solving them by using modern solvers for Satisfiability Testing (SAT; [3]) has proven to be a highly effective approach, as demonstrated by the award-winning sugar4 system.",
      "startOffset" : 63,
      "endOffset" : 69
    }, {
      "referenceID" : 2,
      "context" : "Encoding finite linear Constraint Satisfaction Problems (CSPs; [1, 2]) as propositional formulas and solving them by using modern solvers for Satisfiability Testing (SAT; [3]) has proven to be a highly effective approach, as demonstrated by the award-winning sugar4 system.",
      "startOffset" : 171,
      "endOffset" : 174
    }, {
      "referenceID" : 3,
      "context" : "The translation relies on the order encoding [4, 5], and the resulting CNF formula can be solved by an off-theshelf SAT solver.",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 4,
      "context" : "The translation relies on the order encoding [4, 5], and the resulting CNF formula can be solved by an off-theshelf SAT solver.",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 5,
      "context" : "In what follows, we elaborate upon an alternative approach based on Answer Set Programming (ASP; [6]) and present the resulting CSP solver aspartame5.",
      "startOffset" : 97,
      "endOffset" : 100
    }, {
      "referenceID" : 5,
      "context" : "A comprehensive treatment of ASP can be found in [6], one oriented towards ASP solving is given in [7].",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 6,
      "context" : "A comprehensive treatment of ASP can be found in [6], one oriented towards ASP solving is given in [7].",
      "startOffset" : 99,
      "endOffset" : 102
    }, {
      "referenceID" : 0,
      "context" : "Although we provide essential definitions of CSPs in the next section, we refer the reader to the literature [1, 2] for a broader perspective.",
      "startOffset" : 109,
      "endOffset" : 115
    }, {
      "referenceID" : 1,
      "context" : "Although we provide essential definitions of CSPs in the next section, we refer the reader to the literature [1, 2] for a broader perspective.",
      "startOffset" : 109,
      "endOffset" : 115
    }, {
      "referenceID" : 7,
      "context" : "[9]) is an arbitrary relation over Integer variables in I(V); we here restrict ourselves to table and alldifferent constraints over subsets {x1, .",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "7 Linear inequalities relying on further comparison operators, such as <, >, ≥, =, and 6=, can be converted into the considered format via appropriate replacements [5].",
      "startOffset" : 164,
      "endOffset" : 167
    }, {
      "referenceID" : 3,
      "context" : "For 4x− 3y+ z ≤ 0 from C2 in (2), we get I(4x) = {[4, 12]}, I(−3y) = {[−9,−3]}, and I(1z) = {[1, 3]}.",
      "startOffset" : 50,
      "endOffset" : 57
    }, {
      "referenceID" : 10,
      "context" : "For 4x− 3y+ z ≤ 0 from C2 in (2), we get I(4x) = {[4, 12]}, I(−3y) = {[−9,−3]}, and I(1z) = {[1, 3]}.",
      "startOffset" : 50,
      "endOffset" : 57
    }, {
      "referenceID" : 0,
      "context" : "For 4x− 3y+ z ≤ 0 from C2 in (2), we get I(4x) = {[4, 12]}, I(−3y) = {[−9,−3]}, and I(1z) = {[1, 3]}.",
      "startOffset" : 93,
      "endOffset" : 99
    }, {
      "referenceID" : 2,
      "context" : "For 4x− 3y+ z ≤ 0 from C2 in (2), we get I(4x) = {[4, 12]}, I(−3y) = {[−9,−3]}, and I(1z) = {[1, 3]}.",
      "startOffset" : 93,
      "endOffset" : 99
    }, {
      "referenceID" : 3,
      "context" : "Following the idea of order encodings in SAT [4, 5], the choice rule in Line 3 permits guessing less(V,E) for all but the smallest (relevant) value E in the domain of an Integer variable V, thus indicating that V is assigned to some smaller value than E.",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 4,
      "context" : "Following the idea of order encodings in SAT [4, 5], the choice rule in Line 3 permits guessing less(V,E) for all but the smallest (relevant) value E in the domain of an Integer variable V, thus indicating that V is assigned to some smaller value than E.",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 8,
      "context" : "[10, 11]) to check that the smallest or greatest 1, .",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 9,
      "context" : "[10, 11]) to check that the smallest or greatest 1, .",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 10,
      "context" : "[12]) as well as aggregate-based (cf.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[13]) implementations are applicable in view of the native support of aggregates by ASP solvers like clasp (cf.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "2 as well as a more direct encoding inspired by the original CNF construction of sugar [5], and additionally consider the SAT-based reference solver sugar (2.",
      "startOffset" : 87,
      "endOffset" : 90
    }, {
      "referenceID" : 12,
      "context" : "[15]) is performed by default on CNF inputs, we optionally enabled it for (ground) ASP instances, leading to four combinations of clasp settings for ASP-based approaches and two for SAT-based sugar.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 8,
      "context" : ", [10, 16–18], which aim at integrating CSP and ASP solving (engines), the focus of aspartame lies on pure CSP solving.",
      "startOffset" : 2,
      "endOffset" : 13
    }, {
      "referenceID" : 13,
      "context" : ", [10, 16–18], which aim at integrating CSP and ASP solving (engines), the focus of aspartame lies on pure CSP solving.",
      "startOffset" : 2,
      "endOffset" : 13
    }, {
      "referenceID" : 14,
      "context" : ", [10, 16–18], which aim at integrating CSP and ASP solving (engines), the focus of aspartame lies on pure CSP solving.",
      "startOffset" : 2,
      "endOffset" : 13
    }, {
      "referenceID" : 4,
      "context" : "In fact, aspartame’s approach can be regarded as a first-order alternative to SAT-based systems like sugar [5], where the performance of the underlying SAT solver is crucial.",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 15,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 82,
      "endOffset" : 90
    }, {
      "referenceID" : 16,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 82,
      "endOffset" : 90
    }, {
      "referenceID" : 17,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 109,
      "endOffset" : 117
    }, {
      "referenceID" : 18,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 109,
      "endOffset" : 117
    }, {
      "referenceID" : 19,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 132,
      "endOffset" : 140
    }, {
      "referenceID" : 20,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 132,
      "endOffset" : 140
    }, {
      "referenceID" : 21,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 163,
      "endOffset" : 167
    }, {
      "referenceID" : 22,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 186,
      "endOffset" : 190
    }, {
      "referenceID" : 3,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 207,
      "endOffset" : 213
    }, {
      "referenceID" : 4,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 207,
      "endOffset" : 213
    }, {
      "referenceID" : 23,
      "context" : "There have been several proposals of encoding constraints to SAT: direct encoding [20, 21], support encoding [22, 23], log encoding [24, 25], log support encoding [26], regular encoding [27], order encoding [4, 5], and compact order encoding [28].",
      "startOffset" : 242,
      "endOffset" : 246
    }, {
      "referenceID" : 3,
      "context" : "The order encoding, where Boolean variables represent whether x ≤ i holds for variables x and values i, showed good performance for a wide range of CSPs [4, 11, 27, 29–34].",
      "startOffset" : 153,
      "endOffset" : 171
    }, {
      "referenceID" : 9,
      "context" : "The order encoding, where Boolean variables represent whether x ≤ i holds for variables x and values i, showed good performance for a wide range of CSPs [4, 11, 27, 29–34].",
      "startOffset" : 153,
      "endOffset" : 171
    }, {
      "referenceID" : 22,
      "context" : "The order encoding, where Boolean variables represent whether x ≤ i holds for variables x and values i, showed good performance for a wide range of CSPs [4, 11, 27, 29–34].",
      "startOffset" : 153,
      "endOffset" : 171
    }, {
      "referenceID" : 24,
      "context" : "The order encoding, where Boolean variables represent whether x ≤ i holds for variables x and values i, showed good performance for a wide range of CSPs [4, 11, 27, 29–34].",
      "startOffset" : 153,
      "endOffset" : 171
    }, {
      "referenceID" : 25,
      "context" : "The order encoding, where Boolean variables represent whether x ≤ i holds for variables x and values i, showed good performance for a wide range of CSPs [4, 11, 27, 29–34].",
      "startOffset" : 153,
      "endOffset" : 171
    }, {
      "referenceID" : 26,
      "context" : "The order encoding, where Boolean variables represent whether x ≤ i holds for variables x and values i, showed good performance for a wide range of CSPs [4, 11, 27, 29–34].",
      "startOffset" : 153,
      "endOffset" : 171
    }, {
      "referenceID" : 27,
      "context" : "The order encoding, where Boolean variables represent whether x ≤ i holds for variables x and values i, showed good performance for a wide range of CSPs [4, 11, 27, 29–34].",
      "startOffset" : 153,
      "endOffset" : 171
    }, {
      "referenceID" : 28,
      "context" : "The order encoding, where Boolean variables represent whether x ≤ i holds for variables x and values i, showed good performance for a wide range of CSPs [4, 11, 27, 29–34].",
      "startOffset" : 153,
      "endOffset" : 171
    }, {
      "referenceID" : 29,
      "context" : "The order encoding, where Boolean variables represent whether x ≤ i holds for variables x and values i, showed good performance for a wide range of CSPs [4, 11, 27, 29–34].",
      "startOffset" : 153,
      "endOffset" : 171
    }, {
      "referenceID" : 30,
      "context" : "Especially, the SAT-based constraint solver sugar became a winner in global constraint categories at the 2008 and 2009 CSP solver competitions [35].",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 31,
      "context" : "Moreover, the SAT-based CSP solver BEE [36] and the CLP system B-Prolog [37] utilize the order encoding.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 32,
      "context" : "Moreover, the SAT-based CSP solver BEE [36] and the CLP system B-Prolog [37] utilize the order encoding.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 33,
      "context" : "Interestingly, it has been shown that the order encoding is the only existing SAT encoding that can reduce tractable CSP to tractable SAT [38].",
      "startOffset" : 138,
      "endOffset" : 142
    } ],
    "year" : 2013,
    "abstractText" : "Encoding finite linear CSPs as Boolean formulas and solving them by using modern SAT solvers has proven to be highly effective, as exemplified by the award-winning sugar system. We here develop an alternative approach based on ASP. This allows us to use first-order encodings providing us with a high degree of flexibility for easy experimentation with different implementations. The resulting system aspartame re-uses parts of sugar for parsing and normalizing CSPs. The obtained set of facts is then combined with an ASP encoding that can be grounded and solved by off-the-shelf ASP systems. We establish the competitiveness of our approach by empirically contrasting aspartame and sugar.",
    "creator" : "TeX"
  }
}