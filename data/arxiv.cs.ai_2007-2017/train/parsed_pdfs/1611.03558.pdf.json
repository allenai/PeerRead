{
  "name" : "1611.03558.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "The USTC NELSLIP Systems for Trilingual Entity Detection and Linking Tasks at TAC KBP 2016",
    "authors" : [ "Dan Liu", "Wei Lin", "Shiliang Zhang", "Si Wei", "Hui Jiang" ],
    "emails" : [ "danliu@iflytek.com,", "weilin2@iflytek.com,", "siwei@iflytek.com,", "zsl2008@mail.ustc.edu.cn,", "hj@cse.yorku.ca" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "In this paper, we describe the USTC NELSLIP systems submitted to 2016 TAC KBP Trilingual Entity Discovery and Linking (EDL) task organized by NIST. The EDL task requires to detect named entities and their nominal mentions in the raw text of three languages (English, Chinese and Spanish) and further link each detected mention to the corresponding node in an existing knowledge base, namely Freebase. For NIL mentions that do not exist in the knowledge base, the EDL system needs to cluster all NIL mentions and assign a unique ID to each NIL mention cluster. The entire framework of our EDL systems is shown in Figure 1.\nThis year, the EDL task has extended the nominal mention detection to all entity types for all three\nlanguages. As before, there are in total 5 different mention types, denoted as PER, LOC, ORG, GPE, FAC. During each evaluation window, a large corpus of 90,000 documents is provided to each team to process. Each EDL system needs to be efficient enough to process these documents within the required evaluation window."
    }, {
      "heading" : "2 Mention Detection",
      "text" : "In the conventional approaches, we normally treat mention detection as a sequence labeling problem, which is typically solved using conditional random fields (CRFs) models. As for nominal mention detection, we typically use a noun phrase chunker to detect all possible candidates for nominal mention. Afterwards, some heuristic post-processing methods are used to identify the true nominal mentions. Differing from the traditional methods, in this work, we consider nominal mentions as special named entities and jointly detect both named and nominal mentions altogether using a single model. In this section, we will describe two different systems built for mention detection: the first system uses RNNbased conditional language model to perform the sequence labeling for mention detection; the other one adopts the popular attention based encoder-decoder structure that is further extended to deal with treestructured representations to detect nested mentions in the KBP tasks."
    }, {
      "heading" : "2.1 RNN based Conditional Language Model",
      "text" : "Named entity recognition (NER) without nested entities can be easily formulated as a typical sequence labeling problem, where each output tag can be\nar X\niv :1\n61 1.\n03 55\n8v 1\n[ cs\n.C L\n] 1\n1 N\nov 2\naligned one by one to an input word. Moreover, there exists strong dependency among adjacent output labels. Conditional random fields (CRFs) (Lafferty et al., 2001) is a widely-used method for sequence labeling. However, the linear chain CRFs lack of the capability to model long term dependency. We think the long-term dependency may be important to resolve some NER cases. For example, some entity names may get really long, and the probability for an ORG to occur after a PER (within a certain range) may be quite high. In the past, some high order CRFs have been proposed to address these issues but high order CRFs are too complex to train. In this paper, we introduce a new method to model the long term dependency for NER and mention detection. Let us denote a pair of an input sentence X and an output sequence of tags Y as follows:\nX = (x1, x2, ..., xN )\nY = (y1, y2, ..., yN ).\nLike all sequence labelling problems, the key problem in modeling is to compute the sequencelevel conditional probability Pr (Y |X). In this work, we propose a new model to compute the con-\nditional probability as follows:\nPr (Y |X) = N∏ i=1 P (yi | X, yi−1, yi−2, ...y1) (1)\nAs shown in eq.(1), this modeling approach is quite similar to language models based on recurrent neural networks (RNN) in (Mikolov et al., 2010) except that each factorized probability depends on the entire input sequence X . Here, we call this model as conditional RNN language model. The architecture of this models is as shown in Figure 3. In order to compute each factorized conditional probability in eq.(1), we propose to use a hybrid neural network, consisting of two modules. The first model is a convolutional neural network that is stacked with several 1-dimension convolutional layers to generate the representation for the entire input sequence X . The second model is a standard RNN-like language model for the output sequence, which always takes the representation of X as input. For simplicity, we use one layer of gated recurrent units (GRU) (Cho et al., 2014), which essentially computes all factorized probabilities in eq.(1) one by one sequentially, each of which conditions on the CNN-generated representation ofX and the preceding partial output sequence.\nIn the training stage, we jointly learn the CNN\nlayers and the GRU layer to maximize the conditional probability in eq.(1) based on all collected sequence pairs in the training set, {Xi, Yi}. In the test stage, the learned hybrid model of CNNs and GRU-based RNN is used to calculated all conditional probabilities, and the Viterbi decoding algorithm is used to generate the output sequence Y for each input sentence X ."
    }, {
      "heading" : "2.2 Attention-based Encoder-Decoder",
      "text" : "In KBP tasks, roughly 10% of the labelled entities are nested. It is well known it is not straightforward to handle nested entities using the traditional sequence labeling models. In (Finkel and Manning, 2009), it has shown that the nested entities can be processed into a tree-structured representation using a normal char parser. Furthermore, inspired by the idea in (Vinyals et al., 2015), we may easily linearize a tree structure into a linear sequence representation. For example, given a nested entity such as Kentucky Fried Chicken, the whole phrase is a named entity of FAC and Kentucky is a nested named entity of PER. Following the same idea in (Vinyals et al., 2015), the tree-structured representation for this nested entity may be represented as a linear sequence:\n[FAC [PER Kentucky ]PER Fried Chicken ]FAC\nwhere some paired special symbols, such as [FAC , ]PER, [PER and ]FAC , are introduced to represent\nthe boundaries and type of each entity in a string. Obviously, relying on these extra symbols, this representation is flexible enough to represent any nested entities.\nWe first use a chart parser to process all entity labels in the training data and generate the corresponding output labels in this format. For example, given an input string like Kentucky Fried Chicken and its nested entity labels, we will generate the corresponding output sequence as:\n[FAC [PER Z ]PER Z Z ]FAC\nwhere each Z is a generic placeholder and they correspond to the words of the original sequence one by one in order. Obviously, from this output sequence of placeholder and the input word sequence, we can easily derive all nested entities and their types.\nNext, we use an attention-based encoder-decoder model to learn the mapping from the raw word sequence to the above sequence of special symbols and placeholders. The idea is similar to the traditional sequence labelling models, except that the output tages are extended from regular BIO tags to the above special symbols. The architecture of the attention based encoder-decoder model is shown in Figure 3, which consists of three modules. The encoder module is a stack of several 1-dimension convolutional layers for generating the representation of input sequence X , and the attention mechanism is similar to (Bahdanau et al., 2014), and the third module is an RNN-based decoder to compute the following conditional probability:\nPr (yt | y1, ..., yt−1, X) = g (yt−1, st, ct) (2)\nwhere st is an RNN hidden state at time instant t, ct is the representation of input X at time instant t, and g () is a MLP to output conditional probabilities given yt−1, st, ct. In this model, we use an attention mechanism to compute ct as a weighted sum of all input representations ht, where ht is computed by CNN from the input sentence at time instant t. This attention mmodel works as follows:\nct = Tx∑ i=1 αti hi (3)\nwhere all attention weights αti is computed by\nαti = exp (eti)∑Tx\nk=1 exp (etk) eti = f (st−1, hi)\nwhere f () is a MLP to predict attention weights based on st−1 and hi.\nThe entire model in Figure 3 is jointly learned from all training data to maximize the conditional probability of the corresponding output sequence given each input word sentence. In the test stage, for each input word sentence, the learned model is used to compute all conditional probabilities and the Viterbi algorithm is used to generate the output sequence. Occasionally, we may get some unmatched brackets in the output sequences. In these case, we simply drop the unmatched symbols and derive the nested entities based on the remaining part."
    }, {
      "heading" : "2.3 Model Configurations",
      "text" : "Both conditional RNN-LM and attention-based encoder-decoder use a stack of five 1-dimension convolutional layers as tne encoder to generate the representations for the input word sequences. In all convolutional layers, we set the filter size and the feature maps to 3 and 512 respectively. We do not use any pooling layers but zero-padding is used in each layer. In this way, the length in each convolutional layer does not change and remain the same\nas the input sequence. From it, we may easily retrieve the CNN output ht at every time instant. In place of the 5-layer CNNs, we have also examined to use bidirectional GRUs or LSTMs as encoder, but no gain is observed in our experiments. The computation of 1-dimension convolutional layers is much faster than that of RNNs or LSTMs because of the parallel computation of GPUs. Parameter optimization of all models are performed using AdaDelta (Zeiler, 2012) and early stopping is also used by monitoring a small held-out development set.\nSimilar to all neural networks, the performance of our proposed models relies on the amount of the training data. However, there is not too much matched in-domain training data for the new 2016 KBP mention detection tasks. Therefore, for English and Chinese languages, we have used some inhouse data annotated by iFLYTEK research, which consists of about 10,000 Chinese and English documents downloaded from the web. These documents are internally labelled using some annotation rules similar to the KBP guidelines. For Spanish, we have not found any extra annotated data. Thus, we have trained our Spanish models only using the data from KBP 2015. Because nominal tags are newly introduced to Spanish in KBP 2016, our Spanish models can not predict any nominal tags.\nMoreover, we have tried to use model combination to further improve the performance of entity discovery. For each language, we evenly split all available training data into five parts. For either conditional RNNLM or attention-based encoder-decoder, we have trained 5 different models using only 4 parts of the training data. These models are all randomly initialized. At the end, we use the ensemble of these five models to generate the final entity labels by combining labels scores from these five models.\nFinally, when we use the Viterbi algorithm to generate the output sequence, we implement a beam search for both models, where we only keep at most 10 active paths at any time instant during the Viterbi decoding."
    }, {
      "heading" : "3 Entity Linking",
      "text" : "In the entity linking task, each detected mention needs to be linked to a known entity in an existing knowledge base, namely Freebase in this task.\nFor all mentions that do not match any existing node in Freebase, we need to cluster these NIL mentions. In this work, we adopt a ranking-based method for entity linking. For a given mention, we first use a rather complicated rule-based system to generate all possible Freebase nodes as the linking targets, each of which is called a linking candidate. This stage is called candidate generation. Next, we train a neural network (NN) based ranking model to rank all these candidates to identity the final linking target. In this step, we have proposed to use many handcrafted features for the NN-based ranking model."
    }, {
      "heading" : "3.1 Candidate Generation",
      "text" : "Obviously, the final linking performance heavily relis on the generated candidate list. In this work, we have designed a complicated rule-based system as our candidate generation module to generate candidates for each detected mention. The diagram of the whole candidate generation system is shown in Figure 4. In this module, candidates are generated based on some knowledge bases, including Freebase, Wikipedia. We have chosen to use Lucene and MySQL for search in our implementation. The input to this module is a detected mention, the output from this module is a candidate list, which consists of a list of Freebase nodes possibly matching this mention.\nIn the first step, called query expansion, each mention is first expanded into a number of different queries based on some pre-defined rules. These queries represents different ways to rename the same entities. For example, given a detected mention England, we need to expand it to generate a list of different queries, which may include England, united kingdom, united kingdom of great Britain and norther Ireland and Britain. It is better to generate more queries in this step since it may help to enhance the candidate coverage, but this may significantly slow down the following search and matching steps. We need to have a good compromise here. In this work, we have pre-defined the following rules for the query expansion step:\n1. The underlying mention is added to the query list.\n2. For each mention, we search the original document containing this mention. If we find this\nmention is a sub-string of other longer mentions. All of these longer mentions are added to the query list. For instance, if we have a mention like Bush, and we have found another mention, such as George Bush, from the same document and Bush ⊂ George Bush, then George Bush is added to the query list of Bush.\n3. If a mention is in the form of simplified Chinese, its traditional Chinese version is added to the query list, and vice versa.\n4. If a mention matches any abbreviations in a pre-compiled list, the corresponding full name is added to the query list. For example, if we have a mention like sc, we will add South Carolina to the query list.\n5. If a detected mention is nominal, the nearest named mention is selected to go through the above rules 2, 4 to generate the query list. For example, if a nominal mention is detected as president, its nearest named entity Barack Hussein Obama is selected for query expansion.\n6. If a mention is Chinese or Spanish, we invoke a Google translation API to obtain its English translation. The English translation is used to go through the above rules 2, 4, 5 to expand the query list.\nAfter the query list is ready, we search Freebase nodes and Wikipedia pages to find all possible matches. Since most Wikipedia pages have the corresponding Freebase nodes, we may use these Wikipedia pages as extended context descriptions for the Freebase nodes. We use Lucene and MySQL database to implement search in this step. MySQL is used to store Freebase and Wikipedia to conduct query searches based on the exact case-insensitive matching. To improve the recall of the search results, we also need to do fuzzy search and partial matching. For example, if a query is George Bush, we use the fuzzy search option in Lucene to retrieve the Freebase node labelled as George W. Bush as well. To do this, Lucene indexes are built on Freebase nodes titles and Wikipedia pages, fuzzy search is performed using Lucene. Furthermore, we may directly use the original document containing the underlying mention to search Lucene indexes to gener-\nate more results to further improve the coverage of the candidate list. In our implementation, we first use the expanded queries as input to search Lucene and MySQL to generate the first set of matching results, denoted as Result1. Next, we use the document as input to search Lucene to generate another set of matching results, denoted as Result2. Finally, we add the top N records 1 from Result1 and the intersection of Result1 and Result2 into the list of candidates. As the final step, for every query, if the query exactly matches (case-insensitive) a title of any Wikipedia page according to the redirection or disambiguation information in Wikipedia, then the Freebase nodes corresponding to these Wikipedia pages are also added to the candidate list. In order to process those NIL mentions which can not be linked, a special NIL candidate is always added to the candidate list.\n1In our experiments, the value of N varies for different languages, we set N = 3 for English and Spanish, and N = 30 for Chinese.\nHere, we use two criteria to measure the qualify of candidate generation: the first one is the total number of different candidates generated for each mention in average (called average count), and the second one is how many candiate lists actually contain the true target node (called coverage). In Table 1, we have shown the average count and coverage rate of the candidate lists generated from the above algorithm for three differen languages on the KBP 2015 data set. In general, our method generates about 22- 100 candidates in average for each mention, varying from one language to another, and the average coverage rates range from 88.4% (for Spanish) to 93.0% (for English)."
    }, {
      "heading" : "3.2 Neural Networks Ranking Model",
      "text" : "As described above, we generate a candidate list for each detected mention. This list contains a special NIL candidate and some Freebase node IDs that match with the mention in the candidate generation process. In this work, we have proposed to use a neural network (NN) ranking model to assign probabilities to all candidates in the list. The candidate with the highest probability is chosen as the final linking result. Each time, the NN ranking model takes the mention and a candidate from the list to compute a score. In order to do this, we have designed many handcrafted features for the neural net-\nwork, which we believe play a decisive role to the final linking performance.\nThe input feature vector to the NN ranking model is a concatenation of all the following features:\n1. Mention string embedding (e1): Each word in the detected mention is projected into a 100- dimension word vector. The sum of all word vectors in the mention is used as the first feature vector, denoted as e1.\n2. Candidate name embedding (e2): Each word in the candiate name is also projected into a 100- dimension word vector. The sum of all word vectors in the candidate name is used as another feature vector, denoted as e2.\n3. Mention type (e3): Each mention is represented as a one-hot vector based on the entity type of the detected mention (PER, ORG, GPE, LOC or FAC). This one-hot vector is projected into a 10-dimension dense vector, denoted as e3.\n4. Document category (e4): Each mention is represented as a one-hot vector based on the category of the document containing it (News Report or Discussion Forum). This one-hot vector is projected into another 10-dimension dense vector, denoted as e4.\n5. Candidate’s hot value vector (e5): A hot value is computed for each candiate based on the number of links the corresponding node has in Freebase. This hot value is quantized into 10 discrete values and represented as a 10-D onehot vector. This one-hot vector is projected into a 10-dimension dense vector, denoted as e5.\n6. Edit distance between mention string and candidate name (e6): A simple edit distance between the mention string and the candiate name is computed as the word numbers. For example, the edit distance between George Bush and George W. Bush is 1. The edit distance is quantized and projected into a 10-D vector as above, denoted as e6.\n7. Cosine similarity of document and candidate description (e7): Both the document containing the mention and the extended description\nof the candidate (the corresponding Wikipedia page) are represented as two bag-of-words vectors (normalized by TFIDF). The cosine distance between these two vectors is first computed, and quantized and mapped to a 10-D vector, denoted as e7.\n8. Edit distance between translations of mention and candidate (e8): If the mention or the candidate is Chinese or Spanish, it is translated to English. The edit distance between the English translations of the mention and candidiate is computed, then quantized and projected as e6, denoted as e8.\nFor each detected mention m, the candidate generation module generates a list of K candidates as {c1, · · · , cK}. For each pair of m and ck, we generate all feature vectors as shown in Table 2. These feature vectors are fed into a regular feedforward neural network as shown in Figure 5, to compute a matching score, ek. Furthermore, we use a softmax function to compute a posterior distribution of all candidates in the list as follows:\nPr(ck|m) = exp(ek)∑K k=1 exp(ek) . (4)\nIn this work, we use the EDL2015 training data set, which contains less than 200 labeled documents to train the neural net ranking model for each language. We choose to use 2 hidden layers: the first layer consists of 512 units while the second layer is\ncomposed of 256 units. Each hidden unit use the sigmoid nonlinear activation function. The NN ranking model and all projection matrices in Table 2 are all estimated by maximizing the posterior probabilities in eq.(4) of all training data. We adopt a mini-batch AdaDelta with the mini-batch size of 8. Similar to mention detection, we have also trained 5 different models from different subsets and different random initialization. We have found that an ensemble of five NN ranking yields a small performance gain in the entity linking tasks."
    }, {
      "heading" : "4 NIL Clustering",
      "text" : "For all mentions identified as NIL by the above NN ranking models, we perform a very simple rulebased algorithm to cluster them: i) Different named NIL mentions are grouped into one cluster only if their mention strings are the same (case-insensitive); ii) The nominal NIL mention is always grouped to its nearest named mention with the same mention type. We have investigated other more complex string matching methods for NIL clustering but we have observed no improvement at all."
    }, {
      "heading" : "5 Experimental Results",
      "text" : ""
    }, {
      "heading" : "5.1 Entity Discovery Results",
      "text" : "We have submitted 3 systems to 2016 KBP EDL evaluation. For system 2 and system 3, we use conditional RNN-LM and attention-based encoder-\ndecoder for entity discovery, respectively. We have observed that these models have achieved a quite high precision but relatively low recall rates. As a result, we have submitted another system by merging the results from the systems 2 and 3. This becomes our top-performing system. The official entity discovery performance from the first EDL1 evaluation in 2016 are summarized for these three systems in Table 3."
    }, {
      "heading" : "5.2 Entity Linking Experimental Results",
      "text" : "For 2016 KBP EDL evaluation, we have just developed one entity linking & NIL clustering system as described in Sections 3 and 4. Here we just report the official entity linking results from the best entity discovery system (System 1). The performance (in terms of strong all match) of our system is shown in Table 4 and the performance (in terms of typed mention ceaf plus) is shown in Table 5.\nThe results have shown the English system significantly outperform the other two systems. This can be attributed to that the performance of mention de-\ntection for English is normally better than the other two language because more English data resources are available in Freebase and Wikipedia than Spanish and Chinese."
    }, {
      "heading" : "6 Conclusions",
      "text" : "In this paper, we have described our submitted systems for Trilingual EDL Track of 2016 TAC KBP evaluation. We have investigated several neural network models for both entity discovery and entity linking. For entity discovery tasks, we have used two neural networks in the popular encoderdecoder framework to model long term dependency and nested entities in the KBP tasks. For entity linking, we have proposed some handcrafted features and a simple feedforward neural network ranking model. For the NIL clustering, we have adopted a very simple rule-based string-matching clustering method. In overall, our systems have achieved pretty strong performance in both KBP 2015 data and the official KBP 2016 evaluation.\nWe believe our EDL systems have plenty of room for improvements. For example, we may need to investigate other strategies to detect nominal mentions instead of treating them equally as named entities. Moreover, some coreference resolution strategies may be used to resolve the relations between\nentities within the same document or across different documents."
    } ],
    "references" : [ {
      "title" : "Neural machine translation by jointly learning to align and translate",
      "author" : [ "Kyunghyun Cho", "Yoshua Bengio" ],
      "venue" : "arXiv preprint arXiv:1409.0473",
      "citeRegEx" : "Bahdanau et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Bahdanau et al\\.",
      "year" : 2014
    }, {
      "title" : "On the properties of neural machine translation: Encoderdecoder approaches",
      "author" : [ "Cho et al.2014] Kyunghyun Cho", "Bart Van Merriënboer", "Dzmitry Bahdanau", "Yoshua Bengio" ],
      "venue" : "arXiv preprint arXiv:1409.1259",
      "citeRegEx" : "Cho et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Cho et al\\.",
      "year" : 2014
    }, {
      "title" : "Nested named entity recognition",
      "author" : [ "Finkel", "Manning2009] Jenny Rose Finkel", "Christopher D Manning" ],
      "venue" : "In Proceedings of Conference on Empirical Methods in Natural Language Processing (EMNLP),",
      "citeRegEx" : "Finkel et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Finkel et al\\.",
      "year" : 2009
    }, {
      "title" : "Conditional random fields: Probabilistic models for segmenting and labeling sequence data",
      "author" : [ "Andrew Mccallum", "Fernando C.N. Pereira" ],
      "venue" : "In Proceedings of the 18th International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Lafferty et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Lafferty et al\\.",
      "year" : 2001
    }, {
      "title" : "Recurrent neural network based language model",
      "author" : [ "Martin Karafit", "Lukas Burget", "Jan Cernock", "Sanjeev Khudanpur" ],
      "venue" : "In Proceedings of Interspeech,",
      "citeRegEx" : "Mikolov et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Mikolov et al\\.",
      "year" : 2010
    }, {
      "title" : "Grammar as a foreign language",
      "author" : [ "Łukasz Kaiser", "Terry Koo", "Slav Petrov", "Ilya Sutskever", "Geoffrey Hinton" ],
      "venue" : "In Proceedings of Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Vinyals et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Vinyals et al\\.",
      "year" : 2015
    }, {
      "title" : "Adadelta: an adaptive learning rate method",
      "author" : [ "Matthew D Zeiler" ],
      "venue" : "arXiv preprint arXiv:1212.5701",
      "citeRegEx" : "Zeiler.,? \\Q2012\\E",
      "shortCiteRegEx" : "Zeiler.",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : "Conditional random fields (CRFs) (Lafferty et al., 2001) is a widely-used method for sequence labeling.",
      "startOffset" : 33,
      "endOffset" : 56
    }, {
      "referenceID" : 4,
      "context" : "(1), this modeling approach is quite similar to language models based on recurrent neural networks (RNN) in (Mikolov et al., 2010) except that each factorized probability depends on the entire input sequence X .",
      "startOffset" : 108,
      "endOffset" : 130
    }, {
      "referenceID" : 1,
      "context" : "For simplicity, we use one layer of gated recurrent units (GRU) (Cho et al., 2014), which essentially computes all factorized probabilities in eq.",
      "startOffset" : 64,
      "endOffset" : 82
    }, {
      "referenceID" : 5,
      "context" : "Furthermore, inspired by the idea in (Vinyals et al., 2015), we may easily linearize a tree structure into a linear sequence representation.",
      "startOffset" : 37,
      "endOffset" : 59
    }, {
      "referenceID" : 5,
      "context" : "Following the same idea in (Vinyals et al., 2015), the tree-structured representation for this nested entity may be represented as a linear sequence:",
      "startOffset" : 27,
      "endOffset" : 49
    }, {
      "referenceID" : 0,
      "context" : "of input sequence X , and the attention mechanism is similar to (Bahdanau et al., 2014), and the third module is an RNN-based decoder to compute the following conditional probability:",
      "startOffset" : 64,
      "endOffset" : 87
    }, {
      "referenceID" : 6,
      "context" : "Parameter optimization of all models are performed using AdaDelta (Zeiler, 2012) and early stopping is also used by monitoring a small held-out development set.",
      "startOffset" : 66,
      "endOffset" : 80
    } ],
    "year" : 2016,
    "abstractText" : "This paper describes the USTC NELSLIP systems submitted to the Trilingual Entity Detection and Linking (EDL) track in 2016 TAC Knowledge Base Population (KBP) contests. We have built two systems for entity discovery and mention detection (MD): one uses the conditional RNNLM and the other one uses the attention-based encoder-decoder framework. The entity linking (EL) system consists of two modules: a rule based candidate generation and a neural networks probability ranking model. Moreover, some simple string matching rules are used for NIL clustering. At the end, our best system has achieved an F1 score of 0.624 in the end-to-end typed mention ceaf plus metric.",
    "creator" : "LaTeX with hyperref package"
  }
}