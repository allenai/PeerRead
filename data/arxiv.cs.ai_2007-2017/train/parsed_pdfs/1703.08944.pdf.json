{
  "name" : "1703.08944.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Intelligent bidirectional rapidly-exploring random trees for optimal motion planning in complex cluttered environments",
    "authors" : [ "Ahmed Hussain Qureshi", "Yasar Ayaz" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "The sampling based motion planning algorithm known as Rapidly-exploring Random Trees (RRT) has gained the attention of many researchers due to their computational efficiency and effectiveness. Recently, a variant of RRT called RRT* has been proposed that ensures asymptotic optimality. Subsequently its bidirectional version has also been introduced in the literature known as Bidirectional-RRT* (B-RRT*). We introduce a new variant called Intelligent Bidirectional-RRT* (IB-RRT*) which is an improved variant of the optimal RRT* and bidirectional version of RRT* (B-RRT*) algorithms and is specially designed for complex cluttered environments. IB-RRT* utilizes the bidirectional trees approach and introduces intelligent sample insertion heuristic for fast convergence to the optimal path solution using uniform sampling heuristics. The proposed algorithm is evaluated theoretically and experimental\n∗This is the authors’ version of the paper published in Elsevier Robotics and Autonomous Systems Journal. The source code of this paper is available at: github.com/ahq1993.\nresults are presented that compares IB-RRT* with RRT* and B-RRT*. Moreover, experimental results demonstrate the superior efficiency of IB-RRT* in comparison with RRT* and B-RRT in complex cluttered environments."
    }, {
      "heading" : "1 Introduction",
      "text" : "Motion planning is a well-known problem in robotics [24]. It can be defined as the process of finding a collision-free path for a robot from its initial to goal point while avoiding collisions with any static obstacles or other agents present in its environment. Although motion planning is not the only fundamental problem of robotics, perhaps it has gained popularity among researchers due to widespread applications such as in robotics [21], assembly maintenance [3], computer animation [7], computer-aided surgery [9], manufacturing [22], and many other aspects of daily life.\nThe journey of finding solution to motion planning problems started with complete planning algorithms\nar X\niv :1\n70 3.\n08 94\n4v 1\nthat comprised of deterministic path planning approach. Complete motion planning algorithms [35] [28] are those algorithms that converges to a path solution, if one exists, in finite time. These algorithms are proven to be computationally inefficient [2] in most of the practical motion planning problems [13]. Resolution complete algorithms were then introduced that require fine tuning of resolution parameters for providing the motion planning solution, if one exists, in a finite time period. Artificial Potential Fields (APF) [16] is a well-known resolution complete algorithm. However, APF suffers from the problem of local minima [18] and does not performed well in the environment with narrow passages. Hence, the search for an efficient solution to the problem continued and the idea of exact roadmaps was introduced in the literature which relies on the discretization of the given search space. This discretization of search space makes the algorithm computationally expensive for higher dimensional spaces, that is why the application of such algorithms like Cell Decomposition methods [19] [1], Delaunay Triangulations [10] and Dynamic Graph Search methods [4] [25] are limited to low dimensional spaces only [5]. Moreover the algorithms that combine the set of allowed motions with the graph search methods thus generating state lattices, such as in [8] [31] [30], also suffered from the undesirable effects of discretization. Hence to solve the higher dimensional planning problems, the sampling-based algorithms were introduced [5]; the main advantage of sampling-based algorithms as compared to other state-of-the-art algorithms is avoidance of explicit construction of obstacle configuration space. These algorithms ensure probabilistic completeness which implies that as the number of iterations increases to infinity, the probability of finding a solution, if one exists, approaches one. The sampling-based algorithms have proven to be computationally efficient [2] solution to motion planning problems. Arguably, the most well-known samplingbased algorithms include Probabilistic Road Maps (PRM) [14] [15] and Rapidly exploring Random Trees (RRT) [23]. However, PRMs tend to be inefficient when obstacle geometry is not known beforehand [13]. Therefore, in order to derive efficient solutions for motion planning in the practical world, the Rapidly-exploring Random Trees (RRT) algorithms [23] have been extensively explored. Various algorithms enhancing original RRT algorithm have been proposed [26], [6], [20], [13]. These algorithms present a solution regardless of whether specific geometry of the obstacles is known beforehand or not. One of the most remarkable variant of RRT algorithm is RRT*, an algorithm which guarantees eventual convergence to an optimal path solution [13], unlike the original RRT algorithm. Just like the RRT algorithm, RRT* is able to generate an initial path towards the goal very quickly. It then continues to refine this initial path in successive iterations, eventually returning an optimal or near optimal path towards the goal as the number of iterations approach infinity [12]. This additional guarantee of optimality makes the RRT* algorithm very useful for real-time applications [29]. However, some major constraints still exist in this RRT variant which are presented in this paper. For example: (i) its slow convergence rate in achieving the optimal solution; (ii) its significantly large memory requirements due to the large number of iterations utilized to calculate the optimal path; and (iii) its rejection of samples which may not be directly connectable with the existing nodes in the tree, but may lie closer to the goal region and hence could aid the algorithm in determining an optimal path much faster. Various heuristics have been introduced, such as [32] [33] [34] [17], which perform guided search of the given space instead of pure uniform search (as by RRT and RRT*). Although these biased sampling heuristics make the original RRT* algorithm fast but there is a drawback of computational overload caused by biased sampling. This computational overload limits their application to a limited number of fields [27]. Moreover another disadvantage of deterministic sampling heuristics is that they may interfere with the algorithm characteristics. For example assume a simple case of using goal-biased sampling [33] with bidirectional RRT that alternatively grows two trees. The use of this biased sampling will cause the two trees to always remain in one half of the search space, which is quite undesirable. Hence, to cover\nthe whole search space, a separate sample generator is required for both trees which will cost a significant computational load. Hence there is a need of some better approach that enhances the convergence rate of RRT* for achieving the optimal path solution without affecting the randomization of its sampling heuristic. More recent proposition is the bidirectional version of RRT* known as B-RRT* [11]. B-RRT* presented in [11] is a simple bidirectional implementation of RRT*. B-RRT* uses a slight variation of greedy RRT-Connect heuristic [20] for the connection of two trees. Two directional trees employing greedy connect heuristic for the connection of trees does not ensure asymptotic optimality [11]. The B-RRT* uses slight variation of greedy heuristic i.e., the tree under process first searches for the neighbor vertices before making an attempt to connect the trees using RRT-Connect heuristic [20]. This hybrid greedy connection heuristic of B-RRT* slows down its ability to converge to the optimal solution and also makes it computationally expensive. More detailed discussion is provided in the analysis section. This paper introduces a bidirectional variation to the RRT* algorithm, with unique sample insertion and tree connection heuristics that allows fast convergence to the optimal path solution. The proposed Intelligent Bidirectional-RRT* (IB-RRT*) algorithm has been tested for its robustness in both 2-D and 3-D environments and has also been compared with other state-of-art algorithms such as BidirectionalRRT*[11] and RRT* itself [12]. The rest of the paper is organized as follows. Section 2 addresses the problem definition, Section 3 explains the RRT* algorithm while Section 4 describes the B-RRT* motion planning algorithm in detail. Section 5 presents the proposed Intelligent Bidirectional-RRT* (IB-RRT*). Section 6 presents analysis of the three algorithms under investigation in terms of probabilistic completeness, asymptotic optimality, convergence to the optimal solution and computational complexity. Section 7 provides experimental evidence in support of theoretical results presented in the previous section, whereas Section 8 concludes the paper, also suggesting some future areas of research in this particular domain."
    }, {
      "heading" : "2 Problem Definition",
      "text" : "Let the given state space be denoted by a set X ⊂ Rn, where n represents the dimension of the given space i.e., n ∈ N, n ≥ 2. The configuration space is further classified into obstacle and obstacle-free regions denoted by Xobs ⊂ X and Xfree = X\\Xobs, respectively. Xgoal ⊂ Xfree is the goal region. Let Ta = (Va, Ea) ⊂ Xfree and Tb = (Vb, Eb) ⊂ Xfree represent two growing random trees, where V denotes the nodes and E denotes the edges connecting these nodes. xainit ∈ Xfree and xbinit ∈ Xgoal represent the starting states for Ta and Tb. The function µ() computes the Lebesgue measure of any given state space e.g. µ(X) denotes the Lebesgue measure of the whole state space X. It is also called the n-dimensional volume of any given configuration. This paper only considers Euclidean space and positive Euclidean distance between any two states e.g., x1 ∈ X and x2 ∈ X is denoted by d(x1, x2). The closed ball region of radius r ∈ R, r > 0 centered at x is denoted as Bx,r := {x2 ∈ X : d(x, x2) ≤ r}, where x ∈ X can be any given configuration state. Let the path connecting any two states x1 ∈ Xfree and x2 ∈ Xfree be denoted by σ : [0, s′], such that σ(0) = x1 and σ(s\n′) = x2, whereas, s′ is the positive scalar length of the path. The set of all collision-free paths σ is denoted as ∑ free. Given any random state x ∈ Xfree, the path function connecting initial state xinit and random state x is denoted as σ ′ a[0, sa] ⊂ Xfree|{σ′a(0) = xinit and σ′a(sa) = x}, while the path function connecting random state x and goal region Xgoal is denoted as σ ′ b[0, sb] ⊂ Xfree|{σ′b(0) = x and σ′b(sb) ∈ Xgoal}. The complete, end-to-end path function i.e., the path function from root to the goal is denoted by σ′f(s) = σ ′ a|σ′b : [0, s] ∈ X, where s represents the scalar length of the end-to-end path. The expression σ′a|σ′b ∈ X describes the concatenation of the two path functions, σ′a and σ ′ b. The path function σf is the end-to-end feasible path in obstacle-free configuration space, i.e., σf ∈ Xfree. The set of all end-to-end collision-free paths is denoted as ∑ f i.e.,\nσf ∈ ∑\nf . The cost function c(·) computes the cost in terms of Euclidean distance. The following motion planning problems will be considered in the proposed algorithm:\nProblem 1 (Feasible path solution) Find a path σf : [0, s], if one exists, in obstacle-free space Xfree ⊂ X such that σf(0) = xinit ∈ Xfree and σf(s) ∈ Xgoal. If no such path exists, report failure.\nProblem 2 (Optimal path solution) Find an optimal path σ∗f : [0, s] connecting xinit and Xgoal in obstacle-free space Xfree ⊂ X, such that the cost of the path σ∗f is minimum, i.e., c(σ ∗ f ) = {minσsc(σf) :\nσf ∈ ∑\nf}. Problem 3 (Convergence to Optimal Solution) Find the optimal path σ∗f : [0, s] in obstacle-free space Xfree ⊂ X in the least possible time t ∈ R."
    }, {
      "heading" : "3 RRT* Algorithm",
      "text" : "This section describes the RRT* algorithm [12]. Algorithm 1 is a slightly modified implementation of RRT*. In this version, improvements were made to the original algorithm in order to enhance the computational efficiency of RRT* by reducing the number of calls to the ObstacleFree procedure [29]. Following are some of the processes employed by RRT*:\nAlgorithm 1: RRT*(xinit)\n1 V ← {xinit};E ← ∅;T ← (V,E); 2 for i← 0 to N do 3 xrand ← Sample(i) 4 Xnear ← NearVertices(xrand, T ) 5 if Xnear = ∅ then 6 Xnear ← NearestVertex(xrand, T ) 7 Ls ← GetSortedList(xrand, Xnear) 8 xmin ← ChooseBestParent(Ls) 9 if xmin 6= ∅ then 10 T ← InsertVertex(xrand, xmin, T ) 11 T ← RewireVertices(xrand, Ls, E)\n12 return T = (V,E)\nRandom Sampling: the Sample procedure returns an independent and uniformly distributed random sample from the obstacle free space, i.e., xrand ∈ Xfree.\nCollision Check: the procedure ObstracleFree(σ) checks whether the given path σ : [0, 1] belongs to\nAlgorithm 2: GetSortedList(xrand, Xnear)\n1 Ls ← ∅ 2 for x′ ∈ Xnear do 3 σ′ ← Steer(x′, xrand) 4 C ′ ← c(xinit, x′) + c(x′, xrand) 5 Ls ← (x′, C ′, σ′) 6 Ls ← SortList(Ls) 7 return Ls\nXfree or not. A true value is reported if σ(s) ∈ Xfree∀s[0, 1].\nNear Vertices: given a sample x ∈ X, the tree T = (V,E) and the ball region Bx,r of radius r centered at x, the set of near vertices is defined as:\nNear(x, T, r) := {v ∈ V : v ∈ Bx,r} 7→ Xnear ⊆ V . More specifically, Xnear = {v ∈ V : d(x, v) ≤ γ(logi/i)1/n} where i is the number of vertices, n represents the dimensions and γ is a constant.\nNearest Vertex: As its name suggests, this procedure returns the nearest vertex in the tree from any given state x ∈ X. Given the tree T = (V,E), the nearest vertex procedure can be defined as:\nNearest(T, x) := argminv∈V d(x, v) 7→ xmin. Getting Sorted List: the procedure GetSortedList in Algorithm 2 constructs a tuple and returns it as the list Ls. Each element of this list is a triplet of form (x′, c(σ), σ′) ∈ Ls where x′ ∈ Xnear. The list Ls is sorted in the ascending value of the cost function.\nSteering: the steering function utilised in this modified version of RRT* takes two states as an input and returns the straight trajectory connecting those two states. For example, for two given states x1 ∈ X and x2 ∈ X, the path σ : [0, 1] will be the path connecting these two states, i.e., σ(0) = x1 and σ(1) = x2. The steering is done from x1 to x2 in small, discrete steps and can be summarized as σ(s′) = (1− s′)x1 + s′x2;∀s′[0, 1].\nChoosing Best Parent: this procedure is used to search the list Ls for a state, xmin ∈ Ls which provides the shortest, collision-free path σ′ from the initial state xinit to the random sample xrand. Alternatively, σ′ is the shortest collision-free path connecting the initial state xinit and the random sample xrand via\nxmin ∈ Ls. Algorithm 3 outlines the implementation of this procedure.\nAlgorithm 3: ChooseBestParent(Ls)\n1 for (x′, C ′, σ′) ∈ Ls do 2 if ObstacleFree(σ′) then 3 return x′"
    }, {
      "heading" : "4 return ∅",
      "text" : "Algorithm 4: RewireVertices(xrand, Ls, E)\n1 for (x′, C ′, σ′) ∈ Ls do 2 if ( c(xinit, xrand) + c(xrand, x ′) ) < c(xinit, x\n′) then\n3 if ObstacleFree(σnew) then 4 xparent ← Parent(E, x′) 5 E ← (E\\{(xparent, x′)})∪ ({xrand, x′})"
    }, {
      "heading" : "6 return E",
      "text" : "The RRT* algorithm provides asymptotic optimality. In reference to Algorithm 1, the RRT* algorithm after preliminary initialization process starts its iterative process by sampling the random sample xrand from the given configuration space Xfree (Line 3). After this, the RRT* finds the set of near vertices Xnear from the tree lying inside the ball region centered at xrand. If the set of near vertices Xnear computed by NearVertices procedure is empty, then the set Xnear is filled by the NearestVertex procedure (Line 4-6). The populated set Xnear is then sorted by the GetSortedList procedure to form a list of form (x′, c(σ), σ′), arranged in ascending order of cost function c(σ) (Line 7). The procedure ChooseBestParent iterates over the sorted list Ls (Line 8), returning the best parent vertex xmin ∈ Xnear through which xinit and xrand can be connected in obstacle-free space. Once such a state is located, i.e, the best parent vertex xmin is no longer empty, xmin is inserted into the tree by making xrand its child and then the rewiring step is executed (Line 9-11). Algorithm 4 presents the pseudocode of the rewiring process. Here, the algorithm examines each vertex\nx′ ∈ Xnear lying inside the ball region centered at xrand. If the cost of the path connecting xinit and x ′ through xrand is less than the existing cost of reaching x′ and if this path lies in obstacle-free space Xfree (Algorithm 4 Line 1-3), then xrand is made the parent of x′ (Algorithm 4 Line 4-5). If these conditions do not hold true, no change is made to the tree and the algorithm moves on to check the next vertex. This process is iteratively performed for every vertex x′ present in the sorted list Ls.\nAlgorithm 5: B-RRT*(xinit,xgoal)\n1 V ← {xinit, xgoal};E ← ∅; Ta ← (xinit, E);Tb ← (xgoal, E); 2 σbest ←∞ 3 for i← 0 to N do 4 xrand ← Sample(i) 5 xnearest ← NearestVertex(xrand, Ta) 6 xnew ← Extend(xnearest, xrand) 7 Xnear ← NearVertices(xnew, Ta) 8 Ls ← GetSortedList(xnew, Xnear) 9 xmin ← ChooseBestParent(Ls)\n10 if xmin 6= ∅ then 11 T ← InsertVertex(xnew, xmin, Ta) 12 T ← RewireVertices(xnew, Ls, E) 13 xconn ← NearestVertex(xnew, Tb) 14 σnew ← Connect(xnew, xconn, Tb) 15 if σnew 6= ∅&&c(σnew) < c(σbest) then 16 σbest ← σnew 17 SwapTrees(Ta, Tb)\n18 return Ta, Tb = (V,E)"
    }, {
      "heading" : "4 B-RRT* algorithm",
      "text" : "This section explains the implementation of Bidirectional-RRT*(B-RRT*) [11]. Algorithm 5 outlines the implementation of B-RRT*; extra procedures employed by B-RRT* are explained below while the rest are exactly the same as they were for RRT*.\nExtend: given two nodes x1, x2 ∈ X, the\nExtend(x1, x2) procedure returns a new node xnew ∈ Rn such that xnew is more closer to x2 than x1 in the direction from x1 to x2.\nConnect: connect heuristic employed by BRRT* is slight variation of greedy RRT-Connect heuristic[20]. Algorithm 6 outlines the implementation of Connect heuristic of B-RRT*. Typical RRT* iteration is performed on the input nodes x1, x2, where x1 plays the role of xrand while the set of near vertices is computed from the other tree (Line 1-2). After computing a set of near vertices from tree b, the procedure GetSortedList (explained in previous section) is executed, and the best vertex is selected from the sorted list such that it provides collision-free low-cost connection between the trees Ta, Tb. Finally, this procedure ends by generating and returning the end-to-end feasible path solution, connecting xinit and Xgoal.\nIn reference to Algorithm 5, the B-RRT* works in exactly the same manner as the original RRT* algorithm in its initial phases i.e., it starts with sampling of the configuration space Xfree, then various operations (just like RRT*) are performed on this random sample xrand (Line 4-12 ). After successful insertion of random sample into the tree under operation (Line 11-12), the algorithm computes nearest vertex xconn from xnew in the tree Tb, and then executes the connect procedure for the connection of two trees (Line 13-14). If the attempt to make connection is successful, the collision-free path σnew connecting xinit and Xgoal is returned by the connect function. The cost of this σnew is then compared with the previously computed path σbest. If the cost of σnew is less than the cost of σbest, then σbest is overwritten by σnew (Line 15-16). Finally, the iteration ends by swapping the trees (Line 17) and in the next iteration the same procedure is executed on the other tree."
    }, {
      "heading" : "5 IB-RRT* algorithm",
      "text" : "This section presents our proposed IB-RRT* algorithm1. IB-RRT* is specifically designed for motion\n1The source code is available at :github.com/ahq1993\nAlgorithm 6: Connect(x1,x2,Tb) 1 xnew ← Extend(x2, x1) 2 Xnear ← NearVertices(xnew, Tb) 3 Ls ← GetSortedList(x1, Xnear) 4 xmin ← ChooseBestParent(Ls) 5 if xmin 6= ∅ then 6 E ← E ∪ ((xmin, x1)) 7 σf ← GeneratePath(xmin, x1) 8 return σf\n9 return NULL\nAlgorithm 7: IB-RRT* (xainit, x b init)\n1 Va ← {xainit};Ea ← ∅;Ta ← (Va, Ea) 2 Vb ← {xbinit};Eb ← ∅;Tb ← (Vb, Eb) 3 σf ←∞;E ← ∅ 4 Connection← True 5 for i← 0 to N do 6 xrand ← Sample(i) 7 {Xanear, Xbnear} ← NearVertices(xrand, Ta, Tb) 8 if Xanear = ∅ & & Xbnear = ∅ then 9 {Xanear, Xbnear} ←\nNearestVertex(xrand, Ta, Tb) 10 Connection← False 11 Las ← GetSortedList(xrand, Xanear) 12 Lbs ← GetSortedList(xrand, Xbnear) 13 {xmin,flag, σf} ←\nGetBestTreeParent(Las , L b s ,Connection)\n14 if (flag) then 15 Ta ← InsertVertex(xrand, xmin, Ta) 16 Ta ← RewireVertices(xrand, Ls, Ea) 17 else 18 Tb ← InsertVertex(xrand, xmin, Tb) 19 Tb ← RewireVertices(xrand, Ls, Eb)\n20 E ← Ea ∪ Eb 21 V ← Va ∪ Vb 22 return ({Ta, Tb} = V,E)\nplanning in complex cluttered environments where exploration of configuration space is difficult. Let the sets of near vertices from tree Ta and Tb be denoted by Xanear and X b near, respectively. The path connecting xainit and xrand is denoted by σ ′ a : [0, sa], while the path connecting xbinit and xrand is denoted by σ′b : [0, sb]. Algorithm 7 outlines the implementation of IB-RRT*. In Algorithm 7, the boolean variable Connection represents the feasibility of connecting the two trees while the boolean variable flag indicates the best selected tree. IB-RRT* builds the bidirectional trees incrementally. It starts by picking a random sample xrand from the obstaclefree configuration space Xfree i.e., xrand ∈ Xfree (Line 6). It then populates the set of near vertices Xanear, X b near for both trees using the NearVertices procedure (Line 7). It should be noted that a ball region centered at xrand of radius r is formed and the sets of the near vertices from both trees are computed i.e., Xanear := {v ∈ Va : v ∈ Bxrand,r} and Xbnear := {v ∈ Vb : v ∈ Bxrand,r}, as shown\nin figure 1(a). Xanear and X b near now contain near vertices of xrand from trees Ta and Tb, respectively. In case of both sets of near vertices being found empty, these sets are filled with the closest vertex from their respective trees instead, i.e, the vertex on their respective tree which lies closest to the random sample(Line 8-9). Both sets are then sorted by the GetSortedList procedure (Line 11-12) outlined in Algorithm 2. Once the list is in ascending order, the random vertex xrand is inserted in the best selected tree (Line 13-19). The procedure BestSelectedTree (explained later in this section) returns the nearest vertex on best selected tree which is eligible to become parent of the random sample. Additional features included in IB-RRT* are explained below. The rest of the procedures employed by our algorithm are the same as those outlined in the previous section.\nSelecting Best Tree Parent: the operation GetBestTreeParent replaces the ChooseBestParent\nprocedure of the RRT* algorithm. The implementation of this procedure is outlined in Algorithm 8. Initially the best parent vertex from both the trees is calculated, as shown in figure 1(b). This process (Line 2-9) is similar to ChooseBestParent procedure outlined in algorithm 3. The best selected triplets from each tree Ta and Tb are assigned to {xamin, Camin, σa} ∈ Las and {xbmin, Cbmin, σb} ∈ Lbs respectively. Following this, the GetBestTreeParent procedure selects the best tree from amongst Ta and Tb on the basis of costs C a min and C b min associated with each best selected triplet. The best selected vertex of the best selected tree, i.e. either xamin or xbmin, is then assigned to xmin for the insertion process. For the scenario depicted in Figure 1, tree Ta is selected as the best tree and therefore x a min is assigned to xmin as shown in the figure 1c. The boolean variable flag indicates which tree has been selected as the best tree for any single iteration (Line 10-14). The algorithm then attempts to connect the bidirectional trees (Line 15) on the basis of the boolean variable connection. This is explained further on in the paper. The GetBestTreeParent procedure concludes by returning the best vertex xmin, the boolean flag and, if it exists, the final path σf connecting the initial state to the goal region.\nBidirectional Trees Connection: Algorithm 9 gives the pseudocode of the procedure ConnectTrees. Given collision-free paths σa : [0, sa] and σb : [0,b], where σa(0) = x a init, σb(0) = x b init and σa(sa) = σb(sb) = xrand. This procedure updates the end-to-end collision-free path σf : [0, s] connecting σf(0) = x a init and σf(s) = x b init if the cost of concatenated paths, c(σa|σb), is found to be less than the cost of the existing end-to-end path c(σf) (Line 1-2). Connection between the trees is only successful if the boolean variable connection is true. As mentioned in previous explanation, the occurrence of empty sets for both Xanear and X b near causes the procedure NearestVertex to be called (Algorithm 7, Line 7-8). The NearestVertex changes the boolean variable connection to false. Therefore, the boolean connection is true only when the procedure NearVertices populates both sets. This implies that the two trees are connected if ball of region centered\nat xrand contains near vertices from both trees Ta and Tb. Hence, unlike the connect heuristic [20], the IBRRT* is not greedy since the connection is only made inside the ball region as shown in the figure 1(d). Finally the tree connection generates end-to-end global path, as shown in figure 1(e).\nAlgorithm 8: GetBestTreeParent(Las , L b s ,Connection)\n1 flag← True 2 for (x′a, C ′ a, σ ′ a) ∈ Las do 3 if ObstacleFree(σ′a) then 4 {xamin, Camin, σa} ← {x′a, C ′a, σ′a} 5 Break\n6 for (x′b, C ′ b, σ ′ b) ∈ Lbs do 7 if ObstacleFree(σ′b) then 8 {xbmin, Cbmin, σb} ← {x′b, C ′b, σ′b} 9 Break\n10 if (Camin ≤ Cbmin) then 11 xmin ← xamin 12 else if (Cbmin < C a min) then 13 xmin ← xbmin 14 flag← False 15 if Connection then 16 σf ← ConnectTrees(σa, σb) 17 return {xmin,flag, σf}\nAlgorithm 9: ConnectTrees(σa, σb)\n1 if c(σf) < c(σa|σb) then 2 σf ← σa|σb"
    }, {
      "heading" : "3 return σf",
      "text" : ""
    }, {
      "heading" : "6 Analysis",
      "text" : ""
    }, {
      "heading" : "6.1 Probabilistic Completeness",
      "text" : "In any configuration space, an algorithm is said to be Probabilistically Complete if the probability of finding a path solution, if ones exist, approaches one as the number of samples taken from the configuration\nspace reaches infinity. It is known that RRT is a probabilistically complete algorithm, as its optimal variant RRT* [13]. Since our proposed IB-RRT* algorithm performs the random sampling function exactly like the aforementioned algorithms and is merely a bidirectional version of RRT* with intelligent sample insertion, it can be reasonably proffered that it also inherits the probabilistic completeness property of RRT*."
    }, {
      "heading" : "6.2 Asymptotic Optimality",
      "text" : "It is known that RRT and its variant RRT-Connect do not ensure optimality even if the number of iterations are increased to infinity [13]. However, RRT* is an optimal variant of RRT, ensuring almost-sure convergence to an optimal solution [12]. As explained earlier, IB-RRT* attempts to connect both trees, Ta = (Va, Ea) and Tb = (Vb, Eb), in every iteration. A random sample xrand is used as a point of connection between the two trees (shown in figure 1(d)) if the ball region centered at xrand is found to contain near vertices from both the trees, i.e., va ∈ Va : va ∈ Bxrand,r and vb ∈ Vb : vb ∈ Bxrand,r. A similar procedure is employed by the RRT* algorithm [12] to connect the random sample with its chosen parent. Since there is no extra connection heuristic required for connection of the two trees and the two trees are generated exactly as the tree generated in the original RRT* algorithm, it can be reasonably proposed that the IB-RRT* algorithm inherits the asymptotic optimality property of RRT*."
    }, {
      "heading" : "6.3 Rapid Convergence to Optimal Path",
      "text" : "This section provides proof of IB-RRT*’s rapid convergence to the optimal solution and that this algorithm provides faster convergence rates as compared to state of the art algorithms RRT* and B-RRT*. For simplicity, the following assumptions are are made:\nAssumption 1 (Uniform Sampling) The sampling operation take samples from a configuration space X such that the samples are continuously distributed.\nAssumption 2 (Cluttered Configuration Space) The configuration space X is cluttered such that the tree initially grows near its initial state xinit and then incrementally grows towards the unsearched configuration space.\nAssumption 3 (Uniformity and Additivity of Cost Function) For a given set of path functions, the cost function must satisfy: c(σ1) ≤ c(σ1|σ2) : c(σ1|σ2) = c(σ1) + c(σ2)∀σ1, σ2 ∈ ∑ free.\nAssumption 1 ensures that the sampling operation is not biased or goal directed. Biasing the samples for rapid convergence to the optimal solution is computationally inefficient, specifically in higher dimension configuration spaces [13]. Assumption 2 states that the environment contains obstacles that hinder the expansion of the two trees in the configuration space. Finally, Assumption 3 simply asserts that the longer path has a higher cost than the shorter one. As mentioned in section II, ∑ free denote the set of all collision free paths in the tree T = (V,E). Let σi, σ ′ i ∈ ∑ free such that σ ′ i is closest to σi in terms of Euclidean distance function. The following Lemma states that any sampling-based algorithm can provide almost-sure convergence to the optimal path solution if distance variation ‖σ′i − σi‖ approaches zero as the number of iterations approaches infinity.\nLemma 1 ([13]) A sampling-based algorithm ensures asymptotic optimality, such that\nP(limi→∞ ‖σ′i − σi‖ = 0;∀σi, σ′i ∈ ∑\nfree) = 1.\nWith lemma 1 following corollary immediate.\nCorollary 1 By increasing the number of path variations minimized per iteration, the algorithm can greatly improve its rate of convergence to an optimal solution.\nGiven a tree T = (V,E), random configuration state x ∈ Xfree and a set of near vertices Xnear inside a ball region Bx,r centered at x, the intensity of near vertices around x, denoted by Jx, can be defined as:\nJx := {card(Xnear)/µ(Bx,r) : Xnear|x = Bx,r∩V }.\nRegarding the intensity of near vertices Lemma 2 is stated as follows:\nLemma 2 If Assumptions 1,2,3 hold, then Intensity Jx is higher in the regions closer to the point of generation of the tree.\nSketch of Proof: Let ∈ R+. Xfree is obstaclefree configuration space. Xfree is searched for the set of near neighbors Xnear that lie inside a ball region Bx,r of radius r > 0 centered at the random state x ∈ Xfree. Any state x′ ∈ Xnear can become the parent of xrand, if it provides a lower cost path connecting xrand to xinit than the one provided by all other vertices in Xnear. This implies that ‖x − x′‖ = , where < r = γ(logi/i)1/n. This ensures that the growth of the algorithm presented in this paper is incremental as the tree grows in small incremental distances . For the incremental or wavefront expansion of the trees it is proven that the regions near the point of generation of trees are more dense [23]. Therefore, there is a high probability of having high cardinality of set Xnear, if the random state lies closer to the point of generation of tree.\nHence, with corollary 1 and Lemma 2 holds the following theorem stating effectiveness of IB-RRT* is given below.\nTheorem 1 IB-RRT* algorithm converges to optimal solution more quickly as compared to RRT* and B-RRT*.\nSketch of Proof: Given a random configuration xrand and minimum cost path functions σa[0, sa] := {σa(0) = xainit, σa(sa) = xrand} and σb[0, sb] := {σb(0) = xbinit, σb(sb) = xrand}, then insertion process of IB-RRT* can be summarized as {xrand ∈ Va : c(σa) ≤ c(σb) otherwise xrand ∈ Vb : c(σb) < c(σa)} (Algorithm 8). As the random sample xrand is always inserted into the tree whose initial state is closer to xrand, this ensures that the sample is inserted into a region in the configuration space where the intensity of near vertices Jx is high. Since the rewiring pro-\ncess explained earlier tries to minimize the distance variation ‖σ′i − σi‖ between any two closest paths in each tree. This is done by checking viability of the random sample xrand as the parent of each vertex in the set Xnear. If the cost to reach a particular vertex x′ in the near set Xnear through random sample xrand is lower then the existing cost, then xrand becomes the parent of that particular vertex x′ ∈ Xnear. Hence, IB-RRT* inserts the sample into high intensity regions Jx, maximizing the rewiring process per iteration. This step allows rapid convergence to optimal solution and serves as evidence that IB-RRT* provides better convergence rates than both RRT* and B-RRT* algorithms. Furthermore, trees connection heuristic employed by B-RRT* [11] is partially greedy, similar to the the connect heuristic [20]. It has already been proved that if the bidirectional version of RRT* uses purely RRT-Connect heuristic [20] for the connection of two trees, it is no longer asymptotically optimal [11]. This happens because when only the connect heuristic [20] is used, an edge originating from Ta for example, tries to reach the closest vertex on Tb. This implies that near vertices present inside the ball region are never considered for best parent selection. B-RRT* does eventually converge to an optimal solution but the convergence process is slowed down due to its partially greedy characteristic. Nevertheless, compared to RRT*, the B-RRT* has faster convergence rate due to its generation of two trees. However, in comparison to IB-RRT*, it has significantly less convergence rate. This is later on evident from the experimental results as well."
    }, {
      "heading" : "6.4 Computational Complexity",
      "text" : "This section compares computational complexities of IB-RRT* with complexities of RRT* and the bidirectional version of RRT. Let SRRT ∗ i and S BiRRT i denotes the number of processes executed per iteration by RRT* and bidirectional-RRT (BiRRT), respectively. Let SOursi denote the number of processes executed by IB-RRT*. Theorem 2 and 3 propose that the running time of all processes executed per iteration by IB-RRT* is a constant times higher than both RRT* and BiRRT.\nTheorem 2 The computational ratio of IB-RRT* and RRT* is such that there exists a constant φ1 i.e.,\nlimi→∞ E [ SOursi SRRT\n∗ i\n] ≤ φ1.\nTheorem 3 The computational ratio of IB-RRT* and BiRRT is such that there exists a constant φ2 i.e.,\nlimi→∞ E [ SOursi SBiRRTi ] ≤ φ2. Similar to RRT*, our proposed algorithm calls the procedures Sample and RewireVertices exactly once. The procedure of choosing best parent in RRT* is replaced by FindBestTree in the IB-RRT* algorithm, which also includes the ConnectTrees procedure. As explained earlier, the ConnectTrees function has negligible computational overhead since it merely concatenates two paths. In Intelligent BidirectionalRRT* (IB-RRT*), for every iteration the procedures NearestVertex and NearVertices are executed for both trees Ta and Tb. It has already been proved that both procedures have to run in logi expected time [12]. Furthermore, while IB-RRT* makes its best effort to increase the cardinality of the near vertices, the number of near vertices per tree returned by the procedure NearVertices cannot exceed a constant number [12]. Hence, it can be concluded that the execution of NearestVertex and NearVertices procedures on both trees per iteration adds up a constant computational complexity overhead as compared to RRT*. Hence, it can be concluded that IB-RRT* has the\nsame computational complexity as RRT*. The proof for theorem 3 is exactly the same to one provided for the computational ratio of RRT* and RRT in [12]."
    }, {
      "heading" : "7 Experimental Results",
      "text" : "This section presents simulations performed on a 2.4GHz Intel corei5 processor with 4GB RAM. Here, performance results of our IB-RRT* algorithm are compared with RRT* and B-RRT*. Since exploration of the configuration space by B-RRT* after a large number of iterations is similar to that of IB-RRT*, snap shots presented here only depict the IB-RRT* and RRT* algorithms. This is to better demonstrate the difference between the expansion of trees of the two types of algorithms. For proper comparison, experimental conditions and size of the configuration space were kept constant for all algorithms. Since randomized sampling-based algorithms exhibit large variations in results, the algorithms were run up to 50 times with different seed values for each type of environment. Maximum, minimum and average number of iterations i as well as time t utilized by each algorithm to reach the optimal path solution is presented in the Table 1. To restrain the computational time within reasonable limits, the maximum limit for the number of tree nodes was kept at 5 million. The column fail in the table denotes the number of runs for which the corresponding algorithm failed to find an optimal path solution within node limits when executed with different seed values for random function. Although, algorithms were able to deter-\nmine feasible path solution, this is still considered as a failure, since the table provides comparison for the determination of an optimal path solution only. Figures 2 and 3 illustrate the trees maintained by IB-RRT* and RRT* respectively at different numbers of iterations. The cost C of the path in terms of Euclidean distance is also indicated at each iterations. Table I summarizes the number of iterations and time consumed by IB-RRT*, B-RRT* and RRT* to reach an optimal path in this problem. It should be noted that the RRT* algorithm is unable to fully sample the given configuration space and thus fails to converge to the optimal solution within the limit of 5 million iterations. Although both IB-RRT* and B-RRT* were successful in finding the optimal solution, B-RRT* took an extremely large number of iterations to converge in comparison with IB-RRT*. B-RRT* utilizes the partial greedy heuristic approach as discussed earlier (algorithm line), this significantly reduces its ability of convergence to optimal path solution. Figures 4 and 5 represent particularly challenging maze type of cluttered 2D test environment. The environment has been set up in such a way that the starting and goal regions, while placed close together, are separated by the maze. All algorithms were tested, figure 4(a) to figure 4(d) and 5(a) to figure 5(d) show the convergence from the initial path solution to the optimal path solution by IB-RRT* and RRT*, respectively. For determination of the optimal path, the IB-RRT* algorithm takes the least number of average iterations (iavg=95192) as compared to B-RRT*(iavg=286721) and the extraordinarily large number of iterations taken up by RRT* (iavg=1059268) as shown in Table 1. Figure 8 shows the 3-D environment containing a multiple of barriers which separate the initial state and the goal region. IB-RRT* determines an optimal path most quickly (i=204321) as compared to BRRT* (i=838692) and RRT* (i=1961825). Although all algorithms utilises uniform sampling heuristic, however, IB-RRT* maximizes the rewiring process per iteration due to intelligent sample insertion heuristic and hence quickly converges to the optimal path solution as compared to B-RRT* and RRT*. Figures 6 and 7 depict different scenarios in threedimensional space. Their results are summarized in the Table 1. It can be seen that a similar trend is followed by the algorithms in all environments i.e., IB-RRT* rapidly converges to the optimal solution followed by B-RRT* and then RRT*. Moreover, in the maze problem depicted in Figure 6, RRT* was unable to sample the area close to the goal region even after an extremely large number of iterations while IB-RRT* was able to fully explore the space in a few thousand iterations. Figure 9 summarizes the experimental test results performed in 10 different complex cluttered 2D and 3D environments for the comparison of IB-RRT*, BRRT* and RRT*. The comparison is done in terms of: (a) iterations and time consumed to determine initial path as well as optimal path solution; (b) memory consumed in term of bytes for the determination of optimal path solution (c) convergence rate. From figure 9(a) to figure 9(e), it can be seen that IB-RRT*\nconsumes lesser iterations, time and memory as compared to B-RRT* and RRT* for the determination of feasible path solution. Figure 9(f) provides another type of comparison using boxplot. In this the convergence rate of IB-RRT*, B-RRT* and RRT* are compared in these 10 different complex cluttered environments. Let the initial feasible path, denoted by σinit, is computed in tinit time while the optimal path solution, denoted as σ∗, is computed in t∗ time. Then the convergence rate is defined as\nc(σinit) − c(σ∗) t ∗ −tinit\n. Since the process of convergence to the optimal path solution begins after finding initial feasible path solution, convergence rate is calculated after initial path computation. It is clear from the box plot that convergence rates of IB-RRT* are highest, followed by B-RRT* and RRT*. There also exists a sizable difference between the convergence rates of IB-RRT* and B-RRT*.\nFigure 10 shows the running time ratio of a) IBRRT* over BiRRT and b) IB-RRT* over RRT* after the execution of each iteration. The running time ratio of algorithm A (AL-A) over algorithm B (ALB) is defined as the ratio of time consumed by ALA over the time consumed by AL-B. It can be seen that as the number of iterations increases, the running time ratio reaches a constant value in both cases. Hence, large numbers of iterations imply that the random samples are fully and uniformly distributed in the obstacle-free space. However, before that time, computational complexity of IB-RRT* remains fairly lower than BiRRT and almost equal to RRT*. As a matter of fact, in this specific environment, the average amount of time taken by our proposed IB-RRT* algorithm to determine a viable path to the goal was seen to be barely four times that of BiRRT and 1.4 times that of RRT*."
    }, {
      "heading" : "8 Conclusions and Future work",
      "text" : "This paper presents a detailed comparative analysis of performance of our proposed IB-RRT* algorithm with the existing algorithms RRT* and B-RRT*. It is proven both analytically and experimentally that our proposed algorithm i) has almost similar compu-\ntational complexity as RRT* and BiRRT; ii) provides almost-sure convergence to the optimal path solution; iii) has the higher convergence rate meaning that it rapidly converges to the optimal solution as compared to both state of the art algorithms RRT* and B-RRT*; iv) consumes lesser memory to converge to the optimal solution, as it utilizes lesser iterations and each iteration consumes memory. This paper also presents path planning problems in which the original RRT* algorithm fails to reach the optimal path solution within reasonable limit of iterations. Experimental results supporting theoretical analysis are also presented in this paper. The proposed algorithm IB-RRT* allows rapid convergence to optimal solution without tuning of the sampling operation for optimal paths. Therefore, the proposed planner is of importance in the field of real time motion planning. Hence, we anticipate employing IB-RRT* for online motion planning of animated characters in complex 3-D environments."
    } ],
    "references" : [ {
      "title" : "Lozano-Perez. A subdivision algorithm in configuration space for findpath with rotation",
      "author" : [ "T.R.A. Brooks" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1982
    }, {
      "title" : "The complexity of robot motion planning",
      "author" : [ "J. Canny" ],
      "venue" : "The MIT press,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Assembly maintainability study with motion planning",
      "author" : [ "H. Chang", "T.-Y. Li" ],
      "venue" : "Robotics and Automation, 1995. Proceedings., 1995 IEEE International Conference on, volume 1, pages 1012–1019. IEEE,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Sandros: a dynamic graph search algorithm for motion planning",
      "author" : [ "P.C. Chen", "Y.K. Hwang" ],
      "venue" : "Robotics and Automation, IEEE Transactions on, 14(3):390–403,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Sampling-based robot motion planning: a review",
      "author" : [ "M. Elbanhawi", "M. Simic" ],
      "venue" : "IEEE Access, 2:56–77,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Improving the efficiency of rapidly-exploring random trees using a 15  (a) IB-RRT*: i=186731,t=45.4s,C=81.9 (b) RRT*: i=2106391,t=364s,C=81.9  (c) Optimal path solution Figure 8: Sequence of complex barriers. (a) Iterations used to find initial feasible path solution. (b) Time consumed to find initial feasible path solution. (c) Iterations used to find optimal path solution",
      "author" : [ "I. Garcia", "J.P. How" ],
      "venue" : "In Decision and Control,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2005
    }, {
      "title" : "Computational modeling for the computer animation of legged figures",
      "author" : [ "M. Girard", "A.A. Maciejewski" ],
      "venue" : "ACM SIGGRAPH Computer Graphics, volume 19, pages 263–270. ACM,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "State space sampling of feasible motions for high performance mobile robot navigation in highly constrained environments",
      "author" : [ "T.M. Howard", "C.J. Green", "A. Kelly" ],
      "venue" : "Field and Service Robotics, pages 585–593. Springer,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Robotics for surgery",
      "author" : [ "R.D. Howe", "Y. Matsuoka" ],
      "venue" : "Annual Review of Biomedical Engineering, 1(1):211–240,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "An shortest path algorithm based on delaunay triangulation",
      "author" : [ "G.E. Jan", "C.-C. Sun", "W.C. Tsai", "T.-H. Lin" ],
      "venue" : "Mechatronics, IEEE/ASME Transactions on, 19(2):660–666,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Optimal bidirectional rapidly-exploring random trees",
      "author" : [ "M. Jordan", "A. Perez" ],
      "venue" : "Technical Report MIT-CSAIL-TR-2013-021, CSAIL, MIT, Cambridge, MA, August",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Incremental sampling-based algorithms for optimal motion planning",
      "author" : [ "S. Karaman", "E. Frazzoli" ],
      "venue" : "arXiv preprint arXiv:1005.0416,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Samplingbased algorithms for optimal motion planning",
      "author" : [ "S. Karaman", "E. Frazzoli" ],
      "venue" : " The International Journal of Robotics Research, 30(7):846–894,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Randomized preprocessing of configuration for fast path planning",
      "author" : [ "L. Kavraki", "J.-C. Latombe" ],
      "venue" : "Robotics and Automation, 1994. Proceedings., 1994 IEEE International Conference on, pages 2138–2145. IEEE,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Probabilistic roadmaps for path planning in high-dimensional configuration spaces",
      "author" : [ "L.E. Kavraki", "P. Svestka", "J.-C. Latombe", "M.H. Overmars" ],
      "venue" : "Robotics and Automation, IEEE Transactions on, 12(4):566–580,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Real-time obstacle avoidance for manipulators and mobile robots",
      "author" : [ "O. Khatib" ],
      "venue" : "The international journal of robotics research, 5(1):90–98,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "Cloud rrt: Sampling cloud based rrt",
      "author" : [ "D. Kim", "J. Lee", "S.-e. Yoon" ],
      "venue" : "In Proc. IEEE Int. Conf. Robot. Autom,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2014
    }, {
      "title" : "Potential field methods and their inherent limitations for mobile robot navigation",
      "author" : [ "Y. Koren", "J. Borenstein" ],
      "venue" : "Robotics and Automation, 1991. Proceedings., 1991 IEEE International Conference on, pages 1398–1404. IEEE,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Natural decomposition of free space for path planning",
      "author" : [ "D. Kuan", "J. Zamiska", "R.A. Brooks" ],
      "venue" : "Robotics and Automation. Proceedings. 1985 IEEE International Conference on, volume 2, pages 168–173. IEEE,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "Rrt-connect: An efficient approach to single-query path planning",
      "author" : [ "J.J. Kuffner Jr", "S.M. LaValle" ],
      "venue" : "Robotics and Automation, 2000. Proceedings. ICRA’00. IEEE International Conference on, volume 2, pages 995–1001. IEEE,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "ROBOT MOTION PLAN- NING.",
      "author" : [ "J.-C. Latombe" ],
      "venue" : "Edition en anglais. Springer,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1990
    }, {
      "title" : "Motion planning: A journey of robots, molecules, digital actors, and other artifacts",
      "author" : [ "J.-C. Latombe" ],
      "venue" : "The International Journal of Robotics Research, 18(11):1119–1128,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Rapidly-exploring random trees a ew tool for path planning",
      "author" : [ "S.M. LaValle" ],
      "venue" : null,
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1998
    }, {
      "title" : "Planning algorithms",
      "author" : [ "S.M. LaValle" ],
      "venue" : "Cambridge university press,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Anytime search in dynamic graphs",
      "author" : [ "M. Likhachev", "D. Ferguson", "G. Gordon", "A. Stentz", "S. Thrun" ],
      "venue" : "Artif. Intell., 172(14):1613–1643, Sept.",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Incrementally reducing dispersion by increasing voronoi bias in rrts",
      "author" : [ "S.R. Lindemann", "S.M. LaValle" ],
      "venue" : "Robotics and Automation, 2004. Proceedings. ICRA’04. 2004 IEEE International Conference on, volume 4, pages 3251– 3257. IEEE,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Current issues in sampling-based motion planning",
      "author" : [ "S.R. Lindemann", "S.M. LaValle" ],
      "venue" : "Robotics Research, pages 36–54. Springer,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "An algorithm for planning collision-free paths among polyhedral obstacles",
      "author" : [ "T. Lozano-Pérez", "M.A. Wesley" ],
      "venue" : "Communications of the ACM, 22(10):560–570,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "Asymptoticallyoptimal path planning for manipulation using incremental sampling-based algorithms",
      "author" : [ "A. Perez", "S. Karaman", "A. Shkolnik", "E. Frazzoli", "S. Teller", "M.R. Walter" ],
      "venue" : "Intelligent Robots and Systems (IROS), 2011 IEEE/RSJ International Conference on, pages 4307–4313. IEEE,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Kinodynamic motion planning with state lattice motion primitives",
      "author" : [ "M. Pivtoraiko", "A. Kelly" ],
      "venue" : "Intelligent Robots and Systems (IROS), 2011 IEEE/RSJ International Conference on, pages 2172–2179. IEEE,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Differentially constrained mobile robot motion planning in state lattices",
      "author" : [ "M. Pivtoraiko", "R.A. Knepper", "A. Kelly" ],
      "venue" : "Journal of Field Robotics, 26(3):308–333,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Potential guided directional-rrt* for accelerated motion planning in cluttered environments",
      "author" : [ "A.H. Qureshi", "K.F. Iqbal", "S.M. Qamar", "F. Islam", "Y. Ayaz", "N. Muhammad" ],
      "venue" : "Mechatronics and Automation (ICMA), 2013 IEEE International Conference on, pages 519– 524. IEEE,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Adaptive potential guided directional-rrt",
      "author" : [ "A.H. Qureshi", "S. Mumtaz", "K.F. Iqbal", "B. Ali", "Y. Ayaz", "F. Ahmed", "M.S. Muhammad", "O. Hasan", "W.Y. Kim", "M. Ra" ],
      "venue" : "Robotics and Biomimetics (ROBIO), 2013 IEEE International Conference on, pages 1887–1892. IEEE,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Triangular geometry based optimal motion planning using rrt*-motion planner",
      "author" : [ "A.H. Qureshi", "S. Mumtaz", "K.F. Iqbal", "Y. Ayaz", "M.S. Muhammad", "O. Hasan", "W.Y. Kim", "M. Ra" ],
      "venue" : "Advanced Motion Control (AMC), 2014 IEEE 13th International Workshop on, pages 380–385. IEEE,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "On the piano movers problem",
      "author" : [ "J.T. Schwartz", "M. Sharir" ],
      "venue" : "ii. general techniques for computing topological properties of real algebraic manifolds. Advances in applied Mathematics, 4(3):298–351,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 1983
    } ],
    "referenceMentions" : [ {
      "referenceID" : 23,
      "context" : "Motion planning is a well-known problem in robotics [24].",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 20,
      "context" : "Although motion planning is not the only fundamental problem of robotics, perhaps it has gained popularity among researchers due to widespread applications such as in robotics [21], assembly maintenance [3], computer animation [7], computer-aided surgery [9], manufacturing [22], and many other aspects of daily life.",
      "startOffset" : 176,
      "endOffset" : 180
    }, {
      "referenceID" : 2,
      "context" : "Although motion planning is not the only fundamental problem of robotics, perhaps it has gained popularity among researchers due to widespread applications such as in robotics [21], assembly maintenance [3], computer animation [7], computer-aided surgery [9], manufacturing [22], and many other aspects of daily life.",
      "startOffset" : 203,
      "endOffset" : 206
    }, {
      "referenceID" : 6,
      "context" : "Although motion planning is not the only fundamental problem of robotics, perhaps it has gained popularity among researchers due to widespread applications such as in robotics [21], assembly maintenance [3], computer animation [7], computer-aided surgery [9], manufacturing [22], and many other aspects of daily life.",
      "startOffset" : 227,
      "endOffset" : 230
    }, {
      "referenceID" : 8,
      "context" : "Although motion planning is not the only fundamental problem of robotics, perhaps it has gained popularity among researchers due to widespread applications such as in robotics [21], assembly maintenance [3], computer animation [7], computer-aided surgery [9], manufacturing [22], and many other aspects of daily life.",
      "startOffset" : 255,
      "endOffset" : 258
    }, {
      "referenceID" : 21,
      "context" : "Although motion planning is not the only fundamental problem of robotics, perhaps it has gained popularity among researchers due to widespread applications such as in robotics [21], assembly maintenance [3], computer animation [7], computer-aided surgery [9], manufacturing [22], and many other aspects of daily life.",
      "startOffset" : 274,
      "endOffset" : 278
    }, {
      "referenceID" : 34,
      "context" : "Complete motion planning algorithms [35] [28] are those algorithms that converges to a path solution, if one exists, in finite time.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 27,
      "context" : "Complete motion planning algorithms [35] [28] are those algorithms that converges to a path solution, if one exists, in finite time.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 1,
      "context" : "These algorithms are proven to be computationally inefficient [2] in most of the practical motion planning problems [13].",
      "startOffset" : 62,
      "endOffset" : 65
    }, {
      "referenceID" : 12,
      "context" : "These algorithms are proven to be computationally inefficient [2] in most of the practical motion planning problems [13].",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 15,
      "context" : "Artificial Potential Fields (APF) [16] is a well-known resolution complete algorithm.",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 17,
      "context" : "However, APF suffers from the problem of local minima [18] and does not performed well in the environment with narrow passages.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 18,
      "context" : "This discretization of search space makes the algorithm computationally expensive for higher dimensional spaces, that is why the application of such algorithms like Cell Decomposition methods [19] [1], Delaunay Triangulations [10] and Dynamic Graph Search methods [4] [25] are limited to low dimensional spaces only [5].",
      "startOffset" : 192,
      "endOffset" : 196
    }, {
      "referenceID" : 0,
      "context" : "This discretization of search space makes the algorithm computationally expensive for higher dimensional spaces, that is why the application of such algorithms like Cell Decomposition methods [19] [1], Delaunay Triangulations [10] and Dynamic Graph Search methods [4] [25] are limited to low dimensional spaces only [5].",
      "startOffset" : 197,
      "endOffset" : 200
    }, {
      "referenceID" : 9,
      "context" : "This discretization of search space makes the algorithm computationally expensive for higher dimensional spaces, that is why the application of such algorithms like Cell Decomposition methods [19] [1], Delaunay Triangulations [10] and Dynamic Graph Search methods [4] [25] are limited to low dimensional spaces only [5].",
      "startOffset" : 226,
      "endOffset" : 230
    }, {
      "referenceID" : 3,
      "context" : "This discretization of search space makes the algorithm computationally expensive for higher dimensional spaces, that is why the application of such algorithms like Cell Decomposition methods [19] [1], Delaunay Triangulations [10] and Dynamic Graph Search methods [4] [25] are limited to low dimensional spaces only [5].",
      "startOffset" : 264,
      "endOffset" : 267
    }, {
      "referenceID" : 24,
      "context" : "This discretization of search space makes the algorithm computationally expensive for higher dimensional spaces, that is why the application of such algorithms like Cell Decomposition methods [19] [1], Delaunay Triangulations [10] and Dynamic Graph Search methods [4] [25] are limited to low dimensional spaces only [5].",
      "startOffset" : 268,
      "endOffset" : 272
    }, {
      "referenceID" : 4,
      "context" : "This discretization of search space makes the algorithm computationally expensive for higher dimensional spaces, that is why the application of such algorithms like Cell Decomposition methods [19] [1], Delaunay Triangulations [10] and Dynamic Graph Search methods [4] [25] are limited to low dimensional spaces only [5].",
      "startOffset" : 316,
      "endOffset" : 319
    }, {
      "referenceID" : 7,
      "context" : "Moreover the algorithms that combine the set of allowed motions with the graph search methods thus generating state lattices, such as in [8] [31] [30], also suffered from the undesirable effects of discretization.",
      "startOffset" : 137,
      "endOffset" : 140
    }, {
      "referenceID" : 30,
      "context" : "Moreover the algorithms that combine the set of allowed motions with the graph search methods thus generating state lattices, such as in [8] [31] [30], also suffered from the undesirable effects of discretization.",
      "startOffset" : 141,
      "endOffset" : 145
    }, {
      "referenceID" : 29,
      "context" : "Moreover the algorithms that combine the set of allowed motions with the graph search methods thus generating state lattices, such as in [8] [31] [30], also suffered from the undesirable effects of discretization.",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 4,
      "context" : "Hence to solve the higher dimensional planning problems, the sampling-based algorithms were introduced [5]; the main advantage of sampling-based algorithms as compared to other state-of-the-art algorithms is avoidance of explicit construction of obstacle configuration space.",
      "startOffset" : 103,
      "endOffset" : 106
    }, {
      "referenceID" : 1,
      "context" : "The sampling-based algorithms have proven to be computationally efficient [2] solution to motion planning problems.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 13,
      "context" : "Arguably, the most well-known samplingbased algorithms include Probabilistic Road Maps (PRM) [14] [15] and Rapidly exploring Random Trees (RRT) [23].",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 14,
      "context" : "Arguably, the most well-known samplingbased algorithms include Probabilistic Road Maps (PRM) [14] [15] and Rapidly exploring Random Trees (RRT) [23].",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 22,
      "context" : "Arguably, the most well-known samplingbased algorithms include Probabilistic Road Maps (PRM) [14] [15] and Rapidly exploring Random Trees (RRT) [23].",
      "startOffset" : 144,
      "endOffset" : 148
    }, {
      "referenceID" : 12,
      "context" : "However, PRMs tend to be inefficient when obstacle geometry is not known beforehand [13].",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 22,
      "context" : "Therefore, in order to derive efficient solutions for motion planning in the practical world, the Rapidly-exploring Random Trees (RRT) algorithms [23] have been extensively explored.",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 25,
      "context" : "Various algorithms enhancing original RRT algorithm have been proposed [26], [6], [20], [13].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 5,
      "context" : "Various algorithms enhancing original RRT algorithm have been proposed [26], [6], [20], [13].",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 19,
      "context" : "Various algorithms enhancing original RRT algorithm have been proposed [26], [6], [20], [13].",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 12,
      "context" : "Various algorithms enhancing original RRT algorithm have been proposed [26], [6], [20], [13].",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 12,
      "context" : "One of the most remarkable variant of RRT algorithm is RRT*, an algorithm which guarantees eventual convergence to an optimal path solution [13], unlike the original RRT algorithm.",
      "startOffset" : 140,
      "endOffset" : 144
    }, {
      "referenceID" : 11,
      "context" : "It then continues to refine this initial path in successive iterations, eventually returning an optimal or near optimal path towards the goal as the number of iterations approach infinity [12].",
      "startOffset" : 188,
      "endOffset" : 192
    }, {
      "referenceID" : 28,
      "context" : "This additional guarantee of optimality makes the RRT* algorithm very useful for real-time applications [29].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 31,
      "context" : "Various heuristics have been introduced, such as [32] [33] [34] [17], which perform guided search of the given space instead of pure uniform search (as by RRT and RRT*).",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 32,
      "context" : "Various heuristics have been introduced, such as [32] [33] [34] [17], which perform guided search of the given space instead of pure uniform search (as by RRT and RRT*).",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 33,
      "context" : "Various heuristics have been introduced, such as [32] [33] [34] [17], which perform guided search of the given space instead of pure uniform search (as by RRT and RRT*).",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 16,
      "context" : "Various heuristics have been introduced, such as [32] [33] [34] [17], which perform guided search of the given space instead of pure uniform search (as by RRT and RRT*).",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 26,
      "context" : "This computational overload limits their application to a limited number of fields [27].",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 32,
      "context" : "For example assume a simple case of using goal-biased sampling [33] with bidirectional RRT that alternatively grows two trees.",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 10,
      "context" : "More recent proposition is the bidirectional version of RRT* known as B-RRT* [11].",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 10,
      "context" : "B-RRT* presented in [11] is a simple bidirectional implementation of RRT*.",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 19,
      "context" : "B-RRT* uses a slight variation of greedy RRT-Connect heuristic [20] for the connection of two trees.",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 10,
      "context" : "Two directional trees employing greedy connect heuristic for the connection of trees does not ensure asymptotic optimality [11].",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 19,
      "context" : ", the tree under process first searches for the neighbor vertices before making an attempt to connect the trees using RRT-Connect heuristic [20].",
      "startOffset" : 140,
      "endOffset" : 144
    }, {
      "referenceID" : 10,
      "context" : "The proposed Intelligent Bidirectional-RRT* (IB-RRT*) algorithm has been tested for its robustness in both 2-D and 3-D environments and has also been compared with other state-of-art algorithms such as BidirectionalRRT*[11] and RRT* itself [12].",
      "startOffset" : 219,
      "endOffset" : 223
    }, {
      "referenceID" : 11,
      "context" : "The proposed Intelligent Bidirectional-RRT* (IB-RRT*) algorithm has been tested for its robustness in both 2-D and 3-D environments and has also been compared with other state-of-art algorithms such as BidirectionalRRT*[11] and RRT* itself [12].",
      "startOffset" : 240,
      "endOffset" : 244
    }, {
      "referenceID" : 11,
      "context" : "This section describes the RRT* algorithm [12].",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 28,
      "context" : "In this version, improvements were made to the original algorithm in order to enhance the computational efficiency of RRT* by reducing the number of calls to the ObstacleFree procedure [29].",
      "startOffset" : 185,
      "endOffset" : 189
    }, {
      "referenceID" : 0,
      "context" : "Collision Check: the procedure ObstracleFree(σ) checks whether the given path σ : [0, 1] belongs to Algorithm 2: GetSortedList(xrand, Xnear)",
      "startOffset" : 82,
      "endOffset" : 88
    }, {
      "referenceID" : 0,
      "context" : "A true value is reported if σ(s) ∈ Xfree∀s[0, 1].",
      "startOffset" : 42,
      "endOffset" : 48
    }, {
      "referenceID" : 0,
      "context" : "For example, for two given states x1 ∈ X and x2 ∈ X, the path σ : [0, 1] will be the path connecting these two states, i.",
      "startOffset" : 66,
      "endOffset" : 72
    }, {
      "referenceID" : 0,
      "context" : "The steering is done from x1 to x2 in small, discrete steps and can be summarized as σ(s′) = (1− s′)x1 + s′x2;∀s′[0, 1].",
      "startOffset" : 113,
      "endOffset" : 119
    }, {
      "referenceID" : 10,
      "context" : "This section explains the implementation of Bidirectional-RRT*(B-RRT*) [11].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 19,
      "context" : "Connect: connect heuristic employed by BRRT* is slight variation of greedy RRT-Connect heuristic[20].",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 19,
      "context" : "Hence, unlike the connect heuristic [20], the IBRRT* is not greedy since the connection is only made inside the ball region as shown in the figure 1(d).",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 12,
      "context" : "It is known that RRT is a probabilistically complete algorithm, as its optimal variant RRT* [13].",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 12,
      "context" : "It is known that RRT and its variant RRT-Connect do not ensure optimality even if the number of iterations are increased to infinity [13].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 11,
      "context" : "However, RRT* is an optimal variant of RRT, ensuring almost-sure convergence to an optimal solution [12].",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 11,
      "context" : "A similar procedure is employed by the RRT* algorithm [12] to connect the random sample with its chosen parent.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 12,
      "context" : "Biasing the samples for rapid convergence to the optimal solution is computationally inefficient, specifically in higher dimension configuration spaces [13].",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 12,
      "context" : "Lemma 1 ([13]) A sampling-based algorithm ensures asymptotic optimality, such that P(limi→∞ ‖σ′ i − σi‖ = 0;∀σi, σ′ i ∈ ∑ free) = 1.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 22,
      "context" : "For the incremental or wavefront expansion of the trees it is proven that the regions near the point of generation of trees are more dense [23].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 10,
      "context" : "Furthermore, trees connection heuristic employed by B-RRT* [11] is partially greedy, similar to the the connect heuristic [20].",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 19,
      "context" : "Furthermore, trees connection heuristic employed by B-RRT* [11] is partially greedy, similar to the the connect heuristic [20].",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 19,
      "context" : "It has already been proved that if the bidirectional version of RRT* uses purely RRT-Connect heuristic [20] for the connection of two trees, it is no longer asymptotically optimal [11].",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 10,
      "context" : "It has already been proved that if the bidirectional version of RRT* uses purely RRT-Connect heuristic [20] for the connection of two trees, it is no longer asymptotically optimal [11].",
      "startOffset" : 180,
      "endOffset" : 184
    }, {
      "referenceID" : 19,
      "context" : "This happens because when only the connect heuristic [20] is used, an edge originating from Ta for example, tries to reach the closest vertex on Tb.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 11,
      "context" : "It has already been proved that both procedures have to run in logi expected time [12].",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 11,
      "context" : "Furthermore, while IB-RRT* makes its best effort to increase the cardinality of the near vertices, the number of near vertices per tree returned by the procedure NearVertices cannot exceed a constant number [12].",
      "startOffset" : 207,
      "endOffset" : 211
    }, {
      "referenceID" : 11,
      "context" : "The proof for theorem 3 is exactly the same to one provided for the computational ratio of RRT* and RRT in [12].",
      "startOffset" : 107,
      "endOffset" : 111
    } ],
    "year" : 2017,
    "abstractText" : "The sampling based motion planning algorithm known as Rapidly-exploring Random Trees (RRT) has gained the attention of many researchers due to their computational efficiency and effectiveness. Recently, a variant of RRT called RRT* has been proposed that ensures asymptotic optimality. Subsequently its bidirectional version has also been introduced in the literature known as Bidirectional-RRT* (B-RRT*). We introduce a new variant called Intelligent Bidirectional-RRT* (IB-RRT*) which is an improved variant of the optimal RRT* and bidirectional version of RRT* (B-RRT*) algorithms and is specially designed for complex cluttered environments. IB-RRT* utilizes the bidirectional trees approach and introduces intelligent sample insertion heuristic for fast convergence to the optimal path solution using uniform sampling heuristics. The proposed algorithm is evaluated theoretically and experimental ∗This is the authors’ version of the paper published in Elsevier Robotics and Autonomous Systems Journal. The source code of this paper is available at: github.com/ahq1993. results are presented that compares IB-RRT* with RRT* and B-RRT*. Moreover, experimental results demonstrate the superior efficiency of IB-RRT* in comparison with RRT* and B-RRT in complex cluttered environments.",
    "creator" : "LaTeX with hyperref package"
  }
}