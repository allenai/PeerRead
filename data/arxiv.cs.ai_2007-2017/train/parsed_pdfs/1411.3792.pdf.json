{
  "name" : "1411.3792.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "An Approach to Model Checking of Multi-agent Data Analysis",
    "authors" : [ "M. M. Bersani", "D. Bresolin", "L. Ferrucci", "© N. Garanina", "E. Bodin", "E. Sidorova", "Natalia Garanina", "Eugene Bodin", "Elena Sidorova" ],
    "emails" : [ "garanina@iis.nsk.su", "bodin@iis.nsk.su", "lena@iis.nsk.su" ],
    "sections" : [ {
      "heading" : null,
      "text" : "M. M. Bersani, D. Bresolin, L. Ferrucci and M. Mazzara (Eds.): First Workshop on Logics and MODel-checking for self-* systems (MOD*) EPTCS 168, 2014, pp. 32–44, doi:10.4204/EPTCS.168.3\nc© N. Garanina, E. Bodin, E. Sidorova This work is licensed under the Creative Commons Attribution License."
    }, {
      "heading" : "An Approach to Model Checking of Multi-agent Data",
      "text" : "Analysis\nNatalia Garanina Eugene Bodin A.P. Ershov Institute of Informatics Systems, Novosibirsk, Russia∗\ngaranina,bodin,lena@iis.nsk.su\nElena Sidorova\nThe paper presents an approach to verification of a multi-agent data analysis algorithm. We base correct simulation of the multi-agent system by a finite integer model. For verification we use model checking tool SPIN. Protocols of agents are written in Promela language and properties of the multiagent data analysis system are expressed in logic LTL. We run several experiments with SPIN and the model."
    }, {
      "heading" : "1 Introduction",
      "text" : "The purpose of the paper is to apply formal verification methods to multi-agent algorithms of data analysis in a framework of ontology population.\nMulti-agent data analysis for ontology population is a multilevel process. Let us have an ontology, whose elements are classes, specified by a set of (key) attributes, and relations, specified by attributes and a set of classes they connect. Ontology population rules depend on given ontology classes and relations. Besides, we have rules for input data processing. These data can be natural language text or special format of data storing, for example, various databases or tagged internet pages. We consider all these rules defined formally such that every rule can (1) use data, which can be values of attributes or instances of classes or relations; (2) bind a tuple of attributes into an instance of a given class; (3) determine attribute values of the relation and whether some class instances belong to a given relation.\nAt the first stage of multi-agent data analysis, preliminary investigation of input data generates underdetermined objects that can be instances of classes and relations of the predefined ontology. At the next stage, using rules of ontology population and data processing, concerning semantic and syntactic consistency, these objects are evaluated from input data as full as it is possible. At the third stage, these objects-instances resolve ambiguities that are an inherent feature of automatic data analysis.\nAt the second stage of analysis information (instance and relation) agents appears. They correspond to instances of classes and relations. Information agents interact with rule agents that implement given rules of data processing and ontology population. These agents exchange information necessary for specification of information agents. A special controller agent detects system termination, i.e. a moment when all possible information is retrieved from data and agents just waiting for messages from each others. In contrast to all other model agents, this service agent is universal, i.e. it does not depend on a given ontology and input data types.\nAll agents act in parallel hence we have to verify some important properties of the system. In particulary, properties to be verified are correctness of termination detection and simple operability of the\n∗The research has been supported by Russian Foundation for Basic Research (grant 13-01-00643) and Siberian Branch of Russian Academy of Science (Integration Grant n.15/10 “Mathematical and Methodological Aspects of Intellectual Information Systems”).\nanalysis system. For checking these properties we choose model checking tool SPIN [8]. SPIN has rather expressive input language for specification our data analysis model and its properties, and a welldeveloped system for error detection and examination.\nA multi-agent approach for information retrieval from heterogeneous data sources for completing ontology is widespread. In particular, it is used for natural language processing [2, 1, 10, 6] and web processing [3, 4, 5]. Agents in these works have different behaviors. Usually in web processing, agents are high-level entities that manage rather data flows, using standard algorithm for knowledge retrieval, than data itself. In natural language processing, agents are either associated with conventional linguistic levels (morphological, syntactic, semantic) or targeted to recognize specific linguistic phenomena such as ellipsis, anaphora, parataxis, homonymy. These agents do not use ontological knowledge substantially. Thus they are computing processes which may speed up information retrieval due to their parallel work but they do not affect the retrieval qualitatively.\nOur approach implements multi-agent low-level data analysis in which agents do not process input data by traditional methods but present information items themselves. To the best of our knowledge a similar approach is introduced in [9] only. Verification of such system is also unknown to us.\nThe rest of the paper is organized as follows. The next section 2 describes agents of our systems and their action protocols. The section 3 grounds an approach to finite state model checking of our multiagent model. The following section 4 presents the method for expressing the multi-agent model and its properties in SPIN. Finally, we conclude in the last section 5 with a discussion of further research."
    }, {
      "heading" : "2 Agent Model and Protocols",
      "text" : "Outline of the approach and multi-agent system follows. There is an ontology of a subject domain, a set of rules for completing it, a semantic and syntactic model of the input data language and a finite data to extract information for the ontology. We consider a subject domain’s ontology to be the following tuple O = 〈C,R,T,A〉, where\n• C = ∪Ci is a finite non-empty set of classes describing the subject domain concepts;\n• R = ∪Ri is a finite set of binary relations on classes (concepts), and FR : C×C → 2R is a function defining the names of binary relations between the classes;\n• T = ∪Ti is a set of data type with the domain of possible values {v1, . . . ,vi};\n• A =∪ai is a finite set of attributes, AK ⊆ A is a subset of the key attributes for unique identification of the instances of concepts and relations, and FA : C∪R → 2A×T is a function defining the names and the types of attributes for classes C and relations R.\nThe information content of an ontology O is represented as IC = 〈I,RI〉, where\n• I = ∪Ii is a finite set of ontology class instances from O where Ii from class Ci ∈ C consists of a set of attributes a j with values v j: Ii = ∪ j(a j,v j) and (a j,v j) ∈ FA(Ci);\n• RI = ∪RIi is ontology relation instances which is a finite set of relations on the set I of class instances. Relation instance RIi of the relation Ri consists of a instances (o1)i,(o2)i ∈ I of classes C1 and C2 respectively, with a set of attributes a j provided with values v j: RIi = ((o1,o2)i,∪(a j,v j)), where Ri ∈ FR(C1,C2) and (a j,v j) ∈ FA(Ri).\nRules for completing the ontology recognize instances of ontology classes or relations in input data, evaluate their attributes and bind class instances in relation instances. A semantic-syntactic models of\ninput data languages are usually manifold and complicate. A universal formalization for this topic is out of scope of this paper.\nThe preliminary phase of data processing is executed by an external analysis module based on a vocabulary of the subject domain. This module constructs (1) a set of instance agents corresponding to ontology concepts, and (2) a set of relation agents corresponding to ontology relations. The information agents make use of knowledge concerning their positions in input data. This knowledge is represented as a set of closed natural intervals. We consider this set as set of natural numbers in sense that two intersecting intervals are joined into one.\nThe rule agents implement rules of input data processing and ontology population. According to information received from instance and relation agents, they generate new attribute values of the instances and relations, send the obtained result to all agents interested in it, or generate new instance or relation agents. Eventually, the information agents assign values to all their attributes that can be evaluated with the information from the data, and the system stops. A controller agent keeps track of system stopping. At the termination moment, the instance agents have accumulated all possible values for each of their attributes to resolve information ambiguities. Formal definitions of agents follow.\nA set of instance agents IA corresponds to class ontological instances from O. Each I ∈ IA is a tuple I = (id;Cl;Atr;Rul;Pos;Rel), where\n• id is a unique agent identifier;\n• Cl ∈C is an ontological class of the agent; • Atr = ⋃\nj∈[1..k](a j,Vj,Rul j, pos j) is a set of attributes of the agent, where for each j ∈ [1..k]\n– a j is a name of the agent attribute; – attribute values from Vj belongs to the domain of the corresponding type and (a j,Vj) ⊆\nFA(ClO); – every rule agent in set of rule agents Rul j requires the value of attribute a j to get the result; – pos j is a set of closed natural intervals corresponding to the attribute position in the input\ndata;\n• Rul is a set of rule agents that use data included in this instance agent as an argument; • Pos = ⋃\nj∈[1..k] pos j is a set of natural intervals corresponding to the agent position in the input data;\n• Rel is a set of possible relations of the agent; for every (r, ir) ∈ Rel: ir is a set of instance identifiers of relation agent r which include this agent.\nA set of relation agents RlA corresponds to ontological relations from O. Each Rl ∈ RlA is a tuple Rl = (id;RO; IR;Rul;Pos), where\n• id is a unique agent identifier;\n• RO ∈ R is an ontological relation of the agent; • IR = ⋃\ni∈[1..k]((o1,o2)i,Atri, posi) is a set of instances of relation RO, where for each i ∈ [1..k]\n– relation objects o1 and o2 are identifiers of instance agents belonging to ontological classes C1 and C2 respectively and RlO ∈ FR(C1,C2); – every relation attribute (a,v, pos) ∈ Atri with name a has attribute value v with (a,v) ∈ FA(RlO) and data position pos; – posi = (Poso1 ∪Poso2) ⋃ (∪(a,v,pos)∈Atri pos) is a set of natural intervals corresponding to the\nagent position in the input data;\nrelation instance is evaluated iff both its objects are evaluated;\n• Rul is a set of rule agents that use this relation agent as an argument; • Pos= ⋃\ni∈[1..k] posi is a set of natural intervals corresponding to the agent position in the input data.\nA set of rule agents RA corresponds to rules of input data processing and ontology population rules. Each rule agent R ∈ RA is a tuple R = (id;Args;make res(args),result), where\n• id is a unique agent identifier;\n• Args = ∪(arg1(Cl1), ...,args(Cls)) is a set of argument vectors, where for each i ∈ [1..s]: argi is an argument value determined by the corresponding instance or relation agents from ontological class Cli; let us denote vector of arguments’ values as args, where each value is\n– an attribute value provided with the identifier of an instance agent,\n– an identifier of an instance agent,\n– an identifier of an instance of a relation agent;\n• make res(args) is a function computing the result from vector args;\n• result is the result of function make res(arg) which can be\n– empty, if the argument vector is inconsistent;\n– values of some attributes with their positions for some instance agents and/or\n– tuples of values of some objects and attributes with their positions for some relation agents and/or\n– new information agents (they must differ from other agents by their classes and values of attributes).\nAs a simple example let us consider the following multi-agent system for natural language text processing. Let the given ontology includes classes SciEvent, GeoPlace, and relation Venue. The corresponding instance and relation agents have the following form:\n• I1 = ( /0;SciEvent; (date,{R Calendar, . . .}, /0(Dates), /0),(name,{R Calendar,R Person, . . .}, /0(String), /0), . . . ;\n{R Venue,R Date,R Person, . . .}; /0;{(Venue, /0),(OrganizedBy, /0), . . .}). SciEvent has attributes date and name which can be used by rule agents R Calendar, R Person and others. The agent itself is used by rule agents R Venue, R Date, R Person and others. The relations of the agent are Venue, OrganizedBy and others.\n• I2 = ( /0;GeoPlace; (name,{R Venue,R GeoPlace, . . .}, /0(String), /0),\n(country,{R GeoPlace, . . .}, /0(Countries), /0), . . . ; {R Venue,R Travel, . . .}; /0;{(Venue, /0),(BirthPlace, /0), . . .}).\nGeoPlace has attributes name and country which can be used by the corresponding rule agents R Venue, R GeoPlace and others. The agent itself is used by rule agents R Venue, R Travel, and others. The relations of the agent are Venue, BirthPlace etc.\n• Rl1 = (1;Venue; IR((SciEvent,GeoPlace), /0); /0; /0). Venue connects scientific events and geographic places.\nAs an example of a rule agent let us consider agent R Venue: R Venue = (1,arg1(SciEvent),arg2(GeoPlace),arg3(HoldOp);\n(1) Caption({arg1 ,arg2}),Preposition(arg1 ,arg2) || (2) Re f erence({arg1 ,arg2}),Preposition(arg1 ,arg2) || (3) Sentence1({arg1 ,arg2}),Preposition(arg1 ,arg2), BracketSegment({arg2}),Contact Stop(arg1,arg2) || (4) Sentence2({arg1 ,arg2,arg3}),\nPreposition(arg1 ,arg3),Contact NegWords(arg1 ,arg2), Preposition(arg3 ,arg2),Contact Attr(arg3,arg2,arg1) ||\n(5) . . . ; Venue.o1 = arg1,Venue.o2 = arg2).\nThis rule agent matches scientific events to geographic places. It can recognize this matching in captions, references, various sentences taking into account mutual positions of its arguments and their contacts (for instance, events and places can be interpointed in Sentence1). Third argument arg3(HoldOp) accumulates all verbs and phrases indicating venue: ‘hold’, ‘locate’, ‘take place’ etc. Let us consider the following part of MOD* call for papers:\nThe 1st Workshop on Logics and Model-Checking for Self-* Systems (MOD*) http://modstar.cs.unibo.it/ 12 September 2014, Bertinoro, Italy\nThe following evaluation of attributes of the above agents is the result of analysis of the given text fragment:\n• I1 = (1; SciEvent; (date,{. . .},12.09.2014, [13,15]), (name,{...},”The 1st Workshop on Logics and Model-Checking for Self-* Systems”, [1,10]), ...;\n{. . .}; {[1,10], [13,15]}; {(Venue,1),(OrganizedBy, /0), . . .}).\n• I2 = (2; GeoPlace; (name,{. . .},Bertinoro, [16]), (country,{. . .}, Italy, [17]), . . . ; {. . .}; [16,17]; {(Venue,1),(BirthPlace, /0), . . .}).\n• Rl1 = (1; Venue; {(1, 2, {[1,10], [13,17]})1}; /0; {[1,10], [13,17]}).\nNow we give brief overview of interactions of the above information and rule agents. Multi-agent system MDA for data analysis includes information agents sets, a rule agents set, and an agent-controller. The result of agent interactions by protocols below is data analysis, when the information agents determine the possible values of their attributes and objects from a given data. All agents execute their protocols in parallel. That is, all agents act in parallel until none of the rule agent can proceed. These termination event is determined by the controller agent. We use an original algorithm for termination detection which is based on activity counting. The system is dynamic because rule agents can create new information agents.\nThe agents are connected by duplex channels. The controller agent is connected with all agents, instance agents are connected with their relation agents from Rel, and information agents are connected with rule agents that use information from them and/or provide new attribute/object values for them. Messages are transmitted instantly in a reliable medium and stored in channels until being read.\nLet IA = {I1, ..., In, ...} be an instance agents set, RlA = {Rl1, ...,Rlm, ...} be a relation agents set, and RA= {R1, ...,Rs}, be a rule agents set. The result of executing of the following algorithm is data analysis, when the information agents determine the possible values of their attributes. Let Ii be a protocol of actions of instance agent Ii, Rlj be a protocol of actions of relation agent Rl j, and Rk, be the protocol of actions of rule agent Rk, C be the protocol of actions of an agent-controller C. Then the multi-agent data\nanalysis algorithm MDA can be presented in pseudocode as follows: MDA::\nparallel {I1} ...{In} ...{Rl1} ...{Rlm} ...{R1} ...{Rs} {C} Here the parallel operator means that all execution flows (threads) in the set of braces are working in parallel. Brief descriptions of the protocols follow. Let further C be the controller agent; R,Ri j be rule agents; I be an instance agent; Rl be a relation agent; A be an information agent; mess be message (special for every kind of agents); Input be queue of incoming messages. We suppose that all specialities are clear from the context. For the simplicity, we suggest that rule agents produce results with at most one attribute per an instance agent and/or at most one instance of relation per a relation agent. This case could be easily generalized for multiple results.\nInformal description of the instance agent protocol. In the first phase of its activities the instance agent sends evaluated data to all rule agents interested in these data. Then the agent processes the received data by updating its attributes, relations, and increasing the position with the attributes’ positions, sending fresh attribute values to rule agents interested in. Every change of activity is reported to the controller agent. The instance agent terminates if it receives the stop message from the controller agent. Protocol of instance agents. I:: 1. send |Rul|+1 to C; 2. forall R ∈ Rul send id to R; 3. forall ai ∈ Atr 4. if ai 6= /0 then { send |Ruli| to C; 5. forall Ri j ∈ Ruli send ai to Ri j;} 6. send −1 to C; 7. while (true){ 8. if Input 6= /0 then { 9. mess = get head(Input); 10. if mess.name = C then break; 11. if mess.name ∈ Rel then upd Rel(mess.name, mess.id); 12. if mess.id = i then { 13. upd(ai, mess.value, mess.pos); 14. upd(Pos, mess.pos); 15. send |Ruli| to C; 16. forall Ri j ∈ Ruli send ai to Ri j; } 17. send −1 to C; } }\nInformal description of the relation agent protocol. In the first phase of its activities the relation agent sends evaluated data to all instance and rule agents interested in these data. The agent processes the received data by updating instances of its objects, attributes and increasing the position with the objects’ and attributes’ positions, sending identifiers of these fresh instances to instance agents included into evaluated tuples of data. Every change of activity is reported to the controller agent. The relation agent terminates if it receives the stop message from the controller agent. Protocol of relation agents. Rl:: 1. send 1 to C; 2. forall iri ∈ IR 3. if evaluated(iri) then { 4. send |Rul|+2 to C;\n5. send (Rl, iri) to (o1)i and (o2)i; 6. forall R ∈ Rul send (Rl, iri) to R;} 7. send −1 to C; 8. while (true){ 9. if Input 6= /0 then { 10. mess = get head(Input); 11. if mess.name = C then break;"
    }, {
      "heading" : "12. upd Rel(mess.id, mess.value, mess.pos);",
      "text" : ""
    }, {
      "heading" : "13. i = mess.id",
      "text" : "14. if evaluated(iri) then { 15. send |Rul|+2 to C; 16. send (Rl, iri) to (o1)i and (o2)i; 17. forall R ∈ Rul send (Rl, i) to R;} 18. send −1 to C; }}\nInformal description of the rule agent protocol. It has two parallel subprocesses: processing incoming data from instance agents (ProcInput) and producing the outcoming result (ProcResult). Processing incoming data includes (1) forming argument vectors, and (2) sending argument vectors or indication of termination to ProcResult. Producing the outcoming result includes (1) checking conformity of arguments and argument vectors, (2) making the result, which is new attribute values of some information agents and/or new information agents with their positions, and (3) determining agents for sending new values to. New information agents start immediately with data given them by the rule agent at birth. Every change of activity is reported to the controller agent. The rule agent terminates if it receives the stop message from the controller agent. Protocol of rule agents. R :: SendList: set of Instance Agents = /0;"
    }, {
      "heading" : "1. parallel",
      "text" : "2. { ProcInputR; ProcResultR; } ProcInputR ::\nargs: set of vectors of Argument;"
    }, {
      "heading" : "1. while (true) {",
      "text" : "2. if Input 6= /0 then { 3. mess = get head(Input); 4. if mess.name=C then { 5. send ‘stop’ to ProcResultR; 6. break; } 7. if mess.name=A then { 8. args = make arg(mess.value, A); 9. if (args 6= /0) send ( args ) to ProcResultR; 10. send |args|−1 to C; }}} ProcResultR ::\narg: vector of Argument∪{‘stop’};"
    }, {
      "heading" : "1. while (true) {",
      "text" : "2. if Input 6= /0 then { 3. arg = get head(Input); 4. if arg = ‘stop’ then break;\n5. (result,SendList) = make res(arg); 6. if result 6= /0 then {"
    }, {
      "heading" : "7. start new information agents;",
      "text" : "8. send |SendList| to C; 9. forall A ∈ SendList send result(A) to A;} 10. send −1 to C; }}\nThe main job of the controller agent is to sequentially calculate other agents’ activities. If all agents are inactive, the agent sends them all the stop message. Protocol of agent-controller C. C ::\nAct: integer; Input: set of integer;\n1. Act = 0; 2. while( Input = /0 ) { } 3. while(true){ 4. if( Input 6= /0 ) then Act = Act + get mess(Input); 5. if( Input = /0 and Act = 0 ) then break; }"
    }, {
      "heading" : "6. send STOP to all;",
      "text" : "The following proposition is straight consequence of Proposition 1 from [7]:\nProposition 1 Multi-agent system MDA terminates and the agent-controller determines the termination moment correctly.\nThe proposition is proved in [7]. The proof of the first part is based on finiteness of input data and reasonable suggestion that rules of ontology population and data processing cannot generate new information infinitely. The second assertion is based on timely notifying about activities of information and rule agents."
    }, {
      "heading" : "3 Model Checking of Multi-agent Data Analysis",
      "text" : "We would like to verify properties from proposition 1 formally because a parallel interaction of agents is rather knotty. The crucial property of this multi-agent system is termination. Another important property is correctness of actions of the agent-controller, i.e. that the agent correctly detects the moment of system termination when all system agents do nothing just waiting messages from others. Besides, there is an interesting “operability” property: in a future at least one information agent will update at least one of its attributes. Specific properties of soundness and completeness of information processing are also very important, but we think it is practically impossible to check these by formal verification methods.\nOur agent model is finite if we suggest that rules of ontology population and data processing do not generate new information agents infinitely. Hence it is possible to use finite-state model checking technique for verification. For this it is reasonable to code the model in integers. Let us explain the approach by an example of semantic text analysis for ontology population. (1) Input data. As input data we have a finite natural language text, hence we can just enumerate words in this text. (2) An ontology. We suggest that a given ontology has a finite number of classes and relations and attribute values of classes and relations belong to finite domains or input data1. Hence we can enumerate\n1For example, let input data be texts of calls for papers for conferences, then important dates of a conference can be an attribute of class Con f erence in ontology Scienti f icEvents.\ninstances of classes and relations and their attributes. (3) A model of the domain-specific language. A special preprocessing module based on this model constructs finite number of information agents corresponding to input text. Every information agent (its attributes) can contain the following descriptive information:\n• ontological: belonging to numerated classes or relations, holding numerated evaluated values of some attributes;\n• grammatical: enumerated morphological and syntactical characters;\n• structural: an enumerated text position;\n• segmental: belonging to an enumerated text segment2.\nAgain we can enumerate these agents and their inside information. (4) Processing rules. Every processing rule agent uses a set of arguments whose values come from information agents and include all necessary details (ontological, grammatical, structural and segmental). These data are represented by natural numbers. A rule agent produces result as a set of natural numbers forming attribute values or new information agents. These values and elements of the new agents are some arguments with descriptive information or they belong to corresponding domains. Hence, rule agents consume integer numbers and produce integer numbers.\nA reason for our system termination is that position Pos of every information agent cannot increase infinitely since it is bounded by number of words in the input text. Besides, we have to be sure that there is no infinite information for these positions. This property can be formulated using a special construct according to every vector of rule arguments. Let position Pos(arg) be a union of positions of arguments from arg. Let call it a position point. Informally, this position point corresponds to a set of words from the input text located in positions from Pos. It is reasonable to limit amount of new information corresponding to one position point. Hence, in order to verify the property of interest for every rule agent we just have to accumulate numbers of new information items for every position point of the rule, and then compare them with the limit. This limit depends on the degree of terminological homonymy of the domain-specific language. We say that two sets of words are terminological homonyms iff they include vocabulary terms which are homonyms. This fact causes generation of several ontology objects simultaneously associated with these sets. This homonymic limit HomLim is the same for every rule. Now the termination property can be formulated as follows: if rule agents can not produce information more than the homonymic limit then the system stops."
    }, {
      "heading" : "4 Using SPIN for model checking MDA",
      "text" : "For formal model checking of our multi-agent data analysis system we choose popular and well-developed model checking tool SPIN[8]. We have tried NuSMV model checker also, but have found that its input language is not fit to our multi-agent model because a lot of arrays in the model make the corresponding NuSMV-model very complicated. For verification SPIN requires a model of the system written on SPIN input language Promela with model properties expressed in linear time logic LTL.\nSPIN deals with finite data only. The previous section justifies the following simplification of the original model of data analysis: (1) as input data for analysis we consider finite sets of integers from a bounded integer interval; (2) attribute values of class and relation instances of an ontology are integers; (3) the result of rule agent actions is tuples of integers as attribute values for information agents. Thus\n2For example, to “Conference Topics” in calls for papers for conferences.\nin this simplified model of protocols above it does not matter what exact values are processed by our agents. We are only interested in verification of termination, operability and correctness of termination detection.\nFor the Promela model specification we define agent processes InstAgent, RelAgent, RulAgent and Controller corresponding to agents of the model above. Agents are instances of processes of the corresponding type. Controller is the main process which run all other processes at the beginning. SPIN assigns unique identification number pid to every process. Further we describe some features of these processes.\n(1) Structures of processes. These structures are based on definitions of agents from 2. They include Promela structures with fields containing integer arrays. For example, the following code is a part of an instance agent definition:\nproctype ins_agent(){\nbyte id;\nd_step{\nINS_AGENT[INS_AGENT_COUNT] = _pid;\nINS_AGENT_COUNT = INS_AGENT_COUNT + 1;\nid = INS_AGENT_COUNT; // unique agent identifier\n}\nint Class; // class of the agent\nint RuleOut[MAX_RULE_OUT]; // rules Rul\nAttribute attrs[MAX_ATTR]; // attributes of the agent\nRelation Relations[NUM_INS]; // relations of the agent\nMessagetoRule toRule;\n...\n(2) Types of communicating messages. They are different for different process types and also implemented as Promela structures with fields containing integers and integer arrays. The following code demonstrates messages to an instance agent and to a rule agent:\ntypedef MessagetoIns{\nint name; // name of the sender\nint id; // name of the relation instance (if any)\nint vals_id; // name of the attribute (if any)\nint vals_value; // value of the attribute (if any)\n}\ntypedef MessagetoRule{\nmtype type; // { Agent, Attribute, Relation }\nint name; // name of the sender\nint val; // value of the attribute or name of the relation instance\n}\n...\n(3) Agents initialization. We assign initial data to information agents which imitates a result of work of the external module for preliminary data analysis. We implement this initialization depending on number pid. This number defines a class of an agent, its outcoming rules Rul and Ruli for every\nattribute ai (see the definition of information agents), and its evaluated attributes. The following code is the example of an instance agent initialization:\nActive = 0; // agent activity\nClass = id;\nfor (i : 0 .. id-1 ) { RuleOut[i] = i+1; } // rules Rul\nfor (i : 0 .. 2*id-1) {\nattrs[i].RuleOut[0] = i/2+1; // rules of attributes\nif\n:: (i%2 == 0) ->\nattrs[i].values[0] = i/2+1; // values of attributes\nattrs[i].values_count = 1;\n:: else -> skip;\nfi;\n}\nfor (i : 0 .. id-1 ) { Relations[i].name = i+1; } // relations\n...\n(4) Agent actions. They are based on the protocols above and include message passing and agents’ data updating. Rule agents also create argument vectors and compute the result for information agents which models rules of data processing and ontology population. Actions of information agents and the controller can be translated to Promela almost directly from protocols of the previous section. Subprocesses of each rule agent correspond to consuming input information and producing output information. Function make arg of a rule agent defines a position of incoming data in a vector of arguments with respect to the rule agent definition. This function forms the next data (a set of argument vectors) for processing in function make res that imitates using rules of forming results by input data that depend on the structure of these data and the ontology. Here this imitation depends on input argument values and pid of the rule-process. These parameters are used to define: (1) consistency of an argument vector; (2) quantity and numbers of instance agents, their attributes, that must be updated and values of these attributes; (3) quantity and numbers of relation agents, their instances that must be updated or added, elements of the relation to be changed and their new values. All imitation function are very simple because they are just intended to simulate a linear computation time of real functions for making results to send. Note that function make arg has an exponential time complexity. The following code simulates generating a new attribute value for an instance agent:\nproctype rule_agent(){ // start consuming subprocess\nbyte id; // unique agent identifier\n... ...\nrun rule_agent_out(_pid, id); // start producing subprocess instance\n... ...\nfor(i: id .. 2*id-1){\nmti.vals_id = id+1; // name of the updated attribute\nmti.vals_value = argV[i].val; // new attribute value\ntoController ! ( 1 ); // info for controller\ntoInsAgent[ argV[i].name ] ! ( mti ); // send the new value\n}\n... ...\n}\nLet us express properties of the model to be verified. Let every agent A ∈ IA∪RlA∪RA (not the controller) have a special boolean activity status A.active, whose value is true when the agent does something useful (sends or processes messages) and f alse when the agent just waits for messages and does nothing else. Thus the controller correctness property can be expressed in LTL as\nG(Act = 0 → ∧\nA∈IA∪RlA∪RA\nA.active = f alse)\n. Initially its value is f alse and after the first message it becomes true. The operability property can be expressed as\nF( ∨\nI∈IA\nI.was upd = true)∨ ( ∨\nRl∈RlA\nRl.was upd = true)),\nwhere A.was upd is a boolean variable recording that agent A has updated its attribute, i.e. initially it is set to f alse and after the first attribute update it becomes true.\nThe termination property is expressed in LTL as\nG( ∧\nR∈RA\nR.gen < R.pnt ·HomLim)→ F( ∧\nA∈IA∪RlA∪RA\nA.active = f alse),\nwhere R.gen is the number of new information agents generated by rule agent R, R.pnt is the number of position points corresponding to these generations."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In the paper we suggest the approach to verification of the multi-agent data analysis algorithm for ontology population. A means of verification is model checking tool SPIN and properties of the system are expressed by LTL-formulas. We simulate our model in SPIN for fifty main agents and the agent-controller (138130 steps). SPIN appears to be able to make exhaustive verification of termination correctness and operability properties for twelve main agents, and bitstate verification for eighteen main agents. The latter verification required 25 minutes of a computer with an Intel Celeron(R) CPU running at 2.6 GHz and about 1 GByte of RAM. Both properties are satisfied in this model. The termination property have not verified yet.\nAt this stage of our research we do not handle competition and cooperation of instance agents for resolving ambiguities. We plan to enrich the agents with abilities for these kinds of interactions, to develop ambiguity resolving algorithms and to verify their properties such as termination, correctness of interactions etc."
    } ],
    "references" : [ {
      "title" : "Multi-Agent Systems for Natural Language Processing",
      "author" : [ "V.L.S. de Lima A.M.B.R. Carvalho", "D.S. de Paiva" ],
      "venue" : "Proceedings of the II Iberoamerican Workshop on D.A.I. and M.A.S,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1998
    }, {
      "title" : "A Multi-Agent System for Natural Language Understanding",
      "author" : [ "M.M. Aref" ],
      "venue" : "Proc. of International Conference on Integration of Knowledge Intensive Multi-Agent Systems,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2003
    }, {
      "title" : "Multi-agent systems for ontology-based information retrieval",
      "author" : [ "R. Aldea L. Banares-Alcantara", "R. Jimenez" ],
      "venue" : "Proc. of European Symposium on Computer-Aided Chemical Engineering-15",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2005
    }, {
      "title" : "Study of Multi-Agent Information Retrieval Model in Semantic Web",
      "author" : [ "X. Yang T. Cheng", "Y. Xie" ],
      "venue" : "Proc. of the 2008 International Workshop on Education Technology and Training and 2008 International Workshop on Geoscience and Remote Sensing (ETTANDGRS’08),",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2008
    }, {
      "title" : "A Multi-Agent System for Distributed Information Retrieval on the World Wide Web",
      "author" : [ "K.L. Lazarou V.S. Clark" ],
      "venue" : "Proc. of the 6th Workshop on Enabling Technologies on Infrastructure for Collaborative Enterprises,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1997
    }, {
      "title" : "A Distributed Multi-Agent Architecture for Natural Language Processing",
      "author" : [ "C. Tasso D. Fum", "G. Guida" ],
      "venue" : "Proc. of the 12th conference on Computational linguistics (COLING ’88),",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1988
    }, {
      "title" : "A Multi-agent Approach to Unstructured Data Analysis Based on Domain-specific Onthology",
      "author" : [ "N. Bodin E. Garanina", "E. Sidorova" ],
      "venue" : "Proc. of the 22nd International Workshop on Concurrency, Specification and Programming,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2013
    }, {
      "title" : "Spin Model Checker, the: Primer and Reference Manual, first edition",
      "author" : [ "G.J. Holzmann" ],
      "venue" : null,
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2003
    }, {
      "title" : "Creating Contract Templates for Car Insurance Using Multi-agent Based Text Understanding and Clustering",
      "author" : [ "I. Skobelev P. Volman S. Minakov", "G. Rzevski" ],
      "venue" : "Proc. of Holonic and Multi-Agent Systems for Manufacturing, Third International Conference on Industrial Applications of Holonic and Multi-Agent Systems,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2007
    }, {
      "title" : "A Multi-Agent Approach to Question Answering",
      "author" : [ "P. Quaresma" ],
      "venue" : "Proc. of Computational Processing of the Portuguese Language: 7th International Workshop,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "For checking these properties we choose model checking tool SPIN [8].",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 1,
      "context" : "In particular, it is used for natural language processing [2, 1, 10, 6] and web processing [3, 4, 5].",
      "startOffset" : 58,
      "endOffset" : 71
    }, {
      "referenceID" : 0,
      "context" : "In particular, it is used for natural language processing [2, 1, 10, 6] and web processing [3, 4, 5].",
      "startOffset" : 58,
      "endOffset" : 71
    }, {
      "referenceID" : 9,
      "context" : "In particular, it is used for natural language processing [2, 1, 10, 6] and web processing [3, 4, 5].",
      "startOffset" : 58,
      "endOffset" : 71
    }, {
      "referenceID" : 5,
      "context" : "In particular, it is used for natural language processing [2, 1, 10, 6] and web processing [3, 4, 5].",
      "startOffset" : 58,
      "endOffset" : 71
    }, {
      "referenceID" : 2,
      "context" : "In particular, it is used for natural language processing [2, 1, 10, 6] and web processing [3, 4, 5].",
      "startOffset" : 91,
      "endOffset" : 100
    }, {
      "referenceID" : 3,
      "context" : "In particular, it is used for natural language processing [2, 1, 10, 6] and web processing [3, 4, 5].",
      "startOffset" : 91,
      "endOffset" : 100
    }, {
      "referenceID" : 4,
      "context" : "In particular, it is used for natural language processing [2, 1, 10, 6] and web processing [3, 4, 5].",
      "startOffset" : 91,
      "endOffset" : 100
    }, {
      "referenceID" : 8,
      "context" : "To the best of our knowledge a similar approach is introduced in [9] only.",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 0,
      "context" : "},”The 1st Workshop on Logics and Model-Checking for Self-* Systems”, [1,10]), .",
      "startOffset" : 70,
      "endOffset" : 76
    }, {
      "referenceID" : 9,
      "context" : "},”The 1st Workshop on Logics and Model-Checking for Self-* Systems”, [1,10]), .",
      "startOffset" : 70,
      "endOffset" : 76
    }, {
      "referenceID" : 0,
      "context" : "}; {[1,10], [13,15]}; {(Venue,1),(OrganizedBy, / 0), .",
      "startOffset" : 4,
      "endOffset" : 10
    }, {
      "referenceID" : 9,
      "context" : "}; {[1,10], [13,15]}; {(Venue,1),(OrganizedBy, / 0), .",
      "startOffset" : 4,
      "endOffset" : 10
    }, {
      "referenceID" : 0,
      "context" : "• Rl1 = (1; Venue; {(1, 2, {[1,10], [13,17]})1}; / 0; {[1,10], [13,17]}).",
      "startOffset" : 28,
      "endOffset" : 34
    }, {
      "referenceID" : 9,
      "context" : "• Rl1 = (1; Venue; {(1, 2, {[1,10], [13,17]})1}; / 0; {[1,10], [13,17]}).",
      "startOffset" : 28,
      "endOffset" : 34
    }, {
      "referenceID" : 0,
      "context" : "• Rl1 = (1; Venue; {(1, 2, {[1,10], [13,17]})1}; / 0; {[1,10], [13,17]}).",
      "startOffset" : 55,
      "endOffset" : 61
    }, {
      "referenceID" : 9,
      "context" : "• Rl1 = (1; Venue; {(1, 2, {[1,10], [13,17]})1}; / 0; {[1,10], [13,17]}).",
      "startOffset" : 55,
      "endOffset" : 61
    }, {
      "referenceID" : 6,
      "context" : "send STOP to all; The following proposition is straight consequence of Proposition 1 from [7]: Proposition 1 Multi-agent system MDA terminates and the agent-controller determines the termination moment correctly.",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 6,
      "context" : "The proposition is proved in [7].",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 7,
      "context" : "For formal model checking of our multi-agent data analysis system we choose popular and well-developed model checking tool SPIN[8].",
      "startOffset" : 127,
      "endOffset" : 130
    } ],
    "year" : 2014,
    "abstractText" : "The paper presents an approach to verification of a multi-agent data analysis algorithm. We base correct simulation of the multi-agent system by a finite integer model. For verification we use model checking tool SPIN. Protocols of agents are written in Promela language and properties of the multiagent data analysis system are expressed in logic LTL. We run several experiments with SPIN and the model.",
    "creator" : "LaTeX with hyperref package"
  }
}