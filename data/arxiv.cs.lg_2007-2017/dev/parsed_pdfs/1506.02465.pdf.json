{
  "name" : "1506.02465.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "ASlib: A Benchmark Library for Algorithm Selection",
    "authors" : [ "Bernd Bischl", "Pascal Kerschke", "Lars Kotthoff", "Marius Lindauer", "Yuri Malitsky", "Alexandre Fréchette", "Holger Hoos", "Frank Hutter", "Kevin Leyton-Brown", "Kevin Tierney", "Joaquin Vanschoren" ],
    "emails" : [ "bernd.bischl@stat.uni-muenchen.de", "kerschke@uni-muenster.de", "larsko@cs.ubc.ca", "lindauer@cs.uni-freiburg.de", "yuri.malitsky@gmail.com", "afrechet@cs.ubc.ca", "hoos@cs.ubc.ca", "fh@cs.uni-freiburg.de", "kevinlb@cs.ubc.ca", "tierney@dsor.de", "j.vanschoren@tue.nl" ],
    "sections" : [ {
      "heading" : null,
      "text" : "The task of algorithm selection involves choosing an algorithm from a set of algorithms on a per-instance basis in order to exploit the varying performance of algorithms over a set of instances. The algorithm selection problem is attracting increasing attention from researchers and practitioners in AI. Years of fruitful applications in a number of domains have resulted in a large amount of data, but the community lacks a standard format or repository for this data. This situation makes it difficult to share and compare different approaches effectively, as is done in other, more established fields. It also unnecessarily hinders new researchers who want to work in this area. To address this problem, we introduce a standardized format for representing algorithm selection scenarios and a repository that contains a growing number of data sets from the literature. Our format has been designed to be able to express a wide variety of different scenarios. Demonstrating the breadth and power of our platform, we describe a set of example experiments that build and evaluate algorithm selection models through a common interface. The results display the potential of algorithm selection to achieve significant performance improvements across a broad range of problems and algorithms.\nKeywords: algorithm selection, machine learning, empirical performance estimation\nEmail addresses: bernd.bischl@stat.uni-muenchen.de (Bernd Bischl), kerschke@uni-muenster.de (Pascal Kerschke), larsko@cs.ubc.ca (Lars Kotthoff), lindauer@cs.uni-freiburg.de (Marius Lindauer), yuri.malitsky@gmail.com (Yuri Malitsky), afrechet@cs.ubc.ca (Alexandre Fréchette), hoos@cs.ubc.ca (Holger Hoos), fh@cs.uni-freiburg.de (Frank Hutter), kevinlb@cs.ubc.ca (Kevin Leyton-Brown), tierney@dsor.de (Kevin Tierney), j.vanschoren@tue.nl (Joaquin Vanschoren)\nPreprint submitted to Elsevier October 17, 2017\nar X\niv :1\n50 6.\n02 46\n5v 1\n[ cs\n.A I]"
    }, {
      "heading" : "1. Introduction",
      "text" : "Although NP-complete problems are widely believed to be intractable in the worst case, it is often possible to solve even very large instances of such problems that arise in practice. This is fortunate, because such problems are ubiquitous in artificial intelligence applications. There has thus emerged a large subfield of AI devoted to the advancement and analysis of heuristic algorithms for attacking hard computational problems. Indeed, quite surprisingly, this subfield has made consistent and substantial progress over the past few decades, with the newest algorithms quickly solving benchmark problems that were until recently beyond reach. The results of the international SAT competitions provide a paradigmatic example of this phenomenon. Indeed, the importance of this competition series has gone far beyond documenting the progress achieved by the SAT community in solving difficult and application-relevant SAT instances— it has been instrumental in driving research itself, helping the community to coalesce around a shared set of benchmark instances and providing an impartial basis for determining which new ideas yield the biggest performance gains.\nThe central premise of events like the SAT competitions is that the research community ought to build, identify and reward single solvers that achieve strong across-the-board performance. However, this quest appears quixotic: most hard computational problems admit multiple solution approaches, none of which dominates all alternatives across multiple problem instances. In particular, this fact has been observed to hold across a wide variety of AI applications, including propositional satisfiability (SAT) [106], constraint satisfaction (CSP) [70], AI planning [34], and supervised machine learning [92, 98]. An alternative is to accept that no single algorithm will offer the best performance on all instances, and instead aim to identify a portfolio of complementary algorithms and a strategy for choosing between them [76]. To see the appeal of this idea, consider the results of the sequential application (SAT+UNSAT) track of the 2014 SAT Competition.1 The best of the 35 submitted solvers, Lingeling ayv [7], solved 77% of the 300 instances. However, if we could somehow choose the best among these 35 solvers on a per-instance basis, we would be able to solve 92% of the instances.\nResearch on this algorithm selection problem [76] has demonstrated the practical feasibility of using machine learning for this task. In fact, although practical algorithm selectors occasionally choose suboptimal algorithms, their performance can get close to that of an oracle that always makes the best choice. The area began to attract considerable attention when methods based on algorithm selection began to outperform standalone solvers in SAT competitions [104]. Algorithm selectors have since come to dominate the state of the art on many other problems, including CSP [70], AI planning [34], Max-SAT [61], QBF [74], and ASP [25].\nTo date, much of the progress in research on algorithm selection has been\n1http://www.satcompetition.org/2014/results.shtml\ndemonstrated in algorithm competitions originally intended for non-portfoliobased (“standalone”) solvers. This has given rise to a variety of problems for the field. First, benchmarks selected for such competitions tend to emphasize problem instances that are currently hard for existing standalone algorithms (to drive new research on solving strategies) rather than the wide range of both easy and hard instances that would be encountered in practice (which would be appropriately targeted by researchers developing algorithm selectors). Relatedly, benchmark sets change from year to year, making it difficult to assess the progress of algorithm selectors over time. Second, although competitions often require entrants to publish their source code, none require entries based on algorithm selectors to publish the code used to construct the algorithm selector (e.g., via training a machine learning model) or to adhere to a consistent input format. Third, overwhelming competition victories by algorithm selectors can make it more difficult for new standalone solver designs to get the attention they deserve and can thus create resentment among solver authors. Such concerns have led to a backlash against the participation of portfolio-based solvers in competitions; for example, starting in 2013 solvers that explicitly combine more than two component algorithms have been excluded from the SAT competitions.\nThe natural solution to these problems is to evaluate algorithm selectors on their own terms rather than trying to shoehorn them into competitions intended for standalone solvers. This article, written by a large set of authors active in research on algorithm selectors, aims to advance this goal by introducing a set of specifications and tools designed to standardize and facilitate such evaluations. Specifically, we propose a benchmark library, called ASlib, tailored to the cross-domain evaluation of algorithm selection techniques. ASlib is based on a standardized data format specification (Section 3) that covers a wide variety of foreseeable evaluations. To date, we have instantiated this specification with benchmarks from six different problem domains, which we describe in Section 4. However, we intend for ASlib to grow and evolve over time. Thus, our article is accompanied by an online repository (http://aslib.net), which accepts submissions from any researcher. Indeed, there are already scenarios available online that were added after the ASlib release we describe in this paper.\nOur system automatically checks newly submitted datasets to verify that they adhere to the specifications and then provides an overview of the data, including the results of some straightforward algorithm selection approaches based on regression, clustering and classification. We provide some examples of these automatically-generated overviews and benchmark results in Sections 5 and 6. All code used to parse the format files, explore the algorithm selection scenarios and run benchmark machine learning models on them is publicly available in a new R package dubbed aslib.2\nOverall, our main objective in creating ASlib is the same as that of an algorithm competition: to allow researchers to compare their algorithms sys-\n2This package is currently hosted at https://github.com/coseal/aslib-r. We will submit it to the official R package server CRAN alongside the final version of this article.\ntematically and fairly, without having to replicate someone else’s system or to personally collect raw data. We hope that it will help the community to obtain an unbiased understanding of the strengths and weaknesses of different methodologies and thus to improve the current state of the art in per-instance algorithm selection."
    }, {
      "heading" : "2. Background",
      "text" : "Rice [76] was the first to formalize the idea of selecting among different algorithms on a per-instance basis. While he referred to the problem simply as algorithm selection, we prefer the more precise term per-instance algorithm selection, to avoid confusion with the (simpler) task of selecting one of several given algorithms to optimize performance on a given set or distribution of instances.\nDefinition 1 (Per-instance algorithm selection problem). Given a set I of problem instances and a distribution D over I, a space of algorithms A, and a performance measure m : I × A → R, the per-instance algorithm selection problem is to find a mapping3 s : I → A that optimizes Ei∼Dm(i, s(i)), the performance measure achieved by running the selected algorithm s(i) for instance i, in expectation across instances i ∈ I drawn from distribution D.\nThere are many ways of tackling per-instance algorithm selection and related problems in practice. However, almost all contemporary approaches use machine learning to build predictors of the behaviour of given algorithms as a function of instance features. This general strategy may involve a single learned model or a complex combination of several, which, given a new problem instance to solve, is used to decide which algorithm or which combination of algorithms to choose.\nGiven a portfolio of algorithms and a set of problem instances, building an algorithm selection model entails answering several questions, which we discuss in what follows."
    }, {
      "heading" : "2.1. What to select and when",
      "text" : "It is perhaps most natural to select a single algorithm for solving a given problem instance. This is used in the SATzilla [68, 104], ArgoSmArT [66], SALSA [19] and Eureka [17] systems, to name but a few examples. The main disadvantage of this approach is that there is no way of mitigating a poor selection—there is no way of recovering if the system chooses an algorithm that exhibits bad performance on the problem.\nAlternatively, we can seek a schedule that determines an ordering and time budget according to which we run all or a subset of the algorithms in the\n3In practice, the mapping s is often implemented by using so-called instance features, i.e., numerical characterizations of the instances i ∈ I. These instance features are then mapped to an algorithm using machine learning techniques. However, the computation of instance features incurs additional costs, which have to be considered in the performance measure m.\nportfolio; usually, this schedule is chosen in a way that reflects the expected performance of the given algorithms (see, e.g., [36, 47, 70, 74]). Under some of these approaches, the computation of the schedule is treated as an optimization problem that aims to maximize, e.g., the number of problem instances solved within a timeout. For stochastic algorithms, the further question of whether and when to restart an algorithm arises, opening the possibility of schedules that contain only a single algorithm, restarted several times (see, e.g., [16, 22, 30, 87]). Instead of performing algorithm selection only once before starting to solve a problem, selection can also be carried out repeatedly while the instance is being solved, taking into account information revealed during the algorithm run. Such methods monitor the execution of the chosen algorithm(s) and take remedial action if performance deviates from what is expected [23, 58, 62], or perform selection repeatedly for subproblems of the given instance [3, 55, 56, 78]."
    }, {
      "heading" : "2.2. How to select",
      "text" : "The kinds of decisions the selection process is asked to produce drive the choice of machine learning models that perform the selection. If only a single algorithm should be run, we can train a classification model that makes exactly that prediction. This renders algorithm selection conceptually quite simple—only a single machine learning model needs to be trained and run to determine which algorithm to choose (see, e.g., [27, 32, 63]).\nThere are alternatives to using a classification model to select a single algorithm to be run on a given instance, such as using regression models to predict the performance of each algorithm in the portfolio. This regression approach was adopted by early versions of SATzilla [68, 104], as well as by several other systems [65, 77, 80].\nOther approaches include the use of clustering techniques to partition problem instances in feature space and make decisions for each partition separately [48, 85], hierarchical models that make a series of decisions [37, 102], and costsensitive support vector machines [13]. The current version of SATzilla [105] uses cost-sensitive decision forests to determine the best algorithm for each pair of algorithms and selects the overall best by aggregating these “votes”."
    }, {
      "heading" : "2.3. Selection enablers",
      "text" : "In order to make their decisions, algorithm selection systems need information about the problem instance to solve and the performance of the algorithms in the given portfolio. The extraction of this information—the features used by the machine learning techniques used for selection—incurs overhead not required when only a single algorithm is used for all instances regardless of instance characteristics. It is therefore desirable to extract information as cheaply as possible, thus ensuring that the performance benefits of using algorithm selection are not outweighed by this overhead.\nSome approaches use only past performance of the algorithms in the portfolio as a basis for selecting the one(s) to be run on a given problem instance [23, 80, 86]. This approach has the benefit that the required data can be collected with\nminimal overhead as algorithms are executed. It can work well if the performance of the algorithms is similar on broad ranges of problem instances. However, when this assumption is not satisfied (as is often the case), more informative features are needed.\nTurning to richer instance-specific features, commonly used features include the number of variables of a problem instance and properties of the variable domains (e.g., the list of possible assignments in constraint problems, the number of clauses in SAT, the number of goals in planning). Deeper analysis can involve properties of graph representations derived from the input instance (such as the constraint graph [27, 59]) or properties of encodings into different problems (such as SAT features for SAT-encoded planning problems [21]).\nIn addition, features can be extracted from short runs of one or more solvers on the given problem instance. Examples of such probing features include the number of search nodes explored within a certain time, the fraction of partial solutions that are disallowed by a certain constraint or clause, the average depth reached before backtracking is required, or characteristics of local minima found quickly using local search. Probing features are usually more expensive to compute than the features that can be obtained from shallow analysis of the instance specification, but they can also be more powerful and have thus been used by many authors (see, e.g., [45, 69, 70, 73, 104]). For continuous blackbox optimization, algorithm selection can be performed based on Exploratory Landscape Analysis [13, 51, 65]. The approach defines a set of numerical features (of different complexities and computational costs) to describe the landscapes of such optimization problems. Examples range from simple features that describe the distribution of sampled objective values to more expensive probing features based on local search.\nFinally, in the area of meta-learning (learning about the performance of machine learning algorithms; for an overview, see, e.g, [15]), these features are known as meta-features. They include statistical and information-theoretical measures (e.g., variable entropy), landmarkers (measurements of the performance of fast algorithms [71]), sampling landmarkers (similar to probing features) and model-based meta-features [97]. These meta-features, and the past performance measurements of many machine learning algorithms, are available from the online machine learning platform OpenML [99]. In contrast to ASlib, however, OpenML is not designed to allow cross-domain evaluation of algorithm selection techniques."
    }, {
      "heading" : "2.4. Algorithm Selection vs. Algorithm Configuration",
      "text" : "A problem closely related to that of algorithm selection is the following algorithm configuration problem: given a parameterized algorithm A, a set of problem instances I and a performance measure m, find a parameter setting of A that optimizes m on I. While algorithm selection operates on finite (usually small) sets of algorithms, algorithm configuration operates on the combinatorial space of an algorithm’s parameter settings. General algorithm configuration methods, such as ParamILS [43], GGA [2], I/F-Race [9], and SMAC [41], have yielded substantial performance improvements (sometimes orders of magnitude\nspeedups) of state-of-the-art algorithms for several benchmarks, including SATbased formal verification [38], mixed integer programming [40], AI planning [95], and the combined selection and hyperparameter optimization of machine learning algorithms [92]. Algorithm configuration and selection are complementary since configuration can identify algorithms with peak performance for homogeneous benchmarks and selection can then choose between these specialized algorithms. Consequently, several possibilities exist for combining algorithm configuration and selection [1, 39, 48, 61, 103, 105]. The algorithm configuration counterpart of ASlib is AClib [44] (http://aclib.net). In contrast to ASlib, it is infeasible in AClib to store performance data for all possible parameter configurations, which often number more than 1050. Therefore, an experiment on AClib includes new (expensive) runs of the target algorithms with different configurations and hence, these experiments on AClib are a lot more costly than experiments on ASlib where no new algorithm runs are necessary.4\nThis concludes our discussion of the background. A full coverage of the wide literature on algorithm selection is beyond the scope of this article, but we refer the interested reader to recent survey articles on the topic [54, 79, 81]."
    }, {
      "heading" : "3. Summary of Format Specification",
      "text" : "We propose a data format specification for algorithm selection scenarios, i.e., instances of the per-instance algorithm selection problem. This format and the resulting data repository allow a fair and convenient scientific evaluation of and comparison between algorithm selectors.\nIn addition to the definition of the algorithm selection problem in Section 1, the format specification is tailored to the following generic approach to algorithm selection (Figure 1), where an algorithm has to be applied online to a new problem instance i ∈ I.\n1. A vector of instance features f(i) ∈ F of i is computed. Feature computation may occur in several stages, each of which produces a group of (one or more) features. Furthermore, later stages may depend on the results of earlier ones. Each feature group incurs a cost, e.g., runtime. If no features are required, the cost is 0 (this occurs, e.g., for variants of algorithm selection that compute static schedules). 2. A machine learning technique s selects an algorithm a∗ ∈ A based on the feature vector from Step 1. 3. The selected algorithm a∗ is applied to i.\n4. Performance measure m is evaluated, taking into account feature computation costs and the performance of the selected algorithm.\n4In algorithm configuration, this need for expensive runs indeed causes a problem for research. One way of mitigating it is offered by fast-to-evaluate surrogate algorithm configuration benchmarks [20].\n5. Some algorithm selectors do not select a single algorithm, but rather a schedule of algorithms: they apply a∗ to i for a resource budget r ∈ R (e.g., CPU time); evaluate the performance metric, which also indicates whether i was solved, and then apply another algorithm to i, based on observations made during the run of a∗.5\nThe purpose of our library is to provide all information necessary for performing algorithm selection experiments using the given scenario data. Hence, we do not need to actually run algorithms on instances, since all performance data is already precomputed. This drastically reduces the time required for executing studies, i.e., the runtime of experiments is now dominated by the time required for learning s and not by applying algorithms to instances (e.g., solving SAT problems). It also means that experimental results are perfectly reproducible; for example, the runtimes of algorithms do not depend on the hardware used; rather, they can be simply looked up in the performance data for a scenario.\nTable 1 introduces the basic structure of our format definition; the complete specification with all details can be found in an accompanying technical report [10] and on our online platform.\n5In principle, the workflow can be arbitrarily more complex, e.g., alternating between computing further features and running selected algorithms."
    }, {
      "heading" : "4. Algorithm Selection Scenarios Provided in ASlib Release 1.0.1",
      "text" : "The set of algorithm selection scenarios in release version 1.0.1 of our library, shown in Table 2, has been assembled to represent a diverse set of selection problem settings that covers a wide range of problem domains, types of algorithms, features and problem instances. Our scenarios include both problems that have been broadly studied in the context of algorithm selection techniques (such as SAT and CSP), as well as more recent ones (such as the container premarshalling problem). All of our scenarios were taken from publications that report performance improvements through algorithm selection and consist of\nalgorithms where the virtual best solver (VBS)6 is significantly better than the single best algorithm.7 Therefore, these are problems on which it makes sense to seek performance improvements via algorithm selection. All scenarios are available on our online platform (http://www.aslib.net/).\nThe scenarios we provide here are focused on constraint satisfaction problems, but we encourage readers to submit new scenarios. In the following, we briefly describe the scenarios we included and what makes them interesting."
    }, {
      "heading" : "4.1. SAT: propositional satisfiability",
      "text" : "The propositional satisfiability problem (SAT) is a classic NP-complete problem that consists of determining the existence of an assignment of values to variables of a Boolean formula such that the formula is true. It is widely studied, with many applications including formal verification [72], scheduling [18], planning [50] and graph coloring [96]. Our SAT data mainly stems from different iterations of the SAT competition,8 which is split into three tracks: industrial (INDU), crafted (HAND), and random (RAND).\nThe SAT scenarios are characterized by a high level of maturity and diversity in terms of their solvers, features and instances. Each SAT scenario involves a highly diverse set of solvers, many of which have been developed for several years. In addition, the set of SAT features is probably the best-studied feature\n6The VBS is defined as a solver that perfectly selects the best solver from a given set on a per-instance basis.\n7The single best algorithm has the best performance averaged across all instances. 8http://www.satcompetition.org/\nset among our scenarios; it includes both static and probing features that are organized into as many as ten different feature groups. The instance sets used in our various SAT scenarios range from randomly-generated ones to real-world instances submitted by the industry."
    }, {
      "heading" : "4.2. QBF-2011: Quantified Boolean Formula solver evaluation 2010",
      "text" : "A quantified Boolean formula (QBF) is a formula in propositional logic with universal or existential quantifiers on each variable in the formula. A QBF solver finds a set of variable assignments that makes the formula true or proves that no such set can exist. This is a PSPACE-complete problem for which solvers exhibit a wide range of performance characteristics. Our QBF-2011 data set comes from the QBF Solver Evaluation 20109 and consists of instances from the main, small hard, 2QBF and random tracks. The instance features and solvers are taken from the AQME system and described in more detail by Pulina et al. [74].\nAlthough the QBF scenario includes only five algorithms, this set is highly diverse. Our QBF solvers and instances are taken from a competition setting that was used to evaluate the performance of the solvers, similar to the SAT domain just described."
    }, {
      "heading" : "4.3. MAXSAT12-PMS",
      "text" : "MaxSAT is the optimization version of the previously introduced SAT problem, and aims to find a variable assignment that maximizes the number of satisfied clauses. The MaxSAT problem representation can be used to effectively encode a number of real-world problems, such as FPGA routing [101], and software package installation [4], among others, as it permits reasoning about both optimality and feasibility. This particular scenario focuses on the partial MaxSAT (PMS) problem [8].\nThis scenario is composed of a collection of random, crafted and industrial instances from the 2012 MaxSAT Evaluation [5], which makes it especially diverse in comparison to the other scenarios. The techniques used to solve the various instances in this scenario tend to be significantly different from each other, leading to a substantial performance gap between the best single solver and the virtual best solver. Furthermore, because there are only six solvers with very different performance characteristics, algorithm selection approaches must be very accurate in their choices, since any mistake is heavily penalized."
    }, {
      "heading" : "4.4. CSP-2010: Lazy learning in constraint solving",
      "text" : "Constraint programming [88] is concerned with finding solutions to constraint satisfaction problems—a task that is NP-complete. Learning in the context of constraint solving is a technique by which previously unknown constraints that are implied by the problem specification are uncovered during search and subsequently used to speed up the solving process.\n9http://www.qbflib.org/index_eval.php\nThe scenario contains only two solvers: one that employs lazy learning [27, 29] and one that does not [28]. The data set is heavily biased towards the nonlearning solvers, such that the baseline (the single best algorithm) is very good already. Improving on this is a challenging task and harder than in many of the other scenarios. Furthermore, both solvers share a common core, which results in a scenario that directly evaluates the efficacy of a specific technique in different contexts."
    }, {
      "heading" : "4.5. PROTEUS-2014",
      "text" : "The PROTEUS scenario, stemming from [37], includes an extremely diverse mix of well-known CSP solvers alongside competition-winning SAT solvers that have to solve (converted) XCSP instances10. The SAT solvers can accept different conversions of the CSP problem into SAT (see, e.g., [57, 89, 90]), which in our format are provided as separate algorithms. Indeed, this scenario is the only one in which solvers are tested with varying “views” of the same problem. Furthermore, the features of this scenario are also unique in that they include both the SAT and CSP features for a given instance. This potentially provides additional information to the selection approach that would normally not be available for solving CSPs. An algorithm selection system has a very high degree of flexibility here and may choose to perform only part of the possible conversions, thereby reducing the set of solvers and features, but also reducing the overhead of performing the conversions and feature computations. There are also synergies between feature computation and algorithm runs that can be exploited, e.g., if the same conversion is used for feature computation and to run the chosen algorithm then the cost of performing the conversion is only incurred once. In other cases, where features are computed on one representation and another one is solved, conversion costs are incurred both during feature computation and the running of the algorithm."
    }, {
      "heading" : "4.6. ASP-POTASSCO: Answer Set Programming",
      "text" : "Answer Set Programming (ASP, [6, 24]) is a form of declarative programming with roots in knowledge representation, non-monotonic reasoning and constraint solving. In contrast to many other constraint solving domains (e.g., the satisfiability problem), ASP provides a rich yet simple declarative modeling language in which problems up to ∆p3 (disjunctive optimization problems) can be expressed. ASP has proven to be efficiently applicable to many real-world applications, e.g., product configuration [83], decision support for NASA shuttle controllers [67], synthesis of multiprocessor systems [46] and industrial team building [31].\nIn contrast to the other scenarios, the algorithms in the ASP scenario were automatically constructed by an adapted version of Hydra [103], i.e., the set of algorithms consists of complementary configurations of the solver clasp [26]. The instance features were also generated by a light-weight version of clasp, including\n10The XCSP instances are taken from http://www.cril.univ-artois.fr/~lecoutre/ benchmarks.html as described in [37].\nstatic and probing features organized into feature groups; they were previously used in the algorithm selector claspfolio [25, 35]."
    }, {
      "heading" : "4.7. PREMARSHALLING-ASTAR-2013: Container pre-marshalling",
      "text" : "The container pre-marshalling problem (CPMP) is an NP-hard container stacking problem from the container terminals literature [84]. We constructed an algorithm selection scenario from two recent A* and IDA* approaches for solving the CPMP presented in [94], using instances from the literature. The scenario is described in detail in [93].\nThe pre-marshalling scenario differs from other scenarios in particular because of its highly homogeneous set of algorithms. All of the algorithms are parameterizations of a single symmetry breaking heuristic, either using the A* or IDA* search techniques, which stands in sharp contrast to the diversity of solvers present in most other datasets. Furthermore, the features provided are new and not as well tested as in the other scenarios, perhaps more accurately resembling the features that would be created by domain experts on their first attempt at modeling a problem. Finally, the scenario represents a real-world, time-sensitive problem from the operations research literature, where algorithm selection techniques can have a large impact."
    }, {
      "heading" : "5. Automated Exploratory Data Analysis",
      "text" : "The online platform for our data repository does not only offer the scenario data files themselves, it also provides many tables and figures that summarize them. These pages are automatically generated and currently consist (among others) of the following parts:\n• an overview table that describes all available scenarios by listing, e.g., the number of instances, algorithms and features, similar to Table 2;\n• a summary of the algorithms’ performance and run status data;\n• a summary of the feature values, as well as the run status and costs of the feature steps;\n• benchmark results for standard machine learning models for each scenario; see Section 6.\nPresenting this additional data offers the following advantages:\n• Researchers can quickly understand which scenarios are available and select those best suited to their needs.\n• Data can be sanity-checked by eye-balling. It is common that data collection errors occur when scenario data is gathered and submitted for the first time.\n• Interesting or challenging properties of the data sets become visible, providing the researcher with a quick and informative first impression.\nThe summary page for the algorithms starts with a table listing simple statistics regarding their performance (e.g., mean values and standard variations) and run status (e.g., how many runs were successful or not). We also indicate whether one algorithm is dominated by another,11 which is useful, because there is no reason to include a dominated algorithm in a portfolio. Various visualizations, such as box plots, scatter plot matrices, correlation plots and density plots enable further inspection of the distribution and correlation between algorithms, allowing the reader to better understand the strengths and weaknesses of each algorithm. For display, we impute high values for the missing performance values corresponding to failed runs so that they are clearly visible rather than silently discarded. All of our plots can be configured to use log scales, which often improves visual understanding when all data are non-negative.\nFigure 2 shows boxplots and cumulative distribution functions for the algorithms in the QBF-2011 scenario. Such plots allow the detection of mean location, distribution spread, density multimodality and whether the densities are roughly normally distributed. In addition, they reveal how long it took an algorithm to solve the given instances. For example, for the QBF-2011 scenario in Figure 2, one can see that the algorithm quantor finds a solution very quickly on a few instances, i.e., it solves approximately 5% of the instances nearly instantaneously. However, if it does not succeed quickly, it often does not succeed at all—it solved less than 30% of all the instances. In contrast, sSolve usually\n11An algorithm a1 dominates another algorithm a2 if and only if a1 has performance at least equal to that of a2 on all instances, and a1 outperforms a2 on at least one instance.\nX2clsQ\n1e−06 1e+02\n●● ●\n●● ●\n● ●●\n●● ●\n●\n● ● ● ● ●\n●\n●● ●\n●\n● ●●\n●●\n●\n●●\n●\n●\n● ● ●\n● ● ●\n●●\n●\n●\n●\n● ●\n●\n●\n●●● ●\n●\n●\n●\n● ●\n●\n●● ●\n●● ● ● ●\n● ●\n●\n●●\n● ●\n●\n● ● ●\n● ●●●\n●● ●●●●\n● ● ●\n● ●\n● ● ● ● ●● ● ● ● ●\n●\n●●● ●\n● ●●●\n●●\n●●\n●●\n● ●● ●●● ●● ●\n●\n● ●●● ● ●\n●\n●\n●\n● ●\n●\n●\n● ●\n●● ●\n●\n● ●●\n●●\n●●● ●●● ● ●\n●\n● ● ●\n●● ●\n●\n●●\n●● ●\n●●● ●\n●\n● ●●\n●\n● ●●\n●\n●\n●\n● ●\n● ● ● ● ●● ●● ●●● ● ●● ●\n● ● ●\n●\n● ●●\n●\n● ●●\n● ● ● ● ●\n● ● ●● ●\n●\n●●● ●\n●\n●\n●\n●\n● ●● ●● ●\n●\n● ● ● ●● ●\n1e−06 1e+02\n● ●●●●●●●●\n●●●● ●\n● ●●●\n●●\n●●\n●\n●\n● ●● ●\n●\n●\n●\n● ●\n● ●\n● ●\n●\n●\n● ●\n● ●●\n●\n● ●\n●\n● ●●\n● ●● ●\n●\n●\n●\n●\n● ● ●● ●● ●\n●\n●● ●● ●● ●\n● ● ● ●●\n● ●\n●\n● ●\n●●● ● ●\n●\n● ● ● ●●\n● ●●● ●● ●\n●● ●\n●●\n●\n● ● ● ● ●●\n● ●\n●\n● ●\n● ● ●\n●\n●\n●● ● ●\n●● ●●● ●\n1e −\n06 1e\n+ 02●●\n●●● ●\n● ●●\n●●\n●●●\n●\n●●\n● ● ●\n●●\n●\n●\n●\n●●\n●\n● ●\n●\n● ●● ● ● ● ● ● ● ● ● ● ●● ● ●\n● ●\n●\n● ●●\n●●\n●●\n● ● ●\n●\n●\n●\n●\n●●\n●● ● ●\n●\n● ●● ● ● ● ●\n● ●● ●\n● ● ●\n●\n●\n●\n●\n●● ● ●\n●\n●\n●\n●● ●●\n●● ●● ● ●●\n●●● ●●●\n● ●● ●●\n●\n● ● ● ●●\n●●\n●\n● ●\n● ●● ●\n●\n1e −\n06 1e\n+ 02 ●\n●\n●\n●●● ●●● ●●●●\n●\n● ●● ● ●●● ● ● ●\n●●\n● ●●\n●●\n●\n●\n●●\n● ● ●●\n●●\n● ●\n●\n●\n●\n●\n●\n●● ●\n●\n●\n●\n● ●●\n●\n●\n●●\n●\n●\n●\n●\n●\n●\n●\n●\n● ● ●\n●\n● ● ● ● ● ●●● ●● ● ● ●●\n●\n● ● ●● ●●● ●\n●●\n●\n● ●●\nquantor\n●\n●\n●\n●●●● ● ● ● ●\n●\n●\n●\n● ●\n●\n●\n●\n●●\n●\n●\n●\n●\n●\n●\n●●● ● ●\n●\n●● ●\n●●\n●●●\n●\n● ●\n●\n● ● ●\n●● ●●\n● ●\n● ●\n●\n●\n●\n● ●\n●\n●\n●\n●\n●\n● ●● ● ●\n●\n●\n●\n● ●\n● ●\n● ●\n● ●●●● ●●● ●● ●● ●●● ●●●\n●● ● ●\n●●\n● ●\n●● ●\n●\n● ●\n● ●\n●\n●\n● ●●●●\n● ●●●\n●\n● ● ●\n●●●●●● ● ● ● ● ●●● ● ●\n●\n●●●\n●\n●●\n●\n●\n●● ● ● ● ●●●\n●\n●●\n● ●●\n●● ●\n●\n●\n●\n●\n● ●\n●\n●\n●\n● ●\n●● ● ● ● ●●●\n● ● ●\n●●\n●\n●\n●\n●\n●\n●●\n●\n●● ●●\n● ● ●●●●\n●●● ● ●● ●● ● ●\n●\n●\n●● ●\n●\n●\n●\n● ●\n●● ●●●● ● ●● ●\n● ● ● ●●\n●\n● ●\n●\n●\n●\n●\n●\n●●\n●\n●●\n●●●\n●● ●\n●●●●\n●\n●\n●● ●●\n●\n●\n●\n● ● ●\n●\n●●\n● ●\n●\n●\n●\n● ● ●\n●\n●\n●\n●\n●\n●\n●\n●\n● ●\n● ●\n● ● ●\n●\n●●\n●\n● ●\n●\n●\n● ●\n●●● ●● ●● ●●●●\n●\n●\n●\n● ●\n● ● ●● ●\n● ●\n● ●●●●\n●\n●●●● ●●●● ● ● ●●● ● ●\n●\n●\n● ●\n●\n●\n●\n● ● ●\n● ●●\n●\n●●\n●\n● ●\n●\n●\n● ● ● ●●●\n●\n●● ●\n●●\n●●●● ● ●\n● ●\n●\n●\n●\n●\n●\n●\n●\n●\n● ● ●●●\n●● ● ●\n● ●\n●● ●\n● ● ● ●\n●\n●\n●●\n● ● ●●● ●\n●●\n●● ●\n● ● ●\n●\n●\n● ●\n●\n● ●●\n● ● ● ●\n●●● ●● ● ●●●●\n●\n● ●●●\n●\n● ● ●\n●\n● ● ● ●\n●\n●\n●\n●\n● ● ● ●\n●● ●\n●● ●●\n● ●●● ●\n●\n●\n●\n●\n●\n●\n●\n●\n●\n●\n●\n●● ●\n●\n● ●●\n●\n●●\n●\n●\n● ●●\n● ● ●\n●●\n●\n● ●●●\n●● ●●\n● ● ●\n●\n●\n●\n●\n●\n●\n● ●\n●\n●\n●\n● ● ● ●\n●\n●\n●\n●\n●●\n●\n● ●\n●\n●\n● ●●●\n●● ●\n● ● ● ●\n● ●● ● ● ● ●● ●●\n● ● ●\n●\n● ●\n●\n● ●\n●\n●\n●\n● ●\n●● ●● ● QuBE\n● ●●●●●●●●\n●●● ●●● ●● ●\n●\n●\n●\n● ●\n●\n● ●\n●●\n●\n●● ● ●\n● ● ● ● ● ●\n●\n●●\n●\n●\n●\n●\n● ● ● ●\n● ●●\n●\n●\n●● ●●\n●●\n● ●\n● ● ●● ● ●\n●\n● ●\n● ●\n● ●\n●\n● ●\n●\n●\n●\n●\n● ●\n●\n● ● ●\n●\n●\n●\n●\n● ●\n●\n●\n●\n●\n●\n● ● ● ● ●●\n●●\n● ●●●\n● ● ● ● ●●● ●\n● ●\n●\n●\n●● ● ●\n●\n●\n●\n●\n●\n●●\n●\n●\n●● ●●● ● ● ●●●\n●\n●\n●\n●●\n●\n●\n●● ●\n● ●●● ●\n● ●●\n1e −\n01 1e\n+ 03●●\n●●● ● ●●●● ●●●\n●\n●\n●\n●\n●\n●\n●\n●\n●\n●\n●●\n●\n●●\n● ●● ●\n●\n●\n● ● ● ●\n●\n●●\n●\n●●\n●\n●\n●●\n●●\n● ●\n●\n●\n● ● ●\n●\n●●●\n●\n●\n●\n●\n●\n●\n● ●\n●\n●\n●\n●\n● ●\n● ●\n●\n●\n● ●\n●\n●●\n●\n●\n●\n●\n●\n●\n●\n● ●● ● ●● ●●\n●\n●\n●\n● ●\n●● ● ● ●\n● ●\n●\n●\n●\n●●●\n● ●●● ●\n● ●\n●●\n●\n●\n●\n● ● ●\n●\n● ●● ● ● ●●●\n●\n●\n● ●\n●\n●\n●\n●\n●\n●\n●\n●\n●\n● ●\n●\n● ●●●\n●\n●\n●\n● ●●● ●● ●\n1e −\n06 1e\n+ 02\n●\n● ● ● ● ●● ●● ● ●● ● ● ●●● ● ●● ●●● ●● ● ●\n●\n●\n●\n●\n● ●\n●●\n● ● ●\n● ●\n●\n●\n● ●\n●\n●●\n● ●●● ● ● ●●● ●\n●\n●\n● ●\n●\n●●●\n●\n●\n●\n● ●●● ● ●\n●●\n● ●● ●\n●●\n● ●\n●\n●●●\n●\n●\n●\n●\n●●\n● ●●\n●● ●●●●\n●●● ●●\n●\n●\n●\n●\n●● ● ●\n● ●\n●\n● ● ●●\n●● ●●\n●\n●\n● ●\n●●●\n● ●\n● ● ● ● ●● ● ● ● ● ●●\n●● ●● ●\n● ●●\n● ●\n●\n● ● ●\n● ●●\n●\n●\n● ●\n●● ● ●●●\n●\n●● ●\n● ● ●●\n●\n●\n●\n●\n● ●\n●\n●\n●● ● ● ● ●● ● ●\n●● ●\n●● ●\n● ● ●\n●\n●\n●\n●\n● ● ●\n●●\n●●\n●●● ● ● ●\n●● ●\n●\n● ●\n●\n● ●\n●● ●\n●●●\n●\n●\n● ● ● ● ●● ●● ● ●● ●●● ●●● ● ● ● ●● ● ● ● ●● ● ●\n●\n● ●\n●\n●\n●● ● ● ● ●\n●\n● ●●\n●\n●●● ●\n●●\n● ●\n●\n●● ●●\n●●● ● ●● ● ● ● ●● ● ● ● ●\n● ●\n●\n●\n●\n● ● ●\n● ●\n●●\n● ● ●\n●\n●\n● ●\n●\n●● ●● ●\n●\n●\n●● ●●\n● ●\n●● ●●●● ●●●\n●●●● ●●● ● ●\n● ●● ●\n●\n●\n●\n●\n● ● ● ● ●\n● ●●● ● ●● ●●● ● ● ●\n●●\n●\n●\n●● ●\n● ●●●●\n●●●\nsKizzo ●\n● ● ● ● ●● ●●\n●● ●●●●● ● ●● ● ●\n●\n●●\n● ● ●\n●\n●\n● ● ●● ● ● ●●\n● ●●\n● ●\n● ●● ●●● ●● ●● ● ● ● ●\n●\n●\n●\n●\n● ●\n●● ●●●\n● ●\n● ●●\n●\n●\n●\n● ● ●\n● ●\n●●●● ●●●●● ●\n● ●●\n● ● ● ● ● ● ●● ●\n● ● ● ●\n● ●\n● ● ●\n●\n●\n●●\n●\n●\n●\n●\n●\n● ● ●\n● ●\n● ●\n●\n●● ●●\n● ●●\n●\n●\n●\n●●\n● ●\n●\n●\n●● ●●\n● ● ●\n●\n●\n●\n● ● ● ●●\n●●● ● ●\n●●\n1e−06 1e+02\n●●● ● ● ● ●●● ●●\n●●●●\n● ●\n●\n●\n● ●● ● ●\n● ● ●\n● ●\n●\n● ●\n● ●\n●\n●\n●\n●\n● ●\n●\n●\n●\n●\n●\n●\n● ●\n●\n●\n●●\n● ●\n●●\n●\n●●\n●\n●\n●\n●\n● ●\n● ● ● ● ●\n●\n●\n●\n●\n● ●\n●\n●\n●\n●\n● ●\n●\n● ● ●\n●\n● ● ●\n● ● ● ● ● ●● ● ●●● ● ●●● ● ●● ●\n●\n●● ●\n● ●\n●\n● ●\n●\n● ●\n● ●\n● ●\n●\n●\n●\n● ●\n● ● ●\n●\n●● ●●\n● ●\n●\n●●●●\n● ● ●\n●\n●\n●● ● ● ●●\n● ● ●\n●●\n●\n●\n●\n●\n●\n●\n●\n●\n●\n●\n●\n● ● ● ●\n●\n●\n●\n●\n● ●\n●\n●\n●\n●\n●\n●\n● ● ●\n●\n●\n●\n●\n● ●\n●\n●\n●\n●\n● ●● ● ●\n●\n● ●\n●\n●\n●\n●\n●\n●\n● ●\n●\n●●\n● ●\n●\n●\n●\n●●●●●●● ● ●●\n●\n●\n●\n●\n●\n●●\n●\n●\n●\n●\n●\n●\n●●● ●\n1e−01 1e+03\n●●● ● ● ● ●●●● ● ●●● ●● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ●●● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ●●● ●●● ●● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ●●● ● ●● ●\n● ●●●●●●●● ● ● ● ●●●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ● ● ● ● ● ● ● ● ● ● ● ●● ● ● ● ● ●● ● ● ● ● ● ● ●● ● ●● ● ● ● ●● ● ● ●● ● ● ● ● ● ● ●●● ● ● ● ●● ● ● ● ● ● ● ● ● ● ●\n1 50 5000\n1 50\n50 00\nsSolve\n−1\n−0.8\n−0.6\n−0.4\n−0.2\n0\n0.2\n0.4\n0.6\n0.8\n1\nqu an\nto r\nsK iz\nzo\nsS ol\nve\nX 2c\nls Q\nQ uB\nE\nquantor\nsKizzo\nsSolve\nX2clsQ\nQuBE\nFigure 3: Pairwise correlations among algorithms of the QBF-2011 scenario: A scatter plot matrix on a log scale (left) and the plot of a clustered correlation matrix (right).\nneeds longer to find a solution, but by the time it does, it is one of the best algorithms. Such behavior can indicate that the algorithm requires a ‘warm-up’ stage, which should be considered when deploying it.\nThe left panel of Figure 3 shows pairwise scatterplots of the QBF-2011 scenario, allowing an easy comparison of algorithm pairs on all instances from a given scenario. Each point represents a problem instance within the task, and from the location of the point cloud, one can see whether an algorithm is dominant over the majority of instances, or whether relative performance strongly varies between instances. The first case can be identified by a cloud that is located either in the upper-left or lower-right corner of a single scatterplot. In such a case, the dominated algorithm could be discarded from the portfolio. However, if this type of domination is not present, there is the potential to realize performance improvements by means of per-instance algorithm selection.\nBecause detecting correlation in algorithm performance is also of interest when analyzing the strengths and weaknesses of a given portfolio-based solver [106], we also present a clustered correlation matrix, cf. Figure 3 (right panel). Algorithms that have a (high) positive correlation are more likely to be redundant in a portfolio, whereas pairs with a (high) negative correlation are more likely to complement each other. Here, we calculate Spearman’s correlation coefficient between ranks. Blue boxes represent positive correlation, red boxes represent negative correlation, and shading indicates the strength of correlation. The algorithms are also clustered according to these values (using Ward’s method [100]) and then sorted, such that similar algorithms appear together in blocks. This\n−1\n−0.8\n−0.6\n−0.4\n−0.2\n0\n0.2\n0.4\n0.6\n0.8\n1 m\nin is\nat ps m rc l eb gl uc os e gl uc os e2 qu te rs at cr yp to m\nin is\nat 20 11 lrg ls hr gl ue m in is at lin ge lin g pr ec os at so l sp ea r− sw sp ea r− hw cl as p2 cl as p1 m xc 09 pi co sa t sa pp er lo t eb m in is at re st ar ts at sa tti m ep sa tim e1 1 sa tti m e ea gl eu p gn ov el ty p2 sp ar ro w tn m m ar ch rw m ph as eS AT 64 m ph as eS AT m m ph as eS AT\nminisatpsm rcl\nebglucose glucose2 qutersat\ncryptominisat2011 lrglshr\nglueminisat lingeling precosat\nsol spear−sw spear−hw\nclasp2 clasp1 mxc09 picosat sapperlot ebminisat restartsat sattimep satime11\nsattime eagleup gnoveltyp2 sparrow\ntnm marchrw\nmphaseSAT64 mphaseSATm\nmphaseSAT\nFigure 4: Clustered correlations for the SAT12-ALL scenario.\ntype of clustering allows the identification of algorithms with highly correlated performance.\nThe example given in Figure 4 (the plot of a correlation matrix of the SAT12ALL scenario) shows three groups of algorithms (minisatpsm to restartsat, sattimep to tnm and the three mphaseSAT -algorithms) with high correlations within each group. Also, the performance of marchrw is distinct from all the others. Hence, one might want to select a representative per group, reducing the size of the entire portfolio from 31 to four algorithms.\nAs we do with algorithm runs, we summarize the features e.g., by giving basic statistics of the feature values, and the run status and cost of the feature processing steps. Table 3 displays the summary of the feature steps for the SAT12-RAND scenario. In this scenario, all 115 features use the feature step ‘Pre’ as a requirement (since the first step is to preprocess the instance). While\nthis preprocessing step succeeded in all cases, one other step did not: the feature step ‘CG’ (which computes clause graph features) failed in 37.37% of cases due to exceeding time or memory limits, and even for instances where it succeeded, it was quite expensive (8.79 seconds on average). Such information is useful understanding feature behavior: e.g., how risky it is to compute a feature step; how much time must one invest in order to obtain the corresponding features?\nWe also check whether instances occur with exactly the same feature values, indicating that the experimenter might have erroneously run on the same instance twice.\nIt should be mentioned that all of the tables and figures presented, and additional ones, which we have omitted for space reasons, were automatically generated by our online platform, and are also accessible through the R package aslib. The functions are highly configurable, so users can use them for their own data exploration or publications and flexibly combine individual elements. For the future, we plan to extend our data analysis by additional techniques, such as further measures of algorithm performance [82]."
    }, {
      "heading" : "6. Basic Algorithm Selection Experiments",
      "text" : "In this section, we present exploratory benchmark experiments that give an indication of the diversity of our benchmarks. First, we evaluate the performance of basic algorithm selectors on our scenarios. We then perform a subset selection study to identify the important algorithms and instance features in each of the scenarios. We make no claim that the presented experimental settings are exhaustive or that we achieve state-of-the-art algorithm selection performance; rather, we provide baseline results that can be achieved by standard machine learning approaches for the core technology of an algorithm selection system—the\nselector itself. These results, and our framework in general, allow us to study which algorithm selection approaches work well for which of our scenarios.\nIn order to reach the performance of current state-of-the-art algorithm selection systems [64, 107], we would have to include various extensions, such as cost-sensitive classification and complementary techniques such as pre-solving.12\nWe use the LLAMA toolkit [53], version 0.8.1, in combination with the aslib package13 to run the algorithm selection experiments. LLAMA is an R [75] package that facilitates many common algorithm selection scenarios. In particular, it enables access to classification, regression, and clustering models for algorithm selection—the three main approaches we use in our experiments—from other R packages. As LLAMA does not include any machine learning algorithms, we use the mlr R package [12] as an interface to the machine learning models provided by other R packages. We parallelize all of our benchmark experiments through the BatchExperiments [11] R package.\nIn this paper, we only present aggregated benchmark results, but the interested reader can access full benchmark results at http://aslib.net. Our experiments are fully reproducible as the complete code to generate these results can be accessed in the Github repository mentioned earlier.\nPlease note that for some of the algorithm selection scenarios we have opted to use only a subset of feature processing groups (and their associated features) as recommended by authors of the scenarios; we did this because some feature steps are excessively expensive to calculate and have not fully proved their worth in selection models. Detailed information (e.g., the names of the feature processing groups we selected and their average costs) is provided on the ASlib webpage."
    }, {
      "heading" : "6.1. Data preprocessing",
      "text" : "Before running the experiments, we preprocessed the training data as follows. We removed constant-valued (and therefore irrelevant) features and imputed missing feature values as the mean over all non-missing values of the feature. We normalized the range of each feature to the interval [−1, 1]. While this is unnecessary for some machine learning approaches (e.g., decision trees), it is often helpful or mandatory for others (e.g., SVMs or clustering). Missing performance values were imputed using the timeout value for the data set.\nFor each problem instance, we calculated the feature computation cost based on the costs for the feature groups specified in the data. If the problem instance was solved during feature computation, we only considered the cost of the features up to the one that solved it. Furthermore, we set the runtime for all algorithms to zero for instances solved during feature computation. We added the feature\n12A pre-solver is a default solver that is run for a small amount of time without any algorithm selection taking place; cf. [104]. The problem instances that are solvable in this time are solved without incurring any of the overhead that algorithm selection brings, such as the computation of features. This is relevant in practice, as the cost of computing features can be much higher than the cost of solving a very easy instance.\n13https://github.com/coseal/aslib-r\ncosts computed in this way to the runtimes of the individual algorithms on the respective instances. Given these new runtimes, we checked whether the specified timeout was now exceeded by any algorithm and set the run status of the corresponding algorithm accordingly. Preprocessing runtimes to include feature computation time in this way allows us to focus on an algorithm selection system’s overall performance, and avoid overstating the fraction of instances that would be solved within a time budget in cases where features are expensive to compute.\nEach scenario specifies a partition into 10 folds for cross-validation to ensure consistent evalution across different methods. We also used this splitting in our experiments."
    }, {
      "heading" : "6.2. Experimental setup",
      "text" : "We consider three fundamentally different approaches to algorithm selection that have been studied extensively in the literature (cf. Section 2.2):\nThe specific machine learning algorithms we employed for our experiments are shown in Table 4. To provide a good baseline, they include representatives from\neach of the three major approaches above. We tuned the hyperparameters of ksvm and randomForest (classification and regression) with the listed parameter ranges, using random search with 250 iterations and a nested cross validation (with 3 internal folds) to ensure unbiased performance results. All other parameters were left at their default values. For the clustering algorithm, we set the (maximum) number of clusters to 30 after some preliminary experiments; the exact number of clusters was determined dynamically by XMeans."
    }, {
      "heading" : "6.3. Evaluation",
      "text" : "Each of the algorithm selection models was evaluated based on three different measures: the fraction of all instances solved within the timeout; the penalized average runtime with a penalty factor of 10 (PAR10: this means averaging runtimes with timeouts counting as 10 times the time budget); and the average misclassification penalty (which, for a given instance, is the difference between the performance of the selected algorithm and the performance of the best algorithm). The performance of each algorithm selection model was compared to the virtual best solver (VBS) and the single best solver. Note that the misclassification penalty for VBS is zero by definition. The single best solver is the (actual) solver that has the overall best performance on the data set. Specifically, we consider the solver with the best PAR10 score over all problem instances in a scenario.14"
    }, {
      "heading" : "6.4. Experimental results",
      "text" : "Figure 5 presents a summary of our experimental results. In most cases, the algorithm selection approaches performed better than the single best solver. We expected this, as all of our data sets came from publications that advocated algorithm selection systems.\nNevertheless, there were significant differences between the scenarios. While for most of them, almost all algorithm selection approaches outperformed the single best algorithm, there are some scenarios that seem to be much harder for algorithm selection. In particular, on the SAT11-INDU scenario, three approaches were not able to achieve a performance improvement and all other approaches (with the exception of random regression forests) improved only slightly.\nRandom regression forests stood out as quite clearly the best overall approach, yielding the best performance for 11 of the 13 datasets. This is in line with recent results showing the strong performance of this model for algorithm runtime prediction [45]. The results are also consistent with those of the original papers introducing the datasets. For example, Xu et al. [106] reported somewhat better results for the three SAT11 datasets than the one achieved here with our off-theshelf methods (which is to be expected since their latest SATzilla version used a cost-sensitive approach and pre-solving schedules).\n14The single best solvers determined according to the other evaluation measures described here are presented in the detailed experimental results on the ASlib web page; the results were qualitatively similar.\nXMeans performed worst on average. We suspect that the performance of clustering approaches is highly sensitive to the selection and normalization of instance features. On some scenarios, XMeans performed well; it was the best-performing approach on SAT12-RAND. However, on SAT11-INDU, SAT12INDU, and SAT12-ALL (which also partly consists of industrial SAT instances), XMeans performed worse than the single best solver. This leads us to suspect suspect that the default subset of instance features is not favorable for XMeans on industrial SAT instances."
    }, {
      "heading" : "6.5. Algorithm and Feature Subset Selection",
      "text" : "To provide further insights into our algorithm selection scenarios, we applied forward selection [52] to the algorithms and features to determine whether smaller subsets still achieve comparable performance. We performed forward search independently for algorithms and features for each scenario.\nThe process starts with the empty set and then greedily and iteratively adds the algorithm or feature to the set which most improves the cross-validated score (PAR10) of the predictor. The selection is terminated when the score does not improve by at least 1. In all other aspects, the experimental setup was the same as described before. As a prognostic model we used the random regression forest,15 as it was the best overall approach so far. We note that the selection results use normal resampling and not the nested version, which may result in overconfident performance estimates for the selected subsets [14]. We accept this caveat since our goal here is to study the ranking of the features and the size of the selected sets, and a more complex, nested approach would have resulted in multiple selected sets.\nTable 5 presents the results of forward selection for algorithms and features on all scenarios. Usually, the number of selected features is very small compared to the complete feature set. This is consistent with the observations of Hutter et al. (2013) who showed that only a few instance features are necessary to reliably predict the runtime of algorithm configurations. For example, on SAT12-RAND, the only three features selected were a feature based on survey propagation concerning the probability of variables to be unconstrained, and two balance\n15We used the random forest with default parameters, as the tuning was done for the full set of features and solvers.\nfeatures concerning the ratio of positive and negative (1) occurences of each variable and (2) literals in each clause.\nThe number of algorithms after forward selection is also substantially reduced on most scenarios. On the SAT scenarios, we expected to see this because the scenarios consider a huge set of SAT solvers that were not pre-selected in any way. Xu et al. (2012a) showed that many SAT solvers are strongly correlated (see Figure 4 in Section 5) and make only very small contributions to the VBS. For example on the SAT12-RAND scenario, only three solvers were selected: sparrow, eagleup, and lingeling. We did not expect the set of algorithms to be reduced on the ASP-POTASSCO scenario, as the portfolio was automatically constructed using algorithm configuration to obtain a set of complementary parameter settings that are particularly amenable to portfolios; indeed, forward selection kept as many as 8 of the 11 configurations.\nOur results indicate that in real-world settings, selecting the most predictive features and the solvers that make the highest contributions can be important. More detailed results can be found on the ASlib website."
    }, {
      "heading" : "7. Conclusion",
      "text" : "We have introduced ASlib, a benchmark library for algorithm selection, a rapidly growing field of research with substantial impact on various subcommunities in artificial intelligence. Release version 1.0.1 of the library comprises 12 algorithm selection scenarios from six different areas with a focus on (but not a limitation to) constraint satisfaction problems. We discussed the format of new algorithm selection scenarios and showed examples of the automated exploratory data analysis that will run for each new scenario submitted to our online platform http://aslib.net/. Finally, exploratory experiments with various simple types of algorithm selection systems on our 12 algorithm selection scenarios demonstrated that even simple algorithm selection systems can dramatically outperform the single best solver and confirmed that random forest models performed best overall. We achieved performance improvements over the best single solver on all data sets, often reducing penalized average runtime by a factor of 2 and in the best case by a factor of 3.\nASlib facilitates research on algorithm selection methods by providing a common set of benchmarks and tools for working with these. Similar to solver competitions, it enables principled comparative empirical performance assessment. It also considerably lowers the otherwise rather high barrier for researchers to work on algorithm selection, since anyone using the benchmark scenarios we provide does not have to perform actual runs of the solvers contained in them. Since our library provides performance data for the solvers and problem instances included in each selection scenario (which otherwise would have to be produced, at considerable computational cost, by anyone working with that scenario), using ASlib also substantially reduces the computational burden of performance assessments. The carefully selected set of scenarios included in release version 1.0.1 of ASlib challenge algorithm selection methods in various ways and thus provide a solid basis for developing and assessing such methods.\nFuture updates will ensure that ASlib remains useful as research on algorithm selection progresses."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank the creators of the algorithms and instance distributions used in our various algorithm selection scenarios. The performance of algorithm selection systems depends critically upon the ingenuity and tireless efforts of domain experts who continue to invent novel solver strategies."
    } ],
    "references" : [ {
      "title" : "MaxSAT by Improved Instance-Specific Algorithm Configuration",
      "author" : [ "C. Ansótegui", "Y. Malitsky", "M. Sellmann" ],
      "venue" : "in: Proceedings of the Twenty- Eighth National Conference on Artificial Intelligence",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2014
    }, {
      "title" : "A gender-based genetic algorithm for the automatic configuration of algorithms",
      "author" : [ "C. Ansótegui", "M. Sellmann", "K. Tierney" ],
      "venue" : "in: Proceedings of the Fifteenth International Conference on Principles and Practice of Constraint Programming",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2009
    }, {
      "title" : "Continuous search in constraint programming",
      "author" : [ "A. Arbelaez", "Y. Hamadi", "M. Sebag" ],
      "venue" : "in: Proceedings of the Twenty-Second IEEE International Conference on Tools with Artificial Intelligence,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2010
    }, {
      "title" : "Solving linux upgradeability problems using boolean optimization",
      "author" : [ "J. Argelich", "D.L. Berre", "I. Lynce", "J. Marques-Silva", "P. Rapicault" ],
      "venue" : "in: Proceedings of the International Workshop on Logics for Component Configuration,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2010
    }, {
      "title" : "Knowledge Representation, Reasoning and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2003
    }, {
      "title" : "Yet another local search solver and Lingeling and friends entering the SAT competition",
      "author" : [ "A. Biere" ],
      "venue" : "in: Proceedings of SAT Competition 2014: Solver and Benchmark Descriptions,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2014
    }, {
      "title" : "Empirical Methods for the Analysis of Optimization Algorithms. Springer. chapter F-race and iterated F-race: An overview",
      "author" : [ "M. Birattari", "Z. Yuan", "P. Balaprakash", "T. Stützle" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2010
    }, {
      "title" : "Algorithm Selection Format Specification",
      "author" : [ "B. Bischl", "L. Kotthoff", "M. Lindauer", "Y. Malitsky", "A. Frechétte", "H. Hoos", "F. Hutter", "P. Kerschke", "K. Leyton-Brown", "J. Vanschoren" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2014
    }, {
      "title" : "2015a. BatchJobs and BatchExperiments: Abstraction mechanisms for using R in batch environments",
      "author" : [ "B. Bischl", "M. Lang", "O. Mersmann", "J. Rahnenführer", "C. Weihs" ],
      "venue" : "Journal of Statistical Software",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2015
    }, {
      "title" : "Algorithm selection based on exploratory landscape analysis and cost-sensitive learning",
      "author" : [ "B. Bischl", "O. Mersmann", "H. Trautmann", "M. Preuss" ],
      "venue" : "in: Proceedings of the Fourteenth Annual Conference on Genetic and Evolutionary Computation,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2012
    }, {
      "title" : "Resampling methods for meta-model validation with recommendations for evolutionary computation",
      "author" : [ "B. Bischl", "O. Mersmann", "H. Trautmann", "C. Weihs" ],
      "venue" : "Evolutionary Computation",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2012
    }, {
      "title" : "Metalearning: Applications to Data Mining. 1 ed",
      "author" : [ "P. Brazdil", "C. Giraud-Carrier", "C. Soares", "R. Vilalta" ],
      "venue" : null,
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2008
    }, {
      "title" : "The max k-armed bandit: A new model of exploration applied to search heuristic selection",
      "author" : [ "V.A. Cicirello", "S.F. Smith" ],
      "venue" : "in: Proceedings of the Twentieth National Conference on Artificial Intelligence,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2005
    }, {
      "title" : "Maximizing the benefits of parallel search using machine learning",
      "author" : [ "D.J. Cook", "R.C. Varnell" ],
      "venue" : "in: Proceedings of the Fourteenth National Conference on Artificial Intelligence,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1997
    }, {
      "title" : "Experimental results on the application of satisfiability algorithms to scheduling problems",
      "author" : [ "J.M. Crawford", "A.B. Baker" ],
      "venue" : "Proceedings of the Twelfth National Conference on Artificial Intelligence,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1994
    }, {
      "title" : "Self-Adapting linear algebra algorithms and software",
      "author" : [ "J. Demmel", "J. Dongarra", "V. Eijkhout", "E. Fuentes", "A. Petitet", "R. Vuduc", "R.C. Whaley", "K. Yelick" ],
      "venue" : "Proceedings of the IEEE",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2005
    }, {
      "title" : "Efficient benchmarking of hyperparameter optimizers via surrogates",
      "author" : [ "K. Eggensperger", "F. Hutter", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "in: Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence (AAAI)",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2015
    }, {
      "title" : "Improved features for runtime prediction of domain-independent planners",
      "author" : [ "C. Fawcett", "M. Vallati", "F. Hutter", "J. Hoffmann", "H. Hoos", "K. Leyton-Brown" ],
      "venue" : "in: Proceedings of the International Conference on Automated Planning and Scheduling",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2014
    }, {
      "title" : "Learning restart strategies",
      "author" : [ "M. Gagliolo", "J. Schmidhuber" ],
      "venue" : "in: Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2007
    }, {
      "title" : "Adaptive online time allocation to search algorithms",
      "author" : [ "M. Gagliolo", "V. Zhumatiy", "J. Schmidhuber" ],
      "venue" : "in: Proceedings of European Conference on Machine Learning,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2004
    }, {
      "title" : "Answer Set Solving in Practice",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Synthesis Lectures on Artificial Intelligence and Machine Learning,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2012
    }, {
      "title" : "A portfolio solver for answer set programming: preliminary report",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub", "M.T. Schneider", "S. Ziller" ],
      "venue" : "in: Eleventh International Conference on Logic Programming and Nonmonotonic Reasoning,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2011
    }, {
      "title" : "Multi-threaded ASP solving with clasp",
      "author" : [ "M. Gebser", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Theory and Practice of Logic Programming",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2012
    }, {
      "title" : "Learning when to use lazy learning in constraint solving",
      "author" : [ "I. Gent", "C. Jefferson", "L. Kotthoff", "I. Miguel", "N. Moore", "P. Nightingale", "K. Petrie" ],
      "venue" : "in: Proceedings of the Nineteenth European Conference on Artificial Intelligence,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2010
    }, {
      "title" : "MINION: A fast, scalable, constraint solver",
      "author" : [ "I.P. Gent", "C.A. Jefferson", "I. Miguel" ],
      "venue" : "in: Proceedings of the European Conference on Artificial Intelligence,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2006
    }, {
      "title" : "Lazy explanations for constraint propagators",
      "author" : [ "I.P. Gent", "I. Miguel", "N.C.A. Moore", "2010b" ],
      "venue" : "in: Proceedings of the Twelfth International Symposium on Practical Aspects of Declarative Languages,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2010
    }, {
      "title" : "An ASP-based system for team-building in the Gioia-Tauro seaport",
      "author" : [ "G. Grasso", "S. Iiritano", "N. Leone", "V. Lio", "F. Ricca", "F. Scalise" ],
      "venue" : "in: Proceedings of the Twelfth International Symposium on Practical Aspects of Declarative Languages,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2010
    }, {
      "title" : "Learning techniques for automatic algorithm portfolio selection",
      "author" : [ "A. Guerri", "M. Milano" ],
      "venue" : "in: Proceedings of the Sixteenth Eureopean Conference on Artificial Intelligence,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2004
    }, {
      "title" : "The WEKA data mining software: An update",
      "author" : [ "M. Hall", "E. Frank", "G. Holmes", "B. Pfahringer", "P. Reutemann", "I.H. Witten" ],
      "venue" : "SIGKDD Explorations 11,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2009
    }, {
      "title" : "Fast downward stone soup: A baseline for building planner portfolios",
      "author" : [ "M. Helmert", "G. Röger", "E. Karpas" ],
      "venue" : "in: Proceedings of the Workshop on Planning and Learning at the Twenty-First International Conference on Automated Planning and Scheduling,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2011
    }, {
      "title" : "claspfolio 2: Advances in algorithm selection for answer set programming",
      "author" : [ "H. Hoos", "M. Lindauer", "T. Schaub" ],
      "venue" : "Theory and Practice of Logic",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2014
    }, {
      "title" : "aspeed: Solver scheduling via answer set programming. Theory and Practice of Logic Programming",
      "author" : [ "H.H. Hoos", "R. Kaminski", "M. Lindauer", "T. Schaub" ],
      "venue" : null,
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2014
    }, {
      "title" : "Proteus: A hierarchical portfolio of solvers and transformations",
      "author" : [ "B. Hurley", "L. Kotthoff", "Y. Malitsky", "B. O’Sullivan" ],
      "venue" : "in: Proceedings of the Eleventh International Conference on Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2014
    }, {
      "title" : "Boosting Verification by Automatic Tuning of Decision Procedures, in: Formal Methods in Computer Aided Design, IEEE Computer Society",
      "author" : [ "F. Hutter", "D. Babić", "H.H. Hoos", "A.J. Hu" ],
      "venue" : null,
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2007
    }, {
      "title" : "Performance prediction and automated tuning of randomized and parametric algorithms",
      "author" : [ "F. Hutter", "Y. Hamadi", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "in: Proceedings of the Twelfth International Conference on Principles and Practice of Constraint Programming,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2006
    }, {
      "title" : "Automated configuration of mixed integer programming solvers, in: Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems",
      "author" : [ "F. Hutter", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : null,
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2010
    }, {
      "title" : "Sequential model-based optimization for general algorithm configuration",
      "author" : [ "F. Hutter", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "in: Proceedings of the International Conference on Learning and Intelligent Optimization,",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 2011
    }, {
      "title" : "Identifying key algorithm parameters and instance features using forward selection, in: LION",
      "author" : [ "F. Hutter", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : null,
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 2013
    }, {
      "title" : "ParamILS: an automatic algorithm configuration framework",
      "author" : [ "F. Hutter", "H.H. Hoos", "K. Leyton-Brown", "T. Stützle" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR)",
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 2009
    }, {
      "title" : "Aclib: a benchmark library for algorithm configuration",
      "author" : [ "F. Hutter", "M.L.I. nez", "C. Fawcett", "M. Lindauer", "H. Hoos", "K. Leyton- Brown", "T. Stützle" ],
      "venue" : "in: Proceedings of the International Conference on Learning and Intelligent Optimization,",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2014
    }, {
      "title" : "Algorithm runtime prediction: Methods & evaluation",
      "author" : [ "F. Hutter", "L. Xu", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "45",
      "shortCiteRegEx" : "45",
      "year" : 2014
    }, {
      "title" : "Answer set vs integer linear programming for automatic synthesis of multiprocessor systems from real-time parallel programs",
      "author" : [ "H. Ishebabi", "P. Mahr", "C. Bobda", "M. Gebser", "T. Schaub" ],
      "venue" : "Journal of Reconfigurable Computing",
      "citeRegEx" : "46",
      "shortCiteRegEx" : "46",
      "year" : 2009
    }, {
      "title" : "Algorithm selection and scheduling",
      "author" : [ "S. Kadioglu", "Y. Malitsky", "A. Sabharwal", "H. Samulowitz", "M. Sellmann" ],
      "venue" : "in: Proceedings of the International Conference on Principles and Practice of Constraint Programming. Springer. volume 6876 of Lecture Notes in Computer Science,",
      "citeRegEx" : "47",
      "shortCiteRegEx" : "47",
      "year" : 2011
    }, {
      "title" : "ISAC Instance- Specific Algorithm Configuration",
      "author" : [ "S. Kadioglu", "Y. Malitsky", "M. Sellmann", "K. Tierney" ],
      "venue" : "in: Proceedings of Nineteenth European Conference on Artificial Intelligence,",
      "citeRegEx" : "48",
      "shortCiteRegEx" : "48",
      "year" : 2010
    }, {
      "title" : "kernlab – an S4 package for kernel methods in R",
      "author" : [ "A. Karatzoglou", "A. Smola", "K. Hornik", "A. Zeileis" ],
      "venue" : "Journal of Statistical Software",
      "citeRegEx" : "49",
      "shortCiteRegEx" : "49",
      "year" : 2004
    }, {
      "title" : "Unifying SAT-based and graph-based planning",
      "author" : [ "H. Kautz", "B. Selman" ],
      "venue" : "in: Proceedings of the Sixteenth International Joint Conference on Artifical Intelligence,",
      "citeRegEx" : "50",
      "shortCiteRegEx" : "50",
      "year" : 1999
    }, {
      "title" : "Cell mapping techniques for exploratory landscape analysis, in: Proceedings of the EVOLVE 2014: A Bridge between Probability, Set Oriented Numerics, and Evolutionary Computation",
      "author" : [ "P. Kerschke", "M. Preuss", "C. Hernández", "O. Schütze", "J.Q. Sun", "C. Grimme", "G. Rudolph", "B. Bischl", "H. Trautmann" ],
      "venue" : null,
      "citeRegEx" : "51",
      "shortCiteRegEx" : "51",
      "year" : 2014
    }, {
      "title" : "Wrappers for feature subset selection",
      "author" : [ "R. Kohavi", "G.H. John" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "52",
      "shortCiteRegEx" : "52",
      "year" : 1997
    }, {
      "title" : "LLAMA: Leveraging Learning to Automatically Manage Algorithms",
      "author" : [ "L. Kotthoff" ],
      "venue" : "Technical Report arXiv:1306.1031. arXiv. http://arxiv.org/",
      "citeRegEx" : "53",
      "shortCiteRegEx" : "53",
      "year" : 2013
    }, {
      "title" : "Algorithm selection for combinatorial search problems: A survey",
      "author" : [ "L. Kotthoff" ],
      "venue" : "AI Magazine",
      "citeRegEx" : "54",
      "shortCiteRegEx" : "54",
      "year" : 2014
    }, {
      "title" : "Algorithm selection using reinforcement learning",
      "author" : [ "M. Lagoudakis", "M. Littman" ],
      "venue" : "in: Proceedings of the Seventeenth International Conference on Machine Learning,",
      "citeRegEx" : "55",
      "shortCiteRegEx" : "55",
      "year" : 2000
    }, {
      "title" : "Learning to select branching rules in the DPLL procedure for satisfiability",
      "author" : [ "M. Lagoudakis", "M. Littman" ],
      "venue" : "in: Proceedings of the International Conference on Satisfiability,",
      "citeRegEx" : "56",
      "shortCiteRegEx" : "56",
      "year" : 2001
    }, {
      "title" : "CSP2SAT4J: A simple CSP to SAT translator",
      "author" : [ "D. Le Berre", "I. Lynce" ],
      "venue" : "Proceedings of the Second International CSP Solver",
      "citeRegEx" : "57",
      "shortCiteRegEx" : "57",
      "year" : 2008
    }, {
      "title" : "Selecting classification algorithms with active testing, in: Machine Learning and Data Mining in Pattern Recognition",
      "author" : [ "R. Leite", "P. Brazdil", "J. Vanschoren" ],
      "venue" : null,
      "citeRegEx" : "58",
      "shortCiteRegEx" : "58",
      "year" : 2012
    }, {
      "title" : "A portfolio approach to algorithm selection",
      "author" : [ "K. Leyton-Brown", "E. Nudelman", "G. Andrew", "J. McFadden", "Y. Shoham" ],
      "venue" : "in: Proceedings of the Eighteenth International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "59",
      "shortCiteRegEx" : "59",
      "year" : 2003
    }, {
      "title" : "Classification and regression by randomForest",
      "author" : [ "A. Liaw", "M. Wiener" ],
      "venue" : "R News",
      "citeRegEx" : "60",
      "shortCiteRegEx" : "60",
      "year" : 2002
    }, {
      "title" : "Evolving instance specific algorithm configuration",
      "author" : [ "Y. Malitsky", "D. Mehta", "B. O’Sullivan" ],
      "venue" : "in: The Sixth Annual Symposium on Combinatorial Search",
      "citeRegEx" : "61",
      "shortCiteRegEx" : "61",
      "year" : 2013
    }, {
      "title" : "A portfolio approach to enumerating minimal correction subsets for satisfiability problems",
      "author" : [ "Y. Malitsky", "B. O’Sullivan", "A. Previti", "J. Marques-Silva" ],
      "venue" : "in: Proceedings of the Eleventh International Conference on Integration of Artificical Intelligence and Operations Research Techniques in Constraint Programming",
      "citeRegEx" : "62",
      "shortCiteRegEx" : "62",
      "year" : 2014
    }, {
      "title" : "Nonmodel-based algorithm portfolios for SAT",
      "author" : [ "Y. Malitsky", "A. Sabharwal", "H. Samulowitz", "M. Sellmann" ],
      "venue" : "in: Proceedings of the Fourteenth International Conference on Theory and Applications of Satisfiability Testing,",
      "citeRegEx" : "63",
      "shortCiteRegEx" : "63",
      "year" : 2011
    }, {
      "title" : "Algorithm portfolios based on cost-sensitive hierarchical clustering",
      "author" : [ "Y. Malitsky", "A. Sabharwal", "H. Samulowitz", "M. Sellmann" ],
      "venue" : "in: Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence",
      "citeRegEx" : "64",
      "shortCiteRegEx" : "64",
      "year" : 2013
    }, {
      "title" : "A novel feature-based approach to characterize algorithm performance for the traveling salesperson problem",
      "author" : [ "O. Mersmann", "B. Bischl", "H. Trautmann", "M. Wagner", "J. Bossek", "F. Neumann" ],
      "venue" : null,
      "citeRegEx" : "65",
      "shortCiteRegEx" : "65",
      "year" : 2013
    }, {
      "title" : "Instance-based selection of policies for SAT solvers",
      "author" : [ "M. Nikolić", "F. Marić", "P. Janičić" ],
      "venue" : "in: Proceedings of the Twelfth International Conference on Theory and Applications of Satisfiability Testing,",
      "citeRegEx" : "66",
      "shortCiteRegEx" : "66",
      "year" : 2009
    }, {
      "title" : "An A-prolog decision support system for the space shuttle",
      "author" : [ "M. Nogueira", "M. Balduccini", "M. Gelfond", "R. Watson", "M. Barry" ],
      "venue" : "in: Proceedings of the Third International Symposium on Practical Aspects of Declarative Languages,",
      "citeRegEx" : "67",
      "shortCiteRegEx" : "67",
      "year" : 2001
    }, {
      "title" : "Understanding random SAT: beyond the Clauses-to-Variables ratio, in: Principles and Practice of Constraint Programming CP",
      "author" : [ "E. Nudelman", "K. Leyton-Brown", "H.H. Hoos", "A. Devkar", "Y. Shoham" ],
      "venue" : null,
      "citeRegEx" : "69",
      "shortCiteRegEx" : "69",
      "year" : 2004
    }, {
      "title" : "Using case-based reasoning in an algorithm portfolio for constraint solving",
      "author" : [ "E. O’Mahony", "E. Hebrard", "A. Holland", "C. Nugent", "B. O’Sullivan" ],
      "venue" : "in: Proceedings of the Nineteenth Irish Conference on Artificial Intelligence and Cognitive Science",
      "citeRegEx" : "70",
      "shortCiteRegEx" : "70",
      "year" : 2008
    }, {
      "title" : "Meta-learning by landmarking various learning algorithms",
      "author" : [ "B. Pfahringer", "H. Bensusan", "C. Giraud-Carrier" ],
      "venue" : "Proceedings of the Seventeenth International Conference on Machine",
      "citeRegEx" : "71",
      "shortCiteRegEx" : "71",
      "year" : 2000
    }, {
      "title" : "A survey of recent advances in SAT-based formal verification",
      "author" : [ "M.R. Prasad", "A. Biere", "A. Gupta" ],
      "venue" : "International Journal on Software Tools for Technology Transfer",
      "citeRegEx" : "72",
      "shortCiteRegEx" : "72",
      "year" : 2005
    }, {
      "title" : "A multi-engine solver for quantified boolean formulas",
      "author" : [ "L. Pulina", "A. Tacchella" ],
      "venue" : "in: Proceedings of the Thirteenth International Conference on Principles and Practice of Constraint Programming,",
      "citeRegEx" : "73",
      "shortCiteRegEx" : "73",
      "year" : 2007
    }, {
      "title" : "A self-adaptive multi-engine solver for quantified boolean formulas. Constraints",
      "author" : [ "L. Pulina", "A. Tacchella" ],
      "venue" : null,
      "citeRegEx" : "74",
      "shortCiteRegEx" : "74",
      "year" : 2009
    }, {
      "title" : "The algorithm selection problem",
      "author" : [ "J.R. Rice" ],
      "venue" : "Advances in Computers",
      "citeRegEx" : "76",
      "shortCiteRegEx" : "76",
      "year" : 1976
    }, {
      "title" : "Learned models of performance for many planners",
      "author" : [ "M. Roberts", "A.E. Howe" ],
      "venue" : "in: Proceedings of the Workshop on AI Planning and Learning at the Seventeenth International Conference on Automated Planning and Scheduling",
      "citeRegEx" : "77",
      "shortCiteRegEx" : "77",
      "year" : 2007
    }, {
      "title" : "Learning to solve QBF",
      "author" : [ "H. Samulowitz", "R. Memisevic" ],
      "venue" : "in: Proceedings of the Twenty-Second National Conference on Artificial Intelligence,",
      "citeRegEx" : "78",
      "shortCiteRegEx" : "78",
      "year" : 2007
    }, {
      "title" : "A survey of intelligent assistants for data analysis",
      "author" : [ "F. Serban", "J. Vanschoren", "J.U. Kietz", "A. Bernstein" ],
      "venue" : "ACM Comput. Surv",
      "citeRegEx" : "79",
      "shortCiteRegEx" : "79",
      "year" : 2013
    }, {
      "title" : "Latent class models for algorithm portfolio methods",
      "author" : [ "B. Silverthorn", "R. Miikkulainen" ],
      "venue" : "in: Proceedings of the Twenty-Fourth AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "80",
      "shortCiteRegEx" : "80",
      "year" : 2010
    }, {
      "title" : "Cross-disciplinary perspectives on meta-learning for algorithm selection",
      "author" : [ "K.A. Smith-Miles" ],
      "venue" : "ACM Computing Surveys",
      "citeRegEx" : "81",
      "shortCiteRegEx" : "81",
      "year" : 2008
    }, {
      "title" : "Towards objective measures of algorithm performance across instance space",
      "author" : [ "K.A. Smith-Miles", "D. Baatar", "B.J. Wreford", "R. Lewis" ],
      "venue" : "Computers & Operations Research",
      "citeRegEx" : "82",
      "shortCiteRegEx" : "82",
      "year" : 2014
    }, {
      "title" : "Developing a declarative rule language for applications in product configuration",
      "author" : [ "T. Soininen", "I. Niemelä" ],
      "venue" : "in: Proceedings of the First International Workshop on Practical Aspects of Declarative Languages,",
      "citeRegEx" : "83",
      "shortCiteRegEx" : "83",
      "year" : 1999
    }, {
      "title" : "Operations research at container terminals: a literature update",
      "author" : [ "R. Stahlbock", "S. Voß" ],
      "venue" : "OR Spectrum",
      "citeRegEx" : "84",
      "shortCiteRegEx" : "84",
      "year" : 2008
    }, {
      "title" : "Heuristics for dynamically adapting propagation in constraint satisfaction problems",
      "author" : [ "K. Stergiou" ],
      "venue" : "AI Communications",
      "citeRegEx" : "85",
      "shortCiteRegEx" : "85",
      "year" : 2009
    }, {
      "title" : "Combining multiple heuristics online",
      "author" : [ "M.J. Streeter", "D. Golovin", "S.F. Smith" ],
      "venue" : "in: Proceedings of the Twenty-Second National Conference on Artificial Intelligence,",
      "citeRegEx" : "86",
      "shortCiteRegEx" : "86",
      "year" : 2007
    }, {
      "title" : "Restart schedules for ensembles of problem instances",
      "author" : [ "M.J. Streeter", "D. Golovin", "S.F. Smith" ],
      "venue" : "in: Proceedings of the Twenty-Second National Conference on Artificial Intelligence,",
      "citeRegEx" : "87",
      "shortCiteRegEx" : "87",
      "year" : 2007
    }, {
      "title" : "The MiniZinc challenge 2008-2013",
      "author" : [ "P.J. Stuckey", "T. Feydy", "A. Schutt", "G. Tack", "J. Fischer" ],
      "venue" : "AI Magazine",
      "citeRegEx" : "88",
      "shortCiteRegEx" : "88",
      "year" : 2014
    }, {
      "title" : "System description of a SATbased CSP solver sugar",
      "author" : [ "N. Tamura", "T. Tanjo", "M. Banbara" ],
      "venue" : "Proceedings of the Third International CSP Solver",
      "citeRegEx" : "89",
      "shortCiteRegEx" : "89",
      "year" : 2008
    }, {
      "title" : "Azucar: a SAT-based CSP solver using compact order encoding, in: Theory and Applications of Satisfiability Testing – SAT",
      "author" : [ "T. Tanjo", "N. Tamura", "M. Banbara" ],
      "venue" : null,
      "citeRegEx" : "90",
      "shortCiteRegEx" : "90",
      "year" : 2012
    }, {
      "title" : "rpart: Recursive Partitioning and Regression Trees. URL: http://CRAN.R-project.org/package= rpart. r package version 4.1-8",
      "author" : [ "T. Therneau", "B. Atkinson", "B. Ripley" ],
      "venue" : null,
      "citeRegEx" : "91",
      "shortCiteRegEx" : "91",
      "year" : 2014
    }, {
      "title" : "Auto-WEKA: Combined selection and hyperparameter optimization of classification algorithms",
      "author" : [ "C. Thornton", "F. Hutter", "H. Hoos", "K. Leyton-Brown" ],
      "venue" : "in: Proceedings of the Nineteenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining,",
      "citeRegEx" : "92",
      "shortCiteRegEx" : "92",
      "year" : 2013
    }, {
      "title" : "An algorithm selection benchmark of the container pre-marshalling",
      "author" : [ "K. Tierney", "Y. Malitsky" ],
      "venue" : "Proceedings of the Ninth International Conference Learning and Intelligent Optimisation LION (To Appear),",
      "citeRegEx" : "93",
      "shortCiteRegEx" : "93",
      "year" : 2015
    }, {
      "title" : "Solving the Pre-Marshalling Problem to Optimality with A* and IDA",
      "author" : [ "K. Tierney", "D. Pacino", "S. Voß" ],
      "venue" : "Technical Report Working Paper #1401",
      "citeRegEx" : "94",
      "shortCiteRegEx" : "94",
      "year" : 2014
    }, {
      "title" : "Automatic generation of efficient domain-optimized planners from generic parametrized planners, in: International Symposium on Combinatorial Search (SoCS)",
      "author" : [ "M. Vallati", "C. Fawcett", "A. Gerevini", "H.H. Hoos", "A. Saetti" ],
      "venue" : null,
      "citeRegEx" : "95",
      "shortCiteRegEx" : "95",
      "year" : 2013
    }, {
      "title" : "Another look at graph coloring via propositional satisfiability",
      "author" : [ "A. Van Gelder" ],
      "venue" : "Discrete Applied Mathematics",
      "citeRegEx" : "96",
      "shortCiteRegEx" : "96",
      "year" : 2008
    }, {
      "title" : "Understanding Machine Learning Performance with Experiment Databases",
      "author" : [ "J. Vanschoren" ],
      "venue" : "Ph.D. thesis. University of Leuven",
      "citeRegEx" : "97",
      "shortCiteRegEx" : "97",
      "year" : 2010
    }, {
      "title" : "Experiment databases. A new way to share, organize and learn from experiments",
      "author" : [ "J. Vanschoren", "H. Blockeel", "B. Pfahringer", "G. Holmes" ],
      "venue" : "Machine Learning",
      "citeRegEx" : "98",
      "shortCiteRegEx" : "98",
      "year" : 2012
    }, {
      "title" : "OpenML: Networked science in machine learning",
      "author" : [ "J. Vanschoren", "J.N. van Rijn", "B. Bischl", "L. Torgo" ],
      "venue" : "SIGKDD Explorations",
      "citeRegEx" : "99",
      "shortCiteRegEx" : "99",
      "year" : 2013
    }, {
      "title" : "Hierarchical grouping to optimize an objective function",
      "author" : [ "J. Ward" ],
      "venue" : "Journal of the American Statistical Association",
      "citeRegEx" : "100",
      "shortCiteRegEx" : "100",
      "year" : 1963
    }, {
      "title" : "Sub-SAT: A formulation for relaxed boolean satisfiability with applications in routing",
      "author" : [ "H. Xu", "R. Rutenbar", "K. Sakallah" ],
      "venue" : "in: IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems,",
      "citeRegEx" : "101",
      "shortCiteRegEx" : "101",
      "year" : 2003
    }, {
      "title" : "Hierarchical hardness models for SAT",
      "author" : [ "L. Xu", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "in: Proceedings of the Thirteenth International Conference on Principles and Practice of Constraint Programming,",
      "citeRegEx" : "102",
      "shortCiteRegEx" : "102",
      "year" : 2007
    }, {
      "title" : "Hydra: Automatically configuring algorithms for Portfolio-Based selection",
      "author" : [ "L. Xu", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "in: Proceedings of the Twenty-Fourth AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "103",
      "shortCiteRegEx" : "103",
      "year" : 2010
    }, {
      "title" : "SATzilla: portfolio-based algorithm selection for SAT",
      "author" : [ "L. Xu", "F. Hutter", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "Journal of Artificial Intelligence Research",
      "citeRegEx" : "104",
      "shortCiteRegEx" : "104",
      "year" : 2008
    }, {
      "title" : "Hydra-MIP: automated algorithm configuration and selection for mixed integer programming, in: Proceedings of the RCRA Workshop on Experimental Evaluation of Algorithms for Solving Problems with Combinatorial Explosion at the Twenty-Second International",
      "author" : [ "L. Xu", "F. Hutter", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "Joint Conference on Artificial Intelligence",
      "citeRegEx" : "105",
      "shortCiteRegEx" : "105",
      "year" : 2011
    }, {
      "title" : "Evaluating component solver contributions to Portfolio-Based algorithm selectors",
      "author" : [ "L. Xu", "F. Hutter", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "in: Proceedings of the Fifteenth International Conference on Theory and Applications of Satisfiability Testing,",
      "citeRegEx" : "106",
      "shortCiteRegEx" : "106",
      "year" : 2012
    }, {
      "title" : "Satzilla2012: Improved algorithm selection based on cost-sensitive classification models",
      "author" : [ "L. Xu", "F. Hutter", "J. Shen", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "Proceedings of SAT Challenge 2012: Solver and Benchmark Descriptions ,",
      "citeRegEx" : "107",
      "shortCiteRegEx" : "107",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 99,
      "context" : "In particular, this fact has been observed to hold across a wide variety of AI applications, including propositional satisfiability (SAT) [106], constraint satisfaction (CSP) [70], AI planning [34], and supervised machine learning [92, 98].",
      "startOffset" : 138,
      "endOffset" : 143
    }, {
      "referenceID" : 64,
      "context" : "In particular, this fact has been observed to hold across a wide variety of AI applications, including propositional satisfiability (SAT) [106], constraint satisfaction (CSP) [70], AI planning [34], and supervised machine learning [92, 98].",
      "startOffset" : 175,
      "endOffset" : 179
    }, {
      "referenceID" : 29,
      "context" : "In particular, this fact has been observed to hold across a wide variety of AI applications, including propositional satisfiability (SAT) [106], constraint satisfaction (CSP) [70], AI planning [34], and supervised machine learning [92, 98].",
      "startOffset" : 193,
      "endOffset" : 197
    }, {
      "referenceID" : 85,
      "context" : "In particular, this fact has been observed to hold across a wide variety of AI applications, including propositional satisfiability (SAT) [106], constraint satisfaction (CSP) [70], AI planning [34], and supervised machine learning [92, 98].",
      "startOffset" : 231,
      "endOffset" : 239
    }, {
      "referenceID" : 91,
      "context" : "In particular, this fact has been observed to hold across a wide variety of AI applications, including propositional satisfiability (SAT) [106], constraint satisfaction (CSP) [70], AI planning [34], and supervised machine learning [92, 98].",
      "startOffset" : 231,
      "endOffset" : 239
    }, {
      "referenceID" : 69,
      "context" : "An alternative is to accept that no single algorithm will offer the best performance on all instances, and instead aim to identify a portfolio of complementary algorithms and a strategy for choosing between them [76].",
      "startOffset" : 212,
      "endOffset" : 216
    }, {
      "referenceID" : 5,
      "context" : "The best of the 35 submitted solvers, Lingeling ayv [7], solved 77% of the 300 instances.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 69,
      "context" : "Research on this algorithm selection problem [76] has demonstrated the practical feasibility of using machine learning for this task.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 97,
      "context" : "The area began to attract considerable attention when methods based on algorithm selection began to outperform standalone solvers in SAT competitions [104].",
      "startOffset" : 150,
      "endOffset" : 155
    }, {
      "referenceID" : 64,
      "context" : "Algorithm selectors have since come to dominate the state of the art on many other problems, including CSP [70], AI planning [34], Max-SAT [61], QBF [74], and ASP [25].",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 29,
      "context" : "Algorithm selectors have since come to dominate the state of the art on many other problems, including CSP [70], AI planning [34], Max-SAT [61], QBF [74], and ASP [25].",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 56,
      "context" : "Algorithm selectors have since come to dominate the state of the art on many other problems, including CSP [70], AI planning [34], Max-SAT [61], QBF [74], and ASP [25].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 68,
      "context" : "Algorithm selectors have since come to dominate the state of the art on many other problems, including CSP [70], AI planning [34], Max-SAT [61], QBF [74], and ASP [25].",
      "startOffset" : 149,
      "endOffset" : 153
    }, {
      "referenceID" : 21,
      "context" : "Algorithm selectors have since come to dominate the state of the art on many other problems, including CSP [70], AI planning [34], Max-SAT [61], QBF [74], and ASP [25].",
      "startOffset" : 163,
      "endOffset" : 167
    }, {
      "referenceID" : 69,
      "context" : "Background Rice [76] was the first to formalize the idea of selecting among different algorithms on a per-instance basis.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 97,
      "context" : "This is used in the SATzilla [68, 104], ArgoSmArT [66], SALSA [19] and Eureka [17] systems, to name but a few examples.",
      "startOffset" : 29,
      "endOffset" : 38
    }, {
      "referenceID" : 61,
      "context" : "This is used in the SATzilla [68, 104], ArgoSmArT [66], SALSA [19] and Eureka [17] systems, to name but a few examples.",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 15,
      "context" : "This is used in the SATzilla [68, 104], ArgoSmArT [66], SALSA [19] and Eureka [17] systems, to name but a few examples.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 13,
      "context" : "This is used in the SATzilla [68, 104], ArgoSmArT [66], SALSA [19] and Eureka [17] systems, to name but a few examples.",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 31,
      "context" : ", [36, 47, 70, 74]).",
      "startOffset" : 2,
      "endOffset" : 18
    }, {
      "referenceID" : 42,
      "context" : ", [36, 47, 70, 74]).",
      "startOffset" : 2,
      "endOffset" : 18
    }, {
      "referenceID" : 64,
      "context" : ", [36, 47, 70, 74]).",
      "startOffset" : 2,
      "endOffset" : 18
    }, {
      "referenceID" : 68,
      "context" : ", [36, 47, 70, 74]).",
      "startOffset" : 2,
      "endOffset" : 18
    }, {
      "referenceID" : 12,
      "context" : ", [16, 22, 30, 87]).",
      "startOffset" : 2,
      "endOffset" : 18
    }, {
      "referenceID" : 18,
      "context" : ", [16, 22, 30, 87]).",
      "startOffset" : 2,
      "endOffset" : 18
    }, {
      "referenceID" : 80,
      "context" : ", [16, 22, 30, 87]).",
      "startOffset" : 2,
      "endOffset" : 18
    }, {
      "referenceID" : 19,
      "context" : "Such methods monitor the execution of the chosen algorithm(s) and take remedial action if performance deviates from what is expected [23, 58, 62], or perform selection repeatedly for subproblems of the given instance [3, 55, 56, 78].",
      "startOffset" : 133,
      "endOffset" : 145
    }, {
      "referenceID" : 53,
      "context" : "Such methods monitor the execution of the chosen algorithm(s) and take remedial action if performance deviates from what is expected [23, 58, 62], or perform selection repeatedly for subproblems of the given instance [3, 55, 56, 78].",
      "startOffset" : 133,
      "endOffset" : 145
    }, {
      "referenceID" : 57,
      "context" : "Such methods monitor the execution of the chosen algorithm(s) and take remedial action if performance deviates from what is expected [23, 58, 62], or perform selection repeatedly for subproblems of the given instance [3, 55, 56, 78].",
      "startOffset" : 133,
      "endOffset" : 145
    }, {
      "referenceID" : 2,
      "context" : "Such methods monitor the execution of the chosen algorithm(s) and take remedial action if performance deviates from what is expected [23, 58, 62], or perform selection repeatedly for subproblems of the given instance [3, 55, 56, 78].",
      "startOffset" : 217,
      "endOffset" : 232
    }, {
      "referenceID" : 50,
      "context" : "Such methods monitor the execution of the chosen algorithm(s) and take remedial action if performance deviates from what is expected [23, 58, 62], or perform selection repeatedly for subproblems of the given instance [3, 55, 56, 78].",
      "startOffset" : 217,
      "endOffset" : 232
    }, {
      "referenceID" : 51,
      "context" : "Such methods monitor the execution of the chosen algorithm(s) and take remedial action if performance deviates from what is expected [23, 58, 62], or perform selection repeatedly for subproblems of the given instance [3, 55, 56, 78].",
      "startOffset" : 217,
      "endOffset" : 232
    }, {
      "referenceID" : 71,
      "context" : "Such methods monitor the execution of the chosen algorithm(s) and take remedial action if performance deviates from what is expected [23, 58, 62], or perform selection repeatedly for subproblems of the given instance [3, 55, 56, 78].",
      "startOffset" : 217,
      "endOffset" : 232
    }, {
      "referenceID" : 23,
      "context" : ", [27, 32, 63]).",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 27,
      "context" : ", [27, 32, 63]).",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 58,
      "context" : ", [27, 32, 63]).",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 97,
      "context" : "This regression approach was adopted by early versions of SATzilla [68, 104], as well as by several other systems [65, 77, 80].",
      "startOffset" : 67,
      "endOffset" : 76
    }, {
      "referenceID" : 60,
      "context" : "This regression approach was adopted by early versions of SATzilla [68, 104], as well as by several other systems [65, 77, 80].",
      "startOffset" : 114,
      "endOffset" : 126
    }, {
      "referenceID" : 70,
      "context" : "This regression approach was adopted by early versions of SATzilla [68, 104], as well as by several other systems [65, 77, 80].",
      "startOffset" : 114,
      "endOffset" : 126
    }, {
      "referenceID" : 73,
      "context" : "This regression approach was adopted by early versions of SATzilla [68, 104], as well as by several other systems [65, 77, 80].",
      "startOffset" : 114,
      "endOffset" : 126
    }, {
      "referenceID" : 43,
      "context" : "Other approaches include the use of clustering techniques to partition problem instances in feature space and make decisions for each partition separately [48, 85], hierarchical models that make a series of decisions [37, 102], and costsensitive support vector machines [13].",
      "startOffset" : 155,
      "endOffset" : 163
    }, {
      "referenceID" : 78,
      "context" : "Other approaches include the use of clustering techniques to partition problem instances in feature space and make decisions for each partition separately [48, 85], hierarchical models that make a series of decisions [37, 102], and costsensitive support vector machines [13].",
      "startOffset" : 155,
      "endOffset" : 163
    }, {
      "referenceID" : 32,
      "context" : "Other approaches include the use of clustering techniques to partition problem instances in feature space and make decisions for each partition separately [48, 85], hierarchical models that make a series of decisions [37, 102], and costsensitive support vector machines [13].",
      "startOffset" : 217,
      "endOffset" : 226
    }, {
      "referenceID" : 95,
      "context" : "Other approaches include the use of clustering techniques to partition problem instances in feature space and make decisions for each partition separately [48, 85], hierarchical models that make a series of decisions [37, 102], and costsensitive support vector machines [13].",
      "startOffset" : 217,
      "endOffset" : 226
    }, {
      "referenceID" : 9,
      "context" : "Other approaches include the use of clustering techniques to partition problem instances in feature space and make decisions for each partition separately [48, 85], hierarchical models that make a series of decisions [37, 102], and costsensitive support vector machines [13].",
      "startOffset" : 270,
      "endOffset" : 274
    }, {
      "referenceID" : 98,
      "context" : "The current version of SATzilla [105] uses cost-sensitive decision forests to determine the best algorithm for each pair of algorithms and selects the overall best by aggregating these “votes”.",
      "startOffset" : 32,
      "endOffset" : 37
    }, {
      "referenceID" : 19,
      "context" : "Some approaches use only past performance of the algorithms in the portfolio as a basis for selecting the one(s) to be run on a given problem instance [23, 80, 86].",
      "startOffset" : 151,
      "endOffset" : 163
    }, {
      "referenceID" : 73,
      "context" : "Some approaches use only past performance of the algorithms in the portfolio as a basis for selecting the one(s) to be run on a given problem instance [23, 80, 86].",
      "startOffset" : 151,
      "endOffset" : 163
    }, {
      "referenceID" : 79,
      "context" : "Some approaches use only past performance of the algorithms in the portfolio as a basis for selecting the one(s) to be run on a given problem instance [23, 80, 86].",
      "startOffset" : 151,
      "endOffset" : 163
    }, {
      "referenceID" : 23,
      "context" : "Deeper analysis can involve properties of graph representations derived from the input instance (such as the constraint graph [27, 59]) or properties of encodings into different problems (such as SAT features for SAT-encoded planning problems [21]).",
      "startOffset" : 126,
      "endOffset" : 134
    }, {
      "referenceID" : 54,
      "context" : "Deeper analysis can involve properties of graph representations derived from the input instance (such as the constraint graph [27, 59]) or properties of encodings into different problems (such as SAT features for SAT-encoded planning problems [21]).",
      "startOffset" : 126,
      "endOffset" : 134
    }, {
      "referenceID" : 17,
      "context" : "Deeper analysis can involve properties of graph representations derived from the input instance (such as the constraint graph [27, 59]) or properties of encodings into different problems (such as SAT features for SAT-encoded planning problems [21]).",
      "startOffset" : 243,
      "endOffset" : 247
    }, {
      "referenceID" : 40,
      "context" : ", [45, 69, 70, 73, 104]).",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 63,
      "context" : ", [45, 69, 70, 73, 104]).",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 64,
      "context" : ", [45, 69, 70, 73, 104]).",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 67,
      "context" : ", [45, 69, 70, 73, 104]).",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 97,
      "context" : ", [45, 69, 70, 73, 104]).",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 9,
      "context" : "For continuous blackbox optimization, algorithm selection can be performed based on Exploratory Landscape Analysis [13, 51, 65].",
      "startOffset" : 115,
      "endOffset" : 127
    }, {
      "referenceID" : 46,
      "context" : "For continuous blackbox optimization, algorithm selection can be performed based on Exploratory Landscape Analysis [13, 51, 65].",
      "startOffset" : 115,
      "endOffset" : 127
    }, {
      "referenceID" : 60,
      "context" : "For continuous blackbox optimization, algorithm selection can be performed based on Exploratory Landscape Analysis [13, 51, 65].",
      "startOffset" : 115,
      "endOffset" : 127
    }, {
      "referenceID" : 11,
      "context" : "g, [15]), these features are known as meta-features.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 65,
      "context" : ", variable entropy), landmarkers (measurements of the performance of fast algorithms [71]), sampling landmarkers (similar to probing features) and model-based meta-features [97].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 90,
      "context" : ", variable entropy), landmarkers (measurements of the performance of fast algorithms [71]), sampling landmarkers (similar to probing features) and model-based meta-features [97].",
      "startOffset" : 173,
      "endOffset" : 177
    }, {
      "referenceID" : 92,
      "context" : "These meta-features, and the past performance measurements of many machine learning algorithms, are available from the online machine learning platform OpenML [99].",
      "startOffset" : 159,
      "endOffset" : 163
    }, {
      "referenceID" : 38,
      "context" : "General algorithm configuration methods, such as ParamILS [43], GGA [2], I/F-Race [9], and SMAC [41], have yielded substantial performance improvements (sometimes orders of magnitude",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 1,
      "context" : "General algorithm configuration methods, such as ParamILS [43], GGA [2], I/F-Race [9], and SMAC [41], have yielded substantial performance improvements (sometimes orders of magnitude",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 6,
      "context" : "General algorithm configuration methods, such as ParamILS [43], GGA [2], I/F-Race [9], and SMAC [41], have yielded substantial performance improvements (sometimes orders of magnitude",
      "startOffset" : 82,
      "endOffset" : 85
    }, {
      "referenceID" : 36,
      "context" : "General algorithm configuration methods, such as ParamILS [43], GGA [2], I/F-Race [9], and SMAC [41], have yielded substantial performance improvements (sometimes orders of magnitude",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 33,
      "context" : "speedups) of state-of-the-art algorithms for several benchmarks, including SATbased formal verification [38], mixed integer programming [40], AI planning [95], and the combined selection and hyperparameter optimization of machine learning algorithms [92].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 35,
      "context" : "speedups) of state-of-the-art algorithms for several benchmarks, including SATbased formal verification [38], mixed integer programming [40], AI planning [95], and the combined selection and hyperparameter optimization of machine learning algorithms [92].",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 88,
      "context" : "speedups) of state-of-the-art algorithms for several benchmarks, including SATbased formal verification [38], mixed integer programming [40], AI planning [95], and the combined selection and hyperparameter optimization of machine learning algorithms [92].",
      "startOffset" : 154,
      "endOffset" : 158
    }, {
      "referenceID" : 85,
      "context" : "speedups) of state-of-the-art algorithms for several benchmarks, including SATbased formal verification [38], mixed integer programming [40], AI planning [95], and the combined selection and hyperparameter optimization of machine learning algorithms [92].",
      "startOffset" : 250,
      "endOffset" : 254
    }, {
      "referenceID" : 0,
      "context" : "Consequently, several possibilities exist for combining algorithm configuration and selection [1, 39, 48, 61, 103, 105].",
      "startOffset" : 94,
      "endOffset" : 119
    }, {
      "referenceID" : 34,
      "context" : "Consequently, several possibilities exist for combining algorithm configuration and selection [1, 39, 48, 61, 103, 105].",
      "startOffset" : 94,
      "endOffset" : 119
    }, {
      "referenceID" : 43,
      "context" : "Consequently, several possibilities exist for combining algorithm configuration and selection [1, 39, 48, 61, 103, 105].",
      "startOffset" : 94,
      "endOffset" : 119
    }, {
      "referenceID" : 56,
      "context" : "Consequently, several possibilities exist for combining algorithm configuration and selection [1, 39, 48, 61, 103, 105].",
      "startOffset" : 94,
      "endOffset" : 119
    }, {
      "referenceID" : 96,
      "context" : "Consequently, several possibilities exist for combining algorithm configuration and selection [1, 39, 48, 61, 103, 105].",
      "startOffset" : 94,
      "endOffset" : 119
    }, {
      "referenceID" : 98,
      "context" : "Consequently, several possibilities exist for combining algorithm configuration and selection [1, 39, 48, 61, 103, 105].",
      "startOffset" : 94,
      "endOffset" : 119
    }, {
      "referenceID" : 39,
      "context" : "The algorithm configuration counterpart of ASlib is AClib [44] (http://aclib.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 49,
      "context" : "A full coverage of the wide literature on algorithm selection is beyond the scope of this article, but we refer the interested reader to recent survey articles on the topic [54, 79, 81].",
      "startOffset" : 173,
      "endOffset" : 185
    }, {
      "referenceID" : 72,
      "context" : "A full coverage of the wide literature on algorithm selection is beyond the scope of this article, but we refer the interested reader to recent survey articles on the topic [54, 79, 81].",
      "startOffset" : 173,
      "endOffset" : 185
    }, {
      "referenceID" : 74,
      "context" : "A full coverage of the wide literature on algorithm selection is beyond the scope of this article, but we refer the interested reader to recent survey articles on the topic [54, 79, 81].",
      "startOffset" : 173,
      "endOffset" : 185
    }, {
      "referenceID" : 16,
      "context" : "One way of mitigating it is offered by fast-to-evaluate surrogate algorithm configuration benchmarks [20].",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 7,
      "context" : "Table 1 introduces the basic structure of our format definition; the complete specification with all details can be found in an accompanying technical report [10] and on our online platform.",
      "startOffset" : 158,
      "endOffset" : 162
    }, {
      "referenceID" : 97,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 66,
      "endOffset" : 71
    }, {
      "referenceID" : 97,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 99,
      "endOffset" : 104
    }, {
      "referenceID" : 97,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 131,
      "endOffset" : 136
    }, {
      "referenceID" : 100,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 164,
      "endOffset" : 169
    }, {
      "referenceID" : 100,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 197,
      "endOffset" : 202
    }, {
      "referenceID" : 100,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 231,
      "endOffset" : 236
    }, {
      "referenceID" : 100,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 265,
      "endOffset" : 270
    }, {
      "referenceID" : 68,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 294,
      "endOffset" : 298
    }, {
      "referenceID" : 56,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 325,
      "endOffset" : 329
    }, {
      "referenceID" : 23,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 353,
      "endOffset" : 357
    }, {
      "referenceID" : 32,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 387,
      "endOffset" : 391
    }, {
      "referenceID" : 30,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 421,
      "endOffset" : 425
    }, {
      "referenceID" : 86,
      "context" : "scenario #I #A #F #Fg Costs Literature SAT11-HAND 296 15 115 10 X [104] SAT11-INDU 300 18 115 10 X [104] SAT11-RAND 600 9 115 10 X [104] SAT12-ALL 1614 31 115 10 X [107] SAT12-HAND 767 31 115 10 X [107] SAT12-INDU 1167 31 115 10 X [107] SAT12-RAND 1362 31 115 10 X [107] QBF-2011 1368 5 46 1 × [74] MAXSAT12-PMS 876 6 37 1 X [61] CSP-2010 2024 2 17 1 × [27] PROTEUS-2014 4021 22 198 4 X [37] ASP-POTASSCO 1294 11 138 5 X [35] PREMARSHALLING-ASTAR-2013 527 4 16 1 × [93] Table 2: Overview of algorithm selection scenarios in the ASLib with the number of instances #I, number of algorithms #A, number of features #F , number of feature processing groups #Fg and availability of feature costs.",
      "startOffset" : 465,
      "endOffset" : 469
    }, {
      "referenceID" : 66,
      "context" : "It is widely studied, with many applications including formal verification [72], scheduling [18], planning [50] and graph coloring [96].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 14,
      "context" : "It is widely studied, with many applications including formal verification [72], scheduling [18], planning [50] and graph coloring [96].",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 45,
      "context" : "It is widely studied, with many applications including formal verification [72], scheduling [18], planning [50] and graph coloring [96].",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 89,
      "context" : "It is widely studied, with many applications including formal verification [72], scheduling [18], planning [50] and graph coloring [96].",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 68,
      "context" : "[74].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 94,
      "context" : "The MaxSAT problem representation can be used to effectively encode a number of real-world problems, such as FPGA routing [101], and software package installation [4], among others, as it permits reasoning about both optimality and feasibility.",
      "startOffset" : 122,
      "endOffset" : 127
    }, {
      "referenceID" : 3,
      "context" : "The MaxSAT problem representation can be used to effectively encode a number of real-world problems, such as FPGA routing [101], and software package installation [4], among others, as it permits reasoning about both optimality and feasibility.",
      "startOffset" : 163,
      "endOffset" : 166
    }, {
      "referenceID" : 81,
      "context" : "CSP-2010: Lazy learning in constraint solving Constraint programming [88] is concerned with finding solutions to constraint satisfaction problems—a task that is NP-complete.",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 23,
      "context" : "The scenario contains only two solvers: one that employs lazy learning [27, 29] and one that does not [28].",
      "startOffset" : 71,
      "endOffset" : 79
    }, {
      "referenceID" : 25,
      "context" : "The scenario contains only two solvers: one that employs lazy learning [27, 29] and one that does not [28].",
      "startOffset" : 71,
      "endOffset" : 79
    }, {
      "referenceID" : 24,
      "context" : "The scenario contains only two solvers: one that employs lazy learning [27, 29] and one that does not [28].",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 32,
      "context" : "PROTEUS-2014 The PROTEUS scenario, stemming from [37], includes an extremely diverse mix of well-known CSP solvers alongside competition-winning SAT solvers that have to solve (converted) XCSP instances.",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 52,
      "context" : ", [57, 89, 90]), which in our format are provided as separate algorithms.",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 82,
      "context" : ", [57, 89, 90]), which in our format are provided as separate algorithms.",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 83,
      "context" : ", [57, 89, 90]), which in our format are provided as separate algorithms.",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 4,
      "context" : "ASP-POTASSCO: Answer Set Programming Answer Set Programming (ASP, [6, 24]) is a form of declarative programming with roots in knowledge representation, non-monotonic reasoning and constraint solving.",
      "startOffset" : 66,
      "endOffset" : 73
    }, {
      "referenceID" : 20,
      "context" : "ASP-POTASSCO: Answer Set Programming Answer Set Programming (ASP, [6, 24]) is a form of declarative programming with roots in knowledge representation, non-monotonic reasoning and constraint solving.",
      "startOffset" : 66,
      "endOffset" : 73
    }, {
      "referenceID" : 76,
      "context" : ", product configuration [83], decision support for NASA shuttle controllers [67], synthesis of multiprocessor systems [46] and industrial team building [31].",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 62,
      "context" : ", product configuration [83], decision support for NASA shuttle controllers [67], synthesis of multiprocessor systems [46] and industrial team building [31].",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 41,
      "context" : ", product configuration [83], decision support for NASA shuttle controllers [67], synthesis of multiprocessor systems [46] and industrial team building [31].",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 26,
      "context" : ", product configuration [83], decision support for NASA shuttle controllers [67], synthesis of multiprocessor systems [46] and industrial team building [31].",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 96,
      "context" : "In contrast to the other scenarios, the algorithms in the ASP scenario were automatically constructed by an adapted version of Hydra [103], i.",
      "startOffset" : 133,
      "endOffset" : 138
    }, {
      "referenceID" : 22,
      "context" : ", the set of algorithms consists of complementary configurations of the solver clasp [26].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 32,
      "context" : "html as described in [37].",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 21,
      "context" : "static and probing features organized into feature groups; they were previously used in the algorithm selector claspfolio [25, 35].",
      "startOffset" : 122,
      "endOffset" : 130
    }, {
      "referenceID" : 30,
      "context" : "static and probing features organized into feature groups; they were previously used in the algorithm selector claspfolio [25, 35].",
      "startOffset" : 122,
      "endOffset" : 130
    }, {
      "referenceID" : 77,
      "context" : "PREMARSHALLING-ASTAR-2013: Container pre-marshalling The container pre-marshalling problem (CPMP) is an NP-hard container stacking problem from the container terminals literature [84].",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 87,
      "context" : "We constructed an algorithm selection scenario from two recent A* and IDA* approaches for solving the CPMP presented in [94], using instances from the literature.",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 86,
      "context" : "The scenario is described in detail in [93].",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 99,
      "context" : "Because detecting correlation in algorithm performance is also of interest when analyzing the strengths and weaknesses of a given portfolio-based solver [106], we also present a clustered correlation matrix, cf.",
      "startOffset" : 153,
      "endOffset" : 158
    }, {
      "referenceID" : 93,
      "context" : "The algorithms are also clustered according to these values (using Ward’s method [100]) and then sorted, such that similar algorithms appear together in blocks.",
      "startOffset" : 81,
      "endOffset" : 86
    }, {
      "referenceID" : 75,
      "context" : "For the future, we plan to extend our data analysis by additional techniques, such as further measures of algorithm performance [82].",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 59,
      "context" : "In order to reach the performance of current state-of-the-art algorithm selection systems [64, 107], we would have to include various extensions, such as cost-sensitive classification and complementary techniques such as pre-solving.",
      "startOffset" : 90,
      "endOffset" : 99
    }, {
      "referenceID" : 100,
      "context" : "In order to reach the performance of current state-of-the-art algorithm selection systems [64, 107], we would have to include various extensions, such as cost-sensitive classification and complementary techniques such as pre-solving.",
      "startOffset" : 90,
      "endOffset" : 99
    }, {
      "referenceID" : 48,
      "context" : "We use the LLAMA toolkit [53], version 0.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 8,
      "context" : "We parallelize all of our benchmark experiments through the BatchExperiments [11] R package.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 97,
      "context" : "[104].",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 44,
      "context" : "Technical Name Algorithm and parameter ranges reference classification ksvm support vector machine [49] C ∈ [2−12, 2], γ ∈ [2−12, 2] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] regression lm linear regression [75] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] clustering XMeans extended k-means clustering [33] Table 4: Machine learning algorithms and their parameter ranges used for our experiments.",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 55,
      "context" : "Technical Name Algorithm and parameter ranges reference classification ksvm support vector machine [49] C ∈ [2−12, 2], γ ∈ [2−12, 2] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] regression lm linear regression [75] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] clustering XMeans extended k-means clustering [33] Table 4: Machine learning algorithms and their parameter ranges used for our experiments.",
      "startOffset" : 160,
      "endOffset" : 164
    }, {
      "referenceID" : 7,
      "context" : "Technical Name Algorithm and parameter ranges reference classification ksvm support vector machine [49] C ∈ [2−12, 2], γ ∈ [2−12, 2] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] regression lm linear regression [75] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] clustering XMeans extended k-means clustering [33] Table 4: Machine learning algorithms and their parameter ranges used for our experiments.",
      "startOffset" : 173,
      "endOffset" : 182
    }, {
      "referenceID" : 0,
      "context" : "Technical Name Algorithm and parameter ranges reference classification ksvm support vector machine [49] C ∈ [2−12, 2], γ ∈ [2−12, 2] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] regression lm linear regression [75] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] clustering XMeans extended k-means clustering [33] Table 4: Machine learning algorithms and their parameter ranges used for our experiments.",
      "startOffset" : 191,
      "endOffset" : 198
    }, {
      "referenceID" : 84,
      "context" : "Technical Name Algorithm and parameter ranges reference classification ksvm support vector machine [49] C ∈ [2−12, 2], γ ∈ [2−12, 2] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] regression lm linear regression [75] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] clustering XMeans extended k-means clustering [33] Table 4: Machine learning algorithms and their parameter ranges used for our experiments.",
      "startOffset" : 239,
      "endOffset" : 243
    }, {
      "referenceID" : 55,
      "context" : "Technical Name Algorithm and parameter ranges reference classification ksvm support vector machine [49] C ∈ [2−12, 2], γ ∈ [2−12, 2] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] regression lm linear regression [75] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] clustering XMeans extended k-means clustering [33] Table 4: Machine learning algorithms and their parameter ranges used for our experiments.",
      "startOffset" : 308,
      "endOffset" : 312
    }, {
      "referenceID" : 7,
      "context" : "Technical Name Algorithm and parameter ranges reference classification ksvm support vector machine [49] C ∈ [2−12, 2], γ ∈ [2−12, 2] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] regression lm linear regression [75] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] clustering XMeans extended k-means clustering [33] Table 4: Machine learning algorithms and their parameter ranges used for our experiments.",
      "startOffset" : 321,
      "endOffset" : 330
    }, {
      "referenceID" : 0,
      "context" : "Technical Name Algorithm and parameter ranges reference classification ksvm support vector machine [49] C ∈ [2−12, 2], γ ∈ [2−12, 2] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] regression lm linear regression [75] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] clustering XMeans extended k-means clustering [33] Table 4: Machine learning algorithms and their parameter ranges used for our experiments.",
      "startOffset" : 339,
      "endOffset" : 346
    }, {
      "referenceID" : 84,
      "context" : "Technical Name Algorithm and parameter ranges reference classification ksvm support vector machine [49] C ∈ [2−12, 2], γ ∈ [2−12, 2] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] regression lm linear regression [75] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] clustering XMeans extended k-means clustering [33] Table 4: Machine learning algorithms and their parameter ranges used for our experiments.",
      "startOffset" : 387,
      "endOffset" : 391
    }, {
      "referenceID" : 28,
      "context" : "Technical Name Algorithm and parameter ranges reference classification ksvm support vector machine [49] C ∈ [2−12, 2], γ ∈ [2−12, 2] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] regression lm linear regression [75] randomForest random forest [60] ntree ∈ [10, 200], mtry ∈ [1, 30] rpart recursive partitioning tree, CART [91] clustering XMeans extended k-means clustering [33] Table 4: Machine learning algorithms and their parameter ranges used for our experiments.",
      "startOffset" : 438,
      "endOffset" : 442
    }, {
      "referenceID" : 40,
      "context" : "This is in line with recent results showing the strong performance of this model for algorithm runtime prediction [45].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 99,
      "context" : "[106] reported somewhat better results for the three SAT11 datasets than the one achieved here with our off-theshelf methods (which is to be expected since their latest SATzilla version used a cost-sensitive approach and pre-solving schedules).",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 47,
      "context" : "Algorithm and Feature Subset Selection To provide further insights into our algorithm selection scenarios, we applied forward selection [52] to the algorithms and features to determine whether smaller subsets still achieve comparable performance.",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 10,
      "context" : "We note that the selection results use normal resampling and not the nested version, which may result in overconfident performance estimates for the selected subsets [14].",
      "startOffset" : 166,
      "endOffset" : 170
    } ],
    "year" : 2017,
    "abstractText" : "The task of algorithm selection involves choosing an algorithm from a set of algorithms on a per-instance basis in order to exploit the varying performance of algorithms over a set of instances. The algorithm selection problem is attracting increasing attention from researchers and practitioners in AI. Years of fruitful applications in a number of domains have resulted in a large amount of data, but the community lacks a standard format or repository for this data. This situation makes it difficult to share and compare different approaches effectively, as is done in other, more established fields. It also unnecessarily hinders new researchers who want to work in this area. To address this problem, we introduce a standardized format for representing algorithm selection scenarios and a repository that contains a growing number of data sets from the literature. Our format has been designed to be able to express a wide variety of different scenarios. Demonstrating the breadth and power of our platform, we describe a set of example experiments that build and evaluate algorithm selection models through a common interface. The results display the potential of algorithm selection to achieve significant performance improvements across a broad range of problems and algorithms.",
    "creator" : "LaTeX with hyperref package"
  }
}