{
  "name" : "1701.08466.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Predicting SMT Solver Performance for Software Verification",
    "authors" : [ "Andrew Healy", "Rosemary Monahan", "James F. Power" ],
    "emails" : [ "ahealy@cs.nuim.ie", "rosemary@cs.nuim.ie", "jpower@cs.nuim.ie" ],
    "sections" : [ {
      "heading" : null,
      "text" : "C. Dubois, P. Masci, D. Méry (Eds.): F-IDE 2016 EPTCS 240, 2017, pp. 20–37, doi:10.4204/EPTCS.240.2\nc© A. Healy, R. Monahan & J. F. Power This work is licensed under the Creative Commons Attribution License.\nPredicting SMT Solver Performance for Software Verification\nAndrew Healy Rosemary Monahan James F. Power Dept. of Computer Science, Maynooth University, Maynooth, Ireland\nahealy@cs.nuim.ie rosemary@cs.nuim.ie jpower@cs.nuim.ie\nThe Why3 IDE and verification system facilitates the use of a wide range of Satisfiability Modulo Theories (SMT) solvers through a driver-based architecture. We present Where4: a portfolio-based approach to discharge Why3 proof obligations. We use data analysis and machine learning techniques on static metrics derived from program source code. Our approach benefits software engineers by providing a single utility to delegate proof obligations to the solvers most likely to return a useful result. It does this in a time-efficient way using existing Why3 and solver installations — without requiring low-level knowledge about SMT solver operation from the user."
    }, {
      "heading" : "1 Introduction",
      "text" : "The formal verification of software generally requires a software engineer to use a system of tightly integrated components. Such systems typically consist of an IDE that can accommodate both the implementation of a program and the specification of its formal properties. These two aspects of the program are then typically translated into the logical constructs of an intermediate language, forming a series of goals which must be proved in order for the program to be fully verified. These goals (or “proof obligations”) must be formatted for the system’s general-purpose back-end solver. Examples of systems which follow this model are Spec# [3] and Dafny [28] which use the Boogie [2] intermediate language and the Z3 [19] SMT solver.\nWhy3 [22] was developed as an attempt to make use of the wide spectrum of interactive and automated theorem proving tools and overcome the limitations of systems which rely on a single SMT solver. It provides a driver-based, extensible architecture to perform the necessary translations into the input formats of two dozen provers. With a wide choice of theorem-proving tools now available to the software engineer, the question of choosing the most appropriate tool for the task at hand becomes important. It is this question that Where4 answers.\nAs motivation for our approach, Table 1 presents the results from running the Why3 tool over the example programs included in the Why3 distribution (version 0.87.1), using eight SMT solvers at the back-end. Each Why3 file contains a number of theories requiring proof, and these in turn are broken down into a number of goals for the SMT solver; for the data in Table 1 we had 128 example programs, generating 289 theories, in turn generating 1048 goals. In Table 1 each row presents the data for a single SMT solver, and the three main data columns give data totalled on a per-file, per-theory and per-goal basis. Each of these three columns is further broken down to show the number of programs/theories/goals that were successfully solved, their percentage of the total, and the average time taken in seconds for each solver to return such a result. Program verification by modularisation construct is particularly relevant to the use of Why3 on the command line as opposed to through the IDE.\nTable 1 also has a row for an imaginary “theoretical” solver, Choose Single, which corresponds to choosing the best (fastest) solver for each individual program, theory or goal. This solver performs significantly better than any individual solver, and gives an indication of the maximum improvement that could be achieved if it was possible to predict in advance which solver was the best for a given program,\ntheory or goal. In general, the method of choosing from a range of solvers on an individual goal basis is called portfolio-solving. This technique has been successfully implemented in the SAT solver domain by SATzilla [38] and for model-checkers [20][36]. Why3 presents a unique opportunity to use a common input language to develop a portfolio SMT solver specifically designed for software verification.\nThe main contributions of this paper are: 1. The design and implementation of our portfolio solver, Where4, which uses supervised machine\nlearning to predict the best solver to use based on metrics collected from goals.\n2. The integration of Where4 into the user’s existing Why3 work-flow by imitating the behaviour of an orthodox SMT solver.\n3. A set of metrics to characterise Why3 goal formulae.\n4. Statistics on the performance of eight SMT solvers using a dataset of 1048 Why3 goals. Section 2 describes how the data was gathered and discusses issues around the accurate measurement of results and timings. A comparison of prediction models forms the basis of Section 3 where a number of evaluation metrics are introduced. The Where4 tool is compared to a range of SMT tools and strategies in Section 5. The remaining sections present a review of additional related work and a summary of our conclusions."
    }, {
      "heading" : "2 System Overview and Data Preparation",
      "text" : "Due to the diverse range of input languages used by software verification systems, a standardised benchmark repository of verification programs does not yet exist [8]. For our study we chose the 128 example programs included in the Why3 distribution (version 0.87.1) as our corpus for training and testing purposes. The programs in this repository are written in WhyML, a dialect of ML with added specification syntax and verified libraries. Many of the programs are solutions to problems posed at software verification competitions such as VerifyThis [12], VSTTE [26] and COST [14]. Other programs are implementations of benchmarks proposed by the VACID-0 [29] initiative. It is our assumption that these programs\nare a representative software verification workload. Alternatives to this dataset are discussed in Section 6.\nWe used six current, general-purpose SMT solvers supported by Why3: Alt-Ergo [18] versions 0.95.2 and 1.01, CVC3 [6] ver. 2.4.1, CVC4 [4] ver. 1.4, veriT [15], ver. 2015061, Yices [21] ver. 1.0.382, and Z3 [19] ver. 4.3.2 and 4.4.1. We expanded the range of solvers to eight by recording the results for two of the most recent major versions of two popular solvers - Alt-Ergo and Z3.\nWhen a solver is sent a goal by Why3 it returns one of the five possible answers Valid, Invalid, Unknown, Timeout or Failure. As can be seen from Table 1 and Fig. 1, not all goals can be proved Valid or Invalid. Such goals usually require the use of an interactive theorem prover to discharge goals that require reasoning by induction. Sometimes a splitting transformation needs to be applied to simplify the goals before they are sent to the solver. Our tool does not perform any transformations to goals other than those defined by the solver’s Why3 driver file. In other cases, more time or memory resources need to be allocated in order to return a conclusive result. We address the issue of resource allocation in Section 2.1.1."
    }, {
      "heading" : "2.1 Problem Quantification: predictor and response variables",
      "text" : "Two sets of data need to be gathered in supervised machine learning [31]: the independent/predictor variables which are used as input for both training and testing phases, and the dependent/response variables\n1The most recent version - 201506 - is not officially supported by Why3 but is the only version available 2We did not use Yices2 as its lack of support for quantifiers makes it unsuitable for software verification\nwhich correspond to ground truths during training. Of the 128 programs in our dataset, 25% were held back for system evaluation (Section 5). The remaining 75% (corresponding to 96 WhyML programs, 768 goals) were used for training and 4-Fold cross-validation."
    }, {
      "heading" : "2.1.1 Independent/Predictor Variables",
      "text" : "Fig. 2 lists the predictor variables that were used in our study. All of these are (integer-valued) metrics that can be calculated by analysing a Why3 proof obligation, and are similar to the Syntax metadata category for proof obligations written in the TPTP format [34]. To construct a feature vector from each task sent to the solvers, we traverse the abstract syntax tree (AST) for each goal and lemma, counting the number of each syntactic feature we find on the way. We focus on goals and lemmas as they produce proof obligations, with axioms and predicates providing a logical context.\nOur feature extraction algorithm has similarities in this respect to the method used by Why3 for computing goal “shapes” [11]. These shape strings are used internally by Why3 as an identifying fingerprint. Across proof sessions, their use can limit the amount of goals in a file which need to be re-proved."
    }, {
      "heading" : "2.1.2 Dependent/Response Variables",
      "text" : "Our evaluation of the performance of a solver depends on two factors: the time taken to calculate that result, and whether or not the solver had actually proven the goal.\nIn order to accurately measure the time each solver takes to return an answer, we used a measurement framework specifically designed for use in competitive environments. The BenchExec [9] framework was developed by the organisers of the SVCOMP [7] software verification competition to reliably measure CPU time, wall-clock time and memory usage of software verification tools. We recorded the time spent on CPU by each SMT solver for each proof obligation. To account for random errors in\nmeasurement introduced at each execution, we used the methodology described by Lilja [30] to obtain an approximation of the true mean time. A 90% confidence interval was used with an allowed error of ±3.5%.\nBy inspecting our data, we saw that most Valid and Invalid answers returned very quickly, with Unknown answers taking slightly longer, and Failure/Timeout responses taking longest. We took the relative utility of responses to be {Valid, Invalid}>Unknown > {Timeout,Failure} which can be read as “it is better for a solver to return a Valid response than Timeout”, etc. A simple function allocates a cost to each solver S’s response to each goal G:\ncost(S,G) =  timeS,G, if answerS,G ∈ {Valid, Invalid} timeS,G + timeout, if answerS,G =Unknown timeS,G +(timeout×2), if answerS,G ∈ {Timeout,Failure}\nThus, to penalise the solvers that return an Unknown result, the timeout limit is added to the time taken, while solvers returning Timeout or Failure are further penalised by adding double the timeout limit to the time taken. A response of Failure refers to an error with the backend solver and usually means a required logical theory is not supported. This function ensures the best-performing solvers always have the lowest costs. A ranking of solvers for each goal in order of decreasing relevance is obtained by sorting the solvers by ascending cost.\nSince our cost model depends on the time limit value chosen, we need to choose a value that does not favour any one solver. To establish a realistic time limit value, we find each solver’s “Peter Principle Point” [35]. In resource allocation for theorem proving terms, this point can be defined as the time limit at which more resources will not lead to a significant increase in the number of goals the solver can prove.\nFig. 3 shows the number of Valid/Invalid/Unknown results for each prover when given a time limit of 60 seconds. This value was chosen as an upper limit, since a time limit value of 60 seconds is not realistic for most software verification scenarios. Why3, for example, has a default time limit value of 5 seconds. From Fig. 3 we can see that the vast majority of useful responses are returned very quickly.\nBy satisfying ourselves with being able to record 99% of the useful responses which would be returned after 60 seconds, a more reasonable threshold is obtained for each solver. This threshold ranges from 7.35 secs (veriT) to 9.69 secs (Z3-4.3.2). Thus we chose a value of 10 seconds as a representative, realistic time limit that gives each solver a fair opportunity to return decent results."
    }, {
      "heading" : "3 Choosing a prediction model",
      "text" : "Given a Why3 goal, a ranking of solvers can be obtained by sorting the cost for each solver. For unseen instances, two approaches to prediction can be used: (1) classification — predicting the final ranking directly — and (2) regression — predicting each solver’s score individually and deriving a ranking from these predictions. With eight solvers, there are 8! possible rankings. Many of these rankings were observed very rarely or did not appear at all in the training data. Such an unbalanced dataset is not appropriate for accurate classification, leading us to pursue the regression approach.\nSeven regression models were evaluated3: Linear Regression, Ridge Regression, K-Nearest Neighbours, Decision Trees, Random Forests (with and without discretisation) and the regression variant of Support Vector Machines. Table 2 shows the results for some of the best-performing models. Most\n3We used the Python Sci-kit Learn [33] implementations of these models\nmodels were evaluated with and without a weighting function applied to the training samples. Weighting is standard practice in supervised machine learning: each sample’s weight was defined as the standard deviation of solver costs. This function was designed to give more importance to instances where there was a large difference in performance among the solvers.\nTable 2 also shows three theoretical strategies in order to provide bounds for the prediction models. Best always chooses the best ranking of solvers and Worst always chooses the worst ranking (which is the reverse ordering to Best). Random is the average result of choosing every permutation of the eight solvers for each instance in the training set. We use this strategy to represent the user selecting SMT solvers at random without any consideration for goal characterisation or solver capabilities. A comparison to a fixed ordering of solvers for each goal is not made as any such ordering would be arbitrarily determined.\nWe note that the Best theoretical strategy of Table 2 is not directly comparable with the theoretical solver Choose Single from Table 1. The two tables’ average time columns are measuring different results: in contrast to Choose Single, Best will call each solver in turn, as will all the other models in Table 2, until a result Valid/Invalid is recorded (which it may never be). Thus Table 2’s Time column shows the average cumulative time of each such sequence of calls, rather than the average time taken by the single best solver called by Choose Single."
    }, {
      "heading" : "3.1 Evaluating the prediction models",
      "text" : "Table 2’s Time column provides an overall estimate of the effectiveness of each prediction model. We can see that the discretised Random Forest method provides the best overall results for the solvers, yielding an average time of 14.92 seconds.\nThe second numeric column of Table 2 shows the Normalised Discounted Cumulative Gain (nDCG), which is commonly used to evaluate the accuracy of rankings in the search engine and e-commerce recommender system domains [24]. Here, emphasis is placed on correctly predicting items higher in the\nranking. For a general ranking of length p, it is formulated as:\nnDCGp = DCGp IDCGp where DCGp = p ∑ i=1 2reli−1 log2(i+1)\nHere reli refers to the relevance of element i with regard to a ground truth ranking, and we take each solver’s relevance to be inversely proportional to its rank index. In our case, p = 8 (the number of SMT solvers). The DCGp is normalised by dividing it by the maximum (or idealised) value for ranks of length p, denoted IDCGp. As our solver rankings are permutations of the ground truth (making nDCG values of 0 impossible), the values in Table 2 are further normalised to the range [0..1] using the lower nDCG bound for ranks of length 8 — found empirically to be 0.4394.\nThe third numeric column of Table 2 shows the R2 score (or coefficient of determination), which is an established metric for evaluating how well regression models can predict the variance of dependent/response variables. The maximum R2 score is 1 but the minimum can be negative. Note that the theoretical strategies return rankings rather than individual solver costs. For this reason, R2 scores are not applicable. Table 2’s fourth numeric column shows the MAE (Mean Average Error) — a ranking metric which can also be used to measure string similarity. It measures the average distance from each predicted rank position to the solver’s index in the ground truth. Finally, the fifth numeric column of Table 2 shows the mean regression error (Reg. error) which measures the mean absolute difference in predicted solver costs to actual values."
    }, {
      "heading" : "3.2 Discussion: choosing a prediction model",
      "text" : "An interesting feature of all the best-performing models in Table 2 is their ability to predict multi-output variables [13]. In contrast to the Support Vector model, for example, which must predict the cost for each solver individually, a multi-output model predicts each solver’s cost simultaneously. Not only is this method more efficient (by reducing the number of estimators required), but it has the ability to account for the correlation of the response variables. This is a useful property in the software verification domain where certain goals are not provable and others are trivial for SMT solvers. Multiple versions of the same solver can also be expected to have highly correlated costs.\nAfter inspecting the results for all learning algorithms (summarised in Table 2), we can see that random forests [16] perform well, relative to other methods. They score highest for three of the five\nmetrics (shown in bold) and have generally good scores in the others. Random forests are an ensemble extension of decision trees: random subsets of the training data are used to train each tree. For regression tasks, the set of predictions for each tree is averaged to obtain the forest’s prediction. This method is designed to prevent over-fitting.\nBased on the data in Table 2 we selected random forests as the choice of predictor to use in Where4.\n4 Implementing Where4 in OCaml\nWhere4’s interaction with Why3 is inspired by the use of machine learning in the Sledgehammer tool [10] which allows the use of SMT solvers in the interactive theorem prover Isabelle/HOL. We aspired to Sledgehammer’s ‘zero click, zero maintenance, zero overhead’ philosophy in this regard: it should not interfere with a Why3 user’s normal work-flow nor should it penalise those who do not use it.\nWe implement a “pre-solving” heuristic commonly used by portfolio solvers [1][38]: a single solver is called with a short time limit before feature extraction and solver rank prediction takes place. By using a good “pre-solver” at this initial stage, easily-proved instances are filtered with a minimum time overhead. We used a ranking of solvers based on the number of goals each could prove, using the data from Table 1. The highest-ranking solver installed locally is chosen as a pre-solver. For the purposes of this paper which assumes all 8 solvers are installed, the pre-solver corresponds to Alt-Ergo version 1.01. The effect pre-solving has on the method Where4 uses to return responses is illustrated in Alg. 1.\nThe random forest is fitted on the entire training set and encoded as a JSON file for legibility and modularity. This approach allows new trees and forests devised by the user (possibly using new SMT solvers or data) to replace our model. When the user installs Where4 locally, this JSON file is read and printed as an OCaml array. For efficiency, other important configuration information is compiled into OCaml data structures at this stage: e.g. the user’s why3.conf file is read to determine the supported SMT solvers. All files are compiled and a native binary is produced. This only needs to be done once (unless the locally installed provers have changed).\nThe Where4 command-line tool has the following functionality: 1. Read in the WhyML/Why file and extract feature vectors from its goals.\n2. Find the predicted costs for each of the 8 provers by traversing the random forest, using each goal’s feature vector.\n3. Sort the costs to produce a ranking of the SMT solvers.\n4. Return a predicted ranking for each goal in the file, without calling any solver .\n5. Alternatively, use the Why3 API to call each solver (if it is installed) in rank order until a Valid/Invalid answer is returned (using Alg. 1).\nIf the user has selected that Where4 be available for use through Why3, the file which lets Why3 know about supported provers installed locally is modified to contain a new entry for the Where4 binary. A simple driver file (which just tells Why3 to use the Why logical language for encoding) is added to the drivers’ directory. At this point, Where4 can be detected by Why3, and then used at the command line, through the IDE or by the OCaml API just like any other supported solver."
    }, {
      "heading" : "5 Evaluating Where4’s performance on test data",
      "text" : "The evaluation of Where4 was carried out on a test set of 32 WhyML files, 77 theories, 263 goals (representing 25% of the entire dataset). This section is guided by the following three Evaluation Criteria:\nInput: P, a Why3 program; R, a static ranking of solvers for pre-proving; φ , a timeout value Output: 〈A,T 〉 where A = the best answer from the solvers; T = the cumulative time taken to return A begin\n/* Highest ranking solver installed locally */ S← BestInstalled(R) /* Call solver S on Why3 program P with a timeout of 1 second */ 〈A,T 〉 ←Call(P,S,1) if A ∈ {Valid, Invalid} then\nreturn 〈A,T 〉 end /* extract feature vector F from program P */ F ← ExtractFeatures(P) /* R is now based on program features */ R← PredictRanking(F) while A /∈ {Valid, Invalid}∧R 6= /0 do\nS← BestInstalled(R) /* Call solver S on Why3 program P with a timeout of φ seconds */ 〈AS,TS〉 ←Call(P,S,φ) /* add time TS to the cumulative runtime */ T ← T +TS if AS > A then\n/* answer AS is better than the current best answer */ A← AS end /* remove S from the set of solvers R */ R← R\\{S}\nend return 〈A,T 〉\nend Algorithm 1: Returning an answer and runtime from a Why3 input program\n5.1 EC1: How does Where4 perform in comparison to the 8 SMT solvers under consideration?\nWhen each solver in Where4’s ranking sequence is run on each goal, the maximum amount of files, theories and goals are provable. As Table 3 shows, the difference between Where4 and our set of reference theoretical strategies (Best, Random, and Worst) is the amount of time taken to return the Valid/Invalid result. Compared to the 8 SMT provers, the biggest increase is on individual goals: Where4 can prove 203 goals, which is 26 (9.9%) more goals than the next best single SMT solver, Alt-Ergo-1.01.\nUnfortunately, the average time taken to solve each of these goals is high when compared to the 8 SMT provers. This tells us that Where4 can perform badly with goals which are not provable by many SMT solvers: expensive Timeout results are chosen before the Valid result is eventually returned. In the worst case, Where4 may try and time-out for all 8 solvers in sequence, whereas each individual solver does this just once. Thus, while having access to more solvers allows more goals to be proved, there is also a time penalty to portfolio-based solvers in these circumstances.\nAt the other extreme, we could limit the portfolio solver to just using the best predicted individual solver (after “pre-solving”), eliminating the multiple time-out overhead. Fig. 4 shows that the effect of this is to reduce the number of goals provable by Where4, though this is still more than the bestperforming individual SMT solver, Alt-Ergo-1.01.\nTo calibrate this cost of Where4 against the individual SMT solvers, we introduce the notion of a cost threshold: using this strategy, after pre-solving, solvers with a predicted cost above this threshold are not called. If no solver’s cost is predicted below the threshold, the pre-solver’s result is returned.\nFig. 5 shows the effect of varying this threshold, expressed in terms of the average execution time (top graph) and the number of goals solved (bottom graph). As we can see from both graphs in Fig. 5, for the goals in the test set a threshold of 7 for the cost function allows Where4 to prove more goals than any single solver, in a time approximately equal to the four slower solvers (CVC4, veriT and both\nversions of Z3).\n5.2 EC2: How does Where4 perform in comparison to the 3 theoretical ranking strategies?\nFig. 6 compares the cumulative time taken for Where4 and the 3 ranking strategies to return the 203 valid answers in the test set. Although both Where4 and Random finish at approximately the same time, Where4 is significantly faster for returning Valid/Invalid answers. Where4’s solid line is more closely correlated to Best’s rate of success than the erratic rate of the Random strategy. Best’s time result shows the capability of a perfect-scoring learning strategy. It is motivation to further improve Where4 in the future.\n5.3 EC3: What is the time overhead of using Where4 to prove Why3 goals?\nThe timings for Where4 in all plots and tables are based solely on the performance of the constituent solvers (the measurement of which is discussed in Sec. 2.1.2). They do not measure the time it takes for the OCaml binary to extract the static metrics, traverse the decision trees and predict the ranking. We have found that this adds (on average) 0.46 seconds to the time Where4 takes to return a result for each file. On a per goal basis, this is equivalent to an increase in 0.056 seconds.\nThe imitation of an orthodox solver to interact with Why3 is more costly: this is due to Why3 printing each goal as a temporary file to be read in by the solver individually. Future work will look at bypassing this step for WhyML files while still allowing files to be proved on an individual theory and goal basis."
    }, {
      "heading" : "5.4 Threats to Validity",
      "text" : "We categorise threats as either internal or external. Internal threats refer to influences that can affect the response variable without the researcher’s knowledge and threaten the conclusions reached about the cause of the experimental results [37]. Threats to external validity are conditions that limit the generalisability and reproducibility of an experiment."
    }, {
      "heading" : "5.4.1 Internal",
      "text" : "The main threat to our work’s internal validity is selection bias. All of our training and test samples are taken from the same source. We took care to split the data for training and testing purposes on a per file basis. This ensured that Where4 was not trained on a goal belonging to the same theory or file as any goal used for testing. The results of running the solvers on our dataset are imbalanced. There were far more Valid responses than any other response. No goal in our dataset returned an answer of Invalid on any of the 8 solvers. This is a serious problem as Where4 would not be able to recognize such a goal in real-world use. In future work we hope to use the TPTP benchmark library to remedy these issues. The benchmarks in this library come from a diverse range of contributors working in numerous problem domains [35] and are not as specific to software verification as the Why3 suite of examples.\nUse of an independent dataset is likely to influence the performance of the solvers. Alt-Ergo was designed for use with the Why3 platform — its input language is a previous version of the Why logic language. It is natural that the developers of the Why3 examples would write programs which AltErgo in particular would be able to prove. Due to the syntactic similarities in input format and logical similarities such as support for type polymorphism, it is likely that Alt-Ergo would perform well with any Why3 dataset. We would hope, however, that the gulf between it and other solvers would narrow.\nThere may be confounding effects in a solver’s results that are not related to the independent variables we used (Sec. 2.1.1). We were limited in the tools available to extract features from the domain-specific\nWhy logic language (in contrast to related work on model checkers which use the general-purpose C language [20][36]). We made the decision to keep the choice of independent variables simple in order to increase generalisability to other formalisms such as Microsoft’s Boogie [2] intermediate language."
    }, {
      "heading" : "5.4.2 External",
      "text" : "The generalisability of our results is limited by the fact that all dependent variables were measured on a single machine.4 We believe that the number of each response for each solver would not vary dramatically on a different machine of similar specifications. By inspecting the results when each solver was given a timeout of 60 seconds (Fig. 3), the rate of increase for Valid/Invalid results was much lower than that of Unknown/Failure results. The former set of results are more important when computing the cost value for each solver-goal pair.\nTimings of individual goals are likely to vary widely (even across independent executions on the same machine). It is our assumption that although the actual timed values would be quite different on any other machine, the ranking of their timings would stay relatively stable.\nA “typical” software development scenario might involve a user verifying a single file with a small number of resultant goals: certainly much smaller than the size of our test set (263 goals). In such a setting, the productivity gains associated with using Where4 would be minor. Where4 is more suited therefore to large-scale software verification."
    }, {
      "heading" : "5.5 Discussion",
      "text" : "By considering the answers to our three Evaluation Criteria, we can make assertions about the success of Where4. The answer to EC1, Where4’s performance in comparison to individual SMT solvers, is positive. A small improvement in Valid/Invalid responses results from using only the top-ranked solver, while a much bigger increase can be seen by making the full ranking of solvers available for use. The time penalty associated with calling a number of solvers on an un-provable proof obligation is mitigated by the use of a cost threshold. Judicious use of this threshold value can balance the time-taken-versusgoals-proved trade-off: in our test set of 263 POs, using a threshold value of 7 results in 192 Valid responses – an increase of 15 over the single best solver – in a reasonable average time per PO (both Valid and otherwise) of 4.59 seconds.\nThere is also cause for optimism in Where4’s performance as compared to the three theoretical ranking strategies — the subject of Evaluation Criterion 2. All but the most stubborn of Valid answers are returned in a time far better than Random theoretical strategy. We take this random strategy as representing the behaviour of the non-expert Why3 user who does not have a preference amongst the variety of supported SMT solvers. For this user, Where4 could be a valuable tool in the efficient initial verification of proof obligations through the Why3 system.\nIn terms of time overhead — the concern of EC3 — our results are less favourable, particularly when Where4 is used as an integrated part of the Why3 toolchain. The costly printing and parsing of goals slows Where4 beyond the time overhead associated with feature extraction and prediction. At present, due to the diversity of languages and input formats used by software verification tools, this is an unavoidable pre-processing step enforced by Why3 (and is indeed one of the Why3 system’s major advantages).\n4All data collection was conducted on a 64-bit machine running Ubuntu 14.04 with a dual-core Intel i5-4250U CPU and 16GB of RAM.\nOverall, we believe that the results for two out of three Evaluation Criteria are encouraging and suggest a number of directions for future work to improve Where4."
    }, {
      "heading" : "6 Comparison with Related Work",
      "text" : "Comparing verification systems: The need for a standard set of benchmarks for the diverse range of software systems is a recurring issue in the literature [8]. The benefits of such a benchmark suite are identified by the SMTLIB [5] project. The performance of SMT solvers has significantly improved in recent years due in part to the standardisation of an input language and the use of standard benchmark programs in competitions [17][7]. The TPTP (Thousands of Problems for Theorem Provers) project [34] has similar aims but a wider scope: targeting theorem provers which specialise in numerical problems as well as general-purpose SAT and SMT solvers. The TPTP library is specifically designed for the rigorous experimental comparison of solvers [35].\nPortfolio solvers: Portfolio-solving approaches have been implemented successfully in the SAT domain by SATzilla [38] and the constraint satisfaction / optimisation community by tools such as CPHydra [32] and sunny-cp [1]. Numerous studies have used the SVCOMP [7] benchmark suite of C programs for model checkers to train portfolio solvers [36][20]. These particular studies have been predicated on the use of Support Vector Machines (SVM) with only a cursory use of linear regression [36]. In this respect, our project represents a more wide-ranging treatment of the various prediction models available for portfolio solving. The need for a strategy to delegate Why3 goals to appropriate SMT solvers is stated in recent work looking at verification systems on cloud infrastructures [23].\nMachine Learning in Formal Methods: The FlySpec [25] corpus of proofs has been the basis for a growing number of tools integrating interactive theorem provers with machine-learning based factselection. The MaSh engine in Sledgehammer [10] is a related example. It uses a Naive Bayes algorithm and clustering to select facts based on syntactic similarity. Unlike Where4, MaSh uses a number of metrics to measure the shape of goal formulæas features. The weighting of features uses an inverse document frequency (IDF) algorithm. ML4PG (Machine Learning for Proof General) [27] also uses clustering techniques to guide the user for interactive theorem proving.\nOur work adds to the literature by applying a portfolio-solving approach to SMT solvers. We conduct a wider comparison of learning algorithms than other studies which mostly use either SVMs or clustering. Unlike the interactive theorem proving tools mentioned above, Where4 is specifically suited to software verification through its integration with the Why3 system."
    }, {
      "heading" : "7 Conclusion and Future Work",
      "text" : "We have presented a strategy to choose appropriate SMT solvers based on Why3 syntactic features. Users without any knowledge of SMT solvers can prove a greater number of goals in a shorter amount of time by delegating to Where4 than by choosing solvers at random. Although some of Where4’s results are disappointing, we believe that the Why3 platform has great potential for machine-learning based portfolio-solving. We are encouraged by the performance of a theoretical Best strategy and the convenience that such a tool would give Why3 users.\nThe number of potential directions for this work is large: parallel solving, minimal datasets for practical local training, larger and more generic datasets for increased generalisability, etc. The TPTP repository represents a large source of proof obligations which can be translated into the Why logic language. The number of goals provable by Where4 could be increased by identifying which goals need\nto be simplified in order to be tractable for an SMT solver. Splitting transforms would also increase the number of goals for training data: from 1048 to 7489 through the use of the split_goal_wp transform, for example. An interesting direction for this work could be the identification of the appropriate transformations. Also, we will continue to improve the efficiency of Where4 when used as a Why3 solver and investigate the use of a minimal benchmark suite which can be used to train the model using new SMT solvers and theorem provers installed locally.\nData related to this paper is hosted at github.com/ahealy19/F-IDE-2016. Where4 is hosted at github.com/ahealy19/where4.\nAcknowledgments.\nThis project is being carried out with funding provided by Science Foundation Ireland under grant number 11/RFP.1/CMS/3068"
    } ],
    "references" : [ {
      "title" : "SUNNY-CP: A Sequential CP Portfolio Solver",
      "author" : [ "Roberto Amadini", "Maurizio Gabbrielli", "Jacopo Mauro" ],
      "venue" : "ACM Symposium on Applied Computing,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2015
    }, {
      "title" : "Boogie: A Modular Reusable Verifier for Object-Oriented Programs",
      "author" : [ "Mike Barnett", "Bor-Yuh Evan Chang", "Robert DeLine", "Bart Jacobs", "K. Rustan M. Leino" ],
      "venue" : "Formal Methods for Components and Objects: 4th International Symposium,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2005
    }, {
      "title" : "The Spec# Programming System: An Overview. In: Construction and Analysis of Safe, Secure and Interoperable Smart devices",
      "author" : [ "Mike Barnett", "K. Rustan M. Leino", "Wolfram Schulte" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2004
    }, {
      "title" : "The Satisfiability Modulo Theories Library (SMT-LIB). Available at http://www.smt-lib.org",
      "author" : [ "Clark Barrett", "Aaron Stump", "Cesare Tinelli" ],
      "venue" : null,
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2010
    }, {
      "title" : "Status Report on Software Verification. In: Tools and Algorithms for the Construction and Analysis of Systems, Grenoble, France",
      "author" : [ "Dirk Beyer" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2014
    }, {
      "title" : "Evaluating Software Verification Systems: Benchmarks and Competitions (Dagstuhl Reports 14171)",
      "author" : [ "Dirk Beyer", "Marieke Huisman", "Vladimir Klebanov", "Rosemary Monahan" ],
      "venue" : "Dagstuhl Reports",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2014
    }, {
      "title" : "Benchmarking and Resource Measurement. In: Model Checking Software - 22nd International Symposium, SPIN 2015, Stellenbosch",
      "author" : [ "Dirk Beyer", "Stefan Löwe", "Philipp Wendler" ],
      "venue" : "South Africa,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2015
    }, {
      "title" : "Urban (2016): A Learning-Based Fact Selector for Isabelle/HOL",
      "author" : [ "Jasmin Christian Blanchette", "David Greenaway", "Cezary Kaliszyk", "Daniel Kühlwein", "Josef" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2016
    }, {
      "title" : "Preserving User Proofs across Specification Changes",
      "author" : [ "François Bobot", "Jean-Christophe Filliâtre", "Claude Marché", "Guillaume Melquiond", "Andrei Paskevich" ],
      "venue" : "5th International Conference,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2013
    }, {
      "title" : "Let’s verify this with Why3",
      "author" : [ "François Bobot", "Jean-Christophe Filliâtre", "Claude Marché", "Andrei Paskevich" ],
      "venue" : "International Journal on Software Tools for Technology Transfer",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2015
    }, {
      "title" : "A survey on multi-output regression",
      "author" : [ "Hanen Borchani", "Gherardo Varando", "Concha Bielza", "Pedro" ],
      "venue" : "Larranaga",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2015
    }, {
      "title" : "The COST IC0701 Verification Competition",
      "author" : [ "Thorsten Bormer", "Marc Brockschmidt", "Dino Distefano", "Gidon Ernst", "Jean-Christophe Filliâtre", "Radu Grigore", "Marieke Huisman", "Vladimir Klebanov", "Claude Marché", "Rosemary Monahan", "Wojciech Mostowski", "Nadia Polikarpova", "Christoph Scheben", "Gerhard Schellhorn", "Bogdan Tofan", "Julian Tschannen", "Mattias Ulbrich" ],
      "venue" : "Formal Verification of Object-Oriented Software,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2011
    }, {
      "title" : "veriT: An Open, Trustable and Efficient SMT-Solver",
      "author" : [ "Thomas Bouton", "Diego Caminha B. de Oliveira", "David Déharbe", "Pascal Fontaine" ],
      "venue" : "In: 22nd International Conference on Automated Deduction,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2009
    }, {
      "title" : "The Alt-Ergo automatic theorem prover. Available at http: //alt-ergo.lri.fr",
      "author" : [ "Sylvain Conchon", "Évelyne Contejean" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2008
    }, {
      "title" : "Empirical Software Metrics for Benchmarking of Verification Tools",
      "author" : [ "Yulia Demyanova", "Thomas Pani", "Helmut Veith", "Florian Zuleger" ],
      "venue" : null,
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2015
    }, {
      "title" : "The Yices SMT Solver. Available at http://yices.csl. sri.com/papers/tool-paper.pdf",
      "author" : [ "Bruno Dutertre", "Leonardo de Moura" ],
      "venue" : null,
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2006
    }, {
      "title" : "2016): Rodin Platform Why3 Plug-In",
      "author" : [ "Alexei Iliasov", "Paulius Stankaitis", "David Adjepon-Yamoah", "Alexander Romanovsky" ],
      "venue" : "ABZ",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2016
    }, {
      "title" : "IR Research: Systems, Interaction, Evaluation and Theories",
      "author" : [ "Kalervo Järvelin" ],
      "venue" : "SIGIR Forum 45(2),",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2012
    }, {
      "title" : "Learning-Assisted Automated Reasoning with Flyspeck",
      "author" : [ "Cezary Kaliszyk", "Josef" ],
      "venue" : "Journal of Automated Reasoning",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2014
    }, {
      "title" : "The 1st Verified Software Competition: Experience Report",
      "author" : [ "Vladimir Klebanov", "Peter Müller", "Natarajan Shankar", "Gary T. Leavens", "Valentin Wüstholz", "Eyad Alkassar", "Rob Arthan", "Derek Bronish", "Rod Chapman", "Ernie Cohen", "Mark Hillebrand", "Bart Jacobs", "K. Rustan M. Leino", "Rosemary Monahan", "Frank Piessens", "Nadia Polikarpova", "Tom Ridge", "Jan Smans", "Stephan Tobies", "Thomas Tuerk", "Mattias Ulbrich", "Benjamin Weiß" ],
      "venue" : "FM 2011: 17th International Symposium on Formal Methods,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2011
    }, {
      "title" : "Machine Learning in Proof General: Interfacing Interfaces",
      "author" : [ "Ekaterina Komendantskaya", "Jónathan Heras", "Gudmund Grov" ],
      "venue" : "In: 10th International Workshop On User Interfaces for Theorem Provers, Bremen, Germany,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2012
    }, {
      "title" : "Dafny: An Automatic Program Verifier for Functional Correctness. In: Logic for Programming, Artificial Intelligence, and Reasoning: 16th International Conference, Dakar, Senegal",
      "author" : [ "K. Rustan M. Leino" ],
      "venue" : "pp. 348–370,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2010
    }, {
      "title" : "VACID-0: Verification of Ample Correctness of Invariants of Data-structures, Edition",
      "author" : [ "K. Rustan M. Leino", "Michał Moskal" ],
      "venue" : "Tools and Experiments Workshop at VSTTE. Available at https://www",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2010
    }, {
      "title" : "Measuring computer performance: a practitioner’s guide",
      "author" : [ "David J Lilja" ],
      "venue" : null,
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2000
    }, {
      "title" : "Using casebased reasoning in an algorithm portfolio for constraint solving",
      "author" : [ "Eoin O’Mahony", "Emmanuel Hebrard", "Alan Holland", "Conor Nugent", "Barry O’Sullivan" ],
      "venue" : "Irish Conference on Artificial Intelligence and Cognitive Science,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2008
    }, {
      "title" : "Scikit-learn: Machine Learning in Python",
      "author" : [ "Fabian Pedregosa", "Gaël Varoquaux", "Alexandre Gramfort", "Vincent Michel", "Bertrand Thirion", "Olivier Grisel", "Mathieu Blondel", "Peter Prettenhofer", "Ron Weiss", "Vincent Dubourg", "Jake Vanderplas", "Alexandre Passos", "David Cournapeau", "Mathieu Brucher", "Mathieu Perrot", "Édouard Duchesnay" ],
      "venue" : "Journal of Machine Learning Research",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2011
    }, {
      "title" : "The TPTP Problem Library",
      "author" : [ "Geoff Sutcliffe", "Christian Suttner" ],
      "venue" : "Journal Automated Reasoning",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 1998
    }, {
      "title" : "Evaluating general purpose automated theorem proving systems",
      "author" : [ "Geoff Sutcliffe", "Christian Suttner" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2001
    }, {
      "title" : "MUX: algorithm selection for software model checkers",
      "author" : [ "Varun Tulsian", "Aditya Kanade", "Rahul Kumar", "Akash Lal", "Aditya V. Nori" ],
      "venue" : "Working Conference on Mining Software Repositories,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2014
    }, {
      "title" : "SATzilla: Portfolio-based Algorithm Selection for SAT",
      "author" : [ "Lin Xu", "Frank Hutter", "Holger H. Hoos", "Kevin Leyton-Brown" ],
      "venue" : "Journal of Artificial Intelligence Research",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "Examples of systems which follow this model are Spec# [3] and Dafny [28] which use the Boogie [2] intermediate language and the Z3 [19] SMT solver.",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 21,
      "context" : "Examples of systems which follow this model are Spec# [3] and Dafny [28] which use the Boogie [2] intermediate language and the Z3 [19] SMT solver.",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 1,
      "context" : "Examples of systems which follow this model are Spec# [3] and Dafny [28] which use the Boogie [2] intermediate language and the Z3 [19] SMT solver.",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 29,
      "context" : "This technique has been successfully implemented in the SAT solver domain by SATzilla [38] and for model-checkers [20][36].",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 14,
      "context" : "This technique has been successfully implemented in the SAT solver domain by SATzilla [38] and for model-checkers [20][36].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 28,
      "context" : "This technique has been successfully implemented in the SAT solver domain by SATzilla [38] and for model-checkers [20][36].",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 5,
      "context" : "Due to the diverse range of input languages used by software verification systems, a standardised benchmark repository of verification programs does not yet exist [8].",
      "startOffset" : 163,
      "endOffset" : 166
    }, {
      "referenceID" : 9,
      "context" : "Many of the programs are solutions to problems posed at software verification competitions such as VerifyThis [12], VSTTE [26] and COST [14].",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 19,
      "context" : "Many of the programs are solutions to problems posed at software verification competitions such as VerifyThis [12], VSTTE [26] and COST [14].",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 11,
      "context" : "Many of the programs are solutions to problems posed at software verification competitions such as VerifyThis [12], VSTTE [26] and COST [14].",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 22,
      "context" : "Other programs are implementations of benchmarks proposed by the VACID-0 [29] initiative.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 13,
      "context" : "We used six current, general-purpose SMT solvers supported by Why3: Alt-Ergo [18] versions 0.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 12,
      "context" : "4, veriT [15], ver.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 15,
      "context" : "2015061, Yices [21] ver.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 26,
      "context" : "All of these are (integer-valued) metrics that can be calculated by analysing a Why3 proof obligation, and are similar to the Syntax metadata category for proof obligations written in the TPTP format [34].",
      "startOffset" : 200,
      "endOffset" : 204
    }, {
      "referenceID" : 8,
      "context" : "Our feature extraction algorithm has similarities in this respect to the method used by Why3 for computing goal “shapes” [11].",
      "startOffset" : 121,
      "endOffset" : 125
    }, {
      "referenceID" : 6,
      "context" : "The BenchExec [9] framework was developed by the organisers of the SVCOMP [7] software verification competition to reliably measure CPU time, wall-clock time and memory usage of software verification tools.",
      "startOffset" : 14,
      "endOffset" : 17
    }, {
      "referenceID" : 4,
      "context" : "The BenchExec [9] framework was developed by the organisers of the SVCOMP [7] software verification competition to reliably measure CPU time, wall-clock time and memory usage of software verification tools.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 23,
      "context" : "measurement introduced at each execution, we used the methodology described by Lilja [30] to obtain an approximation of the true mean time.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 27,
      "context" : "To establish a realistic time limit value, we find each solver’s “Peter Principle Point” [35].",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 25,
      "context" : "3We used the Python Sci-kit Learn [33] implementations of these models",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 17,
      "context" : "The second numeric column of Table 2 shows the Normalised Discounted Cumulative Gain (nDCG), which is commonly used to evaluate the accuracy of rankings in the search engine and e-commerce recommender system domains [24].",
      "startOffset" : 216,
      "endOffset" : 220
    }, {
      "referenceID" : 10,
      "context" : "An interesting feature of all the best-performing models in Table 2 is their ability to predict multi-output variables [13].",
      "startOffset" : 119,
      "endOffset" : 123
    }, {
      "referenceID" : 7,
      "context" : "Where4’s interaction with Why3 is inspired by the use of machine learning in the Sledgehammer tool [10] which allows the use of SMT solvers in the interactive theorem prover Isabelle/HOL.",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 0,
      "context" : "We implement a “pre-solving” heuristic commonly used by portfolio solvers [1][38]: a single solver is called with a short time limit before feature extraction and solver rank prediction takes place.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 29,
      "context" : "We implement a “pre-solving” heuristic commonly used by portfolio solvers [1][38]: a single solver is called with a short time limit before feature extraction and solver rank prediction takes place.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 27,
      "context" : "The benchmarks in this library come from a diverse range of contributors working in numerous problem domains [35] and are not as specific to software verification as the Why3 suite of examples.",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 14,
      "context" : "Why logic language (in contrast to related work on model checkers which use the general-purpose C language [20][36]).",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 28,
      "context" : "Why logic language (in contrast to related work on model checkers which use the general-purpose C language [20][36]).",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 1,
      "context" : "We made the decision to keep the choice of independent variables simple in order to increase generalisability to other formalisms such as Microsoft’s Boogie [2] intermediate language.",
      "startOffset" : 157,
      "endOffset" : 160
    }, {
      "referenceID" : 5,
      "context" : "Comparing verification systems: The need for a standard set of benchmarks for the diverse range of software systems is a recurring issue in the literature [8].",
      "startOffset" : 155,
      "endOffset" : 158
    }, {
      "referenceID" : 3,
      "context" : "The benefits of such a benchmark suite are identified by the SMTLIB [5] project.",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 4,
      "context" : "The performance of SMT solvers has significantly improved in recent years due in part to the standardisation of an input language and the use of standard benchmark programs in competitions [17][7].",
      "startOffset" : 193,
      "endOffset" : 196
    }, {
      "referenceID" : 26,
      "context" : "The TPTP (Thousands of Problems for Theorem Provers) project [34] has similar aims but a wider scope: targeting theorem provers which specialise in numerical problems as well as general-purpose SAT and SMT solvers.",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 27,
      "context" : "The TPTP library is specifically designed for the rigorous experimental comparison of solvers [35].",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 29,
      "context" : "Portfolio solvers: Portfolio-solving approaches have been implemented successfully in the SAT domain by SATzilla [38] and the constraint satisfaction / optimisation community by tools such as CPHydra [32] and sunny-cp [1].",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 24,
      "context" : "Portfolio solvers: Portfolio-solving approaches have been implemented successfully in the SAT domain by SATzilla [38] and the constraint satisfaction / optimisation community by tools such as CPHydra [32] and sunny-cp [1].",
      "startOffset" : 200,
      "endOffset" : 204
    }, {
      "referenceID" : 0,
      "context" : "Portfolio solvers: Portfolio-solving approaches have been implemented successfully in the SAT domain by SATzilla [38] and the constraint satisfaction / optimisation community by tools such as CPHydra [32] and sunny-cp [1].",
      "startOffset" : 218,
      "endOffset" : 221
    }, {
      "referenceID" : 4,
      "context" : "Numerous studies have used the SVCOMP [7] benchmark suite of C programs for model checkers to train portfolio solvers [36][20].",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 28,
      "context" : "Numerous studies have used the SVCOMP [7] benchmark suite of C programs for model checkers to train portfolio solvers [36][20].",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 14,
      "context" : "Numerous studies have used the SVCOMP [7] benchmark suite of C programs for model checkers to train portfolio solvers [36][20].",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 28,
      "context" : "These particular studies have been predicated on the use of Support Vector Machines (SVM) with only a cursory use of linear regression [36].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 16,
      "context" : "The need for a strategy to delegate Why3 goals to appropriate SMT solvers is stated in recent work looking at verification systems on cloud infrastructures [23].",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 18,
      "context" : "Machine Learning in Formal Methods: The FlySpec [25] corpus of proofs has been the basis for a growing number of tools integrating interactive theorem provers with machine-learning based factselection.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 7,
      "context" : "The MaSh engine in Sledgehammer [10] is a related example.",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 20,
      "context" : "ML4PG (Machine Learning for Proof General) [27] also uses clustering techniques to guide the user for interactive theorem proving.",
      "startOffset" : 43,
      "endOffset" : 47
    } ],
    "year" : 2017,
    "abstractText" : "The Why3 IDE and verification system facilitates the use of a wide range of Satisfiability Modulo Theories (SMT) solvers through a driver-based architecture. We present Where4: a portfolio-based approach to discharge Why3 proof obligations. We use data analysis and machine learning techniques on static metrics derived from program source code. Our approach benefits software engineers by providing a single utility to delegate proof obligations to the solvers most likely to return a useful result. It does this in a time-efficient way using existing Why3 and solver installations — without requiring low-level knowledge about SMT solver operation from the user.",
    "creator" : "LaTeX with hyperref package"
  }
}