{
  "name" : "1705.04712.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Progression of Decomposed Local-Effect Action Theories",
    "authors" : [ "Denis Ponomaryov", "Mikhail Soutchanski" ],
    "emails" : [ "ponom@iis.nsk.su,", "mes@scs.ryerson.ca" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 5.\n04 71\n2v 1\n[ cs\n.A I]\n1 2\nM ay"
    }, {
      "heading" : "1 Introduction",
      "text" : "Modularity of theories has been established as an important research topic in knowledge representation. It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few. Surprisingly, this research topic is little explored in the context of reasoning about actions. More specifically, it is natural to decompose a large heterogeneous theory covering several loosely-coupled application domains into components that have little or no intersection in terms of signatures. Potentially, such decomposition can facilitate solving the projection problem, which requires answering whether a given logical formula is true after executing a sequence of actions (events). In cases, when a query is a logical formula composed from symbols occurring in only one of the components, the query can be answered more easily than in the case when the whole theory is required. This decomposition can help in solving other reasoning problems (e.g. planning or high-level program execution) that require a solution to the projection problem as a prerequisite. To the best of our knowledge, the only previous work that explored decomposition of logical theories for the purposes of solving the projection problem are the papers [1,2]. These papers investigate decomposition in the situation calculus\n[34,43], a well-known logical formalism for representation of actions and their effects. The author proposed reasoning procedures for a situation calculus theory by dividing the whole theory syntactically into weakly-related partitions. Specifically, he developed algorithms that use local computation inside syntactically-identified partitions and message passing between partitions. We take a different approach in our paper: instead of decomposing the whole action theory into subsets, as in [1,2], we consider signature decompositions of an initial theory only. Our components are not necessarily syntactic subsets of the initial theory. We concentrate on foundations, and explore properties of components produced by our decomposition. Whenever possible, we try to formulate these properties in a general logical language L, that is a fragment of second order logic; however, when necessary, we focus on a specific logic.\nThis paper considers the decomposability and inseparability properties of logical theories. These properties are well known in research on modularization in the area of knowledge representation [17,38,18,32], but have not been studied previously in the scope of the situation calculus. Both properties are concerned with subdividing theories into components to facilitate reasoning. Informally, decomposability of a theory means that the theory can be equivalently represented as a union of two (or several) theories sharing a given set (∆) of signature symbols. Inseparability of theories wrt some signature∆ means that the theories have the same set of logical consequences in the signature∆. If a theory (T ) is∆–decomposable into∆–inseparable components, then (under certain restrictions on the underlying logic) each component of the decomposition contains all information from T in its own signature. This is an ideal case of decomposition, since in this case the problem of entailment from T can be reduced to entailment from components, which are potentially smaller than the theory T .\nIn the area of reasoning about actions, an initial logical theory represents knowledge that is subject to change due to the effects of actions on some of the properties mentioned in the theory. It can be updated with new information caused by actions, while some other knowledge should be forgotten, as it is no longer true in the next situation. We consider two types of update operators: 1) forgetting in arbitrary theories and 2) progression of theories in the situation calculus. Forgetting is a well-known operation on theories first introduced by Fangzhen Lin and Ray Reiter in their seminal paper [25]. Forgetting a signature σ in a theory T means obtaining a theory indistinguishable from T in the rest of the signature symbols sig (T )\\σ. In this sense, forgetting a signature is close to the well-known notion of uniform interpolation. Forgetting a ground atom P (t̄) in a theory T results in a theory that implies all the consequences of T “modulo” the truth value of P (t̄). The operation of forgetting is closely related to progression in basic action theories in the situation calculus.\nThe situation calculus [43] is a knowledge representation logical formalism, which has been designed for axiomatization of problems in planning and high-level program execution. The idea is to 1) axiomatize a set of initial states (as an initial theory), 2) axiomatize preconditions telling when actions can be performed, and then 3) add the axioms about the effects of actions on situationdependent properties. After these steps, one can reason about the consequences of sequences of actions to determine whether properties of interest hold in a given situation resulting from executing a sequence of actions and whether a certain sequence of actions is consecutively executable. In the situation calculus, the so-called basic action theories represent such axiomatizations [43]. Each basic action theory contains an initial theory that represents incomplete knowledge about an initial situation S0. In a special case, when there is complete knowledge about a finite number of individuals having unique names, the initial theory can be implemented as a relational database [43,8]. Roughly, a basic action theory D is a union of an initial theory DS0 with some theory T , defining\ntransitions among situations, and a set of “canonical” axioms assumed to be true for all application problems represented in the situation calculus. Informally speaking, an update of the initial theory after execution of an action is called “progression of the initial theory wrt an action”. More precisely, progression of DS0 wrt some action α is a logical consequence of D which contains all information from D about the situation resulting from the execution of α in the situation S0. Ideally, it is computed as updating DS0 with some logical consequences of T , once all information in DS0 , which is no longer true in the resulting situation, has been forgotten. Progression is important for practical agents with indefinite horizon since progression is the only feasible way of maintaining knowledge about the world. Exploiting modularity in the vast agent’s knowledge is important to guarantee that progression of the agent’s knowledge will be computationally feasible.\nHistorically, the “situation calculus” (earlier referred to as “situational logic”) is the earliest logical framework developed in the area of artificial intelligence (AI). Having been developed in the 1960s by John McCarthy and his colleagues [33,34,14], it is one of the most popular logical frameworks for reasoning about actions; it is presented in most well-known textbooks on AI. It is worth mentioning that there are both conceptual and technical differences between the situation calculus, designed for reasoning about arbitrary actions, and the Floyd–Hoare logic, Dijkstra’s predicate transformers, and dynamic logic, and other related formalisms, which have been developed for reasoning about the correctness of computer programs. For example, the latter category of formalisms would consider the operator assigning a new value to a variable in a program as a primitive action, while the former would consider as primitive the actions on higher level of abstraction, such as moving a book from its current location to the table. For this reason, the situation calculus is chosen as foundation for high-level programming languages in cognitive robotics [22]. In our paper, when we refer to the “situation calculus”, we are following the axiomatic approach and notation proposed by R.Reiter [43] who developed a general approach to axiomatizing direct effects and non-effects of actions. It has been observed for a long time that in practical applications, real-world actions have no effect on most properties. However, it was Reiter who first proposed an elegant axiomatization that represents compactly non-effects of actions. Reiter’s book covers several extensions of the situation calculus to reasoning about concurrent actions, instantaneous actions, processes extended in time, interaction between action and knowledge, stochastic actions, as well as high-level programming languages based on the situation calculus. In our paper, we will focus on the cases of situation calculus when actions are sequential, atemporal, and deterministic. Despite this focus, our results can be subsequently adapted to characterize more general classes of actions. The main limitation of our work is in concentrating on direct effects only. Indirect effects of actions are beyond the scope of the present study and will be considered in future work.\nIn this paper, we are interested in the case when the initial theory is decomposed into inseparable components, studying which conditions guarantee preservation of decomposability and inseparability of components after forgetting or progression. We would like to avoid recomputing a decomposition of an updated initial theory after executing an action. Moreover, we would like to know whether the components remain inseparable after progression. Such invariance of decomposability and inseparability wrt progression is important since progression may continue indefinitely as long as new actions are being executed. If decomposability and inseparability are always preserved, then it would suffice to compute a decomposition of the initial theory once – this decomposition will remain “stable\" after progression wrt any arbitrary sequence of actions. Additionally, if an executed action has effects only on one component of the initial theory, then we would like to be able to compute progression using only this part instead of the whole initial theory. This leads to the question of\nwhen the decomposability and inseparability properties are preserved under progression and under forgetting. To answer this question we have to better understand the properties of these two operations. In our study, for brevity, when we refer to “decomposability” and “inseparability” properties of components, we will use the phrase component properties.\nThis paper contributes to the general understanding of forgetting and progression in the literature, since new results on them are needed for the purposes of our investigation.Not surprisingly, both forgetting and progression have intricate interactions with properties of decomposed components. We will demonstrate that, in general, it is very difficult to guarantee the preservation of decomposability and inseparability, because there is a certain conceptual distance between these notions on one hand, and forgetting and progression on the other – we provide examples witnessing this. Nevertheless, we will identify cases when these properties remain invariant. Our results show that some of these cases have a practically important formulation. An important contribution of the paper is in formulating clear negative examples that demonstrate cases when decomposability and inseparability are lost under progression. Thus, the paper contributes to understanding the limits of the component approach based on these properties. In particular, our examples demonstrate that there is little hope to preserve inseparability if the different components share a fluent. Decomposability turns out to be also a fragile property that can be easily lost after executing just one action in a simple basic action theory. Overall, this paper contributes by advancing the study of forgetting and progression, and also by carrying out a thorough and comprehensive study of when decomposability and inseparability are preserved and when they are lost.\nWe start in Section 2 by introducing basic notations and then provide a survey on decomposability and inseparability, the two component properties of theories considered in this paper. Then in Section 3 we introduce the basics of the situation calculus, proceeding to the component properties of forgetting in Section 3 and progression in Section 4. The last section, Section 5, includes a summary of the obtained results. A preliminary shorter version of this paper (without proofs) appeared in the proceedings of AAAI-13 conference [40]. This extended version of our paper includes new results not mentioned in the conference version as well as proofs and a detailed backgroundmaterial and discussion of previously published results about forgetting and progression, in order to make this paper self-contained."
    }, {
      "heading" : "2 Background",
      "text" : ""
    }, {
      "heading" : "2.1 Conventions and Notations",
      "text" : "Let L be a logic (possibly many-sorted), which is a fragment (a set of sentences) of second-order logic (either by syntax or by translation of formulas), and has the standard model-theoretic Tarskian semantics. We call the signature a subset of non-logical symbols of L (and treat equality as a logical symbol). If M1 and M2 are two many–sorted structures and ∆ is a signature then we say that M1 and M2 agree on ∆ if they have the same domains for each sort and the same interpretation of every symbol from∆. If M is a structure and σ is a subset of predicate and function symbols from M, then we denote by M|σ the reduct of M to σ, i.e., the structure with predicate and function names from σ, where every symbol of σ names the same entity as in M. The structure M is called expansion of M|σ . For a set of formulas T in L, we denote by sig (T ) the signature of T , i.e. the set of all non-logical symbols which occur in T . We will use the same notation sig (ϕ) for the signature of a formula ϕ in L. If t is a term in the logic L then the same notation sig (t) will be used for the set of all non-logical symbols occurring in t. Throughout this paper, we use the notion\nof theory as a synonym for a set of formulas in L, which are sentences when translated into secondorder logic. Whenever we mention a set of formulas, it is assumed that this set is in L, if the context is not specified. For two theories, T1 and T2, the notation T1 ≡ T2 will be the abbreviation for the semantic equivalence. If T is a set of formulas in L and ∆ is a signature, then Cons (T , ∆) will denote the set of semantic consequences of T (in L) in the signature ∆, i.e. Cons (T , ∆) = {ϕ ∈ L | T |= ϕ and sig (ϕ) ⊆ ∆}. We emphasize that this is a notation for a set of formulas in L, because T may semantically entail formulas that are outside of L."
    }, {
      "heading" : "2.2 Basic Facts about Decomposability and Inseparability",
      "text" : "In the area of theory modularization, a module (or component) is usually understood as a set of theory consequences that satisfy certain properties. The latter are determined by requirements to a module in the context of application. Some approaches follow the idea that a module should be a syntactic subset of the axioms of a given theory. For instance, a theory can be partitioned into subsets of axioms meeting certain requirements of balance among the partition. Thereafter, reasoning wrt the initial theory can be reduced to reasoning within the obtained components via a message passing algorithm, which communicates between the partitions to find information needed to answer a query [3]. As a rule, the information to be communicated relates to the signatures shared between the partitions. The advantage of this approach is that the partitioning algorithm can be relatively simple and rely on syntactic analysis of theory axioms, thereby circumventing semantics. On the other hand, it may not be possible to eliminate some dependences between the partitions, if they are induced by syntactic form of the axioms. For instance, if a theory T consists of the axioms {∀x P (x), ∀x (P (x) ↔ Q(x))}, then it may not be possible to infer that it can be represented as the union of two components {∀xP (x)} and {∀xQ(x)}, which do not share any signature symbols. In other words, a theory with syntactic dependencies may have an axiomatization that yields a partitioning into components, which either do not have symbols in common, or in a more general case, share a fixed signature (given as a parameter of decomposition).\nIn our paper, we adopt the following notion that was introduced in [38] and applied to the study of modularity in [17].\nDefinition 2.1 (∆–decomposability property) Let T be a theory in L and∆ ⊆ sig (T ) a subsignature. We call T ∆–decomposable, if there are theories T1 and T2 in L such that\n– sig (T1) ∩ sig (T2) = ∆, but sig (T1) 6= ∆ 6= sig (T2); – sig (T1) ∪ sig (T2) = sig (T ); – T ≡ T1 ∪ T2.\nThe pair 〈T1, T2〉 is called ∆–decomposition of T and the theories T1 and T2 are called ∆– decomposition components of T . We will sometimes omit the word “decomposition\" and call the sets T1 and T2 simply components of T , when the signature ∆ is clear from the context. The sets sig (T1) \\∆ and sig (T2) \\∆ are called signature (∆–decomposition) components of T .\nThe notion of∆–decomposition is defined using a pair of theories, but it can be easily extended to the case of a family of theories. It is important to realize that T1 and T2 are not necessarily subsets of axioms of T in the above definition. We only require that T ≡ T1 ∪ T2. Clearly, if L satisfies compactness and T is a finite ∆–decomposable theory in L for a signature ∆, then there is a ∆– decomposition 〈T1, T2〉 of T , where T1 and T2 are finite.\nNote that the axioms of theory T given beforeDefinition 2.1 can not be (syntactically) partitioned into subsets having no signature symbols in common. However T has a different axiomatization given by ∀xP (x) and ∀xQ(x) and hence, is ∅-decomposable. Thus, in general ∆-decomposition can be finer than a syntactic partitioning based on a particular axiomatization of a theory.\nAccording to the definition of decomposability, computing a decomposition means finding another (equivalent) representation of a theory, which defines the required components. This means that a decomposition procedure must employ logical reasoning. Therefore, potentially it is more computationally complex than syntactic partitioning, which splits a theory into syntactic subsets of axioms. However, the research on algorithmic properties of decomposability (see e.g., [39,9,17,35,38]) shows that deciding whether a theory is ∆-decomposable turns out to be not harder than deciding the entailment in the underlying logic. Studying the complexity of decomposability in different logics is an ongoing research topic. An algorithm for computing decomposition components can be obtained, e.g., from a procedure of computing uniform interpolants (if the logic enjoys efficient uniform interpolation, see Proposition 2 in [38] and [35]), or by applying the technique of eliminating non-∆-symbols from the axioms of a theory. The technique is described in [17] for the logics EL and DL-Lite, which is further studied in [41] and can be extended to more expressive Description Logics. Using any form of equivalent rewriting means that the obtained axiomatization may be of a size larger than the set of axioms of the original theory. In particular, finding a decomposition may imply computing explicit definitions, in which case the size of the components depends on the complexity of such definitions in the underlying logic. For instance, a decomposition component may be of size exponentially larger than the original theory, which is evidenced by Example 28 in [17]. It is known that in general there is no upper bound on the complexity of explicit definitions in first-order logic [11,36] and computing them is usually harder than entailment in FOL fragments (see e.g. [44]). On the other hand, one can take control over the growth of the component sizes by carefully choosing which signature ∆ can be shared between the components. Using Example 28 from [17], for instance, it possible to describe a situation when tuning up ∆ can exponentially reduce the component sizes. In general however, this question motivates research on the succinctness of explicit definitions and uniform interpolants in different logics.\nAn important requirement often considered in the literature is that a module must contain all information about a signature of interest∆, which is typically a subset of the signature of the module. In other words, it is required that a module must entail the same consequences in signature ∆, as the source theory. Having fixed a signature ∆, the ability to see differences between two theories strongly depends on the logic being used as “lens” for their examination: the more expressive power the logic employed has, the more differences it is possible to see. Probably the most powerful tool in measuring similarity of theories is the language of second-order logic. If two theories have the same sets of second-order consequences in a signature∆, then the classes of reducts of their models onto ∆ coincide, i.e. both theories “define” the same semantics for ∆-symbols. Keeping in mind that a module is usually understood as a set of consequences of a source theory, it is important to note the following model-theoretic fact, which will be helpful for grasping the results of this paper. It says that if a logic L is weaker than second-order, then in general, a set of consequences of a theory T in L may not be able to capture the intended semantics of symbols from a subsignature ∆, as defined by T .\nFact 2.2 If T is a theory in L and ∆ a signature, then some models of Cons (T , ∆) may not have an expansion to a model of T .\nIndeed, let L be first-order logic and {P, f} be a signature, where P is a unary predicate and f is a unary function. Let T be a theory saying that f is a bijection between the interpretation of"
    }, {
      "heading" : "P and its complement. Thus, T axiomatizes the class of models, where the interpretation of P and its complement are of the same cardinality. Let M be a model from this class and let N be a model",
      "text" : "of the same signature {P} in which the interpretation of P is a countable set, but the complement is uncountable. The modelsM and N are elementary equivalent, i.e., no formula in signature {P} can distinguish between these two models. For instance, this can be shown by using the fact (e.g., see [10]) that every sentence in signature {P} is equivalent to a boolean combination of formulas ∃>mP and ∃>m¬P , where an integerm > 0, which mean “P (respectively, ¬P ) holds on at least m distinct elements”. Therefore,N is a model of Cons (T , {P}), but clearly, it has no expansion to a model of T .\nAs will be noted in Section 3, forgetting is an operation, which gives a set of (second-order) consequences axiomatizing the same class of models, as the original theory, modulo forgotten signature/ground atom.\nIt is known that in general, a set of consequences of a theory may not be finitely axiomatizable in the logic, in which the theory is formulated. For instance, the following example is widely known in the literature on Description Logics (e.g., see Section 3.2 in [31]).\nFact 2.3 If T is a theory inL and∆ a signature, then Cons (T , ∆)may not be finitely axiomatizable in L.\nLet T be the first-order theory axiomatized by the following two axioms: ∀x [A(x) → B(x) ] ∀x [B(x) → ∃y(R(x, y) ∧B(y)) ]\nConsider the signature ∆ = {A,R}. Then it is not hard to verify that Cons (T , ∆) is equivalent to the following infinite set of formulas:\n∀xA(x) → ∃yR(x, y) ∀xA(x) → ∃y∃u[R(x, y) ∧R(y, u) ] ∀xA(x) → ∃y∃u∃v[R(x, y) ∧R(y, u) ∧R(u, v) ] ..."
    }, {
      "heading" : "By compactness, this theory is not finitely axiomatizable in first-order logic.",
      "text" : "A well-known concept used to characterize similarity of two theories wrt a signature is inseparability. This notion has also appeared in the context of entailment in Description Logics, e.g., see [18,32].\nDefinition 2.4 (∆–inseparability) Theories T1 and T2 in L are called ∆–inseparable, for a signature ∆, if Cons (T1, ∆) = Cons (T2, ∆).\nIn other words, T1 and T2 are ∆–inseparable if for any L-formula ψ in signature ∆, T1 entails ψ iff T2 does. That is, in the language L, no query in signature ∆ separates T1 and T2 from each other. If Cons () is augmented with the third parameter specifying a logic, in which consequences are taken, then inseparability gives rise to a variety of notions of similarity between theories. As informally noted, two theories may be inseparable wrt a logic L, but entail different consequences wrt a language more expressive than L. For the purpose of this paper, we consider the non-parametrized notion of inseparability, assuming that the language of interest is the underlying logic L, in which\nthe theories are formulated. This assumption is natural if one is only interested in entailment of L-formulas.\nInseparability plays an important role for decompositions. Assume that we have a theory T that is ∆-decomposable into some components T1 and T2. Although, the union T1 ∪ T2 must entail all consequences of T in the signature ∆, the components T1 and T2 may not be ∆–inseparable, if we demand them to be finite. For example, the set of∆–consequences of T2 may not be finitely axiomatizable in L by axioms of T1. This easily follows from Fact 2.3 which shows that this phenomenon is already possible in weak languages such as the sub-boolean description logic EL. On the other hand,∆–inseparability of decomposition components can always be obtained if the underlying logic L has uniform interpolation (cf. Proposition 2 in [38]). Both∆–decomposition and∆–inseparability are required to achieve modularity. Without∆–inseparability the components are not self-sufficient, since a component may not entail some of the consequences in the shared vocabulary∆. The ideal case is when a theory T has ∆-decomposition into finite ∆–inseparable components, as noted in Fact 2.6 further in this section.\nIn contrast to decomposability, deciding ∆-inseparability of theories is usually harder, than deciding entailment in the logic in which the theories are formulated, as proved by the results in [18], [32], and the results on the complexity of deciding conservative extensions [29,12]. However, there are practical cases in which this property is guaranteed to hold for any decomposition components of a given theory wrt a certain signature ∆. For example, if the theory without equality is a set of ground atoms, then such theory is∆-decomposable iff there exist two subsets of atoms having only ∆-symbols in common and containing at least one non-∆-symbol. This property is easy to check by computing syntactic connectedness of the signature symbols. It is straightforward to verify that if ∆ does not contain predicate symbols, then the obtained decomposition components are guaranteed to be ∆-inseparable. In other words, a set of ground atoms can be easily decomposed into inseparable components, if they share constants only with no common predicate symbols. A practically important generalization of theories consisting of ground atoms is proper+ theories [21,27]. Developing computationally tractable techniques for decomposition of proper+ theories into inseparable components is of particular interest. We note the importance of having inseparable decomposition components below.\nThe well-known property of logics related to signature decompositions of theories is the Parallel Interpolation Property (PIP) first considered in a special form in [20] and studied later in a more general form in [17].\nDefinition 2.5 (Parallel Interpolation Property) A logicL is said to have the parallel interpolation property (PIP) if for any theories T1, T2 in L with sig (T1) ∩ sig (T2) = ∆ and any formula ϕ in L, the condition T1 ∪ T2 |= ϕ yields the existence of sets of formulas T ′1 and T ′ 2 in L such that:\n– Ti |= T ′i , for i = 1, 2, and T ′ 1 ∪ T ′ 2 |= ϕ; – sig (T ′i ) \\∆ ⊆ (sig (Ti) ∩ sig (ϕ)) \\∆.\nNote that PIP is closely related to Craig’s interpolation [5,6]. In fact, PIP can be understood as an iterated version of Craig’s interpolation in the logics that have compactness and deduction theorem (see Lemma 1 in [38]). Many logics known to have Craig interpolation – e.g., second- and first-order logics, numerous modal logics, and some description logics, also have PIP. It is easy to note that, in the presence of PIP, decomposing a set T of formulas into inseparable components wrt a signature ∆ gives a family of theories that imply all the consequences of T in their own subsignatures.\nFact 2.6 Let L have PIP, T be a theory in L, and∆ a signature. Let 〈T1, T2〉 be a∆–decomposition of T , with T1 and T2 being ∆–inseparable. Then for any formula ϕ with sig (ϕ) ⊆ sig (Ti), for some i = 1, 2, we have T |= ϕ iff Ti |= ϕ.\nProof. Assume sig (ϕ) ⊆ sig (T1). If T1 |= ϕ then T |= ϕ by definition of∆–decomposability. If T |= ϕ then T1∪T2 |= ϕ and by PIP, there are T ′1 and T ′ 2 such that T1 |= T ′ 1 , T2 |= T ′ 2 , T ′ 1 ∪T ′ 2 |= ϕ, and sig (T ′2 ) ⊆ ∆. As T1 and T2 are∆–inseparable, we obtain T1 |= T ′ 2 and conclude that T1 |= ϕ.\nIn other words, in the presence of PIP, inseparable decomposition components can be used instead of the original theory for checking the entailment of formulas in the corresponding subsignatures. This is the reason for our interest in the inseparability property in connection with decompositions. As shown in [1,2,3], a decomposition of a theory can be beneficial even without inseparability thanks to applying the known methods of distributed reasoning via message passing between components. However, if components are inseparable, then the reasoner can avoid message passing completely."
    }, {
      "heading" : "2.3 Basics of the Situation Calculus",
      "text" : "The language of the situation calculus Lsc has the first-order syntax over three sorts action, situation, object. It is provided with the standard model-theoretic semantics. It is defined over the countably infinite alphabet Asc = {do, , S0, Poss} ∪ A ∪ F ∪ O ∪ P , where do is a binary function symbol of sort situation; is a binary relation on situations; S0 is the constant of sort situation; Poss(a, s) is a binary predicate (saying whether a is possible in s) with the first argument of sort action and the second one of sort situation; A is a set of action functions with arguments of sort object, F is a set of so-called fluents, i.e., predicates having as arguments a tuple (vector) of sort object and one last argument of sort situation; O is a set of constants of sort object; and P is a set of static predicates and functions, i.e., those that only have objects as arguments. A symbol v ∈ Asc (predicate or function) is called situation-independent if v ∈ A ∪O ∪ P . A ground term is of sort situation iff it is either the constant S0 or a term do(A(t̄), S), where A(t) is a ground action term and S is a ground situation term. For instance, a term do(A2(t̄2), do(A1(t̄1), S0)) denotes the situation resulting from executing actions A1(t̄1) andA2(t̄2) consecutively from the initial situation S0. Informally, static predicates specify object properties that never change no matter what actions are executed and fluents describe those object properties that are situation–dependent. The language of the situation calculus is used to formulate basic action theories (BAT s); they may serve as the formal specifications of planning problems. Every BAT consists of a set of foundational axioms Σ, which specify constraints on how the function do and fluents must be understood, a theoryDuna stating the unique name assumption for action functions and objects, an initial theoryDS0 describing knowledge about the initial situation S0, a theoryDap specifying preconditions of action execution, and a theory Dss (the set of successor-state axioms, SSAs for short) which contains definitions of fluents in the next situation in terms of static predicates and the values of fluents in the previous situation. A detailed example of a BAT is given at the end of this section.\nExample 1 (The Blocks World).We illustrate some of the syntactic definitions using the well-known BlocksWorld example. The domain of objects in this example consists of blocks that can form towers such that a block can be on the top of only one other block and conversely only one block can be staying on the top of another block. The unary predicate Block holds for objects. The towers of blocks\ncan be described using the fluents On(x, y, s), a block x is on y in situation s, and Clear(x, s), a block x is clear in s meaning that there is no block on top of x in situation s. The first fluent applies to pairs of blocks in a tower, while the second fluent characterizes the top block. An initial theory DS0 may include axioms about the initial configuration of blocks named using object constants A,B,C, e.g.,On(A,B, S0), the blockA is onB initially, ¬∃xOn(x,A, S0) and ¬∃xOn(x,C, S0), i.e., there are no blocks on top of blocks A and C. Notice that both fluents are predicates with situation as the last argument. A theoryDuna includes axioms saying that all blocksA,B,C are pairwise distinct. The function move(x, y, z) maps blocks x, y, z into a separate sort action that represents moving block x staying on top of block y from block y onto another block z. The precondition axioms Dap characterize when this action is possible, e.g.,move(A,B,C) is possible in the initial situation S0, because both A and C are clear, but move(B,A,C) is not possible in S0, because the block B is not clear, and it is not staying on A in S0. The situation do(move(A,B,C), S0) results from executing action move(A,B,C) in the initial situation S0. This action has effects on the fluents in the sense that the fluent predicates about S0 may change their truth values in the situation do(move(A,B,C), S0). Observe however that in do(move(A,C,B), do(move(A,B,C), S0)) fluents are true iff they are true in S0, sincemove(A,C,B) is inverse wrt move(A,B,C) when these actions executed consecutively. The following successor state axiom characterizes all effects of all actions on the fluent On:\n∀x, y, z, a, s On(x,z, do(a,s)) ↔ ∃y(a=move(x,y,z)) ∨On(x,z,s)∧¬∃y(a=move(x,z,y))\nMore specifically, block x is on block z after doing an action a in situation s iff the last action a was moving x from some other block y to z, or if x was already on z in s, and the last action a did not move it elsewhere. Subsequently, we do not write the ∀-quantifiers explicitly at front of the axioms.\nIn every basic action theory D over a signature σ ⊆ Asc, the set of foundational axioms Σ consists of the following formulas [42] (note the axiom schema for induction):\n∀ a1, a2, s1, s2 [do(a1, s1) = do(a2, s2) → a1 = a2 ∧ s1 = s2] ∀ s ¬(s S0 ∧ s 6= S0) ∀ s1, s2 [s1 s2 ↔ ∃a (do(a, s1) s2) ∨ s1 = s2] ∀P P (S0) ∧ ∀a, s[P (s) → P (do(a, s))] → ∀sP (s)\nReiter observed in [42] that foundational axioms Σ generalize a single successor function over natural numbers to the case of multiple successors over situations. The second order induction axiom serves to exclude non-standard trees as models.\nFor every pair of distinct action functions {A,A′} ⊆ σ and every pair 〈a, b〉 of distinct object constants from σ, a theoryDuna contains axioms of the form:\na 6= b ∀ x̄, ȳ A(x̄) 6= A′(ȳ) ∀ x̄, ȳ A(x1, . . . , xn) = A(y1, . . . , yn) → x1 = y1 ∧ . . . ∧ xn = yn if A is n–ary.\nNo other axioms are inDuna. To define the remaining subtheories of BAT , we need to introduce the following syntactic notion (taken from [37,43]).\nDefinition 2.7 A formula ϕ in language Lsc is called uniform in a situation term S if:\n1. it does not contain quantifiers over variables of sort situation;\n2. it does not contain equalities between situation terms; 3. the predicates Poss, do not occur in ϕ: {Poss, } ∩ sig (ϕ) = ∅; 4. for every fluent F ∈ sig (ϕ), the term in the situation argument of F is S.\nA set T of formulas in Lsc is called uniform in a situation term S if every formula of T is uniform in S.\nBy definition, a set T of formulas uniform in a situation term S either does not contain any situation terms (and hence, fluents), or the only situation term is S which occurs as the situation argument of each fluent from sig (T ). In the example above, the formula on the right hand side of the SSA is a formula uniform in s. If T is a set of sentences uniform in situation term S, i.e., T has no free variables, and S occurs in formulas of T , then by items (1), (2) of the definition, S must be ground and thus, it must either be the constant S0, or have the form do(A(t̄), S′), where S′ is a ground situation term. Note that if the constant S0 or the binary function symbol do is present in sig (T ) and T is uniform in S, then necessarily S0 ∈ sig (S), or do ∈ sig (S), respectively. By items (1) and (2), such theory T does not restrict the interpretation of the term S and the cardinality of the sort situation, so the observations above lead to the following property of uniform theories, which informally can be summarized by saying that in sentences of a theory T uniform in a ground situation term S, we can understand this situation term as playing a role of an index that can remain implicit. Whenever we change the interpretation of S (e.g., by choosing a different interpretation for do and S0) in a model of T , it suffices to “move” interpretations of fluents to this new point to obtain again a model for T .\nLemma 2.8 Let T be a set of sentences uniform in a ground situation term S. Let M = 〈Act ∪ Sit ∪ Obj, do,S0,F1, . . . ,Fn, I 〉 be a model of T , where Act, Sit, and Obj are domains for the corresponding sorts action, situation, and object, do and S0 are the interpretations of the function do and constant S0, respectively, F1, . . . ,Fn are the interpretations of fluents from sig (T ), and I is the interpretation of the rest of symbols from sig (T ). For example, Fi is a set of tuples 〈u1, . . . , um−1,S〉, where S is the interpretation of the ground term S inM.\nConsider the structure M′ = 〈Act ∪ Sit′ ∪ Obj, do′,S0 ′,F1 ′, . . . ,Fn ′, I 〉, where Sit′ is an arbitrary set, the domain for sort situation, do′ and S0 ′ are arbitrary interpretations of do and S0 on Sit′, respectively, and for i 6 n, Fi ′ denotes the interpretation of the fluent Fi as a set of tuples 〈u1, . . . , um−1,S′〉, with S′ being the interpretation of term S inM′ and 〈u1, . . . , um−1,S〉 ∈ Fi. Then, M′ is a model of T . By definition, the interpretation of situation–independent predicates and functions is the same inM′ andM.\nThis lemma can be easily proved by induction over possible syntactic form of sentences in T . If S and S′ are two situation terms and T is a set of formulas uniform in S, then we denote by T (S′/S) the set of formulas obtained from T by replacing every occurrence of S with S′. This notation will be extensively used in Section 4. Obviously, T (S′/S) is uniform in S′.\nThe initial theory DS0 of D is defined as an arbitrary set of sentences in the signature σ that are uniform in the situation constant S0. Throughout the paper, we assume that DS0 is a theory in (any fragment of) second-order logic that can be translated into a set of sentences of first-order logic uniform in S0. In particular,DS0 can include both an ABox and a TBox in an appropriateDescription Logic, as argued in [16,48].\nNext, for every n-ary action functionA ∈ σ, a theory Dap includes an axiom of the form\n∀ x̄, s ( Poss(A(x̄), s) ↔ ΠA(x̄, s) ) ,\nwhere ΠA(x̄, s) is a formula uniform in s with free variables among x̄ and s. Informally,ΠA(x̄, s) characterizes preconditions for executing the action A in the situation s. No other formulas are in Dap.\nExample 1 (continuation). The following is the precondition axiom formove(x, y, z):\nPoss(move(x, y, z), s) ↔ Block(x) ∧Block(y) ∧Block(z) ∧On(x, y, s)∧ Clear(x, s) ∧ Clear(z, s) ∧ x 6= z\nThe action move(x, y, z) is possible iff x, y, z are blocks, x is located on y in situation s, and both the block x that is to be moved, and a destination block z are not occupied by any other blocks. Notice the preconditions do not allow moving a block back to the same location where it was before.\nFinally, for every fluent F ∈ σ, a theoryDss contains an axiom of the form\n∀ x̄, a, s ( F (x̄, do(a, s)) ↔ γ+F (x̄, a, s) ∨ F (x̄, s) ∧ ¬γ − F (x̄, a, s) ) (†),\nspecifying a condition γ+F (x̄, a, s) when fluent F becomes true in situation do(a, s), or when F remains true in situation do(a, s) if it is true in s, unless another condition γ−F (x̄, a, s)] holds. Here, γ+F is a disjunction of formulas of the form [∃ȳ](a = A\n+(t̄) ∧ φ+(x̄, ȳ, s)), where A+ is an action function, t̄ is a (possibly empty) vector of object terms with variables at most among x̄ and ȳ, and φ+ is a formula uniform in s with variables at most among x̄, ȳ, and s. We write [∃ȳ] to show that ∃ȳ is optional; it is present only if t̄ includes ȳ or if φ has an occurrence of ȳ. The formula φ+ is called a positive context condition meaning that A+(t̄) makes the fluent F true if this context condition holds in s, but otherwise, A+(t̄) has no effect on F . Similarly, γ−F is a disjunction of formulas of the form [∃z̄](a = A−(t̄′) ∧ φ−(x̄, z̄, s)), where A− is an action function, t̄′ is a (possibly empty) vector of object terms with variables at most among x̄ and z̄, and φ− is a formula uniform in s with variables at most among x̄, z̄, and s. The formula φ− is called a negative context conditionmeaning that A−(t̄) makes the fluent F false if this context condition holds in s, but otherwise, A−(t̄) has no effect on F . In the definition above, we assume that the empty disjunction is equal to false. No other formulas are in Dss. This completes the definition of Dss. Subsequently, the following will be useful.\nDefinition 2.9 (SSA and active position of an action) The axioms of Dss in the form above are called successor state axioms (SSAs) of a basic action theory D.\nAn action function f is said to be in active position of some SSA ϕ ∈ Dss if f occurs either as A+, or A− in the definition of Dss above.\nWe say that ϕ ∈ Dss is SSA for the fluent F if F is the fluent from the left-hand side of ϕ.\nExample 1 (continuation). The following is the SSA for the fluentEH(x, s)meaning the height of a block x is even, i.e., the number of blocks under x is odd:\nEH(x, do(a, s)) ↔ ∃y, z ( a=move(x, y, z) ∧ ¬EH(z, s) ) ∨\nEH(x, s) ∧ ¬∃y, z ( a=move(x, y, z) ∧ EH(z, s) ) .\nThen formula ¬EH(z, s) is a positive context condition. If it holds in s, i.e., if the height of block z is not even in a situation s, then in the situation that results from moving x from y to a block z, the height of x becomes even. But if the positive context condition does not hold in s, then move(x, y, z) does not make the height of block x even. Also, if the height of x is even in s, then it remains even unless a block x is moved from y on top of z and the height of z is even in s. The\nformula EH(z, s) is a negative context condition, i.e., if the height of block z is even in s, then the action move(x, y, z) has a negative conditional effect on the fluent EH(x, s) in the sense that this fluent becomes false in the situation that results from doingmove(x, y, z) in s. In this SSA, an action functionmove occurs both as A+ and A− on the right hand side of this SSA.\nFollowing the consistency requirement on SSAs by Reiter (see Proposition 3.2.6 in [43]), we require that if an action function f occurs in active position in some SSA for a fluent F , then f is not in active position in either γ+F , or γ − F . Informally, this means that an action cannot have both positive and negative effects on F . Each SSA for a fluent F completely defines the truth value of F in the situation do(a, s) in terms of what holds in situation s. Also, SSA compactly represents non-effects by quantifying ∀a over variables of sort action. Only action terms that occur explicitly on the right-hand side of SSA for a fluent F have effects on this fluent, while all other actions have no effect.\nWe note that the original version of Reiter’s situation calculus admits functional fluents, e.g. functions having a vector of arguments of sort object and one last argument of sort situation. Reiter defines the notion of SSA for functional fluents [43]. Without loss of generality, we omit functional fluents in this paper.\nThe following fundamental result, which will be used in our Theorem 4.4, says that the initial theory together with the UNA is the core of any basic action theory, while the rest of the constituent theories may be considered as add-ons.\nProposition 2.10 (Theorem 1 in [37]) A basic action theory Σ ∪ Duna ∪ DS0 ∪ Dap ∪ Dss is satisfiable iffDuna ∪DS0 is satisfiable.\nSuppose A1, · · · ,An is a sequence of ground action terms, and ϕ(s) is a formula with one free variable s of sort situation which is uniform in s. One of the most important reasoning tasks in the situation calculus is the projection problem: that is, to determine whether D |= ϕ(do(An, do(An−1, do(· · · , do(A1, S0))))). Informally,ϕ represents some property of interest and entailment holds iff this property is true in the situation resulting from performing the sequence of actionsA1, · · · ,An starting from S0.\nAnother basic reasoning task is the executability problem. Let executable(do(An, do(An−1, do(· · · , do(A1, S0)))))\nbe an abbreviation of the formula Poss(A1, S0) ∧ ∧n i=2 Poss(Ai, do(A1, do(· · · , do(Ai−1, S0))). Then, the executability problem is to determine whether D |= executable(do(An, do(An−1, do(· · · , do(A1, S0))))), i.e. whether it is possible to perform the sequence of actions starting from S0. Planning and high-level program execution are two important settings, where the executability and projection problems arise naturally. Regression is a central computational mechanism that forms the basis for an automated solution to the executability and projection tasks in the situation calculus ([43]). Regression requires reasoning backwards: a given formula ϕ(do(An, do(An−1, do(· · · , do(A1, S0))))) is recursively transformed into a logically equivalent formula by using SSAs until the resulting formula has only occurrences of the situation term S0. It is easy to see that regression becomes computationally intractable if the sequence of actions grows indefinitely [16]. In this case, an alternative to regression is progression, which provides forward-style reasoning. The initial theoryDS0 is updated to take into account the effects of an executed action. Computing the progression of a given theory\nDS0 requires forgetting facts in DS0 which are no longer true after executing an action. The closely related notions of progression and forgetting are discussed in the next sections.\nDefinition 2.11 (local-effect SSA and BAT ) An SSAϕ ∈ Dss for the fluentF is called local-effect if the set of arguments of every action function in active position of ϕ contains all object variables from F . A basic action theory is said to be local-effect if every axiom of Dss is a local-effect SSA.\nLocal-effect BAT s are a well-known3 class of theories, for which the operation of progression (Section 4) can be computed effectively [27], without regard to decidability of the underlying theory DS0 . They are special in the sense that the truth value of each fluent defined by a local-effect SSA can change only for objects explicitly named as arguments of the executed action. Therefore, in local-effect BAT s, each action can change only finitely many ground fluent atoms. This allows for computing forgetting (the operation considered in Section 3) efficiently. Informally speaking, forgetting erases fromDS0 those finitely many fluent atoms which changed after executing an action.\nExample 1 (continuation). Observe that in the Blocks World example considered above, the actionmove has only local effects on the fluentsOn andClear. As an informal example of an action that has global effects, consider the action drive(t, l1, l2) of driving a truck t loaded with boxes from one location l1 to another location l2. Consider also the fluent At(x, l, s) that holds if an object x is at a location l in s. Observe that this action would have a global effect on location of all boxes loaded on the truck since these boxes are not named explicitly in the action function drive(t, l1, l2), but the SSA for At(x, l, s) would have a ∀-quantifier over the object argument x. Therefore, the truth value of At(x, l, s) changes not only for t, but also for other objects not mentioned in drive(t, l1, l2). It would be awkward to include all the boxes loaded in t as arguments of this action. For this reason, axioms for the logistics domain should include actions with global effects on the fluents.\nBefore we proceed to a discussion of component properties under forgetting (Section 3) and to progression of initial theories (Section 4), we consider an example that helps to illustrate the notion of BAT and the advantages of decomposition of its initial theory. Our example combines the simplified Blocks World (BW) with a kind of Stacks World. A complete axiomatization of BW modelled as a finite collection of finite chains can be found in [4]. In this example, and subsequently, we resort to the common situation calculus convention that free variables in BAT axioms are implicitly taken to be universally quantified at front.\nExample 2 (A running example of BAT ). The blocks-and-stacks-world consists of a finite set of blocks and a finite set of other entities. Blocks can be located on top of each other, while other entities can be either in a heap of unlimited capacity, or can be organized in stacks. There is an unnamed manipulator that can move a block from one block to another, provided that there is nothing on the top of the blocks. It can also put an entity from the heap upon a stack with a named top element, or move the top element of a stack into the heap. For stacking/unstacking operations we adopt the push/pop terminology and use the unary predicate Block to distinguish between blocks and other entities. We use the following action functions and relational fluents to axiomatize this example as a local-effect BAT in SC.\nActions\n– move(x, y, z): Move block x from block y onto block z, provided both x and z are clear.\n3 The phrase local-effect actions first appeared in [28], but it was motivated by actions with simple effects defined in the paper [24], where simple effects are understood similar to the Def. 2.11.\n– push(x,y): Stack entity x from the heap on top of entity y. – pop(x): Unstack entity x into the heap, provided x is the top element and is not in the heap.\nFluents\n– On(x, z, s): Block x is on block z, in situation s. – Clear(x, s): Block x has no other blocks on top of it in s. – Top(x, s): Entity x is the top element of a stack in s. – Inheap(x, s): Entity x is in the heap in situation s. – Under(x, y, s): Entity y is directly under x in a stack in situation s.\nThe sub-theories of the basic action theory are defined as follows.\nSuccessor state axioms (theory Dss) On(x, z, do(a, s)) ↔ ∃y(a=move(x, y, z)) ∨On(x, z, s) ∧ ¬∃y(a=move(x, z, y))\nClear(x, do(a, s)) ↔ ∃y, z(a=move(y, x, z)∧ On(y, x, s)) ∨ Clear(x, s)∧ ¬∃y,z(a=move(y, z, x))\nInheap(x, do(a, s)) ↔ a=pop(x) ∨ Inheap(x, s) ∧ ¬∃y(a=push(x, y))\nTop(x, do(a, s)) ↔ ∃y( a=push(x, y) ) ∨ ∃y( a=pop(y) ∧ Under(y, x, s) ) ∨ Top(x, s) ∧ a 6=pop(x) ∧ ¬∃y(a=push(y, x))\nUnder(x, y, do(a, s)) ↔ a=push(x, y) ∨ Under(x, y, s) ∧ a 6=pop(x)\nThe first axiom is saying that a block x will be on top of a block z after moving x from another block y onto z, or if x was already on z and it was not moved elsewhere. The second axiom is saying that x will become clear, i.e., there will be no blocks on top of x after moving the block y that was previously on top of x onto another block z. Otherwise, if a block x was already clear, it remains clear unless some block y will be moved from the block z onto the block x. The third axiom asserts that an entity x is in a heap once it has been removed from a stack, or if it was already in a heap, and it was not stacked on top of another entity y. In the fourth axiom, when an entity x is stacked upon an entity y, x become the new top. Also, it becomes the top, when x was located under some y that was removed into a heap. Otherwise, an entity x remains on the top unless it was unstacked or buried under by stacking another entity y onto x. In the last fifth axiom, an entity y will be under another entity x after stacking x on top of y, or y remains under x after any action that does not remove x into a heap. It is easy to observe that all these SSAs are local-effect, and we will exploit this fact later in our paper.\nAction precondition axioms (theoryDap) Poss(move(x, y, z), s) ↔ Block(x) ∧Block(y) ∧Block(z) ∧On(x, y, s)∧\nClear(x, s) ∧ Clear(z, s) ∧ x 6= z\nPoss(push(x, y), s) ↔ ¬Block(x) ∧ ¬Block(y) ∧ Top(y, s) ∧ Inheap(x, s)\nPoss(pop(x), s) ↔ ¬Block(x) ∧ Top(x, s)\nThe precondition axioms are self-explanatory. The actionmove(x, y, z) is possible in any situation s where a block x is located on top of a block y, both x and a destination block z are clear (i.e., not obstructed by any blocks on top of them) and x is different from z. The last condition precludes moving x on top of itself. According to the second precondition axiom, it is possible to stack x on y in any situation s, if x and y are entities which are not blocks, y is the top of a stack, and x is in a heap. The opposite operation of unstacking x is possible if and only if x is a top entity in situation s.\nInitial Theory (DS0) is defined as the set of axioms 4 using object constants {A,B,C}:\n¬∃yOn(y, x, S0) ∧ ∃yOn(x, y, S0) ∧ ¬Inheap(x, S0)→Clear(x, S0) ∃y On(x, y, S0) → Block(x) (Top(x, S0) ∨ Inheap(x, S0)) → ¬Block(x) On(A,B, S0)∧Block(B)∧Block(C)∧ Clear(A,S0)∧ Clear(C, S0)\nUnique names axioms for actions and objects (theory Duna) is the set of unique names axioms for all pairs of object constants and action functions used above.\nThen Σ ∪ Duna ∪Dap ∪ Dss ∪ DS0 is the resulting local-effect basic action theory.\nNotice that all fluents are syntactically related in DS0 , so purely syntactic techniques fail to decomposeDS0 into components sharing no fluents. However,Dss is the union of two theories with the intersection of signatures equal to {do}. The set of precondition axioms is also union of two theories – the first axiom by itself is one of them, and the conjunction of the second and third axioms is another one – with the intersection of signatures equal to {Poss,Block}. At the same time, the initial theory DS0 is ∆–decomposable for ∆ = {Block, S0} into two distinct ∆–inseparable components:\n¬∃y On(y, x, S0) ∧ ∃y On(x, y, S0) → Clear(x, S0) ∃y On(x, y, S0) → Block(x) On(A,B, S0)∧Block(B)∧Block(C)∧Clear(A,S0)∧ Clear(C, S0)\nand (Top(x, S0) ∨ Inheap(x, S0)) → ¬Block(x) ∃x Block(x)\nThis example is continued after Theorem 4.5 in Section 4, where we will show that the progression for BAT s of this kind preserves both decomposability and inseparability of the decomposition components."
    }, {
      "heading" : "3 Properties of Forgetting",
      "text" : "There are two basic types of forgetting considered in the literature: forgetting a signature and forgetting a ground atom. As will be explained in Section 4, progression of BAT s is closely related to forgetting. In particular, computing progression of a local-effect BAT involves forgetting a set of ground atoms representing facts that are no longer true after an action execution. Thus, in order to understand the behavior of the component properties of theories under progression, one needs to first examine their relationship to forgetting, which is the purpose of this section. Although we are focused on forgetting ground atoms, the counterpart results for signature forgetting often come for free and are therefore included into this section. Moreover, they help to see the difference between the two types of forgetting, which contributes to a better understanding of this operation wrt the component properties, which we believe would be of interest to a broader audience in the literature. To emphasize broader applicability of these results, we consider a general first- and second-order logic setting in the remainder of this section.\n4 Some of these axioms, e.g., the second axiom, remain true after executing any of the possible actions, but this fact is irrelevant to the purposes of this example.\nLet us define a relation on structures as follows. Let σ be a signature or a ground atom and M, M′ be two many–sorted structures. Then we set M ∼σ M′ if:\n– M andM′ have the same domain for each sort; – M andM′ interpret all symbols which do not occur in σ identically; – if σ is a ground atom P (t̄) then M and M′ agree on interpretation ū of t̄ and for every vector of elements v̄ 6= ū, we haveM |= P (v̄) iffM′ |= P (v̄).\nObviously,∼σ is an equivalence relation.\nThe following notion summarizes the well-known Definitions 1 and 7 in [25].\nDefinition 3.1 (Forgetting an atom or signature) Let T be a theory in L and σ be either a signature, or some ground atom. A set T ′ of formulas in a fragment of second-order logic is called the result of forgetting σ in T (denoted by forget (T , σ)) if for any structure M′, we have M′ |= T ′ iff there is a modelM |= T such thatM ∼σ M′.\nIt is known that forget (T , σ) always exists, i.e. it is second-order definable, for a finite set of formulas T in L and a finite signature or a ground atom σ (see [25], or Section 2.1 in [27]). On the other hand, the definition yields T |= forget (T , σ); thus, forget (T , σ) is a set of second-order consequences of T which suggests that it may not always be definable in the logic, where T is formulated, and it may not be finitely axiomatizable in this logic, even if T is so.\nFact 3.2 (Basic properties of forgetting) If σ and π are signatures or ground atoms and T , T ′ are theories in L then:\n– forget (T , σ ∪ π) ≡ forget (forget (T , σ), π) (if σ and π are signatures) – forget (forget (T , σ), π) ≡ forget (forget (T , π), σ) – forget (forget (T , σ), σ) ≡ forget (T , σ) – forget (T , σ) ≡ T if σ is a signature with σ ∩ sig (T ) = ∅, or a ground atom with predicate not contained in sig (T ) – forget (T ∪ T ′, σ) 6≡ forget (T , σ) ∪ forget (T ′, σ) (see Example 5) – forget (ϕ ∨ ψ, σ) ≡ forget (ϕ, σ) ∨ forget (ψ, σ) (if ϕ, ψ are formulas inL).\nThese properties either follow immediately from the definition, or from the results proven in [25].\nProposition 3.3 (Signature of forget(T ,σ)) Let T be a theory in L, σ a signature (or a ground atom) and let forget (T , σ) be a set of formulas in a language L′, a fragment of second-order logic with PIP. Then forget (T , σ) is logically equivalent in L′ to a set of formulas in the signature sig (T ) \\ σ (sig (T ), respectively).\nProof. We consider the case when σ is a signature; the case of a ground atom being proved analogously. Assume that σ ∩ sig (forget (T , σ)) 6= ∅. Denote by forget (T , σ)∗ a “copy\" of the set of formulas forget (T , σ), where each symbol from σ∪[sig (forget (T , σ))\\sig (T )] is uniquely replacedwith a fresh symbol, not present in sig (forget (T , σ)). We claim that forget (T , σ)∗ |=L′ forget (T , σ). There is nothing to prove if forget (T , σ)∗ is unsatisfiable. Note that, by definition of forgetting, forget (T , σ)∗ and forget (T , σ) are satisfiable iff T is. Let us assume that T is satisfiable. Take an arbitrary model M∗ |= forget (T , σ)∗; then there exists a model M′ |= forget (T , σ) which agrees on sig (forget (T , σ)∗) with M∗ and interprets symbols\nfrom σ ∪ [sig (forget (T , σ)) \\ sig (T )] equally to the interpretation of the corresponding fresh symbols in M∗. Therefore, we may assume that M∗ ∼σ M′. By definition of forgetting, there is a model M |= T such that M′ ∼σ M, hence M∗ ∼σ M and M∗ |= forget (T , σ). We have forget (T , σ)∗ |=L′ forget (T , σ) and sig (forget (T , σ)∗)∩sig ( forget (T , σ))⊆ sig (T )\\ σ. By PIP, there is a set of formulasΘ in signature sig (T )\\σ such that forget (T , σ)∗ |=L′ Θ and Θ |=L′ forget (T , σ). Note that forget (T , σ)∗ |=L′ Θ yields forget (T , σ) |=L′ Θ, because every model of forget (T , σ) can be expanded to a model of forget (T , σ)∗ and the reduct of this model onto (a subset of) sig (T ) \\ σ suffices to satisfy Θ. Thus, we conclude that forget (T , σ) is equivalent to Θ.\nCorollary 3.4 Let T be a theory in L having PIP and σ a signature. Then T ≡ forget (T , σ) iff T is equivalent to a set of formulas in the signature sig (T ) \\ σ.\nWe note that the similar statement does not hold when σ is a ground atom. It follows from Proposition 3.3 that in case σ is a signature, forget (T , σ) axiomatizes the class of reducts of models of T onto the signature sig (T ) \\ σ. Clearly, if T is a theory in language L, then forget (T , σ) may not be in L, however it is always expressible in second-order logic if T is finitely axiomatizable (we note that second-order logic has PIP). For the case when σ is a signature, forget (T , σ) is known as sig (T ) \\ σ–uniform interpolant of T wrt the language L and second-order queries, that is, wrt the pair (L, second-order logic), see Definition 13 in [18] and Lemma 39 in [32] for a justification. In other words, T and forget (T , σ) semantically entail the same second-order formulas in signature T \\ σ.\nIf σ is a ground atom P (t̄) then, by definition, for any modelM |= T , forget (T , σ) must have two “copies” ofM: a model with the value of P (t̄) false and a model where this value is true. Let L be first-order logic. In contrast to forgetting a signature, for any recursively axiomatizable theory T in L and a ground atom σ, one can effectively construct the set of formulas forget (T , σ) in L such that forget (T , σ) is finitely axiomatizable iff T is. This follows from Theorem 4 in [25], where it is shown that forgetting a ground atom P (t̄) in a theory T can be computed by simple syntactic manipulations:\n– for an axiom ϕ ∈ T , denote by ϕ[P (t̄)] the result of replacing every occurrence of atom P (t̄′) (with t̄′ a term) by formula [t̄ = t̄′ ∧ P (t̄)] ∨ [t̄ 6= t̄′ ∧ P (t̄′)] – denote by ϕ+[P (t̄)] the formula ϕ[P (t̄)] with every occurrence of the ground atom P (t̄) replaced with true and similarly, denote by ϕ−[P (t̄)] the formulaϕ[P (t̄)] with P (t̄) replaced with false – then forget (T , P (t̄)) is equivalent to ( ∧\nϕ∈T ϕ +[P (t̄)])\n∨ ( ∧\nϕ∈T ϕ −[P (t̄)]).\nThe disjunction corresponds to the union of two classes of models obtained from models of T , with the ground atom P (t̄) interpreted as true and false, respectively. This fact is important for effective computation of progression for local-effect BAT s mentioned in Section 4.\nExample 3 (Forgetting a ground atom).Consider a theory T = {ϕ}, where ϕ = ¬P (c), i.e., P (c) is false in every model of T . Consider forgetting P (c) in T . By the (semantic) definition of forgetting, the set of models of forget (T , P (c)) consists of models of T and those models, in which P (c) is true. Therefore, any structure is a model of forget (T , P (c)). Now consider the syntactic definition of forgetting given above. We have\nϕ[P (c)] = ¬([c = c ∧ P (c)] ∨ [c 6= c ∧ P (c)])\nthus, ϕ+[P (c)] ≡ false, ϕ−[P (c)] ≡ true and hence, forget (T , P (c)) ≡ ϕ+[P (c)] ∨ ϕ−[P (c)] is a tautology.\nNow consider forgetting P (c) in the theory T = {ϕ}, where ϕ = ∀xP (x). By the (semantic) definition of forgetting, any structure, in which P is true on every element, except possibly, the interpretation of c, is a model of forget (T , P (c)). By the syntactic definition of forgetting we have:\nϕ[P (c)] = ∀x ( [x = c ∧ P (c)] ∨ [x 6= c ∧ P (x)] )\nthus, ϕ+[P (c)] = ∀x ( x = c ∨ [x 6= c ∧ P (x)] ), ϕ−[P (c)] = ∀x ( x 6= c ∧ P (x) ). Since ϕ−[P (c)] ≡ false, we obtain forget (T , P (c)) ≡ ϕ+[P (c)] and hence, forget (T , P (c)) ≡ ∀x ( x 6= c → P (x) ).\nWe note that in case a theory T is finitely axiomatizable, computing forget (T , P (t̄)) in the way above doubles the size of theory in the worst case, due to the disjunction. It is sometimes necessary to consider forgetting of some set S of ground atoms in a theory T . This is equivalent to iterative computation of forgetting of atoms from S starting from the theory T (the order on atoms can be chosen arbitrary as noted in Fact 3.2). However, it is important to note that the size of the resulting theory is O(2|S| × |T |), where |S| is the number of atoms in S and |T | is the size of T .\nProposition 3.5 (Interplay of forgetting and entailment) Let T and T1 be two sets of formulas in L, with T |= T1, and σ be a signature or a ground atom. Then the following holds:\nT |=\n|=\nT1\n|= |=\nforget (T , σ) forget (T1, σ)\nProof. Follow the diagram starting from the top-left column. By definition of forgetting, everymodel of T is a model of forget (T , σ), so we have T |= forget (T , σ) as shown in the left column of the diagram. Similarly, T1 |= forget (T1, σ) in the right column of the diagram. To prove entailment at the bottom we rely on entailments in the columns and on the given entailment at the top, i.e., we navigate the diagram up from the bottom-left corner, then move right, and finally go down to the bottom-right expression. Let M′ be an arbitrary model of forget (T , σ). Then there is a model M |= T such that M ∼σ M′. Since T |= T1, we have M |= T1, so we conclude that M′ |= forget (T1, σ), because M is a model satisfying the conditions of Definition 3.1 for T1 and M′. Thus, we proved entailment shown in the bottom row of the diagram.\nProposition 3.6 (Preservation of consequences under forgetting) Let T be a theory in L and σ be either a signature or a ground atom. Let ϕ be a formula such that either sig (ϕ) ∩ σ = ∅ (in case σ is a signature), or which does not contain the predicate from σ (if σ is a ground atom). Then T |= ϕ iff forget (T , σ) |= ϕ.\nProof. From Proposition 3.5, we have T |= forget (T , σ), thus forget (T , σ) |= ϕ yields T |= ϕ. Now let T |= ϕ and assume there is a modelM′ of forget (T , σ) such thatM′ 6|= ϕ. By definition of forgetting, there exists a model M of T such that M ∼σ M′, i.e. M and M′ have the same universe and may differ only on interpretation of signature σ (ground atom σ). By the condition on signature of ϕ, thenM is not a model of ϕ, which contradicts T |= ϕ.\nNow we answer the question when inseparability is preserved under forgetting. This is important for our research, since we are interested in preservation of inseparability under progression, the operation which relies on forgetting in local-effect BAT s. We demonstrate that it is important to distinguish between forgetting something in ∆ (the common symbols of theories) or outside of the shared signature. While Proposition 3.6 shows that the situation is simple in the latter case, it is apriory unclear, whether the same holds in the former. Example 4 demonstrates that this is not true, while the accompanying Propositions 3.7, 3.8 describe the cases when this situation can be recovered. We believe that giving the accompanying positive results is important in order to provide a big picture to the reader. Proposition 3.7 shows that signature forgetting (the arguably more frequently used type of forgetting in the literature) preserves inseparability, while Proposition 3.8 tackles this question from another perspective. It shows that semantic inseparability, the property also well studied in the literature, is the stronger form of inseparability, which is invariant under forgetting.\nObserve that by Proposition 3.6 and the first item of Fact 3.2, when studying preservation of ∆–inseparability of two sets of formulas for a signature ∆, it is sufficient to consider the case of forgetting a subset of∆ or a ground atom with the predicate from∆, respectively.\nProposition 3.7 (Preservation of∆–insep. under signature forgetting) Let L have PIP and T1 and T2 be two ∆–inseparable sets of formulas in L with sig (T1) ∩ sig (T2) = ∆, for a signature ∆. Let σ be a subsignature of ∆ and forget (T1, σ) and forget (T2, σ) be sets of formulas of L. Then forget (T1, σ) and forget (T2, σ) are ∆–inseparable.\nProof. Let ϕ be a formula with sig (ϕ) ⊆ ∆ such that forget (T1, σ) |= ϕ. By Proposition 3.3, we may assume that for i = 1, 2 the signature of forget (Ti, σ) is a subset of sig (Ti) \\ σ. We depict the direction of the proof in the figure below.\nT1 |= T ′1 ⇒ T2 |= T ′ 1\n⇒ ⇒\nforget (T1, σ) |= T ′1 |= ϕ forget (T2, σ) |= T ′ 1 |= ϕ\nWe start with the lower-left corner of the diagram and navigate up, then right, and finally down. As forget (T1, σ) |= ϕ, by PIP, there is a set of formulas T ′1 with sig (T ′ 1 ) ⊆ sig (forget (T1, σ)) ∩ sig (ϕ) ⊆ ∆ \\ σ such that forget (T1, σ) |= T ′1 and T ′ 1 |= ϕ. Then, by Proposition 3.6, we have T1 |= T ′1 . This proves entailment in the top-left corner. Since T1 and T2 are ∆– inseparable and sig (T ′1 ) ⊆ ∆, we obtain T2 |= T ′ 1 . Therefore, the top-right entailment holds. Again, since sig (T ′1 ) ∩ σ = ∅, by Proposition 3.6, we conclude that forget (T2, σ) |= T ′ 1 and thus, forget (T2, σ) |= ϕ.\nThe following example demonstrates that a similar result does not hold under forgetting a ground atom with the predicate from∆.\nExample 4 (∆–inseparability lost under forgetting a ground atom). We give an example of a logic L, sets of formulas T1, T2 in L, and a signature ∆ = sig (T1) ∩ sig (T2) such that T1 and T2 are ∆–inseparable, but forget (T1, R(c, c)) and forget (T2, R(c, c)) are not, for a ground atom R(c, c) with a predicate R ∈ ∆. Let L be Description Logic ELO⊥, i.e. the sub-boolean logic EL augmented with nominals and the bottom concept ⊥. Let Σ = {R, a, c} be signature, where R is\na role name (binary predicate) and a, c are nominals (i.e. constants). Define a set of formulas T1 in the signature Σ as {{a} ⊓ {c} ⊑ ⊥, {c} ⊑ ∃R.{a}, ⊤ ⊑ ∃R.⊤}. Set ∆ = {R, c} and consider the set of formulas T2 = {⊤ ⊑ ∃R.⊤, T aut(c)}, where Taut(c) is a tautology with the nominal c (e.g., the formula {c} ⊑ ⊤). We have sig (T1) ∩ sig (T2) = ∆ and it is easy to check that T2 is equivalent to Cons (T1, ∆) in the logic ELO\n⊥; thus, T1 and T2 are ∆–inseparable. Now consider forget (T1, R(c, c)) and forget (T2, R(c, c)) as sets of formulas in second-order logic (we assume the standard translation of formulas of ELO⊥ into the language of second-order logic). We verify that they are not ∆–inseparable and the formula ⊤ ⊑ ∃R.⊤ is the witness for this. By definition of T1, we have forget (T1, R(c, c)) |= T1, since any model of T1 with a changed truth value of the predicate R on the pair 〈c, c〉 is still a model of T1. On the other hand, forget (T2, R(c, c)) 6|= ⊤ ⊑ ∃R.⊤, because T2 has the one–element model M, where R is reflexive (on the sole element corresponding to c). Hence, by definition of forgetting, the one-element model M′ with R false on the pair 〈c, c〉 must be a model of forget (T2, R(c, c)), but obviously,M′ 6|= ⊤ ⊑ ∃R.⊤.\nIt turns out that the preservation of inseparability under forgetting a ground atom requires rather strong model-theoretic conditions like (*) in Proposition 3.8 below. Specialists might notice that (*) is equivalent to semantic ∆–inseparability of the initial sets of formulas (see Definition 11 in [18]) which is very hard to decide from the computational point of view (see Theorem 3 in [30], Lemma 40 in [32]). Nevertheless, there are practically useful restrictions under which the complexity becomes feasible [19]. Semantic∆–inseparability is stronger than the notion of inseparability given in Definition 2.4: it means that the theories are indistinguishable by second-order formulas. On the other hand, Proposition 3.8 says that whenever there is a chance to satisfy (*) for two given sets of formulas, one does not need to check it again after forgetting something in their common signature. To compare condition (*) with Example 4, note that the aforementioned one-element model of T2 does not expand to a model of T1 ∪ T2.\nProposition 3.8 (Preservation of∆–inseparability under forgetting) Let T1 and T2 be two sets of formulas in L, with sig (T1) ∩ sig (T2) = ∆, for a signature ∆, which satisfy the following condition (*): for i = 1, 2, any model of Ti can be expanded to a model of T1 ∪ T2. Then:\n– T1 and T2 are ∆–inseparable; – for σ a signature or a ground atom, forget (T1, σ) and forget (T2, σ) satisfy (*) as well.\nProof. ∆–inseparability is the immediate consequence of (*): if ϕ is a formula with sig (ϕ) ⊆ ∆, T1 |= ϕ, but T2 6|= ϕ, then there is a modelM2 of T2 such thatM2 6|= ϕ. Then there is an expansion M ofM2 such thatM |= T1∪T2,M|sig (T1) |= T1, butM|sig (T1) 6|= ϕ, a contradiction. Now let us verify that for i = 1, 2, any model of forget (Ti, σ) can be expanded to a model of forget (T1, σ)∪ forget (T2, σ). For instance, let M′2 be a model of forget (T2, σ). Consider a model M2 of T2, such that M2 ∼σ M′2, and expand it to a model M of T1 ∪ T2. Then by definition of forgetting, there must be a modelM′ |= forget (T1, σ) with M′ ∼σ M, which agrees withM′2 on σ (if σ is a signature), or on the predicate of σ (if σ is a ground atom). By construction,M′ is an expansion ofM′2 and thus a model for forget (T1, σ) ∪ forget (T2, σ).\nLet T1 and T2 be two sets of formulas in L, with sig (T1) ∩ sig (T2) = ∆, for a signature ∆, and let σ be either a subsignature of ∆ or a ground atom with the predicate from ∆. It is known that in general, forgetting σ may not be distributive over union of sets of formulas. The entailment forget (T1 ∪ T2, σ) |= forget (T1, σ) ∪ forget (T2, σ) holds by Proposition 3.5, but Example\n5 below easily shows that even strong semantic conditions related to modularity do not guarantee the reverse entailment. On the other hand, forgetting something outside of the common signature of T1 and T2 is distributive over union, as formulated in Corollary 3.10 which is a consequence of the criterion in Proposition 3.9 and is used in the proof of one of our main results, Theorem 4.5.\nExample 5 (Failure of componentwise forgetting in ∆). Let L be first-order logic and ∆ = {P, c} be the signature consisting of a unary predicateP and a constant c. Define theories T1 and T2 as: T1 = {A → P (c)}, T2 = {P (c) → B}, where A,B are nullary predicate symbols. We have sig (T1) ∩ sig (T2) = ∆ and for i = 1, 2, any model of Ti can be expanded to a model of T1 ∪ T2. Clearly, T1 and T2 are∆–inseparable and for i = 1, 2, Cons (Ti, ∆) is the set of tautologies in ∆. By definition of forgetting, for i = 1, 2, forget (Ti, P (c)) is a set of tautologies and thus, forget (T1, P (c)) ∪ forget (T2, P (c)) 6|= forget (T1 ∪ T2, P (c)), because forget (T1 ∪ T2, P (c)) |= A → B (by Proposition 3.6). For the case of forgetting a signature, say a nullary predicate P , it suffices to consider ∆ = {P} and theories T1 = {A → P}, T2 = {P → B}, where A,B are nullary predicates.\nProposition 3.9 (A criterion for componentwise forgetting) Let T1 and T2 be two sets of formulas and σ either a signature or a ground atom. Then the following statements are equivalent:\n– forget (T1, σ) ∪ forget (T2, σ) |= forget (T1 ∪ T2, σ) – for any two models M1 |= T1 and M2 |= T2, with M1 ∼σ M2, there exists a model M |= T1 ∪ T2 such thatM ∼σ Mi, for some i = 1, 2.\nProof. Note in the second condition, the requirementM ∼σ Mi for some i = 1, 2 is equivalent to M ∼σ Mi for all i = 1, 2, by transitivity of∼σ . (⇒): LetM1 |= T1 andM2 |= T2 be models with M1 ∼σ M2. Then there are modelsM′1 andM ′ 2 such that for i = 1, 2,M ′ i |= forget (Ti, σ) and M′i ∼σ Mi. Then, by transitivity of ∼σ , for all i, j = 1, 2 we have M ′ i ∼σ Mj and thus, M ′ i |= forget (Tj , σ). ThenM′1 |= forget (T1 ∪ T2, σ), so there exists a modelM |= T1 ∪ T2 such that M ∼σ M′1 and hence,M ∼σ M1. (⇐): Let M\n′ be a model of forget (T1, σ) ∪ forget (T2, σ). There exist models M1 and M2 such that for i = 1, 2, Mi |= Ti and Mi ∼σ M′. Then M1 ∼σ M2, hence, there must be a modelM of T1∪T2 withM ∼σ Mi for some i = 1, 2. Then we obtain that M ∼σ M′ and thus, by definition of forgetting,M′ is a model of forget (T1 ∪ T2, σ).\nTo compare this criterion with Example 5, observe that there exist modelsM1 |= T1 andM2 |= T2 with common domain such that M1 |= A ∧ P (c) ∧ ¬B and M2 |= A ∧ ¬P (c) ∧ ¬B. Thus, M1 ∼P (c) M2, however, there does not exist a model M of T1 ∪ T2 such that M ∼P (c) Mi, for some i = 1, 2. NeitherM1, norM2 is a model for T1 ∪ T2.\nCorollary 3.10 (Forgetting in the scope of one component) Let T1 and T2 be two sets of formulas, with sig (T1)∩sig (T2) = ∆, for a signature∆, and σ be either a subsignature of sig (T1)\\∆ or a ground atom with the predicate from sig (T1) \\∆. Then forget (T1 ∪ T2, σ) is equivalent to forget (T1, σ)∪T2. Moreover, if T1 and T2 are∆–inseparable, then so are forget (T1, σ) and T2.\nProof. Note that by the choice of σ, T2 is equivalent to forget (T2, σ) and thus, by Proposition 3.5, it suffices to verify the entailment forget (T1, σ)∪ forget (T2, σ) |= forget (T1 ∪T2, σ). If there are modelsM1 |= T1 andM2 |= T2, withM1 ∼σ M2, then in fact,M1 |= T1 ∪ T2, by the choice of σ and definition of ∼σ. Thus, the criterion from Proposition 3.9 obviously yields the required entailment. It remains to note that ∆–inseparability of forget (T1, σ) and forget (T2, σ) follows from the choice of σ, Proposition 3.6, and∆–inseparability of T1 and T2.\nIn general, the results of this section prove that the operation of forgetting does not behave well wrt the modularity properties of the input, since they are logic-dependent. Stronger model-theoretic conditions on the input are needed due to the model-theoretic nature of forgetting."
    }, {
      "heading" : "4 Properties of Progression",
      "text" : "We have considered some component properties of forgetting. It turns out that the operation of progression is closely related to forgetting in initial theories. However, in case of progression, we can not restrict ourselves to working with initial theories only; we need also to take into account information from successor state axioms. The aim of this section is to study component properties of progression wrt different forms of SSAs and common signatures ∆s (deltas) of components of initial theories. We will consider local-effect SSAs discussed in [27] and deltas, which do not contain fluents.\nWe use the following notations further in the paper. For a ground action term α in the language of the situation calculus, we denote by Sα the situation term do(α, S0). To define progression, we introduce an equivalence relation on many-sorted structures in the situation calculus signature. For two structuresM, M′ and a ground action α, we set M ∼Sα M ′ if:\n– M andM′ have the same sorts for action and object; – M andM′ interpret all situation-independent predicate and function symbols identically; – M andM′ agree on interpretation of all fluents at Sα, i.e., for every fluent F and every variable assignment θ, we haveM, θ |= F (x̄, Sα) iffM′, θ |= F (x̄, Sα).\nThat is, ifM ∼Sα M ′ then the structuresM andM′ are allowed to differ in sorts for situation and interpretations of fluents at situation terms, not equal to Sα. Note that a similar notation with ∼ is used to denote the equivalence relation on models from Definition 3.1 of forgetting. The two notations are easily distinguished depending on the context and are standard in the literature, therefore we adopt both of them in our paper.\nDefinition 4.1 (Progression, modified Definition 9.1.1 in [43]) LetD be a basic action theory with unique name axioms Duna and the initial theoryDS0 , and let α be a ground action term. A set DSα of formulas in a fragment of second-order logic is called progression ofDS0 wrt α if it is uniform in the situation term Sα and for any structure M, M is a model of Σ ∪ Dss ∪ Dap ∪ Duna ∪ DSα iff there is a modelM′ of D such thatM ∼Sα M ′.\nBelow, we use DSα to denote progression of the initial theory wrt the action term α, if the context of BAT is clear. We sometimes abuse terminology and call progression not only the theory DSα , but also the operation of computing this theory (when the existence of an effective operation is implicitly assumed). It can be seen (Theorem 2 in [26] and Theorem 2.10 in [27]) that progression always exists, i.e., is second-order definable, if the signature of BAT is finite and the initial theory DS0 is finitely axiomatizable. On the other hand, by the definition, for any BAT D, we have D |= DSα and, similarly to the operation of forgetting, it is possible to provide an example (see Definition 2, Conjecture 1, and Theorem 2 in [45]), when the progression DSα is not definable (even by an infinite set of formulas) in the logic in which D is formulated.\nTo understand the notion of progression intuitively, note the following. The progression DSα is a set of consequences of BAT that are uniform in the situation term Sα; it can be viewed as\nthe strongest postcondition of the precondition DS0 wrt the action α. Thus, informally, DSα is all the information about the situation Sα implied by BAT . This is guaranteed by the model-theoretic property with the relation ∼Sα in the definition. Recall that the initial theory of BAT describes information in the initial situation S0 and SSAs are essentially the rules for computing the new truth values of fluents that change after performing actions. Thus, progression DSα can be viewed as minimal “modification” of the initial theory obtained after executing the action α. In particular, the initial theory of BAT can be replaced with DSα(Sα/S0) (recall the notation from Section 2.3) which gives a new BAT , with Sα as the new initial situation. Let ϕ(s) be a formula uniform in a situation variable s. To solve the projection problem for ϕ(Sα), i.e., to find whether ϕ(Sα) holds in the situation Sα wrt BAT D, one might wish to compute progression DSα and then check whether Duna ∪ DSα |= ϕ(Sα) holds (or equivalently, whether Duna ∪ DSα(S0/Sα) |= ϕ(S0) holds). By Proposition 2.10, this is equivalent to D |= ϕ(Sα), so this progression-based approach solves the projection problem for ϕ(Sα). This helps to demonstrate why progression may be useful.\nConsequently, of interest are cases when progression can be computed effectively as a theory in the same logic that is used to formulate underlyingDS0 . The well-known approach is to consider the local-effect BAT s (recall Definition 2.11) in which progression can be obtained by just a syntactic modification of the initial theory DS0 with respect to SSAs. This approach is based on effective forgetting of a finite set of ground atoms (extracted from SSAs) in the initial theory of BAT . Recall the well–known observation from Section 3 that, given a theory T (in an appropriate logic L), forgetting a finite set of ground atoms in T can be computed effectively by straightforward syntactic manipulations with the axioms of T . Thus, the cornerstone of computing progression in the localeffect case is to extract effectively the set of ground atoms from SSAs that need to be forgotten. Subsequently, inDSα , they are replaced with new values of fluents, which are computed from SSAs. An interested reader may consult the whole paper [27], while here we only introduce necessary notations from Definition 3.4 of [27], which will be used in Theorem 4.5.\nLet D be a BAT with a set Dss of SSAs, an initial theory DS0 , and a unique name theory Duna, and let α be a ground action term. Take a generic SSA (†) for the fluent F (see Section 2.3) and replace there an action variable a with the action term α. Then, use unique name axioms for actions to replace equalities (or negations of equalities) between action functions with equalities (or negations of equalities, respectively) between object arguments. After that, apply the usual FO logic equivalences to eliminate existential quantifiers inside γ+F (x̄, α, s), γ − F (x̄, α, s), if any. Recall these are formulas uniform in s that appear on the right-hand side of a generic SSA (†). Observe that in a local-effect SSA, when one substitutes a ground action termA(b̄x, b̄z) for a variable a in the formula [∃z̄].a=A(x̄, z̄) ∧ φ(x̄, z̄, s), applying UNA for actions yields [∃z̄].x̄= b̄x ∧ z̄= b̄z ∧ φ(x̄, z̄, s), and applying ∃z(z = b ∧ φ(z)) ≡ φ(b) repeatedly results in the logically equivalent formula x̄= b̄x ∧ φ(x̄, b̄z, s). In a transformed SSA that is obtained after doing all these simplifications, it is convenient to consider all object constants appearing in equalities between object variables and constants. These represent values where the fluent F changes. To compute the new value of the fluent it is sufficient to instantiate object variables of F with the corresponding constants. Denote\n∆F = {t̄ | x̄ = t̄ appears in γ + F (x̄, α, s) or γ − F (x̄, α, s) in a transformed SSA for F instantiated with α and equivalently rewritten wrt Duna}, Ω(s) = {F (t̄, s) | t̄ ∈ ∆F }.\nConsider Ω(s) and notice that Ω(S0) is a finite set of ground atoms to be forgotten. According to Fact 3.2, forgetting several ground atoms can be accomplished consecutively in any order.\nAn instantiation of Dss wrt Ω(S0), denoted by Dss[Ω(S0)], is the set of formulas of the form:\nF (t̄, do(α, S0)) ↔ γ + F (t̄, α, S0) ∨ F (t̄, S0) ∧ ¬γ − F (t̄, α, S0).\nThese formulas represent instantiations of the transformed SSAs with object constants where the fluents change. Observe that Dss[Ω(S0)] effectively defines new values for those fluents, which are affected by the action α. However, these definitions use fluents wrt S0, which may include fluents to be forgotten. For this reason, forgetting should be performed not only in DS0 , but in Dss[Ω(S0)] as well.\nProposition 4.2 (Theorem 3.6 in [27]) In the notations above, the following is a progression of DS0 wrt α in the sense of Definition 4.1:\nDSα = forget ( Dss[Ω(S0)] ∪ DS0 , Ω(S0) ) (Sα/S0).\nThis formula demonstrates that progression is a set of formulas obtained after forgetting old values of fluents in the initial theory and in instantiation of transformed SSAs that provide new values of fluents, and then replacing S0 with Sα. Thus, computing a progression in a local-effect BAT is an effective syntactic transformation of the initial theory, which leads to the unique form of the updated theory DSα . This fact will be used in Theorem 4.5. It is important to realize that this transformation can lead to an exponential blow-up of the initial theory, as noted after Theorem 3.6 in [27], due to the possible exponential blow-up after forgetting a set of ground atoms. This is not a surprise, because even in propositional logic, forgetting a symbol in a formula is essentially the elimination of a “middle term\" (introduced by Boole), which results in the disjunction of two instances of the input formula [23]. As a consequence, forgetting may result in a formula that is roughly twice as long as the input formula. It is important to realize that the exponential blowup is not inevitable in the case of progression. As shown in [27], there are practical classes of the initial theories for which there is no blow-up and the size of the progressed theory is actually linear wrt the size of the initial theory.\nExample 1 (continuation). As was discussed before, all SSAs in this example are local effect. Instantiate the action variable a in the SSAs with a ground actionmove(C1, C2, C3). Then, we get:\nClear(x, do(move(C1 , C2, C3), s)) ↔ ∃y, z ( move(C1, C2, C3)=move(y, x, z) ) ∨ Clear(x, s) ∧ ¬∃y, z(move(C1, C2, C3)=move(y, z, x)), On(x, y, do(move(C1, C2, C3), s)) ↔ ∃z ( move(C1, C2, C3)=move(x, z, y) ) ∨\nOn(x, y, s) ∧ ¬∃z ( move(C1, C2, C3)=move(x, y, z) ) .\nApplying UNA for actions yields the following axioms:\nClear(x, do(move(C1, C2, C3), s)) ↔ ∃y, z ( y=C1 ∧ x=C2 ∧ z=C3 ) ∨ Clear(x, s) ∧ ¬∃y, z(y=C1 ∧ z=C2 ∧ x=C3), On(x, y, do(move(C1, C2, C3), s)) ↔ ∃z(x=C1 ∧ z=C2 ∧ y=C3)∨\nOn(x, y, s) ∧ ¬∃z(x=C1 ∧ y=C2 ∧ z=C3).\nDoing the equivalent first order simplifications yields the transformed SSAs:\nClear(x, do(move(C1 , C2, C3), s)) ↔ (x=C2) ∨ Clear(x, s) ∧ ¬(x=C3), On(x, y, do(move(C1 , C2, C3), s)) ↔ (x=C1 ∧ y=C3) ∨On(x, y, s) ∧ ¬(x=C1 ∧ y=C2).\nThe argument set∆F for the fluent F wrt a ground action α is a set of constants appearing in the transformed SSA for F instantiated with α. For example, the set ∆clear for the fluent Clear(x, s) wrt a ground actionmove(C1, C2, C3) is {C2, C3}. For the fluentOn(x, y, s) this argument set∆on is {〈C1, C3〉, 〈C1, C2〉}. The characteristic set Ω of a ground action move(C1, C2, C3) is a set of all ground atoms subject to change by this action. Therefore Ω(s) = {Clear(C2, s), Clear(C3, s), On(C1, C3, s), On(C1, C2, s)}. Notice that if block C3 is clear at s, it no longer remains clear after doingmove(C1, C2, C3) action, but blockC2 will become clear. However, this action has no effect on the property of C1 being clear, and for this reason, C1 is not in∆clear and not in the characteristic set Ω.\nUsing these atoms to instantiate the transformed SSA, i.e., by replacing object arguments with constants from∆F , we obtain the set Dss[Ω] of formulas representing new values of fluents, e.g.,\nOn(C1, C3, do(move(C1, C2, C3), S0)) ↔ C1=C1 ∧ C3=C3 ∨ On(C1, C3, S0) ∧ ¬(C2=C3 ∧C3=C2).\nAfter the equivalent simplifications using UNA, the instantiated SSAs wrt Ω(Sα), where Sα = do(move(C1, C2, C3), S0) will be the following set:\n{Clear(C2, Sα),¬Clear(C3, Sα), On(C1, C3, Sα),¬On(C1, C2, Sα)}.\nNote that in this example Dss[Ω] are very simple, but in a general case, if a SSA includes context conditions, these axioms may include fluents wrt S0. Finally, according to Proposition 4.2, to compute a progression DSα of an initial theory DS0 for BW, we have to forget all old values of the fluents from Ω(S0) in the theory Dss[Ω] ∪DS0 , and subsequently replace the situation Sα with S0.\nNow we are ready to formulate the results on component properties of progression in terms of decomposability and inseparability. We start with negative examples in which every BAT is localeffect and the initial theories are formulated in first-order logic. As the progression DSα is a set of formulas uniform in some situation term Sα, which may occur in every formula of DSα (thus potentially spoiling decomposability), we consider the mentioned decomposability and inseparability properties regarding the theory DSα(S0/Sα) instead of DSα . Otherwise, in every result we would have to speak of∆∪sig (Sα)–decomposability of progression, since the symbols from sig (Sα)= sig (do(α, S0))={do, S0} ∪ sig (α) may occur in all components.\nConsider a BAT D with ∆–decomposable initial theory DS0 for a signature ∆. The general definition of a successor state axiom gives enough freedom to design examples showing (non)preservation of the decomposability property of DS0 or inseparability of its components. Note that an SSA may contain symbols that are not even present in sig (DS0), or symbols from both components of DS0 (if decomposition exists). Therefore, it makes sense to restrict our study to those BAT s, where SSAs have one of the well-studied forms, e.g., to local-effect theories. It turns out that this form is still general enough to easily formulate negative results demonstrating that the aforementioned properties are not preserved without stipulations.\nFirst, we provide an example showing that the decomposability property of the initial theory can be easily lost under progression. Next, we show that ∆–inseparability of components of the initial theory DS0 can be easily lost when fluents are present in ∆ (see Example 7). The third observation is that even if there are no fluents in ∆, some components of DS0 can split after progression into theories which are no longer inseparable (see Example 8). All observations hold already for localeffect BAT s and follow from the fact that some new information from SSAs can be added to the initial theory after progression, which spoils its component properties. We only need to provide a\ncombination of an initial theory with a set of SSAs that are appropriate for this purpose. The aim of Theorem 4.4 following these negative examples is to prove that if ∆ does not contain fluents and the components of DS0 do not split after progression, then ∆–inseparability is preserved after progression under a slight stipulation which is caused only by generality of the theorem and the nonuniqueness of progression in the general case. This stipulation is avoided in Theorem 4.5, where we consider the class of local-effect BAT s. Recall that all free variables in axioms of BAT s are assumed to be universally quantified.\nExample 6 (Decomposability lost under progression).Consider basic action theoryD, with {F, P,A, c} ⊆ sig (D), where F is a fluent, P a predicate, A an action function, and c an object constant. Let the theory Dss consist of the single axiom\nF (x, do(a, s)) ↔ (a = A(x)) ∧ P (x) ∨ F (x, s)\nand let the initial theory DS0 consist of two axioms ¬F (c, S0) and ∃xP (x). Clearly, DS0 is a ∅– decomposable.\nConsider action α = A(c) and let us compute progression of DS0 wrt α. We apply Proposition 4.2, since D is local-effect. The instantiation of the SSA from Dss with α has the form\nF (x, do(A(c), s)) ↔ (A(c) = A(x)) ∧ P (x) ∨ F (x, s)\nfor which equivalent rewriting wrt Duna gives\nF (x, do(A(c), s)) ↔ (x = c) ∧ P (x) ∨ F (x, s)\nHence, we have Ω(S0) = {F (c, S0)} and Dss[Ω(S0)] = F (c, Sα) ↔ P (c) ∨ F (c, S0). Since ¬F (c, S0) ∈ DS0 , the theory Dss[Ω(S0)] ∪ DS0 is equivalent to {F (c, Sα) ↔ P (c)} ∪ DS0 . By Proposition 4.2, forgetting the ground atom F (c, S0) in this theory and substituting S0 with Sα gives the theory DSα , the progression of DS0 wrt α. By using the definition of forgetting, it is easy to confirm that DSα is equivalent to {F (c, Sα) ↔ P (c), ∃xP (x)}. One can verify that DSα (and also DSα(S0/Sα)) is not ∆–decomposable theory, for any ∆. Notice that decomposability is lost, because fluent F and predicate P from different components of DS0 become related to each other after progression.\nFor a signature ∆, with S0 ∈ ∆, and an action A(c), we now give an example of a local-effect basic action theoryD withDS0 , an initial theory∆–decomposable into finite∆–inseparable components. This example shows that progressionDSα(S0/Sα) ofDS0 wrtA(c) (with term Sα substituted with S0) is finitely axiomatizable and ∆–decomposable, but the decomposition components are no longer∆–inseparable, unless we allow them to be infinite.\nExample 7 (∆–inseparability is lost when fluents are in ∆). Consider a basic action theory D with {F, P,R,A, b, c} ⊆ sig (D), where F is a fluent, P,R are predicates,A an action function, and b, c object constants. Let∆ = {F,R, S0, c} and define subtheories of D as follows:\nDss = {F (x, do(a, s)) ↔ (a = A(x)) ∧ P (x) ∨ F (x, s)} (i.e. as in the previous example)\nDS0 = D1 ∪ D2,with\nD1 = {Taut(F,R, S0, b), ¬F (c, S0)}, where Taut(F,R, S0, b, c) is a tautological formula in the signature {F,R, S0, b, c},which is uniform in S0\nD2 = {P (x) → ∃y(R(x, y) ∧ P (y)), ¬F (c, S0)}.\nBy the syntactic form,DS0 is∆–decomposable:we haveDS0 = D1∪D2, sig (D1)∩sig (D2) = ∆, sig (D1) \\ ∆ = {b}, and sig (D2) \\ ∆ = {P}. It is also easy to confirm that D1 and D2 are ∆–inseparable.\nBy Proposition 4.2 it is easy to verify that the union of {Taut(F,R, S0, b, c)} and D′2 = (D2 \\ {¬F (c, S0)}) ∪ {ϕ}, where ϕ = F (c, Sα) ↔ P (c) is a progression (DSα) of DS0 wrt α = A(c).\nBy the syntactic form, DSα(S0/Sα) is a ∆–decomposable theory. On the other hand, we have ϕ |= F (c, Sα) → P (c), thus\nD′2(S0/Sα) |= {F (c, S0) → ∃yR(c, y) , F (c, S0) → ∃y∃z[R(c, y) ∧R(y, z)] , . . .}\nThis is an infinite set of formulas in signature ∆. It follows from Fact 2.3 that this theory is not finitely axiomatizable by formulas of first-order logic in signature ∆ and it is easy to verify that DSα(S0/Sα) can not have a decomposition into finite ∆–inseparable components.\nNote that in the example above, the initial theory DS0 is in fact ∅–decomposable with one signature component equal to {b} and the other component containing the rest of the symbols. It is easy to see that the progression of DS0 wrt A(c) is ∅–decomposable as well. We use tautologies in the example just to illustrate the idea that information from SSA can propagate to the initial theory after progression, thus making the components lose the inseparability property. There is a plenty of freedom to formulate similar examples with the help of non-tautological formulas which syntactically “bind” symbols F,R, S0, b in the theory D1. We appeal to a similar observation in Example 8.\nExample 8 (Split of a component and loss of ∆–inseparability). Consider BAT D, with {F1, F2, D,B, P,R,A, c} ⊆ sig (D), where F1, F2 are fluents, D,B, P,R predicates, A an action function, and c an object constant. Let ∆ = {D,R, S0} and define the subtheories of D as follows:\nDss = {F1(x, do(a, s)) ↔ F1(x, s) ∧ ¬(a = A(x)), F2(x, do(a, s)) ↔ F2(x, s)}\nDS0 = D1 ∪ D2,where D1 is the set of formulas with occurrences ofD,R, S0:\nD(x) ∨R(x, y) → F1(c, S0)\nD(x) → P (x)\nP (x) → ∃y(R(x, y) ∧ P (y))\nand D2 consists of the following three formulas (which also mentionD,R, S0):\nD(x) → B(x)\nB(x) → ∃y(R(x, y) ∧B(y))\nTaut(F2, S0), a tautology in the signature {F2, S0}, uniform in S0. Here, F2 is an auxiliary fluent introduced to have an occurrence of S0 in D2.\nBy definition, DS0 is ∆–decomposable into ∆–inseparable components D1 and D2. Note that Dss |= ¬F1(c, do(A(c), S0)), which is the result of substitution of the ground actionA(c), situation constant S0, and object constant c in SSA.\nConsider progression of DS0 wrt the action α = A(c). By Proposition 4.2, it is equivalent to the theory DSα = D ′ 1 ∪ D ′′ 1 ∪ D ′ 2, where D ′ 1 is the set of the following formulas:\n¬F1(c, do(A(c), S0))\nTaut(D,R), a tautological formula in the signature {D,R} which is uniform in Sα,\nD′′1 is the set of formulas:\nD(x) → P (x)\nP (x) → ∃y(R(x, y) ∧ P (y))\nTaut(F2, Sα), a tautological formula in the signature {F2, do, A, c, S0} which is uniform in Sα\nand D′2 is the theory D2 with every occurrence of S0 substituted with Sα.\nClearly, DSα(S0/Sα) is ∆–decomposable. Note that after progression the component D1 is “split” intoD′1(S0/Sα) andD ′′ 1 (S0/Sα) and these theories are not∆–inseparable (similarly,D ′ 1(S0/Sα) and D′2(S0/Sα)). By Fact 2.3, it can be shown that they can not be made ∆–inseparable while remaining finitely axiomatizable.\nTo formulate the theorems below, we let D denote a BAT with the initial theory DS0 , the set of successor state axioms Dss, and the unique name axioms Duna. Example 7 has resulted in the following definition.\nDefinition 4.3 (Fluent–free signature) A signature ∆ is called fluent–free if no fluent (from the alphabet of situation calculus) is contained in∆.\nTheorem 4.2 complements Examples 4.3 and 4.4, which identify properties of decomposed actions theories causing loss of inseparability of components after progression. The theorem shows that if these properties are absent then inseparability is preserved. As we have already seen in Example 7, the initial theory and progression may differ in consequences involving symbols of fluents. Thus in general, preservation of ∆–inseparability can be guaranteed only for fluent-free signatures ∆, which is reflected in the conditions of the theorem. Besides, by the model-theoretic Definition 4.1, progression is not uniquely defined – there is no restriction on occurrences of the unique name axioms in progression, which may easily lead to loss of inseparability of the components. In other words, progression may logically imply unique name axioms even if the initial theory did not imply them. Some decomposition components of progression may imply such formulas, while the others may not. For this reason, we speak of inseparability “modulo” theory Duna in the first point of the theorem below. In particular, we have to make the assumption that not only the components {Di}i∈I⊆ω of the initial theory are pairwise∆–inseparable, but so are the theories {Duna∪Di}i∈I .\nFor fluent-free deltas, the progression entails exactly those ∆-formulas, which are entailed already by the initial theory (together with UNA-axioms), and the question is how these formulas can be “distributed” between the components. The second point of the theorem rules out the case (described in Example 8), when ∆-consequences are split between the components of progression. Note that in the theorem we do not specify how the progression was obtained (cf. Theorem 4.5) and the only condition that relates the components of progression with those of the initial theory says about containment of∆–consequences.\nTheorem 4.4 (Preservation of∆-insep. for fluent-free∆) Let L have PIP and D be a BAT in which DS0 and Duna are theories in L. Let σ ⊆ sig (DS0) be a fluent–free signature and denote ∆ = sig (Duna) ∪ σ. Suppose the following:\n– DS0 is σ–decomposable with some components {Di}i∈I⊆ω such that the theories from {Duna∪ Di}i∈I are pairwise ∆–inseparable; – DSα(S0/Sα) is equivalent to the union of theories {D ′ j}j∈J⊆ω such that for every j ∈ J and\nsome i ∈ I , Cons (Duna ∪D′j, ∆) ⊇ Cons (Duna ∪Di, ∆).\nThen the theories from {Duna ∪D′j}j∈J⊆ω are pairwise ∆–inseparable.\nProof. Let us demonstrate that for all j ∈ J we have Cons (Duna ∪ D′j , ∆) = Cons (Duna ∪ DS0 , ∆), from which the statement of the theorem obviously follows. Essentially, we prove the following inclusions (the corresponding points of the proof are marked with circles):\nCons (Duna ∪ DSα(S0/Sα),∆) ⊆ Cons (Duna ∪ DSα ,∆) ⊆ Cons (Duna ∪ DS0 ,∆)\n❥2❥3\n❥1\n⊆\n⊇ ❥4\nTheorem conditions\n⊆❥4 Theorem conditions\nCons (Duna ∪ Di,∆)Cons (Duna ∪ D ′ j ,∆)\n1) Note that for any i ∈ I , DS0 is σ–decomposable with componentsDi and ⋃ k∈I\\{i}Dk. We\nclaim thatDuna∪Di andDuna∪ ⋃ k∈I\\{i}Dk are∆–inseparable. Letϕ be a formula in signature∆.\nIf Duna ∪Di |= ϕ then clearly, Duna ∪ ⋃ k∈I\\{i}Dk |= ϕ by ∆–inseparability from the condition\nof the theorem. On the other hand, if Duna ∪ ⋃\nk∈I\\{i}Dk |= ϕ then by PIP we have Tuna ∪⋃ k∈I\\{i} Tk |= ϕ, where Duna |= Tuna, sig (Tuna) ⊆ sig (Duna) and Dk |= Tk for k ∈ I \\ {i}, sig (Tk) ⊆ ∆. Again, by∆–inseparability, for each k ∈ I \\ {i}we haveDuna ∪Di |= Tk and thus, Duna ∪Di |= ϕ.\nTherefore, if ϕ ∈ Cons (Duna∪DS0 , ∆), then for every i ∈ I , [Duna∪ ⋃ k∈I\\{i}Dk] ∪ [Duna∪\nDi] |= ϕ and then by PIP and inseparability shown above, Duna ∪Di |= ϕ. Since DS0 |= ⋃\ni∈I Di by decomposability, we obtain Cons (Duna ∪ DS0 , ∆) = Cons (Duna ∪Di, ∆) for all i ∈ I .\n2) Let us show that Cons (Duna ∪DSα , ∆) ⊆ Cons (Duna ∪DS0 , ∆). First, take a formula ψ ∈ Cons (Duna ∪ DSα , ∆), which does not contain situation terms. From the definition of progression, every model of D is a model of Duna ∪ DSα , so D |= Duna ∪ DSα and hence, D |= ψ. If Duna ∪ DS0 6|= ψ, then Duna ∪ DS0 ∪ {¬ψ} is satisfiable and since ψ is a uniform formula, by Proposition 2.10, D ∪ {¬ψ} is satisfiable, which contradictsD |= ψ. Therefore,Duna ∪ DS0 |= ψ.\nIt remains to verify that the set Cons (Duna ∪ DSα , ∆) is axiomatized by sentences which do not contain situation terms. We have ∆ = sig (Duna) ∪ σ ⊆ sig (Duna) ∪ sig (DS0), so {do, , Poss}∩∆ = ∅, by definition ofDuna andDS0 . As σ if fluent-free by the condition of the theorem (and sig (Duna) is fluent-free by definition of BAT ), ∆ may contain only situation–independent predicates and functions. Thus, any formulaϕ ∈ Cons (Duna∪DSα , ∆)may contain situation terms only in equalities, where each term is either the constant S0 (in case S0 ∈ σ) or a bound variable of sort situation. Suppose that this is the case and there is no ψ ∈ Cons (Duna ∪ DSα , ∆) such that ψ |= ϕ and ψ does not contain situation terms. By the syntax of Lsc and the choice of∆, then ϕ is a boolean combination of formulas without situation terms and sentences over signature {S0} stating that ϕ has a model with cardinality |Sit| of sort situation lying in the interval [n,m] for n ∈ ω and m ∈ ω ∪ {∞}. We denote sentences of this form by ∃[n,m]θ=. We may assume that ϕ is in conjunctive normal form and that there is a formula ξ, a boolean combination of ∃[n,m]θ= such that 6|= ξ, 6|= ¬ξ, either ξ or ξ ∨ η is a conjunct of ϕ, and η 6∈ Cons (Duna ∪ DSα , ∆), sig (η) ⊆ ∆, is\na formula without situation terms. As 6|= ξ and 6|= ¬ξ, there are n,m ∈ ω such that ξ does not have a model with |Sit| = n and ¬ξ does not have a model with |Sit| = m. Then by Lemma 2.8, we conclude thatDuna∪DSα 6|= ξ andDuna∪DSα 6|= ¬ξ. In particular, ξ can not be a conjunct of ϕ. If ξ∨η is a conjunct, then there exists a modelM ofDuna∪DSα such thatM |= ξ andM 6|= η. Then, by applying Lemma 2.8 again, there must be a modelM′ of Duna ∪DSα with |Sit| = n where the interpretation of situation–independent predicates and functions is the same as inM. Thus,M′ 6|= ξ and since η does not contain situation terms,M′ 6|= η, which contradictsDuna ∪ DSα |= ϕ.\n3) Now let us demonstrate that Cons (Duna ∪ DSα(S0/Sα), ∆) ⊆ Cons (Duna ∪ DSα , ∆). Note that Duna ∪ DSα(S0/Sα) is uniform in S0. Following the above proved, assume that there is a formula ϕ ∈ Cons (Duna ∪ DSα(S0/Sα), ∆) such that ϕ does not contain situation terms and Duna ∪DSα 6|= ϕ. Take a modelM of Duna ∪DSα such thatM 6|= ϕ. Then, by Lemma 2.8, there exists a modelM′ ofDuna∪DSα such that the domain for sort situation inM\n′ is a singleton set (i.e., the interpretation of terms S0 and Sα coincide inM′) and the interpretation of situation–independent symbols is the same in M and M′. ThenM′ 6|= ϕ, but clearly M′ |= Duna ∪ DSα(S0/Sα) which contradicts the assumption Duna ∪DSα 6|= ϕ.\n4) Finally, by the condition of the theorem, for all j ∈ J , we have Duna ∪ D′j ⊆ Duna ∪ DSα (S0/Sα) and from points 1–3 above we obtain Cons (Duna ∪ DSα(S0/Sα), ∆) ⊆ Cons (Duna ∪ DS0 , ∆). Hence, for all j ∈ J we have Cons (Duna ∪ D ′ j , ∆) ⊆ Cons (Duna ∪ DS0 , ∆). On the other hand, we also have Cons (Duna ∪ Di, ∆) ⊆ Cons (Duna ∪ D′j, ∆) from the condition of the theorem. Therefore from the inclusion ∀ i ∈ I Cons (Duna ∪ DS0 , ∆) ⊆ Cons (Duna ∪Di, ∆) of point 1 we conclude that Cons (Duna ∪D′j, ∆) = Cons (Duna ∪ DS0 , ∆) for all j ∈ J .\nThe next theorem provides a result on local-effect BAT s with initial theories in first-order logic for which progression becomes more concrete, since it can be computed by syntactic manipulations. In contrast to Theorem 4.4, this allows us to judge about inseparability without the theory Duna in background. Recall that, in general, a BAT includes non-trivial precondition axioms. On the righthand side of each precondition axiom, there is a formulaΠA(x̄, s) that is a formula uniform in swith free variables among x̄ and s. However, any BAT can be transformed into an action theory without precondition axioms by introducing the right hand side formulas from the precondition axioms as conjuncts of context conditions for each corresponding active position of an action term in a SSA. Therefore, without loss of generality, and for simplicity of presentation, we subsequently consider the BAT s where all precondition axioms are trivial.\nEssentially, the conditions of the theorem are defined to guarantee componentwise computation of progression for a decomposable initial theory. A finite set Dss of the SSAs is considered to be syntactically divided into the union of |I| sub-theories sharing some fluent-free signature∆1 (which may include actions, static predicates, and object constants), as well as function do (which occurs in every SSA). Informally, each of |I| sub-theories is about a different set of properties, e.g., one of them could be about the blocks world, while another could be about the logistics world, with the two theories possibly sharing some constants, such as a box name, and situation-independent predicates, such as shapes of the boxes. The initial theory DS0 is∆2–decomposable, for a fluent-free signature ∆2, into |J | components. To distinguish visually componentsD′j ofDS0 from the componentsDi of Dss, we write D′j with apostrophe when we mean components of DS0 , and Di without apostrophe when we mean groups of SSAs. Informally, each component D′j is about a separate aspect of the initial theory. The syntactic form of the initial theory may not reveal the components readily, but they can be discovered through decomposition. Naturally, it is expected that independent components of\nthe initial theory should remain independent after doing any actions. This imposes a condition that each component from the initial theory should be related with its own group of SSAs.\nThe last two conditions of the theorem enforce that the subtheories of Dss are aligned with the components ofDS0 via syntactic occurrences of fluents. The second to last condition says that every fluent mentioned in a SSA must also occur in the initial theory DS0 . It is easy to satisfy by adding tautologies with the corresponding fluents to DS0 . Together with the last condition it guarantees that for every SSA ϕ containing fluents F1, . . . , Fn there is a corresponding component of DS0 , which describes the initial interpretation of these fluents, and this is the component that must be updated upon executing an action mentioned in active position of ϕ. The last condition also enforces that actions, static predicates, or object constants separated by the decomposition of DS0 must be also separated by the subtheories of Dss, whenever they occur in SSAs. This guarantees that these symbols do not become connected after progression (as opposed to the situation presented in Example 6). Thus, the theory Dss ∪ DS0 can be divided into parts (consisting of successor-state axioms and statements about the initial situation) which may mention common actions, static predicates and constants, but talk about different fluents. In other words, these subtheories define independent sets of situation-related properties, which is natural for a composite action theory describing a single domain of objects from a number of different perspectives. Note that it is allowed for a single action to have effects on groups of fluents (possibly, all the fluents at once, without regard to distribution of the fluents between the subtheories), which is reflected in the theorem condition that ∆1 is just fluent-free, but not action free. We impose stronger restriction in Corollary 4.6, which describes a class of BAT s representing composite subject domains, like the one mentioned in the running example from Section 2.3.\nFor the reader’s convenience, we stress that in the formulation of the theorem, the indices i and j vary over components of Dss and DS0 , respectively. The signatures ∆1 and ∆2 are the sets of allowed common symbols between the components of Dss and DS0 , respectively. We recall that A (F , respectively) denotes the set of action functions (the set of fluents, respectively) from the alphabet of the language of the situation calculus.\nTheorem 4.5 (Preservation of components in local-effect BAT ) Let D be a local-effect BAT , with DS0 an initial theory in first-order logic. Let ∆1, ∆2 be fluent-free signatures, do 6∈ ∆1, ∆2, and α = A(c̄) a ground action term. Denote∆ = ∆1 ∪∆2 ∪ {c1, . . . , ck}, if c̄ = 〈c1, . . . , ck〉, and suppose the following:\n– Dss is the union of theories {Di}i∈I , with sig (Dn) ∩ sig (Dm) ⊆ ∆1 ∪ {do} for all n,m ∈ I 6= ∅, n 6= m; – DS0 is ∆2–decomposable into finite components {D ′ j}j∈J uniform in S0 such that sig (D ′ j) \\\n∆ 6= ∅, for all j ∈ J; – sig (Dss) ∩ F ⊆ sig (DS0); – for every i ∈ I , there is j ∈ J such that sig (Di) ∩ sig (DS0) ⊆ sig (D ′ j).\nThenDSα(S0/Sα) is∆–decomposable. If the components {D ′ j}j∈J are pairwise∆–inseparable,\nthen so are the components of DSα(S0/Sα) in the corresponding decomposition.\nProof. The proof consists of two parts, both of which rely on the constructive definition of progression for local-effect BAT s from Section 4 and component properties of forgetting discussed in Section 3. In the first part, we show∆-decomposability ofDSα(S0/Sα) by constructing its components explicitly and in the second part we prove that these components are ∆-inseparable.\n1) By definition of BAT , for every i ∈ I , we have sig (Di) ∩ F 6= ∅ and thus, from the conditions of the theorem, sig (Di) ∩ sig (DS0) 6= ∅, sig (Dss) ∩ F = sig (DS0) ∩ F . Hence, for every i ∈ I there is j ∈ J such that sig (Di) ∩ F ⊆ sig (D′j). Moreover, such j ∈ J is unique for every i ∈ I , because otherwise there would exist n,m ∈ J , n 6= m, such that sig (D′n) ∩ sig (D′m)∩F 6= ∅, which contradicts the condition that∆2 is fluent-free. Therefore, there is a map f : I → J such that for every i ∈ I , sig (Di) ∩ F ⊆ sig (D′f(i)). Note that there may exist j ∈ J such that sig (D′j) ∩ F = ∅ and in this case j is the image of no i ∈ I . Let us denote the image of f by J̃ (so, J̃ ⊆ J). Now, for every i ∈ I , consider the set of formulas Di[Ω], the instantiation of Di w.r.t. Ω(S0), and for each j ∈ J̃ , denote D̃j = [ ⋃ i∈f−1(j)(Di[Ω]) ]∪D ′ j . Then, by Proposition 4.2,DSα(S0/Sα) (progression of DS0 wrt α, with term Sα substituted with S0) is logically equivalent to\n[ forget ( ⋃\nj∈J̃\nD̃j , Ω(S0)) ∪ ⋃\nj∈J\\J̃\nD′j ] (S0/Sα).\nAs ∆1 and ∆2 are fluent-free, the signatures {sig (D̃j)}j∈J̃ do not have fluents in common and thus, by Corollary 3.10, DSα(S0/Sα) is equivalent to\n[ ⋃\nj∈J̃\nforget (D̃j , Ω(S0) |j) ∪ ⋃\nj∈J\\J̃\nD′j ] (S0/Sα),\nwhere for j ∈ J̃ , Ω(S0) |j is the subset of ground atoms from Ω(S0) with fluents from sig (D′j). For all j ∈ J \\ J̃ , we have sig (D′j) ∩ F = ∅ and D ′ j is uniform in S0, so it follows that S0 6∈ sig (D′j) and thus, DSα(S0/Sα) is equivalent to the union\n[ ⋃\nj∈J̃\nforget (D̃j , Ω(S0) |j) ] (S0/Sα) ∪ ⋃\nj∈J\\J̃\nD′j.\nFor every j ∈ J , let D′′j be the set of formulas (forget (D̃j , Ω(S0) |j))(S0/Sα) (in case j ∈ J̃) or the set of formulas D′j (if j ∈ J \\ J̃). So DSα(S0/Sα) is equivalent to ⋃ j∈J D ′′ j . By the definition of forgetting a set of ground atoms one can assume that sig (D′j) ⊆ sig (D ′′ j ) and sig (D ′′ j ) \\ sig (D′j) ⊆ sig (Dss) ∪ {c1, . . . , ck}, for all j ∈ J . Let us show that [sig (D′′i )∩ sig (D ′′ j )] ⊆ ∆, for all distinct i, j ∈ J . Assume there are distinct i, j ∈ J such that [sig (D′′i ) ∩ sig (D ′′ j )] \\ ∆ = Σ 6= ∅, for a signature Σ. Then do 6∈ Σ, since both D′′i and D ′′ j are uniform in S0. If there is a single subtheory Dm of Dss, m ∈ I , such that Σ ⊆ sig (Dm), then the last two conditions of the theorem yieldΣ ⊆ ∆2, which is a contradiction, because we have assumed Σ ∩∆ = ∅. If there are distinct subtheoriesDm andDn of Dss,m,n ∈ I , such that Σ ⊆ sig (Dm) ∩ sig (Dn), then Σ ⊆ ∆1, and we again arrive at contradiction.\nIt follows that the pairwise intersection of any signatures from {sig (D′′j )}j∈J is a subset of ∆ and it follows from the second condition of the theorem that sig (D′′j ) \\ ∆ 6= ∅. Then {D ′′ j ∪ Taut(∆, j)}j∈J is∆–decomposition of DSα(S0/Sα), where for each j ∈ J , Taut(∆, j) is a set of tautologies in signature∆ \\ sig (D′′j ) which are uniform in S0.\n2) Now let us verify that the sets of formulas from {D′′j }j∈J are pairwise ∆–inseparable, if so are the components of DS0 .\na) First, consider the sets from the union\n⋃\nj∈J̃\nD̃j ∪ ⋃\nj∈J\\J̃\nD′j . (‡)\nThe pairwise intersection of their signatures is contained in ∆ ∪ sig (Sα). We claim that the sets from this union are pairwise∆–inseparable.\nBy our definition, for all j ∈ J̃ we have D′j ⊆ D̃j and hence, Cons (D ′ j , ∆) ⊆ Cons (D̃j , ∆), so let us check that Cons (D̃j , ∆) ⊆ Cons (D′j , ∆) for every j ∈ J̃ . Each formula in Di[Ω], for i ∈ f−1(j), j ∈ J̃ , has the form\nF (c̄, do(A(c1, . . . , ck), S0)) ↔ (ε1 ∧ φ +) ∨ (F (c̄, S0) ∧ ε2 ∧ φ −), (∗)\nwhere F is a fluent from sig (D′j), c̄ is a vector of constants from {c1, . . . , ck}, φ +, φ− are sentences uniform in S0, and each ε1, ε2 equals true or false (the parameters to summarize different cases of this formula). This is a definition of ground atom F (c̄, do(A(c1, . . . , ck), S0) via fluents at situation S0 and situation-independent predicates and functions. Therefore, since ∆ is fluent-free and for all j ∈ J̃ , D′j is uniform in S0, every model M of D ′ j can be transformed into a model M\n′ of D̃j which agrees with M on ∆. The model M′ is obtained in two steps. First, we expand M with an arbitrary interpretation of function do and situation-independent predicates and functions from sig (Di[Ω]) \\ sig (D′j) for every i ∈ f\n−1(j). Then we continue with this expanded model and modify the truth value of each fluent F at the interpretation of the tuple 〈c̄, do(A(c1, . . . , ck), S0)〉 according to the obtained truth value of the formula in the definition of F (c̄, do(A(c1, . . . , ck), S0) above. This gives us the modelM′. Hence, if ϕ ∈ Cons (D̃j , ∆) and ϕ 6∈ Cons (D′j , ∆), then there is a modelM ofD′j such thatM 6|= ϕ, but thenM ′ |= D̃j andM′ 6|= ϕ, a contradiction. Therefore, we conclude that for all j ∈ J̃ , Cons (D̃j , ∆) = Cons (D′j , ∆) and, by pairwise∆–inseparability of the components of DS0 , the sets from the union (‡) are ∆–inseparable.\nb) Since ∆ is fluent-free and Ω(S0) consists only of ground atoms with fluents, from Corollary 3.10 we conclude that the sets from the following union are∆–inseparable:\n⋃\nj∈J̃\nforget (D̃j , Ω(S0) |j) ∪ ⋃\nj∈J\\J̃\nD′j .\nNow we are ready to prove that the sets from {D′′j }j∈J are pairwise ∆–inseparable. For every j ∈ J̃ , let us denote Gj = forget (D̃j , Ω(S0) |j). We will demonstrate that for every j ∈ J̃ it holds Cons (Gj(S0/Sα), ∆) = Cons (Gj , ∆), from which the statement follows. First, let us verify that Cons (Gj (S0/Sα), ∆) ⊆ Cons (Gj , ∆). Assume that for some j ∈ J̃ (we fix this j for the following) there is a formula ϕ ∈ Cons (Gj(S0/Sα), ∆) and a model M of Gj such that M 6|= ϕ, and arrive at contradiction.\nBy the syntactic definition of forgetting a ground atom, the term Sα occurs in Gj only in subformulas obtained from the definitions (∗), so let us consider such a definition for a ground atom F (c̄, Sα) with some fluent F . Let us recall that Gj is the result of forgetting a set of ground atoms with fluents having S0 as situation argument. Since c̄ is the vector of object arguments in the definition of F (c̄, Sα) in (∗), we have F (c̄, S0) ∈ Ω(S0) |j . Therefore, ifM |= εF (c̄, S0) (ε denotes the optional negation in front of atom), then there is a model M′ |= ¬εF (c̄, S0) such that M′ ∼σ M,\nwith σ = F (c̄, S0), and hence, M′ 6|= ϕ (since ∆ is fluent–free) and the truth value of F (c̄, Sα) in M and M′ is the same. Hence, either in M or M′ the truth values of F (c̄, Sα) and F (c̄, S0) coincide. The similar argument applies to the whole set of definitions (∗) from D̃j under forgetting the set Ω(S0) |j . Therefore we may assume that in M or M′, for each fluent F ∈ sig (Gj) the values of F (c̄, Sα) and F (c̄, S0) coincide. So M |= Gj(S0/Sα) or M′ |= Gj(S0/Sα) which is a contradiction, because ϕ holds in neither of these models.\nTo prove the reverse inclusion Cons (Gj , ∆) ⊆ Cons (Gj(S0/Sα), ∆), observe thatGj(S0/Sα) is uniform in S0. Hence, by an observation similar to Lemma 2.8, every model M of Gj(S0/Sα) can be expanded to a model M′, where the interpretation of function do is such that the values of terms Sα and S0 in M′ coincide. ThenM′ |= Gj and thus, there is no formula ϕ ∈ Cons (Gj , ∆) such that ϕ 6∈ Cons (Gj(S0/Sα), ∆).\nWe note that a result similar to Theorem 4.5 can be proved in a more general case, for progression of not-necessarily local-effect BAT s, by considering progression as a set of consequences of Duna ∪ Dss ∪ DS0 uniform in Sα or using the second-order definition of progression from Theorem 2.10 in [27]. Since both definitions of progression are non-constructive, one would have to deal with background theories such as Duna, when reasoning about decomposition of the initial theory. Although it would be possible to define a more general notion of decomposability wrt a background theory by following this direction, this study would take us too far away from the goals of this paper, and it would not be illuminating.\nThe proof of the theorem uses Proposition 4.2 and the component properties of forgetting from Section 3. The important observation behind this result is that in order to compute progression of an initial theory wrt an action having effects only on fluents from one decomposition component, it suffices to compute forgetting only in this component. Given a decomposition of the initial theory into inseparable components, the rest of the conditions in the theorem are purely syntactical and easy to check. For example, these conditions would naturally hold if one merges weakly-related action theories, as illustrated in the running example (continued below). SSAs can be grouped into |I| components by drawing a graph with fluent names as vertices, and an edge from the fluent on the left-hand side of each SSA going to each fluent occurring on the right-hand side of the same SSA. Similarly, it is easy to check the last condition of the Theorem that guarantees alignment of groups of axioms in SSAs with decomposition components of DS0 .\nIn the above conditions, observe that if an action A occurs in active position of SSAs from two different sub-theories of Dss, then computing progression may involve forgetting in two corresponding components of DS0 . This can potentially lead to appearance of new common∆1–symbols in the components of progression. As a consequence, ∆2–decomposability of progression may be destroyed, but it is desirable to preserve it. A practically important class of BAT s, for which this interference can be avoided, is described in the corollary below. Note the first condition in the corollary that every action mentioned in BAT can have effects on fluents only from one component of Dss. Together with the second condition this guarantees preservation of ∆2-decomposability and inseparability of the initial theory after progression. The third condition in the corollary guarantees preservation of all the conditions of Theorem 4.5 for the BAT obtained after progression and thus, one can compute progression for arbitrary long sequences of actions while preserving decomposability of DSα(S0/Sα) and inseparability of its components.\nCorollary 4.6 (Strong preservation of components in local-effect BAT s) In the conditions and notations of Theorem 4.5, let α = A(c̄) be a ground action term, where c̄ = 〈c1, . . . , ck〉 is a tuple of constants, and let the following conditions hold:\n– no action function is in∆1; – {c1, . . . , ck} ⊆ sig (D′j), for some j ∈ J , whenever A is in active position in a SSA for a fluent F ∈ sig (D′j); – it holds that∆1 ⊆ ∆2.\nThen DSα(S0/Sα) is ∆2–decomposable into ∆2–inseparable components. Moreover, all the conditions of Theorem 4.5 hold for the BAT with the initial theory DSα(S0/Sα) obtained after progression.\nProof. By the first condition, action A can be in active position of SSAs of a single subtheoryDi of Dss. Then, due to the componentwise computation of progression shown in the proof of Theorem 4.5, progression can affect the single corresponding componentD′f(i) of DS0 . The second condition of the corollary guarantees that {c1, . . . , ck} ⊆ sig (D′f(i)) and together with the third condition this yields that DSα(S0/Sα) is ∆2–decomposable into ∆2–inseparable components, just like DS0 is.\nComputing the progression of DS0 wrt α is essentially a syntactic modification of D ′ f(i) which may introduce signature symbols from context conditions of Di only into D′f(i) and into no other components of DS0 . Denote byD ′′ f(i) the theory obtained fromD ′ f(i) in this way.\nLet us verify that all the conditions of Theorem 4.5 are preserved for the BAT with the initial theory DSα(S0/Sα) obtained after progression. The first condition of the theorem holds by default. By the definition of forgetting ground atoms, one can assume that sig (D′f(i)) ⊆ sig (D ′′ f(i)). Since DSα(S0/Sα) is∆2–decomposable and, by the definition ofDSα(S0/Sα), all the components ofDS0 except D′\nf(i) remain unchanged after progression, the second and third conditions of the theorem hold. To show the last condition suppose the opposite, i.e. there is k ∈ I , for which the condition does not hold. Then k 6= i, since sig (D′\nf(i)) ⊆ sig (D ′′ f(i)), and there is a subsignature Σ ⊆\nsig (D′′ f(i)) \\ sig (D ′ f(i)) such that Σ ⊆ sig (Dk). By the definition ofD ′′ f(i), we may assume that Σ ⊆ sig (Di). As DSα(S0/Sα) is a set of formulas uniform in S0, we have do 6∈ Σ and thus, Σ ⊆ ∆1 ⊆ ∆2. Let D′j be the component of DS0 , for which the condition sig (Dk) ∩ DS0 ⊆ sig (D ′ j) holds. Since Σ ⊆ ∆2 and DS0 is ∆2–decomposable, we have Σ ⊆ sig (D ′ j) and thus D ′ j is the required component forDk, a contradiction.\nExample 2 (continuation). Note that theBAT considered in the example satisfies the conditions of the corollary with fluent-free signatures∆1=∅ and∆2={Block, S0}. The theoryDss is a union of two theories, with the intersection of signatures equal to {do}. As already noted in the example, the initial theory DS0 is ∆2–decomposable into ∆2–inseparable components. Now, consider the ground action α=move(A,B,C). By Corollary 3.10 and Proposition 4.2, in order to compute the theoryDSα(S0/Sα) (the progression ofDS0 wrt α, with the term Sα substituted with S0), it suffices to forget the ground atomsOn(A,B, S0) andClear(C, S0) in the first decomposition component of DS0 and update it with the ground atoms On(A,C, S0) and Clear(B,S0). The second component of DS0 remains unchanged. One can check that DSα(S0/Sα) is the union of the following theories:\nϕ ∧ ψ ∧ (x 6= C) → Clear(x, S0) ψ → Block(x) Block(B)∧Block(C)∧On(A,C,S0)∧ ¬On(A,B,S0) Clear(A,S0) ∧Clear(B,S0) ∧ ¬Clear(C, S0)\nand\n(Top(x, S0) ∨ Inheap(x, S0)) → ¬Block(x) ∃x Block(x),\nwhere ϕ and ψ, respectively, stand for\n(x 6= B) ∧ ¬∃y ((y 6= A ∨ x 6= B) ∧On(y, x, S0)), (x = A) ∨ ∃y ((x 6= A ∨B 6= y) ∧On(x, y, S0)).\nThe theoryDSα(S0/Sα) is∆2–decomposable by the syntactic form and there is no need to compute a decomposition again after progression. Corollary 4.6 guarantees that the obtained components are ∆2–inseparable. It is important that in this case we can compute progression for arbitrary long sequences of actions while preserving both decomposability of DSα(S0/Sα) and inseparability of its components."
    }, {
      "heading" : "5 Summary and Future Work",
      "text" : "We have considered the impact of the theory update operations, such as forgetting and progression on preserving the component properties of theories, such as decomposability and inseparability. Forgetting and progression have a “semantic nature”, since the input and the output of these transformations are related to each other by using restrictions on the classes of models. On the contrary, the decomposability and inseparability properties are defined using entailment in a particular logic. As logics (weaker than second-order) may not distinguish the needed classes of models, the conceptual “distance” between these two kinds of notions is potentially immense. This can be somewhat bridged by the choice of either an appropriate logic, or appropriate theories in the input. We have identified conditions that should be imposed on the components of input theories to match these notions more closely. Also, the Parallel Interpolation Property (PIP) was shown to be a relevant property of logics in our investigations. The results can be briefly summarized in the tables below. For brevity, we use σ to denote a signature or a ground atom.We slightly abuse notation and consider σ as a set of symbols even in the case of a ground atom implying that in the latter case σ consists of the single predicate symbol from the atom. We assume that the input of operations of forgetting and progression is a union of theories T1 and T2, with sig (T1) ∩ sig (T2) = ∆, for a signature∆.\nProperty Condition Result Reference\nPreservation of ∆–inseparability of T1 and T2 under forgetting σ\nσ ∩∆ = ∅ YES Corollary 3.10 σ ⊆ ∆ and σ is a ground atom NO Example 4 σ ⊆ ∆ and σ is a signature YES, if logic has PIP Proposition 3.7 σ ⊆ ∆ and T1, T2 are semantically inseparable YES Proposition 3.8\nDistributivity of forgetting σ over union of T1 and T2\nσ ∩∆ = ∅ YES Corollary 3.10\nσ ⊆ ∆\nNO, even if T1 and T2 are semantically inseparable Example 5\nT1 and T2 are semantically inseparable “modulo σ” YES Proposition 3.9\nProperty Condition Preservation Reference\n∆– inseparability of components of initial theory under progression\nat least one fluent is present in ∆ NO\nExample 7\n∆ is fluent-free and some components of initial theory split under progression NO Example 8\n∆ is fluent-free and components of initial theory do not split under progression YES, modulo the unique name assumption theory\nTheorem 4.4\nBAT is local–effect, ∆ is fluent-free and components of initial theory do not split under progression\nYES Theorem 4.5\n∆– decomposability and preservation of signature components of an initial theory under progression wrt action term α\nUnconditionally, in particular for local-effect BAT s and fluent-free∆’s NO Example 6\nBAT is local–effect, ∆ is fluent-free, and components of DS0 are aligned with components of Dss YES, modulo common symbols of the components of Dss and constants in term α\nTheorem 4.5\nif additionally the constants in term α are contained in a single ∆-decomposition component of DS0\nYES Corollary 4.6\nThe examples and Lemmas given in the paper demonstrate that the sufficient conditions for invariance of decomposability and inseparability wrt progression in local-effect action theories cannot be relaxed. Our research has required new understanding of progression and the related notion of forgetting wrt modularity of theories. The new results about forgetting are general and may find applicability outside of reasoning about actions. Given a decomposition of the initial theory into inseparable components, the rest of the conditions in Theorem 4.5 and Corollary 4.6 are purely syntactical and therefore are easy to check. The important practical observation behind these results is that in order to compute the progression of an initial theory wrt an action having effects only on fluents from one decomposition component, it suffices to compute forgetting only in this component. As illustrated by the running example, non-interacting dynamic systems may share only some common names or static entities, such as location. The fact that the dynamic systems share no fluents can be obscured by the way they are presented, whereas decomposition would make it explicit. We believe that our positive results are applicable to a large and general class of basic action theories. The significant contribution of the paper is in exploring the important connections between research on\nmodularity and reasoning about action. The paper starts bridging the gap between these two different research communities in knowledge representation.\nThere are several directions where future work may proceed. In this paper, we concentrate on local-effect action theories only. However, recently [7] defined a new broad class of action theories called bounded situation calculus action theories, in which actions may have non-local, but bounded effects. Moreover, for these action theories, one can find cases when progression is effectively computable [46]. Therefore, it is natural to explore when decomposability and inseparability remain invariant wrt progression in bounded action theories. Additionally, we noted that there is a realistic case of initial theories, for which the size of a progressed theory with local effects does not grow exponentially. The initial theories of this kind are known as proper+ theories [21,27]. Therefore, it is worth while to develop computationally tractable techniques for decomposition of proper+ theories."
    }, {
      "heading" : "6 Acknowledgements",
      "text" : "The first author was supported by the German Research Foundation within the Transregional Collaborative Research Centre SFB/ TRR 62 “Companion-Technology for Cognitive Technical Systems” and by Russian Ministry of Science and Education under the 5-100 Excellence Programme, and Russian Foundation for Basic Research, Project No. 15-07-03410A.\nThe authors would like to thank the Natural Sciences and Engineering Research Council of Canada and the Dept. of Computer Science of the Ryerson University for providing partial financial support."
    } ],
    "references" : [ {
      "title" : "De)composition of situation calculus theories",
      "author" : [ "Eyal Amir" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2000
    }, {
      "title" : "Projection in decomposed situation calculus",
      "author" : [ "Eyal Amir" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2002
    }, {
      "title" : "Partition-based logical reasoning for first-order and propositional theories",
      "author" : [ "Eyal Amir", "Sheila A. McIlraith" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2005
    }, {
      "title" : "A complete axiomatization for blocks world",
      "author" : [ "Stephen A. Cook", "Yongmei Liu" ],
      "venue" : "J. Log. Comput.,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2003
    }, {
      "title" : "Three uses of the Herbrand-Gentzen theorem in relating model theory and proof theory",
      "author" : [ "William Craig" ],
      "venue" : "J. Symb. Log.,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1957
    }, {
      "title" : "The road to two theorems of logic. Synthese",
      "author" : [ "William Craig" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2008
    }, {
      "title" : "Bounded situation calculus action theories and decidable verification",
      "author" : [ "Giuseppe De Giacomo", "Yves Lespérance", "Fabio Patrizi" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2012
    }, {
      "title" : "Scaling up reasoning about actions using relational database technology",
      "author" : [ "Giuseppe De Giacomo", "Toni Mancini" ],
      "venue" : null,
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2004
    }, {
      "title" : "Algorithmic issues of and-decomposition of boolean formulas",
      "author" : [ "Pavel Emelyanov", "Denis Ponomaryov" ],
      "venue" : "Programming and Computer Software,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2015
    }, {
      "title" : "Decision problems and constructive models. (in Russian) [Проблемы разрешимости и конструктивные модели",
      "author" : [ "Yu. L. Ershov" ],
      "venue" : "Nauka, Moscow,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1980
    }, {
      "title" : "The complexity of explicit definitions",
      "author" : [ "Harvey Friedman" ],
      "venue" : "Advances in Mathematics,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1976
    }, {
      "title" : "Conservative extensions in modal logics",
      "author" : [ "Silvio Ghilardi", "Carsten Lutz", "FrankWolter", "Michael Zakharyaschev" ],
      "venue" : "Proceedings of AiML-6,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2006
    }, {
      "title" : "Modular reuse of ontologies: Theory and practice",
      "author" : [ "Bernardo Cuenca Grau", "Ian Horrocks", "Yevgeny Kazakov", "Ulrike Sattler" ],
      "venue" : "J. Artif. Int. Res.,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2008
    }, {
      "title" : "Application of theorem proving to problem solving",
      "author" : [ "C. Cordell Green" ],
      "venue" : null,
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1969
    }, {
      "title" : "Modular first-order ontologies via repositories",
      "author" : [ "Michael Grüninger", "Torsten Hahmann", "Ali Hashemi", "Darren Ong", "Atalay Özgövde" ],
      "venue" : "Applied Ontology,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "A description logic based situation calculus",
      "author" : [ "Yilan Gu", "Mikhail Soutchanski" ],
      "venue" : "Ann. Math. Artif. Intell.,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2010
    }, {
      "title" : "Decomposing description logic ontologies",
      "author" : [ "Boris Konev", "Carsten Lutz", "Denis Ponomaryov", "Frank Wolter" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2010
    }, {
      "title" : "Formal properties of modularisation",
      "author" : [ "Boris Konev", "Carsten Lutz", "Dirk Walther", "FrankWolter" ],
      "venue" : "editors,Modular Ontologies,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2009
    }, {
      "title" : "Model-theoretic inseparability and modularity of description logic ontologies",
      "author" : [ "Boris Konev", "Carsten Lutz", "Dirk Walther", "Frank Wolter" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2013
    }, {
      "title" : "Parallel interpolation, splitting, and relevance in belief change",
      "author" : [ "George Kourousias", "David Makinson" ],
      "venue" : "J. Symb. Log.,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2007
    }, {
      "title" : "Evaluation-based reasoning with disjunctive information in first-order knowledge bases",
      "author" : [ "Gerhard Lakemeyer", "Hector J. Levesque" ],
      "venue" : "In Proc. of KR-02,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2002
    }, {
      "title" : "Cognitive robotics (chapter 24)",
      "author" : [ "Hector Levesque", "Gerhard Lakemeyer" ],
      "venue" : "Handbook of Knowledge Representation,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2007
    }, {
      "title" : "On strongest necessary and weakest sufficient conditions",
      "author" : [ "Fangzhen Lin" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2001
    }, {
      "title" : "Discovering state invariants",
      "author" : [ "Fangzhen Lin" ],
      "venue" : null,
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2004
    }, {
      "title" : "How to progress a database",
      "author" : [ "Fangzhen Lin", "Raymond Reiter" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1997
    }, {
      "title" : "On first-order definability and computability of progression for local-effect actions and beyond",
      "author" : [ "Yongmei Liu", "Gerhard Lakemeyer" ],
      "venue" : null,
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2009
    }, {
      "title" : "Tractable reasoning with incomplete first-order knowledge in dynamic systems with context-dependent actions",
      "author" : [ "Yongmei Liu", "Hector J. Levesque" ],
      "venue" : null,
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2005
    }, {
      "title" : "Conservative extensions in expressive description logics",
      "author" : [ "Carsten Lutz", "Dirk Walther", "Frank Wolter" ],
      "venue" : "In In Proc. of IJCAI-2007,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2007
    }, {
      "title" : "Conservative extensions in expressive description logics",
      "author" : [ "Carsten Lutz", "Dirk Walther", "Frank Wolter" ],
      "venue" : null,
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2007
    }, {
      "title" : "Mathematical logic for life science",
      "author" : [ "Carsten Lutz", "Frank Wolter" ],
      "venue" : "editors, WoLLIC,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2009
    }, {
      "title" : "Deciding inseparability and conservative extensions in the description logic EL",
      "author" : [ "Carsten Lutz", "Frank Wolter" ],
      "venue" : "J. Symb. Comput.,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2010
    }, {
      "title" : "Situations, actions and causal laws",
      "author" : [ "John McCarthy" ],
      "venue" : "Memo 2, Stanford University, Department of Computer Science,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 1963
    }, {
      "title" : "Some philosophical problems from the standpoint of artificial intelligence",
      "author" : [ "John McCarthy", "Patrick Hayes" ],
      "venue" : "Machine Intelligence,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 1990
    }, {
      "title" : "On decidability of the decomposability problem for finite theories",
      "author" : [ "Andrey Morozov", "Denis Ponomaryov" ],
      "venue" : "Siberian Mathematical Journal,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2010
    }, {
      "title" : "Complexity of craig’s interpolation",
      "author" : [ "Daniele Mundici" ],
      "venue" : "Fundamenta Informaticae,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 1982
    }, {
      "title" : "Some contributions to the metatheory of the situation calculus",
      "author" : [ "Fiora Pirri", "Ray Reiter" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 1999
    }, {
      "title" : "On decomposibility in logical calculi",
      "author" : [ "Denis Ponomaryov" ],
      "venue" : "Bulletin of the Novosibirsk Computing Center,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2008
    }, {
      "title" : "The algorithmic complexity of decomposability in fragments of first-order logic. Manuscript",
      "author" : [ "Denis Ponomaryov" ],
      "venue" : "Abstract to appear in the Bulletin of Symbolic Logic. http://persons.iis.nsk.su/files/persons/pages/sigdecomp.pdf,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2014
    }, {
      "title" : "Progression of decomposed situation calculus theories",
      "author" : [ "Denis Ponomaryov", "Mikhail Soutchanski" ],
      "venue" : null,
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2013
    }, {
      "title" : "Concept definability and interpolation in enriched models of eltboxes",
      "author" : [ "Denis Ponomaryov", "Dmitry Vlasov" ],
      "venue" : "Description Logics,",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 2013
    }, {
      "title" : "Proving properties of states in the situation calculus",
      "author" : [ "Raymond Reiter" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 1993
    }, {
      "title" : "Knowledge in Action: Logical Foundations for Describing and Implementing Dynamical Systems",
      "author" : [ "Raymond Reiter" ],
      "venue" : null,
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 2001
    }, {
      "title" : "Beth definability in expressive description logics",
      "author" : [ "Balder ten Cate", "Enrico Franconi", "Inanç Seylan" ],
      "venue" : "J. Artif. Intell. Res. (JAIR),",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2013
    }, {
      "title" : "On the progression of situation calculus basic action theories: Resolving a 10-year-old conjecture",
      "author" : [ "Stavros Vassos", "Hector J. Levesque" ],
      "venue" : null,
      "citeRegEx" : "45",
      "shortCiteRegEx" : "45",
      "year" : 2008
    }, {
      "title" : "A classification of first-order progressable action theories in situation calculus",
      "author" : [ "Stavros Vassos", "Fabio Patrizi" ],
      "venue" : null,
      "citeRegEx" : "46",
      "shortCiteRegEx" : "46",
      "year" : 2013
    }, {
      "title" : "The modular structure of an ontology: Atomic decomposition",
      "author" : [ "Chiara Del Vescovo", "Bijan Parsia", "Ulrike Sattler", "Thomas Schneider" ],
      "venue" : "Proceedings of the 22nd International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "47",
      "shortCiteRegEx" : "47",
      "year" : 2011
    }, {
      "title" : "Experimental results on solving the projection problem in action formalisms based on description logics",
      "author" : [ "Wael Yehia", "Hongkai Liu", "Marcel Lippmann", "Franz Baader", "Mikhail Soutchanski" ],
      "venue" : "Description Logics,",
      "citeRegEx" : "48",
      "shortCiteRegEx" : "48",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 12,
      "context" : "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.",
      "startOffset" : 232,
      "endOffset" : 251
    }, {
      "referenceID" : 14,
      "context" : "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.",
      "startOffset" : 232,
      "endOffset" : 251
    }, {
      "referenceID" : 16,
      "context" : "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.",
      "startOffset" : 232,
      "endOffset" : 251
    }, {
      "referenceID" : 17,
      "context" : "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.",
      "startOffset" : 232,
      "endOffset" : 251
    }, {
      "referenceID" : 36,
      "context" : "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.",
      "startOffset" : 232,
      "endOffset" : 251
    }, {
      "referenceID" : 45,
      "context" : "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.",
      "startOffset" : 232,
      "endOffset" : 251
    }, {
      "referenceID" : 0,
      "context" : "To the best of our knowledge, the only previous work that explored decomposition of logical theories for the purposes of solving the projection problem are the papers [1,2].",
      "startOffset" : 167,
      "endOffset" : 172
    }, {
      "referenceID" : 1,
      "context" : "To the best of our knowledge, the only previous work that explored decomposition of logical theories for the purposes of solving the projection problem are the papers [1,2].",
      "startOffset" : 167,
      "endOffset" : 172
    }, {
      "referenceID" : 32,
      "context" : "[34,43], a well-known logical formalism for representation of actions and their effects.",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 41,
      "context" : "[34,43], a well-known logical formalism for representation of actions and their effects.",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 0,
      "context" : "We take a different approach in our paper: instead of decomposing the whole action theory into subsets, as in [1,2], we consider signature decompositions of an initial theory only.",
      "startOffset" : 110,
      "endOffset" : 115
    }, {
      "referenceID" : 1,
      "context" : "We take a different approach in our paper: instead of decomposing the whole action theory into subsets, as in [1,2], we consider signature decompositions of an initial theory only.",
      "startOffset" : 110,
      "endOffset" : 115
    }, {
      "referenceID" : 16,
      "context" : "These properties are well known in research on modularization in the area of knowledge representation [17,38,18,32], but have not been studied previously in the scope of the situation calculus.",
      "startOffset" : 102,
      "endOffset" : 115
    }, {
      "referenceID" : 36,
      "context" : "These properties are well known in research on modularization in the area of knowledge representation [17,38,18,32], but have not been studied previously in the scope of the situation calculus.",
      "startOffset" : 102,
      "endOffset" : 115
    }, {
      "referenceID" : 17,
      "context" : "These properties are well known in research on modularization in the area of knowledge representation [17,38,18,32], but have not been studied previously in the scope of the situation calculus.",
      "startOffset" : 102,
      "endOffset" : 115
    }, {
      "referenceID" : 30,
      "context" : "These properties are well known in research on modularization in the area of knowledge representation [17,38,18,32], but have not been studied previously in the scope of the situation calculus.",
      "startOffset" : 102,
      "endOffset" : 115
    }, {
      "referenceID" : 41,
      "context" : "The situation calculus [43] is a knowledge representation logical formalism, which has been designed for axiomatization of problems in planning and high-level program execution.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 41,
      "context" : "In the situation calculus, the so-called basic action theories represent such axiomatizations [43].",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 41,
      "context" : "In a special case, when there is complete knowledge about a finite number of individuals having unique names, the initial theory can be implemented as a relational database [43,8].",
      "startOffset" : 173,
      "endOffset" : 179
    }, {
      "referenceID" : 7,
      "context" : "In a special case, when there is complete knowledge about a finite number of individuals having unique names, the initial theory can be implemented as a relational database [43,8].",
      "startOffset" : 173,
      "endOffset" : 179
    }, {
      "referenceID" : 31,
      "context" : "Having been developed in the 1960s by John McCarthy and his colleagues [33,34,14], it is one of the most popular logical frameworks for reasoning about actions; it is presented in most well-known textbooks on AI.",
      "startOffset" : 71,
      "endOffset" : 81
    }, {
      "referenceID" : 32,
      "context" : "Having been developed in the 1960s by John McCarthy and his colleagues [33,34,14], it is one of the most popular logical frameworks for reasoning about actions; it is presented in most well-known textbooks on AI.",
      "startOffset" : 71,
      "endOffset" : 81
    }, {
      "referenceID" : 13,
      "context" : "Having been developed in the 1960s by John McCarthy and his colleagues [33,34,14], it is one of the most popular logical frameworks for reasoning about actions; it is presented in most well-known textbooks on AI.",
      "startOffset" : 71,
      "endOffset" : 81
    }, {
      "referenceID" : 21,
      "context" : "For this reason, the situation calculus is chosen as foundation for high-level programming languages in cognitive robotics [22].",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 41,
      "context" : "Reiter [43] who developed a general approach to axiomatizing direct effects and non-effects of actions.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 38,
      "context" : "A preliminary shorter version of this paper (without proofs) appeared in the proceedings of AAAI-13 conference [40].",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 2,
      "context" : "Thereafter, reasoning wrt the initial theory can be reduced to reasoning within the obtained components via a message passing algorithm, which communicates between the partitions to find information needed to answer a query [3].",
      "startOffset" : 224,
      "endOffset" : 227
    }, {
      "referenceID" : 36,
      "context" : "In our paper, we adopt the following notion that was introduced in [38] and applied to the study of modularity in [17].",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 16,
      "context" : "In our paper, we adopt the following notion that was introduced in [38] and applied to the study of modularity in [17].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 37,
      "context" : ", [39,9,17,35,38]) shows that deciding whether a theory is ∆-decomposable turns out to be not harder than deciding the entailment in the underlying logic.",
      "startOffset" : 2,
      "endOffset" : 17
    }, {
      "referenceID" : 8,
      "context" : ", [39,9,17,35,38]) shows that deciding whether a theory is ∆-decomposable turns out to be not harder than deciding the entailment in the underlying logic.",
      "startOffset" : 2,
      "endOffset" : 17
    }, {
      "referenceID" : 16,
      "context" : ", [39,9,17,35,38]) shows that deciding whether a theory is ∆-decomposable turns out to be not harder than deciding the entailment in the underlying logic.",
      "startOffset" : 2,
      "endOffset" : 17
    }, {
      "referenceID" : 33,
      "context" : ", [39,9,17,35,38]) shows that deciding whether a theory is ∆-decomposable turns out to be not harder than deciding the entailment in the underlying logic.",
      "startOffset" : 2,
      "endOffset" : 17
    }, {
      "referenceID" : 36,
      "context" : ", [39,9,17,35,38]) shows that deciding whether a theory is ∆-decomposable turns out to be not harder than deciding the entailment in the underlying logic.",
      "startOffset" : 2,
      "endOffset" : 17
    }, {
      "referenceID" : 36,
      "context" : ", from a procedure of computing uniform interpolants (if the logic enjoys efficient uniform interpolation, see Proposition 2 in [38] and [35]), or by applying the technique of eliminating non-∆-symbols from the axioms of a theory.",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 33,
      "context" : ", from a procedure of computing uniform interpolants (if the logic enjoys efficient uniform interpolation, see Proposition 2 in [38] and [35]), or by applying the technique of eliminating non-∆-symbols from the axioms of a theory.",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 16,
      "context" : "The technique is described in [17] for the logics EL and DL-Lite, which is further studied in [41] and can be extended to more expressive Description Logics.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 39,
      "context" : "The technique is described in [17] for the logics EL and DL-Lite, which is further studied in [41] and can be extended to more expressive Description Logics.",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 16,
      "context" : "For instance, a decomposition component may be of size exponentially larger than the original theory, which is evidenced by Example 28 in [17].",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 10,
      "context" : "It is known that in general there is no upper bound on the complexity of explicit definitions in first-order logic [11,36] and computing them is usually harder than entailment in FOL fragments (see e.",
      "startOffset" : 115,
      "endOffset" : 122
    }, {
      "referenceID" : 34,
      "context" : "It is known that in general there is no upper bound on the complexity of explicit definitions in first-order logic [11,36] and computing them is usually harder than entailment in FOL fragments (see e.",
      "startOffset" : 115,
      "endOffset" : 122
    }, {
      "referenceID" : 42,
      "context" : "[44]).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "Using Example 28 from [17], for instance, it possible to describe a situation when tuning up ∆ can exponentially reduce the component sizes.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 9,
      "context" : "see [10]) that every sentence in signature {P} is equivalent to a boolean combination of formulas ∃P and ∃¬P , where an integerm > 0, which mean “P (respectively, ¬P ) holds on at least m distinct elements”.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 29,
      "context" : "2 in [31]).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 17,
      "context" : ", see [18,32].",
      "startOffset" : 6,
      "endOffset" : 13
    }, {
      "referenceID" : 30,
      "context" : ", see [18,32].",
      "startOffset" : 6,
      "endOffset" : 13
    }, {
      "referenceID" : 36,
      "context" : "Proposition 2 in [38]).",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 17,
      "context" : "In contrast to decomposability, deciding ∆-inseparability of theories is usually harder, than deciding entailment in the logic in which the theories are formulated, as proved by the results in [18], [32], and the results on the complexity of deciding conservative extensions [29,12].",
      "startOffset" : 193,
      "endOffset" : 197
    }, {
      "referenceID" : 30,
      "context" : "In contrast to decomposability, deciding ∆-inseparability of theories is usually harder, than deciding entailment in the logic in which the theories are formulated, as proved by the results in [18], [32], and the results on the complexity of deciding conservative extensions [29,12].",
      "startOffset" : 199,
      "endOffset" : 203
    }, {
      "referenceID" : 27,
      "context" : "In contrast to decomposability, deciding ∆-inseparability of theories is usually harder, than deciding entailment in the logic in which the theories are formulated, as proved by the results in [18], [32], and the results on the complexity of deciding conservative extensions [29,12].",
      "startOffset" : 275,
      "endOffset" : 282
    }, {
      "referenceID" : 11,
      "context" : "In contrast to decomposability, deciding ∆-inseparability of theories is usually harder, than deciding entailment in the logic in which the theories are formulated, as proved by the results in [18], [32], and the results on the complexity of deciding conservative extensions [29,12].",
      "startOffset" : 275,
      "endOffset" : 282
    }, {
      "referenceID" : 20,
      "context" : "A practically important generalization of theories consisting of ground atoms is proper theories [21,27].",
      "startOffset" : 97,
      "endOffset" : 104
    }, {
      "referenceID" : 25,
      "context" : "A practically important generalization of theories consisting of ground atoms is proper theories [21,27].",
      "startOffset" : 97,
      "endOffset" : 104
    }, {
      "referenceID" : 19,
      "context" : "The well-known property of logics related to signature decompositions of theories is the Parallel Interpolation Property (PIP) first considered in a special form in [20] and studied later in a more general form in [17].",
      "startOffset" : 165,
      "endOffset" : 169
    }, {
      "referenceID" : 16,
      "context" : "The well-known property of logics related to signature decompositions of theories is the Parallel Interpolation Property (PIP) first considered in a special form in [20] and studied later in a more general form in [17].",
      "startOffset" : 214,
      "endOffset" : 218
    }, {
      "referenceID" : 4,
      "context" : "Note that PIP is closely related to Craig’s interpolation [5,6].",
      "startOffset" : 58,
      "endOffset" : 63
    }, {
      "referenceID" : 5,
      "context" : "Note that PIP is closely related to Craig’s interpolation [5,6].",
      "startOffset" : 58,
      "endOffset" : 63
    }, {
      "referenceID" : 36,
      "context" : "In fact, PIP can be understood as an iterated version of Craig’s interpolation in the logics that have compactness and deduction theorem (see Lemma 1 in [38]).",
      "startOffset" : 153,
      "endOffset" : 157
    }, {
      "referenceID" : 0,
      "context" : "As shown in [1,2,3], a decomposition of a theory can be beneficial even without inseparability thanks to applying the known methods of distributed reasoning via message passing between components.",
      "startOffset" : 12,
      "endOffset" : 19
    }, {
      "referenceID" : 1,
      "context" : "As shown in [1,2,3], a decomposition of a theory can be beneficial even without inseparability thanks to applying the known methods of distributed reasoning via message passing between components.",
      "startOffset" : 12,
      "endOffset" : 19
    }, {
      "referenceID" : 2,
      "context" : "As shown in [1,2,3], a decomposition of a theory can be beneficial even without inseparability thanks to applying the known methods of distributed reasoning via message passing between components.",
      "startOffset" : 12,
      "endOffset" : 19
    }, {
      "referenceID" : 40,
      "context" : "In every basic action theory D over a signature σ ⊆ Asc, the set of foundational axioms Σ consists of the following formulas [42] (note the axiom schema for induction):",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 40,
      "context" : "Reiter observed in [42] that foundational axioms Σ generalize a single successor function over natural numbers to the case of multiple successors over situations.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 35,
      "context" : "To define the remaining subtheories of BAT , we need to introduce the following syntactic notion (taken from [37,43]).",
      "startOffset" : 109,
      "endOffset" : 116
    }, {
      "referenceID" : 41,
      "context" : "To define the remaining subtheories of BAT , we need to introduce the following syntactic notion (taken from [37,43]).",
      "startOffset" : 109,
      "endOffset" : 116
    }, {
      "referenceID" : 15,
      "context" : "In particular,DS0 can include both an ABox and a TBox in an appropriateDescription Logic, as argued in [16,48].",
      "startOffset" : 103,
      "endOffset" : 110
    }, {
      "referenceID" : 46,
      "context" : "In particular,DS0 can include both an ABox and a TBox in an appropriateDescription Logic, as argued in [16,48].",
      "startOffset" : 103,
      "endOffset" : 110
    }, {
      "referenceID" : 41,
      "context" : "6 in [43]), we require that if an action function f occurs in active position in some SSA for a fluent F , then f is not in active position in either γ F , or γ − F .",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 41,
      "context" : "Reiter defines the notion of SSA for functional fluents [43].",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 35,
      "context" : "10 (Theorem 1 in [37]) A basic action theory Σ ∪ Duna ∪ DS0 ∪ Dap ∪ Dss is satisfiable iffDuna ∪DS0 is satisfiable.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 41,
      "context" : "Regression is a central computational mechanism that forms the basis for an automated solution to the executability and projection tasks in the situation calculus ([43]).",
      "startOffset" : 164,
      "endOffset" : 168
    }, {
      "referenceID" : 15,
      "context" : "It is easy to see that regression becomes computationally intractable if the sequence of actions grows indefinitely [16].",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 25,
      "context" : "Local-effect BAT s are a well-known3 class of theories, for which the operation of progression (Section 4) can be computed effectively [27], without regard to decidability of the underlying theory DS0 .",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 3,
      "context" : "A complete axiomatization of BW modelled as a finite collection of finite chains can be found in [4].",
      "startOffset" : 97,
      "endOffset" : 100
    }, {
      "referenceID" : 26,
      "context" : "3 The phrase local-effect actions first appeared in [28], but it was motivated by actions with simple effects",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 23,
      "context" : "defined in the paper [24], where simple effects are understood similar to the Def.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 25,
      "context" : "1 in [27]).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 17,
      "context" : "For the case when σ is a signature, forget (T , σ) is known as sig (T ) \\ σ–uniform interpolant of T wrt the language L and second-order queries, that is, wrt the pair (L, second-order logic), see Definition 13 in [18] and Lemma 39 in [32] for a justification.",
      "startOffset" : 214,
      "endOffset" : 218
    }, {
      "referenceID" : 30,
      "context" : "For the case when σ is a signature, forget (T , σ) is known as sig (T ) \\ σ–uniform interpolant of T wrt the language L and second-order queries, that is, wrt the pair (L, second-order logic), see Definition 13 in [18] and Lemma 39 in [32] for a justification.",
      "startOffset" : 235,
      "endOffset" : 239
    }, {
      "referenceID" : 17,
      "context" : "Specialists might notice that (*) is equivalent to semantic ∆–inseparability of the initial sets of formulas (see Definition 11 in [18]) which is very hard to decide from the computational point of view (see Theorem 3 in [30], Lemma 40 in [32]).",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 28,
      "context" : "Specialists might notice that (*) is equivalent to semantic ∆–inseparability of the initial sets of formulas (see Definition 11 in [18]) which is very hard to decide from the computational point of view (see Theorem 3 in [30], Lemma 40 in [32]).",
      "startOffset" : 221,
      "endOffset" : 225
    }, {
      "referenceID" : 30,
      "context" : "Specialists might notice that (*) is equivalent to semantic ∆–inseparability of the initial sets of formulas (see Definition 11 in [18]) which is very hard to decide from the computational point of view (see Theorem 3 in [30], Lemma 40 in [32]).",
      "startOffset" : 239,
      "endOffset" : 243
    }, {
      "referenceID" : 18,
      "context" : "Nevertheless, there are practically useful restrictions under which the complexity becomes feasible [19].",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 25,
      "context" : "We will consider local-effect SSAs discussed in [27] and deltas, which do not contain fluents.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 41,
      "context" : "1 in [43]) LetD be a basic action theory with",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 24,
      "context" : "It can be seen (Theorem 2 in [26] and Theorem 2.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 25,
      "context" : "10 in [27]) that progression always exists, i.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 43,
      "context" : "On the other hand, by the definition, for any BAT D, we have D |= DSα and, similarly to the operation of forgetting, it is possible to provide an example (see Definition 2, Conjecture 1, and Theorem 2 in [45]), when the progression DSα is not definable (even by an infinite set of formulas) in the logic in which D is formulated.",
      "startOffset" : 204,
      "endOffset" : 208
    }, {
      "referenceID" : 25,
      "context" : "An interested reader may consult the whole paper [27], while here we only introduce necessary notations from Definition 3.",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 25,
      "context" : "4 of [27], which will be used in Theorem 4.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 25,
      "context" : "6 in [27]) In the notations above, the following is a progression of",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 25,
      "context" : "6 in [27], due to the possible exponential blow-up after forgetting a set of ground atoms.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 22,
      "context" : "This is not a surprise, because even in propositional logic, forgetting a symbol in a formula is essentially the elimination of a “middle term\" (introduced by Boole), which results in the disjunction of two instances of the input formula [23].",
      "startOffset" : 238,
      "endOffset" : 242
    }, {
      "referenceID" : 25,
      "context" : "As shown in [27], there are practical classes of the initial theories for which there is no blow-up and the size of the progressed theory is actually linear wrt the size of the initial theory.",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 25,
      "context" : "10 in [27].",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 6,
      "context" : "However, recently [7] defined a new broad class of action theories called bounded situation calculus action theories, in which actions may have non-local, but bounded effects.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 44,
      "context" : "Moreover, for these action theories, one can find cases when progression is effectively computable [46].",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 20,
      "context" : "The initial theories of this kind are known as proper theories [21,27].",
      "startOffset" : 63,
      "endOffset" : 70
    }, {
      "referenceID" : 25,
      "context" : "The initial theories of this kind are known as proper theories [21,27].",
      "startOffset" : 63,
      "endOffset" : 70
    } ],
    "year" : 2017,
    "abstractText" : "In many tasks related to reasoning about consequences of a logical theory, it is desirable to decompose the theory into a number of weakly-related or independent components. However, a theory may represent knowledge that is subject to change, as a result of executing actions that have effects on some of the initial properties mentioned in the theory. Having once computed a decomposition of a theory, it is advantageous to know whether a decomposition has to be computed again in the newly-changed theory (obtained from taking into account changes resulting from execution of an action). In the paper, we address this problem in the scope of the situation calculus, where a change of an initial theory is related to the notion of progression. Progression provides a form of forward reasoning; it relies on forgetting values of those properties, which are subject to change, and computing new values for them. We consider decomposability and inseparability, two component properties known from the literature, and contribute by 1) studying the conditions when these properties are preserved and 2) when they are lost wrt progression and the related operation of forgetting. To show the latter, we demonstrate the boundaries using a number of negative examples. To show the former, we identify cases when these properties are preserved under forgetting and progression of initial theories in local-effect basic action theories of the situation calculus. Our paper contributes to bridging two different communities in Knowledge Representation, namely research on modularity and research on reasoning about actions.",
    "creator" : "dvips(k) 5.996 Copyright 2016 Radical Eye Software"
  }
}