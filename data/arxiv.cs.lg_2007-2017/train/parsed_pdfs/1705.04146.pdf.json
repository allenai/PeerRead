{
  "name" : "1705.04146.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Program Induction by Rationale Generation: Learning to Solve and Explain Algebraic Word Problems",
    "authors" : [ "Wang Ling", "Dani Yogatama", "Chris Dyer", "Phil Blunsom" ],
    "emails" : [ "lingwang@google.com", "dyogatama@google.com", "cdyer@google.com", "pblunsom@google.com" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Behaving intelligently often requires mathematical reasoning. Shopkeepers calculate change, tax, and sale prices; agriculturists calculate the proper amounts of fertilizers, pesticides, and water for their crops; and managers analyze productivity. Even determining whether you have enough money to pay for a list of items requires applying addition, multiplication, and comparison. Solving these tasks is challenging as it involves recognizing how goals, entities, and quantities in the real-world map onto a mathematical formalization, computing the solution, and mapping the solution back onto the world. As a proxy for the richness of the real world, a series of papers have\nused natural language specifications of algebraic word problems, and solved these by either learning to fill in templates that can be solved with equation solvers (Hosseini et al., 2014; Kushman et al., 2014) or inferring and modeling operation sequences (programs) that lead to the final answer (Roy and Roth, 2015).\nIn this paper, we learn to solve algebraic word problems by inducing and modeling programs that generate not only the answer, but an answer rationale, a natural language explanation interspersed with algebraic expressions justifying the overall solution. Such rationales are what examiners require from students in order to demonstrate understanding of the problem solution; they play the very same role in our task. Not only do natural language rationales enhance model interpretability, but they provide a coarse guide to the structure of the arithmetic programs that must be executed. In fact the learner we propose (which relies on a heuristic search; §4) fails to solve this task without modeling the rationales—the search space is too unconstrained.\nThis work is thus related to models that can explain or rationalize their decisions (Hendricks et al., 2016; Harrison et al., 2017). However, the use of rationales in this work is quite different from the role they play in most prior work, where interpretation models are trained to generate plausible sounding (but not necessarily accurate) posthoc descriptions of the decision making process they used. In this work, the rationale is generated as a latent variable that gives rise to the answer—it is thus a more faithful representation of the steps used in computing the answer.\nThis paper makes three contributions. First, we have created a new dataset with more than 100,000 algebraic word problems that includes both answers and natural language answer rationales (§2). Figure 1 illustrates three representative instances\nar X\niv :1\n70 5.\n04 14\n6v 1\n[ cs\n.A I]\n1 1\nM ay\n2 01\n7\nfrom the dataset. Second, we propose a sequence to sequence model that generates a sequence of instructions that, when executed, generates the rationale; only after this is the answer chosen (§3). Since the target program is not given in the training data (most obviously, its specific form will depend on the operations that are supported by the program interpreter); the third contribution is thus a technique for inferring programs that generate a rationale and, ultimately, the answer. Even constrained by a text rationale, the search space of possible programs is quite large, and we employ a heuristic search to find plausible next steps to guide the search for programs (§4). Empirically, we are able to show that state-of-the-art sequence to sequence models are unable to perform above chance on this task, but that our model doubles the accuracy of the baseline (§6)."
    }, {
      "heading" : "2 Dataset",
      "text" : "We built a dataset with 100,000 problems with the annotations shown in Figure 1. Each question is decomposed in four parts, two inputs and two outputs: the description of the problem, which we will denote as the question, and the possible (multiple choice) answer options, denoted as options. Our goal is to generate the description of the rationale used to reach the correct answer, denoted as rationale and the correct option label. Problem 1 illustrates an example of an algebra problem, which must be translated into an expression (i.e., (27x + 17y)/(x + y) = 23) and then the desired quantity (x/y) solved for. Problem 2 is an example that could be solved by multi-step arithmetic operations proposed in (Roy and Roth, 2015). Finally, Problem 3 describes a problem that is solved by testing each of the options, which has not been addressed in the past."
    }, {
      "heading" : "2.1 Construction",
      "text" : "We first collect a set of 34,202 seed problems that consist of multiple option math questions covering a broad range of topics and difficulty levels. Examples of exams with such problems include the GMAT (Graduate Management Admission Test) and GRE (General Test). Many websites contain example math questions in such exams, where the answer is supported by a rationale.\nNext, we turned to crowdsourcing to generate new questions. We create a task where users are presented with a set of 5 questions from our seed dataset. Then, we ask the Turker to choose one of the questions and write a similar question. We also force the answers and rationale to differ from the original question in order to avoid paraphrases of the original question. Once again, we manually check a subset of the jobs for each Turker for quality control. The type of questions generated using this method vary. Some turkers propose small changes in the values of the questions (e.g., changing the equality p(a)p(b) = p(ab) in Problem 3 to a different equality is a valid question, as long as the rationale and options are rewritten to reflect the change). We designate these as replica problems as the natural language used in the question and rationales tend to be only minimally unaltered. Others propose new problems in the same topic where the generated questions tend to differ more radically from existing ones. Some Turkers also copy math problems available on the web, and we\ndefine in the instructions that this is not allowed, as it will generate multiple copies of the same problem in the dataset if two or more Turkers copy from the same resource. These Turkers can be detected by checking the nearest neighbours within the collected datasets as problems obtained from online resources are frequently submitted by more than one Turker. Using this method, we obtained 70,318 additional questions."
    }, {
      "heading" : "2.2 Statistics",
      "text" : "Descriptive statistics of the dataset is shown in Figure 1. In total, we collected 104,519 problems (34,202 seed problems and 70,318 crowdsourced problems). We removed 500 problems as heldout set (250 for development and 250 for testing). As replicas of the heldout problems may be present in the training set, these were removed manually by listing for each heldout instance the closest problems in the training set in terms of character-based Levenstein distance. After filtering, 100,949 problems remained in the training set.\nWe also show the average number of tokens (total number of tokens in the question, options and rationale) and the vocabulary size of the questions and rationales. Finally, we provide the same statistics exclusively for tokens that are numeric values and tokens that are not.\nFigure 2 shows the distribution of examples based on the total number of tokens. We can see that most examples consist of 30 to 500 tokens, but there are also extremely long examples with more than 1000 tokens in our dataset."
    }, {
      "heading" : "3 Model",
      "text" : "Generating rationales for math problems is challenging as it requires models that learn to perform math operations at a finer granularity as each step within the solution must be explained. For instance, in Problem 1, the equation (27x +\n17y)/(x + y) = 23 must be solved to obtain the answer. In previous work (Kushman et al., 2014), this could be done by feeding the equation into an expression solver to obtain x/y = 3/2. However, this would skip the intermediate steps 27x+17y = 23x+23y and 4x = 6y, which must also be generated in our problem. We propose a model that jointly learns to generate the text in the rationale, and to perform the math operations required to solve the problem. This is done by generating a program, containing both instructions that generate output and instructions that simply generate intermediate values used by following instructions."
    }, {
      "heading" : "3.1 Problem Definition",
      "text" : "In traditional sequence to sequence models (Sutskever et al., 2014; Bahdanau et al., 2014), the goal is to predict the output sequence y = y1, . . . , y|y| from the input sequence x = x1, . . . , x|x|, with lengths |y| and |x|.\nIn our particular problem, we are given the problem and the set of options, and wish to predict the rationale and the correct option. We set x as the sequence of words in the problem, concatenated with words in each of the options separated by a special tag. Note that knowledge about the possible options is required as some problems are solved by the process of elimination or by testing each of the options (e.g. Problem 3). We wish to generate y, which is the sequence of words in the rationale. We also append the correct option as the last word in y, which is interpreted as the chosen option. For example, y in Problem 1 is “Let the . . . = 3/2 . 〈EOR〉 B 〈EOS〉”, whereas in Problem 2 it is “Let s be . . . Answer is C 〈EOR〉 C 〈EOS〉”, where “〈EOS〉” is the end of sentence symbol and “〈EOR〉” is the end of rationale symbol."
    }, {
      "heading" : "3.2 Generating Programs to Generate Rationales",
      "text" : "We wish to generate a latent sequence of program instructions, z = z1, . . . , z|z|, with length |z|, that will generate y when executed.\nWe express z as a program that can access x, y, and the memory buffer m. Upon finishing execution we expect that the sequence of output tokens to be placed in the output vector y.\nTable 2 illustrates an example of a sequence of instructions that would generate an excerpt from Problem 2, where columns x, z, v, and r denote the input sequence, the instruction sequence (program), the values of executing the instruction, and where each value vi is written (i.e., either to the output or to the memory). In this example, instructions from indexes 1 to 14 simply fill each position with the observed output y1, . . . , y14 with a string, where the Id operation simply returns its parame-\nter without applying any operation. As such, running this operation is analogous to generating a word by sampling from a softmax over a vocabulary. However, instruction z15 reads the input word x5, 52, and applies the operation Str to Float, which converts the word 52 into a floating point number, and the same is done for instruction z20, which reads a previously generated output word y17. Unlike, instructions z1, . . . , z14, these operations write to the external memory m, which stores intermediate values. A more sophisticated instruction—which shows some of the power of our model—is z21 = Choose(m1,m2) → m3 which evaluates ( m1 m2 ) and stores the result in m3. This process repeats until the model generates the end-of-sentence symbol. The last token of the program as said previously must generate the correct option value, from “A” to “E”.\nBy training a model to generate instructions that can manipulate existing tokens, the model benefits from the additional expressiveness needed to solve math problems within the generation process. In total we define 22 different operations, 13 of which are frequently used operations when solving math problems. These are: Id, Add, Subtract, Multiply, Divide, Power, Log, Sqrt, Sine, Cosine, Tangent, Factorial, and Choose (number of combinations). We also provide 2 operations to convert between Radians and Degrees, as these are needed for the sine, cosine and tangent operations. There are 6 operations that convert floating point numbers into strings and vice-versa. These include the Str to Float and Float to Str operations described previously, as well as operations which convert between floating point numbers and fractions, since in many math problems the answers are in the form “3/4”. For the same reason, an operation to convert between a floating point number and number grouped in thousands is also used (e.g. 1000000 to “1,000,000” or “1.000.000”). Finally, we define an operation (Check) that given the input string, searches through the list of options and returns a string with the option index in {“A”, “B”, “C”, “D”, “E”}. If the input value does not match any of the options, or more than one option contains that value, it cannot be applied. For instance, in Problem 2, once the correct probability “1/221” is generated, by applying the check operation to this number we can obtain correct option “C”."
    }, {
      "heading" : "3.3 Generating and Executing Instructions",
      "text" : "In our model, programs consist of sequences of instructions, z. We turn now to how we model each zi, conditional on the text program specification, and the program’s history. The instruction zi is a tuple consisting of an operation (oi), an ordered sequence of its arguments (ai), and a decision about where its results will be placed (ri) (is it appended in the output y or in a memory buffer m?), and the result of applying the operation to its arguments (vi). That is, zi = (oi, ri,ai, vi).\nFormally, oi is an element of the pre-specified set of operations O, which contains, for example add, div, Str to Float, etc. The number of arguments required by oi is given by argc(oi), e.g., argc(add) = 2 and argc(log) = 1. The arguments are ai = ai,1, . . . , ai,argc(oi). An instruction will generate a return value vi upon execution, which will either be placed in the output y or hidden. This decision is controlled by ri. We define the instruction probability as:\np(oi,ai, ri,vi | z<i,x,y,m) = p(oi | z<i,x)× p(ri | z<i,x, oi)×\nargc(oi)∏ j=1 p(ai,j | z<i,x, oi,m,y)×\n[vi = apply(oi,a)],\nwhere [p] evaluates to 1 if p is true and 0 otherwise, and apply(f,x) evaluates the operation f with arguments x. Note that the apply function is not learned, but pre-defined.\nThe network used to generate an instruction at a given timestamp i is illustrated in Figure 3. We first use the recurrent state hi to generate p(oi | z<i,x) = softmax\noi∈O (hi), using a softmax over the\nset of available operations O. In order to predict ri, we generate a new hidden state ri, which is a function of the current program context hi, and an embedding of the current predicted operation, oi. As the output can either be placed in the memory m or the output y, we compute the probability p(ri = OUTPUT | z<i,x, oi) = σ(ri · wr + br), where σ is the logistic sigmoid function. If ri = OUTPUT, vi is appended to the output y; otherwise it is appended to the memory m.\nOnce we generate ri, we must predict ai, the argc(oi)-length sequence of arguments that operation oi requires. The jth argument ai,j can be either generated from a softmax over the vocabulary, copied from the input vector x, or copied from previously generated values in the output y or memory m. This decision is modeled using a latent predictor network (Ling et al., 2016), where the control over which method used to generate ai,j is governed by a latent variable qi,j ∈ {SOFTMAX, COPY-INPUT, COPY-OUTPUT}. Similar to when predicting ri, in order to make this choice, we also generate a new hidden state for each argument slot j, denoted by qi,j with an LSTM, feeding the previous argument in at each time step, and initializing it with ri and by reading the predicted value of the output ri.\n• If qi,j = SOFTMAX, ai,j is generated by sampling from a softmax over the vocabulary Y ,\np(ai,j | qi,j = SOFTMAX) = softmax ai,j∈Y (qi,j).\nThis corresponds to a case where a string is used as argument (e.g. y1=“Let”). • If qi,j = COPY-INPUT, ai,j is obtained by copy-\ning an element from the input vector with a pointer network (Vinyals et al., 2015) over input words x1, . . . , x|x|, represented by their encoder LSTM state u1, . . . ,u|x|. As such, we compute the probability distribution over input words as:\np(ai,j | qi,j =COPY-INPUT) = (1) softmax\nai,j∈x1,...,x|x|\n( f(uai,j ,qi,j) ) Function f computes the affinity of each token xai,j and the current output context qi,j . A common implementation of f , which we follow, is to apply a linear projection from [uai,j ;qi,j ] into a fixed size vector (where [u;v] is vector concatenation), followed by a tanh and a linear projection into a single value.\n• If qi,j = COPY-OUTPUT, the model copies from either the output y or the memory m. This is equivalent to finding the instruction zi, where the value was generated. Once again, we define a pointer network that points to the output instructions and define the distribution over previously generated instructions as:\np(ai,j | qi,j =COPY-OUTPUT) = softmax\nai,j∈z1,...,zi−1\n( f(hai,j ,qi,j) ) Here, the affinity is computed using the decoder state hai,j and the current state qi,j .\nFinally, we embed the argument ai,j1 and the state qi,j to generate the next state qi,j+1. Once all arguments for oi are generated, the operation is executed to obtain vi. Then, the embedding of vi, the final state of the instruction qi,|ai| and the previous state hi are used to generate the state at the next timestamp hi+1."
    }, {
      "heading" : "4 Inducing Programs while Learning",
      "text" : "The set of instructions z that will generate y is unobserved. Thus, given x we optimize the marginal probability function:\np(y | x) = ∑ z∈Z p(y | z)p(z | x) = ∑ z∈Z(y) p(z | x),\nwhere p(y | z) is the Kronecker delta function δe(z),y, which is 1 if the execution of z, denoted as e(z), generates y and 0 otherwise. Thus, we can redefine p(y|x), the marginal over all programsZ , as a marginal over programs that would generate y, defined as Z(y). As marginalizing over z ∈ Z(y) is intractable, we approximate the marginal by generating samples from our model. Denote the set of samples that are generated by Ẑ(y). We maximize ∑ z ∈ Ẑ(y)p(z|x).\nHowever, generating programs that generate y is not trivial, as randomly sampling from the RNN distribution over instructions at each timestamp is unlikely to generate a sequence z ∈ Z(y).\nThis is analogous to the question answering work in Liang et al. (2016), where the query that\n1 The embeddings of a given argument ai,j and the return value vi are obtained with a lookup table embedding and two flags indicating whether it is a string and whether it is a float. Furthermore, if the the value is a float we also add its numeric value as a feature.\ngenerates the correct answer must be found during inference, and training proved to be difficult without supervision. In Roy and Roth (2015) this problem is also addressed by adding prior knowledge to constrain the exponential space.\nIn our work, we leverage the fact that we are generating rationales, where there is a sense of progression within the rationale. That is, we assume that the rationale solves the problem step by step. For instance, in Problem 2, the rationale first describes the number of combinations of two cards in a deck of 52 cards, then describes the number of combinations of two kings, and finally computes the probability of drawing two kings. Thus, while generating the final answer without the rationale requires a long sequence of latent instructions, generating each of the tokens of the rationale requires far less operations.\nMore formally, given the sequence z1, . . . , zi−1 generated so far, and the possible values for zi given by the network, denotedZi, we wish to filter Zi to Zi(yk), which denotes a set of possible options that contain at least one path capable of generating the next token at index k. Finding the set Zi(yk) is achieved by testing all combinations of instructions that are possible with at most one level of indirection, and keeping those that can generate yk. This means that the model can only generate one intermediate value in memory (not including the operations that convert strings into floating point values and vice-versa).\nDecoding. During decoding we find the most likely sequence of instructions z given x, which can be performed with a stack-based decoder. However, it is important to refer that each generated instruction zi = (oi, ri, ai,1, . . . , ai,|ai|, vi) must be executed to obtain vi. To avoid generating unexecutable code—e.g., log(0)—each hypothesis instruction is executed and removed if an error occurs. Finally, once the “〈EOR〉” tag is generated, we only allow instructions that would generate one of the option “A” to “E” to be generated, which guarantees that one of the options is chosen."
    }, {
      "heading" : "5 Staged Back-propagation",
      "text" : "As it is shown in Figure 2, math rationales with more than 200 tokens are not uncommon, and with additional intermediate instructions, the size z can easily exceed 400. This poses a practical challenge for training the model.\nFor both the attention and copy mechanisms,\nfor each instruction zi, the model needs to compute the probability distribution between all the attendable units c conditioned on the previous state hi−1. For the attention model and input copy mechanisms, c = x0,i−1 and for the output copy mechanism c = z. These operations generally involve an exponential number of matrix multiplications as the size of c and z grows. For instance, during the computation of the probabilities for the input copy mechanism in Equation 1, the affinity function f between the current context q and a given input uk is generally implemented by projecting u and q into a single vector followed by a non-linearity, which is projected into a single affinity value. Thus, for each possible input u, 3 matrix multiplications must be performed. Furthermore, for RNN unrolling, parameters and intermediate outputs for these operations must be replicated for each timestamp. Thus, as z becomes larger the attention and copy mechanisms quickly become a memory bottleneck as the computation graph becomes too large to fit on the GPU. In contrast, the sequence-to-sequence model proposed in (Sutskever et al., 2014), does not suffer from these issues as each timestamp is dependent only on the previous state hi−1.\nTo deal with this, we use a training method we call staged back-propagation which saves memory by considering slices of K tokens in z, rather than the full sequence. That is, to train on a minibatch where |z| = 300 with K = 100, we would actually train on 3 mini-batches, where the first batch would optimize for the first z1:100, the second for z101:200 and the third for z201:300. The advantage of this method is that memory intensive operations, such as attention and the copy mechanism, only need to be unrolled for K steps, and K can be adjusted so that the computation graph fits in memory.\nHowever, unlike truncated back-propagation for language modeling, where context outside the scope of K is ignored, sequence-to-sequence models require global context. Thus, the sequence of states h is still built for the whole sequence z. Afterwards, we obtain a slice hj:j+K , and compute the attention vector.2 Finally, the prediction of the instruction is conditioned on the LSTM state and the attention vector.\n2This modeling strategy is sometimes known as late fusion, as the attention vector is not used for state propagation, it is incorporated “later”."
    }, {
      "heading" : "6 Experiments",
      "text" : "We apply our model to the task of generating rationales for solutions to math problems, evaluating it on both the quality of the rationale and the ability of the model to obtain correct answers."
    }, {
      "heading" : "6.1 Baselines",
      "text" : "As the baseline we use the attention-based sequence to sequence model proposed by Bahdanau et al. (2014), and proposed augmentations, allowing it to copy from the input (Ling et al., 2016) and from the output (Merity et al., 2016)."
    }, {
      "heading" : "6.2 Hyperparameters",
      "text" : "We used a two-layer LSTM with a hidden size of H = 200, and word embeddings with size 200. The number of levels that the graph G is expanded during sampling D is set to 5. Decoding is performed with a beam of 200. As for the vocabulary of the softmax and embeddings, we keep the most frequent 20,000 word types, and replace the rest of the words with an unknown token. During training, the model only learns to predict a word as an unknown token, when there is no other alternative to generate the word."
    }, {
      "heading" : "6.3 Evaluation Metrics",
      "text" : "The evaluation of the rationales is performed with average sentence level perplexity and BLEU4 (Papineni et al., 2002). When a model cannot generate a token for perplexity computation, we predict unknown token. This benefits the baselines as they are less expressive. As the perplexity of our model is dependent on the latent program that is generated, we force decode our model to generate the rationale, while maximizing the probability of the program. This is analogous to the method used to obtain sample programs described in Section 4, but we choose the most likely instructions at each timestamp instead of sampling. Finally, the correctness of the answer is evaluated by computing the percentage of the questions, where the chosen option matches the correct one."
    }, {
      "heading" : "6.4 Results",
      "text" : "The test set results, evaluated on perplexity, BLEU, and accuracy, are presented in Table 3.\nPerplexity. In terms of perplexity, we observe that the regular sequence to sequence model fares poorly on this dataset, as the model requires the generation of many values that tend to be\nsparse. Adding an input copy mechanism greatly improves the perplexity as it allows the generation process to use values that were mentioned in the question. The output copying mechanism improves perplexity slightly over the input copy mechanism, as many values are repeated after their first occurrence. For instance, in Problem 2, the value “1326” is used twice, so even though the model cannot generate it easily in the first occurrence, the second one can simply be generated by copying the first one. We can observe that our model yields significant improvements over the baselines, demonstrating that the ability to generate new values by algebraic manipulation is essential in this task. An example of a program that is inferred is shown in Figure 4. The graph was generated by finding the most likely program z that generates y. Each node isolates a value in x, m, or y, where arrows indicate an operation executed with the outgoing nodes as arguments and incoming node as the return of the operation. For simplicity, operations that copy or convert values (e.g. from string to float) were not included, but nodes that were copied/converted share the same color. Examples of tokens where our model can obtain the perplexity reduction are the values “0.025”, “0.023”, “0.002” and finally the answer “E” , as these cannot be copied from the input or output.\nBLEU. We observe that the regular sequence to sequence model achieves a low BLEU score. In fact, due to the high perplexities the model generates very short rationales, which frequently consist of segments similar to “Answer should be D”, as most rationales end with similar statements. By applying the copy mechanism the BLEU score improves substantially, as the model can define the variables that are used in the rationale. Interestingly, the output copy mechanism adds no further improvement in the perplexity evaluation. This is because during decoding all values that can be copied from the output are values that could\nhave been generated by the model either from the softmax or the input copy mechanism. As such, adding an output copying mechanism adds little to the expressiveness of the model during decoding.\nFinally, our model can achieve the highest BLEU score as it has the mechanism to generate the intermediate and final values in the rationale.\nAccuracy. In terms of accuracy, we see that all baseline models obtain values close to chance (20%), indicating that they are completely unable to solve the problem. In contrast, we see that our model can solve problems at a rate that is significantly higher than chance, demonstrating the value of our program-driven approach, and its ability to learn to generate programs.\nIn general, the problems we solve correctly correspond to simple problems that can be solved in one or two operations. Examples include questions such as “Billy cut up each cake into 10 slices, and ended up with 120 slices altogether. How many cakes did she cut up? A) 9 B) 7 C) 12 D) 14 E) 16”, which can be solved in a single step. In this case, our model predicts “120 / 10 = 12 cakes. Answer is C” as the rationale, which is reasonable."
    }, {
      "heading" : "6.5 Discussion.",
      "text" : "While we show that our model can outperform the models built up to date, generating complex rationales as those shown in Figure 1 correctly is still an unsolved problem, as each additional step adds complexity to the problem both during inference and decoding. Yet, this is the first result showing that it is possible to solve math problems in such a manner, and we believe this modeling approach and dataset will drive work on this problem."
    }, {
      "heading" : "7 Related Work",
      "text" : "Extensive efforts have been made in the domain of math problem solving (Hosseini et al., 2014; Kushman et al., 2014; Roy and Roth, 2015), which aim at obtaining the correct answer to a given math problem. Other work has focused on learning to map math expressions into formal languages (Roy et al., 2016). We aim to generate natural language rationales, where the bindings between variables and the problem solving approach are mixed into a single generative model that attempts to solve the problem while explaining the approach taken.\nOur approach is strongly tied with the work on sequence to sequence transduction using the encoder-decoder paradigm (Sutskever et al., 2014;\nBahdanau et al., 2014; Kalchbrenner and Blunsom, 2013), and inherits ideas from the extensive literature on semantic parsing (Jones et al., 2012; Berant et al., 2013; Andreas et al., 2013; Quirk et al., 2015; Liang et al., 2016; Neelakantan et al., 2016) and program generation (Reed and de Freitas, 2016; Graves et al., 2016), namely, the usage of an external memory, the application of different operators over values in the memory and the copying of stored values into the output sequence.\nProviding textual explanations for classification decisions has begun to receive attention, as part of increased interest in creating models whose decisions can be interpreted. Lei et al. (2016), jointly modeled both a classification decision, and the selection of the most relevant subsection of a document for making the classification decision. Hendricks et al. (2016) generate textual explanations for visual classification problems, but in contrast to our model, they first generate an answer, and then, conditional on the answer, generate an explanation. This effectively creates a post-hoc justification for a classification decision rather than a program for deducing an answer. These papers,\nlike ours, have jointly modeled rationales and answer predictions; however, we are the first to use rationales to guide program induction."
    }, {
      "heading" : "8 Conclusion",
      "text" : "In this work, we addressed the problem of generating rationales for math problems, where the task is to not only obtain the correct answer of the problem, but also generate a description of the method used to solve the problem. To this end, we collect 100,000 question and rationale pairs, and propose a model that can generate natural language and perform arithmetic operations in the same decoding process. Experiments show that our method outperforms existing neural models, in both the fluency of the rationales that are generated and the ability to solve the problem."
    } ],
    "references" : [ {
      "title" : "Semantic parsing as machine translation",
      "author" : [ "Jacob Andreas", "Andreas Vlachos", "Stephen Clark." ],
      "venue" : "Proc. of ACL.",
      "citeRegEx" : "Andreas et al\\.,? 2013",
      "shortCiteRegEx" : "Andreas et al\\.",
      "year" : 2013
    }, {
      "title" : "Semantic parsing on freebase from question-answer pairs",
      "author" : [ "Jonathan Berant", "Andrew Chou", "Roy Frostig", "Percy Liang." ],
      "venue" : "Proc. of EMNLP.",
      "citeRegEx" : "Berant et al\\.,? 2013",
      "shortCiteRegEx" : "Berant et al\\.",
      "year" : 2013
    }, {
      "title" : "Hybrid computing using a neural network with dynamic external memory",
      "author" : [ "Yori Zwols", "Georg Ostrovski", "Adam Cain", "Helen King", "Christopher Summerfield", "Phil Blunsom", "Koray Kavukcuoglu", "Demis Hassabis." ],
      "venue" : "Nature 538(7626):471–",
      "citeRegEx" : "Zwols et al\\.,? 2016",
      "shortCiteRegEx" : "Zwols et al\\.",
      "year" : 2016
    }, {
      "title" : "Rationalization: A neural machine translation approach to generating natural language explanations",
      "author" : [ "Brent Harrison", "Upol Ehsan", "Mark O. Riedl." ],
      "venue" : "CoRR abs/1702.07826.",
      "citeRegEx" : "Harrison et al\\.,? 2017",
      "shortCiteRegEx" : "Harrison et al\\.",
      "year" : 2017
    }, {
      "title" : "Generating visual explanations",
      "author" : [ "Lisa Anne Hendricks", "Zeynep Akata", "Marcus Rohrbach", "Jeff Donahue", "Bernt Schiele", "Trevor Darrell." ],
      "venue" : "Proc. ECCV .",
      "citeRegEx" : "Hendricks et al\\.,? 2016",
      "shortCiteRegEx" : "Hendricks et al\\.",
      "year" : 2016
    }, {
      "title" : "Learning to solve arithmetic word problems with verb categorization",
      "author" : [ "Mohammad Javad Hosseini", "Hannaneh Hajishirzi", "Oren Etzioni", "Nate Kushman." ],
      "venue" : "Proc. of EMNLP.",
      "citeRegEx" : "Hosseini et al\\.,? 2014",
      "shortCiteRegEx" : "Hosseini et al\\.",
      "year" : 2014
    }, {
      "title" : "Semantic parsing with bayesian tree transducers",
      "author" : [ "Bevan Keeley Jones", "Mark Johnson", "Sharon Goldwater." ],
      "venue" : "Proc. of ACL.",
      "citeRegEx" : "Jones et al\\.,? 2012",
      "shortCiteRegEx" : "Jones et al\\.",
      "year" : 2012
    }, {
      "title" : "Recurrent continuous translation models",
      "author" : [ "Nal Kalchbrenner", "Phil Blunsom." ],
      "venue" : "Proc. of EMNLP.",
      "citeRegEx" : "Kalchbrenner and Blunsom.,? 2013",
      "shortCiteRegEx" : "Kalchbrenner and Blunsom.",
      "year" : 2013
    }, {
      "title" : "Learning to automatically solve algebra word problems",
      "author" : [ "Nate Kushman", "Yoav Artzi", "Luke Zettlemoyer", "Regina Barzilay." ],
      "venue" : "Proc. of ACL.",
      "citeRegEx" : "Kushman et al\\.,? 2014",
      "shortCiteRegEx" : "Kushman et al\\.",
      "year" : 2014
    }, {
      "title" : "Rationalizing neural predictions",
      "author" : [ "Tao Lei", "Regina Barzilay", "Tommi Jaakkola." ],
      "venue" : "Proc. of EMNLP.",
      "citeRegEx" : "Lei et al\\.,? 2016",
      "shortCiteRegEx" : "Lei et al\\.",
      "year" : 2016
    }, {
      "title" : "Neural symbolic machines: Learning semantic parsers on freebase with weak supervision",
      "author" : [ "Chen Liang", "Jonathan Berant", "Quoc Le", "Kenneth D. Forbus", "Ni Lao." ],
      "venue" : "arXiv 1611.00020.",
      "citeRegEx" : "Liang et al\\.,? 2016",
      "shortCiteRegEx" : "Liang et al\\.",
      "year" : 2016
    }, {
      "title" : "Latent predictor networks for code generation",
      "author" : [ "Wang Ling", "Edward Grefenstette", "Karl Moritz Hermann", "Tomás Kociský", "Andrew Senior", "Fumin Wang", "Phil Blunsom." ],
      "venue" : "Proc. of ACL.",
      "citeRegEx" : "Ling et al\\.,? 2016",
      "shortCiteRegEx" : "Ling et al\\.",
      "year" : 2016
    }, {
      "title" : "Pointer sentinel mixture models",
      "author" : [ "Stephen Merity", "Caiming Xiong", "James Bradbury", "Richard Socher." ],
      "venue" : "arXiv 1609.07843.",
      "citeRegEx" : "Merity et al\\.,? 2016",
      "shortCiteRegEx" : "Merity et al\\.",
      "year" : 2016
    }, {
      "title" : "Neural programmer: Inducing latent programs with gradient descent",
      "author" : [ "Arvind Neelakantan", "Quoc V. Le", "Ilya Sutskever." ],
      "venue" : "Proc. ICLR.",
      "citeRegEx" : "Neelakantan et al\\.,? 2016",
      "shortCiteRegEx" : "Neelakantan et al\\.",
      "year" : 2016
    }, {
      "title" : "Bleu: A method for automatic evaluation of machine translation",
      "author" : [ "Kishore Papineni", "Salim Roukos", "Todd Ward", "WeiJing Zhu." ],
      "venue" : "Proc. of ACL.",
      "citeRegEx" : "Papineni et al\\.,? 2002",
      "shortCiteRegEx" : "Papineni et al\\.",
      "year" : 2002
    }, {
      "title" : "Language to code: Learning semantic parsers for if-this-then-that recipes",
      "author" : [ "Chris Quirk", "Raymond Mooney", "Michel Galley." ],
      "venue" : "Proc. of ACL.",
      "citeRegEx" : "Quirk et al\\.,? 2015",
      "shortCiteRegEx" : "Quirk et al\\.",
      "year" : 2015
    }, {
      "title" : "Neural programmer-interpreters",
      "author" : [ "Scott E. Reed", "Nando de Freitas." ],
      "venue" : "Proc. of ICLR.",
      "citeRegEx" : "Reed and Freitas.,? 2016",
      "shortCiteRegEx" : "Reed and Freitas.",
      "year" : 2016
    }, {
      "title" : "Solving general arithmetic word problems",
      "author" : [ "Subhro Roy", "Dan Roth." ],
      "venue" : "Proc. of EMNLP.",
      "citeRegEx" : "Roy and Roth.,? 2015",
      "shortCiteRegEx" : "Roy and Roth.",
      "year" : 2015
    }, {
      "title" : "Equation parsing: Mapping sentences to grounded equations",
      "author" : [ "Subhro Roy", "Shyam Upadhyay", "Dan Roth." ],
      "venue" : "Proc. of EMNLP.",
      "citeRegEx" : "Roy et al\\.,? 2016",
      "shortCiteRegEx" : "Roy et al\\.",
      "year" : 2016
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "Ilya Sutskever", "Oriol Vinyals", "Quoc V. Le." ],
      "venue" : "arXiv 1409.3215.",
      "citeRegEx" : "Sutskever et al\\.,? 2014",
      "shortCiteRegEx" : "Sutskever et al\\.",
      "year" : 2014
    }, {
      "title" : "Pointer networks",
      "author" : [ "Oriol Vinyals", "Meire Fortunato", "Navdeep Jaitly." ],
      "venue" : "Proc. of NIPS.",
      "citeRegEx" : "Vinyals et al\\.,? 2015",
      "shortCiteRegEx" : "Vinyals et al\\.",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "As a proxy for the richness of the real world, a series of papers have used natural language specifications of algebraic word problems, and solved these by either learning to fill in templates that can be solved with equation solvers (Hosseini et al., 2014; Kushman et al., 2014) or inferring and modeling operation sequences (programs) that lead to the final an-",
      "startOffset" : 234,
      "endOffset" : 279
    }, {
      "referenceID" : 8,
      "context" : "As a proxy for the richness of the real world, a series of papers have used natural language specifications of algebraic word problems, and solved these by either learning to fill in templates that can be solved with equation solvers (Hosseini et al., 2014; Kushman et al., 2014) or inferring and modeling operation sequences (programs) that lead to the final an-",
      "startOffset" : 234,
      "endOffset" : 279
    }, {
      "referenceID" : 17,
      "context" : "swer (Roy and Roth, 2015).",
      "startOffset" : 5,
      "endOffset" : 25
    }, {
      "referenceID" : 4,
      "context" : "This work is thus related to models that can explain or rationalize their decisions (Hendricks et al., 2016; Harrison et al., 2017).",
      "startOffset" : 84,
      "endOffset" : 131
    }, {
      "referenceID" : 3,
      "context" : "This work is thus related to models that can explain or rationalize their decisions (Hendricks et al., 2016; Harrison et al., 2017).",
      "startOffset" : 84,
      "endOffset" : 131
    }, {
      "referenceID" : 17,
      "context" : "Problem 2 is an example that could be solved by multi-step arithmetic operations proposed in (Roy and Roth, 2015).",
      "startOffset" : 93,
      "endOffset" : 113
    }, {
      "referenceID" : 8,
      "context" : "In previous work (Kushman et al., 2014), this could be done by feeding the equation into an expression solver to obtain x/y = 3/2.",
      "startOffset" : 17,
      "endOffset" : 39
    }, {
      "referenceID" : 11,
      "context" : "This decision is modeled using a latent predictor network (Ling et al., 2016), where the control over which method used to generate ai,j is governed by a latent variable qi,j ∈ {SOFTMAX, COPY-INPUT, COPY-OUTPUT}.",
      "startOffset" : 58,
      "endOffset" : 77
    }, {
      "referenceID" : 20,
      "context" : "• If qi,j = COPY-INPUT, ai,j is obtained by copying an element from the input vector with a pointer network (Vinyals et al., 2015) over input words x1, .",
      "startOffset" : 108,
      "endOffset" : 130
    }, {
      "referenceID" : 10,
      "context" : "This is analogous to the question answering work in Liang et al. (2016), where the query that",
      "startOffset" : 52,
      "endOffset" : 72
    }, {
      "referenceID" : 17,
      "context" : "In Roy and Roth (2015) this problem is also addressed by adding prior knowledge to constrain the exponential space.",
      "startOffset" : 3,
      "endOffset" : 23
    }, {
      "referenceID" : 19,
      "context" : "trast, the sequence-to-sequence model proposed in (Sutskever et al., 2014), does not suffer from these issues as each timestamp is dependent only on the previous state hi−1.",
      "startOffset" : 50,
      "endOffset" : 74
    }, {
      "referenceID" : 11,
      "context" : "(2014), and proposed augmentations, allowing it to copy from the input (Ling et al., 2016) and from the output (Merity et al.",
      "startOffset" : 71,
      "endOffset" : 90
    }, {
      "referenceID" : 12,
      "context" : ", 2016) and from the output (Merity et al., 2016).",
      "startOffset" : 28,
      "endOffset" : 49
    }, {
      "referenceID" : 14,
      "context" : "The evaluation of the rationales is performed with average sentence level perplexity and BLEU4 (Papineni et al., 2002).",
      "startOffset" : 95,
      "endOffset" : 118
    }, {
      "referenceID" : 5,
      "context" : "Extensive efforts have been made in the domain of math problem solving (Hosseini et al., 2014; Kushman et al., 2014; Roy and Roth, 2015), which aim at obtaining the correct answer to a given math",
      "startOffset" : 71,
      "endOffset" : 136
    }, {
      "referenceID" : 8,
      "context" : "Extensive efforts have been made in the domain of math problem solving (Hosseini et al., 2014; Kushman et al., 2014; Roy and Roth, 2015), which aim at obtaining the correct answer to a given math",
      "startOffset" : 71,
      "endOffset" : 136
    }, {
      "referenceID" : 17,
      "context" : "Extensive efforts have been made in the domain of math problem solving (Hosseini et al., 2014; Kushman et al., 2014; Roy and Roth, 2015), which aim at obtaining the correct answer to a given math",
      "startOffset" : 71,
      "endOffset" : 136
    }, {
      "referenceID" : 18,
      "context" : "Other work has focused on learning to map math expressions into formal languages (Roy et al., 2016).",
      "startOffset" : 81,
      "endOffset" : 99
    }, {
      "referenceID" : 6,
      "context" : "som, 2013), and inherits ideas from the extensive literature on semantic parsing (Jones et al., 2012; Berant et al., 2013; Andreas et al., 2013; Quirk et al., 2015; Liang et al., 2016; Neelakantan et al., 2016) and program generation (Reed and de Freitas, 2016; Graves et al.",
      "startOffset" : 81,
      "endOffset" : 210
    }, {
      "referenceID" : 1,
      "context" : "som, 2013), and inherits ideas from the extensive literature on semantic parsing (Jones et al., 2012; Berant et al., 2013; Andreas et al., 2013; Quirk et al., 2015; Liang et al., 2016; Neelakantan et al., 2016) and program generation (Reed and de Freitas, 2016; Graves et al.",
      "startOffset" : 81,
      "endOffset" : 210
    }, {
      "referenceID" : 0,
      "context" : "som, 2013), and inherits ideas from the extensive literature on semantic parsing (Jones et al., 2012; Berant et al., 2013; Andreas et al., 2013; Quirk et al., 2015; Liang et al., 2016; Neelakantan et al., 2016) and program generation (Reed and de Freitas, 2016; Graves et al.",
      "startOffset" : 81,
      "endOffset" : 210
    }, {
      "referenceID" : 15,
      "context" : "som, 2013), and inherits ideas from the extensive literature on semantic parsing (Jones et al., 2012; Berant et al., 2013; Andreas et al., 2013; Quirk et al., 2015; Liang et al., 2016; Neelakantan et al., 2016) and program generation (Reed and de Freitas, 2016; Graves et al.",
      "startOffset" : 81,
      "endOffset" : 210
    }, {
      "referenceID" : 10,
      "context" : "som, 2013), and inherits ideas from the extensive literature on semantic parsing (Jones et al., 2012; Berant et al., 2013; Andreas et al., 2013; Quirk et al., 2015; Liang et al., 2016; Neelakantan et al., 2016) and program generation (Reed and de Freitas, 2016; Graves et al.",
      "startOffset" : 81,
      "endOffset" : 210
    }, {
      "referenceID" : 13,
      "context" : "som, 2013), and inherits ideas from the extensive literature on semantic parsing (Jones et al., 2012; Berant et al., 2013; Andreas et al., 2013; Quirk et al., 2015; Liang et al., 2016; Neelakantan et al., 2016) and program generation (Reed and de Freitas, 2016; Graves et al.",
      "startOffset" : 81,
      "endOffset" : 210
    }, {
      "referenceID" : 8,
      "context" : "Lei et al. (2016), jointly modeled both a classification decision, and the selection of the most relevant subsection of a document for making the classification decision.",
      "startOffset" : 0,
      "endOffset" : 18
    }, {
      "referenceID" : 4,
      "context" : "Hendricks et al. (2016) generate textual explanations for visual classification problems, but in contrast to our model, they first generate an answer, and then, conditional on the answer, generate an explanation.",
      "startOffset" : 0,
      "endOffset" : 24
    } ],
    "year" : 2017,
    "abstractText" : "Solving algebraic word problems requires executing a series of arithmetic operations—a program—to obtain a final answer. However, since programs can be arbitrarily complicated, inducing them directly from question-answer pairs is a formidable challenge. To make this task more feasible, we solve these problems by generating answer rationales, sequences of natural language and human-readable mathematical expressions that derive the final answer through a series of small steps. Although rationales do not explicitly specify programs, they provide a scaffolding for their structure via intermediate milestones. To evaluate our approach, we have created a new 100,000-sample dataset of questions, answers and rationales. Experimental results show that indirect supervision of program learning via answer rationales is a promising strategy for inducing arithmetic programs.",
    "creator" : "LaTeX with hyperref package"
  }
}