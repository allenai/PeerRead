{
  "name" : "1705.06564.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Stepwise Debugging of Answer-Set Programs",
    "authors" : [ "JOHANNES OETSCH", "HANS TOMPITS" ],
    "emails" : [ "johannes.oetsch@tuwien.ac.at)", "puehrer@informatik.uni-leipzig.de)", "tompits@kr.tuwien.ac.at)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We introduce a stepping methodology for answer-set programming (ASP) that allows for debugging answer-set programs and is based on the stepwise application of rules. Similar to debugging in imperative languages, where the behaviour of a program is observed during a step-by-step execution, stepping for ASP allows for observing the effects that rule applications have in the computation of an answer set. While the approach is inspired from debugging in imperative programming, it is conceptually different to stepping in other paradigms due to non-determinism and declarativity that are inherent to ASP. In particular, unlike statements in an imperative program that are executed following a strict control flow, there is no predetermined order in which to consider rules in ASP during a computation. In our approach, the user is free to decide which rule to consider active in the next step following his or her intuition. This way, one can focus on interesting parts of the debugging search space. Bugs are detected during stepping by revealing differences between the actual semantics of the program and the expectations of the user. As a solid formal basis for stepping, we develop a framework of computations for answer-set programs. For fully supporting different solver languages, we build our framework on an abstract ASP language that is sufficiently general to capture different solver languages. To this end, we make use of abstract constraints as an established abstraction for popular language constructs such as aggregates. Stepping has been implemented in SeaLion, an integrated development environment for ASP. We illustrate stepping using an example scenario and discuss the stepping plugin of SeaLion. Moreover, we elaborate on methodological aspects and the embedding of stepping in the ASP development process.\nUnder consideration in Theory and Practice of Logic Programming (TPLP).\nar X\niv :1\n70 5.\n06 56"
    }, {
      "heading" : "1 Introduction",
      "text" : "Answer-set programming (ASP) (Niemelä 1999; Marek and Truszczyński 1999) is a paradigm for declarative problem solving that is popular amongst researchers in artificial intelligence and knowledge representation. Yet it is rarely used by software engineers outside academia so far. Arguably, one obstacle preventing developers from using ASP is a lack of support tools for developing answer-set programs. One particular problem in the context of programming support is debugging of answerset programs. Due to the fully declarative semantics of ASP, it can be quite tedious to detect an error in an answer-set program. In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015). These previous works are important contributions towards ASP development support, however current approaches come with limitations to their practical applicability. First, existing techniques and tools only capture a basic ASP language fragment that does not include many language constructs that are available and frequently used in modern ASP solver languages, e.g.,, aggregates or choice rules are not covered by current debugging strategies (with the exception of the work by Polleres et al. (2013), where cardinality constraints are dealt with by translation). Second, usability aspects are often not considered in current approaches, in particular, the programmer is required to either provide a lot of data to a debugging system or he or she is confronted with a huge amount of information from the system (tackling this problem in query-based debugging has been addressed by Shchekotykhin (2015)).\nThis paper introduces a stepping methodology for ASP, which is a novel technique for debugging answer-set programs that is general enough to deal with current ASP solver languages and is intuitive and easy to use. Our method is similar in spirit to the widespread and effective debugging strategy in imperative programming, where the idea is to gain insight into the behaviour of a program by executing statement by statement following the program’s control flow. In our approach, we allow for stepwise constructing interpretations by considering rules of an answer-set program at hand in a successive manner. This method guarantees that either an answer set will be reached, or some error will occur that provides hints why the semantics of the program differs from the user’s expectations. A major difference to the imperative setting is that, due to its declarativity, ASP lacks any control flow. Instead, we allow the user to follow his or her intuition on which rule instances to become active. This way, one can focus on interesting parts of the debugging search space from the beginning. For illustration, the following answer-set program has {a} as its only answer set.\na :- not b. b :- not a. a :- b.\nLet’s step through the program to obtain explanations why this is the case. In\nthe beginning of a stepping session, no atom is considered to be true. Under this premise, the first two rules are active. The user decides which of these rules to apply. Choosing a rule to be applied in this manner is considered a step in our approach. In case the user chooses the first rule, the atom a is derived. Then, no further rule is active and one of the answer sets, {a} has been reached. If, on the other hand, the user chooses the second rule in the first step, atom b is derived and a is considered false. Then, the third rule becomes active. However, this rule would derive a that is already considered false when choosing the second rule. In this case, the user sees that no answer set can be reached based on the initial choice.\nBesides single steps that allow the user to consider one rule instance at a time, we also lay the ground for so-called jumps. The intuition is that in a jump multiple rule instances and even multiple non-ground rules can be considered at once. Jumping significantly speeds up the stepping process which makes our technique a usable tool for debugging in practice. Consider the following encoding of an instance of the three-colouring problem in the Gringo language (Gebser et al. 2011):\n1{color(X,red;green;blue)}1 :- node(X).\n:- edge(X,Y), color(X,C), color(X,C).\nnode(X):-edge(X,Y). node(Y):-edge(X,Y). edge(1,2). edge(1,3). edge(1,4). edge(2,4). edge(2,5). edge(2,6). edge(3,4). edge(3,5). edge(3,6). edge(4,5). edge(5,6).\nThe user expects the program to have answer sets but it does not. Following our approach, the reason for that can be found after two actions. First, trusting the “instance” part of the program, the user applies a jump on all rules of this part, and, intuitively, gets all atoms implied by these rules as an intermediate result. Second, the user applies an arbitrary instance of the rule\n1{color(X,red;green;blue)}1 :- node(X).\nthat is active under the atoms derived during the jump. Suppose, the user chooses the instance"
    }, {
      "heading" : "1 {color(1, red), color(1, green), color(1, blue)} 1 :- node(1).",
      "text" : "and selects color(1, red) to be true. Then, the debugging system reveals that the instance\n:- edge(1, 2), color(1, red), color(1, red).\nof the “check” constraint becomes unexpectedly active. Now, the users sees that the second occurrence of color(X,C) in the constraint has to be replaced by color(Y,C). Generally, bugs can be detected whenever stepping reveals differences between the actual semantics of the program and the expectations of the user.\nIn order to establish a solid formal basis for our stepping technique, we developed a framework of computations for answer-set programs. For fully supporting current solver languages, we were faced with several challenges. For one, the languages of answer-set solvers differ from each other and from formal ASP languages in various ways. In order to develop a method that works for different solvers, we need an abstract ASP language that is sufficiently general to capture actual solver languages. To this end, we make use of abstract constraints (Marek and Remmel 2004; Marek and Truszczyński 2004) as an established abstraction for language constructs such as aggregates, weight constraints, and external atoms. We rely on a semantics for arbitrary abstract-constraint programs with disjunctions that we introduced for this purpose in previous work (Oetsch et al. 2012a). In contrast to other semantics for this type of programs, it is compatible with the semantics of all the ASP solvers we want to support, namely, Clasp (Gebser et al. 2012), DLV (Leone et al. 2006), and DLVHEX (Redl 2016). Note that our framework for computations for abstractconstraint programs differs from the one by Liu et al. (2010). We did not build on this existing notion for three reasons. First, it does not cover rules with disjunctive heads which we want to support. Second, steps in this framework correspond to the application of multiple rules. Since our method is rooted in the analogy to stepping in procedural languages, where an ASP rule corresponds to a statement in an imperative language, we focus on steps corresponding to application of a single rule. Finally, the semantics of non-convex literals differs from that of DLVHEX in the existing approach. A thorough discussion on the relation of the two notions of computations is given in Section 5.\nAnother basic problem deals with the grounding step in which variables are removed from answer-set programs before solving. In formal ASP languages, the grounding of a program consists of all rules resulting from substitutions of variables by ground terms. In contrast, actual grounding tools apply many different types of simplifications and pre-evaluations for creating a variable-free program. In order to close this gap between formal and practical ASP, Pührer developed abstractions of the grounding step together with an abstract notion of non-ground answer-set program as the base language for the stepping methodology in his PhD thesis (Pührer 2014). Based on that, stepping can easily be applied to existing solver languages and it becomes robust to changes to these languages. As we focus on the methodological aspects of stepping in this article, we do not present these abstractions and implicitly use grounding as carried out by actual grounding tools.\nThe stepping technique has been implemented in SeaLion (Oetsch et al. 2013), an integrated development environment for ASP. We discuss how SeaLion can be used for stepping answer-set programs written in the Gringo or the DLV language.1\n1 The framework introduced in this paper subsumes and significantly extends previous versions of the stepping technique for normal logic programs (Oetsch et al. 2010; Oetsch et al. 2011) and DL-programs (Oetsch et al. 2012b)."
    }, {
      "heading" : "Outline",
      "text" : "Next, we provide the formal background that is necessary for our approach. We recall the syntax of disjunctive abstract-constraint programs and the semantics on which we base our framework (Oetsch et al. 2012a). Section 3 introduces a framework of computations that allows for breaking the semantics down to the level of individual rules. After defining states and computations, we show several properties of the framework, most importantly soundness and completeness in the sense that the result of a successful computation is an answer set and that every answer set can be constructed with a computation. Moreover, we study language fragments for which a simpler form of computation suffices. In Section 4, we present the stepping technique for debugging answer-set programs based on our computation framework. We explain steps and jumps as a means to progress in a computation using an example scenario. Moreover, we discuss methodological aspects of stepping on the application level (how stepping is used for debugging and program analysis) and the top level (how stepping is embedded in the ASP development process). We illustrate the approach with several use cases and describe the stepping interface of SeaLion. Related work is discussed in Section 5. We compare stepping to other debugging approaches for ASP and discuss the relation of our computation framework to that of Liu et al. (2010) and transition systems for ASP (Lierler 2011; Lierler and Truszczyński 2016; Brochenin et al. 2014). We conclude the paper in Section 6.\nIn Appendix A we compile guidelines for stepping and give general recommendations for ASP development. Selected and short proofs are included in the main text and all remaining proofs are provided in Appendix B."
    }, {
      "heading" : "2 Background",
      "text" : "As motivated in the introduction, we represent grounded answer-set programs by abstract-constraint programs (Marek and Remmel 2004; Marek and Truszczyński 2004; Oetsch et al. 2012a). Non-ground programs will be denoted by programs in the input language of Gringo. Thus, we implicitly assume that grounding translates (non-ground) Gringo rules to rules of abstract-constraint programs. For a detailed formal account of our framework in the non-ground setting we refer the interested reader to the dissertation of Pührer (2014).\nWe assume a fixed set A of ground atoms.\nDefinition 1 An interpretation is a set I ⊆ A of ground atoms. A ground atom a is true under interpretation I , symbolically I |= a, if a ∈ I , otherwise it is false under I . We will use the symbol 6|= to denote the complement of a relation denoted with the symbol |= in different contexts.\nFor better readability, we sometimes make use of the following notation when the reader may interpret the intersection of two sets I and X of ground atoms as a projection from I to X .\nDefinition 2 For two sets I and X of ground atoms, I |X = I ∩X is the projection of I to X ."
    }, {
      "heading" : "2.1 Syntax of Abstract-Constraint Programs",
      "text" : "Rule heads and bodies of abstract-constraint programs are formed by so-called abstract-constraint atoms.\nDefinition 3 (Marek and Remmel 2004; Marek and Truszczyński 2004) An abstract constraint, abstract-constraint atom, or C-atom, is a pair A = 〈D ,C 〉, where D ⊆ A is a finite set called the domain of A, denoted by DA, and C ⊆ 2D is a collection of sets of ground atoms, called the satisfiers of A, denoted by CA.\nWe can express atoms also as C-atoms. In particular, for a ground atom a, we identify the C-atom 〈{a}, {{a}}〉 with a. We call such C-atoms elementary . We will also make use of default negation in abstract-constraint programs. An abstract-constraint literal, or C-literal, is a C-atom A or a default negated C-atom notA.\nUnlike the original definition, we introduce abstract-constraint programs with\ndisjunctive rule heads.\nDefinition 4\nAn abstract-constraint rule, or simply C-rule, is an expression of the form\nA1 ∨ · · · ∨Ak ← Ak+1, . . . ,Am , not Am+1, . . . , not An , (1)\nwhere 0 ≤ k ≤ m ≤ n and any Ai , for 1 ≤ i ≤ n, is a C-atom.\nNote that if all disjuncts share the same domain they can be expressed by a single C-atom (see Pührer 2014) but in general disjunction adds expressivity.\nWe identify different parts of a C-rule and introduce some syntactic properties.\nDefinition 5\nFor a C-rule r of form (1),\n• B(r) = {Ak+1, . . . ,Am , not Am+1, . . . , not An} is the body of r , • B+(r) = {Ak+1, . . . ,Am} is the positive body of r , • B−(r) = {Am+1, . . . ,An} is the negative body of r , and • H(r) = {A1, . . . ,Ak} is the head of r .\nIf B(r) = ∅ and H(r) 6= ∅, then r is a C-fact. For C-facts, we usually omit the symbol “←”. A C-rule r of form (1) is normal if k = 1 and positive if m = n.\nWe define the domain of a default negated C-atom notA as Dnot A = DA. Then,\nthe domain DS of a set S of C-literals is given by DS = ⋃ L∈S DL·\nFinally, the domain of a C-rule r is Dr = ⋃\nX∈H(r)∪B(r) DX ·\nDefinition 6 An abstract-constraint program, or simply C-program, is a finite set of C-rules. A C-program is normal, respectively positive, if it contains only normal, respectively positive, C-rules. A C-program is elementary if it contains only elementary Catoms."
    }, {
      "heading" : "2.2 Satisfaction Relation",
      "text" : "Intuitively, a C-atom 〈D ,C 〉 is a literal whose truth depends on the truth of all atoms in D under a given interpretation. The satisfiers in C explicitly list which combinations of true atoms in D make the C-atom true.\nDefinition 7 An interpretation I satisfies a C-atom 〈D ,C 〉, symbolically I |= 〈D ,C 〉, if I |D ∈ C . Moreover, I |= not 〈D ,C 〉 iff I 6|= 〈D ,C 〉.\nImportant criteria for distinguishing classes of C-atoms are concerned with their semantic behaviour with respect to growing (or shrinking) interpretations. In this respect, we identify monotonicity properties in the following.\nDefinition 8 A C-literal L is monotone if, for all interpretations I and I ′, if I ⊆ I ′ and I |= L, then also I ′ |= L. L is convex if, for all interpretations I , I ′, and I ′′, if I ⊆ I ′ ⊆ I ′′, I |= L, and I ′′ |= L, then also I ′ |= L. Moreover, a C-program P is monotone (respectively, convex) if for all r ∈ P all C-literals L ∈ H(r) ∪ B(r) are monotone (respectively, convex).\nNext, the notion of satisfaction is extended to C-rules and C-programs in the obvious way.\nDefinition 9 An interpretation I satisfies a set S of C-literals, symbolically I |= S , if I |= L for all L ∈ S . For brevity, we will use the notation I |=∃ S to denote that I |= L for some L ∈ S . Moreover, I satisfies a C-rule r , symbolically I |= r , if I |= B(r) implies I |=∃ H(r). A C-rule r such that I |= B(r) is called active under I . As well, I satisfies a set P of C-rules, symbolically I |= P , if I |= r for every r ∈ P . If I |= P , we say that I is a model of P ."
    }, {
      "heading" : "2.3 Viewing ASP Constructs as Abstract Constraints",
      "text" : "We want to use abstract constraints as a uniform means to represent common constructs in ASP solver languages. As an example, we recall how weight constraints (Simons et al. 2002) can be expressed as C-atoms. In a similar fashion, we can use them as abstractions of e.g., aggregates (Faber et al. 2004; Faber et al. 2011) or external atoms (Eiter et al. 2005). Note that the relation between abstract constraints and ASP constructs is well known and motivated abstract constraints in the first place (cf. Marek and Remmel 2004; Marek and Truszczyński 2004).\nDefinition 10 (Simons et al. 2002)\nA weight constraint is an expression of form\nl [a1 = w1, . . . , ak = wk , not ak+1 = wk+1, . . . , not an = wn ] u , (2)\nwhere each ai is a ground atom and each weight wi is a real number, for 1 ≤ i ≤ n. The lower bound l and the upper bound u are either a real number, ∞, or −∞.\nFor a weight constraint to be true, the sum of weights wi of those atoms ai , 1 ≤ i ≤ k , that are true and the weights of the atoms ai , k < i ≤ n, that are false must lie within the lower and the upper bound. Thus, a weight constraint of form (2) corresponds to the C-atom 〈D ,C 〉, where the domain D = {a1, . . . , an} consists of the atoms appearing in the weight constraint and\nC = {X ⊆ D | l ≤ ( ∑\n1≤i≤k ,ai∈X wi + ∑ k<i≤n,ai 6∈X wi) ≤ u} ·"
    }, {
      "heading" : "2.4 Semantics and Characterisations based on External Support and Unfounded Sets",
      "text" : "The semantics we use (Oetsch et al. 2012a) extends the FLP-semantics (Faber et al. 2004; 2011) and coincides with the original notion of answer sets by Gelfond and Lifschitz (1991) on many important classes of logic programs, including elementary C-programs. Similar to the original definition of answer sets, Faber et al. make use of a program reduct depending on a candidate interpretation I for determining whether I satisfies a stability criterion and thus is considered an answer set. However, the reduct of Faber, Leone, and Pfeifer differs in spirit from that of Gelfond and Lifschitz as it does not reduce the program to another syntactic class (the Gelfond-Lifschitz reduct of an elementary C-program is always positive). Instead, the so-called FLP-reduct, defined next, keeps the individual rules intact and just ignores all rules that are not active under the candidate interpretation.\nDefinition 11\nLet I be an interpretation, and let P be a C-program. The FLP-reduct of P with respect to I is given by P I = {r ∈ P | r is active under I }.\nThe notion of answer sets for abstract-constraint programs defined next provides\nthe semantic foundation for the computation model we use for debugging.\nDefinition 12 (Oetsch et al. 2012a)\nLet P be a C-program, and let I be an interpretation. I is an answer set of P if I |= P and there is no I ′ ⊂ I such that P , I , and I ′ satisfy the following condition:\n(?) for every r ∈ P I with I ′ |= B(r), there is some A ∈ H(r) with I ′ |= A and I ′|DA = I |DA .\nThe set of all answer sets of P is denoted by AS(P).\nThe purpose of Condition (?) is to prevent minimisation within C-atoms: the requirement I ′|DA = I |DA ensures that a satisfier {a, b} can enforce b to be true in an answer set even if the same C-atom has a satisfier {a}. As a consequence answer sets need not be subset minimal (see Pührer 2014 for details).\nOur choice of semantics has high solver compatibility as its objective as we want to support Gringo, DLV, and DLVHEX. We need an FLP-style treatment of nonconvex literals for being compatible with DLVHEX, disjunctions to support DLV and DLVHEX, and we must allow for weight constraints in rule heads for compatibility with Gringo. Note that Gringo/Clasp treats aggregates in the way suggested by Ferraris (2011). As a consequence, its semantics differs from our semantics in some cases, when recursion is used through negated c-atoms, as ours is an extension of the FLP semantics. For an in-depth comparison of FLP-semantics and Ferraris semantics we refer to work by Truszczyński (2010). An example where the semantics differ is given by the single rule Gringo program a :- not 0{a}0 that has only the empty set as answer set under our semantics, whereas Clasp also admits {a} as an answer set. In practice, this difference only hardly influences the compatibility with Gringo, as aggregates are seldom used in this way. We examined all Gringo encodings send to the second ASP competition and could not find any such usage.\nOur framework of computations for stepping is based on a characterisation of the semantics of Definition 12 in terms of external supports. Often, answer sets are computed following a two-step strategy: First, a model of the program is built, and second, it is checked whether this model obeys a foundedness condition ensuring that it is an answer set. Intuitively, every set of atoms in an answer set must be “supported” by some active rule that derives one of the atoms. Here, it is important that the reason for this rule to be active does not depend on the atom it derives. Such rules are referred to as external support (Lee 2005). The extension of this notion to our setting is the following.\nDefinition 13 (Oetsch et al. 2012a) Let r be a C-rule, X a set of atoms, and I an interpretation. Then, r is an external support for X with respect to I if\n(i) I |= B(r), (ii) I \\X |= B(r),\n(iii) there is some A ∈ H(r) with X |DA 6= ∅ and I |DA ⊆ S , for some S ∈ CA, and (iv) for all A ∈ H(r) with I |= A, (X ∩ I )|DA 6= ∅ holds.\nCondition (i) ensures that r is active. Condition (ii) prevents self-support by guaranteeing the support to be “external” of X , i.e., r is also be active without the atoms in X . In case I is a model, Items (iii) and (iv) jointly ensure that there is some C-atom A in the head of r that is satisfied by I and derives some atom of X .\nWe can express the absence of an external support in an interpretation by the\nconcept of an unfounded set.\nDefinition 14 (Oetsch et al. 2012a) Let P be a C-program, X a set of atoms, and I an interpretation. Then, X is unfounded in P with respect to I if there is no C-rule r ∈ P that is an external support for X with respect to I .\nCorollary 1 (Oetsch et al. 2012a) Let P be a C-program and I an interpretation. Then, I is an answer set of P iff I is a model of P and there is no set X with ∅ ⊂ X ⊆ I that is unfounded in P with respect to I ."
    }, {
      "heading" : "3 Computation Framework",
      "text" : "In this section, we want to break the conceptual complexity of the semantics down to artefacts the programmer is familiar with: the rules the user has written or, more precisely, their ground instances. To this end, we introduce a framework of computations that captures the semantics described in the previous section. In this computation model, on top of which we will introduce stepping in Section 4, an interpretation is built up step-by-step by considering an increasing number of rule instances to be active. A computation in our framework is a sequence of states which are structures that keep information which rules and atoms have already been considered and what truth values were assigned to those atoms. Utilising the framework, only one rule and the atoms it contains have to be considered at once while building up an interpretation until an answer set is reached or a source for the unexpected behaviour becomes apparent.\nIn the next two subsections, we introduce states and computations. In Section 3.3, we define and show some properties of computations that we need later on when we describe stepping. Section 3.4 is concerned with the existence of a stable computation which is a simpler form of computation that suffices for many popular classes of answer-set programs. We discuss existing work related to our computation framework later in Section 5."
    }, {
      "heading" : "3.1 States",
      "text" : "Our framework is based on sequences of states, reassembling computations, in which an increasing number of ground rules are considered that build up a monotonically growing interpretation. Besides that interpretation, states also capture literals which cannot become true in subsequent steps and sets that currently lack external support in the state’s interpretation.\nDefinition 15 A state structure S is a tuple 〈P , I , I−,Υ〉, where P is a set of C-rules, I is an interpretation, I− a set of atoms such that I and I− are disjoint, and Υ is a collection of sets of atoms. We call DS = I ∪ I− the domain of S and define PS = P , IS = I , I − S = I\n−, and ΥS = Υ. A state structure 〈P , I , I−,Υ〉 is a state if\n(i) I |= B(r) and I |=∃ H(r) for every r ∈ P , (ii) Dr ⊆ DS for every r ∈ P , and\n(iii) Υ = {X ⊆ I | X is unfounded in P with respect to I }.\nWe call 〈∅, ∅, ∅, {∅}〉 the empty state.\nIntuitively, we use the first component P of a state to collect C-rules that the user has considered to be active and satisfied. The interpretation I collects atoms that have been considered true. Condition (i) ensures that P and I are compatible in the sense that every C-rule that is considered active and satisfied is active and satisfied with respect to I . Dual to I , the interpretation I− collects atoms that the user has considered to be false. We require that all atoms appearing in a C-rule in P is either in I or in I− which is expressed in Condition (ii). Finally, the set Υ keeps track of unfounded subsets of I , as stated in Condition (iii). Intuitively, as we will see later, when building a computation, the aim is to get rid of all unfounded sets (except for the empty set) in order to compute an answer set of a C-program. If a state does not contain such unfounded sets then we call it stable:\nDefinition 16 A state S is stable if IS ∈ AS(PS ).\nThe intuition is that when a state S is stable, no more C-rules need to be added to PS to provide missing external support for the atoms in the current interpretation IS . Note that a state S is stable exactly when ΥS = {∅}. For example, the empty state is a stable state.\nExample 1 Consider the C-rules\nr1 : 〈{a, b}, {∅, {a}, {b}, {a, b}〉 ← not a r2 : b ← a\nand the state structures\nS1 =〈{r1}, ∅, {a, b}, {∅}〉, S2 =〈{r1}, {b}, {a}, {∅}〉, S3 =〈{r1}, {a, b}, ∅, {∅}〉, S4 =〈{r2}, {a, b}, ∅, {∅}〉, S5 =〈{r2}, {a, b}, ∅, {{b}, {a, b}}〉·\nS1 and S2 are stable states. S3 is not a state as IS3 6|= B(r1). S4 is not a state as the sets {b} and {a, b} are unfounded in PS4 with respect to IS4 but {b} 6∈ ΥS4 and {a, b} 6∈ ΥS4 . S5 is a state but not stable."
    }, {
      "heading" : "3.2 Computations",
      "text" : "Next, we show how we can proceed forward in a computation, i.e., which states might follow a given state using a successor relation for state structures.\nDefinition 17\nFor a state S = 〈P , I , I−,Υ〉 and a state structure S ′ = 〈P ′, I ′, I ′−,Υ′〉, S ′ is a successor of S if there is a C-rule r ∈ P ′ \\ P and sets ∆,∆− ⊆ Dr such that\n(i) P ′ = P ∪ {r}, (ii) I ′ = I ∪∆, I ′− = I− ∪∆−, and DS ∩ (∆ ∪∆−) = ∅, (iii) Dr ⊆ DS ′ , (iv) I |= B(r), (v) I ′ |= B(r) and I ′ |=∃ H(r), and\n(vi) X ′ ∈ Υ′ iff X ′ = X ∪ ∆′, where X ∈ Υ, ∆′ ⊆ ∆, and r is not an external support for X ′ with respect to I ′.\nWe denote r by rnew(S ,S ′).\nCondition (i) ensures that a successor state considers exactly one rule more to be active. Conditions (ii) and (iii) express that the interpretations I and I− are extended by the so far unconsidered literals in ∆ and ∆− appearing in the new C-rule rnew(S ,S\n′). Note that from S ′ being a state structure we get that ∆ and ∆− are distinct. A requirement for considering rnew(S ,S ′) as next C-rule is that it is active under the current interpretation I , expressed by Condition (iv). Moreover, rnew(S ,S ′) must be satisfied and still be active under the succeeding interpretation, as required by Condition (v). The final condition ensures that the unfounded sets of the successor are extensions of the previously unfounded sets that are not externally supported by the new rule.\nHere, it is interesting that only extended previous unfounded sets can be unfounded sets in the extended C-program P ′ and that rnew(S ,S ′) is the only C-rule which could provide external support for them in P ′ with respect to the new interpretation I ′ as seen next.\nTheorem 1 Let S be a state and S ′ a successor of S , where ∆ = IS ′ \\ IS . Moreover, let X ′ be a set of literals with ∅ ⊂ X ′ ⊆ IS ′ . Then, the following statements are equivalent:\n(i) X ′ is unfounded in PS ′ with respect to IS ′ . (ii) X ′ = ∆′ ∪ X , where ∆′ ⊆ ∆, X ∈ ΥS , and rnew(S ,S ′) is not an external\nsupport for X ′ with respect to IS ′ .\nThe result shows that determining the unfounded sets in a computation after adding a further C-rule r can be done locally, i.e., only supersets of previously unfounded sets can be unfounded sets, and if such a superset has some external support then it is externally supported by r . The result also implies that the successor relation suffices to “step” from one state to another.\nCorollary 2 Let S be a state and S ′ a successor of S . Then, S ′ is a state."
    }, {
      "heading" : "Proof",
      "text" : "We show that the Conditions (i), (ii), and (iii) of Definition 15 hold for S ′. Consider some rule r ∈ PS ′ . In case r = rnew(S ,S ′), IS ′ |= B(r) and IS ′ |=∃ H(r) hold because of Item (v) of Definition 17 and Dr ⊆ DS ′ because of Item (iii) of the same definition. Moreover, in case r 6= rnew(S ,S ′), we have r ∈ PS . As S is a state, we have Dr ⊆ DS . Hence, since DS ⊆ DS ′ also Dr ⊆ DS ′ . Note that IS ′ |Dr = IS |Dr because of Item (ii) of Definition 17. Therefore, as IS |= B(r) and IS |=∃ H(r), also IS ′ |= B(r) and IS ′ |=∃ H(r). From these two cases, we see that Conditions (i) and (ii) of Definition 15 hold for S ′. Finally, Condition (iii) follows from Item (vi) of Definition 17 and Theorem 1.\nNext, we define computations based on the notion of a state.\nDefinition 18 A computation is a sequence C = S0, . . . ,Sn of states such that Si+1 is a successor of Si , for all 0 ≤ i < n. We call C rooted if S0 is the empty state and stable if each Si is stable, for 0 ≤ i ≤ n."
    }, {
      "heading" : "3.3 Properties",
      "text" : "We next define when a computation has failed, gets stuck, is complete, or has succeeded. Intuitively, failure means that the computation reached a point where no answer set of the C-program can be reached. A computation is stuck when the last state activated rules deriving literals that are inconsistent with previously chosen active rules. It is considered complete when there are no more unconsidered active rules. Finally, a computation has succeeded if an answer set has been reached.\nDefinition 19 Let P be a C-program and C = S0, . . . ,Sn a computation such that PSn ⊆ P . Then, C is called a computation for P . Moreover,\n• C has failed for P at step i if there is no answer set I of P such that ISi ⊆ I , I−Si ∩ I = ∅, and PSi ⊆ P I ; • is complete for P if for every rule r ∈ P ISn , we have r ∈ PSn ; • is stuck in P if it is not complete for P but there is no successor Sn+1 of Sn\nsuch that rnew(Sn ,Sn+1) ∈ P ; • succeeded for P if it is complete and Sn is stable.\nExample 2 Let PEx2 be the C-program consisting of the C-rules\nr1 : a ← 〈{a, b}, {∅, {a, b}}〉 r2 : b ← a r3 : a ← b r4 : 〈{c}, {∅, {c}}〉 ← r5 : ← c\nthat has {a, b} as its single answer set, and consider the sequences • C1 =〈∅, ∅, ∅, {∅}〉,\n〈{r4}, {}, {c}, {∅}〉, 〈{r4, r1}, {a, b}, {c}, {{a}, {b}}〉,\n• C2 =〈∅, ∅, ∅, {∅}〉, 〈{r4}, {}, {c}, {∅}〉, 〈{r4, r1}, {a, b}, {c}, {{a}, {b}}〉, 〈{r4, r1, r2}, {a, b}, {c}, {{a}}〉, 〈{r4, r1, r2, r3}, {a, b}, {c}, {∅}〉, • C3 =〈{r4, r1, r2, r3}, {a, b}, {c}, {∅}〉, • C4 =〈∅, ∅, ∅, {∅}〉, 〈{r4}, {c}, ∅, {∅}〉, • C5 =〈{r4, r1, r2, r3}, {a, b, c}, ∅, {∅}〉, • C6 =〈{r5}, ∅, {c}, {∅}〉, and • C7 =〈∅, ∅, ∅, {∅}〉, 〈{r4, r1}, {a, b}, {c}, {{a}, {b}}〉·\nC1, C2, C3, C4, and C5 are computations for PEx2. The sequence C6 is not a computation, as 〈{r5}, ∅, {c}, {∅}〉 is not a state. C7 is not a computation, as the second state in C7 is not a successor of the empty state. C1, C2, and C4 are rooted. C3, C4, and C5 are stable. C2 and C3 are complete and have succeeded for PEx2. C1 is complete for PEx2 \\{r2, r3} but has failed for PEx2 \\{r2, r3} at Step 0 because PEx2 \\ {r2, r3} has no answer set. C4 has failed for PEx2 at Step 1. C5 has failed for PEx2 at Step 0 and is stuck in PEx2.\nThe following result guarantees the soundness of our framework of computations.\nTheorem 2 Let P be a C-program and C = S0, . . . ,Sn a computation that has succeeded for P . Then, ISn is an answer set of P ."
    }, {
      "heading" : "Proof",
      "text" : "As C is complete for P , we have P ISn ⊆ PSn . Conversely, we have PSn ⊆ P ISn because for each r ∈ PSn we have r ∈ P and ISn |= B(r). By stability of Sn , we get that ISn ∈ AS(PSn ). The conjecture holds since then ISn ∈ AS(P ISn ).\nThe computation model is also complete in the following sense:\nTheorem 3 Let S0 be a state, P a C-program with PS0 ⊆ P , and I an answer set of P with IS0 ⊆ I and I ∩ I−S0 = ∅. Then, there is a computation S0, . . . ,Sn that has succeeded for P such that PSn = P I and ISn = I .\nAs the empty state, 〈∅, ∅, ∅, {∅}〉, is trivially a state, we can make the completeness aspect of the previous result more apparent in the following corollary:\nCorollary 3 Let P be a C-program and I ∈ AS(P). Then, there is a rooted computation S0, . . . ,Sn that has succeeded for P such that PSn = P I and ISn = I ."
    }, {
      "heading" : "Proof",
      "text" : "The claim follows immediately from Theorem 3 in case S0 = 〈∅, ∅, ∅, {∅}〉.\nNote, that there are states that do not result from rooted computations, e.g., the state 〈{a ← b}, {a, b}, ∅, {∅, {a, b}, {b}}〉 is not a successor of any other state. However, for stable states, we can guarantee the existence of rooted computations.\nCorollary 4 Let S be a stable state. Then, there is a rooted computation S0, . . . ,Sn with Sn = S ."
    }, {
      "heading" : "Proof",
      "text" : "The result is a direct consequence of Corollary 3 and Definition 16.\nThe next theorem lays the ground for the jumping technique that we introduce in Section 4. It allows for extending a computation by considering multiple rules of a program at once and using ASP solving itself for creating this extension.\nTheorem 4 Let P be a C-program, C = S0, . . . ,Sn a computation for P , P ′ a set of C-rules with P ′ ⊆ P , and I an answer set of PSn ∪P ′ with ISn ⊆ I and I ∩ I−Sn = ∅. Then, there is a computation C ′ = S0, . . . ,Sn ,Sn+1, . . . ,Sm for P , such that Sm is stable, PSm = PSn ∪ P ′I and ISm = I ."
    }, {
      "heading" : "Proof",
      "text" : "By Theorem 3, as PSn ⊆ PSn ∪P ′, ISn ⊆ I , and I ∩I−Sn = ∅, there is a computation Sn , . . . ,Sm that has succeeded for PSn ∪ P ′ such that PSm = (PSn ∪ P ′)I and ISm = I . Then, Sm is stable and, as PSn\nI = PSn , we have PSm = PSn ∪ P ′I . As PSm ⊆ P , we have that C ′ = S0, . . . ,Sn ,Sn+1, . . . ,Sm is a computation for P .\nThe following result illustrates that the direction one chooses for building up a certain interpretation, i.e., the order of the rules considered in a computation, is irrelevant in the sense that eventually the same state will be reached.\nProposition 1 Let P be a C-program and C = S0, . . . ,Sn and C ′ = S ′0, . . . ,S ′ m computations complete for P such that S0 = S ′ 0. Then, ISn = IS ′m iff Sn = S ′ m and n = m."
    }, {
      "heading" : "Proof",
      "text" : "The “if” direction is trivial. Let I = ISn = IS ′m . Towards a contradiction, assume PSn 6= PS ′m . Without loss of generality, we focus on the case that there is some r ∈ PSn such that r 6∈ PS ′m . Then, it holds that I |= r , I |= B(r), and r ∈ P . Consequently, r ∈ P I . By completeness of C ′, we have r ∈ PS ′m which contradicts our assumption. Hence, we have PSn = PS ′m .\nBy definition of a state, from ISn = IS ′m and PSn = PS ′m , it follows that ΥSn = ΥS ′m . Towards a contradiction, assume I − Sn 6= I−S ′m . Without loss of generality we focus on the case that there is some a ∈ I−Sn such that a 6∈ I−S ′m . Consider the integer i where 0 < i ≤ n such that a ∈ I−Si but a 6∈ I−Si−1 . Then, by definition of a successor, for r = rnew(Si−1,Si), we have a ∈ ∆− for some ∆− ⊆ Dr . As then a ∈ Dr and, as PSn = PS ′m , we have r ∈ PS ′m , it must hold that a ∈ DS ′m by definition of a state structure. From I ∩ I−Sn = ∅ we know that a 6∈ I . Therefore, since a ∈ I ∪ I−S ′m , we get that a ∈ I−S ′m , being a contradiction to our assumption. As then Sn = S ′ m , PS0 = PS ′0 , and since in every step in a computation exactly one rule is added it must hold that n = m.\nFor rooted computations, the domain of each state is determined by the atoms\nin the C-rules it contains.\nProposition 2 Let C = S0, . . . ,Sn be a rooted computation. Then, ISi = ISn |DPSi and I − Si = I−Sn |DPSi , for all 0 ≤ i ≤ n."
    }, {
      "heading" : "Proof",
      "text" : "The proof is by contradiction. Let j be the smallest index with 0 ≤ j ≤ n such that ISj 6= ISn |DPSj or I − Sj 6= I−Sn |DPSj . Note that 0 < j as IS0 = I − S0 = DPS0 = ∅. As Sj is a successor of Sj−1, we have ISj = ISj−1 ∪∆ and I−Sj = I−Sj−1 ∪∆−, where ∆,∆− ⊆ Drnew(Sj−1,Sj ), DSj−1 ∩ (∆ ∪∆−) = ∅, and Drnew(Sj−1,Sj ) ⊆ ISj ∪ I−Sj . As we have ISj−1 = ISn |DPSj−1 and I − Sj−1 = I − Sn |DPSj−1 , it holds that\nISj−1 ∪ ISn |Dδ = ISn |DPSj−1 ∪ ISn |Dδ = ISn |DPSj and I−Sj−1 ∪ I−Sn |Dδ = I−Sn |DPSj−1 ∪ I − Sn |Dδ = I−Sn |DPSj ,\nwhere Dδ = DPSj \\ DPSj−1 . For establishing the contradiction, it suffices to show that ISn |Dδ = ∆ and I−Sn |Dδ = ∆−. Consider some a ∈ ∆. Then, a ∈ Dδ because a ∈ Drnew(Sj−1,Sj ), DSj−1 ∩ (∆ ∪∆−) = ∅, and DPSj−1 ⊆ DSj−1 . Moreover, a ∈ ISj implies a ∈ ISn and therefore ∆ ⊆ ISn |Dδ . Now, consider some b ∈ ISn |Dδ . As Drnew(Sj−1,Sj ) ⊆ ISj ∪ I−Sj , we have b ∈ ISj ∪ I−Sj . Consider the case that b ∈ I−Sj . Then, also b ∈ I−Sn which is a contradiction to b ∈ ISn as Sn is a state structure. Hence, b ∈ ISj = ISj−1 ∪∆. First, assume b ∈ ISj−1 . This leads to a contradiction as then b ∈ DPSj−1 since ISj−1 = ISn |DPSj−1 . It follows that b ∈ ∆ and therefore ∆ = ISn |Dδ . One can show that ∆− = I−Sn |Dδ analogously."
    }, {
      "heading" : "3.4 Stable Computations",
      "text" : "In this section, we are concerned with the existence of stable computations, i.e., computations that do not involve unfounded sets. We single out an important class of C-programs for which one can solely rely on this type of computation and also give examples of C-programs that do not allow for succeeding stable computations.\nIntuitively, the ΣP2 -hardness of the semantics (cf. Pührer 2014), demands for unstable computations in the general case. This becomes obvious when considering that for a given C-program one could guess a candidate sequence C for a stable computation in polynomial time. Then, a polynomial number of checks whether each state is a successor of the previous one in the sequence suffices to establish whether C is a computation. Following Definition 17, these checks can be done in polynomial time when we are allowed to omit Condition (vi) for unfounded sets. Hence, answer-set existence for the class of C-programs for which every answer set can be built up with stable computations is in NP.\nNaturally, it is interesting whether there are syntactic classes of C-programs for which we can rely on stable computations only. It turns out that many syntactically simple C-programs already require the use of unfounded sets.\nExample 3\nConsider C-program PEx3 consisting of the C-rules\nr1 : a ← b and r2 : b ← 〈{a}, {∅, {a}}〉·\nWe have that {a, b} is the only answer set of PEx3 and C =〈∅, ∅, ∅, {∅}〉, 〈{r2}, {a, b}, ∅, {∅, {a}}〉, 〈{r2, r1}, {a, b}, ∅, {∅}〉\nis the only computation that succeeds for PEx3: starting at the empty state, only rule r2 is active, thus it must be the new rule in the successor. When, deciding the truth values for the atoms in Dr2 , r2 requires b to be positive, and a must be true as well, as otherwise the computation is stuck due to violation of r1. The second state of C contains the singleton {a} as unfounded set. As Example 3 shows, unstable computations are already required for a C-program without disjunction and a single monotone C-atom. Hence, also the use of weaker restrictions, like convexity of C-atoms or some notion of head-cycle freeness (BenEliyahu and Dechter 1994), is not sufficient.\nOne can observe, that the C-program from the example has cyclic positive dependencies between atoms a and b. Hence, we next explore whether such dependencies influence the need for computations that are not stable. To this end, we introduce notions of positive dependency in a C-program.\nDefinition 20 Let S be a set of C-literals. Then, the positive normal form of S is given by\nS+ = {A | A ∈ S ,A is a C-atom} ∪ {Ā | not A ∈ S}, where Ā = 〈DA, 2DA \\ CDA〉 is the complement of A. Furthermore, the set of positive atom occurrences in S is given by posOcc(S ) = ⋃ A∈S+,X∈CA X .\nLet P be a C-program. The positive dependency graph of P is the directed graph\nG(P) = 〈DP , {〈a, b〉 | r ∈ P , a ∈ posOcc(H(r)), b ∈ posOcc(B(r))}〉· We next introduce the notion of absolute tightness for describing C-programs without cyclic positive dependencies after recalling basic notions of graph theory. For a (directed) graph G = 〈V ,≺〉, the reachability relation of G is the transitive closure of ≺. Let ≺′ be the reachability relation of G . Then, G is acyclic if there is no v ∈ V such that v ≺′ v . Definition 21 Let P be a C-program. P is absolutely tight if G(P) is acyclic.\nOne could assume that absolute tightness paired with convexity or monotonicity is sufficient to guarantee stable computations because absolute tightness forbids positive dependencies among disjuncts and the absence of such dependencies lowers the complexity of elementary C-programs (Ben-Eliyahu and Dechter 1994). However, as the following example illustrates, this is not the case for general C-programs.\nExample 4 Consider C-program PEx4 consisting of the C-rules\nr1 : a ∨ 〈{a, b}, {{a}, {a, b}}〉 ← r2 : b ∨ 〈{a, b}, {{b}, {a, b}}〉 ←\nWe have that {a, b} is the only answer set of PEx4 and C1 =〈∅, ∅, ∅, {∅}〉,\n〈{r1}, {a, b}, ∅, {∅, {b}}〉, 〈{r1, r2}, {a, b}, ∅, {∅}〉 and\nC2 =〈∅, ∅, ∅, {∅}〉, 〈{r2}, {a, b}, ∅, {∅, {a}}〉, 〈{r1, r2}, {a, b}, ∅, {∅}〉\nare the only computations that succeed for PEx4. Clearly, PEx4 is monotone and absolutely tight but C1 and C2 are not stable.\nNevertheless, we can assure the existence of stable computations for answer sets of normal C-programs that are absolutely tight and convex. This is good news, as this class corresponds to a large subset of typical answer-set programs written for solvers like Clasp that do not rely on disjunction as their guessing device.\nTheorem 5 Let C = S0, . . . ,Sn be a computation such that S0 and Sn are stable and P∆ = PSn \\ PS0 is a normal, convex, and absolutely tight C-program. Then, there is a stable computation C′=S ′0, . . . ,S ′ n such that S0 = S ′ 0 and Sn = S ′ n .\nAs a direct consequence of Theorem 5 and Corollary 3, we get an improved completeness result for normal convex C-programs that are absolutely tight, i.e., we can find a computation that consists of stable states only.\nCorollary 5 Let P be a normal C-program that is convex and absolutely tight, and consider some I ∈ AS(P). Then, there is a rooted stable computation S0, . . . ,Sn such that PSn = P I and ISn = I ."
    }, {
      "heading" : "Proof",
      "text" : "From I ∈ AS(P), we get by Corollary 3 that there is a rooted computation S0, . . . ,Sn such that PSn = P I and ISn = I . Note that S0 is the empty state. S0 and Sn are stable according to Definition 16. From Theorem 5, we can conclude the existence of another computation C′= S ′0, . . . ,S ′ n such that S0 = S ′ 0 and Sn = S ′ n that is stable. Clearly, C ′ is also rooted."
    }, {
      "heading" : "4 Theory and Practice of Stepping",
      "text" : "In this section we present our methodology for stepping answer-set programs based on the computation model introduced in the previous section.\nStep-by-step execution of a program is common practice in procedural programming languages, where developers can debug and investigate the behaviour of their programs in an incremental way. The technique introduced in this work shows how this popular form of debugging can be applied to ASP, despite the genuine declarative semantics of answer-set programs that lacks a control flow. Its main application\nis debugging but it is also beneficial in other contexts such as improving the understanding of a given answer-set program or teaching the answer-set semantics to beginners.\nFor stepping to be a practical support technique for answer-set programmers rather than a purely theoretical approach, we assume the availability of a support environment that assists a user in a stepping session. A prototype our stepping framework has been implemented in SeaLion, an integrated development environment (IDE) for ASP (Oetsch et al. 2013). It was developed as one of the major goals of a research project on methods and methodologies for developing answerset programs conducted at Vienna University of Technology (2009-2013). SeaLion supports the ASP languages of Gringo and DLV and comes as a plugin of the Eclipse platform that is popular for Java development. All the features of a stepping support environment described in this section are implemented in SeaLion, if not stated otherwise.\nTo bridge the gap between theory and practical stepping, our examples use solver syntax rather than the abstract language of c-programs. We implicitly identify solver constructs with their abstract counterparts (cf. Section 2.3). While we use c-programs as a formal lingua franca for different solver languages, we do not require the user to know about it. Likewise, we do not expect a user to be aware of the specifics of the computation framework of Section 3 that provides the backbone of stepping. For example, the user does not need to know the properties of Definition 17. The debugging environment automatically restricts the available choices a user has when performing a step to ones that result in valid successor states.\nIn the following subsection, we introduce an example scenario that we use later on. In Section 4.2, we describe the general idea of stepping for ASP. There are two major ways for navigating in a computation in our framework: performing steps, discussed in Section 4.3, and jumps that we describe in Section 4.4. In Section 4.5, we describe the stepping interface of SeaLion. Building on steps and jumps, we discuss methodological aspects of stepping for debugging purposes in Section 4.6 and provide a number of use cases."
    }, {
      "heading" : "4.1 Example Scenario - Maze Generation",
      "text" : "Next, we introduce the problem of maze generation that serves as a running example in the remainder of the paper. It has been a benchmark problem of the second ASP competition (Denecker et al. 2009) to which it was submitted by Martin Brain. The original problem description is available on the competition’s website.2\nAs the name of the problem indicates, the task we deal with is to generate a maze, i.e., a labyrinth structure in a grid that satisfies certain conditions. In particular, we deal with two-dimensional grids of cells where each cell can be assigned to be either an empty space or a wall. Moreover, there are two (distinct) empty squares on the edge of the grid, known as the entrance and the exit. A path is a finite sequence of\n2 http://dtai.cs.kuleuven.be/events/ASP-competition/Benchmarks/MazeGeneration.shtml\ncells, in which each distinct cell appears at most once and each cell is horizontally or vertically adjacent to the next cell in the sequence.\nSuch a grid is a valid maze if it meets the following criteria:\n1. Each cell is a wall or is empty. 2. There must be a path from the entrance to every empty cell (including the\nexit).\n3. If a cell is on any of the edges of the grid, and is not an entrance or an exit,\nit must contain a wall.\n4. There must be no 2x2 blocks of empty cells or walls. 5. No wall can be completely surrounded by empty cells. 6. If two walls are diagonally adjacent then one or other of their common neigh-\nbours must be a wall.\nThe maze generation problem is the problem of completing a two-dimensional grid in which some cells are already decided to be empty or walls and the entrance and the exit are pre-defined to a valid maze. An example of a problem instance and a corresponding solution maze is depicted in Fig. 1.\nNext, we describe the predicate schema that we use for ASP maze generation encodings. The predicates col/1 and row/1 define the columns and rows in the grid, respectively. They are represented by a range of consecutive, ascending integers, starting at 1. The positions of the entrance and the exit are determined by predicates entrance/2 and exit/2, respectively, where the first argument is a column index and the second argument is a row index. In a similar manner, empty/2 and wall/2 determine which cells are empty or contain walls. For example, the instance of Fig. 1 can be encoded by program Π1 consisting of the following facts:\ncol(1..5). row(1..5). entrance(1,2). exit(5,4). wall(3,3). empty(3,4).\nMoreover, the solution in the figure could be represented by the following interpretation (projected to predicates empty/2 and wall/2):\n{wall(1,1), empty(1,2), wall(1,3), wall(1,4), wall(1,5),\nwall(2,1), empty(2,2), empty(2,3), empty(2,4), wall(2,5), wall(3,1), wall(3,2), wall(3,3), empty(3,4), wall(3,5), wall(4,1), empty(4,2), empty(4,3), empty(4,4), wall(4,5), wall(5,1), wall(5,2), wall(5,3), empty(5,4), wall(5,5)}"
    }, {
      "heading" : "4.2 General Idea",
      "text" : "We introduce stepping for ASP as a strategy to identify mismatches between the intended semantics of an answer-set program under development and its actual semantics. Due to the declarativity of ASP, once one detects unintended semantics, it can be a tough problem to manually detect the reason. Stepping is a method for breaking this problem into smaller parts and structuring the search for an error. The general idea is to monotonically build up an interpretation by, in each step, adding literals derived by a rule that is active with respect to the interpretation obtained in the previous step. The process is interactive in the sense that at each such step the user chooses the active rule to proceed with and decides which literals of the rule should be considered true or false in the target interpretation. Hereby, the user only adds rules he or she thinks are active in an expected or an unintended actual answer set. The interpretation grows monotonically until it is eventually guaranteed to be an answer set of the overall program, otherwise the programmer is informed why and at which step something went wrong. This way, one can in principle without any backtracking direct the computation towards the interpretation one has in mind. In debugging, having the programmer in the role of an oracle is a common scenario as it is reasonable to assume that a programmer has good intuitions on where to guide the search (Shapiro 1982). We use the computation model of Section 3 to ensure that, if the interpretation specified in this way is indeed an answer set, the process of stepping will eventually terminate with the interpretation as its result. Otherwise, the computation will fail at some step where the user gets insight why the interpretation is not an answer set, e.g., when a constraint becomes irrevocably active or no further rule is active that could derive some desired literal."
    }, {
      "heading" : "4.3 Steps",
      "text" : "By a step we mean the extension of a computation by a further state. We consider a setting, where a programmer has written an answer-set program in a solver language for which C-program P it the abstraction of its grounding. Moreover, we assume that the programmer has obtained some computation for P that is neither stuck in P nor complete for P . For performing a step, one needs to find a successor state Sn+1 for Sn such that C ′ = S0, . . . ,Sn+1 is a computation for P .\nWe propose a sequence of three user actions to perform a step. Intuitively, for quickly finding a successor state (with the help of the debugging environment), we suggest to\n1. select a non-ground rule with active ground instances, then\n2. choose an active ground rule among the instances of the non-ground rule, and\n3. select for yet undefined atoms in the domain of the ground instance whether\nthey are considered true or false.\nFirst, the user selects a non-ground rule ρ. In SeaLion, this can be done by directly selecting ρ in the editor in which the program was written. The debugging system can support this user action by automatically determining the subset of rules in the program that have at least one instance r in their grounding that could lead to a successor state, i.e., r = rnew(Sn ,S ) for some successor S of Sn .\nThen, the user selects an instance r from the grounding of ρ. As the ground instances of ρ are not part of the original program, picking one requires a different approach as for choosing ρ. Here, the debugging environment can display the ground rules in a dedicated area and, as before, restrict the choice of rule groundings of ρ to ones that lead to a successor state. Filtering techniques can be used to restrict the amount of the remaining instances. In SeaLion, the user defines partial assignments for the variables in ρ that determine a subset of the considered instances.\nIn the third user action for performing a step, the programmer chooses the truth values for the atoms in Dr that are neither in ISn nor in I − Sn . This choice must be made in a way such that there is a successor Sn+1 of Sn with PSn+1 = PSn ∪ {r}, ISn+1 = ISn∪∆, and I−Sn+1 = I−Sn∪∆−, where ∆ contains the atoms the user chose to be true and ∆− the atoms considered false. That is, Sn , ∆, and ∆− must fulfil the conditions of Definition 17. Here, the user needs only to ensure that Condition (v) of Definition 17 holds, i.e., ISn+1 |= B(r) and ISn+1 |=∃ H(r), as the other conditions automatically hold once all unassigned atoms have been assigned to ∆ and ∆−. In particular, the set of unfounded sets, ΥSn+1 can always be automatically computed following Condition (vi) of Definition 17 and does not impose restrictions on the choice of ∆ and ∆−. The support system can check whether Condition (v) holds for the truth assignment specified by the user. Also, atoms are automatically assigning to ∆ or ∆− whenever their truth values are the same for all successor states that are based on adding r .\nExample 5 As a first step for developing the maze-generation encoding, we want to identify border cells and guess an assignment of walls and empty cells. Our initial program is Π2, given next.\nmaxCol(X) :- col(X), not col(X+1). maxRow(Y) :- row(Y), not row(Y+1). border(1,Y) :- col(1), row(Y). border(X,1) :- col(X), row(1). border(X,Y) :- row(Y), maxCol(X). border(X,Y) :- col(X), maxRow(Y).\nwall(X,Y) :- border(X,Y), not entrance(X,Y), not exit(X,Y). { wall(X,Y) : col(X), row(Y), not border(X,Y) }. empty(X,Y) :- col(X), row(Y), not wall(X,Y).\nThe first two rules extract the numbers of columns and rows of the maze from the\ninput facts of predicates col/1 and row/1. The next four rules derive border/2 atoms that indicate which cells form the border of the grid. The final three rules derive wall/2 atoms for border cells except entrance and exit, guess wall/2 atoms for the remaining cells, and derive empty/2 atoms for non-wall cells, respectively.\nWe use Π2 in conjunction with the facts in program Π1 (defined in Section 4.1)\nthat determine the problem instance.\nWe start a stepping session with the computation C0 = S0 consisting of the empty state S0 = 〈∅, ∅, ∅, {∅}〉. Following the scheme of user actions described above for performing a step, we first look for a non-ground rule with instances that are active under IS0 . As IS0 = ∅, only the facts from Π1 have active instances. We choose the rule entrance(1,2). In this case, the only (active) instance of the rule is identical to the rule, i.e., the fact:\nentrance(1,2).\nThe only atom in the domain of the rule instance is entrance(1,2). Therefore, when performing the final user action for a step one has to decide the truth value of this atom. In order to fulfil Condition (v) of Definition 17, the rule head, i.e., entrance(1,2), must be true in the successor state. Thus, our first step results in the computation C1 = S0,S1 where\nS1 = 〈{entrance(1,2).}, {entrance(1,2)}, ∅, {∅}〉· For the next step, we choose the rule\ncol(1..5).\nfrom Π1. The grounding 3 by Gringo consists of the following instances:\ncol(1). col(2). col(3). col(4). col(5).\nWe select the instance col(5). Since the head of the rule must be true under the successor state, as before, atom col(5) must be considered true in the successor state of S1. The resulting computation after the second step is C2 = S0,S1,S2, where\nS2 = 〈{entrance(1,2).col(5).}, {entrance(1,2), col(5)}, ∅, {∅}〉· Under IS2 a further rule in Π1 ∪Π2 has active instances:\nmaxCol(X) :- col(X), not col(X+1).\nThat is, it has the active instance\nmaxCol(5) :- col(5), not col(6).\nthat we choose for the next step. In order to ensure that Condition (v) of Definition 17 is satisfied, we need to ensure that head and body are satisfied under the successor state. Hence, atom maxCol(5) has to be considered true, whereas col(6) must be considered false. We obtain the computation C3 = S0,S1,S2,S3, where\nS3 = 〈{entrance(1,2).col(5).maxCol(5) :- col(5), not col(6).}, {entrance(1,2), col(5), maxCol(5)}, {col(6)}, {∅}〉·\n3 Remember that grounding refers to the translation performed by the grounding tool rather than mere variable elimination."
    }, {
      "heading" : "4.4 Jumps",
      "text" : "If one wants to simulate the computation of an answer set I in a stepping session using steps only, as many steps are necessary as there are active rules in the grounding under I . Although, typically the number of active ground instances is much less than the total number of rules in the grounding, still many rules would have to be considered. In order to focus on the parts of a computation that the user is interested in, we introduce a jumping technique for quickly considering rules that are of minor interest, e.g., for rules that are already considered correct. We say that we jump through these rules. By performing a jump, we mean to find a state that could be reached by a computation for the program at hand that extends the current computation by possibly multiple states. If such a state can be found, one can continue to expand a computation from that while it is ensured that the same states could be reached by using steps only. Jumps can be performed exploiting Theorem 4. In essence, jumping is done as follows.\n1. Select rules that you want to jump through (i.e., the rules you want to be\nconsidered in the state to jump to),\n2. an auxiliary answer-set program is created that contains the selected rules\nand the active rules of the current computations final state, and\n3. a new state is computed from an answer set of the auxiliary program.\nNext, we describe the items in more detail. We assume that an answer-set program in a solver language for which C-program P it the abstraction of its grounding and a computation S0, . . . ,Sn for P are given.\nThe first user action is to select a subset P ′ of P , the rules to jump through. Hence, an implication for a stepping support environment is the necessity of means to select the ground instances that form P ′. In case the user wants to consider all instances of some non-ground rules, a very user friendly way of selecting these is to simply select the non-ground rules and the environment implicitly considers P ′ to be their instances. SeaLion implements this feature such that this selection can be done in the editor in which the answer-set program is written. If the user wants to jump through only some instances of a non-ground rule, we need further user-interface features. In order to keep memory resources and the amount of rules that have to be considered by the user low, the system splits the selection of an instance in two phases. First, the user selects a non-ground rule ρ, similar as in the first user action of defining a step. Then, the system provides so far unconsidered rules of P for selection, where similar filtering techniques as sketched for the second user action for performing a step can be applied.\nThe auxiliary program of the second item can be automatically computed. That\nis a C-program Paux given by Paux = PSn ∪ P ′ ∪ Pcon, where Pcon ={← not a | a ∈ ISn} ∪ {← a | a ∈ I−Sn} is a set of constraints that ensure that for every answer set I of Paux we have ISn ⊆ I and I ∩ I−Sn = ∅. After computing an answer set I of the auxiliary program, Theorem 4 ensures\nthe existence of a computation C ′ = S0, . . . ,Sn ,Sn+1, . . . ,Sm for P such that Sm is stable and ISm = I . Moreover, we have PSm = PSn ∪ P ′I . Then, the user can proceed with further steps or jumps extending the computation S0, . . . ,Sm as if Sm had been reached by steps only.\nNote that non-existence of answer sets of the auxiliary program does not imply\nthat the overall program has no answer sets as shown next.\nExample 6 Consider a program P consisting of the C-rules a ← and ← not a that has {a} as its unique answer set. Assume we want to jump through the second rule starting from the computation C = 〈∅, ∅, ∅, {∅}〉 consisting of the empty state. Then, Paux = {← not a} has no answer set.\nThe example shows that jumping only makes sense when the user is interested in a computation reaching an answer set of the auxiliary program. In case of multiple answer sets of the auxiliary program, the user could pick any or a stepping environment can choose one at random. For practical reasons, the second option seems more preferable. On the one hand, presenting multiple answer sets to the user can lead to a large amount of information that has to be stored and processed by the user. And on the other hand, if the user is not happy with the truth value of some atoms in an arbitrary answer set of the auxiliary program, he or she can use steps to define the truth of these atoms before performing the jump. In SeaLion only one answer set of the auxiliary program is computed.\nThe iterative extension of a computation using steps and jumps can be described as a stepping cycle that is depicted in Fig. 2. It summarises how a user may advance a computation and thus provides a technical level representation of stepping.\nExample 7 We continue computation C3 for program Π1 ∪ Π2 from Example 5. As we are interested in the final three rules of Π2 that derive empty/2 and wall/2 atoms but these rules depend on atoms of predicate border/2, entrance/2, and exit/2 that are not yet considered in C3, we jump through the facts from Π1 and the rules\nmaxCol(X) :- col(X), not col(X+1). maxRow(Y) :- row(Y), not row(Y+1). border(1,Y) :- col(1), row(Y). border(X,1) :- col(X), row(1). border(X,Y) :- row(Y), maxCol(X). border(X,Y) :- col(X), maxRow(Y).\nof program Π2. The resulting auxiliary program Π3 is given by the following rules (for non-ground rules, their unconsidered instances in the grounding of Π1 ∪Π2).\nentrance(1,2). col(5). maxCol(5) :- col(5), not col(6).\ncol(1..5). row(1..5). exit(5,4). wall(3,3). empty(3,4). maxCol(X) :- col(X), not col(X+1). maxRow(Y) :- row(Y), not row(Y+1). border(1,Y) :- col(1), row(Y). border(X,1) :- col(X), row(1). border(X,Y) :- row(Y), maxCol(X). border(X,Y) :- col(X), maxRow(Y).\n:- not entrance(1,2). :- not col(5). :- not maxCol(5). :- col(6).\nThe program Π3 has the single answer set Iaux consisting of the atoms:\ncol(1), col(2), col(3), col(4), col(5), maxCol(5), row(1), row(2), row(3), row(4), row(5), maxRow(5), empty(3,4), wall(3,3), entrance(1,2), exit(5,4), border(1,1), border(2,1), border(3,1), border(4,1), border(5,1), border(1,2), border(5,2), border(1,3), border(5,3), border(1,4), border(5,4), border(1,5), border(2,5), border(3,5), border(4,5), border(5,5),\nWe obtain the new state S4 = 〈PS4 , Iaux,DPS4 \\ Iaux, {∅}〉, where PS4 consists of the following rules:\ncol(1). col(2). col(3). col(4). col(5). row(1). row(2). row(3). row(4). row(5). wall(3,3). empty(3,4). entrance(1,2). exit(5,4). maxCol(5) :- col(5), not col(6). maxRow(5) :- row(5), not row(6). border(1,1) :- col(1), row(1). border(2,1) :- col(2), row(1).\nborder(3,1) :- col(3), row(1). border(4,1) :- col(4), row(1). border(5,1) :- col(5), row(1). border(1,2) :- col(1), row(2). border(5,2) :- row(2), maxCol(5). border(1,3) :- col(1), row(3). border(5,3) :- row(3), maxCol(5). border(1,4) :- col(1), row(4). border(5,4) :- row(4), maxCol(5). border(1,5) :- col(1), row(5). border(5,1) :- row(1), maxCol(5). border(5,5) :- row(5), maxCol(5). border(1,5) :- col(1), maxRow(5). border(2,5) :- col(2), maxRow(5). border(3,5) :- col(3), maxRow(5). border(4,5) :- col(4), maxRow(5). border(5,5) :- col(5), maxRow(5).\nTheorem 4 ensures the existence of a computation C4 = S0,S1,S2, S3, . . . ,S4 for program Π1 ∪Π2.\n4.5 Stepping Interface of SeaLion\nIn the following, we focus on the stepping functionality of SeaLion that was implemented by our former student Peter Skočovský. While it is the first implementation of the stepping technique for ASP and hence still a prototype, it is tailored for intuitive and user-friendly usage and able to cope with real-world answer-set programs. The stepping feature is integrated with the Kara plugin of SeaLion (Kloimüllner et al. 2013) that can create user-defined graphical representations of interpretations. Thus, besides visualising answer sets, it is also possible to visualise intermediate states of a stepping session. Visualisations in Kara are defined using ASP itself, for further information we refer to earlier work (Kloimüllner et al. 2013). A comprehensive discussion of other features of SeaLion is given in a related paper (Busoniu et al. 2013) on the IDE. SeaLion is published under the GNU General Public License and can be obtained from www.sealion.at\nA stepping session in SeaLion can be started in a similar fashion as debugging Java programs in Eclipse using the launch configuration framework. SeaLion launch configurations that are used for defining which program files should be run with which solvers can be re-used as debug configurations.\nLike many IDEs, Eclipse comes with a multiple document interface in which inner frames, in particular Eclipse editors and views, can be arranged freely by the user. Such configurations can be persisted as perspectives. Eclipse plugins often come with default perspectives, i.e., arrangements of views and editors that are tailored to a specific user task in the context of the plugin. Also the stepping plugin has a preconfigured perspective that is opened automatically once a stepping session has\nbeen initiated. The next subsection gives an overview of the individual stepping related subframes in this perspective.\nFig. 3 shows SeaLion in the stepping perspective. The illustration distinguishes five regions (marked by supplementary dashed frames and labelled by letters) for which we give an overview in what follows.\nThe source code editor (Fig. 3a) is the same as used for writing answer-set programs but extended with additional functionality during stepping mode for the ASP files involved in the stepping session. In particular it indicates rules with ground instances that are active under the interpretation of the current stepping state. Constraints with active instances are highlighted by a red background (cf. Fig. 9), other rules with active instances have a blue background (as, e.g., in Fig. 4). The editor remains functional during stepping, i.e., the program can be modified while debugging. Note, however, that the system does not guarantee that the current computation is still a valid computation in case of a modification of the answerset program after stepping has been initiated. The source code editor is also the starting point for performing a step or a jump as it allows for directly selecting the non-ground rule(s) to be considered in the step or jump in the source code. The choice of non-ground rules corresponds to the initial step in the stepping cycle (see Section 4.4). Selecting a single rule or consecutive rules is done by directly selecting them in the source code editor. If the rules are non-consecutive, the user must collect rules in the jump view located in area c of Fig. 3 as the second tab.\nChoosing a ground instance for performing a step is done in the active instances view (Fig. 3b). It contains a list with all active ground instances (with respect to conditional grounding) of the currently selected rule in the source editor. As these are potentially many, the view has a textfield for filtering the list of rules. Filters are given as dot-separated list of variable assignments of the form X=t where X is a variable of the non-ground rule and t is the ground term that the user considers X to be assigned to. Only ground instances are listed that obey all variable substitutions of the entered filters.\nOnce a rule instance is selected in the active instances view the atoms in the rule’s domain are displayed in three lists of the truth assignment view (Fig. 3c). The list in the centre shows atoms whose truth value has not already been determined in the current state. The user can decide whether they should be true, respectively false, in the next step by putting them into the list on the left, respectively, on the right. These atoms can be transferred between the lists by using keyboard cursors or drag-and-drop (Fig. 4). After the truth value has been decided for all the atoms of the rule instance and only in case that the truth assignment leads to a valid successor state (cf. Definition 17), a button labelled “Step” appears. Clicking this button computes the new state.\nThe state view (Fig. 3d) shows the current stepping state of the debugging session. Hence, it is updated after every step or jump. It comprises four areas, corresponding to the components of the state (cf. Definition 15), the list of active rules instances, a tree-shaped representation of the atoms considered true, a tree-shaped representation of the atoms considered false, both in a similar graphical representation as that of interpretations in the interpretation view, and an area displaying the unfounded sets in a similar way. The sets of atoms displayed in this view can also be visualised using Kara (via options in the context menu).\nFinally, the computation view (Fig. 3e) gives an overview of the steps and jumps performed so far. Importantly, the view implements an undo-redo mechanism. That is, by clicking on one of the nodes displayed in the view, representing a previous step or jump, the computation can be reset to the state after this step or jump has been performed. Moreover, after performing an undo operation, the undone computation is not lost but becomes an inactive branch of the tree-shaped representation of steps and jumps. Thus, one can immediately jump back to any state that has been reached in the stepping session by clicking on a respective node in the tree (Fig. 6).\nMismatches between the users intentions (reflected in the current stepping state) and the actual semantics of the program can be detected in different parts of the stepping perspective. If the user thinks a rule instance should be active but it is not, this can already be seen in the source code editor if the non-ground version of the rule does not have any active instance. Then, the rule is not highlighted in the editor. If the non-ground version does have active instances but not the one the user has in mind, this can be detected after clicking on the non-ground rule if they are missing in the active instances view. The computation is stuck if only rules are highlighted in the source editor that are constraints (cf. Fig. 9) or for all of its instances, no truth assignment can be established such that the “Step” button appears.\nFinally, if no further rule is highlighted and there is no non-empty unfounded set visible in the state view, the atoms considered positive form an answer set of the overall program. If there are further unfounded sets, the user sees that the constructed interpretation is not stable. The unfounded sets indicate which atoms would need external support."
    }, {
      "heading" : "4.6 Methodology",
      "text" : "We identify three three conceptual levels of stepping as a methodology. The technical level corresponds to the iterative advancement of a computation covered in Sections 4.3 and 4.4 summarised in the stepping cycle (Fig. 2). Next, we describe stepping on the application level as a method for debugging and program analysis. After that, we highlight how stepping is embedded in the greater context of ASP development from a top level perspective. Finally, we illustrate our approach in different usage scenarios. In Appendix A, we compile practical guidelines for our methodology."
    }, {
      "heading" : "Program Analysis and Debugging Level Methodology",
      "text" : "The main purpose for stepping in the context of this paper is its application for debugging and analysing answer-set programs. Next, we describe how insight into a program is gained using stepping. During stepping, the user follows his or her intuitions on which rule(s) to apply next and which atoms to consider true or false. In this way, an interpretation is built up that either is or is not an answer set of the program. In both cases, stepping can be used to analyse the interplay of rules in the program in the same manner, i.e., one can see which rule instances become active or inactive after each step or jump. In the case that the targeted interpretation is an answer set of the program, the computation will never fail (in the sense of Definition 19) or get stuck and will finally succeed. It can, however, happen that intermediate states in the computation are unstable (cf. Example 3). For debugging, stepping towards an answer set is useful if the answer set is unwanted. In particular, one can see why a constraint (or a group of rules supposed to have a constraining effect) does not become active. For instance, stepping reveals other active rules that derive atoms that make some literal in the constraint false or rules that fail do derive atoms that activate the constraint. Stepping towards an actual answer set of a program is illustrated in Example 8.\nIn the case that there is an answer set that the user expects to be different, i.e., certain atoms are missing or unwanted, it makes sense to follow the approach that we recommend for expected but missing answer sets, i.e., stepping towards the interpretation that the user wants to be an answer set. Then, the computation is guaranteed to fail at some point, i.e., there is some state in the computation from which no more answer set of the program can be reached. In other situations, the computation can already have failed before the bug can be found, e.g., the computation can have failed from the beginning in case the program has no answer sets at all. Nevertheless, the error can be found when stepping towards the intended\ninterpretation. In most cases, there will be either a rule instance that becomes active that the user considered inactive, or the other way around, i.e., a rule instance never becomes active or is deactivated while the computation progresses. Eventually, due to our completeness results in the previous section, the computation will either get stuck or ends in an unstable state S such that no active external support for a nonempty unfounded set from ΥS is available in the program’s grounding. Stepping towards an interpretation that is not an answer set of the overall program can be seen as a form of hypothetical reasoning: the user can investigate how rules of a part of the program support each other before adding a further rule would cause an inconsistency. Example 9 illustrates stepping towards an intended but non-existing answer set for finding a bug. Another illustration of hypothetical reasoning is given in Example 10 where a user tries to understand why an interpretation that is not supposed to be an answer set is indeed no answer set.\nNote that stepping does not provide explanation artefacts, analogous to stepping in imperative languages, where insight in a problem is gained by simply following the control flow and watching variable assignments. In our setting, the user only sees which remaining rule instances are active and the current state of the computation which in principle suffices to notice differences to his or her expectations. Nevertheless, it can be useful to combine this approach with query based debugging methods that provide explicit explanations as will be discussed in Section 5.\nAs mentioned in Section 4.2, if one has a clear idea on the interpretation one expects to be an answer set, stepping allows for building up a computation for this interpretation without backtracking. In practice, one often lacks a clear vision on the truth value of each and every atom with respect to a desired answer set. As a consequence, the user may require revising the decisions he or she has taken on the truth values of atoms as well as on which rules to add to the computation. For this reason, SeaLion allows for retracting a computation to a previous state, i.e., let the user select one of the states in the computation and continue stepping from there. This way a tree of states can be built up (as in Fig. 9), where every path from the root node to a leaf node is a rooted computation."
    }, {
      "heading" : "Top-Level Methodology",
      "text" : "Stepping must be understood as embedded in the programming and modelling process, i.e., the technique has to be recognised in the context of developing answerset programs. A practical consequence of viewing stepping in the big picture are several possibilities for exploiting information obtained during the development of a program for doing stepping faster and more accurate.\nWhile an answer-set program evolves, the programmer will in many cases compute answer sets of preliminary versions of the program for testing purposes. If this answer sets are persisted, they can often be used as a starting point for stepping sessions for later versions of the program. For instance, in case the grounding P of a previous version of a program is a subset of the current grounding P ′ it is obvious that a successful computation C for P is also a computation for P ′. Hence, the user can initiate a stepping session starting from C . Also in case that P 6⊂ P ′, a\nstepping support system could often automatically build a computation that uses an answer set of P (or parts of it) as guidance for deciding on the rules to add and the truth values to assign in consecutive states. Likewise, (parts of) computations of stepping sessions for previous versions of a program can be stored and re-used either as a computation of the current program if applicable or for computing such a computation. The idea is that previous versions of a program often constitute a part of the current version that one is already familiar with and “trusts” in. By starting from a computation that already considers a well-known part of the program, the user can concentrate on new and often more suspicious parts of the program. Currently, there is no such feature implemented in SeaLion."
    }, {
      "heading" : "Use Cases",
      "text" : "Next, we show application scenarios of stepping using our running example.\nThe first scenario illustrates stepping towards an interpretation that is an answer\nset of the program under consideration.\nExample 8 We want to step towards an answer set of our partial encoding of the maze generation problem, i.e., of the program Π1 ∪ Π2. Therefore, we continue our stepping session with computation C4, i.e., we start stepping from state S4 that we obtained in Example 7. In particular, we want to reach an answer set that is compatible with the maze generation solution depicted in Fig. 1. To this end, we start with stepping through the active instances of the rule\n{wall(X,Y) : col(X), row(Y), not border(X,Y)}.\nThe only active instance of the rule is\n{wall(2,2), wall(3,2), wall(4,2), wall(2,3), wall(3,3),\nwall(4,3), wall(2,4), wall(3,4), wall(4,4)}.\nThus, we next choose a truth assignment for the atoms appearing in the instance’s choice atom. Note that we do not need to decide for the truth value of wall(3,3) as it is already contained in IS4 and therefore already considered true. As can be observed in Fig. 1, among the remaining cells the rule deals with, only the one at position (3, 2) is a wall in our example. Hence, we obtain a new state S5 from S4 by extending PS4 by our rule instance, IS4 by wall(3,2), and I − S4 by wall(2,2), wall(4,2), wall(2,3), wall(4,3), wall(2,4), wall(3,4), wall(4,4). As in S4, the empty set is the only unfounded set in state S5. It remains to jump through the rules\nwall(X,Y) :- border(X,Y), not entrance(X,Y), not exit(X,Y).\nand\nempty(X,Y) :- col(X), row(Y), not wall(X,Y).\nthat leads to the addition of instances\nwall(1, 1) :- border(1, 1), not entrance(1, 1), not exit(1, 1). wall(2, 1) :- border(2, 1), not entrance(2, 1), not exit(2, 1). wall(3, 1) :- border(3, 1), not entrance(3, 1), not exit(3, 1). wall(4, 1) :- border(4, 1), not entrance(4, 1), not exit(4, 1). wall(5, 1) :- border(5, 1), not entrance(5, 1), not exit(5, 1). wall(5, 2) :- border(5, 2), not entrance(5, 2), not exit(5, 2). wall(1, 3) :- border(1, 3), not entrance(1, 3), not exit(1, 3). wall(5, 3) :- border(5, 3), not entrance(5, 3), not exit(5, 3). wall(1, 4) :- border(1, 4), not entrance(1, 4), not exit(1, 4). wall(1, 5) :- border(1, 5), not entrance(1, 5), not exit(1, 5). wall(2, 5) :- border(2, 5), not entrance(2, 5), not exit(2, 5). wall(3, 5) :- border(3, 5), not entrance(3, 5), not exit(3, 5). wall(4, 5) :- border(4, 5), not entrance(4, 5), not exit(4, 5). wall(5, 5) :- border(5, 5), not entrance(5, 5), not exit(5, 5).\nempty(1, 2) :- col(1), row(2), not wall(1, 2). empty(2, 2) :- col(2), row(2), not wall(2, 2). empty(4, 2) :- col(4), row(2), not wall(4, 2). empty(2, 3) :- col(2), row(3), not wall(2, 3). empty(4, 3) :- col(4), row(3), not wall(4, 3). empty(2, 4) :- col(2), row(4), not wall(2, 4). empty(3, 4) :- col(3), row(4), not wall(3, 4). empty(4, 4) :- col(4), row(4), not wall(4, 4). empty(5, 4) :- col(5), row(4), not wall(5, 4).\nto a new state S6. IS6 extends IS5 by the head atoms of these rules that are not yet in IS5 . Likewise, I − S6 extends I − S5 by the default negated atoms appearing in the rules that are not yet in I−S5 . As ΥS6 = {∅} and no rule in Π1 ∪ Π2 has further active instances under IS6 , the computation S0, . . . ,S6 has succeeded and hence IS6 is an answer set of the program.\nIn the next example, a bug is revealed by stepping towards an intended answer set.\nExample 9 As a next feature, we (incorrectly) implement rules in program Π4 that should express that there has to be a path from the entrance to every empty cell and that 2× 2 blocks of empty cells are forbidden:\nadjacent(X,Y,X,Y+1) :- col(X), row(Y), row(Y+1). adjacent(X,Y,X,Y-1) :- col(X), row(Y), row(Y-1). adjacent(X,Y,X+1,Y) :- col(X), row(Y), col(X+1). adjacent(X,Y,X-1,Y) :- col(X), row(Y), col(X-1). reach(X,Y) :- entrance(X,Y), not wall(X,Y). reach(XX,YY) :- adjacent(X,Y,XX,YY), reach(X,Y), not wall(XX,YY).\n:- empty(X,Y), not reach(X,Y). :- empty(X,Y), empty(X+1,Y), empty(X,X+1), empty(X+1,Y+1).\nThe first six rules formalise when an empty cell is reached from the entrance, and the two constraints should ensure that every empty cell is reached and that no 2×2 blocks of empty cells exist, respectively.\nAssume that we did not spot the bug in the second constraint—in the third body literal the term Y+1 was mistaken for X+1. This could be the result of a typical copypaste error. It turns out that Π1 ∪ Π2 ∪ Π4 has no answer set. In order to find a reason, one can start stepping towards an intended answer set. We assume that the user already trusts the program Π1 ∪Π2 from Example 8. Hence, he or she can reuse the computation S0, . . . ,S6 for Π1∪Π2 as starting point for a stepping session because all rules in PS6 are also ground instances of rules in the extended program Π1 ∪ Π2 ∪ Π4. Then, when the user asks for rules with active ground instances a stepping support environment would present the following rules:\nadjacent(X,Y,X,Y+1) :- col(X), row(Y), row(Y+1). adjacent(X,Y,X,Y-1) :- col(X), row(Y), row(Y-1).\nadjacent(X,Y,X+1,Y) :- col(X), row(Y), col(X+1). adjacent(X,Y,X-1,Y) :- col(X), row(Y), col(X-1). reach(X,Y) :- entrance(X,Y), not wall(X,Y).\n:- empty(X,Y), not reach(X,Y). :- empty(X,Y), empty(X+1,Y), empty(X,X+1), empty(X+1,Y+1).\nThe attentive observer will immediately notice that two constraints are currently active. There is no reason to be deeply concerned about\n:- empty(X,Y), not reach(X,Y).\nbeing active because the rule defining the reach/2 predicate—that can potentially deactivate the constraint—has not been considered yet. However, the constraint\n:- empty(X,Y), empty(X+1,Y), empty(X,X+1), empty(X+1,Y+1).\ncontains only atoms of predicate empty/2 that has already been fully evaluated. Even if empty/2 was only partially evaluated, an active instance of the constraint could not become inactive in a subsequent computation for the sole ground that it only contains monotonic literals. When the user inspects the single ground instance\n:- empty(1,2), empty(2,2), empty(1,2), empty(2,3).\nof the constraint the bug becomes obvious. A less attentive observer would maybe not immediately realise that the constraint will not become inactive again. In this case, he or she would in the worst case step through all the other rules before the constraint above remains as the last rule with active instances. Then, at the latest,\none comes to the same conclusion that X+1 has to be replaced by Y+1. Moreover, a stepping environment could give a warning when there is a constraint instance that is guaranteed to stay active in subsequent states. This feature is not implemented in SeaLion. We refer to the corrected version of program Π4 by Π5.\nCompared to traditional software, programs in ASP are typically very succinct and often authored by a single person. Nevertheless, people are sometimes confronted with ASP code written by another person, e.g., in case of joint program development, software quality inspection, legacy code maintenance, or evaluation of student assignments in a logic-programming course. As answer-set programs can model complex problems within a few lines of code, it can be pretty puzzling to understand someone else’s ASP code, even if the program is short. Here, stepping can be very helpful to get insight into how a program works that was written by another programmer, as illustrated by the following example.\nExample 10 Assume that the full encoding of the maze generation encoding is composed by the programs Π2 ∪Π5 and that the constraints in Π6, given next, has been written by another author.\n:- exit(X,Y), wall(X,Y). :- wall(X,Y), wall(X+1,Y), wall(X,Y+1), wall(X+1,Y+1). :- wall(X,Y), empty(X+1;X-1,Y), empty(X,Y+1;Y-1), col(X+1;X-1),\nrow(Y+1;Y-1).\n:- wall(X,Y), wall(X+1,Y+1), not wall(X+1,Y), not wall(X,Y+1). :- wall(X+1,Y), wall(X,Y+1), not wall(X,Y), not wall(X+1,Y+1).\nNote that the guess whether a cell is a wall or empty in the program Π2∪Π5∪Π6 is realised by guessing for each non-border cell whether it is a wall or not and deriving that a cell is empty in case we do not know that it is a wall. Moreover, observe that facts of predicate empty/2 may be part of a valid encoding of a maze generation problem instance, i.e., they are a potential input of the program. As a consequence, it seems plausible that the encoding could guess the existence of a wall for a cell that is already defined to be empty by a respective fact in the program input. In particular, there is no constraint that explicitly forbids that a single cell can be empty and contain a wall. The encoding would be incorrect if it would allow for answer sets with cells that are empty and a wall according to the maze generation problem specification. However, it turns out that the answer sets of the program are exactly the intended ones. Let us find out why by means of stepping.\nReconsider the problem instance depicted in Fig. 1 that is encoded in the program Π1. It requires that cell (3, 4) is empty. If it did not, the maze shown in Fig. 7 that contains a wall at cell (3, 4) would be a valid solution. We start a stepping session for program Π1 ∪ Π2 ∪ Π5 ∪ Π6, whose code is summarised in Fig. 5, and step towards an interpretation encoding the maze of Fig. 7 to see what is happening if we consider (3, 4) to be a wall despite the presence of fact empty(3,4). We can reuse the computation C4 obtained in Example 7 whose final state S4 considers already the facts describing the input instance and the rules needed for deriving\nborder/2 atoms. As in Example 8, we continue with a step for considering the ground instance of the rule\n{wall(X,Y) : col(X), row(Y), not border(X,Y)}.\nthat guesses whether non-border cells are walls. This time, instead of choosing wall(3,2) to be true, we only add wall(3,4) to the atoms considered true. Then, for the resulting state S ′5, both empty(3,4) and wall(3,4) are contained in IS ′5 . A visualisation of IS ′5 if given in the centre of Fig. 8. In order to derive the remaining atoms of predicates empty/2 and wall/2 we then jump through the rules\nwall(X,Y) :- border(X,Y), not entrance(X,Y), not exit(X,Y). empty(X,Y) :- col(X), row(Y), not wall(X,Y).\nto obtain state S ′6, where IS ′6 is illustrated in the right subfigure of Fig. 8. Now, the user sees that constraint\n:- empty(X,Y), not reach(X,Y).\nhas active instances. This comes as no surprise as the rules defining reachability between empty cells have not been considered yet. We decide to do so now and initiate a jump through the rules\nadjacent(X,Y,X,Y+1) :- col(X), row(Y), row(Y+1). adjacent(X,Y,X,Y-1) :- col(X), row(Y), row(Y-1). adjacent(X,Y,X+1,Y) :- col(X), row(Y), col(X+1). adjacent(X,Y,X-1,Y) :- col(X), row(Y), col(X-1). reach(X,Y) :- entrance(X,Y), not wall(X,Y). reach(XX,YY) :- adjacent(X,Y,XX,YY), reach(X,Y), not wall(XX,YY).\nWe obtain the new state S ′7 and observe that under interpretation IS ′7 the constraint still has an active instance, namely\n:- empty(3,4), not reach(3,4).\nObviously, the atom reach(3,4) has not been derived in the computation. When inspecting the rules defining reach/2 it becomes clear why the answer sets of the encoding are correct: the atom reach(X,Y) is only derived for cells that do not contain walls. Consequently, whenever there is an empty cell which was guessed to contain a wall it will be considered as not reachable from the entrance. As every empty cell has to be reachable, a respective answer-set candidate will be eliminated by an instance of the constraint\n:- empty(X,Y), not reach(X,Y).\nAlthough the encoding of the maze generation problem is correct one could consider it to be not very well designed. Conceptually, the purpose of the constraint above is forbidding empty cells to be unreachable from the entrance and not forbidding them to be walls. Moreover, if one would replace the rules\nreach(X,Y) :- entrance(X,Y), not wall(X,Y). reach(XX,YY) :- adjacent(X,Y,XX,YY), reach(X,Y), not wall(XX,YY).\nby\nreach(X,Y) :- entrance(X,Y), empty(X,Y). reach(XX,YY) :- adjacent(X,Y,XX,YY), reach(X,Y), empty(XX,YY).\nwhich seem to be equivalent in the terms of the problem specification, the program would not work. A more natural encoding would be to explicitly forbid empty cells to contain walls either by an explicit constraint or a modified guess where nonborder cell is guessed to be either empty or contain a wall but not both."
    }, {
      "heading" : "5 Related Work",
      "text" : "First, we describe existing approaches for debugging answer-set programs and how they are related to the method proposed in this paper.\nThe first work devoted to debugging of answer-set programs is a paper by Brain and De Vos (2005) in which they provide general considerations on the subject, such as the discussion of error classes in the context of ASP or implications of declarativity on debugging mentioned in the previous section. They also formulated important debugging questions in ASP, namely, why is a set of atoms subset of a specific answer set and why is a set of atoms not subset of any answer set. The authors provided pseudocode for two imperative ad-hoc algorithms for answering these questions for propositional normal answer-set programs. The algorithm addressing the first question returns answers in terms of active rules that derive atoms from the given set. The algorithm for explaining why a set of atoms is not subset of any answer set identifies different sorts of answers such as atoms with no deriving rules, inactive deriving rules, or supersets of the given set in which adding further literals would lead to some inconsistency.\nThe goal of the work by Pontelli et al. (2009) is to explain the truth values of literals with respect to a given actual answer set of a program. Explanations are provided in terms of justifications which are labelled graphs whose nodes are truth assignments of possibly default-negated ground atoms. The edges represent positive and negative support relations between these truth assignments such that every path ends in an assignment which is either assumed or known to hold. The authors have also introduced justifications for partial answer sets that emerge during the\nsolving process (online justifications), being represented by three-valued interpretations. Pontelli et al. (2009) use sequences of three-valued interpretations (called computations) in which monotonously more atoms are considered true, respectively, false. The information carried in these interpretations corresponds to that of the second and third component of a state in a computation in our framework. The purpose of using computations in the two approaches differs however. While computations in stepping are used for structuring debugging process in a natural way, where the choices how to proceed remains with the user, the computations of Pontelli et al. are abstractions of the solving procedure. Their goal is to allow a solver that is compatible with their computation model to compute justifications for its intermediate results. Thus, similar to their offline versions, online justifications are non-interactive, i.e., they are computed automatically and used for post-mortem debugging. As our computation model is compatible with that for online justifications, it seems very promising to combine the two approaches in practice. While debugging information in stepping focuses on violation of rules and unfounded sets,\nour method leaves the reasons for an atom being true or false as implicit consequences of a user’s decision. Here, online justifications could keep track of the reasons for truth values at each state of a stepping session and presented to the user during debugging on demand.\nSyrjänen (2006) aimed at finding explanations why a program has no answer sets. His approach is based on finding minimal sets of constraints such that their removal yields consistency. Hereby, it is assumed that a program does not involve circular dependencies between literals through an odd number of negations which might also cause inconsistency. The author considers only a basic ASP language and hence does not take further sources of inconsistency into account, caused by program constructs of richer ASP languages, such as cardinality constraints.\nAnother early approach (Brain et al. 2007; Pührer 2007) is based on program rewritings using some additional control atoms, called tags, that allow, e.g., for switching individual rules on or off and for analysing the resulting answer sets. Debugging requests can be posed by adding further rules that can employ tags as well. That is, ASP is used itself for debugging answer-set programs. The translations needed were implemented in the command-line tool Spock (Brain et al. 2007; Gebser et al. 2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al. 2008; Pührer 2007). The technique is based on ASP meta-programming, i.e., a program over a metalanguage is used to manipulate a program over an object language (in this case, both the meta-language and the object language are instances of ASP). It addresses the question why some interpretation is not an answer set of the given program. Answers are given in terms of unsatisfied rules and unfounded loops. The approach has later been extended from propositional to disjunctive logic programs with constraints, integer arithmetic, comparison predicates, and strong negation (Oetsch et al. 2010) and also to programs with cardinality constraints (Polleres et al. 2013). It has been implemented in the Ouroboros plugin of SeaLion (Frühstück et al. 2013). Moreover, Shchekotykhin (2015) developed a method on top of the meta-programming approaches (Gebser et al. 2008; Oetsch et al. 2010) that poses questions to the user in order to find a desired problem diagnosis while keeping the amount of required interaction low.\nIn a related approach, Dodaro et al. (2015) use control atoms quite similar to that of the tagging approach (Brain et al. 2007; Pührer 2007) to identify sets of rules that lead to inconsistency of a program under the requirement that a given set of atoms is true in some intended answer set. An implementation is provided that profits from a tight integration with the ASP solver WASP (Alviano et al. 2015). In order to reduce the possible outcomes, the debugger asks the user about the intended truth of further atoms in an interactive session.\nIn another paper, Li et al. (2015) use inductive logic programming to repair answer-set programs. The idea is that the user provides examples of desired and undesired properties of answer sets such that the debugger can semi-automatically revise a faulty program. The method requires a difference metric between logic programs in order to restrict repairs to programs that have the desired properties that minimally differ from the original program. The authors propose such a measure\nin terms of number of operations required for revision. These operations are rule removal and creation as well as addition or removal of individual body literals.\nCaballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query.\nWittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree.\nBesides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers.\nWe can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set. Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence. The approach by Caballero et al. (2008) can also be seen to target a single actual answer set. Due to their focus on actual answer sets of the debugged program, these methods cannot be applied on (erroneous) programs without any answer set. The previous meta-programming based debugging technique (Gebser et al. 2008; Pührer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program. In the approach of Wittocx et al. (2009), the user can specify a class of intended semantic structures which are not preferred models of the theory at hand (corresponding to actual answer sets of the program to be debugged in ASP terminology). Syrjänen’s diagnosis technique (Syrjänen 2006) is limited to the setting when a program has no answer set at all. The same holds for the work of Dodaro et al. (2015), however the authors demonstrate how other debugging problems can be reduced to that of inconsistency. The method requires an intended answer set but offers the means to generate that in an interactive way, building on the technique by Shchekotykhin (2015). Stepping does not require actual or intended answer sets as a prerequisite, as the user can explore the behaviour of his or her program under different interpretations that may or may not be extended to answer sets by choosing different rules instances. In the interactive setting summarised in Fig. 2, where one can retract a computation to a previous state and continue stepping from there that is also implemented in SeaLion, a stepping session can thus be seen as an inspection across\narbitrary interpretations rather than an inquiry about a concrete set of actual or non-existent answer sets. Nevertheless, if one has a concrete interpretation in mind, the user is free to focus on that. The ability to explore rule applications for partial interpretations that cannot become answer sets amounts to a form of hypothetical reasoning. A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms. Here, the stepping technique can be considered more focused, as the interpretation under investigation is determined by the choices of the user in stepping but is essentially arbitrary in the tagging approach if the user does not employ explicit restrictions.\nNext, we compare the ASP languages supported by different approaches. First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules. Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrjänen 2006). The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols. The approach by Caballero et al. (2008) deals with non-ground normal programs which have to be stratified. Explicit support for variables is also given in an extension (Oetsch et al. 2010) of the meta-programming approach for disjunctive programs. It was later extended to allow for weight constraints (Polleres et al. 2013) by compiling them away to normal rules. A commonality of the previous approaches is that they target ASP languages that can be considered idealised proper subsets of current solver languages. In this respect, stepping is the first debugging approach that overcomes these limitations as the use of C-programs and abstract grounding (cf. Pührer 2014) make the framework generic enough to be applied to ASP solver languages. While this does not mean that other approaches cannot be adapted to fit a solver language, it is no always immediately clear how. For our approach, instantiating our abstractions to the language constructs and the grounding method of a solver is sufficient to have a ready-to-use debugging method.\nMost existing debugging approaches for ASP can be seen as declarative in the sense that a user can pose a debugging query, and receives answers in terms of different declarative definitions of the semantics of answer-set programs, e.g., in terms of active or inactive rules with respect to some interpretation. In particular, the approaches do not take the execution strategy of solvers into account. This also holds for our approach, however stepping and online justifications (Pontelli et al. 2009) are exceptional as both involve a generic notion of computation which adds a procedural flavour to debugging. Nonetheless, the computation model we use can be seen as a declarative characterisation of the answer-set semantics itself as it does not apply a fix order in which to apply rules to build up an answer set.\nBesides stepping, also the approaches by Wittocx et al. (2009) and Dodaro et al. (2015) as well as Shchekotykhin (2015) can be considered interactive. While in the approach of Wittocx et al. a fixed proof is explored interactively, the interaction in our method has influence on the direction of the computation. The other\nworks (Dodaro et al. 2015; Shchekotykhin 2015) use interaction for filtering the resulting debugging information. Also in further works (Brain et al. 2007; Gebser et al. 2008) which do not explicitely cover interleaved communication between user and system, user information can be used for filtering. The approaches mentioned in this paragraph realise declarative debugging in the sense of Shapiro (1982), where the user serves as an oracle for guiding the search for errors.\nIt is worth highlighting that stepping can be seen as orthogonal to the basic ideas of all the other approaches we discussed. That is, it is reasonable to have a development kit that supports stepping and other debugging methods simultaneously.\nWhile debugging is the main focus of this paper, we also consider the computation framework for disjunctive abstract constraint programs introduced in Section 3 an interesting theoretical contribution by itself. Here, an important related work is that of Liu et al. (2010), who also use a notion of computation to characterise a semantics for normal C-programs. These computations are sequences of evolving interpretations. Unlike the three-valued ones used for online justifications (Pontelli et al. 2009), these carry only information about atoms considered true. Thus, conceptionally, they correspond to sequences IS0 , IS1 , . . . where S0,S1, . . . is a computation in our sense. The authors formulate principles for characterising different variants of computations. We will highlight differences and commonalities between the approaches along the lines of some of these properties. One main structural difference between their and our notion of computation is the granularity of steps: In the approach by Liu et al. it might be the case that multiple rules must be considered at once, as required by their revision property (R’), while in our case computation proceeds rule instance by rule instance. The purpose of property (R’) is to assure that every successive interpretation must be supported by the rules active with respect to the previous interpretation. But it also requires that every active rule in the overall program is satisfied after each step, whereas we allow rule instances that were not considered yet in the computation to be unsatisfied. For the purpose of debugging, rule-based computation granularity seems favourable as rules are our primary source code artifacts. Moreover, ignoring parts of the program that were not considered yet in a computation is essential in the stepping method, as this breaks down the amount of information that has to be considered by the user at once and allows for getting stuck and thereby detect discrepancies between his or her understanding of the program and its actual semantics. Our computations (when translated as above) meet the persistence principle (P’) of Liu et al. that ensures that a successor’s interpretation is a superset of the current one. Their convergence principle (C’), requiring that a computation stabilises to a supported model, is not met by our computations, as we do not enforce support in general. However, when a computation has succeeded (cf. Definition 19), it meets this property. A further difference is that Liu et al. do not allow for non-stable computations as required by the founded persistence of reasons principle (FPr). This explains why the semantics they characterise treats non-convex atoms not in the FLP-way. Besides that, the use of non-stable computations allow us to handle disjunction. Interestingly, Liu et al. mention the support for disjunction in computations as an open challenging problem and suspect the necessity of a global minimality re-\nquirement on computations for this purpose. Our framework demonstrates that we can do without such a condition: As shown in Theorem 1, unfounded sets in our semantics can be computed incrementally “on-the-fly” by considering only the rule instance added in a step as potential new external support. Finally, the principle of persistence of reasons (Pr’) suggests that the “reason” for the truth value of an atom must not change in the course of a computation. Liu et al. identify such reasons by sets of rules that keep providing support in an ongoing computation. We have a similar principle of persistence of reasons that is however stricter as it is operates on the atom level rather than the rule level: Once a rule instance is considered in a computation in our sense, the truth value of the atoms in the rule’s domain is frozen, i.e., it cannot be changed or forgotten in subsequent steps. Persistence of reasons is also reflected in our definition of answer sets: The requirement I ′|DA = I |DA in Definition 12 that the stability of interpretation I is only spoiled by I ′ if the reason for I ′ |= A is the same satisfier of C-atom A as for I |= A.\nAs argued above and in the introduction, our notion of computation is better suited for stepping than that of Liu et al., yet we see potential for using the latter orthogonal to our method for debugging (for the class of programs for which the different semantics coincide). While our jumping technique allows to consider several rules, selected by the user, at once, a debugging system could provide proposals for jumping, where each proposal corresponds to a set of rules that result in a next step in the sense of Liu et al. Then, the system could present the atom assignments for each proposal such that the user has an alternative to choose a jump based on truth of atoms rather than rules. Moreover, this can be the basis for automated progression in a stepping session until a certain atom is assigned, analogous to watchpoints in imperative debugging. We believe that these ideas for (semi-)automated jumping deserve further investigation.\nAnother branch of research, that is related to our notion of computation, focuses on transition systems for analysing answer-set computation (Lierler 2011; Lierler and Truszczyński 2016; Brochenin et al. 2014). These works build on the ideas of a transition system for the DPLL procedure for SAT solving (Nieuwenhuis et al. 2006). Transition systems are graphs whose nodes represent the state of a computation whereas the edges represent possible state transitions during solving. Typically, a set of transition rules, depending on the answer-set program, determines the possible transitions. In ASP transition systems, nodes are represented by (ordered) sets of literals with annotations whether a literal is a decision literal. Moreover, there is a distinguished state FailState for representing when a branch of computation cannot succeed in producing an answer set. Different sets of transition rules have been proposed that correspond to different models of computations. Typical transition rules include a unit propagation rule that derives one further literal based on a rule of the program for which all other literals are defined in the previous state, a decision rule that adds one further literal (annotated as decision literal), and a transition rule for backtracking that retracts a decision literal from an inconsistent state and replace it by its negation. Existing transition systems for ASP are intended to reflect ASP solving algorithms, including failed branches of search space traversal. For instance, transition systems have been defined with transition rules\nfor backjumping and learning as used in modern solvers (Lierler 2011). In contrast, our framework generates ideal (possibly failed) computations without backtracking. Another main difference is that all proposed transition systems have a transition rule for arbitrary assignment of decision literals whereas in our framework truth assignments are restricted to the domain of the C-rule added in the current step. Regarding supported language constructs, to the best of our knowledge, existing transition systems for ASP focus on elementary atoms, i.e., they do not cover aggregates. However, Lierler and Truszczyński (2016) also proposed transition systems for multi-logic systems including ASP. There has been work on transition systems for disjunctive programs (Brochenin et al. 2014). These are based on integrating two sets of transition rules, one for guessing and one for checking of answer set candidates. Similarly, as in the work by Liu et al. (2010), states in transition systems do not keep track of ASP rules as our states do. Note that our computation framework can be turned into to a transition system for disjunctive C-programs with only two transition rules, one for propagation that is derived from the successor relation (cf. Definition 17) and another for defining the transition of unstable final states or states with remaining active rules but no successor to FailState."
    }, {
      "heading" : "6 Conclusion",
      "text" : "In this paper, we introduced the stepping technique for ASP that can be used for debugging and analysis of answer-set programs. Like stepping in imperative programming, where the effects of consecutive statements are watched by the user, our stepping technique allows for monitoring the effect of rules added in a step-bystep session. In contrast to the imperative setting, stepping in our sense is interactive as a user decides in which direction to branch, by choosing which rule to consider next and which truth values its atoms should be assigned. On the one hand, this breaks a general problem of debugging in ASP, namely how to find the cause for an error, into small pieces. On the other hand, user interaction allows for focusing on interesting parts of the debugging search space from the beginning. This is in contrast to the imperative setting, where the order in which statements are considered in a debugging session is fixed. Nevertheless, also in our setting, the choice of the next rule is not entirely arbitrary, as we require the rule body to be active first. Debuggers for procedural languages often tackle the problem that many statements need to be considered before coming to an interesting step by ignoring several steps until pre-defined breakpoints are reached. We developed an analogous technique in our approach that we refer to as jumping which allows to consider multiple rules at once. Besides developing the technical framework for stepping, we also discussed the implementation of stepping in the SeaLion system and methodological aspects, thereby giving guidelines for the usage of the technique, and for setting the latter in the big picture of ASP development.\nWhile unstable computations are often not needed, they offer great opportunities for further work. For one, the use of unfounded sets for distinguishing states in unstable computations is a natural first choice for expressing the lack of stability. Arguably, when a user arrives in a state with a non-empty unfounded set, he or she\nonly knows that some external support has to be found for this set but there is no information which atoms of the unfounded sets are the crucial ones. It might be worthwhile to explore alternative representations for unstability such as elementary loops (Gebser et al. 2011) that possibly provide more pinpoint information. This would require lifting a respective notion to the full language of C-programs first.\nAnother issue regarding unstable computations that would deserve further attention is that in the current approach jumps can only result in stable states. Thus, unstable states in a computation can only be reached by individual steps at present. Here, it would be interesting to study methods and properties for computations that allow for jumping to states that are not stable.\nWe next discuss functionality that could be helpful for stepping which are not yet implemented in SeaLion. One such feature is semi-automatic stepping, i.e., the user can push a button and then the system searches for potential steps for which no further user interaction is required and applies them automatically until an answer set is reached, the computation is stuck, or user interaction is required. It would also be convenient to automatically check whether the computation of a debugging session is still a computation for the debugged program after a program update. In this respect, when the computation for the old version became incompatible, a feature would be advantageous that builds up a computation for the new version that resembles the old one as much as possible. Unlike semi-automatic stepping and compatibility checks for computations which could be implemented without further studies, the latter point still requires theoretical research. Further convenient features would be functionality that highlights the truth values of atoms that cause a rule not to be active for a given substitution and methods for predicting whether a rule can become active in the future, i.e., in some continuation of the computation."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank the reviewers for their useful comments. This work was partially supported by the Austrian Science Fund (FWF) under project P21698, the German Research Foundation (DFG) under grants BR-1817/7-1 and BR 1817/7-2, and the European Commission under project IST-2009-231875 (OntoRule)."
    }, {
      "heading" : "Appendix A Guidelines for Stepping",
      "text" : "In what follows, we give advice on how users can exploit stepping for analysing and debugging their code. Fig. A 1 synthesises practical guidelines for stepping from the methodological aspects of stepping described in Section 4.6. It can be seen as a useroriented view on the stepping technique. Depending on the goals and the knowledge of the user, this guide gives concise yet high-level suggestions on how to proceed in a stepping session. The upper area of the figure is concerned with clarifying the best strategy for a stepping session and for choosing the computation to start from. The lower area, on the other hand, guides the user through the stepping process.\nThe diagram differentiates between four tasks a user may want to perform.\n(i) Debugging a program lacking a particular answer set: we suggest to step and\njump through rules that one thinks build up this answer set. Eventually, the computation will get stuck when adding a rule that prevents the answer set.\n(ii) Debugging a program that lacks any answer set: if an intended answer set is\nknown, we advise using the strategy of Item (i). Otherwise, the user should choose rules and truth values during stepping that he or she thinks should be consistent, i.e., lead to a successful computation. Also here, the computation is guaranteed to fail and get stuck, indicating a reason for the inconsistency.\n(iii) Debugging a program with an unintended answer set I : In case that I is\nsimilar to an intended but missing answer set I ′, thus if I is intuitively a wrong version of I ′, we recommend stepping towards I ′, following the strategy of Item (i). Otherwise, the user can step towards I . Unlike in the previous cases, the computation is guaranteed to eventually succeed. Here, stepping acts as a disciplined way to inspect how the atoms of I can be derived and why no rule prevents I from being an answer set. If I is intended to be a model but not stable, then the stepping process will reveal which rules provide external support for sets of atoms that are supposed to be unfounded.\n(iv) Analysing a program: In case that the user is interested in the behaviour of\nthe program under a particular interpretation, it is reasonable to step towards this interpretation. Otherwise, rules and truth assignments should be chosen that drive the computation towards states that the user is interested in.\nThe procedures suggested above and in Fig. A 1 are meant as rough guidelines for the inexperienced user. Presumably, knowledge about the own source code and some practice in stepping gives the user a good intuition on how to find bugs efficiently.\nIt is natural to ask how big a program can get such that it is still suitable for stepping. Due to the vague nature of the question, answers cannot be clearly established. From a complexity theoretic point of view, the problems that need to be solved in a stepping support environment for and after performing a step or a jump, e.g., computing a new state from a jump, determining rules with active instances, or checking whether a computation has failed, are not harder than computing an answer set of the program under development. Under this observation, our technique is certainly an appropriate approach for debugging ASP. In some applications, however, solving times of multiple minutes or even hours are acceptable. Certainly, having waiting times of these lengths for individual debugging steps is undesirable. On the positive side, often, following a few guidelines during the development of an answer-set program can significantly reduce the likelihood of introducing bugs, the amount of information the user has to deal with, and also the computational resources required for stepping. Among these measures are best practices for ASP development that have been discussed in a paper by Brain et al. (2009). For working with the stepping method in particular, we give the following recommendations.\nUse scalable encodings and start with small examples. Using small problem instances, also the resulting grounding as well as answer sets are typically small. This limits the amount of information to be considered during debugging. Chances\nSTEPPING GUIDE\nWhat is your goal? What type of bug?\nDo you want to inspect the behaviour of your program\nunder a particular interpretation?\nAlways choose truth values to match the interpretation when performing a step in\nthis session\nFollow your intuitions to create an interesting\nsituation when choosing truth values in this session\nIs the unintended answer set a wrong version of a missing\nexpected answer set?\nDo you know any particular expected answer set?\nAlways choose truth values to match the intended answer set when performing a step in this session\nAlways choose truth values to match the unintended answer set when performing a step in this session\nWhich is the computation you can obtain that reflects your intended setting the\nmost?\nStart stepping from the obtained computation\nStart stepping from the empty state. Then, jump\nthrough the program’s facts\nSelect rules for step or jump\nStep Jump Do you want to continue stepping from the current state of the computation?\nStore computation for later use. Retract the final states from the computation until the new final state matches\nyour intentions\nCan you already gain satisfactory insight into the\nprogram’s semantics?"
    }, {
      "heading" : "Store computation for later use",
      "text" : "DONE\nfind\na bug\nanalyse the program\nyes no\nan unintended answer set\nno answer sets exist although some should\nyesno\na missing answer set\nyes no\na (part of a) stored computation for a trusted part of the program,\na computation generated from an answer set of a trusted part of the program, a computation generated from an answer set of a previous version of the program, or\na computation generated from an interpretation from an external source\nno\nyes no\nyes\nFig. A 1: Stepping guide\nthat bugs are detected early, using small programs is suggested by an evaluation of the small-scope hypothesis for ASP (Oetsch et al. 2012).\nVisualise answer sets and stepping states. Tools like Kara (Kloimüllner et al. 2013) (that is implemented in SeaLion), ASPVIZ (Cliffe et al. 2008), IDPDraw (Wittocx 2009), or Lonsdaleite (Smith 2011) allow for visualising interpretations. With their help, one can quickly spot when an answer set differs from what is expected and they allow to monitor the evolvement of the interpretation that is build up during stepping. The illustrations of the maze generation problem in this section were created using Kara. For use with stepping, we advise to specify visualisations also for interpretations that are not supposed to be answer sets. For example, in Fig. 8, we have visualisations for cells that are not assigned to be empty or a wall and for cells that are assigned to be a wall and empty, despite in an expected answer set, every cell has to be either a wall or empty.\nTest often. Frequent tests allow the user to trust in large parts of the program, hence these parts can be jumped over in a stepping session.\nAppendix B Remaining Proofs\nTheorem 1 Let S be a state and S ′ a successor of S , where ∆ = IS ′ \\ IS . Moreover, let X ′ be a set of literals with ∅ ⊂ X ′ ⊆ IS ′ . Then, the following statements are equivalent:\n(i) X ′ is unfounded in PS ′ with respect to IS ′ . (ii) X ′ = ∆′ ∪ X , where ∆′ ⊆ ∆, X ∈ ΥS , and rnew(S ,S ′) is not an external\nsupport for X ′ with respect to IS ′ ."
    }, {
      "heading" : "Proof",
      "text" : "((i)⇒(ii)) It is obvious that rnew(S ,S ′) is not an external support for X ′ with respect to IS ′ as otherwise X\n′ cannot be unfounded in PS ′ with respect to IS ′ . It remains to be shown that X ′ = ∆′ ∪ X for some ∆′ ⊆ ∆ and some X ∈ ΥS . Towards a contradiction, assume X ′ 6= ∆′′ ∪ X ′′ for all X ′′ ∈ ΥS and all ∆′′ ⊆ ∆. We define X = X ′ ∩ IS .\nConsider the case that X ∈ ΥS . As X ′ \\ IS ⊆ ∆, and X ′ = (X ′ \\ IS ) ∪ X , we have a contradiction to our assumption. Therefore, it holds that X 6∈ ΥS . Hence, as X ⊆ IS , by definition of a state, X is not unfounded in PS with respect to IS . Therefore, there is some external support r ∈ PS for X with respect to IS .\nIn the following, we show that r is also an external support for X ′ with respect to IS ′ . Since S\n′ is a successor of S and S is a state, we get that IS and IS ′ coincide on Dr . Consequently, from IS |= B(r) we get that also IS ′ |= B(r). Moreover, because of IS \\X |= B(r) it is also true that IS ′ \\X ′ |= B(r). Furthermore, we know that there is some A ∈ H(r) with X |DA 6= ∅ and IS |DA ⊆ C , for some C ∈ CA. As X |DA = X ′|DA and IS |DA = IS ′ |DA we also have X ′|DA 6= ∅ and IS ′ |DA ⊆ C . Finally, note that for all A ∈ H(r) with IS |= A, we have (X ∩ IS )|DA 6= ∅. Consider some\nA ∈ H(r) such that IS ′ |= A. From the latter we get that IS |= A and therefore (X ∩ IS )|DA 6= ∅. As X ∩ IS ⊆ X ′ ∩ IS ′ , we also have (X ′ ∩ IS ′)|DA 6= ∅. Hence, r fulfils all conditions for being an external support for X ′ with respect to IS ′ , which is a contradiction to X ′ being unfounded in PS ′ with respect to IS ′ .\n((ii)⇒(i)) Towards a contradiction, assume X ′ has some external support r ∈ PS ′ with respect to IS ′ . From (ii) we know that r 6= rnew(S ,S ′) and X ′ = ∆′ ∪ X for some ∆′ ⊆ ∆ and some X ∈ ΥS . As r 6= rnew(S ,S ′), we have that IS and IS ′ coincide on Dr . Therefore, from IS ′ |= B(r) and IS ′ \\ X ′ |= B(r), it follows that IS |= B(r) and IS \\ X ′ |= B(r). Note that X = X ′ ∩ IS and hence IS \\ X |= B(r). We know that there is some A ∈ H(r) with X ′|DA 6= ∅ and IS ′ |DA ⊆ C , for some C ∈ CA. As X ′|DA = X |DA we have X |DA 6= ∅. Moreover, as IS ′ |DA = IS |DA , it holds that IS |DA ⊆ C . Finally, notice that for all A ∈ H(r) with IS ′ |= A, we have (X ′ ∩ IS ′)|DA 6= ∅. Consider some A ∈ H(r) with IS |= A. As IS ′ |DA = IS |DA , we also have IS ′ |= A and hence (X ′ ∩ IS ′)|DA 6= ∅. As DA ∩ ∆ = ∅, we have (X ′ ∩ IS ′)|DA = (X ∩ IS )|DA . Consequently, it holds that (X ∩ IS )|DA 6= ∅. We showed that r is an external support of X in PS with respect to IS . Therefore, we have a contradiction to X ∈ ΥS because S is a state.\nTheorem 3 Let S0 be a state, P a C-program with PS0 ⊆ P , and I an answer set of P with IS0 ⊆ I and I ∩ I−S0 = ∅. Then, there is a computation S0, . . . ,Sn that has succeeded for P such that PSn = P I and ISn = I ."
    }, {
      "heading" : "Proof",
      "text" : "The proof is by induction on the size of the set P I \\PS0 . Observe that from IS0 ⊆ I , I ∩ I−S0 = ∅, and IS0 |= B(r) and Dr ⊆ IS0 ∪ I−S0 , for all r ∈ PS0 , we get that I |= B(r) for all r ∈ PS0 . Hence, as PS0 ⊆ P , we have PS0 ⊆ P I .\nConsider the base case that |P I \\ PS0 | = 0. From PS0 ⊆ P I we get PS0 = P I . Consider the sequence C = 〈PS0 , IS0 , I−S0 ,ΥS0〉. Towards a contradiction, assume IS0 6= I . As IS0 ⊆ I this means IS0 ⊂ I . Hence, there is some a ∈ I \\ IS0 . As for all r ∈ PS0 it holds that Dr ⊆ IS0 ∪ I−S0 , and I ∩ I−S0 = ∅, we get a 6∈ DPS0 . We have a contradiction to I ∈ AS(PS0) by Corollary 1, as {a} is unfounded in PS0 with respect to I . Consequently, IS0 = I must hold. As IS0 is an answer set of PS0 and S0 is a state, we have that ΥS0 = {∅} by definition of state. It follows that C meets the criteria of the conjectured computation.\nWe proceed with the step case. As induction hypothesis, assume that the claim holds whenever |P I \\ PS0 | ≤ i for an arbitrary but fixed i ≥ 0. Consider some state S0 and some I ∈ AS(PS0) for which the conditions in the premise hold such that |P I \\ PS0 | = i + 1. Towards a contradiction, assume there is no C-rule r ∈ P I \\PS0 such that IS0 |= B(r). Note that there is at least one C-rule r ′ ∈ P I \\PS0 because |P I \\ PS0 | = i + 1. It cannot hold that I = IS0 since from r ′ ∈ P IS0 follows IS0 |= B(r ′). Consequently, we have IS0 ⊂ I . Consider some r ′′ ∈ P I with IS0 |= B(r ′′). By our assumption, we get that r ′′ ∈ PS0 . It follows that IS0 |= r ′′, and consequently there is some C-atom A ∈ H(r ′′) with IS0 |= A. As Dr ′′ ⊆ DS0 , we have\nDA ⊆ IS0 ∪ I−S0 . From that, since IS0 ⊂ I and I ∩ I−S0 = ∅, we get I |DA = IS0 |DA . We have a contradiction to I being an answer set of P by Definition 12.\nSo, there must be some C-rule r ∈ P I \\ PS0 such that IS0 |= B(r). From r ∈ P I we get I |= B(r) and I |= r . Consider the state structure S1 = 〈P1, I1, I1−,Υ1〉, where P1 = PS0 ∪ {r}, I1 = IS0 ∪ (I ∩Dr ), I1− = I−S0 ∪ (Dr \\ I ), and\nΥ1 = {X |X = ∆′ ∪X ′, where ∆′ ⊆ (I1 \\ IS0),X ′ ∈ ΥS0 , and r is not an external support of X with respect to I1}·\nS1 is a successor of state S0, therefore S1 is also a state by Corollary 2. As P1 ⊆ P , I1 ⊆ I , I ∩ I1− = ∅, and |P I \\ P1| = i , by the induction hypothesis, S1, . . . ,Sn is a computation, where Sn is a stable state, PSn = P I , and ISn = I . Since S1 is a successor of state S0, also S0,S1, . . . ,Sn is a computation.\nFor establishing Theorem 5 we make use of the following notion which reflects\npositive dependency on the rule level.\nDefinition 22 The positive rule dependency graph of P is given by\nGR(P) = 〈P , {〈r1, r2〉 | r1, r2 ∈ P , posOcc(B(r1)) ∩ posOcc(H(r2)) 6= ∅}〉·\nWe can relate the two notions of dependency graph as follows.\nLemma 1 Let P be a C-program. GR(P) is acyclic iff G(P) is acyclic."
    }, {
      "heading" : "Proof",
      "text" : "Let ≺D denote the edge relation of G(P) and ≺R that of GR(P). (⇒) Assume G(P) is not acyclic. There must be some path a1, . . . , an of atoms ai such that for 1 ≤ i < n, we have ai ∈ DP , ai ≺D ai+1, and a1 = an . Hence, by the definition of G(P), there must be a sequence r1, . . . , rn−1 such that for each 1 ≤ i ≤ n − 1, ri ∈ P , ai ∈ posOcc(H(ri)), and ai+1 ∈ posOcc(B(ri)). Therefore, for each 1 ≤ i < n − 1, we have ri+1 ≺R ri . Note that a1 ∈ posOcc(H(r1)) and a1 ∈ posOcc(B(rn−1)). Consequently, we have rn−1 ≺R r1 and thus r1, rn−1, . . . , r1 forms a cycle in GR(P). It follows that GR(P) is not acyclic.\n(⇐) Assume now that GR(P) is not acyclic. There must be some path r1, . . . , rn of C-rules ri such that for 1 ≤ i < n we have ri ∈ P , r1 = rn , and ri ≺R ri+1. Hence, by the definition of GR(P), there must be a sequence a1, . . . , an−1 such that for each 1 ≤ i ≤ n − 1, ai ∈ posOcc(H(ri+1)), and ai ∈ posOcc(B(ri)). Therefore, for each 1 ≤ i < n − 1 we have ai+1 ≺D ai . Note that an−1 ∈ posOcc(H(r1)) and a1 ∈ posOcc(B(r1)). Consequently, we have an−1 ≺D a1 and thus a1, an−1, . . . , a1 forms a cycle in G(P). We have that GR(P) is not acyclic.\nLemma 2 Let P be an absolutely tight C-program. There is a strict total order ≺ on P that extends the reachability relation of GR(P)."
    }, {
      "heading" : "Proof",
      "text" : "By Definition 21, G(P) is acyclic. Hence, by Lemma 1, GR(P) is also acyclic. The conjecture holds, since every directed acyclic tree has a topological ordering.\nWe now have the means to show Theorem 5, guaranteeing the existence of stable computations.\nTheorem 5 Let C = S0, . . . ,Sn be a computation such that S0 and Sn are stable and P∆ = PSn \\ PS0 is a normal, convex, and absolutely tight C-program. Then, there is a stable computation C′=S ′0, . . . ,S ′ n such that S0 = S ′ 0 and Sn = S ′ n ."
    }, {
      "heading" : "Proof",
      "text" : "Let ≺ be the strict total order extending the reachability relation of GR(P∆) that is guaranteed to exist by Lemma 2. Let r(·) : {1, . . . ,n} 7→ P∆ denote the one-to-one mapping from the integer interval {1, . . . ,n} to the C-rules from P∆ such that for all i , j in the range of r(·), we have that i < j implies r(j ) ≺ r(i). Consider the sequence C′=S ′0, . . . ,S ′ n , where S ′ 0 = S0, and for all 0 ≤ i < n,\nP ′i+1 = P ′ i ∪ {r(i + 1)},\nIS ′i+1 = IS ′i ∪ (ISn ∩Dr(i+1)), I−S ′i+1 = I − S ′i ∪ (I−Sn ∩Dr(i+1)), and ΥS ′i+1 = {∅}·\nNotice that S ′n = Sn and IS ′i+1 |DPS′ i = IS ′i |DPS′ i , for all 0 ≤ i < n. We show that C′ is a computation by induction on the length of a subsequence of C′. As base case consider the sequence C′′= S ′0. As S ′ 0 = S0 and S0 is a state, C\n′′ is a computation. For the induction hypothesis, assume that for some arbitrary but fixed i with 0 ≤ i < n, the sequence S ′0, . . . ,S ′i is a computation. In the induction step it remains to be shown that S ′i+1 is a successor of S ′ i . Clearly, S ′i+1 is a state structure, and by definition of C ′, since C is a computation and\nIS ′i+1 |DPSi+1 = ISn |DPSi+1 ,\nConditions (i), (ii), (iii), and (v) of Definition 17 for being a successor of S ′i are fulfilled by S ′i+1. Let ∆ denote IS ′i+1 \\ IS ′i .\nNext we show that Condition (iv) holds, i.e., IS ′i |= B(r(i + 1)). Note that since Condition (v) holds, we have IS ′i+1 |= B(r(i + 1)) and hence (iv) holds in the case ∆ = ∅. Towards a contradiction assume ∆ 6= ∅ and IS ′i 6|= B(r(i + 1)). We define ∆B+ = ∆ ∩ posOcc(B(r(i + 1))).\nFirst, consider the case that ∆B+ = ∅. As IS ′i 6|= B(r(i + 1)), there must be some C-literal L ∈ B(r(i + 1)) such that IS ′i 6|= L. We know that IS ′i+1 |= L. Consequently, IS ′i |DL ⊂ IS ′i+1 |DL and therefore ∆|DL 6= ∅. Moreover, from IS ′i+1 |= L we have\nIS ′i+1 |DL ⊆ posOcc(B(r(i + 1)))·\nIt follows that ∆|DL∩posOcc(B(r(i + 1))) 6= ∅, indicating a contradiction to ∆B+ =\n∅. It holds that ∆B+ 6= ∅. Note that X ⊆ ISn . From that, since Sn is a state, there must be some C-rule r∆B+ ∈ PSn such that r∆B+ is an external support for ∆B+ with respect to ISn . It cannot be the case that r ∈ PS0 , since ∆B+ ∩ IS ′i = ∅, therefore, r∆B+ ∈ P∆. As r∆B+ is an external support for ∆B+ with respect to ISn , for {A} = H(r∆B+ ), we have ISn |= A and ∆B+ |DA 6= ∅.\nConsider the case that r∆B+ = r(i + 1). From that we get posOcc(H(r(i + 1)))∩ ∆B+ 6= ∅. This, in turn, implies posOcc(H(r(i + 1))) ∩ posOcc(B(r(i + 1))) 6= ∅ which is a contradiction to GR(P∆) being acyclic. The latter is guaranteed by absolute tightness of P∆ and Lemma 1.\nConsider the case that r(i + 1) ≺ r∆B+ . Then, by definition of C′ we have that r∆B+ ∈ PS ′i . Hence, from ∆B+ |DA 6= ∅ follows\n∆B+ |DP S′ i 6= ∅ and thus IS ′i+1 \\ IS ′i |DPS′ i 6= ∅· The latter is a contradiction to IS ′i+1 |DPS′\ni = IS ′i |DPS′ i .\nConsider the remaining case that r∆B+ ≺ r(i + 1). As ∆B+ |DA 6= ∅, ∆B+ ⊆ ISn , and ISn |DA ∈ CA, it holds that posOcc(H(r∆B+ )) ∩ ∆B+ 6= ∅. Therefore, we have posOcc(H(r∆B+ )) ∩ posOcc(B(r(i + 1))) 6= ∅. This implies r(i + 1) ≺ r∆B+ , being a contradiction to ≺ being a strict order as we also have r∆B+ ≺ r(i + 1). Thus, Condition (iv) of Definition 17 for being a successor of S ′i holds for S ′ i+1.\nTowards a contradiction assume Condition (vi) does not hold. Hence, it must hold that there is some ∆′ ⊆ ∆ such that ∆′ 6= ∅ and r(i + 1) is not an external support for ∆′ with respect to IS ′i+1 . We have IS ′i+1 |= B(r(i + 1)) and since we already know that IS ′i |= B(r(i + 1)), also IS ′i+1 \\ ∆′ |= B(r(i + 1)) holds by convexity of P∆. Moreover, as IS ′i+1 |= r(i + 1), it must hold that IS ′i+1 |= A for H(r(i + 1)) = {A}. Consequently, for r(i + 1) not to be an external support for ∆′ with respect to IS ′i+1 , we have ∆\n′|DA = ∅. As then ∆′|DH(r(i+1)) = ∅ but ∆′|Dr(i+1) 6= ∅ it must hold that ∆′|DB(r(i+1)) 6= ∅. Consider ∆′′ = ∆′ ∩ posOcc(B(r(i + 1))) and assume that ∆′′ 6= ∅. Then, as ∆′′ ⊆ ISn , there must be some C-rule r∆′′ that is an external support for ∆′′ with respect to ISn . Hence, posOcc(H(r∆′′)) ∩ ∆′′ 6= ∅ and therefore posOcc(H(r∆′′)) ∩ posOcc(B(r(i + 1))) 6= ∅. It follows that r(i + 1) ≺ r∆′′ . From that we get r∆′′ ∈ PS ′i . This is a contradiction as we know that posOcc(H(r∆′′)) ∩ ∆′′ 6= ∅, posOcc(H(r∆′′)) ∩ ∆′′ ⊆ IS ′i , and ∆′′ ⊆ IS ′i+1 \\ IS ′i . Consequently, ∆′ ∩ posOcc(B(r(i + 1))) = ∅ must hold. From ∆′|DB(r(i+1)) 6= ∅ we get that there is some L ∈ B(r(i + 1)) with ∆′|DL 6= ∅. As IS ′i+1 |= L, we have that IS ′i+1 |DL ∈ C in the case L is a C-atom L = 〈DL,C 〉, and IS ′i+1 |DL ∈ 2DL \\ C in the case L is a default negated C-atom L = not 〈DL,C 〉. In both cases, as ∆′ ⊆ IS ′i+1 and ∆′|DL 6= ∅, we get a contradiction to ∆′ ∩ posOcc(B(r(i + 1))) = ∅."
    } ],
    "references" : [ {
      "title" : "Advances in WASP",
      "author" : [ "M. Alviano", "C. Dodaro", "N. Leone", "F. Ricca" ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning - 13th International Conference, LPNMR 2015, Lexington, KY, USA, Sept. 27-30, 2015. Proceedings, F. Calimeri, G. Ianni, and M. Truszczyński, Eds. LNCS, vol. 9345. Springer, 40–54.",
      "citeRegEx" : "Alviano et al\\.,? 2015",
      "shortCiteRegEx" : "Alviano et al\\.",
      "year" : 2015
    }, {
      "title" : "Propositional semantics for disjunctive logic programs",
      "author" : [ "R. Ben-Eliyahu", "R. Dechter" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 12, 1-2, 53–87.",
      "citeRegEx" : "Ben.Eliyahu and Dechter,? 1994",
      "shortCiteRegEx" : "Ben.Eliyahu and Dechter",
      "year" : 1994
    }, {
      "title" : "A pragmatic programmer’s guide to answer set programming",
      "author" : [ "M. Brain", "O. Cliffe", "M. De Vos" ],
      "venue" : "Proceedings of the 2nd International Workshop on Software Engineering for Answer-Set Programming (SEA’09), Potsdam, Germany, M. De Vos and T. Schaub, Eds. 49–63.",
      "citeRegEx" : "Brain et al\\.,? 2009",
      "shortCiteRegEx" : "Brain et al\\.",
      "year" : 2009
    }, {
      "title" : "Debugging logic programs under the answer set semantics",
      "author" : [ "M. Brain", "M. De Vos" ],
      "venue" : "Proceedings of the 3rd International Workshop on Answer Set Programming (ASP’05), Advances in Theory and Implementation, Bath, UK, Sept. 27-29, 2005, M. De Vos and A. Provetti, Eds. CEUR Workshop Proceedings, vol. 142. CEUR-WS.org.",
      "citeRegEx" : "Brain and Vos,? 2005",
      "shortCiteRegEx" : "Brain and Vos",
      "year" : 2005
    }, {
      "title" : "That is illogical Captain! The debugging support tool spock for answer-set programs – System description",
      "author" : [ "M. Brain", "M. Gebser", "J. Puehrer", "T. Schaub", "H. Tompits", "S. Woltran" ],
      "venue" : "Proceeding of the 1st International Workshop on Software Engineering for Answer Set Programming (SEA’07), Tempe, AZ, USA, May 14, 2007, M. De Vos and T. Schaub, Eds. 71–85.",
      "citeRegEx" : "Brain et al\\.,? 2007",
      "shortCiteRegEx" : "Brain et al\\.",
      "year" : 2007
    }, {
      "title" : "Debugging ASP programs by means of ASP",
      "author" : [ "M. Brain", "M. Gebser", "J. Pührer", "T. Schaub", "H. Tompits", "S. Woltran" ],
      "venue" : "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’07), Tempe, AZ, USA, May 15-17, 2007, C. Baral, G. Brewka, and J. S. Schlipf, Eds. LNCS, vol. 4483. Springer, 31–43.",
      "citeRegEx" : "Brain et al\\.,? 2007",
      "shortCiteRegEx" : "Brain et al\\.",
      "year" : 2007
    }, {
      "title" : "Abstract disjunctive answer set solvers",
      "author" : [ "R. Brochenin", "Y. Lierler", "M. Maratea" ],
      "venue" : "Proceedings of the 21st European Conference on Artificial Intelligence (ECAI’14), Prague, Czech Republic, Aug. 18-22, 2014, T. Schaub, G. Friedrich, and B. O’Sullivan, Eds. Frontiers in Artificial Intelligence and Applications, vol. 263. IOS Press, 165–170.",
      "citeRegEx" : "Brochenin et al\\.,? 2014",
      "shortCiteRegEx" : "Brochenin et al\\.",
      "year" : 2014
    }, {
      "title" : "Sealion: An eclipse-based IDE for answer-set programming with advanced debugging support",
      "author" : [ "Busoniu", "P.-A.", "J. Oetsch", "J. Pührer", "P. Skočovský", "H. Tompits" ],
      "venue" : "Theory and Practice of Logic Programming 13, 4-5, 657–673.",
      "citeRegEx" : "Busoniu et al\\.,? 2013",
      "shortCiteRegEx" : "Busoniu et al\\.",
      "year" : 2013
    }, {
      "title" : "A theoretical framework for the declarative debugging of datalog programs",
      "author" : [ "R. Caballero", "Y. Garćıa-Ruiz", "F. Sáenz-Pérez" ],
      "venue" : "Revised Selected Papers of the 3rd International Workshop on Semantics in Data and Knowledge Bases (SDKB’08), Nantes, France, Mar. 29, 2008, K.-D. Schewe and B. Thalheim, Eds. LNCS, vol. 4925. Springer, 143–159.",
      "citeRegEx" : "Caballero et al\\.,? 2008",
      "shortCiteRegEx" : "Caballero et al\\.",
      "year" : 2008
    }, {
      "title" : "ASPVIZ: Declarative visualisation and animation using answer set programming",
      "author" : [ "O. Cliffe", "M. De Vos", "M. Brain", "J.A. Padget" ],
      "venue" : "Proceedings of the 24th International Conference on Logic Programming (ICLP’08), Udine, Italy, Dec. 9-13, 2008, M. G. de la Banda and E. Pontelli, Eds. LNCS, vol. 5366. Springer, 724–728.",
      "citeRegEx" : "Cliffe et al\\.,? 2008",
      "shortCiteRegEx" : "Cliffe et al\\.",
      "year" : 2008
    }, {
      "title" : "Extending classical logic with inductive definitions",
      "author" : [ "M. Denecker" ],
      "venue" : "Proceedings of the 1st International Conference on Computational Logic (CL’10), London, UK, July 24-28, 2000, J. W. Lloyd, V. Dahl, U. Furbach, M. Kerber, K. Lau, C. Palamidessi, L. M. Pereira, Y. Sagiv, and P. J. Stuckey, Eds. LNCS, vol. 1861. Springer, 703–717.",
      "citeRegEx" : "Denecker,? 2000",
      "shortCiteRegEx" : "Denecker",
      "year" : 2000
    }, {
      "title" : "A logic of nonmonotone inductive definitions",
      "author" : [ "M. Denecker", "E. Ternovska" ],
      "venue" : "ACM Transactions on Computational Logic 9, 2.",
      "citeRegEx" : "Denecker and Ternovska,? 2008",
      "shortCiteRegEx" : "Denecker and Ternovska",
      "year" : 2008
    }, {
      "title" : "The second answer set programming competition",
      "author" : [ "M. Denecker", "J. Vennekens", "S. Bond", "M. Gebser", "M. Truszczyński" ],
      "venue" : "Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’09), Potsdam, Germany, Sept. 14-18, 2009, E. Erdem, F. Lin, and T. Schaub, Eds. LNCS, vol. 5753. Springer, 637–654.",
      "citeRegEx" : "Denecker et al\\.,? 2009",
      "shortCiteRegEx" : "Denecker et al\\.",
      "year" : 2009
    }, {
      "title" : "Interactive debugging of non-ground ASP programs",
      "author" : [ "C. Dodaro", "P. Gasteiger", "B. Musitsch", "F. Ricca", "K.M. Shchekotykhin" ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning - 13th International Conference, LPNMR 2015, Lexington, KY, USA, Sept. 27-30, 2015. Proceedings, F. Calimeri, G. Ianni, and M. Truszczyński, Eds. LNCS, vol. 9345. Springer, 279–293.",
      "citeRegEx" : "Dodaro et al\\.,? 2015",
      "shortCiteRegEx" : "Dodaro et al\\.",
      "year" : 2015
    }, {
      "title" : "A uniform integration of higher-order reasoning and external evaluations in answer-set programming",
      "author" : [ "T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits" ],
      "venue" : "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI’05), Edinburgh, Scotland, UK, July 30-Aug. 5, 2005, L. P. Kaelbling and A. Saffiotti, Eds. Professional Book Center, 90–96.",
      "citeRegEx" : "Eiter et al\\.,? 2005",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2005
    }, {
      "title" : "Recursive aggregates in disjunctive logic programs: Semantics and complexity",
      "author" : [ "W. Faber", "N. Leone", "G. Pfeifer" ],
      "venue" : "Proceedings of the 9th European Conference on Logics in Artificial Intelligence (JELIA’04). LNCS, vol. 3229. Springer, 200–212.",
      "citeRegEx" : "Faber et al\\.,? 2004",
      "shortCiteRegEx" : "Faber et al\\.",
      "year" : 2004
    }, {
      "title" : "Semantics and complexity of recursive aggregates in answer set programming",
      "author" : [ "W. Faber", "G. Pfeifer", "N. Leone" ],
      "venue" : "Artificial Intelligence 175, 1, 278–298.",
      "citeRegEx" : "Faber et al\\.,? 2011",
      "shortCiteRegEx" : "Faber et al\\.",
      "year" : 2011
    }, {
      "title" : "Logic programs with propositional connectives and aggregates",
      "author" : [ "P. Ferraris" ],
      "venue" : "ACM Transactions on Computational Logic 12, 4, 25.",
      "citeRegEx" : "Ferraris,? 2011",
      "shortCiteRegEx" : "Ferraris",
      "year" : 2011
    }, {
      "title" : "Debugging answer-set programs with Ouroboros – Extending the SeaLion plugin",
      "author" : [ "M. Frühstück", "J. Pührer", "G. Friedrich" ],
      "venue" : "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’13), Corunna, Spain, Sept. 15-19, 2013, P. Cabalar and T. C. Son, Eds. LNCS, vol. 8148. Springer, 323–328.",
      "citeRegEx" : "Frühstück et al\\.,? 2013",
      "shortCiteRegEx" : "Frühstück et al\\.",
      "year" : 2013
    }, {
      "title" : "Advances in gringo series",
      "author" : [ "M. Gebser", "R. Kaminski", "A. König", "T. Schaub" ],
      "venue" : null,
      "citeRegEx" : "Gebser et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2011
    }, {
      "title" : "Conflict-driven answer set solving: From theory to practice",
      "author" : [ "M. Gebser", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Artificial Intelligence 187-188, 52–89.",
      "citeRegEx" : "Gebser et al\\.,? 2012",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2012
    }, {
      "title" : "On elementary loops of logic programs",
      "author" : [ "M. Gebser", "J. Lee", "Y. Lierler" ],
      "venue" : "Theory and Practice of Logic Programming 11, 6, 953–988.",
      "citeRegEx" : "Gebser et al\\.,? 2011",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2011
    }, {
      "title" : "A meta-programming technique for debugging answer-set programs",
      "author" : [ "M. Gebser", "J. Pührer", "T. Schaub", "H. Tompits" ],
      "venue" : "Proceedings of the 23rd AAAI Conference on Artificial Intelligence (AAAI’08), Chicago, IL, USA, July 13-17, 2008, D. Fox and C. P. Gomes, Eds. AAAI Press, 448–453.",
      "citeRegEx" : "Gebser et al\\.,? 2008",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2008
    }, {
      "title" : "spock: A debugging support tool for logic programs under the answer-set semantics",
      "author" : [ "M. Gebser", "J. Pührer", "T. Schaub", "H. Tompits", "S. Woltran" ],
      "venue" : "Revised Selected Papers of the 17th International Conference on Applications of Declarative Programming and Knowledge Management (INAP’07) and 21st Workshop on (Constraint) Logic Programming (WLP’07), D. Seipel, M. Hanus, and A. Wolf, Eds. LNCS,",
      "citeRegEx" : "Gebser et al\\.,? 2009",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2009
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9, 3/4, 365–386.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1991",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1991
    }, {
      "title" : "Kara: A system for visualising and visual editing of interpretations for answer-set programs",
      "author" : [ "C. Kloimüllner", "J. Oetsch", "J. Pührer", "H. Tompits" ],
      "venue" : "Revised Selected Papers of the 19th International Conference on Applications of Declarative Programming and Knowledge Management (INAP’11) and the 25th Workshop on Logic Programming (WLP’11), Vienna, Austria, Sept. 28-30, 2011. LNCS, vol. 7773. Springer,",
      "citeRegEx" : "Kloimüllner et al\\.,? 2013",
      "shortCiteRegEx" : "Kloimüllner et al\\.",
      "year" : 2013
    }, {
      "title" : "A model-theoretic counterpart of loop formulas",
      "author" : [ "J. Lee" ],
      "venue" : "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI’05), Edinburgh, Scotland, UK, July 30-Aug 5, 2005, L. P. Kaelbling and A. Saffiotti, Eds. Professional Book Center, 503–508.",
      "citeRegEx" : "Lee,? 2005",
      "shortCiteRegEx" : "Lee",
      "year" : 2005
    }, {
      "title" : "The DLV system for knowledge representation and reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic 7, 3, 499–562.",
      "citeRegEx" : "Leone et al\\.,? 2006",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 2006
    }, {
      "title" : "Debugging ASP using ILP",
      "author" : [ "T. Li", "M.D. Vos", "J. Padget", "K. Satoh", "T. Balke" ],
      "venue" : "Technical Communications of the 31st International Conference on Logic Programming (ICLP 2015), Cork, Ireland, Aug. 31 - Sept. 4, 2015., M. D. Vos, T. Eiter, Y. Lierler, and F. Toni, Eds. CEUR Workshop Proceedings, vol. 1433. CEUR-WS.org.",
      "citeRegEx" : "Li et al\\.,? 2015",
      "shortCiteRegEx" : "Li et al\\.",
      "year" : 2015
    }, {
      "title" : "Abstract answer set solvers with backjumping and learning",
      "author" : [ "Y. Lierler" ],
      "venue" : "Theory and Practice of Logic Programming 11, 2-3, 135–169.",
      "citeRegEx" : "Lierler,? 2011",
      "shortCiteRegEx" : "Lierler",
      "year" : 2011
    }, {
      "title" : "On abstract modular inference systems and solvers",
      "author" : [ "Y. Lierler", "M. Truszczyński" ],
      "venue" : "Artificial Intelligence 236, 65–89.",
      "citeRegEx" : "Lierler and Truszczyński,? 2016",
      "shortCiteRegEx" : "Lierler and Truszczyński",
      "year" : 2016
    }, {
      "title" : "Logic programs with abstract constraint atoms: The role of computations",
      "author" : [ "L. Liu", "E. Pontelli", "T.C. Son", "M. Truszczyński" ],
      "venue" : "Artificial Intelligence 174, 3-4, 295–315.",
      "citeRegEx" : "Liu et al\\.,? 2010",
      "shortCiteRegEx" : "Liu et al\\.",
      "year" : 2010
    }, {
      "title" : "Set constraints in logic programming",
      "author" : [ "V.W. Marek", "J.B. Remmel" ],
      "venue" : "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’04), Fort Lauderdale, FL, USA, Jan 6-8, 2004, V. Lifschitz and I. Niemelä, Eds. LNCS, vol. 2923. Springer, 167–179.",
      "citeRegEx" : "Marek and Remmel,? 2004",
      "shortCiteRegEx" : "Marek and Remmel",
      "year" : 2004
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V.W. Marek", "M. Truszczyński" ],
      "venue" : "In The Logic Programming Paradigm: a 25-Year Perspective, K. R. Apt, V. W. Marek, M. Truszczyński, and D. S. Warren, Eds. Springer, 375–398.",
      "citeRegEx" : "Marek and Truszczyński,? 1999",
      "shortCiteRegEx" : "Marek and Truszczyński",
      "year" : 1999
    }, {
      "title" : "Logic programs with abstract constraint atoms",
      "author" : [ "V.W. Marek", "M. Truszczyński" ],
      "venue" : "In Proceedings of the 19th National Conference on Artificial Intelligence (AAAI’04), San Jose, CA, USA, July 25-29, 2004, G. Ferguson and D. McGuinness, Eds. AAAI Press, 86–91.",
      "citeRegEx" : "Marek and Truszczyński,? 2004",
      "shortCiteRegEx" : "Marek and Truszczyński",
      "year" : 2004
    }, {
      "title" : "Towards debugging of answerset programs in the language PSpb",
      "author" : [ "A. Mikitiuk", "E. Moseley", "M. Truszczyński" ],
      "venue" : "Proceedings of the 2007 International Conference on Artificial Intelligence (ICAI’07), Volume II, Las Vegas, NV, USA, June 25-28, 2007, H. R. Arabnia, M. Q. Yang, and J. Y. Yang, Eds. CSREA Press, 635–640.",
      "citeRegEx" : "Mikitiuk et al\\.,? 2007",
      "shortCiteRegEx" : "Mikitiuk et al\\.",
      "year" : 2007
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. Niemelä" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 3-4, 241–273.",
      "citeRegEx" : "Niemelä,? 1999",
      "shortCiteRegEx" : "Niemelä",
      "year" : 1999
    }, {
      "title" : "Solving SAT and SAT modulo theories: From an abstract davis–putnam–logemann–loveland procedure to dpll(T)",
      "author" : [ "R. Nieuwenhuis", "A. Oliveras", "C. Tinelli" ],
      "venue" : "Journal of the ACM 53, 6, 937–977.",
      "citeRegEx" : "Nieuwenhuis et al\\.,? 2006",
      "shortCiteRegEx" : "Nieuwenhuis et al\\.",
      "year" : 2006
    }, {
      "title" : "On the small-scope hypothesis for testing answer-set programs",
      "author" : [ "J. Oetsch", "M. Prischink", "J. Pührer", "M. Schwengerer", "H. Tompits" ],
      "venue" : "Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR’12), Rome, Italy, June 10-14, 2012, G. Brewka, T. Eiter, and S. A. McIlraith, Eds. AAAI Press.",
      "citeRegEx" : "Oetsch et al\\.,? 2012",
      "shortCiteRegEx" : "Oetsch et al\\.",
      "year" : 2012
    }, {
      "title" : "Catching the Ouroboros: On debugging non-ground answer-set programs",
      "author" : [ "J. Oetsch", "J. Pührer", "H. Tompits" ],
      "venue" : "Theory and Practice of Logic Programming 10, 4-6 (July), 513–529.",
      "citeRegEx" : "Oetsch et al\\.,? 2010",
      "shortCiteRegEx" : "Oetsch et al\\.",
      "year" : 2010
    }, {
      "title" : "Let’s break the rules: Interactive procedural-style debugging of answer-set programs",
      "author" : [ "J. Oetsch", "J. Pührer", "H. Tompits" ],
      "venue" : "Proceedings of the 24th Workshop on (Constraint) Logic Programming (WLP’10), Cairo, Egypt, Sept. 14-16, 2010, S. Abdennadher, Ed. Technical Report, Faculty of Media Engineering and Technology, German University in Cairo. 77–87.",
      "citeRegEx" : "Oetsch et al\\.,? 2010",
      "shortCiteRegEx" : "Oetsch et al\\.",
      "year" : 2010
    }, {
      "title" : "Stepping through an answer-set program",
      "author" : [ "J. Oetsch", "J. Pührer", "H. Tompits" ],
      "venue" : "Proceedings of the 11th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’11), Vancouver, Canada, May 16-19, 2011. LNCS, vol. 6645. Springer, 134–147.",
      "citeRegEx" : "Oetsch et al\\.,? 2011",
      "shortCiteRegEx" : "Oetsch et al\\.",
      "year" : 2011
    }, {
      "title" : "An FLP-style answer-set semantics for abstract-constraint programs with disjunctions",
      "author" : [ "J. Oetsch", "J. Pührer", "H. Tompits" ],
      "venue" : "Technical Communications of the",
      "citeRegEx" : "Oetsch et al\\.,? 2012a",
      "shortCiteRegEx" : "Oetsch et al\\.",
      "year" : 2012
    }, {
      "title" : "Stepwise debugging of descriptionlogic programs",
      "author" : [ "J. Oetsch", "J. Pührer", "H. Tompits" ],
      "venue" : "Correct Reasoning - Essays on Logic-Based AI in Honour of Vladimir Lifschitz, E. Erdem, J. Lee, Y. Lierler, and D. Pearce, Eds. LNCS, vol. 7265. Springer, 492–508.",
      "citeRegEx" : "Oetsch et al\\.,? 2012b",
      "shortCiteRegEx" : "Oetsch et al\\.",
      "year" : 2012
    }, {
      "title" : "The SeaLion has landed: An IDE for answer-set programming—Preliminary report",
      "author" : [ "J. Oetsch", "J. Pührer", "H. Tompits" ],
      "venue" : "Revised Selected Papers of the 19th International Conference on Applications of Declarative Programming and Knowledge Management (INAP’11) and the 25th Workshop on Logic Programming (WLP’11), Vienna, Austria, Sept. 28-30, 2011. LNCS, vol. 7773. Springer, 305–324.",
      "citeRegEx" : "Oetsch et al\\.,? 2013",
      "shortCiteRegEx" : "Oetsch et al\\.",
      "year" : 2013
    }, {
      "title" : "Debugging non-ground ASP programs with choice rules, cardinality constraints and weight constraints",
      "author" : [ "A. Polleres", "M. Frühstück", "G. Schenner", "G. Friedrich" ],
      "venue" : "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’13), Corunna, Spain, Sept. 15-19, 2013, P. Cabalar and T. C. Son, Eds. LNCS, vol. 8148. Springer, 452–464.",
      "citeRegEx" : "Polleres et al\\.,? 2013",
      "shortCiteRegEx" : "Polleres et al\\.",
      "year" : 2013
    }, {
      "title" : "Justifications for logic programs under answer set semantics",
      "author" : [ "E. Pontelli", "T.C. Son", "O. El-Khatib" ],
      "venue" : "Theory and Practice of Logic Programming 9, 1, 1–56.",
      "citeRegEx" : "Pontelli et al\\.,? 2009",
      "shortCiteRegEx" : "Pontelli et al\\.",
      "year" : 2009
    }, {
      "title" : "Stepwise debugging in answer-set programming: Theoretical foundations and practical realisation",
      "author" : [ "J. Pührer" ],
      "venue" : "Ph.D. thesis, Vienna University of Technology, Vienna, Austria. http://repositum.tuwien.ac.at/urn:nbn:at:at-ubtuw:1-75281 [Online; accessed Dec. 14, 2016].",
      "citeRegEx" : "Pührer,? 2014",
      "shortCiteRegEx" : "Pührer",
      "year" : 2014
    }, {
      "title" : "The dlvhex system for knowledge representation: recent advances (system description)",
      "author" : [ "C. Redl" ],
      "venue" : "Theory and Practice of Logic Programming 16, 5-6, 866–883.",
      "citeRegEx" : "Redl,? 2016",
      "shortCiteRegEx" : "Redl",
      "year" : 2016
    }, {
      "title" : "Algorithmic program debugging",
      "author" : [ "E.Y. Shapiro" ],
      "venue" : "Ph.D. thesis, Yale University, New Haven, CT, USA.",
      "citeRegEx" : "Shapiro,? 1982",
      "shortCiteRegEx" : "Shapiro",
      "year" : 1982
    }, {
      "title" : "Interactive query-based debugging of ASP programs",
      "author" : [ "K.M. Shchekotykhin" ],
      "venue" : "Proceedings of the 29th AAAI Conference on Artificial Intelligence (AAAI’15), Austin, TX, USA, Jan. 25-30, 2015, B. Bonet and S. Koenig, Eds. AAAI Press, 1597–1603.",
      "citeRegEx" : "Shchekotykhin,? 2015",
      "shortCiteRegEx" : "Shchekotykhin",
      "year" : 2015
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "P. Simons", "I. Niemelä", "T. Soininen" ],
      "venue" : "Artificial Intelligence 138, 181–234.",
      "citeRegEx" : "Simons et al\\.,? 2002",
      "shortCiteRegEx" : "Simons et al\\.",
      "year" : 2002
    }, {
      "title" : "Lonsdaleite",
      "author" : [ "A. Smith" ],
      "venue" : "https://github.com/rndmcnlly/Lonsdaleite. [Online; accessed Dec. 14, 2016].",
      "citeRegEx" : "Smith,? 2011",
      "shortCiteRegEx" : "Smith",
      "year" : 2011
    }, {
      "title" : "Debugging inconsistent answer set programs",
      "author" : [ "T. Syrjänen" ],
      "venue" : "Proceedings of the 11th International Workshop on Non-Monotonic Reasoning (NMR’06), Lake District, UK, May 30-June 1, 2006, J. Dix and A. Hunter, Eds. Institut für Informatik, Technische Universität Clausthal, Technical Report, 77–83.",
      "citeRegEx" : "Syrjänen,? 2006",
      "shortCiteRegEx" : "Syrjänen",
      "year" : 2006
    }, {
      "title" : "Reducts of propositional theories, satisfiability relations, and generalizations of semantics of logic programs",
      "author" : [ "M. Truszczyński" ],
      "venue" : "Artificial Intelligence 174, 16-17, 1285– 1306.",
      "citeRegEx" : "Truszczyński,? 2010",
      "shortCiteRegEx" : "Truszczyński",
      "year" : 2010
    }, {
      "title" : "IDPDraw, a tool used for visualizing answer sets",
      "author" : [ "J. Wittocx" ],
      "venue" : "https://dtai.cs. kuleuven.be/software/idpdraw. [Online; accessed Dec. 14, 2016].",
      "citeRegEx" : "Wittocx,? 2009",
      "shortCiteRegEx" : "Wittocx",
      "year" : 2009
    }, {
      "title" : "Debugging for model expansion",
      "author" : [ "J. Wittocx", "H. Vlaeminck", "M. Denecker" ],
      "venue" : "Proceedings of the 25th International Conference on Logic Programming (ICLP’09), Pasadena, CA, USA, July 14-17, 2009, P. M. Hill and D. S. Warren, Eds. LNCS, vol. 5649. Springer, 296–311.",
      "citeRegEx" : "Wittocx et al\\.,? 2009",
      "shortCiteRegEx" : "Wittocx et al\\.",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 36,
      "context" : "Answer-set programming (ASP) (Niemelä 1999; Marek and Truszczyński 1999) is a paradigm for declarative problem solving that is popular amongst researchers in artificial intelligence and knowledge representation.",
      "startOffset" : 29,
      "endOffset" : 72
    }, {
      "referenceID" : 33,
      "context" : "Answer-set programming (ASP) (Niemelä 1999; Marek and Truszczyński 1999) is a paradigm for declarative problem solving that is popular amongst researchers in artificial intelligence and knowledge representation.",
      "startOffset" : 29,
      "endOffset" : 72
    }, {
      "referenceID" : 53,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 4,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 22,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 23,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 46,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 39,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 39,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 41,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 43,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 45,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 18,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 50,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015).",
      "startOffset" : 62,
      "endOffset" : 340
    }, {
      "referenceID" : 2,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015). These previous works are important contributions towards ASP development support, however current approaches come with limitations to their practical applicability. First, existing techniques and tools only capture a basic ASP language fragment that does not include many language constructs that are available and frequently used in modern ASP solver languages, e.g.,, aggregates or choice rules are not covered by current debugging strategies (with the exception of the work by Polleres et al. (2013), where cardinality constraints are dealt with by translation).",
      "startOffset" : 101,
      "endOffset" : 845
    }, {
      "referenceID" : 2,
      "context" : "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrjänen 2006; Brain et al. 2007; Pührer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Frühstück et al. 2013; Shchekotykhin 2015). These previous works are important contributions towards ASP development support, however current approaches come with limitations to their practical applicability. First, existing techniques and tools only capture a basic ASP language fragment that does not include many language constructs that are available and frequently used in modern ASP solver languages, e.g.,, aggregates or choice rules are not covered by current debugging strategies (with the exception of the work by Polleres et al. (2013), where cardinality constraints are dealt with by translation). Second, usability aspects are often not considered in current approaches, in particular, the programmer is required to either provide a lot of data to a debugging system or he or she is confronted with a huge amount of information from the system (tackling this problem in query-based debugging has been addressed by Shchekotykhin (2015)).",
      "startOffset" : 101,
      "endOffset" : 1246
    }, {
      "referenceID" : 19,
      "context" : "Consider the following encoding of an instance of the three-colouring problem in the Gringo language (Gebser et al. 2011):",
      "startOffset" : 101,
      "endOffset" : 121
    }, {
      "referenceID" : 32,
      "context" : "To this end, we make use of abstract constraints (Marek and Remmel 2004; Marek and Truszczyński 2004) as an established abstraction for language constructs such as aggregates, weight constraints, and external atoms.",
      "startOffset" : 49,
      "endOffset" : 101
    }, {
      "referenceID" : 34,
      "context" : "To this end, we make use of abstract constraints (Marek and Remmel 2004; Marek and Truszczyński 2004) as an established abstraction for language constructs such as aggregates, weight constraints, and external atoms.",
      "startOffset" : 49,
      "endOffset" : 101
    }, {
      "referenceID" : 42,
      "context" : "We rely on a semantics for arbitrary abstract-constraint programs with disjunctions that we introduced for this purpose in previous work (Oetsch et al. 2012a).",
      "startOffset" : 137,
      "endOffset" : 158
    }, {
      "referenceID" : 20,
      "context" : "In contrast to other semantics for this type of programs, it is compatible with the semantics of all the ASP solvers we want to support, namely, Clasp (Gebser et al. 2012), DLV (Leone et al.",
      "startOffset" : 151,
      "endOffset" : 171
    }, {
      "referenceID" : 27,
      "context" : "2012), DLV (Leone et al. 2006), and DLVHEX (Redl 2016).",
      "startOffset" : 11,
      "endOffset" : 30
    }, {
      "referenceID" : 48,
      "context" : "2006), and DLVHEX (Redl 2016).",
      "startOffset" : 18,
      "endOffset" : 29
    }, {
      "referenceID" : 19,
      "context" : "In contrast to other semantics for this type of programs, it is compatible with the semantics of all the ASP solvers we want to support, namely, Clasp (Gebser et al. 2012), DLV (Leone et al. 2006), and DLVHEX (Redl 2016). Note that our framework for computations for abstractconstraint programs differs from the one by Liu et al. (2010). We did not build on this existing notion for three reasons.",
      "startOffset" : 152,
      "endOffset" : 337
    }, {
      "referenceID" : 47,
      "context" : "In order to close this gap between formal and practical ASP, Pührer developed abstractions of the grounding step together with an abstract notion of non-ground answer-set program as the base language for the stepping methodology in his PhD thesis (Pührer 2014).",
      "startOffset" : 247,
      "endOffset" : 260
    }, {
      "referenceID" : 44,
      "context" : "The stepping technique has been implemented in SeaLion (Oetsch et al. 2013), an integrated development environment for ASP.",
      "startOffset" : 55,
      "endOffset" : 75
    }, {
      "referenceID" : 39,
      "context" : "1 The framework introduced in this paper subsumes and significantly extends previous versions of the stepping technique for normal logic programs (Oetsch et al. 2010; Oetsch et al. 2011) and DL-programs (Oetsch et al.",
      "startOffset" : 146,
      "endOffset" : 186
    }, {
      "referenceID" : 41,
      "context" : "1 The framework introduced in this paper subsumes and significantly extends previous versions of the stepping technique for normal logic programs (Oetsch et al. 2010; Oetsch et al. 2011) and DL-programs (Oetsch et al.",
      "startOffset" : 146,
      "endOffset" : 186
    }, {
      "referenceID" : 43,
      "context" : "2011) and DL-programs (Oetsch et al. 2012b).",
      "startOffset" : 22,
      "endOffset" : 43
    }, {
      "referenceID" : 42,
      "context" : "We recall the syntax of disjunctive abstract-constraint programs and the semantics on which we base our framework (Oetsch et al. 2012a).",
      "startOffset" : 114,
      "endOffset" : 135
    }, {
      "referenceID" : 29,
      "context" : "(2010) and transition systems for ASP (Lierler 2011; Lierler and Truszczyński 2016; Brochenin et al. 2014).",
      "startOffset" : 38,
      "endOffset" : 106
    }, {
      "referenceID" : 30,
      "context" : "(2010) and transition systems for ASP (Lierler 2011; Lierler and Truszczyński 2016; Brochenin et al. 2014).",
      "startOffset" : 38,
      "endOffset" : 106
    }, {
      "referenceID" : 6,
      "context" : "(2010) and transition systems for ASP (Lierler 2011; Lierler and Truszczyński 2016; Brochenin et al. 2014).",
      "startOffset" : 38,
      "endOffset" : 106
    }, {
      "referenceID" : 28,
      "context" : "We compare stepping to other debugging approaches for ASP and discuss the relation of our computation framework to that of Liu et al. (2010) and transition systems for ASP (Lierler 2011; Lierler and Truszczyński 2016; Brochenin et al.",
      "startOffset" : 123,
      "endOffset" : 141
    }, {
      "referenceID" : 32,
      "context" : "As motivated in the introduction, we represent grounded answer-set programs by abstract-constraint programs (Marek and Remmel 2004; Marek and Truszczyński 2004; Oetsch et al. 2012a).",
      "startOffset" : 108,
      "endOffset" : 181
    }, {
      "referenceID" : 34,
      "context" : "As motivated in the introduction, we represent grounded answer-set programs by abstract-constraint programs (Marek and Remmel 2004; Marek and Truszczyński 2004; Oetsch et al. 2012a).",
      "startOffset" : 108,
      "endOffset" : 181
    }, {
      "referenceID" : 42,
      "context" : "As motivated in the introduction, we represent grounded answer-set programs by abstract-constraint programs (Marek and Remmel 2004; Marek and Truszczyński 2004; Oetsch et al. 2012a).",
      "startOffset" : 108,
      "endOffset" : 181
    }, {
      "referenceID" : 32,
      "context" : "As motivated in the introduction, we represent grounded answer-set programs by abstract-constraint programs (Marek and Remmel 2004; Marek and Truszczyński 2004; Oetsch et al. 2012a). Non-ground programs will be denoted by programs in the input language of Gringo. Thus, we implicitly assume that grounding translates (non-ground) Gringo rules to rules of abstract-constraint programs. For a detailed formal account of our framework in the non-ground setting we refer the interested reader to the dissertation of Pührer (2014). We assume a fixed set A of ground atoms.",
      "startOffset" : 109,
      "endOffset" : 526
    }, {
      "referenceID" : 32,
      "context" : "Definition 3 (Marek and Remmel 2004; Marek and Truszczyński 2004) An abstract constraint, abstract-constraint atom, or C-atom, is a pair A = 〈D ,C 〉, where D ⊆ A is a finite set called the domain of A, denoted by DA, and C ⊆ 2 is a collection of sets of ground atoms, called the satisfiers of A, denoted by CA.",
      "startOffset" : 13,
      "endOffset" : 65
    }, {
      "referenceID" : 34,
      "context" : "Definition 3 (Marek and Remmel 2004; Marek and Truszczyński 2004) An abstract constraint, abstract-constraint atom, or C-atom, is a pair A = 〈D ,C 〉, where D ⊆ A is a finite set called the domain of A, denoted by DA, and C ⊆ 2 is a collection of sets of ground atoms, called the satisfiers of A, denoted by CA.",
      "startOffset" : 13,
      "endOffset" : 65
    }, {
      "referenceID" : 51,
      "context" : "As an example, we recall how weight constraints (Simons et al. 2002) can be expressed as C-atoms.",
      "startOffset" : 48,
      "endOffset" : 68
    }, {
      "referenceID" : 15,
      "context" : ", aggregates (Faber et al. 2004; Faber et al. 2011) or external atoms (Eiter et al.",
      "startOffset" : 13,
      "endOffset" : 51
    }, {
      "referenceID" : 16,
      "context" : ", aggregates (Faber et al. 2004; Faber et al. 2011) or external atoms (Eiter et al.",
      "startOffset" : 13,
      "endOffset" : 51
    }, {
      "referenceID" : 14,
      "context" : "2011) or external atoms (Eiter et al. 2005).",
      "startOffset" : 24,
      "endOffset" : 43
    }, {
      "referenceID" : 34,
      "context" : "Note that the relation between abstract constraints and ASP constructs is well known and motivated abstract constraints in the first place (cf. Marek and Remmel 2004; Marek and Truszczyński 2004).",
      "startOffset" : 139,
      "endOffset" : 195
    }, {
      "referenceID" : 51,
      "context" : "Definition 10 (Simons et al. 2002) A weight constraint is an expression of form",
      "startOffset" : 14,
      "endOffset" : 34
    }, {
      "referenceID" : 42,
      "context" : "The semantics we use (Oetsch et al. 2012a) extends the FLP-semantics (Faber et al.",
      "startOffset" : 21,
      "endOffset" : 42
    }, {
      "referenceID" : 15,
      "context" : "2012a) extends the FLP-semantics (Faber et al. 2004; 2011) and coincides with the original notion of answer sets by Gelfond and Lifschitz (1991) on many important classes of logic programs, including elementary C-programs.",
      "startOffset" : 33,
      "endOffset" : 58
    }, {
      "referenceID" : 15,
      "context" : "2012a) extends the FLP-semantics (Faber et al. 2004; 2011) and coincides with the original notion of answer sets by Gelfond and Lifschitz (1991) on many important classes of logic programs, including elementary C-programs.",
      "startOffset" : 34,
      "endOffset" : 145
    }, {
      "referenceID" : 42,
      "context" : "Definition 12 (Oetsch et al. 2012a) Let P be a C-program, and let I be an interpretation.",
      "startOffset" : 14,
      "endOffset" : 35
    }, {
      "referenceID" : 26,
      "context" : "Such rules are referred to as external support (Lee 2005).",
      "startOffset" : 47,
      "endOffset" : 57
    }, {
      "referenceID" : 17,
      "context" : "Note that Gringo/Clasp treats aggregates in the way suggested by Ferraris (2011). As a consequence, its semantics differs from our semantics in some cases, when recursion is used through negated c-atoms, as ours is an extension of the FLP semantics.",
      "startOffset" : 65,
      "endOffset" : 81
    }, {
      "referenceID" : 17,
      "context" : "Note that Gringo/Clasp treats aggregates in the way suggested by Ferraris (2011). As a consequence, its semantics differs from our semantics in some cases, when recursion is used through negated c-atoms, as ours is an extension of the FLP semantics. For an in-depth comparison of FLP-semantics and Ferraris semantics we refer to work by Truszczyński (2010). An example where the semantics differ is given by the single rule Gringo program a :- not 0{a}0 that has only the empty set as answer set under our semantics, whereas Clasp also admits {a} as an answer set.",
      "startOffset" : 65,
      "endOffset" : 357
    }, {
      "referenceID" : 42,
      "context" : "Definition 13 (Oetsch et al. 2012a) Let r be a C-rule, X a set of atoms, and I an interpretation.",
      "startOffset" : 14,
      "endOffset" : 35
    }, {
      "referenceID" : 42,
      "context" : "Definition 14 (Oetsch et al. 2012a) Let P be a C-program, X a set of atoms, and I an interpretation.",
      "startOffset" : 14,
      "endOffset" : 35
    }, {
      "referenceID" : 42,
      "context" : "Corollary 1 (Oetsch et al. 2012a) Let P be a C-program and I an interpretation.",
      "startOffset" : 12,
      "endOffset" : 33
    }, {
      "referenceID" : 1,
      "context" : "One could assume that absolute tightness paired with convexity or monotonicity is sufficient to guarantee stable computations because absolute tightness forbids positive dependencies among disjuncts and the absence of such dependencies lowers the complexity of elementary C-programs (Ben-Eliyahu and Dechter 1994).",
      "startOffset" : 283,
      "endOffset" : 313
    }, {
      "referenceID" : 44,
      "context" : "A prototype our stepping framework has been implemented in SeaLion, an integrated development environment (IDE) for ASP (Oetsch et al. 2013).",
      "startOffset" : 120,
      "endOffset" : 140
    }, {
      "referenceID" : 12,
      "context" : "It has been a benchmark problem of the second ASP competition (Denecker et al. 2009) to which it was submitted by Martin Brain.",
      "startOffset" : 62,
      "endOffset" : 84
    }, {
      "referenceID" : 49,
      "context" : "In debugging, having the programmer in the role of an oracle is a common scenario as it is reasonable to assume that a programmer has good intuitions on where to guide the search (Shapiro 1982).",
      "startOffset" : 179,
      "endOffset" : 193
    }, {
      "referenceID" : 25,
      "context" : "The stepping feature is integrated with the Kara plugin of SeaLion (Kloimüllner et al. 2013) that can create user-defined graphical representations of interpretations.",
      "startOffset" : 67,
      "endOffset" : 92
    }, {
      "referenceID" : 25,
      "context" : "Visualisations in Kara are defined using ASP itself, for further information we refer to earlier work (Kloimüllner et al. 2013).",
      "startOffset" : 102,
      "endOffset" : 127
    }, {
      "referenceID" : 7,
      "context" : "A comprehensive discussion of other features of SeaLion is given in a related paper (Busoniu et al. 2013) on the IDE.",
      "startOffset" : 84,
      "endOffset" : 105
    }, {
      "referenceID" : 28,
      "context" : "The goal of the work by Pontelli et al. (2009) is to explain the truth values of literals with respect to a given actual answer set of a program.",
      "startOffset" : 30,
      "endOffset" : 47
    }, {
      "referenceID" : 28,
      "context" : "Pontelli et al. (2009) use sequences of three-valued interpretations (called computations) in which monotonously more atoms are considered true, respectively, false.",
      "startOffset" : 6,
      "endOffset" : 23
    }, {
      "referenceID" : 4,
      "context" : "Another early approach (Brain et al. 2007; Pührer 2007) is based on program rewritings using some additional control atoms, called tags, that allow, e.",
      "startOffset" : 23,
      "endOffset" : 55
    }, {
      "referenceID" : 4,
      "context" : "The translations needed were implemented in the command-line tool Spock (Brain et al. 2007; Gebser et al. 2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al.",
      "startOffset" : 72,
      "endOffset" : 111
    }, {
      "referenceID" : 23,
      "context" : "The translations needed were implemented in the command-line tool Spock (Brain et al. 2007; Gebser et al. 2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al.",
      "startOffset" : 72,
      "endOffset" : 111
    }, {
      "referenceID" : 22,
      "context" : "2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al. 2008; Pührer 2007).",
      "startOffset" : 116,
      "endOffset" : 149
    }, {
      "referenceID" : 39,
      "context" : "The approach has later been extended from propositional to disjunctive logic programs with constraints, integer arithmetic, comparison predicates, and strong negation (Oetsch et al. 2010) and also to programs with cardinality constraints (Polleres et al.",
      "startOffset" : 167,
      "endOffset" : 187
    }, {
      "referenceID" : 45,
      "context" : "2010) and also to programs with cardinality constraints (Polleres et al. 2013).",
      "startOffset" : 56,
      "endOffset" : 78
    }, {
      "referenceID" : 18,
      "context" : "It has been implemented in the Ouroboros plugin of SeaLion (Frühstück et al. 2013).",
      "startOffset" : 59,
      "endOffset" : 82
    }, {
      "referenceID" : 22,
      "context" : "Moreover, Shchekotykhin (2015) developed a method on top of the meta-programming approaches (Gebser et al. 2008; Oetsch et al. 2010) that poses questions to the user in order to find a desired problem diagnosis while keeping the amount of required interaction low.",
      "startOffset" : 92,
      "endOffset" : 132
    }, {
      "referenceID" : 39,
      "context" : "Moreover, Shchekotykhin (2015) developed a method on top of the meta-programming approaches (Gebser et al. 2008; Oetsch et al. 2010) that poses questions to the user in order to find a desired problem diagnosis while keeping the amount of required interaction low.",
      "startOffset" : 92,
      "endOffset" : 132
    }, {
      "referenceID" : 4,
      "context" : "(2015) use control atoms quite similar to that of the tagging approach (Brain et al. 2007; Pührer 2007) to identify sets of rules that lead to inconsistency of a program under the requirement that a given set of atoms is true in some intended answer set.",
      "startOffset" : 71,
      "endOffset" : 103
    }, {
      "referenceID" : 0,
      "context" : "An implementation is provided that profits from a tight integration with the ASP solver WASP (Alviano et al. 2015).",
      "startOffset" : 93,
      "endOffset" : 114
    }, {
      "referenceID" : 31,
      "context" : "Syrjänen (2006) aimed at finding explanations why a program has no answer sets.",
      "startOffset" : 0,
      "endOffset" : 16
    }, {
      "referenceID" : 1,
      "context" : "Another early approach (Brain et al. 2007; Pührer 2007) is based on program rewritings using some additional control atoms, called tags, that allow, e.g., for switching individual rules on or off and for analysing the resulting answer sets. Debugging requests can be posed by adding further rules that can employ tags as well. That is, ASP is used itself for debugging answer-set programs. The translations needed were implemented in the command-line tool Spock (Brain et al. 2007; Gebser et al. 2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al. 2008; Pührer 2007). The technique is based on ASP meta-programming, i.e., a program over a metalanguage is used to manipulate a program over an object language (in this case, both the meta-language and the object language are instances of ASP). It addresses the question why some interpretation is not an answer set of the given program. Answers are given in terms of unsatisfied rules and unfounded loops. The approach has later been extended from propositional to disjunctive logic programs with constraints, integer arithmetic, comparison predicates, and strong negation (Oetsch et al. 2010) and also to programs with cardinality constraints (Polleres et al. 2013). It has been implemented in the Ouroboros plugin of SeaLion (Frühstück et al. 2013). Moreover, Shchekotykhin (2015) developed a method on top of the meta-programming approaches (Gebser et al.",
      "startOffset" : 24,
      "endOffset" : 1411
    }, {
      "referenceID" : 1,
      "context" : "Another early approach (Brain et al. 2007; Pührer 2007) is based on program rewritings using some additional control atoms, called tags, that allow, e.g., for switching individual rules on or off and for analysing the resulting answer sets. Debugging requests can be posed by adding further rules that can employ tags as well. That is, ASP is used itself for debugging answer-set programs. The translations needed were implemented in the command-line tool Spock (Brain et al. 2007; Gebser et al. 2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al. 2008; Pührer 2007). The technique is based on ASP meta-programming, i.e., a program over a metalanguage is used to manipulate a program over an object language (in this case, both the meta-language and the object language are instances of ASP). It addresses the question why some interpretation is not an answer set of the given program. Answers are given in terms of unsatisfied rules and unfounded loops. The approach has later been extended from propositional to disjunctive logic programs with constraints, integer arithmetic, comparison predicates, and strong negation (Oetsch et al. 2010) and also to programs with cardinality constraints (Polleres et al. 2013). It has been implemented in the Ouroboros plugin of SeaLion (Frühstück et al. 2013). Moreover, Shchekotykhin (2015) developed a method on top of the meta-programming approaches (Gebser et al. 2008; Oetsch et al. 2010) that poses questions to the user in order to find a desired problem diagnosis while keeping the amount of required interaction low. In a related approach, Dodaro et al. (2015) use control atoms quite similar to that of the tagging approach (Brain et al.",
      "startOffset" : 24,
      "endOffset" : 1689
    }, {
      "referenceID" : 0,
      "context" : "An implementation is provided that profits from a tight integration with the ASP solver WASP (Alviano et al. 2015). In order to reduce the possible outcomes, the debugger asks the user about the intended truth of further atoms in an interactive session. In another paper, Li et al. (2015) use inductive logic programming to repair answer-set programs.",
      "startOffset" : 94,
      "endOffset" : 289
    }, {
      "referenceID" : 22,
      "context" : "(2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010).",
      "startOffset" : 172,
      "endOffset" : 212
    }, {
      "referenceID" : 39,
      "context" : "(2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010).",
      "startOffset" : 172,
      "endOffset" : 212
    }, {
      "referenceID" : 10,
      "context" : "(2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.",
      "startOffset" : 101,
      "endOffset" : 145
    }, {
      "referenceID" : 11,
      "context" : "(2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.",
      "startOffset" : 101,
      "endOffset" : 145
    }, {
      "referenceID" : 46,
      "context" : "Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence.",
      "startOffset" : 21,
      "endOffset" : 43
    }, {
      "referenceID" : 22,
      "context" : "The previous meta-programming based debugging technique (Gebser et al. 2008; Pührer 2007) and follow-up works (Oetsch et al.",
      "startOffset" : 56,
      "endOffset" : 89
    }, {
      "referenceID" : 39,
      "context" : "2008; Pührer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program.",
      "startOffset" : 39,
      "endOffset" : 81
    }, {
      "referenceID" : 45,
      "context" : "2008; Pührer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program.",
      "startOffset" : 39,
      "endOffset" : 81
    }, {
      "referenceID" : 53,
      "context" : "Syrjänen’s diagnosis technique (Syrjänen 2006) is limited to the setting when a program has no answer set at all.",
      "startOffset" : 31,
      "endOffset" : 46
    }, {
      "referenceID" : 8,
      "context" : "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al.",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 8,
      "context" : "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.",
      "startOffset" : 0,
      "endOffset" : 480
    }, {
      "referenceID" : 8,
      "context" : "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily.",
      "startOffset" : 0,
      "endOffset" : 1044
    }, {
      "referenceID" : 8,
      "context" : "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers. We can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set.",
      "startOffset" : 0,
      "endOffset" : 1552
    }, {
      "referenceID" : 8,
      "context" : "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers. We can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set. Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence. The approach by Caballero et al. (2008) can also be seen to target a single actual answer set.",
      "startOffset" : 0,
      "endOffset" : 1881
    }, {
      "referenceID" : 8,
      "context" : "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers. We can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set. Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence. The approach by Caballero et al. (2008) can also be seen to target a single actual answer set. Due to their focus on actual answer sets of the debugged program, these methods cannot be applied on (erroneous) programs without any answer set. The previous meta-programming based debugging technique (Gebser et al. 2008; Pührer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program. In the approach of Wittocx et al. (2009), the user can specify a class of intended semantic structures which are not preferred models of the theory at hand (corresponding to actual answer sets of the program to be debugged in ASP terminology).",
      "startOffset" : 0,
      "endOffset" : 2355
    }, {
      "referenceID" : 8,
      "context" : "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers. We can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set. Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence. The approach by Caballero et al. (2008) can also be seen to target a single actual answer set. Due to their focus on actual answer sets of the debugged program, these methods cannot be applied on (erroneous) programs without any answer set. The previous meta-programming based debugging technique (Gebser et al. 2008; Pührer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program. In the approach of Wittocx et al. (2009), the user can specify a class of intended semantic structures which are not preferred models of the theory at hand (corresponding to actual answer sets of the program to be debugged in ASP terminology). Syrjänen’s diagnosis technique (Syrjänen 2006) is limited to the setting when a program has no answer set at all. The same holds for the work of Dodaro et al. (2015), however the authors demonstrate how other debugging problems can be reduced to that of inconsistency.",
      "startOffset" : 0,
      "endOffset" : 2724
    }, {
      "referenceID" : 8,
      "context" : "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers. We can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set. Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence. The approach by Caballero et al. (2008) can also be seen to target a single actual answer set. Due to their focus on actual answer sets of the debugged program, these methods cannot be applied on (erroneous) programs without any answer set. The previous meta-programming based debugging technique (Gebser et al. 2008; Pührer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program. In the approach of Wittocx et al. (2009), the user can specify a class of intended semantic structures which are not preferred models of the theory at hand (corresponding to actual answer sets of the program to be debugged in ASP terminology). Syrjänen’s diagnosis technique (Syrjänen 2006) is limited to the setting when a program has no answer set at all. The same holds for the work of Dodaro et al. (2015), however the authors demonstrate how other debugging problems can be reduced to that of inconsistency. The method requires an intended answer set but offers the means to generate that in an interactive way, building on the technique by Shchekotykhin (2015). Stepping does not require actual or intended answer sets as a prerequisite, as the user can explore the behaviour of his or her program under different interpretations that may or may not be extended to answer sets by choosing different rules instances.",
      "startOffset" : 0,
      "endOffset" : 2981
    }, {
      "referenceID" : 4,
      "context" : "A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms.",
      "startOffset" : 98,
      "endOffset" : 117
    }, {
      "referenceID" : 56,
      "context" : "First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules.",
      "startOffset" : 99,
      "endOffset" : 120
    }, {
      "referenceID" : 46,
      "context" : "Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al.",
      "startOffset" : 127,
      "endOffset" : 172
    }, {
      "referenceID" : 22,
      "context" : "2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrjänen 2006).",
      "startOffset" : 25,
      "endOffset" : 45
    }, {
      "referenceID" : 53,
      "context" : "2008), or simple choice rules (Syrjänen 2006).",
      "startOffset" : 30,
      "endOffset" : 45
    }, {
      "referenceID" : 4,
      "context" : "The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols.",
      "startOffset" : 36,
      "endOffset" : 55
    }, {
      "referenceID" : 39,
      "context" : "Explicit support for variables is also given in an extension (Oetsch et al. 2010) of the meta-programming approach for disjunctive programs.",
      "startOffset" : 61,
      "endOffset" : 81
    }, {
      "referenceID" : 45,
      "context" : "It was later extended to allow for weight constraints (Polleres et al. 2013) by compiling them away to normal rules.",
      "startOffset" : 54,
      "endOffset" : 76
    }, {
      "referenceID" : 46,
      "context" : "This also holds for our approach, however stepping and online justifications (Pontelli et al. 2009) are exceptional as both involve a generic notion of computation which adds a procedural flavour to debugging.",
      "startOffset" : 77,
      "endOffset" : 99
    }, {
      "referenceID" : 2,
      "context" : "A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms. Here, the stepping technique can be considered more focused, as the interpretation under investigation is determined by the choices of the user in stepping but is essentially arbitrary in the tagging approach if the user does not employ explicit restrictions. Next, we compare the ASP languages supported by different approaches. First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules. Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrjänen 2006). The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols. The approach by Caballero et al. (2008) deals with non-ground normal programs which have to be stratified.",
      "startOffset" : 99,
      "endOffset" : 1195
    }, {
      "referenceID" : 2,
      "context" : "A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms. Here, the stepping technique can be considered more focused, as the interpretation under investigation is determined by the choices of the user in stepping but is essentially arbitrary in the tagging approach if the user does not employ explicit restrictions. Next, we compare the ASP languages supported by different approaches. First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules. Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrjänen 2006). The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols. The approach by Caballero et al. (2008) deals with non-ground normal programs which have to be stratified. Explicit support for variables is also given in an extension (Oetsch et al. 2010) of the meta-programming approach for disjunctive programs. It was later extended to allow for weight constraints (Polleres et al. 2013) by compiling them away to normal rules. A commonality of the previous approaches is that they target ASP languages that can be considered idealised proper subsets of current solver languages. In this respect, stepping is the first debugging approach that overcomes these limitations as the use of C-programs and abstract grounding (cf. Pührer 2014) make the framework generic enough to be applied to ASP solver languages. While this does not mean that other approaches cannot be adapted to fit a solver language, it is no always immediately clear how. For our approach, instantiating our abstractions to the language constructs and the grounding method of a solver is sufficient to have a ready-to-use debugging method. Most existing debugging approaches for ASP can be seen as declarative in the sense that a user can pose a debugging query, and receives answers in terms of different declarative definitions of the semantics of answer-set programs, e.g., in terms of active or inactive rules with respect to some interpretation. In particular, the approaches do not take the execution strategy of solvers into account. This also holds for our approach, however stepping and online justifications (Pontelli et al. 2009) are exceptional as both involve a generic notion of computation which adds a procedural flavour to debugging. Nonetheless, the computation model we use can be seen as a declarative characterisation of the answer-set semantics itself as it does not apply a fix order in which to apply rules to build up an answer set. Besides stepping, also the approaches by Wittocx et al. (2009) and Dodaro et al.",
      "startOffset" : 99,
      "endOffset" : 3081
    }, {
      "referenceID" : 2,
      "context" : "A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms. Here, the stepping technique can be considered more focused, as the interpretation under investigation is determined by the choices of the user in stepping but is essentially arbitrary in the tagging approach if the user does not employ explicit restrictions. Next, we compare the ASP languages supported by different approaches. First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules. Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrjänen 2006). The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols. The approach by Caballero et al. (2008) deals with non-ground normal programs which have to be stratified. Explicit support for variables is also given in an extension (Oetsch et al. 2010) of the meta-programming approach for disjunctive programs. It was later extended to allow for weight constraints (Polleres et al. 2013) by compiling them away to normal rules. A commonality of the previous approaches is that they target ASP languages that can be considered idealised proper subsets of current solver languages. In this respect, stepping is the first debugging approach that overcomes these limitations as the use of C-programs and abstract grounding (cf. Pührer 2014) make the framework generic enough to be applied to ASP solver languages. While this does not mean that other approaches cannot be adapted to fit a solver language, it is no always immediately clear how. For our approach, instantiating our abstractions to the language constructs and the grounding method of a solver is sufficient to have a ready-to-use debugging method. Most existing debugging approaches for ASP can be seen as declarative in the sense that a user can pose a debugging query, and receives answers in terms of different declarative definitions of the semantics of answer-set programs, e.g., in terms of active or inactive rules with respect to some interpretation. In particular, the approaches do not take the execution strategy of solvers into account. This also holds for our approach, however stepping and online justifications (Pontelli et al. 2009) are exceptional as both involve a generic notion of computation which adds a procedural flavour to debugging. Nonetheless, the computation model we use can be seen as a declarative characterisation of the answer-set semantics itself as it does not apply a fix order in which to apply rules to build up an answer set. Besides stepping, also the approaches by Wittocx et al. (2009) and Dodaro et al. (2015) as well as Shchekotykhin (2015) can be considered interactive.",
      "startOffset" : 99,
      "endOffset" : 3106
    }, {
      "referenceID" : 2,
      "context" : "A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms. Here, the stepping technique can be considered more focused, as the interpretation under investigation is determined by the choices of the user in stepping but is essentially arbitrary in the tagging approach if the user does not employ explicit restrictions. Next, we compare the ASP languages supported by different approaches. First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules. Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrjänen 2006). The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols. The approach by Caballero et al. (2008) deals with non-ground normal programs which have to be stratified. Explicit support for variables is also given in an extension (Oetsch et al. 2010) of the meta-programming approach for disjunctive programs. It was later extended to allow for weight constraints (Polleres et al. 2013) by compiling them away to normal rules. A commonality of the previous approaches is that they target ASP languages that can be considered idealised proper subsets of current solver languages. In this respect, stepping is the first debugging approach that overcomes these limitations as the use of C-programs and abstract grounding (cf. Pührer 2014) make the framework generic enough to be applied to ASP solver languages. While this does not mean that other approaches cannot be adapted to fit a solver language, it is no always immediately clear how. For our approach, instantiating our abstractions to the language constructs and the grounding method of a solver is sufficient to have a ready-to-use debugging method. Most existing debugging approaches for ASP can be seen as declarative in the sense that a user can pose a debugging query, and receives answers in terms of different declarative definitions of the semantics of answer-set programs, e.g., in terms of active or inactive rules with respect to some interpretation. In particular, the approaches do not take the execution strategy of solvers into account. This also holds for our approach, however stepping and online justifications (Pontelli et al. 2009) are exceptional as both involve a generic notion of computation which adds a procedural flavour to debugging. Nonetheless, the computation model we use can be seen as a declarative characterisation of the answer-set semantics itself as it does not apply a fix order in which to apply rules to build up an answer set. Besides stepping, also the approaches by Wittocx et al. (2009) and Dodaro et al. (2015) as well as Shchekotykhin (2015) can be considered interactive.",
      "startOffset" : 99,
      "endOffset" : 3138
    }, {
      "referenceID" : 13,
      "context" : "works (Dodaro et al. 2015; Shchekotykhin 2015) use interaction for filtering the resulting debugging information.",
      "startOffset" : 6,
      "endOffset" : 46
    }, {
      "referenceID" : 50,
      "context" : "works (Dodaro et al. 2015; Shchekotykhin 2015) use interaction for filtering the resulting debugging information.",
      "startOffset" : 6,
      "endOffset" : 46
    }, {
      "referenceID" : 4,
      "context" : "Also in further works (Brain et al. 2007; Gebser et al. 2008) which do not explicitely cover interleaved communication between user and system, user information can be used for filtering.",
      "startOffset" : 22,
      "endOffset" : 61
    }, {
      "referenceID" : 22,
      "context" : "Also in further works (Brain et al. 2007; Gebser et al. 2008) which do not explicitely cover interleaved communication between user and system, user information can be used for filtering.",
      "startOffset" : 22,
      "endOffset" : 61
    }, {
      "referenceID" : 46,
      "context" : "Unlike the three-valued ones used for online justifications (Pontelli et al. 2009), these carry only information about atoms considered true.",
      "startOffset" : 60,
      "endOffset" : 82
    }, {
      "referenceID" : 2,
      "context" : "Also in further works (Brain et al. 2007; Gebser et al. 2008) which do not explicitely cover interleaved communication between user and system, user information can be used for filtering. The approaches mentioned in this paragraph realise declarative debugging in the sense of Shapiro (1982), where the user serves as an oracle for guiding the search for errors.",
      "startOffset" : 23,
      "endOffset" : 292
    }, {
      "referenceID" : 2,
      "context" : "Also in further works (Brain et al. 2007; Gebser et al. 2008) which do not explicitely cover interleaved communication between user and system, user information can be used for filtering. The approaches mentioned in this paragraph realise declarative debugging in the sense of Shapiro (1982), where the user serves as an oracle for guiding the search for errors. It is worth highlighting that stepping can be seen as orthogonal to the basic ideas of all the other approaches we discussed. That is, it is reasonable to have a development kit that supports stepping and other debugging methods simultaneously. While debugging is the main focus of this paper, we also consider the computation framework for disjunctive abstract constraint programs introduced in Section 3 an interesting theoretical contribution by itself. Here, an important related work is that of Liu et al. (2010), who also use a notion of computation to characterise a semantics for normal C-programs.",
      "startOffset" : 23,
      "endOffset" : 881
    }, {
      "referenceID" : 29,
      "context" : "Another branch of research, that is related to our notion of computation, focuses on transition systems for analysing answer-set computation (Lierler 2011; Lierler and Truszczyński 2016; Brochenin et al. 2014).",
      "startOffset" : 141,
      "endOffset" : 209
    }, {
      "referenceID" : 30,
      "context" : "Another branch of research, that is related to our notion of computation, focuses on transition systems for analysing answer-set computation (Lierler 2011; Lierler and Truszczyński 2016; Brochenin et al. 2014).",
      "startOffset" : 141,
      "endOffset" : 209
    }, {
      "referenceID" : 6,
      "context" : "Another branch of research, that is related to our notion of computation, focuses on transition systems for analysing answer-set computation (Lierler 2011; Lierler and Truszczyński 2016; Brochenin et al. 2014).",
      "startOffset" : 141,
      "endOffset" : 209
    }, {
      "referenceID" : 37,
      "context" : "These works build on the ideas of a transition system for the DPLL procedure for SAT solving (Nieuwenhuis et al. 2006).",
      "startOffset" : 93,
      "endOffset" : 118
    }, {
      "referenceID" : 29,
      "context" : "for backjumping and learning as used in modern solvers (Lierler 2011).",
      "startOffset" : 55,
      "endOffset" : 69
    }, {
      "referenceID" : 6,
      "context" : "There has been work on transition systems for disjunctive programs (Brochenin et al. 2014).",
      "startOffset" : 67,
      "endOffset" : 90
    }, {
      "referenceID" : 28,
      "context" : "for backjumping and learning as used in modern solvers (Lierler 2011). In contrast, our framework generates ideal (possibly failed) computations without backtracking. Another main difference is that all proposed transition systems have a transition rule for arbitrary assignment of decision literals whereas in our framework truth assignments are restricted to the domain of the C-rule added in the current step. Regarding supported language constructs, to the best of our knowledge, existing transition systems for ASP focus on elementary atoms, i.e., they do not cover aggregates. However, Lierler and Truszczyński (2016) also proposed transition systems for multi-logic systems including ASP.",
      "startOffset" : 56,
      "endOffset" : 624
    }, {
      "referenceID" : 6,
      "context" : "There has been work on transition systems for disjunctive programs (Brochenin et al. 2014). These are based on integrating two sets of transition rules, one for guessing and one for checking of answer set candidates. Similarly, as in the work by Liu et al. (2010), states in transition systems do not keep track of ASP rules as our states do.",
      "startOffset" : 68,
      "endOffset" : 264
    }, {
      "referenceID" : 19,
      "context" : "It might be worthwhile to explore alternative representations for unstability such as elementary loops (Gebser et al. 2011) that possibly provide more pinpoint information.",
      "startOffset" : 103,
      "endOffset" : 123
    }, {
      "referenceID" : 2,
      "context" : "Among these measures are best practices for ASP development that have been discussed in a paper by Brain et al. (2009). For working with the stepping method in particular, we give the following recommendations.",
      "startOffset" : 99,
      "endOffset" : 119
    }, {
      "referenceID" : 38,
      "context" : "that bugs are detected early, using small programs is suggested by an evaluation of the small-scope hypothesis for ASP (Oetsch et al. 2012).",
      "startOffset" : 119,
      "endOffset" : 139
    }, {
      "referenceID" : 25,
      "context" : "Tools like Kara (Kloimüllner et al. 2013) (that is implemented in SeaLion), ASPVIZ (Cliffe et al.",
      "startOffset" : 16,
      "endOffset" : 41
    }, {
      "referenceID" : 9,
      "context" : "2013) (that is implemented in SeaLion), ASPVIZ (Cliffe et al. 2008), IDPDraw (Wittocx 2009), or Lonsdaleite (Smith 2011) allow for visualising interpretations.",
      "startOffset" : 47,
      "endOffset" : 67
    }, {
      "referenceID" : 55,
      "context" : "2008), IDPDraw (Wittocx 2009), or Lonsdaleite (Smith 2011) allow for visualising interpretations.",
      "startOffset" : 15,
      "endOffset" : 29
    }, {
      "referenceID" : 52,
      "context" : "2008), IDPDraw (Wittocx 2009), or Lonsdaleite (Smith 2011) allow for visualising interpretations.",
      "startOffset" : 46,
      "endOffset" : 58
    } ],
    "year" : 2017,
    "abstractText" : "We introduce a stepping methodology for answer-set programming (ASP) that allows for debugging answer-set programs and is based on the stepwise application of rules. Similar to debugging in imperative languages, where the behaviour of a program is observed during a step-by-step execution, stepping for ASP allows for observing the effects that rule applications have in the computation of an answer set. While the approach is inspired from debugging in imperative programming, it is conceptually different to stepping in other paradigms due to non-determinism and declarativity that are inherent to ASP. In particular, unlike statements in an imperative program that are executed following a strict control flow, there is no predetermined order in which to consider rules in ASP during a computation. In our approach, the user is free to decide which rule to consider active in the next step following his or her intuition. This way, one can focus on interesting parts of the debugging search space. Bugs are detected during stepping by revealing differences between the actual semantics of the program and the expectations of the user. As a solid formal basis for stepping, we develop a framework of computations for answer-set programs. For fully supporting different solver languages, we build our framework on an abstract ASP language that is sufficiently general to capture different solver languages. To this end, we make use of abstract constraints as an established abstraction for popular language constructs such as aggregates. Stepping has been implemented in SeaLion, an integrated development environment for ASP. We illustrate stepping using an example scenario and discuss the stepping plugin of SeaLion. Moreover, we elaborate on methodological aspects and the embedding of stepping in the ASP development process. Under consideration in Theory and Practice of Logic Programming (TPLP). ar X iv :1 70 5. 06 56 4v 1 [ cs .A I] 1 8 M ay 2 01 7 2 J. Oetsch, J. Pührer, and H. Tompits",
    "creator" : "LaTeX with hyperref package"
  }
}