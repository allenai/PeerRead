{
  "name" : "1510.01599.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Disjunctive Answer Set Solvers via Templates",
    "authors" : [ "REMI BROCHENIN" ],
    "emails" : [ "remi.brochenin@unige.it)", "ylierler@unomaha.edu)", "marco@dibris.unige.it)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n51 0.\n01 59\n9v 1\nKEYWORDS: Answer Set Programming, Abstract Solvers"
    }, {
      "heading" : "1 Introduction",
      "text" : "Answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems. The idea of answer set programming (ASP) is to represent a given problem\nwith a logic program, whose answer sets correspond to solutions of the problem (see e.g., Lifschitz 1999). ASP has been applied to solve problems in various areas of science and technology including graph-theoretic problems arising in zoology and linguistics (Brooks et al. 2007), team building problems in container terminal (Ricca et al. 2012), and product configuration tasks (Soininen and Niemelä 1999). A fundamental task in ASP is to compute stable models of logic programs. Answer set solvers are the programs that perform this task. There were sixteen answer set solvers participating in the recent Fifth Answer Set Programming Competition1.\nGelfond and Lifschitz introduced logic programs with disjunctive rules (Gelfond and Lifschitz 1991). The problem of deciding whether a disjunctive program has a stable model is ΣP2 -complete (Eiter and Gottlob 1993). The problem of deciding whether a non-disjunctive program has a stable model is NP-complete. The high complexity of reasoning within disjunctive logic programming stems from two sources: first, there is a potentially exponential number of candidate models, and, second, the hardness of checking whether a candidate model is a stable model of a propositional disjunctive logic program is co-NP-complete. Only five answer set systems can solve disjunctive programs: dlv (Leone et al. 2006), gnt (Janhunen et al. 2006), cmodels (Lierler 2005), clasp (Gebser et al. 2013) andwasp (Alviano et al. 2013).\nSeveral formal approaches have been used to describe and compare search procedures implemented in answer set solvers. These approaches range from a pseudocode representation of the procedures (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011). The latter method originates from the work by Nieuwenhuis et al. (2006), where authors propose to use transition systems to describe the Davis-Putnam-Logemann-Loveland (dpll) procedure (Davis et al. 1962). Nieuwenhuis et al. introduce an abstract framework called dpll graph, that captures what states of computation are, and what transitions between states are allowed. Every execution of the dpll procedure corresponds to a path in the dpll graph. Some edges may correspond to unit propagation steps, some to branching, some to backtracking.\nSuch an abstract way of presenting algorithms simplifies their analysis. This approach has been adapted (Lierler 2011; Lierler and Truszczynski 2011) to describing answer set solvers for non-disjunctive programs including smodels, cmodels, and clasp. This type of graphs has been used to relate algorithms in precise mathematical terms. Indeed, once we represent algorithms via graphs, comparing the graphs translates into studying the relationships of underlying algorithms. More generally, the unifying perspective of transition systems brings clarity in the description and comparison of solvers. Practically, such graph representations may serve as an effective tool for analyzing, comparing, proving correctness of, and reasoning formally\n1 https://www.mat.unical.it/aspcomp2014/FrontPage#Participant_Teams\nabout the underlying search algorithms. It may also inspire new ideas in the design of solvers.\nIn this paper we present transition systems that suit multiple disjunctive answer set solvers. We define a general framework, a graph template, which accounts for major techniques implemented in disjunctive answer set solvers excluding backjumping and learning. We study formal properties of this template and we use the template to describe gnt, cmodels and dlv implementing plain backtracking. We then show how a graph template facilitates a design of new solving algorithms by means of combinations of techniques employed in different solvers. For instance, we present a new abstract solver that can be seen as a hybrid between cmodels and gnt. We also present how different solvers may be compared by means of transition systems. In particular, we illustrate a close relationship between answer set solvers dlv and cmodels through the related graphs. The fact that proposed framework does not account for backjumping and learning is one of the reasons that prevents us from capturing such advanced disjunctive answer set solvers as clasp and wasp. It is a direction of future work to investigate how the proposed framework can be adjusted to accommodate these solvers in full generality.\nThe paper is structured as follows. Section 2 introduces required preliminaries. Section 3 presents a first abstract solver related to cmodels. Section 4 defines our general template that accounts for techniques implemented in disjunctive solvers, and Section 5 uses this template to define abstract frameworks for disjunctive solvers. Proofs are presented in Section 6. Section 7 discusses related work and concludes with the final remarks.\nThe current paper builds on the content presented by Brochenin et al. (2014). It enhances the earlier work by introducing notions of a graph template, “propagator conditions”, and “approximating pairs“ that allow to more uniformly account for major techniques implemented in disjunctive answer set solvers. Complete proofs of the formal results are also provided."
    }, {
      "heading" : "2 Preliminaries",
      "text" : ""
    }, {
      "heading" : "2.1 Formulas, Logic Programs, and Program’s Completion",
      "text" : "Formulas. Atoms are Boolean variables over {true, false}. The symbols ⊥ and ⊤ are the false and the true constants, respectively. The letter l denotes a literal, that is an atom a or its negation ¬a, and l is the complement of l, i.e., literal a for ¬a and literal ¬a for a. Propositional formulas are logical expressions defined over atoms and symbols ⊥, ⊤ in usual way. A finite disjunction of literals is a clause. We identify an empty clause with the symbol ⊥. A conjunction (resp. a disjunction) of literals will sometimes be seen as a set, containing each of its literals. Since a clause is identified with a set of its literals, there are no repetition of literals in a clause. A CNF formula is a finite conjunction (alternatively, a set) of clauses. Since a CNF formula is identified with a set of clauses, there are no repetition of clauses in a CNF formula.\nFor a conjunction (resp. a disjunction) D of literals, by D we denote the disjunc-\ntion (resp. the conjunction) of the complements of the elements of D. For example, a ∨ ¬b denotes ¬a∧ b, while a ∧ ¬b denotes ¬a∨ b. For a set L of literals, by L∨ we denote the disjunction of its elements and L∧ the conjunction of its elements; by atoms(L) we denote the set of atoms occurring in L. For a set N of sets of literals by atoms(N) we denote the set of atoms occurring in the elements of N . For example, atoms({a,¬b}) = {a, b} and atoms({{a}, {¬b}}) = {a, b}. For a set L of literals, by L+ we denote atoms that occur positively in L. For instance, {a,¬b}+ = {a}. For a set X of atoms and a set L of literals, by L|X we denote the maximal subset of L over X . For example, {a,¬b, c}|{a,b} = {a,¬b}.\nA (truth) assignment to a setX of atoms is a function from X to {false, true}. An assignment satisfies a formula F if F evaluates to true under this assignment. We call an assignment that satisfies formula F a satisfying assignment or a (classical) model for F . If F evaluates to false under an assignment, we say that this assignment contradicts F . If F has no model we say that F is unsatisfiable. For sets X and Y of atoms such that X ⊆ Y , we identify X with an assignment to Y as follows: if a ∈ X then a maps to true, while if a ∈ Y \\X then a maps to false. We also identify a consistent set L of literals (i.e., a set that does not contain both a literal and its complement) with an assignment to atoms(L) as follows: if a ∈ L then a maps to true, while if ¬a ∈ L then a maps to false. The set M is a complete set of literals over the set of atoms X if atoms(M) = X ; hence a consistent and complete set of literals over X represents an assignment to X .\nLogic Programs. A head is a (possibly empty) disjunction of atoms. A body is an expression of the form\na1, . . . , aj , not aj+1, . . . , not ak (1)\nwhere a1, . . . , ak are atoms, and not is the negation-as-failure operator. We identify body (1) with the following conjunction of literals\na1 ∧ . . . ∧ aj ∧ ¬aj+1 ∧ . . . ∧ ¬ak.\nExpressions a1, . . . , aj and not aj+1, . . . , not ak are called positive and negative parts of the body, respectively. Recall that we sometimes view a conjunction of literals as a set containing all of its literals. Thus, given body B we may write an expression b ∈ B, which means that atom b occurs in the positive part of the body. Similarly, an expression ¬b ∈ B means that the atom b (or, in other words, expression not b) occurs in the negative part of the body.\nA disjunctive rule is an expression of the form A ← B, where A is a head and B is a body. If A is empty we drop it from the expression. A disjunctive logic program is a finite set of disjunctive rules. We call a rule non-disjunctive if its head contains no more than one atom. A program is non-disjunctive if it consists of non-disjunctive rules. By atoms(Π ) we denote the set of atoms occurring in a logic program Π . If we understand A ← B as a classical logic implication, we can see any rule A ← B as logically equivalent to clause A ∨ B (if A is an empty clause then we view the rule as the clause B). This allows us to view a program Π as a CNF formula when useful. Conversely, we identify CNF formulas with logic programs: syntactically,\nevery clause C in a given formula is seen as a rule ← C. For instance a1 ∨ ¬a2 is seen as a rule ← not a1, a2.\nThe presented definition of a logic program accounts for propositional programs only. Indeed, all modern disjunctive answer set solvers consider propositional programs only. In practice, answer set programmers devise programs with variables. Software systems called grounders (Syrjänen 2001; Perri et al. 2007) are used to take a logic program with variables as its input and produce a propositional program as its output so that the resulting propositional program has the same answer sets as the input program.\nReduct and Supporting Rules. In the following definition we write rules in the form A ← B1, B2 where B1 denotes the positive part of the body, whereas B2 denotes the negative part of the body. The reduct ΠX of a disjunctive program Π with respect to a set X of atoms is obtained from Π by deleting each rule A ← B1, B2 such that X ∩ atoms(B2) 6= ∅ and replacing each remaining rule A ← B1, B2 with A ← B1. A set X of atoms is an answer set of a program Π if X is minimal among the sets of atoms that satisfy ΠX .\nFor a program Π , an atom a, and a set L of literals, we call any rule A∨ a ← B\nin Π a supporting rule for a with respect to L when L ∩ (B ∪ A) = ∅.\nA consistent and complete set L of literals over atoms(Π ) is\n1. a classical model of Π if L satisfies every rule in Π ; 2. a supported model of Π if L is a classical model of Π and for every atom\na ∈ L+ there is a supporting rule for a with respect to L;\n3. a stable model of program Π if L+ is an answer set of Π.\nCompletion. The completion comp(Π ) of a program Π is the formula that consists of Π and the formulas\n{¬a ∨ ∨\nA∨a←B∈Π\n(B ∧ A) | a ∈ atoms(Π )}. (2)\nThis formula has the property that any stable model of Π is a classical model of comp(Π ). The converse does not hold in general.\nFor a program Π and a consistent set L of literals over atoms(Π ), a set X of atoms over atoms(Π ) is said to be unfounded (Leone et al. 1997) on L with respect to the program Π when for each atom a ∈ X and each rule A ← B ∈ Π such that a ∈ A, either of the following conditions hold\n1. L ∩B 6= ∅, 2. X ∩B 6= ∅, or 3. (A \\X) ∩ L 6= ∅.\nWe restate Theorem 4.6 from Leone et al. (1997) that relates the notions of\nunfounded set and stable model.\nTheorem 1 For a program Π and a consistent and complete set L of literals over atoms(Π ), L\nis a stable model of Π if and only if L is a classical model of Π and no non-empty subset of L+ is an unfounded set on L with respect to Π .\nThis theorem is crucial for understanding key computational ideas behind modern answer set solvers.\n2.2 Abstract dpll\nThe Davis–Putnam–Logemann–Loveland (dpll) algorithm from Davis et al. (1962) is a well-known method that exhaustively explores sets of literals to generate classical models of a propositional formula. Most satisfiability and non-disjunctive answer set solvers are based on variations of the dpll procedure that is a classical backtrack search-based algorithm. We now review the abstract transition system for dpll proposed by Nieuwenhuis et al. (2006), which is an alternative to common pseudo-code descriptions of backtrack search-based algorithms. For our purposes it is convenient to state dpll as the procedure applied to a logic program in order to find its classical models.\nFor a set X of atoms, a record relative to X is a string L composed of literals over X or the symbol ⊥ so that there are no repetitions, and some literals l may be annotated as l∆. The annotated literals are called decision literals. Figure 1 presents the set of all records relative to the singleton set {a}. We say that a record L is inconsistent if it contains both a literal l and its complement l, or if it contains ⊥, and consistent otherwise. For instance, only five records in Figure 1, namely ∅, a, ¬a, a∆ and ¬a∆, are consistent. We will sometime view a record as the set containing all its elements disregarding their annotations. For example, a record b∆ ¬a is identified with the set {¬a, b}. A basic state relative to X is either\n1. a record relative to X , 2. Ok(L) where L is a record relative to X , or 3. the distinguished state Failstate.\nEach program Π determines its dpll graph DPΠ . The set of nodes of DPΠ consists of the basic states relative to atoms(Π ). A node in the graph is terminal if no edge originates from it. The state ∅ is called initial. The edges of the graph DPΠ are specified by the transition rules presented in Figure 2.\nIntuitively, every state of the dpll graph represents some hypothetical state of the dpll computation whereas a path in the graph is a description of a process of search for a classical model of a given program. The rule Unit asserts that we can add a literal that is a logical consequence of our previous decisions and the\n{\ngiven program. The rule Decide asserts that we make an arbitrary decision to add a literal or, in other words, to assign a value to an atom. Since this decision is arbitrary, we are allowed to backtrack at a later point. The rule Backtrack asserts that the present state of computation is inconsistent but can be fixed: at some point in the past we added a decision literal whose value we can now reverse. The rule Conclude asserts that the current state of computation has failed and cannot be fixed. The rule Success asserts that the current state of computation corresponds to a successful outcome.\nWe say that a graph G checks a set N of sets of literals when all the following\nconditions hold:\n1. G is finite and acyclic; 2. Any terminal state in G is either Failstate or of the form Ok(L); 3. If a state Ok(L) is reachable from the initial state in G then L|atoms(N) ∈ N ; 4. Failstate is reachable from the initial state in G if and only if N is empty.\nProposition 1\nFor any program Π , the graph DPΠ checks the classical models of Π .\nThus, to decide the satisfiability of a program Π it is enough to find a path leading from node ∅ to a terminal node. If it is Failstate, then Π has no classical models. Otherwise, Π has classical models. For instance, let Π1 be\n← not a, not b ← a, not c.\nFigure 3 presents two paths in DPΠ1 from the node ∅ to the node Ok(a ∆ c b∆). Every edge is annotated on the left by the name of the transition rule that gives rise to this edge in DPΠ1 . The node Ok(a ∆ c b∆) is terminal. Thus, Proposition 1 asserts that Π1 is satisfiable and {a, c, b} is a classical model of Π1.\nA path in the graph DPΠ is a description of a process of search for a classical\nmodel of a program Π . The process is captured via applications of transition rules. Therefore, we can characterize the algorithm of a solver that utilizes the transition rules of DPΠ by describing a strategy for choosing a path. A strategy can be based on assigning priorities to transition rules of DPΠ so that a solver never applies a rule in a node if a rule with higher priority is applicable to the same node. The dpll procedure is captured by the priorities ordered as we stated rules in Figure 2. For instance, transition rule Conclude has the highest priority. In Figure 3, the path on the left complies with the dpll priorities: Thus, it corresponds to an execution of the dpll procedure. The path on the right does not: it uses Decide when Unit is applicable. The proof of Proposition 1 follows the lines of the proof of Theorem 2.13 in Nieuwenhuis et al. (2006)2.\nAbstract Answer Set Solver for Non-disjunctive Programs. Lierler (2011) illustrated that extending DPΠ by a transition rule\nUnfounded : L =⇒ L ¬a if\n  \n  ¬a does not occur in L and L is consistent and there is a set X of atoms containing a such that X is unfounded on L w.r.t. Π\ncaptures a backtrack-search procedure for finding answer sets of non-disjunctive programs. Many answer set solvers for such programs can be seen as extensions of this procedure (Lierler and Truszczynski 2011)."
    }, {
      "heading" : "3 A Two-Layer Abstract Solver",
      "text" : "The problem of deciding whether a disjunctive program has a stable model is ΣP2 - complete (Eiter and Gottlob 1993). This translates into the following: (i) there is an exponential number of possible candidate models, and (ii) the problem of deciding whether a candidate model is an answer set of a disjunctive logic program is coNP-complete. The latter condition differentiates algorithms of answer set solvers for disjunctive programs from the procedures for non-disjunctive programs. Indeed, the problem of deciding whether a candidate model is an answer set of a non-disjunctive program is tractable.\n2 This work defines a different dpll graph, avoiding the reference to the transition rule Success. The presence of this rule in this presentation is important for the generalizations of the dpll graph we introduce in the sequel.\nA common architecture of a disjunctive answer set solver is composed of two layers corresponding to the two above conditions: a generate layer and a test layer, each typically based on dpll-like procedures. In particular:\n• The generate layer is used to obtain a set of candidates that are potentially\nstable models.\n• The test layer is used to verify whether a candidate (produced by the generate\nlayer) is a stable model of the given program.\nWe now proceed to present a graph DP 2g,t(Π ) that captures such two-layer architecture. It is based on instances of the dpll procedure for both its generating task and its testing task. We then illustrate how the DP 2g,t(Π ) transition system can be used to capture the disjunctive answer set solver cmodels in its basic form.\n3.1 A Two-Layer Abstract Solver via dpll\nWe start by extending the notion of a basic state to accommodate for generate and test layers. We call symbols L and R labels. A state relative to sets X and X ′ of atoms is either\n1. a pair (L,R)s, where L and R are records relative to X and X ′, respectively,\nand s is a label (either symbol L or R),\n2. Ok(L), where L is a record relative to X , or 3. the distinguished state Failstate.\nWe say that a set M of literals covers a programΠ if atoms(Π ) ⊆ atoms(M). We say that a function g from a program to another program is a generating (program) function if for any program Π , atoms(Π ) ⊆ atoms(g(Π )). We call a function from a program Π and a consistent set M of literals covering Π to a non-disjunctive program Π ′ a witness (program) function. Intuitively, a program Π ′ resulting from a witness function is a witness (program) with respect to Π andM . For a programΠ and a witness function t, by atoms(t,Π , X) we denote the union of atoms(t(Π , L)) for all possible consistent and complete sets L of literals over X .\nWe are now ready to define a graph DP 2g,t(Π ) for a generating function g, a witness function t and a program Π . The set of nodes of DP 2g,t(Π ) consists of the states relative to sets atoms(g(Π )) and atoms(t,Π , atoms(g(Π ))). The state (∅, ∅)L is called initial. The edges of the graph DP 2g,t(Π ) are specified by the transition rules presented in Figure 4. The graph DP 2g,t(Π ) can be used for deciding whether a program g(Π ) has a classical model M such that the witness t(Π ,M) is unsatisfiable.\nProposition 2\nFor any generating function g, any witness function t and any programΠ , the graph\nDP 2g,t(Π ) checks the classical models M of g(Π ) such that t(Π ,M) is unsatisfiable.\nInformal Account of the Two-Layer Abstract Solver. Each of the rules of the graph DP 2g,t(Π ) is placed into one of the three groups Left, Right, and Crossing. The leftrules of DP 2g,t(Π ) capture the generate layer that applies the dpll procedure to the program g(Π ) produced by the generating function. The right-rules of DP 2g,t(Π ) capture the test layer that applies the dpll procedure to the computed witness program. The label L (resp. R) suggests that currently the computation is within the generate (resp. test) layer. The left-hand-side L (resp. right-hand-side R) of the state (L,R)L records the computation state due to the generate (resp. test) layer. The crossing rules form a bridge between the two layers.\nIt turns out that the left-rules no longer apply to a state of the form (L,R)L only when L is a classical model of g(Π ). Thus, when a classical model L of g(Π )\nis found, then the CrossLR is used and a witness program with respect to L is computed. If no classical model is found for the witness program, then ConcludeR rule applies, which brings us to a terminal state Ok(L), suggesting that L represents a solution to a given search problem. It turns out that no right-rules applies in a state of the form (L,R)R only when R is a classical model for the witness program. Thus, the set L of literals is not such that t(Π ,M) is unsatisfiable and the dpll procedure of the generate layer, embodied by the left-rules, proceeds with the search, after backtracking through BacktrackRL. In the case when BacktrackRL cannot be applied, it follows that no other candidate can be found by the generate layer, so the transition ConcludeRL leading to Failstate is the only available one from such a state.\n3.2 Abstract basic cmodels\nWe now relate the graph DP 2g,t(Π ) to the procedure dp-assat-proc from Lierler (2005). This procedure forms the basis of the answer set solver cmodels. Yet, it does not account for backjumping and learning techniques, implemented in cmodels.\nGiven a disjunctive program Π , the answer set solver cmodels starts its computation by computing a CNF formula gC(Π ) that corresponds to the clausified program completion of Π . The dpll procedure is then applied to gC(Π ). The test layer of the cmodels computation relies on the programs produced by a witness program function called tC that intuitively tests minimality of found models of completion.\nTo be complete in our presentation, we now review the details of gC and tC functions (Lierler 2010). To construct gC(Π ), cmodels introduces an auxiliary atom αB for every body B occurring in Π . The atom αB is an explicit definition for B, it is true if and only if B is true. Also every disjunctive rule gives rise to as many auxiliary variables as there are atoms in the head of the rule: for a disjunctive rule A ← B and every atom a ∈ A, an auxiliary atom αa,B is equivalent to a conjunction B ∧ A′, where A′ is (A \\ {a})∨. Formulas (3) and (4) present the definitions of gC and tC for a program Π. The first four lines of the definition of the CNF formula gC(Π ) concern clausification of the introduced explicit definitions, namely αB and αa,B. The last two lines encode clausified completion with the use of αB and αa,B.\ngC(Π ) = {αB ∨B | B ∈ Bodies(Π )}\n{¬αB ∨ a | B ∈ Bodies(Π ), a ∈ B} {αa,B ∨ ¬αB ∨ A | A ∨ a ← B ∈ Π } {¬αa,B ∨ b | A ∨ a ← B ∈ Π , b ∈ A ∪ {αB}} {¬αB ∨ A | A ← B ∈ Π } {¬a ∨\na←B∈Π\nαB ∨\nA∨a←B∈Π\nαa,B}\n(3)\ntC(Π ,M) = {M+|atoms(Π ) ∨ }∪\n{¬a | ¬a ∈ M|atoms(Π )}∪ {B ∨ A | A ← B ∈ ΠM + , B ⊆ M},\n(4)\nIntuitively, cmodels uses the program gC(Π ) as an approximation of Π during the generate-layer computation. Indeed, any stable model of Π is also a classical model of gC(Π ). The converse does not always hold. Thus, classical models of gC(Π ) must be checked. For a classical model M of gC(Π ), a program produced by tC(Π ,M) has no classical models iff M is a stable model of Π . In fact, any model N of tC(Π ,M) is such that it satisfies the reduct ΠM +\n, while N+ ⊂ M+|atoms(Π ). In\nsuch case, M+|atoms(Π ) is not an answer set of Π by definition and, consequently, M is not a stable model of Π.\nBy DP 2Π we denote the graph DP 2 gC ,tC (Π ). Proposition 3 below illustrates that the graph DP 2Π can be used for deciding whether a given program Π has a stable model, similarly as the graph DPΠ can be used for deciding whether Π has a classical model.\nProposition 3\nFor any program Π , the graph DP 2Π checks the stable models of Π .\nThe graph DP 2Π captures the search procedure of dp-assat-proc of cmodels. The dp-assat-proc algorithm follows the priorities on its transition rules as they are ordered in Figure 4. We often use this convention when describing other procedures in the sequel."
    }, {
      "heading" : "4 Graph Templates",
      "text" : "The differences in design choices of disjunctive answer set solvers obscure the understanding of their similarities. In Brochenin et al. (2014), transition systems exemplified by the graph DP 2Π were used to capture several disjunctive solvers, namely, cmodels, gnt and dlv implementing backtracking. The transitions systems made the similarities that these solvers share explicit. For example, all solvers are based on a two-layer approach in the spirit of the dp-assat-proc algorithm. In this work, we make an additional move towards a unifying framework for capturing two-layer methods. We introduce a graph template that we then use to encompass disjunctive solvers cmodels, gnt and dlv."
    }, {
      "heading" : "4.1 A Single Layer Graph Template",
      "text" : "In the next section we will define a graph template suitable for capturing twolayer computation of disjunctive answer set solvers. As a step in this direction, we describe here a simpler graph template that can be used to capture the dpll procedure by encapsulating the dpll graph. We also show that this template can encapsulate a graph capturing the computation underlying the algorithm of answer set solver smodels for non-disjunctive programs.\nTemplate. A function from a program Π and a set of literals over atoms(Π ) to a set of literals over atoms(Π ) is called a propagator condition or, shortly, p-condition. Figure 5 presents four p-conditions, namely, UnitPropagate, AllRulesCancelled, BackchainT rue, and Unfounded . For a set P of p-conditions, a program Π and a set M of literals, by P(Π ,M) we denote the set of literals ⋃\np∈P p(Π ,M). Intu-\nitively, if each image through a p-condition is a set of possible outcomes, this set represents the union of the possible outcomes through P .\nDefinition 1 Given a a program Π and a set P of p-conditions, a dpll graph template DPTP,Π is a graph of which nodes are the basic states relative to atoms(Π ) and edges are specified by the transition rules Conclude, Backtrack, Decide, Success presented in Figure 2 and the transition rule\nPropagate L =⇒ Ll if l ∈ P(Π , L). (5)\nFor instance, the instantiation DPT{UnitPropagate},Π of the dpll graph template results in the dpll graph DPΠ . Indeed, by definition these graphs share the same nodes as well as their rules Conclude, Backtrack, Decide, and Success coincide. Then, one can see that l ∈ UnitPropagate(Π , L) if and only if the transition rule Unit in DPΠ is applicable in L and supports the transition to a state Ll, which shows that the Unit rule and the Propagate rule coincide when P = {UnitPropagate}.\nInstantiation. We call types the elements of the set T = {cla, sup, sta}. In the following, by cla-model, sup-model and sta-model we denote classical, supported, and stable models, respectively. We also use letter w to denote a variable over set T of types. We say that a set P of p-conditions is w-sound if for any program Π , for\nany set M of literals, and for any w-model M1 of Π such that M ⊆ M1, it also holds that P(Π ,M) ⊆ M1. Note that any cla-sound set of p-conditions is sup-sound, and any sup-sound set of p-conditions is sta-sound. We say that a set P of p-conditions is w-complete when for any program Π and any consistent and complete set M of literals over atoms(Π ), set M is a w-model of Π if and only if P(Π ,M) = ∅. For a type w, we say that a set P of p-conditions is w-enforcing if P is both w-sound and w-complete.\nNext theorem summarizes properties of several sets of p-conditions:\nup = {UnitPropagate} sd = {UnitPropagate, AllRulesCancelled,BackchainTrue}\nsm = {UnitPropagate, AllRulesCancelled,BackchainTrue,Unfounded}\nTheorem 2 The following statements hold:\n1. The set up is cla-enforcing; 2. All the subsets of sd that contain {UnitPropagate, AllRulesCancelled} are\nsup-enforcing; and\n3. All the subsets of sm that contain {UnitPropagate,Unfounded} are sta–\nenforcing.\nWe are now ready to state the main result of this section.\nTheorem 3 For any program Π , any type w, and any w-enforcing set of p-conditions P , the graph DPTP,Π checks the w-models of Π .\nTheorems 2 and 3 give rise to families of valid solvers for deciding where classical, supported, or stable models exist for a program. For instance, for a non-disjunctive program Π , the graph DPTsm,Π coincides with the graph smΠ (Lierler 2011) that captures computation of answer set solver smodels (Simons et al. 2002). The graph DPTsd,Π coincides with the graph atleastΠ (Lierler 2011) that provides a procedure for deciding whether a non-disjunctive program has supported models. For a disjunctive program Π the same single layer graph DPTsm,Π forms a procedure for deciding whether Π has a stable model. Note, however, that generally the problem of deciding whether l ∈ Unfounded(Π , L) is np-complete for the case when Π is disjunctive."
    }, {
      "heading" : "4.2 A Two-Layer Graph Template",
      "text" : "We extend here the approach of Section 4.1 to capture two-layer methodology of disjunctive solvers.\nDefinition 2 Given a program Π , sets PL and PR of p-conditions, a generating function g, and a witness function t, a two-layer template graph STTPL,gPR,t (Π ) is a graph defined as follows:\n• The set of nodes is, as in the previous two-layer graphs, the set of states relative to\natoms(g(Π )) and atoms(t,Π , atoms(g(Π ))); and\n• The transition rules are the rules presented in Figure 4 except the rules UnitL and\nUnitR, that are replaced by the rules PropagateL and PropagateR presented in Figure 6.\nDescription of the Template. We call the state (∅, ∅)L initial. Note how the rules PropagateL and PropagateR in STT PL,g PR,t (Π ) refer to the parameters PL, PR, g and t of the graph template. Varying these parameters will allow us to specify transition systems that capture different disjunctive answer set solvers. Intuitively, the parameters PL and PR are sets of p-conditions defining a propagation rule on generate and test side of computation, respectively.\nThe instantiation STT up,g C\nup,tC (Π ) of the two-layer graph template results in DP 2Π .\nIndeed, the graphs share the same nodes. Also their rules ConcludeL, ConcludeR, DecideL, DecideR, BacktrackL, BacktrackR and ConcludeRL coincide. It is easy to see that a literal l is in up(gC(Π ), L) if and only if the transition rule UnitL in DP 2Π is applicable in (L, ∅)L and supports the transition to a state (Ll, ∅)L. Thus, the transition rule PropagateL supports the transition from (L, ∅)L to (Ll, ∅)L if and only if the transition rule UnitL supports the same transition. A similar statement holds for the case of PropagateR and UnitR.\nRecall that in Section 3.2 we showed that cmodels implementing backtracking\ncan be defined using the graph DP 2Π . The fact that instantiation STT up,gC up,tC (Π ) coincides with DP 2Π illustrates that the introduced template is sufficient for capturing existing solvers. Next section demonstrates that the proposed template is suitable for capturing gnt and dlv.\nInstantiation: Approximating and Ensuring Pairs. In the definition of the two-layer template graph STTPL,gPR,t (Π ) we pose no restrictions on its four key parameters: sets PL, PR of p-conditions, and generating and witness functions g, t. In practice, when this template is utilized to model, characterize, and elicit disjunctive solvers these four parameters exhibit specific properties. We now introduce terminology that allows us to specify essential properties of these parameters that will translate into correctness of solvers captured by properly instantiated template. On the one hand, we introduce the conditions on generating and witness functions under which we call these functions ”approximating“ and ”ensuring“, respectively. On the other hand, we couple these conditions with restrictions on sets of p-conditions so that we can speak of (i) approximating-pair (Pg, g) for a set Pg of p-conditions and a generating function g, and (ii) ensuring-pair (Pt, t) for a set Pt of p-conditions and\na witness function t. For such pairs, the template instantiation STT Pg,g Pt,t (Π ) results in a graph that checks stable models of Π . As a result, when we characterize such solvers as gnt and dlv by means of the two-layer template we focus on (i) specifying their generating and witness function as well as their sets of p-conditions, and (ii) illustrating that they form proper approximating and ensuring pairs. This also brings us to the realization that an inception of a novel solver can be triggered by a creation of a novel approximation and ensuring pairs or their combinations. We now make these ideas precise.\nFor types w and w1, we say that a generating function g is w1-approximating\nwith respect to type w if for any program Π :\n1. For any stable model L of Π there is a w1-model L1 of g(Π ) such that\nL = L1|atoms(Π ); and\n2. For any w1-model M of g(Π ), M|atoms(Π ) is a w-model of Π .\nConsider the generating function cnfcomp(Π ) that returns a CNF formula, which stands for the completion comp(Π ) converted to CNF using straightforward equivalent transformations. In other words, cnfcomp(Π ) consists of clauses of two kinds\n1. the rules A ← B of the program written as clauses A ∨B, and 2. formulas of cnfcomp(Π ) from (2) converted to CNF using the distributivity\nof disjunction over conjunction.3\nThe function cnfcomp is cla-approximating with respect to sup. Indeed,\n1. any stable model of a program Π is also a cla-model of cnfcomp(Π ), and 2. any cla-model of cnfcomp(Π ) is a sup-model of Π .\nSince any supported model is also a classical model, the cnfcomp function is also cla-approximating with respect to cla. Note that when a generating function g is w1-approximating with respect to w, then enumerating all w1-models of g(Π ) results in enumerating some w-models of Π modulo a restriction to atoms(Π ).\nFor types w and w1, and a witness function t, we say that t is w1-ensuring with respect to w when for any set M of literals covering Π such that M|atoms(Π ) is w-model of Π , M|atoms(Π ) is a stable model of Π if and only if t(Π ,M) results in a program that has no w1-model.\nFor instance, the witness function tC is cla-ensuring with respect to cla. Since any sup-model is also a cla-model, the function tC is also cla-ensuring with respect to sup. It is easy to see that when a witness function t is w1-ensuring with respect to w, then given any w-model L of a program Π we may use the function t to test that L is also a stable model of Π . Indeed, an application of t resulting in a program that has no w1-models translates into the statement that L is a stable model of Π .\nThese newly defined concepts of approximating and ensuring functions provide\nthe following characterization for the set of stable models of a program Π .\n3 It is essential that repetitions are not removed in the process of clausification. For instance, cnfcomp(a← not a) = (a ∨ a) ∧ (¬a ∨ ¬a).\nProposition 4 For any types w, w1 and w2, generating function g that is w1-approximating with respect to w, witness function t that is w2-ensuring with respect to w, and program Π , the set of all stable models of Π is\n{L|atoms(Π ) | L is a w1-model of g(Π ) and t(Π , L) has no w2-models}.\nWe now introduce the notion of ensuring and approximating pairs that permit an operational use of generating and witness functions, by matching them with a relevant set of propagators. We call a pair (P , g) of a set of p-conditions and a generating function an approximating-pair with respect to w if for some type w1, the set P is w1-enforcing and the function g is w1-approximating with respect to w. For example, the pair (up, cnfcomp) is an approximating-pair with respect to sup as well as to cla. The (up, gC) is also an approximating-pair with respect to sup as well as to cla.\nWe call a pair (P , t) of a set of p-conditions and a witness function an ensuringpair with respect to w if for some type w1, the set P is w1-enforcing and the function t is w1-ensuring with respect to w. For example, the pair (up, t C) is an ensuring-pair with respect to any defined type.\nWe are now ready to state the main result of this section.\nTheorem 4\nFor any program Π , any type w, any (Pg, g) approximating-pair with respect to w,\nand any (Pt, t) ensuring-pair with respect to w, the graph STT Pg,g Pt,t (Π ) checks the stable models of Π .\nTheorem 4 illustrates how the template STT Pg,g Pt,t (Π ) can serve as a framework for defining transitions systems that result in correct algorithms for deciding whether a program Π has a stable model. The facts that (up, gC) is an approximating-pair with respect to cla and that (up, tC) is an ensuring-pair with respect to cla, together with Theorem 4, subsume the result of Proposition 3.\nWe now state propositions that capture interesting properties about states of the\ngraph STT Pg,g Pt,t (Π ). The former proposition concerns states with the label L, the latter concerns states with the label R.\nProposition 5\nFor any type w, generating function g, witness function t, w-enforcing set of pconditions Pg, set of p-conditions Pt, and program Π , if no left-rule is applicable in some state (l1. · · · .lk1 , r1. · · · .rk2)L in STT Pg,g Pt,t (Π ) reachable from the initial state, then l1. · · · .lk1 is a w-model of g(Π ).\nProposition 6\nFor any types w1 and w2, generating function g witness function t, w1-enforcing set of p-conditions Pg, w2-enforcing set of p-conditions Pt, program Π , and a state (l1. · · · .lk1 , r1. · · · .rk2)R in STT Pg,g Pt,t (Π ) reachable from the initial state, the following conditions hold:\n(a) t(Π , l1. · · · .lk1) is defined,\n(b) r1. · · · .rk2 is a set of literals over t(Π , L), (c) l1. · · · .lk1 is a w1-model of g(Π ), and (d) If no right-rule is applicable to (l1. · · · .lk1 , r1. · · · .rk2)R then r1. · · · .rk2 is a\nw2-model of t(Π , l1. · · · .lk1)."
    }, {
      "heading" : "5 Applications of the Template",
      "text" : "Section 3.2 illustrates how cmodels implementing backtracking can be defined using the graph DP 2Π , while the previous section states that the instantiation STT up,gC\nup,tC (Π ) of the two-layer graph template results in DP 2Π . Thus, this template is suitable for capturing computations of cmodels. In this section, we show how the template also captures the solvers gnt and dlv without backjumping. Then, we discuss how the framework facilitates the design of new abstract solvers and their comparison, by means of inspecting the structures of the related graphs.\nAbstract gnt. We now show how the procedure underlying disjunctive solver gnt can be captured by the two-layer template. Unlike solver cmodels that uses the dpll procedure for generating and testing, system gnt uses the smodels procedure for respective tasks. Recall that the smodels procedure finds stable models for nondisjunctive logic programs, while the dpll procedure finds classical models. The graph smΠ (Section 4.1) captures the computation underlying smodels just as the graphDPΠ captures the computation underlying dpll. It forms a basis for devising the transition system suitable to describe gnt. The graph describing the general structure of gnt is obtained from the graph template STT sm,gsm,t (Π ) that rely on the set sm of p-contitions.4\nJanhunen et al. (2006) define the generating function gG and the witness function tG used in gnt. We present these definitions in (6) and (7).5 For a disjunctive program Π , by ΠN we denote the set of non-disjunctive rules of Π , by ΠD we denote the set of disjunctive rules Π \\ΠN . For each atom a in atoms(Π ) let a r and as be new atoms.\ngG(Π ) = {a ← B, not ar | A ∨ a ← B ∈ ΠD}∪\n{ar ← not a | A ∨ a ← B ∈ ΠD}∪ {← A,B | A ← B ∈ ΠD}∪ ΠN∪ {as ← A \\ {a}, B | A ∨ a ← B ∈ ΠD}∪ {← a, not as | a ∨ A ← B ∈ ΠD}\n(6)\n4 The graph template STT sm,gsm,t (Π ) corresponds to the graph SM 2 g(Π),t defined in (Brochenin\net al. 2014). 5 The presented functions gG and tG capture the essence of functions Gen and Test defined by Janhunen et al., but they are not identical. Our language of disjunctive programs includes rules with empty heads. This allows us a more concise description.\ntG(Π ,M) = {a ← B, not ar | A ∨ a ← B ∈ ΠMD , a ∈ M,B ⊆ M}∪\n{ar ← not a | A ∨ a ← B ∈ Π }∪ {← A,B | A ← B ∈ ΠMD , B ⊆ M}∪ {a ← B | a ← B ∈ ΠMN , a ∈ M,B ⊆ M}∪ {← M|atoms(Π )}\n(7)\nBy SM2Π we denote the graph STT sm,gG sm,tG (Π ). The graph SM2Π captures the gnt procedure by Janhunen et al. (2006) in a similar way as the graph DP 2Π captures the cmodels procedure of dp-assat-proc in Section 3.2. Figure 7 presents an example of a path in a graph SM2{a←c;b←c;c←a,b;a∨b←}. From the formal results by Janhunen et al. (2006) it immediately follows that gG is sta-approximating with respect to cla and tG is sta-ensuring with respect to cla. The pair (sm, gG) is an approximating-pair with respect to cla, while (sm, tG) is an ensuring-pair with respect to cla. The following result immediately follows from Theorem 4.6\nCorollary 1\nFor any Π the graph SM2Π checks the stable models of Π .\n6 Corollary 1 corresponds to Theorem 5 in (Brochenin et al. 2014).\nAbstract dlv without Backjumping. This section introduces graphs that capture the answer set solver dlv without backjumping. The generate layer, i.e., the left-rule layer, is reminiscent to the smodels algorithm except it does not use Unfounded . The test layer applies the dpll procedure to a witness formula.\nThe graph templates STT sd,gup,t (Π ) describes the general structure of dlv. The generating function gD is the identity function as in (8), and the witness function tD follows in (9).\ngD(Π ) = Π (8)\ntD(Π ,M) = {(B ∩M+) ∨ ∨ A′ ∨ | A ← B ∈ ΠM + , B ⊆ M,A′ = A ∩M+}∪\n{(M|atoms(Π )) ∨}\n(9)\nFollowing the results from Faber (2002) and Koch et al. (2003), the generating function gD is sup-approximating with respect to cla while the witness function tD is cla-ensuring with respect to cla. The pair (sd, gD) is an approximating-pair with respect to cla, while (up, tD) is an ensuring-pair with respect to cla. The result below immediately follows from Theorem 4.7\nCorollary 2\nFor any Π the graph STT sd,g D\nup,tD (Π ) checks the stable models of Π .\n7 Corollary 2 corresponds to Theorem 6 in (Brochenin et al. 2014).\nThis corollary is an alternative proof of correctness for the dlv algorithm previously stated by Faber (2002) and Koch et al. (2003) in terms of pseudo-code. Figure 8 presents an example of a path through one of the graph describing abstract dlv.\nDesigning new Graphs and Comparing Graphs. The two-layer graph template can be conveniently used to define new abstract solvers. For instance, one may choose to combine (up, gC) with (sm, tG) to obtain a solver captured by the graph template STT up,g C\nsm,tG (Π ). Theorem 4 provides a proof of correctness for the procedure\nsummarized by this family of graphs. More generally, to obtain a new solver one can combine any approximating-pair on the left side of the graphs with any ensuringpair on the right side with respect to the same type. For instance, for any pair (P , t) that is ensuring with respect to cla, the family of graphs STT up,cnfcompP,t (Π ) captures a correct procedure for a disjunctive answer set solver.\nIn the following, we illustrate how abstract solvers can serve also as a convenient tool for comparing search procedures from an abstract point of view, by means of comparison to the related graphs. In this respect we now state the result that illustrates a strong relation between cmodels and dlv. Indeed, their generate layer:\nTheorem 5\nFor any (P , t) ensuring-pair with respect to cla, and any program Π , the graphs\nSTT up,cnfcomp P,t (Π ) and STT\nsd,gD P,t (Π ) are identical graphs."
    }, {
      "heading" : "6 Proofs",
      "text" : ""
    }, {
      "heading" : "6.1 Proof of Theorem 2",
      "text" : "We start by stating several lemmas that will be instrumental in constructing arguments for Theorem 2. Recall that up = {UnitPropagate}.\nLemma 1 The set up is cla-complete.\nIn other words, for any program Π and any complete and consistent set M of literals over atoms(Π ), the set M is a cla-model of Π iff UnitPropagate(Π ,M) = ∅."
    }, {
      "heading" : "Proof",
      "text" : "Left-to-right: Let M be a cla-model of Π . Our proof is by contradiction. Assume that UnitPropagate(Π ,M) 6= ∅. Take any literal l from this set. Then, the literal l is such that it does not belong to M . Also, there is a rule in Π that is equivalent to a clause C ∨ l so that all the literals of C occur in M . Since M is a cla-model of Π , we conclude that l ∈ M . We derive a contradiction.\nRight-to-left: Let UnitPropagate(Π ,M) = ∅. By contradiction. Assume that M is not a cla-model of Π . Then there is a rule in Π that is equivalent to a clause C∨ l so that all the literals of C as well as l occur in M (indeed, M is a complete set of literals over atoms(Π ) that does not satisfy some rule in Π ). Since M is consistent, l 6∈ M . It follows that l ∈ UnitPropagate(Π ,M). We derive a contradiction.\nLemma 2 For any program Π , any atom a, and any sets M and M ′ of literals such that M ⊆ M ′, if a rule in Π is not a supporting rule for a with respect to M then this rule is also not a supporting rule for a with respect to M ′."
    }, {
      "heading" : "Proof",
      "text" : "By contradiction. Assume that there is a rule A ∨ a ← B in Π such that it is not a supporting rule for a with respect to M but it is a supporting rule for a with respect to M ′. It follows that M ∩ (B ∪ A) 6= ∅, while M ′ ∩ (B ∪ A) = ∅. This contradicts the fact that M ⊆ M ′.\nWe now generalize Lemma 4 from Lierler (2008) to the case of disjunctive pro-\ngrams.\nLemma 3 For any unfounded set U on a consistent set L of literals w.r.t. a program Π and any consistent and complete set M of literals over atoms(Π ), if L ⊆ M and M ∩U 6= ∅, then M is not a stable model of Π ."
    }, {
      "heading" : "Proof",
      "text" : "By contradiction. Assume that M is a stable model of Π . Then, M is a classic model of Π also. By Theorem 1, M is such that there is no non-empty subset of M+ such that it is an unfounded set on M w.r.t. Π . Since M ∩ U 6= ∅, it follows that M ∩ U is not an unfounded set on M w.r.t. Π . It follows that for some rule a ∨ A ← B ∈ Π such that a ∈ M ∩ U all of the following conditions hold\n1. M ∩B = ∅, 2. M ∩ U ∩B = ∅, and 3. (A \\ (M ∩ U)) ∩M = ∅.\nSince M ∩ B = ∅ and L ⊆ M it follows that L ∩ B = ∅. Since M ∩ B = ∅ and the fact that M is consistent and complete set of literals over atoms(Π ), B+ ⊆ M . Consequently U ∩B+ = M ∩U ∩B+ = ∅. Since L ⊆ M and (A\\ (M ∩U))∩M = ∅, it follows that (A \\ U) ∩ L = ∅. Consequently, the set U is not an unfounded set on L.\nWe are now ready to introduce the proof of Theorem 2."
    }, {
      "heading" : "Proof of Theorem 2",
      "text" : "Statement 1. We have to show that the set up is cla-enforcing. Lemma 1 states that the set up is cla-complete. Thus, we only ought to illustrate that up is cla-sound. Let Π be any program, M be any set of literals, M ′ be any cla-model of Π such that M ⊆ M ′. We have to show that up(Π ,M) ⊆ M ′. Let l be any literal in up(Π ,M). We now show that l ∈ M ′. The p-condition UnitPropagate is the only member of the set up. Thus, up(Π ,M) = UnitPropagate(Π ,M). It follows that l ∈ UnitPropagate(Π ,M). By the conditions of UnitPropagate definition, there is a rule in Π that is equivalent to a clause C ∨ l so that all the literals of C occur in\nM . Since M ⊆ M ′, it follows that all the literals of C occur in M ′. From the fact that M ′ is cla-model of Π it follows that M ′ |= C ∨ l. Consequently, l ∈ M ′.\nStatement 2. We have to show that the subsets of sd containing {UnitPropagate, AllRulesCancelled} are sup-enforcing. We first illustrate this property for the set {UnitPropagate, AllRulesCancelled}. We call this set ua. We start by showing that the set ua is sup-sound. Let Π be any program, M be any set of literals, M ′ be any sup-model of Π such that M ⊆ M ′. We have to illustrate that the set ua(Π ,M) is a subset of M ′. Consider any literal l in the set ua(Π ,M). We now show that l is also in M ′.\nCase 1. l ∈ UnitPropagate(Π ,M). Since M ′ is a sup-model, M ′ is also a clamodel. The rest of the argument follows the lines of proof in Statement 1, which illustrates that up is cla-sound.\nCase 2. l ∈ AllRulesCancelled(Π ,M). l has the form ¬a. By the conditions of AllRulesCancelled definition, it follows that there is no rule in Π supporting a with respect to M . By Lemma 2, we derive that there is no rule in Π supporting a with respect to M ′. From the fact that M ′ is sup-model of Π it follows that ¬a ∈ M ′. (Indeed, a may not be a member of M ′, while M ′ is a complete set of literals over atoms(Π ).)\nSecond, we show that the set ua is sup-complete. Let Π be any program, M be any complete and consistent set of literals over atoms(Π ). We now show that M is sup-model of Π iff ua(Π ,M) = ∅.\nLeft-to-right: Let M be a sup-model of Π . By contradiction. Assume that the\nset ua(Π ,M) is not empty. Then there is a literal l in this set.\nCase 1. l ∈ UnitPropagate(Π ,M). Since M is also cla-model of Π , by Lemma 1\nwe derive a contradiction.\nCase 2. l ∈ AllRulesCancelled(Π ,M). l has the form ¬a. By the conditions of AllRulesCancelled definition, it follows that (i) literal ¬a is such that it does not belong to M , and (ii) there is no supporting rule in Π for a with respect to M . Since M is a sup-model of Π , we conclude from (ii) that ¬a ∈ M . This contradicts (i).\nRight-to-left: Assume ua(Π ,M) = ∅. By contradiction. Assume that M is not a sup-model of Π . Then either M is not a cla-model of Π or there is an atom a ∈ M+ such that there is no supporting rule in Π for a with respect to M . In the former case, when M is not a cla-model of Π , by Lemma 1 we derive a contradiction. In the latter case, it follows that ¬a ∈ AllRulesCancelled(Π ,M) by the conditions of the AllRulesCancelled definition. We derive a contradiction.\nWe now show that the set sd is sup-enforcing. We start by claiming that the set sd is sup-sound. Let Π be any program, M be any set of literals, M ′ be any sup-model of Π such that M ⊆ M ′. We have to illustrate that the set sd(Π ,M) is a subset of M ′. Consider any literal l in the set sd(Π ,M). We show that l is also in M ′. Given a proof that ua is sup-sound, it is only left to be proved that for any literal l that is in BackchainT rue(Π ,M), it also holds that l ∈ M ′. Consider literal l ∈ BackchainT rue(Π ,M). By the definition of BackchainT rue it follows that there is a rule r = A ∨ a ← B in Π so that (i) a ∈ M , and (ii) either l ∈ A or l ∈ B and, (iii) no other rule in Π is supporting a with respect to M . By Lemma 2\nand (iii), we derive that every rule other than r is such that it is not a supporting rule for a with respect to M ′. By (i) and the fact that M ⊆ M ′, a ∈ M ′. Since M ′ is a sup-model of Π , it follows that M ∩ (B ∪ A) = ∅. By the fact that M ′ is a consistent and complete set of literals over atoms(Π ) we conclude that B∪A ⊆ M . By (ii), l ∈ M ′.\nStatement 3. We have to show that the subsets of sm containing {UnitPropagate, Unfounded} are sta-enforcing. We only illustrate this for the set {UnitPropagate, Unfounded}. We call this set uu. The proof for other sets (i) relies on the fact that any sta-model is also a cla and sup-model and (ii) follows the ideas presented in the proof of Statement 2.\nWe start by showing that the set uu is sta-sound. Let Π be any program, M be any set of literals, M ′ be any sta-model of Π such that M ⊆ M ′. We have to illustrate that the set uu(Π ,M) is a subset of M ′. Consider any literal l in the set uu(Π ,M). We now show that l is also in M ′.\nCase 1. l ∈ UnitPropagate(Π ,M). Since M ′ is a sta-model, M ′ is also a clamodel. The rest of the argument follows the lines of proof in Statement 1, which illustrates that up is cla-sound.\nCase 2. l ∈ Unfounded(Π ,M). Literal l has the form ¬a. By the conditions of Unfounded definition, it follows that there is a set X containing a such that X is unfounded with respect to Π . By Lemma 3 and the fact that M ′ is sta-model of Π it follows that ¬a ∈ M ′. (Indeed, consider a simple argument by contradiction.)\nSecond, we show that the set uu is sta-complete. Let Π be any program, M be any complete and consistent set of literals over atoms(Π ). We now show that M is sta-model of Π iff uu(Π ,M) = ∅.\nLeft-to-right: Let M be a sta-model of Π . By contradiction. Assume that the set\nuu(Π ,M) is not empty. Then there is a literal l in this set.\nCase 1. l ∈ UnitPropagate(Π ,M). Since M is also cla-model of Π , by Lemma 1\nwe derive a contradiction.\nCase 2. l ∈ Unfounded(Π ,M). Literal l has the form ¬a. By the conditions of Unfounded definition, it follows that (i) literal ¬a is such that it does not belong to M , and (ii) there is a set X containing a such that X is unfounded with respect to Π . Since M is a sta-model of Π , we conclude from (ii) that ¬a ∈ M . This contradicts (i).\nRight-to-left: Assume that uu(Π ,M) = ∅. By contradiction. Assume that M is not a sta-model of Π . By Theorem 1, either M is not a cla-model of Π or there is a non-empty subset of L+ that is an unfounded set on L with respect to Π . In the former case, when M is not a cla-model of Π , by Lemma 1 we derive a contradiction. In the latter case, it follows that there is some atom a in an existing unfounded set so that ¬a ∈ Unfounded(Π ,M) by the conditions of the Unfounded definition. We derive a contradiction."
    }, {
      "heading" : "6.2 Proofs of Theorems 3, 4, Propositions 2, 4, 5, 6",
      "text" : "We start by the proof of Theorem 4. We skip the proof of Theorem 3 as it relies on the same proof techniques that proof of Theorem 4 exhibits. The proof of Theorem 4 relies on auxiliary lemmas as well as proofs of Propositions 4, 5, 6 that follow. We conclude this section with the proof of Proposition 2.\nLemma 4\nLet g be a generating function and t be a witness function.\nLet Pg and Pt be sets of p-conditions. Then for any Π , the graph STT Pg,g Pt,t (Π ) is finite and acyclic."
    }, {
      "heading" : "Proof",
      "text" : "Consider the states of the graph STT Pg,g Pt,t (Π ). The string L of states of the form (L,R)s or of the type Ok(L) is built over a set of atoms which is bounded by the size of Π . Also, L does not allow repetitions. Thus, there is a finite number of possible strings L in the states (L,R)s or Ok(L). It immediately follows that there is a finite number of states Ok(L) in STT Pg,g Pt,t (Π ).\nConsider the right side of a state of the form (L,R)s. Since t(Π , L) has a finite number of atoms and there is a finite number of possible L, the set of atoms over which R is built is finite. Consequently, there is a finite number of possible R. We conclude that there is a finite number of possible states (L,R)s. Thus the set of states is finite in STT Pg,g Pt,t (Π ).\nFor any string L of literals, by |L| we denote the length of this string. Any\nstring L of literals can be written L0l ∆ 1 L1 . . . l ∆ k Lk, where (l ∆ i )1≤i≤k contains all the decision literals of L. Let us call v(L) the sequence |L0|, |L1| . . . |Lk|. We then write L ≤ L′ iff v(L) ≤lex v(L ′) where ≤lex is the lexicographic order. Since the length of the sequence v(L) is bounded by the finite number of possible decision literals, this is a well-founded order. Finally, we say that (L,R)s ≤ (L′, R′)s′ iff (L,R, s) ≤lex (L′, R′, s′) where ≤lex is the lexicographic order and L < R. This is clearly well-founded as it is the lexicographic composition of well-founded orders.\nIf there is a transition from (L,R)s to (L ′, R′)s′ then (L,R)s ≤ (L′, R′)s′ and (L,R)s 6= (L′, R′)s′ . This can be checked simply for each of the rules. Since the order is well-founded, there is no infinite path in the graph. Consequently, the graph is acyclic."
    }, {
      "heading" : "Proof of Proposition 5",
      "text" : "We first show that l1. · · · .lk1 is consistent. By contradiction. Assume that l1. · · · .lk1 is inconsistent. Then since ConcludeL is not applicable l1. · · · .lk1 contains at least one decision literal. We now define i as l1. · · · .lk1 = l1. · · · .li−1.l ∆ i .li+1. · · · .lk1 where l∆i is the rightmost decision literal. Since BacktrackL is not applicable l1. · · · .lk1 contains no decision literal. We derive a contradiction.\nSince DecideL is not applicable and l1. · · · .lk1 is consistent, l1. · · · .lk1 assigns all the atoms of atoms(g(Π )). As a consequence l1. · · · .lk1 is a consistent and complete set of literals that covers atoms(g(Π )). Finally, PropagateL is not applicable. So\nPg(Π , l1. · · · .lk1) is the empty set. Since Pg is w-enforcing and hence w-complete, l1. · · · .lk1 is a w-model of g(Π )."
    }, {
      "heading" : "Proof of Proposition 6",
      "text" : "Statements (a− c) We prove these statements by induction on the length of a path in the graph STT Pg,g Pt,t (Π ) from the initial state. Since the statements trivially hold in the initial state of the graph, we only have to prove that all transition rules of"
    }, {
      "heading" : "STT",
      "text" : "Pg,g Pt,t (Π ) preserve the properties.\nStatement (c) trivially holds for all transitions but Crossing-rules RL. Statements (a) and (b) trivially hold for transitions due to Left rules, Crossing-rules RL, ConcludeR, ConcludeRL.\nConsider an edge due to one of the Right rules or Crossing-rules LR from state\nS = (l01. · · · .l 0 k0 1 , r01 . · · · .r 0 k0 2 )s0 to state S ′ = (l1. · · · .lk1 , r1. · · · .rk2)R so that the statements (a) and (b) hold on S (an inductive hypothesis). For the Right rules (excluding ConcludeR), the left side of the state remains unchanged. Thus, by induction hypothesis (a) immediately follows. Similarly, it is easy to see from the conditions of these rules that they also preserve property (b). We now illustrate that the CrossLR preserves (a− c).\nCase CrossLR: It follows that (i) s0 = L, (ii) l1. · · · .lk1 = l 0 1. · · · .l 0 k0 1 , (iii) no\nleft rule applies to S, (iv) r1. · · · .rk1 = r 0 1 . · · · .r 0 k0 1 = ∅. By Proposition 5, (i), and (iii) we conclude that l01. · · · .l 0 k0 1 is a w1-model of g(Π ). By (ii), it follows that l1. · · · .lk1 is also a w1-model of g(Π ). Thus, (c) holds. From the definition of g(Π ) it follows that the set {l1. · · · .lk1} of literals covers Π. It follows that t(Π , l1. · · · .lk1) is defined. Thus (a) holds. From (iv), (b) trivially follows as the right side of the state is empty.\nStatement (d) We first show that r1. · · · .rk2 is consistent. By contradiction. Assume that r1. · · · .rk2 is inconsistent. Then since ConcludeR is not applicable, r1. · · · .rk2 contains at least one decision literal. We now define i as r1. · · · .rk2 = r1. · · · .ri−1.r ∆ i .ri+1. · · · .rk2 where r ∆ i is the rightmost decision literal. Since the rule BacktrackR is not applicable r1. · · · .rk2 contains no decision literal. We derive a contradiction.\nSince DecideR is not applicable and r1. · · · .rk2 is consistent, by (b) r1. · · · .rk2 assigns all the atoms of atoms(t(Π , l1. · · · .lk1)). Thus, r1. · · · .rk2 is a consistent and complete set of literals over atoms(t(Π , l1. · · · .lk1)). Finally, PropagateR is not applicable. So Pt(t(Π , l1. · · · .lk1), r1. · · · .rk2 ) is the empty set. Since Pt is w2enforcing and hence w2-complete, r1. · · · .rk2 is a w2-model of t(Π , l1. · · · .lk1).\nLemma 5\nLet w1 and w2 be some types in {cla, sup, sta}.\nLet g be a generating function and t be a witness function. Let Pg be a w1-enforcing set of p-conditions and Pt be a w2-enforcing set of\np-conditions.\nLet Π be a program.\nLet (l1. · · · .lk1 , r1. · · · .rk2)s be a state of STT Pg,g Pt,t (Π ) reachable from the initial\nstate.\nThen:\n(a) any w2-model of t(Π , l1. · · · .lk1) satisfies ri if it satisfies all decision literals\n(rj) ∆ with j ≤ i.\n(b) Any w1-model L of g(Π ) such that t(Π , L) has no w2-model satisfies li if it\nsatisfies all decision literals l∆j with j ≤ i."
    }, {
      "heading" : "Proof",
      "text" : "We prove statements (a) and (b) by induction on the length of a path in the graph"
    }, {
      "heading" : "STT",
      "text" : "Pg,g Pt,t (Π ) from the initial state. Since the statements trivially hold in the initial state of the graph, we only have to prove that all transition rules of STT Pg,g Pt,t (Π ) preserve the properties.\nConsider an edge from the state S = (l01. · · · .l 0 k0 1 , r01 . · · · .r 0 k0 2 )s0 to the state S ′ = (l1. · · · .lk1 , r1. · · · .rk2)s so that the statements (a) and (b) hold on S (an inductive hypothesis).\nThe statements (a) and (b) trivially hold for the case of transitions due to\nConcludeL, ConcludeR, ConcludeRL.\nFor the case of transition rules CrossLR, BacktrackR, DecideR, PropagateR it holds that l1. · · · .lk1 = l 0 1. · · · .l\n0 k0 1 . So by the induction hypothesis, (b) triv-\nially holds on (l1. · · · .lk1 , r1. · · · .rk2 )s. For these rules, we are left to show that (a) holds on (l1. · · · .lk1 , r1. · · · .rk2 )s. Note that for the case of BacktrackR, DecideR, PropagateR, by Proposition 6 (a) it follows that t(Π , l1. · · · .lk1) is defined.\nCase CrossLR: It follows that r1. · · · .rk1 = r 0 1 . · · · .r 0 k0 1 = ∅. Consequently, (a)\nholds as right side of the state is empty.\nCase BacktrackR. In this case, there is an index i such that r 0 1 . · · · .r 0 k0 2 =\nr01 . · · · .r 0 i−1.(r 0 i ) ∆.r0i+1. · · · .r 0 k0 2 and r1. · · · .rk2−1 = r 0 1 . · · · .r 0 i−1. Also, by the conditions of BacktrackR, the string of literals r 0 1 . · · · .r\n0 k0 2 is inconsistent. Let M be a\nw2-model of t(Π , l1. · · · .lk1). Let rj be a literal of r1. · · · .rk1 . Assume M satisfies all decision literals (rj′ ) ∆ with j′ ≤ j. By the induction hypothesis, if j 6= k2 then M satisfies rj . It remains to prove that this is also true when j = k2. Assume M satisfies all the decision literals of r1. · · · .rk2 . They include all the decision literals of r1. · · · .rk2−1. Then M satisfies all the literals of r1. · · · .rk2−1 by the induction hypothesis. We now show that M also satisfies rk2 .\nNone of the literals r0i+1 · · · r 0 k0 2 is a decision literal. Additionally, r1. · · · .rk2 =\nr01 . · · · .r 0 i−1.r 0 i . Since M satisfies all the literals of r1. · · · .rk2−1, it satisfies all the literals of r01 . · · · .r 0 i−1. Since r 0 1 . · · · .r\n0 k0 2 is inconsistent, M cannot satisfy all of its\nliterals, so M does not satisfy at least one literal of r0i · · · r 0 k0 2 . By the contraposition of the induction hypothesis (a), and since none of the literals r0i+1 · · · r 0 k0 2 is a decision literal, one of the literals not satisfied by M has to be r0i . So M must satisfy r 0 i , that is rk2 .\nCase DecideR. Obvious.\nCase PropagateR. Let M be a w2-model of t(Π , l1. · · · .lk1). Assume M satisfies all the decision literals of r1. · · · .rk2 . Since for any propagator condition rk2 is not a decision literal, they are the decision literals of r1. · · · .rk2−1. So M satisfies all the literals of r1. · · · .rk2−1 by the induction hypothesis. In other words {r1. · · · .rk2−1} ⊆ M . Proving that M satisfies rk2 will complete the proof. We are given that Pt is w2-enforcing and hence w2-sound. By definition of w2-soundness and the fact that {r1. · · · .rk2−1} ⊆ M , it follows that Pt(Π , {r1. · · · .rk2−1}) ⊆ M . Since rk2 ∈ Pt(Π , {r1. · · · .rk2−1}), also rk2 ∈ M . In other words, M satisfies rk2 .\nWe are left to illustrate that transition rulesBacktrackRL, BacktrackL,DecideL, PropagateL preserve properties (a) and (b). Since all of these rules are such that the right side of the resulting state is ∅, clearly (a) is preserved. We will only illustrate that BacktrackRL preserves (b) as the remaining cases for (b) are similar to the arguments constructed above for the respective right rules and property (a).\nCase BacktrackRL. There is an index i such that l1. · · · .lk1−1 = r 0 1 . · · · .r 0 i−1\nand l01. · · · .l 0 k0 1 = l01. · · · .l 0 i−1.(l 0 i ) ∆.l0i+1. · · · .l 0 k0 1 . Let M be a w1-model of g(Π ) such that t(Π ,M) has no w2-model. Assume that M satisfies all the decision literals of l1. · · · .lk1 . Since lk1 is not a decision literal, they are the decision literals of l1. · · · .lk1−1. So M satisfies all the literals of l1. · · · .lk1−1 by the induction hypothesis. Showing that M satisfies lk1 will complete the proof.\nSince the transition is justified by BacktrackRL, by Proposition 6 (c), l 0 1. · · · .l 0 k0 1 is a w1-model of g(Π ). By Proposition 6 (d) and the fact that no right-rule applies, r01 . · · · .r 0 k0 2 is a w2-model of t(Π , l1. · · · .lk1). So t(Π , l1. · · · .lk1) has a w2-model, henceM does not satisfy all the literals of l01. · · · .l 0 k0 1 . Consequently, sinceM satisfies all the literals of l1. · · · .lk1−1, at least one literal from (li 0)∆.l0i+1. · · · .l\n0 k0 1 is not\nsatisfied by M , which by the contraposition of the induction hypothesis (b) proves that l0i = lk1 is not satisfied by M . This means that M satisfies lk1 .\nLemma 6\nLet w1 and w2 be some types in {cla, sup, sta}.\nLet Pg be a w1-enforcing set of p-conditions. Let g be a generating function. Let Pt be a w2-enforcing set of p-conditions. Let t be a witness function. Let Π be a program. Then:\n1. any terminal state of STT Pg,g Pt,t (Π ) reachable from the initial state and other\nthan Failstate is Ok(L), with L being a w1-model of g(Π ) such that t(Π , L) has no w2-model, 2. Failstate is reachable from the initial state iff g(Π ) has no w1-model L such\nthat t(Π , L) has no w2-model."
    }, {
      "heading" : "Proof",
      "text" : "We first illustrate that any terminal state is either Failstate or of the form Ok(L) for some L. By contradiction. Assume there is a terminal state of the form (L,R)s. Case 1. s = L. Then either a left rule or CrossLR applies, so (L,R)s is not terminal. We derive a contradiction. Case 2. s = R. Since ConcludeRL does not apply while\nno right-rule applies and no left-rule applies, L contains at least one decision literal. Since BacktrackRL is not applicable, L contains no decision literal. We derive a contradiction.\nStatement 1. Let Ok(L) be a terminal state reachable from the initial state. As it is different from the initial state there is a transition leading to it. This transition can only be ConcludeR. Let us call (L,R)s a state from which a transition ConcludeR leads to Ok(L). By the definition of ConcludeR, we know that: s = R, that R is inconsistent and that R contains no decision literal. By Lemma 5 item (c), the consistent set of literals obtained from L is a w1-model of g(Π ).\nBy Lemma 5 item (a), and as R contains no decision literal, any w2-model of t(Π , L) satisfies all the literals of R. Since R is inconsistent, any w2-model of t(Π , L) is inconsistent. So t(Π , L) has no w2-model.\nWe have just proved that L is a w1-model of g(Π ) such that t(Π , L) has no\nw2-model.\nStatement 2. Assume Failstate is not reachable from the initial state. Then, since the graph is acyclic, there is a terminal state different from Failstate. By Claim 1, this state is Ok(L), and L is a w1-model of g(Π ) such that t(Π , L) has no w2-model.\nAssume Failstate is reachable from the initial state. As it is different from the initial state there is a transition leading to it. This transition can only be ConcludeL or ConcludeRL. Let us call (L,R)s a state from which a transition leads to Failstate. In either of these cases, L does not contain any decision literal; so by Lemma 5, any w1-model M of g(Π ) such that t(Π ,M) has no w2-model satisfies all the literals of L. In other words, L is the only possible candidate for a w1-model of g(Π ) such that t(Π , L) has no w2-model.\nCase ConcludeL. It follows that L is inconsistent. Consequently, it is not a w1-\nmodel M of g(Π ) such that t(Π , L) has no w2-model.\nCase ConcludeRL. By Proposition 5 (d), the set of literals R is a w2-model of\nt(Π , L). Thus L is not a w1-model of g(Π ) such that t(Π , L) has no w2-model."
    }, {
      "heading" : "Proof of Proposition 4",
      "text" : "We first illustrate that any set M of literals that is a w1-model of g(Π ) such that t(Π ,M) has no w2-model is such that M|atoms(Π ) is a stable model of Π . Indeed, by the definition of w1-approximating functions w.r.t. w, M|atoms(Π ) is a w-model of Π . Also, by the definition of w2-ensuring functions w.r.t. w, M|atoms(Π ) is a stable model of Π .\nSecond, consider any stable model L of Π . By the definitions of w1-approximating and w2-ensuring functions w.r.t. w, it follows there isM ′ such that M ′|atoms(Π ) = L and M ′ is a w1-model of g(Π ) such that t(Π ,M ′) has no w2-model."
    }, {
      "heading" : "Proof of Theorem 4",
      "text" : "Let w1 denote a type such that Pg is w1-enforcing and the function g is w1approximating w.r.t. w. Let w2 denote a type such that Pt is w2-enforcing and function t is w2-ensuring w.r.t. w. We now proceed to prove the four conditions of the definition of ‘checks’ one by one.\n1. By Lemma 4, the graph STT Pg,g Pt,t (Π ) is acyclic and finite. 2. By Lemma 6 item 1, any terminal state is either Failstate or Ok(L). 3. By Lemma 6 item 1, any terminal state of STT Pg,g Pt,t (Π ) reachable from the\ninitial state and other than Failstate is Ok(L), with L being a w1-model of g(Π ) such that t(Π , L) has no w2-model. By Proposition 4, L|atoms(Π ) is a stable model of Π . 4. By Lemma 6 item 2, Failstate is reachable from the initial state iff g(Π ) has\nno w1-model L such that t(Π , L) has no w2-model. By Proposition 4, Π has no stable models."
    }, {
      "heading" : "Proof of Proposition 2",
      "text" : "Recall how we argued DP 2Π is STT up,gC up,tC (Π ). Similarly, DP 2g,t(Π ) is STT up,g up,t (Π ). By Theorem 2, up is cla-enforcing.\n1. By Lemma 4, DP 2g,t(Π ) is finite and acyclic. 2. By Lemma 6 item 1, any terminal state is either Failstate or Ok(L). 3. By Lemma 6 item 1, any terminal state of STT Pg,g Pt,t (Π ) reachable from the\ninitial state and other than Failstate is Ok(L), with L being a cla-model of g(Π ) such that t(Π , L) has no cla-model. 4. By Lemma 6 item 2, Failstate is reachable from the initial state iff g(Π ) has\nno cla-model L such that t(Π , L) has no cla-model."
    }, {
      "heading" : "6.3 Proof of Theorem 5",
      "text" : "First we prove an auxiliary lemma that will help handling CNF conversions of DNF formulas.\nFor a DNF formula F , we define CNF (F ) as the conversion of F to CNF using straightforward equivalent transformations: the distributivity of disjunction over conjunction.\nLemma 7\nLet F be a DNF formula. Let l be a literal of F . Let M be a set of literals.\nThe two following statements are equivalent:\n1. there is a conjunctive clause D of F such that for every conjunctive clause\nD′ ∈ F different from D, D′ is contradicted by M ,\n2. there is a clause C of CNF (F ) such that l ∈ C and M contradicts C \\ {l}."
    }, {
      "heading" : "Proof",
      "text" : "Formula F has the form ∨n\ni=1 ∧k j=1 lij (when necessary the true constant ⊤ is added\nmultiple times to ensure that the conjunctive clauses of F are of equal length). Also CNF (F ) = ∧ (k1...kn)∈{1...k}n ∨n i=1 liki .\nFrom Statement 1 to Statement 2: Assume that there is a conjunctive clause D of F such that for any other conjunctive clause D′ of F , this clause is contradicted by M . Let l be a literal of D. Let D be ∧k\nj=1 li0j for some i0. As any other con-\njunctive clause is contradicted by M , and as these clauses are conjunctions, there is least one literal of each of these clauses that is contradicted by M . Let us call r1 . . . ri0−1ri0+1 . . . rn these literals. Then for each i ∈ {1, . . . , i0 − 1, i0 + 1, . . . , n}, there is k0i ∈ {1, . . . k} such that li,k0i = ri. Also, there is some k 0 i0 such that li,k0\ni0\n= l.\nThen the clause ∨n\ni=1 lik0i of CNF (F ) contains l while each of the other literals it\ncontains is contradicted by M .\nFrom Statement 2 to Statement 1: Assume that for some clause of CNF (F ), all\nliterals but one are known to be contradicted byM . Then let this clause be ∨n\ni=1 liki for some i and let li0ki0 be the literal that is not contradicted by M . Then liki is contradicted by M for any i other than i0. So ∧k j=1 lij is contradicted by M for any i other than i0. So D = ∧k j=1 li0j is a conjunctive clause of F such that for any other conjunctive clause D′ of F , this clause is contradicted by M ."
    }, {
      "heading" : "Proof of Theorem 5",
      "text" : "We must prove that for any edge in the graph STT sd,g D\nPt,t (Π ) there is an edge in\nSTT up,cnfcomp Pt,t (Π ) linking two identical vertexes, and for any edge in the graph STT up,cnfcomp Pt,t (Π ) there is an edge in STT sd,g D Pt,t (Π ) linking two identical vertexes.\nIf the edge is justified by a right-rule then this is obvious as these two graphs have the same witness function and the same set of conditions for the PropagateR rule. If the edge is DecideL, ConcludeL, BacktrackL, BacktrackRL or ConcludeRL then obviously there is the same edge in the other graph, bearing the same name, as these edges do not depend on the generating program or set of conditions for the PropagateR rule.\nIt remains to study the case of an edge justified by PropagateL or CrossLR. Assume we also have proved that PropagateL rules are identical in both graphs. Then if an edge is justified by CrossLR in one of the graphs, which means that no left-rule applies in this graph, equivalently no left-rule applies in the other graph, and CrossLR also applies in that graph. We now show that PropagateL rules are identical in both graphs, which will complete the proof.\nAssume that an edge is justified by PropagateL in one of the graphs, let us prove\nit also exists in the other graph.\nA transition in STT sd,g D\nPt,t (Π ) is justified by PropagateL with UnitPropagate as\ncondition. Then also there is an edge in STT up,cnfcompPt,t (Π ) with the same effect, and justified by PropagateL with the UnitPropagate condition. Indeed, Π is part of cnfcomp(Π ).\nA transition in STT sd,g D\nPt,t (Π ) is justified by PropagateL with AllRulesCancelled\nas condition. Then the edge is turning (L, ∅)L into (L¬a, ∅)L, and each rule A ∨ a ← B ∈ Π is not a supporting rule for a w.r.t. L. In other words, for each rule A∨a ← B ∈ Π the following holds L∩ (B ∪A) 6= ∅. Consequently, the conjunction B∧A is contradicted by L. As a consequence ∨\nA∨a←B∈Π (B∧A) is contradicted by\nL. From Lemma 7, the fact that the DNF formula ¬a∨ ∨\nA∨a←B∈Π (B∧A) belongs\nto comp(Π ), and the cnfcomp construction, it follows that there is a clause C in cnfcomp(Π ) such that ¬a ∈ C and L contradicts C \\ {¬a}. So the rule PropagateL with condition UnitPropagate of STT up,cnfcompPt,t (Π ) can be applied to C to add ¬a, providing the edge we needed.\nA transition in STT sd,g D\nPt,t (Π ) is justified by PropagateL with BackchainT rue as\ncondition. The proof of this case is similar to the proof of previous case.\nA transition in STT up,cnfcompPt,t (Π ) is justified by PropagateL with the condition\nUnitPropagate. Let us call F0 the DNF formula ¬a∨ ∨ A∨a←B∈Π (B∧A) of comp(Π ) for some atom a in Π .\nCase 1: UnitL is applied to a clause of Π in cnfcomp(Π ). Then PropagateL with\nthe condition UnitPropagate itself provides the desired edge in STT sd,g D\nPt,t (Π ).\nCase 2: UnitL is applied to a clause obtained from F0 by the cnfcomp conversion. Then by Lemma 7, the cnfcomp construction, and the UnitL condition there is a conjunctive clause D of F0 such that for every conjunctive clause D ′ in F0 that is different from D the current L contradicts D′.\nCase 2.1: This conjunctive clause is ¬a. Then L contradicts ∨\nA∨a←B∈Π (B∧A).\nIt is easy to see that AllRulesCancelled provides the desired edge.\nCase 2.2: This conjunctive clause is some B ∧ A. Then L contradicts ¬a so a belongs to L. Also L contradicts all of {B′ ∧ A′|A′ ∨ a ← B′ ∈ Π \\ {A ∨ a ← B}}. As a consequence BackchainT rue provides the desired edge."
    }, {
      "heading" : "7 Conclusions, Future and Related Work",
      "text" : "Transition systems for describing dpll-based solving procedures have been introduced by Nieuwenhuis et al. (2006). Lierler (2008) introduced and compared the transition systems for the answer set solvers smodels and cmodels for nondisjunctive programs. In this paper, we continue this direction of work by presenting a two-layer framework suitable to capture disjunctive answer set solvers. We argue that this framework allows simpler analysis and comparison of these systems. We first introduce a general template that includes the techniques implemented in such solvers, and then define specific solvers by instantiating appropriate techniques using this template. Formal results about the correctness of the abstract representations are given. We believe that this work is a stepping stone towards clear, comprehensive articulation of main design features of current disjunctive answer set solvers that will inspire new solving algorithms. Section 5 hints at some of\nthe possibilities. Indeed, to obtain a new solver one can combine any appropriately chosen approximating-pair and ensuring-pair.\nNieuwenhuis et al. (2006) considered another extension of the graphs by introducing transition rules that capture backjumping and learning techniques common in design of modern solvers, that later allowed Lierler (2011) to design, e.g., abstract clasp. It is a direction of future work to extend the two-layer template graph to model such advances solving techniques. This extension will allow us to model disjunctive answer set solvers that rely heavily on backjumping and learning such as clasp and wasp.\nRelated work. The approach based on transition systems for describing and comparing ASP procedures is one of the three main alternatives studied in the ASP literature. Other methods include pseudo-code presentation of algorithms (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013). Giunchiglia et al. (2008) presented pseudo-code descriptions of cmodels without backjumping and learning, smodels and dlv without backjumping restricted to non-disjunctive programs. They study relationships to the solving algorithms by analyzing the correspondence about the search spaces they explore, focusing on tight programs: in particular, they note a tight relation between solvers cmodels and dlv. Gebser and Schaub (2013) considered formal proof systems based on tableau methods for characterizing the operations and the strategies of ASP procedures for disjunctive programs. These proof systems also allow cardinality constraints in the language of logic programs."
    } ],
    "references" : [ {
      "title" : "WASP: A native ASP solver based on constraint learning",
      "author" : [ "M. Alviano", "C. Dodaro", "W. Faber", "N. Leone", "F. Ricca" ],
      "venue" : "Proceedings of the 12th International Conference of Logic Programming and Nonmonotonic Reasoning (LPNMR 2013), P. Cabalar and T. C. Son, Eds. Lecture Notes in Computer Science, vol. 8148. Springer, 54–66.",
      "citeRegEx" : "Alviano et al\\.,? 2013",
      "shortCiteRegEx" : "Alviano et al\\.",
      "year" : 2013
    }, {
      "title" : "Knowledge Representation, Reasoning and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "Baral,? 2003",
      "shortCiteRegEx" : "Baral",
      "year" : 2003
    }, {
      "title" : "Abstract disjunctive answer set solvers",
      "author" : [ "R. Brochenin", "Y. Lierler", "M. Maratea" ],
      "venue" : "Proceedings of the 21st European Conference on Artificial Intelligence (ECAI 2014). Frontiers in Artificial Intelligence and Applications, vol. 263. IOS Press, 165–170.",
      "citeRegEx" : "Brochenin et al\\.,? 2014",
      "shortCiteRegEx" : "Brochenin et al\\.",
      "year" : 2014
    }, {
      "title" : "Inferring phylogenetic trees using answer set programming",
      "author" : [ "D.R. Brooks", "E. Erdem", "S.T. Erdoğan", "J.W. Minett", "D. Ringe" ],
      "venue" : "Journal of Automated Reasoning 39, 471–511.",
      "citeRegEx" : "Brooks et al\\.,? 2007",
      "shortCiteRegEx" : "Brooks et al\\.",
      "year" : 2007
    }, {
      "title" : "A machine program for theorem proving",
      "author" : [ "M. Davis", "G. Logemann", "D. Loveland" ],
      "venue" : "Communications of the ACM 5(7), 394–397.",
      "citeRegEx" : "Davis et al\\.,? 1962",
      "shortCiteRegEx" : "Davis et al\\.",
      "year" : 1962
    }, {
      "title" : "Complexity results for disjunctive logic programming and application to nonmonotonic logics",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "Proceedings of the 1993 International Logic Programming Symposium (ILPS), D. Miller, Ed. 266–278.",
      "citeRegEx" : "Eiter and Gottlob,? 1993",
      "shortCiteRegEx" : "Eiter and Gottlob",
      "year" : 1993
    }, {
      "title" : "Disjunctive Datalog",
      "author" : [ "T. Eiter", "G. Gottlob", "H. Mannila" ],
      "venue" : "ACM Transactions on Database Systems 22, 3 (Sept.), 364–418.",
      "citeRegEx" : "Eiter et al\\.,? 1997",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 1997
    }, {
      "title" : "Enhancing efficiency and expressiveness in answer set programming systems",
      "author" : [ "W. Faber" ],
      "venue" : "Ph.D. thesis, Ph.D. dissertation, Vienna University of Technology.",
      "citeRegEx" : "Faber,? 2002",
      "shortCiteRegEx" : "Faber",
      "year" : 2002
    }, {
      "title" : "Advanced conflict-driven disjunctive answer set solving",
      "author" : [ "M. Gebser", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Proceedings of the 23rd International Joint Conference on Artificial Intelligence (IJCAI 2013), F. Rossi, Ed. IJCAI/AAAI.",
      "citeRegEx" : "Gebser et al\\.,? 2013",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2013
    }, {
      "title" : "Tableau calculi for answer set programming",
      "author" : [ "M. Gebser", "T. Schaub" ],
      "venue" : "Proceedings of the 22nd International Conference on Logic Programming (ICLP 2006), S. Etalle and M. Truszczynski, Eds. Lecture Notes in Computer Science, vol. 4079. Springer, 11–25.",
      "citeRegEx" : "Gebser and Schaub,? 2006",
      "shortCiteRegEx" : "Gebser and Schaub",
      "year" : 2006
    }, {
      "title" : "Tableau calculi for logic programs under answer set semantics",
      "author" : [ "M. Gebser", "T. Schaub" ],
      "venue" : "ACM Transaction on Computational Logic 14, 2, 15.",
      "citeRegEx" : "Gebser and Schaub,? 2013",
      "shortCiteRegEx" : "Gebser and Schaub",
      "year" : 2013
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proceedings of the 5th International Conference and Symposium on Logic Programming (ICLP/SLP 1988), R. Kowalski and K. Bowen, Eds. MIT Press, 1070– 1080.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1988",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9, 365–385.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1991",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1991
    }, {
      "title" : "On the relation among answer set solvers",
      "author" : [ "E. Giunchiglia", "N. Leone", "M. Maratea" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 53, 1-4, 169–204.",
      "citeRegEx" : "Giunchiglia et al\\.,? 2008",
      "shortCiteRegEx" : "Giunchiglia et al\\.",
      "year" : 2008
    }, {
      "title" : "On the relation between answer set and SAT procedures (or, between smodels and cmodels)",
      "author" : [ "E. Giunchiglia", "M. Maratea" ],
      "venue" : "Proceedings of the 21st International Conference on Logic Programming (ICLP 2005), M. Gabbrielli and G. Gupta, Eds. Lecture Notes in Computer Science, vol. 3668. Springer, 37–51.",
      "citeRegEx" : "Giunchiglia and Maratea,? 2005",
      "shortCiteRegEx" : "Giunchiglia and Maratea",
      "year" : 2005
    }, {
      "title" : "Unfolding partiality and disjunctions in stable model semantics",
      "author" : [ "T. Janhunen", "I. Niemelä", "D. Seipel", "P. Simons", "You", "J.-H." ],
      "venue" : "ACM Transactions on Computunational Logic 7, 1, 1–37.",
      "citeRegEx" : "Janhunen et al\\.,? 2006",
      "shortCiteRegEx" : "Janhunen et al\\.",
      "year" : 2006
    }, {
      "title" : "Enhancing disjunctive logic programming systems by sat checkers",
      "author" : [ "C. Koch", "N. Leone", "G. Pfeifer" ],
      "venue" : "Artificial Intelligence 151, 1-2, 177–212.",
      "citeRegEx" : "Koch et al\\.,? 2003",
      "shortCiteRegEx" : "Koch et al\\.",
      "year" : 2003
    }, {
      "title" : "The DLV system for knowledge representation and reasoning",
      "author" : [ "N. Leone", "W. Faber", "G. Pfeifer", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic 7, 3, 499–562.",
      "citeRegEx" : "Leone et al\\.,? 2006",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 2006
    }, {
      "title" : "Disjunctive stable models: Unfounded sets, fixpoint semantics, and computation",
      "author" : [ "N. Leone", "P. Rullo", "F. Scarcello" ],
      "venue" : "Information and Computation 135(2), 69– 112.",
      "citeRegEx" : "Leone et al\\.,? 1997",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 1997
    }, {
      "title" : "Cmodels: SAT-based disjunctive answer set solver",
      "author" : [ "Y. Lierler" ],
      "venue" : "Proceedings of the 8th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2005), C. Baral, G. Greco, N. Leone, and G. Terracina, Eds. Lecture Notes in Computer Science, vol. 3662. Springer, 447–452.",
      "citeRegEx" : "Lierler,? 2005",
      "shortCiteRegEx" : "Lierler",
      "year" : 2005
    }, {
      "title" : "Abstract answer set solvers",
      "author" : [ "Y. Lierler" ],
      "venue" : "Proceedings of the 24th International Conference on Logic Programming (ICLP 2008), M. G. de la Banda and E. Pontelli, Eds. Lecture Notes in Computer Science, vol. 5366. Springer, 377–391.",
      "citeRegEx" : "Lierler,? 2008",
      "shortCiteRegEx" : "Lierler",
      "year" : 2008
    }, {
      "title" : "SAT-based answer set programming",
      "author" : [ "Y. Lierler" ],
      "venue" : "Ph.D. thesis, University of Texas at Austin.",
      "citeRegEx" : "Lierler,? 2010",
      "shortCiteRegEx" : "Lierler",
      "year" : 2010
    }, {
      "title" : "Abstract answer set solvers with backjumping and learning",
      "author" : [ "Y. Lierler" ],
      "venue" : "Theory and Practice of Logic Programming 11, 135–169.",
      "citeRegEx" : "Lierler,? 2011",
      "shortCiteRegEx" : "Lierler",
      "year" : 2011
    }, {
      "title" : "Transition systems for model generators - a unifying approach",
      "author" : [ "Y. Lierler", "M. Truszczynski" ],
      "venue" : "Theory and Practice of Logic Programming 11, 4-5, 629–646.",
      "citeRegEx" : "Lierler and Truszczynski,? 2011",
      "shortCiteRegEx" : "Lierler and Truszczynski",
      "year" : 2011
    }, {
      "title" : "Answer Set Planning",
      "author" : [ "V. Lifschitz" ],
      "venue" : "Proceedings of the 16th International Conference on Logic Programming (ICLP 1999), D. D. Schreye, Ed. The MIT Press, Las Cruces, New Mexico, USA, 23–37.",
      "citeRegEx" : "Lifschitz,? 1999",
      "shortCiteRegEx" : "Lifschitz",
      "year" : 1999
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V. Marek", "M. Truszczyński" ],
      "venue" : "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375–398.",
      "citeRegEx" : "Marek and Truszczyński,? 1999",
      "shortCiteRegEx" : "Marek and Truszczyński",
      "year" : 1999
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. Niemelä" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 241–273.",
      "citeRegEx" : "Niemelä,? 1999",
      "shortCiteRegEx" : "Niemelä",
      "year" : 1999
    }, {
      "title" : "Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T)",
      "author" : [ "R. Nieuwenhuis", "A. Oliveras", "C. Tinelli" ],
      "venue" : "Journal of the ACM 53(6), 937–977.",
      "citeRegEx" : "Nieuwenhuis et al\\.,? 2006",
      "shortCiteRegEx" : "Nieuwenhuis et al\\.",
      "year" : 2006
    }, {
      "title" : "Enhancing DLV instantiator by backjumping techniques",
      "author" : [ "S. Perri", "F. Scarcello", "G. Catalano", "N. Leone" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 51, 2-4, 195–228.",
      "citeRegEx" : "Perri et al\\.,? 2007",
      "shortCiteRegEx" : "Perri et al\\.",
      "year" : 2007
    }, {
      "title" : "Team-building with answer set programming in the gioia-tauro seaport",
      "author" : [ "F. Ricca", "G. Grasso", "M. Alviano", "M. Manna", "V. Lio", "S. Iiritano", "N. Leone" ],
      "venue" : "Theory and Practice of Logic Programming 12, 3, 361–381.",
      "citeRegEx" : "Ricca et al\\.,? 2012",
      "shortCiteRegEx" : "Ricca et al\\.",
      "year" : 2012
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "P. Simons", "I. Niemelä", "T. Soininen" ],
      "venue" : "Artificial Intelligence 138, 181–234.",
      "citeRegEx" : "Simons et al\\.,? 2002",
      "shortCiteRegEx" : "Simons et al\\.",
      "year" : 2002
    }, {
      "title" : "Developing a Declarative Rule Language for Applications in Product Configuration",
      "author" : [ "T. Soininen", "I. Niemelä" ],
      "venue" : "Proceedings of the 1st International Workshop on Practical Aspects of Declarative Languages (PADL 1999), G. Gupta, Ed. Lecture Notes in Computer Science, vol. 1551. Springer, 305–319.",
      "citeRegEx" : "Soininen and Niemelä,? 1999",
      "shortCiteRegEx" : "Soininen and Niemelä",
      "year" : 1999
    }, {
      "title" : "Omega-restricted logic programs",
      "author" : [ "T. Syrjänen" ],
      "venue" : "Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2001), T. Eiter, W. Faber, and M. Truszczynski, Eds. Lecture Notes in Computer Science, vol. 2173. Springer, 267–279.",
      "citeRegEx" : "Syrjänen,? 2001",
      "shortCiteRegEx" : "Syrjänen",
      "year" : 2001
    } ],
    "referenceMentions" : [ {
      "referenceID" : 25,
      "context" : "Answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.",
      "startOffset" : 23,
      "endOffset" : 153
    }, {
      "referenceID" : 26,
      "context" : "Answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.",
      "startOffset" : 23,
      "endOffset" : 153
    }, {
      "referenceID" : 1,
      "context" : "Answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.",
      "startOffset" : 23,
      "endOffset" : 153
    }, {
      "referenceID" : 6,
      "context" : "Answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.",
      "startOffset" : 23,
      "endOffset" : 153
    }, {
      "referenceID" : 11,
      "context" : "Answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.",
      "startOffset" : 23,
      "endOffset" : 153
    }, {
      "referenceID" : 12,
      "context" : "Answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.",
      "startOffset" : 23,
      "endOffset" : 153
    }, {
      "referenceID" : 3,
      "context" : "ASP has been applied to solve problems in various areas of science and technology including graph-theoretic problems arising in zoology and linguistics (Brooks et al. 2007), team building problems in container terminal (Ricca et al.",
      "startOffset" : 152,
      "endOffset" : 172
    }, {
      "referenceID" : 29,
      "context" : "2007), team building problems in container terminal (Ricca et al. 2012), and product configuration tasks (Soininen and Niemelä 1999).",
      "startOffset" : 52,
      "endOffset" : 71
    }, {
      "referenceID" : 31,
      "context" : "2012), and product configuration tasks (Soininen and Niemelä 1999).",
      "startOffset" : 39,
      "endOffset" : 66
    }, {
      "referenceID" : 12,
      "context" : "Gelfond and Lifschitz introduced logic programs with disjunctive rules (Gelfond and Lifschitz 1991).",
      "startOffset" : 71,
      "endOffset" : 99
    }, {
      "referenceID" : 5,
      "context" : "The problem of deciding whether a disjunctive program has a stable model is Σ2 -complete (Eiter and Gottlob 1993).",
      "startOffset" : 89,
      "endOffset" : 113
    }, {
      "referenceID" : 17,
      "context" : "Only five answer set systems can solve disjunctive programs: dlv (Leone et al. 2006), gnt (Janhunen et al.",
      "startOffset" : 65,
      "endOffset" : 84
    }, {
      "referenceID" : 15,
      "context" : "2006), gnt (Janhunen et al. 2006), cmodels (Lierler 2005), clasp (Gebser et al.",
      "startOffset" : 11,
      "endOffset" : 33
    }, {
      "referenceID" : 19,
      "context" : "2006), cmodels (Lierler 2005), clasp (Gebser et al.",
      "startOffset" : 15,
      "endOffset" : 29
    }, {
      "referenceID" : 8,
      "context" : "2006), cmodels (Lierler 2005), clasp (Gebser et al. 2013) andwasp (Alviano et al.",
      "startOffset" : 37,
      "endOffset" : 57
    }, {
      "referenceID" : 0,
      "context" : "2013) andwasp (Alviano et al. 2013).",
      "startOffset" : 14,
      "endOffset" : 35
    }, {
      "referenceID" : 14,
      "context" : "These approaches range from a pseudocode representation of the procedures (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).",
      "startOffset" : 74,
      "endOffset" : 129
    }, {
      "referenceID" : 13,
      "context" : "These approaches range from a pseudocode representation of the procedures (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).",
      "startOffset" : 74,
      "endOffset" : 129
    }, {
      "referenceID" : 9,
      "context" : "2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).",
      "startOffset" : 26,
      "endOffset" : 74
    }, {
      "referenceID" : 10,
      "context" : "2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).",
      "startOffset" : 26,
      "endOffset" : 74
    }, {
      "referenceID" : 20,
      "context" : "2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).",
      "startOffset" : 122,
      "endOffset" : 181
    }, {
      "referenceID" : 22,
      "context" : "2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).",
      "startOffset" : 122,
      "endOffset" : 181
    }, {
      "referenceID" : 23,
      "context" : "2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).",
      "startOffset" : 122,
      "endOffset" : 181
    }, {
      "referenceID" : 4,
      "context" : "(2006), where authors propose to use transition systems to describe the Davis-Putnam-Logemann-Loveland (dpll) procedure (Davis et al. 1962).",
      "startOffset" : 120,
      "endOffset" : 139
    }, {
      "referenceID" : 22,
      "context" : "This approach has been adapted (Lierler 2011; Lierler and Truszczynski 2011) to describing answer set solvers for non-disjunctive programs including smodels, cmodels, and clasp.",
      "startOffset" : 31,
      "endOffset" : 76
    }, {
      "referenceID" : 23,
      "context" : "This approach has been adapted (Lierler 2011; Lierler and Truszczynski 2011) to describing answer set solvers for non-disjunctive programs including smodels, cmodels, and clasp.",
      "startOffset" : 31,
      "endOffset" : 76
    }, {
      "referenceID" : 0,
      "context" : "2013) andwasp (Alviano et al. 2013). Several formal approaches have been used to describe and compare search procedures implemented in answer set solvers. These approaches range from a pseudocode representation of the procedures (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011). The latter method originates from the work by Nieuwenhuis et al. (2006), where authors propose to use transition systems to describe the Davis-Putnam-Logemann-Loveland (dpll) procedure (Davis et al.",
      "startOffset" : 15,
      "endOffset" : 534
    }, {
      "referenceID" : 2,
      "context" : "The current paper builds on the content presented by Brochenin et al. (2014). It enhances the earlier work by introducing notions of a graph template, “propagator conditions”, and “approximating pairs“ that allow to more uniformly account for major techniques implemented in disjunctive answer set solvers.",
      "startOffset" : 53,
      "endOffset" : 77
    }, {
      "referenceID" : 32,
      "context" : "Software systems called grounders (Syrjänen 2001; Perri et al. 2007) are used to take a logic program with variables as its input and produce a propositional program as its output so that the resulting propositional program has the same answer sets as the input program.",
      "startOffset" : 34,
      "endOffset" : 68
    }, {
      "referenceID" : 28,
      "context" : "Software systems called grounders (Syrjänen 2001; Perri et al. 2007) are used to take a logic program with variables as its input and produce a propositional program as its output so that the resulting propositional program has the same answer sets as the input program.",
      "startOffset" : 34,
      "endOffset" : 68
    }, {
      "referenceID" : 18,
      "context" : "For a program Π and a consistent set L of literals over atoms(Π ), a set X of atoms over atoms(Π ) is said to be unfounded (Leone et al. 1997) on L with respect to the program Π when for each atom a ∈ X and each rule A ← B ∈ Π such that a ∈ A, either of the following conditions hold",
      "startOffset" : 123,
      "endOffset" : 142
    }, {
      "referenceID" : 17,
      "context" : "6 from Leone et al. (1997) that relates the notions of unfounded set and stable model.",
      "startOffset" : 7,
      "endOffset" : 27
    }, {
      "referenceID" : 4,
      "context" : "The Davis–Putnam–Logemann–Loveland (dpll) algorithm from Davis et al. (1962) is a well-known method that exhaustively explores sets of literals to generate classical models of a propositional formula.",
      "startOffset" : 57,
      "endOffset" : 77
    }, {
      "referenceID" : 4,
      "context" : "The Davis–Putnam–Logemann–Loveland (dpll) algorithm from Davis et al. (1962) is a well-known method that exhaustively explores sets of literals to generate classical models of a propositional formula. Most satisfiability and non-disjunctive answer set solvers are based on variations of the dpll procedure that is a classical backtrack search-based algorithm. We now review the abstract transition system for dpll proposed by Nieuwenhuis et al. (2006), which is an alternative to common pseudo-code descriptions of backtrack search-based algorithms.",
      "startOffset" : 57,
      "endOffset" : 452
    }, {
      "referenceID" : 27,
      "context" : "13 in Nieuwenhuis et al. (2006).",
      "startOffset" : 6,
      "endOffset" : 32
    }, {
      "referenceID" : 19,
      "context" : "Lierler (2011) illustrated that extending DPΠ by a transition rule",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 23,
      "context" : "Many answer set solvers for such programs can be seen as extensions of this procedure (Lierler and Truszczynski 2011).",
      "startOffset" : 86,
      "endOffset" : 117
    }, {
      "referenceID" : 5,
      "context" : "The problem of deciding whether a disjunctive program has a stable model is Σ2 complete (Eiter and Gottlob 1993).",
      "startOffset" : 88,
      "endOffset" : 112
    }, {
      "referenceID" : 19,
      "context" : "We now relate the graph DP 2 g,t(Π ) to the procedure dp-assat-proc from Lierler (2005). This procedure forms the basis of the answer set solver cmodels.",
      "startOffset" : 73,
      "endOffset" : 88
    }, {
      "referenceID" : 21,
      "context" : "To be complete in our presentation, we now review the details of g and t functions (Lierler 2010).",
      "startOffset" : 83,
      "endOffset" : 97
    }, {
      "referenceID" : 2,
      "context" : "In Brochenin et al. (2014), transition systems exemplified by the graph DP 2 Π were used to capture several disjunctive solvers, namely, cmodels, gnt and dlv implementing backtracking.",
      "startOffset" : 3,
      "endOffset" : 27
    }, {
      "referenceID" : 22,
      "context" : "For instance, for a non-disjunctive program Π , the graph DPTsm,Π coincides with the graph smΠ (Lierler 2011) that captures computation of answer set solver smodels (Simons et al.",
      "startOffset" : 95,
      "endOffset" : 109
    }, {
      "referenceID" : 30,
      "context" : "For instance, for a non-disjunctive program Π , the graph DPTsm,Π coincides with the graph smΠ (Lierler 2011) that captures computation of answer set solver smodels (Simons et al. 2002).",
      "startOffset" : 165,
      "endOffset" : 185
    }, {
      "referenceID" : 22,
      "context" : "The graph DPTsd,Π coincides with the graph atleastΠ (Lierler 2011) that provides a procedure for deciding whether a non-disjunctive program has supported models.",
      "startOffset" : 52,
      "endOffset" : 66
    }, {
      "referenceID" : 15,
      "context" : "Janhunen et al. (2006) define the generating function g and the witness function t used in gnt.",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 15,
      "context" : "The graph SM Π captures the gnt procedure by Janhunen et al. (2006) in a similar way as the graph DP 2 Π captures the cmodels procedure of dp-assat-proc in Section 3.",
      "startOffset" : 45,
      "endOffset" : 68
    }, {
      "referenceID" : 15,
      "context" : "The graph SM Π captures the gnt procedure by Janhunen et al. (2006) in a similar way as the graph DP 2 Π captures the cmodels procedure of dp-assat-proc in Section 3.2. Figure 7 presents an example of a path in a graph SM {a←c;b←c;c←a,b;a∨b←}. From the formal results by Janhunen et al. (2006) it immediately follows that g is sta-approximating with respect to cla and t is sta-ensuring with respect to cla.",
      "startOffset" : 45,
      "endOffset" : 294
    }, {
      "referenceID" : 2,
      "context" : "6 Corollary 1 corresponds to Theorem 5 in (Brochenin et al. 2014).",
      "startOffset" : 42,
      "endOffset" : 65
    }, {
      "referenceID" : 7,
      "context" : "t(Π ,M) = {(B ∩M) ∨ ∨ A′ ∨ | A ← B ∈ Π + , B ⊆ M,A = A ∩M}∪ {(M|atoms(Π )) } (9) Following the results from Faber (2002) and Koch et al.",
      "startOffset" : 108,
      "endOffset" : 121
    }, {
      "referenceID" : 7,
      "context" : "t(Π ,M) = {(B ∩M) ∨ ∨ A′ ∨ | A ← B ∈ Π + , B ⊆ M,A = A ∩M}∪ {(M|atoms(Π )) } (9) Following the results from Faber (2002) and Koch et al. (2003), the generating function g is sup-approximating with respect to cla while the witness function t is cla-ensuring with respect to cla.",
      "startOffset" : 108,
      "endOffset" : 144
    }, {
      "referenceID" : 2,
      "context" : "7 Corollary 2 corresponds to Theorem 6 in (Brochenin et al. 2014).",
      "startOffset" : 42,
      "endOffset" : 65
    }, {
      "referenceID" : 7,
      "context" : "This corollary is an alternative proof of correctness for the dlv algorithm previously stated by Faber (2002) and Koch et al.",
      "startOffset" : 97,
      "endOffset" : 110
    }, {
      "referenceID" : 7,
      "context" : "This corollary is an alternative proof of correctness for the dlv algorithm previously stated by Faber (2002) and Koch et al. (2003) in terms of pseudo-code.",
      "startOffset" : 97,
      "endOffset" : 133
    }, {
      "referenceID" : 19,
      "context" : "We now generalize Lemma 4 from Lierler (2008) to the case of disjunctive programs.",
      "startOffset" : 31,
      "endOffset" : 46
    }, {
      "referenceID" : 23,
      "context" : "Transition systems for describing dpll-based solving procedures have been introduced by Nieuwenhuis et al. (2006). Lierler (2008) introduced and compared the transition systems for the answer set solvers smodels and cmodels for nondisjunctive programs.",
      "startOffset" : 88,
      "endOffset" : 114
    }, {
      "referenceID" : 19,
      "context" : "Lierler (2008) introduced and compared the transition systems for the answer set solvers smodels and cmodels for nondisjunctive programs.",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 23,
      "context" : "Nieuwenhuis et al. (2006) considered another extension of the graphs by introducing transition rules that capture backjumping and learning techniques common in design of modern solvers, that later allowed Lierler (2011) to design, e.",
      "startOffset" : 0,
      "endOffset" : 26
    }, {
      "referenceID" : 19,
      "context" : "(2006) considered another extension of the graphs by introducing transition rules that capture backjumping and learning techniques common in design of modern solvers, that later allowed Lierler (2011) to design, e.",
      "startOffset" : 186,
      "endOffset" : 201
    }, {
      "referenceID" : 14,
      "context" : "Other methods include pseudo-code presentation of algorithms (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013).",
      "startOffset" : 61,
      "endOffset" : 116
    }, {
      "referenceID" : 13,
      "context" : "Other methods include pseudo-code presentation of algorithms (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013).",
      "startOffset" : 61,
      "endOffset" : 116
    }, {
      "referenceID" : 9,
      "context" : "2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013).",
      "startOffset" : 26,
      "endOffset" : 74
    }, {
      "referenceID" : 10,
      "context" : "2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013).",
      "startOffset" : 26,
      "endOffset" : 74
    }, {
      "referenceID" : 9,
      "context" : "2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013). Giunchiglia et al. (2008) presented pseudo-code descriptions of cmodels without backjumping and learning, smodels and dlv without backjumping restricted to non-disjunctive programs.",
      "startOffset" : 27,
      "endOffset" : 102
    }, {
      "referenceID" : 9,
      "context" : "2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013). Giunchiglia et al. (2008) presented pseudo-code descriptions of cmodels without backjumping and learning, smodels and dlv without backjumping restricted to non-disjunctive programs. They study relationships to the solving algorithms by analyzing the correspondence about the search spaces they explore, focusing on tight programs: in particular, they note a tight relation between solvers cmodels and dlv. Gebser and Schaub (2013) considered formal proof systems based on tableau methods for characterizing the operations and the strategies of ASP procedures for disjunctive programs.",
      "startOffset" : 27,
      "endOffset" : 507
    } ],
    "year" : 2015,
    "abstractText" : "Answer set programming is a declarative programming paradigm oriented towards difficult combinatorial search problems. A fundamental task in answer set programming is to compute stable models, i.e., solutions of logic programs. Answer set solvers are the programs that perform this task. The problem of deciding whether a disjunctive program has a stable model is Σ2 -complete. The high complexity of reasoning within disjunctive logic programming is responsible for few solvers capable of dealing with such programs, namely dlv, gnt, cmodels, clasp and wasp. In this paper we show that transition systems introduced by Nieuwenhuis, Oliveras, and Tinelli to model and analyze satisfiability solvers can be adapted for disjunctive answer set solvers. Transition systems give a unifying perspective and bring clarity in the description and comparison of solvers. They can be effectively used for analyzing, comparing and proving correctness of search algorithms as well as inspiring new ideas in the design of disjunctive answer set solvers. In this light, we introduce a general template, which accounts for major techniques implemented in disjunctive solvers. We then illustrate how this general template captures solvers dlv, gnt, and cmodels. We also show how this framework provides a convenient tool for designing new solving algorithms by means of combinations of techniques employed in different solvers. To appear in Theory and Practice of Logic Programming (TPLP).",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}