{
  "name" : "1602.05028.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Symmetry Breaking Predicates for SAT-based DFA Identification",
    "authors" : [ "Vladimir Ulyantsev", "Ilya Zakirzyanov", "Anatoly Shalyto" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 2.\n05 02\n8v 2\n[ cs\n.F L\n] 1\n7 Fe\nb 20\n16\nIt was shown before that the NP-hard problem of deterministic finite automata (DFA) identification can be effectively translated to Boolean satisfiability (SAT). Modern SAT-solvers can tackle hard DFA identification instances efficiently. We present a technique to reduce the problem search space by enforcing an enumeration of DFA states in depth-first search (DFS) or breadth-first search (BFS) order. We propose symmetry breaking predicates, which can be added to Boolean formulae representing various DFA identification problems. We show how to apply this technique to DFA identification from both noiseless and noisy data. Also we propose a method to identify all automata of the desired size. The proposed approach outperforms the current state-of-the-art DFASAT method for DFA identification from noiseless data. A big advantage of the proposed approach is that it allows to determine exactly the existence or non-existence of a solution of the noisy DFA identification problem unlike metaheuristic approaches such as genetic algorithms.\nKeywords: Grammatical inference, Boolean satisfiability, automata identification, symmetry breaking techniques"
    }, {
      "heading" : "1. Introduction",
      "text" : "Deterministic finite automata (DFA) are models that recognize regular languages [1], therefore the problem of DFA identification (induction, learning) is one of the best studied [2] in grammatical inference. The identification problem consists of finding a DFA with the minimal number of states that is consistent with a given set of strings with language attribution labels. This means that such a DFA rejects the negative example strings and accepts the positive example strings. It was shown in [3] that finding a DFA with a given upper bound on its size (number of states) is an NP-complete problem. Besides, in [4] it was shown that this problem cannot be approximated within any polynomial.\nDespite this theoretical difficulty, several efficient DFA identification algorithms exist [2]. The most common approach is the evidence driven state-merging (EDSM) algorithm [5]. The key idea of this algorithm is to first construct an augmented prefix tree acceptor (APTA), a tree-shaped automaton, from the given labeled strings, and then to apply iteratively a state-merging procedure until no valid merges are left. Thus EDSM is a polynomial-time greedy method that tries to find a good local optimum. EDSM participated in the Abbadingo DFA learning competition [5] and won it (in a tie). To improve the EDSM algorithm several specialized search procedures were proposed, see, e.g., [6, 7]. One of the most successful approaches is the EDSM algorithm in the red-blue framework [5], also called the Blue-fringe algorithm.\nThe second approach for DFA learning is based on evolutionary computation; early work includes [8, 9]. Later the authors of [10] presented an effective scheme for evolving DFA with a multi-start random hill climber, which was used to optimize the transition matrix of the identified DFA. A so-called smart state labeling scheme was applied to choose state labels optimally, given the transition matrix and the training\n∗Principal corresponding author ∗∗Corresponding author\nEmail addresses: ulyantsev@rain.ifmo.ru (Vladimir Ulyantsev), zakirzyanov@rain.ifmo.ru (Ilya Zakirzyanov), shalyto@mail.ifmo.ru (Anatoly Shalyto)\nPreprint submitted to Elsevier February 25, 2016\nset. The authors emphasized that smart selection of state labels gave the evolutionary method a significant boost which allowed it to compete with EDSM. Authors find that the proposed evolutionary algorithm (EA) outperforms the EDSM algorithm on small target DFA when the training set is sparse. For larger automata with 32 states, the hill climber fails and EDSM clearly outperforms it.\nThe challenge of the GECCO 2004 Noisy DFA competition [11] was to learn the target DFA when 10 percent of the given training string labels had been randomly flipped. In [12] Lucas and Reynolds show that within limited time the EA with smart state labeling is able to identify the target DFA even at such high noise level. The authors compared their algorithm with the results of the GECCO competition and found that the EA clearly outperformed all the entries. Thereby it is the state-of-the-art technique for learning DFA from noisy training data.\nIn several cases the best solution for noiseless DFA identification is the translation-to-SAT technique [13], which was altered to suit the StaMInA (State Machine Inference Approaches) competition [14] and ultimately won. The main idea of that algorithm is to translate the DFA identification problem to Boolean satisfiability (SAT). Thus it is possible to use highly optimized modern DPLL-style SAT solving techniques [15]. The translation-to-SAT approach was also used to efficiently tackle problems such as bounded model checking [16], solving SQL constraints by incremental translation [17], analysis of JML-annotated Java sequential programs [18], extended finite-state machine induction [19].\nMany optimization problems exhibit symmetries – groups of solutions which can be obtained from each other via some simple transformations. To speed up the solution search process we can reduce the problem search space by performing symmetry breaking. In DFA identification problems the most straightforward symmetries are groups of isomorphic automata. The idea of avoiding isomorphic DFAs by fixing state numbers in breadth-first search (BFS) order was used in the state-merging approach [20] (function NatOrder) and in the genetic algorithm from [21] (Move To Front reorganization). Besides, in [13] symmetry breaking was performed by fixing some colors of the APTA vertices from a clique provided by a greedy max-clique algorithm applied in a preprocessing step of translation-to-SAT technique.\nIn this paper we propose new symmetry breaking predicates [15] which can be added to Boolean formulae representing various DFA identification problems. These predicates enforce DFA states to be enumerated in the DFS (depth-first search) or BFS order. This approach clearly outperforms current state-of-the-art DFASAT from [13]. The proposed predicates cannot be applied with the max-clique technique [13] at the same time, but our approach is more flexible. To show the flexibility of the approach, we pay our attention to the case of noisy DFA identfication. Therefore we propose a modification of the noiseless translation-to-SAT for the noisy case (Section 3). We show that the previously proposed max-clique technique is not applicable in this case while our BFS-based approach is. The big advantage of our approach is that we can determine the existence or non-existence of a solution in this case unlike genetic algorithms. Experiments showed that using BFS-based symmetry breaking predicates can significantly reduce the time of algorithm execution. We also show that our strategy outperforms the current state-of-the-art EA from [12] if the number of the target DFA states, the noise level and the number of strings are small. We also propose a modification of this method to solve the problem of finding all automata with the minimal number of states which are consistent with a given set of strings."
    }, {
      "heading" : "2. Encoding DFA Identification into SAT",
      "text" : "The goal of DFA identification is to find a smallest DFA A such that every string from S+, a set of positive examples, is accepted by A, and every string from S−, a set of negative examples, is rejected. The size of A is defined as the number of states C it has. The alphabet Σ = {l1, . . . , lL} of the sought DFA A is the set of all symbols from S+ and S− where L is the alphabet size. The example of the smallest DFA for S+ = {ab, b, ba, bbb} and S− = {abbb, baba} is shown in Fig. 1. In this work we assume that DFA states are numbered from 1 to C and the start state has number 1.\nIn [13] Heule and Verwer proposed a compact translation of the DFA identification problem into SAT. Here we briefly review the proposed technique, since our symmetry breaking predicates supplement it. The first step of both the state-merging and the translation-to-SAT techniques is the augmented prefix tree\nacceptor (APTA) construction from the given examples S+ and S−. An APTA is a tree-shaped automaton such that paths corresponding to two strings reach the same state v if and only if these strings share the same prefix in which the last symbol corresponds to v. We denote by V the set of all APTA states; by vr the APTA root; by V+ the set of accepting states; and by V− the set of rejecting states. Moreover, for state v (except vr) we denote its incoming symbol by l(v) and its parent by p(v). The APTA for S+ and S− mentioned above is shown in Fig. 2a.\nThe second step of the technique proposed in [13] is the construction of the consistency graph (CG) for the obtained APTA. The set of nodes of the CG is identical to the set of APTA states. Two CG nodes v and w are connected with an edge (and called inconsistent) if merging v and w in the APTA results in an inconsistency: an accepting state is merged with a rejecting state. Let E denote the set of CG edges. The CG for APTA of Fig. 2a is shown in Fig. 2b.\nThe key part of the algorithm is translating the DFA identification problem into a Boolean formula in conjunctive normal form (CNF) and using a SAT solver to find a satisfying assignment. For a given set of examples and fixed DFA size C the solver returns a satisfying assignment (that defines a DFA with C states that is compliant with S+ and S−) or a message that it does not exist. The main idea of this translation is to use a distinct color for every state of the identified DFA and to find a consistent mapping of APTA states to colors. Three types of variables were used in the proposed compact translation:\n1. color variables xv,i ≡ 1 (v ∈ V ; 1 ≤ i ≤ C) if and only if APTA state v has color i (APTA state v will be merged into DFA state i);\n2. parent relation variables yl,i,j ≡ 1 (l ∈ Σ; 1 ≤ i, j ≤ C) if and only if DFA transition with symbol l from state i ends in state j;\n3. accepting color variables zi ≡ 1 (1 ≤ i ≤ C) if and only if DFA state i is accepting.\nDirect encoding, described in [13], uses only variables xv,i; variables yl,i,j and zi are auxiliary and used in compact encoding predicates, which are described below.\nThe compact translation proposed in [13] uses nine types of clauses:\n1. xv,i ⇒ zi (v ∈ V+; 1 ≤ i ≤ C) – definitions of zi values for accepting states (¬xv,i ∨ zi);\n2. xv,i ⇒ ¬zi (v ∈ V−; 1 ≤ i ≤ C) – definitions of zi values for rejecting states (¬xv,i ∨ ¬zi);\n3. xv,1 ∨ xv,2 ∨ . . . ∨ xv,C (v ∈ V ) – each state v has at least one color;\n4. xp(v),i ∧ xv,j ⇒ yl(v),i,j (v ∈ V \\ {vr}; 1 ≤ i, j ≤ C) – a DFA transition is set when a state and its parent are colored (yl(v),i,j ∨ ¬xp(v),i ∨ ¬xv,j);\n5. yl,i,j ⇒ ¬yl,i,k (l ∈ Σ; 1 ≤ i, j, k ≤ C; j < k) – each DFA transition can target at most one state (¬yl,i,j ∨ ¬yl,i,k);\n6. ¬xv,i ∨ ¬xv,j (v ∈ V ; 1 ≤ i < j ≤ C) – each state has at most one color;\n7. yl,i,1 ∨ yl,i,2 ∨ . . . ∨ yl,i,C (l ∈ Σ; 1 ≤ i ≤ C) – each DFA transition must target at least one state;\n8. yl(v),i,j ∧xp(v),i ⇒ xv,j (v ∈ V \\{vr}; 1 ≤ i, j ≤ C) – state color is set when DFA transition and parent color are set (¬yl(v),i,j ∨ ¬xp(v),i ∨ xv,j);\n9. xv,i ⇒ ¬xw,i ((v, w) ∈ E; 1 ≤ i ≤ C) – the colors of two states connected with an edge in the consistency graph must be different (¬xv,i ∨ ¬xw,i).\nThus, the constructed formula consists of O(C2|V |) clauses and, if the SAT solver finds a solution, we can identify the DFA.\nTo find a minimal DFA, the authors use incremental SAT solving. The initial DFA size C is equal to the size of a large clique found in the CG. To find such a clique, a greedy algorithm proposed in [13] can be applied. Then the minimal DFA is found by iterating over the DFA size C until the formula is satisfied. Algorithm 1 illustrates this approach.\nThe found clique was also used to perform symmetry breaking: in any valid coloring of a graph, all states in a clique must have a different color. Thus, we can fix the state colors in the clique during the preprocessing step. Later we will see that the max-clique symmetry breaking is not compatible with the one proposed in this paper.\nTo reduce the SAT search space significantly, the authors applied several EDSM steps before translating the problem to SAT. Since EDSM cannot guarantee the minimality of solution, we will omit the consideration of this step in our paper."
    }, {
      "heading" : "3. Learning DFA from Noisy Samples",
      "text" : "The translation described in the previous section deals with exact DFA identification. In this section we show how to modify the translation in order to apply it to noisy examples. We assume that not more than K attribution labels of the given training strings were randomly flipped. Solving this problem was the goal of the GECCO 2004 Noisy DFA competition [11] (with K equal to 10 percent of the number of the given training strings). The EA with smart state labeling was later proposed in [12], and since that time it has been, to the best of our knowledge, the state-of-the-art technique for learning DFA from noisy training data.\nIn the noisy case we cannot use the APTA node consistency: we cannot determine whether an accepting state is merged with a rejecting state since correct string labels are unknown. Thus we cannot use CG and the max-clique symmetry breaking.\nThe idea of our modification is rather simple: for each labeled state of the APTA we define a variable which states whether the label can be flipped. The number of flips is limited by K. Formally, for each\nData: set of strings SS, minimum size of the target DFA minSize, maximum size of the target DFA maxSize, symmetry breaking strategy SBStrategy, external SAT-solver solver, time limit for SAT-solver TL APTA ← buildAPTA(SS) CG ← buildCG(APTA) clique ← findClique(APTA, CG) minSize ← max(minSize, clique.size) for colors ← minSize to maxSize do\ndimacsFile ← generateFileInDimacsFormat(APTA, CG, colors, SBStrategy) result ← solver.solve(dimacsFile, TL) if result is ‘SAT’ then\nsolution ← solver.getSolution() DFA ← buildSolution(solution) return DFA\nend\nend return null Algorithm 1: Scheme of the SAT-based algorithm\nv ∈ V± = V+ ∪ V− we define fv which is true if and only if the label of state v can (but does not have to) be incorrect (f lipped). Using these variables, we can modify the translation proposed in [13] to take into account mistakes in string labels. To do this, we change the zi definition clauses (items 1 and 2 from list in Section 2): because of mistake possibility they hold in case fv is false. Thus, new zi value definitions are expressed in the following way: ¬fv ⇒ (xv,i ⇒ zi) for v ∈ V+; ¬fv ⇒ (xv,i ⇒ ¬zi) for v ∈ V−.\nTo limit the number of corrections to K we use an auxiliary array of K integer variables. This array stores the numbers of the APTA states for which labels can be flipped. Thus, fv is true if and only if the array contains v. To avoid the consideration of isomorphic permutations we enforce the array to be sorted in the increasing order.\nTo represent the auxiliary array as a Boolean formula we define variables ri,v for 1 ≤ i ≤ K and v ∈ V± = {v1, . . . , vW }. ri,v is true if and only if v is stored in the i-th position of the array. To connect variables fv with ri,v we add so-called channeling constrains: fv ⇔ (r1,v ∨ . . . ∨ rK,v) for each v ∈ V±.\nWe have to state that exactly one ri,v is true for each position i in the auxiliary array. To achieve that we use the order encoding method [22]. We add auxiliary order variables oi,v for 1 ≤ i ≤ K and v ∈ V± = {v1, . . . , vW }. We assume that oi,v for v ∈ {v1, . . . , vj} and ¬oi,v for v ∈ {vj+1, . . . , vW } for some j. This can be expressed by the following constraint: oi,vj+1 ⇒ oi,vj for 1 ≤ j < W . Now we define that ri,vj ⇔ oi,vj ∧ ¬oi,vj+1 . We also add clauses oi,vj ⇒ oi+1,vj+1 (for 1 ≤ i < K and 1 ≤ j < W ) to store corrections in the increasing order.\nThe proposed constraints in CNF are listed in Table 1; there are O(C|V±| +K|V±|) clauses. Thus, to modify the translation for the noiseless case to deal with noise we can replace the zi value definition and inconsistency clauses (items 1, 2 and 9 from list in Section 2) with the ones listed in Table 1."
    }, {
      "heading" : "4. DFS-based Symmetry Breaking Predicates",
      "text" : "In this section we propose a way to fix automata state enumeration to avoid consideration of isomorphic automata during SAT solving. The main idea of our symmetry breaking is to enforce DFA states to be enumerated in the depth-first search (DFS) order. Thus only one representative of each equivalence class with respect to the isomorphic relation will be processed.\nIt is necessary to find all adjacent unvisited states for each unvisited state of the DFA during DFS processing. First the algorithm handles the start DFA state. Then the algorithm processes the children of this state and recursively runs for each of them. We will use an auxiliary structure, an array with transitions which connect its elements. These elements are the numbers of states ordered according to the\nDFS enumeration. Each transition connecting the elements of the array will be a copy of a DFA transition which was used by DFS. Since our transitions are labeled with symbols from Σ, we process child states in the alphabetical order of symbols l on transitions i l −→ j. We call a DFA DFS-enumerated if its auxiliary array is filled by consecutive numbers in the increasing order starting from 1. An example of a DFS-enumerated DFA with six states is shown in Fig. 3a (DFS tree transitions that were used to add states into the array are marked bold); the DFS auxiliary array for this DFA is shown in Fig. 6b. The DFA shown in Fig. 1 is not DFS-enumerated – DFS first handles state 3 rather than state 2 (we consider 1 a −→ 3 before 1 b −→ 2).\nWe propose the constraints that enforce DFA to be DFS-enumerated. We assume that translation of a given DFA identification problem to SAT deals with Boolean variables yl,i,j (l ∈ Σ; 1 ≤ i, j ≤ C) to set the DFA transition function: yl,i,j ≡ 1 if and only if the transition with symbol l from state i ends in state j.\nThe main idea is to determine each state’s parent in the DFS-tree and set constrains between states’ parents. We store parents in values pj,i (for each 1 ≤ i < j ≤ C). pj,i is true if and only if state i is the parent of j in the DFS-tree. Each state except the initial one must have a parent with a smaller number, thus ∧\n2≤j≤C\n(pj,1 ∨ pj,2 ∨ . . . ∨ pj,j−1).\nWe set parent variables pj,i through yl,i,j using auxiliary variables ti,j . In the DFS-enumeration state\nj was added into the array while processing the state with maximal number i among states that have a transition to j: ∧\n1≤i<j≤C\n(pj,i ⇔ ti,j ∧ ¬ti+1,j ∧ . . . ∧ ¬tj−1,j),\nwhere ti,j ≡ 1 if and only if there is a transition between i and j. We define these auxiliary variables using yl,i,j : ∧\n1≤i<j≤C\n(ti,j ⇔ yl1,i,j ∨ . . . ∨ ylL,i,j).\nMoreover, in the DFS-enumeration states’ parents must be ordered. If i is the parent of the state j and k is a state between i and j (i < k < j) then there is no transition from state k to state q which is bigger then j (see Fig. 4): ∧\n1≤i<k<j<q<C\n(pj,i ⇒ ¬tk,q).\nNow to enforce the DFA to be DFS-enumerated we have to order children in the alphabetical order of symbols on transitions. We consider two cases: alphabet Σ consists of two symbols {a, b} and more than two symbols {l1, . . . , lL}. In the case of two symbols only two states j and k can have the same parent i (where without loss of generality j < k). In this case we force the transition that starts in state i labeled with symbol a to end in state j instead of k:\n∧\n1≤i<j<k<C\n(pj,i ∧ pk,i ⇒ ya,i,j).\nIn the second case we have to introduce the third type of variables in our symmetry breaking predicates. We store the alphabetically minimal symbol on transitions between states: ml,i,j is true if and only if there is a transition i l −→ j and there is no such transition with an alphabetically smaller symbol. We connect these variables with DFA transitions by adding the following channeling predicates:\n∧\n1≤i<j≤C\n∧\n1≤n≤L\n(mln,i,j ⇔ yln,i,j ∧ ¬yln−1,i,j ∧ . . . ∧ ¬yl1,i,j).\nNow it remains to arrange states j and k with the same parent i in the alphabetical order of minimal symbols on transitions between them and i (see Fig. 5):\n∧\n1≤i<j<k≤C\n∧\n1≤m<n≤L\n(pj,i ∧ pk,i ∧mln,i,j ⇒ ¬mlm,i,k).\nThus we propose symmetry breaking predicates that are composed of the listed constraints. Predicates (for the case of three or more symbols) translated into O(C4 + C3L2) CNF clauses are listed in Table 2."
    }, {
      "heading" : "5. BFS-based Symmetry Breaking Predicates",
      "text" : "In this section we consider a modification of the DFS-based approach which enforce DFA states to be enumerated in the breadth-first search (BFS) order. This idea was also used in function NatOrder in\nthe state-merging approach from [20] and the Move To Front reorganization algorithm used in the genetic algorithm [21].\nBFS uses the queue data structure to store intermediate results as it traverses the graph. First we enqueue the initial DFA state. While the queue is not empty we deque a state i and enqueue any direct child states j that have not yet been discovered (enqueued before). We enqueue child states in alphabetical order of symbols l on transitions i l −→ j the same as in the DFS-based approach. We call a DFA BFS-enumerated if its states are enumerated in dequeuing (equals to enqueuing) order. An example of a BFS-enumerated DFA with six states is shown in Fig. 6a (BFS tree transitions that were used to enqueue states are marked bold); BFS enqueues are shown in Fig. 6b. The DFA shown in Fig. 1 is not BFS-enumerated – BFS first dequeues state 3 rather than state 2 (we consider 1 a −→ 3 before 1 b −→ 2).\nAll variables which were used for the DFS enumeration are also used for the BFS enumeration, but we have to consider the constraints which must be changed. In the BFS-enumeration pj,i variable definition is changed: state j should be enqueued while processing the state with the minimal number i among the states that have a transition to j:\n∧\n1≤i<j≤C\n(pj,i ⇔ ti,j ∧ ¬ti−1,j ∧ . . . ∧ ¬t1,j).\nIn the BFS-enumeration states’ parents ordering constraints are also changed: state j must be enqueued before the next state j + 1, thus the next state’s parent k cannot be less than the current state’s parent i (see Fig. 7): ∧\n1≤k<i<j<C\n(pj,i ⇒ ¬pj+1,k).\nIt is enough to consider only two consecutive states in the constraints where two states with the same parent were considered (see Fig. 8 for the second type of the constraints):\n∧\n1≤i<j<C\n(pj,i ∧ pj+1,i ⇒ ya,i,j),\n∧\n1≤i<j<C\n∧\n1≤m<n≤L\n(pj,i ∧ pj+1,i ∧mln,i,j ⇒ ¬mlm,i,j+1).\nPredicates (for the case of three or more symbols) translated into O(C3 +C2L2) CNF clauses are listed in Table 2. Our implementation of the proposed predicates and all algorithms can be found on the github repository of our laboratory 1."
    }, {
      "heading" : "6. The find-all problem",
      "text" : "In this section we pay our attention to the problem of finding all non-isomorphic DFA with the minimal number of states which are consistent with a given set of strings. We propose the way to modify the SATbased method in order to apply it to this problem. We consider two ways of using SAT-solvers: restarting a non-incremental solver after finding each automaton and using an incremental solver: if such a solver finds a solution, it retains its state and is ready to accept new clauses. The most common interface and technique for incremental SAT-solving was proposed in [23]. We also consider the heuristic Backtracking method as a baseline for comparing it with SAT-based ones."
    }, {
      "heading" : "6.1. SAT-based methods",
      "text" : "The main idea of SAT-based methods is to ban satisfying interpretations which have already been found. It is obvious that if the proposed symmetry breaking predicates are not used then this approach finds a lot of isomorphic automata (exactly n! for each equivalence class where n is the DFA size). Since max-clique predicates fix k colors only (where k is the clique size), the proposed algorithm finds (n − k)! isomorphic automatons which is also bad. The BFS-based and DFS-based symmetry breaking predicates allow to ban isomorphic DFA from one equality class by banning accordingly enumerated representative. It is easy to implement by adding an additional clause into the Boolean formula. Since we know that yl,i,j variables define the target DFA entirely, it is enough to forbid only values of these variables from found interpretation:\n¬y1 ∨ ¬y2 ∨ . . . ∨ ¬yn|Σ|,\n1https://github.com/ctlab/DFA-Inductor\nwhere yk is some true yl,i,j from the found interpretation for 1 < k < n|Σ|. There are two different ways of using SAT-solvers as it was stated above. First, we can restart a non-incremental SAT-solver with the new Boolean formula with the additional clause after finding each automaton. The second approach is based on an incremental SAT-solver: after each found automaton we add the additional clause to the solver and continue its execution.\nIt is necessary to mention the case when some transitions of the found DFA are not covered by the APTA. It means that there are some free transitions which are not used during processing any given word and each such transition can end in any state, since this does not influence the consistency of the DFA with a given set of strings. But in the case of the find-all problem we do not wish to find all these automatons differed only by such transitions. Thus we propose the way to force all free transitions to finish in the same state as they start. In other words we force them to be a loop. To achieve that we add auxiliary ‘used’ variables: ul,i is true if and only if there is a l-labeled APTA edge from the i-colored state:\n∧\nl∈Σ\n∧\n1≤i≤C\nul,i ⇔ x1,i ∨ . . . ∨ x|Vl|,i,\nwhere Vl is the set of all the APTA states which have an outcoming edge labelled with l. To force unused transitions to be a loop we add the following constraints:\n∧\nl∈Σ\n∧\n1≤i≤C\n¬ul,i ⇒ yl,i,i.\nThese additional constraints are translated into O(C|V |) clauses. See Fig. 9 for the example of an APTA for S+ = {ab, b, ba, bbb} and S− = {abbb} (it is the same example as on the Fig. 1 and Fig. 2 but without the string baba in the S−) and its consistent DFA with unused transition. If we add the proposed constraints then this transition will be forced to be a loop as shown by dashed line at the Fig. 9b."
    }, {
      "heading" : "6.2. Backtracking method",
      "text" : "The solution based on backtracking does not use any external tools like SAT-solvers. This algorithm works as follows. Initially there is an empty DFA with n states. Also there is a frontier – the set of edges from the APTA which are not represented yet in the DFA. Initially the frontier contains all the outcoming edges of the APTA root. The recursive function Backtracking maintains the frontier in the proper state. If the frontier is not empty, then the function tries to augment the DFA with one of its edges. Each found DFA is checked to be consistent with the APTA and if the DFA complies with it then an updated frontier\nis found. If the frontier is empty then the DFA is checked for completeness (a DFA is complete if there are transitions from each state labeled with all alphabet symbols). If it is not complete and there are nodes which have the number of outcoming edges less then the alphabet size then we add missing edges as loops with a function MakeComplete. Algorithm 2 illustrates the solution. The function FindNewFrontier returns the new frontier for the augmented DFA or null if the DFA is inconsistent with the APTA.\nData: augmented prefix tree acceptor APTA, current DFA (initially empty), frontier (initially contains all APTA root outcoming edges) DFAset ← new Set<DFA> edge ← any edge from frontier foreach destination ∈ 1..|S| do\nsource ← the state of DFA from which edge should be added DFA′ ← DFA ∪ transition(source, destination, edge.label) frontier′ ← FindNewFrontier(APTA, DFA′, frontier) if frontier′ 6= null then\nif frontier′ = ∅ then DFAset.add(MakeComplete(DFA′)) else DFAset.add(Backtracking(APTA, DFA′, frontier′)) end\nend\nend return DFAset Algorithm 2: Backtracking solution"
    }, {
      "heading" : "7. Experiments",
      "text" : "All experiments were performed using a machine with an AMD Opteron 6378 2.4 GHz processor running Ubuntu 14.04. All algorithms were implemented in Java, the lingeling SAT-solver was used. Our own algorithm was used for generating problem instances for all the experiments based on randomly generated data sets. This algorithm builds a set of strings with the following parameters: sizeN of DFA to be generated, alphabet size A, the number S of strings to be generated, noise level K (percentage of attribution labels of generated strings which have to be randomly flipped).\nFor exact DFA identification we used randomly generated instances. We used the following parameters: N ∈ [10; 20], A = 2, S = 50N . We compared the SAT-based approach with three types of symmetry breaking predicates: the max-clique algorithm from [13] and the proposed DFS-based and BFS-based methods. Each\nexperiment was repeated 100 times. The time limit was set to 3600 seconds. Values in italics mean that not all 100 instances were solved within the time limit. If less than 50 instances were solved then TL is shown instead of a value. The results are listed in Table 3. It can be seen from the table that both DFS-based and BFS-based strategies clearly outperform the max-clique approach which is the current state-of-the-art. BFS-based strategy in its turn outperforms DFS-based one when target automaton size is larger than 14.\nFor noisy DFA identification we also used randomly generated instances. First we considered the case when the target DFA exists and the Boolean formula is satisfiable. We used the following parameters: N ∈ [5; 10], A = 2, S ∈ {10N, 25N, 50N}. We compared three methods: the SAT-based approach without any symmetry breaking predicates, our solution using BFS-based symmetry breaking predicates, and the current state-of-the-art EA from [12]. Each experiment was repeated 100 times. The time limit was set to 1800 seconds. The initial experiments showed that the EA outperforms our method clearly when K > 4%. Therefore we set this parameter to 1% − 4%. We left only instances which were solved within the time limit. These results indicate that the BFS-based strategy finds the solution slightly faster than the current state-of-the-art EA only when N is small (< 7), noise level is small (1%− 4%) and the number of strings is also small (< 50N). But BFS-based strategy finds the solution extremely faster than SAT approach without the symmetry breaking strategy.\nThe third experiment considered the case when the target DFA does not exist and the Boolean formula is unsatisfiable. Random dataset was also used here. We tried to find the target DFA using the following parameters: N ∈ [5; 7], A = 2, S = 50N , K ∈ [1%; 2%]. The input set of strings was generated from an (N + 1)-sized DFA. It should be noted that the EA from [12] cannot determine that the automaton consistent with a given set of strings does not exist. On the other hand, all SAT-based methods are capable of that. Therefore we compared our implementation of compact SAT encoding without using symmetry breaking predicates (WO) and the same with the BFS-based predicates. Each experiment was repeated 100 times and the time limit was set to 1800 seconds again. The results are listed in Table 4. It can be seen from the table that the BFS-based strategy reduces significantly the mean time of determination that an automaton does not exist.\nThe last experiment concerned the find-all problem. A random dataset was also used here. We used the following parameters: N ∈ [5; 11], A = 2, S ∈ {5N, 10N, 25N}. We compared the SAT-based method with the restarting strategy (REST), the SAT-based method with the incremental strategy (INC) and the backtracking method (BTR). Each experiment was repeated 100 times as well. The time limit was set to 3600 seconds. The first column in each subtable contains the number of instances which has more than one DFA in the solution (> 1). Values in italics mean that not all 100 instances were solved within the time limit. If less than 50 instances were solved then TL is shown instead of a value. The results are listed in Table 5. It can be seen from the table SAT-based methods work significantly faster then backtracking one. As we see incremental strategy in its turn clearly outperforms restart strategy. It can be explained as incremental SAT-solver saves its state but non-incremental solver does the same actions each execution."
    }, {
      "heading" : "8. Conclusions and Future Work",
      "text" : "We have proposed symmetry breaking predicates which can be added to the Boolean formula representing various DFA identification problems. By adding the predicates we can reduce the problem search space through enforcing DFA states to be enumerated in the depth-first search or the breadth-first search order.\nIn the case of noiseless DFA identification we have compared translation-to-SAT method from [13] to the same one with proposed symmetry breaking predicates instead of original max-clique predicates. The proposed approach clearly improved translation-to-SAT technique which was shown with the experiments on the randomly generated input data. The BFS-based approach have shown better result than the DFS-based one if the target DFA size is large enough.\nWe also have drawn our attention to the case of noisy DFA identification. We have proposed a modification of the noiseless approach for the noisy case. To achieve compact encoding for that case we have used the order encoding method. We have shown that the previously proposed max-clique technique for symmetry breaking is not applicable in the noisy case while our BFS-based approach is. We have shown that the BFS-based strategy can be applied in the noisy case when an automaton which is consistent with a given set of strings does not exists. The current state-of-the-art EA from [12] cannot determine that. In experimental results, we have shown that our approach with BFS-based symmetry breaking predicates clearly outperforms the algorithm without any predicates.\nWe have proposed a solution for the find-all DFA problem. The proposed approach can solve the problem that the previously developed methods cannot be applied for efficiently. We had performed the experiments which have shown that our approach with the incremental SAT-solver clearly outperfoms the backtracking algorithm.\nWe plan to translate the problem of noisy DFA identification to Max-SAT in order to limit the number of corrections without using an auxiliary array of integer variables. We also plan to experiment with alternative integer encoding methods."
    }, {
      "heading" : "Acknowledgements",
      "text" : "The authors would like to thank Igor Buzhinsky, Daniil Chivilikhin and Maxim Buzdalov for useful comments. This work was financially supported by the Government of Russian Federation, Grant 074-U01, and also partially supported by RFBR, research project No. 14-07-31337 mol a."
    } ],
    "references" : [ {
      "title" : "Introduction to Automata Theory",
      "author" : [ "J. Hopcroft", "R. Motwani", "J. Ullman" ],
      "venue" : "Languages, and Computation, Addison-Wesley",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A bibliographical study of grammatical inference, Pattern recognition",
      "author" : [ "C. De La Higuera" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2005
    }, {
      "title" : "Complexity of automaton identification from given data",
      "author" : [ "E.M. Gold" ],
      "venue" : "Information and Control 37 (3) ",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "The Minimum Consistent DFA Problem Cannot be Approximated within Any Polynomial",
      "author" : [ "L. Pitt", "M.K. Warmuth" ],
      "venue" : "Journal of the ACM 40 (1) ",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Results of the Abbadingo One DFA Learning Competition and a New Evidence-driven State Merging Algorithm",
      "author" : [ "K.J. Lang", "B.A. Pearlmutter", "R.A. Price" ],
      "venue" : "in: Grammatical Inference, Springer",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Faster Algorithms for Finding Minimal Consistent DFAs",
      "author" : [ "K.J. Lang" ],
      "venue" : "Tech. rep. ",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Inference of regular languages using state merging algorithms with search",
      "author" : [ "M. Bugalho", "A.L. Oliveira" ],
      "venue" : "Pattern Recognition 38 (9) ",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Regular Grammatical Inference from Positive and Negative Samples by Genetic Search: the GIG Method",
      "author" : [ "P. Dupont" ],
      "venue" : "in: Grammatical Inference and Applications, Springer",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "genetic” programming",
      "author" : [ "S. Luke", "S. Hamahashi", "H. Kitano" ],
      "venue" : "in: Proceedings of the Genetic and Evolutionary Computation Conference, Vol. 2",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Learning DFA: Evolution Versus Evidence Driven State Merging",
      "author" : [ "S.M. Lucas", "T.J. Reynolds" ],
      "venue" : "in: Evolutionary Computation, 2003. CEC’03. The 2003 Congress on, Vol. 1, IEEE",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "GECCO 2004 Noisy DFA Results",
      "author" : [ "S. Lucas" ],
      "venue" : "in: GECCO Proc.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Learning deterministic finite automata with a smart state labeling evolutionary algorithm",
      "author" : [ "S.M. Lucas", "T.J. Reynolds" ],
      "venue" : "Pattern Analysis and Machine Intelligence, IEEE Transactions on 27 (7) ",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Exact DFA Identification Using SAT Solvers",
      "author" : [ "M.J. Heule", "S. Verwer" ],
      "venue" : "in: Grammatical Inference: Theoretical Results and Applications, Springer",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "STAMINA: a Competition to Encourage the Development and Assessment of Software Model Inference Techniques",
      "author" : [ "N. Walkinshaw", "B. Lambeau", "C. Damas", "K. Bogdanov", "P. Dupont" ],
      "venue" : "Empirical Software Engineering 18 (4) ",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "H",
      "author" : [ "A. Biere", "M. Heule" ],
      "venue" : "van Maaren, Handbook of Satisfiability, Vol. 185, IOS Press",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "An Analysis of SAT-based Model Checking Techniques in an Industrial Environment",
      "author" : [ "N. Amla", "X. Du", "A. Kuehlmann", "R.P. Kurshan", "K.L. McMillan" ],
      "venue" : "in: Correct Hardware Design and Verification Methods, Springer",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Solving SQL Constraints by Incremental Translation to SAT",
      "author" : [ "R. Lohfert", "J. Lu", "D. Zhao" ],
      "venue" : "in: N. Nguyen, L. Borzemski, A. Grzech, M. Ali (Eds.), New Frontiers in Applied Artificial Intelligence, Vol. 5027 of LNCS",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "TACO: Efficient SAT-Based Bounded Verification Using Symmetry Breaking and Tight Bounds",
      "author" : [ "J.P. Galeotti", "N. Rosner", "C.G. Lopez Pombo", "M.F. Frias" ],
      "venue" : "IEEE Transactions on Software Engineering 39 (9) ",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Extended Finite-state Machine Induction Using SAT-solver",
      "author" : [ "V. Ulyantsev", "F. Tsarev" ],
      "venue" : "in: Proc. of ICMLA 2011, Vol. 2, IEEE",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "State-merging DFA Induction Algorithms with Mandatory Merge Constraints",
      "author" : [ "B. Lambeau", "C. Damas", "P. Dupont" ],
      "venue" : "in: Grammatical Inference: Algorithms and Applications, Springer",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Practical Handbook of Genetic Algorithms: Complex Coding Systems",
      "author" : [ "L.D. Chambers" ],
      "venue" : "Vol. 3, CRC press",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Efficient SAT-Encoding of Linear CSP Constraints",
      "author" : [ "P. Barahona", "S. Hölldobler", "V. Nguyen" ],
      "venue" : "in: 13rd International Symposium on Artificial Intelligence and Mathematics-ISAIM, Fort Lauderdale, Florida, USA",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "An extensible SAT-solver",
      "author" : [ "N. Eén", "N. Sörensson" ],
      "venue" : "in: Theory and applications of satisfiability testing, Springer",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2004
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Deterministic finite automata (DFA) are models that recognize regular languages [1], therefore the problem of DFA identification (induction, learning) is one of the best studied [2] in grammatical inference.",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 1,
      "context" : "Deterministic finite automata (DFA) are models that recognize regular languages [1], therefore the problem of DFA identification (induction, learning) is one of the best studied [2] in grammatical inference.",
      "startOffset" : 178,
      "endOffset" : 181
    }, {
      "referenceID" : 2,
      "context" : "It was shown in [3] that finding a DFA with a given upper bound on its size (number of states) is an NP-complete problem.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 3,
      "context" : "Besides, in [4] it was shown that this problem cannot be approximated within any polynomial.",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 1,
      "context" : "Despite this theoretical difficulty, several efficient DFA identification algorithms exist [2].",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 4,
      "context" : "The most common approach is the evidence driven state-merging (EDSM) algorithm [5].",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 4,
      "context" : "EDSM participated in the Abbadingo DFA learning competition [5] and won it (in a tie).",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 5,
      "context" : ", [6, 7].",
      "startOffset" : 2,
      "endOffset" : 8
    }, {
      "referenceID" : 6,
      "context" : ", [6, 7].",
      "startOffset" : 2,
      "endOffset" : 8
    }, {
      "referenceID" : 4,
      "context" : "One of the most successful approaches is the EDSM algorithm in the red-blue framework [5], also called the Blue-fringe algorithm.",
      "startOffset" : 86,
      "endOffset" : 89
    }, {
      "referenceID" : 7,
      "context" : "The second approach for DFA learning is based on evolutionary computation; early work includes [8, 9].",
      "startOffset" : 95,
      "endOffset" : 101
    }, {
      "referenceID" : 8,
      "context" : "The second approach for DFA learning is based on evolutionary computation; early work includes [8, 9].",
      "startOffset" : 95,
      "endOffset" : 101
    }, {
      "referenceID" : 9,
      "context" : "Later the authors of [10] presented an effective scheme for evolving DFA with a multi-start random hill climber, which was used to optimize the transition matrix of the identified DFA.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 10,
      "context" : "The challenge of the GECCO 2004 Noisy DFA competition [11] was to learn the target DFA when 10 percent of the given training string labels had been randomly flipped.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 11,
      "context" : "In [12] Lucas and Reynolds show that within limited time the EA with smart state labeling is able to identify the target DFA even at such high noise level.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 12,
      "context" : "In several cases the best solution for noiseless DFA identification is the translation-to-SAT technique [13], which was altered to suit the StaMInA (State Machine Inference Approaches) competition [14] and ultimately won.",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 13,
      "context" : "In several cases the best solution for noiseless DFA identification is the translation-to-SAT technique [13], which was altered to suit the StaMInA (State Machine Inference Approaches) competition [14] and ultimately won.",
      "startOffset" : 197,
      "endOffset" : 201
    }, {
      "referenceID" : 14,
      "context" : "Thus it is possible to use highly optimized modern DPLL-style SAT solving techniques [15].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 15,
      "context" : "The translation-to-SAT approach was also used to efficiently tackle problems such as bounded model checking [16], solving SQL constraints by incremental translation [17], analysis of JML-annotated Java sequential programs [18], extended finite-state machine induction [19].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 16,
      "context" : "The translation-to-SAT approach was also used to efficiently tackle problems such as bounded model checking [16], solving SQL constraints by incremental translation [17], analysis of JML-annotated Java sequential programs [18], extended finite-state machine induction [19].",
      "startOffset" : 165,
      "endOffset" : 169
    }, {
      "referenceID" : 17,
      "context" : "The translation-to-SAT approach was also used to efficiently tackle problems such as bounded model checking [16], solving SQL constraints by incremental translation [17], analysis of JML-annotated Java sequential programs [18], extended finite-state machine induction [19].",
      "startOffset" : 222,
      "endOffset" : 226
    }, {
      "referenceID" : 18,
      "context" : "The translation-to-SAT approach was also used to efficiently tackle problems such as bounded model checking [16], solving SQL constraints by incremental translation [17], analysis of JML-annotated Java sequential programs [18], extended finite-state machine induction [19].",
      "startOffset" : 268,
      "endOffset" : 272
    }, {
      "referenceID" : 19,
      "context" : "The idea of avoiding isomorphic DFAs by fixing state numbers in breadth-first search (BFS) order was used in the state-merging approach [20] (function NatOrder) and in the genetic algorithm from [21] (Move To Front reorganization).",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 20,
      "context" : "The idea of avoiding isomorphic DFAs by fixing state numbers in breadth-first search (BFS) order was used in the state-merging approach [20] (function NatOrder) and in the genetic algorithm from [21] (Move To Front reorganization).",
      "startOffset" : 195,
      "endOffset" : 199
    }, {
      "referenceID" : 12,
      "context" : "Besides, in [13] symmetry breaking was performed by fixing some colors of the APTA vertices from a clique provided by a greedy max-clique algorithm applied in a preprocessing step of translation-to-SAT technique.",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 14,
      "context" : "In this paper we propose new symmetry breaking predicates [15] which can be added to Boolean formulae representing various DFA identification problems.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 12,
      "context" : "This approach clearly outperforms current state-of-the-art DFASAT from [13].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 12,
      "context" : "The proposed predicates cannot be applied with the max-clique technique [13] at the same time, but our approach is more flexible.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 11,
      "context" : "We also show that our strategy outperforms the current state-of-the-art EA from [12] if the number of the target DFA states, the noise level and the number of strings are small.",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 12,
      "context" : "In [13] Heule and Verwer proposed a compact translation of the DFA identification problem into SAT.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 12,
      "context" : "The second step of the technique proposed in [13] is the construction of the consistency graph (CG) for the obtained APTA.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 12,
      "context" : "Direct encoding, described in [13], uses only variables xv,i; variables yl,i,j and zi are auxiliary and used in compact encoding predicates, which are described below.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 12,
      "context" : "The compact translation proposed in [13] uses nine types of clauses:",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 12,
      "context" : "To find such a clique, a greedy algorithm proposed in [13] can be applied.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 10,
      "context" : "Solving this problem was the goal of the GECCO 2004 Noisy DFA competition [11] (with K equal to 10 percent of the number of the given training strings).",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 11,
      "context" : "The EA with smart state labeling was later proposed in [12], and since that time it has been, to the best of our knowledge, the state-of-the-art technique for learning DFA from noisy training data.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 12,
      "context" : "Using these variables, we can modify the translation proposed in [13] to take into account mistakes in string labels.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 21,
      "context" : "To achieve that we use the order encoding method [22].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 19,
      "context" : "the state-merging approach from [20] and the Move To Front reorganization algorithm used in the genetic algorithm [21].",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 20,
      "context" : "the state-merging approach from [20] and the Move To Front reorganization algorithm used in the genetic algorithm [21].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 22,
      "context" : "The most common interface and technique for incremental SAT-solving was proposed in [23].",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 12,
      "context" : "We compared the SAT-based approach with three types of symmetry breaking predicates: the max-clique algorithm from [13] and the proposed DFS-based and BFS-based methods.",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 11,
      "context" : "We compared three methods: the SAT-based approach without any symmetry breaking predicates, our solution using BFS-based symmetry breaking predicates, and the current state-of-the-art EA from [12].",
      "startOffset" : 192,
      "endOffset" : 196
    }, {
      "referenceID" : 11,
      "context" : "It should be noted that the EA from [12] cannot determine that the automaton consistent with a given set of strings does not exist.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 12,
      "context" : "In the case of noiseless DFA identification we have compared translation-to-SAT method from [13] to the same one with proposed symmetry breaking predicates instead of original max-clique predicates.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 11,
      "context" : "The current state-of-the-art EA from [12] cannot determine that.",
      "startOffset" : 37,
      "endOffset" : 41
    } ],
    "year" : 2016,
    "abstractText" : "It was shown before that the NP-hard problem of deterministic finite automata (DFA) identification can be effectively translated to Boolean satisfiability (SAT). Modern SAT-solvers can tackle hard DFA identification instances efficiently. We present a technique to reduce the problem search space by enforcing an enumeration of DFA states in depth-first search (DFS) or breadth-first search (BFS) order. We propose symmetry breaking predicates, which can be added to Boolean formulae representing various DFA identification problems. We show how to apply this technique to DFA identification from both noiseless and noisy data. Also we propose a method to identify all automata of the desired size. The proposed approach outperforms the current state-of-the-art DFASAT method for DFA identification from noiseless data. A big advantage of the proposed approach is that it allows to determine exactly the existence or non-existence of a solution of the noisy DFA identification problem unlike metaheuristic approaches such as genetic algorithms.",
    "creator" : "LaTeX with hyperref package"
  }
}