{
  "name" : "1405.1544.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "TRANSALG: a Tool for Translating Procedural Descriptions of Discrete Functions to SAT",
    "authors" : [ "Ilya Otpuschennikov", "Stepan Kochemazov" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 5.\n15 44\nv2 [\ncs .A\nI] 2\n9 O\nct 2\n01 5\nKeywords: SAT encoding, symbolic execution, translator, cryptographic functions"
    }, {
      "heading" : "1 Introduction",
      "text" : "Many new methods for solving Boolean Satisfiability Problem (SAT) were introduced in the past two decades. These methods make it possible to solve combinatorial problems from various areas [2]. One can use different approaches to encode an original problem to SAT [14]. Often each particular problem requires researchers to develop and implement special encoding technique. Recently a number of systems that automate procedures of encoding combinatorial problems to SAT were developed [6,7,12,17,20].\nIn our paper, we present the TRANSALG system that translates procedural descriptions of discrete functions to SAT. Translation mechanisms employed in TRANSALG are based on the ideas of S.A. Cook on propositional encoding of Turing Machine programs [3] and ideas of J.S. King on symbolic execution [8]. At this time we mainly use TRANSALG to produce SAT encodings for cryptographic functions. Inversion problems for such functions are usually computationally hard. Recent works show that the study of cryptanalysis problems in the context of SAT approach can yield promising results [5,10,13,16,18,19]. In our opinion TRANSALG might become a powerful tool in the research of various cryptographic functions.\nTo be processed by TRANSALG a function description should be written in the special TA-language. The TA-language is a procedural domain specific language (DSL) with C-like syntax. Therefore it is usually sufficient to introduce minor changes to Cimplementation of an algorithm to produce its description in the TA-language.\nIt should be noted that the base concept of TRANSALG makes it possible to produce SAT encodings for arbitrary discrete functions computable in polynomial time. We believe that TRANSALG will be useful for many researchers who want to use SAT approach in their studies but don’t have time or desire to develop special encoding techniques for each individual problem."
    }, {
      "heading" : "2 The TA-language for Description of Discrete Functions",
      "text" : "As we already mentioned above, the TRANSALG system uses special DSL, named TAlanguage, to describe discrete functions. Below by translation we mean the process of obtaining a propositional encoding for a TA-program.\nThe translation of a TA-program has two main stages. At the first stage, TRANSALG parses a source code of a TA-program and constructs a syntax tree using standard techniques of compilation theory [1]. At the second stage, the system employs the concept of symbolic execution [8] to construct a propositional encoding for a TA-program considered. TRANSALG can output an encoding obtained in any of standard forms (CNF, DNF, ANF).\nThe TA-language has block structure. A block (composite operator) is a list of instructions. Every block is delimited by curly braces ’{’ and ’}’. Within a block instructions are separated by ’;’ symbol. Each block has its own (local) scope. In the TA-language nested blocks are allowed with no limit on depth. During the analysis of a program TRANSALG constructs a scope tree with global scope at its root. Every identifier in a TA-program belongs to some scope. Variables and arrays declared outside of any block and also all functions belong to a global scope and therefore can be accessed in any point of a program.\nA TA-program is essentially a list of functions. The main function is an entry point so it must exist in any program. The TA-language supports base constructions used in procedural languages (variable declarations, assignment operators, conditional operators, loops, function calls, function returns etc.), various integer operations and bit operations including bit shifting and comparison.\nMain data type in the TA-language is the bit type. TRANSALG uses this type to establish links between variables used in a TA-program and Boolean variables included into corresponding propositional encoding. It is important to distinguish between these two sets of variables. Below we will refer to variables that appear in a TA-program as program variables. All variables included in a propositional encoding are called encoding variables. Upon the translation of an arbitrary instruction that contains a program variable of the bit type, TRANSALG links this program variable with a corresponding encoding variable. TRANSALG establishes such links only for program variables of the bit type. Variables of other types, in particular of the int type and the void type are used only as service variables, for example as loop counters or to specify functions without return value.\nDeclarations of global bit variables can have in or out attribute. Attribute in marks variables that contain input data for an algorithm. Attribute out marks variables that contain an output of an algorithm. Local bit variables cannot be declared with these attributes."
    }, {
      "heading" : "3 Translation of TA-programs to SAT",
      "text" : "Let us consider a sequence of computations defined by an arbitrary TA-program as a sequence of data modifications in a memory of an abstract computing machine in moments {0, 1, . . . , e}. At every moment i ∈ {0, 1, . . . , e} TRANSALG associates a\nset X i of encoding variables with program variables of the bit type. Denote X =⋃e i=0 X\ni. Suppose that X in is formed by encoding variables that correspond to input data, and Xout contains encoding variables corresponding to the output of a discrete function considered. It is easy to see that X in ⊆ X0 and Xout ⊆ X .\nTRANSALG uses the translation concept that makes it possible to reduce the redundancy of propositional encoding. We will explain this concept on the following example.\nExample 1. Consider an encoding of a linear feedback shift register (LFSR) [11] with TRANSALG. In fig. 1 we show the TA-program for the LFSR with feedback polynomial P (z) = z19 + z18 + z17 + z14 + 1 over GF (2) (here z is a formal variable).\nNote that during the translation of transition from step i to step i + 1 it is not necessary to create new encoding variables for every cell of the register. If we copy data from one register cell to another, then we can use the same encoding variable to encode corresponding data value at steps i and i + 1. Therefore, at each step TRANSALG creates only one new encoding variable and links it with program variable reg[0]. All the other program variables get linked with encoding variables created at previous steps. In accordance with the above, a set of encoding variables corresponding to initial values of the register is X in = X0 = {x1, x2, . . . , x19}. After each shift we encode values of register cells with sets\nX1 = {x2, x3, . . . , x20}, X 2 = {x3, x4, . . . , x21}, ..., X e = {xe+1, xe+2, . . . , xe+19}.\nIt is clear that Xout = {x1, . . . , xe}. Thus the set of encoding variables for this program is X = {x1, x2, . . . , xe+19}, and the propositional encoding is the following set of\nBoolean formulae x20 ≡ x1 ⊕ x2 ⊕ x3 ⊕ x6 . . .\nxe+19 ≡ xe ⊕ xe+1 ⊕ xe+2 ⊕ xe+5.\nAn important feature of the TRANSALG system is full support of conditional operators. Consider an arbitrary expressionΦ(z1, . . . , zk) of the TA language. Here z1, . . . , zk are program variables of the bit type. Suppose that they are linked with encoding variables x1, . . . , xk. Also suppose that Boolean formula φ(x1, . . . , xk) is obtained as a result of translation of an expression Φ(z1, . . . , zk). Below we say that an expression Φ(z1, . . . , zk) is associated with a Boolean formula φ(x1, . . . , xk).\nThe BNF of conditional operator has the following form\n<if_statement> := if (<expression>) <statement> [else <statement>]\nIn this BNF <expression> is a predicate of a conditional operator. Let <expression> be Φ. Suppose that expression Φ is associated with formula φ. Denote by ∆1 and ∆2 some expressions of a TA-program, associated with Boolean formulae δ1 and δ2, respectively. Now suppose that program variable z is the left operand in the assignment operator z = ∆1, performed in the first branch of the conditional operator and also the left operand of the assignment operator z = ∆2, performed in the second (else-) branch of the conditional operator. Also, suppose that at the previous translation step z was linked with encoding variable x. During the translation of such conditional operator TRANSALG creates new encoding variable x′, links it with program variable z and adds the following formula to the propositional encoding:\nx′ ≡ φ · δ1 ∨ ¬φ · δ2. (1)\nIf there is no assignment z = ∆2 in the else-branch, or if there is no else-branch, then formula (1) transforms into x′ ≡ φ · δ1 ∨ ¬φ · x. Likewise if there is no assignment z = ∆1 in the first branch then formula (1) transforms into x′ ≡ φ · x ∨ ¬φ · δ2.\nNote that according to the BNF-definition any operator can be a branch of conditional operator. In particular, we can consider the construction of n nested conditional operators. Without the loss of generality suppose that we have the following operator\nif Φ1 z = ∆1 else if Φ2 z = ∆2 . . . else if Φn z = ∆n else z = ∆n+1\nSuppose that each expression Φj , j = 1, . . . , n is associated with Boolean formula φj . Then during the translation of this operator TRANSALG will create new encoding variable x′ and add the following formula to the propositional encoding\nx′ ≡ φ1 ·δ1∨¬φ1 ·φ2 ·δ2∨. . .∨¬φ1 ·¬φ2 · . . .·φn ·δn∨¬φ1 ·¬φ2 · . . . ·¬φn ·δn+1. (2)\nHere Boolean formulae δj , j = 1, . . . , n+ 1 are associated with expressions ∆j . Note that (2) follows from (1)."
    }, {
      "heading" : "4 Encoding Cryptanalysis Problems with TRANSALG",
      "text" : "In recent years a number of papers about the application of SAT-solvers to solving cryptanalysis problems [5,10,13,16,18,19] were published. We used TRANSALG to make propositional encodings for a number of cryptographic functions.\nIn fig. 2 we show the fragment of the TA-program for the A5/1 generator outputting 128 bits of keystream. Here we suppose that functions shift regA, shift regB and shift regC are implemented in a similar way as shift reg function in fig. 1. To translate Boolean formulae to CNF it is sufficient to use only Tseitin transformations [21]. For the TA-program in fig. 2 this approach gives us the CNF with 41600 clauses over the set of 10816 variables.\nHowever, in some cases the use of specialized Boolean optimization libraries makes it possible to significantly decrease the size of propositional encoding. In particular, the TRANSALG system uses the ESPRESSO1 Boolean minimization library. In ESPRESSO the Boolean formulas are minimized via the manipulation with their truth tables, that is why the complexity of the minimization procedure grows exponentially on the number of variables in the formula. In practice, it means that in order to spend reasonable time on minimization, it is best to minimize only formulas that contain limited number of variables. We use the following approach: if during the translation of the TA-program there arise the formulas over the set with more than 12 variables then such formulas are divided into subformulas using the Tseitin transformations.\n1 http://embedded.eecs.berkeley.edu/pubs/downloads/espresso/index.htm\nWith the help of ESPRESSO the size of the propositional encoding of the A5/1 keystream generator outputting 128 keystream bits was reduced to 39936 clauses over the set of 8768 variables. Note, that to obtain the encoding for the A5/1 generator with different size of keystream one only needs to change the value of len constant in the TA-program in fig. 2 and repeat the translation. A5/1 encodings produced with TRANSALG were used to solve the problem of logical cryptanalysis of A5/1 in distributed computing environments [15,16].\nWe also applied TRANSALG to encode the problem of cryptanalysis of the DES cipher to SAT. DES algorithm uses a lot of bit shifting and permutation operations. According to the translation concept used by TRANSALG, the system does not create new encoding variables during the translation of these operations. Propositional encodings of DES obtained with TRANSALG turned out to be significantly more compact than encodings from [9]. For example, if we consider the DES algorithm that takes 1 block of plaintext (64 bits), the corresponding CNF obtained with TRANSALG has 26400 clauses over the set of 1912 variables. In [9] CNF for the same problem has 61935 clauses over the set of 10336 variables.\nThe source code of the TRANSALG2 system, the examples of TA-programs and the corresponding encodings3 are freely accessibly online. They include SAT encodings for problems of cryptanalysis of A5/1, A5/2, Bivium, Trivium, Geffe, Gifford, E0 and Grain keystream generators, DES algorithm, and also for hash algorithms MD4, MD5, SHA-1 and SHA-2."
    }, {
      "heading" : "5 Related Work",
      "text" : "In recent years SAT community have developed many encoding techniques that can be applied to a wide class of combinatorial problems. A lot of references to key papers in this area can be found in [14].\nThere is a number of systems for automated encoding of Constraint Satisfaction Problem (CSP) to SAT [6,12,17,20]. Some methods and approaches to encoding of pseudoboolean constraints were described in [4].\nIn [18] there was presented the GRAIN OF SALT tool that can be used to make SAT encodings for cryptanalysis of keystream generators. The GRAIN OF SALT tool uses the special declarative language to describe keystream generators. This language was designed specifically to produce compact descriptions of configurations of shift registers. The TRANSALG system, on the contrary, was designed as a general tool, and it can be applied to encoding much wider class of functions than that covered by keystream generators. The ideology of TRANSALG is based on modern results in programming language theory and theory of symbolic execution. The most close analogue of the TRANSALG system is, apparently, the URSA system [7]. In comparison to this tool, the distinctive feature of the TRANSALG system consists in ability to encode conditional operators.\nThe TRANSALG system showed high effectiveness in obtaining propositional encodings of various cryptographic functions. In particular, the SAT encodings of cor-\n2 https://gitlab.com/groups/transalg 3 https://gitlab.com/groups/satencodings\nresponding functions produced by TRANSALG are much more compact than known analogues.\nAcknowledgments. Authors thank Oleg Zaikin and Alexey Ignatiev for constructive feedback and helpful discussions. This work was partially supported by Russian Foundation for Basic Research, grants 14-07-00403a, 15-07-07891a, 14-07-31172mol a and by the President of Russian Federation grant for young scientists SP-3667.2013.5."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "In this paper we present the TRANSALG system, designed to produce<lb>SAT encodings for discrete functions, written as programs in a specific language.<lb>Translation of such programs to SAT is based on propositional encoding methods<lb>for formal computing models and on the concept of symbolic execution. We used<lb>the TRANSALG system to make SAT encodings for a number of cryptographic<lb>functions.",
    "creator" : "LaTeX with hyperref package"
  }
}