{
  "name" : "1311.7662.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "The Power of Asymmetry in Binary Hashing",
    "authors" : [ "Behnam Neyshabur", "Payman Yadollahpour", "Yury Makarychev" ],
    "emails" : [ "btavakoli@ttic.edu", "pyadolla@ttic.edu", "yury@ttic.edu", "rsalakhu@cs.toronto.edu", "nati@ttic.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Encoding high-dimensional objects using short binary hashes can be useful for fast approximate similarity computations and nearest neighbor searches. Calculating the hamming distance between two short binary strings is an extremely cheap computational operation, and the communication cost of sending such hash strings for lookup on a server (e.g. sending hashes of all features or patches in an image taken on a mobile device) is low. Furthermore, it is also possible to quickly look up nearby hash strings in populated hash tables. Indeed, it only takes a fraction of a second to retrieve a shortlist of similar items from a corpus containing billions of data points, which is important in image, video, audio, and document retrieval tasks [11, 9, 10, 13]. Moreover, compact binary codes are remarkably storage efficient, and allow one to store massive datasets in memory. It is therefore desirable to find short binary hashes that correspond well to some target notion of similarity. Pioneering work on Locality Sensitive Hashing used random linear thresholds for obtaining bits of the hash [1]. Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3]. More recent work focuses on learning hash functions so as to optimize agreement with the target similarity measure on specific datasets [14, 8, 9, 6] . It is important to obtain accurate and short hashes—the computational and communication costs scale linearly with the length of the hash, and more importantly, the memory cost of the hash table can scale exponentially with the length.\nIn all the above-mentioned approaches, similarity S(x, x′) between two objects is approximated by the hamming distance between the outputs of the same hash function, i.e. between f(x) and f(x′), for some f ∈ {±1}k. The emphasis here is that the same hash function is applied to both x and x′ (in methods like LSH multiple hashes might be used to boost accuracy, but the comparison is still between outputs of the same function).\nThe only exception we are aware of is where a single mapping of objects to fractional vectors f̃(x) ∈ [−1, 1]k is used, its thresholding f(x) = sign f̃(x) ∈ {±1}k is used in the database, and similarity between x and x′ is approximated using 〈 f(x), f̃(x′) 〉 . This has become known as “asymmetric hashing” [2, 4], but even with such a-\nsymmetry, both mappings are based on the same fractional mapping f̃(·). That is, the asymmetry is in that one side of the comparison gets thresholded while the other is fractional, but not in the actual mapping.\nIn this paper, we propose using two distinct mappings f(x), g(x) ∈ {±1}k and approximating the similarity S(x, x′) by the hamming distance between f(x) and g(x′). We refer to such hashing schemes as “asymmetric”. Our main result is that even if the target similarity function is symmetric and “well behaved” (e.g., even if it is based on\nar X\niv :1\n31 1.\n76 62\nv1 [\ncs .L\nG ]\n2 9\nN ov\nEuclidean distances between objects), using asymmetric binary hashes can be much more powerful, and allow better approximation of the target similarity with shorter code lengths. In particular, we show extreme examples of collections of points in Euclidean space, where the neighborhood similarity S(x, x′) can be realized using an asymmetric binary hash (based on a pair of distinct functions) of lengthO(r) bits, but where a symmetric hash (based on a single function) would require at least Ω(2r) bits. Although actual data is not as extreme, our experimental results on real data sets demonstrate significant benefits from using asymmetric binary hashes.\nAsymmetric hashes can be used in almost all places where symmetric hashes are typically used, usually without any additional storage or computational cost. Consider the typical application of storing hash vectors for all objects in a database, and then calculating similarities to queries by computing the hash of the query and its hamming distance to the stored database hashes. Using an asymmetric hash means using different hash functions for the database and for the query. This neither increases the size of the database representation, nor the computational or communication cost of populating the database or performing a query, as the exact same operations are required. In fact, when hashing the entire database, asymmetric hashes provide even more opportunity for improvement. We argue that using two different hash functions to encode database objects and queries allows for much more flexibility in choosing the database hash. Unlike the query hash, which has to be stored compactly and efficiently evaluated on queries as they appear, if the database is fixed, an arbitrary mapping of database objects to bit strings may be used. We demonstrate that this can indeed increase similarity accuracy while reducing the bit length required."
    }, {
      "heading" : "2 Minimum Code Lengths and the Power of Asymmetry",
      "text" : "Let S : X × X → {±1} be a binary similarity function over a set of objects X , where we can interpret S(x, x′) to mean that x and x′ are “similar” or “dissimilar”, or to indicate whether they are “neighbors”. A symmetric binary coding of X is a mapping f : X → {±1}k, where k is the bit-length of the code. We are interested in constructing codes such that the hamming distance between f(x) and f(x′) corresponds to the similarity S(x, x′). That is, for some threshold θ ∈ R, S(x, x′) ≈ sign(〈f(x), f(x′)〉 − θ). Although discussing the hamming distance, it is more convenient for us to work with the inner product 〈u, v〉, which is equivalent to the hamming distance dh(u, v) since 〈u, v〉 = (k − 2dh(u, v)) for u, v ∈ {±1}k.\nIn this section, we will consider the problem of capturing a given similarity using an arbitrary binary code. That is, we are given the entire similarity mapping S, e.g. as a matrix S ∈ {±1}n×n over a finite domain X = {x1, . . . , xn} of n objects, with Sij = S(xi, xj). We ask for an encoding ui = f(xi) ∈ {±1}k of each object xi ∈ X , and a threshold θ, such that Sij = sign(〈ui, uj〉 − θ), or at least such that equality holds for as many pairs (i, j) as possible. It is important to emphasize that the goal here is purely to approximate the given matrix S using a short binary code—there is no out-of-sample generalization (yet).\nWe now ask: Can allowing an asymmetric coding enable approximating a symmetric similarity matrix S with a shorter code length?\nDenoting U ∈ {±1}n×k for the matrix whose columns contain the codewords ui, the minimal binary code length that allows exactly representing S is then given by the following matrix factorization problem:\nks(S) = min k,U,θ k s.t U ∈ {±1}k×n θ ∈ R Y , U>U − θ1n ∀ij SijYij > 0\n(1)\nwhere 1n is an n× n matrix of ones. We begin demonstrating the power of asymmetry by considering an asymmetric variant of the above problem. That is, even if S is symmetric, we allow associating with each object xi two distinct binary codewords, ui ∈ {±1}k and vi ∈ {±1}k (we can think of this as having two arbitrary mappings ui = f(xi) and vi = g(xi)), such that Sij = sign(〈ui, vj〉 − θ). The minimal asymmetric binary code length is then given by:\nka(S) = min k,U,V,θ k s.t U, V ∈ {±1}k×n θ ∈ R Y , U>V − θ1n ∀ij SijYij > 0\n(2)\nWriting the binary coding problems as matrix factorization problems is useful for understanding the power we can get by asymmetry: even if S is symmetric, and even if we seek a symmetric Y , insisting on writing Y as a square of a binary matrix might be a tough constraint. This is captured in the following Theorem, which establishes that there could be an exponential gap between the minimal asymmetry binary code length and the minimal symmetric code length, even if the matrix S is symmetric and very well behaved: Theorem 1. For any r, there exists a set of n = 2r points in Euclidean space, with similarity matrix Sij ={ 1 if ‖xi − xj‖ ≤ 1 −1 if ‖xi − xj‖ > 1 , such that ka(S) ≤ 2r but ks(S) ≥ 2r/2\nProof. Let I1 = {1, . . . , n/2} and I2 = {n/2 + 1, . . . , n}. Consider the matrix G defined by Gii = 1/2, Gij = −1/(2n) if i, j ∈ I1 or i, j ∈ I2, and Gij = 1/(2n) otherwise. Matrix G is diagonally dominant. By the Gershgorin circle theorem, G is positive definite. Therefore, there exist vectors x1, . . . , xn such that 〈xi, xj〉 = Gij (for every i and j). Define\nSij = { 1 if ‖xi − xj‖ ≤ 1 −1 if ‖xi − xj‖ > 1 .\nNote that if i = j then Sij = 1; if i 6= j and (i, j) ∈ I1×I1∪I2×I2 then ‖xi − xj‖2 = Gii+Gjj−2Gij = 1+1/n > 1 and therefore Sij = −1. Finally, if i 6= j and (i, j) ∈ I1 × I2 ∪ I2 × I1 then ‖xi − xj‖2 = Gii + Gjj − 2Gij = 1 + 1/n < 1 and therefore Sij = 1. We show that ka(S) ≤ 2r. Let B be an r × n matrix whose column vectors are the vertices of the cube {±1}r (in any order); let C be an r × n matrix defined by Cij = 1 if j ∈ I1 and Cij = −1\nif j ∈ I2. Let U = [ B C ] and V = [ B −C ] . For Y = U>V − θ1n where threshold θ = −1 , we have that Yij ≥ 1 if Sij = 1 and Yij ≤ −1 if Sij = −1. Therefore, ka(S) ≤ 2r. Now we show that ks = ks(S) ≥ n/2. Consider Y , U and θ as in (1). Let Y ′ = (U>U). Note that Y ′ij ∈ [−ks, ks] and thus θ ∈ [−ks + 1, ks − 1]. Let q = [1, . . . , 1,−1, . . . ,−1]> (n/2 ones followed by n/2 minus ones). We have,\n0 ≤ q>Y ′q = n∑ i=1 Y ′ii + ∑ i,j:Sij=−1 Y ′ij − ∑ i,j:Sij=1,i6=j Y ′ij\n≤ n∑ i=1 ks + ∑ i,j:Sij=−1 (θ − 1)− ∑ i,j:Sij=1,i6=j (θ + 1)\n= nks + (0.5n 2 − n)(θ − 1)− 0.5n2(θ + 1)\n= nks − n2 − n(θ − 1) ≤ 2nks − n2.\nWe conclude that ks ≥ n/2.\nThe construction of Theorem 1 shows that there exists data sets for which an asymmetric binary hash might be much shorter then a symmetric hash. This is an important observation as it demonstrates that asymmetric hashes could be much more powerful, and should prompt us to consider them instead of symmetric hashes. The precise construction of Theorem 1 is of course rather extreme (in fact, the most extreme construction possible) and we would not expect actual data sets to have this exact structure, but we will show later significant gaps also on real data sets."
    }, {
      "heading" : "3 Approximate Binary Codes",
      "text" : "As we turn to real data sets, we also need to depart from seeking a binary coding that exactly captures the similarity matrix. Rather, we are usually satisfied with merely approximating S, and for any fixed code length k seek the\n(symmetric or asymmetric) k-bit code that “best captures” the similarity matrix S. This is captured by the following optimization problem:\nmin U,V,θ\nL(Y ;S) , β ∑\ni,j:Sij=1\n`(Yij) + (1− β) ∑\ni,j:Sij=−1 `(−Yij) s.t. U, V ∈ {±1}k×n θ ∈ R\nY , U>V − θ1n\n(3)\nwhere `(z) = 1z≤0 is the zero-one-error and β is a parameter that allows us to weight positive and negative errors differently. Such weighting can compensate for Sij being imbalanced (typically many more pairs of points are nonsimilar rather then similar), and allows us to obtain different balances between precision and recall.\nThe optimization problem (3) is a discrete, discontinuous and highly non-convex problem. In our experiments, we replace the zero-one loss `(·) with a continuous loss and perform local search by greedily updating single bits so as to improve this objective. Although the resulting objective (let alone the discrete optimization problem) is still not convex even if `(z) is convex, we found it beneficial to use a loss function that is not flat on z < 0, so as to encourage moving towards the correct sign. In our experiments, we used the square root of the logistic loss, `(z) = log1/2(1 + e−z).\nBefore moving on to out-of-sample generalizations, we briefly report on the number of bits needed empirically to find good approximations of actual similarity matrices with symmetric and asymmetric codes. We experimented with several data sets, attempting to fit them with both symmetric and asymmetric codes, and then calculating average precision by varying the threshold θ (while keeping U and V fixed). Results for two similarity matrices, one based on Euclidean distances between points uniformly distributed in a hypoercube, and the other based on semantic similarity between images, are shown in Figure 1."
    }, {
      "heading" : "4 Out of Sample Generalization: Learning a Mapping",
      "text" : "So far we focused on learning binary codes over a fixed set of objects by associating an arbitrary code word with each object and completely ignoring the input representation of the objects xi. We discussed only how well binary hashing can approximate the similarity, but did not consider generalizing to additional new objects. However, in most applications, we would like to be able to have such an out-of-sample generalization. That is, we would like to learn a mapping f : X → {±1}k over an infinite domain X using only a finite training set of objects, and then apply the mapping to obtain binary codes f(x) for future objects to be encountered, such that S(x, x′) ≈ sign(〈f(x), f(x′)〉−θ). Thus, the mapping f : X → {±1}k is usually limited to some constrained parametric class, both so we could represent and evaluate it efficiently on new objects, and to ensure good generalization. For example, when X = Rd, we can consider linear threshold mappings fW (x) = sign(Wx), where W ∈ Rk×d and sign(·) operates elementwise, as in Minimal Loss Hashing [8]. Or, we could also consider more complex classes, such as multilayer networks [11, 9].\nWe already saw that asymmetric binary codes can allow for better approximations using shorter codes, so it is natural to seek asymmetric codes here as well. That is, instead of learning a single parametric map f(x) we can learn a\npair of maps f : X → {±1}k and g : X → {±1}k, both constrained to some parametric class, and a threshold θ, such that S(x, x′) ≈ sign(〈f(x), g(x′)〉− θ). This has the potential of allowing for better approximating the similarity, and thus better overall accuracy with shorter codes (despite possibly slightly harder generalization due to the increase in the number of parameters).\nIn fact, in a typical application where a database of objects is hashed for similarity search over future queries, asymmetry allows us to go even further. Consider the following setup: We are given n objects x1, . . . , xn ∈ X from some infinite domain X and the similarities S(xi, xj) between these objects. Our goal is to hash these objects using short binary codes which would allow us to quickly compute approximate similarities between these objects (the “database”) and future objects x (the “query”). That is, we would like to generate and store compact binary codes for objects in a database. Then, given a new query object, we would like to efficiently compute a compact binary code for a given query and retrieve similar items in the database very fast by finding binary codes in the database that are within small hamming distance from the query binary code. Recall that it is important to ensure that the bit length of the hashes are small, as short codes allow for very fast hamming distance calculations and low communication costs if the codes need to be sent remotely. More importantly, if we would like to store the database in a hash table allowing immediate lookup, the size of the hash table is exponential in the code length.\nThe symmetric binary hashing approach (e.g. [8]), would be to find a single parametric mapping f : X → {±1}k such that S(x, xi) ≈ sign(〈f(x), f(xi)〉 − θ) for future queries x and database objects xi, calculate f(xi) for all database objects xi, and store these hashes (perhaps in a hash table allowing for fast retrieval of codes within a short hamming distance). The asymmetric approach described above would be to find two parametric mappings f : X → {±1}k and g : X → {±1}k such that S(x, xi) ≈ sign(〈f(x), g(xi)〉 − θ), and then calculate and store g(xi).\nBut if the database is fixed, we can go further. There is actually no need for g(·) to be in a constrained parametric class, as we do not need to generalize g(·) to future objects, nor do we have to efficiently calculate it on-the-fly nor communicate g(x) to the database. Hence, we can consider allowing the database hash function g(·) to be an arbitrary mapping. That is, we aim to find a simple parametric mapping f : X → {±1}k and n arbitrary codewords v1, . . . , vn ∈ {±1}k for each x1, . . . , xn in the database, such that S(x, xi) ≈ sign(〈f(x), vi〉−θ) for future queries x and for the objects xi, . . . , xn in the database. This form of asymmetry can allow us for greater approximation power, and thus better accuracy with shorter codes, at no additional computational or storage cost.\nIn Section 6 we evaluate empirically both of the above asymmetric strategies and demonstrate their benefits. But before doing so, in the next Section, we discuss a local-search approach for finding the mappings f, g, or the mapping f and the codes v1, . . . , vn."
    }, {
      "heading" : "5 Optimization",
      "text" : "We focus on x ∈ X ⊂ Rd and linear threshold hash maps of the form f(x) = sign(Wx), where W ∈ Rk×d. Given training points x1, . . . , xn, we consider the two models discussed above: LIN:LIN We learn two linear threshold functions f(x) = sign(Wqx) and g(x) = sign(Wdx). I.e. we need to find the parameters Wq,Wd ∈ Rk×d. LIN:V We learn a single linear threshold function f(x) = sign(Wqx) and n codewords v1, . . . , vn ∈ Rk. I.e. we need to find Wq ∈ Rk×d, as well as V ∈ Rk×n (where vi are the columns of V ). In either case we denote ui = f(xi), and in LIN:LIN also vi = g(xi), and learn by attempting to minimizing the objective in (3), where `(·) is again a continuous loss function such as the square root of the logistic. That is, we learn by optimizing the problem (3) with the additional constraint U = sign(WqX), and possibly also V = sign(WdX) (for LIN:LIN), where X = [x1 . . . xn] ∈ Rd×n.\nWe optimize these problems by alternatively updating rows of Wq and either rows of Wd (for LIN:LIN ) or of V (for LIN:V ). To understand these updates, let us first return to (3) (with unconstrained U, V ), and consider updating a row u(t) ∈ Rn of U . Denote\nY (t) = U>V − θ1n − u(t) > v(t),\nthe prediction matrix with component t subtracted away. It is easy to verify that we can write:\nL(U>V − θ1n;S) = C − u(t)Mv(t) >\n(4)\nwhere C = 12 (L(Y (t) + 1n;S) + L(Y (t) − 1n;S)) does not depend on u(t) and v(t), and M ∈ Rn×n also does not depend on u(t), v(t) and is given by:\nMij = βij 2\n( `(Sij(Y (t) ij − 1))− `(Sij(Y (t) ij + 1)) ) ,\nwith βij = β or βij = (1 − β) depending on Sij . This implies that we can optimize over the entire row u(t) concurrently by maximizing u(t)Mv(t) >\n, and so the optimum (conditioned on θ, V and all other rows of U ) is given by\nu(t) = sign(Mv(t)). (5)\nSymmetrically, we can optimize over the row v(t) conditioned on θ, U and the rest of V , or in the case of LIN:V , conditioned on θ, Wq and the rest of V .\nSimilarly, optimizing over a row w(t) of Wq amount to optimizing:\narg max w(t)∈Rd\nsign(w(t)X)Mv(t) >\n= arg max w(t)∈Rd ∑ i 〈 Mi, v (t) 〉 sign( 〈 w(t), xi 〉 ). (6)\nThis is a weighted zero-one-loss binary classification problem, with targets sign( 〈 Mi, v (t) 〉 ) and weights ∣∣〈Mi, v(t)〉∣∣. We approximate it as a weighted logistic regression problem, and at each update iteration attempt to improve the objective using a small number (e.g. 10) epochs of stochastic gradient descent on the logistic loss. For LIN:LIN , we also symmetrically update rows of Wd.\nWhen optimizing the model for some bit-length k, we initialize to the optimal k − 1-length model. We initialize the new bit either randomly, or by thresholding the rank-one projection of M (for unconstrained U, V ) or the rank-one projection after projecting the columns of M (for LIN:V ) or both rows and columns of M (for LIN:LIN ) to the column space of X . We take the initialization (random, or rank-one based) that yields a lower objective value."
    }, {
      "heading" : "6 Empirical Evaluation",
      "text" : "In order to empirically evaluate the benefits of asymmetry in hashing, we replicate the experiments of [8], which were in turn based on [5], on six datasets using learned (symmetric) linear threshold codes. These datasets include: LabelMe and Peekaboom are collections of images, represented as 512D GIST features [13], Photo-tourism is a database of image patches, represented as 128 SIFT features [12], MNIST is a collection of 785D greyscale handwritten images, and Nursery contains 8D features. Similar to [8, 5], we also constructed a synthetic 10D Uniform dataset, containing uniformly sampled 4000 points for a 10D hypercube. We used 1000 points for training and 3000 for testing.\nFor each dataset, we find the Euclidean distance at which each point has, on average, 50 neighbours. This defines our ground-truth similarity in terms of neighbours and non-neighbours. So for each dataset, we are given a set of n points x1, . . . , xn, represented as vectors in X = Rd, and the binary similarities S(xi, xj) between the points, with +1 corresponding to xi and xj being neighbors and -1 otherwise. Based on these n training points, [8] present a sophisticated optimization approach for learning a thresholded linear hash function of the form f(x) = sign(Wx), whereW ∈ Rk×d. This hash function is then applied and f(x1), . . . , f(xn) are stored in the database. [8] evaluate the quality of the hash by considering an independent set of test points and comparing S(x, xi) to sign(〈f(x), f(xi)〉− θ) on the test points x and the database objects (i.e. training points) xi.\nIn our experiments, we followed the same protocol, but with the two asymmetric variations LIN:LIN and LIN:V, using the optimization method discussed in Sec. 5. In order to obtain different balances between precision and recall, we should vary β in (3), obtaining different codes for each value of β. However, as in the experiments of [8], we actually learn a code (i.e. mappings f(·) and g(·), or a mapping f(·) and matrix V ) using a fixed value of β = 0.7, and then only vary the threshold θ to obtain the precision-recall curve.\nIn all of our experiments, in addition to Minimal Loss Hashing (MLH), we also compare our approach to three other widely used methods: Kernel-Based Supervised Hashing (KSH) of [6], Binary Reconstructive Embedding (BRE)\nof [5], and Locality-Sensitive Hashing (LSH) of [1]. 1\nIn our first set of experiments, we test performance of the asymmetric hash codes as a function of the bit length. Figure 2 displays Average Precision (AP) of data points retrieved using Hamming distance as a function of code length. These results are similar to ones reported by [8], where MLH yields higher precision compared to BRE and LSH. Observe that for all six datasets both variants of our method, asymmetric LIN:LIN and asymmetric LIN:V , consistently outperform all other methods for different binary code length. The gap is particularly large for short\n1We used the BRE, KSH and MLH implementations available from the original authors. For each method, we followed the instructions provided by the authors. More specifically, we set the number of points for each hash function in BRE to 50 and the number of anchors in KSH to 300 (the default values). For MLH, we learn the threshold and shrinkage parameters by cross-validation and other parameters are initialized to the suggested values in the package.\n16 bits 64 bits 16 bits 64bits LabelMe MNIST\ncodes. For example, for the LabelMe dataset, MLH and KSH with 16 bits achieve AP of 0.52 and 0.54 respectively, whereas LIN:V already achieves AP of 0.54 with only 8 bits. Figure 3 shows similar performance gains appear for a number of other datasets. We also note across all datasets LIN:V improves upon LIN:LIN for short-sized codes. These results clearly show that an asymmetric binary hash can be much more compact than a symmetric hash.\nNext, we show, in Figure 4, the full Precision-Recall curves for two datasets, LabelMe and MNIST, and for two specific code lengths: 16 and 64 bits. The performance of LIN:LIN and LIN:V is almost uniformly superior to that of MLH, KSH and BRE methods. We observed similar behavior also for the four other datasets across various different code lengths.\nResults on previous 6 datasets show that asymmetric binary codes can significantly outperform other state-of-theart methods on relatively small scale datasets. We now consider a much larger LabelMe dataset [13], called Semantic 22K LabelMe. It contains 20,019 training images and 2,000 test images, where each image is represented by a 512D GIST descriptor. The dataset also provides a semantic similarity S(x, x′) between two images based on semantic content (object labels overlap in two images). As argued by [8], hash functions learned using semantic labels should be more useful for content-based image retrieval compared to Euclidean distances. Figure 5 shows that LIN:V with 64 bits substantially outperforms MLH and KSH with 64 bits."
    }, {
      "heading" : "7 Summary",
      "text" : "The main point we would like to make is that when considering binary hashes in order to approximate similarity, even if the similarity measure is entirely symmetric and “well behaved”, much power can be gained by considering asymmetric codes. We substantiate this claim by both a theoretical analysis of the possible power of asymmetric codes, and by showing, in a fairly direct experimental replication, that asymmetric codes outperform state-of-the-art\nresults obtained for symmetric codes. The optimization approach we use is very crude. However, even using this crude approach, we could find asymmetric codes that outperformed well-optimized symmetric codes. It should certainly be possible to develop much better, and more well-founded, training and optimization procedures.\nAlthough we demonstrated our results in a specific setting using linear threshold codes, we believe the power of asymmetry is far more widely applicable in binary hashing, and view the experiments here as merely a demonstration of this power. Using asymmetric codes instead of symmetric codes could be much more powerful, and allow for shorter and more accurate codes, and is usually straightforward and does not require any additional computational, communication or significant additional memory resources when using the code. We would therefore encourage the use of such asymmetric codes (with two distinct hash mappings) wherever binary hashing is used to approximate similarity."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This research was partially supported by NSF CAREER award CCF-1150062 and NSF grant IIS-1302662."
    } ],
    "references" : [ {
      "title" : "Locality-sensitive hashing scheme based on p-stable distributions",
      "author" : [ "M. Datar", "N. Immorlica", "P. Indyk", "V.S. Mirrokni" ],
      "venue" : "Proceedings of the twentieth annual symposium on Computational geometry, pages 253–262. ACM",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Asymmetric distance estimation with sketches for similarity search in highdimensional spaces",
      "author" : [ "W. Dong", "M. Charikar" ],
      "venue" : "SIGIR",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Iterative quantization: A procrustean approach to learning binary codes for large-scale image retrieval",
      "author" : [ "Y. Gong", "S. Lazebnik", "A. Gordo", "F. Perronnin" ],
      "venue" : "TPAMI",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Asymmetric distances for binary embeddings",
      "author" : [ "A. Gordo", "F. Perronnin" ],
      "venue" : "CVPR",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Learning to hash with binary reconstructive embeddings",
      "author" : [ "B. Kulis", "T. Darrell" ],
      "venue" : "NIPS",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "R",
      "author" : [ "W. Liu" ],
      "venue" : "Ji J. Wang, Y.-G. Jiang, and S.-F. Chang. Supervised hashing with kernels. CVPR",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Hashing with graphs",
      "author" : [ "W. Liu", "J. Wang", "S. Kumar", "S.-F. Chang" ],
      "venue" : "ICML",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Minimal loss hashing for compact binary codes",
      "author" : [ "M. Norouzi", "D.J. Fleet" ],
      "venue" : "ICML",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Hamming distance metric learning",
      "author" : [ "M. Norouzi", "D.J. Fleet", "R. Salakhutdinov" ],
      "venue" : "NIPS",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Locality-sensitive binary codes from shift-invariant kernels",
      "author" : [ "M. Raginsky", "S. Lazebnik" ],
      "venue" : "NIPS",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Semantic hashing",
      "author" : [ "R. Salakhutdinov", "G. Hinton" ],
      "venue" : "International Journal of Approximate Reasoning",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "S",
      "author" : [ "N. Snavely" ],
      "venue" : "M. Seitz, and R.Szeliski. Photo tourism: Exploring photo collections in 3d. In Proc. SIGGRAPH",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Small codes and large image databases for recognition",
      "author" : [ "A. Torralba", "R. Fergus", "Y. Weiss" ],
      "venue" : "CVPR",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Sequential projection learning for hashing with compact codes",
      "author" : [ "J. Wang", "S. Kumar", "S. Chang" ],
      "venue" : "ICML",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Spectral hashing",
      "author" : [ "Y. Weiss", "A. Torralba", "R. Fergus" ],
      "venue" : "NIPS",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 10,
      "context" : "Indeed, it only takes a fraction of a second to retrieve a shortlist of similar items from a corpus containing billions of data points, which is important in image, video, audio, and document retrieval tasks [11, 9, 10, 13].",
      "startOffset" : 208,
      "endOffset" : 223
    }, {
      "referenceID" : 8,
      "context" : "Indeed, it only takes a fraction of a second to retrieve a shortlist of similar items from a corpus containing billions of data points, which is important in image, video, audio, and document retrieval tasks [11, 9, 10, 13].",
      "startOffset" : 208,
      "endOffset" : 223
    }, {
      "referenceID" : 9,
      "context" : "Indeed, it only takes a fraction of a second to retrieve a shortlist of similar items from a corpus containing billions of data points, which is important in image, video, audio, and document retrieval tasks [11, 9, 10, 13].",
      "startOffset" : 208,
      "endOffset" : 223
    }, {
      "referenceID" : 12,
      "context" : "Indeed, it only takes a fraction of a second to retrieve a shortlist of similar items from a corpus containing billions of data points, which is important in image, video, audio, and document retrieval tasks [11, 9, 10, 13].",
      "startOffset" : 208,
      "endOffset" : 223
    }, {
      "referenceID" : 0,
      "context" : "Pioneering work on Locality Sensitive Hashing used random linear thresholds for obtaining bits of the hash [1].",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 14,
      "context" : "Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3].",
      "startOffset" : 85,
      "endOffset" : 102
    }, {
      "referenceID" : 10,
      "context" : "Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3].",
      "startOffset" : 85,
      "endOffset" : 102
    }, {
      "referenceID" : 4,
      "context" : "Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3].",
      "startOffset" : 85,
      "endOffset" : 102
    }, {
      "referenceID" : 6,
      "context" : "Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3].",
      "startOffset" : 85,
      "endOffset" : 102
    }, {
      "referenceID" : 2,
      "context" : "Later work suggested learning hash functions attuned to the distribution of the data [15, 11, 5, 7, 3].",
      "startOffset" : 85,
      "endOffset" : 102
    }, {
      "referenceID" : 13,
      "context" : "More recent work focuses on learning hash functions so as to optimize agreement with the target similarity measure on specific datasets [14, 8, 9, 6] .",
      "startOffset" : 136,
      "endOffset" : 149
    }, {
      "referenceID" : 7,
      "context" : "More recent work focuses on learning hash functions so as to optimize agreement with the target similarity measure on specific datasets [14, 8, 9, 6] .",
      "startOffset" : 136,
      "endOffset" : 149
    }, {
      "referenceID" : 8,
      "context" : "More recent work focuses on learning hash functions so as to optimize agreement with the target similarity measure on specific datasets [14, 8, 9, 6] .",
      "startOffset" : 136,
      "endOffset" : 149
    }, {
      "referenceID" : 5,
      "context" : "More recent work focuses on learning hash functions so as to optimize agreement with the target similarity measure on specific datasets [14, 8, 9, 6] .",
      "startOffset" : 136,
      "endOffset" : 149
    }, {
      "referenceID" : 1,
      "context" : "This has become known as “asymmetric hashing” [2, 4], but even with such asymmetry, both mappings are based on the same fractional mapping f̃(·).",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 3,
      "context" : "This has become known as “asymmetric hashing” [2, 4], but even with such asymmetry, both mappings are based on the same fractional mapping f̃(·).",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 7,
      "context" : "For example, when X = R, we can consider linear threshold mappings fW (x) = sign(Wx), where W ∈ Rk×d and sign(·) operates elementwise, as in Minimal Loss Hashing [8].",
      "startOffset" : 162,
      "endOffset" : 165
    }, {
      "referenceID" : 10,
      "context" : "Or, we could also consider more complex classes, such as multilayer networks [11, 9].",
      "startOffset" : 77,
      "endOffset" : 84
    }, {
      "referenceID" : 8,
      "context" : "Or, we could also consider more complex classes, such as multilayer networks [11, 9].",
      "startOffset" : 77,
      "endOffset" : 84
    }, {
      "referenceID" : 7,
      "context" : "[8]), would be to find a single parametric mapping f : X → {±1} such that S(x, xi) ≈ sign(〈f(x), f(xi)〉 − θ) for future queries x and database objects xi, calculate f(xi) for all database objects xi, and store these hashes (perhaps in a hash table allowing for fast retrieval of codes within a short hamming distance).",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "In order to empirically evaluate the benefits of asymmetry in hashing, we replicate the experiments of [8], which were in turn based on [5], on six datasets using learned (symmetric) linear threshold codes.",
      "startOffset" : 103,
      "endOffset" : 106
    }, {
      "referenceID" : 4,
      "context" : "In order to empirically evaluate the benefits of asymmetry in hashing, we replicate the experiments of [8], which were in turn based on [5], on six datasets using learned (symmetric) linear threshold codes.",
      "startOffset" : 136,
      "endOffset" : 139
    }, {
      "referenceID" : 12,
      "context" : "These datasets include: LabelMe and Peekaboom are collections of images, represented as 512D GIST features [13], Photo-tourism is a database of image patches, represented as 128 SIFT features [12], MNIST is a collection of 785D greyscale handwritten images, and Nursery contains 8D features.",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 11,
      "context" : "These datasets include: LabelMe and Peekaboom are collections of images, represented as 512D GIST features [13], Photo-tourism is a database of image patches, represented as 128 SIFT features [12], MNIST is a collection of 785D greyscale handwritten images, and Nursery contains 8D features.",
      "startOffset" : 192,
      "endOffset" : 196
    }, {
      "referenceID" : 7,
      "context" : "Similar to [8, 5], we also constructed a synthetic 10D Uniform dataset, containing uniformly sampled 4000 points for a 10D hypercube.",
      "startOffset" : 11,
      "endOffset" : 17
    }, {
      "referenceID" : 4,
      "context" : "Similar to [8, 5], we also constructed a synthetic 10D Uniform dataset, containing uniformly sampled 4000 points for a 10D hypercube.",
      "startOffset" : 11,
      "endOffset" : 17
    }, {
      "referenceID" : 7,
      "context" : "Based on these n training points, [8] present a sophisticated optimization approach for learning a thresholded linear hash function of the form f(x) = sign(Wx), whereW ∈ Rk×d.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 7,
      "context" : "[8] evaluate the quality of the hash by considering an independent set of test points and comparing S(x, xi) to sign(〈f(x), f(xi)〉− θ) on the test points x and the database objects (i.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "However, as in the experiments of [8], we actually learn a code (i.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 5,
      "context" : "In all of our experiments, in addition to Minimal Loss Hashing (MLH), we also compare our approach to three other widely used methods: Kernel-Based Supervised Hashing (KSH) of [6], Binary Reconstructive Embedding (BRE)",
      "startOffset" : 176,
      "endOffset" : 179
    }, {
      "referenceID" : 4,
      "context" : "of [5], and Locality-Sensitive Hashing (LSH) of [1].",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 0,
      "context" : "of [5], and Locality-Sensitive Hashing (LSH) of [1].",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 7,
      "context" : "These results are similar to ones reported by [8], where MLH yields higher precision compared to BRE and LSH.",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 12,
      "context" : "We now consider a much larger LabelMe dataset [13], called Semantic 22K LabelMe.",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 7,
      "context" : "As argued by [8], hash functions learned using semantic labels should be more useful for content-based image retrieval compared to Euclidean distances.",
      "startOffset" : 13,
      "endOffset" : 16
    } ],
    "year" : 2013,
    "abstractText" : "When approximating binary similarity using the hamming distance between short binary hashes, we show that even if the similarity is symmetric, we can have shorter and more accurate hashes by using two distinct code maps. I.e. by approximating the similarity between x and x′ as the hamming distance between f(x) and g(x′), for two distinct binary codes f, g, rather than as the hamming distance between f(x) and f(x′).",
    "creator" : "LaTeX with hyperref package"
  }
}