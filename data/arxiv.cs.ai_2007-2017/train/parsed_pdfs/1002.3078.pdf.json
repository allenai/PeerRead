{
  "name" : "1002.3078.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Using ATL to define advanced and flexible constraint model transformations",
    "authors" : [ "Raphaël Chenouard", "Laurent Granvilliers", "Ricardo Soto" ],
    "emails" : [ "raphael.chenouard@univ-nantes.fr", "laurent.granvilliers@univ-nantes.fr", "ricardo.soto@univ-nantes.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n00 2.\n30 78\nv1 [\ncs .A\nI] 1\n6 Fe"
    }, {
      "heading" : "1 Introduction",
      "text" : "Constraint programming (CP) systems must combine a modeling language and a solving engine. The modeling language is used to represent problems with variables, constraints, or statements. The solving engine computes assignments of variables satisfying the constraints by exploring and pruning the space of potential solutions. This paper considers the constraint modeling process as constraint model transformations between arbitrary modeling or solver languages. It follows several important consequences on the architecture of systems and user practices.\nConstraint programming languages are rich, combining common constraint domains, e.g. integer constraints or linear real constraints, with global constraints like alldifferent, and even statements like if-then-else or forall. Moreover the spectrum of syntaxes is large, ranging from computer programming languages like Java or Prolog to high-level languages intended to be more humancomprehensible. This may be contrasted with the existence of a standard language in the field of mathematical programming, which improves model sharing, writing and understanding. The quest of a standard CP language is a recent thread, dating back to the talk of Puget [15]. Another important concern is to employ the best solving technology for a given model. As a consequence, a new kind of architecture emerged. The key idea is to map models written with a high-level CP language to many solvers. For instance within the G12 project,\nMiniZinc [13] is intended to be a standard modeling language, and Cadmium [3] is able to map MiniZinc models to a set of solvers. Essence [5] is another CP platform offering an high level modeling language refining Essence specifications to Essence’ models using Conjure [6]. Then hand-written translators can generate models for several different solvers. The role of a mapping tool is to bridge modeling and solver languages and to optimize models for improving the solving process. Cadmium is based on Constraint Handling Rules [8] and is the the closest CP platform from our model-driven approach.\nIn our approach, we suppose that any CP language can be chosen at the modeling phase. In fact, finding a standard language is hard and existing languages have their own features. It then becomes necessary to define mappings between any (pure modeling or solver) languages. This is just the first goal of the new architecture for constraint model transformations defined in the sequel. It follows many advantages:\n– Any user may choose its favourite modeling language and the known best solving technology for a given problem provided that the transformation between languages is implemented. – It may be easy to create a collection of benchmarks for a given language from different source languages. This feature may speed up prototyping of one solver, avoiding hand rewriting of problems into the solver language. – A given problem may be handled using different solving technologies. Users may not have to play with solver languages.\nTo this end, we define a generic and flexible pivot model (i.e. an intermediate model) to which any language is mapped. Considering a new language in this framework only requires a parser and a generally simple transformation to the pivot model.\nThe second goal is to define refactoring operations and optimizations of constraint models using declarative rules. Implementing them over pivot models guarantees the independence from external languages. In other words every operation is implemented once, by means of a so-called concept-oriented rule. In our model engineering approach the elements of models are specified within metamodels, which can be seen as a hierarchy of concepts or types. The rules are able to filter models according to these types, which may be more powerful than syntax-oriented rules.\nThe third goal is to apply the best transformations for given solving technologies. For instance, a matrix with a few non null elements could be transformed into a sparse matrix when using a linear algebra package. The selection of transformation steps is implemented as a sequential procedure, applying transformations until at least pivot models fit the structure requirements of the target language.\nThis architecture has been fully implemented using a model-driven engineering (MDE) approach [14]. MDE tools enable us to separate the grammar concerns from modeling concepts using dedicated tools and languages like TCS [11] and ATL [12, 10]. The main advantage is that we can reason about concepts and\nM2\ntheir relations through a metamodel. Transformations are specified by defining matchings between concepts at the metamodel level of abstraction. Thus, grammar concerns are relegated into the foreground, while concepts processing becomes the major task.\nWith respect to previous works, e.g. [4], the new architecture gives more freedom in constraint modeling. s-COMMA is not always the source modeling language and refactoring steps can be chosen. Thus, users can play with any modeling language, until it is mapped to our platform. Dealing with a solver does not require to manipulate its language. Moreover, handling a new language or a new transformation in the system requires a few work. The main limitation of our approach is that only the modeling fragments of languages can be processed i.e., the declarative part. It is not possible to partially execute a computer program that builds the constraint store.\nThis paper is organized as follows. Section 2 presents an overview of our general transformation framework. Next section introduces the metamodels of two CP languages illustrated on a well-known problem. The pivot metamodel and the transformation rules are introduced in Section 4. Section 5 presents the whole model-driven process including the possibility of selecting relevant mappings. The related work and a conclusion follow."
    }, {
      "heading" : "2 The Model-Driven Transformation Framework",
      "text" : "Figure 1 depicts the architecture of our model-driven transformation framework, which is classically divided in two layers M1 and M2 [14]. M1 holds the models representing constraint problems and M2 defines the semantic of M1 through metamodels. Metamodels describe the concepts appearing in models, e.g. constraint, variable, or domain, and the relations among these concepts, e.g. inheritance, composition, or association. In this framework, transformation rules are defined to perform a complete translation in three main steps: translation from source model A to the pivot model, refactoring/optimization on the pivot model, and translation from the pivot model to target model B. Models A and B may\nbe defined through any CP languages. The pivot model may be refined several times in order to adapt it to the desired target model (see Section 4).\nA main feature resulting from a model-driven engineering approach is that transformation rules operate on the metamodel concepts. For instance, unrolling a forall loop is implemented once over the forall concept, which is independent from the many syntaxes of forall in CP languages. In fact, no grammar specification is required for the pivot model. Syntax specifications of CP languages must be defined separately using specific tools achieving text-to-model or model-to-text mappings like TCS [11], which implement both tasks."
    }, {
      "heading" : "3 A Motivating Example",
      "text" : "In this section, we consider two CP languages, and we motivate the needs and the means for implementing transformations between them.\nECLiPSe [17] is chosen as a leading constraint logic programming system. s-COMMA [16] is an object-oriented constraint language developed in our team. Their metamodels are partially depicted in Figure 2 and 3 using UML class diagram notation. The roots of these hierarchies are equivalent, such that the model concept represents the complete constraint problem to be processed.\nIn s-COMMA, a model is composed of a collection of model elements. A model element is either an enumeration, or a class, or a constant. Each class is composed of a set of class features which can be specialized in variables, constant or constraint zones. Variable with a type defined as a class is an object. Constraint zones are used to group constraints and other statements such as conditionals and loops. The concepts of global constraints and optimization objective are not\nshown here, but can be also defined. The concept of expressions are not detailed in this paper since it is based on classical operatored expressions using boolean, set and arithmetic operators.\nIn the ECLiPSe metamodel, we propose to define a model as a collection of predicates holding predicate elements and variables. Predicate elements are variable features or statements. Variables features is either a constant value assignment, a domain definition, an array or a set definition related to a variable. In fact, we consider that variables are implicitly declared through their features.\nConsidering the well-known problem of the social golfers, Figure 4 and 5 show two versions of the same problem using s-COMMA and ECLiPSe languages. This problem considers a group of n = g× s golfers that wish to play golf each week, arranged into g groups of s golfers, the problem is to find a playing schedule for w weeks such that no two golfers play together more than once.\nThe s-COMMA model is divided in a data file and a model file. The data file contains the golfer names encoded as an Enum concept at line 1 and the problem dimensions defined by means of constants (size of groups, number of weeks, and groups per week). The model file represents the generic social golfers problem using the Model concept. The problem structure is captured by the three classes SocialGolfers, Group, and Week, which are conformed to the Class concept. The Group class owns the players attribute corresponding to a set of golfers playing together, each golfer being identified by a name given in the enumeration from the data file. In this class, the constraint zone groupSize (lines 30 to 32) restricts the size of the golfers group. The Week class has an array of Group objects and the constraint zone playOncePerWeek ensures that each golfer takes part of a unique group per week. Finally, the SocialGolfers class has an array of Week objects and the constraint zone differentGroups states that each golfer never plays two times with the same golfer throughout the considered weeks.\nFigure 5 depicts the ECLiPSe model resulting from an automatic transformation of the previous s-COMMA model. The problem is now encoded as a single predicate whose body is a sequence of atoms. The sequence is made of the problem dimensions, the list of constrained variables L, and three statements resulting from the transformation of the three s-COMMA classes. It turns out that parts of both models are similar. This is due to the sharing of concepts in the underlying metamodels, for instance constants, forall statements, or constraints. However, the syntaxes are different and specific processing may be required. For instance, the forall statement of ECLiPSe needs the param keyword to declare parameters defined outside of the current scope, e.g. the number of groups G.\nThe treatment of objects is more subtle since they must not participate to ECLiPSe models. Many mapping strategies may be devised, for instance mapping objects to predicates [16]. Another mapping strategy is used here, which consists in removing the object-based problem structure. Flattening the problem requires visiting the many classes through their inheritance and composition relations. A few problems to be handled are described as follows. Important changes on the attributes may be noticed. For example, the weeks array of Week objects defined at line 9 in Figure 4 is refactored and transformed to the WEEKS GROUPS PLAYERS flat list stated at line 5 in Figure 5. It may be possible to insert new loops in order to traverse arrays of objects and to post the whole set of constraints. For instance, the last block of for loops in the ECLiPSe model (lines 27 to 39) has been built from the playOncePerWeek constraint zone of the s-COMMA model, but there is two additional for loops (lines 21 and 22) since the Week instances are contained in the weeks array. Another issue is related to lists that cannot be accessed in the same way than arrays in s-COMMA. Thus, local variables (Vi) and the well-known nth Prolog built-in function are introduced in the ECLiPSe model."
    }, {
      "heading" : "4 Pivot metamodel and refactoring rules",
      "text" : "The pivot model of a constraint problem is an intermediate model to be transformed by rules. The rules may be chained to implement complex transformations. In the following, the pivot and some structural refactoring and optimization rules are presented."
    }, {
      "heading" : "4.1 Pivot metamodel",
      "text" : "Our pivot model has been designed to support as much as possible the constructs present in CP languages, for instance variables of many types, data structures such as arrays, record, classes, first-order constraints, common global constraints, and control statements. We believe that it is better and simpler to establish a general CP metamodel, while it is more complex to find a standard CP concrete syntax.\nFigure 6 depicts the metamodel associated to pivot models. A pivot model is composed of a collection of elements, divided in three main concepts: types,\nfeatures and the concrete concept of predicate. The inheritance tree of types is the same as in the s-COMMA metamodel (see Figure 2). The inheritance tree for model features is also quite similar, except for the concept of record which is an untyped collection of features."
    }, {
      "heading" : "4.2 Pivot model refactoring",
      "text" : "We define several refactoring steps on pivot models in order to reduce the possible gap between source and target model. These steps are implemented in several model transformations, most of them being independent from the others. The idea is to refine and optimize models in order to fit the target languages supported concepts.\nModel transformations are implemented in the declarative transformation rule language ATL [12]. This rule language is based on a typed description of models to be processed, namely their metamodel. In this way, rules are able to clearly state how concepts from source metamodels are mapped to concepts from the target ones. For the sake of simplicity, only a few of the more representative rules of transformations are shown. ATL helpers are not detailed, but they only consist of OCL navigation.\nComposition flattening This refactoring step replaces object variables by duplicating elements defined in their class definition. Names of duplicated variables are prefixed using their container name in order to avoid naming ambiguities. This refactoring step processes object variables and their occurrences, while other entities are copied without modification. In fact, two ATL transformations are defined to ease each refactoring step. The first one removes classes and object variables by replacing them by the concept of record (see Figure 7).\nIt can be highlighted that there is no ATL rule where the source pattern matches elements being instances of CSPClass. Thus, they are implicitly removed from models (obviously no rule creates class instances). The second transformation removes records to get flattened variables (see Figure 8).\nIn Figure 7, the first rule (lines 1 to 8) is used to copy the root concept of model. Most of other concepts are duplicated with similar rules like the the second one (lines 9 to 22). The helper mustBeDuplicated is defined for each CSPModelFeature and it returns true when: (1) the considered element is an object variable (its type is a class) or (2) it is a feature of a class. Using the last rule, object variables are replaced by records. The helper isObject returns true only if the type of variables is a class. In this rule, features of variable classes are browsed using OCL navigation (collect statement over s.type.features). The rule duplicate is applied on each feature. This rule is lazy and abstract. It is specialized for each CSPModelFeature concrete sub-concepts and it creates as many features as it is called.\nThe second transformation processes records by replacing them by their set of elements. This is easily done by collecting their elements from their container as shown on Figure 8 at lines 7 to 11. The helper getAllElements returns the set of CSPModelFeature within a record or a hierarchy of records.\nHowever, some other complex rules must be defined to process arrays of records, (formerly arrays of object variables). Indeed, contained statements have to be encapsulated in a for loop to take into account the constraints for all objects in the array. This task is performed by the rule RecordArray which create a new for loop over the record statements (lines 25 to 27). A new for loop requires also a new index variables with its domain (lines 28 to 38).\nUsing the concrete syntax of s-COMMA, Figure 9 shows the result of this refactoring step. The name of the variable at line 1 corresponds to the concate-\nnation of all object variable names. The two for loops (lines 2 and 3) were created from the arrays of objects using their name for index variables.\nEnumeration removal During this refactoring step, enumeration variables are replaced by integer variables with a domain defined as an interval from one to the number of elements within the enumeration. Line 1 in Figure 9 shows the result of this transformation on the enumeration called Name in the social golfers model: the variable has an integer domain from 1 to 9 replacing the set of nine values {a, b, c, d, e, f, g, h, i}. In the same way, occurences of CSPEnumLiteral are replaced by their position in the sequence of elements of the enumeration type.\nOther implemented refactoring steps Some other generic refactoring steps have been implemented in ATL to handle some structural needs. They are not detailed since their complexity is similar to the previous examples and to detail all of them is not the scope of this paper.\n– If statements can be replaced by one constraint based on one or two boolean implications. For instance, if a then b else c becomes (a→ b) ∧ (¬a → c). – Loop structures can be unrolled, i.e. the loop is replaced by the whole set of constraints it implicitly contains. Within expressions, the iterator variable used by the loop structure is replaced by an integer corresponding to the current number of loop turns. – Expressions can be simplified if they are constants. Boolean and integer expressions are replaced by their evaluation. Real expressions are not processed, because of real number rounding errors. More subtle simplifactions can be performed on boolean expressions such as a∨¬a that is always true. Only atomic boolean elements are processed by this last step. – Matrices are not allowed in all CP language, thus they can be replaced by one dimension arrays. Their occurrences in expressions must also be adapted: the index of the array is computed as follows: m[i, j] becomes m[j + (i ∗ ncols)], where ncols is the number of columns of the matrix m. – The ECLiPSe language does not allow some sort of expressions. For instance, arrays of int sets cannot be accessed like other arrays with ‘[ ]’. Thus, an\nECLiPSe specific transformation processes expressions and introduces local variables if needed, as shown on Figure 5 with Vi variables and nth predicate calls."
    }, {
      "heading" : "5 Handling CP languages and transformation chains",
      "text" : "In this section, we describe the whole transformation chain from a given CP language to another language."
    }, {
      "heading" : "5.1 Parsing CP languages",
      "text" : "The front-end of our system parses a source CP language file to get a model representation (on which transformation rules act) matching the concepts of the CP language (injection phase). The back-end generates the code in the target CP language (extraction phase) from the model representation. Interfacing CP languages and metamodels is implemented by means of the TCS tool [11]. This tool allows one to smoothly associate grammars and metamodels. It is responsible for generating parsers of CP languages and also code generators.\nFigure 10 depicts an extract of the TCS file for s-COMMA. In a TCS file every concrete concept must have a corresponding template to be matched. For instance, the SCMAClass template implements the grammar pattern for class declarations using at the same time features of this concept defined in the metamodel of s-COMMA. At parsing time on the s-COMMA social golfers example (see Figure 4, the \"class\" token is matched for the week class statement. Then Week is processed as the name attribute (a string in the metamodel) of a new class instance. Then the \"{\" token is recognized and the class features (the array of groups and the constraint) are processed by implicit matchings to their corresponding templates using the features reference. Finally the \"}\" token terminates the pattern description. In the SCMAClass template (lines 4 to 8), several TCS keywords are used. Here is a description of the most important keywords use in Figure 10:\n– context defines a local symbol table. – addToContext adds instances to the current symbol table. – refersTo accesses to the symbol tables according to the given parameter (here\nthe name) to check the existence of an already declared element."
    }, {
      "heading" : "5.2 Model checking rules",
      "text" : "The presented metamodels (see section 2) and the previous subsection show how to get CP language models. However, many irrelevant or erroneous models can be obtained without any additional checking [2]. For instance, variables may be defined with empty domains or expressions may be ill made (e.g. several equalities in an equality constraint).\nSeveral ATL transformations are used to check source models. We transform a source CP model to a model conform to the metamodel Problem defined in the ATL zoo3. A Problem model corresponds to a set of Problem elements. This concept is only composed of three features:\n– severity is an attribute with an enumerated type which possible values are: error, warning and critic. – location is a string used to store le location of the problem in the source file. – description is a string used to defined a relevant message to descibe the problem.\nMultiple ATL rules have been implemented to check models. Here is an extract of the list of properties to check:\n– Some type checking on expressions. Operands must have a consistent type with the operator. For instance, an equality operator may operate on arithmetic expressions. – The consistency of variable domains : they must be based on constant expressions and interval domains must have a lower bound smaller than the upper bound. – No composition or inheritance loops in s-COMMA."
    }, {
      "heading" : "5.3 Chaining model transformations",
      "text" : "After the injection step or before the extraction step, models have to be transformed with respect to our pivot metamodel. All the refactoring steps presented in Section 4.2 are clearly not necessary in a transformation chain. Indeed, it clearly depends on the modeling structures of the source and target CP languages. The idea is to use most of constructs supported by the target language to have a target model close, in terms of constructs, to our source model. For\n3 http://www.eclipse.org/m2m/atl/atlTransformations/#KM32Problem\ninstance, when translating a s-COMMA model to ECLiPSe, we should transform the objects. So, we choose the composition flattening step. We also need the enumeration removal and other refactoring steps such as the use of local variables and nth predicates. Optionally, we may select the expression simplification steps.\nThe whole transformation chain is based on three kind of tasks: (1) injection/extraction steps, (2) transformation steps from/to the pivot model, (3) relevant refactoring steps. Transformation chains are currently performed using Ant scripts4. These scripts are hand-written, but they can be automatically generated using the am3 tool [1] and the concept of megamodel [7] to get a graphical interfaces to manage terminal models, metamodels and complex transformation chains. However, Automating the building of transformation chains is not possible with current tools. It would require to deeply analyze models and transformations to build relevant transformation chains."
    }, {
      "heading" : "6 Experiments",
      "text" : "The benchmarking study was performed on a 2.66Ghz computer with 2GB RAM running Ubuntu. The ATL regular VM is used for all model-to-model transformations, whereas TCS achieve the text-to-model and model-to-text tasks. Five CP problems were used to validate our approach as shown in Table 1. The second column represents the number of lines of the s-COMMA source files. The next columns correspond to the time of atomic steps (in seconds): model injection (Inject), transformations from s-COMMA to Pivot (s-to-P), refactoring composition structures (Comp), refactoring enumeration structures (Enum), transformations from Pivot to ECLiPSe (P-to-E), and target file extraction (Extract). The next column details the total time of complete transformation chains, and the last column corresponds to the number of lines of the generated ECLiPSe files.\nThe transformation chain is efficient for these small problems. The text file injection and extraction are fast. The parsing phase is more expensive than the extraction, since it requires the management of symbol tables. The extraction phase settle for reading the ECLiPSe model. It can also be noticed that model transformations to and from the pivot are quite efficient, more especially the\n4 http://wiki.eclipse.org/index.php/AM3 Ant Tasks\ntransformation to ECLiPSe model. It can be explained by the refactoring phases on the pivot model which simplify and reduce the data to process. We see that the composition flattening step is the more expensive. In particular, the Engine problem exhibits the slowest running time, since it corresponds to the design of an engine with more object compositions.\nTable 2 presents seven different sizes of the N-Queens problem where the loop unrolling step has been applied. This experiment allows us to check the scalability of our approach according to model sizes. It can be analyzed through the ratio given in the last column which aims at quantifying the efficiency of a transformation chain considering the execution time per generated lines.\nAs shown on this table, the ratio first decreases, but after 50-Queens it slowly grows up. In fact, the first four row ratios are impacted by the steps before the loop unrolling process, but for the last three rows they become neglectible comparing to the whole execution time. It may be noticed that for big problems (after 50-Queens) the ratio smoothly increases. We can thus conclude that our approach is applicable even for huge models, although translations times are not the major concerns in CP."
    }, {
      "heading" : "7 Conclusion and Future Work",
      "text" : "In this paper, we propose a new framework for constraint model transformations. This framework is supported by a set of MDE tools that allow an easy design of translators to be used in the whole transformation chain. This chain is composed by three main steps: from the source to the pivot model, refining of the pivot model and from the pivot model to the target. The hard transformation work (refactoring/optimization) is always performed by the pivot which provide reusable and flexible transformations. The transformations from/to pivot become simple, thus facilitating the integration of new language transformations. In this paper, only two languages are presented, but translation processes with Gecode and Realpaver [9] are already implemented.\nIn a near future, we intend to increase the number of CP languages our approach supports. We also want to define more pivot refactoring transformations to optimize and restructure models. Another major outline for future work is to\nimprove the management of complex CP models transformation chains. Models can be qualified to determine their level of structure and to automatically choose the required refactoring steps according to the target language."
    }, {
      "heading" : "Preface",
      "text" : "This textbook is intended for use by students of physics, physical chemistry, and theoretical chemistry. The reader is presumed to have a basic knowledge of atomic and quantum physics at the level provided, for example, by the first few chapters in our book The Physics of Atoms and Quanta. The student of physics will find here material which should be included in the basic education of every physicist. This book should furthermore allow students to acquire an appreciation of the breadth and variety within the field of molecular physics and its future as a fascinating area of research.\nFor the student of chemistry, the concepts introduced in this book will provide a theoretical framework for that entire field of study. With the help of these concepts, it is at least in principle possible to reduce the enormous body of empirical chemical knowledge to a few basic principles: those of quantum mechanics. In addition, modern physical methods whose fundamentals are introduced here are becoming increasingly important in chemistry and now represent indispensable tools for the chemist. As examples, we might mention the structural analysis of complex organic compounds, spectroscopic investigation of very rapid reaction processes or, as a practical application, the remote detection of pollutants in the air.\nApril 1995 Walter Olthoff Program Chair\nECOOP’95"
    }, {
      "heading" : "Organization",
      "text" : "ECOOP’95 is organized by the department of Computer Science, Univeristy of Århus and AITO (association Internationa pour les Technologie Object) in cooperation with ACM/SIGPLAN."
    }, {
      "heading" : "Executive Commitee",
      "text" : "Conference Chair: Ole Lehrmann Madsen (Århus University, DK) Program Chair: Walter Olthoff (DFKI GmbH, Germany) Organizing Chair: Jørgen Lindskov Knudsen (Århus University, DK) Tutorials: Birger Møller-Pedersen (Norwegian Computing Center, Norway) Workshops: Eric Jul (University of Kopenhagen, Denmark) Panels: Boris Magnusson (Lund University, Sweden) Exhibition: Elmer Sandvad (Århus University, DK) Demonstrations: Kurt Nørdmark (Århus University, DK)"
    }, {
      "heading" : "Program Commitee",
      "text" : "Conference Chair: Ole Lehrmann Madsen (Århus University, DK) Program Chair: Walter Olthoff (DFKI GmbH, Germany) Organizing Chair: Jørgen Lindskov Knudsen (Århus University, DK) Tutorials: Birger Møller-Pedersen (Norwegian Computing Center, Norway) Workshops: Eric Jul (University of Kopenhagen, Denmark) Panels: Boris Magnusson (Lund University, Sweden) Exhibition: Elmer Sandvad (Århus University, DK) Demonstrations: Kurt Nørdmark (Århus University, DK)"
    }, {
      "heading" : "Referees",
      "text" : "V. Andreev Bärwolff E. Barrelet H.P. Beck G. Bernardi E. Binder P.C. Bosetti\nBraunschweig F.W. Büsser T. Carli A.B. Clegg G. Cozzika S. Dagoret Del Buono\nP. Dingus H. Duhm J. Ebert S. Eichenberger R.J. Ellison Feltesse W. Flauger\nIII\nA. Fomenko G. Franke J. Garvey M. Gennis L. Goerlich P. Goritchev H. Greif E.M. Hanlon R. Haydar R.C.W. Henderso P. Hill H. Hufnagel A. Jacholkowska Johannsen S. Kasarian I.R. Kenyon C. Kleinwort T. Köhler S.D. Kolya P. Kostka\nU. Krüger J. Kurzhöfer M.P.J. Landon A. Lebedev Ch. Ley F. Linsel H. Lohmand Martin S. Masson K. Meier C.A. Meyer S. Mikocki J.V. Morris B. Naroska Nguyen U. Obrock G.D. Patel Ch. Pichler S. Prell F. Raupach\nV. Riech P. Robmann N. Sahlmann P. Schleper Schöning B. Schwab A. Semenov G. Siegmon J.R. Smith M. Steenbock U. Straumann C. Thiebaux P. Van Esch from Yerevan Ph L.R. West G.-G. Winter T.P. Yiou M. Zimmer\nSponsoring Institutions\nBernauer-Budiman Inc., Reading, Mass. The Hofmann-International Company, San Louis Obispo, Cal. Kramer Industries, Heidelberg, Germany"
    }, {
      "heading" : "Table of Contents",
      "text" : ""
    }, {
      "heading" : "Hamiltonian Mechanics",
      "text" : "Hamiltonian Mechanics unter besonderer Berücksichtigung der höhreren Lehranstalten . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\nIvar Ekeland, Roger Temam, Jeffrey Dean, David Grove, Craig Chambers, Kim B. Bruce, Elisa Bertino\nHamiltonian Mechanics2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 Ivar Ekeland and Roger Temam\nAuthor Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\nSubject Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\nHamiltonian Mechanics unter besonderer"
    }, {
      "heading" : "Berücksichtigung der höhreren Lehranstalten",
      "text" : "Ivar Ekeland1, Roger Temam2 Jeffrey Dean, David Grove, Craig Chambers, Kim B. Bruce, and Elsa Bertino\n1 Princeton University, Princeton NJ 08544, USA, I.Ekeland@princeton.edu,\nWWW home page: http://users/~iekeland/web/welcome.html 2 Université de Paris-Sud, Laboratoire d’Analyse Numérique, Bâtiment 425,\nF-91405 Orsay Cedex, France\nAbstract. The abstract should summarize the contents of the paper using at least 70 and at most 150 words. It will be set in 9-point font size and be inset 1.0 cm from the right and left margins. There will be two blank lines before and after the Abstract. . . ."
    }, {
      "heading" : "1 Fixed-Period Problems: The Sublinear Case",
      "text" : "With this chapter, the preliminaries are over, and we begin the search for periodic solutions to Hamiltonian systems. All this will be done in the convex case; that is, we shall study the boundary-value problem\nẋ = JH ′(t, x)\nx(0) = x(T )\nwith H(t, ·) a convex function of x, going to +∞ when ‖x‖ → ∞."
    }, {
      "heading" : "1.1 Autonomous Systems",
      "text" : "In this section, we will consider the case when the Hamiltonian H(x) is autonomous. For the sake of simplicity, we shall also assume that it is C1.\nWe shall first consider the question of nontriviality, within the general framework of (A∞, B∞)-subquadratic Hamiltonians. In the second subsection, we shall look into the special case when H is (0, b∞)-subquadratic, and we shall try to derive additional information.\nThe General Case: Nontriviality. We assume that H is (A∞, B∞)-subquadratic at infinity, for some constant symmetric matrices A∞ and B∞, with B∞ −A∞ positive definite. Set:\nγ : = smallest eigenvalue of B∞ −A∞ (1) λ : = largest negative eigenvalue of J d\ndt +A∞ . (2)\n2 Theorem 1 tells us that if λ+ γ < 0, the boundary-value problem:\nẋ = JH ′(x) x(0) = x(T )\n(3)\nhas at least one solution x, which is found by minimizing the dual action functional:\nψ(u) =\n∫ T\no\n[ 1\n2\n( Λ−1o u, u ) +N∗(−u) ] dt (4)\non the range of Λ, which is a subspace R(Λ)2L with finite codimension. Here\nN(x) := H(x)− 1\n2 (A∞x, x) (5)\nis a convex function, and\nN(x) ≤ 1\n2 ((B∞ −A∞)x, x) + c ∀x . (6)\nProposition 1. Assume H ′(0) = 0 and H(0) = 0. Set:\nδ := lim inf x→0\n2N(x) ‖x‖ −2 . (7)\nIf γ < −λ < δ, the solution u is non-zero:\nx(t) 6= 0 ∀t . (8)\nProof. Condition (7) means that, for every δ′ > δ, there is some ε > 0 such that\n‖x‖ ≤ ε⇒ N(x) ≤ δ′\n2 ‖x‖\n2 . (9)\nIt is an exercise in convex analysis, into which we shall not go, to show that this implies that there is an η > 0 such that\n3 Since u1 is a smooth function, we will have ‖hu1‖∞ ≤ η for h small enough, and inequality (10) will hold, yielding thereby:\nψ(hu1) ≤ h2\n2\n1 λ ‖u1‖ 2 2 + h2 2 1 δ′ ‖u1‖ 2 . (11)\nIf we choose δ′ close enough to δ, the quantity ( 1\nλ + 1 δ′\n) will be negative, and\nwe end up with ψ(hu1) < 0 for h 6= 0 small . (12)\nOn the other hand, we check directly that ψ(0) = 0. This shows that 0 cannot be a minimizer of ψ, not even a local one. So u 6= 0 and u 6= Λ−1o (0) = 0. ⊓⊔\nCorollary 1. Assume H is C2 and (a∞, b∞)-subquadratic at infinity. Let ξ1, . . . , ξN be the equilibria, that is, the solutions of H\n′(ξ) = 0. Denote by ωk the smallest eigenvalue of H ′′ (ξk), and set:\nω := Min {ω1, . . . , ωk} . (13)\nIf: T\n2π b∞ < −E\n[ − T\n2π a∞\n] < T\n2π ω (14)\nthen minimization of ψ yields a non-constant T -periodic solution x.\nWe recall once more that by the integer part E[α] of α ∈ IR, we mean the a ∈ ZZ such that a < α ≤ a + 1. For instance, if we take a∞ = 0, Corollary 2 tells us that x exists and is non-constant provided that:\nT 2π b∞ < 1 < T 2π (15)\nor\nT ∈\n( 2π\nω , 2π\nb∞\n) . (16)\nProof. The spectrum of Λ is 2πT ZZ + a∞. The largest negative eigenvalue λ is given by 2πT ko + a∞, where\n2π T ko + a∞ < 0 ≤ 2π T (ko + 1) + a∞ . (17)\nHence:\nko = E\n[ − T\n2π a∞\n] . (18)\nThe condition γ < −λ < δ now becomes:\nb∞ − a∞ < − 2π\nT ko − a∞ < ω − a∞ (19)\nwhich is precisely condition (14). ⊓⊔\n4 Lemma 1. Assume that H is C2 on IR2n\\{0} and that H ′′(x) is non-degenerate for any x 6= 0. Then any local minimizer x̃ of ψ has minimal period T .\nProof. We know that x̃, or x̃ + ξ for some constant ξ ∈ IR2n, is a T -periodic solution of the Hamiltonian system:\nẋ = JH ′(x) . (20)\nThere is no loss of generality in taking ξ = 0. So ψ(x) ≥ ψ(x̃) for all x̃ in some neighbourhood of x in W 1,2 ( IR/TZZ; IR2n ) .\nBut this index is precisely the index iT (x̃) of the T -periodic solution x̃ over the interval (0, T ), as defined in Sect. 2.6. So\niT (x̃) = 0 . (21)\nNow if x̃ has a lower period, T/k say, we would have, by Corollary 31:\niT (x̃) = ikT/k(x̃) ≥ kiT/k(x̃) + k − 1 ≥ k − 1 ≥ 1 . (22)\nThis would contradict (21), and thus cannot happen. ⊓⊔\nNotes and Comments. The results in this section are a refined version of [1]; the minimality result of Proposition 14 was the first of its kind.\nTo understand the nontriviality conditions, such as the one in formula (16), one may think of a one-parameter family xT , T ∈ ( 2πω−1, 2πb−1∞ ) of periodic solutions, xT (0) = xT (T ), with xT going away to infinity when T → 2πω −1, which is the period of the linearized system at 0.\nTheorem 1 (Ghoussoub-Preiss). Assume H(t, x) is (0, ε)-subquadratic at infinity for all ε > 0, and T -periodic in t\nH(t, ·) is convex ∀t (23)\nH(·, x) is T−periodic ∀x (24)\nH(t, x) ≥ n (‖x‖) with n(s)s−1 → ∞ as s→ ∞ (25)\n5 ∀ε > 0 , ∃c : H(t, x) ≤ ε\n2 ‖x‖\n2 + c . (26)\nAssume also that H is C2, and H ′′(t, x) is positive definite everywhere. Then there is a sequence xk, k ∈ IN, of kT -periodic solutions of the system\nẋ = JH ′(t, x) (27)\nsuch that, for every k ∈ IN, there is some po ∈ IN with:\np ≥ po ⇒ xpk 6= xk . (28)\n⊓⊔\nExample 1 (External forcing). Consider the system:\nẋ = JH ′(x) + f(t) (29)\nwhere the Hamiltonian H is (0, b∞)-subquadratic, and the forcing term is a distribution on the circle:\nf = d\ndt F + fo with F ∈ L\n2 ( IR/TZZ; IR2n ) , (30)\nwhere fo := T −1 ∫ T o f(t)dt. For instance,\nf(t) = ∑\nk∈IN\nδkξ , (31)\nwhere δk is the Dirac mass at t = k and ξ ∈ IR 2n is a constant, fits the prescription. This means that the system ẋ = JH ′(x) is being excited by a series of identical shocks at interval T .\nDefinition 1. Let A∞(t) and B∞(t) be symmetric operators in IR 2n, depending continuously on t ∈ [0, T ], such that A∞(t) ≤ B∞(t) for all t. A Borelian function H : [0, T ]× IR2n → IR is called (A∞, B∞)-subquadratic at infinity if there exists a function N(t, x) such that:\nH(t, x) = 1\n2 (A∞(t)x, x) +N(t, x) (32)\n∀t , N(t, x) is convex with respect to x (33)\nN(t, x) ≥ n (‖x‖) with n(s)s−1 → +∞ as s→ +∞ (34)\n∃c ∈ IR : H(t, x) ≤ 1\n2 (B∞(t)x, x) + c ∀x . (35)\nIf A∞(t) = a∞I and B∞(t) = b∞I, with a∞ ≤ b∞ ∈ IR, we shall say that H is (a∞, b∞)-subquadratic at infinity. As an example, the function ‖x‖ α , with 1 ≤ α < 2, is (0, ε)-subquadratic at infinity for every ε > 0. Similarly, the Hamiltonian\nH(t, x) = 1\n2 k ‖k‖2 + ‖x‖α (36)\nis (k, k + ε)-subquadratic for every ε > 0. Note that, if k < 0, it is not convex.\n6 Notes and Comments. The first results on subharmonics were obtained by Rabinowitz in [5], who showed the existence of infinitely many subharmonics both in the subquadratic and superquadratic case, with suitable growth conditions on H ′. Again the duality approach enabled Clarke and Ekeland in [2] to treat the same problem in the convex-subquadratic case, with growth conditions on H only.\nRecently, Michalek and Tarantello (see [3] and [4]) have obtained lower bound on the number of subharmonics of period kT , based on symmetry considerations and on pinching estimates, as in Sect. 5.2 of this article."
    }, {
      "heading" : "Hamiltonian Mechanics2",
      "text" : "Ivar Ekeland1 and Roger Temam2\n1 Princeton University, Princeton NJ 08544, USA 2 Université de Paris-Sud, Laboratoire d’Analyse Numérique, Bâtiment 425,\nF-91405 Orsay Cedex, France\nAbstract. The abstract should summarize the contents of the paper using at least 70 and at most 150 words. It will be set in 9-point font size and be inset 1.0 cm from the right and left margins. There will be two blank lines before and after the Abstract. . . ."
    }, {
      "heading" : "1 Fixed-Period Problems: The Sublinear Case",
      "text" : "With this chapter, the preliminaries are over, and we begin the search for periodic solutions to Hamiltonian systems. All this will be done in the convex case; that is, we shall study the boundary-value problem\nẋ = JH ′(t, x)\nx(0) = x(T )\nwith H(t, ·) a convex function of x, going to +∞ when ‖x‖ → ∞."
    }, {
      "heading" : "1.1 Autonomous Systems",
      "text" : "In this section, we will consider the case when the Hamiltonian H(x) is autonomous. For the sake of simplicity, we shall also assume that it is C1.\nWe shall first consider the question of nontriviality, within the general framework of (A∞, B∞)-subquadratic Hamiltonians. In the second subsection, we shall look into the special case when H is (0, b∞)-subquadratic, and we shall try to derive additional information.\nThe General Case: Nontriviality. We assume that H is (A∞, B∞)-subquadratic at infinity, for some constant symmetric matrices A∞ and B∞, with B∞ −A∞ positive definite. Set:\nγ : = smallest eigenvalue of B∞ −A∞ (1) λ : = largest negative eigenvalue of J d\ndt +A∞ . (2)\nTheorem 21 tells us that if λ+ γ < 0, the boundary-value problem:\nẋ = JH ′(x) x(0) = x(T )\n(3)\n8 has at least one solution x, which is found by minimizing the dual action functional:\nψ(u) =\n∫ T\no\n[ 1\n2\n( Λ−1o u, u ) +N∗(−u) ] dt (4)\non the range of Λ, which is a subspace R(Λ)2L with finite codimension. Here\nN(x) := H(x)− 1\n2 (A∞x, x) (5)\nis a convex function, and\nN(x) ≤ 1\n2 ((B∞ −A∞)x, x) + c ∀x . (6)\nProposition 1. Assume H ′(0) = 0 and H(0) = 0. Set:\nδ := lim inf x→0\n2N(x) ‖x‖ −2 . (7)\nIf γ < −λ < δ, the solution u is non-zero:\nx(t) 6= 0 ∀t . (8)\nProof. Condition (7) means that, for every δ′ > δ, there is some ε > 0 such that\n‖x‖ ≤ ε⇒ N(x) ≤ δ′\n2 ‖x‖\n2 . (9)\nIt is an exercise in convex analysis, into which we shall not go, to show that this implies that there is an η > 0 such that\nSince u1 is a smooth function, we will have ‖hu1‖∞ ≤ η for h small enough, and inequality (10) will hold, yielding thereby:\nψ(hu1) ≤ h2\n2\n1 λ ‖u1‖ 2 2 + h2 2 1 δ′ ‖u1‖ 2 . (11)\n9 If we choose δ′ close enough to δ, the quantity ( 1\nλ + 1 δ′\n) will be negative, and\nwe end up with\nψ(hu1) < 0 for h 6= 0 small . (12)\nOn the other hand, we check directly that ψ(0) = 0. This shows that 0 cannot be a minimizer of ψ, not even a local one. So u 6= 0 and u 6= Λ−1o (0) = 0. ⊓⊔\nCorollary 1. Assume H is C2 and (a∞, b∞)-subquadratic at infinity. Let ξ1, . . . , ξN be the equilibria, that is, the solutions of H\n′(ξ) = 0. Denote by ωk the smallest eigenvalue of H ′′ (ξk), and set:\nω := Min {ω1, . . . , ωk} . (13)\nIf: T\n2π b∞ < −E\n[ − T\n2π a∞\n] < T\n2π ω (14)\nthen minimization of ψ yields a non-constant T -periodic solution x.\nWe recall once more that by the integer part E[α] of α ∈ IR, we mean the a ∈ ZZ such that a < α ≤ a + 1. For instance, if we take a∞ = 0, Corollary 2 tells us that x exists and is non-constant provided that:\nT 2π b∞ < 1 < T 2π (15)\nor\nT ∈\n( 2π\nω , 2π\nb∞\n) . (16)\nProof. The spectrum of Λ is 2πT ZZ + a∞. The largest negative eigenvalue λ is given by 2πT ko + a∞, where\n2π T ko + a∞ < 0 ≤ 2π T (ko + 1) + a∞ . (17)\nHence:\nko = E\n[ − T\n2π a∞\n] . (18)\nThe condition γ < −λ < δ now becomes:\nb∞ − a∞ < − 2π\nT ko − a∞ < ω − a∞ (19)\nwhich is precisely condition (14). ⊓⊔\nLemma 1. Assume that H is C2 on IR2n\\{0} and that H ′′(x) is non-degenerate for any x 6= 0. Then any local minimizer x̃ of ψ has minimal period T .\n10\nProof. We know that x̃, or x̃ + ξ for some constant ξ ∈ IR2n, is a T -periodic solution of the Hamiltonian system:\nẋ = JH ′(x) . (20)\nThere is no loss of generality in taking ξ = 0. So ψ(x) ≥ ψ(x̃) for all x̃ in some neighbourhood of x in W 1,2 ( IR/TZZ; IR2n ) .\nBut this index is precisely the index iT (x̃) of the T -periodic solution x̃ over the interval (0, T ), as defined in Sect. 2.6. So\niT (x̃) = 0 . (21)\nNow if x̃ has a lower period, T/k say, we would have, by Corollary 31:\niT (x̃) = ikT/k(x̃) ≥ kiT/k(x̃) + k − 1 ≥ k − 1 ≥ 1 . (22)\nThis would contradict (21), and thus cannot happen. ⊓⊔\nNotes and Comments. The results in this section are a refined version of 1980; the minimality result of Proposition 14 was the first of its kind.\nTo understand the nontriviality conditions, such as the one in formula (16), one may think of a one-parameter family xT , T ∈ ( 2πω−1, 2πb−1∞ ) of periodic solutions, xT (0) = xT (T ), with xT going away to infinity when T → 2πω −1, which is the period of the linearized system at 0.\nTheorem 1 (Ghoussoub-Preiss). Assume H(t, x) is (0, ε)-subquadratic at infinity for all ε > 0, and T -periodic in t\nH(t, ·) is convex ∀t (23)\nH(·, x) is T−periodic ∀x (24)\nH(t, x) ≥ n (‖x‖) with n(s)s−1 → ∞ as s→ ∞ (25)\n∀ε > 0 , ∃c : H(t, x) ≤ ε\n2 ‖x‖\n2 + c . (26)\n11\nAssume also that H is C2, and H ′′(t, x) is positive definite everywhere. Then there is a sequence xk, k ∈ IN, of kT -periodic solutions of the system\nẋ = JH ′(t, x) (27)\nsuch that, for every k ∈ IN, there is some po ∈ IN with:\np ≥ po ⇒ xpk 6= xk . (28)\n⊓⊔\nExample 1 (External forcing). Consider the system:\nẋ = JH ′(x) + f(t) (29)\nwhere the Hamiltonian H is (0, b∞)-subquadratic, and the forcing term is a distribution on the circle:\nf = d\ndt F + fo with F ∈ L\n2 ( IR/TZZ; IR2n ) , (30)\nwhere fo := T −1 ∫ T o f(t)dt. For instance,\nf(t) = ∑\nk∈IN\nδkξ , (31)\nwhere δk is the Dirac mass at t = k and ξ ∈ IR 2n is a constant, fits the prescription. This means that the system ẋ = JH ′(x) is being excited by a series of identical shocks at interval T .\nDefinition 1. Let A∞(t) and B∞(t) be symmetric operators in IR 2n, depending continuously on t ∈ [0, T ], such that A∞(t) ≤ B∞(t) for all t. A Borelian function H : [0, T ]× IR2n → IR is called (A∞, B∞)-subquadratic at infinity if there exists a function N(t, x) such that:\nH(t, x) = 1\n2 (A∞(t)x, x) +N(t, x) (32)\n∀t , N(t, x) is convex with respect to x (33)\nN(t, x) ≥ n (‖x‖) with n(s)s−1 → +∞ as s→ +∞ (34)\n∃c ∈ IR : H(t, x) ≤ 1\n2 (B∞(t)x, x) + c ∀x . (35)\nIf A∞(t) = a∞I and B∞(t) = b∞I, with a∞ ≤ b∞ ∈ IR, we shall say that H is (a∞, b∞)-subquadratic at infinity. As an example, the function ‖x‖ α , with 1 ≤ α < 2, is (0, ε)-subquadratic at infinity for every ε > 0. Similarly, the Hamiltonian\nH(t, x) = 1\n2 k ‖k‖\n2 + ‖x‖ α (36)\nis (k, k + ε)-subquadratic for every ε > 0. Note that, if k < 0, it is not convex.\n12\nNotes and Comments. The first results on subharmonics were obtained by Rabinowitz in 1985, who showed the existence of infinitely many subharmonics both in the subquadratic and superquadratic case, with suitable growth conditions on H ′. Again the duality approach enabled Clarke and Ekeland in 1981 to treat the same problem in the convex-subquadratic case, with growth conditions on H only.\nRecently, Michalek and Tarantello (see Michalek, R., Tarantello, G. 1982 and Tarantello, G. 1983) have obtained lower bound on the number of subharmonics of period kT , based on symmetry considerations and on pinching estimates, as in Sect. 5.2 of this article."
    } ],
    "references" : [ {
      "title" : "Nonlinear oscillations and boundary-value problems for Hamiltonian systems",
      "author" : [ "F. Clarke", "I. Ekeland" ],
      "venue" : "Arch. Rat. Mech. Anal. 78, 315–333",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "Solutions périodiques, du période donnée, des équations hamiltoniennes",
      "author" : [ "F. Clarke", "I. Ekeland" ],
      "venue" : "Note CRAS Paris 287, 1013–1015",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "Subharmonic solutions with prescribed minimal period for nonautonomous Hamiltonian systems",
      "author" : [ "R. Michalek", "G. Tarantello" ],
      "venue" : "J. Diff. Eq. 72, 28–55",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1988
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "MiniZinc [13] is intended to be a standard modeling language, and Cadmium [3] is able to map MiniZinc models to a set of solvers.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 0,
      "context" : "1 int set week s g roup s p l aye r s [w∗g ] in [ 1 , 9 ] , 2 f o ra l l weeks in [ 1 ,w] { 3 f o ra l l groups in [ 1 , g ] { 4 card ( we ek s g roup s p l aye r s [ weeks∗w+groups ] )= g , 5 .",
      "startOffset" : 48,
      "endOffset" : 57
    }, {
      "referenceID" : 1,
      "context" : "However, many irrelevant or erroneous models can be obtained without any additional checking [2].",
      "startOffset" : 93,
      "endOffset" : 96
    }, {
      "referenceID" : 0,
      "context" : "These scripts are hand-written, but they can be automatically generated using the am3 tool [1] and the concept of megamodel [7] to get a graphical interfaces to manage terminal models, metamodels and complex transformation chains.",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 0,
      "context" : "The results in this section are a refined version of [1]; the minimality result of Proposition 14 was the first of its kind.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 1,
      "context" : "Again the duality approach enabled Clarke and Ekeland in [2] to treat the same problem in the convex-subquadratic case, with growth conditions on H only.",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 2,
      "context" : "Recently, Michalek and Tarantello (see [3] and [4]) have obtained lower bound on the number of subharmonics of period kT , based on symmetry considerations and on pinching estimates, as in Sect.",
      "startOffset" : 39,
      "endOffset" : 42
    } ],
    "year" : 2014,
    "abstractText" : "Transforming constraint models is an important task in recent constraint programming systems. User-understandable models are defined during the modeling phase but rewriting or tuning them is mandatory to get solving-efficient models. We propose a new architecture allowing to define bridges between any (modeling or solver) languages and to implement model optimizations. This architecture follows a modeldriven approach where the constraint modeling process is seen as a set of model transformations. Among others, an interesting feature is the definition of transformations as concept-oriented rules, i.e. based on types of model elements where the types are organized into a hierarchy called a metamodel.",
    "creator" : null
  }
}