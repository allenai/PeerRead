{
  "name" : "1006.4563.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "The State of the Art: Ontology Web- Based Languages: XML Based",
    "authors" : [ "Mohammad Mustafa Taye" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Index Terms — Ontology, Ontology language, RDF, RDFS, DAML+OIL , OWL"
    }, {
      "heading" : "1 INTRODUCTION",
      "text" : "Ontologies become a critical part in many areas, especially in Web Semantics. Consequently, a number of representational formats have been proposed to support and express them completely.\nCurrent languages used to express Ontologies fall generally into three categories [1]: vocabularies of Ontology defined using natural language, frame-based languages used to build the structure of Ontologies based on explicit statements of class and slot, and those languages based on logic, such as Description Logics.\nThe main object of semantic web languages is to add semantics to the existing information on the Web. RDF/RDFS [7], OIL [14], DAML+OIL [9], and OWL [2] are modelling web languages that have already been developed to represent or express Ontologies. In general, most of these languages are based on XML [16] syntax, but they have different terminologies and expressions. Indeed, some of these languages have the ability to represent some logical relation but others do not. Because some languages have greater expressive power than others, languages chosen for representing Ontologies are based mainly on what the Ontology represents or what it will be used for. In other words, different kinds of Ontological knowledge-based applications need different language facilitators for enabling reasoning on Ontology data. These description\nlanguages provide richer constructors for forming complex class expressions and axioms.\nIn fact, recently most Ontology developers have used Ontology Editors, which are environments or tools used directly for editing, developing or modifying Ontologies. These tools are used for providing support for the Ontological development process, as well as for conceptualising the Ontology; they transform the conceptualisation into executable code using translators. So the output Ontology of these tools will be in one of the Web Ontology languages supported by editors Such as Protégé [18], OWLP [21] and OilEd [22]. Alternatively Ontology reasoners are used to check the conflicts with a high degree of automation. Many such systems, including RACER [19] and FaCT [20], have been developed recently.\nReturning to the main concern of this section, modelling web languages, there are in general two different types of language: Presentation languages such as HTML, designed to represent text and images to users or requesters without reference to the content, and Data Languages, intended to be processed by machines. The present research relates to the latter.\nBefore OWL, much research has been conducted into creating a powerful Ontology modelling language. This research stream began with the XML-based RDF and RDF/S,\nprogressed to the Ontology Inference Layer (OIL), and continued with the creation of DAML+OIL, the result of joining the American proposal DAML-ONT5 with the European language OIL. All these languages are XML or RDF syntax based, and are consequently compatible with web standards. Indeed, RDF and OWL make searching for and reusing information both more reliable and easier, because they are considered as standards that enable the Web to be a global infrastructure for sharing documents and data equally.\nAs mentioned in [2], some important requirements for quality support should be taken into account when developing languages for encoding Ontologies. These include giving the user explicit written format, ease of use, expressive power, compatibility, sharing and versioning, internationalisation, formal conceptualisations of domains models, well defined syntax and semantics, efficient reasoning support, sufficient expressive power, and convenience of expression.\nSyntax is one of the most important features in any language, so it should be well-defined, it is also the most significant condition required for the processing of information by machine.\nThe semantics of knowledge should be well defined because it represents the meaning of that knowledge. Formal semantics should be established in the domain of mathematical logic in, clearly defined way that will lead to unambiguous meaning. Well-defined semantics will lead to correct reasoning. Semantics can be considered as pre- requisites that help to support reasoning. On the other hand, reasoning will help to check and discover consistent Ontology, to verify unintended relationships between classes, and to classify individuals into classes.\nThis paper has detailed the most common and important languages such as RDF, RDF/S, DAML+OIL, OWL, all of which are based on XML.\nExtensible Markup Language (XML) [16] is widely known in the WWW community because it is a flexible text format and was designed to describe data and to meet the challenges of largescale e-business and electronic publishing, and it plays an important role in exchanging different type of data on the Web. In fact, it is the basis for a rapidly growing number of software development activities.\nThe present research, for the sake of simplicity, deals with RDF and RDFS as one description language."
    }, {
      "heading" : "2 RESOURCE DESCRIPTION FRAMEWORK",
      "text" : "(RDF)\nResource Description Framework (RDF) [3, 4, and 5] a language used to provide a standard for\nmetadata about the resources on the web, is capable of representing data on and exchanging knowledge over the Web. It was developed to be understood by computers, facilitating interoperability between applications. In other words, it is a framework for using and representing metadata and describing the semantics of information about web resources in a way accessible to machines.\nRDF is recommended by the World Wide Web Consortium (W3C). Uniform Resource Identifiers (URIs) are the method used by RDF to identify resources or thing. In fact, it is based built upon XML, but while that is designed for syntax, RDF is intended for semantics.\nAs has been mentioned, RDF is a framework for describing web resources, which is why it has become a common method of describing the properties, time, information and content of web resources, so that it can be read and understood by computer applications.\nRDF can be used in several applications, one of the most important being resource discovery, used to enhance search engine capabilities. It is also used to facilitate knowledge sharing and exchange in intelligent software agents so-called Ontology, and, previously mentioned, to describe the content and content relationships available with any resource such as a page.\nThe RDF model has three elements: a resource (the subject), the object and the predicate. We can say that <subject> has a property <predicate> valued by <object>.\nFor example, a triplet could be \"H.ZEDAN is the Head of the STRL Group\". In an RDF graph, all triplets \"nodes and arcs\" should be labelled with qualified URIs. In this example, it could be said that the Subject (Resource) is the STRL Group, the predicate (property) is Head of, and the Object (literally) is H.ZEDAN."
    }, {
      "heading" : "2.1 RESOURCE DESCRIPTION FRAMEWORK",
      "text" : "(RDF) SCHEMA\nThe Resource Description Framework / Schema (RDFS) [6, 7] has been built upon the XML and RDF models and upon syntax. RDFS provides additional facilities to support evolution in both of the individual RDF vocabularies, and the core RDF Schema vocabulary.\nThe RDF Schema provides a machineunderstandable system for defining the vocabularies needed for such applications or descriptive vocabularies. In other words, the RDF Schema is a collection of RDF resources that can be used to define or describe properties of other RDF resources which define applicationspecific RDF vocabularies. At the same time, RDF(S) helps developers to describe classes and properties in a specific way and to specify\nrelationships between those properties and classes, and it allows combinations between classes, properties, or values. In other words, RDFS is used to define RDF vocabularies.\nIn general, RDFS is defined in a namespace informally called 'rdfs', and identified by the URI reference http://www.w3.org/2000/01/rdfschema#. On the other hand, RDF is defined in a namespace informally called ‘rdf’, and identified by the URI reference http://www.w3.org/1999/02/22-rdf-syntaxns#.\nFigure 1 presents an excellent description of RDF /RDFS elements, demonstrating three important cores: class, property and constraint property.\nIn general, an RDF document contains two lists, one of descriptions and one of properties, both of which relate to one resource. Property values could be URIs, literals or others descriptions.\nThe rdf:RDF includes a sequence of XML elements called rdf:Description, there are “rdf:about” and “rdf:ID”. In any source we need to use only one of those attributes. rdf:about is used to describe any resource; its value either an absolute or a relative URI. rdf:ID, is used to define a resource; so its value of a fragment to be added to the XML document URI.\nThe elements of RDF are Resource, Property, and Property Value which there are: firstly, Resource is anything that can have a URI, http://www.dmu.ac.uk/RDF, Property is for named resources such as \"university\", the property value is the value of a property, such as \"De Montfort\". For example:\n<?xml version=\"1.0\"?> <RDF> <Description\nabout=\"http://www.dmu.ac.uk/RDF\"> <university>De Montfort</university> <location>UK-Leicester</location> </Description> </RDF> The statement of RDF is a combination of a\nresource, a property, and property value forms, as in the statement: \"The University of Http://www.dmu.ac.uk/RDF is De Montfort\".\nThe subject of the statement above is http:// www.dmu.ac.uk /RDF.\nThe predicate is university. The object is De Montfort. Statement: \"The location of http://www.dmu.ac.uk/RDF is UK-Leicester\". The subject of the statement above is: http://www.dmu.ac.uk/RDF. The predicate is: location. The object is: UK-Leicester."
    }, {
      "heading" : "2.2 CORE CLASSES",
      "text" : "The elements in this class could be called fundamental concepts because they are used to describe most classes and their properties with examples. This class is defined as part of the RDF Schema vocabulary."
    }, {
      "heading" : "2.2.1 RDF:RESOURCE",
      "text" : "RDF is about describing resources or any objects. Therefore, whatever is described by RDF expressions is called resources; these are always identified by URIs and are considered to be instances of the class rdfs:Resource."
    }, {
      "heading" : "2.2.2 RDF:PROPERTY",
      "text" : "rdf:Property is used to represent that subset of RDF resources called properties."
    }, {
      "heading" : "2.2.3. RDFS:CLASS",
      "text" : "RDF classes are the class of resources used to describe (or which could represent) anything such as cars or persons. When a schema defines a new class, the resource representing that class must have an rdf:type property whose value is the resource rdfs:Class.\n<?xml version=\"1.0\"?> <rdf:RDF xmlns:rdf= \"http://www.w3.org/1999/02/22-rdfsyntax-ns#\" xmlns:rdfs=\"http://www.w3.org/2000/01/rdfschema#\" xml:base= \"http://www.cars.fake/cars#\"> <rdfs:Class rdf:ID=\"cars\" /> <rdfs:Class rdf:ID=\"Benz\"> <rdfs:subClassOf rdf:resource=\"#cars\"/> </rdfs:Class> </rdf:RDF>"
    }, {
      "heading" : "2.3. CORE PROPERTIES",
      "text" : "These properties are in fact considered as an instances of the class rdf:Property. They are used to provide a mechanism for expressing relationships between classes and super-classes or between classes and their instances."
    }, {
      "heading" : "2.3.1. RDF:TYPE",
      "text" : "This element is an instance of the RDF\nproperties used to determine that a resource is an instance of a class. In other words, this shows that a resource is a sub-set of a class, and therefore has all the features that are to be expected of a member of that class."
    }, {
      "heading" : "2.3.2. RDFS:SUBCLASSOF",
      "text" : "This property is a transitive relation used to identify a relation between classes as sub/supersets. Classes are therefore structured in a subset hierarchy represented by this property (rdfs:subClassOf) . In other words, this property is used to specify that a class C2 is a subclass of another class C1, with the logical consequence that every instance of C2 is also an instance of C1."
    }, {
      "heading" : "2.3.3. RDFS:SUBPROPERTYOF",
      "text" : "This defines any property used to represent a relation between resources. This kind of property is a specialisation relation. rdfs:subPropertyOf is applied to properties to denote that one property is a subset or specialisation of another."
    }, {
      "heading" : "2.3.4. RDFS:SEEALSO",
      "text" : "The property rdfs:seeAlso used to denote the resources that might either have or provide alternative information about the subject resource over the internet."
    }, {
      "heading" : "2.3.5. RDFS:ISDEFINEDBY",
      "text" : "The property rdfs:isDefinedBy is a subproperty of rdfs:seeAlso, and indicates the resource defining the subject resource."
    }, {
      "heading" : "2.4. CORE CONSTRAINTS",
      "text" : "These are used to restrict the set of resources that may have a given property (the property's domain) and the set of valid values for a property (its range). A property may have as many values for rdfs:domain as needed, but no more than one value for rdfs:range."
    }, {
      "heading" : "2.4.1. RDFS:RANGE & RDFS:DOMAIN",
      "text" : "rdfs:range is used to declare that the values of a property are instances of one or more classes. rdfs:domain is used to declare that any resource that has a given property is an instance of one or more classes.\nIn the rest of this report, there are some properties used to support user-interface simple documentation these properties relate annotations within RDF schemas. This kind of concept is not essential, but could be useful in any application domain. They are defined in external schemas, but when they came into common use, they were permanently defined in the core schema."
    }, {
      "heading" : "2.4.2. RDFS:COMMENT",
      "text" : "This is used to add comments to provide a\nhuman-readable description of a resource."
    }, {
      "heading" : "2.4.3. RDFS:LABEL",
      "text" : "This is used to add a label name to provide a human-readable version of a resource name."
    }, {
      "heading" : "2.4.4. RDFS:CONTAINER",
      "text" : "RDF Containers are could be defined as collections of resources. The container nodes are represented by one of the three subclasses of rdfs:Container: rdf:Bag, an unordered collection; rdf:Seq, an ordered collection, and rdf:Alt used to chose between alternatives.\nAlthough, RDF is a good basic language for many other languages, it is not very expressive and has limitations in describing resources, including descriptions of existence, cardinality, localised range and domain constraints or transitive, inverse or symmetrical properties. In general, as mentioned in [2], RDFS’s expressive power is limited; on other hand, RDF/ RDFS provide modelling that concerns organisation of vocabularies in term of hierarchies: subclass and sub-property relationships, domain and range restrictions, and instances of classes. However, some features are still missing like specialised or defined properties of local scope and the specialisation of their characteristics of properties. It is impossible to separate some classes from each other. For example, we cannot say male and female are disjoint. But RDF Schema can only cater for subclass relationships - e.g. female is a subclass of person. On other hand, it is impossible to combine or create classes using Boolean relations. The expression of many restrictions is limited. The need consequently arose for a new language to supply all these deficiencies.\nThere are also many limitations to RDFS, among which are its inability to express equality and inequality, and its limited ability to define enumeration of property values. Regarding the latter, it cannot describe some relation among entities like union, intersection, complement, unique, symmetric, transitive, and inverse, and as far as constraints go it cannot apply cardinality and existence. Domain and range can only be specified globally. As a result, several languages such as OWL, DAML+OIL have been developed to meet these limitations."
    }, {
      "heading" : "3. ANNOTATED DAML+OIL ONTOLOGY",
      "text" : "MARK-UP\nDARPA Agent Markup Language (DAML) + Ontology Inference Layer (OIL), DAML+OIL [8, 9] is a semantic mark-up language designed for use for Web resources. In fact, it has been built on RDF and RDF Schema, which is to say that it has an RDF/XML syntax based on the frame paradigm, and so DAML+OIL could be considered as a specific kind of RDF and this\nlanguage then extended with more richer modelling primitives to cope with weaknesses in RDF /RFDS. To this end it uses URI to define the resources as RDF. DAML+OIL was actually developed to describe the structure of a domain, as most web-based languages describe structure in terms of classes and properties. DAML+OIL uses a Description Logic style model theory to formalise the meaning of a language [15].\nResearch first produced the Ontology Inference Layer (OIL), and a further effort produced DAML+OIL, an amalgamation of the American proposal DAML-ONT5, and the European language OIL."
    }, {
      "heading" : "3.1. ONTOLOGY INTERCHANGE LANGUAGES",
      "text" : "(OIL)\nA semantic mark-up language for Web semantics has been built on RDF and RDF/S, this language providing modelling primitives used in frame based and Description Logic oriented Ontologies [14].\nThe following illustrate elements that could appear in DAML+OIL documents:"
    }, {
      "heading" : "3.2. SETTING UP NAMESPACES",
      "text" : "Because of DAML+OIL is written in RDF, and RDF is written in XML, DAML+OIL exploits the existing Web standards XML and RDF, so a DAML+OIL document start with several namespace declarations using RDF, XML Namespace, and URIs.\n<rdf:RDF xmlns:rdf =\"http://www.w3.org/1999/02/22-rdfsyntax-ns#\" xmlns:rdfs=\"http://www.w3.org/2000/01/rdfschema#\" xmlns:xsd =\"http://www.w3.org/2000/10/XMLSchema#\" xmlns:daml=\"http://www.w3.org/2001/10/daml+oil#\" xmlns:dex =\"http://www.w3.org/TR/2001/NOTEdaml+oil-walkthru-20011218/daml+oil-ex#\" xmlns:exd =\"http://www.w3.org/TR/2001/NOTEdaml+oil-walkthru-20011218/daml+oil-ex-dt#\" xmlns =\"http://www.w3.org/TR/2001/NOTEdaml+oil-walkthru-20011218/daml+oil-ex#\" > </rdf:RDF>."
    }, {
      "heading" : "3.3. HOUSEKEEPING",
      "text" : "The first declaration after the namespace that is an Ontology. This assertion is formulaic; the “about” attribute will typically be empty, indicating that the subject of this declaration is this document. For documentation purposes a few properties of this Ontology are given, such as daml:versionInfo, rdfs:comment, daml:imports\n<daml:Ontology rdf:about=\"\"> <daml:versionInfo>$Id: daml+oil-ex.daml,v 1.8 2001/03/27 21:24:04 vehicle Exp $ </daml:versionInfo>\n<rdfs:comment> An example vehicle Ontology </rdfs:comment> <daml:imports rdf:resource=\"http://www.w3.org/2001/10/daml+oil\"/> <rdfs:label> vehicle </rdfs:label> </daml:Ontology>"
    }, {
      "heading" : "3.4. DEFINING CLASSES",
      "text" : "The first step in Ontology definitions is to describe objects. It is useful to define some basic types. In DAML+OIL, classes are defined by using a daml:Class element which is a subclass of rdfs:Class.\nThis is done by giving a name for the class, which is the subset of the universe which contains all objects of that type.\n<daml:Class rdf:ID=\"Cars\"> <rdfs:label>Cars</rdfs:label> <rdfs:comment> This class of cars is illustrative of a number of ontological idioms. </rdfs:comment> </daml:Class>\nThis asserts that there is a class known as car. DAML+OIL divides the word into objects (which are elements of DAML classes) and datatype values. Data-type values are used to help define classes, but they are not DAML objects and cannot be included in a DAML object class. There are a number of types of car, including Mercedes- BENZ and BMW.\n<daml:Class rdf:ID=\"BENZ\"> <rdfs:subClassOf rdf:resource=\"#Cars\"/> </daml:Class> <daml:Class rdf:ID=\"BMW\"> <rdfs:subClassOf rdf:resource=\"#Cars\"/> <daml:disjointWith rdf:resource=\"#BENZ\"/> </daml:Class>\nThis means that these two classes are disjoint (using the disjoint with tag): nothing can be both. It perfectly admissible for a class to have multiple superclasses: E-Class is a Car and Mercedes -BENZ.\n<daml:Class rdf:ID=\"E-Class\"> <rdfs:subClassOf rdf:resource=\"#Cars\"/> <rdfs:subClassOf rdf:resource=\"# Mercedes-BENZ\"/> </daml:Class>"
    }, {
      "heading" : "3.5. DEFINING PROPERTIES",
      "text" : "Properties are used to define binary relations between items. Properties in this language are of two kinds: the first, \"daml:ObjectProperty\", defines relations between objects, and the second, daml:DatatypeProperty, defines relations between objects and their data-type values. It can be said that domains and ranges are global\ninformation about properties.\n<daml:ObjectProperty rdf:ID=\"hasCar\"> <rdfs:domain rdf:resource=\"#Person\"/> <rdfs:range rdf:resource=\"#Car\"/> </daml:ObjectProperty>\nIn general, properties that relate object properties to datatype values are members of DatatypeProperty. Strings, integers or decimal numbers are sometimes used when dealing with DatatypeProperty, which lead to such references as standard location XML Schema datatype decimal [8]. So for example to create an age property, non-negative integers must be mapped into XML Schema [9].\n<daml:DatatypeProperty rdf:ID=\"age\"> <rdfs:comment> age is a DatatypeProperty whose range is xsd:decimal. age is also a UniqueProperty (can only have one age) </rdfs:comment> <rdf:type rdf:resource=\"http://www.w3.org/2001/10/daml+oil#U niqueProperty\"/> <rdfs:range rdf:resource=\"http://www.w3.org/2000/10/XMLSchema #nonNegativeInteger\"/> </daml:DatatypeProperty>"
    }, {
      "heading" : "3.6. DEFINING PROPERTY RESTRICTIONS",
      "text" : "The property restriction is used to define an anonymous class, which contains all objects or things that satisfy the restriction. The following example defines an anonymous class of PhD student who has only a car.\n<daml:Class rdf:ID=\"PhD Student\"> <rdfs:subClassOf rdf:resource=\"#UniverstyStudentl\"/> <rdfs:subClassOf> <daml:Restriction> <daml:onProperty rdf:resource=\"#hasCar\"/> <daml:toClass rdf:resource=\"#PhDStudent\"/> </daml:Restriction> </rdfs:subClassOf>\nA requirement of any web Ontology language is that statements about entities can be distributed along with different locations. <daml:Class rdf:about=\"#PhD Student\"> <rdfs:comment> PhD Student has exactly two supervisors, ie: </rdfs:comment> <rdfs:subClassOf> <daml:Restriction daml:cardinality=\"2\"> <daml:onProperty rdf:resource=\"#hasSupervisor\"/> </daml:Restriction> </rdfs:subClassOf> </daml:Class>\nThe cardinality property specifies a precise cardinality. But sometimes the cardinality must\nbe restricted without being precisely specified. A person may have zero or one wife, but no more:\n<daml:Class rdf:about=\"#Person\"> <rdfs:subClassOf> <daml:Restriction daml:maxCardinality=\"1\"> <daml:onProperty rdf:resource=\"#haswife\"/> </daml:Restriction> </rdfs:subClassOf> </daml:Class>\nA minimal value for the cardinality of a property can be expressed thus: <Restriction daml:minCardinality=\"0\">. A cardinality constraint could specify a maximum, minimum or precise number of values as well as enforcing the type of property those values must have."
    }, {
      "heading" : "3.7. NOTATIONS FOR PROPERTIES",
      "text" : "In fact, several annotations are used in this proposal to illustrate various notations for properties:\n<daml:UniqueProperty rdf:ID=\"hasMother\"> <rdfs:subPropertyOf rdf:resource=\"#hasParent\"/> <rdfs:range rdf:resource=\"#Female\"/> </daml:UniqueProperty>\nThe (inverseOf) tag.\n<daml:ObjectProperty rdf:ID=\"hasChild\"> <daml:inverseOf rdf:resource=\"#hasParent\"/> </daml:ObjectProperty> The transitive tag: <daml:TransitiveProperty rdf:ID=\"hasAncestor\"> <rdfs:label>hasAncestor</rdfs:label> </daml:TransitiveProperty> <daml:TransitiveProperty rdf:ID=\"descendant\"/>\nSometimes, “mom” is used as a synonym for “mother”. The tag samePropertyAs allows this synonymy to be established:\n<daml:ObjectProperty rdf:ID=\"hasMom\"> <daml:samePropertyAs rdf:resource=\"#hasMother\"/> </daml:ObjectProperty>"
    }, {
      "heading" : "3.8. NOTATIONS FOR CLASSES",
      "text" : "The following example represents the class “car” as being disjointed from the class “person”, through use of the complementOf tag: <daml:Class rdf:ID=\"Car\"> <rdfs:comment>no car is a person</rdfs:comment> <rdfs:subClassOf> <daml:Class> <daml:complementOf rdf:resource=\"#Person\"/> </daml:Class> </rdfs:subClassOf> </daml:Class>\nA class disjointly united with a set of other classes can also be recognised. In this case, the class “person” can be identified with the disjoint\nunion of the classes “man” and “woman”.\n<daml:Class rdf:about=\"#Person\"> <rdfs:comment>every person is a man or a woman</rdfs:comment> <daml:disjointUnionOf rdf:parseType=\"daml:collection\"> <daml:Class rdf:about=\"#Man\"/> <daml:Class rdf:about=\"#Woman\"/> </daml:disjointUnionOf> </daml:Class>\nThe parseType=\"daml:collection\" indicates that these sub-elements are to be treated as a unit. <daml:Class rdf:ID=\"ElegantWoman\"> <daml:intersectionOf rdf:parseType=\"daml:collection\"> <daml:Class rdf:about=\"#ElegantThing\"/> <daml:Class rdf:about=\"#Woman\"/> </daml:intersectionOf> </daml:Class>"
    }, {
      "heading" : "3.9. DEFINING INDIVIDUALS",
      "text" : "Individual objects in a class can also be identified, for example Adam, a person of age 13 and shoesize 9.5:\n<Person rdf:ID=\"Adam\"> <rdfs:label>Adam</rdfs:label> <rdfs:comment>Adam is a person.</rdfs:comment> <age><xsd:integer rdf:value=\"13\"/></age> <shoesize><xsd:decimal rdf:value=\"9.5\"/></shoesize> </Person>\nThis datatype is used to parse the lexical representation into an actual value. A person has a property called hasSize, which is a size.\n<daml:ObjectProperty rdf:ID=\"hasSize\"> <rdfs:range rdf:resource=\"#Size\"/> </daml:ObjectProperty>\nHeight is a class described by an explicitly enumerated set, which can be described using the oneOf element. Like disjointUnionOf, oneOf uses the RDF-extending parsetype=\"daml:collection\".\n<daml:Class rdf:ID=\"Size\"> <daml:oneOf rdf:parseType=\"daml:collection\"> < Size rdf:ID=\"small\"/> < Size rdf:ID=\"medium\"/> < Size rdf:ID=\"large\"/> < Size rdf:ID=\"Extralarge\"/> </daml:oneOf> </daml:Class>\nFinally, TallThing is the class of objects or\nthings whose hasSize has the value tall:\n<daml:Class rdf:ID=\"TallThing\"> <daml:sameClassAs> <daml:Restriction>\n<daml:onProperty rdf:resource=\"# hasSize \"/> <daml:hasValue rdf:resource=\"#tall\"/> </daml:Restriction> </daml:sameClassAs> </daml:Class>\nDAML+OIL has many limitations [17]: property constructors, it has no composition or transitive closure, in property types contain transitive and symmetrical, sets are the only collection type in this language (there are no bags or lists), there is no aggregation or comparison in data value, it has only unary and binary relations, and there are neither defaults value or nor variables."
    }, {
      "heading" : "4. WEB ONTOLOGY LANGUAGE (OWL)",
      "text" : "Web Ontology Language (OWL) [2, 10, 11, 12, 13], which is a language for processing web information, became a W3C (World Wide Web Consortium) Recommendation in February / 2004. It has been built using RDF to remedy the weaknesses in RDF/S and DAML+OIL. It provides a richer integration and interoperability of data among communities and domains.\nIt can be said that there is a similarity between OWL and RDF, but the former is a stronger syntax with more machine interpretability and vocabulary language than RDF. Obviously, RDF is generally limited to binary ground predicates, and RDF Schema also has the limitation that it represents a subclass hierarchy and a property hierarchy, with the domain and range definitions of these properties. In other words, the language of OWL is more expressive than that of RDF and RDF Schema.\nTo cope with limitation in RDF, RDF/S and DAML+OIL, W3C's defined OWL. Indeed, OWL is an extension of RDFS; in other words, OWL builds on RDF and RDF Schema, and uses RDF' XML syntax; overall, OWL uses the RDF meaning of classes and properties. W3C's classify OWL into three sublanguages, each of which is intended to supply different aspects of these incompatibilities. OWL’s sub-languages are OWL Full, OWL Lite, and OWL DL. What follows is a brief description of these sublanguages.\nOWL documents are usually called OWL Ontologies, some elements of which are:"
    }, {
      "heading" : "4.1. SETTING UP NAMESPACES",
      "text" : "Because OWL is written in RDF, and RDF is written in XML, (in other words, OWL exploits the existing Web standards XML and RDF), so OWL documents start with several namespace declarations using RDF, XML Namespace, and URIs. rdf:RDF is the root element of a OWL Ontology, and also specifies a number of namespaces.\n<rdf:RDF xmlns:owl =\"http://www.w3.org/2002/07/owl#\" xmlns:rdf =\"http://www.w3.org/1999/02/22-rdfsyntax-ns#\" xmlns:rdfs=\"http://www.w3.org/2000/01/rdfschema#\" xmlns:xsd =\"http://www.w3.org/2001/XLMSchema#\">\nAfter rdf:RDF, some declarations to identify namespaces associated with this Ontology could be added. The effect of all of these namespaces is that such prefixes as owl and rdf should be understood as referring to things drawn from following namespaces, as for example http://www.w3.org/2002/07/owl#."
    }, {
      "heading" : "4.2. HOUSEKEEPING",
      "text" : "After namespaces are established, any Ontology written in OWL may start with a collection of assertions for house-keeping purposes. These assertions are grouped under an owl:Ontology element which may contain comments, version statements, imports other Ontologies and labels, for example:\n<owl:Ontology rdf:about=\"\"> <rdfs:comment>An example Currency Ontology </rdfs:comment> <owl:versionInfo>$Id: http://www.daml.ecs.soton.ac.uk/ont/currency.owl, v 1.0 trp 2007/06/13 10:35:25 Exp $</owl:versionInfo> <owl:imports rdf:resource=\"http://www. kkkkkkkkk\"/> <rdfs:label> Currency Ontology </rdfs:label> </owl:Ontology>\nThe rdf:about attribute provides a reference for the Ontology. Where the value of the attribute is \"\", which is the standard case, rdfs:comment is used to provide a humanreadable description of a resource. rdfs:label is used to provide a human-readable version of a resource name.\nThe versioning information \"owl:priorVersion\" which is part of the header information used to indicate earlier versions of the current Ontology. In fact, Ontologies are similar to any software that can be maintained or changed over time. There are three kinds of versioning information statement; none of them carry any formal meaning, but can be exploited by human readers:\n- An owl:versionInfostatement generally contains a string giving information about the current version.\n- An owl:backwardCompatibleWith statement contains a reference to another Ontology.\n- An owl:incompatibleWith indicates that the Ontology containing is a later version of the Ontology referred to, but is not backward compatible with it."
    }, {
      "heading" : "4.3. DEFINING CLASSES",
      "text" : "In OWL, classes are defined by using an owl:Class element that is a subclass of rdfs:Class. For example, a class “cars” is as follows:\n<owl:Class rdf:ID=\"Cars\"> <rdfs:label>Cars</rdfs:label> <rdfs:comment> This class of cars is illustrative of a number of ontological idioms. </rdfs:comment> </owl:Class>\nOne of the power elements of OWL is a \"owl:disjointWith\", which is missing from RDFS, and is used to disjoint one class from others. \"owl:equivalentClass\" is another element that could be used used to establish equivalence between classes. Last but not last, there are two predefined classes, owl:Thing (which defines everything) and owl:Nothing, which is empty set."
    }, {
      "heading" : "4.4. DEFINING PROPERTIES",
      "text" : "There are two kinds of properties in OWL. Object properties represent the relation between two objects, such as the relation (isOwnBy, own) used to represent the relation between car and person. Datatype properties represent the related objects with their data-type values such as person with phone, address and age.\n<owl:ObjectProperty rdf:ID=\"isOwnBy\"> <owl:domain rdf:resource=\"#car\"/> <owl:range rdf:resource=\"#person\"/> </owl:ObjectProperty>\nIn OWL it is possible to talk about Boolean combinations such as union, intersection, or complement of classes. For example it can be said that people in Jordan are Muslims or Christians.\n<owl:Class rdf:ID=\"peopleAtJordan\"> <owl:unionOf rdf:parseType=\"Collection\"> <owl:Class rdf:about=\"# Muslims \"/> <owl:Class rdf:about=\"# Christians \"/> </owl:unionOf> </owl:Class>\nSome Boolean relations are supported by OWL; to declare more than one domain and range, the Boolean relational must be used. One example would be intersection and union among others, as well as inverse properties to inherit domain and range. Another element in OWL, owl:equivalentProperty, is used to define the equivalence of two classes and their properties, whereclasses have the same instances.\n<owl:Class rdf:ID=\"Cars\"> <owl:equivalentClass rdf:resource=\"Automobile\"/> </owl:Class>\nThis is a strong relation used to map between two Ontologies."
    }, {
      "heading" : "4.5. DEFINING PROPERTY RESTRICTIONS",
      "text" : "OWL uses some properties to add specification by using some properties’ restriction to classes. These restrictions are used to define an anonymous class that will contain all things or objects that satisfy the restriction. For example, owl:allValuesFrom is used to specify the class of possible values, and owl:onProperty is used to specify the property. The next example illustrates that every car should be driven by a professional driver.\n<owl:Class rdf:about=\"#everycar \"> <rdfs:subClassOf> <owl:Restriction> <owl:onProperty rdf:resource=\"#isDriveBy\"/> <owl:allValuesFrom rdf:resource=\"#professionaldrivers \"/> </owl:Restriction> </rdfs:subClassOf> </owl:Class>\nAnother and similar property is owl:hasValue, which declares a specific value that the specified property must have. For example, a car should be driven by a person.\n<owl:Class rdf:about=\"#car\"> <rdfs:subClassOf> <owl:Restriction> <owl:onProperty rdf:resource=\"#isDrivenBy\"/> <owl:hasValue rdf:resource=\"#person\"/> </owl:Restriction> </rdfs:subClassOf> </owl:Class>"
    }, {
      "heading" : "4.5.1. SPECIAL PROPERTIES",
      "text" : "There are some other properties of property elements that can be defined directly: owl:TransitiveProperty defines a transitive property, such as ”is older than”, meaning among other things “the ancestor of”, owl:SymmetricProperty defining a symmetric property such as “is sibling of”, owl:FunctionalProperty, defining a property that has at most one unique value for each object such as age or National Insurance Number, and owl:InverseFunctionalProperty, which defines a property for which two different objects cannot have the same value, such as National Insurance Number.\n<owl:ObjectProperty rdf:ID=\"isSiblingOf \"> <rdf:type rdf:resource=\"&owl;TransitiveProperty\" /> <rdf:type rdf:resource=\"&owl;SymmetricProperty\" /> <rdfs:domain rdf:resource=\"#person\" /> <rdfs:range rdf:resource=\"#person\" /> </owl:ObjectProperty>\nAlso,\n<owl:ObjectProperty rdf:ID=\"own\"> <rdfs:range rdf:resource=\"#car\"/> <rdfs:domain rdf:resource=\"#person\"/> <owl:inverseOf rdf:resource=\"#isOwnBy\"/> </owl:ObjectProperty>\nThe rdf:parseType attribute is shorthand for an explicit syntax for building lists with <rdf:first> and <rdf:rest> tags. <owl:Class rdf:ID=\"MuslimsAtJordan\"> <owl:intersectionOf rdf:parseType=\"Collection\"> < owl:Class rdf:ID=\"peopleAtJordan\"> <owl:complementOf> <owl:unionOf rdf:parseType=\"Collection\"> <owl:Class rdf:about=\"# Christians \"/> <owl:Class rdf:about=\"#OtherReligion\"/> </owl:unionOf> </owl:complementOf> </owl:intersectionOf> </owl:Class>"
    }, {
      "heading" : "4.6. ENUMERATIONS",
      "text" : "owl:oneOf is an enumeration element, used to define a class by listing all its elements.\n<owl:oneOf rdf:parseType=\"Collection\"> <owl:Thing rdf:about=\"#January \"/> <owl:Thing rdf:about=\"#February \"/> : : <owl:Thing rdf:about=\"#Desember\"/> </owl:oneOf>"
    }, {
      "heading" : "4.7. INSTANCES",
      "text" : "These are instances of classes, and are defined in the same way as in RDF. For example, the National Insurance Number for one individual could be present thus:\n<rdf:Description rdf:ID=\"9801002839\"> <rdf:type rdf:resource=\"#person\"/> </rdf:Description>\nAnother format could define this so: <person rdf:ID=\"9801002839\"/>. Indeed, further details can also be added, such as:\n<person rdf:ID=\"9801002839\"/> <uni:age rdf:datatype=\"&xsd;integer\">27<uni:age> </person >\nAlso,\n<carplat rdf:about=\"CI123TR\"> <isOwntBy rdf:resource=\" 9801009493\"> <isOwntBy rdf:resource=\"9672006574\"> </course>"
    }, {
      "heading" : "4.8. THE CORE OF OWL LANGUAGE",
      "text" : "This description language contains three expressive sublanguages. These sublanguages are OWL Lite, OWL DL, and OWL Full [1].\nOWL Lite is the simplest version of OWL and provides classification hierarchy and simple constraints, being designed for easy implementation. In this sublanguage there is some restriction of OWL DL to a subset of language constructors, with some limitations such as an absence of explicit negation or union; restricted expressiveness is the disadvantage of this sublanguage.\nOWL DL (short for: Description Logic) the name of this sublanguage shows that it has more Description Logic to represent the relation between objects and their properties. Indeed, it provides maximum expressiveness while preserving the completeness of computational properties. OWL Lite is a sublanguage of OWL DL.\nThe sublanguage OWL Full provides maximum expressiveness. OWL Lite and OWL DL are sublanguages of OWL Full.\nTABLE (1) COMPARISON BETWEEN ONTOLOGY LANGUAGES\nThe expression RDF/RDFS DAML+OIL OWL Class    rdf:Property    rdfs:subClassOf    rdfs:subPropertyOf    rdfs:domain    rdfs:range    Individual ×   sameClassAs ×   samePropertyAs ×   sameIndividualAs ×   differentIndividualFrom ×   inverseOf ×   TransitiveProperty ×   SymmetricProper ×   FunctionalProperty ×   InverseFunctionalProperty ×   allValuesFrom × toClass  someValuesFrom × hasClass  minCardinality    maxCardinality    cardinality    oneOf  ×  disjointWith ×   complementOf ×   unionOf ×   intersectionOf ×   hasValue ×   imports versionInfo priorVersion backwardCompatibleWith × × × ×\n    \n    \nincompatibleWith\n×"
    }, {
      "heading" : "5. CONCLUSION",
      "text" : "Ontology language is the basis of ontological knowledge systems, the definition of a system of knowledge representation language specification; it not only has a rich and intuitive ability to express and use it, but the body should be easily understood by the computer, processing and applications. Thus, a brief survey of state-of-the-art ontology languages which are used to express ontology over the Web is provided; all relevant terms were shown in order to provide a basic understanding of ontologies and of description logics, which are the basis of ontology languages. Therefore, choosing a language for building an Ontology is the main step. In other way, different kinds of Ontological knowledge-based applications need different language facilitators for enabling reasoning on Ontology data. These description languages provide richer constructors for forming complex class expressions and axioms."
    }, {
      "heading" : "6. REFERENCES",
      "text" : "1. J. Bruijn, “Using Ontologies - enabling knowledge\nsharing and reuse on the semantic web”. Technical Report DERI-2003-10-29, DERI, 2003. Available from http://homepage.uibk.ac.at/»c703239/publicati ons/DERI-TR-2003-10-29.pdf.\n2. A. Grigoris, H.Frank van,” Web Ontology\nLanguage: OWL. Handbook on Ontologies in Information Systems”. Springer-Verlag 2003\n3. B. McBride, “The Resource Description\nFramework (RDF) and its Vocabulary Description Language RDFS, in: The Handbook on Ontologies in Information Systems”, S. Staab, R. Studer (eds.), Springer Verlag, 2003.\n4. O. Lassila and R. Swick,” Resource Description\nFramework (RDF) model and syntax specification”, 1999. http://www.w3.org/TR/REC-rdf-syntax.\n5. D. Beckett.,”The design and implementation of the\nRedland RDF application framework”. In Proceedings of WWW10 conference, 2001.\n6. W3C Working Group. “W3c resource description\nframework (rdf) schema specification”. http://www.w3.org/TR/1998/WD-rdfschema/, March 1999.\n7. D. Brickley and R.V. Guha:” Resource Description Framework (RDF) Schema Specification 1.0”, W3C Candidate Recommendation 27 March 2000. http://www.w3.org/TR/2000/CR-rdfschema-20000327.\n8. D.L. McGuinness et al, \"DAML-ONT: An\nOntology Language for the Semantic Web,\" The Semantic Web, D. Fensel, J. et al., eds., to be published by MIT Press, Cambridge, Mass., 2002; www.daml.org/2000/10daml-ont. html.\n9. D. Connolly and et al., “DAML+OIL (March 2001)\nReference Description”, W3C Note 18, World Wide Web Consortium, Dec. 2001; www.w3.org/TRdaml+oil-reference.\n10. D. McGuinness and F. van Harmelen ,”OWL Web\nOntology Language Overview “ http://www.w3.org/TR/2003/WD-owlfeatures-20030331/\n11. M. Dean, G. Schreiber (eds), et al, “OWL Web\nOntology Language Reference “http://www.w3.org/TR/2003/WD-owl-ref20030331/\n12. M. Smith, C.Welty, D. McGuinness, “OWL Web Ontology Language Guide”, http://www.w3.org/TR/2003/WD-owl-guide20030331/\n13. P. Patel-Schneider, P. Hayes, I. Horrocks, “OWL\nWeb Ontology Language Semantics and Abstract Syntax”, http://www.w3.org/TR/2003/WD-owlsemantics-20030331/\n14. I. Horrocks, et al., “The Ontology Interchange\nLanguage OIL,” tech. report, Free Univ. of Amsterdam, 2000; available online at http://www.ontoknowledge.org/oil/\n15. A. Maedche. “Ontology Learning for the Semantic\nWeb”. Kluwer Academic Publishers, 2002 16. T. Bray, J. Paoli, and C.M. Sperberg-McQueen “\nExtensible Markup Language (XML) 1.0 “, W3C Recommendation 10-February-1998, http://www.w3.org/TR/REC-xml The comparison of these languages\n17. S. Bechhofer, C. Goble and I. Horrocks,”\nDAML+OIL is not Enough “ SWWS http://www.semanticweb.org/SWWS/progra m/full/paper40.pdf, 2001,151-159\n18. N. F. Noy and M. A. Musen,” PROMPT:\nAlgorithm and tool for automated Ontology merging and alignment”. In 17th National\nConferences on Artificial Intelligence (AAAI2000). 2000.\n19. V. Haarslev and R. M oller. RACER system\ndescription. In Proc. of the Int. Joint Conf. on Automated Reasoning (IJCAR-01), volume 2083 of Lecture Notes In Arti_cial Intelligence. Springer-Verlag, 2001.\n20. I. Horrocks. The FaCT system. In Harrie de Swart,\neditor, Proc. of theInt. Conf. on Automated Reasoning with Analytic Tableaux and Related Methods (TABLEAUX-98), volume 1397 of Lecture Notes In Arti_cial Intelligence, pages 307{312. Springer-Verlag, 1998.\n21. N. Desai, A. U. Mallya, A. K. Chopra, M. P. Singh.\n“OWL-P: A Methodology for Business Process Development”. Agent-Oriented Information Systems III, Lecture Notes in Computer Science (LNCS) 3529: 79-94, 2006.\n22. A Rector. and et al.,. OilEd Normalised Ontology Tutorial – Biomedical version (forOilEd version 3.4). October 2002. http://www.cs.man.ac.uk/mig/ontologytutorial/oiled-biomedical-ontology-tutorial.zip."
    } ],
    "references" : [ {
      "title" : "Using Ontologies - enabling knowledge sharing and reuse on the semantic web",
      "author" : [ "J. Bruijn" ],
      "venue" : "Technical Report DERI-2003-10-29, DERI,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2003
    }, {
      "title" : "Web Ontology Language: OWL",
      "author" : [ "A. Grigoris", "H.Frank van" ],
      "venue" : "Handbook on Ontologies in Information Systems”",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2003
    }, {
      "title" : "The Resource Description Framework (RDF) and its Vocabulary Description Language RDFS",
      "author" : [ "B. McBride" ],
      "venue" : "in: The Handbook on Ontologies in Information Systems”,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2003
    }, {
      "title" : "Resource Description Framework (RDF) model and syntax specification",
      "author" : [ "O. Lassila", "R. Swick" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1999
    }, {
      "title" : "W3c resource description framework (rdf) schema specification",
      "author" : [ "Working Group" ],
      "venue" : "Journal of Computing,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1998
    }, {
      "title" : "Resource Description Framework (RDF) Schema Specification 1.0",
      "author" : [ "D. Brickley", "R.V. Guha" ],
      "venue" : "W3C Candidate Recommendation",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2000
    }, {
      "title" : "DAML-ONT: An Ontology Language for the Semantic Web,",
      "author" : [ "D.L. McGuinness" ],
      "venue" : "The Semantic Web,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2002
    }, {
      "title" : "DAML+OIL (March 2001) Reference Description",
      "author" : [ "D. Connolly" ],
      "venue" : "World Wide Web Consortium,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2001
    }, {
      "title" : "”OWL Web Ontology Language Overview",
      "author" : [ "D. McGuinness", "F. van Harmelen" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2003
    }, {
      "title" : "OWL Web Ontology  Language  Reference “http://www.w3.org/TR/2003/WD-owl-ref20030331",
      "author" : [ "M. Dean", "G. Schreiber (eds" ],
      "venue" : null,
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2003
    }, {
      "title" : "OWL Web Ontology  Language  Guide",
      "author" : [ "M. Smith", "C.Welty", "D. McGuinness" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2003
    }, {
      "title" : "OWL Web Ontology Language Semantics and Abstract  Syntax",
      "author" : [ "P. Patel-Schneider", "P. Hayes", "I. Horrocks" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2003
    }, {
      "title" : "The Ontology Interchange Language OIL,",
      "author" : [ "I. Horrocks" ],
      "venue" : "tech. report, Free Univ. of Amsterdam,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2000
    }, {
      "title" : "Ontology Learning for the Semantic Web",
      "author" : [ "A. Maedche" ],
      "venue" : "Kluwer Academic Publishers,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2002
    }, {
      "title" : "Extensible Markup Language (XML) 1.0 “, W3C Recommendation 10-February-1998, http://www.w3.org/TR/REC-xml  The comparison of these languages",
      "author" : [ "T. Bray", "J. Paoli", "C.M" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1998
    }, {
      "title" : "DAML+OIL is not Enough",
      "author" : [ "S. Bechhofer", "C. Goble", "I. Horrocks" ],
      "venue" : "SWWS http://www.semanticweb.org/SWWS/progra",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2001
    }, {
      "title" : "PROMPT: Algorithm and tool for automated Ontology merging and alignment",
      "author" : [ "N.F. Noy", "M.A. Musen" ],
      "venue" : "In 17th National  Conferences on Artificial Intelligence",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2000
    }, {
      "title" : "oller. RACER system description",
      "author" : [ "V. Haarslev", "R. M" ],
      "venue" : "In Proc. of the Int. Joint Conf. on Automated Reasoning (IJCAR-01),",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2001
    }, {
      "title" : "The FaCT system",
      "author" : [ "I. Horrocks" ],
      "venue" : "Harrie de Swart, editor, Proc. of theInt. Conf. on Automated Reasoning with Analytic Tableaux and Related Methods (TABLEAUX-98),",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1998
    }, {
      "title" : "OWL-P: A Methodology for Business Process Development",
      "author" : [ "N. Desai", "A.U. Mallya", "A.K. Chopra", "M.P. Singh" ],
      "venue" : "Agent-Oriented Information Systems III, Lecture Notes in Computer Science (LNCS)",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2006
    }, {
      "title" : "OilEd Normalised Ontology Tutorial – Biomedical version (forOilEd version 3.4)",
      "author" : [ "A Rector" ],
      "venue" : null,
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2002
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Current languages used to express Ontologies fall generally into three categories [1]: vocabularies of Ontology defined using natural language, frame-based languages used to build the structure of Ontologies based on explicit statements of class and slot, and those languages based on logic, such as Description Logics.",
      "startOffset" : 82,
      "endOffset" : 85
    }, {
      "referenceID" : 5,
      "context" : "RDF/RDFS [7], OIL [14], DAML+OIL [9], and OWL [2] are modelling web languages that have already been developed to represent or express Ontologies.",
      "startOffset" : 9,
      "endOffset" : 12
    }, {
      "referenceID" : 12,
      "context" : "RDF/RDFS [7], OIL [14], DAML+OIL [9], and OWL [2] are modelling web languages that have already been developed to represent or express Ontologies.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 7,
      "context" : "RDF/RDFS [7], OIL [14], DAML+OIL [9], and OWL [2] are modelling web languages that have already been developed to represent or express Ontologies.",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 1,
      "context" : "RDF/RDFS [7], OIL [14], DAML+OIL [9], and OWL [2] are modelling web languages that have already been developed to represent or express Ontologies.",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 14,
      "context" : "In general, most of these languages are based on XML [16] syntax, but they have different terminologies and expressions.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 16,
      "context" : "So the output Ontology of these tools will be in one of the Web Ontology languages supported by editors Such as Protégé [18], OWLP [21] and OilEd [22].",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 19,
      "context" : "So the output Ontology of these tools will be in one of the Web Ontology languages supported by editors Such as Protégé [18], OWLP [21] and OilEd [22].",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 20,
      "context" : "So the output Ontology of these tools will be in one of the Web Ontology languages supported by editors Such as Protégé [18], OWLP [21] and OilEd [22].",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 17,
      "context" : "Many such systems, including RACER [19] and FaCT [20], have been developed recently.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 18,
      "context" : "Many such systems, including RACER [19] and FaCT [20], have been developed recently.",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 1,
      "context" : "As mentioned in [2], some important requirements for quality support should be taken into account when developing languages for encoding Ontologies.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 14,
      "context" : "Extensible Markup Language (XML) [16] is widely known in the WWW community because it is a flexible text format and was designed to describe data and to meet the challenges of largescale e-business and electronic publishing, and it plays an important role in exchanging different type of data on the Web.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 4,
      "context" : "The Resource Description Framework / Schema (RDFS) [6, 7] has been built upon the XML and RDF models and upon syntax.",
      "startOffset" : 51,
      "endOffset" : 57
    }, {
      "referenceID" : 5,
      "context" : "The Resource Description Framework / Schema (RDFS) [6, 7] has been built upon the XML and RDF models and upon syntax.",
      "startOffset" : 51,
      "endOffset" : 57
    }, {
      "referenceID" : 5,
      "context" : "Figure 1: Elements of RDF and RDFS [7]",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 1,
      "context" : "In general, as mentioned in [2], RDFS’s expressive power is limited; on other hand, RDF/ RDFS provide modelling that concerns organisation of vocabularies in term of hierarchies: subclass and sub-property relationships, domain and range restrictions, and instances of classes.",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 6,
      "context" : "ANNOTATED DAML+OIL ONTOLOGY MARK-UP DARPA Agent Markup Language (DAML) + Ontology Inference Layer (OIL), DAML+OIL [8, 9] is a semantic mark-up language designed for use for Web resources.",
      "startOffset" : 114,
      "endOffset" : 120
    }, {
      "referenceID" : 7,
      "context" : "ANNOTATED DAML+OIL ONTOLOGY MARK-UP DARPA Agent Markup Language (DAML) + Ontology Inference Layer (OIL), DAML+OIL [8, 9] is a semantic mark-up language designed for use for Web resources.",
      "startOffset" : 114,
      "endOffset" : 120
    }, {
      "referenceID" : 13,
      "context" : "DAML+OIL uses a Description Logic style model theory to formalise the meaning of a language [15].",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 12,
      "context" : "A semantic mark-up language for Web semantics has been built on RDF and RDF/S, this language providing modelling primitives used in frame based and Description Logic oriented Ontologies [14].",
      "startOffset" : 186,
      "endOffset" : 190
    }, {
      "referenceID" : 6,
      "context" : "Strings, integers or decimal numbers are sometimes used when dealing with DatatypeProperty, which lead to such references as standard location XML Schema datatype decimal [8].",
      "startOffset" : 171,
      "endOffset" : 174
    }, {
      "referenceID" : 7,
      "context" : "So for example to create an age property, non-negative integers must be mapped into XML Schema [9].",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 15,
      "context" : "DAML+OIL has many limitations [17]: property constructors, it has no composition or transitive closure, in property types contain transitive and symmetrical, sets are the only collection type in this language (there are no bags or lists), there is no aggregation or comparison in data value, it has only unary and binary relations, and there are neither defaults value or nor variables.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 1,
      "context" : "WEB ONTOLOGY LANGUAGE (OWL) Web Ontology Language (OWL) [2, 10, 11, 12, 13], which is a language for processing web information, became a W3C (World Wide Web Consortium) Recommendation in February / 2004.",
      "startOffset" : 56,
      "endOffset" : 75
    }, {
      "referenceID" : 8,
      "context" : "WEB ONTOLOGY LANGUAGE (OWL) Web Ontology Language (OWL) [2, 10, 11, 12, 13], which is a language for processing web information, became a W3C (World Wide Web Consortium) Recommendation in February / 2004.",
      "startOffset" : 56,
      "endOffset" : 75
    }, {
      "referenceID" : 9,
      "context" : "WEB ONTOLOGY LANGUAGE (OWL) Web Ontology Language (OWL) [2, 10, 11, 12, 13], which is a language for processing web information, became a W3C (World Wide Web Consortium) Recommendation in February / 2004.",
      "startOffset" : 56,
      "endOffset" : 75
    }, {
      "referenceID" : 10,
      "context" : "WEB ONTOLOGY LANGUAGE (OWL) Web Ontology Language (OWL) [2, 10, 11, 12, 13], which is a language for processing web information, became a W3C (World Wide Web Consortium) Recommendation in February / 2004.",
      "startOffset" : 56,
      "endOffset" : 75
    }, {
      "referenceID" : 11,
      "context" : "WEB ONTOLOGY LANGUAGE (OWL) Web Ontology Language (OWL) [2, 10, 11, 12, 13], which is a language for processing web information, became a W3C (World Wide Web Consortium) Recommendation in February / 2004.",
      "startOffset" : 56,
      "endOffset" : 75
    }, {
      "referenceID" : 0,
      "context" : "These sublanguages are OWL Lite, OWL DL, and OWL Full [1].",
      "startOffset" : 54,
      "endOffset" : 57
    } ],
    "year" : 2010,
    "abstractText" : "Many formal languages have been proposed to express or represent Ontologies, including RDF, RDFS, DAML+OIL and OWL. Most of these languages are based on XML syntax, but with various terminologies and expressiveness. Therefore, choosing a language for building an Ontology is the main step. The main point of choosing language to represent Ontology is based mainly on what the Ontology will represent or be used for. That language should have a range of quality support features such as ease of use, expressive power, compatibility, sharing and versioning, internationalisation. This is because different kinds of knowledge-based applications need different language features. The main objective of these languages is to add semantics to the existing information on the web. The aims of this paper is to provide a good knowledge of existing language and understanding of these languages and how could be used. Index Terms — Ontology, Ontology language, RDF, RDFS, DAML+OIL , OWL",
    "creator" : "PScript5.dll Version 5.2.2"
  }
}