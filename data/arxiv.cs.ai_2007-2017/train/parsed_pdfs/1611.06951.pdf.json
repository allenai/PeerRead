{
  "name" : "1611.06951.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Enforcing Relational Matching Dependencies with Datalog for Entity Resolution",
    "authors" : [ "Zeinab Bahmani", "Leopoldo Bertossi" ],
    "emails" : [ "zbahmani@connect.carleton.ca,", "bertossi@scs.carleton.ca" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n61 1.\n06 95\n1v 2\n[ cs\n.D B\n] 2\n5 Fe\nb 20"
    }, {
      "heading" : "1 Introduction",
      "text" : "The presence in a database of duplicate, but non-identical representations of the same external entity leads to uncertainty. Applications running on top of the database or a query answering process may not be able to tell them apart, and the results may lead to ambiguity, semantic problems, such as unintended inconsistencies, and erroneous results. In this situation, the database has to be cleaned. The whole area of entity resolution (ER) deals with identifying and merging database records in a database that refer to the same real-world entity [Bleiholder and Naumann 2008; Elmagarmid, Ipeirotis and Verykios 2007]. In so doing, duplicates are eliminated from the database, while at the same time new tuples are created through the merging process. ER is one of the most common and difficult problems in data cleaning. In the last few years there has been strong and increasing interest in providing declarative and generic solutions to data cleaning problems [Bertossi and Bravo 2013], in particular, in logical specifications of the ER process. In this direction, matching dependencies (MDs) have been proposed [Fan 2008; Fan et al. 2009]. They are declarative rules that assert that certain attribute values in relational tuples have to be merged, i.e. made identical, when certain similarity conditions hold between possibly other attribute values in those tuples.\n∗Contact author. Research funded by NSERC Discovery. Copyright c© 2016, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nExample 1. Consider the relational predicateR(A,B), with attributes A and B. The symbolic rule R[A] ≈ R[A] → R[B] . = R[B] is an MD specifying that, if for any two database tuplesR(a1, b1), R(a2, b2) in an instanceD, when A-values are similar, i.e. a1 ≈ a2, then their B-values have to be made equal (merged), i.e. b1 or b2 (or both) have to be changed to a value in common. Let us assume that ≈ is reflexive and symmetric, and that a2 ≈ a3, but a2 6≈ a1 6≈ a3. The table on the left-hand side (LHS) below provides the extension for predicate R in D. In it some duplicates are not “resolved”, e.g. the tuples (with tuple identifiers) t1 and t2 have similar – actually equal – A-values, but their B-values are different.\nR(D) A B t1 a1 b1 t2 a1 b2 t3 a2 b3 t4 a3 b4\nR(D′) A B t1 a1 b1 t2 a1 b1 t3 a2 b5 t4 a3 b5\nD does not satisfy the MD, and is a dirty instance. After applying the MD, we could get the instanceD′ on the righthand side (RHS), where values for B have been identified. D′ is stable in the sense that the MD holds in the traditional sense of an implication and “=” on D′, which we call a clean instance. In general, for a dirty instance and a set of MDs, multiple clean instances may exist. Notice that if we add the MD R[B] ≈ R[B] → R[A] . = R[A], creating a set of interactingMDs, a merging with one MDmay create new similarities that enable the other MD.\nA dynamic semantics for MDs was introduced in [Fan et al. 2009], that requires pairs of instances: a first one where the similarities hold, and a second where the mergings are enforced, e.g. D and D′ in Example 1. MDs, as introduced in [Fan et al. 2009], do not specify what values to use when merging two attribute values. The semantics was refined and extended in [Bertossi, Kolahi and Lakshmanan 2012] by means of matching functions (MFs) providing values for equality enforcements. An MF induces a lattice-theoretic structure on an attribute’s domain. Actually, a chase-based semantics for MD enforcement was proposed. On this basis, given an instance D and a set Σ of MDs, wrt. which D may contain duplicates, the chase procedure may lead to several different clean and stable solutions D′. Each of them can be obtained by means of a provably terminating, but\nnon-deterministic, iterative procedure that enforces the MDs through application of MFs. The set of all such clean instances is denoted by C(D,Σ). Each clean instance can be seen as the result of an uncertainty reduction process. If at the end there are several possible clean instances, uncertainty is still present, and expressed through this class of possible worlds. Identifying cases for which a single clean instance exists is particularly relevant: for them uncertainty can be eliminated.\nIn [Bahmani et al. 2012], a declarative specification of this procedural data cleaning semantics was proposed. More precisely, a general methodology was developed to produce, from D, Σ and the MFs, an answer set program (ASP) [Gelfond and Lifschitz 1991; Brewka, Eiter and Truszczynski 2011] whose models are exactly the clean instances in the class C(D,Σ). The ASP enables reasoning in the presence of uncertainty due to multiple clean instances. Computational implementations of ASP can be then used for reasoning, for computing clean instances, and for computing certain query answers (aka. clean answers), i.e. those that hold in all the clean instances [Bahmani et al. 2012]. Disjunctive ASPs, aka. disjunctive Datalog programs with stable model semantics [Eiter, Gottlob and Mannila 1997], are used (and provably required) for this task.\nFor some classes of MDs, for any given initial instance D, the class C(D,Σ) contains a single clean instance that can be computed in polynomial time in the size ofD. Some sufficient syntactic andMF-dependent conditionswere identified in [Bertossi, Kolahi and Lakshmanan 2012]. In this work we identify a new important “semantic” class of MDs, where the initial instance is also considered. This is the similarity-free attribute intersection class (the SFAI class) of combinations of MDs and initial instances. Members of this class also have (polynomial-time computable) single clean instances. For all these classes, we show that the general ASP mentioned above can be automatically and syntactically transformed into an equivalent stratified Datalog program with the single clean instance as its standard model, which can be computed bottom-up from D in polynomial time in the size of D [Abiteboul, Hull, and Vianu 1995; Ceri, Gottlob and Tanca 1989].\nRelational ER has been approached by the machine learning community [Bhattacharya and Getoor 2007]. The idea is to learn from examples a classifier that can be used to determine if an arbitrary pair of records (or tuples), r1, r2, are duplicates (or each other) or not. In order to speed up the process of learning and applying the classifier, usually blocking techniques are applied [Whang et al. 2009]. They are used to group records in clusters (blocks), for further comparison of pairs within clusters, but never of two records in different clusters. Interestingly, as reported in [Bahmani, Bertossi, and Vasiloglou 2015], MDs can be used in the blocking phase. As expected, MDs were also used during the final merging phase, after the calls to the classifier. However, the use at the earlier stage is rather surprising. The kind of MDs in this case turn out to belong, together with the initial instance, to the SFAI class. Actually, this allowed implementation of MD-based blocking by\nmeans of Datalog. The reason for using MDs at the blocking stage is that they may convey semantic relationships between records for different entities, and can then be used to collectively block records for different entities [Bhattacharya and Getoor 2007]: blocking together two records for an entity, say of books, may depend on having blocked together related records for a different entity, say of authors. For these kinds of applications, to capture semantic relationships, MDs were extended with relational atoms (conditions) in the antecedents, leading to the class of relational MDs. In this work we also introduce and investigate the class of relational MDs, we extend the single-clean instance classes mentioned above to the relational MD case, and we obtain in a uniform manner Datalog programs for the enforcement of MDs in these classes. For lack of space, our presentation is based mainly on representative examples."
    }, {
      "heading" : "2 Background",
      "text" : "We consider relational schemas R with a possibly infinite data domain U , a finite set of database predicates, e.g. R, and a set of built-in predicates, e.g. =, 6=. Each R ∈ R has attributes, say A1, . . . , An, each of them with a domain DomAi ⊆ U . We may assume that the Ais are different, and different predicates do not share attributes. However, different attributes may share the same domain. An instanceD forR is a finite set of ground atoms (or tuples) of the form R(c1, . . . , cn), with R ∈ R, ci ∈ DomAi . We will assume that tuples have identifiers, as in Example 1. They allow us to compare extensions of the same predicate in different instances, and trace changes of attribute values. Tuple identifiers can be accommodated by adding to each predicate R ∈ R an extra attribute, T , that acts as a key. Then, tuples take the form R(t, c1, . . . , cn), with t a value for T . Most of the time we leave the tuple identifier implicit, or we use it to denote the whole tuple. More precisely, if t is a tuple identifier in an instance D, then tD denotes the entire atom, R(c̄), identified by t. Similarly, if A is a list of attributes of predicate R, then tD[A] denotes the tuple identified by t, but restricted to the attributes in A. We assume that tuple identifiers are unique across the entire instance. For a schemaRwith predicatesR1[L̄1], R2[L̄2], with lists of attributes L̄1, L̄2, resp., a matching dependency (MD) [Fan et al. 2009] is an expression of the form:\nϕ : R1[X̄1] ≈ R2[X̄2] −→ R1[Ȳ1] . = R2[Ȳ2]. (1)\nHere, X̄1, Ȳ1 are sublists of L̄1, and X̄2, Ȳ2 sublists of L̄2. The lists X̄1, X̄2 (also Ȳ1, Ȳ2) are comparable, i.e. the attributes in them, sayX j 1 , X j 2 , are pairwise comparable in the sense that they share the same data domainDomj on which a binary similarity (i.e. reflexive and symmetric) relation≈j is defined. The MD (1) intuitively states that if, for an R1-tuple t1 and an R2-tuple t2 in an instance D the attribute values in tD1 [X̄1] are similar to attribute values in t D 2 [X̄2], then the values tD1 [Ȳ1] and t D 2 [Ȳ2] have to be made identical. This update results in another instanceD′, where tD ′\n1 [Ȳ1] = t D′ 2 [Ȳ2]\nholds. W.l.o.g., we may assume that the list of attributes on the RHS of MDs contain only one conjunct (attribute).\nFor a setΣ of MDs, a pair of instances (D,D′) satisfies Σ if wheneverD satisfies the antecedents of the MDs, thenD′ satisfies the consequents (taken as equalities). If (D,D) 6|= Σ, we say that D is “dirty” (wrt. Σ). On the other hand, an instanceD is stable if (D,D) |= Σ [Fan et al. 2009]. We now review some elements in [Bertossi, Kolahi and Lakshmanan 2012]. In order to enforce an MD on two tuples, making values of attributes identical, we assume that for each comparable pair of attributes A1, A2 with domain (in common) DomA, there is a binary matching function (MF) mA : DomA × DomA → DomA, such that mA(a, a′) is used to replace two values a, a′ ∈ DomA whenever necessary. MFs are idempotent, commutative, and associative. Similarity relations and MFs are treated as built-in relations.\nA chase-based semantics for entity resolutionwith MDs is as follows: starting from an instance D0, we identify pairs of tuples t1, t2 that satisfy the similarity conditions on the left-hand side of an MD ϕ, i.e. tD01 [X̄1] ≈ t D0 2 [X̄2] (but not the identity in its RHS), and apply an MF on the values for the right-hand side attribute, tD01 [A1], t D0 2 [A2], to make them both equal to mA(t D0 1 [A1], t D0 2 [A2]). We keep doing this on the resulting instance, in a chase-like procedure [Abiteboul, Hull, and Vianu 1995], until a stable instance is reached (cf. [Bertossi, Kolahi and Lakshmanan 2012] for details), i.e. a clean instance. An instance D0 may have several (D0,Σ)-clean instances. C(D0,Σ) denotes the set of clean instances forD0 wrt. Σ. For given D and Σ, the class of clean instances can be specified as the stable models of a logic program Π(D0,Σ) in Datalog\n∨,not , i.e. a disjunctive Datalog program with weak negation and stable model semantics [Gelfond and Lifschitz 1991; Eiter, Gottlob and Mannila 1997], with rules of the form: A1 ∨ . . .∨An ← P1, . . . , Pm, not N1, . . . , not Nk. Here, 0 ≤ n,m, k, andAi, Pj , Ns are (positive) atoms. Rules with n = 0 are called program constraints and have the effect of eliminating the stable models of the program (without them) that make their bodies (RHS of the arrow) true. When n = 1 and k = 0, we have (plain) Datalog programs. When n ≥ 1 and not is stratified, we have disjunctive, stratified Datalog programs, denoted Datalog∨,not,s. The subclass with n = 1 is stratified Datalog, denotedDatalognot,s. We now introduce general cleaning programs by means of a representative example (for full generality and details, see [Bahmani et al. 2012]). Let D0 be a given, possibly dirty initial instance wrt. a set Σ of MDs. The cleaning program, Π(D0,Σ), that we will introduce here, contains an (n+ 1)- ary predicate R′i, for each n-ary database predicate Ri. It will be used in the form R′i(T, Z̄), where T is a variable for the tuple identifier attribute, and Z̄ is a list of variables standing for the (ordinary) attribute values of Ri.\nFor every attribute A in the schema, with domain DomA, the built-in ternary predicate MA represents the MF mA, i.e. MA(a, a ′, a′′) means mA(a, a ′) = a′′. X A Y is used as an abbreviation for MA(X,Y, Y ). For attributes\nA without a matching function, A becomes the equality, =A. For lists of variables Z̄1 = 〈Z11 , . . . Z n 1 〉 and Z̄2 = 〈Z12 , . . . Z n 2 〉, Z̄1 Z̄2 denotes the conjunction Z11 A1 Z 1 2∧. . .∧Z n 1 An Z n 2 . Moreover, for each attribute A, there is a built-in binary predicate ≈A. For two lists of variables X̄1 = 〈X11 , . . .X l 1〉 and X̄2 = 〈X 1 2 , . . .X l 2〉 representing comparable attribute values, X̄1 ≈ X̄2 denotes the conjunctionX11 ≈1 X 1 2 ∧ . . . ∧X l 1 ≈l X l 2.\nIn intuitive terms, program Π(D0,Σ) has rules to implicitly simulate a chase sequence, i.e. rules that enforceMDs on pairs of tuples that satisfy certain similarities, create newer versions of those tuples by applying matching functions, and make the older versions of the tuples unavailable for other rules. The main idea is making stable models of the program correspond to valid chase sequences leading to clean instances. When the conditions for applying an MD hold, we have the choice between matching or not.1 If we do, the tuples are updated to new versions. Old versions are collected in a predicate, and tuples that have not participated in a matching that was possible never become old versions (see the last denial constraint under 2. in Example 2, saying that the RHS of the arrow cannot be made true). The program eliminates, using program constraints, instances (models of the program) that are the result of an illegal set of applications of MDs, i.e. they cannot put them in a linear (chronological) order representing chase steps. This occurs when matchings use old versions of tuples that have been replaced by new versions. To ensure that the matchings are enforced according to an order that correctly represents a chase, pairs of matchings are stored in an auxiliary relation, Prec. The last two program constraints under 6. in the example make Prec a linear order. In particular, matchings performed using old versions of tuples are disallowed.\nExample 2. Consider relation R(A,B) with extension in D0 as below; and assume that exactly the following similarities hold: a1 ≈ a2, b2 ≈ b3; and the MFs are as follows:\nMB(b1, b2, b12), MB(b2, b3, b23), MB(b1, b23, b123), MB(b3, b4, b34).\nR(D0) A B t1 a1 b1 t2 a2 b2 t3 a3 b3\nΣ contains the MDs:\nϕ1 : R [A] ≈ R [A] → R [B] . = R [B], ϕ2 : R [B] ≈ R [B] → R [B] . = R [B],\nwhich are interacting in that the set of attributes in the RHS of ϕ1, namely {R[B]}, and the set of attributes in the LHS of ϕ2, namely {R[B]}, have non-empty intersection. For the same reason, ϕ2 also interacts with itself. Enforcing Σ on D0 results in two alternative chase sequences, each enforcing the MDs in a different order, and two final stable clean instances D1 andD ′ 2.\nD0 A B t1 a1 b1 t2 a2 b2 t3 a3 b3 ⇒ϕ1 D1 A B t1 a1 b12 t2 a2 b12 t3 a3 b3\n1Matching is merging, or making identical, two attribute values on the basis of the MDs.\nD0 A B t1 a1 b1 t2 a2 b2 t3 a3 b3 ⇒ϕ2 D′1 A B t1 a1 b1 t2 a2 b23 t3 a3 b23 ⇒ϕ1 D′2 A B t1 a1 b123 t2 a2 b123 t3 a3 b23\nThe cleaning programΠ(D0,Σ) is as follows:\n1. R′(t1, a1, b1). R ′(t2, a2, b2). R ′(t3, a3, b3). (plus MB facts)\n2. Matchϕ1(T1, X1, Y1, T2, X2, Y2) ∨\nNotMatchϕ1(T1, X1, Y1, T2, X2, Y2) ←\nR ′(T1, X1, Y1), R ′(T2, X2, Y2), X1 ≈ X2, Y1 6= Y2.\nMatchϕ2(T1, X1, Y1, T2, X2, Y2) ∨\nNotMatchϕ2(T1, X1, Y1, T2, X2, Y2) ←\nR ′(T1, X1, Y1), R ′(T2, X2, Y2), Y1 ≈ Y2, Y1 6= Y2.\nMatchϕi(T1, X1, Y1, T2, X2, Y2) ←\nMatchϕi(T2, X2, Y2, T1, X1, Y1). (i ∈ {1, 2})\nOldVersion R (T1, Z̄1) ← R ′(T1, Z̄1), R ′(T1, Z̄ ′ 1),\nZ̄1 Z̄ ′ 1, Z̄1 6= Z̄ ′ 1.\n← NotMatchϕi(T1, X1, Y1, T2, X2, Y2),\nnot OldVersion R (T1, X1, Y1),\nnot OldVersion R (T2, X2, Y2). (i ∈ {1, 2})\n3. R′(T1, X1, Y3) ← Matchϕ1(T1, X1, Y1, T2, X2, Y2),\nMB(Y1, Y2, Y3).\nR ′(T1, X1, Y3) ← Matchϕ2(T1, X1, Y1, T2, X2, Y2),\nMB(Y1, Y2, Y3).\n4. Prec(T1, X1, Y1, T2, X2, Y2, T1, X1, Y ′ 1 , T3, X3, Y3) ←\nMatchϕi(T1, X1, Y1, T2, X2, Y2),\nMatchϕj(T1, X1, Y ′ 1 , T3, X3, Y3),\nY1 Y ′ 1 , Y1 6= Y ′ 1 . (i, j ∈ {1, 2})\n5. Prec(T1, X1, Y1, T2, X2, Y2, T1, X1, Y1, T3, X3, Y3) ←\nMatchϕi(T1, X1, Y1, T2, X2, Y2),\nMatchϕj(T1, X1, Y1, T3, X3, Y3), MB(Y1, Y3, Y4),\nY1 6= Y4. (i, j ∈ {1, 2})\n6. Prec(T1, Z̄1, T2, Z̄2, T1, Z̄1, T2, Z̄2) ←\nMatchϕi(T1, Z̄1, T2, Z̄2). (i ∈ {1, 2})\n← Prec(T1, Z̄1, T2, Z̄2, T1, Z̄ ′ 1, T3, Z̄3),\nPrec(T1, Z̄ ′ 1, T3, Z̄3, T1, Z̄1, T2, Z̄2),\n(T1, Z̄1, T2, Z̄2) 6= (T1, Z̄ ′ 1, T3, Z̄3).\n← Prec(T1, Z̄1, T2, Z̄2, T1, Z̄ ′ 1, T3, Z̄3),\nPrec(T1, Z̄ ′ 1, T3, Z̄3, T1, Z̄ ′′ 1 , T4, Z̄4),\nnot Prec(T1, Z̄1, T2, Z̄2, T1, Z̄ ′′ 1 , T4, Z̄4).\n7. Rc(T1, X1, Y1) ← R ′(T1, X1, Y1),\nnot OldVersion R (T1, X1, Y1).\nThe program constraint under 2. (last in the list) ensures that all new, applicable matchings have to be eventually carried out. The last set of rules (one for each database predicate) collect the final, clean extensions of them. Program Π(D0,Σ) has two stable models, whose R\ncatoms are shown below: M1 = {..., R c(t1, a1, b12), R c(t2, a2, b12), R c(t3, a3, b3)},\nM2 = {..., R c(t1, a1, b123), R c(t2, a2, b123), R c(t3, a3, b23)}. From them we can read off the two clean instances D1, D ′ 2 forD0 that were obtained from the chase.\nThe cleaning program Π(D0,Σ) allows us to reason in the presence of uncertainty as represented by the possibly multiple clean instances. Actually, it holds that there is a one-to-one correspondence between C(D0,Σ) and the set SM (Π(D0,Σ)) of stable models of Π(D0,Σ). Furthermore, the program Π(D0,Σ) without its program constraints belongs to the class Datalog∨,not,s, the subclass of programs in Datalog∨,not that have stratified negation [Eiter and Gottlob 1995]. As a consequence, its stable models can be computed bottom-up by propagating data upwards from the underlying extensional database (that corresponds to the set of facts of the program), and making sure to minimize the selection of true atoms from the disjunctive heads. Since the latter introduces a form of non-determinism, a programmay have several stable models. If the program is nondisjunctive, i.e. belongs to the Datalognot,s, it has a single stable model that can be computed in polynomial time in the size of the extensional databaseD. The program constraints in Π(D0,Σ) make it unstratified [Gelfond and Kahl 2014]. However, this is not a crucial problem because they act as a filter, eliminating the models that make them true from the class of models computed with the bottom-up approach."
    }, {
      "heading" : "3 Relational MDs",
      "text" : "We now introduce a class of MDs that have found useful applications in blocking for learning a classifier for ER [Bahmani, Bertossi, and Vasiloglou 2015]. They allow bringing additional relational knowledge into the conditions of the MDs. Before doing so, notice that an explicit formulation of the MD in (1) in classical predicate logic is:2\nϕ : ∀t1t2 ∀x̄1x̄2 (R1(t1, x̄1) ∧R2(t2, x̄2) ∧∧\nj\nx j 1 ≈j x j 2 −→ y1 . = y2), (2)\nwith x j 1, y1 ∈ x̄1, x j 2, y2 ∈ x̄2. The ti are variables for tuple IDs. LHS(ϕ) and RHS(ϕ) denote the sets of atoms on the LHS and RHS of ϕ, respectively. AtomsR1(t1, x̄1) and R2(t2, x̄2) contain all the variables in theMD; and similarity and identity atoms involve one variable from each ofR1, R2. Now, relational MDs may have in their LHSs, in addition to the two leading atoms, as R1, R2 in (2), additional database atoms, frommore than one relation, that are used to give context to similarity atoms in the MD, and capture additional relational knowledge via additional conditions. Relational MDs extend “classical” MDs.\nExample 3. With predicates Author(AID ,Name, PTitle, ABlock), Paper(PID ,PTitle,Venue,PBlock) (with ID and block attributes), this MD, ϕ, is relational:\nAuthor (t1, x1, y1, bl1) ∧ Paper (t3, y ′ 1, z1, bl4) ∧ y1 ≈ y ′ 1 ∧\nAuthor(t2, x2, y2, bl2) ∧ Paper (t4, y ′ 2, z2, bl4) ∧ y2 ≈ y ′ 2 ∧\nx1 ≈ x2 ∧ y1 ≈ y2 −→ bl1 . = bl2,\n2Similarity symbols can be treated as regular, built-in, binary predicates, but the identity symbol, . =, would be non-classical.\nwith implicit quantifiers, and underlined leading atoms (they contain the identified variables on the RHS). It contains similarity comparisons involving attribute values for both relations Author and Paper. It specifies that when the Authortuple similarities on the LHS hold, and their papers are similar to those in corresponding Paper-tuples that are in the same block (an implicit similarity captured by the join variable bl4), then blocks bl1, bl2 have to be made identical. This blocking policy uses relational knowledge (the relationships between Author and Paper tuples), plus the blocking decisions already made about Paper tuples."
    }, {
      "heading" : "4 Single-Clean-Instance Classes",
      "text" : "First we introduce some notation. For an MD ϕ, ALHS(ϕ) denotes the set of (non-tid) attributes (with predicates) appearing in similarities in the LHS of ϕ (including equalities, implicit or not). Similarly, ARHS(ϕ) contains the attributes appearing in identities in the RHS. In Example 3: ALHS(ϕ) = {Author [Name], Author [PTitle], Paper [PTitle], Paper [PBlock ]}, ARHS(ϕ) = {Author [ABlock ]}.\nAs shown in [Bertossi, Kolahi and Lakshmanan 2012], for the classical case of similarity-preserving MDs (i.e. whose MFs satisfy a ≈A a ′ implies a ≈ mA(a ′, a′′)), the chase-procedure computes a single clean instance in polynomial time in the size of the initial instance. The same holds for the classical case of non-interacting MDs. Now, a set Σ of possibly relational MDs is non-interacting if there are no ϕ1, ϕ2 ∈ Σ (possibly the same), with ARHS(ϕ1) ∩ ALHS(ϕ2) 6= ∅. Relational similaritypreserving MDs are trivially defined by using similarity preserving MFs. Through simple changes in the proofs given in [Bertossi, Kolahi and Lakshmanan 2012] for classical similarity-preserving and non-interacting MDs, it is possible to prove that, for both classes, for a given initial instance D, there is a single resolved instance that can be computed in polynomial time in the size of D. We say that these classes of MDs have the single-clean instance property, in short, they are SCI.\nThere is another class of combinations of relational MDs Σ and initial instances D that lead to a single clean instance:3 That of similarity-free attribute intersection (SFAI) combinations (Σ, D).\nDefinition 1. Let Σ be a set of relational MDs and D an instance. The combination (Σ, D) has the SFAI property (or is SFAI) if, for every ϕ1, ϕ2 ∈ Σ (which could be the same) and attribute R[A] ∈ ARHS(ϕ1) ∩ ALHS(ϕ2), it holds: If S1, S2 ⊆ D with R(c̄) ∈ S1 ∩ S2, then LHS(ϕ1) is false in S1 or LHS(ϕ2) is false in S2. 4\nNon-interacting sets of MDs are trivially SFAI for every initial instance D. In general, different orders of MD enforcements may result in different clean instances, because tuple similarities may be broken during the chase with interacting MDs and nonsimilarity-preserving MFs, without reappearing again\n3More precisely, it is duplicate-free wrt. the MDs, i.e. no additional enforcements thereof are possible\n4We informally say that ϕ1 is not applicable in S1, etc.\n[Bertossi, Kolahi and Lakshmanan 2012]. With SFAI combinations, two similar tuples, i.e. with similar attribute values, in the original instance D -or becoming similar along a chase sequence- may have the similarities broken in a chase sequence, but they will reappear later on in the same and the other chase sequences. Thus, different orders of MD enforcements cannot lead in the end to different clean instances. Contrary to the syntactic class of non-interacting (relational) MDs and the MF-dependant class of similaritypreserving MDs, SFAI is a semantic class that depends on the initial instance (but not on subsequent instances obtained through the chase). Checking the SFAI property for (Σ, D) can be done by posing Boolean conjunctive queries (with similarity built-ins) toD; actually for each pair ϕ1, ϕ2 in Σ, a query, QAϕ1,ϕ2 , if A ∈ ARHS(ϕ1) ∩ ALHS(ϕ2), and a query,QBϕ2,ϕ1 , if B ∈ ARHS(ϕ2) ∩ ALHS(ϕ1). 5\nExample 4. (ex. 2 cont.) Consider the same classical MDs and MFs, but now with a1 ≈ a2, b3 ≈ b4, and new instance:\nR(D) A B t1 a1 b1 t2 a2 b2 t3 a3 b3 t4 a4 b4\nThe MDs are interacting, and both applicable on D, i.e. their LHSs are true. We can check the SFAI property for the\ncombination (Σ, D) posing the following, implicitly existentially quantified, Boolean conjunctive queries toD:6\nQR[B]ϕ1,ϕ2 : R(t1, x1, y1) ∧ R(t2, x2, y2) ∧ x1 ≈ x2 ∧\nR(t3, x3, y3) ∧ y2 ≈ y3,\nQR[B]ϕ2,ϕ2 : R(t1, x1, y1) ∧ R(t2, x2, y2) ∧ y1 ≈ y2 ∧\nR(t3, x3, y3) ∧ y2 ≈ y3.\nwhich take the value false in D. Then, (Σ, D) is SFAI. This is consistent with the easily verifiable observation that, no matter\nR(D′) A B t1 a1 b12 t2 a2 b12 t3 a3 b34 t4 a4 b34\nhow the MDs are applied, a single clean instance,D′ above, is always achieved.\nThe example shows that it is possible to decide in polynomial time in the size of D if a combination (Σ, D) is SFAI: The number of queries does not depend on D, and they can be answered in polynomial time in data. Furthermore, it is possible to prove from the definition and the chase that SFAI (sets of) MDs are also SCI. However, in Section 5 we will indirectly show that this holds, by presenting stratified Datalog programs that implicitly represent the chase procedure based on them. The SCI property follows also from this."
    }, {
      "heading" : "5 Datalog Programs for SRI Classes",
      "text" : "The general ASPs for classical MDs can be easily changed to deal with relational MDs, by including in the rule bodies the new relational atoms as extra conditions.\n5E.g. R [B] ≈ R [B] → R [A] . = R [A] , R [A] ≈ R [A] →\nR [B] . = R [B] give rise to two SFAI tests (two queries).\n6For each of the intersections: ARHS(ϕ1) ∩ ALHS(ϕ2) = {R[B]}, and ARHS(ϕ2) ∩ALHS(ϕ2) = {R[B]}.\nIt is possible to take a set of MDs of the three kinds introduced in Section 4, generate an ASP for them of the general form of Section 2, and next, appealing to a general semantic property in common for those three classes, automatically rewrite the program into a stratified Datalog program. The rewriting is based on the facts that: (a) We do not need rules or constraints for the Prec predicate, because imposing a linear order of matchings is not needed; basically all MDs can be applied in parallel. (b) For the same reason, we do not need disjunctive heads, as each applicable MD can be applied without affecting the results obtained by the applications of the others. That is, we do not have to withhold any matchings (via the NotMatch predicates). (c) Old versions of tuples can be used in future MDs enforcements without any undesirable impact on the result. In essence, the semantic property of the three classes, which can be expressed and used as a systematic rewriting mechanism of the general cleaning ASP, is that: When confronted with match or not match, we can safely match; and the matchings do not need to be linearly ordered. Also, old versions of tuples can be still used for matchings. The general transformation is illustrated by means of an example.\nExample 5. (ex. 4 cont.) The general cleaning program for Σ in Example 2 depends on the initial instance only through the program facts. Then, the same program can be used in Example 4, but with the facts corresponding to R(D0) replaced by those corresponding to R(D). Since (Σ, D) is SFAI, the cleaning program can be automatically rewritten into the following residual program (with enumeration as Example 2):\n1. R(t1, a1, b1). R(t2, a2, b2). R(t3, a3, b3). R(t4, a4, b4).\n2. Matchϕ1(T1, X1, Y1, T2, X2, Y2) ← R(T1, X1, Y1),\nR(T2, X2, Y2), X1 ≈ X2, Y1 6= Y2.\nMatchϕ2(T1, X1, Y1, T2, X2, Y2) ← R(T1, X1, Y1),\nR(T2, X2, Y2), Y1 ≈ Y2, Y1 6= Y2.\nOldVersion(T1, X1, Y1) ← R(T1, X1, Y1),\nR(T1, X1, Y ′ 1), Y1 Y ′ 1 , Y1 6= Y ′ 1 .\n3. R(T1, X1, Y3) ← Matchϕ1(T1, X1, Y1, T2, X2, Y2),\nMB(Y1, Y2, Y3).\nR(T1, X1, Y3) ← Matchϕ2(T1, X1, Y1, T2, X2, Y2),\nMB(Y1, Y2, Y3).\n7. Rc(T1, X1, Y1) ← R(T1, X1, Y1),\nnot OldVersion(T1, X1, Y1).\nThis program does not have disjunctive heads or program constraints. We still need the OldVersion predicate to collect (the final versions of) the tuples in a clean instance.\nThe general ASP programs of Section 2 can be run on ASP solvers, such as DLV [Leone et al. 2006; Bahmani et al. 2012]. However, the specialized stratified Datalog programs of this section can be run with implementations of Datalog. Actually, for their use in classification-based ER reported in [Bahmani, Bertossi, and Vasiloglou 2015], the programs were specified using LogicQL and run on top of the Datalog-supporting LogicBlox platform [Aref et al. 2015]."
    }, {
      "heading" : "6 Conclusions",
      "text" : "Matching dependencies (MDs) are an important addition to the declarative approaches to data cleaning, in particular, to the common and difficult problem of entity resolution (ER). We have shown that MDs can be extended to capture additional semantic knowledge, which is important in applications, in particular, to machine learning.\nComputing with MDs has a relatively high data complexity [Bertossi, Kolahi and Lakshmanan 2012], but some classes of MDs (possibly in combination with an instance) can be identified for which ER can be done in polynomial time in data. Even more, it is possible to automatically produce Datalog programs that can be used to do ER with them."
    } ],
    "references" : [ {
      "title" : "V",
      "author" : [ "S. Abiteboul", "R. Hull", "Vianu" ],
      "venue" : "Foundations of Databases. Addison-Wesley,",
      "citeRegEx" : "Abiteboul. Hull. and Vianu 1995",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Design and Implementation of the LogicBlox System",
      "author" : [ "Aref" ],
      "venue" : null,
      "citeRegEx" : "Aref,? \\Q2015\\E",
      "shortCiteRegEx" : "Aref",
      "year" : 2015
    }, {
      "title" : "Declarative Entity Resolution via Matching Dependencies and Answer Set Programs",
      "author" : [ "Bahmani" ],
      "venue" : "Proc. KR’12,",
      "citeRegEx" : "Bahmani,? \\Q2012\\E",
      "shortCiteRegEx" : "Bahmani",
      "year" : 2012
    }, {
      "title" : "ERBlox: Combining Matching Dependencies with Machine Learning for Entity Resolution",
      "author" : [ "Bahmani", "Bertossi", "Z. Vasiloglou 2015] Bahmani", "L. Bertossi", "N. Vasiloglou" ],
      "venue" : "Int. J. of Approximate Reasoning,",
      "citeRegEx" : "Bahmani et al\\.,? \\Q2017\\E",
      "shortCiteRegEx" : "Bahmani et al\\.",
      "year" : 2017
    }, {
      "title" : "Generic and Declarative Approaches to Data Quality Management",
      "author" : [ "Bertossi", "L. Bravo 2013] Bertossi", "L. Bravo" ],
      "venue" : "In S. Sadiq (ed.),Handbook of Data Quality - Research and Practice,",
      "citeRegEx" : "Bertossi et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Bertossi et al\\.",
      "year" : 2013
    }, {
      "title" : "Data Cleaning and Query Answering with Matching Dependencies and Matching Functions",
      "author" : [ "Bertossi", "Kolahi", "L. Lakshmanan 2012] Bertossi", "S. Kolahi", "L. Lakshmanan" ],
      "venue" : "Theory of Computing Systems,",
      "citeRegEx" : "Bertossi et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Bertossi et al\\.",
      "year" : 2013
    }, {
      "title" : "Collective Entity Resolution in Relational Data",
      "author" : [ "Bhattacharya", "I. Getoor 2007] Bhattacharya", "L. Getoor" ],
      "venue" : "TKDD,",
      "citeRegEx" : "Bhattacharya et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Bhattacharya et al\\.",
      "year" : 2007
    }, {
      "title" : "Answer Set Programming at a Glance",
      "author" : [ "Brewka", "Eiter", "G. Truszczynski 2011] Brewka", "T. Eiter", "M. Truszczynski" ],
      "venue" : "Comm. of the ACM,",
      "citeRegEx" : "Brewka et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Brewka et al\\.",
      "year" : 2011
    }, {
      "title" : "L",
      "author" : [ "S. Ceri", "G. Gottlob", "Tanca" ],
      "venue" : "Logic Programming and Databases. Springer,",
      "citeRegEx" : "Ceri. Gottlob and Tanca 1989",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "On the Computational Cost of Disjunctive Logic Programming: Propositional Case",
      "author" : [ "Eiter", "T. Gottlob 1995] Eiter", "G. Gottlob" ],
      "venue" : "Annals of Math. and Artif. Intell.,",
      "citeRegEx" : "Eiter et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 1995
    }, {
      "title" : "Duplicate Record Detection: A Survey",
      "author" : [ "Elmagarmid", "Ipeirotis", "A. Verykios 2007] Elmagarmid", "P. Ipeirotis", "V. Verykios" ],
      "venue" : "IEEE Transactions in Knowledge and Data Engineering,",
      "citeRegEx" : "Elmagarmid et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Elmagarmid et al\\.",
      "year" : 2007
    }, {
      "title" : "Dependencies Revisited for Improving Data Quality",
      "author" : [ "W. Fan" ],
      "venue" : "Proc. PODS",
      "citeRegEx" : "Fan,? \\Q2008\\E",
      "shortCiteRegEx" : "Fan",
      "year" : 2008
    }, {
      "title" : "Classical Negation in Logic Programs and Disjunctive Databases",
      "author" : [ "Gelfond", "M. Lifschitz 1991] Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing,",
      "citeRegEx" : "Gelfond et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Gelfond et al\\.",
      "year" : 1991
    }, {
      "title" : "and the Design of Intelligent Agents",
      "author" : [ "M. Gelfond", "Kahl", "J. Knowledge Representation", "Reasoning" ],
      "venue" : "Cambridge U. Press,",
      "citeRegEx" : "Gelfond and Kahl 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "The DLV System for Knowledge Representation and Reasoning",
      "author" : [ "Leone" ],
      "venue" : "ACM Trans. Comput. Log.,",
      "citeRegEx" : "Leone,? \\Q2006\\E",
      "shortCiteRegEx" : "Leone",
      "year" : 2006
    }, {
      "title" : "Entity Resolution with Iterative Blocking",
      "author" : [ "Whang" ],
      "venue" : "Proc. Sigmod,",
      "citeRegEx" : "Whang,? \\Q2009\\E",
      "shortCiteRegEx" : "Whang",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 11,
      "context" : "In this direction, matching dependencies (MDs) have been proposed [Fan 2008; Fan et al. 2009].",
      "startOffset" : 66,
      "endOffset" : 93
    }, {
      "referenceID" : 0,
      "context" : "For all these classes, we show that the general ASP mentioned above can be automatically and syntactically transformed into an equivalent stratified Datalog program with the single clean instance as its standard model, which can be computed bottom-up from D in polynomial time in the size of D [Abiteboul, Hull, and Vianu 1995; Ceri, Gottlob and Tanca 1989].",
      "startOffset" : 294,
      "endOffset" : 357
    }, {
      "referenceID" : 8,
      "context" : "For all these classes, we show that the general ASP mentioned above can be automatically and syntactically transformed into an equivalent stratified Datalog program with the single clean instance as its standard model, which can be computed bottom-up from D in polynomial time in the size of D [Abiteboul, Hull, and Vianu 1995; Ceri, Gottlob and Tanca 1989].",
      "startOffset" : 294,
      "endOffset" : 357
    }, {
      "referenceID" : 0,
      "context" : "We keep doing this on the resulting instance, in a chase-like procedure [Abiteboul, Hull, and Vianu 1995], until a stable instance is reached (cf.",
      "startOffset" : 72,
      "endOffset" : 105
    }, {
      "referenceID" : 13,
      "context" : "The program constraints in Π(D0,Σ) make it unstratified [Gelfond and Kahl 2014].",
      "startOffset" : 56,
      "endOffset" : 79
    } ],
    "year" : 2017,
    "abstractText" : "Entity resolution (ER) is about identifying and merging records in a database that represent the same real-world entity. Matching dependencies (MDs) have been introduced and investigated as declarative rules that specify ER policies. An ER process induced by MDs over a dirty instance leads to multiple clean instances, in general. General answer sets programs have been proposed to specify the MD-based cleaning task and its results. In this work, we extend MDs to relational MDs, which capture more application semantics, and identify classes of relational MDs for which the general ASP can be automatically rewritten into a stratified Datalog program, with the single clean instance as its standard model.",
    "creator" : "LaTeX with hyperref package"
  }
}