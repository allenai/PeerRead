{
  "name" : "1703.10316.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Eicient Parallel Translating Embedding For Knowledge Graphs",
    "authors" : [ "Denghui Zhang", "Manling Li", "Yantao Jia", "Yuanzhuo Wang", "Xueqi Cheng" ],
    "emails" : [ "permissions@acm.org." ],
    "sections" : [ {
      "heading" : null,
      "text" : "CCS CONCEPTS •Computing methodologies →Reasoning about belief and knowledge;\nKEYWORDS Knowledge Graph Embedding, Translation-based, Parallel ACM Reference format: Denghui Zhang, Manling Li, Yantao Jia, Yuanzhuo Wang, Xueqi Cheng. 2017. E cient Parallel Translating Embedding For Knowledge Graphs . In Proceedings of WI ’17, Leipzig, Germany, August 23-26, 2017, 8 pages. DOI: 10.1145/3106426.3106447"
    }, {
      "heading" : "1 INTRODUCTION",
      "text" : "Knowledge graphs are structured graphs with various entities as nodes and relations as edges. ey are usually in form of RDF-style triples (h, r , t), where h represents a head entity, t a tail entity, and r the relation between them. In the past decades, a quantity of large scale knowledge graphs have sprung up, e.g., Freebase [2], WordNet [14], YAGO [12], OpenKN [7], and have played a pivotal role in supporting many applications, such as link prediction, question answering, etc. Although these knowledge graphs are very large, i.e., usually containing thousands of relation types, millions of\nPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro t or commercial advantage and that copies bear this notice and the full citation on the rst page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permi ed. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci c permission and/or a fee. Request permissions from permissions@acm.org. WI ’17, Leipzig, Germany © 2017 ACM. 978-1-4503-4951-2/17/08. . .$15.00 DOI: 10.1145/3106426.3106447\nentities and billions of triples, they are still far from complete. As a result, knowledge graph completion (KGC) has been payed much a ention to, which mainly aims to predict missing relations between entities under the supervision of existing triples.\nRecent years have witnessed great advances of translating embedding methods to tackle KGC problem. e methods represent entities and relations as the embedding vectors by regarding relations as translations from head entities to tail entities, such as TransE [3], TransH [19], TransR[11], etc. However, the training procedure is time consuming, since they all employ stochastic gradient descent (SGD) to optimize a translation-based loss function, which may require days to converge for large knowledge graphs.\nFor instance, Table11 shows the complexity of typical translating embedding methods, where Ttotal stands for the total training time with Tepoch for the time of each epoch, and one epoch is a single pass over all triples. ne , nr and nt are the number of entities, relations and triples in the knowledge graph respectively. d is the embedding dimension which is the same for entities and relations in this case, and ep is the minimum epochs which used to be set to 1000. It can be seen that the time complexity of TransE is proportional to nt , d and ep. When d is 100 and ep is 1000, it will take 78 minutes for TransE to learn the embeddings of FB15k2, which is a subset of Freebase with 483,142 training triples, and has been widely used as experimental dataset in knowledge graph embedding methods [3, 8, 11, 19]. Nevertheless, Freebase-rdf-latest3 is the latest public available data dump of Freebase with 1.9 billion triples, which results in approximately 3932 times the training time, namely, 212 days. Furthermore, the whole Freebase contains over 3 billion triples4, and it will take about 357 days to learn the embeddings of it. Despite its large size, Freebase still su ers from data incomplete problem, e.g., 75% persons do not have nationalities in Freebase [5]. On top of that, most improved variants of TransE employ more complex loss function to be er train the embedding vectors, thus they possess higher time complexity or model complexity, and the training time of them will be even unbearable. For example, it will take more than 59 years for Freebase-rdf-latest when employing TransR, which is one of the typical improved variants and achieves far be er performance than TransE.\nere have been a empts to resolve the e ciency issue of translating embedding methods for knowledge graphs. Pasquale[15] proposed TransE-AdaGrad to speed up the training process by leveraging adaptive learning rates. However, TransE-AdaGrad essentially reduces the number of epochs to converge, and still can\n1 e experiments are conducted on a dual Intel Xeon E5-2640 CPUs (10 cores each × 2 hyperthreading, running at 2.4 GHz) machine with 128GB of RAM. e kernel is Red Hat 4.4.7 2h ps://everest.hds.utc.fr/lib/exe/fetch.php?media=en: 15k.tgz 3h p://commondatastorage.googleapis.com/freebase-public/ 4h ps://github.com/nchah/freebase-triples, there are 3,197,653,841 triples in Freebase on May 2, 2016\nar X\niv :1\n70 3.\n10 31\n6v 2\n[ cs\n.A I]\n1 4\nA ug\n2 01\n7\nnot do well with large scale knowledge graphs. In fact, with more and more computation resources available, it is natural and more e ective to parallel these embedding methods, which will lead to signi cant improvement in training e ciency and can scale to quite large knowledge graphs if given su cient hardware resources.\nHowever, it is challenging to parallel the translating embedding methods, since the training processes mainly employ stochastic gradient descent algorithm (SGD) or the variants of it. SGD is inherently sequential, as a dependence exists between each iteration. Parallelizing translating embedding methods straightforwardly will result in collisions between di erent processors. For instance, an entity embedding vector is updated by two processors at the same time, and the gradients calculated by these processors are di erent. In this case, the diverse gradients are called collisions. To avoid collisions, some methods [9] lock embedding vectors, which will slow the training process greatly as there are so many vectors. On the contrary, updating vectors without locks leads to high e ciency, but should be based on speci c assumptions [4, 16]. Since the lockfree training process may result in poor convergence if adopting suboptimal strategy to resolve collisions.\nOur key observation of translating embedding methods is that the update performed in one iteration of SGD is based on only one triple and its corrupted sample, which is not necessarily bound up with other embedding vectors. is gives us chance to learn the embedding vectors in parallel without being locked. In this article, we analyze the distinguished data structure of knowledge graphs, and propose an e cient parallel framework for translating embedding methods, called ParTrans-X. It enables translating methods to update the embedding vectors e ciently in shared memory without locks. us the training process is greatly speeded up with multi-processors, which can be more than an order of magnitude faster without lowering learning quality.\ne contribution of this aritcle is: 1. We explore the law of collisions along with increasing number of processors, by modelling the training data of knowledge graph into hypergraphs.\n2. We propose ParTrans-X framework to train translating methods e ciently in parallel. It utilizes the training data sparsity of large scale knowledge graphs, and can be easily applied to many translating embedding methods.\n3. We apply ParTrans-X to typical translating embedding methods, i.e., TransE [3], TransH [19], and a more e cient variant TransE-AdaGrad, and experiments validate the e ectiveness of ParTrans-X on two widely used datasets.\ne paper is organized as follows. Related work is in Sec.2. e collision formulation is introduced in Sec.3 and ParTrans-X is proposed based on it in Sec.4. en, experiments demonstrate training e ciency of ParTrans-X in Sec.5, with conclusions in Sec.6."
    }, {
      "heading" : "2 RELATEDWORK",
      "text" : "In recent years, translating embedding methods have played a pivotal role in Knowledge Graph Completion, which usually employ stochastic gradient descent algorithm to optimize a translationbased loss function, i.e.,\nL = ∑ (h,r,t ) ∑ (h′,r,t ′) max [ 0, fr (h, t) +M − fr (h′, t ′) ] , (1)\nwhere (h, r , t) represents the positive triple that exists in the knowledge graph, while (h′, r , t ′) stands for the negative triple that is not in the knowledge graph. max [0, ·] is the hinge loss , and M is the margin between positive and negative triples. fr (h, t) is the score function to determine whether the triple (h, r , t) should exist in the knowledge graph, which varies from di erent translating embedding methods.\nA signi cant work is TransE [3], which heralds the start of translating embedding methods. It looks upon a triple (h, r , t) as a translation from the head entity h to the tail entity t , i.e., h + r ≈ t, and the score function is fr (h, t) = | |h+r−t| |, where | | · | | represents L1-similarity or L2-similarity. e boldface suggests the vectors in the embedding space, namely, h, t ∈ Rd , r ∈ Rd , where d = de = dr is the dimension of embedding space, de the dimension for entities and dr for relations. Moreover, TransH [19] assumes that it is the projections of entities to a relation-speci c hyperplane that satisfy the translation constraint, i.e., fr (h, t) = | |h⊥ + r − t⊥ | |, where h⊥ = h − w>r hwr and t⊥ = t − w>r twr, with wr ∈ Rde as the normal vector of the hyperplane related to r . Furthermore, TransR [11] employs rotation transformation to project the entities to a relation-speci c space, i.e., fr (h, t) = | |hr+r− tr | |, where hr = Mrh and tr = Mrt, and Mr ∈ Rdr×de is the projection matrix relation to r . Some works also involves more information to be er embedding, e.g., paths [10], margins [8].\nAlthough this category of methods achieve the state-of-the-art results, the main limitation is the computationally expensive training process when facing large scale knowledge graphs. Recently, a method TransE-AdaGrad [15] was proposed to reduce the training time of TransE by employing AdaGrad [6], an variant of SGD, to adaptively modify the learning rate. Although the training time has been reduced greatly, there is still some way to go when facing large scale knowledge graphs. With the computation resources greatly enriched, training in parallel seems to be a more reliable way to relieve this issue. Actually, there are some works, e.g., [18], to parallel some graph computation paradigms, such as online query processing, o ine analytics, etc. Nevertheless, it is not easy to train translating embedding methods in parallel, since the main optimation algorithm SGD is born to run in sequence. e major obstacle to parallel SGD is the collisions between updates of different processors for the same parameter [17], to overcome which there are two main brunches of methods.\ne rst brunch is to design a strategy to resolve collisions according to speci c data structure. For example, Hogwild! [16] is a lock-free scheme works well for sparse data, which means that there is only a small part of parameters to update by each iteration of SGD. It has been proved that processors are unlikely to overwrite each other’s progress, and the method can achieve a nearly optimal rate of convergence. While the second brunch is to split the training data to to reduce collisions. Downpour SGD [4] mainly employ DistBelief [4] framework, which divides the training data into a number of subsets, then the model replicas run independently on each of these subsets, and do not communicate with each other. Inspired by this, TensorFlow [1] splits a computation graph into a subgraph for every worker and communication takes place using Send/Receive node pairs. Motivated by training large-scale convolutional neural networks for image classi cation, Elastic Averaging SGD (EASGD) [20] reduces the amount of communication between local workers and the master to allow the parameters of local workers to uctuate further from the center ones. ere are also works to improve the performance in parallel se ings, e.g., Delay-tolerant Algorithms for SGD [13] adapts not only to the sequence of gradients, but also to the precise update delays that occur, inspired by AdaGrad.\nHowever, these parallel framework are based on speci c assumptions, and can not directly apply to translating embedding models without exploring distinguished data structures of knowledge graphs. erefore, we shall propose a parallel framework for translating embedding models, called ParTrans-X, as knowledge graphs are mainly in form of triples, and trained triple by triple, it will lead to particular parallel framework."
    }, {
      "heading" : "3 LAW OF COLLISIONS EMERGING IN KG",
      "text" : "As mentioned previously, there may exist collisions between processors when they update the same embedding vector, which ends up being one of the most challenging aspects of parallelizing translating embedding methods. Hence, we explore the law of collisions emerging in this section. At rst we formulate the training data of knowledge graphs into hypergraphs. en the collisions in training process are further discussed based on this formulation."
    }, {
      "heading" : "3.1 Hypergraph Formulation",
      "text" : "Firstly, we model the knowledge graph formally as G = (E,R,T ), where E is the set of entities with R the set of relations, and T is the set of triples (h, r , t), in which h, t ∈ E and r ∈ R. e cardinalities of E, R and T are ne , nr and n respectively. In this graph, nodes are entities, and edges are triples that connecting nodes with a distinguished relation. For example, the knowledge graph shown in Figure1(a), where black nodes stand for the entities in knowledge graphs and lines for relations, can be represented as G = (E,R,T ), where E = {e1, e2, e3, e4, e5}, R = {r1, r1, r3} and T = {(e1, r2, e4), (e1, r1, e3), (e2, r3, e5), (e4, r3, e2)}. In this case, ne = 5, nr = 3 and n = 4.\nSecondly, the training data of knowledge graphs can be looked upon as hypergraphs. Recall the loss function of translating embedding methods in Eq.(1), which means in one iteration of SGD, only one positive triple (h, r , t) and one negative triple (h′, r , t ′) are concerned. To be more clear, the data used in one iteration, i.e., [(h, r , t), (h′, r , t ′)], is called a sample. Note that (h′, r , t ′) is\nconstructed by substituting one entity h′ ∈ E or t ′ ∈ E for h or t respectively, contributing to a corrupted triple (h′, r , t) or (h, r , t ′), which is just simply denoted by (h′, r , t ′) following [3]. Consequently, a sample corresponding to three entities, i.e., h, t ,h′or t ′, and one relation r . As a result, the training data can be formulated in to a 4-uniform hypergraph, in which all the hyperedges have the same cardinality 4. In this hypergraph, nodes are entities and relations, and edges are training samples containing 4 nodes, i.e., three entities and one relation. More formally,\nDe nition 3.1. e training data to embed the knowledge graph G = (E,R,T ) by translating embedding methods is organized as a 4-uniform hypergraph H = (V , S), where V = {E ∪ R} is the set of entities or relations, and S is the set of training samples s , where s = {h, r , t ,h′(or t ′) : h, r , t ,h′, t ′ ∈ E, r ∈ R}.\nFor example, the hypergraph in Figure1(b) is one of the hypergraphs generated by Figure1(a), where black nodes are entities and colored nodes are relations, and the colored blocks represent hyperedges. Here, di erent colors are related to di erent relations. For instance, for triple (e1, r1, e3), the negative triple sampled in Figure1(b) is (e1, r1, e2), which contributes to a sample s1 = {e1, r1,e2,e3}, thus the hyperedge colored by red contains e1, e2, e3 and r1. Note that many other negative triples can be constucted, e.g., (e1, r1, e5) for triple (e1, r1, e3), and the hypergraph generated in Figure1(b) is just an example. Similarly, the other samples in Figure1(b) are s2 = {e1, r2, e4, e5}, s3 = {e2, r3, e3, e5} and s4 = {e4, r3, e2, e3}.\nTo be er analyze the collisions between processors, we de ne the following statistics of the hypergraph H . Given a hyperedge s ,\nσ (s) = {s ′ : ∃r ∈ s ∩ s ′, r ∈ R} (2) denotes the set of hyperedges containing the same relations with hyperedge s .\nσ̂ = max s ∈S |σ (s)| (3)\ndenotes the maximal number of hyperedges containing same relations, where | · | denotes the cardinality.\nρ(s) = {s ′ : ∃e ∈ s ∩ s ′, e ∈ E} (4) denotes the set of hyperedges containing one or more same entities with hyperedge s .\nρ̂ := max s ∈S |ρ(s)|. (5)\ndenotes the maximal number of hyperedges containing same entities, where | · | denotes the cardinality the same as before."
    }, {
      "heading" : "3.2 Collision Formulation",
      "text" : "In this section, we will verify that it is highly possible that few collisions happen when training byp processors for large and sparse knowledge graphs. LetXsamp represent the event that p processors select p di erent samples. Xr el represents the event that there are collisions between relations, i.e., di erent processors updates a same relation vector, andXent between entities similarly. e veri cation is decomposed into two steps, 1) to prove it is quite likely that the processors handle di erent samples, i.e., P(Xsamp = 1) ≈ 1, which is the prerequisite to no collisions; 2) to prove it is unlikely that these di erent samples correspond to the same relations or entities, i.e., P(Xr el = 0) ≈ 1 and P(Xent = 0) ≈ 1.\nSupposing that for embedding methods and the knowledge graph, the training samples S = {s1, s2, . . . , si , . . . , sn } of size n is drawn independent and identically distributed (i.e., i.i.d.) from some unknown distribution D. erefore, the probability of si being selected Pi is supposed to be\nPi = 1 n . (6)\nMoreover, according to i.i.d., it is reasonable to assume that the sample selecting process by p processors is an observation from a Multinomial Distribution, i.e., selecting one sample from n samples and repeated p times. Let xi denote the number of processors that select si during the same iteration of SGD, then the possibility of si being selected by c1 processors, . . ., sne being selected by cne processors is as follows,\nP(x1 = c1, ...,xne = cne ) = p! c1!c2! · · · cne ! Pc11 ...P cne ne , ne∑ i=1 ci = p 0, otherwise (7)\nwhere ∑ne i=1 ci = p indicates that there are p and only p samples being selected in the same iteration of SGD.\nTheorem 3.2. For a knowledge graph with n triples and training by p processors in parallel, when n is large and p is relatively small, the possibility that p processors select p di erent samples is\nP(Xsamp = 1) ≈ 1 (8) with probability at least γ , where\nγ = p−1∏ i=1 (1 − i n ). (9)\nProof. Provided that samples selected by processors are di erent, it can be easily derived that ∀si ∈ S,xi ≤ 1. en there are only (n p )\nsampling circumstances satisfying no collisions between samples, where p distinct samples are selected once, and other n−p samples are not selected, e.g., x1 = 1,x2 = 1, · · · ,xp = 1,xp+1 = 0, · · · ,xn = 0. erefore, according to Eq.(7) and Eq.(6),\nP(Xsamp = 1) = ( n\np ) p! p∏ i=1 1! p∏ i=1 (Pi )1 = n! (n − p)! ( 1 n )p\n= n(n − 1)(n − 2) · · · (n − p + 1)\nnp\n= (1 − 1 n )(1 − 2 n ) · · · (1 − p − 1 n )\n= p−1∏ i=1 (1 − i n )\nWhen n is large and p is relatively small, P(Xsamp = 1) ≈ 1.\nTheorem 3.3. For a knowledge graph with n triples and training in p processors in parallel, when σ̂n is relatively small and p < n σ̂ + 1, we have the possibility of no relation in a collision is\nP(Xr el = 0) ≈ 1 (10)\nwith probability at least γ , where\nγ = p−1∏ i=1 (1 − iσ̂ n ). (11)\nProof. Given that p processors select p di erent samples, the posibility of relations in a collision can be deduced according to conditional probability as follows,\nP(Xr el = 0) = P(Xr el = 0|Xsamp = 1) · P(Xsamp = 1), (12)\nwhere P(Xr el = 0|Xsamp = 1) is the possibility of p samples containing distinct relations being selected, which is supposed to be similar to sampling without replacement. More precisely, assuming a sample s is selected randomly, then the next sample selected s ′ should be from S −σ (s), and the third sample s ′′ should be selected from in S − σ (s) ∪ σ (s ′). Accordingly, P(Xr el = 0|Xsamp = 1) is deduced as follows when p < nσ̂ + 1 is satis ed,\nP(Xr el = 0|Xsamp = 1) = ∑\ns1,s2, ...,sp ∈S\n1 n · |S − σ (s1)| n − 1 · |S − σ (s1) ∪ σ (s2)| n − 2 . . .\n|S − σ (s1) ∪ σ (s2) ∪ · · · ∪ σ (sp−1)| n − (p − 1)\n≥ ∑\ns1,s2, ...,sp ∈S\n1 n · n − σ̂ n − 1 · n − 2σ̂ n − 2 . . . n − (p − 1)σ̂ n − (p − 1)\n= (1 − σ̂ − 1 n − 1 )(1 − 2(σ̂ − 1) n − 2 ) · · · (1 − (p − 1)(σ̂ − 1) n − (p − 1) )\n= p−1∏ i=1 (1 − i(σ̂ − 1) n − i )\nBy Eq.(12), the possibility of no collisions between relations in di erent processors is\nP(Xr el = 0) = p−1∏ i=1 (1 − i(σ̂ − 1) n − i ) · p−1∏ i=1 (1 − i n ) = p−1∏ i=1 (1 − iσ̂ n ). (13)\nNote that p > nσ̂ + 1 results in 1 − (p−1)(σ̂−1) n−(p−1) < 0, which means σ̂ is so large that one or more processors will de nitely select the same relation among p processors, namely, P(Xr el = 0) = 0. Furthermore, when σ̂n is relatively small, P(Xr el = 0) ≈ 1.\nSimilarly, the possibility of no entities in a collision can be derived as follows, and no more tautology here due to the limitation of length.\nTheorem 3.4. For a knowledge graph with n triples and training in p processors in parallel, when ρ̂n is relatively small and p < n ρ̂ + 1, the possibility of no collisions between entities is\nP(Xent = 0) ≈ 1 (14) with probability at least γ , where\nγ = p−1∏ i=1 (1 − i ρ̂ n ). (15)\nIt is veri ed in eorem3.2, eorem3.3 and eorem3.4 that if n is large and σ̂ and ρ̂ are relatively small, i.e., the knowledge graph is large and sparse, the number of processors p can be very large with supportable collisions, which enables the training process to run in parallel. Motivated by this, we de ne sparsity of training data in a knowledge graph by min( σ̂n , ρ̂ n ). e smaller its value is, the more processors can be used to parallel the training process. Actually, it is the large and sparse knowledge graphs that are in dire need of parallel translating embedding methods. Since they are far from completion, but are too large to train in serial. Besides, since σ̂ and ρ̂ is deduced by the worst case, it is reasonable to assume that the average σ̄ and ρ̄ can be er re ect the general structures in knowledge graphs, and the collisions will be less in practice. As a result, we suppose that it would still work well if the average σ̄ and ρ̄ are relatively small, as a few collisions will not a ect the consistency."
    }, {
      "heading" : "3.3 Special Insights on Parallelizing TransE",
      "text" : "ere is an interesting nding that TransE can be further parallelized than other translating embedding methods, since there are less collisions due to the distinguished score function fr (h, t) = | |h+r− t| |. More precisely, the gradient calculation of TransE when using L2-similarity is as follows,\nhk := hk − η · 2(hk + rk − tk ), h′k := h′k + η · 2(h′k + r′k − t′k ) rk := rk − η · 2(hk + rk − tk ), rk := rk + η · 2(h′k + r′k − t′k ) tk := tk + η · 2(hk + rk − tk ), t′k := t′k − η · 2(h′k + r′k − t′k )\n(16)\nwhere hk represents the k-th dimension of embedding vector h, k ∈ {0, 1, · · · ,d}, and d is the dimension of embedding space. It can be seen that in TransE, the gradient of each dimension is independent of other dimensions, which means that the collisions between di erent dimensions of the same embedding vector will not disturb each other. at is to say, only the collisions between the same dimension of the same embedding vector will ma er in the training process of TransE.\nFor example, Figure2 shows the updating of h by two processors (Processor1 and Processor2) at the same time, where ∇k is the gradient of hk calculated by Processor1, and ∇′k by Processor2. Normally, when Processor2 calculates the gradient ∇′k , the whole embedding vector h will be involved, which is half updated by Processor1. Obviously, this will result in training errors. On the contrary, if it is the training process of TransE in Figure2, the\ncalculation of ∇′k by Processor2 only concerns the k-th dimension hk . As a result, there will no disturbance between Processor1 and Processor2, as long as the two processors are not performing update to the same dimension of the same embedding vector.\nConsequently, the possibility of collisions emerging is greatly decreased for TransE. Since not only the entities or relations are the same one, but also the dimensions being updated are the same. Namely, the maximal degree of parallelism is far larger than other translating embedding methods. is indicates that parallelizing without locks is ideally situated for TransE, and may scale well to extremely large knowledge graphs by given su cient computation resources."
    }, {
      "heading" : "4 THE PARTRANS-X FRAMEWORK",
      "text" : "Inspired by the ndings that collisions between processors are negligible when a knowledge graph is large and sparse, a parallel framework for these methods is designed, called ParTrans-X, and we will describe it in detail in this section."
    }, {
      "heading" : "4.1 Framework Description",
      "text" : "e pseudocode for implementation of ParTrans-X is shown in Algorithm 1. As the embedding vectors are updated frequently, they are stored in shared memory and every processors can perform updates to them freely.\ne training process of ParTrans-X starts with initializing the embedding vectors according to Uniform or Bernoulli Distribution, where no parallel section is needed since it takes constant time. However we can parallel the learning process of each epoch, which is the most time consuming part. Running by p processors in parallel can decrease the training epochs by p times, i.e., the parallel training epoch is ep′ = epp . To do this, we rst determine the random sampling seed seed[i] by calling SEED RAND for the i-th processor. e random sampling seeds di er from each other to avoid same pseudo-random sequence for di erent processors. en, each processor performs embedding learning procedure epoch by epoch asynchronously (lines 5-12). One epoch is a loop over all triples. Each loop is done by rstly normalizing the entity embedding vectors following [3]. en a positive triple P[i](j) = (h, r , t) is sampled from shared memory, where i means that the current processor is i-th processor, and superscript j stands for j-th epoch. According to P[i](j), a negative triple N [i](j) = (h′, r , t ′) is generated by sampling a corrupted entity h′ (or t ′) from shared memory, where i and j are the same as before. at is to say, a sample S[i](j)\nis constructed by P[i](j) and N [i](j), which then be used to calculate the gradient ∇[fr (h, t)+M − fr (h′, t ′)] according to Eq.(1), and update the embeddings of entities and relations (h, r , t ,h′, t ′)(j+1) ← (h, r , t ,h′, t ′)(j) − η∇[i](j).\nAlgorithm 1 ParTrans-X Require:\nTraining triples T = {(h, r , t)}, entities and relations set E and R, embedding dimension d , margin M , training epochs ep, the number of processors p;\nEnsure: Embeddings of entities and relations;\n1: Initialize r ∈ R and e ∈ E by uniform distribution and persist them in the shared memory 2: for i ← 0 to p do 3: ep′ ← epp . In Parallel 4: seed[i] ← SEED RAND(i) 5: for j ← 0 to ep′ do 6: loop 7: e := e| |e | | for each entity e ∈ E 8: P[i](j) ← SAMPLE(T , seed[i]) 9: N [i](j) ← SAMPLE NEG(P[i](j),T ,E, seed[i])\n10: S[i](j) ← [ P[i](j),N [i](j) ] 11: ∇[i](j) ← ∇[fr (h, t) + M − fr (h′, t ′)], where h, r , t ,h′, t ′ ∈ S[i](j) 12: (h, r , t ,h′, t ′)(j+1) ← (h, r , t ,h′, t ′)(j) − η∇[i](j) 13: end loop 14: end for 15: end for 16: Generate embeddings of E and R a er all processors nish"
    }, {
      "heading" : "4.2 Application to Typical translating embedding Methods",
      "text" : "e framework can be applied to many translating embedding methods, which employ SGD or its variants to optimize the hinge loss with similar algorithm framework, and are only di erent in the score function fr (h, t) as mentioned in Sec.2, e.g., TransE, TransH and so on. Hence, the parallel algorithm of them can be obtained by applying the corresponding score function in Lines 11-12 of the pseudocode in Algorithm 1.\nFor example, for TransE, the gradient updating procedure in Lines 11 is performed according to Eq.(16). For TransH, which employs the score function fr (h, t) = | |h⊥ + r − t⊥ | |, the gradient updating procedure of h in Lines 11 is as follows,\nhk := hk − η · 2 [ (hk −wr>hwrk ) + rk − (tk −wr>twrk ) ] .\n(17)\nNamely, ParTrans-X has the exibility to parallel many translating embedding methods, since they possess similar training process.\nMoreover, ParTrans-X can be directly applied to the improved variantTransE-AdaGrad, since the training data sparsity of knowledge graph still holds. In one iteration of AdaGrad, it updates the embedding vectors according to the gradient from the previous iteration. Highly similar to SGD, AdaGrad can be easily parallelled\nusing our framework by only performing a learning rate calculation procedure during the gradient update procedure, i.e., Line 12 of the pseudocode in Algorithm 1. For example, to parallel TransEAdaGrad, the learning rate is determined adaptively by adding\nη(j) := ∇(j)√∑j\nk=1(∇ (k ))2\nη∗ (18)\nbefore Line 12 in Algorithm 1, where j is the current epoch, with η(j) the learning rate of j-th epoch. ∇(k ),k < j represents all the previous gradient before j-th epoch. η∗ is the initial learning rate."
    }, {
      "heading" : "5 EXPERIMENT",
      "text" : "Firstly, we apply ParTrans-X to TransE, TransH and TransE-Adagrad in Sec.5.1. In Sec.5.2, experiment results demonstrate excessive decline in training time by ParTrans-X, with scaling performance along with increasing number of processors shown in Sec.5.3."
    }, {
      "heading" : "5.1 Experimental Settings",
      "text" : "e datasets employed are two representative datasets WN18 and FB15k, which are subsets of well-known knowledge graphs WordNet and Freebase respectively, and have been widely used by translating embedding methods [3, 8, 11, 19]. Table2 shows the statistics of them. Without loss of generality, ρ̄n and σ̄ n are also shown, and they are both small on WN18 and FB15k. Furthermore, it can be seen that the two datasets possess di erent characteristics. Namely, WN18 possesses only 18 relations, which results in large possibility of collisions between relations. On the contrary, FB15k is less unbalanced in the number of entities and relations.\nTo tackle the KGC problem, experiments are conducted on the link prediction task which aims to predict the missing entities h or t for a triple (h, r , t). Namely, it predicts t given (h, r ) or predict h given (r , t). Similar to the se ing in [3], the task returns a list of candidate entities from the knowledge graph.\nTo evaluate the performance of link prediction, we adopt Mean Rank and Hits@10 under “Raw” and “Filter” se ings as evaluation measure following [3]. Mean Rank is the average rank of the correct entities, and Hits@10 is proportion of correct entities ranked in top-10. It is clear that a good predictor has low mean rank and high Hits@10. is is called “Raw” se ing, and “Filter” se ing lters out the corrupted triples which are correct.\nTo evaluate the speed up performance, we adopt Training Time and Speed-up Ratio as evaluation measures, where Training Time is measured using wall-clock seconds. Speed-up Ratio is\nSpeedup Ratio = tser ial tparallel , (19)\nwhere tser ial is the training time in serial, and tparallel is the training time under parallel methods.\nBaselines include typical translating embedding methods, TransE, TransH and TransE-Adagrad, which can all be trained in parallel using the ParTrans-X framework, denoted by ParTransE, ParTransH and ParTransE-Adagrad respectively in Table3. Note that TransE and TransH adopt the programs publicly available5, which are the most e cient serial versions to our knowledge, and TransEAdagrad is implemented based on TransE.\nEach experiment is conducted 10 times and the average is taken as results, with all time measured in wall-clock seconds. Our experiments are carried out on dual Intel Xeon E5-2640 CPUs, and each of them possesses 10 physical cores 20 logical cores and running at 2.4 GHz. e machine has 128 GB RAM and runs Red Hat 4.4.7. e language used is C++ and the program is compiled with the gcc compiler version 6.3.0. We use OpenMP for multithreading, each thread binds a processor."
    }, {
      "heading" : "5.2 Link Prediction Peformance of ParTrans-X",
      "text" : "Experiments on each baseline and its parallel implementation in ParTrans-X employ the same hyper-parameters, which are decided on the validation set. e learning rate η during the stochastic gradient descent process is selected among {0.1,0.01,0.001}, the embedding dimensionde anddr are selected in {20,50,100}, the margin M between positive and negative triples is selected among {1,2,3,4}. For TransE and ParTransE, the parameters are η = 0.01,de = dr = 20,M = 3 on WN18, and η = 0.001,de = dr = 100,M = 4 on Fb15k. For TransH and ParTransH, the parameters are η = 0.01,de = dr = 20,M = 3 on WN18, and η = 0.001,de = dr = 100,M = 3 on Fb15k. For TransEAdaGrad and ParTransE-AdaGrad, the parameters are η∗ = 0.3,de = dr = 50,M = 4 on WN18, and η∗ = 0.1,de = dr = 100,M = 3 on Fb15k. All the experiments employ L1-similarity. ParTransE, ParTransH and ParTransE-AdaGrad all run in 20 processors for both datasets.\nIt can be observed from Table3 that: 1. Link prediction performance in parallel is as good as the serial counterparts on both WN18 and FB15k, which demonstrates that ParTrans-X will not a ect embedding performance.\n2. e training time is greatly reduced by ParTrans-X. On WN18, TransE-AdaGrad only speeds up TransE by 4.7 times, compared to our 28 times. On FB15k, the training time of TransE is reduced from more than 1 hour to less than 1 minute by ParTransE-AdaGrad.\n5h ps://github.com/thunlp/KB2E\n3. ParTrans-X achieves higher speedup ratio on FB15k than on WN18. Since FB15k has far more training triples than WN18, the time of each epoch on FB15k is much longer than WN18. As a result, the overhead of multi-threading is less important compared to the whole training time on FB15k, which leads to a higher speedup ratio. It further validates the superiority of ParTrans-X to handle the data with large size.\n4. ParTrans-X achieves enormous improvement on training time when applying to TransEAdaGrad, especially on FB15k, where the speedup ratio has been improve to 111 from 9. Since AdaGrad decreases the total epochs needed by making the convergence come earlier, and ParTrans-X reduce training time by running in parallel, the two di erent strategies can achieve higher speedup ratio when combined.\nepoch 5 10 15 20 25\nlo ss\n#104\n0\n0.5\n1\n1.5\n2\n2.5\n3\n3.5\n4\n4.5\n5 WN18\nTransE TransE-Adagrad ParTransE\nWN18 epoch\n5 10 15 20 25\nlo ss\n#104\n0\n0.5\n1\n1.5\n2\n2.5\n3\n3.5\n4\n4.5\n5 FB15K\nTransE TransE-Adagrad ParTransE\nFB15k\nFigure 3: e descent process of loss.\nMoreover, the descent process of loss for the three algorithms on WN18 and FB15k is shown in Figure3. It can be seen that, for both datasets, the loss optimizing by ParTrans-X has already fallen sharply in the preceding epochs, and it yields sensibly lower values of the loss than TransE-AdaGrad and TransE even a er a few iterations(< 5 epoches). Still, ParTrans-X performs be er on FB15k than WN18, shows that it is more e ective on large data size."
    }, {
      "heading" : "5.3 Scaling Results for Multi-Processors",
      "text" : "Furthermore, we carry out a number of experiments to test if the implementations scale with increasing number of processors. We mainly analyze two aspects of experiment results, i.e., the training time and the link prediction performance.\nFigure4 shows the log-log plot of the training time in wall-clock seconds for di erent number of processors. We can observe that the training time continue to decrease along with the increasing\nnumber of mutli-processors on both WN18 and FB15k. While the absolute training time of ParTransE-AdaGrad is be er than ParTransE, which is be er than ParTransH, consistent with the previous result. Moreover, the total training time of ParTransE-AdaGrad drops sharply when processor number is less than four, it is because the training time of ParTransE-AdaGrad with few processors is fairly short, the increase of communication time cost with the more processors has larger e ect on the total training time compared with other methods, which leads to small decline.\ne predictive performance measured by Hits@10 along with increasing number of processors is shown in Figure5. It can be seen that ParTransE, ParTransE-AdaGrad and ParTransH always maintain good performance, which validates the applicability and superiority of ParTrans-X. Note that the performance on FB15k is more stable than WN18, since there are more training triples in FB15k, and the model will learn more su cient so that the stability of predictive performance is be er on FB15k, which validates the superiority of ParTrans-X on large data size."
    }, {
      "heading" : "6 CONCLUSION",
      "text" : "In this paper, we explore the law of collisions emerging in knowledge graphs by modelling training data to hypergraphs. Our key observation is that one learning iteration only concerns few embeddings, which is not necessarily bound up with others, thus the probability of collisions between di erent processors can be negligible. Based on this assumption, we propose an e cient parallel framework for translating embedding methods, called ParTrans-X. It employs the intrinsic sparsity of training data in large knowledge graphs, which enables the embedding vectors to be learnt without locks and not inducing errors. Experiments validate that\nParTrans-X can speed up the training process by more than an order of magnitude, without degrading embedding performance."
    }, {
      "heading" : "7 ACKNOWLEDGE",
      "text" : "We thank Jun Xu and the anonymous reviewers for valuable suggestions. e work was funded by National Natural Science Foundation of China (No. 61572469, 61402442, 91646120,61572473, 61402 022), the National Key R&D Program of China (No. 2016QY02D0405, 2016YFB1000902), and National Grand Fundamental Research 973 Program of China (No. 2013CB329602, 2014CB340401)."
    } ],
    "references" : [ {
      "title" : "TensorFlow: Large-Scale Machine",
      "author" : [ "Martn Abadi", "Ashish Agarwal", "Paul Barham", "Eugene Brevdo", "Zhifeng Chen", "Craig Citro", "Greg S. Corrado", "Andy Davis", "Jerey Dean", "Mahieu Devin" ],
      "venue" : "Learning on Heterogeneous Distributed Systems",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2016
    }, {
      "title" : "Freebase: a collaboratively created graph database for structuring human knowledge",
      "author" : [ "Kurt Bollacker", "Colin Evans", "Praveen Paritosh", "Tim Sturge", "Jamie Taylor" ],
      "venue" : "In Proceedings of the 2008 ACM SIGMOD international conference on Management of data. AcM,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2008
    }, {
      "title" : "Translating embeddings for modeling multi-relational data",
      "author" : [ "Antoine Bordes", "Nicolas Usunier", "Alberto Garcia-Duran", "Jason Weston", "Oksana Yakhnenko" ],
      "venue" : "In Advances in neural information processing systems",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2013
    }, {
      "title" : "Large scale distributed deep networks",
      "author" : [ "Jerey Dean", "Greg S Corrado", "Rajat Monga", "Kai Chen", "Mahieu Devin", "oc V Le", "Mark Z Mao", "Marc’Aurelio Ranzato", "Andrew Senior", "Paul Tucker" ],
      "venue" : "In International Conference on Neural Information Processing Systems",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2012
    }, {
      "title" : "Knowledge vault: a web-scale approach to probabilistic knowledge fusion",
      "author" : [ "Xin Dong", "Evgeniy Gabrilovich", "Geremy Heitz", "Wilko Horn", "Ni Lao", "Kevin Murphy", "omas Strohmann", "Shaohua Sun", "Wei Zhang" ],
      "venue" : null,
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2014
    }, {
      "title" : "Adaptive subgradient methods for online learning and stochastic optimization",
      "author" : [ "John Duchi", "Elad Hazan", "Yoram Singer" ],
      "venue" : "Journal of Machine Learning Research 12,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2011
    }, {
      "title" : "OpenKN: An open knowledge computational engine for network big data",
      "author" : [ "Yantao Jia", "Yuanzhuo Wang", "Xueqi Cheng", "Xiaolong Jin", "Jiafeng Guo" ],
      "venue" : "In Advances in Social Networks Analysis and Mining (ASONAM)",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2014
    }, {
      "title" : "Locally Adaptive Translation for Knowledge Graph Embedding",
      "author" : [ "Yantao Jia", "Yuanzhuo Wang", "Hailun Lin", "Xiaolong Jin", "Xueqi Cheng" ],
      "venue" : null,
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2016
    }, {
      "title" : "Slow learners are fast",
      "author" : [ "John Langford", "Alexander J Smola", "Martin Zinkevich" ],
      "venue" : "In International Conference on Neural Information Processing Systems",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2009
    }, {
      "title" : "Modeling Relation Paths for Representation Learning of Knowledge Bases",
      "author" : [ "Yankai Lin", "Zhiyuan Liu", "Huanbo Luan", "Maosong Sun", "Siwei Rao", "Song Liu" ],
      "venue" : "Science",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2015
    }, {
      "title" : "Learning entity and relation embeddings for knowledge graph completion",
      "author" : [ "Yankai Lin", "Zhiyuan Liu", "Maosong Sun", "Yang Liu", "Xuan Zhu" ],
      "venue" : "In Twenty- Ninth AAAI Conference on Articial Intelligence",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2015
    }, {
      "title" : "YAGO3: A Knowledge Base from Multilingual Wikipedias",
      "author" : [ "Farzaneh Mahdisoltani", "Joanna Biega", "Fabian Suchanek" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2014
    }, {
      "title" : "Delay-tolerant algorithms for asynchronous distributed online learning",
      "author" : [ "H.B. Mcmahan", "M. Streeter" ],
      "venue" : "Advances in Neural Information Processing Systems",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2014
    }, {
      "title" : "WordNet: a lexical database for English",
      "author" : [ "George A Miller" ],
      "venue" : "Commun. ACM 38,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1995
    }, {
      "title" : "Ecient Learning of Entity and Predicate Embeddings for Link Prediction in Knowledge Graphs",
      "author" : [ "Pasquale Minervini", "Claudia d’Amato", "Nicola Fanizzi", "Floriana Esposito" ],
      "venue" : "In URSW@ ISWC",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2015
    }, {
      "title" : "Hogwild: A lock-free approach to parallelizing stochastic gradient descent",
      "author" : [ "Benjamin Recht", "Christopher Re", "Stephen Wright", "Feng Niu" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2011
    }, {
      "title" : "An overview of gradient descent optimization algorithms",
      "author" : [ "Sebastian Ruder" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2016
    }, {
      "title" : "Knowledge Graph Embedding by Translating on Hyperplanes",
      "author" : [ "Zhen Wang", "Jianwen Zhang", "Jianlin Feng", "Zheng Chen" ],
      "venue" : "AAAI - Association for the Advancement of Articial Intelligence",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2014
    }, {
      "title" : "Deep learning with Elastic Averaging SGD",
      "author" : [ "Sixin Zhang", "Anna Choromanska", "Yann Lecun" ],
      "venue" : "Science",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : ", TransE [3], TransH [19], and a more ecient variant TransE- AdaGrad [11] validate that ParTrans-X can speed up the training process by more than an order of magnitude.",
      "startOffset" : 9,
      "endOffset" : 12
    }, {
      "referenceID" : 17,
      "context" : ", TransE [3], TransH [19], and a more ecient variant TransE- AdaGrad [11] validate that ParTrans-X can speed up the training process by more than an order of magnitude.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 10,
      "context" : ", TransE [3], TransH [19], and a more ecient variant TransE- AdaGrad [11] validate that ParTrans-X can speed up the training process by more than an order of magnitude.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 1,
      "context" : ", Freebase [2], WordNet [14], YAGO [12], OpenKN [7], and have played a pivotal role in supporting many applications, such as link prediction, question answering, etc.",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 13,
      "context" : ", Freebase [2], WordNet [14], YAGO [12], OpenKN [7], and have played a pivotal role in supporting many applications, such as link prediction, question answering, etc.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 11,
      "context" : ", Freebase [2], WordNet [14], YAGO [12], OpenKN [7], and have played a pivotal role in supporting many applications, such as link prediction, question answering, etc.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 6,
      "context" : ", Freebase [2], WordNet [14], YAGO [12], OpenKN [7], and have played a pivotal role in supporting many applications, such as link prediction, question answering, etc.",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 2,
      "context" : "e methods represent entities and relations as the embedding vectors by regarding relations as translations from head entities to tail entities, such as TransE [3], TransH [19], TransR[11], etc.",
      "startOffset" : 160,
      "endOffset" : 163
    }, {
      "referenceID" : 17,
      "context" : "e methods represent entities and relations as the embedding vectors by regarding relations as translations from head entities to tail entities, such as TransE [3], TransH [19], TransR[11], etc.",
      "startOffset" : 172,
      "endOffset" : 176
    }, {
      "referenceID" : 10,
      "context" : "e methods represent entities and relations as the embedding vectors by regarding relations as translations from head entities to tail entities, such as TransE [3], TransH [19], TransR[11], etc.",
      "startOffset" : 184,
      "endOffset" : 188
    }, {
      "referenceID" : 2,
      "context" : "When d is 100 and ep is 1000, it will take 78 minutes for TransE to learn the embeddings of FB15k2, which is a subset of Freebase with 483,142 training triples, and has been widely used as experimental dataset in knowledge graph embedding methods [3, 8, 11, 19].",
      "startOffset" : 247,
      "endOffset" : 261
    }, {
      "referenceID" : 7,
      "context" : "When d is 100 and ep is 1000, it will take 78 minutes for TransE to learn the embeddings of FB15k2, which is a subset of Freebase with 483,142 training triples, and has been widely used as experimental dataset in knowledge graph embedding methods [3, 8, 11, 19].",
      "startOffset" : 247,
      "endOffset" : 261
    }, {
      "referenceID" : 10,
      "context" : "When d is 100 and ep is 1000, it will take 78 minutes for TransE to learn the embeddings of FB15k2, which is a subset of Freebase with 483,142 training triples, and has been widely used as experimental dataset in knowledge graph embedding methods [3, 8, 11, 19].",
      "startOffset" : 247,
      "endOffset" : 261
    }, {
      "referenceID" : 17,
      "context" : "When d is 100 and ep is 1000, it will take 78 minutes for TransE to learn the embeddings of FB15k2, which is a subset of Freebase with 483,142 training triples, and has been widely used as experimental dataset in knowledge graph embedding methods [3, 8, 11, 19].",
      "startOffset" : 247,
      "endOffset" : 261
    }, {
      "referenceID" : 4,
      "context" : ", 75% persons do not have nationalities in Freebase [5].",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 14,
      "context" : "Pasquale[15] proposed TransE-AdaGrad to speed up the training process by leveraging adaptive learning rates.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 8,
      "context" : "To avoid collisions, some methods [9] lock embedding vectors, which will slow the training process greatly as there are so many vectors.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 3,
      "context" : "On the contrary, updating vectors without locks leads to high eciency, but should be based on specic assumptions [4, 16].",
      "startOffset" : 115,
      "endOffset" : 122
    }, {
      "referenceID" : 15,
      "context" : "On the contrary, updating vectors without locks leads to high eciency, but should be based on specic assumptions [4, 16].",
      "startOffset" : 115,
      "endOffset" : 122
    }, {
      "referenceID" : 2,
      "context" : ", TransE [3], TransH [19], and a more ecient variant TransE-AdaGrad, and experiments validate the eectiveness of ParTrans-X on two widely used datasets.",
      "startOffset" : 9,
      "endOffset" : 12
    }, {
      "referenceID" : 17,
      "context" : ", TransE [3], TransH [19], and a more ecient variant TransE-AdaGrad, and experiments validate the eectiveness of ParTrans-X on two widely used datasets.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 2,
      "context" : "A signicant work is TransE [3], which heralds the start of translating embedding methods.",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 17,
      "context" : "Moreover, TransH [19] assumes that it is the projections of entities to a relation-specic hyperplane that satisfy the translation constraint, i.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 10,
      "context" : "Furthermore, TransR [11] employs rotation transformation to project the entities to a relation-specic space, i.",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 9,
      "context" : ", paths [10], margins [8].",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 7,
      "context" : ", paths [10], margins [8].",
      "startOffset" : 22,
      "endOffset" : 25
    }, {
      "referenceID" : 14,
      "context" : "Recently, a method TransE-AdaGrad [15] was proposed to reduce the training time of TransE by employing AdaGrad [6], an variant of SGD, to adaptively modify the learning rate.",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 5,
      "context" : "Recently, a method TransE-AdaGrad [15] was proposed to reduce the training time of TransE by employing AdaGrad [6], an variant of SGD, to adaptively modify the learning rate.",
      "startOffset" : 111,
      "endOffset" : 114
    }, {
      "referenceID" : 16,
      "context" : "e major obstacle to parallel SGD is the collisions between updates of different processors for the same parameter [17], to overcome which there are two main brunches of methods.",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 15,
      "context" : "For example, Hogwild! [16] is a lock-free scheme works well for sparse data, which means that there is only a small part of parameters to update by each iteration of SGD.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 3,
      "context" : "Downpour SGD [4] mainly employ DistBelief [4] framework, which divides the training data into a number of subsets, then the model replicas run independently on each of these subsets, and do not communicate with each other.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 3,
      "context" : "Downpour SGD [4] mainly employ DistBelief [4] framework, which divides the training data into a number of subsets, then the model replicas run independently on each of these subsets, and do not communicate with each other.",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 0,
      "context" : "Inspired by this, TensorFlow [1] splits a computation graph into a subgraph for every worker and communication takes place using Send/Receive node pairs.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 18,
      "context" : "Motivated by training large-scale convolutional neural networks for image classication, Elastic Averaging SGD (EASGD) [20] reduces the amount of communication between local workers and the master to allow the parameters of local workers to uctuate further from the center ones.",
      "startOffset" : 119,
      "endOffset" : 123
    }, {
      "referenceID" : 12,
      "context" : ", Delay-tolerant Algorithms for SGD [13] adapts not only to the sequence of gradients, but also to the precise update delays that occur, inspired by AdaGrad.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 2,
      "context" : "constructed by substituting one entity h′ ∈ E or t ′ ∈ E for h or t respectively, contributing to a corrupted triple (h′, r , t) or (h, r , t ′), which is just simply denoted by (h′, r , t ′) following [3].",
      "startOffset" : 202,
      "endOffset" : 205
    }, {
      "referenceID" : 2,
      "context" : "Each loop is done by rstly normalizing the entity embedding vectors following [3].",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 2,
      "context" : "e datasets employed are two representative datasets WN18 and FB15k, which are subsets of well-known knowledge graphs WordNet and Freebase respectively, and have been widely used by translating embedding methods [3, 8, 11, 19].",
      "startOffset" : 212,
      "endOffset" : 226
    }, {
      "referenceID" : 7,
      "context" : "e datasets employed are two representative datasets WN18 and FB15k, which are subsets of well-known knowledge graphs WordNet and Freebase respectively, and have been widely used by translating embedding methods [3, 8, 11, 19].",
      "startOffset" : 212,
      "endOffset" : 226
    }, {
      "referenceID" : 10,
      "context" : "e datasets employed are two representative datasets WN18 and FB15k, which are subsets of well-known knowledge graphs WordNet and Freebase respectively, and have been widely used by translating embedding methods [3, 8, 11, 19].",
      "startOffset" : 212,
      "endOffset" : 226
    }, {
      "referenceID" : 17,
      "context" : "e datasets employed are two representative datasets WN18 and FB15k, which are subsets of well-known knowledge graphs WordNet and Freebase respectively, and have been widely used by translating embedding methods [3, 8, 11, 19].",
      "startOffset" : 212,
      "endOffset" : 226
    }, {
      "referenceID" : 2,
      "context" : "Similar to the seing in [3], the task returns a list of candidate entities from the knowledge graph.",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 2,
      "context" : "To evaluate the performance of link prediction, we adopt Mean Rank and Hits@10 under “Raw” and “Filter” seings as evaluation measure following [3].",
      "startOffset" : 144,
      "endOffset" : 147
    } ],
    "year" : 2017,
    "abstractText" : "Knowledge graph embedding aims to embed entities and relations of knowledge graphs into low-dimensional vector spaces. Translating embedding methods regard relations as the translation from head entities to tail entities, which achieve the state-of-the-art results among knowledge graph embedding methods. However, a major limitation of these methods is the time consuming training process, which may take several days or even weeks for large knowledge graphs, and result in great diculty in practical applications. In this paper, we propose an ecient parallel framework for translating embedding methods, called ParTrans-X, which enables the methods to be paralleled without locks by utilizing the distinguished structures of knowledge graphs. Experiments on two datasets with three typical translating embedding methods, i.e., TransE [3], TransH [19], and a more ecient variant TransEAdaGrad [11] validate that ParTrans-X can speed up the training process by more than an order of magnitude.",
    "creator" : "LaTeX with hyperref package"
  }
}