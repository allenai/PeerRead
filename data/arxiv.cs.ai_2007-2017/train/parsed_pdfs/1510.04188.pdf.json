{
  "name" : "1510.04188.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "UNIVERSAL AND DETERMINED CONSTRUCTORS OF MULTISETS OF OBJECTS",
    "authors" : [ "Dmytro Terletskyi" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "aspects of human thinking. The creation of sets is considered within constructive object-oriented version of set theory (COOST), from different sides, in particular classical set theory, object-oriented programming (OOP) and development of intelligent information systems (IIS). The main feature of COOST in contrast to other versions of set theory is an opportunity to describe essences of objects more precisely, using their properties and methods, which can be applied to them. That is why this version of set theory is object-oriented and close to OOP. Within COOST, the author proposes universal constructor of multisets of objects that gives us a possibility to create arbitrary multisets of objects. In addition, a few determined constructors of multisets of objects, which allow creating multisets, using strictly defined schemas, also are proposed in the paper. Such constructors are very useful in cases of very big cardinalities of multisets, because they give us an opportunity to calculate a multiplicity of each object and cardinality of multiset before its creation. The proposed constructors of multisets of objects allow us to model in a sense corresponding processes of human thought, that in turn give us an opportunity to develop IIS, using these tools.\nKeywords: constructive object-oriented set theory, class of objects, homogeneous class of objects, inhomogeneous class of objects, set of objects, multiset of objects.\nACM Classification Keywords: I.2.0 General – Cognitive simulation, F.4.1 Mathematical Logic – Set theory, D.1.5 Object-oriented Programming, D.3.3 Language Constructs and Features – Abstract data types, Classes and objects, Data types and structures, E.2 Data Storage Representations – Object representation."
    }, {
      "heading" : "Introduction",
      "text" : "Nowadays there are different versions of set theory, such as naive set theory of Cantor [Cantor, 1915], type theory of Russell [Wang, Mc Naughton, 1953], Zermelo-Fraenkel set theory [Fraenkel, Bar-Hillel, 1958; Wang, Mc Naughton, 1953], Von Neumann-Bernays-Gedel set theory [Wang, Mc Naughton, 1953], systems of Quine's set theory [Wang, Mc Naughton, 1953], constructible sets of Mostowski [Mostowski, 1969], alternative set theory of Vopenka [Vopenka, 1979], etc. where definition of set is introduced in different ways. Nevertheless, these definitions just describe the concept of set, and do not explain the origin of particular sets. It means they just declare a fact of existence of sets. That is why questions about the origin of specific sets are arising. Of course, we can conclude that the “new” set can be obtained by set-theoretic operations over “existing” sets, and it is really so. However, the questions about origin of these so-called “existing” sets do not disappear, because if they exist, it means that someone, using some methods (algorithms), created them earlier.\nApart from this, concept of set has important place in human thinking activity during perception, analysis, comparison, retrieval, classification and so on. Really, let us consider situation, when you have bunch of keys and need to open certain lock. If you know how exactly corresponding key looks, you can imagine and distinguish it from other keys from this bunch. In this case, it will be easy and fast. However, into another case you need to\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 340\ncheck the keys. It means, you perform certain exhaustive search, and at the same time, you create set of keys, which you have checked. Let us imagine another situation, when you need to count money, which you have in your wallet. During counting, you create at least two sets, set of banknotes and set of coins. In addition, we can consider situation when you want to play chess or checkers, and before starting, you need to make initial arrangement of figures on the chessboard. During figures placement, you create set of white and set of black figures from set of all figures. During the game, you create set of beaten figures and set of unbeaten figures from the set of all figures. These are just a few simple examples from our daily activity. Usually we pay little attention to how do we think, and what concepts do we use during this activity. However, we operate with sets of objects permanently, sometimes it happening consciously sometimes not, but it is so. These facts give as an opportunity to conclude that set is the one of basic constructions of human thinking. Today, we have an opportunity to use sets in programming, in particular in OOP. As a proof, there are appropriate tools within some OOP-languages for working with such data structure, in particular set in STL for C++ [Musser, Derge, Saini, 2001], HashSet, SortedSet and ISet in C# [Mukherjee, 2012], HashSet in Java [Eckel, 2006], set and frozenset in Python [Summerfield, 2010]. These tools allow sets creation, executing basic settheoretic operations, membership checking, adding and removing of elements and checking of equivalence between sets, etc. As we can see, concept of set is very important for mathematics and has some applications in programming, in particular OOP, as practical implementation of some aspects of mathematical set theory. However, set theory and OOP are developed separately, and opportunity to work with sets within OOP is just additional functionality of OOP. It means programmers do not develop set theory, and mathematicians do not develop implementation of set theory within programming languages, very often, these two communities have different interests. Despite this, our target is development of IIS, based on human mechanisms of information analysis, in particular, on manipulation with sets of objects, using OOP. That is why we will try to combine some ideas of set theory and OOP during design and development of such systems. We will consider some constructive version of set theory described in [Terletskyi, 2014], which is close to OOP’s paradigm, and show its application for simulation of some aspects of human thinking, in particular creation of sets and multisets of objects."
    }, {
      "heading" : "Objects and Classes",
      "text" : "We know that each set consists of elements, which form it. Everything, phenomena of our imagination or of our world can be the elements of the set [Cantor, 1915]. From other hand, one of the main postulates of OOP is that real world is created by objects [Pecinovsky, 2013]. Combining these two ideas, we will call elements of sets – objects. Let us consider such object as natural number. It is clear that every natural number must be integer and positive. These are characteristic properties of natural numbers. It is obvious, that 2 is really a natural number, but í12 and 3.62, for example, are not natural numbers. Let us consider another object, for instance triangle. We know that triangle is geometrical figure, which has three sides for which the triangle inequality must be satisfied. According to this, geometrical figure, which has sides 3 cm, 5 cm and 7 cm is really a triangle, but figure with sides 2 cm, 4 cm and 7 cm does not triangle. We can conclude that each object has certain properties, which define it as some essence while analyzing these facts. Furthermore, objects and their properties cannot exist separately, because if we assume the opposite, we will have contradiction. On the one hand, object cannot exist separately from its properties, because without properties we cannot imagine and cannot describe it. On the other hand, object's properties cannot exist\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n341\nseparately from object, because without object we cannot see and cannot perceive them. That is why, we cannot consider them separately, and there are few variants of the definitions order. It means that we cannot introduce definition of object without definition of its properties and vice versa. Therefore, we decided to introduce concept of object's properties firstly. Globally we can divide properties of objects into two types – quantitative and qualitative. We will define these two types of object's properties formally, but their semantics has intuitive nature.\nDefinition 1. Quantitative property of object A is a tuple ( ) ( ( ( )), ( ( )))i i ip A v p A u p A , where 1,i n , ( ( ))iv p A is an quantitative value of ( )ip A , and ( ( ))iu p A are units of measure of quantitative value of ( )ip A Example 1. Suppose we have an apple, and one of its properties is weight. We can present this property as follows ( ) ( ( ( )), ( ( )))w w wp A v p A u p A , and if weight of our apple is 0.2 kg, then property ( )wp A will be the following 0 2( ) ( . , )wp A kg .\nDefinition 2. Two quantitative properties ( )ip A and ( )jp B , where 1,i n , 1,j m , are equivalent, i.e. 1( ( ), ( ))i jEq p A p B , if and only if ( ( )) ( ( ))i ju p A u p B .\nDefinition 3. Qualitative property of object A is a verification function ( ) ( )i ip A vf A , 1,i n , which defines as a mapping 0 1( ) : ( ) [ , ]i ivf A p A . Example 2. Let us consider such object as a triangle. One of its properties is triangle inequality, which must be satisfied for its sides. We can present this property as follows ( ) ( )ti tip T vf T , where ( )tivf T is verification function of property ( )tip T . In this case, function 0 1( ) : ( ) { , }ti tivf T p T , and it is a particular case of verification function – predicate or Boolean-valued function. We can conclude that, such approach gives an opportunity to combine description of property and its verification in the one function, i.e. verification function is a verification function and a description of property at the same time. Therefore, different algorithms can be verifiers and descriptors of properties simultaneously.\nDefinition 4. Two qualitative properties ( )ip A and ( )jp B , where 1,i n , 1,j m , are equivalent, i.e. 1( ( ), ( ))i jEq p A p B , if and only if ( ( ) ( )) ( ( ) ( ))i j i jvf A vf A vf B vf B ¼ .\nDefinition 5. Specification of object A is a vector 1 ( ) ( ( ),..., ( ))nP A p A p A , where ( )ip A , 1,i n is quantitative or qualitative property of object A .\nDefinition 6. Dimension of object A is number of properties of object A , i.e. ( ) ( )D A P A .\nNow, we can formulate the definition of object.\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 342\nDefinition 7. Object is a pair / ( )A P A , where A is object’s identifier and ( )P A – specification of object.\nEssentially, object is a carrier of some properties, which define it as some essence.\nDefinition 8. Two objects A and B are similar, if and only if ( ) ( )P A P B .\nIn general, we can divide objects on concrete and abstract, and does not matter when or how someone created each particular object. It is material implementation of its abstract image – a prototype. This prototype is essentially an abstract specification for creation the future real objects. Besides properties of objects, we should allocate operations (methods) which we can apply to objects, considering the features of their specifications. Really, we can apply some operations (methods) to objects for their changing and for operating with them. That is why, it will be useful to define concept of object's operation (method).\nDefinition 9. Operation (method) of object A is a function ( )f A , which we can apply to object A considering the features of its specification. Example 3. For such objects as natural numbers n , m we can define operations \" \" and \" \"º . In OOP, programmers consider specifications and methods of objects without objects, and they call it a type or a class of objects, which consists of fields and methods [Weisfeld, 2008; Pecinovsky, 2013]. Fields of class, essentially, are specification of class. Methods are functions, which we can apply to objects of this class for their changing and for operating with them. For convenience, we will also use word “signature” for methods of class. Let us define concept of object’s signature.\nDefinition 10. Signature of object A is a vector 1 ( ) ( ( ),..., ( ))mF A f A f A , where ( )if A , 1,i m is an operation (method) of object A . Generally, signature of particular object can consist of different quantity of operations, but in practice, especially in programming, usually we are considering finite signatures of objects.\nAccording to definition of object, every object has some specification, which defines it as some essence. There are some objects, which have similar specifications. It means that we can apply the same methods to them. Let us define similar objects.\nDefinition 11. Objects A and B are similar objects, if and only if, they have the same dimension and equivalent specifications. If certain two objects are similar, we can conclude that these objects have the same type or class. Now we can introduce concept of object’s class.\nDefinition 12. Object’s class T is a tuple ( ( ), ( ))T P T F T , where ( )P T is abstract specification of some quantity of objects, and ( )F T is their signature.\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n343\nWhen we talk about class of objects, we mean properties of these objects and methods, which we can apply to them. Class of objects is a generalized form of consideration of objects and operations on them, without these objects.\nExample 4. Let us describe type Int in programming language C++, using concept of similar objects and object’s class. Let us set the next specification for the class 1 2 ( ) ( ( ), ( ))P Int p Int p Int , where property\n1 ( )p Int means “integer number”, property 2 ( )p Int means “number not bigger then 2147336147 and not smaller\nthan -2147336148”. It is obvious, that all numbers which have properties 1 ( )p Int and 2 ( )p Int are objects of class Int. Let define the methods of class Int in the following way 1 2 ( ) ( ( ), ( ))F Int f Int f Int , where\n1 ( ) \" \"f Int and 2 ( ) \"* \"f Int . As we know, in OOP, every particular object has the same fields and behavior as its class, i.e. it has the same specification and signature. It means that every class of OOP is homogeneous in a sense. That is why, let us define concept of homogeneous class of objects.\nDefinition 13. Homogeneous class of objects T is a class of objects, which contains only similar objects. The simplest examples of homogeneous classes of objects are class of natural numbers, class of letters of English alphabet, class of colors of the rainbow, etc. Clearly, that every object is a member of at least one class of objects. Furthermore, some objects are members of few classes simultaneously. For example, such objects as natural numbers 1 ,..., mn n are members of such classes as natural numbers N , integer numbers Z , rational numbers Q and real numbers R . It is obvious that, class R has the biggest cardinality. Furthermore, it consists of groups of objects of different types. It contradicts concept of OO-class, because different objects from one OO-class cannot have different specifications and signatures. According to this, we cannot describe such classes of objects using concept of homogeneous class. That is why we will define concept of inhomogeneous class of objects.\nDefinition 14. Inhomogeneous class of objects T is a tuple\n1 1 ( ( ), ( ),..., ( ))n nT Core T pr A pr A ,\nwhere ( ) ( ( ), ( ))Core T P T F T is the core of class T , which includes properties and methods similar to specifications 1 ( ),..., ( )nP A P A and signatures 1( ),..., ( )nF A F A respectively and ( ) ( ( ), ( ))i i i ipr A P A F A , 1,i n is projection of object iA , which consists of properties and methods typical only for this object. The simplest examples of inhomogeneous classes of objects are class of polygons, cars, birds, etc.\nDefinition 15. Two classes of objects 1 T and 2 T are equivalent, i.e. 1 2 1( , )Eq T T , if and only if 1 2 1 2 ( ( ) ( )) ( ( ) ( ))P T P T F T F T ¼ .\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 344"
    }, {
      "heading" : "Sets and Multisets of Objects",
      "text" : "According to Naive set theory, a set is a gathering together into a whole of definite, distinct objects of our perception or of our thought, which are called elements of the set [Cantor, 1915]. As we can see, this definition just describes concept of set, and does not explain how to gather these objects together. That is why we are going to define union operation on objects, as a method of set creation.\nDefinition 16. Union « of 2n arbitrary objects is a new set of objects S , which is obtained in the following way\n1 1 1 / ( ) ... / ( ) { ,..., } / ( )n n nS A T A A T A A A T S « « ,\nwhere ,i jA A S ± , 1, ,i j n and i j , 0( , )i jEq A A ; ( )iT A , 1,i n is a class of object iA and ( )T S is a class of new set of objects S and n is its cardinality.\nExample 5. Let us consider such geometrical objects as triangle, square and trapeze. It is obvious that these objects belong to different classes of polygons. Let us denote triangle as A , square as B , trapeze as C , and describe their classes as follows\n1 5 1 2 ( ) (( ( ),..., ( )),( ( ), ( )))T A p A p A f A f A ; 1 4 1 2 ( ) (( ( ),..., ( )),( ( ), ( )))T B p B p B f B f B ;\n1 5 1 2 ( ) (( ( ),..., ( )),( ( ), ( )))T C p C p C f C f C .\nProperties 1 ( )p A , 1 ( )p B , 1 ( )p C are quantities of sides of figures, properties 2 ( )p A , 2 ( )p B , 2 ( )p C , are sizes of sides of figures, properties 3 ( )p A , 3 ( )p B , 3 ( )p C are quantities of angles of figures, properties 4 ( )p A ,\n4 ( )p B , 4 ( )p C are sizes of angles of figures, property 5 ( )p A is triangle inequality and property 5 ( )p C is\nparallelism of two sides of figure. Methods 1 ( )f A , 1 ( )f B , 1 ( )f C are functions of perimeter calculation of figures, and methods 2 ( )f A , 2 ( )f B , 2 ( )f C are functions of area calculation of figures. Of course, specifications and signatures of these objects can include more properties and methods, than we have presented in this example, but everything depends on level of detail. Let us define specifications and signatures of these objects (see Table 1).\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n345\nAnalyzing Table 1, we can see that property 5 p specified as just value of verification function for particular object. All these functions can be simply implemented using OOP language. Furthermore, there are variety of their implementations that is why we will not consider them within this example. Now, let us apply the union operation to these objects and create a new set of objects.\n/ ( ) / ( ) / ( ) { , , } / ( )S A T A B T B C T C A B C T S « «\nWe have obtained a new set of objects S and a new class of objects\n1 2 3 ( ) ( ( ), ( ), ( ), ( ))T S Core S pr A pr B pr C ,\nWhere 1 2 3 4 1 ( ) ( ( ), ( ), ( ), ( ), ( ))Core S p S p S p S p S f S , property 1 ( )p S is quantity of sides of figures, property\n2 ( )p S means sizes of sides of figures, property 3 ( )p S is quantity of angles of figures, property 4 ( )p S means\nsizes of angles of figures, method 1 ( )f S is a function of perimeter calculation of figures,\n1 5 2 ( ) ( ( ), ( ))pr A p A f A , 2 2 ( ) ( ( ))pr B f B , 3 5 2 ( ) ( ( ), ( ))pr C p C f C .\nEssentially, the set of objects S is the set of triangles of class ( )T A , squares of class ( )T B and trapezes of class ( )T C and class of set of objects ( )T S describes these three types of geometrical figures.\nTherefore, we can create sets of object, applying union operation to objects and not only. According to classical set theory, we can do it, applying union operation to sets of objects. However, this operation does not consider concept of class of objects that is why we need to redefine it.\nDefinition 17. Union « of 2m arbitrary sets of objects is a new set of objects S , which is obtained in the following way\n1 1 1 / ( ) ... / ( ) { ,..., } / ( ) m m n S S T S S T S A A T S « « ,\nwhere ,i jA A S ± , 1, ,i j n and i j , 0( , )i jEq A A ; ( )iT S , 1,i m is a class of set of objects iS and ( )T S is a class of a new set of objects S and n is its cardinality.\nExample 6. Let us consider such objects as triangle A , square B and trapeze C , which belong to classes ( )T A , ( )T B and ( )T C , described in the Example 5, respectively. Let us create two sets of objects 1 S and\n2 S using Definition 16, i.e.\n1 1 / ( ) / ( ) { , } / ( )S A T A B T B A B T S « ; 2 2 / ( ) / ( ) { , } / ( )S A T A C T C A C T S « .\nAs the result we have obtain new sets of objects 1 S , 2 S and new classes of objects 1 ( )T S , 2 ( )T S , that have following structures\n1 1 1 2 ( ) ( ( ), ( ), ( ))T S Core S pr A pr B ; 2 2 1 2 ( ) ( ( ), ( ), ( ))T S Core S pr A pr C .\nIn the case cores of both classes are the same, it means\n1 2 1 2 3 4 1 ( ) ( ) ( ( ), ( ), ( ), ( ), ( ))Core S Core S p S p S p S p S f S ,\nwhere property 1 ( )p S is quantity of sides of figures, property 2 ( )p S means sizes of sides of figures, property\n3 ( )p S is quantity of angles of figures, property 4 ( )p S means sizes of angles of figures, method 1 ( )f S is a\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 346\nfunction of perimeter calculation of figures. Concerning projections of these classes, then they have following structures 1 1 2 ( ) ( ( ), ( ))pr A p A f A , 2 2 ( ) ( ( ))pr B f B , 2 5 2 ( ) ( ( ), ( ))pr C p C f C .\nNow, let us calculate union of 1 S and 2 S .\n1 1 2 2 1 2 / ( ) / ( ) { , } / ( ) { , } / ( ) { , , } / ( )S S T S S T S A B T S A C T S A B C T S « «\nAs we can see, we have obtained the same result, as in the case of union of objects A , B and C , which we considered in the previous example.\nConsequently, we have considered two ways of set creation, however we can also obtain a set of objects, combining these two approaches.\nDefinition 18. Union « of 1n arbitrary objects and 1m arbitrary sets of objects is a new set of objects S , which is obtained in the following way\n1 1 1 1 1 / ( ) ... / ( ) / ( ) ... / ( ) { ,..., } / ( ) n n m m k S A T A A T A S T S S T S A A T S « « « « « ,\nwhere ,i jA A S ± , 1, ,i j k and i j , 0( , )i jEq A A ; ( )vT A , 1,v n is a class of object vA , ( )wT S ,\n1,w m is a class of set of objects w S and ( )T S is a class of new set of objects S and k is its cardinality.\nExample7. Let us consider objects A , B , C and sets of objects 1 S , 2 S which were described above, and calculate their union.\n1 1 2 2 / ( ) / ( ) / ( ) / ( ) / ( )S A T A B T B C T C S T S S T S « « « «\n1 2 / ( ) / ( ) / ( ) { , } / ( ) { , } / ( ) { , , } / ( )A T A B T B C T C A B T S A C T S A B C T S « « « « .\nAs we can see, we have obtained the same result, as in the previous example. Let us define a concept of set of objects based on methods of set creation, which were considered above.\nDefinition 19. The set of objects S is a union, which satisfies one of the following schemes:\n1 1 1 : / ( ) ... / ( ) / ( ) n n S O T O O T O S T S« « ;\n1 1 2 : / ( ) ... / ( ) / ( ) m m S S T S S T S S T S« « ;\n1 1 1 1 3 : / ( ) ... / ( ) / ( ) ... / ( ) / ( ) n n m m S O T O O T O S T S S T S S T S« « « « « ;\nwhere 1 ,..., n O O are arbitrary objects, 1 ,..., m S S are arbitrary sets of objects, and ( )T S is a class of a new set of objects S .\nAccording to types of objects, which form a set of objects, we can obtain different types of sets of objects, in particular set of objects, which consists of only objects, that belong to the same class of objects.\nLet us define concept of homogeneous set of objects, based on concept of homogeneous class of objects.\nDefinition 20. Set of objects 1 { ,..., } n S A A is homogeneous, if and only if ,i jA A S ± , 1, ,i j n and i j , 1( ( ), ( ))i jEq T A T A .\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n347\nAs we know, multiset is a generalization of the notion of set in which members are allowed to appear more than once [Syropoulos, 2001]. Formally multiset can be defined as a 2-tuple ( , )A m , where A is the set, and m is the function that puts a natural number, which is called the multiplicity of the element, in accordance to each element of the set A i.e. :m A N . However, this definition does not explain how to create a multiset of objects that is why we are going to define multiset of objects using concept of set of objects.\nDefinition 21. The multiset of objects is a set of objects 1 { ,..., } n S A A , such that ,i jA A S ± , where\n1, ,i j n and i j , 1( , )i jEq A A .\nWe can obtain a multiset of objects in the same way as a set of objects.\nExample 8. Let us consider objects A , B , C and sets of objects 1 S , 2 S from Example 5 and Example 6. Union of objects.\n/ ( ) / ( ) / ( ) / ( ) / ( ) { , , , , } / ( )S A T A A T A B T B B T B C T C A A B B C T S « « « «\nUnion of sets of objects.\n1 1 2 2 1 2 / ( ) / ( ) { , } / ( ) { , } / ( ) { , , , } / ( )S S T S S T S A B T S A C T S A A B C T S « «\nUnion of objects and sets of objects.\n2 2 2 / ( ) / ( ) / ( ) { , } / ( ) { , , } / ( )S A T A S T S A T A A C T S A A C T S « «\nUsing three different ways of creation, we have obtained three different multisets of objects. Let us define some auxiliary definitions connected with multisets of objects.\nDefinition 22. Cardinality of multiset of objects 1 { ,..., } n S A A is a quantity of objects, which it contains, i.e.\nS n .\nDefinition 23. Basic set of multiset of objects 1 { ,..., } n S A A is a set of objects bS , which is defining as follows\n1 ( ) { ,..., }b mS bs S A A ,\nwhere m n , ,i j bA A S ± , 1, ,i j m , i j , 0( , )i jEq A A and wA S ± , w bA S± .\nExample 9. If we have set of objects { , , , , , , , }S A A B B B C D D , then ( ) { , , , }bbs S S A B C D ."
    }, {
      "heading" : "Universal Constructor of Multisets of Objects",
      "text" : "As we can see, a multiset of objects can be obtained similarly to sets of objects. However, sometimes we need to recognize or identify particular copy of some elements, which have multiplicity 2m . That is why, we will consider universal constructor of multisets of objects, which was presented in [Terletskyi, 2014]. After that, we will show its generality, i.e. we can create arbitrary multiset of object, using this constructor. However, firstly we are going to define cloning operation on objects.\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 348\nDefinition 24. Clone of the arbitrary object A is the object ( ) / ( ) k i k i Clone A A P A , where ( )P A is a specification of object A , i is a number of its copy and k is a clone’s number of i A . If the object A is not a clone, then 0i .\nThe main idea of universal constructor of multisets of objects is superposition of union and cloning operation of objects. Example 10. Let us consider triangle A from previous section. Using cloning operation, we can create the clones of A , for example\n1 1 1 5 ( ) / ( ( ),..., ( ))Clone A A p A p A ; 2 2 1 5 ( ) / ( ( ),..., ( ))Clone A A p A p A ;\nClearly, that triangle A and its clones 1 A , 2 A are similar triangles. After this, we can apply union operation to them, and in such a way to create the multiset of triangles S , i.e.\n1 2 1 2 / ( ) / ( ) / ( ) { , , } / ( )S A T A A T A A T A A A A T S « « .\nThus, when we have done it, we have also created a new class of multiset of objects ( )T S , but in this case, it is\nequivalent to class ( )T A , i.e. 1 5 ( ) ( ) ( ( ),..., ( ))P S P A p A p A and 1 2 ( ) ( ) ( ( ), ( ))F S F A f A f A . That is why, S is a homogeneous multiset of objects.\nConsidering this example, we can conclude that\n2\n1 ( )i i S A Clone A\n§ · « ¨ ¸\n© ¹ * .\nIt means that we can create any multisets of objects, using arbitrary superposition of union and cloning operations of objects. According to this, we can define our universal constructor of multisets of objects (UCM) as follows\n1\n( , ) ( ) m\ni\ni\nUCM A m A Clone A § · « ¨ ¸\n© ¹ * ,\nwhere m is a multiplicity of object A . Example 11. Let us extend this constructor to inhomogeneous objects and consider for it the square B and the trapeze C , which were defined in the previous section. Using cloning operation, we can create the clones of object B and of object C , for example\n1 1 1 4 ( ) / ( ( ),..., ( ))Clone B B p B p B ; 1 1 1 5 ( ) / ( ( ),..., ( ))Clone C C p C p C ;\n2 2 1 5 ( ) / ( ( ),..., ( ))Clone C C p C p C .\nClearly, that object B and its clone 1 B are similar squares. We have the same situation in case of trapeze C and its clones 1 C , 2 C . After this, we can apply union operation to objects B , C and their clones 1 B , 1 C , 2 C , and in such a way to create a multiset of squares and trapezes S , i.e.\n1 1 2 1 1 2 / ( ) / ( ) / ( ) / ( ) / ( ) { , , , , } / ( )S B T B B T B C T C C T C C T C B B C C C T S « « « « .\nThus, when we have done it, we have also created a new class ( )T S with the following specification\n1 2 1 2 3 5 1 2 5 2 ( ) ( ( ), ( ), ( )) (( ( ), ( ), ( ), ( ), ( )),( ( )),( ( ), ( )))T S Core S pr B pr C p S p S p S p S f S f B p C f C .\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n349\nClearly, that S is the inhomogeneous multiset of objects, because 1 B B and 1 2 C C C , but B and C are objects of different classes. Considering this example, we can conclude that\n1\n1 1\n(( , ),...,( , )) ( ) imn\nn n i j i\ni j\nUCM A m A m A Clone A § ·§ · «¨ ¸¨ ¸¨ ¸\n© ¹© ¹ * * ,\nwhere 1 ,..., n m m are multiplicities of objects 1 ,..., n A A respectively.\nTheorem 1. Any multiset of objects can be created using UCM. Proof. Our proof consists of two parts, in which we are going to prove that any multiset of objects can be created using UCM(1) and arbitrary multiset of objects can be reduced to input data of UCM (2). First condition follows from UCM’s definition. Really, superposition of union and cloning operation in UCM guarantees multisets of objects in the result. Type of resultant multiset of objects depends on types of objects, which are parameters for UCM and their multiplicities. Second condition follows from that fact, that every multiset of object can be presented in accordance with the formal definition of multiset, i.e. if 1 { ,..., } k S A A is multiset of objects, then it can be presented as follows\n1 1 (( , ),...,( , )) n n S A m A m , where 1 ... n m m k , what is an input data for UCM. It means that we can create exactly the same multiset of objects, using tuple form of presentation of multiset as an input data for UCM, i.e. 1 1 1 (( , ),...,( , )) { ,..., } n n k UCM A m A m A A S . As we can see, this constructor is quite general and gives us an opportunity to create different types of multisets of objects, in particular homogeneous and inhomogeneous. Clearly that this constructor is determined if and only if 1 ,..., n m m are strictly defined. In addition, we are going to define a few other determined constructors of multisets of objects, which strictly define the multiplicity of each element, using for it their own schema."
    }, {
      "heading" : "CP Constructor",
      "text" : "This constructor of multisets of objects based on the idea of Cartesian product of two arbitrary sets, that is why we call it CP constructor. We use the idea of Cartesian product of sets. However, in contrast to classical definition of CP we define pairs of CP as sets of objects.\nExample 12. Let us consider situation that we need to construct electric garland, and we have green, yellow, orange, blue, purple and rosy light bulbs for it. Before we will make our garland, we need to create color scheme for it. It means we need to decide which colors and how many light bulbs of every color we want to use. It is convenient for us to denote every type of light bulbs according to first letter of its color. Let us assume that we want to use all colors, which we have, and each of them can be used more than once. Let us randomly divide all colors on two sets, for instance 1 { , , }S G Y O , 2 { , , }S B P R , and build all possible sets of objects which consist of elements of Cartesian product pairs, i.e.\n1 { , }S G B , 2 { , }S G P , 3 { , }S G R , 4 { , }S Y B , 5 { , }S Y P ,\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 350\n6 { , }S Y R , 7 { , }S O B , 8 { , }S O P , 9 { , }S O R .\nLet us apply union operation to these sets of objects, i.e.\n1 2 3 4 5 { , } / ( ) { , } / ( ) { , } / ( ) { , } / ( ) { , } / ( )S G B T S G P T S G R T S Y B T S Y P T S « « « « «\n6 7 8 9 { , } / ( ) { , } / ( ) { , } / ( ) { , } / ( )Y R T S O B T S O P T S O R T S« « « «\n{ , , , , , , , , , , , , , , , , , } / ( )G B G P G R Y B Y P Y R O B O P O R T S ,\nwhere S is multiset of objects and ( )T S is its class. Clearly, that all objects are similar, that is why class ( )T S\nis homogeneous. As the result, we have obtained multiset of objects, which consists of six objects G , Y , O , B , P , R and we can consider S as one of possible projects of future electric garland.\nGenerally we can represent this scheme as follows 3 3 3 3 3 3{( , ),( , ),( , ),( , ),( , ),( , )}S G Y O B P R , because S is a multiset of colors. Such form of presentation gives us quantity of each type of light bulbs. However, order of colors is very important aspects of garland’s creation. It is obvious that different orders of the same quantity of colors and placement of particular light bulbs give us different perception of garland. According to it, we can vary different combinations of light bulbs for finding needed combination. Sometimes we need to identify each light bulb of each color, for example for substitute. That is why we are going to improve our constructor in this aspect, via indexation operation.\nDefinition25. Indexation of object i A is a redefining of its index i , i.e. 1 ( ) / ( ( ),..., ( )) i i w n Ind A A p A p A , where i is an index of object A and w is its increase. According to this, the result of the Example 12 is the following\n1 1 1 2 1 2 3 1 3 1 2 4 2 2 5 { , } / ( ) { , } / ( ) { , } / ( ) { , } / ( ) { , } / ( )S G B T S G P T S G R T S Y B T S Y P T S « « « « «\n3 2 6 1 3 7 2 3 8 3 3 9 { , } / ( ) { , } / ( ) { , } / ( ) { , } / ( )Y R T S O B T S O P T S O R T S« « « «\n1 1 2 1 3 1 1 2 2 2 3 2 1 3 2 3 3 3 { , , , , , , , , , , , , , , , , , } / ( )G B G P G R Y B Y P Y R O B O P O R T S ,\nwhere S is a multiset of objects and ( )T S is its class. According to this, we can represent our CP constructor as follows\n1 2\n1 1\n( , ) ( ( ) ( )) n m\nj i i j\ni j\nCP S S Ind A Ind B «** ,\nwhere 1 S , 2 S are basic sets of objects for multiset of objects S , 1i A S± , 2jB S± , 1n S and 2m S .\nAs we can see, CP constructor gives us determined scheme for creation of multiset of objects. We also can calculate multiplicity of each object and cardinality of multiset before its creation. As a proof of these facts, we can formulate and prove following two theorems.\nTheorem 2. Cardinality of each multiset of objects S , which is obtained using CP constructor, can be calculated by the following formula\n2S nm ,\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n351\nwhere 1 n S , 2 m S .\nProof. As we know, cardinality of Cartesian product of two sets can be calculated as follows\n1 2 1 2 S S S S nm º .\nAccording to the fact, that elements of Cartesian product are pairs, we can conclude that 1 2 2( , )CP S S nm .\nTheorem 3. Multiplicity of each object i A from multiset of objects S , which is obtained using CP constructor, can be calculated by the following formula\n2 1\n1 2\n, | ; ( )\n, | ;\nj i j\ni\nk i k\nS B S A B m A\nS C S A C\n ± ° ® ± °̄\nwhere 1 2,i nm , 1,j n , 1,k m and 1 S , 2 S are basic sets of objects for multisets of objects S . Proof. Proof follows from the definition of Cartesian product of sets."
    }, {
      "heading" : "RCL Constructor",
      "text" : "The basic principle of this constructor is recursive cloning of set of objects that is why we call this constructor RCL constructor. We will combine the idea of object’s cloning with the idea of direct recursion, within RCL constructor, but firstly we need to define cloning operation for set of objects.\nDefinition 26. Clone of the arbitrary set of objects 1 { ,..., } / ( ) n S A A T S is the set of objects\n1 ( ) { ,..., } / ( ) i i n i Clone S A A T S ,\nwhere ( )T S is a class of set of objects S and i is a number of its clone.\nExample 13. Let us consider Example 12 and imagine that we have only green, yellow and red light bulbs. It means, that we have set of colors 1 { , , }S G Y R . Let us clone it once, and apply union operation to it and to the result of its cloning, i.e.\n2 1 1 1 1 1 1 1 1 1 1 / ( ) ( / ( )) { , , } / ( ) { , , } / ( )S S T S Clone S T S G Y R T S G Y R T S « «\n1 1 1 1 { , , , , , } / ( )G Y R G Y R T S .\nAs the result, we have obtained the multiset of colors 2 S . Let us repeat the same procedure for it.\n3 2 1 1 2 1 1 1 1 1 2 2 2 3 3 3 1 / ( ) ( / ( )) { , , , , , } / ( ) { , , , , , } / ( )S S T S Clone S T S G Y R G Y R T S G Y R G Y R T S « «\n1 1 1 2 2 2 3 3 3 1 { , , , , , , , , , , , } / ( )GY R G Y R G Y R G Y R T S .\nwhere 3 S is a multiset of objects, and 1 ( )T S is its class. As the result we have obtained multiset of objects which consists of three objects G , Y , R and their copies, that can be accurately identified and we can consider S as one of possible projects of future electric garland.\nUsing a scheme of creation of multiset of objects from Example 12, we can represent our RCL constructor as follows\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 352\n1\n1\n2\n1 1\n2\n0 1\n2\n, ;\n( ) ( ), ;\n( ) ( ( )), .\nn\nn\nn\nn n\nS n\nRCL S S Clone S n\nRCL S Clone RCL S n\n °° « ® ° « °̄\nwhere S is a basic set of objects for multiset of objects ( )nRCL S and n is a recursion depth.\nAs we can see, RCL constructor gives us defined order of colors. We also can calculate cardinality of garland and quantity of light bulbs of each color before garland’s creation. As a proof of these facts, we can formulate and prove following two theorems.\nTheorem4. Cardinality of each multiset of objects S , which is obtained using RCL constructor, can be calculated by the following formula\n2 iS n ,\nwhere n is a cardinality of basic set of objects and i is recursion depth. Proof. According to the scheme of RCL constructor, on each step we will make a union of two sets of objects, which have equal cardinality. It means, if bS n , then on the step 1i we have a multiset of objects which cardinality is calculated as follows 1 2 2n n n n . On the step 2i we have a multiset of object with cardinality 2 2 4n n n , i.e. 1 1 22 2 2n n n , on the step 3i we have 4 4 8n n n , i.e.\n2 2 3 2 2 2n n n , etc. It means that on the step i k we will have 1 12 2 2k k kn n n , that is why we can conclude that cardinality of resultant multiset of objects will be equal 2 in , where i is recursion depth (step).\nTheorem 5. Multiplicity of each object jA from multiset of objects S , which is obtained using RCL constructor, can be calculated by the following formula\n2( ) ijm A ,\nwhere i is a recursion depth of RCL constructor. Proof. We know, that on each step i RCL constructor will equally increase the multiplicity of all objects from set of objects i S , it follows from the scheme of RCL constructor. According to Theorem 4, cardinality of resultant multiset of objects 2iS n , where i is recursion depth of RCL constructor. Combining these two facts, we can conclude that 2 2( ) /i ijm A n n ."
    }, {
      "heading" : "PS Constructor",
      "text" : "First version of this constructor was presented in [Terletskyi, 2014] and now we are going to introduce its extension, which give us new abilities of its application. This constructor of multisets of objects is based on the idea of powerset of some set, which is why we will call it PS constructor.\nExample 14. Let us consider again Example 12 and build all possible subsets of colors according to Definition 19 for set of colors { , , }S G Y R , i.e.\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n353\n1 { , }S G Y , 2 { , }S G R , 3 { , }S Y R , 4 { , , }S G Y R .\nLet us apply union operation to sets of objects 1 4 ,...,S S , i.e.\n1 2 3 4 { , } / ( ) { , } / ( ) { , } / ( ) { , , } / ( )S G Y T S G R T S Y R T S G Y R T S « « «\n{ , , , , , , , , } / ( )G Y G R Y R G Y R T S ,\nwhere S is a multiset of objects, and ( )T S is its class. However, such form of PS constructor does not provide indexation of light bulbs of the same color that is why we will improve it in this direction. As we can see, PS constructor consists of two parts, first of them is selection of subsets from basic set of objects, and second one is union of these subsets. Clearly, that we need to select all possible subsets of objects from basic set of objects in such way, that all copies of each object have unique index. That is why, we will organize selection procedure of subsets marking a choice of every object from set of objects S , during selection of every its subset using increase indexation of chosen objects from set of objects S i.e.\n1 { , }S G R , 1 1 1 1 { ( ), ( ), } { , , }S Ind G Ind Y R G Y R ;\n2 1 { , }S G R , 1 1 1 1 2 1 1 { ( ), , ( )} { , , }S Ind G Y Ind R G Y R ;\n3 1 1 { , }S Y R , 2 1 1 1 1 2 2 2 { , ( ), ( )} { , , }S G Ind Y Ind R G Y R ;\n4 2 2 2 { , , }S G Y R , 1 2 1 2 1 2 3 3 3 { ( ), ( ), ( )} { , , }S Ind G Ind Y Ind R G Y R .\nLet us apply union operation to 1 4 ,...,S S and create new multiset of objects S , i.e.\n1 1 2 1 1 3 2 2 2 4 { , } / ( ) { , } / ( ) { , } / ( ) { , , } / ( )S G Y T S G R T S Y R T S G Y R T S « « «\n1 1 1 2 2 2 { , , , , , , , , } / ( )G Y G R Y R G Y R T S ,\nwhere S is a multiset of objects, and ( )T S is its class. As the result we have obtained a multiset of objects,\nwhich consists of three objects G , Y , R and their copies, which can be accurately identified and we can consider S as one of possible projects of future electric garland.\nNow we can formulate and prove the following proposition.\nProposition 1. The quantity of all possible subsets of sets of objects S can be calculated by the following formula\n2 1( ) n w q S n ,\nwhere n S .\nProof. As we know, powerset of any set A is the set of all subsets of A , including the empty set © and A itself, and it is denoted like\n( ) { | }P A P P A ° .\nI.e. for the set { , , }A a b c\n( ) {{ }, { }, { }, { }, { , }, { , }, { , }, { , , }}P A a b c a b a c b c a b c © .\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 354\nWe also know that cardinality of powerset ( )P A of a set A can be calculated using the following formula\n2( ) nP A ,\nwhere n A . However, according to the Definition 19, { }© , { }a , { }b , { }c are not sets and set cannot be an\nelement of another set. That is why in case of sets of objects previous formula can be rewritten as follows\n2 1( ) n w q S n ,\nwhere w S S° , ( ) w q S is a quantity of all possible w S . Using Proposition 1 and scheme of creation of multiset of objects from Example 14, we can represent our PS constructor as follows\n2 1\n1\n( )\nn n\nw\nw\nPS S S * ,\nwhere S is a basic set of objects for multiset of objects ( )PS S and w S S° . As we can see, PS constructor gives us determined scheme for creation of multiset of objects. We also can calculate multiplicity of every object and cardinality of multiset before its creation. As a proof of these facts, we can formulate and prove two following theorems.\nTheorem 6. The cardinality of each multiset of objects S , which is obtained using PS Constructor, can be calculated by the following formula\n2 2\nnn S n ,\nwhere bn S .\nProof. Let us consider the set 1 { , , }S A B C and build a powerset for it, i.e.\n1 ( ) {{ }, { }, { }, { }, { , }, { , }, { , }, { , , }}P S A B C A B A C B C A B C © .\nLet us create the multiset 1 M as a union of all elements of 1 ( )P S , i.e.\n1 { } { } { } { } { , } { , } { , } { , , } { , , , , , , , , , , , }M A B C A B A C B C A B C A B C A B A C B C A B C © « « « « « « « .\nClearly that 1 12M . Let us consider the set 2 { , , , }S A B C D and build a powerset for it, i.e.\n2 ( ) {{ }, { }, { }, { }, { }, { , }, { , }, { , }, { , }, { , }, { , },P S A B C D A B A C A D B C B D C D ©\n{ , , }, { , , }, { , , }, { , , }, { , , , }}A B C A B D A C D B C D A B C D .\nLet us create the multiset 2 M as a union of all elements of 2 ( )P S , i.e.\n2 { } { } { } { } { } { , } { , } { , } { , } { , } { , }M A B C D A B A C A D B C B D C D © « « « « « « « « « « «\n{ , , } { , , } { , , } { , , } { , , , }A B C A B D A C D B C D A B C D« « « « «\n{ , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , }A B C D A B AC A D B C B D C D A B C A B D A C D B C D A B C D .\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n355\nAs you can see 2 32M . We know that 2( ) nP S , where n S . Clearly that in the case of 1 S ,\n3\n1 2 8( )P S and we can put\n3\n1\n3 2 12\n2 M\nº ,\nas it is really so. In the case of 2 S , 4 2 2 16( )P S and similar to the previous case we can put\n4\n2\n4 2 32\n2 M\nº ,\nas we can see it is also true. Based on principle of mathematical induction we can conclude that for ( ) n P S ,\n2 2\nn\nn\nn M .\nLet us consider the set of objects { , , } k S A B C and build for it all possible subsets of objects considering Definition 19, i.e.\n1 { , }S A B , 2 { , }S A C , 3 { , }S B C , 4 { , , }S A B C .\nLet us create the multiset of objects k M as a union of all subset of k S , i.e.\n1 2 3 4 { , } / ( ) { , } / ( ) { , } / ( ) { , , } / ( )kM A B T S A C T S B C T S A B C T S « « «\n{ , , , , , , , , } / ( ) k A B A C B C A B C T M .\nClearly that in the case of kM , the formula which was used for calculation nM will be changed to\n2 2\nk\nk\nk M k ,\nwhere kk M .\nTheorem 7. The multiplicity of each object i A from the multiset of objects S, which is obtained using PS constructor, can be calculated by the following formula\n1 2 1( ) n\ni m A ,\nwhere bn S .\nProof. We know that generating of possible subsets of objects 1 ,..., w S S for set of objects bS can be represented as a combination of 2,k n different elements from the set of n elements, i.e. k\nn C . During\ncreation of subsets of cardinality 2 , we need to combine every object i A with every object from the set of objects \\b iS A . Clearly, we can create only 1n such subsets, i.e. 1 1n C . In the case of subsets of cardinality 3 , we will have 2\n1n C , and finally, in the case of subsets of cardinality k we will have\n1 1\nk\nn C .\nAccording to the scheme of PC constructor, we can conclude that multiplicity of every object i A from multiset of objects S consists of multiplicities of object i A in every subset of objects, i.e.\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 356\n2 1\n1\n( ) ( )\nn n\ni w i\nw\nm A m A ¦ ,\nwhere ( ) w i m A is the multiplicity of object i A in the subset of objects w bS S° . It follows from 1 ... wS S« « , where 2 1 nw n . Using this fact, we can conclude that\n1 1 1 1 ( ) ... n i n n m A C C ,\nwhere bn S . It means that every object iA S± has the same multiplicity. Using this fact, we can conclude that\n1\n2 2 1 2 22 1 2 1\n2 2 2 ( )\nn\nn n n n\ni\nb\nn nS n n n\nm A n S n n n n\n§ · ¨ ¸\n© ¹ ,\nwhere bn S .\nLet us consider proof of Theorem 7. It shows that multiplicity of every object i A from multiset of objects S can be calculated as a sum of appropriate binomial coefficients. Using this fact, we can build a part of Pascal’s triangle. However, in contrast to original Pascal’s triangle, we will combine its part with results of Theorem 6 and Theorem 7. It is convenient to formulate it as a following corollary.\nCorollary 7.1. We can calculate cardinality, multiplicity of every object from the multiset of objects, which was created using PS constructor, and quantity of subsets of objects which were used for its creation, using the following matrix\n2 3 4 5 6\n1 2 1 2 1 3 9 4 3 3 1 7 28 11 4 6 4 1\n15 75 26 5 10 10 5 1 31 186 57 6 15 20 15 6 1\n( ) ( ) ...\n... ... ... ... ... ... ... ... ... ...\nk w bm A S q S S\n,\nwhere column ( ) k m A reflects multiplicity of object k A in multiset of objects S ; column S reflects cardinality of multiset of objects S ; column ( ) w q S reflects quantity of w bS S° that was used for establishing S ; column\nbS reflects cardinality of basic sets of objects; first row starting with 5-th column reflects quantity of subsets of\nobjects of certain cardinality, where cardinality coincides with the value of 1 5, ja .\nThe elements of column ( ) k m A can be calculated using Theorem 7 or using the following formula\n2 1 1\n2 4\n1 2\n2, , ,\n, ;\n, .i i j\ni j\ni a a i ° ® °̄ ¦\nThe elements of column S can be calculated using Theorem 6 or using the following formula\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n357\n2 2 1\n2 5\n, , ,\n,\ni i j j\ni j\na a a º¦ .\nThe elements of column ( ) w q S can be calculated using Proposition 1 or using the following formula\n2 3\n2 5\n, ,\n,\ni i j\ni j\na a ¦ ."
    }, {
      "heading" : "The element",
      "text" : "2 5,i ja of the matrix can be calculated in such a way\n2 5\n1 1 1\n1 1\n3 ,\n, ,\n, ;\n, .i j i j i j\nj i a\na a j i\n° ® °̄\nor using the following formula\n4\n2 5\n1 4 1\n,\n,\n, , ,\n!\n!( )!\ni\ni j\nj i j\na a\na a a\n."
    }, {
      "heading" : "D2 Constructor",
      "text" : "Similarly, to PS constructor, the first version of this constructor was also presented in [Terletskyi, 2014] and now we introduce its extension, which give us new abilities of its application. This constructor of multisets of objects is based on decomposition of basic set of objects on two disjoint subsets such, that in the result of their union we will obtain initial (basic) set of objects. That is why we call this constructor as D2 constructor. Example15. Let us consider Example 12 and imagine that we have light bulbs of green, yellow, red and blue colors, it means that we have set of colors { , , , }S G Y R B . Let us perform D2 decomposition of it and find all possible variants of such decomposition, i.e.\n1 { , }S G Y , 2 { , }S R B ; 3 { , }S G R , 4 { , }S Y B ; 5 { , }S G B , 6 { , }S Y R .\nLet us apply union operation to these sets of objects, i.e.\n1 2 3 4 { , } / ( ) { , } / ( ) { , } / ( ) { , } / ( )S GY T S R B T S G R T S Y B T S « « « «\n5 6 { , } / ( ) { , } / ( ) { , , , , , , , , , , , } / ( )G B T S Y R T S G Y R B G R Y B G B Y R T S« « ,\nwhere S is a multiset of objects, and ( )T S is its class. However, such form of D2 constructor does not provide indexation of light bulbs of same color that is why we will improve it in this direction.\nAs we can see, as the result of D2 decomposition of set of objects, we have obtained sets of objects 1 6 ,...,S S . It means that in this case, there are three possible variants of such decomposition. Each variant of decomposition consists of pair of sets of objects. Let us change indexes of objects of these sets into accordance with number of decomposition’s variant, using indexation operation, i.e.\n1 1 1 1 1 { ( ), ( )} { , }S Ind G Ind Y G Y , 2 1 1 1 1 { ( ), ( )} { , }S Ind R Ind B R B ,\n3 2 2 2 2 { ( ), ( )} { , }S Ind G Ind R G R , 4 2 2 2 2 { ( ), ( )} { , }S Ind Y Ind B Y B ,\n5 3 3 3 3 { ( ), ( )} { , }S Ind G Ind B G B , 6 3 3 3 3 { ( ), ( )} { , }S Ind Y Ind R Y R .\nNow, let us apply union operation to these sets and create new multiset of objects S , i.e.\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 358\n1 1 1 1 1 2 2 2 3 2 2 4 3 3 5 { , } / ( ) { , } / ( ) { , } / ( ) { , } / ( ) { , } / ( )S G Y T S R B T S G R T S Y B T S G B T S « « « « «\n3 3 6 1 1 1 1 2 2 2 2 3 3 3 3 { , } / ( ) { , , , , , , , , , , , } / ( )Y R T S G Y R B G R Y B G B Y R T S« ,\nwhere S is a multiset of objects, and ( )T S is its class. As the result we obtained multiset of objects S which\nconsists of four objects G , Y , R , B and their copies, which can be accurately identified. We can consider S as one of possible projects of future electric garland.\nNow we can formulate and prove the following proposition.\nProposition2. The quantity of all possible subsets of sets of objects S , which were obtained using D2 decomposition, can be calculated by the following formula\n2 2 2( ) nwq S n ,\nwhere n S .\nProof. From the previous section, we know that the quantity of all possible subsets of set of objects can be calculated as 2 1( ) nwq S n , where n S . However, we can observe that the result of D2 decomposition of set of objects { , , , }S G Y R B does not contain subsets of cardinality 3 and 4 , i.e. 1n and n . It is true for any set of objects, because only sets of cardinality n and 1n cannot be divided according to principle of D2 decomposition. Clearly, that for each set of objects S of cardinality n , only one subset of cardinality n exists. Concerning subsets of cardinality 1n , their quantity can be calculated as\n1\n1 1 1 1 1\n! ! !\n( )!( ( ))! ( )! ! ( )!\nn n\nn n n C n\nn n n n n\n,\nit follows from the proof of Theorem 7. Considering all these facts, we can conclude that\n2 1 1 2 2 2( ) n nwq S n n n ,\nwhere n S .\nUsing Proposition 2 and the scheme of creation of multiset of objects from Example 15, we can represent our D2 constructor as follows\n2 2 2\n1 2\n1\n2( ) ( )\nn n\nw\nD S S S «* ,\nwhere n S and 1 2 ,S S S° are disjoint sets of objects, such that 1 2 S S S« .\nAs we can see, D2 constructor gives us determined scheme for creation of multiset of objects. We also can calculate multiplicity of every object and cardinality of the multiset before its creation. As a proof of these facts, we can formulate and prove two following theorems.\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n359\nTheorem 8. The cardinality of each multiset of objects S , which is obtained using D2 constructor, can be calculated by the following formula\n22 2\nnn S n n ,\nwhere bn S .\nProof. According to Theorem 6, cardinality of each multiset of objects S , which is obtained using PS Constructor, can be calculated by the following formula\n2 2\nnn S n ,\nwhere bn S . From proof of Proposition 2, we know that result of D2 decomposition of set of objects S does not contain subsets of cardinality 1n , n and quantity of such subsets of objects will be equal n and 1 respectively. That is why we can conclude that\n2 22 2 2 1 2\n2 2 2 ( )\nn n nn n n S n n n n n n n n n ,\nwhere bn S\nTheorem 9. Multiplicity of each object i A from multiset of objects S , which is obtained using D2 constructor, can be calculated by the following formula\n1 2 1( ) nim A n ,\nwhere bn S .\nProof. From proof of Theorem 7 we know that it is possible to build only 1\n1\nk nC subsets of cardinality k for set of\nobjects bS , where bS n . In addition, we know that each object iA S± has the same multiplicity. Using these facts, we can conclude that\n2\n2\n2\n2 2 1 2 22 1\n2 2 2 ( )\nn\nn n n\ni\nb\nn n nS n n n n\nm A n n n S n n n n n\n§ · ¨ ¸ © ¹\n1\n12 2 2 2 2 1 2 1\n2 2\n( )n n nn n n\n,\nwhere bn S .\nLet us consider proof of Theorem 9. It shows that multiplicity of every object i A from multiset of objects S can be calculated as a sum of appropriate binomial coefficients. Using this fact, we can build a part of Pascal’s triangle. However, in contrast to original Pascal’s triangle, we will combine its part with results of Theorem 8 and Theorem 9. It is convenient to formulate this as following corollary.\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014 360\nCorollary 9.1. We can calculate cardinality, multiplicity of every object from the multiset of objects, which was created using D2 constructor, and quantity of subsets of objects which were used for its creation, using the following matrix\n2 3 4 5 6\n3 12 6 4 6\n10 50 20 5 10 10 25 150 50 6 15 20 15 56 392 112 7 21 35 35 21\n119 952 238 8 28 56 70 56 28\n( ) ( ) ...\n... ... ... ... ... ... ... ... ... ...\nk w bm A S q S S\n,\nwhere column ( ) k m A reflects multiplicity of object k A in multiset of objects S ; column S reflects cardinality of multiset of objects S ; column ( ) w q S reflects quantity of w bS S° that was used for obtaining S ; column\nbS reflects cardinality of basic sets of objects; first row starting with 5-th column reflects quantity of subsets of\nobjects of certain cardinality, where cardinality coincides with the value of 1 5, ja .\nThe elements of column ( ) k m A can be calculated using Theorem 9 or using the following formula\n2 1 1\n2 4\n3 2\n2, ,\n,\n, ;\n, .i i j\ni j\ni a a i ° ® ! °̄ ¦\nThe elements of column S can be calculated using Theorem 8 or using the following formula\n2 2 1\n2 5\n, , ,\n,\ni i j j\ni j\na a a º¦ .\nThe elements of column ( ) w q S can be calculated using Proposition 2 or using the following formula\n2 3\n2 5\n, ,\n,\ni i j\ni j\na a ¦ .\nThe element 2 5,i ja of matrix can be calculated in such a way\n2 5 1 1 1 1\n1 1 1\n6 2 5\n5 3\n3\n, , ,\n, ,\n, , ;\n, , ; , ; i j i j j\ni j i j\ni j\na a a j j i\na a j i\n ° ! ® ° ¯\nor using the following formula\n4\n2 5\n1 4 1\n,\n,\n, , ,\n!\n!( )!\ni\ni j\nj i j\na a\na a a\n."
    }, {
      "heading" : "Conclusions",
      "text" : "This paper presents certain approach for modeling of some aspects of human thinking, in particular creation of sets and multisets of objects, within constructive object-oriented version of set theory, which was proposed in [Terletskyi, 2014]. The creation of sets and multisets of objects is considered from different sides, in particular classical set theory, object-oriented programming and development of intelligent information systems.\nInternational Journal “Information Theories and Applications”, Vol. 21, Number 4, 2014\n361\nThe paper also presents universal constructor of multisets of objects that gives us a possibility to create arbitrary multisets of objects and to recognize (identify) every copy of particular object, which have multiplicity 2m . In addition, a few determined constructors of multisets of objects, which allow to create multisets, using strictly defined schemas, are also presented in the paper. The author proposed methods for calculation multiplicity of each object and cardinality of multiset before its creation for each constructor. That makes them very useful in cases of very big cardinalities of multisets. The proposed approach for modeling of creation of sets and multisets of objects allows not only creation (generation) of sets and multisets of objects, but also their classification. It gives us an opportunity to consider the problem of object classification and identification in another way. The presented constructors of multisets of objects allow us to model corresponding processes of human thought, that in turn give us an opportunity to develop intelligent information systems, using these tools."
    } ],
    "references" : [ {
      "title" : "Contributions to the Founding of the Theory of Transfinite Numbers",
      "author" : [ "G. Cantor" ],
      "venue" : "New York: Dover Publications, Inc.",
      "citeRegEx" : "Cantor. 1915",
      "shortCiteRegEx" : null,
      "year" : 1915
    }, {
      "title" : "Thinking in Java: 4-th Edition",
      "author" : [ "B. Eckel" ],
      "venue" : "Prentice Hall",
      "citeRegEx" : "Eckel. 2006",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Ye",
      "author" : [ "A.A. Fraenkel" ],
      "venue" : "Bar-Hillel. Foundations of set theory. North-Holland Publishing Company",
      "citeRegEx" : "Fraenkel. Bar.Hillel. 1958",
      "shortCiteRegEx" : null,
      "year" : 1958
    }, {
      "title" : "Constructible Sets with Applications",
      "author" : [ "A. Mostowski" ],
      "venue" : "North-Holland Publishing Company",
      "citeRegEx" : "Mostowski. 1969",
      "shortCiteRegEx" : null,
      "year" : 1969
    }, {
      "title" : "STL Tutorial and Reference Guide: 2-nd edition",
      "author" : [ "D.R. Musser", "G.J. Derge", "A. Saini" ],
      "venue" : "C++ Programming with the Standard Template Library, Addison-Wesley Professional",
      "citeRegEx" : "Musser. Derge. Saini. 2001",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "OOP – Learn Object Oriented Thinking and Programming",
      "author" : [ "R. Pecinovsky" ],
      "venue" : "Tomas Bruckner, RepinZivonin",
      "citeRegEx" : "Pecinovsky. 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Programming in Python 3",
      "author" : [ "M. Summerfield" ],
      "venue" : "A Complete Introduction to the Python Language: 2-nd edition. Pearson Education, Inc.",
      "citeRegEx" : "Summerfield. 2010",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Mathematics of multisets. In Proceedings of the “Workshop on Multiset Processing: Multiset Processing, Mathematical, Computer Science, and Molecular Computing Points of View",
      "author" : [ "A. Syropoulos" ],
      "venue" : "[Syropoulos,",
      "citeRegEx" : "Syropoulos.,? \\Q2001\\E",
      "shortCiteRegEx" : "Syropoulos.",
      "year" : 2001
    }, {
      "title" : "Mathematics in the alternative set theory",
      "author" : [ "P. Vopenka" ],
      "venue" : "Leipzig: BSB B.G. Teubner",
      "citeRegEx" : "Vopenka. 1979",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "Les Systemes Axiomatiques de la Theorie des Ensembles",
      "author" : [ "H. Wang", "R. Mc Naughton" ],
      "venue" : "Paris: Gauthier-Villars",
      "citeRegEx" : "Wang. Mc Naughton. 1953",
      "shortCiteRegEx" : null,
      "year" : 1953
    }, {
      "title" : "The Object-Oriented Thought Process",
      "author" : [ "M. Weisfeld" ],
      "venue" : "Third Edition. Addison-Wesley Professional",
      "citeRegEx" : "Weisfeld. 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Introduction Nowadays there are different versions of set theory, such as naive set theory of Cantor [Cantor, 1915], type theory of Russell [Wang, Mc Naughton, 1953], Zermelo-Fraenkel set theory [Fraenkel, Bar-Hillel, 1958; Wang, Mc Naughton, 1953], Von Neumann-Bernays-Gedel set theory [Wang, Mc Naughton, 1953], systems of Quine's set theory [Wang, Mc Naughton, 1953], constructible sets of Mostowski [Mostowski, 1969], alternative set theory of Vopenka [Vopenka, 1979], etc.",
      "startOffset" : 101,
      "endOffset" : 115
    }, {
      "referenceID" : 9,
      "context" : "Introduction Nowadays there are different versions of set theory, such as naive set theory of Cantor [Cantor, 1915], type theory of Russell [Wang, Mc Naughton, 1953], Zermelo-Fraenkel set theory [Fraenkel, Bar-Hillel, 1958; Wang, Mc Naughton, 1953], Von Neumann-Bernays-Gedel set theory [Wang, Mc Naughton, 1953], systems of Quine's set theory [Wang, Mc Naughton, 1953], constructible sets of Mostowski [Mostowski, 1969], alternative set theory of Vopenka [Vopenka, 1979], etc.",
      "startOffset" : 140,
      "endOffset" : 165
    }, {
      "referenceID" : 2,
      "context" : "Introduction Nowadays there are different versions of set theory, such as naive set theory of Cantor [Cantor, 1915], type theory of Russell [Wang, Mc Naughton, 1953], Zermelo-Fraenkel set theory [Fraenkel, Bar-Hillel, 1958; Wang, Mc Naughton, 1953], Von Neumann-Bernays-Gedel set theory [Wang, Mc Naughton, 1953], systems of Quine's set theory [Wang, Mc Naughton, 1953], constructible sets of Mostowski [Mostowski, 1969], alternative set theory of Vopenka [Vopenka, 1979], etc.",
      "startOffset" : 195,
      "endOffset" : 248
    }, {
      "referenceID" : 9,
      "context" : "Introduction Nowadays there are different versions of set theory, such as naive set theory of Cantor [Cantor, 1915], type theory of Russell [Wang, Mc Naughton, 1953], Zermelo-Fraenkel set theory [Fraenkel, Bar-Hillel, 1958; Wang, Mc Naughton, 1953], Von Neumann-Bernays-Gedel set theory [Wang, Mc Naughton, 1953], systems of Quine's set theory [Wang, Mc Naughton, 1953], constructible sets of Mostowski [Mostowski, 1969], alternative set theory of Vopenka [Vopenka, 1979], etc.",
      "startOffset" : 195,
      "endOffset" : 248
    }, {
      "referenceID" : 9,
      "context" : "Introduction Nowadays there are different versions of set theory, such as naive set theory of Cantor [Cantor, 1915], type theory of Russell [Wang, Mc Naughton, 1953], Zermelo-Fraenkel set theory [Fraenkel, Bar-Hillel, 1958; Wang, Mc Naughton, 1953], Von Neumann-Bernays-Gedel set theory [Wang, Mc Naughton, 1953], systems of Quine's set theory [Wang, Mc Naughton, 1953], constructible sets of Mostowski [Mostowski, 1969], alternative set theory of Vopenka [Vopenka, 1979], etc.",
      "startOffset" : 287,
      "endOffset" : 312
    }, {
      "referenceID" : 9,
      "context" : "Introduction Nowadays there are different versions of set theory, such as naive set theory of Cantor [Cantor, 1915], type theory of Russell [Wang, Mc Naughton, 1953], Zermelo-Fraenkel set theory [Fraenkel, Bar-Hillel, 1958; Wang, Mc Naughton, 1953], Von Neumann-Bernays-Gedel set theory [Wang, Mc Naughton, 1953], systems of Quine's set theory [Wang, Mc Naughton, 1953], constructible sets of Mostowski [Mostowski, 1969], alternative set theory of Vopenka [Vopenka, 1979], etc.",
      "startOffset" : 344,
      "endOffset" : 369
    }, {
      "referenceID" : 3,
      "context" : "Introduction Nowadays there are different versions of set theory, such as naive set theory of Cantor [Cantor, 1915], type theory of Russell [Wang, Mc Naughton, 1953], Zermelo-Fraenkel set theory [Fraenkel, Bar-Hillel, 1958; Wang, Mc Naughton, 1953], Von Neumann-Bernays-Gedel set theory [Wang, Mc Naughton, 1953], systems of Quine's set theory [Wang, Mc Naughton, 1953], constructible sets of Mostowski [Mostowski, 1969], alternative set theory of Vopenka [Vopenka, 1979], etc.",
      "startOffset" : 403,
      "endOffset" : 420
    }, {
      "referenceID" : 8,
      "context" : "Introduction Nowadays there are different versions of set theory, such as naive set theory of Cantor [Cantor, 1915], type theory of Russell [Wang, Mc Naughton, 1953], Zermelo-Fraenkel set theory [Fraenkel, Bar-Hillel, 1958; Wang, Mc Naughton, 1953], Von Neumann-Bernays-Gedel set theory [Wang, Mc Naughton, 1953], systems of Quine's set theory [Wang, Mc Naughton, 1953], constructible sets of Mostowski [Mostowski, 1969], alternative set theory of Vopenka [Vopenka, 1979], etc.",
      "startOffset" : 456,
      "endOffset" : 471
    }, {
      "referenceID" : 4,
      "context" : "As a proof, there are appropriate tools within some OOP-languages for working with such data structure, in particular set in STL for C++ [Musser, Derge, Saini, 2001], HashSet, SortedSet and ISet in C# [Mukherjee, 2012], HashSet in Java [Eckel, 2006], set and frozenset in Python [Summerfield, 2010].",
      "startOffset" : 137,
      "endOffset" : 165
    }, {
      "referenceID" : 1,
      "context" : "As a proof, there are appropriate tools within some OOP-languages for working with such data structure, in particular set in STL for C++ [Musser, Derge, Saini, 2001], HashSet, SortedSet and ISet in C# [Mukherjee, 2012], HashSet in Java [Eckel, 2006], set and frozenset in Python [Summerfield, 2010].",
      "startOffset" : 236,
      "endOffset" : 249
    }, {
      "referenceID" : 6,
      "context" : "As a proof, there are appropriate tools within some OOP-languages for working with such data structure, in particular set in STL for C++ [Musser, Derge, Saini, 2001], HashSet, SortedSet and ISet in C# [Mukherjee, 2012], HashSet in Java [Eckel, 2006], set and frozenset in Python [Summerfield, 2010].",
      "startOffset" : 279,
      "endOffset" : 298
    }, {
      "referenceID" : 0,
      "context" : "Everything, phenomena of our imagination or of our world can be the elements of the set [Cantor, 1915].",
      "startOffset" : 88,
      "endOffset" : 102
    }, {
      "referenceID" : 5,
      "context" : "From other hand, one of the main postulates of OOP is that real world is created by objects [Pecinovsky, 2013].",
      "startOffset" : 92,
      "endOffset" : 110
    }, {
      "referenceID" : 10,
      "context" : " In OOP, programmers consider specifications and methods of objects without objects, and they call it a type or a class of objects, which consists of fields and methods [Weisfeld, 2008; Pecinovsky, 2013].",
      "startOffset" : 170,
      "endOffset" : 204
    }, {
      "referenceID" : 5,
      "context" : " In OOP, programmers consider specifications and methods of objects without objects, and they call it a type or a class of objects, which consists of fields and methods [Weisfeld, 2008; Pecinovsky, 2013].",
      "startOffset" : 170,
      "endOffset" : 204
    }, {
      "referenceID" : 0,
      "context" : "Sets and Multisets of Objects According to Naive set theory, a set is a gathering together into a whole of definite, distinct objects of our perception or of our thought, which are called elements of the set [Cantor, 1915].",
      "startOffset" : 208,
      "endOffset" : 222
    }, {
      "referenceID" : 7,
      "context" : "As we know, multiset is a generalization of the notion of set in which members are allowed to appear more than once [Syropoulos, 2001].",
      "startOffset" : 116,
      "endOffset" : 134
    } ],
    "year" : 2015,
    "abstractText" : "This paper contains analysis of creation of sets and multisets as an approach for modeling of some aspects of human thinking. The creation of sets is considered within constructive object-oriented version of set theory (COOST), from different sides, in particular classical set theory, object-oriented programming (OOP) and development of intelligent information systems (IIS). The main feature of COOST in contrast to other versions of set theory is an opportunity to describe essences of objects more precisely, using their properties and methods, which can be applied to them. That is why this version of set theory is object-oriented and close to OOP. Within COOST, the author proposes universal constructor of multisets of objects that gives us a possibility to create arbitrary multisets of objects. In addition, a few determined constructors of multisets of objects, which allow creating multisets, using strictly defined schemas, also are proposed in the paper. Such constructors are very useful in cases of very big cardinalities of multisets, because they give us an opportunity to calculate a multiplicity of each object and cardinality of multiset before its creation. The proposed constructors of multisets of objects allow us to model in a sense corresponding processes of human thought, that in turn give us an opportunity to develop IIS, using these tools.",
    "creator" : "PScript5.dll Version 5.2.2"
  }
}