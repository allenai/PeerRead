{
  "name" : "1406.6102.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Random Logic Programs: Linear Model",
    "authors" : [ "Kewen Wang", "Lian Wen", "Kedian Mu" ],
    "emails" : [ "k.wang@griffith.edu.au)", "l.wen@griffith.edu.au)", "mukedian@math.pku.edu.cn)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "KEYWORDS: answer set programming, random logic programs."
    }, {
      "heading" : "1 Introduction",
      "text" : "As in the case of combinatorial structures, the study of randomly generated instances of NPcomplete problems in artificial intelligence has received significant attention in the last two decades. These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999). In turn, these results on properties of random SAT and random CSP significantly help researchers in better understanding SAT and CSP, and developing fast solvers for them.\nOn the other hand, it is well known that reasoning in propositional logic and in most constraint languages is monotonic in the sense that conclusions obtained before new information is added cannot be withdrawn. However, commonsense knowledge is nonmonotonic. In artificial intelligence, significant effort has been paid to develop fundamental problem solving paradigms that allow users to conveniently represent and reason about commonsense knowledge and solve problems in a declarative way. Answer set programming (ASP) is currently one of the most widely used nonmonotonic reasoning systems due to its simple syntax, precise semantics and importantly, the availability of ASP solvers, such as clasp (Gebser et al. 2009), dlv (Leone et al. 2006), and smodels (Syrjänen and Niemelä 2001). However, the theoretical study of random ASP has not made much progress so far (Namasivayam and Truszczynski 2009; Namasivayam 2009; Schlipf et al. 2005; Zhao and Lin 2003).\n(Zhao and Lin 2003) first conducted an experimental study on the issue of phase transition for randomly generated ASP programs whose rules can have three or more literals. (Schlipf\nar X\niv :1\n40 6.\n61 02\nv1 [\ncs .A\nI] 2\net al. 2005) reported on their experimental work for determining the distribution of randomly generated normal logic programs at the Dagstuhl Seminar.\nTo study statistical properties for random programs, (Namasivayam and Truszczynski 2009; Namasivayam 2009) considered the class of randomly generated ASP programs in which each rule has exactly two literals, called simple random programs. Their method is to map some statistical properties of random graphs into simple random programs by transforming a random program into that of a random graph through a close connection between simple random programs and random graphs. As the authors have commented, those classes of random programs that correspond to some classes of random graphs are too restricted to be useful. Their effort further confirms that it is challenging to recast statistical properties of SAT/CSP to nonmonotonic formalisms such as ASP.\nIn fact, the monotonicity plays an important role in proofs of major results for random SAT/CSP. Specifically, major statistical properties for SAT/CSP are based on a simple but important property: An interpretation M is a model of a set of clauses/constraints if and only if M is a model of each clause/constraint. Due to the lack of monotonicity in ASP, this property fails to hold for ASP and other major nonmonotonic formalisms.\nFor this reason, it might make sense to first focus on some relatively simple but expressive classes of ASP programs (i.e., still NP-complete). We argue that the class of negative two-literal programs (i.e. normal logic programs in which a rule body has exactly one negative literal) is a good start for studying random logic programs under answer set semantics for several reasons1: (1) The problem of deciding if a negative two-literal program has an answer set is still NP-complete. In fact, the class of negative two-literal programs is used to show the NP-hardness of answer set semantics for normal logic programs in (Marek and Truszczynski 1991) (Theorem 6.4 and its proof, where a negative two-literal program corresponds to a simple K1-theory). (2) Many important NP-complete problems can be easily encoded as (negative) two-literal programs (Huang et al. 2002). (3) Negative two-literal programs allow us to conduct large scale experiments with existing ASP solvers, such as smodels, dlv and clasp.\nIn this paper we introduce a new model for generating and studying random negative twoliteral programs, called linear model. A random program generated under the linear model is of the size about c×n where c is a constant and n is the total number of atoms. We choose such a model of randomly generating negative two-literal programs for two reasons. First, if we use a natural way to randomly generate programs like what has been done in SAT and CSP, we would come up with two possible models in terms of program sizes (i.e. linear in n and quadratic in n), since only n2 negative two-literal rules in total can be generated from a set of n atoms. We study statistical properties of such random programs and have obtained both theoretical and experimental results for random programs generated under the linear model, especially, Theorem 1. These properties include the average number of answer sets, the size distribution of answer sets, and the distribution of consistent programs under the linear model. Second, such results can be used in practical applications. For instance, it is important to compute all answer sets of a program in applications, such as diagnoses and query answering, in P-log (Baral et al. 2009). In such cases, the number of answer sets for a program is certainly relevant. If we know the number of answer sets and the average size of the answer sets for a logic program, such information\n1 Our definition of negative two-literal programs here is slightly different from that used by some other authors. But these definitions are essentially equivalent if we notice that a fact rule a← can be expressed as a rule a← not a′ where a′ is a new atom. Details can be found in Section 2.\ncan be useful heuristics for finding all answer sets of a given program. Also, the linear model of random programs may be useful in application domains such as ontology engineering where most of large practical ontologies are sparse in the sense that the ratio of terminological axioms to concepts/roles is relatively small (Staab and Studer 2004).\nThe contributions of this work can be summarised as follows:\n1. A model for generating random logic programs, called the linear model, is established. Our model generates random logic programs in a similar way as SAT and CSP, but we distinguish the probabilities for picking up pure rules and contradiction rules. (Namasivayam and Truszczynski 2009) discusses some program classes of two-literal programs that may not be negative. However, as their major results are inherited from the corresponding ones in random graph theory, such results hold only for very special classes of two-literal programs. For instance, in regard to the result on negative two-literal programs without contradiction rules (Theorem 2, page 228), the authors pointed out that the theorem “concerns only a narrow class of dense programs, its applicability being limited by the specific number of rules programs are to have” (0 < c < 1, x is a fixed number, the number of rules m = bcN + x √ c(c−1)Nc and N = n(n−1))2. 2. We mathematically show that the average number of answer sets for a random program converges to a constant when the number of atoms approaches infinity. We note that the proofs of statistical properties, such as phase transitions, for random SAT and random CSP are usually obtained through the independence of certain probabilistic events, which in turn is based on a form of the monotonicity of classical logics (specifically, given a set of formulas S = {φ1, . . . ,φt} with t ≥ 0, it holds that Mod(S) =Mod(φ1)∩ ·· ·∩Mod(φt) when Mod(·) denotes the set of all models of a formula or a set of formulas). However, it is well known that ASP is nonmonotonic. In our view, this is why many proof techniques for random SAT cannot be immediately adapted to random ASP. In order to provide a formal proof for Theorem 1, we resort to some techniques from mathematical analysis such as Stirling’s Approximation and Taylor series. As a result, our proof is both mathematically involved and technically novel. We look into the application of our main result in predicting the consistency of random programs (Proposition 5 and Section 4.3). 3. We have conducted significant experiments on statistical properties of random programs generated under the linear model. These properties include the average number of answer sets, the size distribution of answer sets, and the distribution of consistent programs under the linear model. For the average number of answer sets, our experimental results closely match the theoretical results obtained in Section 3. Also, the experimental results corroborate the conjecture that under the linear model, the size distribution of answer sets for random programs obeys a normal distribution when n is large. The experimental results show that our theories can be used to predict practical situations. As explained above, we need to find all answer sets in some applications. For large logic programs, it may be infeasible to find all answer sets but we could develop algorithms for finding most of the answer sets. If we know an average size of answer sets, we might need only to examine those sets of atoms whose sizes are around the average size.\nThe rest of the paper is arranged as follows. In Section 2, we briefly review answer set semantics of logic programs and some properties of two-literal programs that will be used in the\n2 There may be an error here as c−1 < 0.\nsubsequent sections. In Section 3, we first introduce the linear model for random logic programs (negative two-literal programs), study mathematical properties of random programs, and then present the main result in a theorem. In Section 4 we describe some of our experimental results and compare them with related theoretical results obtained in the paper. We conclude the work in Section 5. For the convenience of readers, some mathematical basics required for the proofs are included in the Appendix at the end of the paper."
    }, {
      "heading" : "2 Answer Set Semantics and Two-Literal Programs",
      "text" : "We briefly review some basic definitions and notation of answer set programming (ASP). We restrict our discussion to finite propositional logic programs on a finite set An of n atoms (n > 0).\nA normal logic program (simply, logic program) is a finite set of rules of the form\na← b1, . . . ,bs,not c1, . . . ,not ct , (1)\nwhere not is for the default negation, s, t ≥ 0, and a, bi and c j are atoms in An (i = 1, . . . ,s, j = 1, . . . , t).\nWe assume that all atoms appearing in the body of a rule are pairwise distinct. A literal is an atom a or its default negation not a. The latter is called a negative literal. An atom a and its default negation not a are said to be complementary. Given a rule R of form (1), its head is defined as head(R) = a and its body is body(R) = body+(R)∪not body−(R) where body+(R) = {b1, . . . ,bs}, body−(R) = {c1, . . . ,ct}, and not body−(R) = {not q | q ∈ body−(R)}.\nA rule R of form (1) is positive, if t = 0; negative, if s = 0. A logic program P is called positive (resp. negative), if every rule in P is positive (resp. negative).\nAn interpretation for a logic program P is a set of atoms S ⊆ An. A rule R is satisfied by S, denoted S |= R, if S |= head(R) whenever body+(R) ⊆ S and body−(R)∩S = /0. Furthermore, S is a model of P, denoted S |= P, if S |= R for every rule R ∈ P. A model S of P is a minimal model of P if for any model S′ of P, S′ ⊆ S implies S′ = S.\nThe semantics of a logic program P is defined in terms of its answer sets (or equivalently, stable models) (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1990) as follows. Given an interpretation S, the reduct of P on S is defined as PS = {head(R)← body+(R) |R∈P,body−(R)∩S= /0}. Note that PS is a positive logic program and every (normal) positive program has a unique least model. Then we say S is an answer set of P, if S is the least model of PS. By AS(P) we denote the collection of all answer sets of P. For an integer k ≥ 0, AS(P,k) denotes the set of answer sets of size k for P.\nA logic program P may have zero, one or multiple answer sets. P is said to be consistent, if it has at least one answer set. It is well-known that the answer sets of a logic program P are incomparable: for any S and S′ in AS(P), S⊆ S′ implies S = S′.\nTwo logic programs P and P′ are equivalent under answer set semantics, denoted P ≡ P′, if AS(P) = AS(P′), i.e., P and P′ have the same answer sets. We can slightly generalise the equivalence of two programs as follows. Let P be a logic program on An and P′ a logic program on An ∪E, where E is a set of new (auxiliary) atoms. We say P and P′ are equivalent if the following two conditions are satisfied:\n1. if S ∈ AS(P), then there exists S′ ∈ AS(P′) such that S′ = S∪Se and Se ⊆ E. 2. if S′ ∈ AS(P′), then S = S′ \\E is in AS(P).\nFrom the next section and on, we will focus on a special class of logic programs, called negative two-literal programs.\nA negative two-literal rule is a rule of the form a← not b where a and b are atoms. These two atoms do not have to be distinct. If a 6= b, it is a pure rule; if a = b, it is a contradiction rule. A negative two-literal program is a finite set of negative two-literal rules.\nWe note that our definition is slightly different from some other authors, such as (Janhunen 2006; Lonc and Truszczynski 2002), in that fact rules are not allowed in our definition. This may not be an issue since a fact rule of the form a← can be expressed as a negative two-literal rule a← not c, where c is a new atom that does not appear in the program.\nIt is shown in (Marek and Truszczynski 1991) that the problem of deciding the existence of answer sets for a negative two-literal program is NP-complete. This result confirms that the class of negative two-literal programs is computationally powerful and it makes sense to study the randomness for such a class of logic programs.\nWe remark that, by allowing the contradiction rules, constraints of the form ← b1, . . . ,bs,not c1, . . . ,not ct (s, t ≥ 0) can be expressed in the class of negative two-literal programs. A contradiction rule a← not a is strongly equivalent to the constraint ← not a under answer set semantics: for any logic program P, P∪{← not a} is equivalent to P∪{a← not a} under answer set semantics. Notice also that a constraint of the form← not a,not b is strongly equivalent to the two constraints ← not a and ← not b, and a constraint of the form ← a is strongly equivalent to two rules← not a′ and a′← not a where a′ is a fresh atom.\nIn the rest of this section we present three properties of negative two-literal programs. While Proposition 1 is to demonstrate the expressive power of negative two-literal programs, Propositions 2 and 3 will be used to prove our main theorem in the next section. These properties are already known in the literature and we do not claim their originality here.\nFirst, each logic program can be equivalently transformed into a negative two-literal program under answer set semantics. This result is mentioned in (Blair et al. 1999) but no proof is provided there. For completeness, we provide a proof of this proposition in the appendix at the end of the paper.\nProposition 1 Each normal logic program P is equivalent to a negative two-literal program under answer set semantics.\nThe next result provides an alternative characterization for the answer sets of a negative twoliteral program, which is a special case of Theorem 6.81, Section 6.8 in (Marek and Truszczynski 1993).\nProposition 2 Let P be a negative two-literal program on An containing at least one rule. Then S is an answer set of P iff the following two conditions are satisfied:\n1. If b1,b2 ∈ An \\S, then b1← not b2 is not a rule in P. 2. If a ∈ S, then there exists b ∈ An \\S such that a← not b is a rule in P.\nWe note that in condition 1 above, it can be the case that b1 = b2. We note that if the empty set is an answer set of a negative two-literal program, the program must be empty. Also, An is not an answer set for any negative two-literal program on An.\nProposition 3 Let P be a negative two-literal program on An containing at least one rule. If S is an answer set of P, then 0 < |S|< n. Here |S| is the number of elements in S."
    }, {
      "heading" : "3 Random Programs and Their Properties",
      "text" : "In this section we first introduce a model for randomly generating negative two-literal programs and then present some statistical properties of such random programs. The main result in this section (Theorem 1) shows that the expected number of answer sets for a random program on An generated under our model converges to a constant when the number n of atoms approaches infinity. As the proof of Theorem 1 is lengthy and mathematically involved, some technical details, as well as necessary basics of mathematical analysis, are included in the appendix at the end of the paper.\nIn this section, we assume that each negative two-literal program contains at least one rule.\nDefinition 1 (Linear Model L(N2,c1,c2)) Let c1 and c2 be two non-negative real numbers with c1 +c2 > 0. Given a set An of n atoms with n > max(c1,c2), a random program P on An is a negative two-literal program that is generated as follows:\n1. For any two different atoms a,b ∈ An, the probability of the pure rule a← not b being in P is p = c1/n. 2. For any atom a ∈ An, the probability of the constraint a← not a being in P is d = c2/n. 3. Each rule is selected randomly and independently based on the given probability.\nIn the above notation, ‘N2’ is for ‘negative two-literal programs’. For simplicity, we assume that a random program is non-empty. If c2 = 0, then a random program generated under L(N2,c1,c2) does not contain any contradiction rules.\nIn probability theory, the expected value (or mathematical expectation) of a random variable is the weighted average of all possible values that this random variable can take on. Suppose random variable X can take k possible values x1, . . . ,xm and each xk has the probability pk for k = 1, . . . ,m. Then the expected value of random variable X is defined as\nE[X ] = m\n∑ k=1 pkxk.\nAlso, if a random variable X is the sum of a finite number of other variables X1, . . . ,Xs (s > 0), i.e.,\nX = s\n∑ k=1 Xk,\nthen\nE[X ] = s\n∑ k=1 E[Xk].\nThe number |P| of rules in random program P (i.e., the size of P) is a random variable. As there are n(n− 1) possible pure rules, each of which has probability p = c1/n, and n possible constraints, each of which has the probability d = c2/n. Thus, the expected value of |P|, also called the expected number of rules for random program P, is the sum of expected number of\npure rules and the expected number of constraints:\nE[|P|] = n(n−1)p+nd = c1(n−1)+ c2.\nThis means that the average size of random programs generated under the model L(N2,c1,c2) is a linear function of n. This is the reason why we refer to our model for random programs as the linear model of random programs under answer sets.\nFor S ⊆ An with |S| = k (0 < k < n), the probability of S being an answer set of random program P, denoted Pr(k), can be easily figured out as the next result shows. We remark that, by Proposition 3, for negative two-literal program P, neither the empty set /0 nor An can be an answer set of P. So we do not need to consider the case of k = 0 or k = n.\nProposition 4 Let P be a random program on a set An of n atoms, generated under L(N2,c1,c2), with n > max(c1,c2). Then\nPr(k) = (\n1− c1 n\n)(n−k)(n−k−1)( 1− (\n1− c1 n\n)n−k)k( 1− c2\nn\n)n−k . (2)\nRecall that p = c1/n and d = c2/n. If we denote q = 1− p, then Eq.(2) can be simplified into\nPr(k) = q(n−k)(n−k−1)(1−qn−k)k(1−d)n−k. (3)\nProof Let S be a subset of An with |S|= k and T =An\\S. We can split the first condition in Proposition 2 into two sub-conditions. S is an answer set of negative two-literal program P iff the following two conditions are satisfied:\n(1) (1.1) for each pair b1,b2 ∈ T with b1 6= b2, the rule b1← not b2 is not in P. (1.2) for each a ∈ T , the rule a← not a is not in P. (2) for each a ∈ S, there exists an atom b ∈ T such that a← not b is in P.\nLet us figure out the probabilities that the above conditions (1.1), (1.2) and (2) hold, respectively.\nWe say that an atom a is supported w. r. t. S in P (or just, supported) if there exists a rule of the form a← not b in P such that b ∈ T . In this case, the rule a← not b is referred to as a supporting rule for a.\nFirst, since T contains n− k elements, there are (n− k)(n− k− 1) possible pure rules of the form b1← not b2 with b1,b2 ∈ T and b1 6= b2. By the definition of L(N2,c1,c2), the probability that a pure rule does not belong to P is 1− p = q. Thus, the probability that none of the pure rules with b1,b2 ∈ T and b1 6= b2 belongs to P is q(n−k)(n−k−1). That is, the condition (1.1) will hold with the probability q(n−k)(n−k−1).\nNext, by the definition of L(N2,c1,c2), the probability that a constraint rule of the form a← not a does not belong to P is 1−d. Since T contains n− k atoms, the probability that none of the constraint rules of the form a← not a with a ∈ T is (1−d)n−k. That is, the condition (1.2) will hold with the probability (1−d)n−k.\nLast, we consider the condition (2). For each a ∈ S, if a pure rule supports a, then it must be of the form a← not b for some b ∈ T . There are n− k possible such pure rules. Also, a is not supported by such pure rules only if P does not contain such rules at all. Thus, the probability that a is not supported (by one of such pure rules) is qn−k. That is, the probability that a is supported\nis 1−qn−k. As there are k atoms in S, the probability that every atom in S is supported by a pure rule in P is (1−qn−k)k.\nCombining the above three conditions, we know that the probability that S is an answer set of random program P is as follows.\nPr(k) = q(n−k)(n−k−1)(1−qn−k)k(1−d)n−k.\nNow we are ready to present the main result in this section, which shows that the average number of answer sets for random logic programs generated under the linear model converges to a constant when the number of atoms approaches infinity. This constant is determined by c1 and c2, e. g., when c1 = 5 and c2 = 0, the constant is around 1.6.\nTheorem 1 Let P denote a random program generated under the linear model L(N2,c1,c2) and E[|AS(P)|] be the expected number of answer sets for random program P. Then\nlim n→∞\nE[|AS(P)|] = αe c1−c2 α\nα + c1 , (4)\nwhere α > 1 is the unique solution of the equation lnα = c1/α .\nThis result gives an estimation for the average number of answer sets for a random program. Before we prove Theorem 1, let us look at its application in predicting the consistency of a random program.\nFor a random program P and a set of atoms S, by eS we denote the (probabilistic) event that a given set of atoms is an answer set for P. We introduce the following property for random programs: (ASI) Given a random program P, Pr(eS|eS′) = Pr(eS) for any two sets S and S′ of atoms.\nThe ‘I’ in (ASI) is for ‘Independence’. Informally, the above property says that for any two sets of atoms S and S′, the events eS and eS′ are independent of each other. We remark that this property does not hold in general. For example, suppose S1 ⊂ S2 ⊂ An. If S1 is an answer set of P, then S2 must not be an answer set of P. This implies that eS1 and eS2 are actually not independent. However, when the set of atoms An is sufficiently large, by Theorem 1, the average number of answer sets will be relatively small compared to the number of all subsets of An. As a result, there will be a relatively small number of pairs S ⊆ An and S′ ⊆ An with S 6= S′ such that eS and eS′ are not independent. Thus, when n is sufficiently large, the impact of dependency for answer sets will be not radical. Under the (ASI) assumption, we are able to derive an estimation for the probability that a random program has an answer set.\nProposition 5 Let P be a random program on a set An of n atoms, generated under L(N2,c1,c2), with n > max(c1,c2). If (ASI) holds and n is sufficiently large, then\nPr(E(|AS(P)|> 0))≈ 1− e−E(|AS(P)|). (5)\nAs explained, (ASI) does not hold in realistic situation. Our experiments indeed show that there is a shift between the estimated probability determined by Eq.(5) and the actual probability. However, The experimental results suggest that this shift can be remedied by applying a factor γ of around 0.5 to E(|AS(P)|) in Eq.(5), see Section 4 for details. So, combining Theorem 1 and Proposition 5, we will be able to estimate the probability for the consistency of random programs.\nProof Let eS,k be the event that S⊂ An is an answer set of size k for random program P. We first observe that by Eq.(3), lim\nn→∞ Pr(eS,k) = 0. Recall that AS(P,k) is the set of answer sets of size k for logic\nprogram P. If n is sufficiently large, then\nPr(E(|AS(P)|)> 0) = 1−Pr(E(|AS(P)|) = 0) = 1− ∏\n0<k<n Pr(E(|AS(P,k)|) = 0)\n= 1− ∏ 0<k<n\n[1−Pr(eS,k)]( n k)\n= 1− ∏ 0<k<n\n[1−Pr(eS,k)] 1 Pr(eS,k) ·Pr(eS,k)·(nk)\n≈ 1− ∏ 0<k<n\ne−Pr(eS,k)×( n k), because lim\nx→0 (1− x)\n1 x = e−1\n= 1− ∏ 0<k<n\ne−E(|AS(P,k)|)\n= 1− e−∑0<k<n E(|AS(P,k)|)\n= 1− e−E(|AS(P)|).\nIn the rest of this section, we will present a formal proof of Theorem 1. Let us first outline a sketch for the proof. In order to prove Eq.(4), our first goal will be to show that E[|AS(P)|] is the sum of E[Nk]’s for 0 < k < n.\nFor an integer k with 0 < k < n, we use AS(P,k) to denote the collection of answer sets of size k for program P, i.e., AS(P,k) = {S | S ∈ AS(P), |S|= k}. Then the number Nk = |AS(P,k)| is a random variable. It is easy to see that the expected number of answer sets of size k for random program P is\nE[Nk] = (\nn k\n) Pr(k). (6)\nSo the expected (total) number of answer sets for P, denoted E[|AS(P)|], can be expressed as\nE[|AS(P)|] = n−1\n∑ k=1 E[Nk]. (7)\nNote that by Proposition 3, a random program generated under the linear model has neither answer sets of size 0 nor n. So, we can ignore the cases of k = 0 and k = n.\nOur next goal is, based on Eq.(7), to show that\nlim n→∞ E[|AS(P)|] = lim n→∞ ∫ n 1 φ(x)dx. (8)\nwhere the function φ(x) is defined by\nφ(x) = √\nn 2πx(n− x)\n( n(1−qn−x)\nx\n)x(nrqn−x n− x )n−x . (9)\nAt the same time, we are going to show that\nlim n→∞ ∫ n 1 φ(x)dx = lim n→∞ ∫ ∞ −∞ χ(x)dx, (10)\nwhere the function χ(x) defined below is a normal distribution function multiplied by a constant. Thus, it follows from Eq.(8) and Eq.(10) that\nlim n→∞ E[|AS(P)|] = lim n→∞ ∫ ∞ −∞ χ(x)dx.\nAs the above integral of χ(x) is αe c1−c2\nα /(α+c1), which can be figured out easily, the conclusion of Theorem 1 will be proven.\nHere α > 1 is the unique solution of the equation αα = ec1 and χ(x) is the normal distribution function\nNx0,σ (x) = 1√ 2πσ e−\n(x−x0) 2\n2σ2\nmultiplied by a constant √ 2πσφ(x0):\nχ(x) = (√ 2πσφ(x0) ) Nx0,σ (x) = φ(x0)e − (x−x0) 2 2σ2 . (11)\nwhile x0 and σ are defined, respectively, as follows.\nx0 = (α−1)n\nα . (12)\nσ = √ (α−1)n α + c1 . (13)\nSome remarks are in order. As c1 > 0, if αα = ec1 for some α , it must be the case that α > 1. On the other hand, if α > 1, the function αα is monotonically increasing and thus the equation αα = ec1 must have a unique solution.\nMoreover, we define\nc0 = max(\n√ 2(α + c1)√\nα−1 ,\n1 √\nc1 ). (14)\n∆ = c0 √ n lnn. (15)\nBefore providing the proof of Theorem 1, we first prove some technical results. The following result shows that φ(k), as defined in Eq.(9), is indeed a tight approximation to\nE[Nk].\nProposition 6 Let P be a random program on a set An of n atoms, generated under L(N2,c1,c2), with n > max(c1,c2). Let E[Nk] be the expected number of answer sets of size k for P (0 < k < n). Then ,\n4π2\ne2 φ(k)≤ E[Nk]≤ e 2π φ(k). (16)\nE[Nk] = φ(k) ( 1+O (\n1 min(k,n− k)\n)) . (17)\nProof Note that\nE[Nk] = (\nn k\n) Pr(k) =\nn! k!(n− k)! Pr(k).\nBy Proposition 4,\nE[Nk] = n!\nk!(n− k)! q(n−k)(n−k−1)(1−qn−k)k(1−d)n−k.\nLet r = (1−d)/(1− p) = (1−d)/q. Then\nE[Nk] = n!\nk!(n− k)! (qn−kr)n−k(1−qn−k)k.\nApplying Stirling’s approximation to n!, k! and (n− k)!, and based on the two properties of Stirling’s approximation presented in Section 5.2, Eq.(16) and Eq.(17) are obtained.\nBy Proposition 6, we can show the following result.\nProposition 7 Let P be a random program on a set An of n atoms, generated under L(N2,c1,c2), with n > max(c1,c2). If E[Nk] and φ(k) are defined as in Eq.(6) and Eq.(9, then\nlim n→∞\nn−1 ∑ k=1 E[Nk] = limn→∞ n−1 ∑ k=1 φ(k). (18)\nProof Let ∆ be defined as in Eq.(15). Then\nn−1 ∑ k=1 E(Nk) = bx0−∆c ∑ k=1 E(Nk)+ bx0+∆c−1 ∑ k=bx0−∆c+1 E(Nk)+ n−1 ∑ k=bx0+∆c E(Nk).\nBy inequality (16),\nbx0−∆c\n∑ k=1\nE(Nk)+ n−1\n∑ k=bx0+∆c\nE(Nk)≤ e\n2π\n( bx0−∆c\n∑ k=1\nφ(k)+ n−1\n∑ k=bx0+∆c φ(k)\n) .\nBy Lemma 6 (in Section 5.3),\nlim n→∞\n( bx0−∆c\n∑ k=1\nφ(k)+ n−1\n∑ k=bx0+∆c φ(k)\n) = 0.\nBased on Eq.(17), and the fact that both φ(k) and E(Nk) are non-negative,\nlim n→∞\n( bx0−∆c\n∑ k=1\nE(Nk)+ n−1\n∑ k=bx0+∆c E(Nk)\n) =\nlim n→∞\n( bx0−∆c\n∑ k=1\nφ(k) ( 1+O (\n1 min(k,n− k)\n)) + n−1\n∑ k=bx0+∆c\nφ(k) ( 1+O (\n1 min(k,n− k)\n)))\n≤ lim n→∞\n( bx0−∆c\n∑ k=1\nφ(k)+ n−1\n∑ k=bx0+∆c φ(k)\n) (1+O(1)) = 0.\nAs E(Nk)≥ 0 for k ≥ 1, we have that\nlim n→∞\n( bx0−∆c\n∑ k=1\nE(Nk)+ n−1\n∑ k=bx0+∆c E(Nk)\n) = 0.\nBy Eq.(17),\nbx0+∆c−1\n∑ k=bx0−∆c+1\nE(Nk) = bx0+∆c−1\n∑ k=bx0−∆c+1\n( φ(k) ( 1+O ( 1\nmin(k,n− k)\n)))\n=\n( bx0+∆c−1\n∑ k=bx0−∆c+1 φ(k)\n)( 1+O ( 1\nmin(x0−∆,n− x0−∆)\n)) .\nBy Eq.(12) and Eq.(15), we have that\nlim n→∞ min(x0−∆,n− x0−∆) = ∞.\nSo\nlim n→∞\nbx0+∆c−1\n∑ k=bx0−∆c+1 E(Nk) = limn→∞\nbx0+∆c−1\n∑ k=bx0−∆c+1 φ(k).\nTherefore, the conclusion is proved.\nThe next result shows that the integral of φ(x) can be obtained through the integral of χ(x), which is useful as the integral of χ(x) can be easily figured out.\nProposition 8 Let P be a random program on a set An of n atoms, generated under L(N2,c1,c2), with n > max(c1,c2). If the continuous functions φ(x) and χ(x) are defined as in Eq.(9) and Eq.(11), then\nlim n→∞ ∫ n 1 φ(x)dx = lim n→∞ ∫ −∞ ∞ χ(x)dx. (19)\nProof Let ∆ = c0 √ n lnn be defined as in Eq.(15). By Lemma 6, it follows that\nlim n→∞ (∫ x0−∆ 1 φ(x)dx+ ∫ n x0+∆ φ(x)dx ) = 0.\nBy Lemma 8 and Lemma 9, Eq.(19) holds.\nNow we are ready to present the proof of Theorem 1, a main result in this paper,\nProof of Theorem 1 Given a random program P, the expected total number of answer sets for P is\nE[|AS(P)|] = n−1\n∑ k=1 E[Nk].\nBy Proposition 7 and Proposition 8,\nlim n→∞ E[|AS(P)|] = lim n→∞\nn−1 ∑ k=1 E[Nk] = limn→∞ n−1 ∑ k=1 φ(k)\n= lim n→∞ ∫ n 1 φ(x)dx = lim n→∞ ∫ ∞ −∞ χ(x)dx.\nThen\nlim n→∞ ∫ ∞ −∞ χ(x)dx = lim n→∞ √ 2πσφ(x0) = αe c1−c2 α α + c1 .\nTherefore,\nlim n→∞\nE[|AS(P)|] = αe c1−c2 α\nα + c1 ."
    }, {
      "heading" : "4 Experimental Results",
      "text" : "In this section, we describe some experimental results about the average number of answer sets, the size distribution of answer sets, and the probability of consistency for random programs under the linear model. For the average number of answer sets, our experimental results closely match the theoretical results obtained in Section 3.\nTo conduct the experiments, we have developed a software tool to generate random logic programs, which is able to randomly generate logic programs based on the user-input parameters, such as the type of programs, the number of atoms, the number of literals in a rule, the number of rules in a program and the number of programs in a test set etc. After a set of random programs are generated, the tool invokes an ASP solver to compute the answer sets of the random programs, records the test results in a file, and analyses them. The experimental results in this section were based on the ASP solver clasp (Gebser et al. 2009), but same patterns were obtained for test cases on which dlv (Leone et al. 2006) and smodels (Syrjänen and Niemelä 2001) were also used.\nWe have conducted a significant number of experiments to corroborate the theoretical results obtained in Section 3 including Theorem 1. In order to get a feel for how quickly the experimental distribution converges to the theoretical one, we tested the difference rate of these two values for varied numbers of atoms. The experimental results show that the theorem can be used to predict practical situations. Some other statistical properties of random programs generated under the linear model were also experimented, such as the size distribution of answer sets. Positive results are received for nearly all of our experiments. In this section, we report the results from two of our experiments. In the first experiment, we set c2 = 0, which means there are no contradiction rules in the programs. In the second experiment, we set c2 from 0 to 20 to test the impact of contradiction rules on the random programs."
    }, {
      "heading" : "4.1 Experiment 1: Random Programs without contradiction rules",
      "text" : "In this experiment, c1 = 5, c2 = 0, and n varies with values 50,100,150, ...,500, respectively. For each of these values of n, 5,000 logic programs were randomly and independently generated under the linear model.\nGiven that c1 = 5 and α > 1 is determined by αα = ec1 , we have that α ≈ 3.7687. Thus, by Eq.(4), it follows that E(|AS(P)|)≈ 1.6274.\nWe use NAvg to denote the average number of answer sets for the 5,000 programs in each test generated under the linear model. The (experimental) values for NAvg and their corresponding theoretical values (i.e., the expected number E[Nk] of answer sets for random programs determined by Eq.(4)) are listed in Table 1. The experimental and theoretical results are visualized in Figure 1. We can see that these two values are very close even if n is relatively small.\nAnother important result obtained from this experiment is about the size distribution of answer sets for random programs. Specifically, the experiment supports a conjecture that the distribution of the average size of answer sets for random programs obeys a normal distribution.\nThe experimental result can be easily seen by comparing the following three types of values for 0 ≤ k ≤ n, which are visualized as three curves in Figure 2 and Figure 3 with n = 50 and n = 400 respectively. Average number of answer sets for the 5,000 programs randomly generated in each test (referred to as ‘Experiment Result’ in Figure 2 and Figure 3): We took n = 50,100, ...,500, respectively, and for each of these values of n, we randomly generated 5,000 programs under the linear model. For each k (0 ≤ k ≤ n), we calculated the average number of answer sets of size k for these programs, i.e., the ratio of the total number of answer sets of size k for all these programs divided by 5,000. Expected number of answer sets for random programs under the linear model (referred to as ‘The Model’ in Figure 2 and Figure 3): In order to compare the experimental values with their theoretical counterparts, for each 0≤ k≤ n, we calculated the expected number E[Nk] of answer sets of size k for random programs under the linear model. Normal Distribution function: The above two types of values were also compared with the function χ(x) defined by Eq.(11), which is actually the normal distribution function N (x0,σ) multiplied by a constant.\nFigure 2 and Figure 3 show that even for relatively small values of n, the theoretical results are still very close to the experimental results. In order to see how quickly the experimental distribution converges to the theoretical one, we consider the rate variance function D: For two discrete functions f and g on the interval [1,n−1] with f (k)> 0 (1≤ k ≤ n−1), we define\nD( f ,g) = ∑n−1k=1( f (k)−g(k)) 2\n∑n−1k=1 f (k)2 .\nClearly, the closer f and g, the smaller D( f ,g), and vice versa. The function D( f ,g) is often used in measuring the gap between two discrete functions f and g. If we take f as the normal distribution function and g as the experimental distribution function (i.e., the average size of answer sets\nbased on the 5,000 programs randomly generated in each test). The resulting rate variance function is depicted in Figure 4. This diagram shows that, as n increases, the rate variance gradually decreases. It also shows that the rate variance is very small even when n = 50. This experimental result further suggests the conjecture that the size distribution of answer sets obeys a normal distribution."
    }, {
      "heading" : "4.2 Experiment 2: Random Programs with contradiction rules",
      "text" : "In this experiment, we tested random programs that may contain contradiction rules and obtained similar experimental results as in the first experiment. We set c1 = 10, n = 200, and c2 = 0,1,2, ...,20, respectively. For each value of c2, 5,000 programs were independently generated under the linear model.\nGiven c1 = 10, it follows by Eq.(12) and Eq.(13) that α ≈ 5.7289, x0 ≈ 165.0894, and σ ≈ 1.9552. The value φ(x0), which depends on c2, decreases roughly from 0.4257 (when c2 = 0) to 0.01297 (when c2 = 20).\nOn the other hand, based on Eq.(4), we can figure out the expected number of answer sets for each c2.\nThese two types of values are visualized as two curves in Figure 5. It shows that these two curves are very close to each other, which means our theoretical result on size distribution of answer sets is corroborated by the experimental result.\nSimilar to the first experiment, the size distribution of answer sets was also investigated experimentally. In this case, we took c2 = 4 and three types of values were obtained (shown in Figure 6). There is a slight shift between the linear model and the normal distribution. We expect that when the number n is sufficiently large, this shift will become narrower. For example, when n increases from 200 to 400, the shift is significantly reduced."
    }, {
      "heading" : "4.3 Experiment 3: Approximating the probability for consistency of random programs",
      "text" : "In this subsection we present our experimental results on verifying the formula for predicting consistency of random programs (discussed in Section 3):\nPr(E(|AS(P)|> 0))≈ 1− e−γ·E(|AS(P)|). (20)\nHere γ is a constant around 0.5 (i.e. independent of n). We tested various pairs of c1 and c2. For each such pair, we took n = 100,150,200, ...,1000. Then for each value of n, we computed the\nvalue determined by Eq.(20). For each value of n, we generated 5,000 programs randomly and computed the ratio of consistent programs to all 5,000 programs.\nOur experimental results corroborate the estimation in Eq.(20). So this formula can be used to predict the consistency of random programs generated under the linear model. The corresponding values for two cases we tested are depicted in Figures 7 and 8. In each figure, the upper curve is for the value determined by Eq.(5), the middle curve is for the ratio of consistent programs to all 5,000 programs randomly generated, and the lower curve is for the value determined by Eq.(20)."
    }, {
      "heading" : "5 Conclusion",
      "text" : "We have proposed a new model of randomly generating logic programs under answer set semantics, called linear model. The average size of a random program generated in this way is linear to the total number of atoms. We have proved some mathematical results and the main result shows that the expected number of answer sets of random programs under the linear model converges to a constant that is determined by the probabilities of both pure rules and constraints. The formal proof of this result is mathematically involving as we have seen. The main result is further corroborated by our experiments. Another important experimental result reveals that the (size) distribution of answer sets for random programs generated under the linear model obeys a normal distribution.\nThere are several issues for future work. First, it would be interesting to mathematically prove some results presented in Section 4. Second, it would be both interesting and useful to study phase transition phenomena for hardness. In this case, a new model for random programs may need to be designed based on an algorithm for ASP computation (for SAT and CSP, DPLL is often used for studying the hardness of random problems). Last, while the class of negative twoliteral programs is of importance, it would be interesting to study properties of random logic\nprograms that are more general than negative two-literal programs, such as the program classes discussed in (Janhunen 2006; Lonc and Truszczynski 2002). However, it is not straightforward to carry over our proofs to those program classes. For instance, Proposition 4 may not hold for arbitrary two-literal programs."
    }, {
      "heading" : "Acknowledgement",
      "text" : "The authors would like to thank the editor Michael Gelfond and three anonymous referees for their constructive comments, which helped significantly improve the quality of the paper. Thanks to Fangzhen Lin and Yi-Dong Shen for discussions on this topic. This work was supported by the Australian Research Council (ARC) under grants DP1093652 and DP130102302.\nAppendix"
    }, {
      "heading" : "5.1 Proofs for Section 2",
      "text" : "Proposition 1 Each normal logic program P is equivalent to a negative two-literal program under answer set semantics.\nProof First, it has been proven that each normal logic program is equivalent to a negative logic program under answer set semantics (Brass and Dix 1999; Wang and Zhou 2005). So, without loss of generality, we assume that P is a negative normal program.\nNext, we show that each negative normal program P can be transformed into a logic program that consists of only two-literal rules and fact rules. In fact, we can define the translation as follows.\nFor each rule R in P of the form a← not c1, . . . ,not cn (n≥ 0), R is replaced with the following n+1 rules:\na← not eR. eR← c1. . . . . . . eR← cn. Here eR is a new atom introduced for the rule R. The resulting logic program, denoted simple(P), is exactly a logic program that consists of only two-literal rules and fact rules. We use EP to denote the set of new atoms eR introduced above, that is, EP = {eR | R ∈ P}.\nNote that, by applying unfolding transformation, simple(P) can be easily transformed into a logic program that consists of only negative two-literal rules and fact rules. As explained in Section 2, each rule can be expressed as a negative two-literal rule by introducing a new atom. Thus, simple(P) is equivalent to a negative two-literal program under answer set semantics.\nSo, it is sufficient to show that simple(P) and P are indeed equivalent under answer set semantics. (1) Let S be an answer set of P. Take Se = {eR ∈ EP | R ∈ P,body−(R)∩S 6= /0}. Then we show that S′ = S∪Se is an answer set of P′. It suffices to prove that S′ is a minimal model of (P′)S ′ .\nBy the definition of Se, S′ is a model of (P′)S ′ .\nWe need only to show that S′ is minimal. Assume that there exists T ′ such that T ′ ⊆ S′ and T ′ is also a model of (P′)S ′ . Let T = T ′ \\EP. Then T is a model of PS. To see this, for each rule R of the form a← not c1, . . . ,not ct such that ci 6∈ S for i = 1, . . . , t, if a 6∈ T , then a 6∈ T ′. Thus eR ∈ T ′ by T ′ |= R, which implies that ci ∈ T ′ for some i (1≤ i≤ n). So we have ci ∈ T , that is, T |= R. By the minimality of S, T = S.\nAlso, if eR ∈ S′, then ci ∈ S for some i (1 ≤ i ≤ n). This means ci ∈ T because S = T , which implies that eR ∈ T ′. Therefore, T ′ = S′. (2) If S′ is an answer set of P′, we want to show that S = S′ \\EP is an answer set of P.\nS |= PS: for each rule R of the form a← not c1, . . . ,not cn, if R+ ∈ PS, then {c1, . . . ,cn}∩S = /0, which implies that eR 6∈ S′. Thus R+ = (a← not eR)+ ∈ (P′)S ′ . By the assumption, a ∈ S′, that is, a ∈ S. Thus S |= R+. S is a minimal model of PS: Suppose that T ⊆ S and T |= PS. Take T ′ = T ∪ Se where Se = {eR ∈ EP | body−(R)∩S 6= /0}. We first show that T ′ |= (P′)S ′ .\nLet R′ ∈ P′ with (R′)+ ∈ (P′)S′ . Consider two possible cases: Case 1. R′ is of the form a← not eR: Then eR 6∈ S′. By T ′ ⊆ S′, eR 6∈ T ′. Then {c1, . . . ,cn}∩S = /0. This means R+ ∈ PS. Since T |= PS, we have a ∈ T . Thus T ′ |= (R′)+. Case 2. R′ is of the form eR← ci where 1≤ i≤ n: If ci ∈ T ′, then ci ∈ S. By this rule, eR ∈ S′ or eR ∈ Se. Thus eR ∈ T ′. Again, we have T ′ |= (R′)+.\nTherefore, T ′ |= (P′)S′ . By the minimality of S′, T ′ = S′, which implies T = S. Thus S is a minimal model of PS.\nSo, we conclude the proof.\nProposition 2 Let P be a negative two-literal program on An containing at least one rule. Then S is an answer set of P iff the following two conditions are satisfied:\n1. If b1,b2 ∈ An \\S, then b1← not b2 is not a rule in P. 2. If a ∈ S, then there exists b ∈ An \\S such that a← not b is a rule in P.\nProof ⇒: Let S be an answer set of P.\nTo prove condition 1, suppose that b1← not b2 is a rule in P and b2 ∈An\\S. Then the rule b1← is in PS. This implies that b1 ∈ S, which is in contradiction to b1 ∈ An \\S. Therefore, b1← not b2 cannot be a rule in P if b1,b2 ∈ An \\S.\nFor condition 2, if a ∈ S, P contains at least one rule with the head a. On the contrary, suppose that there does not exist any b ∈ An \\ S such that a← not b is in P. Then for every rule of the form a← not b in P, we would have b ∈ S, which implies the reduct PS would contain no rules whose head is a. Therefore, a 6∈ S, a contradiction. Therefore, there must exist an atom b ∈ An \\S such that a← not b is in P. ⇐: Assume that S ⊆ An satisfies the above two conditions 1 and 2. We want show that S is an answer set.\nS |= PS: If R: a← not c is a rule of P such that R+ ∈ PS, then c 6∈ S. By condition 1, a ∈ S. This means that every rule of PS is satisfied by S. Thus, S |= PS.\nS is a minimal model of PS: By condition 2, for each a ∈ S, there exists a rule a← not b such that b 6∈ S. Then the rule a← is in PS, which implies that every model of PS must contain a. This implies that every model of PS is a superset of S. Therefore, S is minimal (actually the least model of PS).\nProposition 3 Let P be a negative two-literal program on An containing at least one rule. If S is an answer set of P, then 0 < |S|< n. Here |S| is the number of elements in S.\nProof If |S| = 0, then S = /0. Since P contains at least one rule, we assume that a← not b is in P. By S = /0, a 6∈ S. Then it would be the case that b ∈ S, which is a contradiction to S = /0. Therefore, |S|> 0.\nIf |S| 6= 0, i.e. S 6= /0, then there exists an element a ∈ S. By the definition of answer sets, the rule a← not b must be in P for some b 6∈ S. This implies that S must be a proper subset of An."
    }, {
      "heading" : "5.2 Basics of mathematical analysis",
      "text" : "In this subsection, we briefly recall some basics of mathematical analysis and notation that are used in related proofs.\n1. Big O notation: let f (x), g(x), h(x) be three real functions. By f (x) = g(x)+O(h(x)), we mean that | f (x)−g(x)|= O(h(x)). That is, there exists a positive real number c and a real number x0 such that for all x > x0.\n| f (x)−g(x)| ≤ c|h(x)|.\nThe same notation is also applicable to discrete functions. 2. Stirling’s approximation: for all integer n > 0\n1≤ n! e−nnn √ 2nπ ≤ e√ 2π , (21)\nn! = e−nnn √ 2nπ(1+O( 1 n )). (22)\n3. Taylor series: Let f (x) be an infinitely differentiable real function on R, x0 ∈ R is a real number, then for all x ∈ R,\nf (x) = ∞\n∑ i=0 f (i)(x0) i! (x− x0)i. (23)\nHere f (i)(x0) denotes the i-th derivative of f at x0 (i≥ 0). In particular, f (0)(x) = f (x). 4. Properties of the natural exponential function:\nlim x→0\n(1+ x) 1 x = e. (24)\n(1+ x)≤ ex , and the equatility holds iff x = 0. (25) For all n ∈ N, (\n1+ 1 n\n)n = e+O ( 1 n ) . (26)\n5. Properties of the logarithmic function:\nlim x→0 ln(1+ x) x = 1 (27)\nif x > 0, ln(1+ x)< x.\n6. Concave functions: A real function f is said to be concave if, for any x,y ∈ R and for any t in [0,1],\nf (tx+(1− t)y)≥ t f (x)+(1− t) f (y). Let f (x) be a continuously differentiable function.\n(a) If f ′′(x) is negative for all x ∈ R, then f (x) is a concave function. (b) For x0 ∈ R, if f (x) is concave and f ′(x0) = 0, then f (x) reaches its apex at x0. (c) If f (x) is concave and reaches its apex at x0, then g(x) = e f (x) is strictly monotoni-\ncally increasing when x < x0 and strictly monotonically decreasing when x > x0.\n7. The complementary error function erfc(x) is defined by\nerfc(x) = 2√ π ∫ ∞ x e−t 2 dt, (28)\nwhich has the following property:\nlim x→∞ erfc(x) = 0. (29)"
    }, {
      "heading" : "5.3 Lemmas",
      "text" : "Recall that φ(x), x0 and σ have been defined in Eq.(9), Eq.(12), and Eq.(13), respectively. We first define three real functions as follows.\nψ(x) = ln(φ(x))− ln(φ(x0)). (30)\nξ (x) = ln(χ(x))− ln(φ(x0)) =− (x− x0)2\n2σ2 . (31)\nκ(x) = 1−qn−x. (32)\nThen\nφ(x) = φ(x0)eψ(x),\nand\nχ(x) = φ(x0)eξ (x).\nAccording to Taylor series:\nln(1+ x) = 0+ x− x 2\n2 +\nx3 3 − ...\nWe have\nlnq = ln(1− c1 n ) =−c1 n − c 2 1 2n2 +O ( 1 n3 ) =−c1 n +O ( 1 n2 ) = O ( 1 n ) . (33)\nLemma 1\nqn−x0 = 1 α − c 2 1 2α2n +O ( 1 n2 ) . (34)\nκ(x0) = α−1\nα + c21 2α2n\n+O (\n1 n2\n) . (35)\nProof By Eq.(12) and Eq.(33),\n(n− x0) lnq = n α\n[ −c1\nn − c 2 1 2n2 +O ( 1 n3 )] =−c1 α − c 2 1 2nα +O ( 1 n2 ) .\nThen\nqn−x0 = e− c1 α e− c21 2nα eO\n( 1\nn2 ) .\nAs α > 1 satisfies the equation αα = ec1 , we can show that\ne− c1 α = 1 α .\nNote that\nex = 1+ x+ 1\n2x2 + ...\nthen,\nqn−x0 = 1 α\n[ 1− c 2 1\n2nα +O ( 1 n2 )][ 1+O ( 1 n2 )] =\n1 α − c 2 1 2α2n +O ( 1 n2 ) . Based on the definition of κ(x) in Eq.(32),\nκ(x0) = 1−qn−x0 = α−1\nα + c21 2α2n\n+O (\n1 n2\n) .\nRemark: lnq and κ(x0) can be simplified into\nlnq =−c1 n +O ( 1 n2 ) = O ( 1 n ) ,\nand\nκ(x0) = α−1\nα +O ( 1 n ) = O(1).\nLemma 2 When n is sufficiently large,\nψ ′(1)> 0. (36)\nψ ′(n−1)< 0. (37) ψ ′(x0) = O (\n1 n\n) . (38)\nProof From the definitions of ψ(x) in Eq.(30) and φ(x) in Eq.(9), it follows that\nψ ′(x) = 1 2 ( 1 n− x − 1 x )+ ln n− x x\n− (2n−2x) lnq+ ln(1−qn−x) + x\n1−qn−x ×qn−x lnq− lnr.\n(39)\nTake x = 1 in Eq.(39), we can see that the second term is ln(n−1) and all the other terms are of the order O(1). So, when n is sufficiently large,\nψ ′(1) = ln(n−1)+O(1)> 0.\nTake x = n−1 in Eq.(39), the most significant term is the fifth one. By Eq.(33), the fifth term can be simplified as follows.\nn−1 1−qn−(n−1) ×qn−(n−1) lnq =− (n−1)(n− c1) n +O(1)\nand the other terms are of the order O(ln(n)) or less. So, when n is sufficient large,\nψ ′(n−1) =− (n−1)(n− c1) n +O(lnn)< 0.\nFinally, take x = x0 = (α−1)n α in Eq.(39), the first term is of the order O ( 1 n ) . The other five terms can be simplified correspondingly into\nln n− x0\nx0 =− ln(α−1),\n−(2n−2x0) lnq = 2c1 α\n+O (\n1 n\n) ,\nln(1−qn−x0) = lnκ(x) = ln(α−1)− lnα +O (\n1 n\n) ,\nx0 1−qn−x0 ×qn−x0 lnq =−c1 α\n+O (\n1 n\n) ,\nRandom Logic Programs: Linear Model 25\n− ln(r) =− ln 1−d 1− p =− ln n− c2 n− c1 =− ln(1+ c1− c2 n− c1\n) = O (\n1 n\n) .\nThen\nψ ′(x0) = c1 α − lnα +O ( 1 n ) .\nSince α > 1 satisfies the equation αα = ec1 , we have that c1 α − lnα = 0.\nThus,\nψ ′(x0) = O (\n1 n\n) .\nLemma 3 If 1≤ x≤ n−1, then\nψ ′′(x)< 2lnq < 0, (40)\nψ ′′(x0) =− 1\nσ2 +O ( 1 n2 ) (41)\nwhere σ is defined in Eq.(13).\nProof By Eq.(39),\nψ ′′(x) = 1 2x2 − 1 x − 1 n− x + 1 2(n− x)2\n+2lnq+ qn−x lnq 1−qn−x + (1−qn−x)(qn−x− xqn−x lnq)− xq2(n−x) lnq\n(1−qn−x)2 × lnq.\nThen it can be further simplified to\nψ ′′(x) = 1 2x2 − 1 x − 1 n− x + 1 2(n− x)2\n+ 2lnq κ(x) +( 1 κ(x) − 1 κ(x)2 )x ln2 q.\n(42)\nFrom 1≤ x≤ n−1, we have that 1\n2x2 − 1 x − 1 n− x + 1 2(n− x)2 < 0.\nAs κ(x) = 1−qn−x, so 0 < κ(x)< 1, then( 1\nκ(x) − 1 κ(x)2\n) x ln2 q < 0.\nSo\nψ ′′(x)< 2lnq κ(x) < 2lnq < 0.\nTake x = x0 = (α−1)n\nα in Eq.(42) and split the formula into three partsas follows. Then by Eq.(33) and Lemma 1,\n1 2x20 − 1 x0 − 1 n− x0 + 1 2(n− x0)2 =− α 2 (α−1)n +O ( 1 n2 ) ,\n2lnq κ(x0) =− 2αc1 (α−1)n\n+O (\n1 n2\n) ,\n( 1 κ(x0) − 1 κ(x0)2 )x0 ln2 q =− c21 (α−1)n\n+O (\n1 n2\n) .\nCombining the three parts above together and by the definition of σ in Eq.(13),\nψ ′′(x0) =− α2 +2αc1 + c21\n(α−1)n +O ( 1 n2 ) =− 1 σ2 +O ( 1 n2 ) .\nLemma 4 For all i > 2, the i-th derivative of ψ(x) at x0 satisfies\nψ(i)(x0) = O (\n1 ni−1\n) . (43)\nProof By the definition of κ(x) in Eq.(32), for i > 2, we have that\nκ(i)(x) = (−1)(i+1)qn−x(lnq)i.\nTake x = x0, by Eq.(33) and Lemma 1, the formula above can be simplified to κ(i)(x0) = O (\n1 ni\n) . (44)\nDefine\nψ1(x) = 1 2x2 − 1 x − 1 n− x + 1 2(n− x)2 ,\nψ2(x) = 2lnq κ(x) ,\nψ3(x) = (\n1 κ(x) − 1 κ(x)2\n) x ln2 q.\nBy Eq.(42), ψ ′′(x) = ψ1(x)+ψ2(x)+ψ3(x). Thus\nψ(i)(x) = ψ(i−2)1 (x)+ψ (i−2) 2 (x)+ψ (i−2) 3 (x).\nAs x0 = O(n), we have that\nψ(i−2)1 (x0) = O ( 1 ni−1 ) . (45)\nThen\nψ2(x) = 2lnq(κ(x))−1 ,\nψ ′2(x) = 2lnq ( −κ(x)−2κ ′(x) ) ,\nψ ′′2 (x) = 2lnq ( 2κ(x)−3κ ′(x)2−κ(x)−2κ ′′(x) ) ,\nψ ′′′2 (x) = 2lnq ( −6κ(x)−4κ ′(x)3 +6κ(x)−3κ ′(x)κ ′′(x).−κ(x)−2κ ′′′(x) ) .\nIn general, for i > 2, it holds that\nψ(i−2)2 (x) = 2lnq∑ j Λi, j(x)\nwhere\nΛi, j(x) = ci, jκ(x)− j ∏ s (κ(is)(x))ts ,\nci, j is a constant determined by i and j, and\n∑ s is× ts = i−2.\nThen by Eq.(44), we know that\nΛi, j(x0) = O (\n1 ni−2\n) .\nSince lnq = O ( 1\nn\n) ,\nψ(i−2)2 (x0) = O ( 1 ni−1 ) .\nSimilarly, we can show that\nψ(i−2)3 (x0) = O ( 1 ni−1 ) .\nTherefore,\nψ(i)(x0) = ψ (i−2) 1 (x0)+ψ (i−2) 2 (x0)+ψ (i−2) 3 (x0) = O\n( 1\nni−1\n) .\nLemma 5\nφ(x0) = αe c1−c2 α√\n2π(α−1)n +O(n− 3 2 ). (46)\nProof By the definition of φ(x) and x0 in Eq.(9) and Eq.(12),\nφ(x0) = √\nn 2πx0(n− x0)\n( n(1−qn−x0)\nx0\n)x0(nrqn−x0 n− x0 )n−x0 = √ α2\n2π(α−1)n\n( κ(x0)\nα−1 α\n) α−1 α n (\nrqn−x0 1 α\n) n α\n.\nBy Lemma 1,\nφ(x0)=\n√ α2\n2π(α−1)n\n( 1+\nc21 2α(α−1)n\n+O (\n1 n2\n)) α−1 α n((\n1− c2− c1 n− c1\n)( 1− c 2 1\n2αn +O ( 1 n2 ))) n α .\nThen Eq.(26), the above equation can be further simplified as follows:\nφ(x0) =\n√ α2\n2π(α−1)n\n( e c21 2α2 +O ( 1 n ))( e− c21 2α2 + c1−c2 α +O ( 1 n ))\n= αe c1−c2 α√\n2π(α−1)n +O(n− 3 2 ).\nLemma 6 Let ∆ = c0 √ n lnn as defined in Eq.(15), where c0 is defined in Eq.(14). Then\nlim n→∞ (∫ x0−∆ 1 φ(x)dx+ ∫ n−1 x0+∆ φ(x)dx ) = 0,\nand\nlim n→∞\n( bx0−∆c\n∑ k=1\nφ(k)+ n−1\n∑ k=bx0+∆c φ(k)\n) = 0.\nProof By the definition of ψ(x), we have\nφ(x) = φ(x0)eψ(x).\nBy Lemma 2 and Lemma 3, for all x ∈ [1,n−1],\nψ ′′(x)< 2lnq =−2c1 n +O( 1 n2 ).\nThen the Taylor series for ψ at x ∈ [1,n−1] is\nψ(x)≤ ψ(x0)+(x− x0)ψ ′(x0)+ 1 2 (x− x0)2 max(ψ ′′(x)).\nAs x < n, so\nψ(x)≤−c1 n (x− x0)2 +O(1).\nWe note that the function − c1n (x− x0) 2 is an upper bound for ψ(x), which is strictly increasing when x < x0 and strictly decreasing when x > x0. Thus,∫ x0−∆ 1 φ(x)dx+ ∫ n−1 x0+∆ φ(x)dx≤ ∫ x0−∆ 1 φ(x0−∆)dx+ ∫ n−1 x0+∆ φ(x0 +∆)dx\n≤ φ(x0)ne− lnn+O(1) = O(φ(x0)).\nBy Lemma 5,\nφ(x0) = αe c1−c2 α√\n2π(α−1)n +O\n( n− 3 2 ) = O ( 1√ n ) .\nSo,\nlim n→∞ (∫ x0−∆ 1 φ(x)dx+ ∫ n−1 x0+∆ φ(x)dx ) ≤ 0.\nFrom φ(x)≥ 0, it follows that\nlim n→∞ (∫ x0−∆ 1 φ(x)dx+ ∫ n−1 x0+∆ φ(x)dx ) = 0.\nThus,\nlim n→∞\n( bx0−∆c\n∑ k=1\nφ(k)+ n−1\n∑ k=bx0+∆c φ(k)\n) = 0.\nThe next lemma is a basic property of integral. We present it here for reader’s reference.\nLemma 7 Let the function φ be defined as in Eq.(9). Then\nlim n→∞\nn−1 ∑ k=1 φ(k) = lim n→∞ ∫ n 1 φ(x)dx. (47)\nProof By Lemma 3, ψ ′′(x) < 0 when x ∈ [1,n− 1]. We know that ψ(x) is a concave function in the range. Also, by Lemma 2, ψ ′(1) > 0 and ψ ′(n− 1) < 0, which mean there exists a unique x̂ ∈ (1,n−1) such that ψ(x) reaches its apex at x̂. As φ(x) = φ(x0)eψ(x) and it is a concave function, φ(x) is strictly increasing for x ∈ (1, x̂) and strictly decreasing for x ∈ (x̂,n−1).\nTo compare the difference between the integral and the sum of the discrete values, we use Figure 9 as an example. The curve reaches its maximum at x̂ which is larger than 3 and smaller than 4. Clearly, from Figure 9(a), it is difficult to compare the integral and the sum of the discrete values. However, if we remove the tallest bar, which is φ(3) and shift all the bars right of it leftward one step, then clearly (as shown in Figure 9(b)) the sum of the discrete values is smaller than the integral of the curve. If we insert the bar of φ(x̂) at the left of the bar of the smallest number which is larger than x̂, (in this example it is 4), and shift all the bars left of it leftward one step (as shown in Figure 9(c)), then the total of the discrete values is larger than the integral of the curve. Therefore we have:\nn−1 ∑ k=1\nφ(k)+φ(x̂)> ∫ n\n1 φ(x)dx >\nn−1 ∑ k=1 φ(k)−φ(x̂).\nBy Lemma 5, we know that\nφ(x0) = αe c1−c2 α√\n2π(α−1)n +O\n( n− 3 2 ) = O ( 1√ n ) .\nAlso, from the proof of Lemma 6, we can see that, for x ∈ [1,n− 1], φ(x) = φ(x0)eψ(x) and ψ(x)≤−c1(x−x0)2/n+O(1). So, φ(x) =O(φ(x0)), which implies φ(x̂) =O(n− 1 2 ). That means lim n→∞ φ(x̂) = 0. Therefore,\nlim n→∞\nn−1 ∑ k=1 φ(k) = lim n→∞ ∫ n 1 φ(x)dx.\nLemma 8\nlim n→∞ (∫ x0−∆ −∞ χ(x)dx+ ∫ ∞ x0+∆ χ(x)dx ) = 0. (48)\nProof Note that ∫ x0−∆\n−∞ χ(x)dx+ ∫ ∞ x0+∆ χ(x)dx = 2 ∫ ∞ x0+∆ χ(x)dx\n= 2φ(x0) ∫ ∞\n∆ e−\nx2\n2σ2 dx.\nLet x = √\n2σt, then ∫ ∞ ∆ e− x2 2σ2 dx = √ 2σ ∫ ∞\n∆√ 2σ\ne−t 2 dt = √ 2πσ 2 erfc( ∆√ 2σ ),\nwhere erfc is the complementary error function. Then\nlim n→∞ (∫ x0−∆ −∞ χ(x)dx+ ∫ ∞ x0+∆ χ(x)dx ) = lim n→∞ √ 2πσφ(x0)erfc( ∆√ 2σ ).\nBy Eq.(13) and Lemma 5, we know that\nσφ(x0) = O(1).\nAnd then by Eq.(15), we have ∆√ 2σ = O (√ lnn ) → ∞. From Eq.29 (the property of complementary error function), it follows that\nlim z→∞ erfc(z) = 0.\nThus,\nlim n→∞ (∫ x0−∆ −∞ χ(x)dx+ ∫ ∞ x0+∆ χ(x)dx ) = 0.\nLemma 9\nlim n→∞ ∫ x0+∆ x0−∆ |φ(x)−χ(x)|dx = 0. (49)\nProof From the definitions of φ(x) and χ(x) in Eq.(9) and Eq.(11),∫ x0+∆\nx0−∆ |φ(x)−χ(x)|dx = φ(x0) ∫ x0+∆ x0−∆ |eψ(x)− eξ (x)|dx\n= φ(x0) ∫ x0+∆\nx0−∆ eξ (x)|eψ(x)−ξ (x)−1|dx,\nwhere\nξ (x) =− (x− x0) 2\n2σ2 .\nNote that eξ (x) ≤ 1 and when |δ | is small enough,\n|eδ −1| ≤ 2|δ |.\nIf we can show that ψ(x)−ξ (x)→ 0 when x ∈ [x0−∆,x0 +∆], then∫ x0+∆ x0−∆ |φ(x)−χ(x)|dx≤ 2φ(x0) ∫ x0+∆ x0−∆ |ψ(x)−ξ (x)|dx. (50)\nFrom the definition of ξ (x), it follows that\nξ (x0) = ξ ′(x0) = 0,\nξ ′′(x0) =− 1\nσ2 ,\nand ξ (i)(x0) = 0, for i > 2. From the definition of ψ(x) in Eq.(30),\nψ(x0) = 0.\nBy Lemma 2, Lemma 3 and Lemma 4, ψ ′(x0) = O (\n1 n\n) ,\nψ ′′(x0) =− 1\nσ2 +O ( 1 n2 ) ,\nψ(i)(x0) = O ( n−(i−1) ) , for i > 2.\nBased on the Taylor series for the function ψ(x)−ξ (x),\n|ψ(x)−ξ (x)| ≤ ∞\n∑ i=0 ∣∣∣∣∣ψ(i)(x0)−ξ (i)(x0)i! (x− x0)i ∣∣∣∣∣ .\nAs x ∈ [x0−∆,x0 +∆],\n|x− x0| ≤ O (√ n lnn ) .\nThus,\n|ψ(x)−ξ (x)| ≤ O (√ lnn n ) → 0,\nwhich indicates Eq(50) holds. By Eq(50), we have∫ x0+∆ x0−∆ |φ(x)−χ(x)|dx≤ O(2φ(x0)) ∫ x0+∆ x0−∆ |ψ(x)−ξ (x)|dx\n≤ O (\n1√ n\n) ×O (√ n lnn ) ×O (√ lnn n )\n= O (\nlnn√ n\n) → 0."
    } ],
    "references" : [ {
      "title" : "Random constraint satisfaction: A more accurate picture",
      "author" : [ "D. ACHLIOPTAS", "L. KIROUSIS", "E. KRANAKIS", "D. KRIZANC", "M. MOLLOY", "Y. STAMATIOU" ],
      "venue" : "Proceedings of the 3rd International Conference on Principles and Practice of Constraint Programming (CP-97). 107–120.",
      "citeRegEx" : "ACHLIOPTAS et al\\.,? 1997",
      "shortCiteRegEx" : "ACHLIOPTAS et al\\.",
      "year" : 1997
    }, {
      "title" : "Rigorous location of phase transitions in hard optimization problems",
      "author" : [ "D. ACHLIOPTAS", "A. NAOR", "Y. PERES" ],
      "venue" : "Nature 435, 7043, 759764.",
      "citeRegEx" : "ACHLIOPTAS et al\\.,? 2005",
      "shortCiteRegEx" : "ACHLIOPTAS et al\\.",
      "year" : 2005
    }, {
      "title" : "Probabilistic reasoning with answer sets",
      "author" : [ "C. BARAL", "M. GELFOND", "N. RUSHTON" ],
      "venue" : "Theory and Practice of Logic Programming 9, 1, 57–144.",
      "citeRegEx" : "BARAL et al\\.,? 2009",
      "shortCiteRegEx" : "BARAL et al\\.",
      "year" : 2009
    }, {
      "title" : "Continuous models of computation for logic programs: importing continuous mathematics into logic programming’s algorithmic foundations",
      "author" : [ "H. BLAIR", "F. DUSHIN", "D. JAKEL", "D. RIVERA", "M. SEZGIN" ],
      "venue" : "The Logic Programming Paradigm. 231–255.",
      "citeRegEx" : "BLAIR et al\\.,? 1999",
      "shortCiteRegEx" : "BLAIR et al\\.",
      "year" : 1999
    }, {
      "title" : "Semantics of disjunctive logic programs based on partial evaluation",
      "author" : [ "S. BRASS", "J. DIX" ],
      "venue" : "Journal of Logic Programming 38, 3, 167–312.",
      "citeRegEx" : "BRASS and DIX,? 1999",
      "shortCiteRegEx" : "BRASS and DIX",
      "year" : 1999
    }, {
      "title" : "Where the really hard problems are",
      "author" : [ "P. CHEESEMAN", "B. KANEFSKY", "W.M. TAYLOR" ],
      "venue" : "Proceedings of the 12th International Joint Conference on Artificial Intelligence (IJCAI-91). 331–340.",
      "citeRegEx" : "CHEESEMAN et al\\.,? 1991",
      "shortCiteRegEx" : "CHEESEMAN et al\\.",
      "year" : 1991
    }, {
      "title" : "The conflict-driven answer set solver clasp: Progress report",
      "author" : [ "M. GEBSER", "B. KAUFMANN", "T. SCHAUB" ],
      "venue" : "Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-09). 509–514.",
      "citeRegEx" : "GEBSER et al\\.,? 2009",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2009
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "Proceedings of the 5th International Conference on Logic Programming (ICLP-88). 1070–1080.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1990",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1990
    }, {
      "title" : "Logic programs with classical negation",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "Proceedings of the 7th International Conference on Logic Programming (ICLP-90). 579–597.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1988",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1988
    }, {
      "title" : "The sat phase transition",
      "author" : [ "I. GENT", "T. WALSH" ],
      "venue" : "Proceedings of the Eleventh European Conference on Artificial Intelligence (ECAI-94). 105–109.",
      "citeRegEx" : "GENT and WALSH,? 1994",
      "shortCiteRegEx" : "GENT and WALSH",
      "year" : 1994
    }, {
      "title" : "Two-literal logic programs and satisfiability representation of stable models: A comparison",
      "author" : [ "HUANG G.", "JIA X.", "C.", "YOU", "J." ],
      "venue" : "Proceedings 15th Canadian Conference on Artificial Intelligence. 119–131.",
      "citeRegEx" : "G. et al\\.,? 2002",
      "shortCiteRegEx" : "G. et al\\.",
      "year" : 2002
    }, {
      "title" : "Phase transitions in artificial intelligence systems",
      "author" : [ "B. HUBERMAN", "T. HOGG" ],
      "venue" : "Artificial Intelligence 33, 2, 155–171.",
      "citeRegEx" : "HUBERMAN and HOGG,? 1987",
      "shortCiteRegEx" : "HUBERMAN and HOGG",
      "year" : 1987
    }, {
      "title" : "Some (in)translatability results for normal logic programs and propositional theories",
      "author" : [ "T. JANHUNEN" ],
      "venue" : "Journal of Applied Non-Classical Logics , 1-2, 35–86.",
      "citeRegEx" : "JANHUNEN,? 2006",
      "shortCiteRegEx" : "JANHUNEN",
      "year" : 2006
    }, {
      "title" : "The dlv system for knowledge representation and reasoning",
      "author" : [ "N. LEONE", "G. PFEIFER", "W. FABER", "T. EITER", "G. GOTTLOB", "S. PERRI", "F. SCARCELLO" ],
      "venue" : "ACM Transactions on Computational Logic 7, 3, 499–562.",
      "citeRegEx" : "LEONE et al\\.,? 2006",
      "shortCiteRegEx" : "LEONE et al\\.",
      "year" : 2006
    }, {
      "title" : "Computing stable models: worst-Case performance estimates",
      "author" : [ "Z. LONC", "M. TRUSZCZYNSKI" ],
      "venue" : "Theory and Practice of Logic Programming 4, 1-2, 193–231.",
      "citeRegEx" : "LONC and TRUSZCZYNSKI,? 2004",
      "shortCiteRegEx" : "LONC and TRUSZCZYNSKI",
      "year" : 2004
    }, {
      "title" : "Autoepistemic logic",
      "author" : [ "V. MAREK", "M. TRUSZCZYNSKI" ],
      "venue" : "Journal of the Association for Computing Machinery 38, 3, 588–619.",
      "citeRegEx" : "MAREK and TRUSZCZYNSKI,? 1991",
      "shortCiteRegEx" : "MAREK and TRUSZCZYNSKI",
      "year" : 1991
    }, {
      "title" : "Nonmonotonic Logic: Context-Dependent Reasonong",
      "author" : [ "V. MAREK", "M. TRUSZCZYNSKI" ],
      "venue" : "Springer, 1993.",
      "citeRegEx" : "MAREK and TRUSZCZYNSKI,? 1993",
      "shortCiteRegEx" : "MAREK and TRUSZCZYNSKI",
      "year" : 1993
    }, {
      "title" : "Hard and easy distributions of sat problems",
      "author" : [ "D. MITCHELL", "B. SELMAN", "H. LEVESQUE" ],
      "venue" : "Proceedings of the 10th National Conference on Artificial Intelligence (AAAI-92). 459–465.",
      "citeRegEx" : "MITCHELL et al\\.,? 1992",
      "shortCiteRegEx" : "MITCHELL et al\\.",
      "year" : 1992
    }, {
      "title" : "2+psat: Relation of typical-case complexity to the nature of the phase transition",
      "author" : [ "R. MONASSON", "R. ZECCHINA", "S. KIRKPATRICK", "B. SELMAN", "L. TROYANSKY" ],
      "venue" : "Random Structures and Algorithms 15, 3-4, 414–435.",
      "citeRegEx" : "MONASSON et al\\.,? 1999",
      "shortCiteRegEx" : "MONASSON et al\\.",
      "year" : 1999
    }, {
      "title" : "Study of random logic programs",
      "author" : [ "G. NAMASIVAYAM" ],
      "venue" : "Proceedings of the 25th International Conference on Logic Programming (ICLP-09). 555–556.",
      "citeRegEx" : "NAMASIVAYAM,? 2009",
      "shortCiteRegEx" : "NAMASIVAYAM",
      "year" : 2009
    }, {
      "title" : "Simple random logic programs",
      "author" : [ "G. NAMASIVAYAM", "M. TRUSZCZYNSKI" ],
      "venue" : "Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-09). 223–235.",
      "citeRegEx" : "NAMASIVAYAM and TRUSZCZYNSKI,? 2009",
      "shortCiteRegEx" : "NAMASIVAYAM and TRUSZCZYNSKI",
      "year" : 2009
    }, {
      "title" : "On the distribution of programs with stable models",
      "author" : [ "J. SCHLIPF", "M. TRUSZCZYNSKI", "D. WONG" ],
      "venue" : "05171 Abstracts Collection - Nonmonotonic Reasoning, Answer Set Prorgamming and Constraints.",
      "citeRegEx" : "SCHLIPF et al\\.,? 2005",
      "shortCiteRegEx" : "SCHLIPF et al\\.",
      "year" : 2005
    }, {
      "title" : "Handbook on Ontologies",
      "author" : [ "S. STAAB", "R. STUDER" ],
      "venue" : "Springer-Verlag, 2004.",
      "citeRegEx" : "STAAB and STUDER,? 2004",
      "shortCiteRegEx" : "STAAB and STUDER",
      "year" : 2004
    }, {
      "title" : "The smodels system",
      "author" : [ "T. SYRJÄNEN", "I. NIEMELÄ" ],
      "venue" : "Proceedings of the 6th International ConferenceLogic Logic Programming and Nonmonotonic Reasoning (LPNMR-01). 434–438.",
      "citeRegEx" : "SYRJÄNEN and NIEMELÄ,? 2001",
      "shortCiteRegEx" : "SYRJÄNEN and NIEMELÄ",
      "year" : 2001
    }, {
      "title" : "Comparisons and computation of well-founded semantics for disjunctive logic programs",
      "author" : [ "K. WANG", "L. ZHOU" ],
      "venue" : "ACM Transactions on Computational Logic 6, 2, 295–327.",
      "citeRegEx" : "WANG and ZHOU,? 2005",
      "shortCiteRegEx" : "WANG and ZHOU",
      "year" : 2005
    }, {
      "title" : "Answer set programming phase transition: A study on randomly generated programs",
      "author" : [ "Y. ZHAO", "F. LIN" ],
      "venue" : "Proceedings of the 19th International Conference on Logic Programming (ICLP-03). 239– 253.",
      "citeRegEx" : "ZHAO and LIN,? 2003",
      "shortCiteRegEx" : "ZHAO and LIN",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).",
      "startOffset" : 115,
      "endOffset" : 275
    }, {
      "referenceID" : 1,
      "context" : "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).",
      "startOffset" : 115,
      "endOffset" : 275
    }, {
      "referenceID" : 5,
      "context" : "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).",
      "startOffset" : 115,
      "endOffset" : 275
    }, {
      "referenceID" : 9,
      "context" : "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).",
      "startOffset" : 115,
      "endOffset" : 275
    }, {
      "referenceID" : 11,
      "context" : "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).",
      "startOffset" : 115,
      "endOffset" : 275
    }, {
      "referenceID" : 17,
      "context" : "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).",
      "startOffset" : 115,
      "endOffset" : 275
    }, {
      "referenceID" : 18,
      "context" : "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).",
      "startOffset" : 115,
      "endOffset" : 275
    }, {
      "referenceID" : 6,
      "context" : "Answer set programming (ASP) is currently one of the most widely used nonmonotonic reasoning systems due to its simple syntax, precise semantics and importantly, the availability of ASP solvers, such as clasp (Gebser et al. 2009), dlv (Leone et al.",
      "startOffset" : 209,
      "endOffset" : 229
    }, {
      "referenceID" : 13,
      "context" : "2009), dlv (Leone et al. 2006), and smodels (Syrjänen and Niemelä 2001).",
      "startOffset" : 11,
      "endOffset" : 30
    }, {
      "referenceID" : 20,
      "context" : "However, the theoretical study of random ASP has not made much progress so far (Namasivayam and Truszczynski 2009; Namasivayam 2009; Schlipf et al. 2005; Zhao and Lin 2003).",
      "startOffset" : 79,
      "endOffset" : 172
    }, {
      "referenceID" : 19,
      "context" : "However, the theoretical study of random ASP has not made much progress so far (Namasivayam and Truszczynski 2009; Namasivayam 2009; Schlipf et al. 2005; Zhao and Lin 2003).",
      "startOffset" : 79,
      "endOffset" : 172
    }, {
      "referenceID" : 21,
      "context" : "However, the theoretical study of random ASP has not made much progress so far (Namasivayam and Truszczynski 2009; Namasivayam 2009; Schlipf et al. 2005; Zhao and Lin 2003).",
      "startOffset" : 79,
      "endOffset" : 172
    }, {
      "referenceID" : 25,
      "context" : "However, the theoretical study of random ASP has not made much progress so far (Namasivayam and Truszczynski 2009; Namasivayam 2009; Schlipf et al. 2005; Zhao and Lin 2003).",
      "startOffset" : 79,
      "endOffset" : 172
    }, {
      "referenceID" : 25,
      "context" : "(Zhao and Lin 2003) first conducted an experimental study on the issue of phase transition for randomly generated ASP programs whose rules can have three or more literals.",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 20,
      "context" : "To study statistical properties for random programs, (Namasivayam and Truszczynski 2009; Namasivayam 2009) considered the class of randomly generated ASP programs in which each rule has exactly two literals, called simple random programs.",
      "startOffset" : 53,
      "endOffset" : 106
    }, {
      "referenceID" : 19,
      "context" : "To study statistical properties for random programs, (Namasivayam and Truszczynski 2009; Namasivayam 2009) considered the class of randomly generated ASP programs in which each rule has exactly two literals, called simple random programs.",
      "startOffset" : 53,
      "endOffset" : 106
    }, {
      "referenceID" : 15,
      "context" : "In fact, the class of negative two-literal programs is used to show the NP-hardness of answer set semantics for normal logic programs in (Marek and Truszczynski 1991) (Theorem 6.",
      "startOffset" : 137,
      "endOffset" : 166
    }, {
      "referenceID" : 2,
      "context" : "For instance, it is important to compute all answer sets of a program in applications, such as diagnoses and query answering, in P-log (Baral et al. 2009).",
      "startOffset" : 135,
      "endOffset" : 154
    }, {
      "referenceID" : 22,
      "context" : "Also, the linear model of random programs may be useful in application domains such as ontology engineering where most of large practical ontologies are sparse in the sense that the ratio of terminological axioms to concepts/roles is relatively small (Staab and Studer 2004).",
      "startOffset" : 251,
      "endOffset" : 274
    }, {
      "referenceID" : 20,
      "context" : "(Namasivayam and Truszczynski 2009) discusses some program classes of two-literal programs that may not be negative.",
      "startOffset" : 0,
      "endOffset" : 35
    }, {
      "referenceID" : 8,
      "context" : "The semantics of a logic program P is defined in terms of its answer sets (or equivalently, stable models) (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1990) as follows.",
      "startOffset" : 107,
      "endOffset" : 163
    }, {
      "referenceID" : 7,
      "context" : "The semantics of a logic program P is defined in terms of its answer sets (or equivalently, stable models) (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1990) as follows.",
      "startOffset" : 107,
      "endOffset" : 163
    }, {
      "referenceID" : 12,
      "context" : "We note that our definition is slightly different from some other authors, such as (Janhunen 2006; Lonc and Truszczynski 2002), in that fact rules are not allowed in our definition.",
      "startOffset" : 83,
      "endOffset" : 126
    }, {
      "referenceID" : 15,
      "context" : "It is shown in (Marek and Truszczynski 1991) that the problem of deciding the existence of answer sets for a negative two-literal program is NP-complete.",
      "startOffset" : 15,
      "endOffset" : 44
    }, {
      "referenceID" : 3,
      "context" : "This result is mentioned in (Blair et al. 1999) but no proof is provided there.",
      "startOffset" : 28,
      "endOffset" : 47
    }, {
      "referenceID" : 16,
      "context" : "8 in (Marek and Truszczynski 1993).",
      "startOffset" : 5,
      "endOffset" : 34
    }, {
      "referenceID" : 6,
      "context" : "The experimental results in this section were based on the ASP solver clasp (Gebser et al. 2009), but same patterns were obtained for test cases on which dlv (Leone et al.",
      "startOffset" : 76,
      "endOffset" : 96
    }, {
      "referenceID" : 13,
      "context" : "2009), but same patterns were obtained for test cases on which dlv (Leone et al. 2006) and smodels (Syrjänen and Niemelä 2001) were also used.",
      "startOffset" : 67,
      "endOffset" : 86
    }, {
      "referenceID" : 12,
      "context" : "programs that are more general than negative two-literal programs, such as the program classes discussed in (Janhunen 2006; Lonc and Truszczynski 2002).",
      "startOffset" : 108,
      "endOffset" : 151
    }, {
      "referenceID" : 4,
      "context" : "Proof First, it has been proven that each normal logic program is equivalent to a negative logic program under answer set semantics (Brass and Dix 1999; Wang and Zhou 2005).",
      "startOffset" : 132,
      "endOffset" : 172
    }, {
      "referenceID" : 24,
      "context" : "Proof First, it has been proven that each normal logic program is equivalent to a negative logic program under answer set semantics (Brass and Dix 1999; Wang and Zhou 2005).",
      "startOffset" : 132,
      "endOffset" : 172
    } ],
    "year" : 2014,
    "abstractText" : "This paper proposes a model, the linear model, for randomly generating logic programs with low density of rules and investigates statistical properties of such random logic programs. It is mathematically shown that the average number of answer sets for a random program converges to a constant when the number of atoms approaches infinity. Several experimental results are also reported, which justify the suitability of the linear model. It is also experimentally shown that, under this model, the size distribution of answer sets for random programs tends to a normal distribution when the number of atoms is sufficiently large.",
    "creator" : "LaTeX with hyperref package"
  }
}